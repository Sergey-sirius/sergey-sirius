---
layout: post
title: Глава 32. JIT-компиляция
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 32. JIT-компиляция

В этой главе рассказывается о том, что такое JIT-компиляция, и как можно настроить её в
PostgreSQL.
32.1. Что такое JIT-компиляция?
JIT-компиляция (Just-In-Time compilation, Компиляция «точно в срок») — это производимая во вре-
мя выполнения процедура преобразования интерпретируемого варианта исполнения программы
в программу на языке процессора. Например, вместо использования универсального кода, способ-
ного вычислять произвольные SQL-выражения, для вычисления конкретного условия WHERE a.col
= 3 можно сгенерировать функцию, предназначенную именно для этого выражения, которую смо-
жет выполнять непосредственно процессор, так что она будет выполняться быстрее.
PostgreSQL поддерживает JIT-компиляцию с использованием LLVM, если сборка PostgreSQL про-
изводится с ключом --with-llvm.
Дополнительные подробности можно найти в файле src/backend/jit/README.
32.1.1. Операции, ускоряемые с применением JIT
В настоящее время реализация JIT в PostgreSQL поддерживает ускорение вычисления выражений
и преобразования кортежей. В будущем могут быть ускорены и некоторые другие операции.
Вычисление выражений производится при обработке предложений WHERE, целевых списков, агре-
гатов и проекций. Оно может быть ускорено в результате генерирования кода, предназначенного
для каждого конкретного случая.
Преобразование кортежей — процедура перевода кортежа с диска (см. Подраздел 68.6.1) в развёр-
нутое представление в памяти. Его можно ускорить, создав функции, предназначенные для опре-
делённой структуры таблицы и количества извлекаемых столбцов.
32.1.2. Встраивание
СУБД PostgreSQL очень гибка и позволяет определять новые типы данных, функции, операторы и
другие объекты базы данных; см. Главу 38. В действительности встроенные объекты реализуются
практически теми же механизмами. С этой гибкостью связаны некоторые издержки, например,
сопутствующие вызовам функций (см. Раздел 38.3). Для сокращения этих издержек JIT-компиля-
ция может встраивать тела маленьких функций в код выражений, использующих их. Это позволяет
соптимизировать значительный процент подобных издержек.
32.1.3. Оптимизация
В LLVM поддерживается оптимизация сгенерированного кода. Некоторые оптимизации обходятся
достаточно дёшево и могут выполняться при использовании JIT в любом случае, тогда как другие
оправданы только при длительных запросах. Подробнее об оптимизации рассказывается в https://
llvm.org/docs/Passes.html#transform-passes.
32.2. Когда применять JIT?
JIT-компиляция имеет смысл в первую очередь для длительных запросов, нагружающих процессор.
Например, такой характер обычно имеют аналитические запросы. Для быстрых запросов наклад-
ные расходы, связанные с выполнением JIT-компиляции, часто будут превышать выигрыш от их
ускорения.
Решение об использовании JIT-компиляции принимается на основании общей стоимости запроса
(см. Главу 70 и Подраздел 19.7.2). Стоимость запроса сравнивается со значением jit_above_cost,
и если она оказывается больше, производится JIT-компиляция. Затем принимаются ещё два реше-
742JIT-компиляция
ния. Во-первых, если его стоимость превышает и значение jit_inline_above_cost, тела небольших
функций и операторов, фигурирующих в запросе, будут встраиваться в вызывающий код. Во-вто-
рых, если стоимость запроса превышает значение jit_optimize_above_cost, при генерации кода за-
действуются дорогостоящие оптимизации для улучшения сгенерированного кода. Обе эти опера-
ции увеличивают накладные расходы JIT, но могут значительно сократить время выполнения за-
проса.
Эти решения принимаются на основе стоимости во время планирования, а не исполнения запроса.
Это означает, что в случае использования подготовленных операторов и общего плана (см. Раздел
«Замечания») принятие решений зависит от параметров конфигурации, действующих во время
подготовки запроса, а не во время выполнения.
Примечание
Если параметр jit имеет значение off или сервер не поддерживает JIT (например, по-
тому что он был скомпилирован без --with-llvm), JIT-компиляция выполняться не бу-
дет, даже если она была бы выгодна, исходя из описанных выше критериев. Присво-
енное параметру jit значение off учитывается и во время планирования, и во время
выполнения запросов.
EXPLAIN позволяет определить, используется ли JIT-компиляция. Например, так выглядит запрос,
не использующий JIT:
=# EXPLAIN ANALYZE SELECT SUM(relpages) FROM pg_class;
QUERY PLAN
--------------------------------------------------------------------------------------------
Aggregate (cost=16.27..16.29 rows=1 width=8) (actual time=0.303..0.303 rows=1
loops=1)
-> Seq Scan on pg_class (cost=0.00..15.42 rows=342 width=4) (actual
time=0.017..0.111 rows=356 loops=1)
Planning Time: 0.116 ms
Execution Time: 0.365 ms
(4 rows)
Учитывая стоимость планирования, отказ от использования JIT вполне обоснован, так как стои-
мость JIT-компиляции оказалась бы больше, чем выигрыш от оптимизации. Если уменьшить огра-
ничение стоимости, JIT будет использоваться:
=# SET jit_above_cost = 10;
SET
=# EXPLAIN ANALYZE SELECT SUM(relpages) FROM pg_class;
QUERY PLAN
--------------------------------------------------------------------------------------------
Aggregate (cost=16.27..16.29 rows=1 width=8) (actual time=6.049..6.049 rows=1
loops=1)
-> Seq Scan on pg_class (cost=0.00..15.42 rows=342 width=4) (actual
time=0.019..0.052 rows=356 loops=1)
Planning Time: 0.133 ms
JIT:
Functions: 3
Options: Inlining false, Optimization false, Expressions true, Deforming true
Timing: Generation 1.259 ms, Inlining 0.000 ms, Optimization 0.797 ms, Emission
5.048 ms, Total 7.104 ms
Execution Time: 7.416 ms
В данном случае видно, что JIT используется, но встраивание (Inlining) и дорогостоящие оптими-
зации (Optimization) не выполнялись. Чтобы их включить, помимо jit_above_cost нужно было также
уменьшить jit_inline_above_cost и jit_optimize_above_cost.
743JIT-компиляция
32.3. Конфигурация
Переменная конфигурации jit определяет, возможно ли использование JIT-компиляции. Если она
включена, переменные jit_above_cost, jit_inline_above_cost и jit_optimize_above_cost определяют, бу-
дет ли выполняться JIT-компиляция для запросов, и насколько ресурсоёмкой она может быть.
Параметр jit_provider определяет, какая реализация JIT-компиляции должна использоваться. Из-
менять его может потребоваться лишь в редких случаях. См. Подраздел 32.4.2.
Для целей отладки и разработки предназначен ряд дополнительных параметров конфигурации,
описанных в Разделе 19.17.
32.4. Расширяемость
32.4.1. Поддержка встраивания кода для расширений
Механизм JIT в PostgreSQL может встраивать в код реализации функций (типа C и internal), а
также операторов, использующих эти функции. Чтобы это встраивание выполнялось для функций
в расширениях, должно быть доступно определение этих функций. При сборке с использованием
PGXS расширения для сервера, скомпилированного с JIT-поддержкой LLVM, соответствующие фай-
лы будут собираться и устанавливаться автоматически.
Соответствующие файлы должны устанавливаться в $pkglibdir/bitcode/$extension/, а информа-
ция о них должна вноситься в $pkglibdir/bitcode/$extension.index.bc, где $pkglibdir — ката-
лог, который выдаёт команда pg_config --pkglibdir, а $extension — базовое имя разделяемой
библиотеки данного расширения.
Примечание
Для функций, встроенных в PostgreSQL, двоичный код устанавливается в $pkglibdir/
bitcode/postgres.
32.4.2. Подключаемые провайдеры JIT
PostgreSQL предоставляет реализацию JIT на базе LLVM. Интерфейс JIT предусматривает динами-
ческое подключение провайдера и позволяет менять провайдер без перекомпиляции (хотя в на-
стоящее время при сборке предоставляется поддержка встраивания только для LLVM). Провайдер
выбирается параметром jit_provider.
32.4.2.1. Интерфейс провайдера JIT
Провайдер JIT загружается путём динамической загрузки заданной разделяемой библиотеки. Для
поиска её используется обычный путь поиска библиотек. Чтобы предоставить требуемые функ-
ции-обработчики провайдера JIT и показать, что библиотека является реализацией провайдера JIT,
она должна содержать функцию, имеющую в C имя _PG_jit_provider_init. Этой функции пере-
даётся структура, которую нужно заполнить указателями на функции-обработчики определённых
действий.
struct JitProviderCallbacks
{
JitProviderResetAfterErrorCB reset_after_error;
JitProviderReleaseContextCB release_context;
JitProviderCompileExprCB compile_expr;
};
extern void _PG_jit_provider_init(JitProviderCallbacks *cb);
744
