---
layout: page
title: Глава 51. Обзор внутреннего устройства PostgreSQL
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Часть VII. Внутреннее устройство

Содержит разнообразную информацию, полезную для разработчиков PostgreSQL.

Глава 51. Обзор внутреннего устройства PostgreSQL

Автор

Основой этой главы послужил материал дипломной работы sim98, написанной Сте-
фаном Симковичем (Stefan Simkovics) в Венском техническом университете под руко-
водством профессора Георга Готлоба (Georg Gottlob) и его ассистентки Катрин Сейр
(Katrin Seyr).
В этой главе даётся обзор внутренней организации сервера PostgreSQL. Прочитав следующие раз-
делы, вы получите представление о том, как обрабатывается запрос. Здесь мы не стремились по-
дробно описывать внутренние операции PostgreSQL, так как это заняло бы слишком большой объ-
ём. Основная цель этой главы другая — помочь читателю понять общую последовательность дей-
ствий, выполняемых сервером с момента получения запроса до момента выдачи результатов кли-
енту.
51.1. Путь запроса
Ниже мы кратко опишем этапы, которые проходит запрос для получения результата.
1. Прикладная программа устанавливает подключение к серверу PostgreSQL. Эта программа пе-
редаёт запрос на сервер и ждёт от него результатов.
2. На этапе разбора запроса сервер выполняет синтаксическую проверку запроса, переданного
прикладной программой, и создаёт дерево запроса.
3. Система правил принимает дерево запроса, созданное на стадии разбора, и ищет в систем-
ных каталогах правила для применения к этому дереву. Обнаружив подходящие правила, она
выполняет преобразования, заданные в теле правил.
Одно из применений системы правил заключается в реализации представлений. Когда выпол-
няется запрос к представлению (т. е. виртуальной таблице), система правил преобразует за-
прос пользователя в запрос, обращающийся не к представлению, а к базовым таблицам из
определения представления.
4.
Планировщик/оптимизатор принимает дерево запроса (возможно, переписанное) и создаёт
план запроса, который будет передан исполнителю.
Он выбирает план, сначала рассматривая все возможные варианты получения одного и того же
результата. Например, если для обрабатываемого отношения создан индекс, прочитать отно-
шение можно двумя способами. Во-первых, можно выполнить простое последовательное ска-
нирование, а во-вторых, можно использовать индекс. Затем оценивается стоимость каждого
варианта и выбирается самый дешёвый. Затем выбранный вариант разворачивается в полно-
ценный план, который сможет использовать исполнитель.
5.
Исполнитель рекурсивно проходит по дереву плана и получает строки тем способом, который
указан в плане. Он сканирует отношения, обращаясь к системе хранения, выполняет сорти-
ровку и соединения, вычисляет условия фильтра и, наконец, возвращает полученные строки.
В следующих разделах мы более подробно рассмотрим каждый из этих этапов, чтобы дать пред-
ставление о внутренних механизмах и структурах данных PostgreSQL.
51.2. Как устанавливаются соединения
PostgreSQL реализует простую клиент-серверную модель по схеме «процесс для пользователя». В
такой схеме один клиентский процесс подключается к одному отдельному серверному процессу.
Так как мы не знаем заранее, сколько подключений будет, нам нужен главный процесс, который
1917Обзор внутреннего
устройства PostgreSQL
будет запускать новый процесс при каждом запросе подключения. Главный процесс называется
postgres и принимает входящие подключения в заданном порту TCP/IP. Получив запрос на под-
ключение, процесс postgres порождает новый серверный процесс. Серверные задачи взаимодей-
ствуют между собой через семафоры и разделяемую память, чтобы обеспечить целостность дан-
ных при одновременном обращении к ним.
Клиентским процессом может быть любая программа, которая понимает протокол PostgreSQL,
описанный в Главе 53. Многие клиенты базируются на библиотеке libpq для языка C, но есть и
другие независимые реализации этого протокола, например, драйвер JDBC для Java.
Установив подключение, клиентский процесс может передать запрос серверу. Запрос передаётся
в обычном текстовом виде, клиент не занимается его анализом. Сервер разбирает запрос, строит
план выполнения, выполняет его и возвращает полученные строки клиенту, передавая их через
установленное подключение.
51.3. Этап разбора
Этап разбора разделяется на две части:
• Разбор, алгоритм которого описан в gram.y и scan.l, а программный код генерируется ин-
струментами Unix bison и flex.
• Преобразование, в процессе которого модифицируются и дополняются структуры данных, по-
лученные после разбора запроса.
51.3.1. Разбор
При разборе проверяется сначала синтаксис строки запроса (поступающей в виде неструктуриро-
ванного текста). Если он правильный, строится дерево запроса и передаётся дальше, в противном
случае возвращается ошибка. Лексический и синтаксический анализ реализован с применением
хорошо известных средств Unix bison и flex.
Лексическая структура определяется в файле scan.l и описывает идентификаторы, ключевые
слова SQL и т. д. Для каждого найденного ключевого слова или идентификатора генерируется
символ языка, который затем передаётся синтаксическому анализатору.
Синтаксис языка определён в файле gram.y в виде набора грамматических правил и действий,
которые должны выполняться при срабатывании правил. Для построения дерева разбора исполь-
зуется код действий (это действительно код на C).
Файл scan.l преобразуется в программу на C scan.c с помощью flex, а gram.y — в gram.c с помо-
щью bison. После этих преобразований исполняемый код анализатора создаётся обычным компи-
лятором C. Никогда не вносите коррективы в сгенерированные файлы C, так как они будут пере-
записаны при следующем вызове flex или bison.
Примечание
Упомянутые преобразования и компиляция обычно производятся автоматически сбо-
рочными файлами Makefile, поставляемыми в составе дистрибутива PostgreSQL.
Подробное описание bison и грамматических правил в gram.y выходит за рамки данной главы.
Узнать больше о flex и bison можно из книг и документации. Изучение грамматики, описанной в
gram.y, следует начать со знакомства с bison, иначе будет трудно понять, что там происходит.
51.3.2. Преобразование
На этой стадии дерево разбора создаётся только с фиксированными знаниями о синтаксической
структуре SQL. При его создании не просматриваются системные каталоги, что не даёт возмож-
ность понять конкретную семантику запрошенной операции. После этого выполняется процедура
1918Обзор внутреннего
устройства PostgreSQL
преобразования, которая принимает дерево разбора от анализатора и выполняет семантический
анализ, необходимый для понимания, к каким именно таблицам, функциям и операторам обраща-
ется запрос. Структура данных, которая создаётся для представления этой информации, называ-
ется деревом запроса.
Синтаксический разбор отделён от семантического анализа, потому что обращаться к системным
каталогам можно только внутри транзакции, а начинать транзакцию сразу после получения стро-
ки с запросом нежелательно. Синтаксического разбора достаточно, чтобы распознать команды
управления транзакциями (BEGIN, ROLLBACK и т. д.), поэтому их можно выполнить без дальнейшего
анализа. Убедившись, что мы имеем дело с собственно запросом (например, SELECT или UPDATE),
можно начинать транзакцию, если она ещё не начата. Только после этого можно переходить к
процедуре преобразования.
Дерево запроса, создаваемое процедурой преобразования, по структуре во многом похоже на де-
рево разбора, но отличается во многих деталях. Например, узел FuncCall в дереве разбора пред-
ставляет то, что по синтаксису похоже на вызов функции. Этот узел может быть преобразован в
узел FuncExpr или Aggref в зависимости от того, какой (обычной или агрегатной) окажется функ-
ция с заданным именем. Кроме того, в дерево запроса добавляется информация о фактических
типах данных столбцов и результатов выражений.
51.4. Система правил PostgreSQL
PostgreSQL поддерживает мощную систему правил для создания представлений и возможности
изменения представлений. Система правил PostgreSQL претерпела две реализации:
• Первый вариант производил обработку на уровне строк и был внедрён глубоко в исполните-
ле. Этот обработчик правил вызывался при обращении к каждой отдельной строке. Эта реали-
зация была ликвидирована в 1995 г., когда последний официальный выпуск Berkeley Postgres
превратился в Postgres95.
• Во втором воплощении системы правил применили так называемое переписывание запроса.
Система переписывания реализована в механизме, внедрённом между анализатором и пла-
нировщиком/оптимизатором. Этот механизм работает и сегодня.
Механизм переписывания запросов подробно обсуждается в Главе  41, так что здесь мы его не
рассматриваем. Мы только отметим, что и на входе, и на выходе у него деревья запросов, то есть
представление или уровень семантической детализации он не меняет. Переписывание запроса
можно считать формой расширения макросов.
51.5. Планировщик/оптимизатор
Задача планировщика/оптимизатора — построить наилучший план выполнения. Определённый
SQL-запрос (а значит, и дерево запроса) на самом деле можно выполнить самыми разными спосо-
бами, при этом получая одни и те же результаты. Если это не требует больших вычислений, опти-
мизатор запросов будет перебирать все возможные варианты планов, чтобы в итоге выбрать тот,
который должен выполниться быстрее остальных.
Примечание
В некоторых ситуациях рассмотрение всех возможных вариантов выполнения запро-
сов занимает слишком много времени и памяти. В частности, это имеет место при вы-
полнении запросов с большим количеством операций соединения. Поэтому, чтобы вы-
брать разумный (но не обязательно наилучший) план запроса за приемлемое время,
PostgreSQL использует генетический оптимизатор запросов (см. Главу 60), когда ко-
личество соединений превышает некоторый предел (см. geqo_threshold).
Процедура поиска лучшего плана на самом деле работает со структурами данных, называемыми
путями, которые представляют собой упрощённые схемы планов, содержащие минимум инфор-
1919Обзор внутреннего
устройства PostgreSQL
мации, необходимый планировщику для принятия решений. Когда наиболее выгодный план вы-
бран, строится полноценное дерево плана, которое и передаётся исполнителю. Оно описывает же-
лаемый план выполнения достаточно подробно, чтобы исполнитель мог обработать его. В продол-
жении этого раздела мы будем считать, что планы и пути по сути одно и то же.
51.5.1. Выработка возможных планов
Сначала планировщик/оптимизатор вырабатывает планы для сканирования каждого отдельного
отношения (таблицы), используемого в запросе. Множество возможных планов определяется в за-
висимости от наличия индексов в каждом отношении. Произвести последовательное сканирова-
ние отношения можно в любом случае, так что план последовательного сканирования создаётся
всегда. Предположим, что для отношения создан индекс (например, индекс-B-дерево) и запрос со-
держит ограничение отношение.атрибут ОПЕР константа. Если окажется, что отношение.атрибут
совпадает с ключом индекса-B-дерева и ОПЕР — один из операторов, входящих в класс операторов
индекса, создаётся ещё один план, c использованием индекса-B-дерева для чтения отношения.
Если находятся другие индексы, ключи которых соответствуют ограничениям запроса, могут до-
бавиться и другие планы. Планы сканирования индекса также создаются для индексов, если их
порядок сортировки соответствует предложению ORDER BY (если оно есть), или этот порядок может
быть полезен для соединения слиянием (см. ниже).
Если в запросе требуется соединить два или несколько отношений, после того, как будут опреде-
лены все подходящие планы сканирования отдельных отношений, рассматриваются планы соеди-
нения. При этом возможны три стратегии соединения:
• соединение с вложенным циклом: Правое отношение сканируется один раз для каждой стро-
ки, найденной в левом отношении. Эту стратегию легко реализовать, но она может быть очень
трудоёмкой. (Однако, если правое отношение можно сканировать по индексу, эта стратегия
может быть удачной. Тогда значения из текущей строки левого отношения могут использо-
ваться как ключи для сканирования по индексу справа.)
• соединение слиянием: Каждое отношение сортируется по атрибутам соединения до начала
соединения. Затем два отношения сканируются параллельно и соответствующие строки, объ-
единяясь, формируют строки соединения. Этот тип соединения более привлекательный, так
как каждое отношение сканируется только один раз. Требуемый порядок сортировки можно
получить, либо добавив явный этап сортировки, либо просканировав отношение в нужном по-
рядке, используя индекс по ключу соединения.
• соединение по хешу: сначала сканируется правое отношение и формируется хеш-таблица,
ключ в которой вычисляется по атрибутам соединения. Затем сканируется левое отношение и
по тем же атрибутам в каждой строке вычисляется ключ для поиска в этой хеш-таблице соот-
ветствующих строк справа.
Когда в запросе задействованы более двух отношений, окончательный результат должен быть по-
лучен из дерева с узлами соединения, имеющими по два входа. Планировщик рассматривает все
возможные последовательности соединения и выбирает самую выгодную.
Если число задействованных в запросе отношений меньше geqo_threshold, для поиска оптималь-
ной последовательности соединений производится практически полный перебор. Планировщик
отдаёт предпочтение соединениям между двумя отношениями, для которых есть соответствующее
предложение соединения в условии WHERE (то есть, для которых находится ограничение вида where
табл1.атр1=табл2.атр2). Пары соединения без подобного предложения рассматриваются, только
если нет другого выбора, то есть когда для определённого отношения не находятся предложения
соединения с каким-либо другим отношением. Планировщик рассматривает все возможные планы
для каждой пары соединения и выбирает самый выгодный из них (по его оценке).
Если geqo_threshold превышается, последовательность соединений выбирается эвристическим
путём, как описано в Главе 60. В остальном процесс планирования тот же.
Законченное дерево плана содержит узлы сканирования по индексу или последовательного ска-
нирования базовых отношений, плюс узлы соединения с вложенным циклом, соединения слияни-
ем или соединения по хешу (если требуется), плюс, возможно, узлы дополнительных действий,
1920Обзор внутреннего
устройства PostgreSQL
например, сортировки или вычисления агрегатных функций. Большинство из этих узлов могут до-
полнительно производить отбор (отбрасывать строки, не удовлетворяющие заданному логическо-
му условию) и расчёты (вычислять производный набор столбцов по значениям заданных столбцов,
то есть вычислять скалярные выражения). Одна из задач планировщика — добавить условия отбо-
ра из предложения WHERE и вычисления требуемых выходных выражений к наиболее подходящим
узлам дерева плана.
51.6. Исполнитель
Исполнитель принимает план, созданный планировщиком/исполнителем и обрабатывает его ре-
курсивно, чтобы получить требуемый набор строк. Обработка выполняется по конвейеру, с полу-
чением данных по требованию. При вызове любого узла плана он должен выдать очередную стро-
ку, либо сообщить, что выдача строк завершена.
В качестве более конкретного примера, давайте предположим, что верхним узлом плана оказался
узел MergeJoin. Для того чтобы выполнить какое-либо соединение, необходимо выбрать две стро-
ки (одну из каждого вложенного плана). Поэтому исполнитель рекурсивно вызывает себя для об-
работки вложенных планов (он начинает с плана левого дерева). Новый верхний узел (верхний
узел левого вложенного плана) может быть, например, узлом Sort, и тогда для получения вход-
ной строки снова требуется рекурсия. Дочерним узлом Sort может быть узел SeqScan, представ-
ляющий собственно чтение таблицы. В результате выполнения этого узла исполнитель выбирает
одну строку из таблицы и возвращает её вызывающему узлу. Узел Sort, в свою очередь, будет
продолжать вызывать дочерний узел, пока не получит все строки для сортировки. Когда строки
закончатся (дочерний узел сообщит об этом, возвратив NULL вместо строки), узел Sort выполнит
сортировку, и наконец сможет выдать свою первую строку, а именно строку первую по порядку
сортировки. Остальные строки будут сохраняться в нём, чтобы он мог выдавать их по порядку при
последующих вызовах.
Узел MergeJoin подобным образом затребует первую строку и у вложенного плана справа. Затем он
сравнивает две строки и определяет, можно ли их соединить; если да, он возвращает соединённую
строки вызывающему узлу. При следующем вызове, или немедленно, если он не может соединить
текущую пару поступивших строк, он переходит к следующей строке в одном отношении или в
другом (в зависимости от результата сравнения) и снова проверяет соответствие. В конце концов,
данные в одном или другом вложенном плане заканчиваются и узел MergeJoin возвращает NULL,
показывая тем самым, что другие строки соединения получить нельзя.
Сложные запросы могут содержать много уровней вложенности узлов плана, но общий подход тот
же: каждый узел вычисляет и возвращает следующую полученную строку при очередном вызове.
Каждый узел также должен производить отбор и расчёты, которые были назначены ему плани-
ровщиком.
Механизм исполнителя применяется для обработки всех четырёх основных типов SQL-запросов:
SELECT, INSERT, UPDATE и DELETE. С SELECT код исполнителя верхнего уровня должен только выдать
клиенту все строки, полученные от дерева плана запроса. С INSERT все полученные строки встав-
ляются в целевую таблицу INSERT. Эта операция выполняется в специальном узле на верхнем уров-
не плана запроса, называемом ModifyTable. (Простая команда INSERT ... VALUES создаёт простей-
шее дерево плана, состоящее из одного узла Result, который вычисляет одну строку результата,
и узла ModifyTable над ним, который осуществляет добавление. Но с INSERT ... SELECT могут
быть востребованы все возможности механизма исполнителя.) С UPDATE планировщик делает так,
чтобы каждая вычисленная строка включала значения всех изменённых столбцов плюс TID (Tuple
ID, идентификатор кортежа) исходной целевой строки; эти данные подаются в узел ModifyTable,
который использует эту информацию, чтобы создать новую изменённую строку и пометить старую
строку как удалённую. С DELETE план фактически возвращает только один столбец, TID, а узел
ModifyTable использует значение TID, чтобы найти каждую целевую строку и пометить её как
удалённую.
1921
