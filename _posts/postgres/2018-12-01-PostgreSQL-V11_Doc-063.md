---
layout: post
title: Глава 63. Индексы B-деревья
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 63. Индексы B-деревья

63.1. Введение

PostgreSQL включает реализацию стандартной индексной структуры данных — B-дерева (btree,
многонаправленного бинарного дерева). В индекс-B-дерево могут быть загружены данные любого
типа, которые можно отсортировать в чётко определённом линейном порядке. Единственное его
ограничение состоит в том, что размер записи в индексе не может превышать примерно треть
страницы (после сжатия TOAST, если оно применяется).
Так как каждый класс операторов btree устанавливает порядок сортировки для своего типа дан-
ных, классы операторов btree (или, фактически, семейства операторов) оказались показательны-
ми и полезными для представления и понимания семантики сортировки в PostgreSQL. Как след-
ствие, они приобрели некоторые возможности, которые выходят за рамки необходимого минимума
для поддержки индексов btree и используются частями системы, довольно далёкими от методов
доступа btree.
63.2. Поведение классов операторов B-дерева
Как показано в Таблице 38.2, класс операторов btree должен предоставить пять операторов срав-
нения, <, <=, =, >= и >. Хотя можно было ожидать, что частью этого класса будет и оператор <>, но
это не так, потому что использовать <> в предложении WHERE для поиска по индексу практически
бесполезно. (Для некоторых целей планировщик условно относит оператор <> к классу операторов
btree, но он находит данный оператор как отрицание оператора =, а не обращаясь к pg_amop.)
Когда несколько типов данных имеют практически одинаковую семантику сортировки, их классы
операторов можно сгруппировать в семейство операторов. Это полезно тем, что позволяет плани-
ровщику делать выводы о межтиповых сравнениях. Каждый класс операторов в семействе должен
содержать операторы для одного своего типа входных данных (и сопутствующие опорные функ-
ции), тогда как межтиповые операторы сравнения и опорные функции являются «слабо» связан-
ными с семейством. В семейство рекомендуется включать полный набор межтиповых операторов,
чтобы планировщик мог представить любые условия, которые он может вывести, используя тран-
зитивность.
Семейство операторов btree должно удовлетворять нескольким базовым положениям:
• Оператор = должен представлять отношение эквивалентности; то есть для всех отличных от
NULL значений A, B, C определённого типа данных:
• A = A — истина (рефлексивность)
• если A = B, то B = A (симметрия)
• если A = B и B = C, то A = C (транзитивность)
• Оператор < должен представлять отношение строгого упорядочивания; то есть для всех от-
личных от NULL значений A, B, C:
• A < A — ложно (антирефлексивность)
• если A < B и B < C, то A < C (транзитивность)
• Более того, упорядочивание действует глобально; то есть для любых отличных от NULL значе-
ний A, B:
• истинным является ровно одно из условий: A < B, A = B или B < A (трихотомия)
(Разумеется, определение функции, осуществляющей сравнение, вытекает из закона трихото-
мии.)
Остальные три оператора определяются через операторы = и < очевидным образом и должны ра-
ботать согласованно с последними.
2136Индексы B-деревья
Для семейства операторов, поддерживающего несколько типов данных, вышеперечисленные за-
коны должны выполняться при значениях A, B, C, относящихся к любым типам из семейства. Тран-
зитивность обеспечить сложнее всего, так как в ситуациях с разными типами она требует согла-
сованного поведения двух или трёх различных операторов. Так например, в одном семействе опе-
раторов не смогут работать типы float8 и numeric, по крайней мере при текущем подходе, когда
значения numeric преобразуются во float8 для сравнения с float8. Из-за ограниченной точности
типа float8 различные значения numeric могут оказаться равными одному значению float8, что
нарушит закон транзитивности.
Ещё одно требование для семейства, рассчитанного на несколько типов данных, состоит в том, что
любое неявное или двоично-совместимое приведение, которое определено между типами, вклю-
чёнными в семейство операторов, не должно менять соответствующий порядок сортировки.
Должно быть достаточно понятно, почему индекс-B-дерево требует выполнения этих законов для
одного типа данных: без этого упорядочивание ключей невозможно. Кроме того, для поиска в ин-
дексе по ключу другого типа данных необходимо, чтобы значения двух типов сравнивались кор-
ректно. Расширение семейства до трёх или более типов данных не является обязательным для са-
мого механизма индекса btree, но может быть полезным для планировщика в целях оптимизации.
63.3. Опорные функции B-деревьев
Как показано в Таблица 38.8, btree определяет одну необходимую и две необязательных опорных
функции.
Для всех комбинаций типов данных, для которых семейство операторов btree предоставляет опе-
раторы сравнения, оно должно предоставлять опорную функцию сравнения в pg_amproc с номером
1 и c amproclefttype/amprocrighttype, равными левому и правому типу сравнения (то есть тем же
типам данных, с которыми соответствующие операторы зарегистрированы в pg_amop). Эта функ-
ция сравнения должна принимать два отличных от NULL значения A и B и возвращать значение
int32, которое будет < 0, 0 или > 0, когда A < B, A = B или A > B, соответственно. Результат NULL не
допускается: все значения типа данных должны быть сравнимыми. Примеры можно найти в src/
backend/access/nbtree/nbtcompare.c.
Если сравниваемые значения имеют сортируемый тип данных, опорной функции сравне-
ния будет передан OID соответствующего правила сортировки через стандартный механизм
PG_GET_COLLATION().
Дополнительно семейство операторов btree может предоставить функции поддержки сортировки,
которые регистрируются под номером опорной функции 2. Эти функции позволяют реализовывать
сравнения для целей сортировки гораздо эффективнее, чем это возможно при прямолинейном вы-
зове функции поддержки сравнения. Задействованные в этом программные интерфейсы опреде-
лены в src/include/utils/sortsupport.h.
Дополнительно семейство операторов btree может предоставить опорные функции in_range, кото-
рые регистрируются под номером 3. Они не используются в ходе операций с индексом btree; вме-
сто этого они расширяют семантику семейства операторов, чтобы оно могло поддерживать окон-
ные предложения RANGE смещение PRECEDING и RANGE смещение FOLLOWING (см. Подраздел  4.2.8).
По сути они предоставляют дополнительную информацию, позволяющую добавлять или вычитать
смещение в соответствии с порядком сортировки, принятым в семействе.
Функция in_range должна иметь сигнатуру
in_range(значение type1, база type1, смещение type2, вычитание bool, меньше bool)
returns bool
Значение и база должны быть одного типа данных, и этот тип должен поддерживаться семейством
операторов (то есть это должен быть тип, для которого реализуется сортировка). Однако смещение
может быть другого типа, который никаким другим образом не поддерживается данным семей-
ством. Например, встроенное семейство time_ops предоставляет функцию, для которой смещение
2137Индексы B-деревья
имеет тип interval. Семейство может предоставлять функции in_range для любых из своих под-
держиваемых типов и одного или нескольких типов смещений. Каждая функция in_range должна
регистрироваться в pg_amproc с полем amproclefttype, равным type1, и amprocrighttype, равным
type2.
Суть действия функции in_range зависит от двух логических флагов. Она должна прибавить или
вычесть из базы смещение, а затем сравнить значение с результатом следующим образом:
• если !вычитание и !меньше, возвращается значение >= (база + смещение)
• если !вычитание и меньше, возвращается значение <= (база + смещение)
• если вычитание и !меньше, возвращается значение >= (база - смещение)
• если вычитание и меньше, возвращается значение <= (база - смещение)
Прежде чем делать это, функция должна проверить знак смещения и, если оно отрицательное,
выдать ошибку ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE (22013) с текстом ошибки «invalid
preceding or following size in window function» (неверная предшествующая или последующая вели-
чина в оконной функции). (Это требуется стандартом SQL, но нестандартные семейства операто-
ров могут проигнорировать данное ограничение, так как оно не несёт большой смысловой нагруз-
ки.) Проверка этого требования делегируется функции in_range, чтобы коду ядра не требовалось
понимать, что означает «меньше нуля» для произвольного типа данных.
Кроме того, функции in_range, если это практично, могут не выдавать ошибку, когда операция
база + смещение или база - смещение приводит к переполнению. Правильный результат сравнения
можно получить, даже если это значение выходит за границы допустимого диапазона этого типа
данных. Заметьте, что если для типа данных определены такие понятия, как «бесконечность» и
«NaN», могут потребоваться дополнительные меры для обеспечения согласованности результатов
in_range с обычным порядком сортировки данного семейства операторов.
Результаты функции in_range должны соответствовать порядку сортировки, устанавливаемому се-
мейством операторов. Точнее говоря, при любых фиксированных аргументах смещение и вычитание
справедливо:
• Если in_range с меньше = true возвращает true для некоторого значения1 и базы, true должно
возвращаться для каждого значения2 <= значению1 с той же базой.
• Если in_range с меньше = true возвращает false для некоторого значения1 и базы, false должно
возвращаться для любого значения2 >= значению1 с той же базой.
• Если in_range с меньше = true возвращает true для некоторого значения и базы1, true должно
возвращаться для каждой базы2 >= базе1 с тем же значением.
• Если in_range с меньше = true возвращает false для некоторого значения и базы1, false должно
возвращаться для любой базы2 <= базе1 с тем же значением.
Аналогичные утверждения с противоположными условиями должны выполняться при меньше =
false.
Если упорядочиваемый тип (type1) является сортируемым, функции in_range будет передан OID
соответствующего правила сортировки через стандартный механизм PG_GET_COLLATION().
Функции in_range не должны обрабатывать NULL в аргументах и обычно помечаются как строгие.
63.4. Реализация
Вводное описание реализации индекса btree можно найти в src/backend/access/nbtree/README.
2138
