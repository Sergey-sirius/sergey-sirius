---
layout: post
title: Глава 8. Типы данных
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 8. Типы данных

PostgreSQL предоставляет пользователям богатый ассортимент встроенных типов данных. Кроме
того, пользователи могут создавать свои типы в PostgreSQL, используя команду CREATE TYPE.
Таблица 8.1 содержит все встроенные типы данных общего пользования. Многие из альтернатив-
ных имён, приведённых в столбце «Псевдонимы», используются внутри PostgreSQL по историче-
ским причинам. В этот список не включены некоторые устаревшие типы и типы для внутреннего
применения.
Таблица 8.1. Типы данных
Имя Псевдонимы Описание
bigint int8 знаковое целое из 8 байт
bigserial serial8 восьмибайтное целое с автоуве-
личением
битовая строка фиксированной
длины
bit [ ( n) ]
bit varying [ ( n) ] varbit [ ( n) ] битовая
длины
строка
boolean bool логическое
false)
переменной
значение
(true/
box прямоугольник в плоскости
bytea двоичные
байт»)
данные
(«массив
character [ ( n) ] char [ ( n) ] символьная строка фиксирован-
ной длины
character varying [ ( n) ] varchar [ ( n) ] символьная строка переменной
длины
cidr сетевой адрес IPv4 или IPv6
circle круг в плоскости
date календарная дата (год, месяц,
день)
double precision
число двойной точности с пла-
вающей точкой (8 байт)
float8
адрес узла IPv4 или IPv6
inet
integer
знаковое четырёхбайтное целое
int, int4
interval [ поля ] [ ( p) ] интервал времени
json текстовые данные JSON
jsonb двоичные данные JSON, разо-
бранные
line прямая в плоскости
lseg отрезок в плоскости
macaddr MAC-адрес
macaddr8 Адрес MAC (Media Access
Control) (в формате EUI-64)
money денежная сумма
numeric [ ( p,
s) ]
decimal [ ( p,
117
s) ]
вещественное число заданной
точностиТипы данных
Имя
Псевдонимы
Описание
path геометрический путь в плоско-
сти
pg_lsn Последовательный
номер
журнале PostgreSQL
point геометрическая точка в плоско-
сти
polygon замкнутый
геометрический
путь в плоскости
в
real float4 число одинарной точности с
плавающей точкой (4 байта)
smallint int2 знаковое двухбайтное целое
smallserial serial2 двухбайтное целое с автоувели-
чением
serial serial4 четырёхбайтное целое с авто-
увеличением
text символьная строка переменной
длины
time [ ( p) ] [ without time
zone ] время суток (без часового поя-
са)
time [ ( p) ] with time zone timetz время суток с учётом часового
пояса
timestamp [ ( p) ] [ without
time zone ] дата и время (без часового поя-
са)
timestamp [ ( p) ] with time timestamptz
zone дата и время с учётом часового
пояса
tsquery запрос текстового поиска
tsvector документ для текстового поис-
ка
txid_snapshot снимок идентификатора тран-
закций
uuid универсальный
идентификатор
xml XML-данные
уникальный
Совместимость
В стандарте SQL описаны следующие типы (или их имена): bigint, bit, bit varying,
boolean, char, character varying, character, varchar, date, double precision,
integer, interval, numeric, decimal, real, smallint, time (с часовым поясом и без),
timestamp (с часовым поясом и без), xml.
Каждый тип данных имеет внутреннее представление, скрытое функциями ввода и вывода. При
этом многие встроенные типы стандартны и имеют очевидные внешние форматы. Однако есть
типы, уникальные для PostgreSQL, например геометрические пути, и есть типы, которые могут
иметь разные форматы, например, дата и время. Некоторые функции ввода и вывода не являются
в точности обратными друг к другу, то есть результат функции вывода может не совпадать со
входным значением из-за потери точности.
118Типы данных
8.1. Числовые типы
Числовые типы включают двух-, четырёх- и восьмибайтные целые, четырёх- и восьмибайтные чис-
ла с плавающей точкой, а также десятичные числа с задаваемой точностью. Все эти типы пере-
числены в Таблице 8.2.
Таблица 8.2. Числовые типы
Имя Размер Описание
Диапазон
smallint 2 байта целое в небольшом диа- -32768 .. +32767
пазоне
integer 4 байта типичный выбор для це- -2147483648
лых чисел
+2147483647
bigint 8 байт целое в большом диапа- -9223372036854775808 ..
зоне
9223372036854775807
decimal переменный вещественное число с до 131072 цифр до де-
указанной точностью
сятичной точки и до
16383 — после
numeric переменный вещественное число с до 131072 цифр до де-
указанной точностью
сятичной точки и до
16383 — после
real 4 байта вещественное число с точность в пределах 6
переменной точностью десятичных цифр
double precision 8 байт вещественное число с точность в пределах 15
переменной точностью десятичных цифр
smallserial 2 байта небольшое целое с ав- 1 .. 32767
тоувеличением
serial 4 байта целое с автоувеличени- 1 .. 2147483647
ем
bigserial 8 байт большое целое с авто- 1
..
увеличением
9223372036854775807
..
Синтаксис констант числовых типов описан в Подразделе 4.1.2. Для этих типов определён полный
набор соответствующих арифметических операторов и функций. За дополнительными сведениями
обратитесь к Главе 9. Подробнее эти типы описаны в следующих разделах.
8.1.1. Целочисленные типы
Типы smallint, integer и bigint хранят целые числа, то есть числа без дробной части, имею-
щие разные допустимые диапазоны. Попытка сохранить значение, выходящее за рамки диапазо-
на, приведёт к ошибке.
Чаще всего используется тип integer, как наиболее сбалансированный выбор ширины диапазона,
размера и быстродействия. Тип smallint обычно применяется, только когда крайне важно умень-
шить размер данных на диске. Тип bigint предназначен для тех случаев, когда числа не умеща-
ются в диапазон типа integer.
В SQL определены только типы integer (или int), smallint и bigint. Имена типов int2, int4 и
int8 выходят за рамки стандарта, хотя могут работать и в некоторых других СУБД.
8.1.2. Числа с произвольной точностью
Тип numeric позволяет хранить числа с очень большим количеством цифр. Он особенно рекомен-
дуется для хранения денежных сумм и других величин, где важна точность. Вычисления с типом
numeric дают точные результаты, где это возможно, например, при сложении, вычитании и умно-
119Типы данных
жении. Однако операции со значениями numeric выполняются гораздо медленнее, чем с целыми
числами или с типами с плавающей точкой, описанными в следующем разделе.
Ниже мы используем следующие термины: масштаб значения numeric определяет количество
десятичных цифр в дробной части, справа от десятичной точки, а точность — общее количество
значимых цифр в числе, т. е. количество цифр по обе стороны десятичной точки. Например, число
23.5141 имеет точность 6 и масштаб 4. Целочисленные значения можно считать числами с мас-
штабом 0.
Для столбца типа numeric можно настроить и максимальную точность, и максимальный масштаб.
Столбец типа numeric объявляется следующим образом:
NUMERIC(точность, масштаб)
Точность должна быть положительной, а масштаб положительным или равным нулю. Альтерна-
тивный вариант
NUMERIC(точность)
устанавливает масштаб 0. Форма:
NUMERIC
без указания точности и масштаба создаёт столбец, в котором можно сохранять числовые значе-
ния любой точности и масштаба в пределах, поддерживаемых системой. В столбце этого типа вход-
ные значения не будут приводиться к какому-либо масштабу, тогда как в столбцах numeric с явно
заданным масштабом значения подгоняются под этот масштаб. (Стандарт SQL утверждает, что
по умолчанию должен устанавливаться масштаб 0, т. е. значения должны приводиться к целым
числам. Однако мы считаем это не очень полезным. Если для вас важна переносимость, всегда
указывайте точность и масштаб явно.)
Примечание
Максимально допустимая точность, которую можно указать в объявлении типа, равна
1000; если же использовать NUMERIC без указания точности, действуют ограничения,
описанные в Таблице 8.2.
Если масштаб значения, которое нужно сохранить, превышает объявленный масштаб столбца, си-
стема округлит его до заданного количества цифр после точки. Если же после этого количество
цифр слева в сумме с масштабом превысит объявленную точность, произойдёт ошибка.
Числовые значения физически хранятся без каких-либо дополняющих нулей слева или справа.
Таким образом, объявляемые точность и масштаб столбца определяют максимальный, а не фикси-
рованный размер хранения. (В этом смысле тип numeric больше похож на тип varchar(n), чем на
char(n).) Действительный размер хранения такого значения складывается из двух байт для каж-
дой группы из четырёх цифр и дополнительных трёх-восьми байт.
Помимо обычных чисел тип numeric позволяет сохранить специальное значение NaN, что означает
«not-a-number» (не число). Любая операция c NaN выдаёт в результате тоже NaN. Записывая это зна-
чение в виде константы в команде SQL, его нужно заключать в апострофы, например так: UPDATE
table SET x = 'NaN'. Регистр символов в строке NaN не важен.
Примечание
В большинстве реализаций «не-число» (NaN) считается не равным любому другому зна-
чению (в том числе и самому NaN). Чтобы значения numeric можно было сортировать
и использовать в древовидных индексах, PostgreSQL считает, что значения NaN равны
друг другу и при этом больше любых числовых значений (не NaN).
120Типы данных
Типы decimal и numeric равнозначны. Оба эти типа описаны в стандарте SQL.
При округлении значений тип numeric выдаёт число, большее по модулю, тогда как (на большин-
стве платформ) типы real и double precision выдают ближайшее чётное число. Например:
SELECT x,
round(x::numeric) AS num_round,
round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
x
| num_round | dbl_round
------+-----------+-----------
-3.5 |
-4 |
-4
-2.5 |
-3 |
-2
-1.5 |
-2 |
-2
-0.5 |
-1 |
-0
0.5 |
1 |
0
1.5 |
2 |
2
2.5 |
3 |
2
3.5 |
4 |
4
(8 rows)
8.1.3. Типы с плавающей точкой
Типы данных real и double precision хранят приближённые числовые значения с переменной
точностью. На практике эти типы обычно реализуют Стандарт IEEE 754 для двоичной арифметики
с плавающей точкой (с одинарной и двойной точностью соответственно), в той мере, в какой его
поддерживают процессор, операционная система и компилятор.
Неточность здесь выражается в том, что некоторые значения, которые нельзя преобразовать во
внутренний формат, сохраняются приближённо, так что полученное значение может несколько
отличаться от записанного. Управление подобными ошибками и их распространение в процессе
вычислений является предметом изучения целого раздела математики и компьютерной науки, и
здесь не рассматривается. Мы отметим только следующее:
• Если вам нужна точность при хранении и вычислениях (например, для денежных сумм), ис-
пользуйте вместо этого тип numeric.
• Если вы хотите выполнять с этими типами сложные вычисления, имеющие большую важ-
ность, тщательно изучите реализацию операций в вашей среде и особенно поведение в край-
них случаях (бесконечность, антипереполнение).
• Проверка равенства двух чисел с плавающей точкой может не всегда давать ожидаемый ре-
зультат.
На большинстве платформ тип real может сохранить значения в пределах от 1E-37 до 1E+37 с
точностью не меньше 6 десятичных цифр. Тип double precision предлагает диапазон значений
от 1E-307 до 1E+308 и точностью не меньше 15 цифр. Попытка сохранить слишком большие или
слишком маленькие значения приведёт к ошибке. Если точность вводимого числа слишком вели-
ка, оно будет округлено. При попытке сохранить число, близкое к 0, но непредставимое как от-
личное от 0, произойдёт ошибка антипереполнения.
Примечание
Параметр extra_float_digits определяет количество дополнительных значащих цифр
при преобразовании значения с плавающей точкой в текст для вывода. Со значени-
ем по умолчанию (0) вывод будет одинаковым на всех платформах, поддерживаемых
PostgreSQL. При его увеличении выводимое значение числа будет более точно пред-
ставлять хранимое, но от этого может пострадать переносимость.
121Типы данных
В дополнение к обычным числовым значениям типы с плавающей точкой могут содержать следу-
ющие специальные значения:
Infinity
-Infinity
NaN
Они представляют особые значения, описанные в IEEE 754, соответственно «бесконечность», «ми-
нус бесконечность» и «не число». (На компьютерах, где арифметика с плавающей точкой не соот-
ветствует стандарту IEEE 754, эти значения, вероятно, не будут работать должным образом.) За-
писывая эти значения в виде констант в команде SQL, их нужно заключать в апострофы, например
так: UPDATE table SET x = '-Infinity'. Регистр символов в этих строках не важен.
Примечание
Согласно IEEE754, NaN не должно считаться равным любому другому значению с пла-
вающей точкой (в том числе и самому NaN). Чтобы значения с плавающей точкой мож-
но было сортировать и использовать в древовидных индексах, PostgreSQL считает, что
значения NaN равны друг другу, и при этом больше любых числовых значений (не NaN).
PostgreSQL также поддерживает форматы float и float(p), оговорённые в стандарте SQL, для
указания неточных числовых типов. Здесь p определяет минимально допустимую точность в дво-
ичных цифрах. PostgreSQL воспринимает запись от float(1) до float(24) как выбор типа real, а
запись от float(25) до float(53) как выбор типа double precision. Значения p вне допустимого
диапазона вызывают ошибку. Если float указывается без точности, подразумевается тип double
precision.
Примечание
Предположение, что типы real и double precision имеют в мантиссе 24 и 53 бита со-
ответственно, справедливо для всех реализаций плавающей точки по стандарту IEEE.
На платформах, не поддерживающих IEEE, размер мантиссы может несколько отли-
чаться, но для простоты диапазоны p везде считаются одинаковыми.
8.1.4. Последовательные типы
Примечание
В этом разделе описывается специфичный для PostgreSQL способ создания столбца с
автоувеличением. Другой способ, соответствующий стандарту SQL, заключается в ис-
пользовании столбцов идентификации и рассматривается в описании CREATE TABLE.
Типы данных smallserial, serial и bigserial не являются настоящими типами, а представляют
собой просто удобное средство для создания столбцов с уникальными идентификаторами (подоб-
ное свойству AUTO_INCREMENT в некоторых СУБД). В текущей реализации запись:
CREATE TABLE имя_таблицы (
имя_столбца SERIAL
);
равнозначна следующим командам:
CREATE SEQUENCE имя_таблицы_имя_столбца_seq;
CREATE TABLE имя_таблицы (
имя_столбца integer NOT NULL DEFAULT nextval('имя_таблицы_имя_столбца_seq')
);
122Типы данных
ALTER SEQUENCE имя_таблицы_имя_столбца_seq OWNED BY имя_таблицы.имя_столбца;
То есть при определении такого типа создаётся целочисленный столбец со значением по умол-
чанию, извлекаемым из генератора последовательности. Чтобы в столбец нельзя было вставить
NULL, в его определение добавляется ограничение NOT NULL. (Во многих случаях также имеет
смысл добавить для этого столбца ограничения UNIQUE или PRIMARY KEY для защиты от ошибочного
добавления дублирующихся значений, но автоматически это не происходит.) Последняя команда
определяет, что последовательность «принадлежит» столбцу, так что она будет удалена при уда-
лении столбца или таблицы.
Примечание
Так как типы smallserial, serial и bigserial реализованы через последовательности,
в числовом ряду значений столбца могут образовываться пропуски (или "дыры"), даже
если никакие строки не удалялись. Значение, выделенное из последовательности, счи-
тается "задействованным", даже если строку с этим значением не удалось вставить в
таблицу. Это может произойти, например, при откате транзакции, добавляющей дан-
ные. См. описание nextval() в Разделе 9.16.
Чтобы вставить в столбец serial следующее значение последовательности, ему нужно присвоить
значение по умолчанию. Это можно сделать, либо исключив его из списка столбцов в операторе
INSERT, либо с помощью ключевого слова DEFAULT.
Имена типов serial и serial4 равнозначны: они создают столбцы integer. Так же являются си-
нонимами имена bigserial и serial8, но они создают столбцы bigint. Тип bigserial следует ис-
31
пользовать, если за всё время жизни таблицы планируется использовать больше чем 2 значений.
И наконец, синонимами являются имена типов smallserial и serial2, но они создают столбец
smallint.
Последовательность, созданная для столбца serial, автоматически удаляется при удалении свя-
занного столбца. Последовательность можно удалить и отдельно от столбца, но при этом также
будет удалено определение значения по умолчанию.
8.2. Денежные типы
Тип money хранит денежную сумму с фиксированной дробной частью; см. Таблицу 8.3. Точность
дробной части определяется на уровне базы данных параметром lc_monetary. Для диапазона, по-
казанного в таблице, предполагается, что число содержит два знака после запятой. Входные дан-
ные могут быть записаны по-разному, в том числе в виде целых и дробных чисел, а также в виде
строки в денежном формате, например '$1,000.00'. Выводятся эти значения обычно в денежном
формате, зависящем от региональных стандартов.
Таблица 8.3. Денежные типы
Имя Размер Описание Диапазон
money 8 байт денежная сумма -92233720368547
758.08
+92233720368547
758.07
..
Так как выводимые значения этого типа зависят от региональных стандартов, попытка загрузить
данные типа money в базу данных с другим параметром lc_monetary может быть неудачной. Во
избежание подобных проблем, прежде чем восстанавливать копию в новую базу данных, убедитесь
в том, что параметр lc_monetary в этой базе данных имеет то же значение, что и в исходной.
Значения типов numeric, int и bigint можно привести к типу money. Преобразования типов real
и double precision так же возможны через тип numeric, например:
123Типы данных
SELECT '12.34'::float8::numeric::money;
Однако использовать числа с плавающей точкой для денежных сумм не рекомендуется из-за воз-
можных ошибок округления.
Значение money можно привести к типу numeric без потери точности. Преобразование в другие
типы может быть неточным и также должно выполняться в два этапа:
SELECT '52093.89'::money::numeric::float8;
При делении значения типа money на целое число выполняется отбрасывание дробной части и
получается целое, ближайшее к нулю. Чтобы получить результат с округлением, выполните деле-
ние значения с плавающей точкой или приведите значение типа money к numeric до деления, а
затем приведите результат к типу money. (Последний вариант предпочтительнее, так как исклю-
чает риск потери точности.) Когда значение money делится на другое значение money, результатом
будет значение типа double precision (то есть просто число, не денежная величина); денежные
единицы измерения при делении сокращаются.
8.3. Символьные типы
Таблица 8.4. Символьные типы
Имя Описание
character varying( n), varchar( n) строка ограниченной переменной длины
character( n), char( n) строка фиксированной длины, дополненная про-
белами
text строка неограниченной переменной длины
В Таблице 8.4 перечислены символьные типы общего назначения, доступные в PostgreSQL.
SQL определяет два основных символьных типа: character varying(n) и character(n), где n — по-
ложительное число. Оба эти типа могут хранить текстовые строки длиной до n символов (не байт).
Попытка сохранить в столбце такого типа более длинную строку приведёт к ошибке, если только
все лишние символы не являются пробелами (тогда они будут усечены до максимально допусти-
мой длины). (Это несколько странное исключение продиктовано стандартом SQL.) Если длина со-
храняемой строки оказывается меньше объявленной, значения типа character будут дополнятся
пробелами; а тип character varying просто сохранит короткую строку.
При попытке явно привести значение к типу character varying(n) или character(n), часть стро-
ки, выходящая за границу в n символов, удаляется, не вызывая ошибки. (Это также продиктовано
стандартом SQL.)
Записи varchar(n) и char(n) являются синонимами character varying(n) и character(n), соот-
ветственно. Записи character без указания длины соответствует character(1). Если же длина не
указывается для character varying, этот тип будет принимать строки любого размера. Это пове-
дение является расширением PostgreSQL.
Помимо этого, PostgreSQL предлагает тип text, в котором можно хранить строки произвольной
длины. Хотя тип text не описан в стандарте SQL, его поддерживают и некоторые другие СУБД SQL.
Значения типа character физически дополняются пробелами до n символов и хранятся, а затем
отображаются в таком виде. Однако при сравнении двух значений типа character дополняющие
пробелы считаются незначащими и игнорируются. С правилами сортировки, где пробельные сим-
волы являются значащими, это поведение может приводить к неожиданным результатам, напри-
мер SELECT 'a '::CHAR(2) collate "C" < E'a\n'::CHAR(2) вернёт true (условие будет истинным),
хотя в локали C символ пробела считается больше символа новой строки. При приведении значе-
ния character к другому символьному типу дополняющие пробелы отбрасываются. Заметьте, что
124Типы данных
эти пробелы несут смысловую нагрузку в типах character varying и text и в проверках по шаб-
лонам, то есть в LIKE и регулярных выражениях.
Для хранения короткой строки (до 126 байт) требуется дополнительный 1 байт плюс размер самой
строки, включая дополняющие пробелы для типа character. Для строк длиннее требуется не 1,
а 4 дополнительных байта. Система может автоматически сжимать длинные строки, так что фи-
зический размер на диске может быть меньше. Очень длинные текстовые строки переносятся в
отдельные таблицы, чтобы они не замедляли работу с другими столбцами. В любом случае, мак-
симально возможный размер строки составляет около 1 ГБ. (Допустимое значение n в объявлении
типа данных меньше этого числа. Это объясняется тем, что в зависимости от кодировки каждый
символ может занимать несколько байт. Если вы желаете сохранять строки без определённого
предела длины, используйте типы text или character varying без указания длины, а не задавайте
какое-либо большое максимальное значение.)
Подсказка
По быстродействию эти три типа практически не отличаются друг от друга, не счи-
тая большего размера хранения для типа с дополняющими пробелами и нескольких
машинных операций для проверки длины при сохранении строк в столбце с ограни-
ченной длиной. Хотя в некоторых СУБД тип character(n) работает быстрее других, в
PostgreSQL это не так; на деле character(n) обычно оказывается медленнее остальных
типов из-за большего размера данных и более медленной сортировки. В большинстве
случаев вместо него лучше применять text или character varying.
Подробнее синтаксис текстовых строк описан в Подразделе 4.1.2.1, а доступные операторы и функ-
ции перечисляются в Главе 9. Кодировка, используемая для хранения текстовых строк, определя-
ется набором символов, выбранным для базы данных. Подробнее это описано в Разделе 23.3.
Пример 8.1. Использование символьных типов
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; --
1
a
| char_length
------+-------------
ok
|
2
CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good
');
INSERT INTO test2 VALUES ('too long');
ОШИБКА: значение не умещается в тип character varying(5)
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- явное усечение
SELECT b, char_length(b) FROM test2;
b
| char_length
-------+-------------
ok
|
2
good |
5
too l |
5
1
Функция char_length рассматривается в Разделе 9.4.
В PostgreSQL есть ещё два символьных типа фиксированной длины, приведённые в Таблице 8.5.
Тип name создан только для хранения идентификаторов во внутренних системных таблицах и не
125Типы данных
предназначен для обычного применения пользователями. В настоящее время его длина составля-
ет 64 байта (63 ASCII-символа плюс конечный знак), но в исходном коде C она задаётся констан-
той NAMEDATALEN. Эта константа определяется во время компиляции (и её можно менять в особых
случаях), а кроме того, максимальная длина по умолчанию может быть увеличена в следующих
версиях. Тип "char" (обратите внимание на кавычки) отличается от char(1) тем, что он факти-
чески хранится в одном байте. Он используется во внутренних системных таблицах для простых
перечислений.
Таблица 8.5. Специальные символьные типы
Имя Размер Описание
"char" 1 байт внутренний однобайтный тип
name 64 байта внутренний тип для имён объек-
тов
8.4. Двоичные типы данных
Для хранения двоичных данных предназначен тип bytea; см. Таблицу 8.6.
Таблица 8.6. Двоичные типы данных
Имя Размер
Описание
bytea 1 или 4 байта плюс сама двоич- двоичная строка переменной
ная строка
длины
Двоичные строки представляют собой последовательность октетов (байт) и имеют два отличия от
текстовых строк. Во-первых, в двоичных строках можно хранить байты с кодом 0 и другими «непе-
чатаемыми» значениями (обычно это значения вне десятичного диапазона 32..126). В текстовых
строках нельзя сохранять нулевые байты, а также значения и последовательности значений, не
соответствующие выбранной кодировке базы данных. Во-вторых, в операциях с двоичными стро-
ками обрабатываются байты в чистом виде, тогда как текстовые строки обрабатываются в зависи-
мости от языковых стандартов. То есть, двоичные строки больше подходят для данных, которые
программист видит как «просто байты», а символьные строки — для хранения текста.
Тип bytea поддерживает два формата ввода и вывода: «шестнадцатеричный» и традиционный для
PostgreSQL формат «спецпоследовательностей». Входные данные принимаются в обоих форматах,
а формат выходных данных зависит от параметра конфигурации bytea_output; по умолчанию вы-
бран шестнадцатеричный. (Заметьте, что шестнадцатеричный формат был введён в PostgreSQL
9.0; в ранних версиях и некоторых программах он не будет работать.)
Стандарт SQL определяет другой тип двоичных данных, BLOB (BINARY LARGE OBJECT, большой дво-
ичный объект). Его входной формат отличается от форматов bytea, но функции и операторы в ос-
новном те же.
8.4.1. Шестнадцатеричный формат bytea
В «шестнадцатеричном» формате двоичные данные кодируются двумя шестнадцатеричными циф-
рами на байт, при этом первая цифра соответствует старшим 4 битам. К полученной строке до-
бавляется префикс \x (чтобы она отличалась от формата спецпоследовательности). В некоторых
контекстах обратную косую черту нужно выделить, продублировав её, в тех же случаях это нуж-
но сделать для формата спецпоследовательности; подробнее это описано ниже. Шестнадцатерич-
ные цифры могут быть в любом регистре, а между парами цифр допускаются пробельные символы
(но не внутри пары и не в начале последовательности \x). Этот формат совместим со множеством
внешних приложений и протоколов, к тому же обычно преобразуется быстрее, поэтому предпо-
чтительнее использовать его.
Пример:
126Типы данных
SELECT '\xDEADBEEF';
8.4.2. Формат спецпоследовательностей bytea
Формат «спецпоследовательностей» традиционно использовался в PostgreSQL для значений типа
bytea. В нём двоичная строка представляется в виде последовательности ASCII-символов, а байты,
непредставимые в виде ASCII-символов, передаются в виде спецпоследовательностей. Этот формат
может быть удобен, если с точки зрения приложения представление байт в виде символов имеет
смысл. Но на практике это обычно создаёт путаницу, так как двоичные и символьные строки мо-
гут выглядеть одинаково, а кроме того выбранный механизм спецпоследовательностей довольно
неуклюж. Поэтому в новых приложениях этот формат обычно не стоит использовать.
Передавая значения bytea в формате спецпоследовательности, байты с определёнными значени-
ями необходимо записывать специальным образом, хотя так можно записывать и все значения. В
общем виде для этого значение байта нужно преобразовать в трёхзначное восьмеричное число и
добавить перед ним обратную косую черту (и продублировать её, если значение записывается в
текстовой спецстроке). Саму обратную косую черту (символ с десятичным кодом 92) можно запи-
сать в виде двух таких символов. В Таблице 8.7 перечислены символы, которые нужно записывать
спецпоследовательностями, и приведены альтернативные варианты записи там, где они возмож-
ны.
Таблица 8.7. Спецпоследовательности записи значений bytea
Десятичное зна- Описание
чение байта Спецпоследова- Пример
тельность ввода Выводимое
представление
0 нулевой байт '\000' SELECT
'\000'::bytea; \x00
39 апостроф '''' или '\047' SELECT
''''::bytea; \x27
92 обратная
черта косая '\' или '\\134'
от 0 до 31 и от 127 «непечатаемые»
до 255
байты
SELECT
\'::bytea;
E'\\xxx' (восьме- SELECT
ричное значение) '\001'::bytea;
'\ \x5c
\x01
Набор непечатаемых символов, которые нужно записывать спецпоследовательностями, опреде-
ляется языковыми стандартами. В некоторых случаях можно оставить в буквальном виде и другие
символы. Заметьте, что во всех примерах в Таблице 8.7 задаётся значение ровно одного байта, хотя
выходное представление может состоять из нескольких символов.
Необходимость дублирования обратных косых черт в записи спецпоследовательностей, показан-
ного в Таблице 8.7, объясняется тем, что строковая константа должна пройти два этапа разбора на
сервере PostgreSQL. Первая обратная косая черта из каждой пары воспринимается анализатором
строки как спецсимвол (если используется синтаксис спецпоследовательностей) и таким образом
пропускается, оставляя только вторую косую черту. (Для избавления от этой вложенности можно
использовать строки в долларах.) Оставшаяся обратная косая черта затем распознаётся функцией
ввода bytea как спецсимвол, предваряющий трёхзначное восьмеричное значение или следующий
спецсимвол. Например, переданная серверу строковая константа '\001' преобразуется в \001,
проходя через анализатор спецстрок. Затем строка \001 передаётся функции ввода типа bytea,
где она преобразуется в один байт с десятичным значением 1. Заметьте, что символ апостроф для
функции ввода bytea не отличается от остальных, поэтому он записывается как обычно принято
в строках. (См. также Подраздел 4.1.2.1.)
Данные Bytea по умолчанию выводятся в шестнадцатеричном формате (hex). Если поменять зна-
чение bytea_output на escape, «непечатаемый» байт представляется в виде трёхзначного восьме-
ричного значения, перед которым добавляется одна обратная косая черта. Большинство «печата-
емых» байтов представляются обычными символами из клиентского набора символов, например:
SET bytea_output = 'escape';
127Типы данных
SELECT 'abc \153\154\155 \052\251\124'::bytea;
bytea
----------------
abc klm *\251T
Байт с десятичным кодом 92 (обратная косая черта) при выводе дублируется. Это иллюстрирует
Таблица 8.8.
Таблица 8.8. Спецпоследовательности выходных значений bytea
Десятичное зна- Описание
чение байта
92
обратная
черта
Спецпоследова- Пример
тельность выво-
да
косая \\
SELECT
'\134'::bytea;
от 0 до 31 и от 127 «непечатаемые»
до 255
байты \xxx
байта)
от 32 до 126 представление из SELECT
клиентского набо- '\176'::bytea;
ра символов
«печатаемые»
байты
(значение SELECT
'\001'::bytea;
Выводимый
зультат
ре-
\\
\001
~
В зависимости от применяемой клиентской библиотеки PostgreSQL, для преобразования значе-
ний bytea в спецстроки и обратно могут потребоваться дополнительные действия. Например, если
приложение сохраняет в строках символы перевода строк, возможно их также нужно будет пред-
ставить спецпоследовательностями.
8.5. Типы даты/времени
PostgreSQL поддерживает полный набор типов даты и времени SQL, показанный в Таблице  8.9.
Операции, возможные с этими типами данных, описаны в Разделе  9.9. Все даты считаются по
Григорианскому календарю, даже для времени до его введения (за дополнительными сведениями
обратитесь к Разделу B.4).
Таблица 8.9. Типы даты/времени
Имя
Размер
Описание
Наименьшее
значение
Наибольшее
значение Точность
timestamp [ ( 8 байт
p)
]
[ without time
zone ] дата и время 4713 до н. э.
(без часового
пояса) 294276 н. э. 1 микросекун-
да
timestamp [ ( 8 байт
p)
]
with
time zone дата и время ( 4713 до н. э.
с часовым поя-
сом) 294276 н. э. 1 микросекун-
да
дата (без вре- 4713 до н. э.
мени суток) 5874897 н. э. 1 день
time [ ( p) ] 8 байт
[ without time
zone ] время суток ( 00:00:00
без даты) 24:00:00 1 микросекун-
да
time [ ( p) ] 12 байт
with time zone время дня (без 00:00:00+1459 24:00:00-1459
даты), с часо-
вым поясом interval [ по- 16 байт
ля ] [ ( p) ] временной ин- -178000000 лет 178000000 лет 1 микросекун-
тервал
да
date
4 байта
128
1 микросекун-
даТипы данных
Примечание
Стандарт SQL требует, чтобы тип timestamp подразумевал timestamp without time
zone (время без часового пояса), и PostgreSQL следует этому. Для краткости timestamp
with time zone можно записать как timestamptz; это расширение PostgreSQL.
Типы time, timestamp и interval принимают необязательное значение точности p, определяющее,
сколько знаков после запятой должно сохраняться в секундах. По умолчанию точность не ограни-
чивается. Допустимые значения p лежат в интервале от 0 до 6.
Тип interval дополнительно позволяет ограничить набор сохраняемых поле следующими фраза-
ми:
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
Заметьте, что если указаны и поля, и точность p, указание поля должно включать SECOND, так как
точность применима только к секундам.
Тип time with time zone определён стандартом SQL, но в его определении описаны свойства
сомнительной ценности. В большинстве случаев сочетание типов date, time, timestamp without
time zone и timestamp with time zone удовлетворяет все потребности в функционале дат/времени,
возникающие в приложениях.
Типы abstime и reltime имеют меньшую точность и предназначены для внутреннего использова-
ния. Эти типы не рекомендуется использовать в обычных приложениях; их может не быть в буду-
щих версиях.
8.5.1. Ввод даты/времени
Значения даты и времени принимаются практически в любом разумном формате, включая ISO
8601, SQL-совместимый, традиционный формат POSTGRES и другие. В некоторых форматах поря-
док даты, месяца и года во вводимой дате неоднозначен и поэтому поддерживается явное опреде-
ление формата. Для этого предназначен параметр DateStyle. Когда он имеет значение MDY, выби-
рается интерпретация месяц-день-год, значению DMY соответствует день-месяц-год, а YMD — год-
месяц-день.
PostgreSQL обрабатывает вводимые значения даты/времени более гибко, чем того требует стан-
дарт SQL. Точные правила разбора даты/времени и распознаваемые текстовые поля, в том числе
названия месяцев, дней недели и часовых поясов описаны в Приложении B.
Помните, что любые вводимые значения даты и времени нужно заключать в апострофы, как тек-
стовые строки. За дополнительной информацией обратитесь к Подразделу 4.1.2.7. SQL предусмат-
ривает следующий синтаксис:
тип [ (p) ] 'значение'
Здесь p — необязательное указание точности, определяющее число знаков после точки в секундах.
Точность может быть определена для типов time, timestamp и interval в интервале от 0 до 6. Если
129Типы данных
в определении константы точность не указана, она считается равной точности значения в строке
(но не больше 6 цифр).
8.5.1.1. Даты
В Таблице 8.10 приведены некоторые допустимые значения типа date.
Таблица 8.10. Вводимые даты
Пример Описание
1999-01-08 ISO 8601; 8 января в любом режиме (рекоменду-
емый формат)
January 8, 1999 воспринимается однозначно в любом режиме
datestyle
1/8/1999 8 января в режиме MDY и 1 августа в режиме DMY
1/18/1999 18 января в режиме MDY; недопустимая дата в
других режимах
01/02/03 2 января 2003 г. в режиме MDY; 1 февраля 2003 г.
в режиме DMY и 3 февраля 2001 г. в режиме YMD
1999-Jan-08 8 января в любом режиме
Jan-08-1999 8 января в любом режиме
08-Jan-1999 8 января в любом режиме
99-Jan-08 8 января в режиме YMD; ошибка в других режи-
мах
08-Jan-99 8 января; ошибка в режиме YMD
Jan-08-99 8 января; ошибка в режиме YMD
19990108 ISO 8601; 8 января 1999 в любом режиме
990108 ISO 8601; 8 января 1999 в любом режиме
1999.008 год и день года
J2451187 дата по юлианскому календарю
January 8, 99 BC 99 до н. э.
8.5.1.2. Время
Для хранения времени суток без даты предназначены типы time [ (p) ] without time zone и
time [ (p) ] with time zone. Тип time без уточнения эквивалентен типу time without time zone.
Допустимые вводимые значения этих типов состоят из записи времени суток и необязательного
указания часового пояса. (См. Таблицу 8.11 и Таблицу 8.12.) Если в значении для типа time without
time zone указывается часовой пояс, он просто игнорируется. Так же будет игнорироваться дата,
если её указать, за исключением случаев, когда в указанном часовом поясе принят переход на
летнее время, например America/New_York. В данном случае указать дату необходимо, чтобы си-
стема могла определить, применяется ли обычное или летнее время. Соответствующее смещение
часового пояса записывается в значении time with time zone.
Таблица 8.11. Вводимое время
Пример Описание
04:05:06.789 ISO 8601
04:05:06 ISO 8601
04:05 ISO 8601
040506 ISO 8601
130Типы данных
Пример Описание
04:05 AM то же, что и 04:05; AM не меняет значение вре-
мени
04:05 PM то же, что и 16:05; часы должны быть <= 12
04:05:06.789-8 ISO 8601
04:05:06-08:00 ISO 8601
04:05-08:00 ISO 8601
040506-08 ISO 8601
04:05:06 PST часовой пояс задаётся аббревиатурой
2003-04-12 04:05:06 America/New_York часовой пояс задаётся полным названием
Таблица 8.12. Вводимый часовой пояс
Пример Описание
PST аббревиатура (Pacific Standard Time, Стандарт-
ное тихоокеанское время)
America/New_York полное название часового пояса
PST8PDT указание часового пояса в стиле POSIX
-8:00 смещение часового пояса PST по ISO-8601
-800 смещение часового пояса PST по ISO-8601
-8 смещение часового пояса PST по ISO-8601
zulu принятое у военных сокращение UTC
z краткая форма zulu
Подробнее узнать о том, как указывается часовой пояс, можно в Подразделе 8.5.3.
8.5.1.3. Даты и время
Допустимые значения типов timestamp состоят из записи даты и времени, после которого может
указываться часовой пояс и необязательное уточнение AD или BC, определяющее эпоху до нашей
эры и нашу эру соответственно. (AD/BC можно указать и перед часовым поясом, но предпочтитель-
нее первый вариант.) Таким образом:
1999-01-08 04:05:06
и
1999-01-08 04:05:06 -8:00
допустимые варианты, соответствующие стандарту ISO 8601. В дополнение к этому поддержива-
ется распространённый формат:
January 8 04:05:06 1999 PST
Стандарт SQL различает константы типов timestamp without time zone и timestamp with time
zone по знаку «+» или «-» и смещению часового пояса, добавленному после времени. Следователь-
но, согласно стандарту, записи
TIMESTAMP '2004-10-19 10:23:54'
должен соответствовать тип timestamp without time zone, а
TIMESTAMP '2004-10-19 10:23:54+02'
тип timestamp with time zone. PostgreSQL никогда не анализирует содержимое текстовой стро-
ки, чтобы определить тип значения, и поэтому обе записи будут обработаны как значения типа
131Типы данных
timestamp without time zone. Чтобы текстовая константа обрабатывалась как timestamp with
time zone, укажите этот тип явно:
TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'
В константе типа timestamp without time zone PostgreSQL просто игнорирует часовой пояс. То
есть результирующее значение вычисляется только из полей даты/времени и не подстраивается
под указанный часовой пояс.
Значения timestamp with time zone внутри всегда хранятся в UTC (Universal Coordinated Time,
Всемирное скоординированное время или время по Гринвичу, GMT). Вводимое значение, в котором
явно указан часовой пояс, переводится в UTC с учётом смещения данного часового пояса. Если
во входной строке не указан часовой пояс, подразумевается часовой пояс, заданный системным
параметром TimeZone и время так же пересчитывается в UTC со смещением timezone.
Когда значение timestamp with time zone выводится, оно всегда преобразуется из UTC в текущий
часовой пояс timezone и отображается как локальное время. Чтобы получить время для другого
часового пояса, нужно либо изменить timezone, либо воспользоваться конструкцией AT TIME ZONE
(см. Подраздел 9.9.3).
В преобразованиях между timestamp without time zone и timestamp with time zone обычно пред-
полагается, что значение timestamp without time zone содержит местное время (для часового
пояса timezone). Другой часовой пояс для преобразования можно задать с помощью AT TIME ZONE.
8.5.1.4. Специальные значения
PostgreSQL для удобства поддерживает несколько специальных значений даты/времени, перечис-
ленных в Таблице 8.13. Значения infinity и -infinity имеют особое представление в системе и
они отображаются в том же виде, тогда как другие варианты при чтении преобразуются в значе-
ния даты/времени. (В частности, now и подобные строки преобразуются в актуальные значения
времени в момент чтения.) Чтобы использовать эти значения в качестве констант в командах SQL,
их нужно заключать в апострофы.
Таблица 8.13. Специальные значения даты/времени
Вводимая строка Допустимые типы Описание
epoch date, timestamp 1970-01-01 00:00:00+00 (точка
отсчёта времени в Unix)
infinity date, timestamp время после максимальной до-
пустимой даты
-infinity date, timestamp время до минимальной допусти-
мой даты
now date, time, timestamp время начала текущей транзак-
ции
today date, timestamp время начала текущих суток
tomorrow date, timestamp время начала следующих суток
yesterday date, timestamp время начала предыдущих су-
ток
allballs time 00:00:00.00 UTC
Для получения текущей даты/времени соответствующего типа можно также использовать следу-
ющие SQL-совместимые функции: CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, LOCALTIME и
LOCALTIMESTAMP. Последние четыре функции принимают необязательное указание точности. (См.
Подраздел 9.9.4.) Заметьте, что во входных строках эти SQL-функции не распознаются.
8.5.2. Вывод даты/времени
132Типы данных
В качестве выходного формата типов даты/времени можно использовать один из четырёх стилей:
ISO 8601, SQL (Ingres), традиционный формат POSTGRES (формат date в Unix) или German. По
умолчанию выбран формат ISO. (Стандарт SQL требует, чтобы использовался именно ISO 8601.
Другой формат называется «SQL» исключительно по историческим причинам.) Примеры всех сти-
лей вывода перечислены в Таблице 8.14. Вообще со значениями типов date и time выводилась бы
только часть даты или времени из показанных примеров, но со стилем POSTGRES значение даты
без времени выводится в формате ISO.
Таблица 8.14. Стили вывода даты/время
Стиль Описание Пример
ISO ISO 8601, стандарт SQL 1997-12-17 07:37:16-08
SQL традиционный стиль 12/17/1997 07:37:16.00 PST
Postgres изначальный стиль Wed Dec 17 07:37:16 1997 PST
German региональный стиль 17.12.1997 07:37:16.00 PST
Примечание
ISO 8601 указывает, что дата должна отделяться от времени буквой T в верхнем реги-
стре. PostgreSQL принимает этот формат при вводе, но при выводе вставляет вместо
T пробел, как показано выше. Это сделано для улучшения читаемости и для совмести-
мости с RFC 3339 и другими СУБД.
В стилях SQL и POSTGRES день выводится перед месяцем, если установлен порядок DMY, а в
противном случае месяц выводится перед днём. (Как этот параметр также влияет на интерпрета-
цию входных значений, описано в Подразделе 8.5.1) Соответствующие примеры показаны в Таб-
лице 8.15.
Таблица 8.15. Соглашения о порядке компонентов даты
Параметр datestyle Порядок при вводе Пример вывода
SQL, DMY день/месяц/год 17/12/1997 15:37:16.00 CET
SQL, MDY месяц/день/год 12/17/1997 07:37:16.00 PST
Postgres, DMY день/месяц/год Wed 17 Dec 07:37:16 1997 PST
Стиль даты/времени пользователь может выбрать с помощью команды SET datestyle, параметра
DateStyle в файле конфигурации postgresql.conf или переменной окружения PGDATESTYLE на сер-
вере или клиенте.
Для большей гибкости при форматировании выводимой даты/времени можно использовать функ-
цию to_char (см. Раздел 9.8).
8.5.3. Часовые пояса
Часовые пояса и правила их применения определяются, как вы знаете, не только по географиче-
ским, но и по политическим соображениям. Часовые пояса во всём мире были более-менее стан-
дартизированы в начале прошлого века, но они продолжают претерпевать изменения, в частности
это касается перехода на летнее время. Для расчёта времени в прошлом PostgreSQL получает ис-
торические сведения о правилах часовых поясов из распространённой базы данных IANA (Olson).
Для будущего времени предполагается, что в заданном часовом поясе будут продолжать действо-
вать последние принятые правила.
PostgreSQL стремится к совместимости со стандартом SQL в наиболее типичных случаях. Однако
стандарт SQL допускает некоторые странности при смешивании типов даты и времени. Две оче-
видные проблемы:
133Типы данных
• Хотя для типа date часовой пояс указать нельзя, это можно сделать для типа time. В реально-
сти это не очень полезно, так как без даты нельзя точно определить смещение при переходе
на летнее время.
• По умолчанию часовой пояс задаётся постоянным смещением от UTC. Это также не позво-
ляет учесть летнее время при арифметических операций с датами, пересекающими границы
летнего времени.
Поэтому мы советуем использовать часовой пояс с типами, включающими и время, и дату. Мы
не рекомендуем использовать тип time with time zone (хотя PostgreSQL поддерживает его для
старых приложений и совместимости со стандартом SQL). Для типов, включающих только дату
или только время, в PostgreSQL предполагается местный часовой пояс.
Все значения даты и времени с часовым поясом представляются внутри в UTC, а при передаче
клиентскому приложению они переводятся в местное время, при этом часовой пояс по умолчанию
определяется параметром конфигурации TimeZone.
PostgreSQL позволяет задать часовой пояс тремя способами:
• Полное название часового пояса, например America/New_York. Все допустимые названия пе-
речислены в представлении pg_timezone_names (см. Раздел 52.90). Определения часовых поя-
сов PostgreSQL берёт из широко распространённой базы IANA, так что имена часовых поясов
PostgreSQL будут воспринимать и многие другие приложения.
• Аббревиатура часового пояса, например PST. Такое определение просто задаёт смещение
от UTC, в отличие от полных названий поясов, которые кроме того подразумевают и пра-
вила перехода на летнее время. Распознаваемые аббревиатуры перечислены в представле-
нии pg_timezone_abbrevs (см. Раздел 52.89). Аббревиатуры можно использовать во вводи-
мых значениях даты/времени и в операторе AT TIME ZONE, но не в параметрах конфигурации
TimeZone и log_timezone.
• В дополнение к полным названиям и аббревиатурам часовых поясов PostgreSQL принимает
указания часового пояса в стиле POSIX: STDсмещение или STDсмещениеDST, где STD — аббре-
виатура пояса, смещение — разница с UTC, а DST — необязательное дополнение, обозначаю-
щее летнее время и добавляющее к смещению ещё один час. Например, если бы обозначение
EST5EDT не являлось названием часового пояса, оно всё равно было бы воспринято и функцио-
нально соответствовало бы поясу североамериканского восточного времени. При такой запи-
си аббревиатура пояса может быть набором букв или обычной строкой, заключённой в угло-
вые скобки ((<>). Когда представлено название пояса с летним временем, при пересчёте вре-
мени будут использоваться правила перехода на летнее время, описанные в базе данных IANA
в файле posixrules. В стандартной инсталляции PostgreSQL файл posixrules соответствует
описанию US/Eastern, так что для указаний часовых поясов в стиле POSIX применяются пра-
вила перехода на летнее время, принятые в США. При необходимости это можно изменить,
заменив файл posixrules.
Вкратце, различие между аббревиатурами и полными названиями заключаются в следующем: аб-
бревиатуры представляют определённый сдвиг от UTC, а полное название подразумевает ещё и
местное правило по переходу на летнее время, то есть, возможно, два сдвига от UTC. Например,
2014-06-04 12:00 America/New_York представляет полдень по местному времени в Нью-Йорк, что
для данного дня было бы летним восточным временем (EDT или UTC-4). Так что 2014-06-04 12:00
EDT обозначает тот же момент времени. Но 2014-06-04 12:00 EST задаёт стандартное восточное
время (UTC-5), не зависящее о того, действовало ли летнее время в этот день.
Мало того, в некоторых юрисдикциях одна и та же аббревиатура часового пояса означала разные
сдвиги UTC в разное время; например, аббревиатура московского времени MSK несколько лет озна-
чала UTC+3, а затем стала означать UTC+4. PostgreSQL обрабатывает такие аббревиатуры в соот-
ветствии с их значениями на заданную дату, но, как и с примером выше EST, это не обязательно
будет соответствовать местному гражданскому времени в этот день.
При этом следует использовать возможность указания часового пояса в стиле POSIX с осторожно-
стью, так как при этом могут быть приняты заведомо неверные данные, потому что разумность
134Типы данных
аббревиатуры никак не проверяется. Например, команда SET TIMEZONE TO FOOBAR0 будет работать
и система примет эту довольно оригинальную аббревиатуру для UTC. Также следует учитывать,
что в названиях часовых поясов POSIX положительные смещения соответствуют сдвигу к западу
Гринвича. Во всех остальных формах PostgreSQL следует соглашению ISO-8601, по которому по-
ложительным смещениям соответствует сдвиг к востоку от Гринвича.
Независимо от формы, регистр в названиях и аббревиатурах часовых поясов не важен. (В
PostgreSQL до версии 8.2 он где-то имел значение, а где-то нет.)
Ни названия, ни аббревиатуры часовых поясов, не зашиты в самом сервере; они считываются из
файлов конфигурации, находящихся в путях .../share/timezone/ и .../share/timezonesets/ от-
носительно каталога установки (см. Раздел B.3).
Параметр конфигурации TimeZone можно установить в postgresql.conf или любым другим стан-
дартным способом, описанным в Главе 19. Часовой пояс может быть также определён следующи-
ми специальными способами:
• Часовой пояс для текущего сеанса можно установить с помощью SQL-команды SET TIME ZONE.
Это альтернативная запись команды SET TIMEZONE TO, более соответствующая SQL-стандарту.
• Если установлена переменная окружения PGTZ, клиенты libpq используют её значение, выпол-
няя при подключении к серверу команду SET TIME ZONE.
8.5.4. Ввод интервалов
Значения типа interval могут быть записаны в следующей расширенной форме:
[@] количество единица [количество единица...] [направление]
где количество — это число (возможно, со знаком); единица — одно из значений: microsecond,
millisecond, second, minute, hour, day, week, month, year, decade, century, millennium (которые
обозначают соответственно микросекунды, миллисекунды, секунды, минуты, часы, дни, недели,
месяцы, годы, десятилетия, века и тысячелетия), либо эти же слова во множественном числе, либо
их сокращения; направление может принимать значение ago (назад) или быть пустым. Знак @ яв-
ляется необязательным. Все заданные величины различных единиц суммируются вместе с учётом
знака чисел. Указание ago меняет знак всех полей на противоположный. Этот синтаксис также ис-
пользуется при выводе интервала, если параметр IntervalStyle имеет значение postgres_verbose.
Количества дней, часов, минут и секунд можно определить, не указывая явно соответствующие
единицы. Например, запись '1 12:59:10' равнозначна '1 day 12 hours 59 min 10 sec'. Сочетание
года и месяца также можно записать через минус; например '200-10' означает то, же что и '200
years 10 months'. (На самом деле только эти краткие формы разрешены стандартом SQL и они
используются при выводе, когда IntervalStyle имеет значение sql_standard.)
Интервалы можно также записывать в виде, определённом в ISO 8601, либо в «формате с кодами»,
описанном в разделе 4.4.3.2 этого стандарта, либо в «альтернативном формате», описанном в раз-
деле 4.4.3.3. Формат с кодами выглядит так:
P количество единица [ количество единица ...] [ T [ количество единица ...]]
Строка должна начинаться с символа P и может включать также T перед временем суток. Допусти-
мые коды единиц перечислены в Таблице 8.16. Коды единиц можно опустить или указать в любом
порядке, но компоненты времени суток должны идти после символа T. В частности, значение кода
M зависит от того, располагается ли он до или после T.
Таблица 8.16. Коды единиц временных интервалов ISO 8601
Код Значение
Y годы
M месяцы (в дате)
W недели
135Типы данных
Код Значение
D дни
H часы
M минуты (во времени)
S секунды
В альтернативном формате:
P [ год-месяц-день ] [ T часы:минуты:секунды ]
строка должна начинаться с P, а T разделяет компоненты даты и времени. Значения выражаются
числами так же, как и в датах ISO 8601.
При записи интервальной константы с указанием полей или присвоении столбцу типа interval стро-
ки с полями, интерпретация непомеченных величин зависит от полей. Например, INTERVAL '1'
YEAR воспринимается как 1 год, а INTERVAL '1' — как 1 секунда. Кроме того, значения «справа»
от меньшего значащего поля, заданного в определении полей, просто отбрасываются. Например,
в записи INTERVAL '1 day 2:03:04' HOUR TO MINUTE будут отброшены секунды, но не день.
Согласно стандарту SQL, все компоненты значения interval должны быть одного знака, и ведущий
минус применяется ко всем компонентам; например, минус в записи '-1 2:03:04' применяется
и к дню, и к часам/минутам/секундам. PostgreSQL позволяет задавать для разных компонентов
разные знаки и традиционно обрабатывает знак каждого компонента в текстовом представлении
отдельно от других, так что в данном случае часы/минуты/секунды будут считаться положитель-
ными. Если параметр IntervalStyle имеет значение sql_standard, ведущий знак применяется
ко всем компонентам (но только если они не содержат знаки явно). В противном случае действу-
ют традиционные правила PostgreSQL. Во избежание неоднозначности рекомендуется добавлять
знак к каждому компоненту с отрицательным значением.
В расширенном формате ввода и в некоторых полях более компактных форматов значения компо-
нентов могут иметь дробные части, например '1.5 week' или '01:02:03.45'. Такое значение при
сохранении пересчитывается в соответствующее число месяцев, дней и секунд. Когда при этом
остаётся дробная часть в месяцах или в днях, она переносится в младший компонент с допущени-
ем, что 1 месяц = 30 дней, а 1 день = 24 часа. Например, значение '1.5 month' будет преобразо-
вано в 1 месяц и 15 дней. В виде дробного числа хранятся и выводятся только секунды.
В Таблице 8.17 показано несколько примеров допустимых вводимых значений типа interval.
Таблица 8.17. Ввод интервалов
Пример Описание
1-2 Стандартный формат SQL: 1 год и 2 месяца
3 4:05:06 Стандартный формат SQL: 3 дня 4 часа 5 минут
6 секунд
1 year 2 months 3 days 4 hours 5 minutes 6 seconds Традиционный формат Postgres: 1 год 2 месяца
3 дня 4 часа 5 минут 6 секунд
P1Y2M3DT4H5M6S «Формат с кодами» ISO 8601: то же значение,
что и выше
P0001-02-03T04:05:06 «Альтернативный формат» ISO 8601: то же зна-
чение, что и выше
Тип interval представлен внутри в виде отдельных значений месяцев, дней и секунд. Это объяс-
няется тем, что число дней в месяце может быть разным, а в сутках может быть и 23, и 25 часов в
дни перехода на летнее/зимнее время. Значения месяцев и дней представлены целыми числами, а
число секунд может быть дробным. Так как интервалы обычно получаются из строковых констант
или при вычитании типов timestamp, этот способ хранения эффективен в большинстве случаев, но
может давать неожиданные результаты:
136Типы данных
SELECT EXTRACT(hours from '80 minutes'::interval);
date_part
-----------
1
SELECT EXTRACT(days from '80 hours'::interval);
date_part
-----------
0
Для корректировки числа дней и часов, когда они выходят за обычные границы, есть специальные
функции justify_days и justify_hours.
8.5.5. Вывод интервалов
Формат вывода типа interval может определяться одним из четырёх стилей: sql_standard,
postgres, postgres_verbose и iso_8601. Выбрать нужный стиль позволяет команда SET
intervalstyle (по умолчанию выбран postgres). Примеры форматов разных стилей показаны в
Таблице 8.18.
Стиль sql_standard выдаёт результат, соответствующий стандарту SQL, если значение интервала
удовлетворяет ограничениям стандарта (и содержит либо только год и месяц, либо только день и
время, и при этом все его компоненты одного знака). В противном случае выводится год-месяц, за
которым идёт дата-время, а в компоненты для однозначности явно добавляются знаки.
Вывод в стиле postgres соответствует формату, который был принят в PostgreSQL до версии 8.4,
когда параметр DateStyle имел значение ISO.
Вывод в стиле postgres_verbose соответствует формату, который был принят в PostgreSQL до вер-
сии 8.4, когда значением параметром DateStyle было не ISO.
Вывод в стиле iso_8601 соответствует «формату с кодами» описанному в разделе 4.4.3.2 формата
ISO 8601.
Таблица 8.18. Примеры стилей вывода интервалов
Стиль Интервал год-месяц Интервал
мя
день-вре- Смешанный
вал
интер-
sql_standard 1-2 3 4:05:06
-1-2 +3 -4:05:06
postgres 1 year 2 mons 3 days 04:05:06
-1 year -2 mons +3 days
-04:05:06
postgres_verbose @ 1 year 2 mons @ 3 days 4 hours 5 mins @ 1 year 2 mons -3 days
6 secs
4 hours 5 mins 6 secs ago
iso_8601 P1Y2M P3DT4H5M6S
P-1Y-2M3DT-4H-5M-6S
8.6. Логический тип
В PostgreSQL есть стандартный SQL-тип boolean; см. Таблицу 8.19. Тип boolean может иметь сле-
дующие состояния: «true», «false» и третье состояние, «unknown», которое представляется SQL-
значением NULL.
Таблица 8.19. Логический тип данных
Имя Размер Описание
boolean 1 байт состояние: истина или ложь
Состояние «true» может задаваться следующими значениями:
TRUE
137Типы данных
't'
'true'
'y'
'yes'
'on'
'1'
Для состояния «false» можно использовать следующие варианты:
FALSE
'f'
'false'
'n'
'no'
'off'
'0'
При этом пробелы в начале и конце строки игнорируются, и регистр так же не имеет значения.
Предпочтительными (совместимыми с SQL) являются варианты TRUE и FALSE.
Пример 8.2 показывает, что значения типа boolean при выводе представляются буквами t и f.
Пример 8.2. Использование типа boolean
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
a |
b
---+---------
t | sic est
f | non est
SELECT * FROM test1 WHERE a;
a |
b
---+---------
t | sic est
8.7. Типы перечислений
Типы перечислений (enum) определяют статический упорядоченный набор значений, так же как
и типы enum, существующие в ряде языков программирования. В качестве перечисления можно
привести дни недели или набор состояний.
8.7.1. Объявление перечислений
Тип перечислений создаются с помощью команды CREATE TYPE, например так:
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
Созданные типы enum можно использовать в определениях таблиц и функций, как и любые другие:
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
name text,
current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
name | current_mood
------+--------------
138Типы данных
Moe | happy
(1 row)
8.7.2. Порядок
Порядок значений в перечислении определяется последовательностью, в которой были указаны
значения при создании типа. Перечисления поддерживаются всеми стандартными операторами
сравнения и связанными агрегатными функциями. Например:
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
name | current_mood
-------+--------------
Moe
| happy
Curly | ok
(2 rows)
SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
name | current_mood
-------+--------------
Curly | ok
Moe
| happy
(2 rows)
SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
name
-------
Larry
(1 row)
8.7.3. Безопасность типа
Все типы перечислений считаются уникальными и поэтому значения разных типов нельзя срав-
нивать. Взгляните на этот пример:
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
num_weeks integer,
happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ОШИБКА: неверное значение для перечисления happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
WHERE person.current_mood = holidays.happiness;
ОШИБКА: оператор не существует: mood = happiness
Если вам действительно нужно сделать что-то подобное, вы можете либо реализовать собственный
оператор, либо явно преобразовать типы в запросе:
SELECT person.name, holidays.num_weeks FROM person, holidays
WHERE person.current_mood::text = holidays.happiness::text;
name | num_weeks
------+-----------
Moe |
4
139Типы данных
(1 row)
8.7.4. Тонкости реализации
В метках значений регистр имеет значение, т. е. 'happy' и 'HAPPY' — не одно и то же. Также в
метках имеют значение пробелы.
Хотя типы-перечисления предназначены прежде всего для статических наборов значений, имеет-
ся возможность добавлять новые значения в существующий тип-перечисление и переименовывать
значения (см. ALTER TYPE). Однако удалять существующие значения из перечисления, а также
изменять их порядок, нельзя — для получения нужного результата придётся удалить и воссоздать
это перечисление.
Значение enum занимает на диске 4 байта. Длина текстовой метки значения ограничена парамет-
ром компиляции NAMEDATALEN; в стандартных сборках PostgreSQL он ограничивает длину 63 бай-
тами.
Сопоставления внутренних значений enum с текстовыми метками хранятся в системном каталоге
pg_enum. Он может быть полезен в ряде случаев.
8.8. Геометрические типы
Геометрические типы данных представляют объекты в двумерном пространстве. Все существую-
щие в PostgreSQL геометрические типы перечислены в Таблице 8.20.
Таблица 8.20. Геометрические типы
Имя Размер Описание Представление
point 16 байт Точка на плоскости (x,y)
line 32 байта Бесконечная прямая (A,B,C)
lseg 32 байта Отрезок ((x1,y1),(x2,y2))
box 32 байта Прямоугольник ((x1,y1),(x2,y2))
path 16+16n байт Закрытый путь (подоб- ((x1,y1),...)
ный многоугольнику)
path 16+16n байт Открытый путь polygon 40+16n байт Многоугольник (подоб- ((x1,y1),...)
ный закрытому пути)
circle 24 байта Окружность
[(x1,y1),...]
<(x,y),r> (центр окруж-
ности и радиус)
Для выполнения различных геометрических операций, в частности масштабирования, вращения
и определения пересечений, PostgreSQL предлагает богатый набор функций и операторов. Они
рассматриваются в Разделе 9.11.
8.8.1. Точки
Точки — это основной элемент, на базе которого строятся все остальные геометрические типы.
Значения типа point записываются в одном из двух форматов:
( x , y )
x , y
где x и y — координаты точки на плоскости, выраженные числами с плавающей точкой.
Выводятся точки в первом формате.
8.8.2. Прямые
140Типы данных
Прямые представляются линейным уравнением Ax + By + C = 0, где A и B не равны 0. Значения
типа line вводятся и выводятся в следующем виде:
( A, B, C )
Кроме того, для ввода может использоваться любая из этих форм:
[ ( x1
( ( x1
( x1
x1
,
,
,
,
y1 ) , ( x2
y1 ) , ( x2
y1 ) , ( x2
y1
,
x2
,
,
,
,
y2 ) ]
y2 ) )
y2 )
y2
где (x1,y1) и (x2,y2) — две различные точки на данной прямой.
8.8.3. Отрезки
Отрезок представляется парой точек, определяющих концы отрезка. Значения типа lseg записы-
ваются в одной из следующих форм:
[ ( x1
( ( x1
( x1
x1
,
,
,
,
y1 ) , ( x2
y1 ) , ( x2
y1 ) , ( x2
y1
,
x2
,
,
,
,
y2 ) ]
y2 ) )
y2 )
y2
где (x1,y1) и (x2,y2) — концы отрезка.
Выводятся отрезки в первом формате.
8.8.4. Прямоугольники
Прямоугольник представляется двумя точками, находящимися в противоположных его углах. Зна-
чения типа box записываются в одной из следующих форм:
( ( x1 , y1 ) , ( x2 , y2 ) )
( x1 , y1 ) , ( x2 , y2 )
x1 , y1
,
x2 , y2
где (x1,y1) и (x2,y2) — противоположные углы прямоугольника.
Выводятся прямоугольники во второй форме.
Во вводимом значении могут быть указаны любые два противоположных угла, но затем они будут
упорядочены, так что внутри сохранятся правый верхний и левый нижний углы, в таком порядке.
8.8.5. Пути
Пути представляют собой списки соединённых точек. Пути могут быть закрытыми, когда подра-
зумевается, что первая и последняя точка в списке соединены, или открытыми, в противном слу-
чае.
Значения типа path записываются в одной из следующих форм:
[ ( x1
( ( x1
( x1
( x1
x1
,
,
,
,
,
y1 ) , ... , ( xn , yn
y1 ) , ... , ( xn , yn
y1 ) , ... , ( xn , yn
y1
, ... ,
xn , yn
y1
, ... ,
xn , yn
) ]
) )
)
)
где точки задают узлы сегментов, составляющих путь. Квадратные скобки ([]) указывают, что путь
открытый, а круглые (()) — закрытый. Когда внешние скобки опускаются, как в показанных выше
последних трёх формах, считается, что путь закрытый.
Пути выводятся в первой или второй форме, в соответствии с типом.
8.8.6. Многоугольники
141Типы данных
Многоугольники представляются списками точек (вершин). Многоугольники похожи на закрытые
пути, но хранятся в другом виде и для работы с ними предназначен отдельный набор функций.
Значения типа polygon записываются в одной из следующих форм:
( ( x1 , y1 ) , ... , ( xn , yn ) )
( x1 , y1 ) , ... , ( xn , yn )
( x1 , y1
, ... ,
xn , yn )
x1 , y1
, ... ,
xn , yn
где точки задают узлы сегментов, образующих границу многоугольника.
Выводятся многоугольники в первом формате.
8.8.7. Окружности
Окружности задаются координатами центра и радиусом. Значения типа circle записываются в
одном из следующих форматов:
< ( x
( ( x
( x
x
,
,
,
,
y ) , r >
y ) , r )
y ) , r
y
, r
где (x,y) — центр окружности, а r — её радиус.
Выводятся окружности в первом формате.
8.9. Типы, описывающие сетевые адреса
PostgreSQL предлагает типы данных для хранения адресов IPv4, IPv6 и MAC, показанные в Таб-
лице 8.21. Для хранения сетевых адресов лучше использовать эти типы, а не простые текстовые
строки, так как PostgreSQL проверяет вводимые значения данных типов и предоставляет специа-
лизированные операторы и функции для работы с ними (см. Раздел 9.12).
Таблица 8.21. Типы, описывающие сетевые адреса
Имя Размер Описание
cidr 7 или 19 байт Сети IPv4 и IPv6
inet 7 или 19 байт Узлы и сети IPv4 и IPv6
macaddr 6 байт MAC-адреса
macaddr8 8 байт MAC-адреса (в формате EUI-64)
При сортировке типов inet и cidr, адреса IPv4 всегда идут до адресов IPv6, в том числе адреса
IPv4, включённые в IPv6 или сопоставленные с ними, например ::10.2.3.4 или ::ffff:10.4.3.2.
8.9.1. inet
Тип inet содержит IPv4- или IPv6-адрес узла и может также содержать его подсеть, всё в одном
поле. Подсеть представляется числом бит, определяющих адрес сети в адресе узла (или «маску
сети»). Если маска сети равна 32 для адреса IPv4, такое значение представляет не подсеть, а опре-
делённый узел. Адреса IPv6 имеют длину 128 бит, поэтому уникальный адрес узла задаётся с мас-
кой 128 бит. Заметьте, что когда нужно, чтобы принимались только адреса сетей, следует исполь-
зовать тип cidr, а не inet.
Вводимые значения такого типа должны иметь формат IP-адрес/y, где IP-адрес — адрес IPv4 или
IPv6, а y — число бит в маске сети. Если компонент /y отсутствует, маска сети считается равной 32
для IPv4 и 128 для IPv6, так что это значение будет представлять один узел. При выводе компонент
/y опускается, если сетевой адрес определяет адрес одного узла.
142Типы данных
8.9.2. cidr
Тип cidr содержит определение сети IPv4 или IPv6. Входные и выходные форматы соответству-
ют соглашениям CIDR (Classless Internet Domain Routing, Бесклассовая межсетевая адресация).
Определение сети записывается в формате IP-адрес/y, где IP-адрес — адрес сети IPv4 или IPv6, а
y — число бит в маске сети. Если y не указывается, это значение вычисляется по старой классовой
схеме нумерации сетей, но при этом оно может быть увеличено, чтобы в него вошли все байты
введённого адреса. Если в сетевом адресе справа от маски сети окажутся биты со значением 1,
он будет считаться ошибочным.
В Таблице 8.22 показаны несколько примеров адресов.
Таблица 8.22. Примеры допустимых значений типа cidr
Вводимое значение cidr Выводимое значение cidr abbrev( cidr)
192.168.100.128/25 192.168.100.128/25 192.168.100.128/25
192.168/24 192.168.0.0/24 192.168.0/24
192.168/25 192.168.0.0/25 192.168.0.0/25
192.168.1 192.168.1.0/24 192.168.1/24
192.168 192.168.0.0/24 192.168.0/24
128.1 128.1.0.0/16 128.1/16
128 128.0.0.0/16 128.0/16
128.1.2 128.1.2.0/24 128.1.2/24
10.1.2 10.1.2.0/24 10.1.2/24
10.1 10.1.0.0/16 10.1/16
10 10.0.0.0/8 10/8
10.1.2.3/32 10.1.2.3/32 10.1.2.3/32
2001:4f8:3:ba::/64 2001:4f8:3:ba::/64 2001:4f8:3:ba::/64
2001:4f8:3:ba:2e0:81ff:fe22:
d1f1/128 2001:4f8:3:ba:2e0:81ff:fe22:
d1f1/128 2001:4f8:3:ba:2e0:81ff:fe22:d1f1
::ffff:1.2.3.0/120 ::ffff:1.2.3.0/120 ::ffff:1.2.3/120
::ffff:1.2.3.0/128 ::ffff:1.2.3.0/128 ::ffff:1.2.3.0/128
8.9.3. Различия inet и cidr
Существенным различием типов данных inet и cidr является то, что inet принимает значения
с ненулевыми битами справа от маски сети, а cidr — нет. Например, значение 192.168.0.1/24
является допустимым для типа inet, но не для cidr.
Подсказка
Если вас не устраивает выходной формат значений inet или cidr, попробуйте функции
host, text и abbrev.
8.9.4. macaddr
Тип macaddr предназначен для хранения MAC-адреса, примером которого является адрес сетевой
платы Ethernet (хотя MAC-адреса применяются и для других целей). Вводимые значения могут
задаваться в следующих форматах:
'08:00:2b:01:02:03'
'08-00-2b-01-02-03'
143Типы данных
'08002b:010203'
'08002b-010203'
'0800.2b01.0203'
'0800-2b01-0203'
'08002b010203'
Все эти примеры определяют один и тот же адрес. Шестнадцатеричные цифры от a до f могут быть
и в нижнем, и в верхнем регистре. Выводятся MAC-адреса всегда в первой форме.
Стандарт IEEE 802-2001 считает канонической формой MAC-адресов вторую (с минусами), а
в первой (с двоеточиями) предполагает обратный порядок бит, так что 08-00-2b-01-02-03 =
01:00:4D:08:04:0C. В настоящее время этому соглашению практически никто не следует, и уместно
оно было только для устаревших сетевых протоколов (таких как Token Ring). PostgreSQL не меняет
порядок бит и во всех принимаемых форматах подразумевается традиционный порядок LSB.
Последние пять входных форматов не описаны ни в каком стандарте.
8.9.5. macaddr8
Тип macaddr8 хранит MAC-адреса в формате EUI-64, применяющиеся, например, для аппаратных
адресов плат Ethernet (хотя MAC-адреса используются и для других целей). Этот тип может при-
нять и 6-байтовые, и 8-байтовые адреса MAC и сохраняет их в 8 байтах. MAC-адреса, заданные
в 6-байтовом формате, хранятся в формате 8 байт, а 4-ый и 5-ый байт содержат FF и FE, соответ-
ственно. Заметьте, что для IPv6 используется модифицированный формат EUI-64, в котором 7-ой
бит должен быть установлен в 1 после преобразования из EUI-48. Для выполнения этого измене-
ния предоставляется функция macaddr8_set7bit. Вообще говоря, этот тип принимает любые стро-
ки, состоящие из пар шестнадцатеричных цифр (выровненных по границам байт), которые могут
согласованно разделяться одинаковыми символами ':', '-' или '.'. Шестнадцатеричных цифр
должно быть либо 16 (8 байт), либо 12 (6 байт). Ведущие и замыкающие пробелы игнорируются.
Ниже показаны примеры допустимых входных строк:
'08:00:2b:01:02:03:04:05'
'08-00-2b-01-02-03-04-05'
'08002b:0102030405'
'08002b-0102030405'
'0800.2b01.0203.0405'
'0800-2b01-0203-0405'
'08002b01:02030405'
'08002b0102030405'
Во всех этих примерах задаётся один и тот же адрес. Для цифр с a по f принимаются буквы и в
верхнем, и в нижнем регистре. Вывод всегда представляется в первом из показанных форматов.
Последние шесть входных форматов, показанных выше, не являются стандартизированными. Что-
бы преобразовать традиционный 48-битный MAC-адрес в формате EUI-48 в модифицированный
формат EUI-64 для включения в состав адреса IPv6 в качестве адреса узла, используйте функцию
macaddr8_set7bit:
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
macaddr8_set7bit
-------------------------
0a:00:2b:ff:fe:01:02:03
(1 row)
8.10. Битовые строки
Битовые строки представляют собой последовательности из 1 и 0. Их можно использовать для
хранения или отображения битовых масок. В SQL есть два битовых типа: bit(n) и bit varying(n),
где n — положительное целое число.
144Типы данных
Длина значения типа bit должна в точности равняться n; при попытке сохранить данные длиннее
или короче произойдёт ошибка. Данные типа bit varying могут иметь переменную длину, но не
превышающую n; строки большей длины не будут приняты. Запись bit без указания длины равно-
значна записи bit(1), тогда как bit varying без указания длины подразумевает строку неогра-
ниченной длины.
Примечание
При попытке привести значение битовой строки к типу bit(n), оно будет усечено или
дополнено нулями справа до длины ровно n бит, ошибки при этом не будет. Подобным
образом, если явно привести значение битовой строки к типу bit varying(n), она будет
усечена справа, если её длина превышает n бит.
Синтаксис констант битовых строк описан в Подразделе 4.1.2.5, а все доступные битовые опера-
торы и функции перечислены в Разделе 9.6.
Пример 8.3. Использование битовых строк
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
ОШИБКА:
длина битовой строки (2) не соответствует типу bit(3)
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
a | b
-----+-----
101 | 00
100 | 101
Для хранения битовой строки используется по 1 байту для каждой группы из 8 бит, плюс 5 или
8 байт дополнительно в зависимости от длины строки (но длинные строки могут быть сжаты или
вынесены отдельно, как описано в Разделе 8.3 применительно к символьным строкам).
8.11. Типы, предназначенные для текстового поиска
PostgreSQL предоставляет два типа данных для поддержки полнотекстового поиска. Текстовым
поиском называется операция анализа набора документов с текстом на естественном языке, в ре-
зультате которой находятся фрагменты, наиболее соответствующие запросу. Тип tsvector пред-
ставляет документ в виде, оптимизированном для текстового поиска, а tsquery представляет за-
прос текстового поиска в подобном виде. Более подробно это описывается в Главе 12, а все свя-
занные функции и операторы перечислены в Разделе 9.13.
8.11.1. tsvector
Значение типа tsvector содержит отсортированный список неповторяющихся лексем, т. е. слов,
нормализованных так, что все словоформы сводятся к одной (подробнее это описано в Главе 12).
Сортировка и исключение повторяющихся слов производится автоматически при вводе значения,
как показано в этом примере:
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
tsvector
----------------------------------------------------
'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
Для представления в виде лексем пробелов или знаков препинания их нужно заключить в апо-
строфы:
145Типы данных
SELECT $$the lexeme '
' contains spaces$$::tsvector;
tsvector
-------------------------------------------
'
' 'contains' 'lexeme' 'spaces' 'the'
(В данном и следующих примерах мы используем строку в долларах, чтобы не дублировать все
апострофы в таких строках.) При этом включаемый апостроф или обратную косую черту нужно
продублировать:
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
tsvector
------------------------------------------------
'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
Также для лексем можно указать их целочисленные позиции:
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11
rat:12'::tsvector;
tsvector
---------------------------------------------------------------------------
'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12
'sat':4
Позиция обычно указывает положение исходного слова в документе. Информация о расположе-
нии слов затем может использоваться для оценки близости. Позиция может задаваться числом
от 1 до 16383; большие значения просто заменяются на 16383. Если для одной лексемы дважды
указывается одно положение, такое повторение отбрасывается.
Лексемам, для которых заданы позиции, также можно назначить вес, выраженный буквами A, B,
C или D. Вес D подразумевается по умолчанию и поэтому он не показывается при выводе:
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
tsvector
----------------------------
'a':1A 'cat':5 'fat':2B,4C
Веса обычно применяются для отражения структуры документа, например для придания особого
значения словам в заголовке по сравнению со словами в обычном тексте. Назначенным весам
можно сопоставить числовые приоритеты в функциях ранжирования результатов.
Важно понимать, что тип tsvector сам по себе не выполняет нормализацию слов; предполагается,
что в сохраняемом значении слова уже нормализованы приложением. Например:
SELECT 'The Fat Rats'::tsvector;
tsvector
--------------------
'Fat' 'Rats' 'The'
Для большинства англоязычных приложений приведённые выше слова будут считаться ненорма-
лизованными, но для tsvector это не важно. Поэтому исходный документ обычно следует обрабо-
тать функцией to_tsvector, нормализующей слова для поиска:
SELECT to_tsvector('english', 'The Fat Rats');
to_tsvector
-----------------
'fat':2 'rat':3
И это подробнее описано в Главе 12.
8.11.2. tsquery
Значение tsquery содержит искомые лексемы, объединяемые логическими операторами & (И), |
(ИЛИ) и ! (НЕ), а также оператором поиска фраз <-> (ПРЕДШЕСТВУЕТ). Также допускается вари-
146Типы данных
ация оператора ПРЕДШЕСТВУЕТ вида <N>, где N — целочисленная константа, задающая расстоя-
ние между двумя искомыми лексемами. Запись оператора <-> равнозначна <1>.
Для группировки операторов могут использоваться скобки. Без скобок эти операторы имеют раз-
ные приоритеты, в порядке убывания: ! (НЕ), <-> (ПРЕДШЕСТВУЕТ), & (И) и | (ИЛИ).
Несколько примеров:
SELECT 'fat & rat'::tsquery;
tsquery
---------------
'fat' & 'rat'
SELECT 'fat & (rat | cat)'::tsquery;
tsquery
---------------------------
'fat' & ( 'rat' | 'cat' )
SELECT 'fat & rat & ! cat'::tsquery;
tsquery
------------------------
'fat' & 'rat' & !'cat'
Лексемам в tsquery можно дополнительно сопоставить буквы весов, при этом они будут соответ-
ствовать только тем лексемам в tsvector, которые имеют какой-либо из этих весов:
SELECT 'fat:ab & cat'::tsquery;
tsquery
------------------
'fat':AB & 'cat'
Кроме того, в лексемах tsquery можно использовать знак * для поиска по префиксу:
SELECT 'super:*'::tsquery;
tsquery
-----------
'super':*
Этот запрос найдёт все слова в tsvector, начинающиеся с приставки «super».
Апострофы в лексемах этого типа можно использовать так же, как и в лексемах в tsvector; и так
же, как и для типа tsvector, необходимая нормализация слова должна выполняться до приведения
значения к типу tsquery. Для такой нормализации удобно использовать функцию to_tsquery:
SELECT to_tsquery('Fat:ab & Cats');
to_tsquery
------------------
'fat':AB & 'cat'
Заметьте, что функция to_tsquery будет обрабатывать префиксы подобно другим словам, поэтому
следующее сравнение возвращает true:
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
?column?
----------
t
так как postgres преобразуется стеммером в postgr:
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
to_tsvector | to_tsquery
---------------+------------
147Типы данных
'postgradu':1 | 'postgr':*
и эта приставка находится в преобразованной форме слова postgraduate.
8.12. Тип UUID
Тип данных uuid сохраняет универсальные уникальные идентификаторы (Universally Unique
Identifiers, UUID), определённые в RFC 4122, ISO/IEC 9834-8:2005 и связанных стандартах. (В неко-
торых системах это называется GUID, глобальным уникальным идентификатором.) Этот иденти-
фикатор представляет собой 128-битное значение, генерируемое специальным алгоритмом, прак-
тически гарантирующим, что этим же алгоритмом оно не будет получено больше нигде в мире.
Таким образом, эти идентификаторы будут уникальными и в распределённых системах, а не толь-
ко в единственной базе данных, как значения генераторов последовательностей.
UUID записывается в виде последовательности шестнадцатеричных цифр в нижнем регистре, раз-
делённых знаками минуса на несколько групп, в таком порядке: группа из 8 цифр, за ней три груп-
пы из 4 цифр и, наконец, группа из 12 цифр, что в сумме составляет 32 цифры и представляет 128
бит. Пример UUID в этом стандартном виде:
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
PostgreSQL также принимает альтернативные варианты: цифры в верхнем регистре, стандартную
запись, заключённую в фигурные скобки, запись без минусов или с минусами, разделяющими лю-
бые группы из четырёх цифр. Например:
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
(a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11)
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
(a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11)
Выводится значение этого типа всегда в стандартном виде.
В PostgreSQL встроены функции хранения и сравнения идентификаторов UUID, но нет внутренней
функции генерирования UUID, потому что не существует какого-то единственного алгоритма, под-
ходящего для всех приложений. Сгенерировать UUID можно с помощью дополнительного модуля
uuid-ossp, в котором реализованы несколько стандартных алгоритмов, а можно воспользоваться
модулем pgcrypto, где тоже есть функция генерирования случайных UUID. Кроме того, можно сде-
лать это в клиентском приложении или в другой библиотеке, подключённой на стороне сервера.
8.13. Тип XML
Тип xml предназначен для хранения XML-данных. Его преимущество по сравнению с обычным ти-
пом text в том, что он проверяет вводимые значения на допустимость по правилам XML и для
работы с ним есть типобезопасные функции; см. Раздел 9.14. Для использования этого типа дис-
трибутив должен быть скомпилирован в конфигурации configure --with-libxml.
Тип xml может сохранять правильно оформленные «документы», в соответствии со стандартом
XML, а также фрагменты «содержимого», описанные как содержимое элементов в стандарте XML.
Другими словами, это означает, что фрагменты содержимого могут содержать несколько элемен-
тов верхнего уровня или текстовых узлов. Определить, является ли определённое значение ти-
па xml полным документом или фрагментом содержимого, позволяет выражение xmlvalue IS
DOCUMENT.
8.13.1. Создание XML-значений
Чтобы получить значение типа xml из текстовой строки, используйте функцию xmlparse:
XMLPARSE ( ( DOCUMENT | CONTENT ) value)
Примеры:
148Типы данных
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</
chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
Хотя в стандарте SQL описан только один способ преобразования текстовых строк в XML-значения,
специфический синтаксис PostgreSQL:
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
тоже допустим.
Тип xml не проверяет вводимые значения по схеме DTD (Document Type Declaration, Объявления
типа документа),даже если в них присутствуют ссылка на DTD. В настоящее время в PostgreSQL
также нет встроенной поддержки других разновидностей схем, например XML Schema.
Обратная операция, получение текстовой строки из xml, выполняется с помощью функции
xmlserialize:
XMLSERIALIZE ( ( DOCUMENT | CONTENT ) значение AS тип )
Здесь допустимый тип — character, character varying или text (или их псевдонимы). И в данном
случае стандарт SQL предусматривает только один способ преобразования xml в тип текстовых
строк, но PostgreSQL позволяет просто привести значение к нужному типу.
При преобразовании текстовой строки в тип xml или наоборот без использования функций
XMLPARSE и XMLSERIALIZE, выбор режима DOCUMENT или CONTENT определяется параметром конфи-
гурации сеанса «XML option», установить который можно следующей стандартной командой:
SET XML OPTION ( DOCUMENT | CONTENT );
или такой командой в духе PostgreSQL:
SET xmloption TO ( DOCUMENT | CONTENT );
По умолчанию этот параметр имеет значение CONTENT, так что допускаются все формы XML-дан-
ных.
Примечание
Когда параметр XML option имеет значение по умолчанию, текстовые строки нельзя
напрямую привести к типу xml, если они содержат объявление типа документа, так как
такие объявления не допускаются во фрагментах. Для выполнения преобразования в
таких случаях следует использовать XMLPARSE или изменить параметр XML option.
8.13.2. Обработка кодировки
Если на стороне сервера и клиента и в XML-данных используются разные кодировки символов, с
этим могут возникать проблемы. Когда запросы передаются на сервер, а их результаты возвраща-
ются клиенту в обычном текстовом режиме, PostgreSQL преобразует все передаваемые текстовые
данные в кодировку для соответствующей стороны; см. Раздел 23.3. В том числе это происходит
и со строковыми представлениями XML-данных, подобными тем, что показаны в предыдущих при-
мерах. Обычно это означает, что объявления кодировки, содержащиеся в XML-данных, могут не
соответствовать действительности, когда текстовая строка преобразуется из одной кодировки в
другую при передаче данных между клиентом и сервером, так как подобные включённые в дан-
ные объявления не будут изменены автоматически. Для решения этой проблемы объявления ко-
дировки, содержащиеся в текстовых строках, вводимых в тип xml, просто игнорируются и пред-
полагается, что XML-содержимое представлено в текущей кодировке сервера. Как следствие, для
правильной обработки таких строк с XML-данными клиент должен передавать их в своей текущей
кодировке. Для сервера не важно, будет ли клиент для этого преобразовывать документы в свою
кодировку, или изменит её, прежде чем передавать ему данные. При выводе значения типа xml
149Типы данных
не содержат объявления кодировки, а клиент должен предполагать, что все данные поступают в
его текущей кодировке.
Если параметры запроса передаются на сервер и он возвращает результаты клиенту в двоичном
режиме, кодировка символов не преобразуется, так что возникает другая ситуация. В этом случае
объявление кодировки в XML принимается во внимание, а если его нет, то предполагается, что
данные закодированы в UTF-8 (это соответствует стандарту XML; заметьте, что PostgreSQL не под-
держивает UTF-16). При выводе в данные будет добавлено объявление кодировки, выбранной на
стороне клиента (но если это UTF-8, объявление будет опущено).
Само собой, XML-данные в PostgreSQL будут обрабатываться гораздо эффективнее, когда и в XML-
данных, и на стороне клиента, и на стороне сервера используется одна кодировка. Так как внут-
ри XML-данные представляются в UTF-8, оптимальный вариант, когда на сервере также выбрана
кодировка UTF-8.
Внимание
Некоторые XML-функции могут вовсе не работать с данными не-ASCII, если кодиров-
ка сервера не UTF-8. В частности, это известная особенность функций xmltable() и
xpath().
8.13.3. Обращение к XML-значениям
Тип xml отличается от других тем, что для него не определены никакие операторы сравнения, так
как чётко определённого и универсального алгоритма сравнения XML-данных не существует. Од-
но из следствий этого — нельзя отфильтровать строки таблицы, сравнив столбец xml с искомым
значением. Поэтому обычно XML-значения должны дополняться отдельным ключевым полем, на-
пример ID. Можно также сравнивать XML-значения, преобразовав их сначала в текстовые строки,
но заметьте, что с учётом специфики XML-данных этот метод практически бесполезен.
Из-за отсутствия операторов сравнения для типа xml, для столбца этого типа также нельзя создать
индекс. Поэтому, когда требуется быстрый поиск в XML данных, обойти это ограничение можно,
приведя данные к типу текстовой строки и проиндексировав эти строки, либо проиндексировав
выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск выполнялся по
индексированному выражению.
Для ускорения поиска в XML-данных также можно использовать функции полнотекстового поиска
в PostgreSQL. Однако это требует определённой подготовки данных, что дистрибутив PostgreSQL
пока не поддерживает.
8.14. Типы JSON
Типы JSON предназначены для хранения данных JSON (JavaScript Object Notation, Запись объекта
JavaScript) согласно стандарту RFC 7159. Такие данные можно хранить и в типе text, но типы JSON
лучше тем, что проверяют, соответствует ли вводимое значение формату JSON. Для работы с ними
есть также несколько специальных функций и операторов; см. Раздел 9.15.
Существуют два типа данных JSON: json и jsonb. Они принимают на вход почти одинаковые на-
боры значений, но основное их отличие в эффективности. Тип json сохраняет точную копию вве-
дённого текста, которую функции обработки должны разбирать заново при каждом выполнении,
тогда как данные jsonb сохраняются в разобранном двоичном формате, что несколько замедляет
ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора
текста. Кроме того, jsonb поддерживает индексацию, что тоже может быть очень полезно.
Так как тип json сохраняет точную копию введённого текста, он сохраняет семантически незна-
чащие пробелы между элементами, а также порядок ключей в JSON-объектах. И если JSON-объ-
ект внутри содержит повторяющиеся ключи, этот тип сохранит все пары ключ/значение. (Функ-
150Типы данных
ции обработки будут считать действительной последнюю пару.) Тип jsonb, напротив, не сохраняет
пробелы, порядок ключей и значения с дублирующимися ключами. Если во входных данных ока-
зываются дублирующиеся ключи, сохраняется только последнее значение.
Для большинства приложений предпочтительнее хранить данные JSON в типе jsonb (если нет
особых противопоказаний, например важны прежние предположения о порядке ключей объектов).
PostgreSQL позволяет использовать только одну кодировку символов в базе данных, поэтому дан-
ные JSON не будут полностью соответствовать спецификации, если кодировка базы данных не
UTF-8. При этом нельзя будет вставить символы, непредставимые в кодировке сервера, и наоборот,
допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8.
RFC 7159 разрешает включать в строки JSON спецпоследовательности Unicode в виде \uXXXX. В
функцию ввода для типа json эти спецпоследовательности допускаются вне зависимости от коди-
ровки базы данных, и проверяется только правильность их синтаксиса (за \u должны следовать
четыре шестнадцатеричных цифры). Однако, функция ввода для типа jsonb более строгая: она не
допускает спецпоследовательности Unicode для не-ASCII символов (символов после U+007F), если
кодировка базы данных не UTF8. Тип jsonb также не принимает \u0000 (так как это значение не
может быть представлено в типе text PostgreSQL), и требует, чтобы суррогатные пары Unicode
использовались для представления символов вне основной многоязыковой плоскости (BMP) пра-
вильно. Корректные спецпоследовательности Unicode преобразуются для хранения в соответству-
ющий символ ASCII или UTF8 (это подразумевает сворачивание суррогатных пар в один символ).
Примечание
Многие из функций обработки JSON, описанные в Разделе  9.15, преобразуют спец-
последовательности Unicode в обычные символы, поэтому могут выдавать подобные
ошибки, даже если им на вход поступает тип json, а не jsonb. То, что функция ввода в
тип json не производит этих проверок, можно считать историческим артефактом, хотя
это и позволяет просто сохранять (но не обрабатывать) в JSON спецкоды Unicode в базе
данных с кодировкой не UTF8. Вообще же, по возможности следует избегать смешения
спецкодов Unicode в JSON с кодировкой базой данных не UTF8.
При преобразовании вводимого текста JSON в тип jsonb, примитивные типы, описанные в RFC
7159, по сути отображаются в собственные типы PostgreSQL как показано в Таблице 8.23. Таким
образом, к содержимому типа jsonb предъявляются некоторые дополнительные требования, про-
диктованные ограничениями представления нижележащего типа данных, которые не распростра-
няются ни на тип json, ни на формат JSON вообще. В частности, тип jsonb не принимает числа,
выходящие за диапазон типа данных PostgreSQL numeric, тогда как с json такого ограничения
нет. Такие ограничения, накладываемые реализацией, допускаются согласно RFC 7159. Однако,
на практике такие проблемы более вероятны в других реализациях, так как обычно примитивный
тип JSON number представляется в виде числа с плавающей точкой двойной точности IEEE 754
(что RFC 7159 явно признаёт и допускает). При использовании JSON в качестве формата обмена
данными с такими системами следует учитывать риски потери точности чисел, хранившихся в
PostgreSQL.
И напротив, как показано в таблице, есть некоторые ограничения в формате ввода примитивных
типов JSON, не актуальные для соответствующих типов PostgreSQL.
Таблица 8.23. Примитивные типы JSON и соответствующие им типы PostgreSQL
Примитивный тип JSON Тип PostgreSQL Замечания
string text \u0000 не допускается, как не
ASCII символ, если кодировка
базы данных не UTF8
number numeric Значения NaN и infinity не до-
пускаются
151Типы данных
Примитивный тип JSON Тип PostgreSQL Замечания
boolean boolean Допускаются только варианты
true и false (в нижнем реги-
стре)
null (нет) NULL в SQL имеет другой смысл
8.14.1. Синтаксис вводимых и выводимых значений JSON
Синтаксис ввода/вывода типов данных JSON соответствует стандарту RFC 7159.
Примеры допустимых выражений с типом json (или jsonb):
-- Простое скалярное/примитивное значение
-- Простыми значениями могут быть числа, строки в кавычках, true, false или null
SELECT '5'::json;
-- Массив из нуля и более элементов (элементы могут быть разных типов)
SELECT '[1, 2, "foo", null]'::json;
-- Объект, содержащий пары ключей и значений
-- Заметьте, что ключи объектов — это всегда строки в кавычках
SELECT '("bar": "baz", "balance": 7.77, "active": false)'::json;
-- Массивы и объекты могут вкладываться произвольным образом
SELECT '("foo": [true, "bar"], "tags": ("a": 1, "b": null))'::json;
Как было сказано ранее, когда значение JSON вводится и затем выводится без дополнительной
обработки, тип json выводит тот же текст, что поступил на вход, а jsonb не сохраняет семантиче-
ски незначащие детали, такие как пробелы. Например, посмотрите на эти различия:
SELECT '("bar": "baz", "balance": 7.77, "active":false)'::json;
json
-------------------------------------------------
("bar": "baz", "balance": 7.77, "active":false)
(1 row)
SELECT '("bar": "baz", "balance": 7.77, "active":false)'::jsonb;
jsonb
--------------------------------------------------
("bar": "baz", "active": false, "balance": 7.77)
(1 row)
Первая семантически незначимая деталь, заслуживающая внимания: с jsonb числа выводятся по
правилам нижележащего типа numeric. На практике это означает, что числа, заданные в записи
с E, будут выведены без неё, например:
SELECT '("reading": 1.230e-5)'::json, '("reading": 1.230e-5)'::jsonb;
json
|
jsonb
-----------------------+-------------------------
("reading": 1.230e-5) | ("reading": 0.00001230)
(1 row)
Однако, как видно из этого примера, jsonb сохраняет конечные нули дробного числа, хотя они и
не имеют семантической значимости, в частности для проверки на равенство.
8.14.2. Эффективная организация документов JSON
Представлять данные в JSON можно гораздо более гибко, чем в традиционной реляционной моде-
ли данных, что очень привлекательно там, где нет жёстких условий. И оба этих подхода вполне
могут сосуществовать и дополнять друг друга в одном приложении. Однако, даже для приложений,
152Типы данных
которым нужна максимальная гибкость, рекомендуется, чтобы документы JSON имели некоторую
фиксированную структуру. Эта структура обычно не навязывается жёстко (хотя можно деклара-
тивно диктовать некоторые бизнес-правила), но когда она предсказуема, становится гораздо про-
ще писать запросы, которые извлекают полезные данные из набора «документов» (информации)
в таблице.
Данные JSON, как и данные любых других типов, хранящиеся в таблицах, находятся под контро-
лем механизма параллельного доступа. Хотя хранить большие документы вполне возможно, не
забывайте, что при любом изменении устанавливается блокировка всей строки (на уровне стро-
ки). Поэтому для оптимизации блокировок транзакций, изменяющих данные, стоит ограничить
размер документов JSON разумными пределами. В идеале каждый документ JSON должен собой
представлять атомарный информационный блок, который, согласно бизнес-логике, нельзя разде-
лить на меньшие, индивидуально изменяемые блоки.
8.14.3. Проверки на вхождение и существование jsonb
Проверка вхождения — важная особенность типа jsonb, не имеющая аналога для типа json. Эта
проверка определяет, входит ли один документ jsonb в другой. В следующих примерах возвраща-
ется истинное значение (кроме упомянутых исключений):
-- Простые скалярные/примитивные значения включают только одно идентичное значение:
SELECT '"foo"'::jsonb @> '"foo"'::jsonb;
-- Массив с правой стороны входит в массив слева:
SELECT '[1, 2, 3]'::jsonb @> '[1, 3]'::jsonb;
-- Порядок элементов в массиве не важен, поэтому это условие тоже выполняется:
SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;
-- А повторяющиеся элементы массива не имеют значения:
SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;
-- Объект с одной парой справа входит в объект слева:
SELECT '("product": "PostgreSQL", "version": 9.4, "jsonb": true)'::jsonb @>
'("version": 9.4)'::jsonb;
-- Массив справа не считается входящим в
-- массив слева, хотя в последний и вложен подобный массив:
SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb; -- выдаёт false
-- Но если добавить уровень вложенности, проверка на вхождение выполняется:
SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;
-- Аналогично, это вхождением не считается:
SELECT '("foo": ("bar": "baz"))'::jsonb @> '("bar": "baz")'::jsonb;
-- выдаёт false
-- Ключ с пустым объектом на верхнем уровне входит в объект с таким ключом:
SELECT '("foo": ("bar": "baz"))'::jsonb @> '("foo": ())'::jsonb;
Общий принцип этой проверки в том, что входящий объект должен соответствовать объекту, со-
держащему его, по структуре и данным, возможно, после исключения из содержащего объекта
лишних элементов массива или пар ключ/значение. Но помните, что порядок элементов массива
для проверки на вхождение не имеет значения, а повторяющиеся элементы массива считаются
только один раз.
В качестве особого исключения для требования идентичности структур, массив может содержать
примитивное значение:
-- В этот массив входит примитивное строковое значение:
SELECT '["foo", "bar"]'::jsonb @> '"bar"'::jsonb;
153Типы данных
-- Это исключение действует только в одну сторону -- здесь вхождения нет:
SELECT '"bar"'::jsonb @> '["bar"]'::jsonb; -- выдаёт false
Для типа jsonb введён также оператор существования, который является вариацией на тему
вхождения: он проверяет, является ли строка (заданная в виде значения text) ключом объекта
или элементом массива на верхнем уровне значения jsonb. В следующих примерах возвращается
истинное значение (кроме упомянутых исключений):
-- Строка существует в качестве элемента массива:
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';
-- Строка существует в качестве ключа объекта:
SELECT '("foo": "bar")'::jsonb ? 'foo';
-- Значения объектов не рассматриваются:
SELECT '("foo": "bar")'::jsonb ? 'bar'; -- выдаёт false
-- Как и вхождение, существование определяется на верхнем уровне:
SELECT '("foo": ("bar": "baz"))'::jsonb ? 'bar'; -- выдаёт false
-- Строка считается существующей, если она соответствует примитивной строке JSON:
SELECT '"foo"'::jsonb ? 'foo';
Объекты JSON для проверок на существование и вхождение со множеством ключей или элементов
подходят больше, чем массивы, так как, в отличие от массивов, они внутри оптимизируются для
поиска, и поиск элемента не будет линейным.
Подсказка
Так как вхождение в JSON проверяется с учётом вложенности, правильно написан-
ный запрос может заменить явную выборку внутренних объектов. Например, предпо-
ложим, что у нас есть столбец doc, содержащий объекты на верхнем уровне, и боль-
шинство этих объектов содержит поля tags с массивами вложенных объектов. Данный
запрос найдёт записи, в которых вложенные объекты содержат ключи "term":"paris"
и "term":"food", и при этом пропустит такие ключи, находящиеся вне массива tags:
SELECT doc->'site_name' FROM websites
WHERE doc @> '("tags":[("term":"paris"), ("term":"food")])';
Этого же результата можно добиться, например, так:
SELECT doc->'site_name' FROM websites
WHERE doc->'tags' @> '[("term":"paris"), ("term":"food")]';
Но данный подход менее гибкий и часто также менее эффективный.
С другой стороны, оператор существования JSON не учитывает вложенность: он будет
искать заданный ключ или элемент массива только на верхнем уровне значения JSON.
Различные операторы вхождения и существования, а также все другие операторы и функции для
работы с JSON документированы в Разделе 9.15.
8.14.4. Индексация jsonb
Для эффективного поиска ключей или пар ключ/значение в большом количестве документов jsonb
можно успешно применять индексы GIN. Для этого предоставляются два «класса операторов» GIN,
предлагающие выбор между производительностью и гибкостью.
Класс операторов GIN по умолчанию для jsonb поддерживает запросы с операторами существо-
вания ключа на верхнем уровне (?, ?& и ?|) и оператором существования пути/значения (@>). (По-
154Типы данных
дробнее семантика, реализуемая этими операторами, описана в Таблице 9.44.) Пример создания
индекса с этим классом операторов:
CREATE INDEX idxgin ON api USING GIN (jdoc);
Дополнительный класс операторов GIN jsonb_path_ops поддерживает индексацию только для опе-
ратора @>. Пример создания индекса с этим классом операторов:
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
Рассмотрим пример таблицы, в которой хранятся документы JSON, получаемые от сторонней веб-
службы, с документированным определением схемы. Типичный документ:
(
"guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
"name": "Angela Barton",
"is_active": true,
"company": "Magnafone",
"address": "178 Howard Place, Gulf, Washington, 702",
"registered": "2009-11-07T08:53:22 +08:00",
"latitude": 19.793713,
"longitude": 86.513373,
"tags": [
"enim",
"aliquip",
"qui"
]
)
Мы сохраняем эти документы в таблице api, в столбце jdoc типа jsonb. Если по этому столбцу
создаётся GIN-индекс, он может применяться в подобных запросах:
-- Найти документы, в которых ключ "company" имеет значение "Magnafone"
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @> '("company": "Magnafone")';
Однако, в следующих запросах он не будет использоваться, потому что, несмотря на то, что опера-
тор ? — индексируемый, он применяется не к индексированному столбцу jdoc непосредственно:
-- Найти документы, в которых ключ "tags" содержит ключ или элемент массива "qui"
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc -> 'tags' ? 'qui';
И всё же, правильно применяя индексы выражений, в этом запросе можно задействовать индекс.
Если запрос определённых элементов в ключе "tags" выполняется часто, вероятно стоит опреде-
лить такой индекс:
CREATE INDEX idxgintags ON api USING GIN ((jdoc -> 'tags'));
Теперь предложение WHERE jdoc -> 'tags' ? 'qui' будет выполняться как применение индек-
сируемого оператора ? к индексируемому выражению jdoc -> 'tags'. (Подробнее об индексах
выражений можно узнать в Разделе 11.7.)
Ещё один подход к использованию проверок на существование:
-- Найти документы, в которых ключ "tags" содержит элемент массива "qui"
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @> '("tags": ["qui"])';
Этот запрос может задействовать простой GIN-индекс по столбцу jdoc. Но заметьте, что такой
индекс будет хранить копии всех ключей и значений в поле jdoc, тогда как индекс выражения из
предыдущего примера хранит только данные внутри объекта с ключом tags. Хотя подход с простым
индексом гораздо более гибкий (так как он поддерживает запросы по любому ключу), индексы
конкретных выражений скорее всего будут меньше и быстрее, чем простые индексы.
Класс операторов jsonb_path_ops поддерживает только запросы с оператором @>, но зато он зна-
чительно производительнее класса по умолчанию jsonb_ops. Индекс jsonb_path_ops обычно го-
раздо меньше индекса jsonb_ops для тех же данных и более точен при поиске, особенно, если
155Типы данных
запросы обращаются к ключам, часто встречающимся в данных. Таким образом, с ним операции
поиска выполняются гораздо лучше, чем с классом операторов по умолчанию.
Техническое различие между GIN-индексами jsonb_ops и jsonb_path_ops состоит в том, что для
первых создаются независимые элементы индекса для каждого ключа/значения в данных, тогда
1
как для вторых создаются элементы только для значений. По сути, каждый элемент индекса
jsonb_path_ops представляет собой хеш значения и ключа(ей), приводящего к нему; например,
при индексации ("foo": ("bar": "baz")) будет создан один элемент индекса с хешем, рассчитан-
ным по всем трём значениям: foo, bar и baz. Таким образом, проверка на вхождение этой структу-
ры будет использовать крайне точный поиск по индексу, но определить, является ли foo ключом,
с помощью такого индекса нельзя. С другой стороны, индекс jsonb_ops создаст три отдельных
элемента индекса, представляющих foo, bar и baz по отдельности; для выполнения проверки на
вхождение будут проверены строки таблицы, содержащие все эти три значения. Хотя GIN-индексы
позволяют вычислить AND довольно эффективно, такой поиск всё же будет менее точным и более
медленным, чем равнозначный поиск с jsonb_path_ops, особенно если любое одно из этих трёх
значений содержится в большом количестве строк.
Недостаток класса jsonb_path_ops заключается в том, что он не учитывает в индексе структуры
JSON, не содержащие никаких значений ("a": ()). Для поиска по документам, содержащих такие
структуры, потребуется выполнить полное сканирование индекса, что довольно долго, поэтому
jsonb_path_ops не очень подходит для приложений, часто выполняющих такие запросы.
Тип jsonb также поддерживает индексы btree и hash. Они полезны, только если требуется прове-
рять равенство JSON-документов в целом. Порядок сортировки btree для типа jsonb редко имеет
большое значение, но для полноты он приводится ниже:
Объект > Массив > Логическое значение > Число > Строка > Null
Объект с n парами > Объект с n - 1 парами
Массив с n элементами > Массив с n - 1 элементами
Объекты с равным количеством пар сравниваются в таком порядке:
ключ-1, значение-1, ключ-2 ...
Заметьте, что ключи объектов сравниваются согласно порядку при хранении; в частности, из-за
того, что короткие ключи хранятся перед длинными, результаты могут оказаться несколько не
интуитивными:
( "aa": 1, "c": 1) > ("b": 1, "d": 1)
Массивы с равным числом элементом упорядочиваются аналогично:
элемент-1, элемент-2 ...
Примитивные значения JSON сравниваются по тем же правилам сравнения, что и нижележащие
типы данных PostgreSQL. Строки сравниваются с учётом порядка сортировки по умолчанию в те-
кущей базе данных.
8.14.5. Трансформации
Для различных процедурных языков представлены дополнительные расширения, реализующие
трансформации для типа jsonb.
Расширения для PL/Perl называются jsonb_plperl и jsonb_plperlu. Когда они используются, зна-
чения jsonb отображаются в соответствующие структуры Perl: массивы, хеши или скаляры.
Расширения для PL/Python называются jsonb_plpythonu, jsonb_plpython2u и jsonb_plpython3u
(принятое в PL/Python соглашение об именовании описано в Разделе 46.1). Когда они используют-
1
Поэтому понятие «значение» включает и элементы массивов, хотя в терминологии JSON иногда элементы массивов считаются отличными от значений
внутри объектов.
156Типы данных
ся, значения jsonb отображаются в соответствующие структуры Python: массивы, хеши или ска-
ляры.
8.15. Массивы
PostgreSQL позволяет определять столбцы таблицы как многомерные массивы переменной длины.
Элементами массивов могут быть любые встроенные или определённые пользователями базовые
типы, перечисления, составные типы, типы-диапазоны или домены.
8.15.1. Объявления типов массивов
Чтобы проиллюстрировать использовать массивов, мы создадим такую таблицу:
CREATE TABLE sal_emp (
name
text,
pay_by_quarter integer[],
schedule
text[][]
);
Как показано, для объявления типа массива к названию типа элементов добавляются квадратные
скобки ([]). Показанная выше команда создаст таблицу sal_emp со столбцами типов text (name),
одномерный массив с элементами integer (pay_by_quarter), представляющий квартальную зар-
плату работников, и двухмерный массив с элементами text (schedule), представляющий недель-
ный график работника.
Команда CREATE TABLE позволяет также указать точный размер массивов, например так:
CREATE TABLE tictactoe (
squares
integer[3][3]
);
Однако текущая реализация игнорирует все указанные размеры, т. е. фактически размер массива
остаётся неопределённым.
Текущая реализация также не ограничивает число размерностей. Все элементы массивов счита-
ются одного типа, вне зависимости от его размера и числа размерностей. Поэтому явно указывать
число элементов или размерностей в команде CREATE TABLE имеет смысл только для документи-
рования, на механизм работы с массивом это не влияет.
Для объявления одномерных массивов можно применять альтернативную запись с ключевым сло-
вом ARRAY, соответствующую стандарту SQL. Столбец pay_by_quarter можно было бы определить
так:
pay_by_quarter
integer ARRAY[4],
Или без указания размера массива:
pay_by_quarter
integer ARRAY,
Заметьте, что и в этом случае PostgreSQL не накладывает ограничения на фактический размер
массива.
8.15.2. Ввод значения массива
Чтобы записать значение массива в виде буквальной константы, заключите значения элементов
в фигурные скобки и разделите их запятыми. (Если вам знаком C, вы найдёте, что это похоже на
синтаксис инициализации структур в C.) Вы можете заключить значение любого элемента в двой-
ные кавычки, а если он содержит запятые или фигурные скобки, это обязательно нужно сделать.
(Подробнее это описано ниже.) Таким образом, общий формат константы массива выглядит так:
'( значение1 разделитель значение2 разделитель ... )'
где разделитель — символ, указанный в качестве разделителя в соответствующей записи в таблице
pg_type. Для стандартных типов данных, существующих в дистрибутиве PostgreSQL, разделителем
является запятая (,), за исключением лишь типа box, в котором разделитель —точка с запятой
157Типы данных
(;). Каждое значение здесь — это либо константа типа элемента массива, либо вложенный массив.
Например, константа массива может быть такой:
'((1,2,3),(4,5,6),(7,8,9))'
Эта константа определяет двухмерный массив 3x3, состоящий из трёх вложенных массивов целых
чисел.
Чтобы присвоить элементу массива значение NULL, достаточно просто написать NULL (регистр
символов при этом не имеет значения). Если же требуется добавить в массив строку, содержащую
«NULL», это слово нужно заключить в двойные кавычки.
(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай
констант, описанных в Подразделе  4.1.2.7. Константа изначально воспринимается как строка и
передаётся процедуре преобразования вводимого массива. При этом может потребоваться явно
указать целевой тип.)
Теперь мы можем показать несколько операторов INSERT:
INSERT INTO sal_emp
VALUES ('Bill',
'(10000, 10000, 10000, 10000)',
'(("meeting", "lunch"), ("training", "presentation"))');
INSERT INTO sal_emp
VALUES ('Carol',
'(20000, 25000, 25000, 25000)',
'(("breakfast", "consulting"), ("meeting", "lunch"))');
Результат двух предыдущих команд:
SELECT * FROM sal_emp;
name |
pay_by_quarter
|
schedule
-----+-------------------------+--------------------------------------
Bill |(10000,10000,10000,10000)|((meeting,lunch),(training,presentation))
Carol|(20000,25000,25000,25000)|((breakfast,consulting),(meeting,lunch))
(2 rows)
В многомерных массивов число элементов в каждой размерности должно быть одинаковым; в про-
тивном случае возникает ошибка. Например:
INSERT INTO sal_emp
VALUES ('Bill',
'(10000, 10000, 10000, 10000)',
'(("meeting", "lunch"), ("meeting"))');
ОШИБКА: для многомерных массивов должны задаваться выражения
с соответствующими размерностями
Также можно использовать синтаксис конструктора ARRAY:
INSERT INTO sal_emp
VALUES ('Bill',
ARRAY[10000, 10000, 10000, 10000],
ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);
INSERT INTO sal_emp
VALUES ('Carol',
ARRAY[20000, 25000, 25000, 25000],
ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
Заметьте, что элементы массива здесь — это простые SQL-константы или выражения; и поэтому,
например строки будут заключаться в одинарные апострофы, а не в двойные, как в буквальной
константе массива. Более подробно конструктор ARRAY обсуждается в Подразделе 4.2.12.
158Типы данных
8.15.3. Обращение к массивам
Добавив данные в таблицу, мы можем перейти к выборкам. Сначала мы покажем, как получить
один элемент массива. Этот запрос получает имена сотрудников, зарплата которых изменилась
во втором квартале:
SELECT name FROM sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2];
name
-------
Carol
(1 row)
Индексы элементов массива записываются в квадратных скобках. По умолчанию в PostgreSQL дей-
ствует соглашение о нумерации элементов массива с 1, то есть в массиве из n элементов первым
считается array[1], а последним — array[n].
Этот запрос выдаёт зарплату всех сотрудников в третьем квартале:
SELECT pay_by_quarter[3] FROM sal_emp;
pay_by_quarter
----------------
10000
25000
(2 rows)
Мы также можем получать обычные прямоугольные срезы массива, то есть подмассивы. Срез мас-
сива обозначается как нижняя-граница:верхняя-граница для одной или нескольких размерностей.
Например, этот запрос получает первые пункты в графике Билла в первые два дня недели:
SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';
schedule
------------------------
((meeting),(training))
(1 row)
Если одна из размерностей записана в виде среза, то есть содержит двоеточие, тогда срез распро-
страняется на все размерности. Если при этом для размерности указывается только одно число
(без двоеточия), в срез войдут элемент от 1 до заданного номера. Например, в этом примере [2]
будет равнозначно [1:2]:
SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';
schedule
-------------------------------------------
((meeting,lunch),(training,presentation))
(1 row)
Во избежание путаницы с обращением к одному элементу, срезы лучше всегда записывать явно
для всех измерений, например [1:2][1:1] вместо [2][1:1].
Значения нижняя-граница и/или верхняя-граница в указании среза можно опустить; опущенная
граница заменяется нижним или верхним пределом индексов массива. Например:
SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';
schedule
------------------------
((lunch),(presentation))
(1 row)
159Типы данных
SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';
schedule
------------------------
((meeting),(training))
(1 row)
Выражение обращения к элементу массива возвратит NULL, если сам массив или одно из выраже-
ний индексов элемента равны NULL. Значение NULL также возвращается, если индекс выходит за
границы массива (это не считается ошибкой). Например, если schedule в настоящее время имеет
размерности [1:3][1:2], результатом обращения к schedule[3][3] будет NULL. Подобным обра-
зом, при обращении к элементу массива с неправильным числом индексов возвращается NULL,
а не ошибка.
Аналогично, NULL возвращается при обращении к срезу массива, если сам массив или одно из
выражений, определяющих индексы элементов, равны NULL. Однако, в других случаях, например,
когда границы среза выходят за рамки массива, возвращается не NULL, а пустой массив (с раз-
мерностью 0). (Так сложилось исторически, что в этом срезы отличаются от обращений к обычным
элементам.) Если запрошенный срез пересекает границы массива, тогда возвращается не NULL,
а срез, сокращённый до области пересечения.
Текущие размеры значения массива можно получить с помощью функции array_dims:
SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';
array_dims
------------
[1:2][1:2]
(1 row)
array_dims выдаёт результат типа text, что удобно скорее для людей, чем для программ. Размеры
массива также можно получить с помощью функций array_upper и array_lower, которые возвра-
щают соответственно верхнюю и нижнюю границу для указанной размерности:
SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';
array_upper
-------------
2
(1 row)
array_length возвращает число элементов в указанной размерности массива:
SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';
array_length
--------------
2
(1 row)
cardinality возвращает общее число элементов массива по всем измерениям. Фактически это
число строк, которое вернёт функция unnest:
SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';
cardinality
-------------
4
(1 row)
8.15.4. Изменение массивов
160Типы данных
Значение массива можно заменить полностью так:
UPDATE sal_emp SET pay_by_quarter = '(25000,25000,27000,27000)'
WHERE name = 'Carol';
или используя синтаксис ARRAY:
UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
WHERE name = 'Carol';
Также можно изменить один элемент массива:
UPDATE sal_emp SET pay_by_quarter[4] = 15000
WHERE name = 'Bill';
или срез:
UPDATE sal_emp SET pay_by_quarter[1:2] = '(27000,27000)'
WHERE name = 'Carol';
При этом в указании среза может быть опущена нижняя-граница и/или верхняя-граница, но только
для массива, отличного от NULL, и имеющего ненулевую размерность (иначе неизвестно, какие
граничные значения должны подставляться вместо опущенных).
Сохранённый массив можно расширить, определив значения ранее отсутствовавших в нём эле-
ментов. При этом все элементы, располагающиеся между существовавшими ранее и новыми, при-
нимают значения NULL. Например, если массив myarray содержит 4 элемента, после присвоения
значения элементу myarray[6] его длина будет равна 6, а myarray[5] будет содержать NULL. В
настоящее время подобное расширение поддерживается только для одномерных, но не многомер-
ных массивов.
Определяя элементы по индексам, можно создавать массивы, в которых нумерация элементов мо-
жет начинаться не с 1. Например, можно присвоить значение выражению myarray[-2:7] и таким
образом создать массив, в котором будут элементы с индексами от -2 до 7.
Значения массива также можно сконструировать с помощью оператора конкатенации, ||:
SELECT ARRAY[1,2] || ARRAY[3,4];
?column?
-----------
(1,2,3,4)
(1 row)
SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
?column?
---------------------
((5,6),(1,2),(3,4))
(1 row)
Оператор конкатенации позволяет вставить один элемент в начало или в конец одномерного мас-
сива. Он также может принять два N-мерных массива или массивы размерностей N и N+1.
Когда в начало или конец одномерного массива вставляется один элемент, в образованном в ре-
зультате массиве будет та же нижняя граница, что и в массиве-операнде. Например:
SELECT array_dims(1 || '[0:1]=(2,3)'::int[]);
array_dims
------------
[0:2]
(1 row)
SELECT array_dims(ARRAY[1,2] || 3);
array_dims
161Типы данных
------------
[1:3]
(1 row)
Когда складываются два массива одинаковых размерностей, в результате сохраняется нижняя гра-
ница внешней размерности левого операнда. Выходной массив включает все элементы левого опе-
ранда, после которых добавляются все элементы правого. Например:
SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
array_dims
------------
[1:5]
(1 row)
SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
array_dims
------------
[1:5][1:2]
(1 row)
Когда к массиву размерности N+1 спереди или сзади добавляется N-мерный массив, он вставляется
аналогично тому, как в массив вставляется элемент (это было описано выше). Любой N-мерный
массив по сути является элементом во внешней размерности массива, имеющего размерность N
+1. Например:
SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
array_dims
------------
[1:3][1:2]
(1 row)
Массив также можно сконструировать с помощью функций array_prepend, array_append и
array_cat. Первые две функции поддерживают только одномерные массивы, а array_cat поддер-
живает и многомерные. Несколько примеров:
SELECT array_prepend(1, ARRAY[2,3]);
array_prepend
---------------
(1,2,3)
(1 row)
SELECT array_append(ARRAY[1,2], 3);
array_append
--------------
(1,2,3)
(1 row)
SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
array_cat
-----------
(1,2,3,4)
(1 row)
SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
array_cat
---------------------
((1,2),(3,4),(5,6))
(1 row)
SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
162Типы данных
array_cat
---------------------
((5,6),(1,2),(3,4))
В простых случаях описанный выше оператор конкатенации предпочтительнее непосредственного
вызова этих функций. Однако, так как оператор конкатенации перегружен для решения всех трёх
задач, возможны ситуации, когда лучше применить одну из этих функций во избежание неодно-
значности. Например, рассмотрите:
SELECT ARRAY[1, 2] || '(3, 4)';
?column?
-----------
(1,2,3,4)
-- нетипизированная строка воспринимается как массив
SELECT ARRAY[1, 2] || '7';
ERROR: malformed array literal: "7" -- как и эта
SELECT ARRAY[1, 2] || NULL;
?column?
----------
(1,2)
(1 row) -- как и буквальный NULL
SELECT array_append(ARRAY[1, 2], NULL);
array_append
--------------
(1,2,NULL) -- это могло иметься в виду на самом деле
В показанных примерах анализатор запроса видит целочисленный массив с одной стороны опера-
тора конкатенации и константу неопределённого типа с другой. Согласно своим правилам разре-
шения типа констант, он полагает, что она имеет тот же тип, что и другой операнд — в данном
случае, целочисленный массив. Поэтому предполагается, что оператор конкатенации здесь пред-
ставляет функцию array_cat, а не array_append. Если это решение оказывается неверным, его
можно скорректировать, приведя константу к типу элемента массива; однако может быть лучше
явно использовать функцию array_append.
8.15.5. Поиск значений в массивах
Чтобы найти значение в массиве, необходимо проверить все его элементы. Это можно сделать
вручную, если вы знаете размер массива. Например:
SELECT * FROM sal_emp WHERE pay_by_quarter[1]
pay_by_quarter[2]
pay_by_quarter[3]
pay_by_quarter[4]
=
=
=
=
10000 OR
10000 OR
10000 OR
10000;
Однако с большим массивами этот метод становится утомительным, и к тому же он не работает,
когда размер массива неизвестен. Альтернативный подход описан в Разделе  9.23. Показанный
выше запрос можно было переписать так:
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
А так можно найти в таблице строки, в которых массивы содержат только значения, равные 10000:
SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
Кроме того, для обращения к
generate_subscripts. Например так:
элементам
массива
SELECT * FROM
(SELECT pay_by_quarter,
generate_subscripts(pay_by_quarter, 1) AS s
163
можно
использовать
функциюТипы данных
FROM sal_emp) AS foo
WHERE pay_by_quarter[s] = 10000;
Эта функция описана в Таблице 9.59.
Также искать в массиве значения можно, используя оператор &&, который проверяет, перекрыва-
ется ли левый операнд с правым. Например:
SELECT * FROM sal_emp WHERE pay_by_quarter && ARRAY[10000];
Этот и другие операторы для работы с массивами описаны в Разделе 9.18. Он может быть ускорен
с помощью подходящего индекса, как описано в Разделе 11.2.
Вы также можете искать определённые значения в массиве, используя функции array_position
и array_positions. Первая функция возвращает позицию первого вхождения значения в массив,
а вторая — массив позиций всех его вхождений. Например:
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
array_positions
-----------------
2
SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
array_positions
-----------------
(1,4,8)
Подсказка
Массивы — это не множества; необходимость поиска определённых элементов в масси-
ве может быть признаком неудачно сконструированной базы данных. Возможно, вме-
сто массива лучше использовать отдельную таблицу, строки которой будут содержать
данные элементов массива. Это может быть лучше и для поиска, и для работы с боль-
шим количеством элементов.
8.15.6. Синтаксис вводимых и выводимых значений массива
Внешнее текстовое представление значения массива состоит из записи элементов, интерпрети-
руемых по правилам ввода/вывода для типа элемента массива, и оформления структуры массива.
Оформление состоит из фигурных скобок (( и )), окружающих значение массива, и знаков-разде-
лителей между его элементами. В качестве знака-разделителя обычно используется запятая (,),
но это может быть и другой символ; он определяется параметром typdelim для типа элемента мас-
сива. Для стандартных типов данных, существующих в дистрибутиве PostgreSQL, разделителем
является запятая (,), за исключением лишь типа box, в котором разделитель — точка с запятой
(;). В многомерном массиве у каждой размерности (ряд, плоскость, куб и т. д.) есть свой уровень
фигурных скобок, а соседние значения в фигурных скобках на одном уровне должны отделяться
разделителями.
Функция вывода массива заключает значение элемента в кавычки, если это пустая строка или
оно содержит фигурные скобки, знаки-разделители, кавычки, обратную косую черту, пробельный
символ или это текст NULL. Кавычки и обратная косая черта, включённые в такие значения, преоб-
разуются в спецпоследовательность с обратной косой чертой. Для числовых типов данных можно
рассчитывать на то, что значения никогда не будут выводиться в кавычках, но для текстовых типов
следует быть готовым к тому, что выводимое значение массива может содержать кавычки.
По умолчанию нижняя граница всех размерностей массива равна одному. Чтобы представить мас-
сивы с другими нижними границами, перед содержимым массива можно указать диапазоны ин-
дексов. Такое оформление массива будет содержать квадратные скобки ([]) вокруг нижней и верх-
164Типы данных
ней границ каждой размерности с двоеточием (:) между ними. За таким указанием размерности
следует знак равно (=). Например:
SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
FROM (SELECT '[1:1][-2:-1][3:5]=(((1,2,3),(4,5,6)))'::int[] AS f1) AS ss;
e1 | e2
----+----
1 | 6
(1 row)
Процедура вывода массива включает в результат явное указание размерностей, только если ниж-
няя граница в одной или нескольких размерностях отличается от 1.
Если в качестве значения элемента задаётся NULL (в любом регистре), этот элемент считается рав-
ным непосредственно NULL. Если же оно включает кавычки или обратную косую черту, элемен-
ту присваивается текстовая строка «NULL». Кроме того, для обратной совместимости с версиями
PostgreSQL до 8.2, параметр конфигурации array_nulls можно выключить (присвоив ему off), что-
бы строки NULL не воспринимались как значения NULL.
Как было показано ранее, записывая значение массива, любой его элемент можно заключить в
кавычки. Это нужно делать, если при разборе значения массива без кавычек возможна неодно-
значность. Например, в кавычки необходимо заключать элементы, содержащие фигурные скобки,
запятую (или разделитель, определённый для данного типа), кавычки, обратную косую черту, а
также пробельные символы в начале или конце строки. Пустые строки и строки, содержащие од-
но слово NULL, также нужно заключать в кавычки. Чтобы включить кавычки или обратную косую
черту в значение, заключённое в кавычки, добавьте обратную косую черту перед таким символом.
С другой стороны, чтобы обойтись без кавычек, таким экранированием можно защитить все сим-
волы в данных, которые могут быть восприняты как часть синтаксиса массива.
Перед открывающей и после закрывающей скобки можно добавлять пробельные символы. Пробе-
лы также могут окружать каждую отдельную строку значения. Во всех случаях такие пробельные
символы игнорируются. Однако все пробелы в строках, заключённых в кавычки, или окружённые
не пробельными символами, напротив, учитываются.
Подсказка
Записывать значения массивов в командах SQL часто бывает удобнее с помощью кон-
структора ARRAY (см. Подраздел 4.2.12). В ARRAY отдельные значения элементов запи-
сываются так же, как если бы они не были членами массива.
8.16. Составные типы
Составной тип представляет структуру табличной строки или записи; по сути это просто список
имён полей и соответствующих типов данных. PostgreSQL позволяет использовать составные типы
во многом так же, как и простые типы. Например, в определении таблицы можно объявить столбец
составного типа.
8.16.1. Объявление составных типов
Ниже приведены два простых примера определения составных типов:
CREATE TYPE complex AS (
r
double precision,
i
double precision
);
CREATE TYPE inventory_item AS (
name
text,
165Типы данных
supplier_id
price
integer,
numeric
);
Синтаксис очень похож на CREATE TABLE, за исключением того, что он допускает только названия
полей и их типы, какие-либо ограничения (такие как NOT NULL) в настоящее время не поддержи-
ваются. Заметьте, что ключевое слово AS здесь имеет значение; без него система будет считать,
что подразумевается другой тип команды CREATE TYPE, и выдаст неожиданную синтаксическую
ошибку.
Определив такие типы, мы можем использовать их в таблицах:
CREATE TABLE on_hand (
item
inventory_item,
count
integer
);
INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);
или функциях:
CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;
SELECT price_extension(item, 10) FROM on_hand;
Всякий раз, когда создаётся таблица, вместе с ней автоматически создаётся составной тип. Этот
тип представляет тип строки таблицы, и его именем становится имя таблицы. Например, при вы-
полнении команды:
CREATE TABLE inventory_item (
name
text,
supplier_id
integer REFERENCES suppliers,
price
numeric CHECK (price > 0)
);
в качестве побочного эффекта будет создан составной тип inventory_item, в точности соответ-
ствующий тому, что был показан выше, и использовать его можно так же. Однако заметьте, что
в текущей реализации есть один недостаток: так как с составным типом не могут быть связаны
ограничения, то описанные в определении таблицы ограничения не применяются к значениям
составного типа вне таблицы. (Чтобы обойти этот недостаток, создайте домен поверх составного
типа и добавьте желаемые ограничения в виде ограничений CHECK для данного домена.)
8.16.2. Конструирование составных значений
Чтобы записать значение составного типа в виде текстовой константы, его поля нужно заключить
в круглые скобки и разделить их запятыми. Значение любого поля можно заключить в кавычки,
а если оно содержит запятые или скобки, это делать обязательно. (Подробнее об этом говорится
ниже.) Таким образом, в общем виде константа составного типа записывается так:
'( значение1 , значение2 , ... )'
Например, эта запись:
'("fuzzy dice",42,1.99)'
будет допустимой для описанного выше типа inventory_item. Чтобы присвоить NULL одному из
полей, в соответствующем месте в списке нужно оставить пустое место. Например, эта константа
задаёт значение NULL для третьего поля:
'("fuzzy dice",42,)'
Если же вместо NULL требуется вставить пустую строку, нужно записать пару кавычек:
'("",42,)'
166Типы данных
Здесь в первом поле окажется пустая строка, а в третьем — NULL.
(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай
констант, описанных в Подразделе  4.1.2.7. Константа изначально воспринимается как строка и
передаётся процедуре преобразования составного типа. При этом может потребоваться явно ука-
зать тип, к которому будет приведена константа.)
Значения составных типов также можно конструировать, используя синтаксис выражения ROW. В
большинстве случаев это значительно проще, чем записывать значения в строке, так как при этом
не нужно беспокоиться о вложенности кавычек. Мы уже обсуждали этот метод ранее:
ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)
Ключевое слово ROW на самом деле может быть необязательным, если в выражении определяются
несколько полей, так что эту запись можно упростить до:
('fuzzy dice', 42, 1.99)
('', 42, NULL)
Синтаксис выражения ROW более подробно рассматривается в Подразделе 4.2.13.
8.16.3. Обращение к составным типам
Чтобы обратиться к полю столбца составного типа, после имени столбца нужно добавить точку и
имя поля, подобно тому, как указывается столбец после имени таблицы. На самом деле, эти обра-
щения неотличимы, так что часто бывает необходимо использовать скобки, чтобы команда была
разобрана правильно. Например, можно попытаться выбрать поле столбца из тестовой таблицы
on_hand таким образом:
SELECT item.name FROM on_hand WHERE item.price > 9.99;
Но это не будет работать, так как согласно правилам SQL имя item здесь воспринимается как имя
таблицы, а не столбца в таблице on_hand. Поэтому этот запрос нужно переписать так:
SELECT (item).name FROM on_hand WHERE (item).price > 9.99;
либо указать также и имя таблицы (например, в запросе с многими таблицами), примерно так:
SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;
В результате объект в скобках будет правильно интерпретирован как ссылка на столбец item, из
которого выбирается поле.
При выборке поля из значения составного типа также возможны подобные синтаксические казу-
сы. Например, чтобы выбрать одно поле из результата функции, возвращающей составное значе-
ние, потребуется написать что-то подобное:
SELECT (my_func(...)).field FROM ...
Без дополнительных скобок в этом запросе произойдёт синтаксическая ошибка.
Специальное имя поля * означает «все поля»; подробнее об этом рассказывается в Подразде-
ле 8.16.5.
8.16.4. Изменение составных типов
Ниже приведены примеры правильных команд добавления и изменения значений составных столб-
цов. Первые команды иллюстрируют добавление или изменение всего столбца:
INSERT INTO mytab (complex_col) VALUES((1.1,2.2));
UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;
В первом примере опущено ключевое слово ROW, а во втором оно есть; присутствовать или отсут-
ствовать оно может в обоих случаях.
167Типы данных
Мы можем изменить также отдельное поле составного столбца:
UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;
Заметьте, что при этом не нужно (и на самом деле даже нельзя) заключать в скобки имя столбца,
следующее сразу за предложением SET, но в ссылке на тот же столбец в выражении, находящемся
по правую сторону знака равенства, скобки обязательны.
И мы также можем указать поля в качестве цели команды INSERT:
INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);
Если при этом мы не укажем значения для всех полей столбца, оставшиеся поля будут заполнены
значениями NULL.
8.16.5. Использование составных типов в запросах
С составными типами в запросах связаны особые правила синтаксиса и поведение. Эти правила
образуют полезные конструкции, но они могут быть неочевидными, если не понимать стоящую за
ними логику.
В PostgreSQL ссылка на имя таблицы (или её псевдоним) в запросе по сути является ссылкой на
составное значение текущей строки в этой таблице. Например, имея таблицу inventory_item, по-
казанную выше, мы можем написать:
SELECT c FROM inventory_item c;
Этот запрос выдаёт один столбец с составным значением, и его результат может быть таким:
c
------------------------
("fuzzy dice",42,1.99)
(1 row)
Заметьте, однако, что простые имена сопоставляются сначала с именами столбцов, и только потом
с именами таблиц, так что такой результат получается только потому, что в таблицах запроса не
оказалось столбца с именем c.
Обычную запись полного имени столбца вида имя_таблицы.имя_столбца можно понимать как при-
менение выбора поля к составному значению текущей строки таблицы. (Из соображений эффек-
тивности на самом деле это реализовано по-другому.)
Когда мы пишем
SELECT c.* FROM inventory_item c;
то, согласно стандарту SQL, мы должны получить содержимое таблицы, развёрнутое в отдельные
столбцы:
name
| supplier_id | price
------------+-------------+-------
fuzzy dice |
42 | 1.99
(1 row)
как с запросом
SELECT c.name, c.supplier_id, c.price FROM inventory_item c;
PostgreSQL применяет такое развёртывание для любых выражений с составными значениями, хо-
тя как показано выше, необходимо заключить в скобки значение, к которому применяется .*, если
только это не простое имя таблицы. Например, если myfunc() — функция, возвращающая состав-
ной тип со столбцами a, b и c, то эти два запроса выдадут одинаковый результат:
SELECT (myfunc(x)).* FROM some_table;
SELECT (myfunc(x)).a, (myfunc(x)).b, (myfunc(x)).c FROM some_table;
168Типы данных
Подсказка
PostgreSQL осуществляет развёртывание столбцов фактически переводя первую форму
во вторую. Таким образом, в данном примере myfunc() будет вызываться три раза для
каждой строки и с одним, и с другим синтаксисом. Если это дорогостоящая функция,
и вы хотите избежать лишних вызовов, можно использовать такой запрос:
SELECT m.* FROM some_table, LATERAL myfunc(x) AS m;
Размещение вызова функции в элементе FROM LATERAL гарантирует, что она будет вы-
зываться для строки не более одного раза. Конструкция m.* так же разворачивается
в m.a, m.b, m.c, но теперь эти переменные просто ссылаются на выходные значения
FROM. (Ключевое слово LATERAL здесь является необязательным, но мы добавили его,
чтобы подчеркнуть, что функция получает x из some_table.)
Запись составное_значение.* приводит к такому развёртыванию столбцов, когда она фигурирует
на верхнем уровне выходного списка SELECT, в списке RETURNING команд INSERT/UPDATE/DELETE, в
предложении VALUES или в конструкторе строки. Во всех других контекстах (включая вложенные
в одну из этих конструкций), добавление .* к составному значению не меняет это значение, так
как это воспринимается как «все столбцы» и поэтому выдаётся то же составное значение. Напри-
мер, если функция somefunc() принимает в качестве аргумента составное значение, эти запросы
равносильны:
SELECT somefunc(c.*) FROM inventory_item c;
SELECT somefunc(c) FROM inventory_item c;
В обоих случаях текущая строка таблицы inventory_item передаётся функции как один аргумент
с составным значением. И хотя дополнение .* в этих случаях не играет роли, использовать его
считается хорошим стилем, так как это ясно указывает на использование составного значения. В
частности анализатор запроса воспримет c в записи c.* как ссылку на имя или псевдоним таблицы,
а не имя столбца, что избавляет от неоднозначности; тогда как без .* неясно, означает ли c имя
таблицы или имя столбца, и на самом деле при наличии столбца с именем c будет выбрано второе
прочтение.
Эту концепцию демонстрирует и следующий пример, все запросы в котором действуют одинаково:
SELECT * FROM inventory_item c ORDER BY c;
SELECT * FROM inventory_item c ORDER BY c.*;
SELECT * FROM inventory_item c ORDER BY ROW(c.*);
Все эти предложения ORDER BY обращаются к составному значению строки, вследствие чего стро-
ки сортируются по правилам, описанным в Подразделе 9.23.6. Однако, если в inventory_item со-
держится столбец с именем c, первый запрос будет отличаться от других, так как в нём выполнит-
ся сортировка только по данному столбцу. С показанными выше именами столбцов предыдущим
запросам также равнозначны следующие:
SELECT * FROM inventory_item c ORDER BY ROW(c.name, c.supplier_id, c.price);
SELECT * FROM inventory_item c ORDER BY (c.name, c.supplier_id, c.price);
(В последнем случае используется конструктор строки, в котором опущено ключевое слово ROW.)
Другая особенность синтаксиса, связанная с составными значениями, состоит в том, что мы мо-
жем использовать функциональную запись для извлечения поля составного значения. Это легко
можно объяснить тем, что записи поле(таблица) и таблица.поле взаимозаменяемы. Например,
следующие запросы равнозначны:
SELECT c.name FROM inventory_item c WHERE c.price > 1000;
SELECT name(c) FROM inventory_item c WHERE price(c) > 1000;
Более того, если у нас есть функция, принимающая один аргумент составного типа, мы можем
вызвать её в любой записи. Все эти запросы равносильны:
SELECT somefunc(c) FROM inventory_item c;
169Типы данных
SELECT somefunc(c.*) FROM inventory_item c;
SELECT c.somefunc FROM inventory_item c;
Эта равнозначность записи с полем и функциональной записи позволяет использовать с составны-
ми типами функции, реализующие «вычисляемые поля». При этом приложению, использующему
последний из предыдущих запросов, не нужно знать, что фактически somefunc — не настоящий
столбец таблицы.
Подсказка
Учитывая такое поведение, будет неразумно давать функции, принимающей один ар-
гумент составного типа, то же имя, что и одному из полей данного составного типа. В
случае неоднозначности прочтение имени поля будет выбрано при использовании син-
таксиса обращения к полю, а прочтение имени функции — если используется синтак-
сис вызова функции. Однако в PostgreSQL до 11 версии всегда выбиралось прочтение
имени поля, если только синтаксис вызова не подталкивал к прочтению имени функ-
ции. Чтобы принудительно выбрать прочтение имени функции, в предыдущих версиях
надо было дополнить это имя схемой, то есть написать схема.функция(составное_зна-
чение).
8.16.6. Синтаксис вводимых и выводимых значений составного ти-
па
Внешнее текстовое представление составного значения состоит из записи элементов, интерпре-
тируемых по правилам ввода/вывода для соответствующих типов полей, и оформления структуры
составного типа. Оформление состоит из круглых скобок (( и )) окружающих всё значение, и за-
пятых (,) между его элементами. Пробельные символы вне скобок игнорируются, но внутри они
считаются частью соответствующего элемента и могут учитываться или не учитываться в зависи-
мости от правил преобразования вводимых данных для типа этого элемента. Например, в записи:
'(
42)'
пробелы будут игнорироваться, если соответствующее поле имеет целочисленный тип, но не тек-
стовый.
Как было показано ранее, записывая составное значение, любой его элемент можно заключить в
кавычки. Это нужно делать, если при разборе этого значения без кавычек возможна неоднознач-
ность. Например, в кавычки нужно заключать элементы, содержащие скобки, кавычки, запятую
или обратную косую черту. Чтобы включить в поле составного значения, заключённое в кавычки,
такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную ко-
сую черту. (Кроме того, продублированные кавычки в значении поля, заключённого в кавычки,
воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно
обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть
синтаксиса составного значения, с помощью спецпоследовательностей.
Значение NULL в этой записи представляется пустым местом (когда между запятыми или скобка-
ми нет никаких символов). Чтобы ввести именно пустую строку, а не NULL, нужно написать "".
Функция вывода составного значения заключает значения полей в кавычки, если они представ-
ляют собой пустые строки, либо содержат скобки, запятые, кавычки или обратную косую черту,
либо состоят из одних пробелов. (В последнем случае можно обойтись без кавычек, но они добав-
ляются для удобочитаемости.) Кавычки и обратная косая черта, заключённые в значения полей,
при выводе дублируются.
Примечание
Помните, что написанная SQL-команда прежде всего интерпретируется как текстовая
строка, а затем как составное значение. Вследствие этого число символов обратной ко-
170Типы данных
сой черты удваивается (если используются спецпоследовательности). Например, что-
бы ввести в поле составного столбца значение типа text с обратной косой чертой и
кавычками, команду нужно будет записать так:
INSERT ... VALUES ('("\"\\")');
Сначала обработчик спецпоследовательностей удаляет один уровень обратной косой
черты, так что анализатор составного значения получает на вход ("\"\\"). В свою
очередь, он передаёт эту строку процедуре ввода значения типа text, где она преоб-
разуются в "\. (Если бы мы работали с типом данных, процедура ввода которого также
интерпретирует обратную косую черту особым образом, например bytea, нам могло
бы понадобиться уже восемь таких символов, чтобы сохранить этот символ в поле со-
ставного значения.) Во избежание такого дублирования спецсимволов строки можно
заключать в доллары (см. Подраздел 4.1.2.4).
Подсказка
Записывать составные значения в командах SQL часто бывает удобнее с помощью кон-
структора ROW. В ROW отдельные значения элементов записываются так же, как если бы
они не были членами составного выражения.
8.17. Диапазонные типы
Диапазонные типы представляют диапазоны значений некоторого типа данных (он также называ-
ется подтипом диапазона). Например, диапазон типа timestamp может представлять временной
интервал, когда зарезервирован зал заседаний. В данном случае типом данных будет tsrange (со-
кращение от «timestamp range»), а подтипом — timestamp. Подтип должен быть полностью упоря-
дочиваемым, чтобы можно было однозначно определить, где находится значение по отношению
к диапазону: внутри, до или после него.
Диапазонные типы полезны тем, что позволяют представить множество возможных значений в
одной структуре данных и чётко выразить такие понятия, как пересечение диапазонов. Наиболее
очевидный вариант их использования — применять диапазоны даты и времени для составления
расписания, но также полезными могут оказаться диапазоны цен, интервалы измерений и т. д.
8.17.1. Встроенные диапазонные типы
PostgreSQL имеет следующие встроенные диапазонные типы:
• int4range — диапазон подтипа integer
• int8range — диапазон подтипа bigint
• numrange — диапазон подтипа numeric
• tsrange — диапазон подтипа timestamp without time zone
• tstzrange — диапазон подтипа timestamp with time zone
• daterange — диапазон подтипа date
Помимо этого, вы можете определять собственные типы; подробнее это описано в CREATE TYPE.
8.17.2. Примеры
CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
(1108, '[2010-01-01 14:30, 2010-01-01 15:30)');
-- Вхождение
171Типы данных
SELECT int4range(10, 20) @> 3;
-- Перекрытие
SELECT numrange(11.1, 22.2) && numrange(20.0, 30.0);
-- Получение верхней границы
SELECT upper(int8range(15, 25));
-- Вычисление пересечения
SELECT int4range(10, 20) * int4range(15, 25);
-- Является ли диапазон пустым?
SELECT isempty(numrange(1, 5));
Полный список операторов и функций, предназначенных для диапазонных типов, приведён в Таб-
лице 9.50 и Таблице 9.51.
8.17.3. Включение и исключение границ
Любой непустой диапазон имеет две границы, верхнюю и нижнюю, и включает все точки между
этими значениями. В него также может входить точка, лежащая на границе, если диапазон вклю-
чает эту границу. И наоборот, если диапазон не включает границу, считается, что точка, лежащая
на этой границе, в него не входит.
В текстовой записи диапазона включение нижней границы обозначается символом «[», а исклю-
чением — символом «(». Для верхней границы включение обозначается аналогично, символом
«]», а исключение — символом «)». (Подробнее это описано в Подразделе 8.17.5.)
Для проверки, включается ли нижняя или верхняя граница в диапазон, предназначены функции
lower_inc и upper_inc, соответственно.
8.17.4. Неограниченные (бесконечные) диапазоны
Нижнюю границу диапазона можно опустить и определить тем самым диапазон, включающий все
точки, лежащие ниже верхней границы. Подобным образом, если не определить верхнюю грани-
цу, в диапазон войдут все точки, лежащие выше нижней границы. Если же опущена и нижняя, и
правая границы, такой диапазон будет включать все возможные значения своего подтипа.
Это равнозначно тому, что нижней границей будет считаться «минус бесконечность», а верхней —
«плюс бесконечность». Но заметьте, что эти бесконечные значения не являются значениями под-
типа диапазона и поэтому также не могут входить в диапазон. (Как следствие, нет такого понятия,
как включаемая нижняя бесконечная граница — если попытаться записать такой диапазон, она
будет автоматически преобразована в исключаемую.)
Кроме этого, в некоторых типах есть понятие «бесконечность», но в данном контексте оно счита-
ется просто одним из значений. Например, во временных диапазонах [today,] означает то же са-
мое, что и [today,). Но диапазон [today,infinity] отличается от [today,infinity) — в послед-
нем специальное значение infinity типа timestamp не входит в диапазон.
Проверить, определена ли верхняя или нижняя граница, можно с помощью функций lower_inf и
upper_inf, соответственно.
8.17.5. Ввод/вывод диапазонов
Вводимое значение диапазона должно записываться в одной из следующих форм:
(нижняя-граница,верхняя-граница)
(нижняя-граница,верхняя-граница]
[нижняя-граница,верхняя-граница)
[нижняя-граница,верхняя-граница]
empty
172Типы данных
Тип скобок (квадратные или круглые) определяет, включаются ли в диапазон соответствующие
границы, как описано выше. Заметьте, что последняя форма содержит только слово empty и опре-
деляет пустой диапазон (диапазон, не содержащий точек).
Здесь нижняя-граница может быть строкой с допустимым значением подтипа или быть пустой (то-
гда диапазон будет без нижней границы). Аналогично, верхняя-граница может задаваться одним
из значений подтипа или быть неопределённой (пустой).
Любое значение диапазона можно заключить в кавычки ("). А если значение содержит круглые
или квадратные скобки, запятые, кавычки или обратную косую черту, использовать кавычки необ-
ходимо, чтобы эти символы не рассматривались как часть синтаксиса диапазона. Чтобы включить
в значение диапазона, заключённое в кавычки, такие символы, как кавычки или обратная косая
черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавыч-
ки в значении диапазона, заключённого в кавычки, воспринимаются как одинарные, подобно апо-
строфам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в
данных, которые могут быть восприняты как часть синтаксиса диапазона, с помощью спецпосле-
довательностей. Чтобы задать в качестве границы пустую строку, нужно ввести "", так как пустая
строка без кавычек будет означать отсутствие границы.
Пробельные символы до и после определения диапазона игнорируются, но когда они присутствуют
внутри скобок, они воспринимаются как часть значения верхней или нижней границы. (Хотя они
могут также игнорироваться в зависимости от подтипа диапазона.)
Примечание
Эти правила очень похожи на правила записи значений для полей составных типов.
Дополнительные замечания приведены в Подразделе 8.16.6.
Примеры:
-- в диапазон включается 3, не включается 7 и включаются все точки между ними
SELECT '[3,7)'::int4range;
-- в диапазон не включаются 3 и 7, но включаются все точки между ними
SELECT '(3,7)'::int4range;
-- в диапазон включается только одно значение 4
SELECT '[4,4]'::int4range;
-- диапазон не включает никаких точек (нормализация заменит его определение
-- на 'empty')
SELECT '[4,4)'::int4range;
8.17.6. Конструирование диапазонов
Для каждого диапазонного типа определена функция конструктора, имеющая то же имя, что и
данный тип. Использовать этот конструктор обычно удобнее, чем записывать текстовую константу
диапазона, так как это избавляет от потребности в дополнительных кавычках. Функция конструк-
тора может принимать два или три параметра. Вариант с двумя параметрами создаёт диапазон
в стандартной форме (нижняя граница включается, верхняя исключается), тогда как для вариан-
та с тремя параметрами включение границ определяется третьим параметром. Третий параметр
должен содержать одну из строк: «()», «(]», «[)» или «[]». Например:
-- Полная форма: нижняя граница, верхняя граница и текстовая строка, определяющая
-- включение/исключение границ.
SELECT numrange(1.0, 14.0, '(]');
-- Если третий аргумент опущен, подразумевается '[)'.
SELECT numrange(1.0, 14.0);
173Типы данных
-- Хотя здесь указывается '(]', при выводе значение будет приведено к
-- каноническому виду, так как int8range — тип дискретного диапазона (см. ниже).
SELECT int8range(1, 14, '(]');
-- Когда вместо любой границы указывается NULL, соответствующей границы
-- у диапазона не будет.
SELECT numrange(NULL, 2.2);
8.17.7. Типы дискретных диапазонов
Дискретным диапазоном считается диапазон, для подтипа которого однозначно определён «шаг»,
как например для типов integer и date. Значения этих двух типов можно назвать соседними, ко-
гда между ними нет никаких других значений. В непрерывных диапазонах, напротив, всегда (или
почти всегда) можно найти ещё одно значение между двумя данными. Например, непрерывным
диапазоном будет диапазон с подтипами numeric и timestamp. (Хотя timestamp имеет ограничен-
ную точность, то есть теоретически он является дискретным, но всё же лучше считать его непре-
рывным, так как шаг его обычно не определён.)
Можно также считать дискретным подтип диапазона, в котором чётко определены понятия «сле-
дующего» и «предыдущего» элемента для каждого значения. Такие определения позволяют пре-
образовывать границы диапазона из включаемых в исключаемые, выбирая следующий или преды-
дущий элемент вместо заданного значения. Например, диапазоны целочисленного типа [4,8] и
(3,9) описывают одно и то же множество значений; но для диапазона подтипа numeric это не так.
Для типа дискретного диапазона определяется функция канонизации, учитывающая размер ша-
га для данного подтипа. Задача этой функции — преобразовать равнозначные диапазоны к един-
ственному представлению, в частности нормализовать включаемые и исключаемые границы. Ес-
ли функция канонизации не определена, диапазоны с различным определением будут всегда счи-
таться разными, даже когда они на самом деле представляют одно множество значений.
Для встроенных типов int4range, int8range и daterange каноническое представление включает
нижнюю границу и не включает верхнюю; то есть диапазон приводится к виду [). Однако для
нестандартных типов можно использовать и другие соглашения.
8.17.8. Определение новых диапазонных типов
Пользователи могут определять собственные диапазонные типы. Это может быть полезно, когда
нужно использовать диапазоны с подтипами, для которых нет встроенных диапазонных типов. На-
пример, можно определить новый тип диапазона для подтипа float8:
CREATE TYPE floatrange AS RANGE (
subtype = float8,
subtype_diff = float8mi
);
SELECT '[1.234, 5.678]'::floatrange;
Так как для float8 осмысленное значение «шага» не определено, функция канонизации в данном
примере не задаётся.
Определяя собственный диапазонный тип, вы также можете выбрать другие правила сортировки
или класс оператора B-дерева для его подтипа, что позволит изменить порядок значений, от кото-
рого зависит, какие значения попадают в заданный диапазон.
Если подтип можно рассматривать как дискретный, а не непрерывный, в команде CREATE TYPE
следует также задать функцию канонизации. Этой функции будет передаваться значение диапазо-
на, а она должна вернуть равнозначное значение, но, возможно, с другими границами и формати-
рованием. Для двух диапазонов, представляющих одно множество значений, например, целочис-
ленные диапазоны [1, 7] и [1, 8), функция канонизации должна выдавать один результат. Какое
именно представление будет считаться каноническим, не имеет значения — главное, чтобы два
174Типы данных
равнозначных диапазона, отформатированных по-разному, всегда преобразовывались в одно зна-
чение с одинаковым форматированием. Помимо исправления формата включаемых/исключаемых
границ, функция канонизации может округлять значения границ, если размер шага превышает
точность хранения подтипа. Например, в типе диапазона для подтипа timestamp можно опреде-
лить размер шага, равный часу, тогда функция канонизации должна будет округлить границы, за-
данные, например с точностью до минут, либо вместо этого выдать ошибку.
Помимо этого, для любого диапазонного типа, ориентированного на использование с индексами
GiST или SP-GiST, должна быть определена разница значений подтипов, функция subtype_diff.
(Индекс сможет работать и без subtype_diff, но в большинстве случаев это будет не так эффектив-
но.) Эта функция принимает на вход два значения подтипа и возвращает их разницу (т. е. X минус
Y) в значении типа float8. В показанном выше примере может использоваться функция float8mi,
определяющая нижележащую реализацию обычного оператора «минус» для типа float8, но для
другого подтипа могут потребоваться дополнительные преобразования. Иногда для представления
разницы в числовом виде требуется ещё и творческий подход. Функция subtype_diff, насколько
это возможно, должна быть согласована с порядком сортировки, вытекающим из выбранных пра-
вил сортировки и класса оператора; то есть, её результат должен быть положительным, если со-
гласно порядку сортировки первый её аргумент больше второго.
Ещё один, не столь тривиальный пример функции subtype_diff:
CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS
'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;
CREATE TYPE timerange AS RANGE (
subtype = time,
subtype_diff = time_subtype_diff
);
SELECT '[11:10, 23:00]'::timerange;
Дополнительные сведения о создании диапазонных типов можно найти в описании CREATE TYPE.
8.17.9. Индексация
Для столбцов, имеющих диапазонный тип, можно создать индексы GiST и SP-GiST. Например, так
создаётся индекс GiST:
CREATE INDEX reservation_idx ON reservation USING GIST (during);
Индекс GiST или SP-GiST помогает ускорить запросы со следующими операторами: =, &&, <@, @>,
<<, >>, -|-, &< и &> (дополнительно о них можно узнать в Таблице 9.50.
Кроме того, для таких столбцов можно создать индексы на основе хеша и B-деревьев. Для индек-
сов таких типов полезен по сути только один оператор диапазона — равно. Порядок сортировки
B-дерева определяется для значений диапазона соответствующими операторами < и >, но этот по-
рядок может быть произвольным и он не очень важен в реальном мире. Поддержка B-деревьев и
хешей диапазонными типами нужна в основном для сортировки и хеширования при выполнении
запросов, но не для создания самих индексов.
8.17.10. Ограничения для диапазонов
Тогда как для скалярных значений естественным ограничением является UNIQUE, оно обычно не
подходит для диапазонных типов. Вместо этого чаще оказываются полезнее ограничения-исклю-
чения (см. CREATE TABLE ... CONSTRAINT ... EXCLUDE). Такие ограничения позволяют, например
определить условие «непересечения» диапазонов. Например:
CREATE TABLE reservation (
during tsrange,
EXCLUDE USING GIST (during WITH &&)
);
175Типы данных
Это ограничение не позволит одновременно сохранить в таблице несколько диапазонов, которые
накладываются друг на друга:
INSERT INTO reservation VALUES
('[2010-01-01 11:30, 2010-01-01 15:00)');
INSERT 0 1
INSERT INTO reservation VALUES
('[2010-01-01 14:45, 2010-01-01 15:45)');
ОШИБКА: конфликтующее значение ключа нарушает ограничение-исключение
"reservation_during_excl"
ПОДРОБНОСТИ: Ключ (during)=(["2010-01-01 14:45:00","2010-01-01 15:45:00"))
конфликтует с существующим ключом (during)=(["2010-01-01 11:30:00","2010-01-01
15:00:00"))
Для максимальной гибкости в ограничении-исключении можно сочетать простые скалярные типы
данных с диапазонами, используя расширение btree_gist. Например, если btree_gist установле-
но, следующее ограничение не будет допускать пересекающиеся диапазоны, только если совпа-
дают также и номера комнат:
CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
room text,
during tsrange,
EXCLUDE USING GIST (room WITH =, during WITH &&)
);
INSERT INTO room_reservation VALUES
('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');
INSERT 0 1
INSERT INTO room_reservation VALUES
('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');
ОШИБКА: конфликтующее значение ключа нарушает ограничение-исключение
"room_reservation_room_during_excl"
ПОДРОБНОСТИ: Ключ (room, during)=(123A, [ 2010-01-01 14:30:00,
2010-01-01 15:30:00 )) конфликтует
с существующим ключом (room, during)=(123A, ["2010-01-01 14:00:00","2010-01-01
15:00:00")).
INSERT INTO room_reservation VALUES
('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');
INSERT 0 1
8.18. Типы доменов
Домен — пользовательский тип данных, основанный на другом нижележащем типе. Он может
быть определён с условиями, ограничивающими множество допустимых значений подмножеством
значений нижележащего типа. В остальном он ведёт себя как нижележащий тип — например, с
доменными типом будут работать любые операторы или функции, применимые к нижележащему
типу. Нижележащим типом может быть любой встроенный или пользовательский базовый тип,
тип-перечисление, массив, составной тип, диапазон или другой домен.
Например, мы можем создать домен поверх целых чисел, принимающий только положительные
числа:
CREATE
CREATE
INSERT
INSERT
DOMAIN posint AS integer CHECK (VALUE > 0);
TABLE mytable (id posint);
INTO mytable VALUES(1);
-- работает
INTO mytable VALUES(-1); -- ошибка
176Типы данных
Когда к значению доменного типа применяются операторы или функции, предназначенные для
нижележащего типа, домен автоматически приводится к нижележащему типу. Так, например, ре-
зультат операции mytable.id - 1 будет считаться имеющим тип integer, а не posint. Мы могли
бы записать (mytable.id - 1)::posint, чтобы снова привести результат к типу posint, что повле-
чёт перепроверку ограничений домена. В этом случае, если данное выражение будет применено
к id, равному 1, произойдёт ошибка. Значение нижележащего типа можно присвоить полю или
переменной доменного типа, не записывая приведение явно, но и в этом случае ограничения до-
мена будут проверяться.
За дополнительными сведениями обратитесь к описанию CREATE DOMAIN.
8.19. Идентификаторы объектов
Идентификатор объекта (Object Identifier, OID) используется внутри PostgreSQL в качестве первич-
ного ключа различных системных таблиц. В пользовательские таблицы столбец OID добавляется,
только если при создании таблицы указывается WITH OIDS или включён параметр конфигурации
default_with_oids. Идентификатор объекта представляется в типе oid. Также для типа oid опре-
делены следующие псевдонимы: regproc, regprocedure, regoper, regoperator, regclass, regtype,
regrole, regnamespace, regconfig и regdictionary. Обзор этих типов приведён в Таблице 8.24.
В настоящее время тип oid реализован как четырёхбайтное целое. Таким образом оно может быть
недостаточно большим для обеспечения уникальности в базе данных или даже в отдельных боль-
ших таблицах. Поэтому в пользовательских таблицах использовать столбец типа OID в качестве
первичного ключа не рекомендуется. Лучше всего ограничить применение этого типа обращени-
ями к системным таблицам.
Для самого типа oid помимо сравнения определены всего несколько операторов. Однако его мож-
но привести к целому и затем задействовать в обычных целочисленных вычислениях. (При этом
следует опасаться путаницы со знаковыми/беззнаковыми значениями.)
Типы-псевдонимы OID сами по себе не вводят новых операций и отличаются только специализиро-
ванными функциями ввода/вывода. Эти функции могут принимать и выводить не просто числовые
значения, как тип oid, а символические имена системных объектов. Эти типы позволяют упростить
поиск объектов по значениям OID. Например, чтобы выбрать из pg_attribute строки, относящие-
ся к таблице mytable, можно написать:
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
вместо:
SELECT * FROM pg_attribute
WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
Хотя второй вариант выглядит не таким уж плохим, но это лишь очень простой запрос. Если же
потребуется выбрать правильный OID, когда таблица mytable есть в нескольких схемах, вложенный
подзапрос будет гораздо сложнее. Преобразователь вводимого значения типа regclass находит
таблицу согласно заданному пути поиска схем, так что он делает «всё правильно» автоматически.
Аналогично, приведя идентификатор таблицы к типу regclass, можно получить символическое
представление числового кода.
Таблица 8.24. Идентификаторы объектов
Имя Ссылки Описание
oid any числовой идентифика- 564182
тор объекта
regproc pg_proc имя функции
regprocedure pg_proc функция с типами аргу- sum(int4)
ментов
regoper pg_operator имя оператора
177
Пример значения
sum
+Типы данных
Имя Ссылки Описание
Пример значения
regoperator pg_operator оператор с типами ар- *(integer,integer)
гументов
или -(NONE,integer)
regclass pg_class имя отношения
pg_type
regtype pg_type имя типа данных
integer
regrole pg_authid имя роли
smithee
regnamespace pg_namespace пространство имён
pg_catalog
regconfig pg_ts_config конфигурация
вого поиска
regdictionary pg_ts_dict словарь текстового по- simple
иска
тексто- english
Все типы псевдонимов OID для объектов, сгруппированных в пространство имён, принимают име-
на, дополненные именем схемы, и выводят имена со схемой, если данный объект нельзя будет
найти в текущем пути поиска без имени схемы. Типы regproc и regoper принимают только уни-
кальные вводимые имена (не перегруженные), что ограничивает их применимость; в большинстве
случаев лучше использовать regprocedure или regoperator. Для типа regoperator в записи унар-
ного оператора неиспользуемый операнд заменяется словом NONE.
Дополнительным свойством большинства типов псевдонимов OID является образование зави-
симостей. Когда в сохранённом выражении фигурирует константа одного из этих типов (на-
пример, в представлении или в значении столбца по умолчанию), это создаёт зависимость
от целевого объекта. Например, если значение по умолчанию определяется выражением
nextval('my_seq'::regclass), PostgreSQL понимает, что это выражение зависит от последова-
тельности my_seq, и не позволит удалить последовательность раньше, чем будет удалено это вы-
ражение. Единственным ограничением является тип regrole. Константы этого типа в таких выра-
жениях не допускаются.
Примечание
Типы псевдонимов OID не полностью следуют правилам изоляции транзакций. Плани-
ровщик тоже воспринимает их как простые константы, что может привести к неопти-
мальному планированию запросов.
Есть ещё один тип системных идентификаторов, xid, представляющий идентификатор транзакции
(сокращённо xact). Этот тип имеют системные столбцы xmin и xmax. Идентификаторы транзакций
определяются 32-битными числами.
Третий тип идентификаторов, используемых в системе, — cid, идентификатор команды (command
identifier). Этот тип данных имеют системные столбцы cmin и cmax. Идентификаторы команд — это
тоже 32-битные числа.
И наконец, последний тип системных идентификаторов — tid, идентификатор строки/кортежа
(tuple identifier). Этот тип данных имеет системный столбец ctid. Идентификатор кортежа пред-
ставляет собой пару (из номера блока и индекса кортежа в блоке), идентифицирующую физиче-
ское расположение строки в таблице.
(Подробнее о системных столбцах рассказывается в Разделе 5.4.)
8.20. Тип pg_lsn
Тип данных pg_lsn может применяться для хранения значения LSN (последовательный номер в
журнале, Log Sequence Number), которое представляет собой указатель на позицию в журнале
WAL. Этот тип содержит XLogRecPtr и является внутренним системным типом PostgreSQL.
178Типы данных
Технически LSN — это 64-битное целое, представляющее байтовое смещение в потоке журнала
предзаписи. Он выводится в виде двух шестнадцатеричных чисел до 8 цифр каждое, через косую
черту, например: 16/B374D848. Тип pg_lsn поддерживает стандартные операторы сравнения, та-
кие как = и >. Можно также вычесть один LSN из другого с помощью оператора -; результатом
будет число байт между этими двумя позициями в журнале предзаписи.
8.21. Псевдотипы
В систему типов PostgreSQL включены несколько специальных элементов, которые в совокупности
называются псевдотипами. Псевдотип нельзя использовать в качестве типа данных столбца, но
можно объявить функцию с аргументом или результатом такого типа. Каждый из существующих
псевдотипов полезен в ситуациях, когда характер функции не позволяет просто получить или вер-
нуть определённый тип данных SQL. Все существующие псевдотипы перечислены в Таблице 8.25.
Таблица 8.25. Псевдотипы
Имя Описание
any Указывает, что функция принимает любой вво-
димый тип данных.
anyelement Указывает, что функция принимает любой тип
данных (см. Подраздел 38.2.5).
anyarray Указывает, что функция принимает любой тип
массива (см. Подраздел 38.2.5).
anynonarray Указывает, что функция принимает любой тип
данных, кроме массивов (см. Подраздел 38.2.5).
anyenum Указывает, что функция принимает любое пере-
числение (см. Подраздел 38.2.5 и Раздел 8.7).
anyrange Указывает, что функция принимает любой диа-
пазонный тип данных (см. Подраздел  38.2.5 и
Раздел 8.17).
cstring Указывает, что функция принимает или возвра-
щает строку в стиле C.
internal Указывает, что функция принимает или возвра-
щает внутренний серверный тип данных.
language_handler Обработчик процедурного языка объявляется
как возвращающий тип language_handler .
fdw_handler Обработчик обёртки сторонних данных объявля-
ется как возвращающий тип fdw_handler .
index_am_handler Обработчик метода доступа индекса объявляет-
ся как возвращающий тип index_am_handler .
tsm_handler Обработчик метода выборки из таблицы объяв-
ляется как возвращающий тип tsm_handler .
record Указывает, что функция принимает или возвра-
щает неопределённый тип строки.
trigger Триггерная функция объявляется как возвраща-
ющая тип trigger.
event_trigger Функция событийного триггера объявляется как
возвращающая тип event_trigger .
pg_ddl_command Обозначает представление команд DDL, доступ-
ное событийным триггерам.
void Указывает, что функция не возвращает значе-
ние.
179Типы данных
Имя Описание
unknown Обозначает ещё не распознанный тип, то есть
раскрытое строковое значение.
opaque Устаревший тип, который раньше использовал-
ся во многих вышеперечисленных случаях.
Функции, написанные на языке C (встроенные или динамически загружаемые), могут быть объяв-
лены с параметрами или результатами любого из этих типов. Ответственность за безопасное по-
ведение функции с аргументами таких типов ложится на разработчика функции.
Функции, написанные на процедурных языках, могут использовать псевдотипы, только если это
позволяет соответствующий язык. В настоящее время большинство процедурных языков запреща-
ют использовать псевдотипы в качестве типа аргумента и позволяют использовать для результа-
тов только типы void и record (и trigger или event_trigger, когда функция реализует триггер
или событийный триггер). Некоторые языки также поддерживают полиморфные функции с типа-
ми anyelement, anyarray, anynonarray, anyenum и anyrange.
Псевдотип internal используется в объявлениях функций, предназначенных только для внутрен-
него использования в СУБД, но не для прямого вызова в запросах SQL. Если у функции есть как
хотя бы один аргумент типа internal, её нельзя будет вызывать из SQL. Чтобы сохранить типобез-
опасность при таком ограничении, следуйте важному правилу: не создавайте функцию, возвраща-
ющую результат типа internal, если у неё нет ни одного аргумента internal.
