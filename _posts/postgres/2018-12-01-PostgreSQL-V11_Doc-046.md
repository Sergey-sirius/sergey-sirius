---
layout: post
title: Глава 46. PL/Python — процедурный язык Python
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 46. PL/Python — процедурный язык Python


Процедурный язык PL/Python позволяет писать функции PostgreSQL на языке Python.
Чтобы установить PL/Python в определённую базу данных, выполните команду CREATE EXTENSION
plpythonu (но смотрите также Раздел 46.1).
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
PL/Python представлен только в виде «недоверенного» языка, что означает, что он никаким спо-
собом не ограничивает действия пользователей, и поэтому он называется plpythonu. Доверенная
вариация plpython может появиться в будущем, если в Python будет разработан безопасный меха-
низм выполнения. Автор функции на недоверенном языке PL/Python должен позаботиться о том,
чтобы эту функцию нельзя было использовать не по назначению, так как она может делать всё, что
может пользователь с правами администратора баз данных. Создавать функции на недоверенных
языках, таких как plpythonu, разрешено только суперпользователям.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Python в процессе установки. (За дополнительными сведениями обратитесь к инструк-
циям по установке.) Пользователи двоичных пакетов могут найти PL/Python в отдель-
ном модуле.
46.1. Python 2 и Python 3
PL/Python поддерживает две вариации языка: Python 2 и Python 3. (Более точная информация о
поддерживаемых второстепенных версиях Python может содержаться в инструкциях по установке
PostgreSQL.) Так как языки Python 2 и Python 3 несовместимы в некоторых важных аспектах, во
избежание смешения их в PL/Python применяется следующая схема именования:
• Язык PostgreSQL с именем plpython2u представляет реализацию PL/Python, основанную на ва-
риации языка Python 2.
• Язык PostgreSQL с именем plpython3u представляет реализацию PL/Python, основанную на ва-
риации языка Python 3.
• Язык с именем plpythonu представляет реализацию PL/Python, основанную на версии Python
по умолчанию, в данный момент это Python 2. (Этот выбор по умолчанию не зависит от того,
какая версия считается локальной версией «по умолчанию», например, на какую версию ука-
зывает /usr/bin/python.) Выбор по умолчанию в отдалённом будущем выпуске PostgreSQL
может быть сменён на Python 3, в зависимости от того, как будет происходить переход на
Python 3 в сообществе Python.
Эта схема аналогична рекомендациям, данным в PEP 394, по выбору имени команды python и
переходу с версии на версию.
Будет ли доступен PL/Python для Python 2 или для Python 3, либо сразу для обеих версий, зависит
от конфигурации сборки или установленных пакетов.
1210PL/Python — проце-
дурный язык Python
Подсказка
Какая вариация будет собрана, зависит от того, как версия Python будет найдена при
установке или будет задана в переменной окружения PYTHON; см. Раздел 16.4. Чтобы в
одной инсталляции присутствовали обе вариации PL/Python, необходимо сконфигури-
ровать и настроить дерево исходного кода дважды.
В результате формируется такая стратегия использования и смены определённой версии:
• Существующие пользователи и пользователи, которым в настоящее время неинтересен Python
3, могут выбрать имя языка plpythonu и им не придётся ничего менять в обозримом будущем.
Чтобы упростить миграцию на Python 3, которая произойдёт в конце концов, рекомендуется
постепенно проверять «готовность к будущему» кода, обновляя его до версий Python 2.6/2.7.
На практике многие функции PL/Python можно мигрировать на Python 3 с минимальными из-
менениями или вовсе без изменений.
• Пользователи, знающие, что их код очень сильно зависит от Python 2, и не планирующие ко-
гда-либо менять его, могут использовать имя языка plpython2u. Это будет работать ещё очень
и очень долго, пока в PostgreSQL не будет полностью ликвидирована поддержка Python 2.
• Пользователи, желающие погрузиться в Python 3, могут выбрать имя языка plpython3u, и их
код будет работать всегда, по сегодняшним стандартам. В отдалённом будущем, когда верси-
ей по умолчанию может стать Python 3, цифру «3» из имени языка можно будет убрать из эс-
тетических соображений.
• Смельчаки, желающие уже сегодня получить операционное окружение только с Python 3, мо-
гут модифицировать pg_pltemplate, чтобы имя plpythonu было равнозначно plpython3u, отда-
вая себе отчёт в том, что такая инсталляция будет несовместима с остальным миром.
Дополнительную информацию о переходе на Python 3 можно также найти в описании Что нового
в Python 3.0.
Использовать PL/Python на базе Python 2 и PL/Python на базе Python 3 в одном сеансе нельзя, так
как это приведёт к конфликту символов в динамических модулях, что может повлечь сбой сервер-
ного процесса PostgreSQL. В системе есть проверка, предотвращающая смешение основных вер-
сий Python в одном сеансе, которая прервёт сеанс при выявлении расхождения. Однако использо-
вать обе вариации в одной базе данных всё же возможно, обращаясь к ним в разных сеансах.
46.2. Функции на PL/Python
Функции на PL/Python объявляются стандартным образом с помощью команды CREATE FUNCTION:
CREATE FUNCTION funcname (argument-list)
RETURNS return-type
AS $$
# Тело функции на PL/Python
$$ LANGUAGE plpythonu;
Тело функции содержит просто скрипт на языке Python. Когда вызывается функция, её аргументы
передаются в виде элементов списка args; именованные аргументы также передаются скрипту
Python как обычные переменные. С именованными аргументами скрипт обычно лучше читается.
Результат из кода Python возвращается обычным способом: командой return или yield (в случае
функции, возвращающей множество). Если возвращаемое значение не определено, Python возвра-
щает None. Исполнитель PL/Python преобразует None языка Python в значение NULL языка SQL.
В процедуре код Python должен возвращать None (обычно для этого процедура завершается без
оператора return или используется оператор return без аргумента); в противном случае выдаётся
ошибка.
Например, функцию, возвращающее большее из двух целых чисел, можно определить так:
1211PL/Python — проце-
дурный язык Python
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS $$
if a > b:
return a
return b
$$ LANGUAGE plpythonu;
Код на Python, заданный в качестве тела объявляемой функции, становится телом функции Python.
Например, для показанного выше объявления получается функция:
def __plpython_procedure_pymax_23456():
if a > b:
return a
return b
Здесь 23456 — это OID, который PostgreSQL присвоил данной функции.
Значения аргументов задаются в глобальных переменных. Согласно правилам видимости в Python,
тонким следствием этого является то, что переменной аргумента нельзя присвоить внутри функ-
ции выражение, включающее имя самой этой переменной, если только эта переменная не объяв-
лена глобальной в текущем блоке. Например, следующий код не будет работать:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS $$
x = x.strip() # ошибка
return x
$$ LANGUAGE plpythonu;
так как присвоение x значения делает x локальной переменной для всего блока, и при этом x
в правой части присваивания оказывается ещё не определённой локальной переменной x, а не
параметром функции PL/Python. Добавив оператор global, это можно исправить:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS $$
global x
x = x.strip() # теперь всё в порядке
return x
$$ LANGUAGE plpythonu;
Однако рекомендуется не полагаться на такие особенности реализации PL/Python, а принять, что
параметры функции предназначены только для чтения.
46.3. Значения данных
Вообще говоря, цель исполнителя PL/Python — обеспечить «естественное» соответствие между
мирами PostgreSQL и Python. Этим объясняется выбор правил сопоставления данных, описанных
ниже.
46.3.1. Сопоставление типов данных
Когда вызывается функция PL/Python, её аргументы преобразуются из типа PostgreSQL в соответ-
ствующий тип Python по таким правилам:
• Тип PostgreSQL boolean преобразуется в bool языка Python.
• Типы PostgreSQL smallint и int преобразуются в тип int языка Python. Типы PostgreSQL
bigint и oid становятся типами long в Python 2 и int в Python 3.
• Типы PostgreSQL real и double преобразуются в тип float языка Python.
• Тип PostgreSQL numeric преобразуется в Decimal среды Python. Этот тип импортируется из
пакета cdecimal, при его наличии. В противном случае используется decimal.Decimal из
1212PL/Python — проце-
дурный язык Python
стандартной библиотеки. Тип cdecimal работает значительно быстрее, чем decimal. Однако
в Python версии 3.3 и выше тип cdecimal включается в стандартную библиотеку под именем
decimal, так что теперь этого различия нет.
• Тип PostgreSQL bytea становится типом str в Python 2 и bytes в Python 3. В Python 2 такую
строку следует воспринимать как последовательность байт без какой-либо определённой ко-
дировки символов.
• Все другие типы данных, включая типы символьных строк PostgreSQL, преобразуются в тип
str языка Python. В Python 2 эта строка будет передаваться в кодировке сервера PostgreSQL; в
Python 3 это будет строка в Unicode, как и все строки.
• Информация о нескалярных типах данных приведена ниже.
При завершении функции PL/Python её значение результата преобразуется в тип данных, объяв-
ленный как тип результата в PostgreSQL, следующим образом:
• Когда тип результата функции в PostgreSQL — boolean, возвращаемое значение приводится к
логическому типу по правилам, принятым в Python. То есть false будет возвращено для 0 и пу-
стой строки, но, обратите внимание, для 'f' будет возвращено true.
• Когда тип результата функции PostgreSQL — bytea, возвращаемое значение будет преобразо-
вано в строку (Python 2) или набор байт (Python 3), используя встроенные средства Python, а
затем будет приведено к типу bytea.
• Для всех других типов результата PostgreSQL возвращаемое значение преобразуется в строку
с помощью встроенной в Python функции str, и полученная строка передаётся функции ввода
типа данных PostgreSQL. (Если значение в Python имеет тип float, оно преобразуется встро-
енной функцией repr, а не str, для недопущения потери точности.)
Из кода Python 2 строки должны передаваться в PostgreSQL в кодировке сервера PostgreSQL.
При передаче строки, неприемлемой для текущей кодировки сервера, возникает ошибка, но
не все несоответствия кодировки могут быть выявлены, так что с некорректной кодировкой
всё же могут быть получены нечитаемые строки. Строки Unicode переводятся в нужную коди-
ровку автоматически, так что использовать их может быть безопаснее и удобнее. В Python 3
все строки имеют кодировку Unicode.
• Информация о нескалярных типах данных приведена ниже.
Заметьте, что логические несоответствия между объявленным в PostgreSQL типом результата и
типом фактически возвращаемого объекта Python игнорируются — значение преобразуется в лю-
бом случае.
46.3.2. Null, None
Если функции передаётся значение SQL NULL, в Python значением этого аргумента будет None.
Например, функция pymax, определённая как показано в Раздел 46.2, возвратит неверный ответ,
получив аргументы NULL. Мы могли бы добавить указание STRICT в определение функции, чтобы
PostgreSQL поступал немного разумнее: при передаче значения NULL функция вовсе не будет
вызываться, будет сразу возвращён результат NULL. С другой стороны, мы могли бы проверить
аргументы на NULL в теле функции:
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS $$
if (a is None) or (b is None):
return None
if a > b:
return a
return b
$$ LANGUAGE plpythonu;
Как показано выше, чтобы выдать из функции PL/Python значение SQL NULL, нужно вернуть зна-
чение None. Это можно сделать и в строгой, и в нестрогой функции.
1213PL/Python — проце-
дурный язык Python
46.3.3. Массивы, списки
Значения массивов SQL передаются в PL/Python в виде списка Python. Чтобы вернуть значение
массива SQL из функции PL/Python, возвратите список Python:
CREATE FUNCTION return_arr()
RETURNS int[]
AS $$
return [1, 2, 3, 4, 5]
$$ LANGUAGE plpythonu;
SELECT return_arr();
return_arr
-------------
(1,2,3,4,5)
(1 row)
Многомерные массивы передаются в PL/Python в виде вложенных списков Python. Например, двух-
мерный массив представляется как список списков. При передаче многомерного массива SQL из
функции PL/Python необходимо, чтобы все внутренние списки на каждом уровне имели одинако-
вый размер. Например:
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
plpy.info(x, type(x))
return x
$$ LANGUAGE plpythonu;
SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO: ([[1, 2, 3], [4, 5, 6]], <type 'list'>)
test_type_conversion_array_int4
---------------------------------
((1,2,3),(4,5,6))
(1 row)
Другие последовательности Python, например кортежи, тоже принимаются для обратной совме-
стимости с PostgreSQL версии 9.6 и ниже (где многомерные массивы не поддерживались). Однако
они всегда воспринимаются как одномерные массивы, чтобы не возникало неоднозначности с со-
ставными типами. По этой же причине когда в многомерном массиве используется составной тип,
он должен представляться как кортеж, а не список.
Учтите, что в Python и строки являются последовательностями, что может давать неожиданные
эффекты, хорошо знакомые тем, кто программирует на Python:
CREATE FUNCTION return_str_arr()
RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;
SELECT return_str_arr();
return_str_arr
----------------
(h,e,l,l,o)
(1 row)
46.3.4. Составные типы
Аргументы составного типа передаются функции в виде сопоставлений Python. Именами элемен-
тов сопоставления являются атрибуты составного типа. Если атрибут в переданной строке имеет
значение NULL, он передаётся в сопоставлении значением None. Пример работы с составным ти-
пом:
1214PL/Python — проце-
дурный язык Python
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid (e employee)
RETURNS boolean
AS $$
if e["salary"] > 200000:
return True
if (e["age"] < 30) and (e["salary"] > 100000):
return True
return False
$$ LANGUAGE plpythonu;
Возвратить составной тип или строку таблицы из функции Python можно несколькими способами.
В следующих примерах предполагается, что у нас объявлен тип:
CREATE TYPE named_value AS (
name
text,
value integer
);
Результат этого типа можно вернуть как:
Последовательность (кортеж или список, но не множество, так как оно не индексируется)
В возвращаемых объектах последовательностей должно быть столько элементов, сколько полей
в составном типе результата. Элемент с индексом 0 присваивается первому полю составного
типа, с индексом 1 — второму и т. д. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS $$
return ( name, value )
# или альтернативный вариант, в виде кортежа: return [ name, value ]
$$ LANGUAGE plpythonu;
Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте в соответствующую позицию None.
Когда возвращается массив составных значений, его нельзя представить в виде списка, так как
невозможно однозначно определить, представляет ли список Python составной тип или ещё
одну размерность массива.
Сопоставление (словарь)
Значение столбца результата получается из сопоставления, в котором ключом является имя
столбца. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS $$
return ( "name": name, "value": value )
$$ LANGUAGE plpythonu;
Любые дополнительные пары ключ/значение в словаре игнорируются, а отсутствие нужных
ключей считается ошибкой. Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте None
с именем соответствующего столбца в качестве ключа.
Объект (любой объект с методом __getattr__)
Объект передаётся аналогично сопоставлению. Пример:
1215PL/Python — проце-
дурный язык Python
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS $$
class named_value:
def __init__ (self, n, v):
self.name = n
self.value = v
return named_value(name, value)
# или просто
class nv: pass
nv.name = name
nv.value = value
return nv
$$ LANGUAGE plpythonu;
Также поддерживаются функции с параметрами OUT (выходными). Например:
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;
SELECT * FROM multiout_simple();
Выходные параметры процедуры выдаются таким же образом. Например:
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$
return (a * 3, b * 3)
$$ LANGUAGE plpythonu;
CALL python_triple(5, 10);
46.3.5. Функции, возвращающие множества
Функция PL/Python также может возвращать множества, содержащие скалярные и составные ти-
пы. Это можно осуществить разными способами, так как возвращаемый объект внутри превраща-
ется в итератор. В следующих примерах предполагается, что у нас есть составной тип:
CREATE TYPE greeting AS (
how text,
who text
);
Множество в качестве результата можно возвратить, применив:
Последовательность (кортеж, список, множество)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS $$
# возвращает кортеж, содержащий списки в качестве составных типов
# также будут работать и остальные комбинации
return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
Итератор (любой объект, реализующий методы __iter__ и next)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS $$
class producer:
def __init__ (self, how, who):
1216PL/Python — проце-
дурный язык Python
self.how = how
self.who = who
self.ndx = -1
def __iter__ (self):
return self
def next (self):
self.ndx += 1
if self.ndx == len(self.who):
raise StopIteration
return ( self.how, self.who[self.ndx] )
return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
Генератор (yield)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS $$
for who in [ "World", "PostgreSQL", "PL/Python" ]:
yield ( how, who )
$$ LANGUAGE plpythonu;
Также поддерживаются функции, возвращающие множества, с параметрами OUT (объявленные с
RETURNS SETOF record). Например:
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS
SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;
SELECT * FROM multiout_simple_setof(3);
46.4. Совместное использование данных
Для сохранения внутренних данных при повторных вызовах одной и той же функции предусмотрен
глобальный словарь SD. Для размещения публичных данных предназначен глобальный словарь GD,
доступный всем функциям на Python в сеансе; используйте его с осторожностью.
Каждая функция получает собственную среду выполнения в интерпретаторе Python, так что гло-
бальные данные и аргументы функции, например myfunc, не будут доступны в myfunc2. Исключе-
ние составляют данные в словаре GD, как сказано выше.
46.5. Анонимные блоки кода
PL/Python также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO $$
# Код на PL/Python
$$ LANGUAGE plpythonu;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
46.6. Триггерные функции
Когда функция используется как триггер, словарь TD содержит значения, связанные с работой
триггера:
1217PL/Python — проце-
дурный язык Python
TD["event"]
содержит название события в виде строки: INSERT, UPDATE, DELETE или TRUNCATE.
TD["when"]
содержит одну из строк: BEFORE, AFTER или INSTEAD OF.
TD["level"]
содержит ROW или STATEMENT.
TD["new"]
TD["old"]
Для триггера уровня строки одно или оба этих поля содержат соответствующие строки тригге-
ра, в зависимости от события триггера.
TD["name"]
содержит имя триггера.
TD["table_name"]
содержит имя таблицы, для которой сработал триггер.
TD["table_schema"]
содержит схему таблицы, для которой сработал триггер.
TD["relid"]
содержит OID таблицы, для которой сработал триггер.
TD["args"]
Если в команде CREATE TRIGGER задавались аргументы, их можно получить как элементы мас-
сива с TD["args"][0] по TD["args"][n-1].
Если в TD["when"] передано BEFORE или INSTEAD OF, а в TD["level"] — ROW, вы можете вернуть
значение None или "OK" из функции Python, чтобы показать, что строка не была изменена, значение
"SKIP", чтобы прервать событие, либо, если в TD["event"] передана команда INSERT или UPDATE,
вы можете вернуть "MODIFY", чтобы показать, что новая строка была изменена. Во всех других
случаях возвращаемое значение игнорируется.
46.7. Обращение к базе данных
Исполнитель языка PL/Python автоматически импортирует модуль Python с именем plpy. Вы в сво-
ём коде можете использовать функции и константы, объявленные в этом модуле, обращаясь к ним
по именам вида plpy.имя.
46.7.1. Функции обращения к базе данных
Модуль plpy содержит различные функции для выполнения команд в базе данных:
plpy.execute(запрос [, макс-строк])
При вызове plpy.execute со строкой запроса и необязательным аргументом, ограничивающим
число строк, выполняется заданный запрос, а то, что он выдаёт, возвращается в виде объекта
результата.
Объект результата имитирует список или словарь. Получить из него данные можно по номеру
строки и имени столбца. Например, команда:
rv = plpy.execute("SELECT * FROM my_table", 5)
1218PL/Python — проце-
дурный язык Python
вернёт не более 5 строк из отношения my_table. Если в my_table есть столбец my_column, к
нему можно обратиться так:
foo = rv[i]["my_column"]
Число возвращённых в этом объекте строк можно получить, воспользовавшись встроенной
функцией len.
Для объекта результата определены следующие дополнительные методы:
nrows()
Возвращает число строк, обработанных командой. Заметьте, что это число не обязательно
будет равно числу возвращённых строк. Например, команда UPDATE устанавливает это зна-
чение, но не возвращает строк (без указания RETURNING).
status()
Значение состояния, возвращённое SPI_execute().
colnames()
coltypes()
coltypmods()
Возвращают список имён столбцов, список OID типов столбцов и список модификаторов
типа этих столбцов, соответственно.
Эти методы вызывают исключение, когда им передаётся объект, полученный от команды, не
возвращающей результирующий набор, например, UPDATE без RETURNING, либо DROP TABLE.
Но эти методы вполне можно использовать с результатом, содержащим ноль строк.
__str__()
Стандартный метод __str__ определён так, чтобы можно было, например, вывести отладоч-
ное сообщение с результатами запроса, вызвав plpy.debug(rv).
Объект результата может быть изменён.
Заметьте, что при вызове plpy.execute весь набор результатов будет прочитан в память. Эту
функцию следует использовать, только если вы знаете, что набор будет относительно неболь-
шим. Если вы хотите исключить риск переполнения памяти при выборке результатов большого
объёма, используйте plpy.cursor вместо plpy.execute.
plpy.prepare(запрос [, типы_аргументов])
plpy.execute(план [, аргументы [, макс-строк]])
Функция plpy.prepare подготавливает план выполнения для запроса. Она вызывается со стро-
кой запроса и списком типов параметров (если в запросе есть параметры). Например:
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1",
["text"])
Здесь text представляет переменную, передаваемую в качестве параметра $1. Второй аргумент
необязателен, если запросу не нужно передавать никакие параметры.
Чтобы запустить подготовленный оператор на выполнение, используйте вариацию функции
plpy.execute:
rv = plpy.execute(plan, ["name"], 5)
Передайте план в первом аргументе (вместо строки запроса), а список значений, которые будут
подставлены в запрос, — во втором. Второй аргумент можно опустить, если запрос не прини-
мает никакие параметры. Третий аргумент, как и раньше, задаёт необязательное ограничение
максимального числа строк.
1219PL/Python — проце-
дурный язык Python
Вы также можете вызвать метод execute объекта плана:
rv = plan.execute(["name"], 5)
Параметры запросов и поля строк результата преобразуются между типами данных PostgreSQL
и Python как описано в Разделе 46.3.
Когда вы подготавливаете план, используя модуль PL/Python, он сохраняется автоматически.
Что это означает, вы можете узнать в документации SPI (Глава 47). Чтобы эффективно исполь-
зовать это в нескольких вызовах функции, может потребоваться применить словарь постоянно-
го хранения SD или GD (см. Раздел 46.4). Например:
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
if "plan" in SD:
plan = SD["plan"]
else:
plan = plpy.prepare("SELECT 1")
SD["plan"] = plan
# остальной код функции
$$ LANGUAGE plpythonu;
plpy.cursor(запрос)
plpy.cursor(план [, аргументы])
Функция plpy.cursor принимает те же аргументы, что и plpy.execute (кроме ограничения
строк) и возвращает объект курсора, который позволяет обрабатывать объёмные наборы ре-
зультатов небольшими порциями. Как и plpy.execute, этой функции можно передать строку
запроса или объект плана со списком аргументов, а можно вызывать функцию cursor как ме-
тод объекта плана.
Объект курсора реализует метод fetch, который принимает целочисленный параметр и воз-
вращает объект результата. При каждом следующем вызове fetch возвращаемый объект будет
содержать следующий набор строк, в количестве, не превышающем значение параметра. Ко-
гда строки закончатся, fetch начнёт возвращать пустой объект результата. Объекты курсора
также предоставляют интерфейс итератора, выдающий по строке за один раз, пока не будут
выданы все строки. Данные, выбираемые таким образом, возвращаются не как объекты резуль-
тата, а как словари (одной строке результата соответствует один словарь).
Следующий пример демонстрирует обработку содержимого большой таблицы двумя способа-
ми:
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
if row['num'] % 2:
odd += 1
return odd
$$ LANGUAGE plpythonu;
CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
rows = cursor.fetch(batch_size)
if not rows:
break
for row in rows:
if row['num'] % 2:
odd += 1
return odd
$$ LANGUAGE plpythonu;
1220PL/Python — проце-
дурный язык Python
CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 <> 0", ["integer"])
rows = list(plpy.cursor(plan, [2])) # или: = list(plan.cursor([2]))
return len(rows)
$$ LANGUAGE plpythonu;
Курсоры ликвидируются автоматически. Но если вы хотите явно освободить все ресурсы, за-
нятые курсором, вызовите метод close. Продолжать получать данные через курсор, который
был закрыт, нельзя.
Подсказка
Не путайте объекты, создаваемые функцией plpy.cursor, с курсорами DB-API, опре-
делёнными в спецификации API для работы с базами данных в Python. Они не име-
ют ничего общего, кроме имени.
46.7.2. Обработка ошибок
Функции, обращающиеся к базе данных, могут сталкиваться с ошибками, в результате которых
они будут прерываться и вызывать исключение. Обе функции plpy.execute и plpy.prepare могут
вызывать экземпляр подкласса исключения plpy.SPIError, которое по умолчание прекращает вы-
полнение функции. Эту ошибку можно обработать, как и любое другое исключение в Python, при-
менив конструкцию try/except. Например:
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
try:
plpy.execute("INSERT INTO users(username) VALUES ('joe')")
except plpy.SPIError:
return "something went wrong"
else:
return "Joe added"
$$ LANGUAGE plpythonu;
Фактический класс вызываемого исключения соответствует определённому условию возник-
новения ошибки. Список всех возможных условий приведён в Таблице  A.1. В модуле
plpy.spiexceptions определяются классы исключений для каждого условия PostgreSQL, с име-
нами, производными от имён условий. Например, имя division_by_zero становится именем
DivisionByZero, unique_violation — именем UniqueViolation, fdw_error — именем FdwError и т.
д. Все эти классы исключений наследуются от SPIError. Такое разделение на классы упрощает
обработку определённых ошибок, например:
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int",
"int"])
plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
return "already have that fraction"
except plpy.SPIError, e:
return "other error, SQLSTATE %s" % e.sqlstate
else:
return "fraction inserted"
1221PL/Python — проце-
дурный язык Python
$$ LANGUAGE plpythonu;
Заметьте, что так как все исключения из модуля plpy.spiexceptions наследуются от исключения
SPIError, команда except, обрабатывающая это исключение, будет перехватывать все ошибки при
обращении к базе данных.
В качестве другого варианта обработки различных условий ошибок, вы можете перехватывать ис-
ключение SPIError и определять конкретное условие ошибки внутри блока except по значению ат-
рибута sqlstate объекта исключения. Этот атрибут содержит строку с кодом ошибки «SQLSTATE».
Конечный результат при таком подходе примерно тот же.
46.8. Явные подтранзакции
Перехват ошибок, произошедших при обращении к базе данных, как описано в Подразделе 46.7.2,
может привести к нежелательной ситуации, когда часть операций будет успешно выполнена,
прежде чем произойдёт сбой. Данные останутся в несогласованном состоянии после обработки
такой ошибки. PL/Python предлагает решение этой проблемы в форме явных подтранзакций.
46.8.1. Менеджеры контекста подтранзакций
Рассмотрим функцию, осуществляющую перевод средств между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'")
plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'")
except plpy.SPIError, e:
result = "error transferring funds: %s" % e.args
else:
result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
Если при выполнении второго оператора UPDATE произойдёт исключение, эта функция сообщит
об ошибке, но результат первого UPDATE будет, тем не менее, зафиксирован. Другими словами,
средства будут списаны со счёта Джо, но не зачислятся на счёт Мэри.
Во избежание таких проблем вы можете завернуть вызовы plpy.execute в явную подтранзакцию.
Модуль plpy предоставляет вспомогательный объект для управления явными подтранзакциями,
создаваемый функцией plpy.subtransaction(). Объекты, созданные этой функцией, реализуют
интерфейс менеджера контекста. Используя явные подтранзакции, мы можем переписать нашу
функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
with plpy.subtransaction():
plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'")
plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'")
except plpy.SPIError, e:
result = "error transferring funds: %s" % e.args
else:
result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
1222PL/Python — проце-
дурный язык Python
Заметьте, что конструкция try/catch по-прежнему нужна. Без неё исключение распространится
вверх по стеку Python и приведёт к прерыванию всей функции с ошибкой PostgreSQL, так что в
таблицу operations запись не добавится. Менеджер контекста подтранзакции не перехватывает
ошибки, он только гарантирует, что все операции с базой данных в его области действия будут
атомарно зафиксированы или отменены. Откат блока подтранзакции происходит при исключении
любого вида, а не только исключения, вызванного ошибками при обращении к базе данных. Обыч-
ное исключение Python, вызванное внутри блока явной подтранзакции, также приведёт к откату
этой подтранзакции.
46.8.2. Старые версии Python
Синтаксис использования менеджеров контекста с ключевым словом with по умолчанию поддер-
живается в Python 2.6. В PL/Python с более старой версией Python тоже возможно использовать
явные подтранзакции, хотя и не так прозрачно. При этом вы можете вызывать методы __enter__
и __exit__ менеджера контекста по удобным псевдонимам enter и exit. Для такого случая функ-
цию перечисления средств можно переписать так:
CREATE FUNCTION transfer_funds_old() RETURNS void AS $$
try:
subxact = plpy.subtransaction()
subxact.enter()
try:
plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'")
plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'")
except:
import sys
subxact.exit(*sys.exc_info())
raise
else:
subxact.exit(None, None, None)
except plpy.SPIError, e:
result = "error transferring funds: %s" % e.args
else:
result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
Примечание
Хотя менеджеры контекста были реализованы в 2.5, для использования синтаксиса
with в этой версии нужно применить «будущий оператор». Однако по техническим
причинам «будущие операторы» в функциях PL/Python использовать нельзя.
46.9. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в ко-
манде DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, вызови-
те plpy.commit(), а чтобы откатить — plpy.rollback(). (Заметьте, что выполнить SQL-команды
COMMIT или ROLLBACK через plpy.execute или подобную функцию нельзя. Соответствующие опера-
ции могут выполняться только данными функциями.) После завершения одной транзакции следу-
ющая начинается автоматически, отдельной функции для этого нет.
Пример:
1223PL/Python — проце-
дурный язык Python
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS $$
for i in range(0, 10):
plpy.execute("INSERT INTO test1 (a) VALUES (%d)" % i)
if i % 2 == 0:
plpy.commit()
else:
plpy.rollback()
$$;
CALL transaction_test1();
Транзакцию нельзя завершить в случае существования открытой явной подтранзакции.
46.10. Вспомогательные функции
Модуль plpy также предоставляет функции
plpy.debug( msg, **kwargs )
plpy.log( msg, **kwargs )
plpy.info( msg, **kwargs )
plpy.notice( msg, **kwargs )
plpy.warning( msg, **kwargs )
plpy.error( msg, **kwargs )
plpy.fatal( msg, **kwargs )
Функции plpy.error и plpy.fatal на самом деле выдают исключение Python, которое, если его
не перехватить, распространяется в вызывающий запрос, что приводит к прерыванию текущей
транзакции или подтранзакции. Команды raise plpy.Error(msg) и raise plpy.Fatal(msg) рав-
нозначны вызовам plpy.error(msg) и plpy.fatal(msg), соответственно, но форма raise не позво-
ляет передавать аргументы с ключами. Другие функции просто выдают сообщения разных уров-
ней важности. Будут ли сообщения определённого уровня передаваться клиентам и/или записы-
ваться в журнал сервера, определяется конфигурационными переменными log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
Аргумент msg задаётся как позиционный. Для обратной совместимости может быть передано
несколько позиционных аргументов. В этом случае сообщением для клиента становится строковое
представление кортежа позиционных аргументов.
Дополнительно только по ключам принимаются следующие аргументы:
detail
hint
sqlstate
schema_name
table_name
column_name
datatype_name
constraint_name
Строковое представление объектов, передаваемых в аргументах по ключам, позволяет выдать кли-
енту более богатую информацию. Например:
CREATE FUNCTION raise_custom_exception() RETURNS void AS $$
plpy.error("custom exception message",
detail="some info about exception",
hint="hint for users")
$$ LANGUAGE plpythonu;
1224PL/Python — проце-
дурный язык Python
=# SELECT raise_custom_exception();
ERROR: plpy.Error: custom exception message
DETAIL: some info about exception
HINT: hint for users
CONTEXT: Traceback (most recent call last):
PL/Python function "raise_custom_exception", line 4, in <module>
hint="hint for users")
PL/Python function "raise_custom_exception"
Ещё
один
набор
вспомогательных
функций
образуют
plpy.quote_literal(строка),
plpy.quote_nullable(строка) и plpy.quote_ident(строка). Они равнозначны встроенным функ-
циям заключения в кавычки, описанным в Разделе 9.4. Они полезны при конструировании свобод-
но составляемых запросов. На PL/Python динамический SQL, показанный в Примере 43.1, форми-
руется так:
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
plpy.quote_ident(colname),
plpy.quote_nullable(newvalue),
plpy.quote_literal(keyvalue)))
46.11. Переменные окружения
Некоторые переменные окружения, воспринимаемые интерпретатором Python, тоже могут влиять
на поведение PL/Python. При необходимости их нужно установить в среде основного серверного
процесса PostgreSQL, например, в скрипте запуска. Множество доступных переменных окружения
зависит от версии Python; за подробностями обратитесь к документации Python. На момент напи-
сания этой документации, на поведение PL/Python влияли следующие переменные окружения, при
наличии подходящей версии Python:
• PYTHONHOME
• PYTHONPATH
• PYTHONY2K
• PYTHONOPTIMIZE
• PYTHONDEBUG
• PYTHONVERBOSE
• PYTHONCASEOK
• PYTHONDONTWRITEBYTECODE
• PYTHONIOENCODING
• PYTHONUSERBASE
• PYTHONHASHSEED
(Похоже, что вследствие тонкостей реализации Python, не зависящих от исполнителя PL/Python,
некоторые переменные окружения, перечисленные на странице руководства man python, действу-
ют только в интерпретаторе для командной строки, но не во встраиваемом интерпретаторе Python.)
1225
