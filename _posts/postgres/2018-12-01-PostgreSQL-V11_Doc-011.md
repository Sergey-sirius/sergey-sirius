---
layout: post
title: Глава 11. Индексы
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 11. Индексы

Индексы — это традиционное средство увеличения производительности БД. Используя индекс,
сервер баз данных может находить и извлекать нужные строки гораздо быстрее, чем без него.
Однако с индексами связана дополнительная нагрузка на СУБД в целом, поэтому применять их
следует обдуманно.
11.1. Введение
Предположим, что у нас есть такая таблица:
CREATE TABLE test1 (
id integer,
content varchar
);
и приложение выполняет много подобных запросов:
SELECT content FROM test1 WHERE id = константа;
Если система не будет заранее подготовлена, ей придётся сканировать всю таблицу test1, стро-
ку за строкой, чтобы найти все подходящие записи. Когда таблица test1 содержит большое коли-
чество записей, а этот запрос должен вернуть всего несколько (возможно, одну или ноль), такое
сканирование, очевидно, неэффективно. Но если создать в системе индекс по полю id, она смо-
жет находить строки гораздо быстрее. Возможно, для этого ей понадобится опуститься всего на
несколько уровней в дереве поиска.
Подобный подход часто используется в технической литературе: термины и понятия, которые мо-
гут представлять интерес, собираются в алфавитном указателе в конце книги. Читатель может
просмотреть этот указатель довольно быстро и затем перейти сразу к соответствующей странице,
вместо того, чтобы пролистывать всю книгу в поисках нужного материала. Так же, как задача ав-
тора предугадать, что именно будут искать в книге читатели, задача программиста баз данных —
заранее определить, какие индексы будут полезны.
Создать индекс для столбца id рассмотренной ранее таблицы можно с помощью следующей ко-
манды:
CREATE INDEX test1_id_index ON test1 (id);
Имя индекса test1_id_index может быть произвольным, главное, чтобы оно позволяло понять,
для чего этот индекс.
Для удаления индекса используется команда DROP INDEX. Добавлять и удалять индексы можно в
любое время.
Когда индекс создан, никакие дополнительные действия не требуются: система сама будет обнов-
лять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её
мнению, это будет эффективнее, чем сканирование всей таблицы. Вам, возможно, придётся только
периодически запускать команду ANALYZE для обновления статистических данных, на основе ко-
торых планировщик запросов принимает решения. В Главе 14 вы можете узнать, как определить,
используется ли определённый индекс и при каких условиях планировщик может решить не ис-
пользовать его.
Индексы могут быть полезны также при выполнении команд UPDATE и DELETE с условиями поиска.
Кроме того, они могут применяться в поиске с соединением. То есть, индекс, определённый для
столбца, участвующего в условии соединения, может значительно ускорить запросы с JOIN.
Создание индекса для большой таблицы может занимать много времени. По умолчанию
PostgreSQL позволяет параллельно с созданием индекса выполнять чтение (операторы SELECT)
таблицы, но операции записи (INSERT, UPDATE и DELETE) блокируются до окончания построения
индекса. Для производственной среды это ограничение часто бывает неприемлемым. Хотя есть
356Индексы
возможность разрешить запись параллельно с созданием индексов, при этом нужно учитывать ряд
оговорок — они описаны в подразделе «Неблокирующее построение индексов».
После создания индекса система должна поддерживать его в состоянии, соответствующем данным
таблицы. С этим связаны неизбежные накладные расходы при изменении данных. Таким образом,
индексы, которые используются в запросах редко или вообще никогда, должны быть удалены.
11.2. Типы индексов
PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для
разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы
запросов. По умолчанию команда CREATE INDEX создаёт индексы типа B-дерево, эффективные в
большинстве случаев.
B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые
можно отсортировать в некотором порядке. Точнее, планировщик запросов PostgreSQL может за-
действовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из сле-
дующих операторов:
<
<=
=
>=
>
При обработке конструкций, представимых как сочетание этих операторов, например BETWEEN и
IN, так же может выполняться поиск по индексу-B-дереву. Кроме того, такие индексы могут ис-
пользоваться и в условиях IS NULL и IS NOT NULL по индексированным столбцам.
Также оптимизатор может использовать эти индексы в запросах с операторами сравнения по шаб-
лону LIKE и ~, если этот шаблон определяется константой и он привязан к началу строки — на-
пример, col LIKE 'foo%' или col ~ '^foo', но не col LIKE '%bar'. Но если ваша база данных
использует не локаль C, для поддержки индексирования запросов с шаблонами вам потребуется
создать индекс со специальным классом операторов; см. Раздел 11.9. Индексы-B-деревья можно
использовать и для ILIKE и ~*, но только если шаблон начинается не с алфавитных символов, то
есть символов, не подверженных преобразованию регистра.
B-деревья могут также применяться для получения данных, отсортированных по порядку. Это не
всегда быстрее простого сканирования и сортировки, но иногда бывает полезно.
Хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может
применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором
=. Создать такой индекс можно следующей командой:
CREATE INDEX имя ON таблица USING HASH (столбец);
GiST-индексы представляют собой не просто разновидность индексов, а инфраструктуру, позволя-
ющую реализовать много разных стратегий индексирования. Как следствие, GiST-индексы могут
применяться с разными операторами, в зависимости от стратегии индексирования (класса опера-
торов). Например, стандартный дистрибутив PostgreSQL включает классы операторов GiST для
нескольких двумерных типов геометрических данных, что позволяет применять индексы в запро-
сах с операторами:
<<
&<
&>
>>
<<|
&<|
|&>
357Индексы
|>>
@>
<@
~=
&&
(Эти операторы описаны в Разделе 9.11.) Классы операторов GiST, включённые в стандартный дис-
трибутив, описаны в Таблице 64.1. В коллекции contrib можно найти и другие классы операторов
GiST, реализованные как отдельные проекты. За дополнительными сведениями обратитесь к Гла-
ве 64.
GiST-индексы также могут оптимизировать поиск «ближайшего соседа», например такой:
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
который возвращает десять расположений, ближайших к заданной точке. Возможность такого
применения индекса опять же зависит от класса используемого оператора. Операторы, которые
можно использовать таким образом, перечислены в Таблице 64.1, в столбце «Операторы сортиров-
ки».
Индексы SP-GiST, как и GiST, предоставляют инфраструктуру, поддерживающие различные типы
поиска. SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры
данных, такие как деревья квадрантов, k-мерные и префиксные деревья. Например, стандартный
дистрибутив PostgreSQL включает классы операторов SP-GiST для точек в двумерном простран-
стве, что позволяет применять индексы в запросах с операторами:
<<
>>
~=
<@
<^
>^
(Эти операторы описаны в Разделе 9.11.) Классы операторов SP-GiST, включённые в стандартный
дистрибутив, описаны в Таблице 65.1. За дополнительными сведениями обратитесь к Главе 65.
GIN-индексы представляют собой «инвертированные индексы», в которых могут содержаться зна-
чения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный
элемент для значения каждого компонента, и может эффективно работать в запросах, проверяю-
щих присутствие определённых значений компонентов.
Подобно GiST и SP-GiST, индексы GIN могут поддерживать различные определённые пользовате-
лем стратегии и в зависимости от них могут применяться с разными операторами. Например, стан-
дартный дистрибутив PostgreSQL включает класс операторов GIN для массивов, что позволяет
применять индексы в запросах с операторами:
<@
@>
=
&&
(Эти операторы описаны в Разделе 9.18.) Классы операторов GIN, включённые в стандартный дис-
трибутив, описаны в Таблице 66.1. В коллекции contrib и в отдельных проектах можно найти и
много других классов операторов GIN. За дополнительными сведениями обратитесь к Главе 66.
BRIN-индексы (сокращение от Block Range INdexes, Индексы зон блоков) хранят обобщённые све-
дения о значениях, находящихся в физически последовательно расположенных блоках таблицы.
Подобно GiST, SP-GiST и GIN, индексы BRIN могут поддерживать определённые пользователем
стратегии, и в зависимости от них применяться с разными операторами. Для типов данных, имею-
щих линейный порядок сортировки, записям в индексе соответствуют минимальные и максималь-
358Индексы
ные значения данных в столбце для каждой зоны блоков. Это позволяет поддерживать запросы со
следующими операторами:
<
<=
=
>=
>
Классы операторов BRIN, включённые в стандартный дистрибутив, описаны в Таблице  67.1. За
дополнительными сведениями обратитесь к Главе 67.
11.3. Составные индексы
Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица:
CREATE TABLE test2 (
major int,
minor int,
name varchar
);
(предположим, что вы поместили в неё содержимое каталога /dev) и вы часто выполняете запросы
вида:
SELECT name FROM test2 WHERE major = константа AND minor = константа;
тогда имеет смысл определить индекс, покрывающий оба столбца major и minor. Например:
CREATE INDEX test2_mm_idx ON test2 (major, minor);
В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Число
столбцов в индексе ограничивается 32. (Этот предел можно изменить при компиляции PostgreSQL;
см. файл pg_config_manual.h.)
Составной индекс-B-дерево может применяться в условиях с любым подмножеством столбцов ин-
декса, но наиболее эффективен он при ограничениях по ведущим (левым) столбцам. Точное прави-
ло состоит в том, что сканируемая область индекса определяется условиями равенства с ведущи-
ми столбцами и условиями неравенства с первым столбцом, не участвующим в условии равенства.
Ограничения столбцов правее них также проверяются по индексу, так что обращение к таблице
откладывается, но на размер сканируемой области индекса это уже не влияет. Например, если
есть индекс по столбцам (a, b, c) и условие WHERE a = 5 AND b >= 42 AND c < 77, индекс будет
сканироваться от первой записи a = 5 и b = 42 до последней с a = 5. Записи индекса, в которых
c >= 77, не будут учитываться, но, тем не менее, будут просканированы. Этот индекс в принципе
может использоваться в запросах с ограничениями по b и/или c, без ограничений столбца a, но при
этом будет просканирован весь индекс, так что в большинстве случаев планировщик предпочтёт
использованию индекса полное сканирование таблицы.
Составной индекс GiST может применяться в условиях с любым подмножеством столбцов индек-
са. Условия с дополнительными столбцами ограничивают записи, возвращаемые индексом, но в
первую очередь сканируемая область индекса определяется ограничением первого столбца. GiST-
индекс будет относительно малоэффективен, когда первый его столбец содержит только несколь-
ко различающихся значений, даже если дополнительные столбцы дают множество различных зна-
чений.
Составной индекс GIN может применяться в условиях с любым подмножеством столбцов индекса.
В отличие от индексов GiST или B-деревьев, эффективность поиска по нему не меняется в зависи-
мости от того, какие из его столбцов используются в условиях запроса.
Составной индекс BRIN может применяться в условиях запроса с любым подмножеством столбцов
индекса. Подобно индексу GIN и в отличие от B-деревьев или GiST, эффективность поиска по нему
359Индексы
не меняется в зависимости от того, какие из его столбцов используются в условиях запроса. Един-
ственное, зачем в одной таблице могут потребоваться несколько индексов BRIN вместо одного со-
ставного индекса — это затем, чтобы применялись разные параметры хранения pages_per_range.
При этом, разумеется, каждый столбец должен использоваться с операторами, соответствующими
типу индекса; ограничения с другими операторами рассматриваться не будут.
Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному
столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чём
трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообраз-
но. Описание достоинств различных конфигураций индексов можно найти в Разделе 11.5 и Разде-
ле 11.11.
11.4. Индексы и предложения ORDER BY
Помимо простого поиска строк для выдачи в результате запроса, индексы также могут применять-
ся для сортировки строк в определённом порядке. Это позволяет учесть предложение ORDER BY
в запросе, не выполняя сортировку дополнительно. Из всех типов индексов, которые поддержива-
ет PostgreSQL, сортировать данные могут только B-деревья — индексы других типов возвращают
строки в неопределённом, зависящем от реализации порядке.
Планировщик может выполнить указание ORDER BY, либо просканировав существующий индекс,
подходящий этому указанию, либо просканировав таблицу в физическом порядке и выполнив сор-
тировку явно. Для запроса, требующего сканирования большой части таблицы, явная сортировка
скорее всего будет быстрее, чем применение индекса, так как при последовательном чтении она
потребует меньше операций ввода/вывода. Важный особый случай представляет ORDER BY в соче-
тании с LIMIT n: при явной сортировке системе потребуется обработать все данные, чтобы выбрать
первые n строк, но при наличии индекса, соответствующего столбцам в ORDER BY, первые n строк
можно получить сразу, не просматривая остальные вовсе.
По умолчанию элементы B-дерева хранятся в порядке возрастания, при этом значения NULL идут
в конце. Это означает, что при прямом сканировании индекса по столбцу x порядок оказывается
соответствующим указанию ORDER BY x (или точнее, ORDER BY x ASC NULLS LAST). Индекс также
может сканироваться в обратную сторону, и тогда порядок соответствует указанию ORDER BY x
DESC (или точнее, ORDER BY x DESC NULLS FIRST, так как для ORDER BY DESC подразумевается
NULLS FIRST).
Вы можете изменить порядок сортировки элементов B-дерева, добавив уточнения ASC, DESC, NULLS
FIRST и/или NULLS LAST при создании индекса; например:
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
Индекс, в котором элементы хранятся в порядке возрастания и значения NULL идут первыми,
может удовлетворять указаниям ORDER BY x ASC NULLS FIRST или ORDER BY x DESC NULLS LAST,
в зависимости от направления просмотра.
У вас может возникнуть вопрос, зачем нужны все четыре варианта при создании индексов, когда
и два варианта с учётом обратного просмотра покрывают все виды ORDER BY. Для индексов по
одному столбцу это и в самом деле излишне, но для индексов по многим столбцам это может быть
полезно. Рассмотрим индекс по двум столбцам (x, y): он может удовлетворять указанию ORDER BY
x, y при прямом сканировании или ORDER BY x DESC, y DESC при обратном. Но вполне возможно,
что приложение будет часто выполнять ORDER BY x ASC, y DESC. В этом случае получить такую
сортировку от простого индекса нельзя, но можно получить подходящий индекс, определив его
как (x ASC, y DESC) или (x DESC, y ASC).
Очевидно, что индексы с нестандартными правилами сортировки весьма специфичны, но иногда
они могут кардинально ускорить определённые запросы. Стоит ли вводить такие индексы, зависит
от того, как часто выполняются запросы с необычным порядком сортировки.
360Индексы
11.5. Объединение нескольких индексов
При простом сканировании индекса могут обрабатываться только те предложения в запросе, в
которых применяются операторы его класса и объединяет их AND. Например, для индекса (a, b)
условие запроса WHERE a = 5 AND b = 6 сможет использовать этот индекс, а запрос WHERE a =
5 OR b = 6 — нет.
К счастью, PostgreSQL способен соединять несколько индексов (и в том числе многократно при-
менять один индекс) и охватывать также случаи, когда сканирования одного индекса недостаточ-
но. Система может сформировать условия AND и OR за несколько проходов индекса. Например, за-
прос WHERE x = 42 OR x = 47 OR x = 53 OR x = 99 можно разбить на четыре сканирования
индекса по x, по сканированию для каждой части условия. Затем результаты этих сканирований
будут логически сложены (OR) вместе и дадут конечный результат. Другой пример — если у нас
есть отдельные индексы по x и y, запрос WHERE x = 5 AND y = 6 можно выполнить, применив
индексы для соответствующих частей запроса, а затем вычислив логическое произведение (AND)
для найденных строк, которое и станет конечным результатом.
Выполняя объединение нескольких индексов, система сканирует все необходимые индексы и со-
здаёт в памяти битовую карту расположения строк таблицы, которые удовлетворяют условиям
каждого индекса. Затем битовые карты объединяются операциями AND и OR, как того требуют
условия в запросе. Наконец система обращается к соответствующим отмеченным строкам табли-
цы и возвращает их данные. Строки таблицы просматриваются в физическом порядке, как они
представлены в битовой карте; это означает, что порядок сортировки индексов при этом теряется
и в запросах с предложением ORDER BY сортировка будет выполняться отдельно. По этой причине,
а также потому, что каждое сканирование индекса занимает дополнительное время, планировщик
иногда выбирает простое сканирование индекса, несмотря на то, что можно было бы подключить
и дополнительные индексы.
В большинстве приложений (кроме самых простых) полезными могут оказаться различные комби-
нации индексов, поэтому разработчик баз данных, определяя набор индексов, должен искать ком-
промиссное решение. Иногда оказываются хороши составные индексы, а иногда лучше создать
отдельные индексы и положиться на возможности объединения индексов. Например, если типич-
ную нагрузку составляют запросы иногда с условием только по столбцу x, иногда только по y, а
иногда по обоим столбцам, вы можете ограничиться двумя отдельными индексами по x и y, рас-
считывая на то, что при обработке условий с обоими столбцами эти индексы будут объединяться.
С другой стороны, вы можете создать один составной индекс по (x, y). Этот индекс скорее всего
будет работать эффективнее, чем объединение индексов, в запросах с двумя столбцами, но как го-
ворилось в Разделе 11.3, он будет практически бесполезен для запросов с ограничениями только
по y, так что одного этого индекса будет недостаточно. Выигрышным в этом случае может быть
сочетание составного индекса с отдельным индексом по y. В запросах, где задействуется только x,
может применяться составной индекс, хотя он будет больше и, следовательно, медленнее индекса
по одному x. Наконец, можно создать все три индекса, но это будет оправдано, только если данные
в таблице изменяются гораздо реже, чем выполняется поиск в таблице, при этом частота запросов
этих трёх типов примерно одинакова. Если запросы какого-то одного типа выполняются гораздо
реже других, возможно лучше будет оставить только два индекса, соответствующих наиболее ча-
стым запросам.
11.6. Уникальные индексы
Индексы также могут обеспечивать уникальность значения в столбце или уникальность сочетания
значений в нескольких столбцах.
CREATE UNIQUE INDEX имя ON таблица (столбец [, ...])
[ INCLUDE (столбец [, ...]) ];
В настоящее время обеспечение уникальности поддерживают только индексы-B-деревья.
Если индекс создаётся как уникальный, в таблицу нельзя будет добавить несколько строк с оди-
наковыми значениями ключа индекса. При этом значения NULL считаются не равными друг дру-
361Индексы
гу. Составной уникальный индекс не принимает только те строки, в которых все индексируемые
столбцы содержат одинаковые значения. Столбцы, включённые предложением INCLUDE, не учиты-
ваются при выявлении одинаковых записей индекса.
Когда для таблицы определяется ограничение уникальности или первичный ключ, PostgreSQL ав-
томатически создаёт уникальный индекс по всем столбцам, составляющим это ограничение или
первичный ключ (индекс может быть составным). Такой индекс и является механизмом, который
обеспечивает выполнение ограничения.
Примечание
Для уникальных столбцов не нужно вручную создавать отдельные индексы — они про-
сто продублируют индексы, созданные автоматически.
11.7. Индексы по выражениям
Индекс можно создать не только по столбцу нижележащей таблицы, но и по функции или скаляр-
ному выражению с одним или несколькими столбцами таблицы. Это позволяет быстро находить
данные в таблице по результатам вычислений.
Например, для сравнений без учёта регистра символов часто используется функция lower:
SELECT * FROM test1 WHERE lower(col1) = 'value';
Этот запрос сможет использовать индекс, определённый для результата функции lower(col1) так:
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
Если мы объявим этот индекс уникальным (UNIQUE), он не даст добавить строки, в которых значения
col1 различаются только регистром, как и те, в которых значения col1 действительно одинаковые.
Таким образом, индексы по выражениям можно использовать ещё и для обеспечения ограничений,
которые нельзя записать как простые ограничения уникальности.
Если же часто выполняются запросы вида:
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
тогда, возможно, стоит создать такой индекс:
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
Синтаксис команды CREATE INDEX обычно требует заключать индексные выражения в скобки, как
показано во втором примере. Если же выражение представляет собой просто вызов функции, как
в первом примере, дополнительные скобки можно опустить.
Поддержка индексируемых выражений обходится довольно дорого, так как эти выражения долж-
ны вычисляться при добавлении каждой строки и при каждом последующем изменении. Однако
при поиске по индексу индексируемое выражение не вычисляется повторно, так как его результат
уже сохранён в индексе. В рассмотренных выше случаях система видит запрос как WHERE столбе-
ц_индекса = 'константа' и поэтому поиск выполняется так же быстро, как и с простым индексом.
Таким образом, индексы по выражениям могут быть полезны, когда скорость извлечения данных
гораздо важнее скорости добавления и изменения.
11.8. Частичные индексы
Частичный индекс — это индекс, который строится по подмножеству строк таблицы, определяе-
мому условным выражением (оно называется предикатом частичного индекса). Такой индекс со-
держит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно спе-
цифичны, но в ряде ситуаций они могут быть очень полезны.
362Индексы
Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать индексирования
распространённых значений. Так как при поиске распространённого значения (такого, которое
содержится в значительном проценте всех строк) индекс всё равно не будет использоваться, хра-
нить эти строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его размер, а
значит и ускорить запросы, использующие этот индекс. Это также может ускорить операции из-
менения данных в таблице, так как индекс будет обновляться не всегда. Возможное применение
этой идеи проиллюстрировано в Примере 11.1.
Пример 11.1. Настройка частичного индекса, исключающего распространённые значения
Предположим, что вы храните в базе данных журнал обращений к корпоративному сайту. Большая
часть обращений будет происходить из диапазона IP-адресов вашей компании, а остальные могут
быть откуда угодно (например, к нему могут подключаться внешние сотрудники с динамическими
IP). Если при поиске по IP вас обычно интересуют внешние подключения, IP-диапазон внутренней
сети компании можно не включать в индекс.
Пусть у вас есть такая таблица:
CREATE TABLE access_log (
url varchar,
client_ip inet,
...
);
Создать частичный индекс для нашего примера можно так:
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip > inet '192.168.100.0' AND
client_ip < inet '192.168.100.255');
Так будет выглядеть типичный запрос, использующий этот индекс:
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
А следующий запрос не будет использовать этот индекс:
SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';
Заметьте, что при таком определении частичного индекса необходимо, чтобы распространённые
значения были известны заранее, так что такие индексы лучше использовать, когда распределе-
ние данных не меняется. Хотя такие индексы можно пересоздавать время от времени, подстраи-
ваясь под новое распределение, это значительно усложняет поддержку.
Во-вторых, частичные индексы могут быть полезны тем, что позволяют исключить из индекса зна-
чения, которые обычно не представляют интереса; это проиллюстрировано в Примере 11.2. При
этом вы получаете те же преимущества, что и в предыдущем случае, но система не сможет извлечь
«неинтересные» значения по этому индексу, даже если сканирование индекса может быть эффек-
тивным. Очевидно, настройка частичных индексов в таких случаях требует тщательного анализа
и тестирования.
Пример 11.2. Настройка частичного индекса, исключающего неинтересные значения
Если у вас есть таблица, в которой хранятся и оплаченные, и неоплаченные счета, и при этом
неоплаченные счета составляют только небольшую часть всей таблицы, но представляют наиболь-
ший интерес, производительность запросов можно увеличить, создав индекс только по неоплачен-
ным счетам. Сделать это можно следующей командой:
CREATE INDEX orders_unbilled_index ON orders (order_nr)
WHERE billed is not true;
363Индексы
Этот индекс будет применяться, например в таком запросе:
SELECT * FROM orders WHERE billed is not true AND order_nr < 10000;
Однако он также может применяться в запросах, где order_nr вообще не используется, например:
SELECT * FROM orders WHERE billed is not true AND amount > 5000.00;
Конечно, он будет не так эффективен, как мог бы быть частичный индекс по столбцу amount, так
как системе придётся сканировать его целиком. Тем не менее, если неоплаченных счетов сравни-
тельно мало, выиграть при поиске неоплаченного счёта можно и с таким частичным индексом.
Заметьте, что в таком запросе этот индекс не будет использоваться:
SELECT * FROM orders WHERE order_nr = 3501;
Счёт с номером 3501 может оказаться, как в числе неоплаченных, так и оплаченных.
Пример 11.2 также показывает, что индексируемый столбец не обязательно должен совпадать со
столбцом, используемым в предикате. PostgreSQL поддерживает частичные индексы с произволь-
ными предикатами — главное, чтобы в них фигурировали только столбцы индексируемой табли-
цы. Однако не забывайте, что предикат должен соответствовать условиям запросов, для оптими-
зации которых предназначается данный индекс. Точнее, частичный индекс будет применяться в
запросе, только если система сможет понять, что условие WHERE данного запроса математически
сводится к предикату индекса. Но учтите, что PostgreSQL не умеет доказывать математические
утверждения об эквивалентности выражений, записанных в разных формах. (Составить програм-
му для таких доказательств крайне сложно, и если даже это удастся, скорость её будет непри-
емлема для применения на практике.) Система может выявить только самые простые следствия
с неравенствами; например, понять, что из «x < 1» следует «x < 2»; во всех остальных случаях
условие предиката должно точно совпадать с условием в предложении WHERE, иначе индекс будет
считаться неподходящим. Сопоставление условий происходит во время планирования запросов, а
не во время выполнения. Как следствие, запросы с параметрами не будут работать с частичными
индексами. Например, условие с параметром «x < ?» в подготовленном запросе никогда не будет
сведено к «x < 2» при всех возможных значениях параметра.
Третье возможное применение частичных индексов вообще не связано с использованием индекса
в запросах. Идея заключается в том, чтобы создать уникальный индекс по подмножеству строк
таблицы, как в Примере 11.3. Это обеспечит уникальность среди строк, удовлетворяющих условию
предиката, но никак не будет ограничивать остальные.
Пример 11.3. Настройка частичного уникального индекса
Предположим, что у нас есть таблица с результатами теста. Мы хотим, чтобы для каждого соче-
тания предмета и целевой темы была только одна запись об успешном результате, а неудачных
попыток могло быть много. Вот как можно этого добиться:
CREATE TABLE tests (
subject text,
target text,
success boolean,
...
);
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
WHERE success;
Это подход будет особенно эффективным, когда неудачных попыток будет намного больше, чем
удачных.
Наконец, с помощью частичных индексов можно также переопределять выбираемый системой
план запроса. Возможно, что для данных с неудачным распределением система решит использо-
вать индекс, тогда как на самом деле это неэффективно. В этом случае индекс можно настроить
так, чтобы в подобных запросах он не работал. Обычно PostgreSQL принимает разумные решения
относительно применения индексов (т. е. старается не использовать их для получения распростра-
364Индексы
нённых значений, так что частичный индекс в вышеприведённом примере помог только умень-
шить размер индекса, для отказа от использования индекса он не требовался), поэтому крайне
неэффективный план может быть поводом для сообщения об ошибке.
Помните, что настраивая частичный индекс, вы тем самым заявляете, что знаете о данных гораз-
до больше, чем планировщик запросов. В частности, вы знаете, когда такой индекс может быть
полезен. Это знание обязательно должно подкрепляться опытом и пониманием того, как работают
индексы в PostgreSQL. В большинстве случаев преимущества частичных индексов по сравнению
с обычными будут минимальными.
Узнать о частичных индексах больше можно в следующих источниках: ston89b, olson93 и
seshadri95.
11.9. Семейства и классы операторов
В определении индекса можно указать класс операторов для каждого столбца индекса.
CREATE INDEX имя ON таблица (столбец класс_операторов [параметры сортировки] [, ...]);
Класс операторов определяет, какие операторы будет использовать индекс для этого столбца. На-
пример, индекс-B-дерево по столбцу int4 будет использовать класс int4_ops; этот класс операто-
ров включает операции со значениями типа int4. На практике часто достаточно принять класс
операторов, назначенный для типа столбца классом по умолчанию. Однако для некоторых типов
данных могут иметь смысл несколько разных вариантов индексирования и реализовать их как раз
позволяют разные классы операторов. Например, комплексные числа можно сортировать как по
вещественной части, так и по модулю. Получить два варианта индексов для них можно, определив
два класса операторов для данного типа и выбрав соответствующий класс при создании индекса.
Выбранный класс операторов задаст основной порядок сортировки данных (его можно уточнить,
добавив параметры COLLATE, ASC/DESC и/или NULLS FIRST/NULLS LAST).
Помимо классов операторов по умолчанию есть ещё несколько встроенных:
• Классы операторов text_pattern_ops, varchar_pattern_ops и bpchar_pattern_ops поддержи-
вают индексы-B-деревья для типов text, varchar и char, соответственно. От стандартных клас-
сов операторов они отличаются тем, что сравнивают значения по символам, не применяя пра-
вила сортировки, определённые локалью. Благодаря этому они подходят для запросов с по-
иском по шаблону (с LIKE и регулярными выражениями POSIX), когда локаль базы данных не
стандартная «C». Например, вы можете проиндексировать столбец varchar так:
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
Заметьте, что при этом также следует создать индекс с классом операторов по умолчанию, ес-
ли вы хотите ускорить запросы с обычными сравнениями <, <=, > и >= за счёт применения ин-
дексов. Классы операторов xxx_pattern_ops не подходят для таких сравнений. (Однако для
проверки равенств эти классы операторов вполне пригодны.) В подобных случаях для одного
столбца можно создать несколько индексов с разными классами операторов. Если же вы ис-
пользуете локаль C, классы операторов xxx_pattern_ops вам не нужны, так как для поиска по
шаблону в локали C будет достаточно индексов с классом операторов по умолчанию.
Следующий запрос выводит список всех существующих классов операторов:
SELECT am.amname AS index_method,
opc.opcname AS opclass_name,
opc.opcintype::regtype AS indexed_type,
opc.opcdefault AS is_default
FROM pg_am am, pg_opclass opc
WHERE opc.opcmethod = am.oid
ORDER BY index_method, opclass_name;
Класс операторов на самом деле является всего лишь подмножеством большой структуры, назы-
ваемой семейством операторов. В случаях, когда несколько типов данных ведут себя одинаково,
часто имеет смысл определить операторы так, чтобы они могли использоваться с индексами сразу
365Индексы
нескольких типов. Сделать это можно, сгруппировав классы операторов для этих типов в одном
семействе операторов. Такие многоцелевые операторы, являясь членами семейства, не будут свя-
заны с каким-либо одним его классом.
Расширенная версия предыдущего запроса показывает семью операторов, к которой принадлежит
каждый класс операторов:
SELECT am.amname AS index_method,
opc.opcname AS opclass_name,
opf.opfname AS opfamily_name,
opc.opcintype::regtype AS indexed_type,
opc.opcdefault AS is_default
FROM pg_am am, pg_opclass opc, pg_opfamily opf
WHERE opc.opcmethod = am.oid AND
opc.opcfamily = opf.oid
ORDER BY index_method, opclass_name;
Этот запрос выводит все существующие семейства операторов и все операторы, включённые в эти
семейства:
SELECT am.amname AS index_method,
opf.opfname AS opfamily_name,
amop.amopopr::regoperator AS opfamily_operator
FROM pg_am am, pg_opfamily opf, pg_amop amop
WHERE opf.opfmethod = am.oid AND
amop.amopfamily = opf.oid
ORDER BY index_method, opfamily_name, opfamily_operator;
11.10. Индексы и правила сортировки
Один индекс может поддерживать только одно правило сортировки для индексируемого столбца.
Поэтому при необходимости применять разные правила сортировки могут потребоваться несколь-
ко индексов.
Рассмотрим следующие операторы:
CREATE TABLE test1c (
id integer,
content varchar COLLATE "x"
);
CREATE INDEX test1c_content_index ON test1c (content);
Этот индекс автоматически использует правило сортировки нижележащего столбца. И запрос ви-
да
SELECT * FROM test1c WHERE content > константа;
сможет использовать этот индекс, так как при сравнении по умолчанию будет действовать прави-
ло сортировки столбца. Однако этот индекс не поможет ускорить запросы с каким-либо другим
правилом сортировки. Поэтому, если интерес представляют также и запросы вроде
SELECT * FROM test1c WHERE content > константа COLLATE "y";
для них можно создать дополнительный индекс, поддерживающий правило сортировки "y", при-
мерно так:
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
11.11. Сканирование только индекса
Все индексы в PostgreSQL являются вторичными, что значит, что каждый индекс хранится вне
области основных данных таблицы (которая в терминологии PostgreSQL называется кучей табли-
366Индексы
цы). Это значит, что при обычном сканировании индекса для извлечения каждой строки необхо-
димо прочитать данные и из индекса, и из кучи. Более того, тогда как элементы индекса, соответ-
ствующие заданному условию WHERE, обычно находятся в индексе рядом, строки таблицы могут
располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по ин-
дексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево,
особенно на традиционных вращающихся носителях. (Как описано в Разделе 11.5, сканирование
по битовой карте пытается снизить стоимость этих операций, упорядочивая доступ к куче, но не
более того.)
Чтобы решить эту проблему с производительностью, PostgreSQL поддерживает сканирование
только индекса, при котором результат запроса может быть получен из самого индекса, без об-
ращения к куче. Основная идея такого сканирования в том, чтобы выдавать значения непосред-
ственно из элемента индекса, и не обращаться к соответствующей записи в куче. Для применения
этого метода есть два фундаментальных ограничения:
1. Тип индекса должен поддерживать сканирование только индекса. Индексы-B-деревья поддер-
живают его всегда. Индексы GiST и SP-GiST могут поддерживать его с одними классами опе-
раторов и не поддерживать с другими. Другие индексы такое сканирование не поддерживают.
Суть нижележащего требования в том, что индекс должен физически хранить или каким-то об-
разом восстанавливать исходное значение данных для каждого элемента индекса. В качестве
контрпримера, индексы GIN неспособны поддерживать сканирование только индекса, так как в
элементах индекса обычно хранится только часть исходного значения данных.
2. Запрос должен обращаться только к столбцам, сохранённым в индексе. Например, если в таб-
лице построен индекс по столбцам x и y, и в ней есть также столбец z, такие запросы будут
использовать сканирование только индекса:
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y < 42;
А эти запросы не будут:
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z < 42;
(Индексы по выражениям и частичные индексы усложняют это правило, как описано ниже.)
Если два этих фундаментальных ограничения выполняются, то все данные, требуемые для выпол-
нения запроса, содержатся в индексе, так что сканирование только по индексу физически воз-
можно. Но в PostgreSQL существует и ещё одно требование для сканирования таблицы: необхо-
димо убедиться, что все возвращаемые строки «видны» в снимке MVCC запроса, как описано в
Главе  13. Информация о видимости хранится не в элементах индекса, а только в куче; поэтому
на первый взгляд может показаться, что для получения данных каждой строки всё равно необхо-
димо обращаться к куче. И это в самом деле так, если в таблице недавно произошли изменения.
Однако для редко меняющихся данных есть возможность обойти эту проблему. PostgreSQL отсле-
живает для каждой страницы в куче таблицы, являются ли все строки в этой странице достаточно
старыми, чтобы их видели все текущие и будущие транзакции. Это отражается в битах в карте
видимости таблицы. Процедура сканирования только индекса, найдя потенциально подходящую
запись в индексе, проверяет бит в карте видимости для соответствующей страницы в куче. Если
он установлен, значит эта строка видна, и данные могут быть возвращены сразу. В противном слу-
чае придётся посетить запись строки в куче и проверить, видима ли она, так что никакого выиг-
рыша по сравнению с обычным сканированием индекса не будет. И даже в благоприятном случае
обращение к кучи не исключается совсем, а заменяется обращением к карте видимости; но так
как карта видимости на четыре порядка меньше соответствующей ей области кучи, для работы с
ней требуется много меньше операций физического ввода/вывода. В большинстве ситуаций карта
видимости просто всё время находится в памяти.
Таким образом, тогда как сканирование только по индексу возможно лишь при выполнении двух
фундаментальных требований, оно даст выигрыш, только если для значительной части страниц в
куче таблицы установлены биты полной видимости. Но таблицы, в которых меняется лишь неболь-
шая часть строк, встречаются достаточно часто, чтобы этот тип сканирования был весьма полезен
на практике.
367Индексы
Чтобы эффективно применять возможность сканирования только индекса, можно создать индек-
сы, в которых только первые столбцы будут соответствовать предложениям WHERE, а остальные
столбцы будут содержать полезные данные, возвращаемые запросом. Например, если вы часто
выполняете запросы вида:
SELECT y FROM tab WHERE x = 'key';
при традиционном подходе к ускорению таких запросов можно было бы создать индекс только
по x. Однако индекс по (x, y) дал бы возможность выполнения этого запроса со сканированием
только индекса. Как говорилось ранее, такой индекс был бы объёмнее и дороже в обслуживании,
чем индекс только по x, так что этот вариант предпочтителен, только для таблиц в основном ста-
тических. Заметьте, что в объявлении индекса важно указать столбцы (x, y), а не (y, x), так как
для большинства типов индексов (а именно, B-деревьев) поиск, при котором не ограничиваются
значения ведущих столбцов индекса, не будет эффективным.
В принципе сканирование только индекса может применяться и с индексами по выражениям. На-
пример, при наличии индекса по f(x), где x — столбец таблицы, должно быть возможно выполнить
SELECT f(x) FROM tab WHERE f(x) < 1;
как сканирование только индекса; и это очень заманчиво, если f() — сложная для вычисления
функция. Однако планировщик PostgreSQL в настоящее время может вести себя не очень разум-
но. Он считает, что запрос может выполняться со сканированием только по индексу, только когда
из индекса могут быть получены все столбцы, требующиеся для запроса. В этом примере x фигу-
рирует только в контексте f(x), но планировщик не замечает этого и решает, что сканирование
только по индексу невозможно. Если сканирование только по индексу заслуживает того, эту про-
блему можно обойти, объявив индекс по (f(x), x), где второй столбец может не использоваться
на практике, но нужен для того, чтобы убедить планировщик, что сканирование только по индексу
возможно. Если это делается ради того, чтобы избежать вычислений f(x), надо также заметить,
что планировщик не обязательно свяжет с использованием индекса упоминания f(x), фигуриру-
ющие не в индексируемых предложениях WHERE со столбцом индекса. Обычно он это делает пра-
вильно в простых запросах, вроде показанного выше, но не в запросах с соединениями. Эти недо-
статки могут быть устранены в будущих версиях PostgreSQL.
С использованием частичных индексов при сканировании только по индексу тоже связаны инте-
ресные особенности. Предположим, что у нас есть частичный индекс, показанный в Примере 11.3:
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
WHERE success;
В принципе с ним мы можем произвести сканирование только по индексу при выполнении запроса
SELECT target FROM tests WHERE subject = 'some-subject' AND success;
Но есть одна проблема: предложение WHERE обращается к столбцу success, который отсутствует в
результирующих столбцах индекса. Тем не менее, сканирование только индекса возможно, так как
плану не нужно перепроверять эту часть предложения WHERE во время выполнения: у всех записей,
найденных в индексе, значение success = true, так что в плане его не нужно проверять явно.
PostgreSQL версий 9.6 и новее распознает такую ситуацию и сможет произвести сканирование
только по индексу, но старые версии неспособны на это.
11.12. Контроль использования индексов
Хотя индексы в PostgreSQL не требуют какого-либо обслуживания или настройки, это не избавляет
от необходимости проверять, как и какие индексы используются на самом деле в реальных усло-
виях. Узнать, как отдельный запрос использует индексы, можно с помощью команды EXPLAIN; её
применение для этих целей описывается в Разделе 14.1. Также возможно собрать общую стати-
стику об использовании индексов на работающем сервере, как описано в Разделе 28.2.
Вывести универсальную формулу, определяющую, какие индексы нужно создавать, довольно
сложно, если вообще возможно. В предыдущих разделах рассматривались некоторые типовые си-
туации, иллюстрирующие подходы к этому вопросу. Часто найти ответ на него помогают экспери-
менты. Ниже приведены ещё несколько советов:
368Индексы
• Всегда начинайте исследование с ANALYZE. Эта команда собирает статистические данные о
распределении значений в таблице, которые необходимы для оценивания числа строк, возвра-
щаемых запросов. А это число, в свою очередь, нужно планировщику, чтобы оценить реаль-
ные затраты для всевозможных планов выполнения запроса. Не имея реальной статистики,
планировщик будет вынужден принять некоторые значения по умолчанию, которые почти на-
верняка не будут соответствовать действительности. Поэтому понять, как индекс использует-
ся приложением без предварительного запуска ANALYZE, практически невозможно. Подробнее
это рассматривается в Подразделе 24.1.3 и Подразделе 24.1.6.
• Используйте в экспериментах реальные данные. Анализируя работу системы с тестовыми дан-
ными, вы поймёте, какие индексы нужны для тестовых данных, но не более того.
Особенно сильно искажают картину очень маленькие наборы тестовых данных. Тогда как для
извлечения 1000 строк из 100000 может быть применён индекс, для выбора 1 из 100 он вряд
ли потребуется, так как 100 строк скорее всего уместятся в одну страницу данных на диске и
никакой другой план не будет лучше обычного сканирования 1 страницы.
Тем не менее, пока приложение не эксплуатируется, создавать какие-то тестовые данные всё
равно нужно, и это нужно делать обдуманно. Если вы наполняете базу данных очень близки-
ми, или наоборот, случайными значениями, либо добавляете строки в отсортированном по-
рядке, вы получите совсем не ту статистику распределения, что дадут реальные данные.
• Когда индексы не используются, ради тестирования может быть полезно подключить их при-
нудительно. Для этого можно воспользоваться параметрами выполнения, позволяющими вы-
ключать различные типы планов (см. Подраздел 19.7.1). Например, выключив наиболее про-
стые планы: последовательное сканирование (enable_seqscan) и соединения с вложенными
циклами (enable_nestloop), вы сможете заставить систему выбрать другой план. Если же си-
стема продолжает выполнять сканирование или соединение с вложенными циклами, вероят-
но, у неё есть более серьёзная причина не использовать индекс; например, индекс может не
соответствовать условию запроса. (Какие индексы работают в запросах разных типов, обсуж-
далось в предыдущих разделах.)
• Если система начинает использовать индекс только под принуждением, тому может быть две
причины: либо система права и применять индекс в самом деле неэффективно, либо оценка
стоимости применения индекса не соответствует действительности. В этом случае вам следу-
ет замерить время выполнения запроса с индексами и без них. В анализе этой ситуации мо-
жет быть полезна команда EXPLAIN ANALYZE.
• Если выясняется, что оценка стоимости неверна, это может иметь тоже два объяснения. Об-
щая стоимость вычисляется как произведение цены каждого узла плана для одной строки и
оценки избирательности узла плана. Цены узлов при необходимости можно изменить пара-
метрами выполнения (описанными в Подразделе 19.7.2). С другой стороны, оценка избира-
тельности может быть неточной из-за некачественной статистики. Улучшить её можно, на-
строив параметры сбора статистики (см. ALTER TABLE).
Если ваши попытки скорректировать стоимость планов не увенчаются успехом, возможно
вам останется только явно заставить систему использовать нужный индекс. Вероятно, имеет
смысл также связаться с разработчиками PostgreSQL, чтобы прояснить ситуацию.
