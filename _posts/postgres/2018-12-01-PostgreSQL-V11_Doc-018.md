---
layout: post
title: Глава 18. Подготовка к работе и сопровождение сервера
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 18. Подготовка к работе и сопровождение сервера

В этой главе рассказывается, как организовать работу сервера баз данных и его взаимодействие с
операционной системой, а также о некоторых задачах сопровождения.
18.1. Учётная запись пользователя PostgreSQL
Как и любую другую службу, доступную для внешнего мира, PostgreSQL рекомендуется запускать
под именем отдельного пользователя. Эта учётная запись должна владеть только данными, кото-
рыми управляет сервер, и разделять её с другими службами не следует. (Например, не стоит ис-
пользовать для этого пользователя nobody.) Также рекомендуется не устанавливать под именем
этого пользователя исполняемые файлы, чтобы их нельзя было подменить в случае компромета-
ции системы.
Для создания пользователя в Unix-подобной системе следует искать команду useradd или adduser.
В качестве имени пользователя часто используется postgres, и именно это имя предполагается в
данной документации, но вы можете выбрать и другое, если захотите.
18.2. Создание кластера баз данных
Прежде чем вы сможете работать с базами данных, вы должны проинициализировать область хра-
нения баз данных на диске. Мы называем это хранилище кластером баз данных. (В SQL приме-
няется термин «кластер каталога».) Кластер баз данных представляет собой набор баз, управля-
емых одним экземпляром работающего сервера. После инициализации кластер будет содержать
базу данных с именем postgres, предназначенную для использования по умолчанию утилитами,
пользователями и сторонними приложениями. Сам сервер баз данных не требует наличия базы
postgres, но многие внешние вспомогательные программы рассчитывают на её существование.
При инициализации в каждом кластере создаётся ещё одна база, с именем template1. Как мож-
но понять из имени, она применяется впоследствии в качестве шаблона создаваемых баз данных;
использовать её в качестве рабочей не следует. (За информацией о создании новых баз данных в
кластере обратитесь к Главе 22.)
С точки зрения файловой системы, кластер баз данных представляет собой один каталог, в кото-
ром будут храниться все данные. Мы называем его каталогом данных или областью данных. Где
именно хранить данные, вы абсолютно свободно можете выбирать сами. Какого-либо стандартно-
го пути не существует, но часто данные размещаются в /usr/local/pgsql/data или в /var/lib/
pgsql/data. Для инициализации кластера баз данных применяется команда initdb,которая уста-
навливается в составе PostgreSQL. Расположение кластера базы данных в файловой системе зада-
ётся параметром -D, например:
$ initdb -D /usr/local/pgsql/data
Заметьте, что эту команду нужно выполнять от имени учётной записи PostgreSQL, о которой гово-
рится в предыдущем разделе.
Подсказка
В качестве альтернативы параметра -D можно установить переменную окружения
PGDATA.
Также можно запустить команду initdb, воспользовавшись программой pg_ctl , примерно так:
$ pg_ctl -D /usr/local/pgsql/data initdb
Этот вариант может быть удобнее, если вы используете pg_ctl для запуска и остановки сервера
(см. Раздел  18.3), так как pg_ctl будет единственной командой, с помощью которой вы будете
управлять экземпляром сервера баз данных.
478Подготовка к работе и
сопровождение сервера
Команда initdb попытается создать указанный вами каталог, если он не существует. Конечно,
она не сможет это сделать, если initdb не будет разрешено записывать в родительский каталог.
Вообще рекомендуется, чтобы пользователь PostgreSQL был владельцем не только каталога дан-
ных, но и родительского каталога, так что такой проблемы быть не должно. Если же и нужный
родительский каталог не существует, вам нужно будет сначала создать его, используя права root,
если вышестоящий каталог защищён от записи. Таким образом, процедура может быть такой:
root# mkdir /usr/local/pgsql
root# chown postgres /usr/local/pgsql
root# su postgres
postgres$ initdb -D /usr/local/pgsql/data
Команда initdb не будет работать, если указанный каталог данных уже существует и содержит
файлы; это мера предохранения от случайной перезаписи существующей инсталляции.
Так как каталог данных содержит все данные базы, очень важно защитить его от неавторизованно-
го доступа. Для этого initdb лишает прав доступа к нему всех пользователей, кроме пользователя
PostgreSQL и, возможно, его группы. Если группе разрешается доступ, то только для чтения. Это
позволяет непривилегированному пользователю, входящему в одну группу с владельцем кластера,
делать резервные копии данных кластера или выполнять другие операции, для которых достаточ-
но доступа только для чтения.
Заметьте, чтобы корректно разрешить или запретить доступ группы к данным существующего кла-
стера, необходимо выключить кластер и установить соответствующий режим для всех каталогов и
файлов до запуска PostgreSQL. В противном случае в каталоге данных возможно смешение режи-
мов. Для кластеров, к которым имеет доступ только владелец, требуется установить режим 0700
для каталогов и 0600 для файлов, а для кластеров, в которых также разрешается чтение группой,
режим 0750 для каталогов и 0640 для файлов.
Однако, даже когда содержимое каталога защищено, если проверка подлинности клиентов на-
строена по умолчанию, любой локальный пользователь может подключиться к базе данных и да-
же стать суперпользователем. Если вы не доверяете другим локальным пользователям, мы реко-
мендуем использовать один из параметров команды initdb: -W, --pwprompt или --pwfile и назна-
чить пароль суперпользователя баз данных. Кроме того, воспользуйтесь параметром -A md5 или -A
password и отключите разрешённый по умолчанию режим аутентификации trust; либо измените
сгенерированный файл pg_hba.conf после выполнения initdb, но перед тем, как запустить сервер
в первый раз. (Возможны и другие разумные подходы — применить режим проверки подлинности
peer или ограничить подключения на уровне файловой системы. За дополнительными сведениями
обратитесь к Главе 20.)
Команда initdb также устанавливает для кластера баз данных локаль по умолчанию. Обычно она
просто берёт параметры локали из текущего окружения и применяет их к инициализируемой базе
данных. Однако можно выбрать и другую локаль для базы данных; за дополнительной информа-
цией обратитесь к Разделу  23.1. Команда initdb задаёт порядок сортировки по умолчанию для
применения в определённом кластере баз данных, и хотя новые базы данных могут создаваться
с иным порядком сортировки, порядок в базах-шаблонах, создаваемых initdb, можно изменить,
только если удалить и пересоздать их. Также учтите, что при использовании локалей, отличных
от C и POSIX, возможно снижение производительности. Поэтому важно правильно выбрать локаль
с самого начала.
Команда initdb также задаёт кодировку символов по умолчанию для кластера баз данных. Обычно
она должна соответствовать кодировке локали. За подробностями обратитесь к Разделу 23.3.
Для локалей, отличных от C и POSIX, порядок сортировки символов зависит от системной библио-
теки локализации, а он, в свою очередь, влияет на порядок ключей в индексах. Поэтому кластер
нельзя перевести на несовместимую версию библиотеки ни путём восстановления снимка, ни че-
рез двоичную репликацию, ни перейдя на другую операционную систему или обновив её версию.
18.2.1. Использование дополнительных файловых систем
479Подготовка к работе и
сопровождение сервера
Во многих инсталляциях кластеры баз данных создаются не в «корневом» томе, а в отдельных
файловых системах (томах). Если вы решите сделать так же, то не следует выбирать в качестве ка-
талога данных самый верхний каталог дополнительного тома (точку монтирования). Лучше всего
создать внутри каталога точки монтирования каталог, принадлежащий пользователю PostgreSQL,
а затем создать внутри него каталог данных. Это исключит проблемы с разрешениями, особенно
для таких операций, как pg_upgrade, и при этом гарантирует чистое поведение в случае, если до-
полнительный том окажется отключён.
18.2.2. Использование сетевых файловых систем
Во многих инсталляциях кластеры баз данных создаются в сетевых файловых ресурсах. Иногда
это реализуется с применением сетевой файловой системы (NFS, Network File System) или сете-
вых хранилищ (NAS, Network Attached Storage), использующих NFS внутри. PostgreSQL не делает
ничего специфического с файловыми системами NFS, то есть он предполагает, что NFS работает
точно так же, как и локально подключённые диски. Но если реализация клиента или сервера NFS
не обеспечивает стандартное поведение файловой системы, это чревато нестабильной работой (см.
https://www.time-travellers.org/shane/papers/NFS_considered_harmful.html). В частности, возможно
разрушение данных при отложенной (асинхронной) записи на сервер NFS. Поэтому, по возможно-
сти, во избежание таких проблем монтируйте файловые системы NFS в синхронном режиме (без
кеширования). Кроме того, не рекомендуется применять мягкое монтирование файловой системы
NFS.
В сетях хранения данных (SAN, Storage Area Networks) обычно используются собственные прото-
колы, не NFS, и они могут быть не подвержены (а могут быть и подвержены) этим рискам. По во-
просам гарантии согласованности данных обратитесь к документации производителя. PostgreSQL
не может быть надёжнее файловой системы, которую он использует.
18.3. Запуск сервера баз данных
Чтобы кто-либо смог обратиться к базе данных, необходимо сначала запустить сервер баз данных.
Программа сервера называется postgres.Для работы программа postgres должна знать, где найти
данные, которые она будет использовать. Указать это местоположение позволяет параметр -D.
Таким образом, проще всего запустить сервер, выполнив команду:
$ postgres -D /usr/local/pgsql/data
в результате которой сервер продолжит работу в качестве процесса переднего плана. Запускать
эту команду следует под именем учётной записи PostgreSQL. Без параметра -D сервер попытается
использовать каталог данных, указанный в переменной окружения PGDATA. Если и эта переменная
не определена, сервер не будет запущен.
Однако обычно лучше запускать postgres в фоновом режиме. Для этого можно применить обыч-
ный синтаксис, принятый в оболочке Unix:
$ postgres -D /usr/local/pgsql/data >logfile 2>&1 &
Важно где-либо сохранять информацию, которую выводит сервер в каналы stdout и stderr, как по-
казано выше. Это полезно и для целей аудита, и для диагностики проблем. (Более глубоко работа
с файлами журналов рассматривается в Разделе 24.3.)
Программа postgres также принимает несколько других параметров командной строки. За допол-
нительными сведениями обратитесь к справочной странице postgres и к следующей Главе 19.
Такой вариант запуска довольно быстро может оказаться неудобным. Поэтому для упрощения по-
добных задач предлагается вспомогательная программа pg_ctl. Например:
pg_ctl start -l logfile
запустит сервер в фоновом режиме и направит выводимые сообщения сервера в указанный файл
журнала. Параметр -D для неё имеет то же значение, что и для программы postgres. С помощью
pg_ctl также можно остановить сервер.
Обычно возникает желание, чтобы сервер баз данных сам запускался при загрузке операционной
системы.Скрипты автозапуска для разных систем разные, но в составе PostgreSQL предлагается
480Подготовка к работе и
сопровождение сервера
несколько типовых скриптов в каталоге contrib/start-scripts. Для установки такого скрипта в
систему требуются права root.
В различных системах приняты разные соглашения о порядке запуска служб в процессе загрузки.
Во многих системах для этого используется файл /etc/rc.local или /etc/rc.d/rc.local. В других
применяются каталоги init.d или rc.d. Однако при любом варианте запускаться сервер должен
от имени пользователя PostgreSQL, но не root или какого-либо другого пользователя. Поэтому ко-
манду запуска обычно следует записывать в форме su postgres -c '...'. Например:
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
Ниже приведены более конкретные предложения для нескольких основных ОС. (Вместо указан-
ных нами шаблонных значений необходимо подставить правильный путь к каталогу данных и фак-
тическое имя пользователя.)
• Для запуска во FreeBSD воспользуйтесь файлом contrib/start-scripts/freebsd в дереве ис-
ходного кода PostgreSQL.
• В OpenBSD, добавьте в файл /etc/rc.local следующие строки:
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -
D /usr/local/pgsql/data'
echo -n ' postgresql'
fi
• В системах Linux вы можете либо добавить
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
в /etc/rc.d/rc.local или в /etc/rc.local, либо воспользоваться файлом contrib/start-
scripts/linux в дереве исходного кода PostgreSQL.
Используя systemd, вы можете применить следующий файл описания службы (например, /
etc/systemd/system/postgresql.service):
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)
[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0
[Install]
WantedBy=multi-user.target
Для использования Type=notify требуется, чтобы сервер был скомпилирован с указанием
configure --with-systemd.
Особого внимания заслуживает значение тайм-аута. На момент написания этой документации
по умолчанию в systemd принят тайм-аут 90 секунд, так что процесс, не сообщивший о своей
готовности за это время, будет уничтожен. Но серверу PostgreSQL при запуске может потре-
боваться выполнить восстановление после сбоя, так что переход в состояние готовности мо-
жет занять гораздо больше времени. Предлагаемое значение 0 отключает логику тайм-аута.
• В NetBSD можно использовать скрипт запуска для FreeBSD или для Linux, в зависимости от
предпочтений.
481Подготовка к работе и
сопровождение сервера
• В Solaris, создайте файл с именем /etc/init.d/postgresql, содержащий следующую стоку:
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/
data"
Затем создайте символическую ссылку на него в каталоге /etc/rc3.d с именем
S99postgresql.
Когда сервер работает, идентификатор его процесса (PID) сохраняется в файле postmaster.pid в
каталоге данных. Это позволяет исключить запуск нескольких экземпляров сервера с одним ката-
логом данных, а также может быть полезно для выключения сервера.
18.3.1. Сбои при запуске сервера
Есть несколько распространённых причин, по которым сервер может не запуститься. Чтобы по-
нять, чем вызван сбой, просмотрите файл журнала сервера или запустите сервер вручную (не пе-
ренаправляя его потоки стандартного вывода и ошибок) и проанализируйте выводимые сообще-
ния. Ниже мы рассмотрим некоторые из наиболее частых сообщений об ошибках более подробно.
LOG: could not bind IPv4 address "127.0.0.1": Address already in use
HINT: Is another postmaster already running on port 5432? If not, wait a few seconds
and retry.
FATAL: could not create any TCP/IP sockets
Это обычно означает именно то, что написано: вы пытаетесь запустить сервер на том же порту,
на котором уже работает другой. Однако, если сообщение ядра не Address already in use или
подобное, возможна и другая проблема. Например, при попытке запустить сервер с номером за-
резервированного порта будут выданы такие сообщения:
$ postgres -p 666
LOG: could not bind IPv4 address "127.0.0.1": Permission denied
HINT: Is another postmaster already running on port 666? If not, wait a few seconds
and retry.
FATAL: could not create any TCP/IP sockets
Следующее сообщение:
FATAL: could not create shared memory segment: Invalid argument
DETAIL: Failed system call was shmget(key=5440001, size=4011376640, 03600).
может означать, что установленный для вашего ядра предельный размер разделяемой памяти
слишком мал для рабочей области, которую пытается создать PostgreSQL (в данном примере
4011376640 байт). Возможно также, что в вашем ядре вообще отсутствует поддержка разделяемой
памяти в стиле System-V. В качестве временного решения можно попытаться запустить сервер с
меньшим числом буферов (shared_buffers), но в итоге вам, скорее всего, придётся переконфигури-
ровать ядро и увеличить допустимый размер разделяемой памяти. Вы также можете увидеть это
сообщение при попытке запустить несколько серверов на одном компьютере, если запрошенный
ими объём разделяемой памяти в сумме превышает этот предел.
Сообщение:
FATAL: could not create semaphores: No space left on device
DETAIL: Failed system call was semget(5440126, 17, 03600).
не означает, что у вас закончилось место на диске. Это значит, что установленное в вашем ядре
предельное число семафоров System V меньше, чем количество семафоров, которое пытается со-
здать PostgreSQL. Как и в предыдущем случае, можно попытаться обойти эту проблему, запустив
сервер с меньшим числом допустимых подключений (max_connections), но в конце концов вам при-
дётся увеличить этот предел в ядре.
Если вы получаете ошибку «illegal system call» (неверный системный вызов), то, вероятнее всего,
ваше ядро вовсе не поддерживает разделяемую память или семафоры. В этом случае, вам остаётся
только переконфигурировать ядро и включить их поддержку.
Настройка средств IPC в стиле System V описывается в Подразделе 18.4.1.
482Подготовка к работе и
сопровождение сервера
18.3.2. Проблемы с подключениями клиентов
Хотя ошибки подключений, возможные на стороне клиента, довольно разнообразны и зависят от
приложений, всё же несколько проблем могут быть связаны непосредственно с тем, как был за-
пущен сервер. Описание ошибок, отличных от описанных ниже, следует искать в документации
соответствующего клиентского приложения.
psql: could not connect to server: Connection refused
Is the server running on host "server.joe.com" and accepting
TCP/IP connections on port 5432?
Это общая проблема «я не могу найти сервер и начать взаимодействие с ним». Показанное выше
сообщение говорит о попытке установить подключение по TCP/IP. Очень часто объясняется это
тем, что сервер просто забыли настроить для работы по протоколу TCP/IP.
Кроме того, при попытке установить подключение к локальному серверу через Unix-сокет можно
получить такое сообщение:
psql: could not connect to server: No such file or directory
Is the server running locally and accepting
connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
Путь в последней строке помогает понять, к правильному ли адресу пытается подключиться кли-
ент. Если сервер на самом деле не принимает подключения по этому адресу, обычно выдаётся
сообщение ядра Connection refused (В соединении отказано) или No such file or directory
(Нет такого файла или каталога), приведённое выше. (Важно понимать, что Connection refused
в данном контексте не означает, что сервер получил запрос на подключение и отверг его. В этом
случае были бы выданы другие сообщения, например, показанные в Разделе 20.15.) Другие сооб-
щения об ошибках, например Connection timed out (Тайм-аут соединения) могут сигнализировать
о более фундаментальных проблемах, например, о нарушениях сетевых соединений.
18.4. Управление ресурсами ядра
PostgreSQL иногда может исчерпывать некоторые ресурсы операционной системы до предела, осо-
бенно при запуске нескольких копий сервера в одной системе или при работе с очень большими
базами. В этом разделе описываются ресурсы ядра, которые использует PostgreSQL, и подходы к
решению проблем, связанных с ограниченностью этих ресурсов.
18.4.1. Разделяемая память и семафоры
PostgreSQL требует, чтобы операционная система предоставляла средства межпроцессного взаи-
модействия (IPC), в частности, разделяемую память и семафоры. Системы семейства Unix обычно
предоставляют функции IPC в стиле «System V» или функции IPC в стиле «POSIX» или и те, и дру-
гие. В Windows эти механизмы реализованы по-другому, но здесь это не рассматривается.
Если эти механизмы полностью отсутствуют в системе, при запуске сервера обычно выдаётся
ошибка «Illegal system call» (Неверный системный вызов). В этом случае единственный способ ре-
шить проблему — переконфигурировать ядро системы. Без них PostgreSQL просто не будет рабо-
тать. Это довольно редкая ситуация, особенно с современными операционными системами.
При запуске сервера PostgreSQL обычно запрашивает очень небольшой объём разделяемой памя-
ти System V и намного больший объём памяти POSIX (mmap). Помимо этого при запуске создаётся
значительное количество семафоров (в стиле System V или POSIX). В настоящее время семафоры
POSIX используются в системах Linux и FreeBSD, а на других платформах используются семафоры
System V.
Примечание
PostgreSQL до версии 9.3 использовал только разделяемую память System V, поэтому
необходимый для запуска сервера объём разделяемой памяти System V был гораздо
483Подготовка к работе и
сопровождение сервера
больше. Если вы используете более раннюю версию сервера, обратитесь к документа-
ции по вашей версии.
Функции IPC в стиле System V обычно сталкиваются с лимитами на уровне системы. Когда
PostgreSQL превышает один из этих лимитов, сервер отказывается запускаться, но должен выдать
полезное сообщение, говорящее об ошибке и о том, что с ней делать. (См. также Подраздел 18.3.1.)
Соответствующие параметры ядра в разных системах называются аналогично (они перечислены
в Таблице 18.1), но устанавливаются по-разному. Ниже предлагаются способы их изменения для
некоторых систем.
Таблица 18.1. Параметры IPC в стиле System V
Имя Описание
Значения, необходимые для
запуска одного экземпляра
PostgreSQL
SHMMAX Максимальный размер сегмен- как минимум 1 КБ, но значение
та разделяемой памяти (в бай- по умолчанию обычно гораздо
тах)
больше
SHMMIN Минимальный размер сегмента 1
разделяемой памяти (в байтах)
SHMALL Общий объём доступной разде- если в байтах, то же, что
ляемой памяти (в байтах или и SHMMAX; если в страницах,
страницах)
то ceil(SHMMAX/PAGE_SIZE) ,
плюс потребность других при-
ложений
SHMSEG Максимальное число сегментов требуется только 1 сегмент, но
разделяемой памяти для про- значение по умолчанию гораз-
цесса
до больше
SHMMNI Максимальное число сегментов как SHMSEG плюс потребность
разделяемой памяти для всей других приложений
системы
SEMMNI Максимальное число идентифи- как
минимум
ceil((max_
каторов семафоров (т. е., их на- connections + autovacuum_
боров)
max_workers + max_worker_
processes + 5) / 16) плюс по-
требность других приложений
SEMMNS Максимальное число семафо- ceil((max_connections
+
ров для всей системы
autovacuum_max_workers
+
max_worker_processes + 5) /
16) * 17 плюс потребность дру-
гих приложений
SEMMSL Максимальное число семафо- не меньше 17
ров в наборе
SEMMAP Число записей в карте семафо- см. текст
ров
SEMVMX Максимальное значение сема- не меньше 1000 (по умолчанию
фора
оно обычно равно 32767; без
необходимости менять его не
следует)
PostgreSQL запрашивает небольшой блок разделяемой памяти System V (обычно 48 байт на 64-
битной платформе) для каждой копии сервера. В большинстве современных операционных систем
такой объём выделяется без проблем. Однако, если запускать много копий сервера или разделяе-
484Подготовка к работе и
сопровождение сервера
мую память System V занимают и другие приложения, может понадобиться увеличить значение
SHMALL, задающее общий объём разделяемой памяти System V, доступный для всей системы. За-
метьте, что SHMALL во многих системах задаётся в страницах, а не в байтах.
Менее вероятны проблемы с минимальным размером сегментов разделяемой памяти (SHMMIN), ко-
торый для PostgreSQL не должен превышать примерно 32 байт (обычно это всего 1 байт). Макси-
мальное число сегментов для всей системы (SHMMNI) или для одного процесса (SHMSEG) тоже обыч-
но не влияет на работоспособность сервера, если только это число не равно нулю.
Когда PostgreSQL использует семафоры System V, он занимает по одному семафору на одно
разрешённое подключение (max_connections), на разрешённый рабочий процесс автоочистки
(autovacuum_max_workers) и фоновый процесс (max_worker_processes), в наборах по 16. В каждом
таком наборе есть также 17-ый семафор, содержащий «магическое число», позволяющий обнару-
живать коллизии с наборами семафоров других приложений. Максимальное число семафоров в си-
стеме задаётся параметром SEMMNS, который, следовательно, должен быть равен как минимум сум-
ме max_connections, autovacuum_max_workers и max_worker_processes, плюс один дополнитель-
ный на каждые 16 семафоров подключений и рабочих процессов (см. формулу в Таблице  18.1).
Параметр SEMMNI определяет максимальное число наборов семафоров, которые могут существо-
вать в системе в один момент времени. Таким образом, этот параметр должен быть не меньше
ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16). В ка-
честве временного решения проблем, которые вызваны этими ограничениями, но обычно сопро-
вождаются некорректными сообщениями, например, «No space left on device» (На устройстве не
осталось места) от функции semget, можно уменьшить число разрешённых соединений
В некоторых случаях может потребоваться увеличить SEMMAP как минимум до уровня SEMMNS. Этот
параметр определяет размер карты ресурсов семафоров, в которой выделяется запись для каж-
дого непрерывного блока семафоров. Когда набор семафоров освобождается, эта запись либо до-
бавляется к существующей соседней записи, либо регистрируется как новая запись в карте. Ес-
ли карта переполняется, освобождаемые семафоры теряются (до перезагрузки). Таким образом,
фрагментация пространства семафоров может со времени привести к уменьшению числа доступ-
ных семафоров.
Другие параметры, связанные с «аннулированием операций» с семафорами, например, SEMMNU и
SEMUME, на работу PostgreSQL не влияют.
При использовании семафоров POSIX требуемое их количество не отличается от количества
для System V, то есть по одному семафору на разрешённое подключение (max_connections),
на разрешённый рабочий процесс автоочистки (autovacuum_max_workers) и фоновый процесс
(max_worker_processes). На платформах, где предпочитается этот вариант, отсутствует определён-
ный лимит ядра на количество семафоров POSIX.
AIX
Как минимум с версии 5.1, для таких параметров, как SHMMAX, никакая дополнительная на-
стройка не должна требоваться, так как система, похоже, позволяет использовать всю память
в качестве разделяемой. Подобная конфигурация требуется обычно и для других баз данных,
например, для DB/2.
Однако может понадобиться изменить глобальные параметры ulimit в /etc/security/limits,
так как стандартные жёсткие ограничения на размер (fsize) и количество файлов (nofiles)
могут быть недостаточно большими.
FreeBSD
Значения по умолчанию можно изменить, используя возможности sysctl или loader. С помо-
щью sysctl можно задать следующие параметры:
# sysctl kern.ipc.shmall=32768
# sysctl kern.ipc.shmmax=134217728
Чтобы эти изменения сохранялись после перезагрузки, измените /etc/sysctl.conf.
485Подготовка к работе и
сопровождение сервера
Эти параметры, связанные с семафорами, sysctl менять не позволяет, но их можно задать в
/boot/loader.conf:
kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256
Чтобы изменённые таким образом параметры вступили в силу, требуется перезагрузить си-
стему. (Заметьте, что во FreeBSD нет параметра SEMMAP. В старых версиях значение для
kern.ipc.semmap принималось, но игнорировалось; новые версии его не принимают.)
Возможно, вы захотите настроить ядро так, чтобы разделяемая память всегда находилась в ОЗУ
и никогда не выгружалась в пространство подкачки. Это можно сделать, установив с помощью
sysctl параметр kern.ipc.shm_use_phys.
Если
вы
используете
«камеры»
FreeBSD,
включив
в
sysctl
параметр
security.jail.sysvipc_allowed, главные процессы postmaster, работающие в разных камерах,
должны запускаться разными пользователями операционной системы. Это усиливает защи-
ту, так как не позволяет обычным пользователям обращаться к разделяемой памяти или се-
мафорам в разных камерах, и при этом способствует корректной работе кода очистки IPC в
PostgreSQL. (Во FreeBSD 6.0 и более поздних версиях код очистки IPC не может корректно вы-
явить процессы в других камерах, что не позволяет запускать процессы postmaster на одном
порту в разных камерах.)
До версии 4.0 система FreeBSD работала так же, как сейчас OpenBSD (см. ниже).
NetBSD
В NetBSD, начиная с версии 5.0, параметры IPC можно изменить, воспользовавшись командой
sysctl, например:
$ sysctl -w kern.ipc.shmmax=16777216
Чтобы эти параметры сохранялись после перезагрузки, измените /etc/sysctl.conf.
Возможно, вы захотите настроить ядро так, чтобы разделяемая память всегда находилась в ОЗУ
и никогда не выгружалась в пространство подкачки. Это можно сделать, установив с помощью
sysctl параметр kern.ipc.shm_use_phys.
До версии 5.0 система NetBSD работала так же, как сейчас OpenBSD (см. ниже), за исключе-
нием того, что параметры устанавливаются с указанием options, а не option.
OpenBSD
При компиляции ядра должны быть включены механизмы SYSVSHM и SYSVSEM. (По умолча-
нию они включены.) Максимальный размер разделяемой памяти определяется параметром
SHMMAXPGS (в страницах). Ниже показан пример, как установить следующие параметры:
option
option
option SYSVSHM
SHMMAXPGS=4096
SHMSEG=256
option
option
option
option SYSVSEM
SEMMNI=256
SEMMNS=512
SEMMNU=256
HP-UX
Значения по умолчанию обычно вполне удовлетворяют средним потребностям. В HP-UX 10 па-
раметр SEMMNS по умолчанию имеет значение 128, что может быть недостаточно для больших
баз данных.
486Подготовка к работе и
сопровождение сервера
Параметры IPC можно установить в менеджере системного администрирования (System
Administration Manager, SAM) в разделе Kernel Configuration (Настройка ядра) → Configurable
Parameters (Настраиваемые параметры). Установив нужные параметры, выполните операцию
Create A New Kernel (Создать ядро).
Linux
По умолчанию максимальный размер сегмента равен 32 МБ, а максимальный общий размер
составляет 2097152 страниц. Страница почти всегда содержит 4096 байт, за исключением
нестандартных конфигураций ядра с поддержкой «огромных страниц» (точно узнать размер
страницы можно, выполнив getconf PAGE_SIZE).
Параметры размера разделяемой памяти можно изменить, воспользовавшись командой
sysctl. Например, так можно выделить 16 ГБ для разделяемой памяти:
$ sysctl -w kernel.shmmax=17179869184
$ sysctl -w kernel.shmall=4194304
Чтобы сохранить эти изменения после перезагрузки, их также можно записать в файл /etc/
sysctl.conf (это настоятельно рекомендуется).
В некоторых старых дистрибутивах может не оказаться программы sysctl, но те же изменения
можно произвести, обратившись к файловой системе /proc:
$ echo 17179869184 >/proc/sys/kernel/shmmax
$ echo 4194304 >/proc/sys/kernel/shmall
Остальные параметры имеют вполне подходящие значения, так что их обычно менять не нуж-
но.
macOS
Для настройки разделяемой памяти в macOS рекомендуется создать файл /etc/sysctl.conf и
записать в него присвоения переменных следующим образом:
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
Заметьте, что в некоторых версиях macOS, все пять параметров разделяемой памяти должны
быть установлены в /etc/sysctl.conf, иначе их значения будут проигнорированы.
Имейте в виду, что последние версии macOS игнорируют попытки задать для SHMMAX значение,
не кратное 4096.
SHMALL на этой платформе измеряется в страницах (по 4 КБ).
В старых версиях macOS, чтобы изменения параметров разделяемой памяти вступили в силу,
требовалась перезагрузка. Начиная с версии 10.5, все параметры, кроме SHMMNI можно изме-
нить «на лету», воспользовавшись командой sysctl. Но, тем не менее, лучше задавать выбран-
ные вами значения в /etc/sysctl.conf, чтобы они сохранялись после перезагрузки.
Файл /etc/sysctl.conf обрабатывается только начиная с macOS версии 10.3.9. Если вы ис-
пользуете предыдущий выпуск 10.3.x, необходимо отредактировать файл /etc/rc и задать зна-
чения следующими командами:
sysctl
sysctl
sysctl
sysctl
-w
-w
-w
-w
kern.sysv.shmmax
kern.sysv.shmmin
kern.sysv.shmmni
kern.sysv.shmseg
487Подготовка к работе и
сопровождение сервера
sysctl -w kern.sysv.shmall
Заметьте, что /etc/rc обычно заменяется при обновлении системы macOS, так что следует
ожидать, что вам придётся повторять эти изменения после каждого обновления.
В macOS 10.2 и более ранних версиях вместо этого надо записать эти команды в файле /System/
Library/StartupItems/SystemTuning/SystemTuning.
Solaris версии с 2.6 по 2.9 (Solaris 6 .. Solaris 9)
Соответствующие параметры можно изменить в /etc/system, например так:
set
set
set
set shmsys:shminfo_shmmax=0x2000000
shmsys:shminfo_shmmin=1
shmsys:shminfo_shmmni=256
shmsys:shminfo_shmseg=256
set
set
set
set semsys:seminfo_semmap=256
semsys:seminfo_semmni=512
semsys:seminfo_semmns=512
semsys:seminfo_semmsl=32
Чтобы изменения вступили в силу, потребуется перегрузить систему. Информацию о разделя-
емой памяти в более старых версиях Solaris можно найти по ссылке http://sunsite.uakom.sk/
sunworldonline/swol-09-1997/swol-09-insidesolaris.html.
Solaris 2.10 (Solaris 10) и более поздние версии
OpenSolaris
В Solaris 10 и новее, а также в OpenSolaris, стандартные параметры разделяемой памяти и се-
мафоров достаточно хороши для большинства применений PostgreSQL. По умолчанию Solaris
теперь устанавливает в SHMMAX четверть объёма ОЗУ. Чтобы изменить этот параметр, восполь-
зуйтесь возможностью задать параметр проекта, связанного с пользователем postgres. Напри-
мер, выполните от имени root такую команду:
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U
postgres -G postgres user.postgres
Эта команда создаёт проект user.postgres и устанавливает максимальный объём разделяемой
памяти для пользователя postgres равным 8 ГБ. Это изменение вступает в силу при следую-
щем входе этого пользователя или при перезапуске PostgreSQL (не перезагрузке конфигура-
ции). При этом подразумевается, что PostgreSQL выполняется пользователем postgres в груп-
пе postgres. Перезагружать систему после этой команды не нужно.
Для серверов баз данных, рассчитанных на большое количество подключений, рекомендуется
также изменить следующие параметры:
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
Кроме того, если PostgreSQL у вас выполняется внутри зоны, может понадобиться также
увеличить лимиты на использование ресурсов зоны. Получить дополнительную информацию
о проектах и команде prctl можно в Руководстве системного администратора (System
Administrator's Guide), «Главе 2: Проекты и задачи» (Chapter2: Projects and Tasks).
18.4.2. RemoveIPC в systemd
Если используется systemd, необходимо позаботиться о том, чтобы ресурсы IPC (общая память и
семафоры) не освобождались преждевременно операционной системой. Это особенно актуально
при сборке и установке PostgreSQL из исходного кода. Пользователей дистрибутивных пакетов
PostgreSQL это касается в меньшей степени, так как пользователь postgres обычно создаётся как
системный пользователь.
488Подготовка к работе и
сопровождение сервера
Параметр RemoveIPC в logind.conf определяет, должны ли объекты IPC удаляться при полном вы-
ходе пользователя из системы. На системных пользователей это не распространяется. Этот пара-
метр по умолчанию включён в стандартной сборке systemd, но в некоторых дистрибутивах опера-
ционных систем он по умолчанию отключён.
Обычно нежелательный эффект этого включённого параметра проявляется в том, что объекты
семафоров, используемые сервером PostgreSQL, удаляются без видимых причин, что приводит к
отказу сервера с сообщениями вида:
LOG: semctl(1234567890, 0, IPC_RMID, ...) failed: Invalid argument
Различные типы объектов IPC (разделяемая память/семафоры, System V/POSIX) обрабатываются
в systemd несколько по-разному, поэтому могут наблюдаться ситуации, когда некоторые ресурсы
IPC не удаляются так, как другие. Однако полагаться на эти тонкие различия не рекомендуется.
Событие «выхода пользователя из системы» может произойти при выполнении задачи обслужи-
вания или если администратор войдёт под именем postgres, а затем выйдет, либо случится что-
то подобное, так что предотвратить это довольно сложно.
Какой пользователь является «системным», определяется во время компиляции systemd, исходя
из значения SYS_UID_MAX в /etc/login.defs.
Скрипт упаковывания и развёртывания сервера должен предусмотрительно создавать пользовате-
ля postgres как системного пользователя, используя команды useradd -r, adduser --system или
равнозначные.
Если же учётная запись пользователя была создана некорректно и изменить её невозможно, ре-
комендуется задать
RemoveIPC=no
в /etc/systemd/logind.conf или другом подходящем файле конфигурации.
Внимание
Необходимо предпринять минимум одно из этих двух действий, иначе сервер
PostgreSQL будет очень нестабильным.
18.4.3. Ограничения ресурсов
В Unix-подобных операционных системах существуют различные типы ограничений ресурсов, ко-
торые могут влиять на работу сервера PostgreSQL. Особенно важны ограничения на число про-
цессов для пользователя, число открытых файлов и объём памяти для каждого процесса. Каждое
из этих ограничений имеет «жёсткий» и «мягкий» предел. Мягкий предел действительно ограни-
чивает использование ресурса, но пользователь может увеличить его значение до жёсткого пре-
дела. Изменить жёсткий предел может только пользователь root. За изменение этих параметров
отвечает системный вызов setrlimit. Управлять этими ресурсами в командной строке позволяет
встроенная команда ulimit (в оболочках Bourne) и limit (csh). В системах семейства BSD различ-
ными ограничениями ресурсов, устанавливаемыми при входе пользователя, управляет файл /etc/
login.conf. За подробностями обратитесь к документации операционной системы. Для PostgreSQL
интерес представляют параметры maxproc, openfiles и datasize. Они могут задаваться, например
так:
default:\
...
:datasize-cur=256M:\
:maxproc-cur=256:\
:openfiles-cur=256:\
...
489Подготовка к работе и
сопровождение сервера
(Здесь -cur обозначает мягкий предел. Чтобы задать жёсткий предел, нужно заменить это окон-
чание на -max.)
Ядро также может устанавливать общесистемные ограничения на использование некоторых ре-
сурсов.
• В Linux максимальное число открытых файлов, которое поддерживает ядро, определяется в
спецфайле /proc/sys/fs/file-max. Изменить этот предел можно, записав другое число в этот
файл, либо добавив присваивание в файл /etc/sysctl.conf. Максимальное число файлов для
одного процесса задаётся при компиляции ядра; за дополнительными сведения обратитесь к /
usr/src/linux/Documentation/proc.txt.
Сервер PostgreSQL использует для обслуживания каждого подключения отдельный процесс, так
что возможное число процессов должно быть не меньше числа разрешённых соединений плюс
число процессов, требуемых для остальной системы. Это обычно не проблема, но когда в одной
системе работает множество серверов, предел может быть достигнут.
В качестве максимального числа открытых файлов по умолчанию обычно выбираются «социаль-
но-ориентированные» значения, позволяющие использовать одну систему нескольким пользова-
телям так, чтобы ни один из них не потреблял слишком много системных ресурсов. Если вы запус-
каете в системе несколько серверов, это должно вполне устраивать, но на выделенных машинах
может возникнуть желание увеличить этот предел.
С другой стороны, некоторые системы позволяют отдельным процессам открывать очень много
файлов и если это делают сразу несколько процессов, они могут легко исчерпать общесистемный
предел. Если вы столкнётесь с такой ситуацией, но не захотите менять общесистемное ограниче-
ние, вы можете ограничить использование открытых файлов сервером PostgreSQL, установив па-
раметр конфигурации max_files_per_process.
18.4.4. Чрезмерное выделение памяти в Linux
В Linux 2.4 и новее механизм виртуальной памяти по умолчанию работает не оптимально для
PostgreSQL. Вследствие того, что ядро выделяет память в чрезмерном объёме, оно может уничто-
жить главный управляющий процесс PostgreSQL (postmaster), если при выделении памяти процес-
су PostgreSQL или другому процессу виртуальная память будет исчерпана.
Когда это происходит, вы можете получить примерно такое сообщение ядра (где именно искать
это сообщение, можно узнать в документации вашей системы):
Out of Memory: Killed process 12345 (postgres).
Это сообщение говорит о том, что процесс postgres был уничтожен из-за нехватки памяти. Хотя
существующие подключения к базе данных будут работать по-прежнему, новые подключения при-
ниматься не будут. Чтобы восстановить работу сервера, PostgreSQL придётся перезапустить.
Один из способов обойти эту проблему — запускать PostgreSQL на компьютере, где никакие другие
процессы не займут всю память. Если физической памяти недостаточно, решить проблему также
можно, увеличив объём пространства подкачки, так как уничтожение процессов при нехватке па-
мяти происходит только когда заканчивается и физическая память, и место в пространстве под-
качки.
Если памяти не хватает по вине самого PostgreSQL, эту проблему можно решить, изменив конфи-
гурацию сервера. В некоторых случаях может помочь уменьшение конфигурационных парамет-
ров, связанных с памятью, а именно shared_buffers и work_mem. В других случаях проблема может
возникать, потому что разрешено слишком много подключений к самому серверу баз данных. Ча-
ще всего в такой ситуации стоит уменьшить число подключений max_connections и организовать
внешний пул соединений.
В Linux 2.6 и новее «чрезмерное выделение» памяти можно предотвратить, изменив поведение
ядра. Хотя при этом OOM killer (уничтожение процессов при нехватке памяти) всё равно может
вызываться, вероятность такого уничтожения значительно уменьшается, а значит поведение си-
490Подготовка к работе и
сопровождение сервера
стемы становится более стабильным. Для этого нужно включить режим строгого выделения памя-
ти, воспользовавшись sysctl:
sysctl -w vm.overcommit_memory=2
либо поместив соответствующую запись в /etc/sysctl.conf. Возможно, вы также захотите изме-
нить связанный параметр vm.overcommit_ratio. За подробностями обратитесь к документации яд-
ра https://www.kernel.org/doc/Documentation/vm/overcommit-accounting.
Другой
подход,
который
можно
применить
(возможно,
вместе
с
изменением
vm.overcommit_memory), заключается в исключении процесса postmaster из числа возможных
жертв при нехватке памяти. Для этого нужно задать для свойства поправка очков OOM этого про-
цесса значение -1000. Проще всего это можно сделать, выполнив
echo -1000 > /proc/self/oom_score_adj
в скрипте запуска управляющего процесса непосредственно перед тем, как запускать postmaster.
Заметьте, что делать это надо под именем root, иначе ничего не изменится; поэтому проще всего
вставить эту команду в стартовый скрипт, принадлежащий пользователю root. Если вы делаете
это, вы также должны установить в данном скрипте эти переменные окружения перед запуском
главного процесса:
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
С такими параметрами дочерние процессы главного будут запускаться с обычной, нулевой поправ-
кой очков OOM, так что при необходимости механизм OOM сможет уничтожать их. Вы можете за-
дать и другое значение для PG_OOM_ADJUST_VALUE, если хотите, чтобы дочерние процессы исполня-
лись с другой поправкой OOM. (PG_OOM_ADJUST_VALUE также можно опустить, в этом случае подра-
зумевается нулевое значение.) Если вы не установите PG_OOM_ADJUST_FILE, дочерние процессы бу-
дут работать с той же поправкой очков OOM, которая задана для главного процесса, что неразум-
но, так всё это делается как раз для того, чтобы главный процесс оказался на особом положении.
В старых ядрах Linux /proc/self/oom_score_adj отсутствует, но та же функциональность может
быть доступна через /proc/self/oom_adj. Эта переменная процесса работает так же, только зна-
чение, исключающее уничтожение процесса, равно -17, а не -1000.
Примечание
Некоторые дистрибутивы с ядрами Linux 2.4 содержат предварительную реализацию
механизма sysctl overcommit, появившегося официально в 2.6. Однако, если устано-
вить для vm.overcommit_memory значение 2 в ядре 2.4, ситуация не улучшится, а толь-
ко ухудшится. Прежде чем модифицировать этот параметр в ядре 2.4, рекомендуется
проанализировать исходный код вашего ядра (см. функцию vm_enough_memory в файле
mm/mmap.c) и убедиться, что ядро поддерживает именно нужный вам режим. Наличие
файла документации overcommit-accounting не следует считать признаком того, что
он действительно поддерживается. В случае сомнений, обратитесь к эксперту по ядру
или поставщику вашей системы.
18.4.5. Огромные страницы в Linux
Использование огромных страниц снижает накладные расходы при работе с большими непре-
рывными блоками памяти, что характерно для PostgreSQL, особенно при большом объёме
shared_buffers. Чтобы такие страницы можно было задействовать в PostgreSQL, ядро должно быть
собрано с параметрами CONFIG_HUGETLBFS=y и CONFIG_HUGETLB_PAGE=y. Также вам понадобится на-
строить параметр ядра vm.nr_hugepages. Чтобы оценить требуемое количество огромных страниц,
запустите PostgreSQL без поддержки огромных страниц и определите размер сегмента анонимной
разделяемой памяти процесса postmaster, а также узнайте размер огромной страницы, воспользо-
вавшись файловой системой /proc. Например, вы можете получить:
491Подготовка к работе и
сопровождение сервера
$ head -1 $PGDATA/postmaster.pid
4170
$ pmap 4170 | awk '/rw-s/ && /zero/ {print $2}'
6490428K
$ grep ^Hugepagesize /proc/meminfo
Hugepagesize:
2048 kB
В данном случае 6490428 / 2048 даёт примерно 3169.154, так что нам потребуется минимум 3170
огромных страниц, и мы можем задать это значение так:
$ sysctl -w vm.nr_hugepages=3170
Большее значение стоит указать, если огромные страницы будут использоваться и другими про-
граммами в этой системе. Не забудьте добавить этот параметр в /etc/sysctl.conf, чтобы он дей-
ствовал и после перезагрузки.
Иногда ядро не может выделить запрошенное количество огромных страниц сразу, поэтому может
потребоваться повторить эту команду или перезагрузить систему. (Немедленно после перезагруз-
ки должен быть свободен больший объём памяти для преобразования в огромные страницы.) Что-
бы проверить текущую ситуацию с размещением огромных страниц, выполните:
$ grep Huge /proc/meminfo
Также может потребоваться дать пользователю операционной системы, запускающему сервер БД,
право использовать огромные страницы, установив его группу в vm.hugetlb_shm_group с помощью
sysctl, и/или разрешить блокировать память, выполнив ulimit -l.
По умолчанию PostgreSQL использует огромные страницы, когда считает это возможным, а в про-
тивном случае переходит к обычным страницам. Чтобы задействовать огромные страницы прину-
дительно, можно установить для huge_pages значение on в postgresql.conf. Заметьте, что с таким
значением PostgreSQL не сможет запуститься, если не получит достаточного количества огром-
ных страниц.
Более подробно о механизме огромных страниц в Linux можно узнать в документации ядра: https://
www.kernel.org/doc/Documentation/vm/hugetlbpage.txt.
18.5. Выключение сервера
Сервер баз данных можно отключить несколькими способами. Вы выбираете тот или иной вариант
отключения, посылая разные сигналы главному процессу postgres.
SIGTERM
Запускает так называемое умное выключение. Получив SIGTERM, сервер перестаёт принимать
новые подключения, но позволяет всем существующим сеансам закончить работу в штатном
режиме. Сервер будет отключён только после завершения всех сеансов. Если сервер находится
в режиме архивации, сервер дополнительно ожидает выхода из этого режима. При этом в дан-
ном случае сервер позволяет устанавливать новые подключения, но только для суперпользо-
вателей (это исключение позволяет суперпользователю подключиться и прервать архивацию).
Если получая этот сигнал, сервер находится в процессе восстановления, восстановление и по-
токовая репликация будут прерваны только после завершения всех обычных сеансов.
SIGINT
Запускает быстрое выключение. Сервер запрещает новые подключения и посылает всем ра-
ботающим серверным процессам сигнал SIGTERM, в результате чего их транзакции прерыва-
ются и сами процессы завершаются. Управляющий процесс ждёт, пока будут завершены все
эти процессы и затем завершается сам. Если сервер находится в режиме архивации, архивация
прерывается, так что архив оказывается неполным.
SIGQUIT
Запускает немедленное выключение. Сервер отправляет всем дочерним процессам сигнал
SIGQUIT и ждёт их завершения. Если какие-либо из них не завершаются в течение 5 секунд,
492Подготовка к работе и
сопровождение сервера
им посылается SIGKILL. Главный процесс сервера завершается, как только будут завершены
все дочерние процессы, не выполняя обычную процедуру остановки БД. В результате при по-
следующем запуске будет запущен процесс восстановления (воспроизведения изменений из
журнала). Такой вариант выключения рекомендуется только в экстренных ситуациях.
Удобную возможность отправлять эти сигналы, отключающие сервер, предоставляет программа
pg_ctl. Кроме того, в системах, отличных от Windows, соответствующий сигнал можно отправить
с помощью команды kill. PID основного процесса postgres можно узнать, воспользовавшись про-
граммой ps, либо прочитав файл postmaster.pid в каталоге данных. Например, можно выполнить
быстрое выключение так:
$ kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`
Важно
Для выключения сервера не следует использовать сигнал SIGKILL. При таком выклю-
чении сервер не сможет освободить разделяемую память и семафоры, и, возможно, это
придётся делать вручную, чтобы сервер мог запуститься снова. Кроме того, при уни-
чтожении главного процесса postgres сигналом SIGKILL, он не успеет передать этот
сигнал своим дочерним процессам, так что может потребоваться завершать их так же
вручную.
Чтобы завершить отдельный сеанс, не прерывая работу других сеансов, воспользуйтесь функцией
pg_terminate_backend() (см. Таблицу 9.78) или отправьте сигнал SIGTERM дочернему процессу,
обслуживающему этот сеанс.
18.6. Обновление кластера PostgreSQL
В этом разделе рассказывается, как обновить ваш кластер базы данных с одной версии PostgreSQL
на другую.
Текущие номера версий PostgreSQL состоят из номеров основной и корректирующей (дополни-
тельной) версии. Например, в номере версии 10.1 число 10 обозначает основную версию, а 1 — до-
полнительную. Для выпусков PostgreSQL до версии 10.0 номера состояли из трёх чисел (например,
9.5.3). Тогда основная версия образовывалась группой их двух чисел (например, 9.5), а дополни-
тельная задавалась третьим числом (например, 3, что означало, что это третий корректирующий
выпуск основной версии 9.5).
В корректирующих выпусках никогда не меняется внутренний формат хранения и они всегда сов-
местимы с предыдущими и последующими выпусками той же основной версии. Например, версия
10.1 совместима с версией 10.0 и версией 10.6. Подобным образом, например, версия 9.5.3 совме-
стима с 9.5.0, 9.5.1 и 9.5.6. Для обновления версии на совместимую достаточно просто заменить
исполняемые файлы при выключенном сервере и затем запустить сервер. Каталог данных при
этом не затрагивается, так что обновить корректирующую версию довольно просто.
При обновлении основных версий PostgreSQL внутренний формат данных может меняться, что
усложняет процедуру обновления. Традиционный способ переноса данных в новую основную вер-
сию — выгрузить данные из старой версии, а затем загрузить их в новую (это не самый быстрый
вариант). Выполнить обновление быстрее позволяет pg_upgrade. Также для обновления можно ис-
пользовать репликацию, как описано ниже.
Изменения основной версии обычно приносят какие-либо видимые пользователю несовместимо-
сти, которые могут требовать доработки приложений. Все подобные изменения описываются в за-
мечаниях к выпуску (Приложение E); обращайте особое внимание на раздел «Migration» (Мигра-
ция). Если при обновлении вы пропускаете несколько основных версий, обязательно прочитайте
замечания к выпуску, в том числе и для каждой пропускаемой версии.
Осторожные пользователи обычно тестируют свои клиентские приложения с новой версией,
прежде чем переходить на неё полностью; поэтому часто имеет смысл установить рядом старую
493Подготовка к работе и
сопровождение сервера
и новую версии. При тестировании обновления основной версии PostgreSQL изучите следующие
области возможных изменений:
Администрирование
Средства и функции, предоставляемые администраторам для наблюдения и управления серве-
ром, часто меняются и совершенствуются в каждой новой версии.
SQL
В этой области чаще наблюдается появление новых возможностей команд SQL, чем изменение
поведения существующих, если только об этом не говорится в замечаниях к выпуску.
API библиотек
Обычно библиотеки типа libpq только расширяют свою функциональность, если об обратном
так же не говорится в замечаниях к выпуску.
Системные каталоги
Изменения в системных каталогах обычно влияют только на средства управления базами дан-
ных.
API сервера для кода на C
Сюда относятся изменения в API серверных функций, которые написаны на языке программи-
рования C. Такие изменения затрагивают код, обращающийся к служебным функциям глубоко
внутри сервера.
18.6.1. Обновление данных с применением pg_dumpall
Один из вариантов обновления заключается в выгрузке данных из одной основной версии
PostgreSQL и загрузке их в другую — для этого необходимо использовать средство логического ко-
пирования, например pg_dumpall; копирование на уровне файловой системы не подходит. (В самом
сервере есть проверки, которые не дадут использовать каталог данных от несовместимой версии
PostgreSQL, так что если попытаться запустить с существующим каталогом данных неправильную
версию сервера, никакого вреда не будет.)
Для создания копии рекомендуется применять программы pg_dump и pg_dumpall от новой версии
PostgreSQL, чтобы воспользоваться улучшенными функциями, которые могли в них появиться. Те-
кущие версии этих программ способны читать данные любой версии сервера, начиная с 7.0.
В следующих указаниях предполагается, что сервер установлен в каталоге /usr/local/pgsql, а
данные находятся в /usr/local/pgsql/data. Вам нужно подставить свои пути.
1.
При запуске резервного копирования убедитесь в том, что в базе данных не производятся из-
менения. Изменения не повлияют на целостность полученной копии, но изменённые данные,
само собой, в неё не попадут. Если потребуется, измените разрешения в файле /usr/local/
pgsql/data/pg_hba.conf (или подобном), чтобы подключиться к серверу могли только вы. За
дополнительными сведениями об управлении доступом обратитесь к Главе 20.
Чтобы получить копию всех ваших данных, введите:
pg_dumpall > выходной_файл
Для создания резервной копии вы можете воспользоваться программой pg_dumpall от теку-
щей версии сервера; за подробностями обратитесь к Подразделу 25.1.2. Однако для лучшего
результата стоит попробовать pg_dumpall из PostgreSQL 11.1, так как в эту версию вошли ис-
правления ошибок и усовершенствования, по сравнению с предыдущими версиями. Хотя этот
совет может показаться абсурдным, ведь новая версия ещё не установлена, ему стоит после-
довать, если вы планируете установить новую версию рядом со старой. В этом случае вы смо-
жете выполнить установку как обычно, а перенести данные позже. Это также сократит время
обновления.
2.
Остановите старый сервер:
494Подготовка к работе и
сопровождение сервера
pg_ctl stop
В системах, где PostgreSQL запускается при загрузке, должен быть скрипт запуска, с которым
можно сделать то же самое. Например, в Red Hat Linux может сработать такой вариант:
/etc/rc.d/init.d/postgresql stop
Подробнее запуск и остановка сервера описаны в Главе 18.
3.
При восстановлении из резервной копии удалите или переименуйте старый каталог, где был
установлен сервер, если его имя не привязано к версии. Разумнее будет переименовать ката-
лог, а не удалять его, чтобы его можно было восстановить в случае проблем. Однако учтите,
что этот каталог может занимать много места на диске. Переименовать каталог можно, на-
пример так:
mv /usr/local/pgsql /usr/local/pgsql.old
(Этот каталог нужно переименовывать (перемещать) как единое целое, чтобы относительные
пути в нём не изменились.)
4. Установите новую версию PostgreSQL как описано в Разделе 16.4.
5. При необходимости создайте новый кластер баз данных. Помните, что следующие команды
нужно выполнять под именем специального пользователя БД (вы уже действуете под этим
именем, если производите обновление).
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
6. Перенесите изменения, внесённые в предыдущие версии pg_hba.conf и postgresql.conf.
7. Запустите сервер баз данных, так же применяя учётную запись специального пользователя БД:
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
8.
Наконец, восстановите данные из резервной копии, выполнив:
/usr/local/pgsql/bin/psql -d postgres -f выходной_файл
(При этом будет использоваться новый psql.)
Минимизировать время отключения сервера можно, установив новый сервер в другой каталог и
запустив параллельно оба сервера, старый и новый, с разными портами. Затем можно будет пере-
нести данные примерно так:
pg_dumpall -p 5432 | psql -d postgres -p 5433
18.6.2. Обновление данных с применением pg_upgrade
Модуль pg_upgrade позволяет обновить инсталляцию PostgreSQL с одной основной версии на дру-
гую непосредственно на месте. Такое обновление может выполняться за считанные минуты, осо-
бенно в режиме --link. Для него требуются примерно те же подготовительные действия, что и для
варианта с pg_dumpall: запустить/остановить сервер, выполнить initdb. Все эти действия описаны
в документации pg_upgrade.
18.6.3. Обновление данных с применением репликации
Методы логической репликации также могут применяться для создания резервного сервера с об-
новлённой версией PostgreSQL. Это возможно благодаря тому, что логическая репликация под-
держивается между разными основными версиями PostgreSQL. Резервный сервер может распола-
гаться как на том же компьютере, так и на другом. Как только синхронизация с главным сервером
(где работает старая версия PostgreSQL) будет завершена, можно сделать главным новый сервер, а
старый экземпляр базы данных просто отключить. При таком переключении обновление возмож-
но осуществить, прервав работу сервера всего на несколько секунд.
Этот вариант обновления можно осуществить, используя как встроенные средства логической ре-
пликации, так и внешние системы логической репликации, такие как pglogical, Slony, Londiste и
Bucardo.
495Подготовка к работе и
сопровождение сервера
18.7. Защита от подмены сервера
Когда сервер работает, злонамеренный пользователь не может подставить свой сервер вместо
него. Однако, если сервер отключён, локальный пользователь может подменить нормальный сер-
вер, запустив свой собственный. Поддельный сервер сможет читать пароли и запросы клиентов,
хотя не сможет вернуть никакие данные, так как каталог PGDATA будет защищён от чтения посто-
ронними пользователями. Такая подмена возможна потому, что любой пользователь может запу-
стить сервер баз данных; клиент, со своей стороны, не может обнаружить подмену, если его не
настроить дополнительно.
Один из способов предотвратить подмену для локальных подключений — использовать каталог
Unix-сокетов (unix_socket_directories), в который сможет писать только проверенный локальный
пользователь. Это не позволит злонамеренному пользователю создать в этом каталоге свой файл
сокета. Если вас беспокоит, что некоторые приложения при этом могут обращаться к файлу со-
кета в /tmp и, таким образом, всё же будут уязвимыми, создайте при загрузке операционной си-
стемы символическую ссылку /tmp/.s.PGSQL.5432, указывающую на перемещённый файл сокета.
Возможно, вам также придётся изменить скрипт очистки /tmp, чтобы он не удалял эту ссылку.
Также клиенты могут защитить локальные подключения, установив в параметре requirepeer имя
пользователя, который должен владеть серверным процессом, подключённым к сокету.
Лучший способ защиты от подмены для соединений TCP — использовать сертификаты SSL и до-
биться, чтобы клиенты проверяли сертификат сервера. Для этого надо настроить сервер, чтобы он
принимал только подключения hostssl (см. Раздел 20.1) и имел ключ и сертификаты SSL (см. Раз-
дел 18.9). Тогда TCP-клиент должен будет подключаться к серверу с параметром sslmode=verify-
ca или verify-full и у него должен быть установлен соответствующий корневой сертификат (см.
Подраздел 34.18.1).
18.8. Возможности шифрования
PostgreSQL обеспечивает шифрование на разных уровнях и даёт гибкость в выборе средств защиты
данных в случае кражи сервера, от недобросовестных администраторов или в небезопасных сетях.
Шифрование может также требоваться для защиты конфиденциальных данных, например, меди-
цинских сведений или финансовых транзакций.
Шифрование паролей
Пароли пользователей базы данных хранятся в виде хешей (алгоритм хеширования определя-
ется параметром password_encryption), так что администратор не может узнать, какой именно
пароль имеет пользователь. Если шифрование SCRAM или MD5 применяется и при проверке
подлинности, пароль не присутствует на сервере в открытом виде даже кратковременно, так
как клиент шифрует его перед тем как передавать по сети. Предпочтительным методом явля-
ется SCRAM, так как это стандарт, принятый в Интернете, и он более безопасен, чем собствен-
ный протокол проверки MD5 в PostgreSQL.
Шифрование избранных столбцов
Модуль pgcrypto позволяет хранить в зашифрованном виде избранные поля. Это полезно, если
ценность представляют только некоторые данные. Чтобы прочитать эти поля, клиент передаёт
дешифрующий ключ, сервер расшифровывает данные и выдаёт их клиенту.
Расшифрованные данные и ключ дешифрования находятся на сервере в процессе расшифро-
вывания и передачи данных. Именно в этот момент данные и ключи могут быть перехвачены
тем, кто имеет полный доступ к серверу баз данных, например, системным администратором.
Шифрование раздела данных
Шифрование хранилища данных можно реализовать на уровне файловой системы или на уров-
не блоков. В Linux можно воспользоваться шифрованными файловыми системами eCryptfs и
EncFS, а во FreeBSD есть PEFS. Шифрование всего диска на блочном уровне в Linux можно
496Подготовка к работе и
сопровождение сервера
организовать, используя dm-crypt + LUKS, а во FreeBSD — модули GEOM, geli и gbde. Подобные
возможности есть и во многих других операционных системах, включая Windows.
Этот механизм не позволяет читать незашифрованные данные с дисков в случае кражи дис-
ков или всего компьютера. При этом он не защищает данные от чтения, когда эта файловая
система смонтирована, так как на смонтированном устройстве операционная система видит
все данные в незашифрованном виде. Однако, чтобы смонтировать файловую систему, нужно
передать операционной системе ключ (иногда он хранится где-то на компьютере, который вы-
полняет монтирование).
Шифрование данных при передаче по сети
SSL-соединения шифруют все данные, передаваемые по сети: пароль, запросы и возвращаемые
данные. Файл pg_hba.conf позволяет администраторам указать, для каких узлов будут разре-
шены незашифрованные соединения (host), а для каких будет требоваться SSL (hostssl). Кро-
ме того, и на стороне клиента можно разрешить подключения к серверам только с SSL. Для
шифрования трафика также можно применять stunnel и SSH.
Проверка подлинности сервера SSL
И клиент, и сервер могут проверять подлинность друг друга по сертификатам SSL. Это требует
дополнительной настройки на каждой стороне, но даёт более надёжную гарантию подлинно-
сти, чем обычные пароли. С такой защитой подставной компьютер не сможет представлять из
себя сервер с целью получить пароли клиентов. Она также предотвращает атаки с посредником
(«man in the middle»), когда компьютер между клиентом и сервером представляется сервером
и незаметно передаёт все запросы и данные между клиентом и подлинным сервером.
Шифрование на стороне клиента
Если системный администратор сервера, где работает база данных, не является доверенным,
клиент должен сам шифровать данные; тогда незашифрованные данные никогда не появятся
на этом сервере. В этом случае клиент шифрует данные, прежде чем передавать их серверу, а
получив из базы данных результаты, он расшифровывает их для использования.
18.9. Защита соединений TCP/IP с применением SSL
В PostgreSQL встроена поддержка SSL для шифрования трафика между клиентом и сервером,
что повышает уровень безопасности системы. Для использования этой возможности необходимо,
чтобы и на сервере, и на клиенте был установлен OpenSSL, и поддержка SSL была разрешена в
PostgreSQL при сборке (см. Главу 16).
18.9.1. Базовая настройка
Когда в установленном сервере PostgreSQL разрешена поддержка SSL, его можно запустить с
включённым механизмом SSL, задав в postgresql.conf для параметра ssl значение on. Запущен-
ный сервер будет принимать, как обычные, так и SSL-подключения в одном порту TCP и будет со-
гласовывать использование SSL с каждым клиентом. По умолчанию клиент выбирает режим под-
ключения сам; как настроить сервер, чтобы он требовал использовать только SSL для всех или
некоторых подключений, вы можете узнать в Разделе 20.1.
Чтобы сервер мог работать в режиме SSL, ему необходимы файлы с сертификатом сервера и за-
крытым ключом. По умолчанию это должны быть файлы server.crt и server.key, соответствен-
но, расположенные в каталоге данных, но можно использовать и другие имена и местоположения
файлов, задав их в конфигурационных параметрах ssl_cert_file и ssl_key_file.
В Unix-подобных системах к файлу server.key должен быть запрещён любой доступ группы и всех
остальных; чтобы установить такое ограничение, выполните chmod 0600 server.key. Возможен и
другой вариант, когда этим файлом владеет root, а группа имеет доступ на чтение (то есть, маска
разрешений 0640). Данный вариант предназначен для систем, в которых файлами сертификатов и
ключей управляет сама операционная система. В этом случае пользователь, запускающий сервер
497Подготовка к работе и
сопровождение сервера
PostgreSQL, должен быть членом группы, имеющей доступ к указанным файлам сертификата и
ключа.
Если к каталогу данных разрешён доступ группы, файлы сертификатов должны размещаться вне
этого каталога для удовлетворения озвученных выше требований безопасности. Вообще говоря,
доступ группы разрешается для того, чтобы непривилегированный пользователь мог производить
резервное копирование базы данных, и в этом случае средство резервного копирования не сможет
прочитать файлы сертификатов, что скорее всего приведёт к ошибке.
Если закрытый ключ защищён паролем, сервер спросит этот пароль и не будет запускаться, пока
он не будет введён. Использование такого пароля лишает возможности изменять конфигурацию
SSL без перезагрузки сервера. Более того, закрытые ключи, защищённые паролям, не годятся для
использования в Windows.
Первым сертификатом в server.crt должен быть сертификат сервера, так как он должен соответ-
ствовать закрытому ключу сервера. В этот файл также могут быть добавлены сертификаты «про-
межуточных» центров сертификации. Это избавляет от необходимости хранить все промежуточ-
ные сертификаты на клиентах, при условии, что корневой и промежуточные сертификаты были
созданы с расширениями v3_ca. Это также упрощает управление промежуточными сертификата-
ми с истекающим сроком.
Добавлять корневой сертификат в server.crt нет необходимости. Вместо этого клиенты должны
иметь этот сертификат в цепочке сертификатов сервера.
18.9.2. Конфигурация OpenSSL
PostgreSQL читает системный файл конфигурации OpenSSL. По умолчанию этот файл называется
openssl.cnf и находится в каталоге, который сообщает команда openssl version -d. Если требу-
ется указать другое расположение файла конфигурации, его можно задать в переменной окруже-
ния OPENSSL_CONF.
OpenSSL предоставляет широкий выбор шифров и алгоритмов аутентификации разной защищён-
ности. Хотя список шифров может быть задан непосредственно в файле конфигурации OpenSSL,
можно задать отдельные шифры именно для сервера баз данных, указав их в параметре ssl_ciphers
в postgresql.conf.
Примечание
Накладные расходы, связанные с шифрованием, в принципе можно исключить, огра-
ничившись только проверкой подлинности, то есть применяя шифр NULL-SHA или NULL-
MD5. Однако в этом случае посредник сможет пропускать через себя и читать весь тра-
фик между клиентом и сервером. Кроме того, шифрование привносит минимальную
дополнительную нагрузку по сравнению с проверкой подлинности. По этим причинам
использовать шифры NULL не рекомендуется.
18.9.3. Использование клиентских сертификатов
Чтобы клиенты должны были предоставлять серверу доверенные сертификаты, поместите серти-
фикаты корневых центров сертификации (ЦС), которым вы доверяете, в файл в каталоге данных,
укажите в параметре ssl_ca_file в postgresql.conf имя этого файла и добавьте параметр аутенти-
фикации clientcert=1 в соответствующие строки hostssl в pg_hba.conf. В результате от клиен-
та в процессе установления SSL-подключения будет затребован сертификат. (Как настроить сер-
тификаты на стороне клиента, описывается в Разделе 34.18.) Получив сертификат, сервер будет
проверять, подписан ли этот сертификат одним из доверенным центром сертификации.
Промежуточные сертификаты, которые составляют цепочку с существующими корневыми серти-
фикатами, можно также включить в файл ssl_ca_file, если вы не хотите хранить их на клиентах
(предполагается, что корневой и промежуточный сертификаты были созданы с расширениями
498Подготовка к работе и
сопровождение сервера
v3_ca). Если установлен параметр ssl_crl_file, также проверяются списки отзыва сертификатов
(Certificate Revocation List, CRL). (Диаграммы, иллюстрирующие использование сертификатов SSL,
можно найти на странице http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html.)
Параметр аутентификации clientcert можно использовать с любым методом проверки подлинно-
сти, но только в строках pg_hba.conf типа hostssl. Когда clientcert не задан или равен 0, сервер,
тем не менее, будет проверять все представленные клиентские сертификаты по своему файлу со
списком ЦС (если он настроен) — но позволит подключаться клиентам без сертификата.
Если вы используете клиентские сертификаты, вы можете также применить метод аутентифика-
ции cert, чтобы сертификаты обеспечивали не только защиту соединений, но и проверку подлин-
ности пользователей. За подробностями обратитесь к Разделу 20.12. (Устанавливать clientcert=1
явно при использовании метода аутентификации cert не требуется.)
18.9.4. Файлы, используемые SSL-сервером
В Таблице 18.2 кратко описаны все файлы, имеющие отношение к настройке SSL на сервере. (Здесь
приведены стандартные имена файлов. В конкретной системе они могут быть другими.)
Таблица 18.2. Файлы, используемые SSL-сервером
Файл
Содержимое
Назначение
ssl_cert_file
server.crt) ($PGDATA/ сертификат сервера отправляется клиенту для иден-
тификации сервера
ssl_key_file
server.key) ($PGDATA/ закрытый ключ сервера подтверждает, что сертификат
сервера был передан его вла-
дельцем; не гарантирует, что
его владельцу можно доверять
ssl_ca_file сертификаты доверенных ЦС
позволяет проверить, что серти-
фикат клиента подписан дове-
ренным центром сертификации
ssl_crl_file сертификаты, отозванные цен- сертификат клиента должен от-
трами сертификации
сутствовать в этом списке
Сервер читает эти файлы при запуске или при перезагрузке конфигурации. В системах Windows
они также считываются заново, когда для нового клиентского подключения запускается новый
обслуживающий процесс.
Если в этих файлах при запуске сервера обнаружится ошибка, сервер откажется запускаться. Но
если ошибка обнаруживается при перезагрузке конфигурации, эти файлы игнорируются и продол-
жает использоваться старая конфигурация SSL. В системах Windows, если в одном из этих файлов
обнаруживается ошибка при запуске обслуживающего процесса, этот процесс не сможет устанав-
ливать SSL-соединения. Во всех таких случаях в журнал событий сервера выводится сообщение
об ошибке.
18.9.5. Создание сертификатов
Чтобы создать простой самоподписанный сертификат для сервера, действующий 365 дней, выпол-
ните следующую команду OpenSSL, заменив dbhost.yourdomain.com именем компьютера, где раз-
мещён сервер:
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
-keyout server.key -subj "/CN=dbhost.yourdomain.com"
Затем выполните:
chmod og-rwx server.key
так как сервер не примет этот файл, если разрешения будут более либеральными, чем показанные.
За дополнительными сведениями относительно создания закрытого ключа и сертификата сервера
обратитесь к документации OpenSSL.
499Подготовка к работе и
сопровождение сервера
Хотя самоподписанный сертификат может успешно применяться при тестировании, в произ-
водственной среде следует использовать сертификат, подписанный центром сертификации (ЦС)
(обычно это корневой ЦС предприятия).
Чтобы создать сертификат сервера, подлинность которого смогут проверять клиенты, сначала со-
здайте запрос на получение сертификата (CSR) и файлы открытого/закрытого ключа:
openssl req -new -nodes -text -out root.csr \
-keyout root.key -subj "/CN=root.yourdomain.com"
chmod og-rwx root.key
Затем подпишите запрос ключом, чтобы создать корневой центр сертификации (с файлом конфи-
гурации OpenSSL, помещённым в Linux в расположение по умолчанию):
openssl x509 -req -in root.csr -text -days 3650 \
-extfile /etc/ssl/openssl.cnf -extensions v3_ca \
-signkey root.key -out root.crt
Наконец, создайте сертификат сервера, подписанный новым корневым центром сертификации:
openssl req -new -nodes -text -out server.csr \
-keyout server.key -subj "/CN=dbhost.yourdomain.com"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
-CA root.crt -CAkey root.key -CAcreateserial \
-out server.crt
server.crt и server.key должны быть сохранены на сервере, а root.crt — на клиенте, чтобы кли-
ент мог убедиться в том, что конечный сертификат сервера подписан центром сертификации, ко-
торому он доверяет. Файл root.key следует хранить в изолированном месте для создания серти-
фикатов в будущем.
Также возможно создать цепочку доверия, включающую промежуточные сертификаты:
# корневой сертификат
openssl req -new -nodes -text -out root.csr \
-keyout root.key -subj "/CN=root.yourdomain.com"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
-extfile /etc/ssl/openssl.cnf -extensions v3_ca \
-signkey root.key -out root.crt
# промежуточный
openssl req -new -nodes -text -out intermediate.csr \
-keyout intermediate.key -subj "/CN=intermediate.yourdomain.com"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
-extfile /etc/ssl/openssl.cnf -extensions v3_ca \
-CA root.crt -CAkey root.key -CAcreateserial \
-out intermediate.crt
# конечный
openssl req -new -nodes -text -out server.csr \
-keyout server.key -subj "/CN=dbhost.yourdomain.com"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
-CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
-out server.crt
server.crt и intermediate.crt следует сложить вместе в пакет сертификатов и сохранить на сер-
вере. Также на сервере следует сохранить server.key. Файл root.crt нужно сохранить на клиен-
500Подготовка к работе и
сопровождение сервера
те, чтобы клиент мог убедиться в том, что конечный сертификат сервера был подписан по цепоч-
ке сертификатов, связанных с корневым сертификатом, которому он доверяет. Файлы root.key и
intermediate.key следует хранить в изолированном месте для создания сертификатов в будущем.
18.10. Защита соединений TCP/IP с применением тун-
нелей SSH
Для защиты сетевых соединений клиентов с сервером PostgreSQL можно применить SSH. При
правильном подходе это позволяет обеспечить должный уровень защиты сетевого трафика, даже
для клиентов, не поддерживающих SSL.
Прежде всего, убедитесь, что на компьютере с сервером PostgreSQL также работает сервер SSH
и вы можете подключиться к нему через ssh каким-нибудь пользователем. Затем вы можете уста-
новить защищённый тоннель с клиентской машины следующим образом:
ssh -L 63333:localhost:5432 joe@foo.com
Первое число в аргументе -L, 63333 — это номер порта с вашей стороны туннеля; это может быть
номер любого свободного порта. (IANA резервирует порты с 49152 по 65535 для частного исполь-
зования.) Второе число, 5432 — порт с удалённой стороны туннеля, порт вашего сервера. Имя или
IP-адрес между этими номерами портов идентифицирует целевой компьютер (где работает сервер
баз данных, к которому вы будете подключаться), с точки зрения компьютера, с которого выпол-
няется подключение (в данном примере, foo.com). Чтобы подключиться к этому серверу через со-
зданный тоннель, вы можете подключиться к порту 63333 на локальном компьютере:
psql -h localhost -p 63333 postgres
Для сервера баз данных это будет выглядеть так, как будто вы действительно пользователь joe
компьютера foo.com, подключающийся к localhost в этом контексте, и он будет применять ту
процедуру проверки подлинности, которая установлена для подключений данного пользователя с
этого компьютера. Заметьте, что сервер не будет считать такое соединение защищённым SSL, так
как на самом деле трафик между сервером SSH и сервером PostgreSQL не защищён. Это не должно
нести какие-то дополнительные риски, так как эти серверы работают на одном компьютере.
Чтобы настроенный таким образом туннель работал, вы должны иметь возможность подключаться
к компьютеру через ssh под именем joe@foo.com, так же, как это происходит при установлении
терминального подключения с помощью ssh.
Вы также можете настроить перенаправление портов примерно так:
ssh -L 63333:foo.com:5432 joe@foo.com
Но в этом случае для сервера баз данных подключение будет приходить с его интерфейса foo.com,
а этот интерфейс по умолчанию не прослушивается (вследствие указания listen_addresses =
'localhost'). Обычно требуется другое поведение.
Если вам нужно «перейти» к серверу баз данных через некоторый шлюз, это можно организовать
примерно так:
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
Заметьте, что в этом случае трафик между shell.foo.com и db.foo.com не будет защищён тунне-
лем SSH. SSH предлагает довольно много вариантов конфигурации, что позволяет организовывать
защиту сети разными способами. За подробностями обратитесь к документации SSH.
Подсказка
Существуют и другие приложения, которые могут создавать безопасные туннели, при-
меняя по сути тот же подход, что был описан выше.
501Подготовка к работе и
сопровождение сервера
18.11. Регистрация журнала событий в Windows
Чтобы зарегистрировать библиотеку журнала событий в Windows, выполните следующую команду:
regsvr32 каталог_библиотек_pgsql/pgevent.dll
При этом в реестре будут созданы необходимые записи для средства просмотра событий, относя-
щиеся к источнику событий по умолчанию с именем PostgreSQL.
Чтобы задать другое имя источника событий (см. event_source), укажите ключи /n и /i:
regsvr32 /n /i:имя_источника_событий каталог_библиотек_pgsql/pgevent.dll
Чтобы разрегистрировать библиотеку журнала событий в операционной системе, выполните ко-
манду:
regsvr32 /u [/i:имя_источника_событий] каталог_библиотек_pgsql/pgevent.dll
Примечание
Чтобы сервер баз данных записывал сообщения в журнал событий, добавьте eventlog
в параметр log_destination в postgresql.conf.
