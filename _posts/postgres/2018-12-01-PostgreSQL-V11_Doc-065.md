---
layout: post
title: Глава 65. Индексы SP-GiST
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 65. Индексы SP-GiST

65.1. Введение

Аббревиатура SP-GiST расшифровывается как «Space-Partitioned GiST» (GiST с разбиением про-
странства). SP-GiST поддерживает деревья поиска с разбиением, что облегчает разработку широ-
кого спектра различных несбалансированных структур данных, в том числе деревьев квадрантов,
а также k-мерных и префиксных деревьев. Общей характеристикой этих структур является то, что
они последовательно разбивают пространство поиска на сегменты, которые не обязательно долж-
ны быть равного размера. При этом поиск, хорошо соответствующий правилу разбиения, с таким
индексом может быть очень быстрым.
Эти популярные структуры данных изначально конструировались для работы в памяти. При таком
применении они обычно представляются в виде набора динамически выделяемых узлов, связыва-
емых указателями. Однако подобную схему нельзя в таком виде перенести на диск, так как цепоч-
ки указателей могут быть довольно длинными, и поэтому потребуется слишком много обращений
к диску. Структуры данных для хранения на диске, напротив, должны иметь большую разветвлён-
ность для минимизации объёма ввода/вывода. Для решения этой задачи SP-GiST сопоставляет уз-
лы дерева поиска со страницами на диске так, чтобы при поиске требовалось обращаться только
к нескольким страницам на диске, даже если при этом нужно просмотреть множество узлов.
Как и GiST, SP-GiST призван дать возможность разрабатывать дополнительные типы данных с со-
ответствующими методами доступа экспертам в предметной области типа данных, а не специали-
стам по СУБД.
Представленная здесь информация частично позаимствована с сайта Проекта индексации SP-
GiST Университета Пердью. Сопровождением реализации SP-GiST в PostgreSQL в основном зани-
маются Фёдор Сигаев и Олег Бартунов; дополнительные сведения можно получить на их сайте.
65.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов SP-GiST, перечисленные в Таб-
лице 65.1.
Таблица 65.1. Встроенные классы операторов SP-GiST
Имя Индексируемый тип данных Индексируемые операторы
kd_point_ops point << <@ <^ >> >^ ~=
quad_point_ops point << <@ <^ >> >^ ~=
range_ops любой тип диапазона && &< &> -|- << <@ = >> @>
box_ops box << &< && &> >> ~= @> <@ &<| <<| |
>> |&>
poly_ops polygon << &< && &> >> ~= @> <@ &<| <<| |
>> |&>
text_ops text < <= = > >= ~<=~ ~<~ ~>=~ ~>~ ^@
inet_ops inet, cidr && >> >>= > >= <> << <<= < <= =
Из двух классов операторов для типа point классом по умолчанию является quad_point_ops. Класс
kd_point_ops поддерживает те же операторы, но использует другую структуру данных индекса,
которая может дать выигрыш в скорости для некоторых приложений.
65.3. Расширяемость
SP-GiST предлагает интерфейс с высоким уровнем абстракции и таким образом требует от разра-
ботчика метода доступа реализовать только методы, специфичные для конкретного типа данных.
Ядро SP-GiST отвечает за эффективную схему обращений к диску и поиск в структуре дерева, а
также берёт на себя заботу о параллельном доступе и поддержке журнала.
2150Индексы SP-GiST
Кортежи в листьях дерева SP-GiST содержат значения того же типа данных, что и индексируе-
мый столбец. На верхнем уровне эти кортежи содержат всегда исходное индексируемое значение
данных, но на более нижних могут содержать только сокращённое представление, например, суф-
фикс. В этом случае опорные функции класса операторов должны уметь восстанавливать исходное
значение, собирая его из внутренних кортежей, которые нужно пройти для достижения уровня
конкретного листа.
Внутренние кортежи устроены сложнее, так как они представляют собой точки разветвления в
дереве поиска. Каждый внутренний кортеж содержит набор из одного или нескольких узлов, пред-
ставляющих группы сходных значений листьев. Узел содержит ответвление, приводящее либо к
другому, внутреннему кортежу нижнего уровня, либо к короткому списку кортежей в листьях, ле-
жащих в одной странице индекса. Для каждого узла обычно задаётся метка, описывающая его;
например, в префиксном дереве меткой может быть очередной символ в строковом значении. (С
другой стороны, класс операторов может опускать метки узлов, если он имеет дело с фиксирован-
ным набором узлов во всех внутренних кортежах; см. Подраздел 65.4.2.) Дополнительно внутрен-
ний кортеж может хранить префикс, описывающий все его члены. В префиксном дереве это мо-
жет быть общий префикс всех представленных ниже строк. Значением префикса не обязательно
должен быть префикс, а могут быть любые данные, требующиеся классу операторов; например, в
дереве квадрантов это может быть центральная точка, от которой отмеряются четыре квадранта.
В этом случае внутренний кортеж дерева квадрантов будет также содержать четыре узла, соот-
ветствующие квадрантам вокруг этой центральной точки.
Некоторые алгоритмы деревьев требует знания уровня (или глубины) текущего кортежа, так что
ядро SP-GiST даёт возможность классам операторов контролировать число уровней при спуске по
дереву. Также имеется поддержка пошагового восстановления представленного значения, когда
это требуется, и передачи вниз дополнительных данных (так называемых переходящих значений)
при спуске.
Примечание
Ядро SP-GiST берёт на себя заботу о значениях NULL. Хотя в индексах SP-GiST не хра-
нятся записи для NULL в индексируемых столбцах, это скрыто от кода класса опера-
торов; записи индексов или условия поиска с NULL никогда не передаются методам
класса операторов. (Предполагается, что операторы SP-GiST строгие и не могут возвра-
щать положительный результат для значений NULL.) Поэтому значения NULL здесь
больше обсуждаться не будут.
Класс операторов индекса для SP-GiST должен предоставить пять методов и может дополнительно
предоставить ещё один. Все пять обязательных методов должны по единому соглашению прини-
мать два аргумента internal, первым из которых будет указатель на структуру C, содержащую
входные значения для опорного метода, а вторым — указатель на структуру C, в которую должны
помещаться выходные значения. Четыре из этих методов должны возвращать просто void, так как
их результаты помещаются в выходную структуру; однако leaf_consistent дополнительно возвра-
щает результат boolean. Эти методы не должны менять никакие поля в их входных структурах.
Выходная структура всегда обнуляется перед вызовом пользовательского метода. Необязательный
шестой метод compress принимает в единственном аргументе данные, подлежащие индексирова-
нию, и возвращает значение, подходящее для физического хранения в кортеже уровня листьев.
Пользователь должен определить следующие пять обязательных методов:
config
Возвращает статическую информацию о реализации индекса, включая OID типов данных пре-
фикса и метки узла.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_config(internal, internal) RETURNS void ...
2151Индексы SP-GiST
В первом аргументе передаётся указатель на структуру spgConfigIn языка C, содержа-
щие входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgConfigOut языка C, в которую функция должна поместить результат.
typedef struct spgConfigIn
{
Oid
attType;
} spgConfigIn;
typedef struct spgConfigOut
{
Oid
prefixType;
Oid
labelType;
Oid
leafType;
bool
canReturnData;
данные */
bool
longValuesOK;
одной странице */
} spgConfigOut;
/* Индексируемый тип данных */
/*
/*
/*
/*
Тип данных префикса во внутренних кортежах */
Тип данных метки узла во внутренних кортежах */
Тип данных в кортежах уровня листьев */
Класс операторов может восстановить исходные
/* Класс может принимать значения, не умещающиеся на
Поле attType передаётся для поддержки полиморфных классов операторов; для обычных клас-
сов операторов с фиксированным типом оно будет всегда содержать одно значение и поэтому
его можно просто игнорировать.
Для классов операторов, не использующих префиксы, в prefixType можно установить VOIDOID.
Подобным образом, для классов операторов, не использующих метки узлов, в labelType тоже
можно установить VOIDOID. Признак canReturnData следует установить, если класс операторов
может восстановить изначально переданное в индекс значение. Признак longValuesOK должен
устанавливаться, только если attType переменной длины и класс операторов может фрагмен-
тировать длинные значения, повторяя суффиксы (см. Подраздел 65.4.1).
Значение leafType обычно совпадает с attType. Для обеспечения обратной совместимости ме-
тоду config разрешается оставить leafType неинициализированным; это будет иметь тот же
эффект, что и присвоение leafType значения attType. Когда attType и leafType различаются,
должен предоставляться метод compress. Метод compress отвечает за преобразование данных,
подлежащих индексации, из типа attType в тип leafType. Заметьте, что обе функции, оценива-
ющие согласованность, получают значения scankeys неизменёнными, не прошедшими через
compress.
choose
Выбирает метод для добавления нового значения во внутренний кортеж.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_choose(internal, internal) RETURNS void ...
В первом аргументе передаётся указатель на структуру spgChooseIn языка C, содержащую
входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgChooseOut, в которую функция должна поместить результат.
typedef struct spgChooseIn
{
Datum
datum;
*/
Datum
leafDatum;
листе */
int
level;
/* исходное значение, которое должно индексироваться
/* текущее значение, которое должно сохраниться в
/* текущий уровень (начиная с нуля) */
/* Данные из текущего внутреннего кортежа */
bool
allTheSame;
/* кортеж с признаком все-равны? */
bool
hasPrefix;
/* у кортежа есть префикс? */
2152Индексы SP-GiST
Datum
prefixDatum;
int
nNodes;
Datum
*nodeLabels;
} spgChooseIn;
/* если да, то это значение префикса */
/* число узлов во внутреннем кортеже */
/* значения меток узлов (NULL, если их нет) */
typedef enum spgChooseResultType
{
spgMatchNode = 1,
/* спуститься в существующий узел */
spgAddNode,
/* добавить узел во внутренний кортеж */
spgSplitTuple
/* разделить внутренний кортеж (изменить его
префикс) */
} spgChooseResultType;
typedef struct spgChooseOut
{
spgChooseResultType resultType;
/* код действия, см. выше */
union
{
struct
/* результаты для spgMatchNode */
{
int
nodeN;
/* спуститься к этому узлу (нумерация с 0) */
int
levelAdd;
/* шаг увеличения уровня */
Datum
restDatum; /* новое значение листа */
}
matchNode;
struct
/* результаты для spgAddNode */
{
Datum
nodeLabel; /* метка нового узла */
int
nodeN;
/* куда вставлять её (нумерация с 0) */
}
addNode;
struct
/* результаты для spgSplitTuple */
{
/* Информация для формирования нового внутреннего кортежа верхнего
уровня с одним дочерним кортежем */
bool
prefixHasPrefix;
/* кортеж должен иметь префикс? */
Datum
prefixPrefixDatum; /* если да, его значение */
int
prefixNNodes;
/* число узлов */
Datum
*prefixNodeLabels;
/* их метки (или NULL, если
* меток нет) */
int
childNodeN;
/* узел, который получит дочерний кортеж
*/
/* Информация для формирования нового внутреннего кортежа нижнего уровня
со всеми старыми узлами */
bool
postfixHasPrefix;
/* кортеж должен иметь префикс? */
Datum
postfixPrefixDatum; /* если да, его значение */
}
splitTuple;
}
result;
} spgChooseOut;
В datum передаётся исходное значение типа spgConfigIn.attType, которое должно быть встав-
лено в индекс. В leafDatum содержится значение типа spgConfigOut.leafType, изначально
представляющее собой результат метода compress, применённого к datum, если метод compress
реализован, а иначе — собственно значение datum. leafDatum может быть другим на нижних
уровнях дерева, если его изменят функции choose или picksplit. Когда поиск места добавле-
ния достигает страницы уровня листа, в создаваемом кортеже листа сохраняется текущее зна-
чение leafDatum. В level задаётся текущий уровень внутреннего кортежа, начиная с нуля для
уровня корня. Признак allTheSame устанавливается, если текущий внутренний кортеж содер-
жит несколько равнозначных узлов (см. Подраздел 65.4.3). Признак hasPrefix устанавливает-
2153Индексы SP-GiST
ся, если текущий внутренний кортеж содержит префикс; в этом случае в prefixDatum задаётся
его значение. Поле nNodes задаёт число дочерних узлов, содержащихся во внутреннем корте-
же, а nodeLabels представляет массив их меток или NULL, если меток у них нет.
Функция choose может определить, соответствует ли новое значение одному из существующих
дочерних узлов, или что нужно добавить новый дочерний узел, или что новое значение не со-
гласуется с префиксом кортежа и внутренний кортеж нужно разделить, чтобы получить менее
ограничивающий префикс.
Если новое значение соответствует одному из существующих дочерних узлов, установите в
resultType значение spgMatchNode. Установите в nodeN номер этого узла в массиве узлов (ну-
мерация начинается с нуля). Установите в levelAdd значение, на которое должен увеличивать-
ся уровень (level) при спуске через этот узел, либо оставьте его нулевым, если класс операто-
ров не отслеживает уровни. Установите restDatum, равным leafDatum, если класс операторов
не меняет значения данных от уровня к уровню, а в противном случае запишите в него изме-
нённое значение, которое должно использоваться в качестве leafDatum на следующем уровне.
Если нужно добавить новый дочерний узел, установите в resultType значение spgAddNode. В
nodeLabel задайте метку для нового узла, а в nodeN позицию (отсчитываемую от нуля), в кото-
рую должен вставляться узел в массиве узлов. После того как узел будет добавлен, функция
choose вызывается снова с изменённым внутренним кортежем; в результате этого вызова дол-
жен быть получен результат spgMatchNode.
Если новое значение не согласуется с префиксом кортежа, установите в resultType значе-
ние spgSplitTuple. Это действие приводит к перемещению всех существующих узлов в но-
вый внутренний кортеж нижнего уровня и замене существующего внутреннего кортежа кор-
тежем, содержащим одну ссылку вниз на новый внутренний кортеж. Установите признак
prefixHasPrefix, чтобы указать, должен ли новый верхний кортеж иметь префикс, и если
да, задайте в prefixPrefixDatum значение префикса. Это новое значение префикса должно
быть в достаточной мере менее ограничивающим, чем исходное, чтобы в индекс было приня-
то новое значение. Запишите в prefixNNodes число требующихся узлов в новом кортеже, а в
prefixNodeLabels — указатель на выделенный через palloc массив с их метками или NULL, если
метки узлов не нужны. Заметьте, что общий размер нового кортежа верхнего уровня не должен
превышать общий размер кортежа, который он замещает; это ограничивает длины нового пре-
фикса и новых меток. Установите в childNodeN индекс (начиная с нуля) узла, который будет ссы-
латься на новый внутренний кортеж нижнего уровня. Установите признак postfixHasPrefix,
чтобы указать, должен ли новый внутренний кортеж нижнего уровня иметь префикс, и если
да, задайте в postfixPrefixDatum значение префикса. Сочетание этих двух префиксов и метки
узла, ссылающегося вниз, (если она есть) должно иметь то же значение, что и исходный пре-
фикс, так как нет возможности ни изменить метки узлов, перемещённых в новый кортеж ниж-
него уровня, ни изменить какие-либо нижние записи индекса. После того как узел разделён,
функция choose будет вызвана снова с заменяемым внутренним кортежем. При этом вызове
может быть возвращён результат spgAddNode, если подходящий узел не был создан действием
spgSplitTuple. В конце концов choose должна вернуть spgMatchNode, чтобы операция добавле-
ния могла перейти на следующий уровень.
picksplit
Выбирает, как создать новый внутренний кортеж по набору кортежей в листьях.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...
В первом аргументе передаётся указатель на структуру spgPickSplitIn языка C, содержа-
щую входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgPickSplitOut языка C, в которую функция должна поместить результат.
typedef struct spgPickSplitIn
{
2154Индексы SP-GiST
int
nTuples;
Datum
*datums;
int
level;
} spgPickSplitIn;
typedef struct spgPickSplitOut
{
bool
hasPrefix;
Datum
prefixDatum;
int
Datum
nNodes;
*nodeLabels;
/* число кортежей в листьях */
/* их значения (массив длины nTuples) */
/* текущий уровень (отсчитывая от 0) */
/* новый внутренний кортеж должен иметь префикс? */
/* если да, его значение */
/* число узлов для нового внутреннего кортежа */
/* их метки (или NULL, если их нет) */
int
*mapTuplesToNodes;
Datum
*leafTupleDatums;
} spgPickSplitOut;
/* номер узла для каждого кортежа в листе */
/* значения, помещаемые в каждый новый кортеж */
В nTuples задаётся число предоставленных кортежей уровня листьев, а в datums — массив их
значений типа spgConfigOut.leafType. В level указывается текущий уровень, который должны
разделять все кортежи листьев, и который станет уровнем нового внутреннего кортежа.
Установите признак hasPrefix, чтобы указать, должен ли новый внутренний кортеж иметь пре-
фикс, и если да, задайте в prefixDatum значение префикса. Установите в nNodes количество уз-
лов, которые будут содержаться во внутреннем кортеже, а в nodeLabels — массив значений их
меток либо NULL, если узлам не нужны метки. Поместите в mapTuplesToNodes указатель на мас-
сив, назначающий номера узлов (начиная с нуля) каждому кортежу листа. В leafTupleDatums
передайте массив значений, которые должны быть сохранены в новых кортежах листьев (они
будут совпадать со входными значениями (datums), если класс операторов не изменяет значе-
ния от уровня к следующему). Заметьте, что функция picksplit сама должна выделить память,
используя palloc, для массивов nodeLabels, mapTuplesToNodes и leafTupleDatums.
Если передаётся несколько кортежей листьев, ожидается, что функция picksplit классифици-
рует их и разделит на несколько узлов; иначе нельзя будет разнести кортежи листьев по раз-
ным страницам, что является конечной целью этой операции. Таким образом, если picksplit
в итоге помещает все кортежи листьев в один узел, ядро SP-GiST меняет это решение и создаёт
внутренний кортеж, в котором кортежи листьев связываются случайным образом с несколь-
кими узлами с одинаковыми метками. Такой кортеж помечается флагом allTheSame, показы-
вающим, что все узлы равны. Функции choose и inner_consistent должны работать с такими
внутренними кортежами особым образом. За дополнительными сведениями обратитесь к Под-
разделу 65.4.3.
picksplit может применяться к одному кортежу на уровне листьев, только когда функция
config установила в longValuesOK значение true и было передано входное значение, большее
страницы. В этом случае цель операции — отделить префикс и получить новое, более короткое
значение для листа. Этот вызов будет повторяться, пока значение уровня листа не уменьшится
настолько, чтобы уместиться в странице. За дополнительными сведениями обратитесь к Под-
разделу 65.4.1.
inner_consistent
Возвращает набор узлов (ветвей), по которым надо продолжать поиск.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...
В первом аргументе передаётся указатель на структуру spgInnerConsistentIn языка C, содер-
жащую входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgInnerConsistentOut языка C, в которую функция должна поместить результат.
typedef struct spgInnerConsistentIn
2155Индексы SP-GiST
{
ScanKey
int
scankeys;
nkeys;
/* массив операторов и искомых значений */
/* длина массива */
Datum
reconstructedValue;
/* значение, восстановленное для родителя */
void
*traversalValue; /* переходящее значение, специфичное для класса
операторов */
MemoryContext traversalMemoryContext;
/* переходящие значения нужно помещать
сюда */
int
level;
/* текущий уровень (отсчитывается от нуля) */
bool
returnData;
/* нужно ли возвращать исходные данные? */
/* Данные из текущего внутреннего кортежа */
bool
allTheSame;
/* кортеж с признаком все-равны? */
bool
hasPrefix;
/* у кортежа есть префикс? */
Datum
prefixDatum;
/* если да, то это значение префикса */
int
nNodes;
/* число узлов во внутреннем кортеже */
Datum
*nodeLabels;
/* значения меток узлов (NULL, если их нет) */
} spgInnerConsistentIn;
typedef struct spgInnerConsistentOut
{
int
nNodes;
/* число дочерних узлов, которые нужно посетить */
int
*nodeNumbers;
/* их номера в массиве узлов */
int
*levelAdds;
/* шаги увеличения уровня для этих узлов */
Datum
*reconstructedValues;
/* связанные восстановленные значения */
void
**traversalValues;
/* переходящие значения, специфичные для
класса операторов */
} spgInnerConsistentOut;
Массив scankeys длины nkeys описывает условия поиска по индексу. Эти условия объединя-
ются операцией И — найдены должны быть только те записи, которые удовлетворяют всем
условиям. (Заметьте, что с nkeys = 0 подразумевается, что запросу удовлетворяют все записи
в индексе.) Обычно эту функцию интересуют только поля sk_strategy и sk_argument в каж-
дой записи массива, в которых определяется соответственно индексируемый оператор и иско-
мое значение. В частности, нет необходимости проверять sk_flags, чтобы распознать NULL
в искомом значении, так как ядро SP-GiST отфильтрует такие условия. В reconstructedValue
передаётся значение, восстановленное для родительского кортежа; это может быть (Datum)
0 на уровне корня или если функция inner_consistent не установила значение на преды-
дущем уровне. Значение reconstructedValue всегда имеет тип spgConfigOut.leafType. В
traversalValue передаётся указатель на переходящие данные, полученные из предыдущего
вызова inner_consistent для родительского кортежа индекса, либо NULL на уровне корня. По-
ле traversalMemoryContext указывает на контекст памяти, в котором нужно сохранить выход-
ные переходящие данные (см. ниже). В level передаётся уровень текущего внутреннего кор-
тежа (уровень корня считается нулевым). Флаг returnData устанавливается, когда для этого
запроса нужно получить восстановленные данные; это возможно, только если функция config
установила признак canReturnData. Признак allTheSame устанавливается, если текущий внут-
ренний кортеж имеет пометку «все-равны»; в этом случае все узлы имеют одну метку (если
имеют) и значит, либо все они, либо никакой не соответствует запросу (см. Подраздел 65.4.3).
Признак hasPrefix устанавливается, если текущий внутренний кортеж содержит префикс; в
этом случае в prefixDatum находится его значение. В nNodes задаётся число дочерних узлов,
содержащихся во внутреннем кортеже, а в nodeLabels — массив их меток либо NULL, если они
не имеют меток.
В nNodes нужно записать число дочерних узлов, которые потребуется посетить при поиске, а
в nodeNumbers — массив их индексов. Если класс операторов отслеживает уровни, в levelAdds
нужно передать массив с шагами увеличения уровня при посещении каждого узла. (Часто шаг
будет одним для всех узлов, но может быть и по-другому, поэтому применяется массив.) Ес-
2156Индексы SP-GiST
ли потребовалось восстановить значения, поместите в reconstructedValues указатель на мас-
сив значений типа spgConfigOut.leafType, восстановленных для каждого дочернего узла, ко-
торый нужно посетить; в противном случае оставьте reconstructedValues равным NULL. Ес-
ли желательно передать дополнительные данные («переходящие значения») на нижние уров-
ни при поиске по дереву, поместите в traversalValues указатель на массив соответствую-
щих переходящих значений, по одному для каждого дочернего узла, который нужно посе-
тить; в противном случае оставьте в traversalValues значение NULL. Заметьте, что функция
inner_consistent сама должна выделять память, используя palloc, для массивов nodeNumbers,
levelAdds, distances, reconstructedValues и traversalValues в текущем контексте памя-
ти. Однако выходные переходящие значения, на которые указывает массив traversalValues,
должны размещаться в контексте traversalMemoryContext. При этом каждое переходящее зна-
чения должно располагаться в отдельном блоке памяти palloc.
leaf_consistent
Возвращает true, если кортеж листа удовлетворяет запросу.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...
В первом аргументе передаётся указатель на структуру spgLeafConsistentIn языка C, содер-
жащую входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgLeafConsistentOut языка C, в которую функция должна поместить результат.
typedef struct spgLeafConsistentIn
{
ScanKey
scankeys;
/* массив операторов и искомых значений */
int
nkeys;
/* длина массива */
Datum
reconstructedValue;
/* значение, восстановленное для родителя */
void
*traversalValue; /* переходящее значение, специфичное для класса
операторов */
int
level;
/* текущий уровень (отсчитывая от нуля) */
bool
returnData;
/* нужно ли возвращать исходные данные? */
Datum
leafDatum;
} spgLeafConsistentIn;
/* значение в кортеже листа */
typedef struct spgLeafConsistentOut
{
Datum
leafValue;
/* восстановленные исходные данные, при наличии */
bool
recheck;
/* true, если оператор нужно перепроверить */
} spgLeafConsistentOut;
Массив scankeys длины nkeys описывает условия поиска по индексу. Эти условия объединя-
ются операцией И — запросу удовлетворяют только те записи в индексе, которые удовлетво-
ряют всем этим условиям. (Заметьте, что с nkeys = 0 подразумевается, что запросу удовле-
творяют все записи в индексе.) Обычно эту функцию интересуют только поля sk_strategy
и sk_argument в каждой записи массива, в которых определяются соответственно индекси-
руемый оператор и искомое значение. В частности, нет необходимости проверять sk_flags,
чтобы распознать NULL в искомом значении, так как ядро SP-GiST отфильтрует такие усло-
вия. В reconstructedValue передаётся значение, восстановленное для родительского кор-
тежа; это может быть (Datum) 0 на уровне корня или если функция inner_consistent не
установила значение на предыдущем уровне. Значение reconstructedValue всегда имеет тип
spgConfigOut.leafType. В traversalValue передаётся указатель на переходящие данные, полу-
ченные из предыдущего вызова inner_consistent для родительского кортежа индекса, либо
NULL на уровне корня. В level передаётся уровень текущего внутреннего кортежа (уровень
корня считается нулевым). Флаг returnData устанавливается, когда для этого запроса нужно
получить восстановленные данные; это возможно, только если функция config установила при-
2157Индексы SP-GiST
знак canReturnData. В leafDatum передаётся значение ключа типа spgConfigOut.leafType, за-
писанное в текущем кортеже листа.
Эта функция должна вернуть true, если кортеж листа соответствует запросу, или false в про-
тивном случае. В случае положительного результата, если в поле returnData передано true,
нужно поместить в leafValue значение типа spgConfigIn.attType, изначально переданное для
индексации в этот кортеж. Кроме того, флагу recheck можно присвоить true, если соответствие
неточное, так что для установления точного результата проверки нужно повторно применить
оператор(ы) к актуальному кортежу данных.
Дополнительно пользователь может определить метод:
Datum compress(Datum in)
Преобразует элемент данных в формат, подходящий для физического хранения в кортеже уров-
ня листьев на странице индекса. Эта функция принимает значение spgConfigIn.attType и воз-
вращает spgConfigOut.leafType (это значение должно быть не в виде TOAST).
Все опорные методы SP-GiST обычно вызываются в кратковременных контекстах памяти; то есть
CurrentMemoryContext сбрасывается после обработки каждого кортежа. Таким образом, можно не
заботиться об освобождении любых блоков памяти, выделенных функцией palloc. (Метод config
является исключением: в нём нужно не допускать утечек памяти. Но обычно метод config не
делает ничего, кроме как присваивает константы переданной структуре параметров.)
Если индексируемый столбец имеет сортируемый тип данных, правило сортировки индекса будет
передаваться всем опорным методам, используя стандартный механизм PG_GET_COLLATION().
65.4. Реализация
В этом разделе освещаются тонкости реализации и особенности, о которых полезно знать тем, кто
будет реализовывать классы операторов SP-GiST.
65.4.1. Ограничения SP-GiST
Отдельные кортежи листьев и внутренние кортежи должны умещаться в одной странице индек-
са (по умолчанию её размер 8 Кбайт). Таким образом при индексировании значений типов дан-
ных переменной длины большие значения могут поддерживаться только такими схемами, как пре-
фиксные деревья, в которых каждый уровень дерева включает префикс, достаточно короткий для
помещения в страницу, и на конечном уровне листьев содержится суффикс, который также до-
статочно мал, чтобы поместиться в странице. Класс операторов должен устанавливать признак
longValuesOK, только если он готов организовывать такую структуру. Если этот признак не уста-
новлен, ядро SP-GiST не примет запрос на индексацию значения, которое слишком велико для
одной страницы индекса.
Также класс операторов должен отвечать за то, чтобы внутренние кортежи при расширении не
выходили за пределы страницы индекса; это ограничивает число дочерних узлов, которые могут
принадлежать одному внутреннему кортежу, а также максимальный размер значения префикса.
Ещё одно ограничение состоит в том, что когда узел внутреннего кортежа указывает на набор кор-
тежей листьев, все эти кортежи должны находиться в одной странице индекса. (Это конструктив-
ное ограничение введено для оптимизации позиционирования и экономии места на ссылках, свя-
зывающих такие кортежи вместе.) Если набор кортежей листьев оказывается слишком большим
для одной страницы, выполняется разделение и вставляется промежуточный внутренний кортеж.
Чтобы устранить возникшую проблему, новый внутренний кортеж должен разделять набор зна-
чений в листе на несколько групп узлов. Если функция picksplit класса операторов не может
сделать это, ядро SP-GiST переходит к чрезвычайным мерам, описанным в Подразделе 65.4.3.
65.4.2. SP-GiST без меток узлов
В некоторых древовидных схемах каждый внутренний кортеж содержит фиксированный набор
узлов; например, в дереве квадрантов это всегда четыре узла, соответствующие четырём квад-
2158Индексы SP-GiST
рантам вокруг центральной точки внутреннего кортежа. В таком случае код обычно работа-
ет с узлами по номерам и необходимости в явных метках узлов нет. Чтобы убрать метки уз-
лов (и таким образом сэкономить место), функция picksplit может возвратить NULL вместо
массива nodeLabels, а функция choose аналогично может возвратить NULL вместо массива
prefixNodeLabels во время действия spgSplitTuple. В результате при последующих вызовах функ-
ций choose и inner_consistent им вместо nodeLabels будет передаваться NULL. В принципе мет-
ки узлов могут применяться для одних внутренних кортежей и отсутствовать у других в том же
индексе.
Когда внутренний кортеж содержит узлы без меток, функция choose не может выбрать действие
spgAddNode, так как в этом случае предполагается, что набор узлов фиксированный.
65.4.3. Внутренние кортежи «все-равны»
Ядро SP-GiST может переопределить результаты функции picksplit класса операторов, когда эта
функция не может разделить поступившие значения листьев на минимум две категории узлов.
Когда это происходит, создаётся новый внутренний кортеж с несколькими узлами, каждый из ко-
торых имеет одну метку (если имеет), которую picksplit дала одному узлу, а значения листьев
распределяются случайно между этими равнозначными узлами. Для этого внутреннего кортежа
устанавливается флаг allTheSame, который предупреждает функции choose и inner_consistent,
что кортеж не содержит набор узлов, который они обычно ожидают.
Когда обрабатывается кортеж с флагом allTheSame, выбранное функцией choose действие
spgMatchNode воспринимается как указание, что новое значение можно присвоить одному из рав-
нозначных узлов; код ядра будет игнорировать полученное значение nodeN и спустится в один
из узлов, выбранный случайно (чтобы дерево было сбалансированным). Будет считаться ошиб-
кой, если choose выберет действие spgAddNode, так как при этом не все узлы окажутся равны;
если добавляемое значение не соответствует существующим узлам, должно выбираться действие
spgSplitTuple.
Также, когда обрабатывается кортеж с флагом allTheSame, функция inner_consistent должна
вернуть все или не возвращать никакие узлы для продолжения поиска по индексу, так как все узлы
равнозначны. Для этого может потребоваться, а может и не потребоваться код обработки особого
случая, в зависимости от того, как inner_consistent обычно воспринимает узлы.
65.5. Примеры
Дистрибутив исходного кода PostgreSQL содержит несколько примеров классов операторов индек-
са SP-GiST, перечисленных в Таблице 65.1. Код их реализации вы можете найти в src/backend/
access/spgist/ и src/backend/utils/adt/.
2159
