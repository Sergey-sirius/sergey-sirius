---
layout: post
title: Глава 55. Языковая поддержка
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 55. Языковая поддержка

55.1. Переводчику

Программы PostgreSQL (серверные и клиентские) могут выдавать сообщения на предпочитаемом
вами языке — если эти сообщения были переведены. Создание и поддержка переведённых наборов
сообщений предполагает помощь со стороны людей, которые хорошо говорят на своём языке и
хотят сотрудничать с PostgreSQL. Для этого совершенно не обязательно быть программистом. В
данном разделе объясняется, как можно помочь.
55.1.1. Требования
Мы не будем оценивать ваши языковые навыки — данный раздел посвящён средствам программ-
ного обеспечения. Теоретически, требуется лишь текстовый редактор. Но, скорее всего, вы захо-
тите проверить свои переведённые сообщения. Когда вы выполняете configure, обязательно ис-
пользуйте параметр --enable-nls. Это также проверит библиотеку libintl и программу msgfmt, ко-
торые понадобятся всем пользователям в любом случае. Чтобы проверить свою работу, следуйте
соответствующим разделам инструкций по установке.
Если вы захотите выполнить перевод или слияние каталога сообщений (описано ниже), вам пона-
добятся, соответственно, программы xgettext и msgmerge в GNU-совместимой реализации. Позд-
нее, мы постараемся сделать так, что если вы будете использовать дистрибутив исходников, вам
не понадобится xgettext. (При работе с Git, вам всё же это будет необходимо). В настоящее время
рекомендуется GNU Gettext 0.10.36 или более поздняя версия.
К вашей реализации gettext должна прилагаться документация. Некоторая её часть, возможно,
будет продублирована ниже, но более подробную информацию следует искать там.
55.1.2. Основные понятия
Пары оригинальных (английских) сообщений и их (предположительно) переведённых эквивален-
тов хранятся в каталогах сообщений, по одному для каждой программы (хотя связанные програм-
мы могут иметь общий каталог) и для каждого языка перевода. Существует два формата, поддер-
живающих каталоги сообщений: Первый — «PO» (Portable Object, переносимый объект), который
является простым текстовым файлом с особым синтаксисом, редактируемый переводчиками. Вто-
рой — «MO» (Machine Object, машинный объект), который является двоичным файлом, генерируе-
мым из соответствующего файла PO, и используется при выполнении интернационализированной
программы. Переводчики не работают с файлами MO; фактически с ними едва ли кто-то работает
напрямую.
Файл каталога сообщений, как можно было предположить, имеет расширение .po или .mo. Базо-
вым именем является либо имя сопровождаемой им программы, либо язык, для которого создан
файл, в зависимости от ситуации. Это создаёт некоторую путаницу. Например, psql.po (файл PO
для psql) или fr.mo (файл MO на французском).
Здесь проиллюстрирован формат файлов PO:
# comment
msgid "original string"
msgstr "translated string"
msgid "more original"
msgstr "another translated"
"string can be broken up like this"
...
Строки msgid извлекаются из исходного кода программы (что необязательно, но это наиболее рас-
пространённый способ). Строки msgstr изначально пусты, и переводчик заполняет их переводами.
2080Языковая поддержка
Строки могут содержать экранирующие спецсимволы в стиле С и занимать несколько строк, как
в приведённом примере. (Следующая строка должна начинаться с начала строки.)
Символ # обозначает начало комментария. Если сразу за символом # следует пробел, то этим ком-
ментарием управляет переводчик. Комментарии также могут быть автоматическими, у которых
сразу за # следует символ, отличный от пробела. Они управляются различными инструментами,
которые работают с файлами PO и предназначены для переводчиков.
#. automatic comment
#: filename.c:1023
#, flags, flags
Комментарии в стиле #. извлекаются из исходного файла, где используется сообщение. Возмож-
но, программист вставил информацию для переводчика, например, о предполагаемом выравнива-
нии. Комментарий #: указывает точное место (места), где сообщение используется в исходном
коде. Переводчику не нужно смотреть на исходный код программы, но он может это сделать, ес-
ли сомневается в точности перевода. Комментарии #, содержат флаги, которые некоторым обра-
зом описывают сообщение. В настоящее время существует два флага: fuzzy устанавливается, ес-
ли сообщение, возможно, стало неактуально по причине изменений в исходном коде программы.
Переводчик может проверить это и, возможно, удалить флаг fuzzy. Заметьте, что fuzzy сообщения
недоступны конечному пользователю. Другой флаг это c-format, который указывает, что сообще-
ние является шаблоном формата в стиле printf. Это означает, что перевод также должен быть
строкой формата с таким же количеством и типом "заполнителей". Существуют средства, которые
распознают и проверяют флаги c-format.
55.1.3. Создание и управление каталогами сообщений
Итак, как же создать «blank» каталог сообщений? Во-первых, зайдите в каталог, содержащий про-
грамму, сообщения которой необходимо перевести. Если имеется файл nls.mk, данная программа
подготовлена к переводу.
Если уже есть некоторые .po файлы, то кто-то уже занимался переводом. Файлы получают имя
language.po, где language это двухбуквенный языковой код ISO 639-1 (в нижнем регистре), на-
пример, fr.po для французского. Если требуется больше одного перевода на какой-либо язык,
файлы могут также быть названы language_region.po, где region это двухбуквенный код страны
ISO 3166-1 (в верхнем регистре), например, pt_BR.po для португальского в Бразилии. Если найден
необходимый язык, можно просто начать работать над этим файлом.
Если необходимо начать новый перевод, сначала выполните команду:
make init-po
В результате будет создан файл progname.pot. (.pot, чтобы отличать его от файлов PO, находящих-
ся «в эксплуатации». T означает «шаблон».) Скопируйте данный файл в language.po и редакти-
руйте его. Чтобы сообщить о том, что новый язык доступен, также редактируйте файл nls.mk и до-
бавляйте языковой код (или код языка и страны) к строке, которая выглядит следующим образом:
AVAIL_LANGUAGES := de fr
(Конечно, и другие языки могут появиться.)
По мере развития базовой программы или библиотеки, сообщения могут быть изменены или до-
бавлены программистами. В этом случае нет необходимости начинать с нуля. Вместо этого выпол-
ните команду:
make update-po
что создаст новый пустой файл каталога сообщений (файл с расширением pot, с которого вы на-
чали) и объединит его с существующими файлами PO. Если алгоритм слияния не распознаёт кон-
кретное сообщение, он ставит пометку «fuzzy», как говорилось выше. Новый файл PO сохраняется
с расширением .po.new.
2081Языковая поддержка
55.1.4. Редактирование файлов PO
Файлы PO можно редактировать при помощи обычного текстового редактора. Переводчику нужно
лишь вставить перевод между кавычками после директивы msgstr, добавить комментарии и изме-
нить флаг fuzzy. Существует также режим PO для Emacs, который представляется довольно полез-
ным.
Файлы PO не обязательно должны быть полностью заполнены. Программа автоматически вернётся
к использованию исходной строки, если перевод недоступен (или отсутствует). Вы вполне можете
предлагать для включения в исходный код неполный перевод; это даст возможность другим про-
должить работу над ним. Однако после слияния рекомендуется в первую очередь удалить ненуж-
ные неточные соответствия. Помните, что неточные соответствия в итоге не будут использоваться,
они могут лишь подсказывать, каким мог бы быть перевод похожей строки.
Ниже описаны моменты, которые следует учитывать при редактировании переводов:
• Если оригинал заканчивается переводом строки, важно, чтобы это было отражено и в перево-
де. То же относится к табуляции, и т. п.
• Если оригиналом является строка форматирования printf, то перевод должен иметь такой же
вид. Перевод также должен иметь те же спецификаторы формата в том же порядке. Иногда
правила языка таковы, что это невозможно или как минимум нелепо. В таком случае можно
модифицировать спецификаторы формата подобным образом:
msgstr "Die Datei %2$s hat %1$u Zeichen."
Тогда первый заполнитель просто использует второй аргумент из списка.digits$ должен сто-
ять сразу за % до любых других модификаторов формата. (Эта возможность действительно су-
ществует в семействе функций printf. Вы, возможно, не слышали о ней раньше, потому что
она мало используется где-либо кроме интернационализации сообщений.)
• Если исходная строка содержит лингвистическую ошибку, сообщите об этом (или исправьте
самостоятельно в исходном коде программы) и переведите правильно. Верная строка может
быть добавлена, когда исходный программный код будет обновлен. Если исходная строка со-
держит фактическую ошибку, сообщите об этом (или исправьте самостоятельно) и не перево-
дите её. Вместо этого, можно отметить строку, оставив комментарий в файле PO.
• Сохраняйте стиль и тон исходной строки. В частности, сообщения, не являющиеся предложе-
ниями (cannot open file %s), вероятно, не следует начинать с заглавной буквы (если в вашем
языке есть разделение на регистры) или заканчивать точкой (если в вашем языке использу-
ются знаки препинания). Дополнительно см. Раздел 54.3.
• Если вы не знаете, что означает какое-либо сообщение, или если оно допускает двоякое тол-
кование, обратитесь за помощью через список рассылки разработчиков. По всей вероятности,
англоговорящие пользователи могут также его не понять или найти двусмысленным, поэтому
лучше исправить это сообщение.
55.2. Программисту
55.2.1. Механизмы
Данный раздел описывает как добавить языковую поддержку в программе или библиотеке, кото-
рая является частью дистрибутива PostgreSQL. В настоящий момент это относится только к про-
граммам на языке С.
Добавление языковой поддержки для программы
1.
Вставьте этот код в начало программы:
#ifdef ENABLE_NLS
#include <locale.h>
#endif
2082Языковая поддержка
...
#ifdef ENABLE_NLS
setlocale(LC_ALL, "");
bindtextdomain("progname", LOCALEDIR);
textdomain("progname");
#endif
(progname фактически может быть выбрана произвольно.)
2.
Везде, где сообщение нуждается в переводе, необходимо вставить вызов gettext(). Например:
fprintf(stderr, "panic level %d\n", lvl);
нужно заменить на:
fprintf(stderr, gettext("panic level %d\n"), lvl);
(gettext определяется как холостая команда, если NLS поддержка не настроена.)
Это часто приводит к немалой путанице. Один из распространённых подходов в этом случае:
#define _(x) gettext(x)
Ещё одно решение допустимо, если программа часто выполняет обмен данными через одну
или несколько функций, таких как ereport() в серверном процессе. Тогда вы выполняете внут-
ренний вызов функции gettext для каждой входящей строки.
3.
Добавьте файл nls.mk в каталог с исходными кодами программы. Данный файл будет считать-
ся сборочным файлом (makefile). В нём необходимо выполнить присвоение значений для сле-
дующих переменных:
CATALOG_NAME
Имя программы, которое указано в вызове textdomain().
AVAIL_LANGUAGES
Список выполненных переводов (изначально пустой).
GETTEXT_FILES
Список файлов, которые содержат подлежащие переводу строки, т. е. помеченные gettext
или альтернативным решением. В итоге, в него будут включены почти все исходные файлы
программы. Если список станет слишком длинным, можно первый «file» сделать + а второе
слово — файлом, который содержит по одному имени файла на строку.
GETTEXT_TRIGGERS
Утилитам, которые генерируют каталоги сообщений для работы переводчиков, должно
быть известно, какие вызовы функции содержат строки, подлежащие переводу. По умол-
чанию распознаются только вызовы gettext(). Если вы использовали _ или другие иден-
тификаторы, необходимо перечислить их здесь. Если подлежащая переводу строка не яв-
ляется первым аргументом, необходимо, чтобы элемент имел форму func:2 (для второго
аргумента). Если функция поддерживает сообщения в форме множественного числа, эле-
мент должен выглядеть следующим образом func:1,2 (идентификация аргументов в виде
сообщений в форме единственного и множественного числа).
Система сборки автоматически соберёт и установит каталоги сообщений.
55.2.2. Рекомендации по написанию сообщений
Ниже описаны некоторые рекомендации по написанию сообщений, которые легко перевести.
• Не составляйте предложения во время выполнения. Например:
printf("Files were %s.\n", flag ? "copied" : "removed");
2083Языковая поддержка
Порядок слов в предложении может отличаться в других языках. Также, даже если вы не за-
бываете вызывать gettext() для каждого фрагмента, возможно, что по отдельности они не бу-
дут переведены хорошо. Лучше продублировать небольшую часть кода, чтобы каждое сообще-
ние было переведено как единое целое. Лишь цифры, имена файлов и подобные текущие пере-
менные следует вставлять в текст сообщения во время выполнения.
• По тем же причинам следующий подход не будет работать:
printf("copied %d file%s", n, n!=1 ? "s" : "");
так как это подразумевает, как формируется форма множественного числа. Если вы думаете,
что сможете решить это таким способом:
if (n==1)
printf("copied 1 file");
else
printf("copied %d files", n):
возможно, вы будете разочарованы. В некоторых языках существует более двух форм, и они
образуются по особым правилам. Обычно лучше сформулировать сообщение, которое позво-
лит полностью избежать этой проблемы, например:
printf("number of copied files: %d", n);
Если вы действительно хотите формировать правильно составленные сообщения в форме мно-
жественного числа, есть способ этого добиться, но это несколько неудобно. При генерирова-
нии первичного или детализированного сообщения об ошибке в ereport(), можно написать
так:
errmsg_plural("copied %d file",
"copied %d files",
n,
n)
Первым аргументом является строка формата, соответствующая форме единственного чис-
ла в английском языке, вторым аргументом — строка формата, соответствующая форме мно-
жественного числа в английском языке, и третьим аргументом — управляющее целочислен-
ное значение, которое определяет, какую форму (единственного или множественного числа)
использовать. Последующие аргументы форматируются на основе строки формата, как обыч-
но. (Как правило, значение аргумента для управления формой множественного числа будет
также одним из значений, подлежащих форматированию, поэтому оно должно быть записа-
но дважды.) В английском языке важно лишь, является ли значение n единицей или нет, но
в других языках может быть много различных форм множественного числа. Переводчик рас-
сматривает две английские формы как группу и имеет возможность задать несколько вариан-
тов замены строк, при этом подходящий вариант выбирается исходя из текущего значения n.
Если вам нужно составить сообщение в форме множественного числа, которое не использует-
ся непосредственно при выводе сообщений в errmsg или errdetail, вы должны воспользовать-
ся базовой функцией ngettext. См. документацию по gettext.
• Если вы хотите передать какую-либо информацию переводчику, например о том, насколько
сообщение соотносится с другими выходными данными, перед строкой должен появиться ком-
ментарий, который начинается с translator, например:
/* translator: This message is not what it seems to be. */
Эти комментарии копируются в файлы каталога сообщений, чтобы переводчик мог их видеть.
2084
