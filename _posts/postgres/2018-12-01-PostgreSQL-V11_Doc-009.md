---
layout: post
title: Глава 9. Функции и операторы
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---
Глава 9. Функции и операторы

PostgreSQL предоставляет огромное количество функций и операторов для встроенных типов дан-
ных. Кроме того, пользователи могут определять свои функции операторы, как описано в Части V.
Просмотреть все существующие функции и операторы можно в psql с помощью команд \df и \do,
соответственно.
Если для вас важна переносимость, учтите, что практически все функции и операторы, описанные
в этой главе, за исключением простейших арифметических и операторов сравнения, а также яв-
но отмеченных функций, не описаны в стандарте SQL. Тем не менее, частично эта расширенная
функциональность присутствует и в других СУБД SQL и во многих случаях различные реализации
одинаковых функций оказываются аналогичными и совместимыми. В этой главе не описываются
абсолютно все функции; некоторые дополнительные функции рассматриваются в других разделах
документации.
9.1. Логические операторы
Набор логических операторов включает обычные:
AND
OR
NOT
В SQL работает логическая система с тремя состояниями: true (истина), false (ложь) и NULL,
«неопределённое» состояние. Рассмотрите следующие таблицы истинности:
a b a AND b a OR b
TRUE TRUE TRUE TRUE
TRUE FALSE FALSE TRUE
TRUE NULL NULL TRUE
FALSE FALSE FALSE FALSE
FALSE NULL FALSE NULL
NULL NULL NULL NULL
a NOT a
TRUE FALSE
FALSE TRUE
NULL NULL
Операторы AND и OR коммутативны, то есть от перемены мест операндов результат не меняется.
Однако значение может иметь порядок вычисления подвыражений. Подробнее это описано в Под-
разделе 4.2.14.
9.2. Функции и операторы сравнения
Набор операторов сравнения включает обычные операторы, перечисленные в Таблице 9.1.
Таблица 9.1. Операторы сравнения
Оператор Описание
< меньше
> больше
<= меньше или равно
>= больше или равно
181Функции и операторы
Оператор Описание
= равно
<> или != не равно
Примечание
Оператор != преобразуется в <> на стадии разбора запроса. Как следствие, реализовать
операторы != и <> по-разному невозможно.
Операторы сравнения определены для всех типов данных, для которых они имеют смысл. Все
операторы сравнения представляют собой бинарные операторы, возвращающие значения типа
boolean; при этом выражения вида 1 < 2 < 3 недопустимы (так как не существует оператора <,
который бы сравнивал булево значение с 3).
Существует также несколько предикатов сравнения; они приведены в Таблице 9.2. Они работают
подобно операторам, но имеют особый синтаксис, установленный стандартом SQL.
Таблица 9.2. Предикаты сравнения
Предикат Описание
a BETWEEN x AND y между
a NOT BETWEEN x AND y не между
a BETWEEN SYMMETRIC x AND y между, после сортировки сравниваемых значе-
ний
a NOT BETWEEN SYMMETRIC x AND y не между, после сортировки сравниваемых зна-
чений
a IS DISTINCT FROM b не равно, при этом NULL воспринимается как
обычное значение
a IS NOT DISTINCT FROM b равно, при этом NULL воспринимается как обыч-
ное значение
выражение IS NULL эквивалентно NULL
выражение IS NOT NULL не эквивалентно NULL
выражение ISNULL эквивалентно NULL (нестандартный синтаксис)
выражение NOTNULL не эквивалентно NULL (нестандартный синтак-
сис)
логическое_выражение IS TRUE истина
логическое_выражение IS NOT TRUE ложь или неопределённость
логическое_выражение IS FALSE ложь
логическое_выражение IS NOT FALSE истина или неопределённость
логическое_выражение IS UNKNOWN неопределённость
логическое_выражение IS NOT UNKNOWN истина или ложь
Предикат BETWEEN упрощает проверки интервала:
a BETWEEN x AND y
равнозначно выражению
a >= x AND a <= y
Заметьте, что BETWEEN считает, что границы интервала также включаются в интервал. NOT BETWEEN
выполняет противоположное сравнение:
a NOT BETWEEN x AND y
182Функции и операторы
равнозначно выражению
a < x OR a > y
Предикат BETWEEN SYMMETRIC аналогичен BETWEEN, за исключением того, что аргумент слева от
AND не обязательно должен быть меньше или равен аргументу справа. Если это не так, аргументы
автоматически меняются местами, так что всегда подразумевается непустой интервал.
Обычные операторы сравнения выдают NULL (что означает «неопределённость»), а не true или
false, когда любое из сравниваемых значений NULL. Например, 7 = NULL выдаёт NULL, так же,
как и 7 <> NULL. Когда это поведение нежелательно, можно использовать предикаты IS [ NOT ]
DISTINCT FROM:
a IS DISTINCT FROM b
a IS NOT DISTINCT FROM b
Для значений не NULL условие IS DISTINCT FROM работает так же, как оператор <>. Однако, если
оба сравниваемых значения NULL, результат будет false, и только если одно из значений NULL,
возвращается true. Аналогично, условие IS NOT DISTINCT FROM равносильно = для значений не
NULL, но возвращает true, если оба сравниваемых значения NULL и false в противном случае. Та-
ким образом, эти предикаты по сути работают с NULL, как с обычным значением, а не с «неопре-
делённостью».
Для проверки, содержит ли значение NULL или нет, используются предикаты:
выражение IS NULL
выражение IS NOT NULL
или равнозначные (но нестандартные) предикаты:
выражение ISNULL
выражение NOTNULL
Заметьте, что проверка выражение = NULL не будет работать, так как NULL считается не «равным»
NULL. (Значение NULL представляет неопределённость, и равны ли две неопределённости, тоже
не определено.)
Подсказка
Некоторые приложения могут ожидать, что выражение = NULL вернёт true, если ре-
зультатом выражения является NULL. Такие приложения настоятельно рекомендует-
ся исправить и привести в соответствие со стандартом SQL. Однако, в случаях, когда
это невозможно, это поведение можно изменить с помощью параметра конфигурации
transform_null_equals. Когда этот параметр включён, PostgreSQL преобразует условие
x = NULL в x IS NULL.
Если выражение возвращает табличную строку, тогда IS NULL будет истинным, когда само выраже-
ние — NULL или все поля строки — NULL, а IS NOT NULL будет истинным, когда само выражение
не NULL, и все поля строки так же не NULL. Вследствие такого определения, IS NULL и IS NOT
NULL не всегда будут возвращать взаимодополняющие результаты для таких выражений; в частно-
сти такие выражения со строками, одни поля которых NULL, а другие не NULL, будут ложными
одновременно. В некоторых случаях имеет смысл написать строка IS DISTINCT FROM NULL или
строка IS NOT DISTINCT FROM NULL, чтобы просто проверить, равно ли NULL всё значение строки,
без каких-либо дополнительных проверок полей строки.
Логические значения можно также проверить с помощью предикатов
логическое_выражение
логическое_выражение
логическое_выражение
логическое_выражение
IS
IS
IS
IS
TRUE
NOT TRUE
FALSE
NOT FALSE
183Функции и операторы
логическое_выражение IS UNKNOWN
логическое_выражение IS NOT UNKNOWN
Они всегда возвращают true или false и никогда NULL, даже если какой-любо операнд — NULL.
Они интерпретируют значение NULL как «неопределённость». Заметьте, что IS UNKNOWN и IS NOT
UNKNOWN по сути равнозначны IS NULL и IS NOT NULL, соответственно, за исключением того, что
выражение может быть только булевого типа.
Также имеется несколько связанных со сравнениями функций; они перечислены в Таблице 9.3.
Таблица 9.3. Функции сравнения
Функция Описание
Пример
Результат примера
num_nonnulls(
VARIADIC "any") возвращает число ар- num_nonnulls(1,
гументов, отличных от NULL, 2)
NULL 2
num_nulls(VARIADIC
"any") возвращает число аргу- num_nulls(1, NULL,
ментов NULL
2) 1
9.3. Математические функции и операторы
Математические операторы определены для множества типов PostgreSQL. Как работают эти опе-
рации с типами, для которых нет стандартных соглашений о математических действиях (напри-
мер, с типами даты/времени), мы опишем в последующих разделах.
В Таблице 9.4 перечислены все доступные математические операторы.
Таблица 9.4. Математические операторы
Оператор Описание Пример Результат
+ сложение 2 + 3 5
- вычитание 2 - 3 -1
* умножение 2 * 3 6
/ деление (при целочис- 4 / 2
ленном делении оста-
ток отбрасывается) 2
% остаток от деления 1
^ возведение в степень ( 2.0 ^ 3.0
вычисляется слева на-
право) 8
|/ квадратный корень |/ 25.0 5
||/ кубический корень ||/ 27.0 3
! факториал 5 ! 120
!! факториал
ная форма) @ модуль числа (абсолют- @ -5.0
ное значение) 5
& битовый AND 91 & 15 11
| битовый OR 32 | 3 35
# битовый XOR 17 # 5 20
~ битовый NOT ~1 -2
<< битовый сдвиг влево 1 << 4 16
>> битовый сдвиг вправо 8 >> 2 2
5 % 4
(префикс- !! 5
184
120Функции и операторы
Битовые операторы работают только с целостными типами данных, тогда как другие и работают
и с остальными числовыми типами. Битовые операции также работают с битовыми строками bit
и bit varying, как показано в Таблице 9.13.
В Таблице  9.5 перечислены все существующие математические функции. Сокращение dp в ней
обозначает тип double precision (плавающее с двойной точностью). Многие из этих функций име-
ют несколько форм с разными типами аргументов. За исключением случаев, где это указано явно,
любая форма функции возвращает результат того же типа, что и аргумент. Функции, работающие
с данными double precision, в массе своей используют реализации из системных библиотек сер-
вера, поэтому точность и поведение в граничных случаях может зависеть от системы сервера.
Таблица 9.5. Математические функции
Функция Тип результата Описание
Пример
abs( x) тип аргумента модуль числа ( abs(-17.4)
абсолютное значе-
ние) 17.4
cbrt( dp) dp кубический
рень 3
ко- cbrt(27.0)
Результат
ceil( dp
numeric) или тип аргумента ближайшее целое, ceil(-42.8)
большее или рав-
ное аргументу -42
ceiling( dp
numeric) или тип аргумента ближайшее целое, ceiling(-95.3)
большее или рав-
ное аргументу (
равнозначно ceil) -95
преобразование
degrees(0.5)
радианов в граду-
сы 28.6478897565
412
целочисленный
результат y/x div(9,4) 2
exp(1.0) 2.7182818284
5905
degrees( dp)
dp
div( y
numeric, numeric
x numeric)
exp( dp
numeric) или тип аргумента экспонента floor( dp
numeric) или тип аргумента ближайшее целое, floor(-42.8)
меньшее или рав-
ное аргументу -43
ln( dp
numeric) или тип аргумента натуральный лога- ln(2.0)
рифм 0.6931471805
59945
log( dp
numeric) или тип аргумента логарифм по осно- log(100.0)
ванию 10 2
логарифм по осно- log(2.0, 64.0)
ванию b 6.0000000000
log( b
numeric, numeric
x numeric)
mod( y,
x)
pi()
power( a
dp)
зависит от типов остаток
аргументов
ния y/x
dp
dp,
b dp
power( a numeric, numeric
b numeric)
от
деле- mod(9,4)
константа «π»
pi()
1
3.1415926535
8979
a возводится в сте- power(9.0, 3.0)
пень b 729
a возводится в сте- power(9.0, 3.0)
пень b 729
185Функции и операторы
Функция Тип результата Описание radians( dp) dp преобразование
radians(45.0)
градусов в радиа-
ны 0.7853981633
97448
округление до бли- round(42.4)
жайшего целого 42
round( v numeric, numeric
s int) округление v до round(42.4382,
s десятичных зна- 2)
ков 42.44
scale( numeric) масштаб аргумен- scale(8.41)
та (число десятич-
ных цифр в дроб-
ной части) 2
round( dp
numeric)
или тип аргумента
integer
Пример
Результат
sign( dp
numeric) или тип аргумента знак аргумента ( sign(-8.4)
-1, 0, +1) -1
sqrt( dp
numeric) или тип аргумента квадратный
рень 1.4142135623731
trunc( dp
numeric) или тип аргумента округление к нулю trunc(42.8) 42
trunc( v numeric, numeric
s int) округление к 0 до trunc(42.4382,
s десятичных зна- 2)
ков 42.43
width_bucket(
int
operand dp, b1
dp,
b2
dp,
count int) возвращает номер width_bucket(
группы, в которую 5.35,
0.024,
попадёт operand в 10.06, 5)
гистограмме с чис-
лом групп count
равного размера, в
диапазоне от b1 до
b2; возвращает 0
или count+1, если
операнд лежит вне
диапазона 3
width_bucket(
int
operand numeric,
b1 numeric, b2
numeric,
count
int) возвращает номер width_bucket(
группы, в которую 5.35,
0.024,
попадёт operand в 10.06, 5)
гистограмме с чис-
лом групп count
равного размера, в
диапазоне от b1 до
b2; возвращает 0
или count+1, если
операнд лежит вне
диапазона 3
width_bucket(
int
operand
anyelement,
thresholds
anyarray) возвращает номер width_bucket(
2
группы, в которую now(),
попадёт
operand
array['yesterday',
(группы
опреде-
'today',
ляются
нижни- 'tomorrow']::timestamptz[])
ми границами, пе-
редаваемыми
в
thresholds); воз-
вращает 0, если
186
ко- sqrt(2.0)Функции и операторы
Функция
Тип результата
Описание
Пример
операнд оказыва-
ется левее нижней
границы; массив
thresholds
дол-
жен быть отсор-
тирован по воз-
растанию, иначе
будут
получены
неожиданные ре-
зультаты
Результат
В Таблице 9.6 перечислены все функции для генерации случайных чисел.
Таблица 9.6. Случайные функции
Функция Тип результата Описание
random() dp случайное число в диапазоне
0.0 <= x < 1.0
setseed( dp) void задаёт отправную точку для по-
следующих вызовов random()
(значение между -1.0 и 1.0,
включая границы)
Характеристики значений, возвращаемых функцией random() зависят от системы. Для примене-
ния в криптографии они непригодны; альтернативы описаны в pgcrypto.
Наконец, в Таблице 9.7 перечислены все имеющиеся тригонометрические функции. Все эти функ-
ции принимают аргументы и возвращают значения типа double precision. У каждой функции
имеются две вариации — одна измеряет углы в радианах, а вторая в градусах.
Таблица 9.7. Тригонометрические функции
Функции (в радианах) Функции (в градусах) Описание
acos( x) acosd( x) арккосинус
asin( x) asind( x) арксинус
atan( x) atand( x) арктангенс
atan2( y,
x)
atan2d( y,
x)
арктангенс y/x
cos( x) cosd( x) косинус
cot( x) cotd( x) котангенс
sin( x) sind( x) синус
tan( x) tand( x) тангенс
Примечание
Также можно работать с углами в градусах, применяя вышеупомянутые функции пре-
образования единиц radians() и degrees(). Однако предпочтительнее использовать
тригонометрические функции с градусами, так как это позволяет избежать ошибок
округления в особых случаях, например, при вычислении sind(30).
9.4. Строковые функции и операторы
В этом разделе описаны функции и операторы для работы с текстовыми строками. Под строками
в данном контексте подразумеваются значения типов character, character varying и text. Если
не отмечено обратное, все нижеперечисленные функции работают со всеми этими типами, хотя с
187Функции и операторы
типом character следует учитывать возможные эффекты автоматического дополнения строк про-
белами. Некоторые из этих функций также поддерживают битовые строки.
В SQL определены несколько строковых функций, в которых аргументы разделяются не запятыми,
а ключевыми словами. Они перечислены в Таблице 9.8. PostgreSQL также предоставляет варианты
этих функций с синтаксисом, обычным для функций (см. Таблицу 9.9).
Примечание
До версии 8.3 в PostgreSQL эти функции также прозрачно принимали значения неко-
торых не строковых типов, неявно приводя эти значения к типу text. Сейчас такие
приведения исключены, так как они часто приводили к неожиданным результатам. Од-
нако оператор конкатенации строк (||) по-прежнему принимает не только строковые
данные, если хотя бы один аргумент имеет строковый тип, как показано в Таблице 9.8.
Во всех остальных случаях для повторения предыдущего поведения потребуется доба-
вить явное преобразование в text.
Таблица 9.8. Строковые функции и операторы языка SQL
Функция
Тип результата
Описание Пример Результат
string || string text Конкатенация
строк 'Post'
'greSQL' || PostgreSQL
string
||
не text
string
или
не
string || string Конкатенация
'Value: ' || 42
строк с одним не
строковым операн-
дом
Value: 42
bit_length(
string) Число бит в строке bit_length(
'jose') 32
char_length(
int
string)
или
character_
length( string) Число символов в char_length(
строке
'jose') 4
lower( string) text Переводит симво- lower('TOM')
лы строки в ниж-
ний регистр tom
octet_length(
string) int Число байт в стро- octet_length(
ке
'jose') 4
int
overlay( string text
placing
string
from
int
[for
int]) Заменяет подстро- overlay(
Thomas
ку
'Txxxxas'
placing
'hom'
from 2 for 4)
position(
substring
string) Положение
ука- position('om' in
занной подстроки 'Thomas')
3
substring(
text
string
[from
int] [for int]) Извлекает
строку
hom
substring(
text
string from шаб-
лон) Извлекает
под- substring(
строку,
соответ- 'Thomas'
ствующую
регу- '...$')
лярному выраже-
нию в стиле POSIX.
Подробно шабло-
int
in
188
под- substring(
'Thomas' from 2
for 3)
mas
fromФункции и операторы
Функция
Тип результата
Описание
Пример
ны описаны в Раз-
деле 9.7. Результат
substring(
text
string from шаб-
лон for спецсим-
вол) Извлекает
под-
строку,
соответ-
ствующую
регу-
лярному выраже-
нию в стиле SQL.
Подробно шабло-
ны описаны в Раз-
деле 9.7. substring(
'Thomas'
from
'%#"o_a#"_' for
'#') oma
trim([leading | text
trailing | both]
[characters] from
string) Удаляет наиболь- trim(both 'xyz'
шую
подстро- from 'yxTomxx')
ку,
содержащую
только
символы
characters
(по
умолчанию
про-
белы),
с
нача-
ла (leading), с
конца (trailing)
или с обеих сто-
рон
(both,
(по
умолчанию)) стро-
ки string Tom
trim([leading | text
trailing | both]
[from] string [,
characters] ) Нестандартный
синтаксис trim() Tom
upper( string) Переводит симво- upper('tom')
лы строки в верх-
ний регистр
text
trim(both
'yxTomxx',
'xyz')
from
TOM
Кроме этого, в PostgreSQL есть и другие функции для работы со строками, перечисленные в Таб-
лице 9.9. Некоторые из них используются в качестве внутренней реализации стандартных строко-
вых функций SQL, приведённых в Таблице 9.8.
Таблица 9.9. Другие строковые функции
Функция Тип результата Описание ascii( string) int Возвращает ASCII- ascii('x')
код первого сим-
вола
аргумента.
Для
UTF8
воз-
вращает код сим-
вола в Unicode.
Для других мно-
гобайтных кодиро-
вок аргумент дол-
жен быть ASCII-
символом. 120
Удаляет наиболь- btrim(
шую
подстроку, 'xyxtrimyyx',
состоящую толь- 'xyz')
ко
из
симво-
лов characters (
по умолчанию про- trim
btrim( string
text
text
[,
characters
text])
189
Пример
РезультатФункции и операторы
Функция Тип результата Описание
Пример
белов), с начала
и с конца строки
string Результат
chr( int) text Возвращает сим- chr(65)
вол с данным ко-
дом. Для UTF8 ар-
гумент восприни-
мается как код
символа Unicode, а
для других кодиро-
вок он должен ука-
зывать на ASCII-
символ. Код 0 (
NULL) не допуска-
ется, так как бай-
ты с нулевым ко-
дом в текстовых
строках сохранить
нельзя. A
concat( str "any" text
[, str "any" [,
...] ]) Соединяет тексто- concat('abcde',
вые
представле- 2, NULL, 22)
ния
всех
аргу-
ментов, игнорируя
NULL. abcde222
concat_ws( sep text
text, str "any"
[, str "any" [,
...] ]) Соединяет все ар- concat_ws(',
гументы,
кроме ', 'abcde', 2,
первого,
через NULL, 22)
разделитель,
иг-
норируя аргумен-
ты NULL. Раздели-
тель указывается в
первом аргументе. abcde,2,22
convert( string bytea
bytea,
src_
encoding
name,
dest_encoding
name) Преобразует стро- convert('text_
ку
string
из in_utf8',
кодировки
src_
'UTF8',
encoding в dest_ 'LATIN1')
encoding .
Пе-
реданная строка
должна быть до-
пустимой для ис-
ходной
кодиров-
ки. Преобразова-
ния могут быть
определены с по-
мощью
CREATE
CONVERSION.
Все
встроенные
пре-
образования пере-
числены в Табли-
це 9.10. строка text_in_
utf8 ,
представ-
ленная в коди-
ровке Latin-1 (ISO
8859-1)
convert_from(
text
string
bytea,
src_encoding
name) Преобразует стро- convert_from(
ку
string
из 'text_in_
кодировки
src_ utf8', 'UTF8')
encoding в коди- строка text_in_
utf8 ,
представ-
ленная в кодиров-
190Функции и операторы
Функция
Тип результата
Описание
Пример
ровку базы дан-
ных. Переданная
строка
должна
быть допустимой
для исходной ко-
дировки. Результат
ке текущей базы
данных
convert_to(
bytea
string
text,
dest_encoding
name) Преобразует стро- convert_to(
ку в кодировку 'некоторый
dest_encoding .
текст', 'UTF8') некоторый текст,
представленный в
кодировке UTF8
decode( string
bytea
text,
format
text) Получает двоич- decode(
ные данные из тек- 'MTIzAAE=',
стового представ- 'base64')
ления в string.
Значения
пара-
метра format те
же, что и для
функции encode. \x3132330001
encode( data
text
bytea,
format
text) Переводит двоич- encode(
ные данные в тек- '123\000\001',
стовое представле- 'base64')
ние в одном из
форматов: base64,
hex, escape. Фор-
мат escape пре-
образует нулевые
байты и байты
с 1 в старшем
бите
в
восьме-
ричные последова-
тельности \nnn и
дублирует обрат-
ную косую черту. MTIzAAE=
format(
text
formatstr
text
[,
formatarg
"any" [, ...] ]) Форматирует аргу- format('Hello
мент в соответ- %s,
%1$s',
ствии
со
стро- 'World')
кой формата. Эта
функция работает
подобно sprintf в
языке C. См. Под-
раздел 9.4.1. Hello
World
initcap( string) text Переводит первую initcap('hi
букву каждого сло- THOMAS')
ва
в
строке
в
верхний
ре-
гистр, а осталь-
ные — в нижний.
Словами считают-
ся последователь-
ности
алфавит-
но-цифровых сим-
волов,
разделён-
ные любыми дру-
гими символами. Hi Thomas
191
World,Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
Возвращает пер- left('abcde',
вые n символов 2)
в строке. Когда
n
меньше
ну-
ля, возвращаются
все символы сле-
ва, кроме послед-
них |n|. ab
int Число символов в length('jose')
строке string 4
length( string
int
bytea,
encoding
name ) Число
символов, length('jose',
которые содержит 'UTF8')
строка string в
заданной кодиров-
ке encoding. Пе-
реданная строка
должна быть допу-
стимой в этой ко-
дировке. 4
lpad( string
text
text, length int
[, fill text]) Дополняет строку lpad('hi',
string слева до 'xy')
длины length сим-
волами fill (по
умолчанию пробе-
лами). Если длина
строки уже боль-
ше заданной, она
обрезается спра-
ва. xyxhi
ltrim( string
text
text
[,
characters
text]) Удаляет наиболь- ltrim(
шую
подстро- 'zzzytest',
ку,
содержащую 'xyz')
только
символы
characters
(по
умолчанию пробе-
лы), с начала стро-
ки string test
md5( string) Вычисляет MD5- md5('abc')
хеш строки string
и возвращает ре-
зультат в 16-рич-
ном виде 90015098
3cd24fb0
d6963f7d
28e17f72
left( str
n int)
text, text
length( string)
text
parse_ident(
text[]
qualified_
identifier
text
[,
strictmode
boolean
DEFAULT
true ] )
5,
Раскладывает пол- parse_ident(
(SomeSchema,
ный
идентифи- '"SomeSchema".someTable')
sometable)
катор,
задава-
емый
парамет-
ром
qualified_
identifier ,
на
массив идентифи-
каторов,
удаляя
кавычки,
обрам-
ляющие
отдель-
ные идентифика-
192Функции и операторы
Функция Тип результата Описание
Пример
торы. По умолча-
нию лишние сим-
волы после по-
следнего иденти-
фикатора вызыва-
ют
ошибку,
но
если
отключить
строгий режим (
передать во вто-
ром
параметре
false), такие сим-
волы игнорируют-
ся. (Это поведе-
ние полезно для
разбора имён та-
ких объектов, как
функции.) Заметь-
те, что эта функ-
ция не усекает
чрезмерно длин-
ные идентифика-
торы.
Если
вы
хотите
получить
усечённые
име-
на, можно приве-
сти результат к
name[]. Результат
pg_client_
encoding() name Возвращает
имя pg_client_
текущей клиент- encoding()
ской кодировки SQL_ASCII
quote_ident(
string text) text Переданная стро- quote_ident(
ка
оформляется 'Foo bar')
для
использова-
ния в качестве
идентификатора в
SQL
-операторе.
При необходимо-
сти идентифика-
тор заключается
в кавычки (на-
пример, если он
содержит симво-
лы, недопустимые
в открытом ви-
де,
или
буквы
в разном реги-
стре). Если пере-
данная строка со-
держит кавычки,
они дублируются.
См. также При-
мер 43.1. "Foo bar"
quote_literal(
string text) text Переданная стро- quote_literal(
ка
оформляется E'O\'Reilly')
для
использова- 'O''Reilly'
193Функции и операторы
Функция Тип результата Описание
Пример
ния в качестве
текстовой
стро-
ки в SQL-опера-
торе. Включённые
символы апостроф
и обратная косая
черта при этом
дублируются. За-
метьте, что quote_
literal
возвра-
щает NULL, когда
на вход ей переда-
ётся строка NULL;
если же нужно по-
лучить представ-
ление и такого ар-
гумента, лучше ис-
пользовать quote_
nullable .
См.
также
При-
мер 43.1. Результат
quote_literal(
value
anyelement) text Переводит данное quote_literal(
значение в тексто- 42.5)
вый вид и заклю-
чает в апостро-
фы как текстовую
строку. Символы
апостроф и обрат-
ная косая черта
при этом дублиру-
ются. '42.5'
quote_nullable(
string text) text Переданная стро- quote_nullable(
ка
оформляется NULL)
для
использова-
ния в качестве
текстовой строки
в SQL-операторе;
при этом для ар-
гумента NULL воз-
вращается
стро-
ка NULL. Симво-
лы апостроф и об-
ратная косая чер-
та
дублируются
должным образом.
См. также При-
мер 43.1. NULL
quote_nullable(
value
anyelement) text Переводит данное quote_nullable(
значение в тек- 42.5)
стовый вид и за-
ключает в апо-
строфы как тек-
стовую строку, при
этом для аргумен-
та NULL возвраща- '42.5'
194Функции и операторы
Функция
Тип результата
Описание
Пример
ется строка NULL.
Символы апостроф
и обратная косая
черта дублируют-
ся должным обра-
зом. Результат
regexp_match(
text[]
string
text,
pattern text [,
flags text]) Возвращает под-
ходящие подстро-
ки, полученные из
первого
вхожде-
ния регулярного
выражения POSIX
в строке string.
Подробности опи-
саны в Подразде-
ле 9.7.3. (bar,beque)
regexp_matches
setof text[]
( string
text,
pattern text [,
flags text]) Возвращает подхо- regexp_matches(
дящие подстроки, 'foobar
полученные в ре- bequebaz',
зультате примене- 'ba.', 'g')
ния регулярного
выражения POSIX
к string. Подроб-
ности описаны в
Подразделе 9.7.3. (bar)
regexp_replace
text
( string
text,
pattern text,
replacement
text [,
flags
text]) Заменяет подстро- regexp_replace(
ки, соответствую- 'Thomas',
'.
щие заданному ре- [mN]a.', 'M')
гулярному выра-
жению в стиле
POSIX. Подробно-
сти описаны в Под-
разделе 9.7.3. ThM
regexp_split_
text[]
to_array(
string
text,
pattern text [,
flags text ]) Разделяет содер- regexp_split_
жимое string на to_array(
элементы, исполь- 'hello
world',
зуя в качестве '\s+')
разделителя регу-
лярное выражение
POSIX. Подробно-
сти описаны в Под-
разделе 9.7.3. (hello,world)
regexp_split_
setof text
to_table(
string
text,
pattern text [,
flags text]) Разделяет содер- regexp_split_
жимое string на to_table(
элементы, исполь- 'hello
world',
зуя в качестве '\s+')
разделителя регу-
лярное выражение
POSIX. Подробно-
сти описаны в Под-
разделе 9.7.3. hello
repeat( string
text
text,
number
int) Повторяет содер- repeat('Pg', 4)
жимое string ука- PgPgPgPg
195
regexp_match(
'foobar
bequebaz',
'(
bar)(beque)')
(baz)
(2 строки)
world
(2 строки)Функции и операторы
Функция
Тип результата
Описание
занное число
number) раз
(
Пример
Результат
replace( string text
text, from text,
to text) Заменяет
все replace(
вхождения
в 'abcdefabcdef',
string подстроки 'cd', 'XX')
from подстрокой
to abXXefabXXef
reverse( str) Возвращает пере- reverse(
вёрнутую строку
'abcde') edcba
Возвращает
по- right('abcde',
следние n симво- 2)
лов в строке. Ко-
гда n меньше ну-
ля, возвращаются
все символы спра-
ва, кроме первых
|n|. de
rpad( string
text
text, length int
[, fill text]) Дополняет строку rpad('hi',
string справа до 'xy')
длины length сим-
волами fill (по
умолчанию пробе-
лами). Если длина
строки уже боль-
ше заданной, она
обрезается. hixyx
rtrim( string
text
text
[,
characters
text]) Удаляет наиболь- rtrim(
шую
подстро- 'testxxzx',
ку,
содержащую 'xyz')
только
символы
characters
(по
умолчанию пробе-
лы), с конца стро-
ки string test
split_part(
text
string
text,
delimiter text,
field int) Разделяет строку split_part(
string по симво- 'abc~@~def
лу delimiter и воз- ~@~ghi', '~@~',
вращает элемент 2)
по заданному но-
меру (считая с 1) def
strpos( string,
substring) Возвращает
по- strpos('high',
ложение указан- 'ig')
ной подстроки (
подобно position(
substring
in
string), но с дру-
гим порядком ар-
гументов) 2
Извлекает
под- substr(
строку
(подоб- 'alphabet',
но
substring( 2) ph
right( str
n int)
text
text, text
int
substr( string, text
from
[,
count])
196
5,
3,Функции и операторы
Функция
Тип результата
Описание
Пример
string from from
for count)) Результат
starts_with(
bool
string, prefix) Возвращает true, starts_with(
если
строка 'alphabet',
string начинает- 'alph')
ся с подстроки
prefix. t
to_ascii(
text
string text [,
encoding text]) Преобразует
to_ascii(
string в ASCII 'Karel')
из
кодировки
encoding (поддер-
живаются
толь-
ко LATIN1, LATIN2,
LATIN9 и WIN1250) Karel
to_hex( number
int или bigint) Преобразует чис- to_hex(
ло number в 16-рич- 2147483647)
ный вид 7fffffff
Заменяет симво- translate(
лы в string, най- '12345', '143',
денные в наборе 'ax')
from, на соответ-
ствующие симво-
лы в множестве to.
Если строка from
длиннее to, най-
денные в исход-
ной строке лиш-
ние символы from
удаляются. a2x5
text
translate(
text
string
text,
from text, to
text)
Функции concat, concat_ws и format принимают переменное число аргументов, так что им для
объединения или форматирования можно передавать значения в виде массива, помеченного клю-
чевым словом VARIADIC (см. Подраздел 38.5.5). Элементы такого массива обрабатываются, как ес-
ли бы они были обычными аргументами функции. Если вместо массива в соответствующем аргу-
менте передаётся NULL, функции concat и concat_ws возвращают NULL, а format воспринимает
NULL как массив нулевого размера.
См. также агрегатную функцию string_agg в Разделе 9.20.
Таблица 9.10. Встроенные преобразования
Имя преобразования
a
Исходная кодировка Целевая кодировка
ascii_to_mic SQL_ASCII MULE_INTERNAL
ascii_to_utf8 SQL_ASCII UTF8
big5_to_euc_tw BIG5 EUC_TW
big5_to_mic BIG5 MULE_INTERNAL
big5_to_utf8 BIG5 UTF8
euc_cn_to_mic EUC_CN MULE_INTERNAL
euc_cn_to_utf8 EUC_CN UTF8
euc_jp_to_mic EUC_JP MULE_INTERNAL
euc_jp_to_sjis EUC_JP SJIS
197Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
euc_jp_to_utf8 EUC_JP UTF8
euc_kr_to_mic EUC_KR MULE_INTERNAL
euc_kr_to_utf8 EUC_KR UTF8
euc_tw_to_big5 EUC_TW BIG5
euc_tw_to_mic EUC_TW MULE_INTERNAL
euc_tw_to_utf8 EUC_TW UTF8
gb18030_to_utf8 GB18030 UTF8
gbk_to_utf8 GBK UTF8
iso_8859_10_to_utf8 LATIN6 UTF8
iso_8859_13_to_utf8 LATIN7 UTF8
iso_8859_14_to_utf8 LATIN8 UTF8
iso_8859_15_to_utf8 LATIN9 UTF8
iso_8859_16_to_utf8 LATIN10 UTF8
iso_8859_1_to_mic LATIN1 MULE_INTERNAL
iso_8859_1_to_utf8 LATIN1 UTF8
iso_8859_2_to_mic LATIN2 MULE_INTERNAL
iso_8859_2_to_utf8 LATIN2 UTF8
iso_8859_2_to_windows_
1250 LATIN2 WIN1250
iso_8859_3_to_mic LATIN3 MULE_INTERNAL
iso_8859_3_to_utf8 LATIN3 UTF8
iso_8859_4_to_mic LATIN4 MULE_INTERNAL
iso_8859_4_to_utf8 LATIN4 UTF8
iso_8859_5_to_koi8_r ISO_8859_5 KOI8R
iso_8859_5_to_mic ISO_8859_5 MULE_INTERNAL
iso_8859_5_to_utf8 ISO_8859_5 UTF8
iso_8859_5_to_windows_
1251 ISO_8859_5 WIN1251
iso_8859_5_to_windows_
866 ISO_8859_5 WIN866
iso_8859_6_to_utf8 ISO_8859_6 UTF8
iso_8859_7_to_utf8 ISO_8859_7 UTF8
iso_8859_8_to_utf8 ISO_8859_8 UTF8
iso_8859_9_to_utf8 LATIN5 UTF8
johab_to_utf8 JOHAB UTF8
koi8_r_to_iso_8859_5 KOI8R ISO_8859_5
koi8_r_to_mic KOI8R MULE_INTERNAL
koi8_r_to_utf8 KOI8R UTF8
koi8_r_to_windows_1251 KOI8R WIN1251
koi8_r_to_windows_866 KOI8R WIN866
koi8_u_to_utf8 KOI8U UTF8
198Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
mic_to_ascii MULE_INTERNAL SQL_ASCII
mic_to_big5 MULE_INTERNAL BIG5
mic_to_euc_cn MULE_INTERNAL EUC_CN
mic_to_euc_jp MULE_INTERNAL EUC_JP
mic_to_euc_kr MULE_INTERNAL EUC_KR
mic_to_euc_tw MULE_INTERNAL EUC_TW
mic_to_iso_8859_1 MULE_INTERNAL LATIN1
mic_to_iso_8859_2 MULE_INTERNAL LATIN2
mic_to_iso_8859_3 MULE_INTERNAL LATIN3
mic_to_iso_8859_4 MULE_INTERNAL LATIN4
mic_to_iso_8859_5 MULE_INTERNAL ISO_8859_5
mic_to_koi8_r MULE_INTERNAL KOI8R
mic_to_sjis MULE_INTERNAL SJIS
mic_to_windows_1250 MULE_INTERNAL WIN1250
mic_to_windows_1251 MULE_INTERNAL WIN1251
mic_to_windows_866 MULE_INTERNAL WIN866
sjis_to_euc_jp SJIS EUC_JP
sjis_to_mic SJIS MULE_INTERNAL
sjis_to_utf8 SJIS UTF8
tcvn_to_utf8 WIN1258 UTF8
uhc_to_utf8 UHC UTF8
utf8_to_ascii UTF8 SQL_ASCII
utf8_to_big5 UTF8 BIG5
utf8_to_euc_cn UTF8 EUC_CN
utf8_to_euc_jp UTF8 EUC_JP
utf8_to_euc_kr UTF8 EUC_KR
utf8_to_euc_tw UTF8 EUC_TW
utf8_to_gb18030 UTF8 GB18030
utf8_to_gbk UTF8 GBK
utf8_to_iso_8859_1 UTF8 LATIN1
utf8_to_iso_8859_10 UTF8 LATIN6
utf8_to_iso_8859_13 UTF8 LATIN7
utf8_to_iso_8859_14 UTF8 LATIN8
utf8_to_iso_8859_15 UTF8 LATIN9
utf8_to_iso_8859_16 UTF8 LATIN10
utf8_to_iso_8859_2 UTF8 LATIN2
utf8_to_iso_8859_3 UTF8 LATIN3
utf8_to_iso_8859_4 UTF8 LATIN4
utf8_to_iso_8859_5 UTF8 ISO_8859_5
utf8_to_iso_8859_6 UTF8 ISO_8859_6
199Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
utf8_to_iso_8859_7 UTF8 ISO_8859_7
utf8_to_iso_8859_8 UTF8 ISO_8859_8
utf8_to_iso_8859_9 UTF8 LATIN5
utf8_to_johab UTF8 JOHAB
utf8_to_koi8_r UTF8 KOI8R
utf8_to_koi8_u UTF8 KOI8U
utf8_to_sjis UTF8 SJIS
utf8_to_tcvn UTF8 WIN1258
utf8_to_uhc UTF8 UHC
utf8_to_windows_1250 UTF8 WIN1250
utf8_to_windows_1251 UTF8 WIN1251
utf8_to_windows_1252 UTF8 WIN1252
utf8_to_windows_1253 UTF8 WIN1253
utf8_to_windows_1254 UTF8 WIN1254
utf8_to_windows_1255 UTF8 WIN1255
utf8_to_windows_1256 UTF8 WIN1256
utf8_to_windows_1257 UTF8 WIN1257
utf8_to_windows_866 UTF8 WIN866
utf8_to_windows_874 UTF8 WIN874
windows_1250_to_iso_
8859_2 WIN1250 LATIN2
windows_1250_to_mic WIN1250 MULE_INTERNAL
windows_1250_to_utf8 WIN1250 UTF8
windows_1251_to_iso_
8859_5 WIN1251 ISO_8859_5
windows_1251_to_koi8_r WIN1251 KOI8R
windows_1251_to_mic WIN1251 MULE_INTERNAL
windows_1251_to_utf8 WIN1251 UTF8
windows_1251_to_windows_
866 WIN1251 WIN866
windows_1252_to_utf8 WIN1252 UTF8
windows_1256_to_utf8 WIN1256 UTF8
windows_866_to_iso_8859_
5 WIN866 ISO_8859_5
windows_866_to_koi8_r WIN866 KOI8R
windows_866_to_mic WIN866 MULE_INTERNAL
windows_866_to_utf8 WIN866 UTF8
windows_866_to_windows_
1251 WIN866 WIN
windows_874_to_utf8 WIN874 UTF8
euc_jis_2004_to_utf8 EUC_JIS_2004 UTF8
200Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
utf8_to_euc_jis_2004 UTF8 EUC_JIS_2004
shift_jis_2004_to_utf8 SHIFT_JIS_2004 UTF8
utf8_to_shift_jis_2004 UTF8 SHIFT_JIS_2004
euc_jis_2004_to_shift_
jis_2004 EUC_JIS_2004 SHIFT_JIS_2004
shift_jis_2004_to_euc_
jis_2004 SHIFT_JIS_2004 EUC_JIS_2004
a
Имена преобразований следуют стандартной схеме именования. К официальному названию исходной кодировки, в котором все не алфавитно-цифровые
символы заменяются подчёркиваниями, добавляется _to_, а за ним аналогично подготовленное имя целевой кодировки. Таким образом, имена кодировок
могут не совпадать буквально с общепринятыми названиями.
9.4.1. format
Функция format выдаёт текст, отформатированный в соответствии со строкой формата, подобно
функции sprintf в C.
format(formatstr text [, formatarg "any" [, ...] ])
formatstr — строка, определяющая, как будет форматироваться результат. Обычный текст в стро-
ке формата непосредственно копируется в результат, за исключением спецификаторов форма-
та. Спецификаторы формата представляют собой местозаполнители, определяющие, как долж-
ны форматироваться и выводиться в результате аргументы функции. Каждый аргумент formatarg
преобразуется в текст по правилам выводам своего типа данных, а затем форматируется и встав-
ляется в результирующую строку согласно спецификаторам формата.
Спецификаторы формата предваряются символом % и имеют форму
%[позиция][флаги][ширина]тип
Здесь:
позиция (необязателен)
Строка вида n$, где n — индекс выводимого аргумента. Индекс, равный 1, выбирает первый
аргумент после formatstr. Если позиция опускается, по умолчанию используется следующий
аргумент по порядку.
флаги (необязателен)
Дополнительные параметры, управляющие форматированием данного спецификатора. В на-
стоящее время поддерживается только знак минус (-), который выравнивает результата спе-
цификатора по левому краю. Он работает, только если также определена ширина.
ширина (необязателен)
Задаёт минимальное число символов, которое будет занимать результат данного спецификато-
ра. Выводимое значение выравнивается по правой или левой стороне (в зависимости от флага
-) с дополнением необходимым числом пробелов. Если ширина слишком мала, она просто иг-
норируется, т. е. результат не усекается. Ширину можно обозначить положительным целым,
звёздочкой (*), тогда ширина будет получена из следующего аргумента функции, или строкой
вида *n$, тогда ширина будет задаваться в n-ом аргументе функции.
Если ширина передаётся в аргументе функции, этот аргумент выбирается до аргумента, ис-
пользуемого для спецификатора. Если аргумент ширины отрицательный, результат выравни-
вается по левой стороне (как если бы был указан флаг -) в рамках поля длины abs(ширина).
тип (обязателен)
Тип спецификатора определяет преобразование соответствующего выводимого значения. Под-
держиваются следующие типы:
201Функции и операторы
• s форматирует значение аргумента как простую строку. Значение NULL представляется
пустой строкой.
• I обрабатывает значение аргумента как SQL-идентификатор, при необходимости заключая
его в кавычки. Значение NULL для такого преобразования считается ошибочным (так же,
как и для quote_ident).
• L заключает значение аргумента в апострофы, как строку SQL. Значение NULL выводится
буквально, как NULL, без кавычек (так же, как и с quote_nullable).
В дополнение к спецификаторам, описанным выше, можно использовать спецпоследовательность
%%, которая просто выведет символ %.
Несколько примеров простых преобразований формата:
SELECT format('Hello %s', 'World');
Результат: Hello World
SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
Результат: Testing one, two, three, %
SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
Результат: INSERT INTO "Foo bar" VALUES('O''Reilly')
SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
Результат: INSERT INTO locations VALUES('C:\Program Files')
Следующие примеры иллюстрируют использование поля ширина и флага -:
SELECT format('|%10s|', 'foo');
Результат: |
foo|
SELECT format('|%-10s|', 'foo');
Результат: |foo
|
SELECT format('|%*s|', 10, 'foo');
Результат: |
foo|
SELECT format('|%*s|', -10, 'foo');
Результат: |foo
|
SELECT format('|%-*s|', 10, 'foo');
Результат: |foo
|
SELECT format('|%-*s|', -10, 'foo');
Результат: |foo
|
Эти примеры показывают применение полей позиция:
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
Результат: Testing three, two, one
SELECT format('|%*2$s|', 'foo', 10, 'bar');
Результат: |
bar|
SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
Результат: |
foo|
В отличие от стандартной функции C sprintf, функция format в PostgreSQL позволяет комбиниро-
вать в одной строке спецификаторы с полями позиция и без них. Спецификатор формата без поля
202Функции и операторы
позиция всегда использует следующий аргумент после последнего выбранного. Кроме того, функ-
ция format не требует, чтобы в строке формата использовались все аргументы функции. Пример
этого поведения:
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
Результат: Testing three, two, three
Спецификаторы формата %I и %L особенно полезны для безопасного составления динамических
операторов SQL. См. Пример 43.1.
9.5. Функции и операторы двоичных строк
В этом разделе описываются функции и операторы для работы с данными типа bytea.
В SQL определены несколько строковых функций, в которых аргументы разделяются не запятыми,
а ключевыми словами. Подробнее это описано в Таблице 9.11. PostgreSQL также предоставляет
варианты этих функций с синтаксисом, обычным для функций (см. Таблицу 9.12).
Примечание
В примерах, приведённых на этой странице, подразумевается, что параметр сервера
bytea_output равен escape (выбран традиционный формат PostgreSQL).
Таблица 9.11. SQL-функции и операторы для работы с двоичными строками
Функция
Тип результата
Описание Пример
string || string bytea Конкатенация
строк '\\Post'::bytea \\Post'gres\000
||
'\047gres
\000'::bytea
octet_length(
string) Число байт в дво- octet_length(
ичной строке
'jo
\000se'::bytea)
int
Результат
5
overlay( string bytea
placing
string
from
int
[for
int]) Заменяет подстро- overlay(
T\\002\\003mas
ку
'Th
\000omas'::bytea
placing
'\002\003'::bytea
from 2 for 3)
position(
substring
string) Положение
ука- position(
3
занной подстроки '\000om'::bytea
in
'Th
\000omas'::bytea)
int
in
substring(
bytea
string
[from
int] [for int]) Извлекает
строку
trim([both]
bytes
string) Удаляет наиболь-
шую строку, со-
держащую только
байты, заданные в
параметре bytes, с
начала и с конца
строки string
bytea
from
203
под- substring(
h\000o
'Th
\000omas'::bytea
from 2 for 3)
trim(
Tom
'\000\001'::bytea
from
'\000Tom
\001'::bytea)Функции и операторы
В PostgreSQL есть и другие функции для работы с двоичными строками, перечисленные в Табли-
це 9.12. Некоторые из них используются в качестве внутренней реализации стандартных функций
SQL, приведённых в Таблице 9.11.
Таблица 9.12. Другие функции для работы с двоичными строками
Функция
Тип результата
Описание
Пример
Результат
btrim( string
bytea
bytea,
bytes
bytea) Удаляет наиболь- btrim(
trim
шую строку, со- '\000trim
держащую только \001'::bytea,
байты, заданные в '\000\001'::bytea)
параметре bytes, с
начала и с конца
строки string
decode( string
bytea
text,
format
text) Получает двоич- decode(
ные данные из тек- '123\000456',
стового представ- 'escape')
ления в string.
Значения
пара-
метра format те
же, что и для
функции encode.
encode( data
text
bytea,
format
text) Переводит двоич- encode(
123\000456
ные данные в тек- '123\000456'::bytea,
стовое представле- 'escape')
ние в одном из
форматов: base64,
hex, escape. Фор-
мат escape пре-
образует нулевые
байты и байты
с 1 в старшем
бите
в
восьме-
ричные последова-
тельности \nnn и
дублирует обрат-
ную косую черту.
get_bit(
string, Извлекает бит из get_bit(
1
строки
'Th
\000omas'::bytea,
45)
int
offset)
123\000456
get_byte(
int
string, offset) Извлекает байт из get_byte(
109
строки
'Th
\000omas'::bytea,
4)
length( string) int Длина
строки
md5( string) text Вычисляет MD5- md5(
8ab2d3c9689aaf18
хеш строки string 'Th
b4958c334c82d8b1
и возвращает ре- \000omas'::bytea)
зультат в 16-рич-
ном виде
204
двоичной length(
'jo
\000se'::bytea)
5Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
set_bit(
bytea
string, offset,
newvalue) Устанавливает
значение бита
строке set_byte(
bytea
string, offset,
newvalue) Устанавливает
set_byte(
Th\000o@as
значение байта в 'Th
строке
\000omas'::bytea,
4, 64)
sha224( bytea) bytea Хеш SHA-224 sha224('abc') \x23097d223405d8228642
55b32aadbce4bda0b3f
7e36c9da7
sha256( bytea) bytea Хеш SHA-256 sha256('abc') \xba7816bf8f01cfea4141
b00361a396177a9
cb410ff61f20015ad
sha384( bytea) bytea Хеш SHA-384 sha384('abc') \xcb00753f45a35e8bb5a0
272c32ab0eded16
31a8b605a43ff5bed
8086072ba1e7cc2358baec
sha512( bytea) bytea Хеш SHA-512 sha512('abc') \xddaf35a193617abacc41
12e6fa4e89a97ea
20a9eeee64b55d39a
2192992a274fc1a836ba3c
454d4423643ce80e2a9ac9
set_bit(
Th\000omAs
в 'Th
\000omas'::bytea,
45, 0)
Для функций get_byte и set_byte байты нумеруется с 0. Функции get_bit и set_bit нумеруют
биты справа налево; например, бит 0 будет меньшим значащим битом первого байта, а бит 15 —
большим значащим битом второго байта.
Заметьте, что по историческим причинам функция md5 возвращает значение в шестнадцатерич-
ном виде в типе text, тогда как функции SHA-2 возвращают тип bytea. Используйте функции
encode и decode для преобразования значений из одного представления в другое. Например, вы-
звав encode(sha256('abc'), 'hex'), вы получите значение в шестнадцатеричном виде в строке.
См. также агрегатную функцию string_agg в Разделе 9.20 и функции для работы с большими объ-
ектами в Разделе 35.4.
9.6. Функции и операторы для работы с битовыми
строками
В этом разделе описываются функции и операторы, предназначенные для работы с битовыми стро-
ками, то есть с данными типов bit и bit varying. Помимо обычных операторов сравнения, с таки-
ми данными можно использовать операторы, перечисленные в Таблице 9.13. Заметьте, что опера-
торы &, | и # работают только с двоичными строками одинаковой длины. Операторы побитового
сдвига сохраняют длины исходных строк, как показано в примерах.
Таблица 9.13. Операторы для работы с битовыми строками
Оператор Описание Пример Результат
|| конкатенация B'10001' || B'011' 10001011
& битовый AND B'10001' & B'01101' 00001
| битовый OR B'10001' | B'01101' 11101
# битовый XOR B'10001' # B'01101' 11100
205Функции и операторы
Оператор Описание Пример Результат
~ битовый NOT ~ B'10001' 01110
<< битовый сдвиг влево B'10001' << 3 01000
>> битовый сдвиг вправо B'10001' >> 2 00100
Следующие функции языка SQL работают как с символьными, так и с битовыми строками: length,
bit_length, octet_length, position, substring, overlay.
С битовыми и двоичными строками работают функции get_bit и set_bit. При работе с битовыми
строками эти функции нумеруют биты слева направо и самый левый бит считается нулевым.
Кроме того, целые значения можно преобразовать в тип bit и обратно. Например:
44::bit(10)
44::bit(3)
cast(-44 as bit(12))
'1110'::bit(4)::integer
0000101100
100
111111010100
14
Заметьте, что приведение к типу «bit» без длины будет означать приведение к bit(1), и в резуль-
тате будет получен только один менее значащий бит числа.
Примечание
Приведение целого числа к типу bit(n) копирует правые n бит числа. Если же целое
преобразуется в битовую строку большей длины, чем требуется для этого числа, она
дополняется слева битами знака числа.
9.7. Поиск по шаблону
PostgreSQL предлагает три разных способа поиска текста по шаблону: традиционный оператор
LIKE языка SQL, более современный SIMILAR TO (добавленный в SQL:1999) и регулярные выраже-
ния в стиле POSIX. Помимо простых операторов, отвечающих на вопрос «соответствует ли строка
этому шаблону?», в PostgreSQL есть функции для извлечения или замены соответствующих под-
строк и для разделения строки по заданному шаблону.
Подсказка
Если этих встроенных возможностей оказывается недостаточно, вы можете написать
собственные функции на языке Perl или Tcl.
Внимание
Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, регулярные
выражения бывают и настолько сложными, что их обработка может занять приличное
время и объём памяти. Поэтому опасайтесь шаблонов регулярных выражений, посту-
пающих из недоверенных источников. Если у вас нет другого выхода, рекомендуется
ввести тайм-аут для операторов.
Поиск с шаблонами SIMILAR TO несёт те же риски безопасности, так как конструкция
SIMILAR TO предоставляет во многом те же возможности, что и регулярные выражения
в стиле POSIX.
Поиск с LIKE гораздо проще, чем два другие варианта, поэтому его безопаснее исполь-
зовать с недоверенными источниками шаблонов поиска.
206Функции и операторы
9.7.1. LIKE
строка LIKE шаблон [ESCAPE спецсимвол]
строка NOT LIKE шаблон [ESCAPE спецсимвол]
Выражение LIKE возвращает true, если строка соответствует заданному шаблону. (Как можно было
ожидать, выражение NOT LIKE возвращает false, когда LIKE возвращает true, и наоборот. Этому
выражению равносильно выражение NOT (строка LIKE шаблон).)
Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет в точно-
сти строку и LIKE работает как оператор сравнения. Подчёркивание (_) в шаблоне подменяет (вме-
сто него подходит) любой символ; а знак процента (%) подменяет любую (в том числе и пустую)
последовательность символов.
Несколько примеров:
'abc'
'abc'
'abc'
'abc'
LIKE
LIKE
LIKE
LIKE
'abc'
'a%'
'_b_'
'c'
true
true
true
false
При проверке по шаблону LIKE всегда рассматривается вся строка. Поэтому, если нужно найти по-
следовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться
знаками процента.
Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответ-
ствующим символом в шаблоне нужно добавить спецсимвол. По умолчанию в качестве спецсимво-
ла выбрана обратная косая черта, но с помощью предложения ESCAPE можно выбрать и другой.
Чтобы включить спецсимвол в шаблон поиска, продублируйте его.
Примечание
Если параметр standard_conforming_strings выключен, каждый символ обратной косой
черты, записываемый в текстовой константе, нужно дублировать. Подробнее это опи-
сано в Подразделе 4.1.2.1.
Также можно отказаться от спецсимвола, написав ESCAPE ''. При этом механизм спецпоследова-
тельностей фактически отключается и использовать знаки процента и подчёркивания буквально
в шаблоне нельзя.
Вместо LIKE можно использовать ключевое слово ILIKE, чтобы поиск был регистр-независимым
с учётом текущей языковой среды. Этот оператор не описан в стандарте SQL; это расширение
PostgreSQL.
Кроме того, в PostgreSQL есть оператор ~~, равнозначный LIKE, и ~~*, соответствующий ILIKE.
Есть также два оператора !~~ и !~~*, представляющие NOT LIKE и NOT ILIKE, соответственно. Все
эти операторы можно отнести к особенностям PostgreSQL.
Также существует оператор проверки префикса ^@ и соответствующая функция starts_with, ко-
торые покрывают случаи, когда нужно выполнить поиск только по началу строки.
9.7.2. Регулярные выражения SIMILAR TO
строка SIMILAR TO шаблон [ESCAPE спецсимвол]
строка NOT SIMILAR TO шаблон [ESCAPE спецсимвол]
Оператор SIMILAR TO возвращает true или false в зависимости от того, соответствует ли данная
строка шаблону или нет. Он работает подобно оператору LIKE, только его шаблоны соответствуют
определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют
собой любопытный гибрид синтаксиса LIKE с синтаксисом обычных регулярных выражений.
207Функции и операторы
Как и LIKE, условие SIMILAR TO истинно, только если шаблон соответствует всей строке; это отли-
чается от условий с регулярными выражениями, в которых шаблон может соответствовать любой
части строки. Также подобно LIKE, SIMILAR TO воспринимает символы _ и % как знаки подстанов-
ки, подменяющие любой один символ или любую подстроку, соответственно (в регулярных выра-
жениях POSIX им аналогичны символы . и .*).
Помимо средств описания шаблонов, позаимствованных от LIKE, SIMILAR TO поддерживает следу-
ющие метасимволы, унаследованные от регулярных выражений POSIX:
• | означает выбор (одного из двух вариантов).
• * означает повторение предыдущего элемента 0 и более раз.
• + означает повторение предыдущего элемента 1 и более раз.
• ? означает вхождение предыдущего элемента 0 или 1 раз.
• (m) означает повторяет предыдущего элемента ровно m раз.
• (m,) означает повторение предыдущего элемента m или более раз.
• (m,n) означает повторение предыдущего элемента не менее чем m и не более чем n раз.
• Скобки () объединяют несколько элементов в одну логическую группу.
• Квадратные скобки [...] обозначают класс символов так же, как и в регулярных выражениях
POSIX.
Обратите внимание, точка (.) не является метасимволом для оператора SIMILAR TO.
Как и с LIKE, обратная косая черта отменяет специальное значение любого из этих метасимволов,
а предложение ESCAPE позволяет выбрать другой спецсимвол.
Несколько примеров:
'abc'
'abc'
'abc'
'abc'
SIMILAR
SIMILAR
SIMILAR
SIMILAR
TO
TO
TO
TO
'abc'
'a'
'%(b|d)%'
'(b|c)%'
true
false
true
false
Функция substring с тремя параметрами, substring(строка from шаблон for спецсимвол) из-
влекает подстроку, соответствующую шаблону регулярного выражения SQL. Как и с SIMILAR TO,
указанному шаблону должна соответствовать вся строка, в противном случае функция не найдёт
ничего и вернёт NULL. Для обозначения части шаблона, которая должна быть возвращена в слу-
чае успеха, шаблон должен содержать два спецсимвола и кавычки (") после каждого. Эта функция
возвращает часть шаблона между двумя такими маркерами.
Несколько примеров с маркерами #", выделяющими возвращаемую строку:
substring('foobar' from '%#"o_b#"%' for '#')
substring('foobar' from '#"o_b#"%' for '#')
oob
NULL
9.7.3. Регулярные выражения POSIX
В Таблице 9.14 перечислены все существующие операторы для проверки строк регулярными вы-
ражениями POSIX.
Таблица 9.14. Операторы регулярных выражений
Оператор Описание
Пример
~ Проверяет соответствие регу- 'thomas' ~ '.*thomas.*'
лярному выражению с учётом
регистра
~* Проверяет соответствие регу- 'thomas' ~* '.*Thomas.*'
лярному выражению без учёта
регистра
208Функции и операторы
Оператор Описание
Пример
!~ Проверяет несоответствие регу- 'thomas' !~ '.*Thomas.*'
лярному выражению с учётом
регистра
!~* Проверяет несоответствие регу- 'thomas' !~* '.*vadim.*'
лярному выражению без учёта
регистра
Регулярные выражения POSIX предоставляют более мощные средства поиска по шаблонам, чем
операторы LIKE и SIMILAR TO. Во многих командах Unix, таких как egrep, sed и awk используется
язык шаблонов, похожий на описанный здесь.
Регулярное выражение — это последовательность символов, представляющая собой краткое опре-
деление набора строк (регулярное множество). Строка считается соответствующей регулярному
выражению, если она является членом регулярного множества, описываемого регулярным выра-
жением. Как и для LIKE, символы шаблона непосредственно соответствуют символам строки, за
исключением специальных символов языка регулярных выражений. При этом спецсимволы регу-
лярных выражений отличается от спецсимволов LIKE. В отличие от шаблонов LIKE, регулярное
выражение может совпадать с любой частью строки, если только оно не привязано явно к началу
и/или концу строки.
Несколько примеров:
'abc'
'abc'
'abc'
'abc'
~
~
~
~
'abc'
'^a'
'(b|d)'
'^(b|c)'
true
true
true
false
Более подробно язык шаблонов в стиле POSIX описан ниже.
Функция substring с двумя параметрами, substring(строка from шаблон), извлекает подстроку,
соответствующую шаблону регулярного выражения POSIX. Она возвращает фрагмент текста, под-
ходящий шаблону, если таковой находится в строке, либо NULL в противном случае. Но если шаб-
лон содержит скобки, она возвращает первое подвыражение, заключённое в скобки (то, которое
начинается с самой первой открывающей скобки). Если вы хотите использовать скобки, но не в
таком особом режиме, можно просто заключить в них всё выражение. Если же вам нужно вклю-
чить скобки в шаблон до подвыражения, которое вы хотите извлечь, это можно сделать, используя
группы без захвата, которые будут описаны ниже.
Несколько примеров:
substring('foobar' from 'o.b')
substring('foobar' from 'o(.)b')
oob
o
Функция regexp_replace подставляет другой текст вместо подстрок, соответствующих шаблонам
регулярных выражений POSIX. Она имеет синтаксис regexp_replace(исходная_строка, шаблон, за-
мена [, флаги]). Если исходная_строка не содержит фрагмента, подходящего под шаблон, она воз-
вращается неизменной. Если же соответствие находится, возвращается исходная_строка, в кото-
рой вместо соответствующего фрагмента подставляется замена. Строка замена может содержать
\n, где n — число от 1 до 9, указывающее на исходный фрагмент, соответствующий n-ому подвы-
ражению в скобках, и может содержать обозначение \&, указывающее, что будет вставлен фраг-
мент, соответствующий всему шаблону. Если же в текст замены нужно включить обратную косую
черту буквально, следует написать \\. В необязательном параметре флаги передаётся текстовая
строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Флаг
i включает поиск без учёта регистра, а флаг g указывает, что заменяться должны все подходящие
подстроки, а не только первая из них. Допустимые флаги (кроме g) описаны в Таблице 9.22.
Несколько примеров:
209Функции и операторы
regexp_replace('foobarbaz', 'b..', 'X')
fooXbaz
regexp_replace('foobarbaz', 'b..', 'X', 'g')
fooXX
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
fooXarYXazY
Функция regexp_match возвращает текстовый массив из всех подходящих подстрок, полученных
из первого вхождения шаблона регулярного выражения POSIX в строке. Она имеет синтаксис
regexp_match(строка, шаблон [, флаги]). Если вхождение не находится, результатом будет NULL. Ес-
ли вхождение находится и шаблон не содержит подвыражений в скобках, результатом будет тек-
стовый массив с одним элементом, содержащим подстроку, соответствующую всему шаблону. Если
вхождение находится и шаблон содержит подвыражения в скобках, результатом будет текстовый
массив, в котором n-ым элементом будет n-ое заключённое в скобки подвыражение шаблона (не
считая «незахватывающих» скобок; подробнее см. ниже). В параметре флаги передаётся необяза-
тельная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведе-
ние функции. Допустимые флаги описаны в Таблице 9.22.
Некоторые примеры:
SELECT regexp_match('foobarbequebaz', 'bar.*que');
regexp_match
--------------
(barbeque)
(1 row)
SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
regexp_match
--------------
(bar,beque)
(1 row)
В общем случае просто получить всю найденную подстроку или NULL, если нет соответствия, можно
примерно так:
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
regexp_match
--------------
barbeque
(1 row)
Функция regexp_matches возвращает набор текстовых массивов со всеми подходящими подстро-
ками, полученными в результате применения регулярного выражения POSIX к строке. Она имеет
тот же синтаксис, что и regexp_match. Эта функция не возвращает никаких строк, если вхождений
нет; возвращает одну строку, если найдено одно вхождение и не передан флаг g, или N строк, если
найдено N вхождений и передан флаг g. Каждая возвращаемая строка представляет собой тексто-
вый массив, содержащий всю найденную подстроку или подстроки, соответствующие заключён-
ным в скобки подвыражениям шаблона, как и описанный выше результат regexp_match. Функция
regexp_matches принимает все флаги, показанные в Таблице 9.22, а также флаг g, указывающий
ей выдать все вхождения, а не только первое.
Несколько примеров:
SELECT regexp_matches('foo', 'not there');
regexp_matches
----------------
(0 rows)
SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
regexp_matches
210Функции и операторы
----------------
(bar,beque)
(bazil,barf)
(2 rows)
Подсказка
В большинстве случаев regexp_matches() должна применяться с флагом g, так как ес-
ли вас интересует только первое вхождение, проще и эффективнее использовать функ-
цию regexp_match(). Однако regexp_match() существует только в PostgreSQL версии
10 и выше. В старых версиях обычно помещали вызов regexp_matches() во вложенный
SELECT, например, так:
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
В результате выдаётся текстовый массив, если вхождение найдено, или NULL в против-
ном случае, так же как с regexp_match(). Без вложенного SELECT этот запрос не воз-
вращает никакие строки, если соответствие не находится, а это обычно не то, что нуж-
но.
Функция regexp_split_to_table разделяет строку, используя в качестве разделителя шаблон ре-
гулярного выражения POSIX. Она имеет синтаксис regexp_split_to_table(строка, шаблон [, фла-
ги]). Если шаблон не находится в переданной строке, возвращается вся строка целиком. Если на-
ходится минимум одно вхождение, для каждого такого вхождения возвращается текст от конца
предыдущего вхождения (или начала строки) до начала вхождения. После последнего найденного
вхождения возвращается фрагмент от его конца до конца строки. В необязательном параметре
флаги передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняю-
щих поведение функции. Флаги, которые поддерживает regexp_split_to_table, описаны в Табли-
це 9.22.
Функция regexp_split_to_array ведёт себя подобно regexp_split_to_table, за исключением то-
го, что regexp_split_to_array возвращает результат в массиве элементов типа text. Она имеет
синтаксис regexp_split_to_array(строка, шаблон [, флаги]). Параметры у этой функции те же, что
и у regexp_split_to_table.
Несколько примеров:
SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog',
'\s+') AS foo;
foo
-------
the
quick
brown
fox
jumps
over
the
lazy
dog
(9 rows)
SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
regexp_split_to_array
-----------------------------------------------
(the,quick,brown,fox,jumps,over,the,lazy,dog)
(1 row)
211Функции и операторы
SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
foo
-----
t
h
e
q
u
i
c
k
b
r
o
w
n
f
o
x
(16 rows)
Как показывает последний пример, функции разделения по регулярным выражениям игнорируют
вхождения нулевой длины, идущие в начале и в конце строки, а также непосредственно за преды-
дущим вхождением. Это поведение противоречит строгому определению поиска по регулярным
выражениям, который реализуют функции regexp_match и regexp_matches, но обычно более удоб-
но на практике. Подобное поведение наблюдается и в других программных средах, например в Perl.
9.7.3.1. Подробное описание регулярных выражений
Регулярные выражения в PostgreSQL реализованы с использованием программного пакета, кото-
рый разработал Генри Спенсер (Henry Spencer). Практически всё следующее описание регуляр-
ных выражений дословно скопировано из его руководства.
Регулярное выражение (Regular expression, RE), согласно определению в POSIX 1003.2, может
иметь две формы: расширенное RE или ERE (грубо говоря, это выражения, которые понимает
egrep) и простое RE или BRE (грубо говоря, это выражения для ed). PostgreSQL поддерживает обе
формы, а кроме того реализует некоторые расширения, не предусмотренные стандартом POSIX,
но широко используемые вследствие их доступности в некоторых языках программирования, на-
пример в Perl и Tcl. Регулярные выражения, использующие эти несовместимые с POSIX расшире-
ния, здесь называются усовершенствованными RE или ARE. ARE практически представляют со-
бой надмножество ERE, тогда как BRE отличаются некоторой несовместимостью в записи (помимо
того, что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, отметив особен-
ности, присущие только ARE, а затем расскажем, чем от них отличаются BRE.
Примечание
PostgreSQL изначально всегда предполагает, что регулярное выражение следует пра-
вилам ARE. Однако можно переключиться на более ограниченные правила ERE или
BRE, добавив в шаблон RE встроенный параметр, как описано в Подразделе 9.7.3.4.
Это может быть полезно для совместимости с приложениями, ожидающими от СУБД
строгого следования правилам POSIX 1003.2.
Регулярное выражение определяется как одна или более ветвей, разделённых символами |. Оно
считается соответствующим всему, что соответствует одной из этих ветвей.
Ветвь — это ноль или несколько количественных атомов или ограничений, соединённых вместе.
Соответствие ветви в целом образуется из соответствия первой части, за которым следует соот-
ветствие второй части и т. д.; пустой ветви соответствует пустая строка.
212Функции и операторы
Количественный атом — это атом, за которым может следовать определитель количества. Без
этого определителя ему соответствует одно вхождение атома. С определителем количества ему
может соответствовать некоторое число вхождений этого атома. Все возможные атомы перечис-
лены в Таблице 9.15. Варианты определителей количества и их значения перечислены в Табли-
це 9.16.
Ограничению соответствует пустая строка, но это соответствие возможно только при выполнении
определённых условий. Ограничения могут использоваться там же, где и атомы, за исключением
того, что их нельзя дополнять определителями количества. Простые ограничения показаны в Таб-
лице 9.17; некоторые дополнительные ограничения описаны ниже.
Таблица 9.15. Атомы регулярных выражений
Атом Описание
( re) (где re — любое регулярное выражение) описы-
вает соответствие re, при этом данное соответ-
ствие захватывается для последующей обработ-
ки
(?: re) подобно предыдущему, но соответствие не за-
хватывается (т. е. это набор скобок «без захва-
та») (применимо только к ARE)
. соответствует любому символу
[символы] выражение в квадратных скобках, соответству-
ет любому из символов (подробнее это описано в
Подразделе 9.7.3.2)
\k (где k — не алфавитно-цифровой символ) соот-
ветствует обычному символу буквально, т. е. \\
соответствует обратной косой черте
\c где c — алфавитно-цифровой символ (за которым
могут следовать другие символы), это спецсим-
вол, см. Подраздел  9.7.3.3 (применим только к
ARE; в ERE и BRE этому атому соответствует c)
( когда за этим символом следует любой символ,
кроме цифры, этот атом соответствует левой фи-
гурной скобке ((), если же за ним следует циф-
ра, это обозначает начало границы (см. ниже)
x (где x — один символ, не имеющий специального
значения) соответствует этому символу
Выражение RE не может заканчиваться обратной косой чертой (\).
Примечание
Если параметр standard_conforming_strings выключен, каждый символ обратной косой
черты, записываемый в текстовой константе, нужно дублировать. Подробнее это опи-
сано в Подразделе 4.1.2.1.
Таблица 9.16. Определители количества в регулярных выражениях
Определитель Соответствует
* 0 или более вхождений атома
+ 1 или более вхождений атома
? 0 или 1 вхождение атома
213Функции и операторы
Определитель Соответствует
(m) ровно m вхождений атома
(m,) m или более вхождений атома
(m, n) от m до n (включая границы) вхождений атома; m
не может быть больше n
*? не жадная версия *
+? не жадная версия +
?? не жадная версия ?
(m)? не жадная версия (m)
(m,)? не жадная версия (m,)
(m, n)? не жадная версия (m, n)
В формах с (...) числа m и n определяют так называемые границы количества. Эти числа должны
быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 включительно.
Не жадные определители (допустимые только в ARE) описывают те же возможные соответствия,
что и аналогичные им обычные («жадные»), но предпочитают выбирать наименьшее, а не наи-
большее количество вхождений. Подробнее это описано в Подразделе 9.7.3.5.
Примечание
Определители количества не могут следовать один за другим, например запись ** бу-
дет ошибочной. Кроме того, определители не могут стоять в начале выражения или
подвыражения и идти сразу после ^ или |.
Таблица 9.17. Ограничения в регулярных выражениях
Ограничение Описание
^ соответствует началу строки
$ соответствует концу строки
(?= re) позитивный просмотр вперёд находит соответ-
ствие там, где начинается подстрока, соответ-
ствующая re (только для ARE)
(?! re) негативный просмотр вперёд находит соответ-
ствие там, где не начинается подстрока, соот-
ветствующая re (только для ARE)
(?<= re) позитивный просмотр назад находит соответ-
ствие там, где заканчивается подстрока, соот-
ветствующая re (только для ARE)
(?<! re) негативный просмотр назад находит соответ-
ствие там, где не заканчивается подстрока, со-
ответствующая re (только для ARE)
Ограничения просмотра вперёд и назад не могут содержать ссылки назад (см. Подраздел 9.7.3.3),
и все скобки в них считаются «скобками без захвата».
9.7.3.2. Выражения в квадратных скобках
Выражение в квадратных скобках содержит список символов, заключённый в []. Обычно ему со-
ответствует любой символ из списка (об исключении написано ниже). Если список начинается с ^,
ему соответствует любой символ, который не перечисляется далее в этом списке. Если два символа
214Функции и операторы
в списке разделяются знаком -, это воспринимается как краткая запись полного интервала сим-
волов между двумя заданными (и включая их) в порядке сортировки; например выражению [0-9]
в ASCII соответствует любая десятичная цифра. Два интервала не могут разделять одну границу,
т. е. выражение a-c-e недопустимо. Интервалы зависят от порядка сортировки, который может
меняться, поэтому в переносимых программах их лучше не использовать.
Чтобы включить в список ], этот символ нужно написать первым (сразу за ^, если он присутствует).
Чтобы включить в список символ -, его нужно написать первым или последним, либо как вторую
границу интервала. Указать - в качестве первой границы интервал можно, заключив его между [.
и .], чтобы он стал элементом сортировки (см. ниже). За исключением этих символов, некоторых
комбинаций с [ (см. следующие абзацы) и спецсимволов (в ARE), все остальные специальные сим-
волы в квадратных скобках теряют своё особое значение. В частности, символ \ по правилам ERE
или BRE воспринимается как обычный, хотя в ARE он экранирует символ, следующий за ним.
Выражения в квадратных скобках могут содержать элемент сортировки (символ или последова-
тельность символов или имя такой последовательности), определение которого заключается меж-
ду [. и .]. Определяющая его последовательность воспринимается в выражении в скобках как
один элемент. Это позволяет включать в такие выражения элементы, соответствующие последо-
вательности нескольких символов. Например, с элементом сортировки ch в квадратных скобках
регулярному выражению [[.ch.]]*c будут соответствовать первые пять символов строки chchcc.
Примечание
В настоящее время PostgreSQL не поддерживает элементы сортировки, состоящие из
нескольких символов. Эта информация относится к возможному в будущем поведению.
В квадратных скобках могут содержаться элементы сортировки, заключённые между [= и =], обо-
значающие классы эквивалентности, т. е. последовательности символов из всех элементов сорти-
ровки, эквивалентных указанному, включая его самого. (Если для этого символа нет эквивалент-
ных, он обрабатывается, как заключённый между [. и .].) Например, если е и ё — члены одного
класса эквивалентности, выражения [[=е=]], [[=ё=]] и [её] будут равнозначными. Класс эквива-
лентности нельзя указать в качестве границы интервала.
В квадратных скобках может также содержаться имя класса символов, заключённое между [: и
:], и заменяющее список всех символов этого класса. Стандартные имена классов: alnum, alpha,
blank, cntrl, digit, graph, lower, print, punct, space, upper и xdigit. Весь этот набор классов
определён в ctype и он может меняться в зависимости от локали (языковой среды). Класс символов
также нельзя использовать в качестве границы интервала.
Есть два особых вида выражений в квадратных скобках: выражения [[:<:]] и [[:>:]], представ-
ляющие собой ограничения, соответствующие пустым строкам в начале и конце слова. Слово в
данном контексте определяется как последовательность словосоставляющих символов, перед или
после которой нет словосоставляющих символов. Словосоставляющий символ — это символ клас-
са alnum (определённого в ctype) или подчёркивание. Это расширение совместимо со стандартом
POSIX 1003.2, но не описано в нём, и поэтому его следует использовать с осторожностью там, где
важна совместимость с другими системами. Обычно лучше использовать ограничивающие спец-
символы, описанные ниже; они также не совсем стандартны, но набрать их легче.
9.7.3.3. Спецсимволы регулярных выражений
Спецсимволы — это специальные команды, состоящие из \ и последующего алфавитно-цифрово-
го символа. Можно выделить следующие категории спецсимволов: обозначения символов, коды
классов, ограничения и ссылки назад. Символ \, за которым идёт алфавитно-цифровой символ,
не образующий допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет:
вне квадратных скобок пара из \ и последующего алфавитно-цифрового символа, воспринимается
просто как данный символ, а в квадратных скобках и сам символ \ воспринимается просто как
обратная косая черта. (Последнее на самом деле нарушает совместимость между ERE и ARE.)
215Функции и операторы
Спецобозначения символов введены для того, чтобы облегчить ввод в RE непечатаемых и других
неудобных символов. Они приведены в Таблице 9.18.
Коды классов представляют собой краткий способ записи имён некоторых распространённых клас-
сов символов. Они перечислены в Таблице 9.19.
Спецсимволы ограничений обозначают ограничения, которым при совпадении определённых
условий соответствует пустая строка. Они перечислены в Таблице 9.20.
Ссылка назад (\n) соответствует той же строке, какой соответствовало предыдущее подвыраже-
ние в скобках под номером n (см. Таблицу 9.21). Например, ([bc])\1 соответствует bb или cc, но
не bc или cb. Это подвыражение должно полностью предшествовать ссылке назад в RE. Нумеру-
ются подвыражения в порядке следования их открывающих скобок. При этом скобки без захвата
исключаются из рассмотрения.
Таблица 9.18. Спецобозначения символов в регулярных выражениях
Спецсимвол Описание
\a символ звонка, как в C
\b символ «забой», как в C
\B синоним для обратной косой черты (\), сокраща-
ющий потребность в дублировании этого симво-
ла
\cX (где X — любой символ) символ, младшие 5 бит
которого те же, что и у X, а остальные равны 0
\e символ, определённый в последовательности
сортировки с именем ESC, либо, если таковой не
определён, символ с восьмеричным значением
033
\f подача формы, как в C
\n новая строка, как в C
\r возврат каретки, как в C
\t горизонтальная табуляция, как в C
\uwxyz (где wxyz ровно четыре шестнадцатеричные
цифры) символ с шестнадцатеричным кодом
0xwxyz
\Ustuvwxyz (где stuvwxyz ровно восемь шестнадцатерич-
ных цифр) символ с шестнадцатеричным кодом
0xstuvwxyz
\v вертикальная табуляция, как в C
\xhhh (где hhh — несколько шестнадцатеричных цифр)
символ с шестнадцатеричным кодом 0xhhh (сим-
вол всегда один вне зависимости от числа шест-
надцатеричных цифр)
\0 символ с кодом 0 (нулевой байт)
\xy (где xy — ровно две восьмеричных цифры, не
ссылка назад) символ с восьмеричным кодом 0xy
\xyz (где xyz — ровно три восьмеричных цифры, не
ссылка назад) символ с восьмеричным кодом
0xyz
Шестнадцатеричные цифры записываются символами 0-9 и a-f или A-F. Восьмеричные цифры —
цифры от 0 до 7.
216Функции и операторы
Спецпоследовательности с числовыми кодами, задающими значения вне диапазона ASCII (0-127),
воспринимаются по-разному в зависимости от кодировки базы данных. Когда база данных имеет
кодировку UTF-8, спецкод равнозначен позиции символа в Unicode, например, \u1234 обозначает
символ U+1234. Для других многобайтных кодировок спецпоследовательности обычно просто зада-
ют серию байт, определяющих символ. Если в кодировке базы данных отсутствует символ, задан-
ный спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей соответствовать.
Символы, переданные спецобозначением, всегда воспринимаются как обычные символы. Напри-
мер, \135 кодирует ] в ASCII, но спецпоследовательность \135 не будет закрывать выражение в
квадратных скобках.
Таблица 9.19. Спецкоды классов в регулярных выражениях
Спецсимвол Описание
\d [[:digit:]]
\s [[:space:]]
\w [[:alnum:]_] (подчёркивание также включает-
ся)
\D [^[:digit:]]
\S [^[:space:]]
\W [^[:alnum:]_]
ется)
(подчёркивание также включа-
В выражениях в квадратных скобках спецсимволы \d, \s и \w теряют свои внешние квадрат-
ные скобки, а \D, \S и \W — недопустимы. (Так что, например запись [a-c\d] равнозначна [a-
c[:digit:]]. А запись [a-c\D], которая была бы равнозначна [a-c^[:digit:]], — недопустима.)
Таблица 9.20. Спецсимволы ограничений в регулярных выражений
Спецсимвол Описание
\A соответствует только началу строки (чем это от-
личается от ^, описано в Подразделе 9.7.3.5)
\m соответствует только началу слова
\M соответствует только концу слова
\y соответствует только началу или концу слова
\Y соответствует только положению не в начале и
не в конце слова
\Z соответствует только концу строки (чем это от-
личается от $, описано в Подразделе 9.7.3.5)
Определением слова здесь служит то же, что было приведено выше в описании [[:<:]] и [[:>:]].
В квадратных скобках спецсимволы ограничений не допускаются.
Таблица 9.21. Ссылки назад в регулярных выражениях
Спецсимвол Описание
\m (где m — цифра, отличная от 0) — ссылка назад
на подвыражение под номером m
\mnn (где m — цифра, отличная от 0, а nn — ещё
несколько цифр с десятичным значением mnn, не
превышающим число закрытых до этого скобок
с захватом) ссылка назад на подвыражение под
номером mnn
217Функции и операторы
Примечание
Регулярным выражениям присуща неоднозначность между восьмеричными кодами
символов и ссылками назад, которая разрешается следующим образом (это упомина-
лось выше). Ведущий ноль всегда считается признаком восьмеричной последователь-
ности. Единственная цифра, отличная от 0, за которой не следует ещё одна цифра, все-
гда воспринимается как ссылка назад. Последовательность из нескольких цифр, кото-
рая начинается не с 0, воспринимается как ссылка назад, если она идёт за подходящим
подвыражением (т. е. число оказывается в диапазоне, допустимом для ссылки назад),
в противном случае она воспринимается как восьмеричное число.
9.7.3.4. Метасинтаксис регулярных выражений
В дополнение к основному синтаксису, описанному выше, можно использовать также несколько
особых форм и разнообразные синтаксические удобства.
Регулярное выражение может начинаться с одного из двух специальных префиксов режима. Если
RE начинается с ***:, его продолжение рассматривается как ARE. (В PostgreSQL это обычно не
имеет значения, так как регулярные выражения воспринимаются как ARE по умолчанию; но это
может быть полезно, когда параметр флаги функций regex включает режим ERE или BRE.) Если
RE начинается с ***=, его продолжение воспринимается как обычная текстовая строка, все его
символы воспринимаются буквально.
ARE может начинаться со встроенных параметров: последовательности (?xyz) (где xyz — один
или несколько алфавитно-цифровых символов), определяющих параметры остального регулярного
выражения. Эти параметры переопределяют любые ранее определённые параметры, в частности
они могут переопределить режим чувствительности к регистру, подразумеваемый для оператора
regex, или параметр флаги функции regex. Допустимые буквы параметров показаны в Таблице 9.22.
Заметьте, что те же буквы используются в параметре флаги функций regex.
Таблица 9.22. Буквы встроенных параметров ARE
Параметр Описание
b продолжение регулярного выражения — BRE
c поиск соответствий с учётом регистра (пере-
определяет тип оператора)
e продолжение RE — ERE
i поиск соответствий без учёта регистра (см. Под-
раздел 9.7.3.5) (переопределяет тип оператора)
m исторически сложившийся синоним n
n поиск соответствий с учётом перевода строк (см.
Подраздел 9.7.3.5)
p переводы строк учитываются частично (см. Под-
раздел 9.7.3.5)
q продолжение регулярного выражения — обыч-
ная строка («в кавычках»), содержимое которой
воспринимается буквально
s поиск соответствий без учёта перевода строк (
по умолчанию)
t компактный синтаксис (по умолчанию; см. ни-
же)
w переводы строк учитываются частично, но в дру-
гом, «странном» режиме (см. Подраздел 9.7.3.5)
218Функции и операторы
Параметр Описание
x развёрнутый синтаксис (см. ниже)
Внедрённые параметры начинают действовать сразу после скобки ), завершающей их последова-
тельность. Они могут находиться только в начале ARE (после указания ***:, если оно присутству-
ет).
Помимо обычного (компактного) синтаксиса RE, в котором имеют значение все символы, поддер-
живается также развёрнутый синтаксис, включить который можно с помощью встроенного пара-
метра x. В развёрнутом синтаксисе игнорируются пробельные символы, а также все символы от
# до конца строки (или конца RE). Это позволяет разделять RE на строки и добавлять в него ком-
ментарии. Но есть три исключения:
• пробельный символ или #, за которым следует \, сохраняется
• пробельный символ или # внутри выражения в квадратных скобках сохраняется
• пробельные символы и комментарии не могут присутствовать в составных символах, напри-
мер, в (?:
В данном контексте пробельными символами считаются пробел, табуляция, перевод строки и лю-
бой другой символ, относящийся к классу символов space.
И наконец, в ARE последовательность (?#ttt) (где ttt — любой текст, не содержащий )) вне квад-
ратных скобок также считается комментарием и полностью игнорируется. При этом она так же
не может находиться внутри составных символов, таких как (?:. Эти комментарии в большей сте-
пени историческое наследие, чем полезное средство; они считаются устаревшими, а вместо них
рекомендуется использовать развёрнутый синтаксис.
Ни одно из этих расширений метасинтаксиса не будет работать, если выражение начинается с
префикса ***=, после которого строка воспринимается буквально, а не как RE.
9.7.3.5. Правила соответствия регулярным выражениям
В случае, когда RE может соответствовать более чем одной подстроке в заданной строке, соответ-
ствующей RE считается подстрока, которая начинается в ней первой. Если к данной позиции по-
добных соответствующих подстрок оказывается несколько, из них выбирается либо самая длин-
ная, либо самая короткая из возможных, в зависимости от того, какой режим выбран в RE: жадный
или не жадный.
Где жадный или не жадный характер RE определяется по следующим правилам:
• Большинство атомов и все ограничения не имеют признака жадности (так как они всё равно
не могут соответствовать подстрокам разного состава).
• Скобки, окружающие RE, не влияют на его «жадность».
• Атом с определителем фиксированного количества ((m) или (m)?) имеет ту же характеристи-
ку жадности (или может не иметь её), как и сам атом.
• Атом с другими обычными определителями количества (включая (m,n), где m равняется n)
считается жадным (предпочитает соответствие максимальной длины).
• Атом с не жадным определителем количества (включая (m,n)?, где m равно n) считается не
жадным (предпочитает соответствие минимальной длины).
• Ветвь (RE без оператора | на верхнем уровне) имеет ту же характеристику жадности, что и
первый количественный атом в нём, имеющий атрибут жадности.
• RE, образованное из двух или более ветвей, соединённых оператором |, всегда считается жад-
ным.
Эти правила связывают характеристики жадности не только с отдельными количественными ато-
мами, но и с ветвями и целыми RE, содержащими количественные атомы. Это означает, что при
219Функции и операторы
сопоставлении ветвь или целое RE может соответствовать максимально длинной или короткой
подстроке в целом. Когда определена длина всего соответствия, часть его, соответствующая кон-
кретному подвыражению, определяется с учётом характеристики жадности для этого подвыраже-
ния, при этом подвыражения, начинающиеся в RE раньше, имеют больший приоритет, чем следу-
ющие за ними.
Это иллюстрирует следующий пример:
SELECT SUBSTRING('XY1234Z', 'Y*([0-9](1,3))');
Результат: 123
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9](1,3))');
Результат: 1
В первом случае, RE в целом жадное, так как жадным является атом Y*. Соответствие ему начина-
ется с буквы Y и оно включает подстроку максимальной длины с этого места, т. е. подстроку Y123.
Результат выражения — её часть, соответствующая подвыражению в скобках, т. е. 123. Во втором
случае, RE в целом наследует не жадный характер от атома Y*?. Соответствие ему так же начина-
ется с Y, но включает оно подстроку минимальной длины с этого места, т. е. Y1. И хотя подвыра-
жение [0-9](1,3) имеет жадный характер, оно не может повлиять на выбор длины соответствия
в целом, поэтому ему остаётся только подстрока 1.
Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё соответствие
будет максимально длинным или коротким в зависимости от характеристики всего RE. Характе-
ристики, связанные с подвыражениями, влияют только на то, какую часть подстроки может «по-
глотить» одно подвыражение относительно другого.
Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению или всему RE,
можно использовать определители (1,1) и (1,1)?, соответственно. Это полезно, когда вам нуж-
но, чтобы общая характеристика жадности RE отличалась от той, что вытекает из его элементов.
Например, предположим, что вы пытаетесь выделить из строки, содержащей несколько цифр, эти
цифры и части до и после них. Можно попытаться сделать это так:
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
Результат: (abc0123,4,xyz)
Но это не будет работать: первая группа .* — «жадная», она «съест» всё, что сможет, оставляя для
соответствия \d+ только последнюю возможность, то есть последнюю цифру. Можно попытаться
сделать запрос «нежадным»:
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
Результат: (abc,0,"")
И это не будет работать, так теперь весь RE в целом стал нежадным, и все соответствия заверша-
ются как можно раньше. Но мы можем получить нужный результат, явно сделав жадным всё RE:
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*))(1,1)');
Результат: (abc,01234,xyz)
Управление общей характеристикой «жадности» RE независимо от «жадности» его компонентов
даёт большую гибкость в описании шаблонов переменной длины.
При определении более длинного или более короткого соответствия длины соответствий опреде-
ляются в символах, а не в элементах сортировки. Пустая строка считается длиннее, чем отсутствие
соответствия. Например, выражению bb* соответствуют три символа в середине строки abbbc, вы-
ражению (week|wee)(night|knights) — все десять символов weeknights; когда выражение (.*).*
сопоставляется со строкой abc, подвыражению в скобках соответствуют все три символа; а когда
(a*)* сопоставляется со строкой bc, то и RE в целом, и подстроке в скобках соответствует пустая
строка.
Игнорирование регистра символов даёт практически тот же эффект, как если бы в алфавите ис-
чезли различия прописных и строчных букв. Если буква, существующая и в верхнем, и в нижнем
регистре, фигурирует вне квадратных скобок как обычный символ, она по сути преобразуется в
220Функции и операторы
выражение в квадратных скобках, содержащее оба варианта, например x становится [xX]. Если
же она фигурирует в выражении в квадратных скобках, в это выражение добавляются все её вари-
анты, например [x] становится [xX], а [^x] — [^xX].
Когда включён режим учёта перевода строк, атом . и выражения в квадратных скобках с ^ никогда
не будут соответствовать символам конца строки (так что соответствия никогда не будут пересе-
кать границы строк, если в RE нет явных указаний на эти символы), а ^ и $ будут соответствовать
пустой подстроке не только в начале и конце всего текста, но и в начале и конце каждой отдельной
его строки. Однако спецсимволы ARE \A и \Z по-прежнему будут соответствовать только началу
и концу всего текста.
В режиме, когда переводы строк учитываются частично, особый смысл перевод строк имеет для
атома . и выражений в квадратных скобках, но не для ^ и $.
В обратном частичном режиме, перевод строк имеет особый смысл для ^ и $, как и в режиме с
учётом перевода строк, но не для . и выражений в квадратных скобках. Данный режим не очень
полезен, но существует для симметрии.
9.7.3.6. Пределы и совместимость
В текущей реализации отсутствует какой-либо явно заданный предел длины RE. Однако, разраба-
тывая программы высокой степени переносимости, не следует применять RE длиннее 256 байт,
так как другая POSIX-совместимая реализация может отказаться обрабатывать такие регулярные
выражения.
Единственная особенность ARE, действительно несовместимая с ERE стандарта POSIX проявляет-
ся в том, что в ARE знак \ не теряет своё специальное значение в квадратных скобках. Все другие
расширения ARE используют синтаксические возможности, которые не определены, не допусти-
мы или не поддерживаются в ERE; синтаксис переключения режимов (***) также выходит за рам-
ки синтаксиса POSIX как для BRE, так и для ERE.
Многие расширения ARE заимствованы из языка Perl, но некоторые были изменены, оптимизиро-
ваны, а несколько расширений Perl были исключены. В результате имеют место следующие несов-
местимости: атомы \b и \B, отсутствие специальной обработки завершающего перевода строки,
добавление исключений в квадратных скобках в число случаев, когда учитывается перевод строк,
особые условия для скобок и ссылок назад в ограничениях просмотра вперёд/назад и семантика
«наиболее длинное/короткое соответствие» (вместо «первое соответствие»).
Важно отметить две несовместимости синтаксиса ARE и регулярных выражений ERE, которые
воспринимал PostgreSQL до версии 7.4:
• В ARE \ с последующим алфавитно-цифровым символом представляет либо спецсимвол, ли-
бо ошибочную последовательность, тогда как в предыдущих версиях так можно было записы-
вать алфавитно-цифровые символы. Это не должно быть большой проблемой, так как раньше
не было причин использовать такие последовательности.
• В ARE знак \ сохраняет своё специальное значение в [], поэтому, чтобы передать \ в квадрат-
ных скобках буквально, его нужно записать как \\.
9.7.3.7. Простые регулярные выражения
BRE имеют ряд отличий от ERE. В BRE знаки |, + и ? теряют специальное значение, а замены им
нет. Границы количества окружаются символами \( и \), тогда как ( и ) рассматриваются как
обычные символы. Вложенные подвыражения помещаются между \( и \), а ( и ) представляют
обычные символы. Символ ^ воспринимается как обычный, если только он не находится в начале
RE или подвыражения в скобках, $ — тоже обычный символ, если он находится не в конце RE
или в конце подвыражения в скобках, и * — обычный символ, когда он находится в начале RE
или подвыражения в скобках (возможно, после начального ^). И, наконец, в BRE работают ссылки
назад с одной цифрой, \< и \> — синонимы для [[:<:]] и [[:>:]], соответственно; никакие другие
спецсимволы в BRE не поддерживаются.
221Функции и операторы
9.8. Функции форматирования данных
Функции форматирования в PostgreSQL предоставляют богатый набор инструментов для преобра-
зования самых разных типов данных (дата/время, целое, числа с плавающей и фиксированной точ-
кой) в форматированные строки и обратно. Все они перечислены в Таблице 9.23. Все эти функции
следует одному соглашению: в первом аргументе передаётся значение, которое нужно отформа-
тировать, а во втором — шаблон, определяющий формат ввода или вывода.
Таблица 9.23. Функции форматирования
Функция
Тип результата Описание
Пример
to_char(
text) timestamp, text преобразует
текст
to_char(
text) interval, text преобразует интервал в to_char(interval
текст
'15h
2m
12s',
'HH24:MI:SS')
to_char( int,
преобразует
текст
text) text
время
целое
в to_char(current_
timestamp,
'HH12:MI:SS')
в to_char(125,
'999')
to_char ( double
precision, text) text преобразует
плаваю- to_char(
щее
одинарной/двой- 125.8::real,
ной точности в текст
'999D9')
to_char(
text) numeric, text преобразует числовое to_char(-125.8,
значение в текст
'999D99S')
to_date(
text) text, date преобразует текст в да- to_date(
ту
'05
Dec
2000',
'DD Mon YYYY')
numeric преобразует
число
to_number(
text)
text,
to_timestamp(
text)
text,
timestamp
zone
with
текст
в to_number('12,
454.8-',
'99G999D9S')
time преобразует строку во to_timestamp(
время
'05
Dec
2000',
'DD Mon YYYY')
Примечание
Также имеется функция to_timestamp с одним аргументом; см. Таблицу 9.30.
Подсказка
Функции to_timestamp и to_date предназначены для работы с входными форматами,
которые нельзя преобразовать простым приведением. Для большинства стандартных
форматов даты/времени работает простое приведение исходной строки к требуемому
типу и использовать его гораздо легче. Так же и функцию to_number нет необходимости
использовать для стандартных представлений чисел.
Шаблон вывода to_char может содержать ряд кодов, которые распознаются при форматировании
и заменяются соответствующими данными в зависимости от заданного значения. Любой текст,
который не является кодом, просто копируется в неизменном виде. Подобным образом в строке
шаблона ввода (для других функций) шаблонные коды определяют, какие значения должны посту-
пать из входной строки. Если в строке шаблона есть символы, не относящиеся к шаблонным ко-
222Функции и операторы
дам, соответствующие символы во входной строке просто пропускаются (вне зависимости от того,
совпадают ли они с символами в строке шаблона).
Все коды форматирования даты и времени перечислены в Таблице 9.24.
Таблица 9.24. Коды форматирования даты/времени
Код Описание
HH час (01-12)
HH12 час (01-12)
HH24 час (00-23)
MI минута (00-59)
SS секунда (00-59)
MS миллисекунда (000-999)
US микросекунда (000000-999999)
SSSS число секунд с начала суток (0-86399)
AM, am, PM или pm обозначение времени до/после полудня (без то-
чек)
A.M., a.m., P.M. или p.m. обозначение времени до/после полудня (с точка-
ми)
Y,YYY год (4 или более цифр) с разделителем
YYYY год (4 или более цифр)
YYY последние 3 цифры года
YY последние 2 цифры года
Y последняя цифра года
IYYY недельный год по ISO 8601 (4 или более цифр)
IYY последние 3 цифры недельного года по ISO 8601
IY последние 2 цифры недельного года по ISO 8601
I последняя цифра недельного года по ISO 8601
BC, bc, AD или ad обозначение эры (без точек)
B.C., b.c., A.D. или a.d. обозначение эры (с точками)
MONTH полное название месяца в верхнем регистре (до-
полненное пробелами до 9 символов)
Month полное название месяца с большой буквы (до-
полненное пробелами до 9 символов)
month полное название месяца в нижнем регистре (до-
полненное пробелами до 9 символов)
MON сокращённое название месяца в верхнем реги-
стре (3 буквы в английском; в других языках дли-
на может меняться)
Mon сокращённое название месяца с большой буквы
(3 буквы в английском; в других языках длина
может меняться)
mon сокращённое название месяца в нижнем реги-
стре (3 буквы в английском; в других языках дли-
на может меняться)
MM номер месяца (01-12)
223Функции и операторы
Код Описание
DAY полное название дня недели в верхнем регистре
(дополненное пробелами до 9 символов)
Day полное название дня недели с большой буквы (
дополненное пробелами до 9 символов)
day полное название дня недели в нижнем регистре
(дополненное пробелами до 9 символов)
DY сокращённое название дня недели в верхнем ре-
гистре (3 буквы в английском; в других языках
может меняться)
Dy сокращённое название дня недели с большой
буквы (3 буквы в английском; в других языках
длина может меняться)
dy сокращённое название дня недели в нижнем ре-
гистре (3 буквы в английском; в других языках
длина может меняться)
DDD номер дня в году (001-366)
IDDD номер дня в году по ISO 8601 (001-371; 1 день —
понедельник первой недели по ISO)
DD день месяца (01-31)
D номер дня недели, считая с воскресенья (1) до
субботы (7)
ID номер дня недели по ISO 8601, считая с поне-
дельника (1) до воскресенья (7)
W неделя месяца (1-5) (первая неделя начинается
в первое число месяца)
WW номер недели в году (1-53) (первая неделя начи-
нается в первый день года)
IW номер недели в году по ISO 8601 (01-53; первый
четверг года относится к неделе 1)
CC век (2 цифры) (двадцать первый век начался
2001-01-01)
J День по юлианскому календарю (номер дня с 24
ноября 4714 г. до н. э.)
Q quarter
RM номер месяца римскими цифрами в верхнем ре-
гистре (I-XII; I=январь)
rm номер месяца римскими цифрами в нижнем ре-
гистре (i-xii; i=январь)
TZ сокращённое название часового пояса в верхнем
регистре (поддерживается только в to_char )
tz сокращённое название часового пояса в нижнем
регистре (поддерживается только в to_char )
TZH часы часового пояса
TZM минуты часового пояса
OF смещение часового пояса от UTC (поддержива-
ется только в to_char )
224Функции и операторы
К любым кодам форматирования можно добавить модификаторы, изменяющие их поведение. На-
пример, шаблон форматирования FMMonth включает код Month с модификатором FM. Модификато-
ры, предназначенные для форматирования даты/времени, перечислены в Таблице 9.25.
Таблица 9.25. Модификаторы кодов для форматирования даты/времени
Модификатор Описание
Пример
Приставка FM режим заполнения (подавляет FMMonth
ведущие нули и дополнение
пробелами)
Окончание TH окончание порядкового числи- DDTH, например 12TH
тельного в верхнем регистре
Окончание th окончание порядкового числи- DDth, например 12th
тельного в нижнем регистре
Приставка FX глобальный параметр фиксиро- FX Month DD Day
ванного формата (см. замеча-
ния)
Приставка TM режим перевода (выводятся ло- TMMonth
кализованные названия дней и
месяцев, исходя из lc_time)
Окончание SP режим числа прописью (не реа- DDSP
лизован)
Замечания по использованию форматов даты/времени:
• FM подавляет дополняющие пробелы и нули справа, которые в противном случае будут добав-
лены, чтобы результат имел фиксированную ширину. В PostgreSQL модификатор FM действует
только на следующий код, тогда как в Oracle FM её действие распространяется на все последу-
ющие коды, пока не будет отключено последующим модификатором FM.
• TM не затрагивает замыкающие пробелы. Функции to_timestamp и to_date игнорируют указа-
ние TM.
• to_timestamp и to_date пропускают повторяющиеся пробелы во входной строке, если только
не используется параметр FX. Например, to_timestamp('2000    JUN', 'YYYY MON') будет ра-
ботать, но to_timestamp('2000    JUN', 'FXYYYY MON') вернёт ошибку, так как to_timestamp
в данном случае ожидает только один разделяющий пробел. Приставка FX должна быть пер-
вой в шаблоне.
• Шаблоны для to_char могут содержать обычный текст; он будет выведен в неизменном ви-
де. Чтобы принудительно вывести текст буквально, даже если он содержит шаблонные коды,
подстроку с ним можно заключить в кавычки. Например, в строке '"Hello Year "YYYY', код
YYYY будет заменён годом, а буква Y в слове Year останется неизменной. В функциях to_date,
to_number и to_timestamp при обработке подстрок в кавычках и буквального текста некото-
рой длины пропускается такое же число символов во входной строке; например, при обработ-
ке подстроки "XX" будут пропущены два символа (любые, не обязательно XX).
• Если вам нужно получить на выходе двойные кавычки, вы должны предварить их символом
обратной косой черты, например: '\"YYYY Month\"'. В остальном этот символ вне кавычек
воспринимается как обычный. Внутри строки в кавычках он указывает, что следующий сим-
вол должен восприниматься буквально, каким бы он ни был (но это имеет смысл, только если
следующий символ — кавычки или обратная косая черта).
• Если в функциях to_timestamp и to_date формат года определяется менее, чем 4 цифрами,
например, как YYY, и в переданном значении года тоже меньше 4 цифр, год пересчитывается
в максимально близкий к году 2020, т. е. 95 воспринимается как 1995.
• В функциях to_timestamp и to_date с преобразованием YYYY связано ограничение, когда об-
рабатываемый год записывается более чем 4 цифрами. После YYYY необходимо будет доба-
225Функции и операторы
вить нецифровой символ или соответствующий код, иначе год всегда будет восприниматься
как 4 цифры. Например, в to_date('200001131', 'YYYYMMDD') (с годом 20000) год будет ин-
терпретирован как состоящий из 4 цифр; чтобы исправить ситуацию, нужно добавить нециф-
ровой разделитель после года, как в to_date('20000-1131', 'YYYY-MMDD'), или код как в
to_date('20000Nov31', 'YYYYMonDD').
• Функции to_timestamp и to_date принимают поле CC (век), но игнорируют его, если в шаб-
лоне есть поле YYY, YYYY или Y,YYY. Если CC используется с YY или Y, результатом будет год в
данном столетии. Если присутствует только код столетия, без года, подразумевается первый
год этого века.
• Функции to_timestamp и to_date принимают названия и номера дней недели (DAY, D и связан-
ные типы полей), но игнорируют их при вычислении результата. То же самое происходит с по-
лями квартала (Q).
• Функциям to_timestamp и to_date можно передать даты по недельному календарю ISO 8601
(отличающиеся от григорианских) одним из двух способов:
• Год, номер недели и дня недели: например, to_date('2006-42-4', 'IYYY-IW-ID') возвра-
щает дату 2006-10-19. Если день недели опускается, он считается равным 1 (понедельни-
ку).
• Год и день года: например, to_date('2006-291', 'IYYY-IDDD') также возвращает
2006-10-19.
Попытка ввести дату из смеси полей григорианского и недельного календаря ISO 8601 бес-
смысленна, поэтому это будет считаться ошибкой. В контексте ISO 8601 понятия «номер ме-
сяца» и «день месяца» не существуют, а в григорианском календаре нет понятия номера неде-
ли по ISO.
Внимание
Тогда как to_date не примет смесь полей григорианского и недельного календаря
ISO, to_char способна на это, так как форматы вроде YYYY-MM-DD (IYYY-IDDD) мо-
гут быть полезны. Но избегайте форматов типа IYYY-MM-DD; в противном случае с
датами в начале года возможны сюрпризы. (За дополнительными сведениями об-
ратитесь к Подразделу 9.9.1.)
• Функция to_timestamp воспринимает поля миллисекунд (MS) или микросекунд (US) как дроб-
ную часть число секунд. Например, to_timestamp('12.3', 'SS.MS') — это не 3 миллисекун-
ды, а 300, так как это значение воспринимается как 12 + 0.3 секунды. Это значит, что для
формата SS.MS входные значения 12.3, 12.30 и 12.300 задают одно и то же число миллисе-
кунд. Чтобы получить три миллисекунды, время нужно записать в виде 12.003, тогда оно бу-
дет воспринято как 12 + 0.003 = 12.003 сек.
Ещё более сложный пример: to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US') бу-
дет преобразовано в 15 часов, 12 минут и 2 секунды + 20 миллисекунд + 1230 микросекунд =
2.021230 seconds.
• Нумерация дней недели в to_char(..., 'ID') соответствует функции extract(isodow
from ...), но нумерация to_char(..., 'D') не соответствует нумерации, принятой в
extract(dow from ...).
• Функция to_char(interval) обрабатывает форматы HH and HH12 в рамках 12 часов, то есть 0 и
36 часов будут выводиться как 12, тогда как HH24 выводит число часов полностью, и для зна-
чений interval результат может превышать 23.
Коды форматирования числовых значений перечислены в Таблице 9.26.
226Функции и операторы
Таблица 9.26. Коды форматирования чисел
Код Описание
9 позиция цифры (может отсутствовать, если циф-
ра незначащая)
0 позиция цифры (присутствует всегда, даже если
цифра незначащая)
. (точка) десятичная точка
, (запятая) разделитель групп (тысяч)
PR отрицательное значение в угловых скобках
S знак, добавляемый к числу (с учётом локали)
L символ денежной единицы (с учётом локали)
D разделитель целой и дробной части числа (с учё-
том локали)
G разделитель групп (с учётом локали)
MI знак минус в заданной позиции (если число < 0)
PL знак плюс в заданной позиции (если число > 0)
SG знак плюс или минус в заданной позиции
RN число римскими цифрами (в диапазоне от 1 до
3999)
TH или th окончание порядкового числительного
V сдвиг на заданное количество цифр (см. замеча-
ния)
EEEE экспоненциальная запись числа
Замечания по использованию форматов чисел:
• 0 обозначает позицию цифры, которая будет выводиться всегда, даже если это незначащий
ноль слева или справа. 9 также обозначает позицию цифры, но если это незначащий ноль сле-
ва, он заменяется пробелом, а если справа и задан режим заполнения, он удаляется. (Для
функции to_number() эти два символа равнозначны.)
• Символы шаблона S, L, D и G представляют знак, символ денежной единицы, десятичную точ-
ку и разделитель тысяч, как их определяет текущая локаль (см. lc_monetary и lc_numeric).
Символы точка и запятая представляют те же символы, обозначающие десятичную точку и
разделитель тысяч, но не зависят от локали.
• Если в шаблоне to_char() отсутствует явное указание положения знака, для него резервиру-
ется одна позиция рядом с числом (слева от него). Если левее нескольких 9 помещён S, знак
также будет приписан слева к числу.
• Знак числа, полученный кодами SG, PL или MI, не присоединяется к числу; например,
to_char(-12, 'MI9999') выдаёт '-  12', тогда как to_char(-12, 'S9999') — '  -12'. (В
Oracle MI не может идти перед 9, наоборот 9 нужно указать перед MI.)
• TH не преобразует значения меньше 0 и не поддерживает дробные числа.
• PL, SG и TH — расширения PostgreSQL.
• В to_number при использовании шаблонных кодов, не обозначающих данные, таких как L и TH,
пропускается соответствующее количество входных символов. При этом не имеет значения,
совпадают ли они с символами шаблона, если только это не символы данных (то есть цифры,
знак числа, десятичная точка или запятая). Например, для подстроки TH будут пропущены
два символа, не представляющие данные.
227Функции и операторы
• V c to_char умножает вводимое значение на 10^n, где n — число цифр, следующих за V. V с
to_number подобным образом делит значение. Функции to_char и to_number не поддерживают
V с дробными числами (например, 99.9V99 не допускается).
• Код EEEE (научная запись) не может сочетаться с любыми другими вариантами форматирова-
ния или модификаторами, за исключением цифр и десятичной точки, и должен располагаться
в конце строки шаблона (например, 9.99EEEE — допустимый шаблон).
Для изменения поведения кодов к ним могут быть применены определённые модификаторы. На-
пример, FM99.99 обрабатывается как код 99.99 с модификатором FM. Все модификаторы для фор-
матирования чисел перечислены в Таблице 9.27.
Таблица 9.27. Модификаторы шаблонов для форматирования чисел
Модификатор Описание
Пример
Приставка FM режим заполнения (подавляет FM99.99
завершающие нули и дополне-
ние пробелами)
Окончание TH окончание порядкового числи- 999TH
тельного в верхнем регистре
Окончание th окончание порядкового числи- 999th
тельного в нижнем регистре
В Таблице 9.28 приведены некоторые примеры использования функции to_char.
Таблица 9.28. Примеры to_char
Выражение
Результат
to_char(current_timestamp,
 DD  HH12:MI:SS') 'Day,
to_char(current_timestamp,
 FMDD  HH12:MI:SS') 'FMDay,
'Tuesday  , 06  05:39:18'
'Tuesday, 6  05:39:18'
to_char(-0.1, '99.99') '  -.10'
to_char(-0.1, 'FM9.99') '-.1'
to_char(-0.1, 'FM90.99') '-0.1'
to_char(0.1, '0.9') ' 0.1'
to_char(12, '9990999.9') '    0012.0'
to_char(12, 'FM9990999.9') '0012.'
to_char(485, '999') ' 485'
to_char(-485, '999') '-485'
to_char(485, '9 9 9') ' 4 8 5'
to_char(1485, '9,999') ' 1,485'
to_char(1485, '9G999') ' 1 485'
to_char(148.5, '999.999') ' 148.500'
to_char(148.5, 'FM999.999') '148.5'
to_char(148.5, 'FM999.990') '148.500'
to_char(148.5, '999D999') ' 148,500'
to_char(3148.5, '9G999D999') ' 3 148,500'
to_char(-485, '999S') '485-'
to_char(-485, '999MI') '485-'
228Функции и операторы
Выражение Результат
to_char(485, '999MI') '485 '
to_char(485, 'FM999MI') '485'
to_char(485, 'PL999') '+485'
to_char(485, 'SG999') '+485'
to_char(-485, 'SG999') '-485'
to_char(-485, '9SG99') '4-85'
to_char(-485, '999PR') '<485>'
to_char(485, 'L999') 'DM 485'
to_char(485, 'RN') '        CDLXXXV'
to_char(485, 'FMRN') 'CDLXXXV'
to_char(5.2, 'FMRN') 'V'
to_char(482, '999th') ' 482nd'
to_char(485, '"Good number:"999') 'Good number: 485'
to_char(485.8, '"Pre:"999" Post:" .999') 'Pre: 485 Post: .800'
to_char(12, '99V999') ' 12000'
to_char(12.4, '99V999') ' 12400'
to_char(12.45, '99V9') ' 125'
to_char(0.0004859, '9.99EEEE') ' 4.86e-04'
9.9. Операторы и функции даты/времени
Все существующие функции для обработки даты/времени перечислены в Таблице 9.30, а подробнее
они описаны в следующих подразделах. Поведение основных арифметических операторов (+, * и
т. д.) описано в Таблице 9.29. Функции форматирования этих типов данных были перечислены в
Разделе 9.8. Общую информацию об этих типах вы получили (или можете получить) в Разделе 8.5.
Все описанные ниже функции и операторы принимают две разновидности типов time или
timestamp: с часовым поясом (time with time zone и timestamp with time zone) и без него (time
without time zone и timestamp without time zone). Для краткости здесь они рассматриваются
вместе. Кроме того, операторы + и * обладают переместительным свойством (например, date +
integer = integer + date); здесь будет приведён только один вариант для каждой пары.
Таблица 9.29. Операторы даты/времени
Оператор Пример
Результат
+ date '2001-09-28' + integer date '2001-10-05'
'7' + date '2001-09-28' + interval timestamp
'1 hour'
01:00:00' '2001-09-28
+ date '2001-09-28'
'03:00' '2001-09-28
+ interval '1 day' + interval interval '1 day 01:00:00'
'1 hour'
+ timestamp '2001-09-28 01:00' timestamp
+ interval '23 hours'
00:00:00' + time '01:00' + interval '3 time '04:00:00'
hours'
229
+
time timestamp
03:00:00'
'2001-09-29Функции и операторы
Оператор Пример
Результат
- - interval '23 hours'
interval '-23:00:00'
- date '2001-10-01'
'2001-09-28'
- date '2001-10-01' - integer date '2001-09-24'
'7'
- date '2001-09-28' - interval timestamp
'1 hour'
23:00:00'
- time '05:00' - time '03:00'
- time '05:00' - interval '2 time '03:00:00'
hours'
- timestamp '2001-09-28 23:00' timestamp
- interval '23 hours'
00:00:00'
- interval '1 day' - interval interval '1 day -01:00:00'
'1 hour'
- timestamp '2001-09-29 03:00' interval '1 day 15:00:00'
-
timestamp
'2001-09-27
12:00'
* 900 * interval '1 second'
interval '00:15:00'
* 21 * interval '1 day'
interval '21 days'
* double precision
interval '1 hour'
/ interval '1 hour' / double interval '00:40:00'
precision '1.5'
-
date integer '3' (дня)
'3.5'
'2001-09-27
interval '02:00:00'
'2001-09-28
* interval '03:30:00'
Таблица 9.30. Функции даты/времени
Функция Тип результата Описание age( timestamp,
timestamp) interval Вычитает
аргу- age(timestamp
менты
и
вы- '2001-04-10',
даёт «символиче-
timestamp
ский» результат с '1957-06-13')
годами и месяца-
ми, а не просто
днями 43 years 9 mons 27
days (43 года 9
месяцев 27 дней)
age( timestamp) interval Вычитает
да- age(timestamp
ту/время
из '1957-06-13')
current_date
(
полночь текущего
дня) 43 years 8 mons 3
days (43 года 8
месяцев 3 дня)
clock_timestamp
() timestamp
time zone current_date date current_time time
zone
with Текущая дата и
время (меняется
в процессе вы-
полнения операто-
ров); см. Подраз-
дел 9.9.4
Текущая дата; см.
Подраздел 9.9.4
with
time Текущее время су-
ток; см. Подраз-
дел 9.9.4
230
Пример
РезультатФункции и операторы
Функция Тип результата
Описание
Пример
Результат
current_
timestamp timestamp
time zone
date_part(
text,
timestamp) double precision Возвращает поле date_part(
даты (равнозначно 'hour',
extract); см. Под-
timestamp
раздел 9.9.1
'2001-02-16
20:38:40')
with Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
20
date_part(
double precision Возвращает поле date_part(
3
даты (равнозначно 'month',
text, interval)
extract); см. Под-
interval
'2
раздел 9.9.1
years 3 months')
date_trunc(
text,
timestamp)
timestamp
date_trunc(
interval
text, interval)
Отсекает
компо-
ненты даты до за-
данной точности;
см. также Подраз-
дел 9.9.2 date_trunc(
'hour',
timestamp
'2001-02-16
20:38:40')
Отсекает
компо-
ненты даты до за-
данной точности;
см. также Подраз-
дел 9.9.2 date_trunc(
2 days 03:00:00
'hour',
interval
'2
days 3 hours 40
minutes')
2001-02-16
20:00:00
extract( field
from timestamp) double precision Возвращает поле extract(hour
20
даты; см. Подраз- from
timestamp
дел 9.9.1
'2001-02-16
20:38:40')
extract( field
from interval) double precision Возвращает поле extract(month
3
даты; см. Подраз- from interval '2
дел 9.9.1
years 3 months')
isfinite( date) boolean Проверяет конеч- isfinite(date
ность даты (её от- '2001-02-16')
личие от +/-беско-
нечности) true
isfinite(
timestamp) boolean Проверяет конеч-
ность времени (его
отличие от +/-бес-
конечности) true
isfinite(
interval) boolean Проверяет конеч- isfinite(
ность интервала
interval
hours') justify_days(
interval) interval Преобразует
ин- justify_days(
тервал так, что interval
'35
каждый 30-днев- days')
ный период счита-
ется одним меся-
цем 1 mon 5 days (1
месяц 5 дней)
justify_hours(
interval) interval Преобразует
ин- justify_hours(
тервал так, что interval
'27
каждый 24-часо- hours') 1 day 03:00:00 (
1 день 03:00:00)
231
isfinite(
timestamp
'2001-02-16
21:28:30')
true
'4Функции и операторы
Функция Тип результата Описание
Пример
вой период счита-
ется одним днём Результат
justify_
interval(
interval) interval Преобразует
ин-
тервал с приме-
нением justify_
days и justify_
hours и дополни-
тельно корректи-
рует знаки 29 days 23:00:00
(29
дней
23:00:00)
localtime time Текущее время су-
ток; см. Подраз-
дел 9.9.4 localtimestamp timestamp Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
justify_
interval(
interval '1 mon
-1 hour')
make_date( year date
int, month int,
day int) Образует дату из make_date(
полей: year (год), 2013, 7, 15)
month (месяц) и
day (день) 2013-07-15
make_interval( interval
years
int
DEFAULT
0,
months
int
DEFAULT 0, weeks
int DEFAULT 0,
days
int
DEFAULT 0, hours
int DEFAULT 0,
mins
int
DEFAULT 0, secs
double precision
DEFAULT 0.0) Образует
интер- make_interval(
вал из полей: years days => 10)
(годы), months (
месяцы), weeks (
недели), days (
дни), hours (часы),
minutes (минуты) и
secs (секунды) 10 days
make_time( hour time
int,
min int,
sec
double
precision) Образует время из make_time(8,
полей: hour (час), 15, 23.5)
minute (минута) и
sec (секунда) 08:15:23.5
make_timestamp( timestamp
year int, month
int,
day int,
hour int, min
int, sec double
precision) Образует дату и make_timestamp(
время из полей: 2013, 7, 15,
year (год), month ( 8, 15, 23.5)
месяц), day (день),
hour (час), minute (
минута) и sec (се-
кунда) 2013-07-15
08:15:23.5
make_ timestamp
timestamptz(
time zone
year int, month
int,
day int,
hour
int,
min int,
sec
double precision,
with Образует дату и make_
время с часовым timestamptz(
поясом из полей: 2013, 7, 15,
year (год), month ( 8, 15, 23.5)
месяц), day (день),
hour (час), minute
(минута) и sec (
секунда). Если па-
232
2013-07-15
08:15:23.5+01Функции и операторы
Функция
Тип результата
[ timezone
text])
Описание
Пример
раметр timezone (
часовой пояс) не
указан, использу-
ется текущий ча-
совой пояс.
now() timestamp
time zone with Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
statement_
timestamp() timestamp
time zone with Текущая дата и
время
(на
мо-
мент начала те-
кущего
операто-
ра); см. Подраз-
дел 9.9.4
timeofday() text transaction_
timestamp() timestamp
time zone with Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
to_timestamp(
double
precision) timestamp
time zone with Преобразует вре- to_timestamp(
мя эпохи Unix ( 1284352323)
число секунд с
1970-01-01
00:00:00+00)
в
стандартное вре-
мя
Результат
Текущая дата и
время (как clock_
timestamp , но в
виде строки типа
text); см. Подраз-
дел 9.9.4
2010-09-13
04:32:03+00
В дополнение к этим функциям поддерживается SQL-оператор OVERLAPS:
(начало1, конец1) OVERLAPS (начало2, конец2)
(начало1, длительность1) OVERLAPS (начало2, длительность2)
Его результатом будет true, когда два периода времени (определённые своими границами) пересе-
каются, и false в противном случае. Границы периода можно задать либо в виде пары дат, времени
или дат со временем, либо как дату, время (или дату со временем) c интервалом. Когда указывается
пара значений, первым может быть и начало, и конец периода: OVERLAPS автоматически считает
началом периода меньшее значение. Периоды времени считаются наполовину открытыми, т. е.
начало<=время<конец, если только начало и конец не равны — в этом случае период представляет
один момент времени. Это означает, например, что два периода, имеющие только общую границу,
не будут считаться пересекающимися.
SELECT (DATE '2001-02-16',
(DATE '2001-10-30',
Результат:true
SELECT (DATE '2001-02-16',
(DATE '2001-10-30',
Результат:false
SELECT (DATE '2001-10-29',
DATE '2001-12-21') OVERLAPS
DATE '2002-10-30');
INTERVAL '100 days') OVERLAPS
DATE '2002-10-30');
DATE '2001-10-30') OVERLAPS
233Функции и операторы
(DATE '2001-10-30', DATE '2001-10-31');
Результат:false
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
(DATE '2001-10-30', DATE '2001-10-31');
Результат:true
При добавлении к дате со временем типа timestamp with time zone значения interval (или при
вычитании из него interval), поле дней в этой дате увеличивается (или уменьшается) на указан-
ное число дней. При пересечении границы перехода на летнее время (если в часовом поясе те-
кущего сеанса производится этот переход) это означает, что interval '1 day' и interval '24
hours' не обязательно будут равны. Например, в часовом поясе CST7CDT результатом выражения
timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' будет timestamp with
time zone '2005-04-03 12:00-06', тогда как, если добавить interval '24 hours' к тому же зна-
чению timestamp with time zone, в результате получится timestamp with time zone '2005-04-03
13:00-06'. Эта разница объясняется тем, что 2005-04-03 02:00 в часовом поясе CST7CDT произо-
шёл переход на летнее время.
Обратите внимание на возможную неоднозначность в поле months в результате функции age, вы-
званную тем, что число дней в разных месяцах неодинаково. Вычисляя оставшиеся дни месяца,
PostgreSQL рассматривает месяц меньшей из двух дат. Например, результатом age('2004-06-01',
'2004-04-30') будет 1 mon 1 day, так как в апреле 30 дней, а то же выражение с датой 30 мая
выдаст 1 mon 2 days, так как в мае 31 день.
Вычитание дат и дат со временем также может быть нетривиальной операцией. Один принципи-
ально простой способ выполнить такое вычисление — преобразовать каждое значение в количе-
ство секунд, используя EXTRACT(EPOCH FROM ...), а затем найти разницу результатов; при этом
будет получено число секунд между двумя датами. При этом будет учтено неодинаковое число
дней в месяцах, изменения часовых поясов и переходы на летнее время. При вычитании дат или
дат со временем с помощью оператора «-» выдаётся число дней (по 24 часа) и часов/минут/секунд
между данными значениями, с учётом тех же факторов. Функция age возвращает число лет, меся-
цев, дней и часов/минут/секунд, выполняя вычитание по полям, а затем пересчитывая отрицатель-
ные значения. Различие этих подходов иллюстрируют следующие запросы. Показанные результа-
ты были получены для часового пояса 'US/Eastern'; между двумя заданными датами произошёл
переход на летнее время:
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
Результат:10537200
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
/ 60 / 60 / 24;
Результат:121.958333333333
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
Результат:121 days 23:00:00
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
Результат:4 mons
9.9.1. EXTRACT, date_part
EXTRACT(field FROM source)
Функция extract получает из значений даты/времени поля, такие как год или час. Здесь источ-
ник — значение типа timestamp, time или interval. (Выражения типа date приводятся к типу
timestamp, так что допускается и этот тип.) Указанное поле представляет собой идентификатор,
по которому из источника выбирается заданное поле. Функция extract возвращает значения типа
double precision. Допустимые поля:
century
Век:
234Функции и операторы
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
Результат:20
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:21
Первый век начался 0001-01-01 00:00:00, хотя люди в то время и не считали так. Это определе-
ние распространяется на все страны с григорианским календарём. Века с номером 0 нет было;
считается, что 1 наступил после -1. Если такое положение вещей вас не устраивает, направ-
ляйте жалобы по адресу: Ватикан, Собор Святого Петра, Папе.
day
Для значений timestamp это день месяца (1 - 31), для значений interval — число дней
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:16
SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
Результат:40
decade
Год, делённый на 10
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:200
dow
День недели, считая с воскресенья (0) до субботы (6)
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:5
Заметьте, что в extract дни недели нумеруются не так, как в функции to_char(..., 'D').
doy
День года (1 - 365/366)
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:47
epoch
Для значений timestamp with time zone это число секунд с 1970-01-01 00:00:00 UTC (может
быть отрицательным); для значений date и timestamp это число секунд с 1970-01-01 00:00:00
по местному времени, а для interval — общая длительность интервала в секундах
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE
'2001-02-16 20:38:40.12-08');
Результат:982384720.12
SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
Результат:442800
Преобразовать время эпохи назад, в значение дата/время, с помощью to_timestamp можно так:
SELECT to_timestamp(982384720.12);
Результат:2001-02-17 04:38:40.12+00
hour
Час (0 - 23)
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:20
235Функции и операторы
isodow
День недели, считая с понедельника (1) до воскресенья (7)
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
Результат:7
Результат отличается от dow только для воскресенья. Такая нумерация соответствует ISO 8601.
isoyear
Год по недельному календарю ISO 8601, в который попадает дата (неприменимо к интервалам)
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
Результат:2005
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
Результат:2006
Год по недельному календарю ISO начинается с понедельника недели, в которой оказывается
4 января, так что в начале января или в конце декабря год по ISO может отличаться от года по
григорианскому календарю. Подробнее об этом рассказывается в описании поля week.
Этого поля не было в PostgreSQL до версии 8.3.
microseconds
Значение секунд с дробной частью, умноженное на 1 000 000; заметьте, что оно включает и
целые секунды
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
Результат:28500000
millennium
Тысячелетие
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:3
Годы 20 века относятся ко второму тысячелетию. Третье тысячелетие началось 1 января 2001 г.
milliseconds
Значение секунд с дробной частью, умноженное на 1 000; заметьте, что оно включает и целые
секунды.
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
Результат:28500
minute
Минуты (0 - 59)
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:38
month
Для значений timestamp это номер месяца в году (1 - 12), а для interval — остаток от деления
числа месяцев на 12 (в интервале 0 - 11)
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:2
SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
Результат:3
SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
Результат:1
236Функции и операторы
quarter
Квартал года (1 - 4), к которому относится дата
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:1
second
1
Секунды, включая дробную часть (0 - 59 )
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:40
SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
Результат:28.5
timezone
Смещение часового пояса от UTC, представленное в секундах. Положительные значения соот-
ветствуют часовым поясам к востоку от UTC, а отрицательные — к западу. (Строго говоря, в
PostgreSQL используется не UTC, так как секунды координации не учитываются.)
timezone_hour
Поле часов в смещении часового пояса
timezone_minute
Поле минут в смещении часового пояса
week
Номер недели в году по недельному календарю ISO 8601. По определению, недели ISO 8601
начинаются с понедельника, а первая неделя года включает 4 января этого года. Другими сло-
вами, первый четверг года всегда оказывается в 1 неделе этого года.
В системе нумерации недель ISO первые числа января могут относиться к 52-ой или 53-ей неде-
ле предыдущего года, а последние числа декабря — к первой неделе следующего года. Напри-
мер, 2005-01-01 относится к 53-ей неделе 2004 г., а 2006-01-01 — к 52-ей неделе 2005 г., тогда
как 2012-12-31 включается в первую неделю 2013 г. Поэтому для получения согласованных
результатов рекомендуется использовать поле isoyear в паре с week.
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:7
year
Поле года. Учтите, что года 0 не было, и это следует иметь в виду, вычитая из годов нашей эры
годы до нашей эры.
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
Результат:2001
Примечание
С аргументом +/-бесконечность extract возвращает +/-бесконечность для монотонно
увеличивающихся полей (epoch, julian, year, isoyear, decade, century и millennium).
Для других полей возвращается NULL. До версии 9.6 PostgreSQL возвращал ноль для
всех случаев с бесконечными аргументами.
Функция extract в основном предназначена для вычислительных целей. Функции форматирования
даты/времени описаны в Разделе 9.8.
1
60, если операционная система поддерживает секунды координации
237Функции и операторы
Функция date_part эмулирует традиционный для Ingres эквивалент стандартной SQL-функции
extract:
date_part('поле', источник)
Заметьте, что здесь параметр поле должен быть строковым значением, а не именем. Функция
date_part воспринимает те же поля, что и extract.
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
Результат:16
SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
Результат:4
9.9.2. date_trunc
Функция date_trunc работает подобно trunc для чисел.
date_trunc('поле', значение)
Здесь значение — это выражение типа timestamp или interval. (Значения типов date и time ав-
томатически приводятся к типам timestamp и interval, соответственно.) Параметр поле опреде-
ляет, до какой точности обрезать переданное значение. Возвращаемое значение будет иметь тип
timestamp или interval и все его значения, менее значимые, чем заданное поле, будут равны нулю
(или единице, если это номер дня или месяца).
Параметр поле может принимать следующие значения:
microseconds
milliseconds
second
minute
hour
day
week
month
quarter
year
decade
century
millennium
Примеры:
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
Результат: 2001-02-16 20:00:00
SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
Результат: 2001-01-01 00:00:00
9.9.3. AT TIME ZONE
Указание AT TIME ZONE позволяет переводить дату/время без часового пояса в дату/время с часо-
вым поясом и обратно, а также пересчитывать значения времени для различных часовых поясов.
Все разновидности этого указания проиллюстрированы в Таблице 9.31.
Таблица 9.31. Разновидности AT TIME ZONE
Выражение
Тип результата
timestamp without time zone timestamp with time zone
AT TIME ZONE часовой_пояс
238
Описание
Воспринимает заданное время
без указания часового пояса
как время в указанном часовом
поясеФункции и операторы
Выражение
Тип результата
Описание
timestamp with time zone AT timestamp without time zone
TIME ZONE часовой_пояс Переводит данное значение
timestamp с часовым поясом в
другой часовой пояс, но не со-
храняет информацию о нём в ре-
зультате
time with time zone AT TIME time with time zone
ZONE часовой_пояс Переводит данное время с ча-
совым поясом в другой часовой
пояс
В этих выражениях желаемый часовой_пояс можно задать либо в виде текстовой строки (напри-
мер, 'America/Los_Angeles'), либо как интервал (например, INTERVAL '-08:00'). В первом случае
название часового пояса можно указать любым из способов, описанных в Подразделе 8.5.3.
Примеры (в предположении, что местный часовой пояс America/Los_Angeles):
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
Результат: 2001-02-16 19:38:40-08
SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
Результат: 2001-02-16 18:38:40
SELECT TIMESTAMP '2001-02-16 20:38:40-05' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE
'America/Chicago';
Результат: 2001-02-16 05:38:40
В первом примере для значения, заданного без часового пояса, указывается часовой пояс и по-
лученное время выводится в текущем часовом поясе (заданном параметром TimeZone). Во втором
примере значение времени смещается в заданный часовой пояс и выдаётся без указания часово-
го пояса. Этот вариант позволяет хранить и выводить значения с часовым поясом, отличным от
текущего. В третьем примере время в часовом поясе Токио пересчитывается для часового пояса
Чикаго. При переводе значений времени без даты в другие часовые пояса используются опреде-
ления часовых поясов, действующие в данный момент.
Функция timezone(часовой_пояс, время) равнозначна SQL-совместимой конструкции время AT
TIME ZONE часовой_пояс.
9.9.4. Текущая дата/время
PostgreSQL предоставляет набор функций, результат которых зависит от текущей даты и времени.
Все следующие функции соответствуют стандарту SQL и возвращают значения, отражающие вре-
мя начала текущей транзакции:
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(точность)
CURRENT_TIMESTAMP(точность)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(точность)
LOCALTIMESTAMP(точность)
CURRENT_TIME и CURRENT_TIMESTAMP возвращают время с часовым поясом. В результатах LOCALTIME
и LOCALTIMESTAMP нет информации о часовом поясе.
CURRENT_TIME, CURRENT_TIMESTAMP, LOCALTIME и LOCALTIMESTAMP могут принимать необязательный
параметр точности, определяющий, до какого знака после запятой следует округлять поле секунд.
Если этот параметр отсутствует, результат будет иметь максимально возможную точность.
Несколько примеров:
239Функции и операторы
SELECT CURRENT_TIME;
Результат: 14:39:53.662522-05
SELECT CURRENT_DATE;
Результат: 2001-12-23
SELECT CURRENT_TIMESTAMP;
Результат: 2001-12-23 14:39:53.662522-05
SELECT CURRENT_TIMESTAMP(2);
Результат: 2001-12-23 14:39:53.66-05
SELECT LOCALTIMESTAMP;
Результат: 2001-12-23 14:39:53.662522
Так как эти функции возвращают время начала текущей транзакции, во время транзакции эти зна-
чения не меняются. Это считается не ошибкой, а особенностью реализации: цель такого поведе-
ния в том, чтобы в одной транзакции «текущее» время было одинаковым и для разных изменений
в одной транзакций записывалась одна отметка времени.
Примечание
В других СУБД эти значения могут изменяться чаще.
В PostgreSQL есть также функции, возвращающие время начала текущего оператора, а также те-
кущее время в момент вызова функции. Таким образом, в PostgreSQL есть следующие функции, не
описанные в стандарте SQL:
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
Функция transaction_timestamp() равнозначна конструкции CURRENT_TIMESTAMP, но в её названии
явно отражено, что она возвращает. Функция statement_timestamp() возвращает время начала
текущего оператора (более точно, время получения последнего командного сообщения от клиен-
та). Функции statement_timestamp() и transaction_timestamp() возвращают одно и то же значе-
ние в первой команде транзакции, но в последующих их показания будут расходиться. Функция
clock_timestamp() возвращает фактическое текущее время, так что её значение меняется в рам-
ках одной команды SQL. Функция timeofday() существует в PostgreSQL по историческим причи-
нам и, подобно clock_timestamp(), она возвращает фактическое текущее время, но представлен-
ное в виде форматированной строки типа text, а не значения timestamp with time zone. Функция
now() — традиционный для PostgreSQL эквивалент функции transaction_timestamp().
Все типы даты/времени также принимают специальное буквальное значение now, подразумеваю-
щее текущую дату и время (тоже на момент начала транзакции). Таким образом, результат следу-
ющих трёх операторов будет одинаковым:
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now'; -- не подходит для DEFAULT
Подсказка
Третья форма не подходит для указания в качестве значения DEFAULT при создании
таблицы. Система преобразует now в значение timestamp в момент разбора константы,
поэтому, когда будет вставляться значение по умолчанию, в соответствующем столбце
окажется время создания таблицы! Первые две формы не будут вычисляться, пока не
240Функции и операторы
потребуется значение по умолчанию, так как это вызовы функции. Поэтому они дадут
желаемый результат при добавлении строки в таблицу.
9.9.5. Задержка выполнения
В случае необходимости вы можете приостановить выполнение серверного процесса, используя
следующие функции:
pg_sleep(сек)
pg_sleep_for(interval)
pg_sleep_until(timestamp with time zone)
Функция pg_sleep переводит процесс текущего сеанса в спящее состояние на указанное число се-
кунд (сек). Параметр сек имеет тип double precision, так что в нём можно указать и дробное чис-
ло. Функция pg_sleep_for введена для удобства, ей можно передать большие значения задержки
в типе interval. А pg_sleep_until удобнее использовать, когда необходимо задать определённое
время выхода из спящего состояния. Например:
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
Примечание
Действительное разрешение интервала задержки зависит от платформы; обычно это
0.01. Фактическая длительность задержки не будет меньше указанного времени, но
может быть больше, в зависимости, например от нагрузки на сервер. В частности, не
гарантируется, что pg_sleep_until проснётся именно в указанное время, но она точно
не проснётся раньше.
Предупреждение
Прежде чем вызывать pg_sleep или её вариации, убедитесь в том, что в текущем сеансе
нет ненужных блокировок. В противном случае в состояние ожидания могут перейти
и другие сеансы, так что это отразится на системе в целом.
9.10. Функции для перечислений
Для типов перечислений (описанных в Разделе 8.7) предусмотрено несколько функций, которые
позволяют сделать код чище, не «зашивая» в нём конкретные значения перечисления. Эти функ-
ции перечислены в Таблице 9.32. В этих примерах подразумевается, что перечисление создано так:
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green',
'blue', 'purple');
Таблица 9.32. Функции для перечислений
Функция Описание
Пример
enum_first(anyenum) Возвращает первое зна- enum_first(
чение заданного пере- null::rainbow)
числения red
enum_last(anyenum) Возвращает последнее enum_last(
значение заданного пе- null::rainbow)
речисления purple
enum_range(anyenum) Возвращает все значе- enum_range(
ния заданного перечис- null::rainbow) (red,orange,yellow,
green,blue,purple)
241
Результат примераФункции и операторы
Функция Описание
Пример
ления в упорядоченном
массиве Результат примера
enum_range(anyenum,
anyenum) Возвращает набор зна-
чений, лежащих меж-
ду двумя заданными,
в виде упорядоченного
массива. Эти значения
должны принадлежать
одному перечислению.
Если первый параметр
равен NULL, функция
возвращает первое зна-
чение перечисления, а
если NULL второй — по-
следнее. enum_range(
'orange'::rainbow,
'green'::rainbow) (orange,yellow,
green)
enum_range(NULL,
'green'::rainbow) (red,orange,yellow,
green)
enum_range(
'orange'::rainbow,
NULL) (orange,yellow,
green,blue,purple)
Заметьте, что за исключением варианта enum_range с двумя аргументами, эти функции не обра-
щают внимание на конкретное переданное им значение; их интересует только объявленный тип.
Они возвращают один и тот же результат, когда им передаётся NULL или любое другое значение
типа. Обычно эти функции применяются к столбцам таблицы или аргументам внешних функций,
а не к предопределённым типам, как показано в этих примерах.
9.11. Геометрические функции и операторы
Для геометрических типов point, box, lseg, line, path, polygon и circle разработан большой набор
встроенных функций и операторов, представленный в Таблице 9.33, Таблице 9.34 и Таблице 9.35.
Внимание
Заметьте, что оператор «идентичности», ~=, представляет обычное сравнение на ра-
венство значений point, box, polygon и circle. Для некоторых из этих типов опреде-
лён также оператор =, но = проверяет только равенство площадей. Другие скалярные
операторы сравнения (<= и т. д.) так же сравнивают площади значений этих типов.
Таблица 9.33. Геометрические операторы
Оператор Описание
Пример
+ Сдвиг
box '((0,0),(1,1))'
point '(2.0,0)'
+
- Сдвиг
box '((0,0),(1,1))'
point '(2.0,0)'
-
* Масштабирование/поворот
box '((0,0),(1,1))'
point '(2.0,0)'
*
/ Масштабирование/поворот
box '((0,0),(2,2))'
point '(2.0,0)'
/
# Точка или прямоугольник в пе- box '((1,-1),(-1,1))' #
ресечении
box '((1,1),(-2,-2))'
# Число точек в пути или вершин # path '((1,0),(0,1),(
в многоугольнике
-1,0))'
@-@ Длина, периметр
окружности
@@ Центр
или
длина @-@
0))'
path
'((0,0),(1,
@@ circle '((0,0),10)'
242Функции и операторы
Оператор Описание
Пример
## Точка, ближайшая к перво- point '(0,0)' ## lseg '((
му операнду и принадлежащая 2,0),(0,2))'
второму
<-> Расстояние между операндами circle '((0,0),1)'
circle '((5,0),1)'
&& Пересекаются ли операнды? ( box '((0,0),(1,1))' &&
Для положительного ответа до- box '((0,0),(2,2))'
статочно одной общей точки.)
<< Строго слева? circle
'((0,0),1)'
circle '((5,0),1)'
<<
>> Строго справа? circle
'((5,0),1)'
circle '((0,0),1)'
>>
&< Не простирается правее? box '((0,0),(1,1))' &<
box '((0,0),(2,2))'
&> Не простирается левее? box '((0,0),(3,3))' &>
box '((0,0),(2,2))'
<<| Строго ниже? box '((0,0),(3,3))' <<|
box '((3,4),(5,5))'
|>> Строго выше? box '((3,4),(5,5))' |>>
box '((0,0),(3,3))'
&<| Не простирается выше? box '((0,0),(1,1))' &<|
box '((0,0),(2,2))'
|&> Не простирается ниже? box '((0,0),(3,3))' |&>
box '((0,0),(2,2))'
<^ Ниже (может касаться)? circle
'((0,0),1)'
circle '((0,5),1)'
<^
>^ Выше (может касаться)? circle
'((0,5),1)'
circle '((0,0),1)'
>^
?# Пересекает? lseg '((-1,0),(1,0))' ?
# box '((-2,-2),(2,2))'
?- Горизонтальный объект? ?-
lseg
0))'
?- Выровнены по горизонтали? point '(1,0)' ?- point '(
0,0)'
?| Вертикальный объект? ?|
lseg
0))'
?| Выровнены по вертикали? point '(0,1)' ?| point '(
0,0)'
?-| Перпендикулярны? lseg
'((0,0),(0,
1))' ?-| lseg '((0,0),(
1,0))'
?|| Параллельны? lseg
'((-1,0),(1,
0))' ?|| lseg '((-1,2),(
1,2))'
@> Первый объект включает вто- circle
'((0,0),2)'
рой?
point '(1,1)'
243
<->
'((-1,0),(1,
'((-1,0),(1,
@>Функции и операторы
Оператор Описание
Пример
<@ Первый объект включён во вто- point '(1,1)' <@ circle '(
рой?
(0,0),2)'
~= Одинаковы?
polygon
'((0,0),(1,
1))' ~= polygon '((1,1),
(0,0))'
Примечание
До PostgreSQL 8.2 операторы включения @> и <@ назывались соответственно ~ и @. Эти
имена по-прежнему доступны, но считаются устаревшими и в конце концов будут уда-
лены.
Таблица 9.34. Геометрические функции
Функция Тип результата Описание Пример
area( объект) double precision площадь area(box '((0,0),
(1,1))')
center( объект) point центр center(box
0),(1,2))')
diameter( circle) double precision диаметр круга diameter(circle '((
0,0),2.0)')
height( box) double precision вертикальный размер height(box
прямоугольника
0),(1,1))')
isclosed( path) boolean замкнутый путь? isclosed(path
0,0),(1,1),(2,
0))')
isopen( path) boolean открытый путь? isopen(path
0),(1,1),(2,
0)]')
length( объект) double precision длина length(path '((-1,
0),(1,0))')
npoints( path) int число точек npoints(path
0),(1,1),(2,
0)]')
npoints( polygon) int число точек npoints(polygon '((
1,1),(0,0))')
pclose( path) path преобразует путь в за- pclose(path
мкнутый
0),(1,1),(2,
0)]')
popen( path) path преобразует путь в от- popen(path
'((0,
крытый
0),(1,1),(2,
0))')
radius( circle) double precision радиус окружности width( box) double precision горизонтальный
раз- width(box
мер прямоугольника
0),(1,1))')
244
radius(circle
0,0),2.0)')
'((0,
'((0,
'((
'[(0,
'[(0,
'[(0,
'((
'((0,Функции и операторы
Таблица 9.35. Функции преобразования геометрических типов
Функция Тип результата Описание
box( circle) box окружность
угольник
box( point) box точка в пустой прямо- box(point '(0,0)')
угольник
box точки в прямоугольник box(point '(0,0)',
point '(1,1)')
box( polygon) box многоугольник в пря- box(polygon '((0,
моугольник
0),(1,1),(2,
0))')
bound_box(
box) box прямоугольники в окру- bound_box(box '((
жающий прямоуголь- 0,0),(1,1))',
ник
box '((3,3),(
4,4))')
circle( box) circle прямоугольник
окружность
circle( point,
double precision) circle окружность из центра и circle(point
радиуса
0)', 2.0)
circle( polygon) circle многоугольник
окружность
в circle(polygon
0,0),(1,1),(2,
0))')
line( point, line точки в прямую
line(point
0)',
point
0)')
lseg диагональ прямоуголь- lseg(box
'((-1,
ника в отрезок
0),(1,0))')
lseg точки в отрезок
lseg(point
0)',
point
0)')
path многоугольник в путь
path(polygon '((0,
0),(1,1),(2,
0))')
point образует точку
point(23.4, -44.5)
point( box) point центр прямоугольника point(box
'((-1,
0),(1,0))')
point( circle) point центр окружности
point(circle '((0,
0),2.0)')
point( lseg) point центр отрезка
point(lseg '((-1,
0),(1,0))')
point( polygon) point центр многоугольника
point(polygon
0,0),(1,1),(2,
0))')
polygon( box) polygon прямоугольник в мно- polygon(box
гоугольник с 4 верши- 0),(1,1))')
нами
box( point,
point)
box,
point)
lseg( box)
lseg( point,
point)
path( polygon)
point( double
precision,
precision)
Пример
в
прямо- box(circle
0),2.0)')
в circle(box
0),(1,1))')
'((0,
'((0,
'(0,
'((
'(-1,
'(1,
'(-1,
'(1,
double
245
'((
'((0,Функции и операторы
Функция Тип результата Описание
Пример
polygon( circle) polygon круг в многоугольник с polygon(circle
12 вершинами
0,0),2.0)')
polygon( число_
точек, circle) polygon окружность с заданным polygon(12, circle
числом_точек
'((0,0),2.0)')
polygon( path) polygon путь в многоугольник
'((
polygon(path '((0,
0),(1,1),(2,
0))')
К двум компонентам типа point (точка) можно обратиться, как к элементам массива с индексами
0 и 1. Например, если t.p — столбец типа point, SELECT p[0] FROM t вернёт координату X, а UPDATE
t SET p[1] = ... изменит координату Y. Таким же образом, значение типа box или lseg можно
воспринимать как массив двух значений типа point.
Функция area работает с типами box, circle и path. При этом для типа path заданный путь
не должен быть самопересекающимся. Например, эта функция не примет значение типа path
'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH, но примет визуально идентичный путь
'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH. Если вы не вполне поняли,
что здесь подразумевается под самопересечением пути, нарисуйте на бумаге две фигуры по при-
ведённым координатам.
9.12. Функции и операторы для работы с сетевыми ад-
ресами
В Таблица 9.36 показаны операторы, работающие с типами cidr и inet. Операторы <<, <<=, >>, >>=
и && проверяют включения подсетей, рассматривая только биты сети в обоих адресах (игнорируя
биты узлов) и определяя, идентична ли одна сеть другой или её подсети.
Таблица 9.36. Операторы для типов cidr и inet
Оператор Описание Пример < меньше inet '192.168.1.5'
'192.168.1.6' < inet
<= меньше или равно inet '192.168.1.5'
'192.168.1.5' <= inet
= равно inet '192.168.1.5'
'192.168.1.5' = inet
>= больше или равно inet '192.168.1.5'
'192.168.1.5' >= inet
> больше inet '192.168.1.5'
'192.168.1.4' > inet
<> не равно inet '192.168.1.5'
'192.168.1.4' <> inet
<< содержится в inet '192.168.1.5'
'192.168.1/24' << inet
<<= равно или содержится в inet '192.168.1/24' <<= inet
'192.168.1/24'
>> содержит inet '192.168.1/24' >> inet
'192.168.1.5'
>>= равно или содержит inet '192.168.1/24' >>= inet
'192.168.1/24'
246Функции и операторы
Оператор Описание Пример
&& содержит или содержится в inet '192.168.1/24' && inet
'192.168.1.80/28'
~ битовый NOT ~ inet '192.168.1.6'
& битовый AND inet '192.168.1.6'
'0.0.0.255'
&
inet
| битовый OR inet '192.168.1.6'
'0.0.0.255'
|
inet
+ сложение inet '192.168.1.6' + 25
- вычитание inet '192.168.1.43' - 36
- вычитание inet '192.168.1.43'
'192.168.1.19'
-
inet
В Таблице 9.37 перечислены функции, работающие с типами cidr и inet. Функции abbrev, host и
text предназначены в основном для вывода данных в альтернативных форматах.
Таблица 9.37. Функции для типов cidr и inet
Функция Тип результата Описание abbrev( inet) text вывод
адрес
в abbrev(inet
кратком
тексто- '10.1.0.0/16')
вом виде 10.1.0.0/16
abbrev( cidr) text вывод
адрес
в abbrev(cidr
кратком
тексто- '10.1.0.0/16')
вом виде 10.1/16
broadcast( inet) inet широковещатель-
ный адрес сети 192.168.1.255/
24
family( inet) int возвращает семей- family('::1')
ство адреса; 4 для
адреса IPv4, 6 для
IPv6 6
host( inet) text извлекает IP-адрес host(
в виде текста
'192.168.1.5/
24') 192.168.1.5
hostmask( inet) inet вычисляет маску hostmask(
узла для сетевого '192.168.23.20/
адреса
30') 0.0.0.3
masklen( inet) int выдаёт длину мас- masklen(
ки сети
'192.168.1.5/
24') 24
netmask( inet) inet вычисляет маску netmask(
сети для сетевого '192.168.1.5/
адреса
24') 255.255.255.0
network( inet) cidr извлекает компо- network(
нент сети из адре- '192.168.1.5/
са
24') 192.168.1.0/24
set_masklen(
inet, int) inet задаёт размер мас- set_masklen(
ки для значения '192.168.1.5/
inet
24', 16) 192.168.1.5/16
247
Пример
broadcast(
'192.168.1.5/
24')
РезультатФункции и операторы
Функция Тип результата Описание
Пример
Результат
set_masklen(
cidr, int) cidr задаёт размер мас- set_masklen(
ки для значения '192.168.1.0/
cidr
24'::cidr, 16) 192.168.0.0/16
text( inet) text выводит в тексто- text(inet
вом виде IP-адрес и '192.168.1.5')
длину маски 192.168.1.5/32
inet_same_
family( inet,
inet) boolean адреса относятся inet_same_
false
к одному семей- family(
ству?
'192.168.1.5/24',
'::1')
inet_merge(
inet, inet) cidr наименьшая сеть, inet_merge(
192.168.0.0/22
включающая обе '192.168.1.5/24',
заданные сети
'192.168.2.5/24')
Любое значение cidr можно привести к типу inet, явно или нет; поэтому все функции, показанные
выше с типом inet, также будут работать со значениями cidr. (Некоторые из функций указаны
отдельно для типов inet и cidr, потому что их поведение с разными типами различается.) Кроме
того, значение inet тоже можно привести к типу cidr. При этом все биты справа от сетевой маски
просто обнуляются, чтобы значение стало допустимым для типа cidr. К типам inet и cidr можно
привести и обычные текстовые значения, используя обычный синтаксис, например: inet(выраже-
ние) или столбец::cidr.
В Таблице  9.38 приведена функция, предназначенная для работы с типом macaddr. Функция
trunc(macaddr) возвращает MAC-адрес, последние 3 байта в котором равны 0. Это может быть по-
лезно для вычисления префикса, определяющего производителя.
Таблица 9.38. Функции macaddr
Функция Тип результата Описание
Пример
trunc( macaddr) macaddr обнуляет послед- trunc(macaddr
ние 3 байта
'12:34:56:
78:90:ab')
Результат
12:34:56:
00:00:00
Тип macaddr также поддерживает стандартные реляционные операторы лексической сортировки
(>, <= и т. д.) и операторы битовой арифметики (~, & и |), соответствующие операциям NOT, AND
и OR.
В Таблице  9.39 приведены функции, предназначенные для работы с типом macaddr8. Функция
trunc(macaddr8) возвращает MAC-адрес, последние 5 байт в котором равны нулю. Это может быть
полезно для вычисления префикса, определяющего производителя.
Таблица 9.39. Функции macaddr8
Функция
Тип результата
Описание
Пример
Результат
trunc( macaddr8) macaddr8 обнуляет послед- trunc(macaddr8
12:34:56:00:00:00:00:0
ние 5 байт
'12:34:56:78:90:ab:cd:ef')
macaddr8_
set7bit(
macaddr8) устанавливает в 7
бите единицу, что-
бы получить так
называемый моди-
фицированный ад-
рес EUI-64 (для
включения в адрес
IPv6)
macaddr8
248
macaddr8_
02:34:56:ff:fe:ab:cd:eФункции и операторы
Тип macaddr8 также поддерживает стандартные реляционные операторы лексической сортировки
(>, <= и т. д.) и операторы битовой арифметики (~, & и |), соответствующие операциям NOT, AND
и OR.
9.13. Функции и операторы текстового поиска
В Таблице 9.40, Таблице 9.41 и Таблице 9.42 собраны все существующие функции и операторы,
предназначенные для полнотекстового поиска. Во всех деталях возможности полнотекстового по-
иска в PostgreSQL описаны в Главе 12.
Таблица 9.40. Операторы текстового поиска
Оператор Тип результата Описание
Пример
Результат
@@ boolean tsvector соответ- to_tsvector(
t
ствует tsquery ?
'fat cats ate
rats')
@@
to_
tsquery('cat &
rat')
@@@ boolean устаревший сино- to_tsvector(
t
ним для @@
'fat cats ate
rats') @@@ to_
tsquery('cat &
rat')
|| tsvector объединяет
значения
tsvector
&& tsquery логическое И ( 'fat
| ( 'fat' | 'rat' )
AND) двух запро- rat'::tsquery && & 'cat'
сов tsquery
'cat'::tsquery
|| tsquery логическое ИЛИ ( 'fat
| ( 'fat' | 'rat' )
OR) двух запросов rat'::tsquery || | 'cat'
tsquery
'cat'::tsquery
!! tsquery отрицание запро- !! 'cat'::tsquery !'cat'
са tsquery
<-> tsquery tsquery предше- to_tsquery(
ствует tsquery
'fat') <-> to_
tsquery('rat')
@> boolean запрос
tsquery 'cat'::tsquery @> f
включает другой? 'cat
&
rat'::tsquery
<@ boolean запрос
tsquery 'cat'::tsquery <@ t
включён в другой? 'cat
&
rat'::tsquery
два 'a:1
'a':1
'b':2,5
b:2'::tsvector || 'c':3 'd':4
'c:1
d:2
b:3'::tsvector
'fat' <-> 'rat'
Примечание
Операторы включения tsquery рассматривают только лексемы двух запросов, игнори-
руя операторы их сочетания.
В дополнение к операторам, перечисленным в этой таблице, для типов tsvector и tsquery опре-
делены обычные операторы сравнения для B-дерева (=, < и т. д.). Они не очень полезны для поиска,
но позволяют, в частности, создавать индексы для столбцов этих типов.
249Функции и операторы
Таблица 9.41. Функции текстового поиска
Функция Тип результата Описание
Пример
Результат
array_to_
tsvector(
text[]) tsvector преобразует мас- array_to_
сив
лексем
в tsvector(
tsvector
'(fat,cat,
rat)'::text[]) 'cat' 'fat' 'rat'
get_current_
ts_config() regconfig получает конфигу- get_current_
рацию текстового ts_config()
поиска по умолча-
нию english
length(
tsvector) integer число лексем
значении
tsvector numnode(
tsquery) integer число лексем и numnode('(fat &
5
операторов в за- rat)
|
просе tsquery
cat'::tsquery)
в length('fat:2,
3
4
cat:3
rat:5A'::tsvector)
plainto_
tsquery
tsquery(
[конфигурация
regconfig ,] за-
прос text) выдаёт значение plainto_
tsquery, игнори- tsquery(
руя пунктуацию
'english', 'The
Fat Rats') 'fat' & 'rat'
phraseto_
tsquery
tsquery(
[конфигурация
regconfig ,] за-
прос text) выдаёт значение
tsquery для поис-
ка фразы, игнори-
руя пунктуацию 'fat' <-> 'rat'
websearch_to_
tsquery
tsquery(
[конфигурация
regconfig ,] за-
прос text) преобразует в зна- websearch_to_
чение tsquery по- tsquery(
исковый запрос в 'english',
веб-стиле
'"fat rat" or
rat') querytree(
запрос tsquery) text получает индекси- querytree('foo
руемую часть за- &
проса tsquery
bar'::tsquery) setweight(
вектор tsvector,
вес "char") tsvector
phraseto_
tsquery(
'english', 'The
Fat Rats')
'fat' <-> 'rat' |
'rat'
'foo'
!
назначает
вес setweight(
'cat':3A
каждому элементу 'fat:2,4 cat:3
'fat':2A,4A
вектора
rat:5B'::tsvector, 'rat':5A
'A')
setweight(
tsvector
вектор tsvector,
вес "char", лек-
семы text[]) назначает вес эле- setweight(
'cat':3A 'fat':2,
ментам
вектора, 'fat:2,4 cat:3
4 'rat':5A
перечисленным в rat:5B'::tsvector,
массиве лексемы
'A', '(cat,
rat)')
strip( tsvector) tsvector убирает позиции и strip('fat:2,4
'cat' 'fat' 'rat'
веса из значения cat:3
tsvector
rat:5A'::tsvector)
to_tsquery(
tsquery
[конфигурация
regconfig ,] за-
прос text) нормализует слова to_tsquery(
и переводит их в 'english', 'The
tsquery
& Fat & Rats')
250
'fat' & 'rat'Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
to_tsvector(
tsvector
[конфигурация
regconfig ,] до-
кумент text) сокращает текст to_tsvector(
документа до зна- 'english', 'The
чения tsvector
Fat Rats') 'fat':2 'rat':3
to_tsvector(
tsvector
[конфигурация
regconfig ,] до-
кумент json(b) ) сокращает
каж-
дое строковое зна-
чение
в
доку-
менте до значе-
ния tsvector, а
затем складывает
эти значения по
порядку в доку-
менте и выдаёт
один tsvector to_tsvector(
'english',
'("a": "The Fat
Rats")'::json) 'fat':2 'rat':3
json(b)_to_
tsvector
tsvector(
[конфигурация
regconfig,]
до-
кумент json(b) ,
фильтр json(b) ) сокращает каждое
значение в до-
кументе, заданное
фильтром, до векто-
ра tsvector, а за-
тем соединяет их
в порядке следо-
вания в докумен-
те и получает один
tsvector. Фильтр
представляет со-
бой массив jsonb,
в котором пере-
числяются
типы
элементов, кото-
рые должны войти
в результирующий
tsvector. Возмож-
ные значения для
элементов филь-
тра: "string" (
включить все стро-
ковые значения),
"numeric" (вклю-
чить все числовые
значения в виде
строк), "boolean" (
включить все логи-
ческие значения
в
виде
"true"/
"false"), "key" (
включить все клю-
чи) или "all" (
включить всё вы-
шеперечислен-
ное). Эти значения
можно комбиниро-
вать для вклю-
чения, например,
всех строковых и json_to_
tsvector(
'english',
'("a":
"The
Fat Rats", "b":
123)'::json,
'["string",
"numeric"]') '123':5
'rat':3
251
'fat':2Функции и операторы
Функция Тип результата Описание
Пример
числовых
значе-
ний.
Результат
ts_delete(
вектор tsvector,
лексема text) tsvector удаляет заданную ts_delete(
'cat':3 'rat':5A
лексему из векто- 'fat:2,4 cat:3
ра
rat:5A'::tsvector,
'fat')
ts_delete(
вектор tsvector,
лексемы text[]) tsvector удаляет все вхож-
дения лексем, пе-
речисленных
в
массиве лексемы,
из вектора
ts_filter(
вектор tsvector,
веса "char"[]) tsvector выбирает из век- ts_filter(
'cat':3B 'rat':5A
тора только эле- 'fat:2,4 cat:3b
менты с заданным rat:5A'::tsvector,
весом
'(a,b)')
ts_delete(
'cat':3
'fat:2,4 cat:3
rat:5A'::tsvector,
ARRAY['fat',
'rat'])
ts_headline(
text
[конфигурация
regconfig,]
до-
кумент text, за-
прос tsquery [,
параметры text]) выводит
фраг- ts_headline('x
x y <b>z</b>
мент, соответству- y
z',
ющий запросу
'z'::tsquery)
ts_headline(
text
[конфигурация
regconfig,]
до-
кумент json(b) ,
запрос
tsquery
[,
параметры
text]) выводит
фраг- ts_headline(
мент, соответству- '("a":"x
y
ющий запросу
z")'::json,
'z'::tsquery) ("a":"x y <b>z</
b>")
ts_rank([ веса float4
float4[],]
век-
тор
tsvector,
запрос
tsquery
[,
нормализация
integer]) вычисляет
ранг ts_rank(
документа по от- textsearch,
ношению к запро- query)
су 0.818
ts_rank_cd(
float4
[веса float4[],]
вектор tsvector,
запрос
tsquery
[,
нормализация
integer]) вычисляет
ранг ts_rank_cd(
документа по от- '(0.1,
0.2,
ношению к за-
0.4, 1.0)',
просу, используя
textsearch,
плотность покры- query)
тия (CDR) 2.01317
ts_rewrite(
запрос tsquery,
цель
tsquery,
замена tsquery) tsquery подставляет в за- ts_rewrite('a &
просе вместо цели b'::tsquery,
замену
'a'::tsquery,
'foo|
bar'::tsquery) 'b' & ( 'foo' |
'bar' )
ts_rewrite(
запрос tsquery,
выборка text) tsquery заменяет элемен-
ты запроса, выби-
рая цели и под-
становки
коман-
дой SELECT
252
SELECT
ts_ 'b' & ( 'foo' |
rewrite('a
&
'bar' )
b'::tsquery,
'SELECT t,s
FROM aliases')Функции и операторы
Функция
Тип результата
Описание Пример Результат
tsquery_
tsquery
phrase( запрос1
tsquery, запрос2
tsquery) создаёт запрос, ко-
торый ищет за-
прос1, за кото-
рым идёт запрос2 (
как делает опера-
тор <->) tsquery_phrase(
to_tsquery(
'fat'),
to_
tsquery(
'cat')) 'fat' <-> 'cat'
tsquery_
tsquery
phrase( запрос1
tsquery, запрос2
tsquery, рассто-
яние integer) создаёт запрос, ко-
торый ищет за-
прос1, за которым
идёт запрос2 на
заданном рассто-
янии tsquery_phrase(
to_tsquery(
'fat'),
to_
tsquery(
'cat'), 10) 'fat' <10> 'cat'
tsvector_to_
array(
tsvector) text[] преобразует
tsvector_to_
(cat,fat,rat)
tsvector в массив array('fat:2,
лексем
4
cat:3
rat:5A'::tsvector)
tsvector_
update_
trigger() trigger триггерная функ-
ция для автома-
тического измене-
ния столбца типа
tsvector CREATE
TRIGGER
...
tsvector_
update_
trigger(
tsvcol,
'pg_
catalog.
swedish',
title, body) tsvector_
update_
trigger_
column() trigger триггерная функ-
ция для автома-
тического измене-
ния столбца типа
tsvector CREATE
TRIGGER
...
tsvector_
update_
trigger_
column(tsvcol,
configcol,
title, body)
unnest(
setof record
tsvector,
OUT
лексема
text,
OUT
позиции
smallint[], OUT
веса text)
разворачивает
unnest('fat:2,
(cat,(3),
tsvector в набор 4
cat:3 (D)) ...
строк
rat:5A'::tsvector)
Примечание
Все функции текстового поиска, принимающие необязательный аргумент regconfig,
будут использовать конфигурацию, указанную в параметре default_text_search_config,
когда этот аргумент опущен.
Функции в Таблице  9.42 перечислены отдельно, так как они не очень полезны в традиционных
операциях поиска. Они предназначены в основном для разработки и отладки новых конфигураций
текстового поиска.
253Функции и операторы
Таблица 9.42. Функции отладки текстового поиска
Функция
Тип результата
Описание
Пример
Результат
ts_debug(
setof record
[конфигурация
regconfig,]
до-
кумент
text,
OUT
псевдоним
text, OUT
опи-
сание text, OUT
фрагмент
text,
OUT
словари
regdictionary[],
OUT
словарь
regdictionary,
OUT
лексемы
text[]) проверяет конфи- ts_debug(
гурацию
'english', 'The
Brightest
supernovaes') (asciiword,
"Word,
all
ASCII",The,(
english_stem
),english_
stem,()) ...
ts_lexize(
словарь
regdictionary,
фрагмент text) проверяет словарь ts_lexize(
'english_
stem', 'stars') (star)
ts_parse( имя_ setof record
анализатора
text,
доку-
мент
text,
OUT код_фрагмен-
та integer, OUT
фрагмент text) проверяет
затор анали- ts_parse(
'default', 'foo
- bar') (1,foo) ...
ts_parse( oid_
анализатора oid,
документ
text,
OUT код_фрагмен-
та integer, OUT
фрагмент text) проверяет
затор анали- ts_parse(3722,
'foo - bar') (1,foo) ...
text[]
setof record
ts_token_
setof record
type( имя_
анализатора
text, OUT код_
фрагмента
integer,
OUT
псевдоним text,
OUT
описание
text) получает
типы ts_token_type(
фрагментов, опре- 'default')
делённые анализа-
тором (1,asciiword,
"Word,
all
ASCII") ...
ts_token_
setof record
type( oid_
анализатора oid,
OUT
код_фраг-
мента
integer,
OUT
псевдоним
text, OUT описа-
ние text) получает
типы ts_token_type(
фрагментов, опре- 3722)
делённые анализа-
тором (1,asciiword,
"Word,
all
ASCII") ...
ts_stat(
запрос
[веса получает
стати- ts_stat(
стику
столбца 'SELECT
vector
tsvector
from apod') (foo,10,
15) ...
sql_
text,
text,
setof record
254Функции и операторы
Функция
Тип результата
]
OUT
слово
text, OUT
чис-
ло_док integer,
OUT число_вхожд
integer)
Описание
Пример
Результат
9.14. XML-функции
Функции и подобные им выражения, описанные в этом разделе, работают со значениями типа xml.
Информацию о типе xml вы можете найти в Разделе 8.13. Выражения xmlparse и xmlserialize,
преобразующие значения xml в текст и обратно, здесь повторно не рассматриваются. Для исполь-
зования большинства этих функций дистрибутив должен быть собран с ключом configure --with-
libxml.
9.14.1. Создание XML-контента
Для получения XML-контента из данных SQL существует целый набор функций и функциональных
выражений, особенно полезных для выдачи клиентским приложениям результатов запроса в виде
XML-документов.
9.14.1.1. xmlcomment
xmlcomment(текст)
Функция xmlcomment создаёт XML-значение, содержащее XML-комментарий с заданным текстом.
Этот текст не должен содержать «--» или заканчиваться знаком «-», чтобы результирующая кон-
струкция была допустимой в XML. Если аргумент этой функции NULL, результатом её тоже будет
NULL.
Пример:
SELECT xmlcomment('hello');
xmlcomment
--------------
<!--hello-->
9.14.1.2. xmlconcat
xmlconcat(xml[, ...])
Функция xmlconcat объединяет несколько XML-значений и выдаёт в результате один фрагмент
XML-контента. Значения NULL отбрасываются, так что результат будет равен NULL, только если
все аргументы равны NULL.
Пример:
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');
xmlconcat
----------------------
<abc/><bar>foo</bar>
XML-объявления, если они присутствуют, обрабатываются следующим образом. Если во всех ар-
гументах содержатся объявления одной версии XML, эта версия будет выдана в результате; в про-
тивном случае версии не будет. Если во всех аргументах определён атрибут standalone со значе-
нием «yes», это же значение будет выдано в результате. Если во всех аргументах есть объявление
standalone, но минимум в одном со значением «no», в результате будет это значение. В противном
255Функции и операторы
случае в результате не будет объявления standalone. Если же окажется, что в результате должно
присутствовать объявление standalone, а версия не определена, тогда в результате будет выведена
версия 1.0, так как XML-объявление не будет допустимым без указания версии. Указания кодиров-
ки игнорируются и будут удалены в любых случаях.
Пример:
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?
><bar/>');
xmlconcat
-----------------------------------
<?xml version="1.1"?><foo/><bar/>
9.14.1.3. xmlelement
xmlelement(name имя [, xmlattributes(значение [AS атрибут] [, ...])]
[, содержимое, ...])
Выражение xmlelement создаёт XML-элемент с заданным именем, атрибутами и содержимым.
Примеры:
SELECT xmlelement(name foo);
xmlelement
------------
<foo/>
SELECT xmlelement(name foo, xmlattributes('xyz' as bar));
xmlelement
------------------
<foo bar="xyz"/>
SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');
xmlelement
-------------------------------------
<foo bar="2007-01-26">content</foo>
Если имена элементов и атрибутов содержат символы, недопустимые в XML, эти символы заме-
няются последовательностями _xHHHH_, где HHHH — шестнадцатеричный код символа в Unicode.
Например:
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));
xmlelement
----------------------------------
<foo_x0024_bar a_x0026_b="xyz"/>
Если в качестве значения атрибута используется столбец таблицы, имя атрибута можно не указы-
вать явно, этим именем станет имя столбца. Во всех остальных случаях имя атрибута должно быть
определено явно. Таким образом, это выражение допустимо:
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
А следующие варианты — нет:
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
256Функции и операторы
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
Содержимое элемента, если оно задано, будет форматировано согласно его типу данных. Когда
оно само имеет тип xml, из него можно конструировать сложные XML-документы. Например:
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
xmlelement(name abc),
xmlcomment('test'),
xmlelement(name xyz));
xmlelement
----------------------------------------------
<foo bar="xyz"><abc/><!--test--><xyz/></foo>
Содержимое других типов будет оформлено в виде блока символьных данных XML. Это, в частно-
сти, означает, что символы <, > и & будут преобразованы в сущности XML. Двоичные данные (дан-
ные типа bytea) представляются в кодировке base64 или в шестнадцатеричном виде, в зависимо-
сти от значения параметра xmlbinary. Следует ожидать, что конкретные представления отдельных
типов данных могут быть изменены для приведения типов SQL и PostgreSQL в соответствие со
стандартом XML Schema, когда появится его более полное описание.
9.14.1.4. xmlforest
xmlforest(содержимое [AS имя] [, ...])
Выражение xmlforest создаёт последовательность XML-элементов с заданными именами и содер-
жимым.
Примеры:
SELECT xmlforest('abc' AS foo, 123 AS bar);
xmlforest
------------------------------
<foo>abc</foo><bar>123</bar>
SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';
xmlforest
-------------------------------------------------------------------------------------------
<table_name>pg_authid</table_name><column_name>rolname</column_name>
<table_name>pg_authid</table_name><column_name>rolsuper</column_name>
...
Как показано во втором примере, имя элемента можно опустить, если источником содержимого
служит столбец (в этом случае именем элемента по умолчанию будет имя столбца). В противном
случае это имя необходимо указывать.
Имена элементов с символами, недопустимыми для XML, преобразуются так же, как и для
xmlelement. Данные содержимого тоже приводятся к виду, допустимому для XML (кроме данных,
которые уже имеют тип xml).
Заметьте, что такие XML-последовательности не являются допустимыми XML-документами, если
они содержат больше одного элемента на верхнем уровне, поэтому может иметь смысл вложить
выражения xmlforest в xmlelement.
9.14.1.5. xmlpi
257Функции и операторы
xmlpi(name цель [, содержимое])
Выражение xmlpi создаёт инструкцию обработки XML. Содержимое, если оно задано, не должно
содержать последовательность символов ?>.
Пример:
SELECT xmlpi(name php, 'echo "hello world";');
xmlpi
-----------------------------
<?php echo "hello world";?>
9.14.1.6. xmlroot
xmlroot(xml, version текст | нет значения [, standalone yes|no|нет значения])
Выражение xmlroot изменяет свойства корневого узла XML-значения. Если в нём указывается
версия, она заменяет значение в объявлении версии корневого узла; также в корневой узел пере-
носится значение свойства standalone.
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
version '1.0', standalone yes);
xmlroot
----------------------------------------
<?xml version="1.0" standalone="yes"?>
<content>abc</content>
9.14.1.7. xmlagg
xmlagg(xml)
Функция xmlagg, в отличие от других описанных здесь функций, является агрегатной. Она соеди-
няет значения, поступающие на вход агрегатной функции, подобно функции xmlconcat, но делает
это, обрабатывая множество строк, а не несколько выражений в одной строке. Дополнительно аг-
регатные функции описаны в Разделе 9.20.
Пример:
CREATE
INSERT
INSERT
SELECT
TABLE test (y int, x xml);
INTO test VALUES (1, '<foo>abc</foo>');
INTO test VALUES (2, '<bar/>');
xmlagg(x) FROM test;
xmlagg
----------------------
<foo>abc</foo><bar/>
Чтобы задать порядок сложения элементов, в агрегатный вызов можно добавить предложение
ORDER BY, описанное в Подраздел 4.2.7. Например:
SELECT xmlagg(x ORDER BY y DESC) FROM test;
xmlagg
----------------------
<bar/><foo>abc</foo>
Следующий нестандартный подход рекомендовался в предыдущих версиях и может быть по-преж-
нему полезен в некоторых случаях:
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
xmlagg
258Функции и операторы
----------------------
<bar/><foo>abc</foo>
9.14.2. Условия с XML
Описанные в этом разделе выражения проверяют свойства значений xml.
9.14.2.1. IS DOCUMENT
xml IS DOCUMENT
Выражение IS DOCUMENT возвращает true, если аргумент представляет собой правильный XML-
документ, false в противном случае (т. е. если это фрагмент содержимого) и NULL, если его аргу-
мент также NULL. Чем документы отличаются от фрагментов содержимого, вы можете узнать в
Разделе 8.13.
9.14.2.2. IS NOT DOCUMENT
xml IS NOT DOCUMENT
Выражение IS NOT DOCUMENT возвращает false, если аргумент представляет собой правильный
XML-документ, true в противном случае (т. е. если это фрагмент содержимого) и NULL, если его
аргумент — NULL.
9.14.2.3. XMLEXISTS
XMLEXISTS(текст
PASSING [BY REF] xml [BY REF])
Функция xmlexists возвращает true, если выражение XPath в первом аргументе возвращает какие
либо узлы, и false — в противном случае. (Если один из аргументов равен NULL, результатом также
будет NULL.)
Пример:
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Toronto</
town><town>Ottawa</town></towns>');
xmlexists
------------
t
(1 row)
Указания BY REF не несут смысловой нагрузки в PostgreSQL, но могут присутствовать для соответ-
ствия стандарту SQL и совместимости с другими реализациями. По стандарту SQL первое указа-
ние BY REF является обязательным, а второе — нет. Также заметьте, что, согласно стандарту SQL,
конструкция xmlexists должна принимать в первом аргументе выражение XQuery, но PostgreSQL
в настоящее время поддерживает только XPath, подмножество XQuery.
9.14.2.4. xml_is_well_formed
xml_is_well_formed(текст)
xml_is_well_formed_document(текст)
xml_is_well_formed_content(текст)
Эти функции проверяют, является ли текст правильно оформленным XML, и возвращают соответ-
ствующее логическое значение. Функция xml_is_well_formed_document проверяет аргумент как
правильно оформленный документ, а xml_is_well_formed_content — правильно оформленное со-
держание. Функция xml_is_well_formed может делать первое или второе, в зависимости от значе-
ния параметра конфигурации xmloption (DOCUMENT или CONTENT, соответственно). Это значит, что
259Функции и операторы
xml_is_well_formed помогает понять, будет ли успешным простое приведение к типу xml, тогда
как две другие функции проверяют, будут ли успешны соответствующие варианты XMLPARSE.
Примеры:
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
xml_is_well_formed
--------------------
f
(1 row)
SELECT xml_is_well_formed('<abc/>');
xml_is_well_formed
--------------------
t
(1 row)
SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
xml_is_well_formed
--------------------
t
(1 row)
SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/
stuff">bar</pg:foo>');
xml_is_well_formed_document
-----------------------------
t
(1 row)
SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/
stuff">bar</my:foo>');
xml_is_well_formed_document
-----------------------------
f
(1 row)
Последний пример показывает, что при проверке также учитываются сопоставления пространств
имён.
9.14.3. Обработка XML
Для обработки значений типа xml в PostgreSQL представлены функции xpath и xpath_exists, вы-
числяющие выражения XPath 1.0, а также табличная функция XMLTABLE.
9.14.3.1. xpath
xpath(xpath, xml [, nsarray])
Функция xpath вычисляет выражение XPath (аргумент xpath типа text) для заданного xml. Она
возвращает массив XML-значений с набором узлов, полученных в результате выражения XPath.
Если выражение XPath выдаёт не набор узлов, а скалярное значение, возвращается массив из од-
ного элемента.
Вторым аргументом должен быть правильно оформленный XML-документ. В частности, в нём дол-
жен быть единственный корневой элемент.
В необязательном третьем аргументе функции передаются сопоставления пространств имён. Эти
сопоставления должны определяться в двумерном массиве типа text, во второй размерности ко-
260Функции и операторы
торого 2 элемента (т. е. это должен быть массив массивов, состоящих из 2 элементов). В первом
элементе каждого массива определяется псевдоним (префикс) пространства имён, а во втором —
его URI. Псевдонимы, определённые в этом массиве, не обязательно должны совпадать с префик-
сами пространств имён в самом XML-документе (другими словами, для XML-документа и функции
xpath псевдонимы имеют локальный характер).
Пример:
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
ARRAY[ARRAY['my', 'http://example.com']]);
xpath
--------
(test)
(1 row)
Для пространства имён по умолчанию (анонимного) это выражение можно записать так:
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
ARRAY[ARRAY['mydefns', 'http://example.com']]);
xpath
--------
(test)
(1 row)
9.14.3.2. xpath_exists
xpath_exists(xpath, xml [, nsarray])
Функция xpath_exists представляет собой специализированную форму функции xpath. Она воз-
вращает не весь набор XML-узлов, удовлетворяющих выражению XPath, а только одно логическое
значение, показывающее, есть ли такие узлы. Эта функция равнозначна стандартному условию
XMLEXISTS, за исключением того, что она также поддерживает сопоставления пространств имён.
Пример:
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
ARRAY[ARRAY['my', 'http://example.com']]);
xpath_exists
--------------
t
(1 row)
9.14.3.3. xmltable
xmltable( [XMLNAMESPACES(URI пространства имён AS имя пространства имён[, ...]),]
выражение_строки PASSING [BY REF] выражение_документа [BY REF]
COLUMNS имя ( type [PATH выражение_столбца] [DEFAULT выражение_по_умолчанию]
[NOT NULL | NULL]
| FOR ORDINALITY )
[, ...]
)
Функция xmltable строит таблицу из данного XML-значения по фильтру XPath, извлекающему
строки, с необязательным набором определений столбцов.
Необязательное предложение XMLNAMESPACES задаёт разделённый запятыми список пространств
имён. В нём определяются пространства имён XML и их псевдонимы. Определение пространства
по умолчанию в настоящее время не поддерживается.
261Функции и операторы
Обязательный аргумент выражение_строки задаёт выражение XPath, вычисляемое в данном XML-
документе и выдающее упорядоченную последовательность XML-узлов. Эту последовательность
xmltable преобразует в выходные строки.
В аргументе выражение_документа передаётся XML-документ для обработки. Предложения BY REF
не действуют в PostgreSQL, но допускаются для соответствия стандарту SQL и совместимости
с другими реализациями. Передаваемый XML-документ должен быть правильно оформленным;
фрагменты/леса не принимаются.
В предложении COLUMNS задаётся список столбцов в выходной таблице. Если предложение COLUMNS
опускается, строки в результирующем наборе содержат один столбец типа xml с данными, кото-
рые отобрало выражение_строки. Если COLUMNS присутствует, каждый его элемент описывает один
столбец. Формат этого предложения показан выше в примере синтаксиса. Имя столбца и его тип
должны задаваться обязательно: путь, значение по умолчанию и признак допустимости NULL мо-
гут опускаться.
Столбец с признаком FOR ORDINALITY будет заполняться номерами строк, соответствующими по-
рядку, в котором строки находились в исходном документе XML. Признак FOR ORDINALITY может
быть не больше чем у одного столбца.
В указании выражение_столбца для столбца задаётся выражение XPath, вычисляемое для каждой
строки относительно результата выражение_строки и выдающее значение столбца. Если выраже-
ние_столбца отсутствует, в качестве неявного пути используется имя столбца.
Если выражение XPath для столбца выдаёт несколько элементов, происходит ошибка. Если вы-
ражению соответствует пустой элемент, результатом будет пустая строка (не NULL). Атрибуты
xsi:nil при поиске игнорируются.
Значением столбца становится текстовое содержимое XML-узла, отобранного выражением_столб-
ца. Несколько узлов text() внутри целевого элемента складываются вместе по порядку. Все до-
черние элементы, инструкции обработки и комментарии игнорируются, но текстовое содержи-
мое дочерних элементов добавляется к результату. Заметьте, что исключительно пробельные узлы
text() между двумя не текстовыми элементами сохраняются, как не убираются и ведущие пробе-
лы в узле text().
Если выражение пути не находит элемент строки, но задано выражение_по_умолчанию, значением
поля становится результат вычисления этого выражения. Если предложение DEFAULT для этого
столбца отсутствует, в это поле записывается NULL. В выражении_по_умолчанию можно обращаться
к значениям выходных столбцов, описанных ранее в списке столбцов, так что значение по умол-
чанию одного столбца можно получить из значения другого.
Столбцы могут иметь признак NOT NULL. Если выражение_столбца для столбца с признаком NOT NULL
не соответствует ничему и при этом отсутствует указание DEFAULT или выражение_по_умолчанию
также выдаёт NULL, происходит ошибка.
В отличие от обычных функций PostgreSQL, выражение_столбца и выражение_по_умолчанию не сво-
дятся к единственному простому значению перед вызовом функции. Так, выражение_столбца обыч-
но вычисляется ровно один раз для каждой входной строки, а выражение_по_умолчанию вычисля-
ется каждый раз, когда для поля требуется значение по умолчанию. Если выражение оказывается
стабильным или постоянным, повторное вычисление может не выполняться. По сути xmltable дей-
ствует больше как подзапрос, а не как вызов функции. Это значит, что вы можете с пользой при-
менять изменчивые функции, такие как nextval в выражении_по_умолчанию, а выражение_столбца
может зависеть от других частей XML-документа.
Примеры:
CREATE TABLE xmldata AS SELECT
xml $$
262Функции и операторы
<ROWS>
<ROW id="1">
<COUNTRY_ID>AU</COUNTRY_ID>
<COUNTRY_NAME>Australia</COUNTRY_NAME>
</ROW>
<ROW id="5">
<COUNTRY_ID>JP</COUNTRY_ID>
<COUNTRY_NAME>Japan</COUNTRY_NAME>
<PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
<SIZE unit="sq_mi">145935</SIZE>
</ROW>
<ROW id="6">
<COUNTRY_ID>SG</COUNTRY_ID>
<COUNTRY_NAME>Singapore</COUNTRY_NAME>
<SIZE unit="sq_km">697</SIZE>
</ROW>
</ROWS>
$$ AS data;
SELECT xmltable.*
FROM xmldata,
XMLTABLE('//ROWS/ROW'
PASSING data
COLUMNS id int PATH '@id',
ordinality FOR ORDINALITY,
"COUNTRY_NAME" text,
country_id text PATH 'COUNTRY_ID',
size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
size_other text PATH
'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/
@unit)',
premier_name text PATH 'PREMIER_NAME' DEFAULT 'not
specified') ;
id | ordinality | COUNTRY_NAME | country_id | size_sq_km |
size_other
| premier_name
----+------------+--------------+------------+------------+--------------
+---------------
1 |
1 | Australia
| AU
|
|
| not
specified
5 |
2 | Japan
| JP
|
| 145935 sq_mi | Shinzo Abe
6 |
3 | Singapore
| SG
|
697 |
| not
specified
Следующий пример иллюстрирует сложение нескольких узлов text(), использование имени столб-
ца в качестве фильтра XPath и обработку пробельных символов, XML-комментариев и инструкций
обработки:
CREATE TABLE xmlelements AS SELECT
xml $$
<root>
<element> Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->
</root>
$$ AS data;
bbb<x>xxx</x>CC
SELECT xmltable.*
FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
element
----------------------
263
</element>Функции и операторы
Hello2a2
bbbCC
Следующий пример показывает, как с помощью предложения XMLNAMESPACES можно задать список
пространств имён, используемых в XML-документе и в выражениях XPath:
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
<item foo="1" B:bar="2"/>
<item foo="3" B:bar="4"/>
<item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
'http://example.com/b' AS "B"),
'/x:example/x:item'
PASSING (SELECT data FROM xmldata)
COLUMNS foo int PATH '@foo',
bar int PATH '@B:bar');
foo | bar
-----+-----
1 |
2
3 |
4
4 |
5
(3 rows)
9.14.4. Отображение таблиц в XML
Следующие функции отображают содержимое реляционных таблиц в значения XML. Их можно
рассматривать как средства экспорта в XML:
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
tableforest boolean, targetns text)
Результат всех этих функций имеет тип xml.
table_to_xml отображает в xml содержимое таблицы, имя которой задаётся в параметре tbl. Тип
regclass принимает идентификаторы строк в обычной записи, которые могут содержать указание
схемы и кавычки. Функция query_to_xml выполняет запрос, текст которого передаётся в парамет-
ре query, и отображает в xml результирующий набор. Последняя функция, cursor_to_xml выбира-
ет указанное число строк из курсора, переданного в параметре cursor. Этот вариант рекоменду-
ется использовать с большими таблицами, так как все эти функции создают результирующий xml
в памяти.
Если параметр tableforest имеет значение false, результирующий XML-документ выглядит так:
<имя_таблицы>
<row>
<имя_столбца1> данные </имя_столбца1>
<имя_столбца2> данные </имя_столбца2>
</row>
<row>
...
</row>
...
</имя_таблицы>
264Функции и операторы
А если tableforest равен true, в результате будет выведен следующий фрагмент XML:
<имя_таблицы>
<имя_столбца1> данные </имя_столбца1>
<имя_столбца2> данные </имя_столбца2>
</имя_таблицы>
<имя_таблицы>
...
</имя_таблицы>
...
Если имя таблицы неизвестно, например, при отображении результатов запроса или курсора, вме-
сто него в первом случае вставляется table, а во втором — row.
Выбор между этими форматами остаётся за пользователем. Первый вариант позволяет создать
готовый XML-документ, что может быть полезно для многих приложений, а второй удобно приме-
нять с функцией cursor_to_xml, если её результаты будут собираться в документ позже. Получен-
ный результат можно изменить по вкусу с помощью рассмотренных выше функций создания XML-
содержимого, в частности xmlelement.
Значения данных эти функции отображают так же, как и ранее описанная функция xmlelement.
Параметр nulls определяет, нужно ли включать в результат значения NULL. Если он установлен,
значения NULL в столбцах представляются так:
<имя_столбца xsi:nil="true"/>
Здесь xsi — префикс пространства имён XML Schema Instance. При этом в результирующий XML
будет добавлено соответствующее объявление пространства имён. Если же данный параметр ра-
вен false, столбцы со значениями NULL просто не будут выводиться.
Параметр targetns определяет целевое пространство имён для результирующего XML. Если про-
странство имён не нужно, значением этого параметра должна быть пустая строка.
Следующие функции выдают документы XML Schema, которые содержат схемы отображений, вы-
полняемых соответствующими ранее рассмотренными функциями:
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean,
targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,
targetns text)
Чтобы результаты отображения данных в XML соответствовали XML-схемам, важно, чтобы паре
функций передавались одинаковые параметры.
Следующие функции выдают отображение данных в XML и соответствующую XML-схему в одном
документе (или фрагменте), объединяя их вместе. Это может быть полезно там, где желательно
получить самодостаточные результаты с описанием:
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,
targetns text)
В дополнение к ним есть следующие функции, способные выдать аналогичные представления для
целых схем в базе данных или даже всей текущей базы данных:
schema_to_xml(schema name, nulls boolean, tableforest boolean,
265Функции и операторы
targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean,
targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean,
targetns text)
database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,
targetns text)
Заметьте, что объём таких данных может быть очень большим, а XML будет создаваться в памяти.
Поэтому, вместо того, чтобы пытаться отобразить в XML сразу всё содержимое больших схем или
баз данных, лучше делать это по таблицам, возможно даже используя курсор.
Результат отображения содержимого схемы будет выглядеть так:
<имя_схемы>
отображение-таблицы1
отображение-таблицы2
...
</имя_схемы>
Формат отображения таблицы определяется параметром tableforest, описанным выше.
Результат отображения содержимого базы данных будет таким:
<имя_схемы>
<имя_схемы1>
...
</имя_схемы1>
<имя_схемы2>
...
</имя_схемы2>
...
</имя_схемы>
Здесь отображение схемы имеет вид, показанный выше.
В качестве примера, иллюстрирующего использование результата этих функций, на
Рисунке  9.1 показано XSLT-преобразование, которое переводит результат функции
table_to_xml_and_xmlschema в HTML-документ, содержащий таблицу с данными. Подобным обра-
зом результаты этих функций можно преобразовать и в другие форматы на базе XML.
266Функции и операторы
Рисунок 9.1. XSLT-преобразование, переводящее результат SQL/XML в формат HTML
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns="http://www.w3.org/1999/xhtml"
>
<xsl:output method="xml"
doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
indent="yes"/>
<xsl:template match="/*">
<xsl:variable name="schema" select="//xsd:schema"/>
<xsl:variable name="tabletypename"
select="$schema/xsd:element[@name=name(current())]/@type"/>
<xsl:variable name="rowtypename"
select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/
xsd:element[@name='row']/@type"/>
<html>
<head>
<title><xsl:value-of select="name(current())"/></title>
</head>
<body>
<table>
<tr>
<xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/
xsd:sequence/xsd:element/@name">
<th><xsl:value-of select="."/></th>
</xsl:for-each>
</tr>
<xsl:for-each select="row">
<tr>
<xsl:for-each select="*">
<td><xsl:value-of select="."/></td>
</xsl:for-each>
</tr>
</xsl:for-each>
</table>
</body>
</html>
</xsl:template>
</xsl:stylesheet>
9.15. Функции и операторы JSON
В Таблице 9.43 перечислены функции, позволяющие создавать данные в формате JSON (см. Раз-
дел 8.14).
267Функции и операторы
Таблица 9.43. Операторы для типов json и jsonb
Оператор Тип правого опе- Описание
ранда
Пример
Результат
мера
-> int Выдаёт
элемент
массива JSON (по
номеру от 0, от-
рицательные чис-
ла задают позиции
с конца)
-> text Выдаёт поле объ- '("a":
("b":"foo")
екта JSON по клю- ("b":"foo"))'::json-
чу
>'a'
->> int Выдаёт
элемент '[1,2,
массива JSON в ти- 3]'::json->>2
пе text
3
->> text Выдаёт поле объ- '("a":1,
екта JSON в типе "b":2)'::json-
text
>>'b'
2
#> text[] Выдаёт
объект '("a":
("b": ("c": "foo")
JSON по заданно- ("c":
му пути
"foo")))'::json#>'(a,
b)'
#>> text[] Выдаёт
объект '("a":[1,2,3],
3
JSON по заданно- "b":[4,5,
му пути в типе 6])'::json#>>'(a,
text
2)'
при-
'[("a":"foo"),
("c":"baz")
("b":"bar"),
("c":"baz")]'::json-
>2
Примечание
Эти операторы существуют в двух вариациях для типов json и jsonb. Операторы из-
влечения поля/элемента/пути возвращают тот же тип, что у операнда слева (json или
jsonb), за исключением тех, что возвращают тип text (они возвращают значение как
текстовое). Если входные данные JSON не содержат структуры, удовлетворяющей за-
просу, например в них нет искомого элемента, то операторы извлечения поля/элемен-
та/пути не выдают ошибку, а возвращают NULL. Все операторы извлечения поля/эле-
мента/пути, принимающие целочисленные позиции в массивах JSON, поддерживают и
отсчёт от конца массива по отрицательной позиции.
Стандартные операторы сравнения, приведённые в Таблице  9.1, есть для типа jsonb, но не для
json. Они следуют правилам сортировки для операций B-дерева, описанным в Подразделе 8.14.4.
Некоторые из следующих операторов существуют только для jsonb, как показано в Таблице 9.44.
Многие из этих операторов могут быть проиндексированы с помощью классов операторов jsonb.
Полное описание проверок на вхождение и существование для jsonb приведено в Подразде-
ле  8.14.3. Как эти операторы могут использоваться для эффективного индексирования данных
jsonb, описано в Подразделе 8.14.4.
Таблица 9.44. Дополнительные операторы jsonb
Оператор Тип правого операн- Описание
да
@> jsonb
Пример
Левое значение JSON '("a":1,
содержит на верхнем
"b":2)'::jsonb
'("b":2)'::jsonb
268
@>Функции и операторы
Оператор Тип правого операн- Описание
Пример
да
уровне путь/значение
JSON справа?
<@ jsonb Путь/значение
JSON '("b":2)'::jsonb
слева содержится на '("a":1,
верхнем уровне в пра- "b":2)'::jsonb
вом значении JSON?
? text Присутствует ли стро- '("a":1,
ка в качестве ключа "b":2)'::jsonb ? 'b'
верхнего уровня в зна-
чении JSON?
?| text[] Какие-либо
строки '("a":1,
"b":2,
массива присутствуют
"c":3)'::jsonb ?|
в
качестве
ключей array['b', 'c']
верхнего уровня?
?& text[] Все строки массива '["a",
присутствуют в каче-
"b"]'::jsonb
стве ключей верхнего array['a', 'b']
уровня?
<@
?&
|| jsonb Соединяет два значе- '["a", "b"]'::jsonb
ния jsonb в новое зна- ||
'["c",
чение jsonb
"d"]'::jsonb
- text Удаляет пару ключ/ '("a": "b")'::jsonb -
значение
или
эле- 'a'
мент-строку из левого
операнда. Пары ключ/
значение выбираются
по значению ключа.
- text[] Удаляет множество пар '("a":
"b",
"c":
ключ/значение или эле- "d")'::jsonb - '(a,
менты-строки из ле- c)'::text[]
вого операнда. Пары
ключ/значение выбира-
ются по значению клю-
ча.
- integer Удаляет из массива эле- '["a",
мент в заданной пози- - 1
ции (отрицательные но-
мера позиций отсчиты-
ваются от конца). Выда-
ёт ошибку, если контей-
нер верхнего уровня —
не массив.
#- text[] Удаляет поле или эле- '["a",
мент с заданным пу- ("b":1)]'::jsonb #-
тём (для массивов JSON '(1,b)'
отрицательные номера
позиций отсчитывают-
ся от конца)
269
"b"]'::jsonbФункции и операторы
Примечание
Оператор || соединяет элементы верхнего уровня обоих операндов. Вложенность при
этом не учитывается. Например, если оба операнда содержат поле с одноимённым клю-
чом, значением поля в результате будет значение, взятое из правого операнда.
В Таблице  9.45 показаны функции, позволяющие создавать значения типов json и jsonb. (Для
типа jsonb нет аналогов функций row_to_json и array_to_json, но практически тот же результат
можно получить с помощью to_jsonb.)
Таблица 9.45. Функции для создания JSON
Функция Описание
to_json(anyelement) Возвращает значение в to_json('Fred
виде json или jsonb. "Hi."'::text)
Массивы и составные
структуры преобразу-
ются (рекурсивно) в
массивы и объекты; для
других типов, для ко-
торых определено при-
ведение к json, при-
меняется эта функ-
ция приведения, а для
всех остальных выдаёт-
ся скалярное значение.
Значения всех скаляр-
ных типов, кроме чис-
лового, логического и
NULL, представляются
в текстовом виде, в сти-
ле, допустимом для зна-
чений json или jsonb.
to_jsonb(
anyelement)
Пример
Результат примера
said
"Fred said \"Hi.\""
array_to_json(
anyarray [, pretty_
bool]) Возвращает массив в array_to_json(
виде массива JSON. '((1,5),(99,
Многомерный массив 100))'::int[])
PostgreSQL
становит-
ся массивом масси-
вов JSON. Если пара-
метр pretty_bool ра-
вен true, между эле-
ментами 1-ой размер-
ности вставляются раз-
рывы строк. [[1,5],[99,100]]
row_to_json(record
[, pretty_bool]) Возвращает кортеж в row_to_json(row(
виде объекта JSON. Ес- 1,'foo'))
ли параметр pretty_
bool равен true, меж-
ду элементами 1-ой раз-
мерности вставляются
разрывы строк. ("f1":1,"f2":"foo")
json_build_array(
VARIADIC "any") Формирует
массив json_build_array(
JSON (возможно, разно- 1,2,'3',4,5)
родный) из переменно-
го списка аргументов. [1, 2, "3", 4, 5]
270Функции и операторы
Функция
jsonb_build_array(
VARIADIC "any") Описание json_build_object(
VARIADIC "any") Формирует
объект json_build_object(
JSON из переменно- 'foo',1,'bar',2)
го списка аргументов.
По соглашению в этом
списке перечисляются
по очереди ключи и
значения. ("foo": 1, "bar": 2)
Формирует
объект json_object('(a,
JSON из текстового 1, b, "def", c,
массива.
Этот
мас- 3.5)')
сив должен иметь ли-
бо одну размерность json_object('((a,
с чётным числом эле-
1),(b,
"def"),
ментов (в этом слу- (c, 3.5))')
чае они воспринимают-
ся как чередующиеся
ключи/значения), либо
две размерности и при
этом каждый внутрен-
ний массив содержит
ровно два элемента, ко-
торые воспринимаются
как пара ключ/значе-
ние. ("a":
"1",
"b":
"def", "c": "3.5")
Эта
форма
json_ json_object('(a,
object
принимает b)', '(1,2)')
ключи и значения по
парам из двух отдель-
ных массивов. Во всех
остальных отношениях
она не отличается от
формы с одним аргу-
ментом. ("a": "1", "b": "2")
jsonb_build_object(
VARIADIC "any")
json_object(text[])
jsonb_object(
text[])
json_object(keys
text[],
values
text[])
jsonb_object(keys
text[],
values
text[])
Пример
Результат примера
Примечание
Функции array_to_json и row_to_json подобны to_json, но предлагают возможность
улучшенного вывода. Действие to_json, описанное выше, распространяется на каждое
отдельное значение, преобразуемое этими функциями.
Примечание
В расширении hstore определено преобразование из hstore в json, так что значения
hstore, преобразуемые функциями создания JSON, будут представлены в виде объектов
JSON, а не как примитивные строковые значения.
В Таблице 9.46 показаны функции, предназначенные для работы со значениями json и jsonb.
271Функции и операторы
Таблица 9.46. Функции для обработки JSON
Функция Тип результата Описание Пример Результат
мера
json_array_
length(json) int Возвращает чис-
ло элементов во
внешнем массиве
JSON. json_array_
length('[1,2,
3,("f1":1,
"f2":[5,6]),
4]') 5
jsonb_array_
length(jsonb)
json_each(
json)
jsonb_each(
jsonb)
json_each_
text(json)
jsonb_each_
text(jsonb)
json_extract_
path(from_
json
json,
VARIADIC path_
elems text[])
setof key text, Разворачивает
select
* key | value
внешний
объект from json_each( -----+-------
value json
JSON в набор пар '("a":"foo",
a
| "foo"
setof key text, ключ/значение
( "b":"bar")')
b
| "bar"
value jsonb
key/value).
setof key text, Разворачивает
внешний
объект
value text
JSON в набор пар
ключ/значение
(
key/value). Возвра-
щаемые значения
будут иметь тип
text.
json_extract_
path(
'("f2":
("f3":1),
"f4":("f5":99,
"f6":"foo"))',
'f4') ("f5":99,
"f6":"foo")
text Возвращает значе-
ние JSON по пути,
заданному элемен-
тами пути path_
elems , как text
(равнозначно опе-
ратору #>>). json_extract_
path_text(
'("f2":
("f3":1),
"f4":("f5":99,
"f6":"foo"))',
'f4', 'f6') foo
setof text Возвращает набор json_object_
ключей во внеш- keys(
нем объекте JSON. '("f1":"abc",
"f2":("f3":"a",
"f4":"b"))') anyelement Разворачивает
объект из from_
json
в таблич-
ную строку, в ко-
торой столбцы со-
jsonb
jsonb_extract_
path_text(
from_json
jsonb, VARIADIC
path_elems
text[])
json_object_
keys(json)
jsonb_object_
keys(jsonb)
json_populate_
record(base
anyelement,
from_json
json)
select
* key | value
from json_each_ -----+-------
a
| foo
text(
b
| bar
'("a":"foo",
"b":"bar")')
Возвращает значе-
ние JSON по пу-
ти, заданному эле-
ментами пути (
path_elems ) (рав-
нозначно операто-
ру #> operator).
json
jsonb_extract_
path(from_
json
jsonb,
VARIADIC path_
elems text[])
json_extract_
path_text(
from_json json,
VARIADIC path_
elems text[])
при-
272
json_object_keys
-----------------
f1
f2
b
|
select
* a |
c
from
json_
---+-----------
populate_
+-------------
record(
null::myrowtype,Функции и операторы
Функция
Тип результата
jsonb_populate_
recordset(base
anyelement,
from_json
jsonb)
json_array_
elements(json)
setof anyelement Разворачивает
внешний
массив
объектов из from_
json в набор таб-
личных строк, в
котором столбцы
соответствуют ти-
пу строки, задан-
ному параметром
base (см. примеча-
ния ниже).
setof text Разворачивает
массив JSON в
набор
значений
text. value
select
*
from
-----------
json_array_
foo
elements_text(
bar
'["foo",
"bar"]')
text Возвращает
тип json_typeof(
внешнего
значе- '-123.4')
ния JSON в ви-
де текстовой стро-
ки. Возможные ти-
пы: object, array,
string, number,
boolean и null.
record Формирует обыч-
ную запись из объ-
екта JSON (см.
примечания
ни-
же). Как и со
всеми
функция-
ми, возвращающи-
ми record, при
вызове необходи-
мо явно опреде-
лить структуру за-
писи с помощью
предложения AS.
setof jsonb
jsonb_typeof(
jsonb)
json_to_
record(json)
jsonb_to_
record(jsonb)
select
* a | b
from
json_ ---+---
1 | 2
populate_
3 | 4
recordset(
null::myrowtype,
'[("a":1,
"b":2),("a":3,
"b":4)]')
value
select
*
from
-----------
json_array_
1
elements('[1,
true
true,
[2,
[2,false]
false]]')
jsonb_array_
elements_text(
jsonb)
json_typeof(
json)
Результат
при-
мера
1 | (2,"a b") |
(4,"a b c")
Разворачивает
массив JSON в
набор
значений
JSON.
setof json
jsonb_array_
elements(
jsonb)
json_array_
elements_text(
json)
Пример
ответствуют типу '("a": 1, "b":
строки, заданному ["2", "a b"],
параметром base "c": ("d": 4,
(см. примечания "e": "a b c"))')
ниже).
jsonb_populate_
record(base
anyelement,
from_json
jsonb)
json_populate_
recordset(base
anyelement,
from_json
json)
Описание
273
number
b
|
select
* a |
c
| d |
from
json_to_
r
record(
---+---------
'("a":1,
+---------+---
"b":[1,2,3],
+---------------
"c":[1,2,3],
1 | [1,2,3] |
"e":"bar","r":
(1,2,3) |
|
("a": 123, "b":
"a b c"))') as (123,"a b c")
x(a
int,
b
text, c int[],
d
text,
r
myrowtype)Функции и операторы
Функция Тип результата Описание Пример json_to_
recordset(
json) setof record Формирует обыч-
ный
набор
за-
писей из масси-
ва объекта JSON
(см. примечания
ниже).
Как
и
со всеми функция-
ми, возвращающи-
ми record, при
вызове необходи-
мо явно опреде-
лить структуру за-
писи с помощью
предложения AS. select
* a | b
from
json_to_ ---+-----
1 | foo
recordset(
2 |
'[("a":1,
"b":"foo"),
("a":"2",
"c":"bar")]') as
x(a
int,
b
text);
json Возвращает
зна-
чение from_json ,
из которого ис-
ключаются все по-
ля объекта, содер-
жащие значения
NULL. Другие зна-
чения NULL оста-
ются нетронуты-
ми. json_strip_
nulls(
'[("f1":1,
"f2":null),2,
null,3]') [("f1":1),2,
null,3]
jsonb_set(
jsonb
target
jsonb,
path text[],
new_value
jsonb[,
create_
missing
boolean]) Возвращает значе-
ние target, в ко-
тором раздел с за-
данным путём (
path) заменяется
новым значением
(new_value ), ли-
бо в него добав-
ляется значение
new_value , если
аргумент create_
missing
равен
true (это значе-
ние по умолча-
нию) и элемент,
на который ссыла-
ется path, не су-
ществует. Как и с
операторами, рас-
считанными на пу-
ти, отрицательные
числа в пути (path)
обозначают отсчёт
от конца массивов
JSON. jsonb_set(
'[("f1":1,
"f2":null),2,
null,3]', '(0,
f1)','[2,3,
4]', false) [("f1":[2,3,
4],"f2":null),
2,null,3]
jsonb_insert(
target
jsonb,
path text[],
new_value Возвращает значе- jsonb_insert(
ние target с встав- '("a":
[0,1,
ленным в него 2])',
'(a,
новым значением
jsonb_to_
recordset(
jsonb)
json_strip_
nulls(from_
json json)
jsonb
jsonb_strip_
nulls(from_
json jsonb)
jsonb
274
Результат
мера
при-
[("f1": 1, "f2":
null, "f3": [2,
3, 4]), 2]
jsonb_set(
'[("f1":1,
"f2":null),
2]', '(0,f3)',
'[2,3,4]')
("a": [0, "new_
value", 1, 2])Функции и операторы
Функция
Тип результата
jsonb, [ insert_
after boolean])
jsonb_pretty(
from_json
jsonb)
text
Описание Пример
new_value . Если
место в target,
выбранное путём
path, оказывается
в массиве JSONB,
new_value
будет
вставлен до (по
умолчанию)
или
после (если па-
раметр
insert_
after равен true)
выбранной пози-
ции. Если место
в target, выбран-
ное путём path,
оказывается в объ-
екте JSONB, зна-
чение new_value
будет вставлено в
него, только ес-
ли заданный путь
path не существу-
ет. Как и с опе-
раторами, рассчи-
танными на пу-
ти, отрицательные
числа в пути (path)
обозначают отсчёт
от конца массивов
JSON. 1)', '"new_
value"')
Возвращает значе-
ние from_json в
виде текста JSON с
отступами. jsonb_pretty(
'[("f1":1,
"f2":null),2,
null,3]')
jsonb_insert(
'("a":
[0,1,
2])',
'(a,
1)', '"new_
value"', true)
Результат
при-
мера
("a":
[0,
1,
"new_value",
2])
[
(
"f1": 1,
"f2":
null
),
2,
null,
3
]
Примечание
Многие из этих функций и операторов преобразуют спецпоследовательности Unicode в
JSON-строках в соответствующие одиночные символы. Для входных данных типа jsonb
это ничем не грозит, так как преобразование уже выполнено; однако для типа json в
результате может произойти ошибка, как отмечено в Разделе 8.14.
Примечание
Хотя
в
примерах
использования
функций
json_populate_record,
json_populate_recordset, json_to_record и json_to_recordset применяются кон-
станты, обычно эти функции обращаются к таблицам в предложении FROM, а в качестве
275Функции и операторы
аргумента указывается один из столбцов типа json или jsonb. Извлечённые значения
затем могут использоваться в других частях запроса, например, в предложениях WHERE
и результирующих списках. Извлекая множество значений подобным образом, можно
значительно увеличить производительность по сравнению с использованием операто-
ров, работающих с отдельными ключами.
Ключи JSON сопоставляются с идентичными именами столбцов в целевом типе запи-
сей. Приведение типов JSON для этих функций выполняется «насколько это возмож-
но», и его результаты могут быть не вполне ожидаемыми для некоторых типов. По-
ля JSON, отсутствующие в целевом типе, в выходные данные не попадают, а целевые
столбцы, для которых нет соответствующих полей JSON, будут просто содержать NULL.
Примечание
В target должны присутствовать все элементы пути, заданного параметром path функ-
ций jsonb_set и jsonb_insert, за исключением последнего. Если create_missing ра-
вен false, должны присутствовать абсолютно все элементы пути path, переданного
функции jsonb_set. Если это условие не выполняется, значение target возвращается
неизменённым.
Если последним элементом пути оказывается ключ объекта, он будет создан в случае
отсутствия и получит новое значение. Если последний элемент пути — позиция в мас-
сиве, то когда она положительна, целевой элемент отсчитывается слева, а когда отри-
цательна — справа, то есть -1 указывает на самый правый элемент и т. д. Если позиция
лежит вне диапазона -длина_массива .. длина_массива -1, и параметр create_missing
равен true, новое значение добавляется в начало массива, если позиция отрицательна,
и в конец, если положительна.
Примечание
Значение null, возвращаемое функцией json_typeof, не следует путать с SQL NULL.
Тогда как при вызове json_typeof('null'::json) возвращается null, при вызове
json_typeof(NULL::json) будет возвращено значение SQL NULL.
Примечание
Если аргумент функции json_strip_nulls содержит повторяющиеся имена полей в
любом объекте, в результате могут проявиться семантические различия, в зависимости
от порядка этих полей. Это не проблема для функции jsonb_strip_nulls, так как в
значениях jsonb имена полей не могут дублироваться.
В Разделе 9.20 вы также можете узнать об агрегатной функции json_agg, которая агрегирует зна-
чения записи в виде JSON, и агрегатной функции json_object_agg, агрегирующей пары значений
в объект JSON, а также их аналогах для jsonb, функциях jsonb_agg и jsonb_object_agg.
9.16. Функции для работы с последовательностями
В этом разделе описаны функции для работы с объектами, представляющими последователь-
ности. Такие объекты (также называемыми генераторами последовательностей или просто по-
следовательностями) являются специальными таблицами из одной строки и создаются коман-
дой CREATE SEQUENCE. Используются они обычно для получения уникальных идентификаторов
строк таблицы. Функции, перечисленные в Таблице  9.47, предоставляют простые и безопасные
для параллельного использования методы получения очередных значений таких последователь-
ностей.
276Функции и операторы
Таблица 9.47. Функции для работы с последовательностями
Функция Тип результата Описание
currval( regclass) bigint Выдаёт значение заданной по-
следовательности, которое бы-
ло возвращено при последнем
вызове функции nextval
lastval() bigint Выдаёт значение любой после-
довательности, которое было
возвращено при последнем вы-
зове функции nextval
nextval( regclass) bigint Продвигает
последователь-
ность к следующему значению
и возвращает его
bigint Устанавливает текущее значе-
ние последовательности
bigint, bigint Устанавливает текущее значе-
ние последовательности и флаг
is_called , указывающий на
то, что это значение использо-
валось
setval( regclass,
setval( regclass,
boolean)
bigint)
Последовательность, к которой будет обращаться одна из этих функций, определяется аргументом
regclass, задающим просто OID последовательности в системном каталоге pg_class. Вычислять
этот OID вручную не нужно, так как процедура ввода данных regclass автоматически выполнит эту
работу за вас. Просто запишите имя последовательности в апострофах, чтобы оно выглядело как
строковая константа. Для совместимости с обычными именами SQL эта строка будет переведена
в нижний регистр, если только она не заключена в кавычки. Например:
nextval('foo')
nextval('FOO')
nextval('"Foo"')
обращается к последовательности foo
обращается к последовательности foo
обращается к последовательности Foo
При необходимости имя последовательности можно дополнить именем схемы:
nextval('myschema.foo')
nextval('"myschema".foo')
nextval('foo')
обращается к myschema.foo
то же самое
ищет foo в пути поиска
Подробнее тип regclass описан в Разделе 8.19.
Примечание
В PostgreSQL до версии 8.1 аргументы этих функций имели тип text, а не regclass,
и поэтому описанное выше преобразование текстовой строки в OID имело место при
каждом вызове функции. Это поведение сохраняется и сейчас для обратной совмести-
мости, но сейчас оно реализовано как неявное приведение типа text к типу regclass
перед вызовом функции.
Когда вы записываете аргумент функции, работающей с последовательностью, как тек-
стовую строку в чистом виде, она становится константой типа regclass. Так как фак-
тически это будет просто значение OID, оно будет привязано к изначально идентифи-
цированной последовательности, несмотря на то, что она может быть переименована,
перенесена в другую схему и т. д. Такое «раннее связывание» обычно желательно для
ссылок на последовательности в значениях столбцов по умолчанию и представлени-
ях. Но иногда возникает необходимость в «позднем связывании», когда ссылки на по-
следовательности распознаются в процессе выполнения. Чтобы получить такое пове-
дение, нужно принудительно изменить тип константы с regclass на text:
nextval('foo'::text)
foo распознаётся во время выполнения
277Функции и операторы
Заметьте, что версии PostgreSQL до 8.1 поддерживали только позднее связывание, так
что это может быть полезно и для совместимости со старыми приложениями.
Конечно же, аргументом таких функций может быть не только константа, но и выра-
жение. Если это выражение текстового типа, неявное приведение типов повлечёт раз-
решение имени во время выполнения.
Ниже описаны все функции, предназначенные для работы с последовательностями:
nextval
Продвигает последовательность к следующему значению и возвращает его. Это атомарная опе-
рация: если nextval вызывается одновременно в нескольких сеансах, в результате каждого вы-
зова будут гарантированно получены разные значения.
Если последовательность создаётся с параметрами по умолчанию, успешные вызовы nextval
получают очередные значения по возрастанию, начиная с 1. Другое поведение можно получить
с помощью специальных параметров в команде CREATE SEQUENCE; подробнее это описано на
странице описания команды.
Важно
Во избежание блокирования параллельных транзакций, пытающихся получить зна-
чения одной последовательности, операция nextval никогда не откатывается; то
есть, как только значение было выбрано, оно считается использованным и не будет
возвращено снова. Это утверждение верно, даже когда окружающая транзакция
впоследствии прерывается или вызывающий запрос никак не использует это зна-
чение. Например, команда INSERT с предложением ON CONFLICT вычислит кортеж,
претендующий на добавление, произведя все требуемые вызовы nextval, прежде
чем выявит конфликты, которые могут привести к отработке правил ON CONFLICT
вместо добавления. В таких ситуациях в последовательности задействованных зна-
чений могут образовываться «дыры». Таким образом, объекты последовательностей
PostgreSQL не годятся для получения непрерывных последовательностей.
Этой функции требуется право USAGE или UPDATE для последовательности.
currval
Возвращает значение, выданное при последнем вызове nextval для этой последовательности
в текущем сеансе. (Если в данном сеансе nextval ни разу не вызывалась для данной после-
довательности, возвращается ошибка.) Так как это значение ограничено рамками сеанса, эта
функция выдаёт предсказуемый результат вне зависимости от того, вызвалась ли впоследствии
nextval в других сеансах или нет.
Этой функции требуется право USAGE или SELECT для последовательности.
lastval
Возвращает значение, выданное при последнем вызове nextval в текущем сеансе. Эта функция
подобна currval, но она не принимает в параметрах имя последовательности, а обращается к
той последовательности, для которой вызывалась nextval в последний раз в текущем сеансе.
Если в текущем сеансе функция nextval ещё не вызывалась, при вызове lastval произойдёт
ошибка.
Этой функции требуется право USAGE или SELECT для последней использованной последователь-
ности.
setval
Сбрасывает счётчик последовательности. В форме с двумя параметрами устанавливает для по-
следовательности заданное значение поля last_value и значение true для флага is_called,
278Функции и операторы
показывающего, что при следующем вызове nextval последовательность должна сначала про-
двинуться к очередному значению, которое будет возвращено. При этом currval также возвра-
тит заданное значение. В форме с тремя параметрами флагу is_called можно присвоить true
или false. Со значением true она действует так же, как и форма с двумя параметрами. Если
же присвоить этому флагу значение false, первый вызов nextval после этого вернёт именно
заданное значение, а продвижение последовательности произойдёт при последующем вызове
nextval. Кроме того, значение, возвращаемое currval в этом случае, не меняется. Например,
SELECT setval('foo', 42);
SELECT setval('foo', 42, true);
SELECT setval('foo', 42, false);
Следующий вызов nextval вернёт 43
То же самое
Следующий вызов nextval вернёт 42
Результатом самой функции setval будет просто значение её второго аргумента.
Важно
Так как значения последовательностей изменяются вне транзакций, действие
функции setval не отменяется при откате транзакции.
Этой функции требуется право UPDATE для последовательности.
9.17. Условные выражения
В этом разделе описаны SQL-совместимые условные выражения, которые поддерживаются в
PostgreSQL.
Подсказка
Если возможностей этих условных выражений оказывается недостаточно, вероятно,
имеет смысл перейти к написанию серверных функций на более мощном языке про-
граммирования.
9.17.1. CASE
Выражение CASE в SQL представляет собой общее условное выражение, напоминающее операторы
if/else в других языках программирования:
CASE WHEN условие THEN результат
[WHEN ...]
[ELSE результат]
END
Предложения CASE можно использовать везде, где допускаются выражения. Каждое условие в нём
представляет собой выражение, возвращающее результат типа boolean. Если результатом выра-
жения оказывается true, значением выражения CASE становится результат, следующий за услови-
ем, а остальная часть выражения CASE не вычисляется. Если же условие не выполняется, за ним
таким же образом проверяются все последующие предложения WHEN. Если не выполняется ни од-
но из условий WHEN, значением CASE становится результат, записанный в предложении ELSE. Если
при этом предложение ELSE отсутствует, результатом выражения будет NULL.
Пример:
SELECT * FROM test;
a
---
1
2
3
279Функции и операторы
SELECT a,
CASE WHEN a=1 THEN 'one'
WHEN a=2 THEN 'two'
ELSE 'other'
END
FROM test;
a | case
---+-------
1 | one
2 | two
3 | other
Типы данных всех выражений результатов должны приводиться к одному выходному типу. По-
дробнее это описано в Разделе 10.5.
Существует также «простая» форма выражения CASE, разновидность вышеприведённой общей
формы:
CASE выражение
WHEN значение THEN результат
[WHEN ...]
[ELSE результат]
END
В такой форме сначала вычисляется первое выражение, а затем его результат сравнивается с вы-
ражениями значений в предложениях WHEN, пока не будет найдено равное ему. Если такого не зна-
чения не находится, возвращается результат предложения ELSE (или NULL). Эта форма больше
похожа на оператор switch, существующий в языке C.
Показанный ранее пример можно записать по-другому, используя простую форму CASE:
SELECT a,
CASE a WHEN 1 THEN 'one'
WHEN 2 THEN 'two'
ELSE 'other'
END
FROM test;
a | case
---+-------
1 | one
2 | two
3 | other
В выражении CASE вычисляются только те подвыражения, которые необходимы для получения
результата. Например, так можно избежать ошибки деления на ноль:
SELECT ... WHERE CASE WHEN x <> 0 THEN y/x > 1.5 ELSE false END;
Примечание
Как было описано в Подразделе 4.2.14, всё же возможны ситуации, когда подвыраже-
ния вычисляются на разных этапах, так что железной гарантии, что в «CASE вычис-
ляются только необходимые подвыражения», в принципе нет. Например, константное
подвыражение 1/0 обычно вызывает ошибку деления на ноль на этапе планирования,
хотя эта ветвь CASE может вовсе не вычисляться во время выполнения.
9.17.2. COALESCE
280Функции и операторы
COALESCE(значение [, ...])
Функция COALESCE возвращает первый попавшийся аргумент, отличный от NULL. Если же все ар-
гументы равны NULL, результатом тоже будет NULL. Это часто используется при отображении
данных для подстановки некоторого значения по умолчанию вместо значений NULL:
SELECT COALESCE(description, short_description, '(none)') ...
Этот запрос вернёт значение description, если оно не равно NULL, либо short_description, если
оно не NULL, и строку (none), если оба эти значения равны NULL.
Как и выражение CASE, COALESCE вычисляет только те аргументы, которые необходимы для полу-
чения результата; то есть, аргументы правее первого отличного от NULL аргумента не вычисля-
ются. Эта функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги называ-
ются NVL и IFNULL.
9.17.3. NULLIF
NULLIF(значение1, значение2)
Функция NULLIF возвращает значение NULL, если значение1 равно значение2; в противном случае
она возвращает значение1. Это может быть полезно для реализации обратной операции к COALESCE.
В частности, для примера, показанного выше:
SELECT NULLIF(value, '(none)') ...
Если аргумент value равен (none), результатом выражения будет NULL, а в противном случае —
значение аргумента value.
9.17.4. GREATEST и LEAST
GREATEST(значение [, ...])
LEAST(значение [, ...])
Функции GREATEST и LEAST выбирают наибольшее или наименьшее значение из списка выражений.
Все эти выражения должны приводиться к общему типу данных, который станет типом результата
(подробнее об этом в Разделе 10.5). Значения NULL в этом списке игнорируются, так что результат
выражения будет равен NULL, только если все его аргументы равны NULL.
Заметьте, что функции GREATEST и LEAST не описаны в стандарте SQL, но часто реализуются в СУБД
как расширения. В некоторых других СУБД они могут возвращать NULL, когда не все, а любой из
аргументов равен NULL.
9.18. Функции и операторы для работы с массивами
В Таблице 9.48 показаны операторы, предназначенные для работы с массивами.
Таблица 9.48. Операторы для работы с массивами
Оператор Описание Пример
= равно ARRAY[1.1,2.1,
3.1]::int[]
ARRAY[1,2,3]
Результат
t
=
<> не равно ARRAY[1,2,3]
ARRAY[1,2,4] <> t
< меньше ARRAY[1,2,3]
ARRAY[1,2,4] < t
> больше ARRAY[1,4,3]
ARRAY[1,2,4] > t
<= меньше или равно ARRAY[1,2,3]
ARRAY[1,2,3] <= t
281Функции и операторы
Оператор Описание Пример
Результат
>= больше или равно ARRAY[1,4,3]
ARRAY[1,4,3] >= t
@> содержит ARRAY[1,4,3]
ARRAY[3,1] @> t
<@ содержится в ARRAY[2,7]
ARRAY[1,7,4,2,6] && пересечение (есть об- ARRAY[1,4,3]
щие элементы)
ARRAY[2,1] && t
|| соединение массива с ARRAY[1,2,3]
массивом
ARRAY[4,5,6] || (1,2,3,4,5,6)
|| соединение массива с ARRAY[1,2,3]
||
массивом
ARRAY[[4,5,6], [7,
8,9]] ((1,2,3),(4,5,
6),(7,8,9))
|| соединение элемента с 3 || ARRAY[4,5,6]
массивом (3,4,5,6)
|| соединение массива с ARRAY[4,5,6] || 7
элементом (4,5,6,7)
<@
t
Операторы сравнения массивов сравнивают содержимое массивов по элементам, используя при
этом функцию сравнения для B-дерева, определённую для типа данного элемента по умолчанию.
В многомерных массивах элементы просматриваются по строкам (индекс последней размерности
меняется в первую очередь). Если содержимое двух массивов совпадает, а размерности различа-
ются, результат их сравнения будет определяться первым отличием в размерностях. (В PostgreSQL
до версии 8.2 поведение было другим: два массива с одинаковым содержимом считались одинако-
выми, даже если число их размерностей и границы индексов различались.)
Подробнее поведение операторов с массивами описано в Разделе 8.15. За дополнительными све-
дениями об операторах, поддерживающих индексы, обратитесь к Разделу 11.2.
В Таблице 9.49 перечислены функции, предназначенные для работы с массивами. Дополнительная
информация о них и примеры использования приведены в Разделе 8.15.
Таблица 9.49. Функции для работы с массивами
Функция Тип результата Описание array_append (
anyarray,
anyelement) anyarray добавляет элемент array_append(
в конец массива
ARRAY[1,2], 3) (1,2,3)
array_cat (
anyarray,
anyarray) anyarray соединяет два мас- array_cat(
сива
ARRAY[1,2,3],
ARRAY[4,5]) (1,2,3,4,5)
array_ndims (
anyarray) int возвращает число array_ndims(
размерностей мас- ARRAY[[1,2,
сива
3], [4,5,6]]) 2
array_dims (
anyarray) text возвращает
тек- array_dims(
стовое представле- ARRAY[[1,2,
ние размерностей 3], [4,5,6]])
массива [1:2][1:3]
array_fill (
anyelement,
int[]
int[]]) anyarray возвращает
мас- array_fill(7,
сив, заполненный
ARRAY[3],
заданным значе- ARRAY[2])
нием и имеющий [2:4]=(7,7,7)
[,
282
Пример
РезультатФункции и операторы
Функция
Тип результата
Описание
Пример
указанные размер-
ности, в которых
нижняя
граница
может быть отлич-
на от 1 Результат
array_length (
int
anyarray, int) возвращает длину array_length(
указанной размер- array[1,2,3],
ности массива
1) 3
array_lower (
int
anyarray, int) возвращает ниж- array_lower(
нюю границу ука- '[0:2]=(1,2,
занной размерно- 3)'::int[], 1)
сти массива 0
array_position ( int
anyarray,
anyelement [,
int]) возвращает пози-
цию первого вхож-
дения второго ар-
гумента в массиве,
начиная с элемен-
та,
выбираемого
третьим аргумен-
том, либо с перво-
го элемента (мас-
сив должен быть
одномерным) array_position(
ARRAY['sun',
'mon','tue',
'wed','thu',
'fri','sat'],
'mon') 2
array_
positions (
anyarray,
anyelement) int[] возвращает
мас-
сив с позиция-
ми всех вхождений
второго аргумента
в массиве, задава-
емым первым ар-
гументом (массив
должен быть одно-
мерным) array_
positions(
ARRAY['A','A',
'B','A'], 'A') (1,2,4)
array_prepend (
anyelement,
anyarray) anyarray вставляет элемент array_prepend(
в начало массива 1, ARRAY[2,3]) (1,2,3)
array_remove (
anyarray,
anyelement) anyarray удаляет из масси- array_remove(
ва все элементы, ARRAY[1,2,3,
равные заданному 2], 2)
значению (массив
должен быть одно-
мерным) (1,3)
array_replace ( anyarray
anyarray,
anyelement,
anyelement) заменяет в масси- array_replace(
ве все элементы, ARRAY[1,2,5,
равные заданному 4], 5, 3)
значению, другим
значением (1,2,3,4)
array_to_
string (
anyarray,
[, text]) выводит элементы
массива через за-
данный раздели-
тель и позволяет
определить заме-
ну для значения
NULL 1,2,3,*,5
text
text
283
array_to_
string(
ARRAY[1, 2, 3,
NULL, 5], ',
', '*')Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
array_upper (
int
anyarray, int) возвращает верх- array_upper(
нюю границу ука- ARRAY[1,8,3,
занной размерно- 7], 1)
сти массива 4
cardinality(
anyarray) возвращает общее cardinality(
число элементов в ARRAY[[1,2],
массиве, либо 0, [3,4]])
если массив пуст 4
разбивает строку
на элементы мас-
сива,
используя
заданный раздели-
тель и, возможно,
замену для значе-
ний NULL (xx,NULL,zz)
int
string_to_
text[]
array ( text,
text [, text])
unnest(
anyarray)
unnest(
anyarray,
anyarray
...])
string_to_
array(
'xx~^~yy~
^~zz',
'~^~',
'yy')
setof anyelement разворачивает
unnest(ARRAY[1,
массив в набор 2])
строк
setof anyelement, разворачивает
anyelement [, массивы (возмож-
но разных типов)
[, ...]
в набор строк. Это
допускается толь-
ко в предложении
FROM; см. Подраз-
дел 7.2.1.4
unnest(ARRAY[1,
2],
ARRAY['foo',
'bar','baz'])
1
2
(2 строки)
1
foo
2
bar
NULL baz
(3 строки)
В функциях array_position и array_positions каждый элемент массива сравнивается с искомым
значением по принципу IS NOT DISTINCT FROM.
Функция array_position возвращает NULL, если искомое значение не находится.
Функция array_positions возвращает NULL, только если в качестве массива передаётся NULL; если
же в массиве не находится значение, она возвращает пустой массив.
Если для функции string_to_array в качестве разделителя задан NULL, каждый символ входной
строки станет отдельным элементом в полученном массиве. Если разделитель пустая строка, стро-
ка будет возвращена целиком в массиве из одного элемента. В противном случае входная строка
разбивается по вхождениям подстроки, указанной в качестве разделителя.
Если для функции string_to_array параметр замены значения NULL опущен или равен NULL,
никакие подстроки во входных данных не будут заменяться на NULL. Если же параметр замены
NULL опущен или равен NULL для функции array_to_string, все значения NULL просто пропус-
каются и никак не представляются в выходной строке.
Примечание
В поведении string_to_array по сравнению с PostgreSQL версий до 9.1 произошли два
изменения. Во-первых, эта функция возвращает пустой массив (содержащий 0 элемен-
тов), а не NULL, когда входная строка имеет нулевую длину. Во-вторых, если в каче-
стве разделителя задан NULL, эта функция разбивает строку по символам, а не просто
возвращает NULL, как было раньше.
284Функции и операторы
Вы также можете узнать об агрегатной функции, работающей с массивами, array_agg в Разде-
ле 9.20.
9.19. Диапазонные функции и операторы
Диапазонные типы данных рассматриваются в Разделе 8.17.
В Таблице 9.50 показаны операторы, предназначенные для работы с диапазонами.
Таблица 9.50. Диапазонные операторы
Оператор Описание Пример Результат
= равно int4range(1,5)
=
'[1,4]'::int4range t
<> не равно numrange(1.1,2.2)
<>
numrange(1.1,
2.3) t
< меньше int4range(1,10)
int4range(2,3) < t
> больше int4range(1,10)
int4range(1,5) > t
<= меньше или равно numrange(1.1,2.2)
<=
numrange(1.1,
2.2) t
>= больше или равно numrange(1.1,2.2)
>=
numrange(1.1,
2.0) t
@> содержит диапазон int4range(2,4)
int4range(2,3) t
@> содержит элемент '[2011-01-01,
t
2011-03-01)'::tsrange
@>
'2011-01-10'::timestamp
<@ диапазон содержится в int4range(2,4)
int4range(1,7) <@ элемент содержится в && пересекает (есть общие int8range(3,7)
точки)
int8range(4,12) <<
42
7)
<@
@>
<@
int4range(1,
t
f
&& t
строго слева от int8range(1,10) <<
int8range(100,110) t
>> строго справа от int8range(50,60) >>
int8range(20,30) t
&< не простирается правее int8range(1,20) &<
int8range(18,20) t
&> не простирается левее int8range(7,20)
int8range(5,10) t
-|- примыкает к
&>
numrange(1.1,2.2)
-|-
numrange(2.2,
3.3)
285
tФункции и операторы
Оператор Описание Пример
Результат
+ union numrange(5,15)
numrange(10,20) + [5,20)
* пересечение int8range(5,15)
int8range(10,20) * [10,15)
- вычитание int8range(5,15)
int8range(10,20) - [5,10)
Простые операторы сравнения <, >, <= и >= сначала сравнивают нижние границы, и только если
они равны, сравнивают верхние. Эти операторы сравнения обычно не очень полезны для диапазо-
нов; основное их предназначение — сделать возможным построение индексов-B-деревьев по диа-
пазонам.
Операторы слева/справа/примыкает всегда возвращают false, если один из диапазонов пуст; то
есть, считается, что пустой диапазон находится не слева и не справа от какого-либо другого диа-
пазона.
Операторы сложения и вычитания вызывают ошибку, если получающийся в результате диапазон
оказывается состоящим из двух разделённых поддиапазонов, так как его нельзя представить в
этом типе данных.
В Таблице 9.51 перечислены функции, предназначенные для работы с диапазонными типами.
Таблица 9.51. Диапазонные функции
Функция
Тип результата
Описание
Пример
Результат
граница lower(numrange(
lower( anyrange) тип элемента диа- нижняя
пазона
диапазона
1.1, 2.2)) 1.1
upper( anyrange) тип элемента диа- верхняя граница upper(numrange(
пазона
диапазона
1.1, 2.2)) 2.2
isempty(
anyrange) boolean диапазон пуст? lower_inc (
anyrange) boolean нижняя
граница lower_inc(
включается?
numrange(1.1,
2.2)) true
upper_inc (
anyrange) boolean верхняя граница upper_inc(
включается?
numrange(1.1,
2.2)) false
lower_inf (
anyrange) boolean нижняя
граница lower_inf('(,
равна бесконечно- )'::daterange)
сти? true
upper_inf (
anyrange) boolean верхняя граница upper_inf('(,
равна бесконечно- )'::daterange)
сти? true
range_merge (
anyrange,
anyrange) anyrange наименьший диа- range_merge(
пазон, включаю- '[1,
щий оба заданных 2)'::int4range,
диапазона
'[3,
4)'::int4range) [1,4)
isempty(
numrange(1.1,
2.2))
false
Функции lower и upper возвращают NULL, если диапазон пуст или указанная граница равна бес-
конечности. Если же пустой диапазон передаётся функциям lower_inc, upper_inc, lower_inf и
upper_inf, все они возвращают false.
286Функции и операторы
9.20. Агрегатные функции
Агрегатные функции получают единственный результат из набора входных значений. Встроенные
агрегатные функции общего назначения перечислены в Таблице 9.52, а статистические агрегат-
ные функции — в Таблице 9.53. Встроенные внутригрупповые сортирующие агрегатные функции
перечислены в Таблице  9.54, встроенные внутригрупповые гипотезирующие — в Таблице  9.55.
Группирующие операторы, тесно связанные с агрегатными функциями, перечислены в Табли-
це 9.56. Особенности синтаксиса агрегатных функцией разъясняются в Подразделе 4.2.7. За до-
полнительной вводной информацией обратитесь к Разделу 2.7.
Таблица 9.52. Агрегатные функции общего назначения
Функция Типы аргумента Тип результата array_agg(
выражение) любой тип не мас- массив элементов Нет
сива
с типом аргумента входные значения,
включая
NULL,
объединяются
в
массив
array_agg(
выражение) любой тип массива тот же, что и тип Нет
аргумента входные
масси-
вы собираются в
массив
большей
размерности (они
должны иметь од-
ну размерность и
не могут быть пу-
стыми или равны
NULL)
avg( выражение) smallint,
int,
bigint,
real,
double precision,
numeric
или
interval numeric для лю- Да
бых целочислен-
ных
аргументов,
double precision
для аргументов с
плавающей
точ-
кой, в противном
случае тип данных
аргумента арифметическое
среднее для всех
входных значений
bit_and(
выражение) smallint,
int, тот же, что и тип Да
аргумента
bigint или bit побитовое И для
всех входных зна-
чений, не равных
NULL, или NULL,
если таких нет
bit_or(
выражение) smallint,
int, тот же, что и тип Да
аргумента
bigint или bit побитовое
ИЛИ
для всех входных
значений, не рав-
ных NULL, или
NULL, если таких
нет
bool_and(
выражение) bool bool Да true, если все вход-
ные значения рав-
ны true, и false в
противном случае
bool_or(
выражение) bool bool Да true, если хотя бы
одно входное зна-
чение равно true, и
false в противном
случае
287
Частичный
жим
ре- ОписаниеФункции и операторы
Функция
Типы аргумента Тип результата
count(*)
Частичный
жим
ре- Описание
bigint Да количество
ных строк
вход-
count(
выражение) any bigint Да количество вход-
ных строк, для
которых значение
выражения не рав-
но NULL
every(
выражение) bool bool Да синоним
and
json_agg(
выражение) any json Нет агрегирует значе-
ния в виде массива
JSON
jsonb_agg(
выражение) any jsonb Нет агрегирует значе-
ния в виде массива
JSON
json_object_
(any, any)
agg( имя, значе-
ние) json Нет агрегирует пары
имя/значение в ви-
де объекта JSON
jsonb_object_
(any, any)
agg( имя, значе-
ние) jsonb Нет агрегирует пары
имя/значение в ви-
де объекта JSON
bool_
max( выражение) любой числовой, тот же, что и тип Да
строковый, сете- аргумента
вой тип или тип
даты/времени, ли-
бо массив этих ти-
пов максимальное зна-
чение выражения
среди всех вход-
ных данных
min( выражение) любой числовой, тот же, что и тип Да
строковый, сете- аргумента
вой тип или тип
даты/времени, ли-
бо массив этих ти-
пов минимальное зна-
чение выражения
среди всех вход-
ных данных
string_agg(
выражение,
делитель)
(text, text) или ( тот же, что и типы Нет
аргументов
раз- bytea, bytea)
sum( выражение) smallint,
int,
bigint,
real,
double precision,
numeric, interval
или money bigint для аргу- Да
ментов smallint
или int, numeric
для
аргументов
bigint, и тип аргу-
мента в остальных
случаях
xmlagg(
выражение) xml xml
Нет
288
входные
данные
складываются
в
строку через за-
данный раздели-
тель
сумма
значений
выражения по всем
входным данным
соединение XML-
значений
(см.
также
Подраз-
дел 9.14.1.7)Функции и операторы
Следует заметить, что за исключением count, все эти функции возвращают NULL, если для них не
была выбрана ни одна строка. В частности, функция sum, не получив строк, возвращает NULL, а не
0, как можно было бы ожидать, и array_agg в этом случае возвращает NULL, а не пустой массив.
Если необходимо, подставить в результат 0 или пустой массив вместо NULL можно с помощью
функции coalesce.
Агрегатные функции, поддерживающие частичный режим, являются кандидатами на участие в
различных оптимизациях, например, в параллельном агрегировании.
Примечание
Булевы агрегатные функции bool_and и bool_or соответствуют стандартным SQL-аг-
регатам every и any или some. Что касается any и some, по стандарту их синтаксис до-
пускает некоторую неоднозначность:
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
Здесь ANY можно рассматривать и как объявление подзапроса, и как агрегатную функ-
цию, если этот подзапрос возвращает одну строку с булевым значением. Таким обра-
зом, этим агрегатным функциям нельзя было дать стандартные имена.
Примечание
Пользователи с опытом использования других СУБД SQL могут быть недовольны ско-
ростью агрегатной функции count, когда она применяется ко всей таблице. Подобный
запрос:
SELECT count(*) FROM sometable;
потребует затрат в количестве, пропорциональном размеру таблицы: PostgreSQL при-
дётся полностью просканировать либо всю таблицу, либо один из индексов, включаю-
щий все её строки.
Агрегатные функции array_agg, json_agg, jsonb_agg, json_object_agg, jsonb_object_agg,
string_agg и xmlagg так же, как и подобные пользовательские агрегатные функции, выдают раз-
ные по содержанию результаты в зависимости от порядка входных значений. По умолчанию поря-
док не определён, но его можно задать, дополнив вызов агрегатной функции предложением ORDER
BY, как описано в Подразделе 4.2.7. Обычно нужного результата также можно добиться, передав
для агрегирования результат подзапроса с сортировкой. Например:
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
Но учтите, что этот подход может не работать, если на внешнем уровне запроса выполняется до-
полнительная обработка, например, соединение, так как при этом результат подзапроса может
быть переупорядочен перед вычислением агрегатной функции.
В Таблице 9.53 перечислены агрегатные функции, обычно применяемые в статистическом анали-
зе. (Они выделены просто для того, чтобы не загромождать список наиболее популярных агрегат-
ных функций.) В их описании под N подразумевается число входных строк, для которых входные
выражения не равны NULL. Все эти функции возвращают NULL во всех случаях, когда вычисление
бессмысленно, например, когда N равно 0.
Таблица 9.53. Агрегатные функции для статистических вычислений
Функция
corr( Y,
Тип аргумента
X)
Тип результата
Частичный
жим
double precision double precision Да
289
ре- Описание
коэффициент кор-
реляцииФункции и операторы
Функция
Тип аргумента
covar_pop(
X)
Y,
covar_samp(
X)
Y,
Тип результата
Частичный
жим
ре- Описание
double precision double precision Да ковариация
купности
сово-
double precision double precision Да ковариация выбор-
ки
regr_avgx(
X) Y, double precision double precision Да среднее независи-
мой переменной (
sum( X)/N)
regr_avgy(
X) Y, double precision double precision Да среднее
зависи-
мой переменной (
sum( Y)/N)
Да число
входных
строк, в которых
оба выражения не
NULL
double precision double precision Да пересечение
с
осью OY линии, по-
лученной методом
наименьших квад-
ратов по данным (
X, Y)
regr_count(
X)
Y,
regr_intercept(
Y, X)
regr_r2(
double precision bigint
X) double precision double precision Да
Y,
regr_slope(
X)
Y,
квадрат
циента
ции
коэффи-
корреля-
double precision double precision Да наклон линии, по-
лученной методом
наименьших квад-
ратов по данным (
X, Y)
regr_sxx( Y, X) double precision double precision Да sum( X^2) - sum(
X)^2/N
(«сумма
квадратов» неза-
висимой перемен-
ной)
regr_sxy( Y, X) double precision double precision Да sum( X*Y) - sum(
X) * sum( Y)/N (
«сумма произведе-
ний» независимых
и зависимых пере-
менных)
regr_syy( Y, X) double precision double precision Да sum( Y^2) - sum(
Y)^2/N
(«сумма
квадратов» зави-
симой
перемен-
ной)
double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных сохранившийся
синоним stddev_
samp
stddev(
выражение)
smallint,
int,
bigint,
real,
double precision
или numeric
290Функции и операторы
Функция Тип аргумента Тип результата
Частичный
жим
ре- Описание
stddev_pop(
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных стандартное
от-
клонение по гене-
ральной совокуп-
ности входных зна-
чений
stddev_samp(
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных стандартное
от-
клонение по вы-
борке входных зна-
чений
variance(
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных сохранившийся
синоним
var_
samp
var_pop (
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных дисперсия для ге-
неральной
сово-
купности входных
значений (квадрат
стандартного от-
клонения)
var_samp (
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных дисперсия по вы-
борке для входных
значений (квадрат
отклонения по вы-
борке)
В Таблице 9.54 показаны некоторые агрегатные функции, использующие синтаксис сортирующих
агрегатных функций. Иногда такие функции функциями называют функциями «обратного распре-
деления».
Таблица 9.54. Сортирующие агрегатные функции
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
Описание
mode() WITHIN
GROUP (ORDER
BY выражение_
сортировки) любой сортиру- тот же, что Нет
емый тип
у
выражения
сортировки возвращает
значение, наи-
более
часто
встречающее-
ся
во
вход-
ных данных (
если одинаково
часто встреча-
ются несколько
значений, про-
извольно выби-
рается первое
из них)
percentile_
double
cont( дробь)
precision
WITHIN
GROUP
(ORDER BY вы- тот же, что Нет
double
выражения
precision или у
сортировки
interval непрерывный
процентиль:
возвращает
значение, соот-
291Функции и операторы
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
ражение_
сортировки)
Описание
ветствующее
заданной дро-
би по поряд-
ку, интерполи-
руя
соседние
входные значе-
ния, если необ-
ходимо
percentile_
double
cont( дроби)
precision[]
WITHIN
GROUP
(ORDER BY вы-
ражение_
сортировки) массив
ти- Нет
double
precision или па выражения
сортировки
interval множествен-
ный
непре-
рывный
про-
центиль:
воз-
вращает
мас-
сив результа-
тов,
соответ-
ствующих фор-
ме параметра
дроби (для каж-
дого элемента
не NULL под-
ставляется зна-
чение, соответ-
ствующее дан-
ному проценти-
лю)
percentile_
double
disc( дробь)
precision
WITHIN
GROUP
(ORDER BY вы-
ражение_
сортировки) любой сортиру- тот же, что Нет
емый тип
у
выражения
сортировки дискретный
процентиль:
возвращает
первое значе-
ние из вход-
ных данных, по-
зиция которого
по порядку рав-
на или превос-
ходит указан-
ную дробь
percentile_
double
disc( дроби)
precision[]
WITHIN
GROUP
(ORDER BY вы-
ражение_
сортировки) любой сортиру- массив
ти- Нет
емый тип
па выражения
сортировки множествен-
ный
дискрет-
ный
процен-
тиль:
возвра-
щает
мас-
сив результа-
тов,
соответ-
ствующих фор-
ме
парамет-
ра
дроби
(
для
каждого
элемента
не
NULL подстав-
ляется
вход-
ное
значе-
ние,
соответ-
ствующее дан-
292Функции и операторы
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
Описание
ному проценти-
лю)
Все агрегатные функции, перечисленные в Таблице 9.54, игнорируют значения NULL при сорти-
ровке данных. Для функций, принимающих параметр дробь, значение этого параметра должно
быть от 0 до 1; в противном случае возникает ошибка. Однако, если в этом параметре передаётся
NULL, эти функции просто выдают NULL.
Все агрегатные функции, перечисленные в Таблице  9.55, связаны с одноимёнными оконными
функциями, определёнными в Разделе 9.21. В каждом случае их результат — значение, которое
вернула бы связанная оконная функция для «гипотетической» строки, полученной из аргументов,
если бы такая строка была добавлена в сортированную группу строк, которую образуют сортиро-
ванные_аргументы.
Таблица 9.55. Гипотезирующие агрегатные функции
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
Описание
rank(
VARIADIC "any" VARIADIC "any" bigint
аргументы)
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет ранг гипотети-
ческой
стро-
ки, с пропус-
ками повторя-
ющихся строк
dense_rank(
VARIADIC "any" VARIADIC "any" bigint
аргументы)
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет ранг гипотети-
ческой строки,
без пропусков
percent_
VARIADIC "any" VARIADIC "any" double
rank(
precision
аргументы)
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет относительный
ранг гипотети-
ческой строки,
от 0 до 1
cume_dist(
VARIADIC "any" VARIADIC "any" double
аргументы)
precision
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет относительный
ранг гипотети-
ческой строки,
от 1/N до 1
Для всех этих гипотезирующих агрегатных функций непосредственные аргументы должны соот-
ветствовать (по количеству и типу) сортированным_аргументам. В отличие от встроенных агрегат-
ных функций, они не являются строгими, то есть не отбрасывают входные строки, содержащие
NULL. Значения NULL сортируются согласно правилу, указанному в предложении ORDER BY.
293Функции и операторы
Таблица 9.56. Операции группировки
Функция Тип результата Описание
GROUPING( аргументы...) integer Целочисленная битовая маска,
показывающая, какие аргумен-
ты не вошли в текущий набор
группирования
Операции группировки применяются в сочетании с наборами группирования (см. Подраздел 7.2.4)
для различения результирующих строк. Аргументы операции GROUPING на самом деле не вычисля-
ются, но они должны в точности соответствовать выражениям, заданным в предложении GROUP BY
на их уровне запроса. Биты назначаются справа налево (правый аргумент отражается в младшем
бите); бит равен 0, если соответствующее выражение вошло в критерий группировки набора груп-
пирования, для которого сформирована строка результата, или 1 в противном случае. Например:
=> SELECT * FROM items_sold;
make | model | sales
-------+-------+-------
Foo
| GT
| 10
Foo
| Tour | 20
Bar
| City | 15
Bar
| Sport | 5
(4 rows)
=> SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY
ROLLUP(make,model);
make | model | grouping | sum
-------+-------+----------+-----
Foo
| GT
|
0 | 10
Foo
| Tour |
0 | 20
Bar
| City |
0 | 15
Bar
| Sport |
0 | 5
Foo
|
|
1 | 30
Bar
|
|
1 | 20
|
|
3 | 50
(7 rows)
9.21. Оконные функции
Оконные функции дают возможность выполнять вычисления с набором строк, каким-либо образом
связанным с текущей строкой запроса. Вводную информацию об этом можно получить в Разде-
ле 3.5, а подробнее узнать о синтаксисе можно в Подразделе 4.2.8.
Встроенные оконные функции перечислены в Таблице 9.57. Заметьте, что эти функции должны
вызываться именно как оконные, т. е. при вызове необходимо использовать предложение OVER.
В дополнение к этим функциям в качестве оконных можно использовать любые встроенные или
пользовательские универсальные или статистические агрегатные функции (но не сортирующие и
не гипотезирующие); список встроенных агрегатных функций приведён в Разделе 9.20. Агрегат-
ные функции работают как оконные, только когда за их вызовом следует предложение OVER; в про-
тивном случае они работают как обычные, не оконные функции и выдают для всего набора един-
ственную строку.
Таблица 9.57. Оконные функции общего назначения
Функция Тип результата Описание
row_number() bigint номер текущей строки в её раз-
деле, начиная с 1
rank() bigint ранг текущей строки с про-
пусками; то же, что и row_
294Функции и операторы
Функция Тип результата Описание
number для первой родствен-
ной ей строки
dense_rank() bigint ранг текущей строки без про-
пусков; эта функция считает
группы родственных строк
percent_rank() double precision относительный ранг текущей
строки: (rank - 1) / (общее число
строк раздела - 1)
cume_dist() double precision кумулятивное распределение: (
число строк раздела, предше-
ствующих или родственных те-
кущей строке) / общее число
строк раздела
ntile( число_групп
ранжирование по целым чис-
лам от 1 до значения аргумента
так, чтобы размеры групп были
максимально близки
integer) integer
lag( значение anyelement [,
смещение integer [,
по_
умолчанию anyelement ]]) тип аргумента значение возвращает значение для стро-
ки, положение которой задаёт-
ся смещением от текущей стро-
ки к началу раздела; если такой
строки нет, возвращается зна-
чение по_умолчанию (оно долж-
но иметь тот же тип, что и зна-
чение). Оба параметра смеще-
ние и по_умолчанию вычисля-
ются для текущей строки. Если
они не указываются, то смеще-
ние считается равным 1, а по_
умолчанию — NULL
lead( значение anyelement [,
смещение integer [,
по_
умолчанию anyelement ]]) тип аргумента значение возвращает значение для стро-
ки, положение которой задаёт-
ся смещением от текущей стро-
ки к концу раздела; если такой
строки нет, возвращается зна-
чение по_умолчанию (оно долж-
но иметь тот же тип, что и зна-
чение). Оба параметра смеще-
ние и по_умолчанию вычисля-
ются для текущей строки. Если
они не указываются, то смеще-
ние считается равным 1, а по_
умолчанию — NULL
first_value( тип аргумента значение возвращает значение, вычис-
ленное для первой строки в рам-
ке окна
тип аргумента значение возвращает значение, вычис-
ленное для последней строки в
рамке окна
n тип аргумента значение возвращает значение, вычис-
ленное в н-ой строке в рамке ок-
last_value(
nth_value(
integer)
значение any)
значение any)
значение any,
295Функции и операторы
Функция
Тип результата
Описание
на (считая с 1), или NULL, если
такой строки нет
Результат всех функций, перечисленных в Таблице 9.57, зависит от порядка сортировки, заданного
предложением ORDER BY в определении соответствующего окна. Строки, которые являются одина-
ковыми при рассмотрении только столбцов ORDER BY, считаются родственными. Четыре функции,
вычисляющие ранг (включая cume_dist), реализованы так, что их результат будет одинаковым для
всех родственных строк.
Заметьте, что функции first_value, last_value и nth_value рассматривают только строки в «рам-
ке окна», которая по умолчанию содержит строки от начала раздела до последней родственной
строки для текущей. Поэтому результаты last_value и иногда nth_value могут быть не очень по-
лезны. В таких случаях можно переопределить рамку, добавив в предложение OVER подходящее
указание рамки (RANGE, ROWS или GROUPS). Подробнее эти указания описаны в Подразделе 4.2.8.
Когда в качестве оконной функции используется агрегатная, она обрабатывает строки в рамке те-
кущей строки. Агрегатная функция с ORDER BY и определением рамки окна по умолчанию будет
вычисляться как «бегущая сумма», что может не соответствовать желаемому результату. Чтобы
агрегатная функция работала со всем разделом, следует опустить ORDER BY или использовать ROWS
BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING. Используя другие указания в определе-
нии рамки, можно получить и другие эффекты.
Примечание
В стандарте SQL определены параметры RESPECT NULLS или IGNORE NULLS для функций
lead, lag, first_value, last_value и nth_value. В PostgreSQL такие параметры не ре-
ализованы: эти функции ведут себя так, как положено в стандарте по умолчанию (или
с подразумеваемым параметром RESPECT NULLS). Также функция nth_value не поддер-
живает предусмотренные стандартом параметры FROM FIRST и FROM LAST: реализовано
только поведение по умолчанию (с подразумеваемым параметром FROM FIRST). (Полу-
чить эффект параметра FROM LAST можно, изменив порядок ORDER BY на обратный.)
Функция cume_dist вычисляет процент строк раздела, которые меньше или равны текущей строке
или родственным ей строкам, тогда как percent_rank вычисляет процент строк раздела, которые
меньше текущей строки, в предположении, что текущая строка не относится к разделу.
9.22. Выражения подзапросов
В этом разделе описаны выражения подзапросов, которые реализованы в PostgreSQL в соответ-
ствии со стандартом SQL. Все рассмотренные здесь формы выражений возвращает булевы значе-
ния (true/false).
9.22.1. EXISTS
EXISTS (подзапрос)
Аргументом EXISTS является обычный оператор SELECT, т. е. подзапрос. Выполнив запрос, систе-
ма проверяет, возвращает ли он строки в результате. Если он возвращает минимум одну строку,
результатом EXISTS будет «true», а если не возвращает ни одной — «false».
Подзапрос может обращаться к переменным внешнего запроса, которые в рамках одного вычис-
ления подзапроса считаются константами.
Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как только будет воз-
вращена хотя бы одна строка. Поэтому в подзапросах следует избегать побочных эффектов (на-
пример, обращений к генераторам последовательностей); проявление побочного эффекта может
быть непредсказуемым.
296Функции и операторы
Так как результат этого выражения зависит только от того, возвращаются строки или нет, но не от
их содержимого, список выходных значений подзапроса обычно не имеет значения. Как следствие,
широко распространена практика, когда проверки EXISTS записываются в форме EXISTS(SELECT
1 WHERE ...). Однако из этого правила есть и исключения, например с подзапросами с предло-
жением INTERSECT.
Этот простой пример похож на внутреннее соединение по столбцу col2, но он выдаёт максимум
одну строку для каждой строки в tab1, даже если в tab2 ей соответствуют несколько строк:
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
9.22.2. IN
выражение IN (подзапрос)
В правой стороне этого выражения в скобках задаётся подзапрос, который должен возвращать ров-
но один столбец. Вычисленное значение левого выражения сравнивается со значениями во всех
строках, возвращённых подзапросом. Результатом всего выражения IN будет «true», если строка
с таким значением находится, и «false» в противном случае (в том числе, когда подзапрос вообще
не возвращает строк).
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция IN возвращает NULL, а
не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
конструктор_строки IN (подзапрос)
В левой части этой формы IN записывается конструктор строки (подробнее они рассматриваются
в Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен вернуть ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом.
Результатом всего выражения IN будет «true», если строка с такими значениями находится, и
«false» в противном случае (в том числе, когда подзапрос вообще не возвращает строк).
Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам
сравнения. Две строки считаются равными, если все их соответствующие элементы не равны
NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не рав-
ные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён
(равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы
один NULL, результатом IN будет NULL.
9.22.3. NOT IN
выражение NOT IN (подзапрос)
Справа в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вы-
численное значение левого выражения сравнивается со значением во всех строках, возвращённых
подзапросом. Результатом всего выражения NOT IN будет «true», если находятся только несовпа-
дающие строки (в том числе, когда подзапрос вообще не возвращает строк). Если же находится
хотя бы одна подходящая строка, результатом будет «false».
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция NOT IN возвращает
NULL, а не true. Это соответствует принятым в SQL правилам сравнения переменных со значени-
ями NULL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
297Функции и операторы
конструктор_строки NOT IN (подзапрос)
В левой части этой формы NOT IN записывается конструктор строки (подробнее они описываются
в Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен вернуть ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом.
Результатом всего выражения NOT IN будет «true», если равных строк не найдётся (в том числе, и
когда подзапрос не возвращает строк), и «false», если такие строки есть.
Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам
сравнения. Две строки считаются равными, если все их соответствующие элементы не равны
NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не рав-
ные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён
(равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы
один NULL, результатом NOT IN будет NULL.
9.22.4. ANY/SOME
выражение оператор ANY (подзапрос)
выражение оператор SOME (подзапрос)
В правой части конструкции в скобках записывается подзапрос, который должен возвращать ров-
но один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой
строке результата подзапроса с помощью заданного оператора условия, который должен выдавать
логическое значение. Результатом ANY будет «true», если хотя бы для одной строки условие истин-
но, и «false» в противном случае (в том числе, и когда подзапрос не возвращает строк).
Ключевое слово SOME является синонимом ANY. Конструкцию IN можно записать также записать
как = ANY.
Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы для одной строки
условный оператор выдаёт NULL, конструкция ANY возвращает NULL, а не false. Это соответствует
принятым в SQL правилам сравнения переменных со значениями NULL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
конструктор_строки оператор ANY (подзапрос)
конструктор_строки оператор SOME (подзапрос)
В левой части этой формы ANY записывается конструктор строки (подробнее они описываются в
Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен возвращать ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом,
с применением заданного оператора. Результатом всего выражения ANY будет «true», если для
какой-либо из строк подзапроса результатом сравнения будет true, или «false», если для всех строк
результатом сравнения оказывается false (в том числе, и когда подзапрос не возвращает строк).
Результатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения
не равен true, а минимум для одной равен NULL.
Подробнее логика сравнения конструкторов строк описана в Подразделе 9.23.5.
9.22.5. ALL
выражение оператор ALL (подзапрос)
В правой части конструкции в скобках записывается подзапрос, который должен возвращать ров-
но один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой
строке результата подзапроса с помощью заданного оператора условия, который должен выдавать
логическое значение. Результатом ALL будет «true», если условие истинно для всех строк (и когда
подзапрос не возвращает строк), или «false», если находятся строки, для которых оно ложно. Ре-
зультатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения
не равен true, а минимум для одной равен NULL.
298Функции и операторы
Конструкция NOT IN равнозначна <> ALL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
конструктор_строки оператор ALL (подзапрос)
В левой части этой формы ALL записывается конструктор строки (подробнее они описываются в
Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен возвращать ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом,
с применением заданного оператора. Результатом всего выражения ALL будет «true», если для всех
строк подзапроса результатом сравнения будет true (или если подзапрос не возвращает строк),
либо «false», если результат сравнения равен false для любой из строк подзапроса. Результатом
выражения будет NULL, если ни для одной из строк подзапроса результат сравнения не равен true,
а минимум для одной равен NULL.
Подробнее логика сравнения конструкторов строк описана в Подразделе 9.23.5.
9.22.6. Сравнение единичных строк
конструктор_строки оператор (подзапрос)
В левой части конструкции записывается конструктор строки (подробнее они описываются в Под-
разделе  4.2.13). Справа в скобках записывается подзапрос, который должен возвращать ровно
столько столбцов, сколько содержит строка в выражении слева. Более того, подзапрос может вер-
нуть максимум одну строку. (Если он не вернёт строк, результатом будет NULL.) Конструкция воз-
вращает результат сравнения строки слева с этой одной строкой результата подзапроса.
Подробнее логика сравнения конструкторов строк описана в Подразделе 9.23.5.
9.23. Сравнение табличных строк и массивов
В этом разделе описываются несколько специальных конструкций, позволяющих сравнивать груп-
пы значений. Синтаксис этих конструкций связан с формами выражений с подзапросами, описан-
ными в предыдущем разделе, а отличаются они отсутствием подзапросов. Конструкции, в кото-
рых в качестве подвыражений используются массивы, являются расширениями PostgreSQL; все
остальные формы соответствуют стандарту SQL. Все описанные здесь выражения возвращают ло-
гические значения (true/false).
9.23.1. IN
выражение IN (значение [, ...])
Справа в скобках записывается список скалярных выражений. Результатом будет «true», если зна-
чение левого выражения равняется одному из значений выражений в правой части. Эту конструк-
цию можно считать краткой записью условия
выражение = значение1
OR
выражение = значение2
OR
...
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция IN возвращает NULL, а
не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.
9.23.2. NOT IN
выражение NOT IN (значение [, ...])
Справа в скобках записывается список скалярных выражений. Результатом будет «true», если зна-
чение левого выражения не равно ни одному из значений выражений в правой части. Эту кон-
струкцию можно считать краткой записью условия
299Функции и операторы
выражение <> значение1
AND
выражение <> значение2
AND
...
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция NOT IN возвращает
NULL, а не true, как можно было бы наивно полагать. Это соответствует принятым в SQL правилам
сравнения переменных со значениями NULL.
Подсказка
Выражения x NOT IN y и NOT (x IN y) полностью равнозначны. Учитывая, что значения
NULL могут ввести в заблуждение начинающих скорее в конструкции NOT IN, чем в IN,
лучше формулировать условия так, чтобы в них было как можно меньше отрицаний.
9.23.3. ANY/SOME (с массивом)
выражение оператор ANY (выражение массива)
выражение оператор SOME (выражение массива)
Справа в скобках записывается выражение, результатом которого является массив. Вычисленное
значение левого выражения сравнивается с каждым элементом этого массива с применением за-
данного оператора условия, который должен выдавать логическое значение. Результатом ANY бу-
дет «true», если для какого-либо элемента условие истинно, и «false» в противном случае (в том
числе, и когда массив оказывается пустым).
Если значением массива оказывается NULL, результатом ANY также будет NULL. Если NULL по-
лучен в левой части, результатом ANY обычно тоже будет NULL (хотя оператор нестрогого сравне-
ния может выдать другой результат). Кроме того, если массив в правой части содержит элементы
NULL и ни c одним из элементов условие не выполняется, результатом ANY будет NULL, а не false
(опять же, если используется оператор строгого сравнения). Это соответствует принятым в SQL
правилам сравнения переменных со значениями NULL.
Ключевое слово SOME является синонимом ANY.
9.23.4. ALL (с массивом)
выражение оператор ALL (выражение массива)
Справа в скобках записывается выражение, результатом которого является массив. Вычисленное
значение левого выражения сравнивается с каждым элементом этого массива с применением
заданного оператора условия, который должен выдавать логическое значение. Результатом ALL
будет «true», если для всех элементов условие истинно (или массив не содержит элементов), и
«false», если находятся строки, для которых оно ложно.
Если значением массива оказывается NULL, результатом ALL также будет NULL. Если NULL по-
лучен в левой части, результатом ALL обычно тоже будет NULL (хотя оператор нестрогого сравне-
ния может выдать другой результат). Кроме того, если массив в правой части содержит элементы
NULL и при этом нет элементов, с которыми условие не выполняется, результатом ALL будет NULL,
а не true (опять же, если используется оператор строгого сравнения). Это соответствует принятым
в SQL правилам сравнения переменных со значениями NULL.
9.23.5. Сравнение конструкторов строк
конструктор_строки оператор конструктор_строки
С обеих сторон представлены конструкторы строк (они описываются в Подразделе  4.2.13). При
этом данные строки должны содержать одинаковое число полей. После вычисления каждой сто-
300Функции и операторы
роны они сравниваются по строкам. Сравнения конструкторов строк возможны с оператором =, <>,
<, <=, > или >=. Каждый элемент строки должен иметь тип, для которого определён класс операто-
ров B-дерева; в противном случае при попытке сравнения может возникнуть ошибка.
Примечание
Ошибок, связанных с числом или типов элементов, не должно быть, если сравнение
выполняется с ранее полученными столбцами.
Сравнения = и <> несколько отличаются от других. С этими операторами две строки считаются
равными, если все их соответствующие поля не равны NULL и равны между собой, и неравными,
если какие-либо соответствующие их поля не NULL и не равны между собой. В противном случае
результатом сравнения будет неопределённость (NULL).
С операторами <, <=, > и >= элементы строк сравниваются слева направо до тех пор, пока не бу-
дет найдена пара неравных элементов или значений NULL. Если любым из элементов пары ока-
зывается NULL, результатом сравнения будет неопределённость (NULL), в противном случае ре-
зультат всего выражения определяется результатом сравнения этих двух элементов. Например,
результатом ROW(1,2,NULL) < ROW(1,3,0) будет true, а не NULL, так как третья пара элементов
не принимается в рассмотрение.
Примечание
До версии 8.2 PostgreSQL обрабатывал условия <, <=, > и >= не так, как это описано в
стандарте SQL. Сравнение ROW(a,b) < ROW(c,d) выполнялось как a < c AND b < d,
тогда как по стандарту должно быть a < c OR (a = c AND b < d).
конструктор_строки IS DISTINCT FROM конструктор_строки
Эта конструкция похожа на сравнение строк с оператором <>, но со значениями NULL она выдаёт
не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению
не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого
выражения будет true или false, но не NULL.
конструктор_строки IS NOT DISTINCT FROM конструктор_строки
Эта конструкция похожа на сравнение строк с оператором =, но со значениями NULL она выдаёт
не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению
не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого
выражения всегда будет true или false, но не NULL.
9.23.6. Сравнение составных типов
запись оператор запись
Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если результат зависит от
сравнения двух значений NULL или значения NULL и не NULL. PostgreSQL выполняет это требо-
вание только при сравнении строк, созданных конструкторами (как описано в Подразделе 9.23.5),
или строки, созданной конструктором, со строкой результата подзапроса (как было описано в Раз-
деле 9.22). В других контекстах при сравнении полей составных типов два значения NULL счита-
ются равными, а любое значение не NULL полагается меньшим NULL. Это отклонение от правила
необходимо для полноценной реализации сортировки и индексирования составных типов.
После вычисления каждой стороны они сравниваются по строкам. Сравнения составных типов
возможны с оператором =, <>, <, <=, > или >=, либо другим подобным. (Точнее, оператором сравне-
ния строк может быть любой оператор, входящий в класс операторов B-дерева, либо обратный к
оператору =, входящему в класс операторов B-дерева.) По умолчанию вышеперечисленные опера-
торы действуют так же, как выражение IS [ NOT ] DISTINCT FROM для конструкторов строк (см.
Подраздел 9.23.5).
301Функции и операторы
Для поддержки сравнения строк с элементами, для которых не определён класс операторов B-
дерева по умолчанию, введены следующие операторы: *=, *<>, *<, *<=, *> и *>=. Эти операторы
сравнивают внутреннее двоичное представление двух строк. Учтите, что две строки могут иметь
различное двоичное представление, даже когда при сравнении оператором равенства считаются
равными. Порядок строк с такими операторами детерминирован, но не несёт смысловой нагрузки.
Данные операторы применяются внутри системы для материализованных представлений и могут
быть полезны для других специальных целей (например, репликации), но, вообще говоря, не пред-
назначены для использования в обычных запросах.
9.24. Функции, возвращающие множества
В этом разделе описаны функции, которые могут возвращать не одну, а множество строк. Чаще
всего из их числа используются функции, генерирующие ряды значений, которые перечислены
в Таблице 9.58 и Таблице 9.59. Другие, более специализированные функции множеств описаны в
других разделах этой документации. Варианты комбинирования нескольких функций, возвращаю-
щих множества строк, описаны в Подразделе 7.2.1.4.
Таблица 9.58. Функции, генерирующие ряды значений
Функция Тип аргумента
Тип результата
Описание
generate_series(
start, stop) int, bigint или numeric setof
int,
setof Выдаёт ряд целых чи-
bigint
или
setof сел от start до stop с
numeric (определяется шагом 1
типом аргумента)
generate_series(
int, bigint или numeric setof
int,
setof Выдаёт ряд значений от
start, stop, step)
bigint
или
setof start до stop с задан-
numeric (определяется ным шагом (step)
типом аргумента)
generate_series(
timestamp
start,
stop,
step timestamp
interval)
zone
with
или setof timestamp или Выдаёт ряд значений от
time setof timestamp with start до stop с задан-
time zone (определяет- ным шагом (step)
ся типом аргумента)
Если заданный шаг (step) положительный, а start оказывается больше stop, эти функции возвра-
щают 0 строк. Тот же результат будет, если step меньше 0, а start меньше stop, или если какой-ли-
бо аргумент равен NULL. Если же step будет равен 0, произойдёт ошибка. Несколько примеров:
SELECT * FROM generate_series(2,4);
generate_series
-----------------
2
3
4
(3 rows)
SELECT * FROM generate_series(5,1,-2);
generate_series
-----------------
5
3
1
(3 rows)
SELECT * FROM generate_series(4,3);
generate_series
-----------------
(0 rows)
302Функции и операторы
SELECT generate_series(1.1, 4, 1.3);
generate_series
-----------------
1.1
2.4
3.7
(3 rows)
-- этот пример задействует оператор прибавления к дате целого числа
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
dates
------------
2004-02-05
2004-02-12
2004-02-19
(3 rows)
SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
'2008-03-04 12:00', '10 hours');
generate_series
---------------------
2008-03-01 00:00:00
2008-03-01 10:00:00
2008-03-01 20:00:00
2008-03-02 06:00:00
2008-03-02 16:00:00
2008-03-03 02:00:00
2008-03-03 12:00:00
2008-03-03 22:00:00
2008-03-04 08:00:00
(9 rows)
Таблица 9.59. Функции, генерирующие индексы массивов
Функция
Тип результата Описание
setof int Выдаёт ряд значений для ис-
пользования в качестве индекса
данного массива.
generate_subscripts( array setof int
anyarray, dim int, reverse
boolean) Выдаёт ряд значений для ис-
пользования в качестве индек-
са данного массива. Если пара-
метр reverse равен true, зна-
чения выдаются от большего к
меньшему.
generate_subscripts(
anyarray, dim int)
array
Функция generate_subscripts позволяет упростить получение всего набора индексов для указан-
ной размерности заданного массива. Она выдаёт 0 строк, если в массиве нет указанной размерно-
сти или сам массив равен NULL (хотя для элементов, равных NULL, индексы будут выданы, как и
для любых других). Взгляните на следующие примеры:
-- простой пример использования
SELECT generate_subscripts('(NULL,1,NULL,2)'::int[], 1) AS s;
s
---
1
2
3
303Функции и операторы
4
(4 rows)
-- для показанного массива получение индекса и обращение
-- к элементу по индексу выполняется с помощью подзапроса
SELECT * FROM arrays;
a
--------------------
(-1,-2)
(100,200,300)
(2 rows)
SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
array
| subscript | value
---------------+-----------+-------
(-1,-2)
|
1 |
-1
(-1,-2)
|
2 |
-2
(100,200,300) |
1 |
100
(100,200,300) |
2 |
200
(100,200,300) |
3 |
300
(5 rows)
-- разворачивание двумерного массива
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
from generate_subscripts($1,1) g1(i),
generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
unnest2
---------
1
2
3
4
(4 rows)
Когда после функции в предложении FROM добавляется WITH ORDINALITY, в выходные данные до-
бавляется столбец типа bigint, числа в котором начинаются с 1 и увеличиваются на 1 для каждой
строки, выданной функцией. В первую очередь это полезно для функций, возвращающих множе-
ства, например, unnest().
-- функция, возвращающая множество, с нумерацией
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
ls
| n
-----------------+----
pg_serial
| 1
pg_twophase
| 2
postmaster.opts | 3
pg_notify
| 4
postgresql.conf | 5
pg_tblspc
| 6
logfile
| 7
base
| 8
postmaster.pid | 9
304Функции и операторы
pg_ident.conf
global
pg_xact
pg_snapshots
pg_multixact
PG_VERSION
pg_wal
pg_hba.conf
pg_stat_tmp
pg_subtrans
(19 строк)
|
|
|
|
|
|
|
|
|
|
10
11
12
13
14
15
16
17
18
19
9.25. Системные информационные функции
В Таблице 9.60 перечислен ряд функций, предназначенных для получения информации о текущем
сеансе и системе.
В дополнение к перечисленным здесь функциям существуют также функции, связанные с под-
системой статистики, которые тоже предоставляют системную информацию. Подробнее они рас-
сматриваются в Подразделе 28.2.2.
Таблица 9.60. Функции получения информации о сеансе
Имя Тип результата Описание
current_catalog name имя текущей базы данных (в
стандарте SQL она называется
«каталогом»)
current_database() name имя текущей базы данных
current_query() text текст запроса, выполняемого в
данный момент, в том виде, в ка-
ком его передал клиент (может
состоять из нескольких опера-
торов)
current_role name синоним current_user
current_schema [()] name имя текущей схемы
current_schemas( name[] имена схем в пути поиска, воз-
можно включая схемы, добавля-
емые в него неявно
current_user name имя пользователя в текущем
контексте выполнения
inet_client_addr() inet адрес удалённой стороны со-
единения
inet_client_port() int порт удалённой стороны соеди-
нения
inet_server_addr() inet адрес локальной стороны соеди-
нения
inet_server_port() int порт локальной стороны соеди-
нения
pg_backend_pid() int код серверного процесса, обслу-
живающего текущий сеанс
int[] идентификаторы процессов, не
дающих серверному процессу с
определённым ID получить бло-
кировку
pg_blocking_pids(
boolean)
int)
305Функции и операторы
Имя Тип результата Описание
pg_conf_load_time() timestamp with time zone время загрузки конфигурации
pg_current_logfile(
[ text]) text имя файла главного журнала
или журнала в заданном форма-
те, который в настоящее время
используется сборщиком сооб-
щений
pg_my_temp_schema() oid OID временной схемы этого се-
анса или 0, если её нет
pg_is_other_temp_schema(
oid) boolean является ли заданная схема
временной в другом сеансе?
pg_jit_available() boolean доступна ли JIT-компиляция в
данном сеансе (см. Главу  32)?
Возвращает false, если пара-
метр jit равен false.
pg_listening_channels() setof text имена каналов, по которым те-
кущий сеанс принимает сигна-
лы
pg_notification_queue_
usage() double занятая доля очереди асинхрон-
ных уведомлений (0-1)
pg_postmaster_start_time(
) timestamp with time zone время запуска сервера
pg_safe_snapshot_
blocking_pids(
int) int[] Идентификаторы процессов, не
дающих серверному процессу с
определённым ID получить без-
опасный снимок
pg_trigger_depth() int текущий уровень вложенности
в триггерах PostgreSQL (0, если
эта функция вызывается (прямо
или косвенно) не из тела триг-
гера)
session_user name имя пользователя сеанса
user name синоним current_user
version() text информация
о
версии
PostgreSQL. Также можно про-
читать версию в машинно-ори-
ентированном виде, обратив-
шись к переменной server_
version_num.
Примечание
Функции current_catalog, current_role, current_schema, current_user, session_user
и user имеют особый синтаксический статус в SQL: они должны вызываться без скобок
после имени. (PostgreSQL позволяет добавить скобки в вызове current_schema, но не
других функций.)
Функция session_user обычно возвращает имя пользователя, установившего текущее соединение
с базой данных, но суперпользователи могут изменить это имя, выполнив команду SET SESSION
AUTHORIZATION. Функция current_user возвращает идентификатор пользователя, по которому
будут проверяться его права. Обычно это тот же пользователь, что и пользователь сеанса, но его
306Функции и операторы
можно сменить с помощью SET ROLE. Этот идентификатор также меняется при выполнении функ-
ций с атрибутом SECURITY DEFINER. На языке Unix пользователь сеанса называется «реальным»,
а текущий — «эффективным». Имена current_role и user являются синонимами current_user.
(В стандарте SQL current_role и current_user имеют разное значение, но в PostgreSQL они не
различаются, так как пользователи и роли объединены в единую сущность.)
Функция current_schema возвращает имя схемы, которая стоит первой в пути поиска (или NULL,
если путь поиска пуст). Эта схема будет задействована при создании таблиц или других имено-
ванных объектов, если целевая схема не указана явно. Функция current_schemas(boolean) возвра-
щает массив имён всех схем, находящихся в пути поиска. Её логический параметр определяет,
будут ли включаться в результат неявно добавляемые в путь поиска системные схемы, такие как
pg_catalog.
Примечание
Путь поиска можно изменить во время выполнения следующей командой:
SET search_path TO схема [, схема, ...]
Функция inet_client_addr возвращает IP-адрес текущего клиента, inet_client_port — номер
его порта, inet_server_addr — IP-адрес сервера, по которому он принял подключение клиента,
а inet_server_port — соответствующий номер порта. Все эти функции возвращают NULL, если
текущее соединение устанавливается через Unix-сокет.
Функция pg_blocking_pids возвращает массив идентификаторов процессов сеансов, которые бло-
кирует серверный процесс с указанным идентификатором, либо пустой массив, если такой сер-
верный процесс не найден или не заблокирован. Один серверный процесс блокирует другой, если
он либо удерживает блокировку, конфликтующую с блокировкой, запрашиваемой серверным про-
цессом (жёсткая блокировка), либо ждёт блокировки, которая вызвала бы конфликт с запросом
блокировки заблокированного процесса и находится перед ней в очереди ожидания (мягкая бло-
кировка). При распараллеливании запросов эта функция всегда выдаёт видимые клиентом иден-
тификаторы процессов (то есть, результаты pg_backend_pid), даже если фактическая блокировка
удерживается или ожидается дочерним рабочим процессом. Вследствие этого, в результатах мо-
гут оказаться дублирующиеся PID. Также заметьте, что когда конфликтующую блокировку удер-
живает подготовленная транзакция, в выводе этой функции она будет представлена нулевым ID
процесса. Частые вызовы этой функции могут отразиться на производительности базы данных, так
как ей нужен монопольный доступ к общему состоянию менеджера блокировок, хоть и на корот-
кое время.
Функция pg_conf_load_time возвращает время (timestamp with time zone), когда в последний
раз сервер загружал файлы конфигурации. (Если текущий сеанс начался раньше, она возвращает
время, когда эти файлы были перезагружены для данного сеанса, так что в разных сеансах это
значение может немного различаться. В противном случае это будет время, когда файлы конфи-
гурации считал главный процесс.)
Функция pg_current_logfile возвращает в значении text путь к файлам журналов, в настоящее
время используемым сборщиком сообщений. Этот путь состоит из каталога log_directory и имени
файла журнала. Если сборщик сообщений отключён, возвращается значение NULL. Если ведутся
несколько журналов в разных форматах, при вызове функции pg_current_logfile без аргументов
возвращается путь файла, имеющего первый формат по порядку из следующего списка: stderr,
csvlog. Если файл журнала имеет какой-то иной формат, возвращается NULL. Чтобы запросить файл
в определённом формате, передайте либо csvlog, либо stderr в качестве значения необязательного
параметра типа text. Если запрошенный формат не включён в log_destination, будет возвращено
значение NULL. Функция pg_current_logfiles отражает содержимое файла current_logfiles.
pg_my_temp_schema возвращает OID временной схемы текущего сеанса или 0, если такой нет (в
рамках сеанса не создавались временные таблицы). pg_is_other_temp_schema возвращает true, ес-
307Функции и операторы
ли заданный OID относится к временной схеме другого сеанса. (Это может быть полезно, напри-
мер для исключения временных таблиц других сеансов из общего списка при просмотре таблиц
базы данных.)
Функция pg_listening_channels возвращает набор имён каналов асинхронных уведомлений, на
которые подписан текущий сеанс. Функция pg_notification_queue_usage возвращает долю от все-
го свободного пространства для уведомлений, в настоящее время занятую уведомлениями, ожи-
дающими обработки, в виде значения double в диапазоне 0..1. За дополнительными сведениями
обратитесь к LISTEN и NOTIFY.
pg_postmaster_start_time возвращает время (timestamp with time zone), когда был запущен
сервер.
Функция pg_safe_snapshot_blocking_pids возвращает массив идентификаторов процессов сеан-
сов, которые блокируют серверный процесс с указанным идентификатором (не дают получить
ему безопасный снимок), либо пустой массив, если такой серверный процесс не найден или
не заблокирован. Сеанс, выполняющий транзакцию уровня SERIALIZABLE, блокирует транзакцию
SERIALIZABLE READ ONLY DEFERRABLE, не давая ей получить снимок, пока она не определит, что
можно безопасно избежать установления предикатных блокировок. За дополнительными сведени-
ями о сериализуемых и откладываемых транзакциях обратитесь к Подразделу 13.2.3. Частые вы-
зовы этой функции могут отразиться на производительности базы данных, так как ей нужен доступ
к общему состоянию менеджера предикатных блокировок, хоть и на короткое время.
Функция version возвращает строку, описывающую версию сервера PostgreSQL. Эту информа-
цию также можно получить из переменной server_version или, в более машинно-ориентирован-
ном формате, из переменной server_version_num. При разработке программ следует использовать
server_version_num (она появилась в версии 8.2) либо PQserverVersion , а не разбирать тексто-
вую версию.
В Таблице  9.61 перечислены функции, позволяющую пользователю программно проверить свои
права доступа к объектам. Подробнее о правах можно узнать в Разделе 5.6.
Таблица 9.61. Функции для проверки прав доступа
Имя
Тип результата
Описание
has_any_column_privilege
( boolean
user, table, privilege) имеет ли пользователь ука-
занное право для какого-либо
столбца таблицы
has_any_column_privilege
table, privilege) ( boolean имеет ли текущий пользователь
указанное право для какого-ли-
бо столбца таблицы
has_column_privilege (
boolean
user,
table,
column,
privilege) имеет ли пользователь указан-
ное право для столбца
has_column_privilege (
boolean
table, column, privilege) имеет ли текущий пользователь
указанное право для столбца
has_database_privilege (
boolean
user, database, privilege) имеет ли пользователь указан-
ное право для базы данных
has_database_privilege
database, privilege) boolean имеет ли текущий пользователь
указанное право для базы дан-
ных
has_foreign_data_wrapper_
boolean
privilege ( user,
fdw,
privilege) имеет ли пользователь указан-
ное право для обёртки сторон-
них данных
(
308Функции и операторы
Имя
Тип результата
Описание
has_foreign_data_wrapper_
boolean
privilege ( fdw, privilege) имеет ли текущий пользователь
указанное право для обёртки
сторонних данных
has_function_privilege (
boolean
user, function, privilege) имеет ли пользователь указан-
ное право для функции
has_function_privilege
function, privilege) boolean имеет ли текущий пользователь
указанное право для функции
has_language_privilege (
boolean
user, language, privilege) имеет ли пользователь указан-
ное право для языка
has_language_privilege
language, privilege) boolean имеет ли текущий пользователь
указанное право для языка
has_schema_privilege (
user, schema, privilege) boolean имеет ли пользователь указан-
ное право для схемы
has_schema_privilege
schema, privilege) boolean имеет ли текущий пользователь
указанное право для схемы
has_sequence_privilege (
boolean
user, sequence, privilege) имеет ли пользователь указан-
ное право для последовательно-
сти
has_sequence_privilege
sequence, privilege) boolean имеет ли текущий пользователь
указанное право для последова-
тельности
has_server_privilege (
user, server, privilege) boolean имеет ли пользователь указан-
ное право для стороннего серве-
ра
has_server_privilege
server, privilege) boolean имеет ли текущий пользователь
указанное право для сторонне-
го сервера
has_table_privilege ( user, boolean
table, privilege) имеет ли пользователь указан-
ное право для таблицы
has_table_privilege
table, privilege) boolean имеет ли текущий пользователь
указанное право для таблицы
has_tablespace_privilege ( boolean
user,
tablespace,
privilege) имеет ли пользователь указан-
ное право для табличного про-
странства
has_tablespace_privilege
tablespace, privilege)
(
(
(
(
(
(
( boolean имеет ли текущий пользователь
указанное право для таблично-
го пространства
has_type_privilege ( user,
type, privilege) boolean имеет ли пользователь указан-
ное право для типа
has_type_privilege
privilege) boolean имеет ли текущий пользователь
указанное право для типа
pg_has_role ( user,
privilege) role, boolean имеет ли пользователь указан-
ное право для роли
pg_has_role ( role,
privilege) boolean имеет ли текущий пользователь
указанное право для роли
boolean включена ли для текущего
пользователя защита на уровне
строк для таблицы
row_security_active
table)
( type,
(
309Функции и операторы
has_table_privilege проверяет, может ли пользователь выполнять с таблицей заданные действия.
В качестве идентификатора пользователя можно задать его имя, OID (pg_authid.oid) или public
(это будет указывать на псевдороль PUBLIC). Если этот аргумент опущен, подразумевается теку-
щий пользователь (current_user). Таблицу можно указать по имени или по OID. (Таким образом,
фактически есть шесть вариантов функции has_table_privilege, различающихся по числу и типу
аргументов.) Когда указывается имя объекта, его можно дополнить именем схемы, если это необ-
ходимо. Интересующее право доступа записывается в виде текста и может быть одним из следую-
щих: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES и TRIGGER. Дополнительно к названию
права можно добавить WITH GRANT OPTION и проверить, разрешено ли пользователю передавать это
право другим. Кроме того, в одном параметре можно перечислить несколько названий прав через
запятую, и тогда функция возвратит true, если пользователь имеет одно из этих прав. (Регистр в
названии прав не имеет значения, а между ними (но не внутри) разрешены пробельные символы.)
Пара примеров:
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable',
'INSERT, SELECT WITH GRANT OPTION');
has_sequence_privilege проверяет, может ли пользователь выполнять заданные действия с по-
следовательностью. В определении аргументов эта функция аналогична has_table_privilege. До-
пустимые для неё права складываются из USAGE, SELECT и UPDATE.
has_any_column_privilege проверяет, может ли пользователь выполнять заданные дей-
ствия с каким-либо столбцом таблицы. В определении аргументов эта функция аналогич-
на has_table_privilege, а допустимые права складываются из SELECT, INSERT, UPDATE и
REFERENCES. Заметьте, что любое из этих прав, назначенное на уровне таблицы, автоматиче-
ски распространяется на все её столбцы, так что has_any_column_privilege всегда возвра-
щает true, если has_table_privilege даёт положительный ответ для тех же аргументов. Но
has_any_column_privilege возвращает true ещё и тогда, когда право назначено только для неко-
торых столбцов.
has_column_privilege проверяет, может ли пользователь выполнять заданные действия со столб-
цом таблицы. В определении аргументов эта функция аналогична has_table_privilege, с неболь-
шим дополнением: столбец можно задать по имени или номеру атрибута. Для неё допустимые
права складываются из SELECT, INSERT, UPDATE и REFERENCES. Заметьте, что любое из этих прав,
назначенное на уровне таблицы, автоматически распространяется на все столбцы таблицы.
has_database_privilege проверяет, может ли пользователь выполнять заданные действия с базой
данных. В определении аргументов эта функция аналогична has_table_privilege. Для неё допу-
стимые права складываются из CREATE, CONNECT и TEMPORARY (или TEMP, что равносильно TEMPORARY).
has_function_privilege проверяет, может ли пользователь обратиться к заданной функции. В
определении аргументов эта функция аналогична has_table_privilege. Когда функция определя-
ется не своим OID, а текстовой строкой, эта строка должна быть допустимой для вводимого зна-
чения типа regprocedure (см. Раздел 8.19). Для этой функции допустимо только право EXECUTE.
Например:
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
has_foreign_data_wrapper_privilege проверяет, может ли пользователь обращаться к обёртке
сторонних данных. В определении аргументов она аналогична has_table_privilege. Для неё до-
пустимо только право USAGE.
has_language_privilege проверяет, может ли пользователь обращаться к процедурному языку. В
определении аргументов эта функция аналогична has_table_privilege. Для неё допустимо только
право USAGE.
has_schema_privilege проверяет, может ли пользователь выполнять заданные действия со схемой.
В определении аргументов эта функция аналогична has_table_privilege. Для неё допустимые
права складываются из CREATE и USAGE.
310Функции и операторы
has_server_privilege проверяет, может ли пользователь обращаться к стороннему серверу. В
определении аргументов она аналогична has_table_privilege. Для неё допустимо только право
USAGE.
has_tablespace_privilege проверяет, может ли пользователь выполнять заданное действие в таб-
личном пространстве. В определении аргументов эта функция аналогична has_table_privilege.
Для неё допустимо только право CREATE.
has_type_privilege проверяет, может ли пользователь обратиться к типу определённым образом.
Возможные аргументы аналогичны has_table_privilege. При указании типа текстовой строкой, а
не по OID, допускаются те же входные значения, что и для типа данных regtype (см. Раздел 8.19).
Для неё допустимо только право USAGE.
pg_has_role проверяет, может ли пользователь выполнять заданные действия с ролью. В опреде-
лении аргументов эта функция аналогична has_table_privilege, за исключением того, что име-
нем пользователя не может быть public. Для неё допустимые права складываются из MEMBER и
USAGE. MEMBER обозначает прямое или косвенное членство в данной роли (то есть наличие права
выполнить команду SET ROLE), тогда как USAGE показывает, что пользователь получает все права
роли сразу, без SET ROLE.
row_security_active проверяет, включена ли защита на уровне строк для указанной таблицы в
контексте и окружении текущего пользователя (current_user). Таблицу можно задать по имени
или OID.
В Таблице 9.62 перечислены функции, определяющие видимость объекта с текущим путём поиска
схем. К примеру, таблица считается видимой, если содержащая её схема включена в путь поиска
и нет другой таблицы с тем же именем, которая была бы найдена по пути поиска раньше. Другими
словами, к этой таблице можно будет обратиться просто по её имени, без явного указания схемы.
Просмотреть список всех видимых таблиц можно так:
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
Таблица 9.62. Функции для определения видимости
Имя Тип результата Описание
pg_collation_is_visible(
collation_oid ) boolean видимо ли правило сортировки
pg_conversion_is_visible(
conversion_oid ) boolean видимо ли преобразование
pg_function_is_visible(
function_oid ) boolean видима ли функция
pg_opclass_is_visible(
opclass_oid ) boolean видим ли класс операторов
pg_operator_is_visible(
operator_oid ) boolean видим ли оператор
pg_opfamily_is_visible(
opclass_oid ) boolean видимо ли семейство операто-
ров
pg_statistics_obj_is_
visible( stat_oid ) boolean видим ли объект статистики в
пути поиска
pg_table_is_visible(
table_oid ) boolean видима ли таблица
pg_ts_config_is_visible(
config_oid ) boolean видима ли конфигурация тек-
стового поиска
pg_ts_dict_is_visible(
dict_oid ) boolean видим ли словарь текстового по-
иска
311Функции и операторы
Имя Тип результата Описание
pg_ts_parser_is_visible(
parser_oid ) boolean видим ли анализатор текстово-
го поиска
pg_ts_template_is_
visible( template_oid ) boolean видим ли шаблон текстового по-
иска
pg_type_is_visible(
oid )
видим ли тип (или домен)
type_ boolean
Каждая из этих функций проверяет видимость объектов определённого типа. Заметьте, что
pg_table_is_visible можно также использовать для представлений, материализованных пред-
ставлений, индексов, последовательностей и сторонних таблиц; pg_function_is_visible — для
процедур и агрегатных функций; pg_type_is_visible — для доменов. Для функций и операторов
объект считается видимым в пути поиска, если при просмотре пути не находится предшествующий
ему другой объект с тем же именем и типами аргументов. Для классов операторов во внимание
принимается и имя оператора, и связанный с ним метод доступа к индексу.
Всем этим функциям должен передаваться OID проверяемого объекта. Если вы хотите проверить
объект по имени, удобнее использовать типы-псевдонимы OID (regclass, regtype, regprocedure,
regoperator, regconfig или regdictionary), например:
SELECT pg_type_is_visible('myschema.widget'::regtype);
Заметьте, что проверять таким способом имена без указания схемы не имеет большого смысла —
если имя удастся распознать, значит и объект будет видимым.
В Таблице 9.63 перечислены функции, извлекающие информацию из системных каталогов.
Таблица 9.63. Функции для обращения к системным каталогам
Имя
Тип результата Описание
text получает имя типа данных в
формате SQL
text получает определение ограни-
чения
pg_get_constraintdef(
text
constraint_oid ,
pretty_
bool ) получает определение ограни-
чения
pg_get_expr(
pg_node_
tree , relation_oid ) text декомпилирует
внутреннюю
форму выражения, в предполо-
жении, что все переменные в
нём ссылаются на таблицу или
отношение, указанное вторым
параметром
pg_get_expr(
pg_node_
text
tree ,
relation_oid ,
pretty_bool ) декомпилирует
внутреннюю
форму выражения, в предполо-
жении, что все переменные в
нём ссылаются на таблицу или
отношение, указанное вторым
параметром
pg_get_functiondef(
oid ) text получает определение функции
или процедуры
text получает список аргументов из
определения функции или про-
цедуры (со значениями по умол-
чанию)
format_type(
typemod)
type_oid ,
pg_get_constraintdef(
constraint_oid )
pg_get_function_
arguments( func_oid )
func_
312Функции и операторы
Имя Тип результата Описание
pg_get_function_identity_
arguments( func_oid ) text получает список аргументов,
идентифицирующий функцию
или процедуру (без значений по
умолчанию)
pg_get_function_result(
func_oid ) text получает предложение RETURNS
для функции (для процедуры
возвращает NULL)
pg_get_indexdef(
oid ) text получает команду CREATE INDEX
для индекса
pg_get_indexdef(
index_
text
oid ,
column_no ,
pretty_
bool ) получает команду CREATE INDEX
для индекса или определе-
ние одного индексированного
столбца, когда column_no не
равен 0
pg_get_keywords() получает список ключевых слов
SQL по категориям
index_
setof record
pg_get_ruledef( rule_oid ) text получает команду CREATE RULE
для правила
pg_get_ruledef(
pretty_bool ) rule_oid , text получает команду CREATE RULE
для правила
pg_get_serial_sequence(
text
table_name , column_name ) получает имя последователь-
ности, используемой столбцом
идентификации или столбцом
serial
pg_get_statisticsobjdef(
statobj_oid ) text получает
команду
CREATE
STATISTICS для объекта расши-
ренной статистики
(trigger_ text получает
команду
CREATE
[ CONSTRAINT ] TRIGGER для
триггера
pg_get_triggerdef (trigger_ text
oid , pretty_bool ) получает
команду
CREATE
[ CONSTRAINT ] TRIGGER для
триггера
pg_get_userbyid(
oid ) name получает имя роли по заданно-
му OID
view_ text получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление (устаревшая функция)
pg_get_viewdef(
view_
name , pretty_bool ) text получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление (устаревшая функция)
pg_get_viewdef( view_oid ) text получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление
pg_get_viewdef(
pretty_bool ) view_oid , text получает команду SELECT, опре-
деляющую представление или
pg_get_triggerdef
oid )
pg_get_viewdef(
name )
role_
313Функции и операторы
Имя
Тип результата
Описание
материализованное
ление
представ-
pg_get_viewdef(
view_oid , text
wrap_column_int ) получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление; при необходимости раз-
бивает строки с полями, вы-
ходящие за wrap_int симво-
лов, подразумевая форматиро-
ванный вывод
pg_index_column_has_
property( index_oid ,
column_no , prop_name ) boolean проверяет, имеет ли столбец ин-
декса заданное свойство
pg_index_has_property(
index_oid , prop_name ) boolean проверяет, имеет ли индекс за-
данное свойство
pg_indexam_has_property(
am_oid , prop_name ) boolean проверяет, имеет ли метод до-
ступа индекса заданное свой-
ство
pg_options_to_table(
reloptions) setof record получает набор параметров хра-
нилища в виде имя/значение
pg_tablespace_databases(
tablespace_oid ) setof oid получает или устанавливает
OID баз данных, объекты кото-
рых содержатся в заданном таб-
личном пространстве
pg_tablespace_location(
tablespace_oid ) text получает путь в файловой си-
стеме к местоположению задан-
ного табличного пространства
pg_typeof( regtype получает тип данных любого
значения
collation for ( any) text получает правило сортировки
для аргумента
to_regclass( rel_name ) regclass получает OID указанного отно-
шения
to_regproc( func_name ) regproc получает OID указанной функ-
ции
regprocedure получает OID указанной функ-
ции
any)
to_regprocedure(
name )
to_regoper(
имя_
type_name )
to_regnamespace(
name )
to_regrole(
получает OID указанного опера-
тора
имя_оператора ) regoper
to_regoperator(
оператора)
to_regtype(
func_
schema_
role_name )
regoperator получает OID указанного опера-
тора
regtype получает OID указанного типа
regnamespace получает OID указанной схемы
regrole получает OID указанной роли
format_type возвращает в формате SQL имя типа данных, определяемого по OID и, возможно,
модификатору типа. Если модификатор неизвестен, вместо него можно передать NULL.
314Функции и операторы
pg_get_keywords возвращает таблицу с ключевыми словами SQL, которые воспринимает сервер.
Столбец word содержит ключевое слово, а catcode — код категории: U — не зарезервировано, C
— имя столбца, T — имя типа или функции, R — зарезервировано. Столбец catdesc содержит воз-
можно локализованное описание категории.
pg_get_constraintdef,
pg_get_indexdef,
pg_get_ruledef,
pg_get_statisticsobjdef
и
pg_get_triggerdef восстанавливают команду, создававшую заданное ограничение, индекс, пра-
вило, объект статистики или триггер, соответственно. (Учтите, что они возвращают не изначаль-
ный текст команды, а результат декомпиляции.) pg_get_expr декомпилирует внутреннюю форму
отдельного выражения, например значения по умолчанию для столбца. Это может быть полез-
но для изучения содержимого системных каталогов. Если выражение может содержать перемен-
ные, укажите во втором параметре OID отношения, на который они ссылаются; если таких пере-
менных нет, вместо OID можно передать 0. pg_get_viewdef восстанавливает запрос SELECT, опре-
деляющий представление. Многие из этих функций имеют две версии, одна из которых позволя-
ет получить форматированный вывод (с параметром pretty_bool). Форматированный текст легче
читается, но нет гарантии, что он будет всегда восприниматься одинаково будущими версиями
PostgreSQL; поэтому не следует применять форматирование при выгрузке метаданных. Если в па-
раметре pretty_bool передаётся false, эта версия функции выдаёт тот же результат, что и версия
без параметров.
pg_get_functiondef возвращает полный оператор CREATE OR REPLACE FUNCTION для заданной функ-
ции. pg_get_function_arguments возвращает список аргументов функции, в виде достаточном для
включения в команду CREATE FUNCTION. pg_get_function_result в дополнение возвращает готовое
предложение RETURNS для функции. pg_get_function_identity_arguments возвращает список ар-
гументов, достаточный для однозначной идентификации функции, в форме, допустимой, например
для команды ALTER FUNCTION. Значения по умолчанию в этой форме опускаются.
pg_get_serial_sequence возвращает имя последовательности, связанной со столбцом, либо NULL,
если такой последовательности нет. Для столбца идентификации это будет последовательность,
связанная с ним внутренним образом. Для столбцов, имеющих один из последовательных типов
(serial, smallserial, bigserial), это последовательность, созданная объявлением данного столб-
ца. В последнем случае эту связь можно изменить или разорвать, воспользовавшись командой
ALTER SEQUENCE OWNED BY. (Возможно, эту функцию стоило назвать pg_get_owned_sequence; её
существующее имя отражает тот факт, что она обычно используется со столбцами serial или
bigserial.) В первом параметре функции указывается имя таблицы, возможно дополненное схе-
мой, а во втором имя столбца. Так как первый параметр может содержать имя схемы и таблицы,
он воспринимается не как идентификатор в кавычках и поэтому по умолчанию приводится к ниж-
нему регистру, тогда как имя столбца во втором параметре воспринимается как заключённое в
кавычки и в нём регистр символов сохраняется. Эта функция возвращает имя в виде, пригодном
для передачи функциям, работающим с последовательностями (см. Раздел 9.16). Обычно она при-
меняется для получения текущего значения последовательности для столбца идентификации или
последовательного столбца, например:
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
pg_get_userbyid получает имя роли по её OID.
Функции pg_index_column_has_property, pg_index_has_property и pg_indexam_has_property по-
казывают, обладает ли указанный столбец индекса, индекс или метод доступа индекса заданным
свойством. Они возвращают NULL, если имя свойства неизвестно или неприменимо к конкретному
объекту, либо если OID или номер столбца не указывают на действительный объект. Описание
свойств столбцов вы можете найти в Таблице 9.64, свойства индексов описаны в Таблице 9.65, а
свойства методов доступа — в Таблица 9.66. (Заметьте, что методы доступа, реализуемые расши-
рениями, могут определять для своих индексов дополнительные имена свойств.)
Таблица 9.64. Свойства столбца индекса
Имя Описание
asc Сортируется ли столбец по возрастанию при
сканировании вперёд?
315Функции и операторы
Имя Описание
desc Сортируется ли столбец по убыванию при скани-
ровании вперёд?
nulls_first Выдаются ли NULL в начале при сканирования
вперёд?
nulls_last Выдаются ли NULL в конце при сканировании
вперёд?
orderable Связан ли со столбцом некоторый порядок сор-
тировки?
distance_orderable Может ли столбец сканироваться по порядку
оператором «расстояния», например, ORDER BY
столбец <-> константа ?
returnable Может ли значение столбца быть получено при
сканировании только индекса?
search_array Поддерживает ли столбец внутренними сред-
ствами поиск столбец = ANY(массив) ?
search_nulls Поддерживает ли столбец поиск IS NULL и IS
NOT NULL?
Таблица 9.65. Свойства индекса
Имя Описание
clusterable Может ли индекс использоваться в команде
CLUSTER?
index_scan Поддерживает ли индекс простое сканирование
(не по битовой карте)?
bitmap_scan Поддерживает ли индекс сканирование по бито-
вой карте?
backward_scan Может ли в процессе сканирования меняться на-
правление (для поддержки перемещения курсо-
ра FETCH BACKWARD без необходимости материа-
лизации)?
Таблица 9.66. Свойства метода доступа индекса
Имя Описание
can_order Поддерживает ли метод доступа ASC, DESC и свя-
занные ключевые слова в CREATE INDEX?
can_unique Поддерживает ли метод доступа уникальные ин-
дексы?
can_multi_col Поддерживает ли метод доступа индексы по
нескольким столбцам?
can_exclude Поддерживает ли
ния-исключения?
can_include Поддерживает ли метод доступа предложение
INCLUDE команды CREATE INDEX?
метод
доступа
ограниче-
pg_options_to_table возвращает набор параметров хранилища в виде пар (имя_параметра/значе-
ние_параметра), когда ей передаётся pg_class.reloptions или pg_attribute.attoptions.
pg_tablespace_databases позволяет изучить содержимое табличного пространства. Она возвра-
щает набор OID баз данных, объекты которых размещены в этом табличном пространстве. Если
316Функции и операторы
эта функция возвращает строки, это означает, что табличное пространство не пустое и удалить
его нельзя. Какие именно объекты находятся в табличном пространстве, можно узнать, подклю-
чаясь к базам данных, OID которых сообщила pg_tablespace_databases, и анализируя их каталоги
pg_class.
pg_typeof возвращает OID типа данных для переданного значения. Это может быть полезно для
разрешения проблем или динамического создания SQL-запросов. Эта функция объявлена как воз-
вращающая тип regtype, который является псевдонимом типа OID (см. Раздел 8.19); это означает,
что значение этого типа можно сравнивать как OID, но выводится оно как название типа. Напри-
мер:
SELECT pg_typeof(33);
pg_typeof
-----------
integer
(1 row)
SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
typlen
--------
4
(1 row)
Выражение collation for возвращает правило сортировки для переданного значения. Например:
SELECT collation for (description) FROM pg_description LIMIT 1;
pg_collation_for
------------------
"default"
(1 row)
SELECT collation for ('foo' COLLATE "de_DE");
pg_collation_for
------------------
"de_DE"
(1 row)
Это значение может быть заключено в кавычки и дополнено схемой. Если для выражения аргу-
мента нет правила сортировки, возвращается значение NULL. Если же правила сортировки не
применимы для типа аргумента, происходит ошибка.
Функции to_regclass, to_regproc, to_regprocedure, to_regoper, to_regoperator, to_regtype,
to_regnamespace и to_regrole преобразуют имена отношений, функций, операторов, типов, схем
и ролей (заданных значением text) в объекты типа regclass, regproc, regprocedure, regoper,
regoperator, regtype, regnamespace и regrole, соответственно. Перечисленные функции отлича-
ются от явных приведений к этим типам тем, что они не принимают числовые OID и возвращают
NULL вместо ошибки, если имя не найдено (или, в случае с to_regproc и to_regoper, если данному
имени соответствуют несколько объектов).
В Таблице 9.67 перечислены функции, связанные с идентификацией и адресацией объектов баз
данных.
Таблица 9.67. Функции получения информации и адресации объектов
Имя
pg_describe_object(
classid oid,
objid
objsubid integer)
Тип результата Описание
text получает описание объекта ба-
зы данных
oid,
317Функции и операторы
Имя
Тип результата
pg_identify_object(
classid oid,
objid
objsubid integer)
Описание
type text, schema text, name получает идентификатор объек-
та базы данных
oid, text, identity text
pg_identify_object_as_
type
text,
object_names
address( classid oid, objid text[], object_args text[]
oid, objsubid integer)
pg_get_object_address(
classid
oid,
objid
type text,
object_names objsubid integer
text[], object_args text[])
получает внешнее представле-
ние адреса объекта базы данных
oid, получает адрес объекта базы
данных из его внешнего пред-
ставления
pg_describe_object возвращает текстовое описание объекта БД, идентифицируемого по OID ка-
талога, OID объекта и ID подобъекта (например, номер столбца в таблице; ID подобъекта равен
нулю для объекта в целом). Это описание предназначено для человека и может переводиться, в
зависимости от конфигурации сервера. С помощью этой функции, например, можно узнать, что за
объект хранится в каталоге pg_depend.
pg_identify_object возвращает запись, содержащую достаточно информации для однозначной
идентификации объекта БД по OID каталога, OID объекта и ID подобъекта. Эта информация пред-
назначена для машины и поэтому никогда не переводится. Столбец type содержит тип объекта
БД; schema — имя схемы, к которой относится объект (либо NULL для объектов, не относящихся к
схемам); name — имя объекта, при необходимости в кавычках, которое присутствует, только если
оно (возможно, вместе со схемой) однозначно идентифицирует объект (в противном случае NULL);
identity — полный идентификатор объекта, точный формат которого зависит от типа объекта, а
каждая его часть дополняется схемой и заключается в кавычки, если требуется.
pg_identify_object_as_address возвращает запись, содержащую достаточно информации для од-
нозначной идентификации объекта БД по OID каталога, OID объекта и ID подобъекта. Выдаваемая
информация не зависит от текущего сервера, то есть по ней можно идентифицировать одноимён-
ный объект на другом сервере. Поле type содержит тип объекта БД, а object_names и object_args
— текстовые массивы, в совокупности формирующие ссылку на объект. Эти три значения мож-
но передать функции pg_get_object_address, чтобы получить внутренний адрес объекта. Данная
функция является обратной к pg_get_object_address.
pg_get_object_address возвращает запись, содержащую достаточно информации для уникальной
идентификации объекта БД по его типу и массивам имён и аргументов. В ней возвращаются зна-
чения, которые используются в системных каталогах, например pg_depend, и могут передаваться в
другие системные функции, например pg_identify_object или pg_describe_object. Поле classid
содержит OID системного каталога, к которому относится объект; objid — OID самого объекта,
а objsubid — идентификатор подобъекта или 0 в случае его отсутствия. Эта функция является
обратной к pg_identify_object_as_address.
Функции, перечисленные в Таблице 9.68, извлекают комментарии, заданные для объектов с по-
мощью команды COMMENT. Если найти комментарий для заданных параметров не удаётся, они
возвращают NULL.
Таблица 9.68. Функции получения комментариев
Имя Тип результата Описание
col_description( table_
oid , column_number ) text получает
комментарий
столбца таблицы
obj_description( object_
oid , catalog_name ) text получает комментарий для объ-
екта базы данных
obj_description(
oid ) text получает комментарий для объ-
екта базы данных (устаревшая
форма)
object_
318
дляФункции и операторы
Имя Тип результата Описание
shobj_description( object_
oid , catalog_name ) text получает комментарий для раз-
деляемого объекта баз данных
col_description возвращает комментарий для столбца с заданным номером в таблице с указан-
ным OID. (obj_description нельзя использовать для столбцов таблицы, так столбцы не имеют соб-
ственных OID.)
Функция obj_description с двумя параметрами возвращает комментарий для объекта,
имеющего заданный OID и находящегося в указанном системном каталоге. Например,
obj_description(123456,'pg_class') вернёт комментарий для таблицы с OID 123456. Форма
obj_description с одним параметром принимает только OID. Она является устаревшей, так как
значения OID могут повторяться в разных системных каталогах, и поэтому она может возвращать
комментарий для другого объекта.
shobj_description работает подобно obj_description, но она получает комментарии для разде-
ляемых объектов. Некоторые системные каталоги являются глобальными для всех баз данных в
кластере и описания объектов в них также хранятся глобально.
Функции, перечисленные в Таблице 9.69, выдают информацию о транзакциях сервера в форме во
внешнем представлении. В основном эти функции используются, чтобы определить, какие тран-
закции были зафиксированы между двумя снимками состояния.
Таблица 9.69. Идентификаторы транзакций и снимков состояния
Имя Тип результата Описание
txid_current() bigint получает идентификатор теку-
щей транзакции и присваивает
новый, если текущая транзак-
ция его не имеет
txid_current_if_assigned(
) bigint работает
аналогично
txid_
current() , но возвращает
NULL, не присваивая новый
идентификатор транзакции, ес-
ли он ещё не присвоен
txid_current_snapshot() txid_snapshot получает код текущего снимка
txid_snapshot_xip(
snapshot ) setof bigint возвращает
идентификаторы
выполняющихся транзакций в
снимке
txid_
txid_snapshot_xmax(
snapshot ) txid_ bigint возвращает значение xmax для
заданного снимка
txid_snapshot_xmin(
snapshot ) txid_ bigint возвращает значение xmin для
заданного снимка
txid_visible_in_snapshot(
bigint, txid_snapshot ) boolean видима ли транзакция с указан-
ным идентификатором в данном
снимке? (коды подтранзакций
не поддерживаются)
txid_status( text возвращает состояние заданной
транзакции — committed (за-
фиксирована), aborted (прерва-
на), in progress (выполняется)
или NULL, если идентификатор
транзакции слишком старый
bigint)
Внутренний тип идентификаторов транзакций (xid) имеет размер 32 бита, поэтому они повторя-
ются через 4 миллиарда транзакций. Однако эти функции выдают 64-битные значения, дополнен-
319Функции и операторы
ные счётчиком «эпохи», так что эти значения останутся уникальными на протяжении всей жиз-
ни сервера. Используемый этими функциями тип данных txid_snapshot сохраняет информацию о
видимости транзакций в определённый момент времени. Его состав описан в Таблице 9.70.
Таблица 9.70. Состав информации о снимке
Имя Описание
xmin Идентификатор самой ранней транзакции (txid)
из активных. Все предыдущие транзакции ли-
бо зафиксированы и видимы, либо отменены и
мертвы.
xmax Первый txid из ещё не назначенных. На момент
снимка не было запущенных (а значит и види-
мых) транзакций с идентификатором, большим
или равным данному.
xip_list Список идентификаторов транзакций, активных
в момент снимка. Он включает только идентифи-
каторы с номерами от xmin до xmax; хотя уже мо-
гут быть транзакции с идентификаторами боль-
ше xmax. Если в этом списке не оказывается
идентификатора транзакции xmin <= txid <
xmax, это означает, что она уже не выполня-
лась к моменту снимка и, таким образом, видима
или мертва, в зависимости от типа завершения.
Идентификаторы подтранзакций в этот список
не включаются.
В текстовом виде txid_snapshot представляется как xmin:xmax:xip_list.
10:20:10,14,15 означает xmin=10, xmax=20, xip_list=10, 14, 15.
Например,
Функция txid_status(bigint) выдаёт состояние фиксации последней транзакции. Проверяя его,
приложения могут определить, была ли транзакция зафиксирована или прервана, когда приложе-
ние отключается от сервера баз данных в процессе выполнения COMMIT. Состояние транзакции мо-
жет быть следующим: in progress (выполняется), committed (зафиксирована) и aborted (прерва-
на), если только транзакция не настолько стара, чтобы система удалила информация о её состоя-
нии фиксирования. Если же она так стара, что упоминаний о ней в системе не осталось и информа-
ция о фиксации потеряна, эта функция возвращает NULL. Заметьте, что для подготовленных тран-
закций возвращается состояние in progress; приложения должны проверять pg_prepared_xacts,
если им нужно определить, является ли транзакция «txid» подготовленной.
Функции, показанные в Таблице  9.71, выдают информацию об уже зафиксированных тран-
закциях. Они возвращают полезные данные, только когда включён параметр конфигурации
track_commit_timestamp и только для транзакций, зафиксированных после его включения.
Таблица 9.71. Информация о фиксации транзакций
Имя Тип результата
Описание
pg_xact_commit_timestamp(
xid) timestamp with time zone
выдаёт время фиксации тран-
закции
pg_last_committed_xact() xid xid, timestamp timestamp выдаёт идентификатор и время
фиксации транзакции, зафикси-
with time zone
рованной последней
Функции, перечисленные в Таблице 9.72, выводят свойства, установленные командой initdb, на-
пример, версию каталога. Они также выводят сведения о работе журнала предзаписи и контроль-
ных точках. Эта информация относится ко всему кластеру, а не к отдельной базе данных. Данные
функции выдают практически всю ту же информацию, и из того же источника, что и pg_controldata,
но в форме, более подходящей для функций SQL.
320Функции и операторы
Таблица 9.72. Функции управления данными
Имя Тип результата Описание
pg_control_checkpoint() record Возвращает информацию о со-
стоянии текущей контрольной
точки.
pg_control_system() record Возвращает информацию о те-
кущем состоянии управляюще-
го файла.
pg_control_init() record Возвращает информацию о со-
стоянии инициализации класте-
ра.
pg_control_recovery() record Возвращает информацию о со-
стоянии восстановления.
Функция pg_control_checkpoint возвращает запись, показанную в Таблице 9.73.
Таблица 9.73. Столбцы результата pg_control_checkpoint
Имя столбца Тип данных
checkpoint_lsn pg_lsn
redo_lsn pg_lsn
redo_wal_file text
timeline_id integer
prev_timeline_id integer
full_page_writes boolean
next_xid text
next_oid oid
next_multixact_id xid
next_multi_offset xid
oldest_xid xid
oldest_xid_dbid oid
oldest_active_xid xid
oldest_multi_xid xid
oldest_multi_dbid oid
oldest_commit_ts_xid xid
newest_commit_ts_xid xid
checkpoint_time timestamp with time zone
Функция pg_control_system возвращает запись, показанную в Таблице 9.74.
Таблица 9.74. Столбцы результата pg_control_system
Имя столбца Тип данных
pg_control_version integer
catalog_version_no integer
system_identifier bigint
pg_control_last_modified timestamp with time zone
321Функции и операторы
Функция pg_control_init возвращает запись, показанную в Таблице 9.75.
Таблица 9.75. Столбцы результата pg_control_init
Имя столбца Тип данных
max_data_alignment integer
database_block_size integer
blocks_per_segment integer
wal_block_size integer
bytes_per_wal_segment integer
max_identifier_length integer
max_index_columns integer
max_toast_chunk_size integer
large_object_chunk_size integer
float4_pass_by_value boolean
float8_pass_by_value boolean
data_page_checksum_version integer
Функция pg_control_recovery возвращает запись, показанную в Таблице 9.76
Таблица 9.76. Столбцы результата pg_control_recovery
Имя столбца Тип данных
min_recovery_end_lsn pg_lsn
min_recovery_end_timeline integer
backup_start_lsn pg_lsn
backup_end_lsn pg_lsn
end_of_backup_record_required boolean
9.26. Функции для системного администрирования
Функции, описанные в этом разделе, предназначены для контроля и управления сервером
PostgreSQL.
9.26.1. Функции для управления конфигурацией
В Таблице 9.77 показаны функции, позволяющие получить и изменить значения параметров кон-
фигурации выполнения.
Таблица 9.77. Функции для управления конфигурацией
Имя Тип результата Описание
current_setting( setting_
name [, missing_ok ]) text получает текущее значение па-
раметра
set_config( setting_name ,
new_value , is_local ) text устанавливает новое значение
параметра и возвращает его
Функция current_setting выдаёт текущее значение параметра setting_name. Она соответствует
стандартной SQL-команде SHOW. Пример использования:
SELECT current_setting('datestyle');
322Функции и операторы
current_setting
-----------------
ISO, MDY
(1 row)
Если параметра с именем setting_name нет, функция current_setting выдаёт ошибку, если только
дополнительно не передан параметр missing_ok со значением true.
set_config устанавливает для параметра setting_name значение new_value. Если параметр
is_local равен true, новое значение будет действовать только в рамках текущей транзакции. Что-
бы это значение действовало на протяжении текущего сеанса, ему нужно присвоить false. Эта
функция соответствует SQL-команде SET. Пример использования:
SELECT set_config('log_statement_stats', 'off', false);
set_config
------------
off
(1 row)
9.26.2. Функции для передачи сигналов серверу
Функции, перечисленные в Таблице 9.78, позволяют передавать управляющие сигналы другим сер-
верным процессам. Вызывать эти функции по умолчанию разрешено только суперпользователям,
но доступ к ним можно дать и другим пользователям командой GRANT, кроме явно отмеченных ис-
ключений.
Таблица 9.78. Функции для передачи сигналов серверу
Имя
Тип результата Описание
boolean Отменяет текущий запрос в
обслуживающем процессе. Это
действие разрешается и ролям,
являющимся членами роли, об-
служивающий процесс которой
затрагивается, и ролям, кото-
рым дано право pg_signal_
backend ; однако только супер-
пользователям разрешено воз-
действовать на обслуживающие
процессы других суперпользо-
вателей.
pg_reload_conf() boolean Даёт команду серверным про-
цессам перегрузить конфигура-
цию
pg_rotate_logfile() boolean Прокручивает журнал сообще-
ний сервера
boolean Завершает
обслуживающий
процесс. Это действие разре-
шается и ролям, являющимся
членами роли, обслуживающий
процесс которой прерывается,
и ролям, которым дано пра-
во pg_signal_backend ; одна-
ко только суперпользователям
разрешено прерывать обслужи-
вающие процессы других супер-
пользователей.
pg_cancel_backend(
int)
pg_terminate_backend(
int)
pid
pid
323Функции и операторы
Каждая из этих функций возвращает true при успешном завершении и false в противном случае.
pg_cancel_backend и pg_terminate_backend передают сигналы (SIGINT и SIGTERM, соответствен-
но) серверному процессу с заданным кодом PID. Код активного процесса можно получить из столб-
ца pid представления pg_stat_activity или просмотрев на сервере процессы с именем postgres
(используя ps в Unix или Диспетчер задач в Windows). Роль пользователя активного процесса мож-
но узнать в столбце usename представления pg_stat_activity.
pg_reload_conf отправляет сигнал SIGHUP главному серверному процессу, который командует
всем подчинённым процессам перезагрузить файлы конфигурации.
pg_rotate_logfile указывает менеджеру журнала сообщений немедленно переключиться на но-
вый файл. Это имеет смысл, только когда работает встроенный сборщик сообщений, так как без
него подпроцесс менеджера журнала не запускается.
9.26.3. Функции управления резервным копированием
Функции, перечисленные в Таблице  9.79, предназначены для выполнения резервного копиро-
вания «на ходу». Эти функции нельзя выполнять во время восстановления (за исключением
pg_is_in_backup, pg_backup_start_time и pg_wal_lsn_diff).
Таблица 9.79. Функции управления резервным копированием
Имя Тип результата Описание
pg_create_restore_point(
name text) pg_lsn Создаёт именованную точку
для восстановления (по умолча-
нию разрешено только супер-
пользователям, но право на её
выполнение (EXECUTE) можно
дать и другим пользователям)
pg_current_wal_flush_
lsn() pg_lsn Получает текущую позицию
сброса данных в журнале пред-
записи
pg_current_wal_insert_
lsn() pg_lsn Получает текущую позицию до-
бавления в журнале предзаписи
pg_current_wal_lsn() pg_lsn Получает текущую позицию за-
писи в журнале предзаписи
pg_start_backup(
label
text [,
fast boolean
exclusive boolean]]) pg_lsn Подготавливает сервер к ре-
зервному
копированию
(по
умолчанию разрешено только
суперпользователям, но право
на её выполнение (EXECUTE)
можно дать и другим пользова-
телям)
pg_stop_backup() pg_lsn Завершает монопольное резерв-
ное копирование (по умолча-
нию разрешено только супер-
пользователям, но право на её
выполнение (EXECUTE) можно
дать и другим пользователям)
pg_stop_backup(
exclusive
boolean
[,
wait_for_
archive boolean]) setof record Завершает монопольное или
немонопольное резервное копи-
рование (по умолчанию разре-
шено только суперпользовате-
лям, но право на её выполнение
(EXECUTE) можно дать и дру-
гим пользователям)
[,
324Функции и операторы
Имя Тип результата Описание
pg_is_in_backup() bool Возвращает true в процессе ис-
ключительного резервного ко-
пирования
pg_backup_start_time() timestamp with time zone Получает время запуска вы-
полняющегося исключительно-
го резервного копирования
pg_switch_wal() pg_lsn Инициирует переключение на
новый файл журнала предза-
писи (по умолчанию разреше-
но только суперпользователям,
но право на её выполнение (
EXECUTE) можно дать и другим
пользователям)
pg_walfile_name(
lsn )
lsn
pg_walfile_name_offset(
lsn pg_lsn )
pg_wal_lsn_diff(
lsn
lsn , lsn pg_lsn )
Получает из позиции в журна-
ле предзаписи имя соответству-
ющего файла
pg_ text
text, integer
Получает из позиции в журна-
ле предзаписи имя соответству-
ющего файла и десятичное сме-
щение в нём
Вычисляет разницу между дву-
мя позициями в журнале пред-
записи
pg_ numeric
pg_start_backup принимает произвольную заданную пользователем метку резервной копии.
(Обычно это имя файла, в котором будет сохранена резервная копия.) При копировании в моно-
польном режиме эта функция записывает файл метки (backup_label) и, если есть ссылки в ката-
логе pg_tblspc/, файл карты табличных пространств (tablespace_map) в каталог данных кластера
БД, выполняет процедуру контрольной точки, а затем возвращает в текстовом виде начальную по-
зицию в журнале предзаписи для данной резервной копии. Результат этой функции может быть
полезен, но если он не нужен, его можно просто игнорировать. При копировании в немонопольном
режиме содержимое этих файлов выдаётся функцией pg_stop_backup и должно быть записано в
архивную копию вызывающим субъектом.
postgres=# select pg_start_backup('label_goes_here');
pg_start_backup
-----------------
0/D4445B8
(1 row)
У этой функции есть также второй, необязательный параметр типа boolean. Если он равен true,
pg_start_backup начнёт работу максимально быстро. При этом будет немедленно выполнена про-
цедура контрольной точки, что может повлечь массу операций ввода/вывода и затормозить парал-
лельные запросы.
При монопольном копировании функция pg_stop_backup удаляет файл метки (и, если существует,
файл tablespace_map), созданный функцией pg_start_backup. При немонопольном копировании
содержимое backup_label и tablespace_map возвращается в результате функции и должно быть
записано в файлы в архиве (а не в каталоге данных). Также есть необязательный второй параметр
типа boolean. Если он равен false, pg_stop_backup завершится сразу после окончания резервно-
го копирования, не дожидаясь архивации WAL. Это поведение полезно только для программ ре-
зервного копирования, которые независимо осуществляют архивацию WAL. Если же WAL не заар-
хивируется, резервная копия может оказаться неполной, а значит, бесполезной. Когда он равен
true, pg_stop_backup будет ждать выполнения архивации WAL, если архивирование включено; для
резервного сервера это означает, что ожидание возможно только при условии archive_mode =
325Функции и операторы
always. Если активность записи на ведущем сервере невысока, может иметь смысл выполнить на
нём pg_switch_wal для немедленного переключения сегмента.
При выполнении на ведущем эта функция также создаёт файл истории резервного копирования в
области архива журнала предзаписи. В этом файле для данной резервной копии сохраняется мет-
ка, заданная при вызове pg_start_backup, начальная и конечная позиция в журнале предзаписи,
а также время начала и окончания. Возвращает данная функция позицию окончания резервной
копии в журнале предзаписи (которую тоже можно игнорировать). После записи конечной пози-
ции текущая позиция автоматически перемещается к следующему файлу журнала предзаписи,
чтобы файл конечной позиции можно было немедленно архивировать для завершения резервного
копирования.
pg_switch_wal производит переключение на следующий файл журнала предзаписи, что позволяет
архивировать текущий (в предположении, что архивация выполняется непрерывно). Эта функция
возвращает конечную позицию в журнале предзаписи (в только что законченном файле журна-
ла) + 1. Если с момента последнего переключения файлов не было активности, отражающейся в
журнале предзаписи, pg_switch_wal не делает ничего и возвращает начальную позицию в файле
журнала предзаписи, используемом в данный момент.
pg_create_restore_point создаёт именованную запись в журнале предзаписи, которую можно ис-
пользовать как цель при восстановлении, и возвращает соответствующую позицию в журнале пред-
записи. Затем полученное имя можно присвоить параметру recovery_target_name, указав тем са-
мым точку, до которой будет выполняться восстановление. Учтите, что если вы создадите несколь-
ко точек восстановления с одним именем, восстановление будет остановлено на первой точке с
этим именем.
pg_current_wal_lsn выводит текущую позицию записи в журнале предзаписи в том же формате,
что и вышеописанные функции. pg_current_wal_insert_lsn подобным образом выводит текущую
позицию добавления, а pg_current_wal_flush_lsn — позицию сброса данных журнала. Позици-
ей добавления называется «логический» конец журнала предзаписи в любой момент времени, то-
гда как позиция записи указывает на конец данных, фактически вынесённых из внутренних буфе-
ров сервера, а позиция сброса показывает, до какого места данные гарантированно сохранены в
надёжном хранилище. Позиция записи отмечает конец данных, которые может видеть снаружи
внешний процесс, и именно она представляет интерес при копировании частично заполненных
файлов журнала. Позиция добавления и позиция сброса выводятся в основном для отладки сер-
верной части. Все эти операции выполняются в режиме «только чтение» и не требуют прав супер-
пользователя.
Из результатов всех описанных выше функций можно получить имя файла журнала предзаписи и
смещение в нём, используя функцию pg_walfile_name_offset. Например:
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
file_name
| file_offset
--------------------------+-------------
00000001000000000000000D |
4039624
(1 row)
Подобным образом, pg_walfile_name извлекает только имя файла журнала предзаписи. Когда за-
данная позиция в журнале предзаписи находится ровно на границе файлов, обе эти функции воз-
вращают имя предыдущего файла. Обычно это поведение предпочтительно при архивировании
журнала предзаписи, так как именно предыдущий файл является последним подлежащим архи-
вации.
pg_wal_lsn_diff вычисляет разницу в байтах между двумя позициями в журнале предзаписи. По-
лученный результат можно использовать с pg_stat_replication или другими функциями, пере-
численными в Таблице 9.79, для определения задержки репликации.
Подробнее практическое применение этих функций описывается в Разделе 25.3.
9.26.4. Функции управления восстановлением
326Функции и операторы
Функции, приведённые в Таблице  9.80, предоставляют сведения о текущем состоянии ведомого
сервера. Эти функции могут выполняться, как во время восстановления, так и в обычном режиме
работы.
Таблица 9.80. Функции для получения информации о восстановлении
Имя Тип результата Описание
pg_is_in_recovery() bool Возвращает true в процессе вос-
становления.
pg_last_wal_receive_lsn(
) pg_lsn Получает позицию последней
записи журнала предзаписи,
полученной и записанной на
диск в процессе потоковой ре-
пликации. Пока выполняется
потоковая репликация, эта по-
зиция постоянно увеличивает-
ся. По окончании восстановле-
ния она останавливается на за-
писи WAL, полученной и запи-
санной на диск последней. Если
потоковая репликация отклю-
чена или ещё не запускалась,
функция возвращает NULL.
pg_last_wal_replay_lsn(
) pg_lsn Получает позицию последней
записи журнала предзаписи,
воспроизведённой при восста-
новлении. В процессе восста-
новления эта позиция постоян-
но увеличивается. По оконча-
нии восстановления она оста-
навливается на записи WAL, ко-
торая была восстановлена по-
следней. Если сервер был за-
пущен не в режиме восстанов-
ления, эта функция возвращает
NULL.
pg_last_xact_replay_
timestamp() timestamp with time zone Получает отметку времени по-
следней транзакции, воспроиз-
ведённой при восстановлении.
Это время, когда на главном
сервере произошла фиксация
или откат записи WAL для этой
транзакции. Если в процессе
восстановления не была воспро-
изведена ни одна транзакция,
эта функция возвращает NULL.
В противном случае это зна-
чение постоянно увеличивает-
ся в процессе восстановления.
По окончании восстановления
оно останавливается на тран-
закции, которая была восста-
новлена последней. Если сер-
вер был запущен не в режи-
ме восстановления, эта функ-
ция возвращает NULL.
327Функции и операторы
Функции, перечисленные в Таблице 9.81 управляют процессом восстановления. Вызывать их в дру-
гое время нельзя.
Таблица 9.81. Функции управления восстановлением
Имя Тип результата Описание
pg_is_wal_replay_paused(
) bool Возвращает true, если восста-
новление приостановлено.
pg_wal_replay_pause() void Немедленно приостанавливает
восстановление (по умолчанию
разрешено только суперпользо-
вателям, но право на её выпол-
нение (EXECUTE) можно дать и
другим пользователям).
pg_wal_replay_resume() void Перезапускает восстановление,
если оно было приостановлено (
по умолчанию разрешено толь-
ко суперпользователям, но пра-
во на её выполнение (EXECUTE)
можно дать и другим пользова-
телям).
Когда восстановление приостановлено, запись изменений в базу не производится. Если она нахо-
дится в «горячем резерве», все последующие запросы будут видеть один согласованный снимок
базы данных и до продолжения восстановления конфликты запросов исключаются.
Когда потоковая репликация выключена, пауза при восстановлении может длиться сколь угодно
долго без каких-либо проблем. Если же запущена потоковая репликация, новые записи WAL про-
должат поступать и заполнят весь диск рано или поздно, в зависимости от длительности паузы,
интенсивности записи в WAL и объёма свободного пространства.
9.26.5. Функции синхронизации снимков
PostgreSQL позволяет синхронизировать снимки состояния между сеансами баз данных. Снимок
состояния определяет, какие данные видны транзакции, работающей с этим снимком. Синхрони-
зация снимков необходима, когда в двух или более сеансах нужно видеть одно и то же содержимое
базы данных. Если в двух сеансах транзакции запускаются независимо, всегда есть вероятность,
что некая третья транзакция будет зафиксирована между командами START TRANSACTION для пер-
вых двух, и в результате в одном сеансе будет виден результат третьей, а в другом — нет.
Для решения этой проблемы PostgreSQL позволяет транзакции экспортировать снимок состоя-
ния, с которым она работает. Пока экспортирующая этот снимок транзакция выполняется, другие
транзакции могут импортировать его и, таким образом, увидеть абсолютно то же состояние ба-
зы данных, что видит первая транзакция. Но учтите, что любые изменения, произведённые эти-
ми транзакциями, будут не видны для других, как это и должно быть с изменениями в незафикси-
рованных транзакциях. Таким образом, транзакции синхронизируют только начальное состояние
данных, а последующие производимые в них изменения изолируются как обычно.
Снимки состояния экспортируются с помощью функции pg_export_snapshot, показанной в Табли-
це 9.82, и импортируются командой SET TRANSACTION.
Таблица 9.82. Функции синхронизации снимков
Имя Тип результата Описание
pg_export_snapshot() text Сохраняет снимок текущего со-
стояния и возвращает его иден-
тификатор
Функция pg_export_snapshot создаёт снимок текущего состояния и возвращает его идентифика-
тор в строке типа text. Данная строка должна передаваться (за рамками базы данных) клиентам,
328Функции и операторы
которые будут импортировать этот снимок. При этом импортировать его нужно раньше, чем за-
вершится транзакция, которая его экспортировала. Если необходимо, транзакция может экспор-
тировать несколько снимков. Заметьте, что это имеет смысл только для транзакций уровня READ
COMMITTED, так как транзакции REPEATABLE READ и более высоких уровней изоляции работают с
одним снимком состояния. После того как транзакция экспортировала снимок, её нельзя подгото-
вить с помощью PREPARE TRANSACTION.
Подробнее использование
TRANSACTION.
экспортированных
снимков
рассматривается
в
описании
SET
9.26.6. Функции репликации
В Таблице 9.83 перечислены функции, предназначенные для управления и взаимодействия с ме-
ханизмом репликации. Чтобы изучить этот механизм детальнее, обратитесь к Подразделу 26.2.5,
Подразделу 26.2.6 и Главе 50. Использовать эти функции разрешено только суперпользователям.
Многие из этих функций соответствуют командам в протоколе репликации; см. Раздел 53.4.
Функции, описанные в Подразделе  9.26.3, Подразделе  9.26.4 и Подразделе  9.26.5 также имеют
отношение к репликации.
Таблица 9.83. Функции репликации SQL
Функция
Тип результата
Описание
pg_create_physical_
(slot_name name, lsn pg_lsn )
replication_slot(
slot_
name name [, immediately_
reserve boolean, temporary
boolean]) Создаёт новый физический слот
репликации с именем slot_
name . Необязательный второй
параметр, когда он равен true,
указывает, что LSN для этого
слота репликации должен быть
зарезервирован немедленно; в
противном случае LSN резер-
вируется при первом подклю-
чении клиента потоковой ре-
пликации. Передача изменений
из физического слота возможна
только по протоколу потоковой
репликации — см. Раздел  53.4.
Необязательный третий пара-
метр, temporary, когда он равен
true, указывает, что этот слот не
должен постоянно храниться на
диске, так как он предназначен
только для текущего сеанса.
Временные слоты также осво-
бождаются при любой ошиб-
ке. Эта функция соответству-
ет команде протокола репли-
кации
CREATE_REPLICATION_
SLOT ... PHYSICAL .
pg_drop_replication_slot(
slot_name name) Удаляет физический или логи-
ческий слот репликации с име-
нем slot_name . Соответствует
команде протокола репликации
DROP_REPLICATION_SLOT . Для
логических слотов эта функция
должна вызываться через под-
ключение к той же базе данных,
в которой был создан слот.
void
329Функции и операторы
Функция
Тип результата
Описание
pg_create_logical_
(slot_name name, lsn pg_lsn )
replication_slot(
slot_
name name, plugin name [,
temporary boolean]) Создаёт новый логический (
декодирующий) слот реплика-
ции с именем slot_name , ис-
пользуя модуль вывода plugin.
Необязательный третий пара-
метр, temporary, когда равен
true, указывает, что этот слот
не должен постоянно хранить-
ся на диске, так как он
предназначен только для теку-
щего сеанса. Временные сло-
ты также освобождаются при
любой ошибке. Вызов этой
функции равнозначен выполне-
нию команды протокола репли-
кации
CREATE_REPLICATION_
SLOT ... LOGICAL .
pg_logical_slot_get_
(lsn pg_lsn , xid xid, data text)
changes( slot_name
name,
upto_lsn pg_lsn , upto_
nchanges
int,
VARIADIC
options text[]) Возвращает изменения в слоте
slot_name с позиции, до кото-
рой ранее были получены из-
менения. Если параметры upto_
lsn и upto_nchanges равны
NULL, логическое декодирова-
ние продолжится до конца жур-
нала транзакций. Если upto_
lsn не NULL, декодировать-
ся будут только транзакции,
зафиксированные до заданно-
го LSN. Если upto_nchanges
не NULL, декодирование оста-
новится, когда число строк, по-
лученных при декодировании,
превысит заданное значение.
Заметьте, однако, что фактиче-
ское число возвращённых строк
может быть больше, так как
это ограничение проверяется
только после добавления строк,
декодированных для очередной
транзакции.
pg_logical_slot_peek_
(lsn pg_lsn , xid xid, data text)
changes( slot_name
name,
upto_lsn pg_lsn , upto_
nchanges
int,
VARIADIC
options text[]) Работает так же, как функ-
ция pg_logical_slot_get_
changes() , но не забирает из-
менения; то есть, они будут по-
лучены снова при следующих
вызовах.
pg_logical_slot_get_
(lsn pg_lsn , xid xid, data Работает так же, как функ-
ция pg_logical_slot_get_
binary_changes(
slot_name bytea)
changes() , но выдаёт измене-
name,
upto_lsn
pg_lsn ,
ния в типе bytea.
upto_nchanges
int,
VARIADIC options text[])
pg_logical_slot_peek_
(lsn pg_lsn , xid xid, data Работает так же, как функ-
ция pg_logical_slot_get_
binary_changes(
slot_name bytea)
changes() , но выдаёт измене-
name,
upto_lsn
pg_lsn ,
330Функции и операторы
Функция
Тип результата
upto_nchanges
int,
VARIADIC options text[])
pg_replication_slot_
advance( slot_name
upto_lsn pg_lsn )
(slot_name
name, lsn ) bool
name, end_lsn
Описание
ния в типе bytea и не забирает
их; то есть, они будут получены
снова при следующих вызовах.
pg_ Продвигает текущую подтвер-
ждённую позицию слота репли-
кации с именем slot_name .
Слот нельзя переместить назад,
а также вперёд за текущую по-
зицию добавления. Возвращает
имя слота и позицию, до кото-
рой он продвинулся.
pg_replication_origin_
create( node_name text) oid Создаёт источник репликации
с заданным внешним именем
и возвращает назначенный ему
внутренний идентификатор.
pg_replication_origin_
drop( node_name text) void Удаляет ранее созданный ис-
точник репликации, в том числе
связанную информацию о вос-
произведении.
pg_replication_origin_
oid( node_name text) oid Ищет источник репликации по
имени и возвращает внутрен-
ний идентификатор. Если такой
источник не находится, выдаёт-
ся ошибка.
pg_replication_origin_
session_setup(
node_name
text) void Помечает текущий сеанс, как
воспроизводящий журнал из
указанного источника, что поз-
воляет отслеживать положе-
ние воспроизведения. Чтобы
отменить это действие, вызо-
вите pg_replication_origin_
session_reset . Может ис-
пользоваться, только если не
был настроен предыдущий ис-
точник.
pg_replication_origin_
session_reset() void Отменяет
действие
replication_origin_
session_setup()
.
pg_replication_origin_
session_is_setup() bool В текущем сеансе настроен ис-
точник репликации?
pg_replication_origin_
session_progress(
flush
bool) pg_lsn Возвращает позицию воспроиз-
ведения для источника репли-
кации, настроенного в текущем
сеансе. Параметр flush опреде-
ляет, будет ли гарантироваться
сохранение локальной транзак-
ции на диске.
pg_replication_origin_
xact_setup(
origin_lsn
pg_lsn ,
origin_timestamp
timestamptz) void Помечает текущую транзакцию
как воспроизводящую транзак-
цию, зафиксированную с ука-
занным LSN и временем. Может
вызываться только после то-
го, как был настроен источник
331
pg_Функции и операторы
Функция Тип результата Описание
репликации в результате вы-
зова pg_replication_origin_
session_setup()
.
pg_replication_origin_
xact_reset() void Отменяет
действие
pg_
replication_origin_xact_
setup() .
pg_replication_origin_
void
advance ( node_name
text,
lsn pg_lsn ) Устанавливает положение ре-
пликации для заданного уз-
ла в указанную позицию. Это
в основном полезно для уста-
новки начальной позиции или
новой позиции после изме-
нения конфигурации и по-
добных действий. Но учтите,
что неосторожное использова-
ние этой функции может приве-
сти к несогласованности репли-
цированных данных.
pg_replication_origin_
pg_lsn
progress( node_name
text,
flush bool) Возвращает позицию воспроиз-
ведения для заданного источни-
ка репликации. Параметр flush
определяет, будет ли гаранти-
роваться сохранение локальной
транзакции на диске.
pg_logical_emit_message(
pg_lsn
transactional bool,
prefix
text, содержимое text) Выдаёт текстовое сообщение
логического декодирования. Её
можно использовать для пе-
редачи произвольных сообще-
ний через WAL модулям ло-
гического декодирования. Па-
раметр transactional устанав-
ливает, должно ли сообщение
быть частью текущей транзак-
ции или оно должно записы-
ваться немедленно и декодиро-
ваться сразу, как только эта за-
пись будет прочитана при ло-
гическом декодировании. Пара-
метр prefix задаёт текстовый
префикс, по которому модули
логического декодирования мо-
гут легко распознать интересу-
ющие их сообщения. В парамет-
ре content передаётся текст со-
общения.
pg_logical_emit_message(
pg_lsn
transactional bool,
prefix
text, содержимое bytea) Выдаёт двоичное сообщение ло-
гического декодирования. Её
можно использовать для пе-
редачи произвольных сообще-
ний через WAL модулям ло-
гического декодирования. Па-
раметр transactional устанав-
ливает, должно ли сообщение
быть частью текущей транзак-
332Функции и операторы
Функция
Тип результата
Описание
ции или оно должно записы-
ваться немедленно и декодиро-
ваться сразу, как только эта за-
пись будет прочитана при ло-
гическом декодировании. Пара-
метр prefix задаёт текстовый
префикс, по которому модули
логического декодирования мо-
гут легко распознать интересу-
ющие их сообщения. В парамет-
ре content передаётся двоич-
ное содержание сообщения.
9.26.7. Функции управления объектами баз данных
Функции, перечисленные в Таблице 9.84, вычисляют объём, который занимают на диске различ-
ные объекты баз данных.
Таблица 9.84. Функции получения размера объектов БД
Имя
pg_column_size(
any)
Тип результата Описание
int Число байт, необходимых для
хранения заданного значения (
возможно, в сжатом виде)
pg_database_size( oid) bigint Объём, который занимает на
диске база данных с заданным
OID
pg_database_size( name) bigint Объём, который занимает на
диске база данных с заданным
именем
regclass) bigint Общий объём индексов, связан-
ных с указанной таблицей
pg_relation_size(
relation bigint
regclass, fork text) Объём, который занимает на
диске указанный слой ('main',
'fsm', 'vm' или 'init') задан-
ной таблицы или индекса
pg_relation_size(
regclass) Краткая форма pg_relation_
size(..., 'main')
pg_indexes_size(
pg_size_bytes(
relation bigint
text)
bigint Преобразует размер в понятном
человеку формате с единицами
измерения в число байт
pg_size_pretty( bigint) text Преобразует размер в байтах,
представленный в 64-битном
целом, в понятный человеку
формат с единицами измерения
pg_size_pretty( numeric) text Преобразует размер в бай-
тах, представленный в значе-
нии числового типа, в понятный
человеку формат с единицами
измерения
pg_table_size( regclass) bigint Объём, который занимает на
диске данная таблица, за ис-
333Функции и операторы
Имя
Тип результата Описание
ключением индексов (но вклю-
чая TOAST, карту свободного
места и карту видимости)
pg_tablespace_size( oid) bigint Объём, который занимает на
диске табличное пространство
с указанным OID
pg_tablespace_size( name) bigint Объём, который занимает на
диске табличное пространство
с заданным именем
bigint Общий объём, который занима-
ет на диске заданная таблица,
включая все индексы и данные
TOAST
pg_total_relation_size(
regclass)
pg_column_size показывает, какой объём требуется для хранения данного значения.
pg_total_relation_size принимает OID или имя таблицы или данных TOAST и возвращает общий
объём, который занимает на диске эта таблица, включая все связанные с ней индексы. Результат
этой функции равняется pg_table_size + pg_indexes_size.
pg_table_size принимает OID или имя таблицы и возвращает объём, который занимает на диске
эта таблица без индексов. (При этом учитывается размер TOAST, карты свободного места и карты
видимости.)
pg_indexes_size принимает OID или имя таблицы и возвращает общий объём, который занимают
все индексы таблицы.
pg_database_size и pg_tablespace_size принимают OID или имя базы данных либо таблич-
ного пространства и возвращают общий объём, который они занимают на диске. Для исполь-
зования pg_database_size требуется иметь право CONNECT для указанной базы данных (оно
предоставляется по умолчанию) или быть членом роли pg_read_all_stats. Для использования
pg_tablespace_size необходимо иметь право CREATE для указанного табличного пространства или
быть членом роли pg_read_all_stats, если только это не табличное пространство по умолчанию
для текущей базы данных.
pg_relation_size принимает OID или имя таблицы, индекса или TOAST-таблицы и возвращает
размер одного слоя этого отношения (в байтах). (Заметьте, что в большинстве случаев удобнее
использовать более высокоуровневые функции pg_total_relation_size и pg_table_size, которые
суммируют размер всех слоёв.) С одним аргументом она возвращает размер основного слоя для
данных заданного отношения. Название другого интересующего слоя можно передать во втором
аргументе:
• 'main' возвращает размер основного слоя данных заданного отношения.
• 'fsm' возвращает размер карты свободного места (см. Раздел 68.3), связанной с заданным от-
ношением.
• 'vm' возвращает размер карты видимости (см. Раздел 68.4), связанной с заданным отношени-
ем.
• 'init' возвращает размер слоя инициализации для заданного отношения, если он имеется.
pg_size_pretty можно использовать для форматирования результатов других функций в виде, бо-
лее понятном человеку, с единицами измерения bytes, kB, MB, GB и TB.
pg_size_bytes можно использовать для получения размера в байтах из строки в формате, понят-
ном человеку. Входная строка может содержать единицы bytes, kB, MB, GB и TB, и разбирается
без учёта регистра. Если единицы не указываются, подразумеваются байты.
334Функции и операторы
Примечание
Единицы kB, MB, GB и TB, фигурирующие в функциях pg_size_pretty и pg_size_bytes,
2
определяются как степени 2, а не 10, так что 1kB равен 1024 байтам, 1MB равен 1024
= 1048576 байтов и т. д.
Вышеописанные функции, работающие с таблицами или индексами, принимают аргумент типа
regclass, который представляет собой просто OID таблицы или индекса в системном катало-
ге pg_class. Однако вам не нужно вручную вычислять OID, так как процедура ввода значения
regclass может сделать это за вас. Для этого достаточно записать имя таблицы в апострофах, как
обычную текстовую константу. В соответствии с правилами обработки обычных имён SQL, если
имя таблицы не заключено в кавычки, эта строка будет переведена в нижний регистр.
Если переданному значению OID не соответствуют существующий объект, эти функции возвраща-
ют NULL.
Функции, перечисленные в Таблице 9.85, помогают определить, в каких файлах на диске хранятся
объекты базы данных.
Таблица 9.85. Функции определения расположения объектов
Имя Тип результата Описание
pg_relation_filenode(
relation regclass) oid Номер файлового узла для ука-
занного отношения
pg_relation_filepath(
relation regclass) text Путь к файлу, в котором хранит-
ся указанное отношение
Находит отношение, связанное
с данным табличным простран-
ством и файловым узлом
pg_filenode_relation(
regclass
tablespace oid,
filenode
oid)
pg_relation_filenode принимает OID или имя таблицы, индекса, последовательности или таб-
лицы TOAST и возвращает номер «файлового узла», связанным с этим объектом. Файловым уз-
лом называется основной компонент имени файла, используемого для хранения данных (подроб-
нее это описано в Разделе  68.1). Для большинства таблиц этот номер совпадает со значением
pg_class.relfilenode, но для некоторых системных каталогов relfilenode равен 0, и нужно ис-
пользовать эту функцию, чтобы узнать действительное значение. Если указанное отношение не
хранится на диске, как например представление, данная функция возвращает NULL.
pg_relation_filepath подобна pg_relation_filenode, но возвращает полный путь к файлу (отно-
сительно каталога данных PGDATA) отношения.
Функция pg_filenode_relation является обратной к pg_relation_filenode. Она возвращает OID
отношения по заданному OID «табличного пространства» и «файловому узлу». Для таблицы в таб-
личном пространстве по умолчанию в первом параметре можно передать 0.
В Таблица 9.86 перечислены функции, предназначенные для управления правилами сортировки.
Таблица 9.86. Функции управления правилами сортировки
Имя Тип результата Описание
pg_collation_actual_
version( oid) text выдаёт действующую версию
правила сортировки из опера-
ционной системы
pg_import_system_
collations( schema
regnamespace) integer импортирует правила сортиров-
ки из операционной системы
335Функции и операторы
Функция pg_collation_actual_version возвращает действующую версию объекта правила сорти-
ровки, которая в настоящее время установлена в операционной системе. Если она отличается от
значения в pg_collation.collversion, может потребоваться перестроить объекты, зависящие от
данного правила сортировки. См. также ALTER COLLATION.
Функция pg_import_system_collations добавляет правила сортировки в системный каталог
pg_collation, анализируя все локали, которые она находит в операционной системе. Эту инфор-
мацию использует initdb; за подробностями обратитесь к Подразделу 23.2.2. Если позднее в си-
стему устанавливаются дополнительные локали, эту функцию можно запустить снова, чтобы доба-
вились правила сортировки для новых локалей. Локали, для которых обнаруживаются существую-
щие записи в pg_collation, будут пропущены. (Объекты правил сортировки для локалей, которые
перестают существовать в операционной системе, никогда не удаляются этой функцией.) В пара-
метре schema обычно передаётся pg_catalog, но это не обязательно; правила сортировки могут
быть установлены и в другую схему. Эта функция возвращает число созданных ей объектов правил
сортировки.
9.26.8. Функции обслуживания индексов
В Таблице 9.87 перечислены функции, предназначенные для обслуживания индексов. Эти функ-
ции нельзя вызывать в процессе восстановления. Использовать эти функции разрешено только су-
перпользователям и владельцу определённого индекса.
Таблица 9.87. Функции обслуживания индексов
Имя Тип результата Описание
brin_summarize_new_
values( index regclass) integer обобщает ещё не обобщённые
зоны страниц
brin_summarize_range(
integer
index regclass, blockNumber
bigint) обобщает зону страниц, охваты-
вающую данный блок (если она
ещё не обобщена)
brin_desummarize_range(
integer
index regclass, blockNumber
bigint) сброс обобщения зоны страниц,
охватывающей данный блок (ес-
ли она была обобщена)
gin_clean_pending_list(
index regclass) перемещает элементы из спис-
ка записей GIN, ожидающих об-
работки, в основную структуру
индекса
bigint
Функция brin_summarize_new_values принимает OID или имя индекса BRIN и просматривает ин-
декс в поисках зон страниц в базовой таблице, ещё не обобщённых в индексе; для каждой такой
зоны в результате сканирования страниц таблицы создаётся новый обобщающий кортеж в индек-
се. Возвращает эта функция число вставленных в индекс обобщающих записей о зонах страниц.
Функция brin_summarize_range делает то же самое, но затрагивает только зону, охватывающую
блок с заданным номером.
Функция gin_clean_pending_list принимает OID или имя индекса GIN и очищает очередь указан-
ного индекса, массово перемещая элементы из неё в основную структуру данных GIN. Возвращает
она число страниц, убранных из очереди. Заметьте, что если для обработки ей передаётся индекс
GIN, построенный с отключённым параметром fastupdate, очистка не производится и возвраща-
ется значение 0, так как у такого индекса нет очереди записей. Подробнее об очереди записей и
параметре fastupdate рассказывается в Подразделе 66.4.1 и Разделе 66.5.
9.26.9. Функции для работы с обычными файлами
Функции, перечисленные в Таблице 9.88, предоставляют прямой доступ к файлам, находящимся
на сервере. Обычным пользователям, не включённым в роль pg_read_server_files, они позволяют
обращаться только к файлам в каталоге кластера баз данных и в каталоге log_directory. Для
336Функции и операторы
файлов в каталоге кластера этим функциям передаётся относительный путь, а для файлов журнала
— путь, соответствующий значению параметра log_directory.
Заметьте, что пользователи, обладающие правом EXECUTE для pg_read_file() или связанных
функций, имеют возможность читать любой файл на сервере, который может прочитать сервер-
ный процесс, и это чтение не ограничивается никакими проверками уровня базы данных. В част-
ности это означает, что пользователь с такими правами может прочитать содержимое таблицы
pg_authid, в которой хранятся данные аутентификации, равно как и любой другой файл в базе
данных. Таким образом, разрешать доступ к этим функциям следует с большой осторожностью.
Таблица 9.88. Функции для работы с обычными файлами
Имя
Тип результата
Описание
pg_ls_dir(
dirname text [, setof text
missing_ok
boolean,
include_dot_dirs
boolean]) Выводит содержимое каталога (
по умолчанию разрешено толь-
ко суперпользователям, но пра-
во на её выполнение (EXECUTE)
можно дать и другим пользова-
телям).
pg_ls_logdir() setof record Выводит имя, размер и время
последнего изменения файлов
в каталоге журнала сообщений.
Доступ к этой функции имеют
члены роли pg_monitor , также
его можно разрешить и другим
ролям обычных пользователей.
pg_ls_waldir() setof record Выводит имя, размер и время
последнего изменения файлов
в каталоге WAL. Доступ к этой
функции имеют члены роли pg_
monitor , также его можно раз-
решить и другим ролям обыч-
ных пользователей.
pg_read_file(
filename
text
text
[,
offset
bigint,
length bigint [, missing_
ok boolean] ]) Возвращает содержимое тек-
стового файла (по умолчанию
разрешено только суперпользо-
вателям, но право на её выпол-
нение (EXECUTE) можно дать и
другим пользователям).
pg_read_binary_file(
bytea
filename text [,
offset
bigint,
length bigint [,
missing_ok boolean] ]) Возвращает содержимое файла
(по умолчанию разрешено толь-
ко суперпользователям, но пра-
во на её выполнение (EXECUTE)
можно дать и другим пользова-
телям).
pg_stat_file(
filename
record
text[, missing_ok boolean]) Возвращает информацию о фай-
ле (по умолчанию разреше-
но только суперпользователям,
но право на её выполнение (
EXECUTE) можно дать и другим
пользователям).
Некоторые из этих функций принимают необязательный параметр missing_ok, который определя-
ет их поведение в случае отсутствия файла или каталога. Если он равен true, функция возвращает
NULL (за исключением pg_ls_dir, которая возвращает пустое множество). Если он равен false,
возникает ошибка. Значение по умолчанию — false.
337Функции и операторы
pg_ls_dir возвращает имена всех файлов (а также каталогов и других специальных файлов) в
заданном каталоге. Параметр include_dot_dirs определяет, будут ли в результирующий набор
включаться каталоги «.» и «..». По умолчанию они не включаются (false), но их можно включить,
чтобы с параметром missing_ok равным true, пустой каталог можно было отличить от несуще-
ствующего.
pg_ls_logdir возвращает имя, размер и время последнего изменения (mtime) всех файлов в ката-
логе журналов сообщений. По умолчанию использовать её разрешено только суперпользователям
и членам роли pg_monitor. Другим пользователям доступ к ней можно дать, используя GRANT.
pg_ls_waldir возвращает имя, размер и время последнего изменения (mtime) всех файлов в ката-
логе журнала предзаписи (WAL). По умолчанию использовать её разрешено только суперпользо-
вателям и членам роли pg_monitor. Другим пользователям доступ к ней можно дать, используя
GRANT.
pg_read_file возвращает фрагмент текстового файла с заданного смещения (offset), размером
не больше length байт (размер может быть меньше, если файл кончится раньше). Если смещение
offset отрицательно, оно отсчитывается от конца файла. Если параметры offset и length опуще-
ны, возвращается всё содержимое файла. Прочитанные из файла байты обрабатываются как сим-
волы в серверной кодировке; если они оказываются недопустимыми для этой кодировки, возника-
ет ошибка.
pg_read_binary_file подобна pg_read_file, но её результат имеет тип bytea; как следствие, ни-
какие проверки кодировки не выполняются. В сочетании с convert_from эту функцию можно при-
менять для чтения файлов в произвольной кодировке:
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
pg_stat_file возвращает запись, содержащую размер файла, время последнего обращения и по-
следнего изменения, а также время последнего изменения состояния (только в Unix-системах),
время создания (только в Windows) и признак типа boolean, показывающий, что это каталог. При-
меры использования:
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
9.26.10. Функции управления рекомендательными блокировками
Функции, перечисленные в Таблице 9.89, предназначены для управления рекомендательными бло-
кировками. Подробнее об их использовании можно узнать в Подразделе 13.3.5.
Таблица 9.89. Функции управления рекомендательными блокировками
Имя
Тип результата Описание
pg_advisory_lock(
bigint) key void Получает исключительную бло-
кировку на уровне сеанса
pg_advisory_lock(
int, key2 int) key1 void Получает исключительную бло-
кировку на уровне сеанса
pg_advisory_lock_shared(
key bigint) void Получает разделяемую блоки-
ровку на уровне сеанса
pg_advisory_lock_shared(
key1 int, key2 int) void Получает разделяемую блоки-
ровку на уровне сеанса
pg_advisory_unlock(
bigint) boolean Освобождает исключительную
блокировку на уровне сеанса
key
338Функции и операторы
Имя
Тип результата Описание
boolean Освобождает исключительную
блокировку на уровне сеанса
pg_advisory_unlock_all() void Освобождает все блокировки на
уровне сеанса, удерживаемые в
данном сеансе
pg_advisory_unlock_
shared( key bigint) boolean Освобождает разделяемую бло-
кировку на уровне сеанса
pg_advisory_unlock_
boolean
shared( key1 int, key2 int) Освобождает разделяемую бло-
кировку на уровне сеанса
pg_advisory_xact_lock(
key bigint) void Получает исключительную бло-
кировку на уровне транзакции
pg_advisory_xact_lock(
key1 int, key2 int) void Получает исключительную бло-
кировку на уровне транзакции
pg_advisory_xact_lock_
shared( key bigint) void Получает разделяемую блоки-
ровку на уровне транзакции
pg_advisory_xact_lock_
void
shared( key1 int, key2 int) Получает разделяемую блоки-
ровку на уровне транзакции
pg_try_advisory_lock(
bigint) key boolean Получает исключительную бло-
кировку на уровне сеанса, если
это возможно
pg_try_advisory_lock(
key1 int, key2 int) boolean Получает исключительную бло-
кировку на уровне сеанса, если
это возможно
pg_try_advisory_lock_
shared( key bigint) boolean Получает разделяемую блоки-
ровку на уровне сеанса, если
это возможно
pg_try_advisory_lock_
boolean
shared( key1 int, key2 int) Получает разделяемую блоки-
ровку на уровне сеанса, если
это возможно
pg_try_advisory_xact_
lock( key bigint) boolean Получает исключительную бло-
кировку на уровне транзакции,
если это возможно
pg_try_advisory_xact_
lock( key1 int, key2 int) boolean Получает исключительную бло-
кировку на уровне транзакции,
если это возможно
pg_try_advisory_xact_
lock_shared(
key bigint) boolean Получает разделяемую блоки-
ровку на уровне транзакции, ес-
ли это возможно
pg_try_advisory_xact_
lock_shared(
key1
key2 int) boolean Получает разделяемую блоки-
ровку на уровне транзакции, ес-
ли это возможно
pg_advisory_unlock(
int, key2 int)
key1
int,
pg_advisory_lock блокирует определённый приложением ресурс, задаваемый одним 64-битным
или двумя 32-битными ключами (заметьте, что их значения не пересекаются). Если идентифика-
тор этого ресурса удерживает другой сеанс, эта функция не завершится, пока ресурс не станет
доступным. Данная функция устанавливает блокировку в исключительном режиме. Если поступа-
ет сразу несколько запросов на блокировку, они накапливаются, так что если один ресурс был
заблокирован три раза, его необходимо три раза разблокировать, чтобы он был доступен в других
сеансах.
339Функции и операторы
pg_advisory_lock_shared работает подобно pg_advisory_lock, но позволяет разделять блокиров-
ку с другими сеансами, запрашивающими её как разделяемую. Выполнение может быть приоста-
новлено, только если другой сеанс запросил её в исключительном режиме.
pg_try_advisory_lock работает подобно pg_advisory_lock, но не ждёт освобождения ресурса. Эта
функция либо немедленно получает блокировку и возвращает true, либо сразу возвращает false,
если получить её не удаётся.
pg_try_advisory_lock_shared работает как pg_try_advisory_lock, но пытается получить разде-
ляемую, а не исключительную блокировку.
pg_advisory_unlock освобождает ранее полученную исключительную блокировку на уровне сеан-
са. Если блокировка освобождена успешна, эта функция возвращает true, а если она не была за-
нята — false, при этом сервер выдаёт предупреждение SQL.
pg_advisory_unlock_shared работает подобно pg_advisory_unlock, но освобождает разделяемую
блокировку на уровне сеанса.
pg_advisory_unlock_all освобождает все блокировки на уровне сеанса, закреплённые за текущим
сеансом. (Эта функция неявно вызывается в конце любого сеанса, даже при нештатном отключе-
нии клиента.)
pg_advisory_xact_lock работает подобно pg_advisory_lock, но её блокировка автоматически
освобождается в конце текущей транзакции и не может быть освобождена явным образом.
pg_advisory_xact_lock_shared подобна функции pg_advisory_lock_shared, но её блокировка ав-
томатически освобождается в конце текущей транзакции и не может быть освобождена явным
образом.
pg_try_advisory_xact_lock работает подобно pg_try_advisory_lock, но её блокировка (если она
была получена) автоматически освобождается в конце текущей транзакции и не может быть осво-
бождена явным образом.
pg_try_advisory_xact_lock_shared работает подобно pg_try_advisory_lock_shared, но её блоки-
ровка (если она была получена) автоматически освобождается в конце текущей транзакции и не
может быть освобождена явным образом.
9.27. Триггерные функции
В настоящее время в PostgreSQL есть единственная встроенная триггерная функция,
suppress_redundant_updates_trigger, которая предотвращает изменения, фактически не влияю-
щие на данные в строке, тогда как обычно изменения выполняются вне зависимости от того, были
ли изменены данные. (Обычное поведение не предполагает сравнения данных, поэтому изменения
выполняются быстрее, и в ряде случаев именно это поведение желательно.)
В идеале, следует избегать операций изменения, которые фактически не меняют данные в запи-
сях. Подобные ненужные изменения могут обходиться дорого, особенно когда требуется обновлять
множество индексов, к тому же впоследствии базу данных придётся очищать от «мёртвых» строк.
Однако выявить такие изменения в клиентском коде бывает сложно, если вообще возможно, а при
составлении соответствующих проверочных выражений легко допустить ошибку. В качестве аль-
тернативного решения можно использовать функцию suppress_redundant_updates_trigger, кото-
рая опускает изменения, не меняющие данные. Однако использовать её следует с осторожностью.
Данный триггер выполняется не большое, но значительное время для каждой записи, так что если
большинство записей всё-таки фактически изменяются, этот триггер скорее замедлит операцию
изменения.
340Функции и операторы
Функцию suppress_redundant_updates_trigger можно привязать к таблице так:
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
В большинстве случаев этот триггер должен вызываться для каждой строки последним. А так как
триггеры вызываются по порядку сортировки их имён, имя для него нужно выбирать таким, чтобы
оно было последним среди имён всех триггеров, которые могут быть в таблице.
Подробнее о создании триггеров можно узнать в описании CREATE TRIGGER.
9.28. Функции событийных триггеров
PostgreSQL предоставляет следующие вспомогательные функции для получения информации в
событийных триггерах.
Подробнее о событийных триггерах можно узнать в Главе 40.
9.28.1. Получение изменений в конце команды
Функция pg_event_trigger_ddl_commands возвращает список команд DDL, выполняемых в резуль-
тате действия пользователя. Вызывать её можно только в функции, реализующей событийный
триггер ddl_command_end. При попытке вызвать её в любом другом контексте возникнет ошиб-
ка. Функция pg_event_trigger_ddl_commands возвращает одну строку для каждой базовой коман-
ды; для некоторых команд, записываемых в виде одного предложения SQL, может возвращаться
несколько строк. Эта функция возвращает следующие столбцы:
Имя Тип Описание
classid oid OID каталога, к которому отно-
сится объект
objid oid OID самого объекта
objsubid integer Идентификатор подобъекта (на-
пример, номер для столбца)
command_tag text Тег команды
object_type text Тип объекта
schema_name text Имя схемы, к которой относит-
ся объект; если объект не отно-
сится ни к какой схеме — NULL.
В кавычки имя не заключается.
object_identity text Текстовое представление иден-
тификатора объекта, включаю-
щее схему. При необходимости
компоненты этого идентифика-
тора заключаются в кавычки.
in_extension bool True, если команда является ча-
стью скрипта расширения
command pg_ddl_command Полное представление коман-
ды, во внутреннем формате. Его
нельзя вывести непосредствен-
но, но можно передать другим
функциям, чтобы получить раз-
личные сведения о команде.
9.28.2. Обработка объектов, удалённых командой DDL
341Функции и операторы
Функция pg_event_trigger_dropped_objects возвращает список всех объектов, удалён-
ных
командой,
вызвавшей
событие
sql_drop.
При
вызове
в
другом
контексте
pg_event_trigger_dropped_objects выдаёт ошибку. pg_event_trigger_dropped_objects возвра-
щает следующие столбцы:
Имя Тип Описание
classid oid OID каталога, к которому отно-
сился объект
objid oid OID самого объекта
objsubid integer Идентификатор подобъекта (на-
пример, номер для столбца)
original bool True, если это один из корневых
удаляемых объектов
normal bool True, если к этому объекту в гра-
фе зависимостей привело отно-
шение обычной зависимости
is_temporary bool True, если объект был времен-
ным
object_type text Тип объекта
schema_name text Имя схемы, к которой относил-
ся объект; если объект не отно-
сился ни к какой схеме — NULL.
В кавычки имя не заключается.
object_name text Имя объекта, если сочетание
схемы и имени позволяет уни-
кально идентифицировать объ-
ект; в противном случае — NULL.
Имя не заключается в кавычки
и не дополняется именем схе-
мы.
object_identity text Текстовое представление иден-
тификатора объекта, включаю-
щее схему. При необходимости
компоненты этого идентифика-
тора заключаются в кавычки.
address_names text[] Массив, который в сочета-
нии с object_type и масси-
вом address_args можно пере-
дать функции pg_get_object_
address() , чтобы воссоздать
адрес объекта на удалённом
сервере, содержащем одно-
имённый объект того же рода.
address_args text[] Дополнение к массиву address_
names
Функцию pg_event_trigger_dropped_objects можно использовать в событийном триггере так:
CREATE FUNCTION test_event_trigger_for_drops()
RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
obj record;
BEGIN
FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
342Функции и операторы
LOOP
RAISE NOTICE '% dropped object: % %.% %',
tg_tag,
obj.object_type,
obj.schema_name,
obj.object_name,
obj.object_identity;
END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
ON sql_drop
EXECUTE FUNCTION test_event_trigger_for_drops();
9.28.3. Обработка события перезаписи таблицы
В Таблице 9.90 показаны функции, выдающие информацию о таблице, для которой произошло со-
бытие перезаписи таблицы (table_rewrite). При попытке вызвать их в другом контексте возник-
нет ошибка.
Таблица 9.90. Информация о перезаписи таблицы
Имя Тип результата Описание
pg_event_trigger_table_
rewrite_oid() Oid OID таблицы, которая будет пе-
резаписана.
pg_event_trigger_table_
rewrite_reason() int Код причины, показывающий,
чем вызвана перезапись. Точ-
ное значение кодов зависит от
выпуска (версии).
Функцию pg_event_trigger_table_rewrite_oid можно использовать в событийном триггере так:
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
RETURNS event_trigger
LANGUAGE plpgsql AS
$$
BEGIN
RAISE NOTICE 'rewriting table % for reason %',
pg_event_trigger_table_rewrite_oid()::regclass,
pg_event_trigger_table_rewrite_reason();
END;
$$;
CREATE EVENT TRIGGER test_table_rewrite_oid
ON table_rewrite
EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
