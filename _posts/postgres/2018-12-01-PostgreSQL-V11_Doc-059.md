---
layout: post
title: Глава 59. Написание провайдера нестандартного сканирования
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 59. Написание провайдера нестандартного сканирования


PostgreSQL поддерживает набор экспериментальных средств, предназначенных для того, чтобы
модули расширения могли добавлять в систему новые типы сканирования. В отличие от обёртки
сторонних данных, которая должна знать, как сканировать только собственные таблицы, провай-
дер сканирования может реализовать нестандартный вариант сканирования любого отношения в
системе. Обычно к написанию провайдера нестандартного сканирования подталкивает желание
реализовать какую-то оптимизацию, не поддерживаемую основной системой, например, кеширо-
вание или аппаратное ускорение некоторого рода. В этой главе рассказывается, как написать свой
провайдер нестандартного сканирования.
Процесс реализации нестандартного сканирования нового типа состоит из трёх этапов. Во-пер-
вых, во время планирования необходимо построить пути доступа, представляющие сканирование
с предлагаемой стратегией. Во-вторых, если один из этих путей доступа выбирается планировщи-
ком как оптимальная стратегия сканирования определённого отношения, этот путь доступа дол-
жен быть преобразован в план. Наконец, должно быть возможно выполнить этот план, получив
при этом те же результаты, что были бы получены с любым другим путём доступа, выбранным для
того же отношения.
59.1. Создание нестандартных путей сканирования
Провайдер нестандартного сканирования обычно добавляет пути для базового отношения, уста-
новив следующий обработчик, который вызывается после того, как ядро системы построит, по её
мнению, полный и корректный набор путей доступа для отношения.
typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
RelOptInfo *rel,
Index rti,
RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
Хотя эта функция-обработчик может изучать, изменять или удалять пути, сформированные основ-
ной системой, провайдер нестандартного сканирования обычно ограничивается созданием объек-
тов CustomPath и добавлением их в rel (с помощью add_path). Провайдер нестандартного скани-
рования отвечает за инициализацию объекта CustomPath, который описан так:
typedef struct CustomPath
{
Path
path;
uint32
flags;
List
*custom_paths;
List
*custom_private;
const CustomPathMethods *methods;
} CustomPath;
Поле path должно инициализироваться как для любого другого пути и включать оцен-
ку числа строк, стоимость запуска и общую, а также порядок сортировки, устанавли-
ваемый этим путём. Поле flags задаёт битовую маску, которая должна включать флаг
CUSTOMPATH_SUPPORT_BACKWARD_SCAN, если нестандартный путь поддерживает сканирование назад,
и CUSTOMPATH_SUPPORT_MARK_RESTORE, если он поддерживает пометку позиции и её восстановление.
Обе эти возможности являются факультативными. В необязательном поле custom_paths задаётся
список узлов Path, используемых данным узлом; они будут преобразованы планировщиком в узлы
Plan. В поле custom_private могут быть сохранены внутренние данные нестандартного пути. Со-
хранять их нужно в форме, которую может принять nodeToString, чтобы отладочные процедуры,
пытающиеся вывести нестандартный путь, работали ожидаемым образом. Поле methods должно
указывать на объект (обычно статически размещённый), реализующий требуемые методы нестан-
дартного пути (на данный момент это один метод). В этом объекте также должны быть инициа-
2110Написание провайдера нестан-
дартного сканирования
лизированы поля LibraryName и SymbolName, чтобы динамический загрузчик мог разрешить их и
загрузить таблицу методов.
Провайдер нестандартного сканирования может также реализовать пути соединений. Как и для
базовых отношений, такой путь должен выдавать тот же результат, какой был бы получен обычным
соединением, которое он заменяет. Для этого провайдер соединения должен установить следую-
щий обработчик, а затем внутри функции-обработчика создать пути CustomPath для отношения
соединения.
typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
RelOptInfo *joinrel,
RelOptInfo *outerrel,
RelOptInfo *innerrel,
JoinType jointype,
JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
Этот обработчик будет вызываться многократно для одного отношения соединения с разными со-
четаниями внутренних и внешних отношений; задача обработчика — минимизировать при этом
дублирующиеся операции.
59.1.1. Обработчики пути нестандартного сканирования
Plan *(*PlanCustomPath) (PlannerInfo *root,
RelOptInfo *rel,
CustomPath *best_path,
List *tlist,
List *clauses,
List *custom_plans);
Преобразует нестандартный путь в законченный план. Возвращаемым значением обычно будет
объект CustomScan, который этот обработчик должен разместить в памяти и инициализировать. За
подробностями обратитесь к Разделу 59.2.
59.2. Создание нестандартных планов сканирования
Нестандартное сканирование представляется в окончательном дереве плана в виде следующей
структуры:
typedef struct CustomScan
{
Scan
scan;
uint32
flags;
List
*custom_plans;
List
*custom_exprs;
List
*custom_private;
List
*custom_scan_tlist;
Bitmapset *custom_relids;
const CustomScanMethods *methods;
} CustomScan;
Объект в поле scan должен быть инициализирован, как и для любого другого сканирования, и
включать оценки стоимости, целевые списки, условия и т. д. Поле flags содержит битовую мас-
ку с тем же значением, что и в CustomPath. В поле custom_plans могут быть сохранены дочерние
узлы Plan. В custom_exprs могут быть сохранены деревья выражений, которые будут исправлять-
ся кодом в setrefs.c и subselect.c, а в custom_private следует сохранить другие внутренние
данные, которые будут использоваться только самим провайдером нестандартного сканирования.
Поле custom_scan_tlist может содержать NIL при сканировании базового отношения, что будет
показывать, что нестандартное сканирование возвращает кортежи, соответствующие типу строк
базового отношения. В противном случае оно должно указывать на целевой список, описывающий
2111Написание провайдера нестан-
дартного сканирования
фактические кортежи. Список custom_scan_tlist должен устанавливаться при соединениях и мо-
жет задаваться при сканировании, если провайдер сканирования может вычислять какие-либо вы-
ражения без переменных. Поле custom_relids заполняется ядром и задаёт набор отношений (ин-
дексов в списке отношений), которые обрабатывает данный узел сканирования; когда имеет место
сканирование, а не соединение, в этом списке будет всего один элемент. Поле methods должно
указывать на объект (обычно статически размещённый), реализующий требуемые методы нестан-
дартного сканирования, которые подробнее описываются ниже.
Когда CustomScan сканирует одно отношение, в scan.scanrelid должен задаваться индекс скани-
руемой таблицы в списке отношений. Когда он заменяет соединение, поле scan.scanrelid должно
быть нулевым.
Деревья планов должны поддерживать возможность копирования функцией copyObject, так что
все данные, сохранённые в «дополнительных» полях, должны быть узлами, которые может об-
работать эта функция. Более того, провайдеры нестандартного сканирования не могут заменять
структуру CustomScan расширенной структурой, её содержащей, что возможно с CustomPath или
CustomScanState.
59.2.1. Обработчики плана нестандартного сканирования
Node *(*CreateCustomScanState) (CustomScan *cscan);
Выделяет структуру CustomScanState для заданного объекта CustomScan. Фактически выделенная
область будет обычно больше, чем требуется для самой структуры CustomScanState, так как мно-
гие провайдеры могут включать её в расширенную структуру в качестве первого поля. В возвра-
щаемом значении должны быть подходящим образом заполнены тег узла и поле methods, но дру-
гие поля на данном этапе должны быть обнулены; после того как ExecInitCustomScan произведёт
базовую инициализацию, будет вызван обработчик BeginCustomScan, в котором провайдер нестан-
дартного сканирования может выполнить все остальные требуемые действия.
59.3. Выполнение нестандартного сканирования
Когда выполняется узел CustomScan, его состояние представляется структурой CustomScanState,
объявленной следующим образом:
typedef struct CustomScanState
{
ScanState ss;
uint32
flags;
const CustomExecMethods *methods;
} CustomScanState;
Поле ss инициализируется как и для состояния любого другого сканирования, за исключе-
нием того, что когда это сканирование для соединения, а не для базового отношения, в
ss.ss_currentRelation остаётся NULL. Поле flags содержит битовую маску с тем же значени-
ем, что и в CustomPath и CustomScan. Поле methods должно указывать на объект (обычно стати-
чески размещённый), реализующий требуемые методы состояния нестандартного сканирования,
подробнее описанные ниже. Обычно структура CustomScanState, которой не нужно поддерживать
copyObject, фактически включается в расширенную структуру в качестве её первого члена.
59.3.1. Обработчики выполнения нестандартного сканирования
void (*BeginCustomScan) (CustomScanState *node,
EState *estate,
int eflags);
Завершает инициализацию переданного объекта CustomScanState. Стандартные поля инициали-
зируются в ExecInitCustomScan, но все внутренние поля должны инициализироваться здесь.
TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);
2112Написание провайдера нестан-
дартного сканирования
Считывает следующий кортеж. В случае наличия кортежей эта функция должна записать в
ps_ResultTupleSlot следующий кортеж в текущем направлении сканирования и вернуть слот с
кортежем. Если же кортежей больше нет, она должна вернуть NULL или пустой слот.
void (*EndCustomScan) (CustomScanState *node);
Очищает все внутренние данные, связанные с CustomScanState. Этот метод является обязатель-
ным, но он может ничего не делать, если такие данные отсутствуют или они будут очищены авто-
матически.
void (*ReScanCustomScan) (CustomScanState *node);
Возвращает позицию текущего сканирования в начало и подготавливает повторное сканирование
отношения.
void (*MarkPosCustomScan) (CustomScanState *node);
Сохраняет текущую позицию сканирования, чтобы к ней впоследствии можно было вернуться,
вызвав обработчик RestrPosCustomScan. Данный обработчик является необязательным и должен
присутствовать, только если установлен флаг CUSTOMPATH_SUPPORT_MARK_RESTORE.
void (*RestrPosCustomScan) (CustomScanState *node);
Восстанавливает
предыдущую
позицию
сканирования,
сохранённую
обработчиком
MarkPosCustomScan. Данный обработчик является необязательным и должен присутствовать, толь-
ко если установлен флаг CUSTOMPATH_SUPPORT_MARK_RESTORE.
Size (*EstimateDSMCustomScan) (CustomScanState *node,
ParallelContext *pcxt);
Оценивает объём динамической разделяемой памяти, которая потребуется для параллельной опе-
рации. Это значение может превышать объём, который будет занят фактически, но не должно быть
меньше. Возвращаемое значение задаётся в байтах. Этот обработчик не является обязательным
и должен устанавливаться, только если провайдер нестандартного сканирования поддерживает
параллельное выполнение.
void (*InitializeDSMCustomScan) (CustomScanState *node,
ParallelContext *pcxt,
void *coordinate);
Инициализирует динамическую разделяемую память, которая потребуется для параллельной опе-
рации; coordinate указывает на область разделяемой памяти размера, равного возвращаемому
значению EstimateDSMCustomScan. Этот обработчик является необязательным и должен устанав-
ливаться, только если провайдер нестандартного сканирования поддерживает параллельное вы-
полнение.
void (*ReInitializeDSMCustomScan) (CustomScanState *node,
ParallelContext *pcxt,
void *coordinate);
Заново инициализирует динамическую разделяемую память, требуемую для параллельной опера-
ции, перед тем как будет повторно просканирован узел нестандартного сканирования. Этот обра-
ботчик является необязательным и должен устанавливаться, только если провайдер нестандарт-
ного сканирования поддерживает параллельное выполнение. В этом обработчике рекомендуется
сбрасывать только общее состояние, а в обработчике ReScanCustomScan сбрасывать только локаль-
ное. В настоящее время этот обработчик будет вызываться перед ReScanCustomScan, но лучше на
этот порядок не рассчитывать.
void (*InitializeWorkerCustomScan) (CustomScanState *node,
shm_toc *toc,
void *coordinate);
Инициализирует локальное состояние параллельного исполнителя на основе общего состояния,
заданного ведущим исполнителем во время InitializeDSMCustomScan. Этот обработчик является
2113Написание провайдера нестан-
дартного сканирования
необязательным и должен устанавливаться, только если провайдер нестандартного сканирования
поддерживает параллельное выполнение.
void (*ShutdownCustomScan) (CustomScanState *node);
Освобождает ресурсы, когда становится понятно, что этот узел больше не будет выполняться. Этот
обработчик вызывается не во всех случаях; иногда может вызываться только EndCustomScan. Так
как сегмент DSM, используемый параллельным запросом, освобождается сразу после вызова это-
го обработчика, провайдеры нестандартного сканирования, которым нужно выполнять некоторые
действия до ликвидации сегмента DSM, должны реализовывать этот метод.
void (*ExplainCustomScan) (CustomScanState *node,
List *ancestors,
ExplainState *es);
Выводит дополнительную информацию для EXPLAIN об узле нестандартного сканирования. Этот
обработчик является необязательным. Общие данные, сохранённые в ScanState, такие как целе-
вой список и сканируемое отношение, будут выводиться и без этого обработчика, но с помощью
этого обработчика можно выдать дополнительные, внутренние сведения.
2114
