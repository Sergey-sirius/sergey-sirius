---
layout: post
title: Глава 67. Индексы BRIN
description: ""
tags: [PostgreSQL, PostgreSQL_Book_11]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 67. Индексы BRIN

67.1. Введение

BRIN расшифровывается как «Block Range Index» (Индекс зон блоков). BRIN предназначается для
обработки очень больших таблиц, в которых определённые столбцы некоторым естественным об-
разом коррелируют с их физическим расположением в таблице. Зоной блоков называется группа
страниц, физически расположенных в таблице рядом; для каждой зоны в индексе сохраняется
некоторая сводная информация. Например, в таблице заказов магазина может содержаться поле
с датой добавления заказа, и практически всегда записи более ранних заказов и в таблице будут
размещены ближе к началу; в таблице, содержащей столбец с почтовым индексом, также есте-
ственным образом могут группироваться записи по городам.
Индексы BRIN могут удовлетворять запросы, выполняя обычное сканирование по битовой карте, и
будут возвращать все кортежи во всех страницах каждой зоны, если сводные данные, сохранённые
в индексе, соответствуют условиям запроса. Исполнитель запроса должен перепроверить эти
кортежи и отбросить те, что не соответствуют условиям запроса — другими словами, эти индексы
неточные. Так как индекс BRIN очень маленький, сканирование индекса влечёт мизерные издерж-
ки по сравнению с последовательным сканированием, но может избавить от необходимости ска-
нирования больших областей таблицы, которые определённо не содержат подходящие кортежи.
Конкретные данные, которые будут хранится в индексе BRIN, а также запросы, которые сможет
поддержать этот индекс, зависят от класса операторов, выбранного для каждого столбца индекса.
Например, типы данных с линейным порядком сортировки могут иметь классы операторов, храня-
щие минимальное и максимальное значение для каждой зоны блоков; для геометрических типов
может храниться прямоугольник, вмещающий все объекты в зоне блоков.
Размер зоны блоков определяется в момент создания индекса параметром хранения
pages_per_range. Число записей в индексе будет равняться размеру отношения в страницах, де-
лённому на установленное значение pages_per_range. Таким образом, чем меньше это число, тем
больше становится индекс (так как в нём требуется хранить больше элементов), но в то же время
сводные данные могут быть более точными и большее число блоков данных может быть пропущено
при сканировании индекса.
67.1.1. Обслуживание индекса
Во время создания индекса сканируются все существующие страницы, и в результате в индексе
создаётся сводный кортеж для каждой зоны, в том числе, возможно неполной зоны в конце. По
мере того, как данными наполняются новые страницы, если они оказываются в зонах, для которых
уже есть сводная информация, она будет обновлена с учётом данных из новых кортежей. Если же
создаётся новая страница, которая не попадает в последнюю зону, для новой зоны автоматически
не рассчитывается сводная запись; кортежи на таких страницах остаются неучтёнными, пока поз-
же не будет проведён расчёт сводных данных. Эта процедура может быть вызвана вручную, с по-
мощью функции brin_summarize_new_values(regclass), или автоматически, когда таблицу будет
обрабатывать VACUUM или при автоочистке по мере добавления записей. (Последний метод отклю-
чён по умолчанию и может быть включён параметром autosummarize.) И наоборот, можно удалить
сводное значение для зоны, вызвав функцию brin_desummarize_range(regclass, bigint), что мо-
жет быть полезно, когда этот кортеж в индексе становится не очень хорошим представлением со-
ответствующих данных, так как они изменились.
Когда включён режим автопересчёта сводки, при каждом заполнении зоны страниц механизму
автоочистки передаётся запрос для пересчёта сводки только по этой зоне, и он будет выполнен в
конце следующего прохода обработки той же базы данных. Если очередь запросов переполнена,
запрос в неё не записывается и в журнал сервера выводится соответствующее сообщение:
LOG: request for BRIN range summarization for index "brin_wi_idx" page 128 was not
recorded
2166Индексы BRIN
В этой ситуации сводка для данной зоны будет пересчитана при выполнении следующей обычной
очистки таблицы.
67.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов BRIN, перечисленные в Табли-
це 67.1.
Классы операторов minmax хранят минимальные и максимальные значения, встречающиеся в ин-
дексированном столбце в определённой зоне. Классы операторов inclusion хранят значение, в ко-
тором содержатся значения индексированного столбца в определённой зоне.
Таблица 67.1. Встроенные классы операторов BRIN
Имя Индексируемый тип данных Индексируемые операторы
abstime_minmax_ops abstime < <= = >= >
int8_minmax_ops bigint < <= = >= >
bit_minmax_ops bit < <= = >= >
varbit_minmax_ops bit varying < <= = >= >
box_inclusion_ops box << &< && &> >> ~= @> <@ &<| <<| |
>> |&>
bytea_minmax_ops bytea < <= = >= >
bpchar_minmax_ops character < <= = >= >
char_minmax_ops "char" < <= = >= >
date_minmax_ops date < <= = >= >
float8_minmax_ops double precision < <= = >= >
inet_minmax_ops inet < <= = >= >
network_inclusion_ops inet && >>= <<= = >> <<
int4_minmax_ops integer < <= = >= >
interval_minmax_ops interval < <= = >= >
macaddr_minmax_ops macaddr < <= = >= >
macaddr8_minmax_ops macaddr8 < <= = >= >
name_minmax_ops name < <= = >= >
numeric_minmax_ops numeric < <= = >= >
pg_lsn_minmax_ops pg_lsn < <= = >= >
oid_minmax_ops oid < <= = >= >
range_inclusion_ops любой тип диапазона << &< && &> >> @> <@ -|- = < <= =
> >=
float4_minmax_ops real < <= = >= >
reltime_minmax_ops reltime < <= = >= >
int2_minmax_ops smallint < <= = >= >
text_minmax_ops text < <= = >= >
tid_minmax_ops tid < <= = >= >
timestamp_minmax_ops timestamp without time zone < <= = >= >
timestamptz_minmax_ops timestamp with time zone < <= = >= >
time_minmax_ops time without time zone < <= = >= >
timetz_minmax_ops time with time zone < <= = >= >
2167Индексы BRIN
Имя Индексируемый тип данных Индексируемые операторы
uuid_minmax_ops uuid
< <= = >= >
67.3. Расширяемость
Интерфейс BRIN характеризуется высоким уровнем абстракции и таким образом требует от раз-
работчика метода доступа реализовать только смысловое наполнение обрабатываемого типа дан-
ных. Уровень BRIN берёт на себя заботу о параллельном доступе, поддержке журнала и поиске в
структуре индекса.
Всё, что нужно, чтобы получить работающий метод доступа BRIN — это реализовать несколько
пользовательских методов, определяющих поведение сводных значений, хранящихся в индексе, и
их взаимоотношения с ключами сканирования. Словом, BRIN сочетает расширяемость с универ-
сальностью, повторным использованием кода и аккуратным интерфейсом.
Класс операторов для BRIN должен предоставлять четыре метода:
BrinOpcInfo *opcInfo(Oid type_oid)
Возвращает внутреннюю информацию о сводных данных индексированных столбцов. Возвра-
щаемое значение должно указывать на BrinOpcInfo (в памяти palloc) со следующим определе-
нием:
typedef struct BrinOpcInfo
{
/* Число полей, хранящихся в столбце индекса этого класса операторов */
uint16
oi_nstored;
/* Непрозрачный указатель для внутреннего использования классом операторов */
void
*oi_opaque;
/* Элементы кеша типов для сохранённых столбцов */
TypeCacheEntry *oi_typcache[FLEXIBLE_ARRAY_MEMBER];
} BrinOpcInfo;
Поле BrinOpcInfo.oi_opaque могут использовать подпрограммы класса операторов для пере-
дачи информации опорным функциям при сканировании индекса.
bool consistent(BrinDesc *bdesc, BrinValues *column, ScanKey key)
Показывает, соответствует ли значение ScanKey заданным индексированным значениям неко-
торой зоны. Номер целевого атрибута передаётся в составе ключа сканирования.
bool addValue(BrinDesc *bdesc, BrinValues *column, Datum newval, bool isnull)
Для заданного кортежа индекса и индексируемого значения изменяет выбранный атрибут кор-
тежа, чтобы он дополнительно охватывал новое значение. Если в кортеж вносятся какие-либо
изменения, возвращается true.
bool unionTuples(BrinDesc *bdesc, BrinValues *a, BrinValues *b)
Консолидирует два кортежа индекса. Получая два кортежа, изменяет выбранный атрибут пер-
вого из них, что он охватывал оба кортежа. Второй кортеж не изменяется.
Основной дистрибутив включает поддержку двух типов классов операторов: minmax и inclusion.
Определения классов операторов, использующие их, представлены для встроенных типов данных,
насколько это уместно. Пользователь может определить дополнительные классы операторов для
других типов данных, применяя аналогичные определения, обойдясь без написания исходного ко-
да; достаточно будет объявить нужные записи в каталоге. Заметьте, что предположения о семан-
тике стратегий операторов зашиты в исходном коде опорных функций.
Также возможно создать классы операторов, воплощающие полностью другую семантику, разра-
ботав реализации четырёх основных опорных функций, описанных выше. Заметьте, что обратная
2168Индексы BRIN
совместимость между разными основными версиями не гарантируется: к примеру, в следующих
выпусках могут потребоваться дополнительные опорные функции.
При написании класса операторов для типа данных, представляющего полностью упорядоченное
множество, можно использовать опорные функции minmax вместе с соответствующими операто-
рами, как показано в Таблице 67.2. Все члены класса операторов (функции и операторы) являются
обязательными.
Таблица 67.2. Номера стратегий и опорных функций для классов операторов Minmax
Член класса операторов Объект
Опорная функция 1 внутренняя функция brin_minmax_opcinfo()
Опорная функция 2 внутренняя
value()
Опорная функция 3 внутренняя
consistent()
Опорная функция 4 внутренняя функция brin_minmax_union()
Стратегия оператора 1 оператор меньше
Стратегия оператора 2 оператор меньше-или-равно
Стратегия оператора 3 оператор равно
Стратегия оператора 4 оператор больше-или-равно
Стратегия оператора 5 оператор больше
функция
brin_minmax_add_
функция
brin_minmax_
При написании класса операторов для сложного типа данных, значения которого включаются в
другой тип, можно использовать опорные функции inclusion вместе с соответствующими операто-
рами, как показано в Таблице 67.3. Для этого требуется одна дополнительная функция, которую
можно написать на любом языке. Для расширенной функциональности можно определить другие
функции. Все операторы являются необязательными. Некоторые из них требует наличия других,
что показано в таблице как зависимости.
Таблица 67.3. Номера стратегий и опорных функций для классов операторов Inclusion
Член класса операторов Объект
Зависимость
Опорная функция 1 внутренняя
функция
inclusion_opcinfo()
brin_
Опорная функция 2 внутренняя
функция
inclusion_add_value()
brin_
Опорная функция 3 внутренняя
функция
brin_
inclusion_consistent()
Опорная функция 4 внутренняя
функция
inclusion_union()
Опорная функция 11 функция для слияния двух эле-
ментов
Опорная функция 12 необязательная функция для
проверки возможности слияния
двух элементов
Опорная функция 13 необязательная функция для
проверки, содержится ли один
элемент в другом
Опорная функция 14 необязательная функция для
проверки, является ли элемент
пустым
2169
brin_Индексы BRIN
Член класса операторов Объект Зависимость
Стратегия оператора 1 оператор левее Стратегия оператора 4
Стратегия оператора 2 оператор не-простирается-пра- Стратегия оператора 5
вее
Стратегия оператора 3 оператор перекрывается Стратегия оператора 4 оператор
вее Стратегия оператора 5 оператор правее Стратегия оператора 2
Стратегия оператора 6, 18 оператор то-же-или-равно Стратегия оператора 7
не-простирается-ле- Стратегия оператора 1
Стратегия оператора 7, 13, 16, оператор содержит-или-равно
24, 25
Стратегия оператора 8, 14, 26, оператор
27
равно
содержится-в-или- Стратегия оператора 3
Стратегия оператора 9 оператор
ше
не-простирается-вы- Стратегия оператора 11
Стратегия оператора 10 оператор ниже Стратегия оператора 12
Стратегия оператора 11 оператор выше Стратегия оператора 9
Стратегия оператора 12 оператор
же Стратегия оператора 20 оператор меньше Стратегия оператора 5
Стратегия оператора 21 оператор меньше-или-равно Стратегия оператора 5
Стратегия оператора 22 оператор больше Стратегия оператора 1
Стратегия оператора 23 оператор больше-или-равно Стратегия оператора 1
не-простирается-ни- Стратегия оператора 10
Номера опорных функций 1-10 зарезервированы для внутренних функций BRIN, так что функции
уровня SQL начинаются с номера 11. Опорная функция номер 11 является основной, необходимой
для построения индекса. Она должна принимать два аргумента того же типа данных, что и целе-
вой тип класса, и возвращать их объединение. Класс операторов inclusion может сохранять значе-
ния объединения в различных типах данных, в зависимости от параметра STORAGE. Возвращаемое
значение функции объединения должно соответствовать типу данных STORAGE.
Опорные функции под номерами 12 и 14 предоставляются для поддержки нерегулярностей встро-
енных типов данных. Функция номер 12 применяется для поддержки работы с сетевыми адресами
из различных семейств, которые нельзя объединять. Функция номер 14 применяется для поддерж-
ки зон с пустыми значениями. Функция номер 13 является необязательной, но рекомендуемой; она
проверяет новое значение, прежде чем оно будет передано функции объединения. Инфраструкту-
ра BRIN может соптимизировать некоторые операции, когда объединение не меняется, поэтому
применение этой функции может способствовать увеличению быстродействия индекса.
Классы операторов minmax и inclusion поддерживают операторы с разными типами, хотя с ними
зависимости становятся более сложными. Класс minmax требует, чтобы для двух аргументов одно-
го типа определялся полный набор операторов. Это позволяет поддерживать дополнительные ти-
пы данных, определяя дополнительные наборы операторов. Стратегии операторов класса inclusion
могут зависеть от других стратегий, как показано в Таблице 67.3, или от своих собственных стра-
тегий. Для них требуется, чтобы был определён необходимый оператор с типом данных STORAGE
для левого аргумента и другим поддерживаемым типом для правого аргумента реализуемого опе-
ратора. См. определение float4_minmax_ops в качестве примера для minmax и box_inclusion_ops
в качестве примера для inclusion.
2170
