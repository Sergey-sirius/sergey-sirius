<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page15/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page15/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-038/" title="Глава 38. Расширение SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 38. Расширение SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-038/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~152 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-038/" rel="bookmark" title="Глава 38. Расширение SQL" itemprop="url">Глава 38. Расширение SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Часть V. Серверное программирование</p>

<p>Эта часть документации посвящена расширению функциональности сервера путём реализации соб-
ственных функций, типов данных, триггеров и т. д. Это довольно сложные темы, для освоения кото-
рых рекомендуется предварительно изучить и понять всю остальную документацию для пользовате-
лей PostgreSQL. В последних главах этой части описываются языки программирования на стороне
сервера, поддерживаемые дистрибутивом PostgreSQL, и рассматриваются общие вопросы, связан-
ные с программированием на стороне сервера. Но прежде чем погружаться в этот материал, важно
изучить предыдущие разделы Главы 38 (где освещаются функции).</p>

<p>Глава 38. Расширение SQL</p>

<p>В следующих разделах мы обсудим, как в PostgreSQL можно расширять язык запросов SQL, добав-
ляя собственные:
•
•
•
•
•
•
функции (начиная с Раздела 38.3)
агрегатные функции (начиная с Раздела 38.11)
типы данных (начиная с Раздела 38.12)
операторы (начиная с Раздела 38.13)
классы операторов для индексов (начиная с Раздела 38.15)
пакеты связанных объектов (начиная с Раздела 38.16)
38.1. Как реализована расширяемость
PostgreSQL является расширяемым благодаря тому, что его работа управляется каталогами. Ес-
ли вы знакомы с традиционными реляционными системами баз данных, вы знаете, что они хра-
нят информацию о базах, таблицах, столбцах и т. д., в структурах, которые обычно называются си-
стемными каталогами. (В некоторых системах они называются словарями данных.) Эти каталоги
представляются пользователю в виде таблиц, подобных любым другим, но СУБД ведёт в них свои
внутренние записи. Ключевое отличие PostgreSQL от обычных реляционных СУБД состоит в том,
что PostgreSQL хранит в этих каталогах намного больше информации: информацию не только о
таблицах и столбцах, но также о типах данных, функциях, методах доступа и т. д. Эти таблицы
могут быть изменены пользователями, а так как PostgreSQL в своих действиях руководствуется
этими таблицами, это означает, что пользователи могут расширять PostgreSQL. Обычные же СУБД
можно расширять, только модифицируя жёстко запрограммированные процедуры в исходном ко-
де или загружая модули, специально разработанные производителем СУБД.
Кроме того, сервер PostgreSQL может динамически загружать в свой процесс код, написанный
пользователем. То есть, пользователь может подключить файл с объектным кодом (например, раз-
деляемую библиотеку), который реализует новый тип или функцию, а PostgreSQL загрузит его по
мере надобности. Код, написанный на SQL, добавляется на сервер ещё проще. Эта способность
менять своё поведение «на лету» делает PostgreSQL исключительно подходящим для быстрого
прототипирования новых приложений и структур хранения.
38.2. Система типов PostgreSQL
Типы данных PostgreSQL делятся на базовые, типы-контейнеры, составные, доменные и псевдоти-
пы.
38.2.1. Базовые типы
Базовые типы — это типы, такие как integer, которые реализуются ниже уровня языка SQL (обыч-
но на низкоуровневом языке, например C). В общих чертах они соответствуют так называемым
абстрактным типам данных. PostgreSQL может работать с такими типами только через функции,
предоставленные пользователем, и понимать их поведение только в той степени, в какой его опи-
шет пользователь. Встроенные базовые типы описываются в Главе 8.
Типы-перечисления (enum) можно считать подкатегорией базовых типов. Они отличаются от дру-
гих типов тем, что их можно создавать просто командами SQL, обходясь без низкоуровневого про-
граммирования. За подробностями обратитесь к Разделу 8.7.
38.2.2. Типы-контейнеры
В PostgreSQL есть три вида «типов-контейнеров», то есть типов, которые могут содержать в себе
несколько значений других типов. Это массивы, составные типы и диапазоны.
Массивы могут содержать множество значений, имеющих один тип. Тип массива автоматически
создаётся для каждого базового и составного типа, диапазона и домена, но не для массивов —
996Расширение SQL
массивы массивов не существуют. Для системы типов многомерные массивы не отличаются от
одномерных. За дополнительными сведениями обратитесь к Разделу 8.15.
Составные типы, или типы строк, образуются при создании любой таблицы. С помощью команды
CREATE TYPE также можно определить «независимый» составной тип, не связанный с таблицей.
Составной тип представляет собой просто список типов с определёнными именами полей. Значе-
нием составного типа является строка таблицы или запись из значений полей. За дополнительны-
ми сведениями обратитесь к Разделу 8.16.
Диапазонный тип может содержать два значения одного типа, которые определяют нижнюю и
верхнюю границу диапазона. Диапазонные типы создаются пользователем, хотя существует и
несколько встроенных. За дополнительными сведениями обратитесь к Разделу 8.17.
38.2.3. Домены
Домен основывается на определённом нижележащем типе и во многих аспектах взаимозаменяем
с ним. Однако домен может иметь ограничения, уменьшающие множество допустимых для него
значений относительно нижележащего типа. Домены создаются SQL-командой CREATE DOMAIN.
За дополнительными сведениями обратитесь к Разделу 8.18.
38.2.4. Псевдотипы
Для специальных целей существует также несколько «псевдотипов». Псевдотипы нельзя задей-
ствовать в столбцах таблицы или в типах-контейнерах, но их можно использовать в объявлениях
аргументов и результатов функций. Это даёт возможность выделить в системе типов специальные
классы функций. Все существующие псевдотипы перечислены в Таблице 8.25.
38.2.5. Полиморфные типы
Особый интерес представляют пять псевдотипов: anyelement, anyarray, anynonarray, anyenum и
anyrange, которые называются полиморфными типами. Функция, в объявлении которой использу-
ются эти типы, называется полиморфной. Полиморфная функция может работать со множеством
различных типов данных; конкретный тип определяется в зависимости от значения, переданного
при вызове.
Полиморфные аргументы и результаты связываются друг с другом и сводятся к определённому
типу данных при разборе запроса, вызывающего полиморфную функцию. В каждой позиции (в ар-
гументах или возвращаемом значении), объявленной как anyelement, может передаваться любой
фактический тип данных, но в каждом конкретном вызове все эти фактические типы должны быть
одинаковыми. Аналогичным образом, в каждой позиции, объявленной как anyarray, может пере-
даваться любой тип данных массива, но все фактические типы массивов должны совпадать. Так же
и во всех позициях, объявленных как anyrange, должен передаваться одинаковый тип-диапазон.
Более того, если некоторые позиции объявлены как anyarray, а другие как anyelement, то фактиче-
ским типом в позициях anyarray должен быть массив, элементы которого имеют тот же тип, что и
значения в позициях anyelement. Подобным образом, если одни позиции объявлены как anyrange,
а другие как anyelement, фактическим типом в позициях anyrange должен быть диапазон, подтип
которого совпадает с типом, передаваемым в позициях anyelement. Псевдотип anynonarray обра-
батывается так же, как anyelement, но с дополнительным ограничением — фактический тип не
должен быть типом массива. Псевдотип anyenum тоже обрабатывается как anyelement, но его фак-
тические типы ограничиваются перечислениями.
Таким образом, когда с полиморфным типом объявлено несколько аргументов, в итоге допускают-
ся только определённые комбинации фактических типов. Например, функция, объявленная как
equal(anyelement, anyelement), примет в аргументах любые два значения, но только если их ти-
пы данных совпадают.
Когда с полиморфным типом объявлено возвращаемое значение функции, так же полиморф-
ным должен быть минимум один аргумент, и фактический тип результата при конкретном вы-
997Расширение SQL
зове определится по типу фактически переданного аргумента. Например, если бы отсутствовал
механизм обращения к элементам массива, его можно было бы реализовать, создав функцию
subscript(anyarray, integer) returns anyelement. С таким объявлением первым фактическим
аргументом должен быть массив, и из него будет выведен правильный тип результата при разборе
запроса. В качестве другого примера можно привести функцию f(anyarray) returns anyenum,
которая будет принимать только массивы перечислений.
Заметьте, что anynonarray и anyenum представляют не отдельные типы переменных; это те же
типы, что и anyelement, но с дополнительными ограничениями. Например, объявление функции
f(anyelement, anyenum) равнозначно объявлению f(anyenum, anyenum): оба фактических аргу-
мента должны быть одинаковыми типами-перечислениями.
Функции с переменным числом аргументом (описанные в Подразделе 38.5.5) тоже могут быть по-
лиморфными: для этого их последний параметр описывается как VARIADIC anyarray. Для целей
сопоставления аргументов и определения фактического типа результата такая функция представ-
ляется так же, как если бы в ней явно объявлялось нужное число параметров anynonarray.
38.3. Пользовательские функции
В PostgreSQL представлены функции четырёх видов:
• функции на языке запросов (функции, написанные на SQL) (Раздел 38.5)
• функции на процедурных языках (функции, написанные, например, на PL/pgSQL или PL/Tcl)
(Раздел 38.8)
• внутренние функции (Раздел 38.9)
• функции на языке C (Раздел 38.10)
Функции любых видов могут принимать в качестве аргументов (параметров) базовые типы, состав-
ные типы или их сочетания. Кроме того, любые функции могут возвращать значения базового или
составного типа. Также можно определить функции, возвращающие наборы базовых или состав-
ных значений.
Функции многих видов могут также принимать или возвращать определённые псевдотипы (напри-
мер, полиморфные типы), но доступные средства для работы с ними различаются. За подробно-
стями обратитесь к описанию конкретного вида функций.
Проще всего определить функции на языке SQL, поэтому сначала мы рассмотрим их. Многие кон-
цепции, касающиеся функций на SQL, затем распространятся и на другие виды функций.
Изучая эту главу, будет полезно обращаться к странице справки по команде CREATE FUNCTION,
чтобы лучше понимать примеры. Некоторые примеры из этой главы можно найти в файлах
funcs.sql и funcs.c в каталоге src/tutorial исходного кода PostgreSQL.
38.4. Пользовательские процедуры
Процедура представляет собой объект базы данных, подобный функции. Отличие состоит в том,
что процедура не возвращает значение, и поэтому для неё не определяется возвращаемый тип.
Тогда как функция вызывается в составе запроса или команды DML, процедура вызывается явно,
оператором CALL.
Всё, что говорится в продолжении данной главы о создании пользовательских функций, приме-
нимо и к процедурам, за исключением того, что для процедур используется команда CREATE
PROCEDURE, не определяется тип результата, и к ним не относятся некоторые свойства, напри-
мер, строгость.
Функции и процедуры в совокупности также называются подпрограммами. Существуют коман-
ды, такие как ALTER ROUTINE и DROP ROUTINE, которые способны работать и с функциями, и
998Расширение SQL
с процедурами, не требуя указания точного вида объекта. Однако заметьте, что команды CREATE
ROUTINE нет.
38.5. Функции на языке запросов (SQL)
SQL-функции выполняют произвольный список операторов SQL и возвращают результат последне-
го запроса в списке. В простом случае (не с множеством) будет возвращена первая строка резуль-
тата последнего запроса. (Помните, что понятие «первая строка» в наборе результатов с несколь-
кими строками определено точно, только если присутствует ORDER BY.) Если последний запрос
вообще не вернёт строки, будет возвращено значение NULL.
Кроме того, можно объявить SQL-функцию как возвращающую множество (то есть, несколько
строк), указав в качестве возвращаемого типа функции SETOF некий_тип, либо объявив её с указа-
нием RETURNS TABLE(столбцы). В этом случае будут возвращены все строки результата последнего
запроса. Подробнее это описывается ниже.
Тело SQL-функции должно представлять собой список SQL-операторов, разделённых точкой с за-
пятой. Точка с запятой после последнего оператора может отсутствовать. Если только функция
не объявлена как возвращающая void, последним оператором должен быть SELECT, либо INSERT,
UPDATE или DELETE с предложением RETURNING.
Любой набор команд на языке SQL можно скомпоновать вместе и обозначить как функцию. Поми-
мо запросов SELECT, эти команды могут включать запросы, изменяющие данные (INSERT, UPDATE и
DELETE), а также другие SQL-команды. (В SQL-функциях нельзя использовать команды управления
транзакциями, например COMMIT, SAVEPOINT, и некоторые вспомогательные команды, в частности
VACUUM.) Однако последней командой должна быть SELECT или команда с предложением RETURNING,
возвращающая результат с типом возврата функции. Если же вы хотите определить функцию SQL,
выполняющую действия, но не возвращающую полезное значение, вы можете объявить её как воз-
вращающую тип void. Например, эта функция удаляет строки с отрицательным жалованьем из
таблицы emp:
CREATE FUNCTION clean_emp() RETURNS void AS ‘
DELETE FROM emp
WHERE salary &lt; 0;
‘ LANGUAGE SQL;
SELECT clean_emp();
clean_emp
———–
(1 row)
Примечание
Прежде чем начинается выполнение команд, разбирается всё тело SQL-функции. Ко-
гда SQL-функция содержит команды, модифицирующие системные каталоги (напри-
мер, CREATE TABLE), действие таких команд не будет проявляться на стадии анализа
последующих команд этой функции. Так, например, команды CREATE TABLE foo (…);
INSERT INTO foo VALUES(…); не будут работать, как ожидается, если их упаковать
в одну SQL-функцию, так как foo не будет существовать к моменту разбору команды
INSERT. В подобных ситуациях вместо SQL-функции рекомендуется использовать PL/
pgSQL.
Синтаксис команды CREATE FUNCTION требует, чтобы тело функции было записано как строковая
константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. Подраз-
999Расширение SQL
дел 4.1.2.4). Если вы решите использовать обычный синтаксис с заключением строки в апострофы,
вам придётся дублировать апострофы (‘) и обратную косую черту () (предполагается синтаксис
спецпоследовательностей) в теле функции (см. Подраздел 4.1.2.1).
38.5.1. Аргументы SQL-функций
К аргументам SQL-функции можно обращаться в теле функции по именам или номерам. Ниже
приведены примеры обоих вариантов.
Чтобы использовать имя, объявите аргумент функции как именованный, а затем просто пишите
это имя в теле функции. Если имя аргумента совпадает с именем какого-либо столбца в текущей
SQL-команде внутри функции, имя столбца будет иметь приоритет. Чтобы всё же перекрыть имя
столбца, дополните имя аргумента именем самой функции, то есть запишите его в виде имя_функ-
ции.имя_аргумента. (Если и это имя будет конфликтовать с полным именем столбца, снова выиг-
рает имя столбца. Неоднозначности в этом случае вы можете избежать, выбрав другой псевдоним
для таблицы в SQL-команде.)
Старый подход с нумерацией позволяет обращаться к аргументам, применяя запись $n: $1 обозна-
чает первый аргумент, $2 — второй и т. д. Это будет работать и в том случае, если данному аргу-
менту назначено имя.
Если аргумент имеет составной тип, то для обращения к его атрибутам можно использовать за-
пись с точкой, например: аргумент.поле или $1.поле. И опять же, при этом может потребоваться
дополнить имя аргумента именем функции, чтобы сделать имя аргумента однозначным.
Аргументы SQL-функции могут использоваться только как значения данных, но не как идентифи-
каторы. Например, это приемлемо:
INSERT INTO mytable VALUES ($1);
а это не будет работать:
INSERT INTO $1 VALUES (42);
Примечание
Возможность обращаться к аргументам SQL-функций по именам появилась в
PostgreSQL 9.2. В функциях, которые должны работать со старыми серверами, необхо-
димо применять запись $n.
38.5.2. Функции SQL с базовыми типами
Простейшая возможная функция SQL не имеет аргументов и просто возвращает базовый тип, на-
пример integer:
CREATE FUNCTION one() RETURNS integer AS <script type="math/tex">SELECT 1 AS result;</script> LANGUAGE SQL;
– Альтернативная запись строковой константы:
CREATE FUNCTION one() RETURNS integer AS ‘
SELECT 1 AS result;
‘ LANGUAGE SQL;
SELECT one();
one
—–
1000Расширение SQL
1
Заметьте, что мы определили псевдоним столбца в теле функции для её результата (дали ему имя
result), но этот псевдоним не виден снаружи функции. Вследствие этого, столбец результата по-
лучил имя one, а не result.
Практически так же легко определяются функции SQL, которые принимают в аргументах базовые
типы:
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS <script type="math/tex">SELECT x + y;</script> LANGUAGE SQL;
SELECT add_em(1, 2) AS answer;
answer
——–
3
Мы также можем отказаться от имён аргументов и обращаться к ним по номерам:
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS <script type="math/tex">SELECT $1 + $2;</script> LANGUAGE SQL;
SELECT add_em(1, 2) AS answer;
answer
——–
3
Вот более полезная функция, которую можно использовать, чтобы дебетовать банковский счёт:
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS <script type="math/tex">UPDATE bank
SET balance = balance - debit
WHERE accountno = tf1.accountno;
SELECT 1;</script> LANGUAGE SQL;
Пользователь может выполнить эту функцию, чтобы дебетовать счёт 17 на 100 долларов, так:
SELECT tf1(17, 100.0);
В этом примере мы выбрали имя accountno для первого аргумента, но это же имя имеет столбец
в таблице bank. В команде UPDATE имя accountno относится к столбцу bank.accountno, так для
обращения к аргументу нужно записать tf1.accountno. Конечно, мы могли бы избежать этого,
выбрав другое имя для аргумента.
На практике обычно желательно получать от функции более полезный результат, чем константу
1, поэтому более реалистично такое определение:
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS <script type="math/tex">UPDATE bank
SET balance = balance - debit
WHERE accountno = tf1.accountno;
SELECT balance FROM bank WHERE accountno = tf1.accountno;</script> LANGUAGE SQL;
Эта функция изменяет баланс и возвращает полученное значение. То же самое можно сделать в
одной команде, применив RETURNING:
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS <script type="math/tex">1001Расширение SQL
UPDATE bank
SET balance = balance - debit
WHERE accountno = tf1.accountno
RETURNING balance;</script> LANGUAGE SQL;
Функция SQL должна возвращать в точности объявленный тип результата. Для этого может потре-
боваться добавить явное приведение. Например, предположим, что мы захотели изменить возвра-
щаемый тип в предыдущей функции на float8. Этот вариант не будет работать:
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS <script type="math/tex">SELECT $1 + $2;</script> LANGUAGE SQL;
несмотря на то, что в других контекстах PostgreSQL выполнил бы неявное приведение для преоб-
разования integer в float8. Правильный вариант выглядит так:
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS <script type="math/tex">SELECT ($1 + $2)::float8;</script> LANGUAGE SQL;
38.5.3. Функции SQL со сложными типами
В функциях с аргументами составных типов мы должны указывать не только, какой аргумент, но
и какой атрибут (поле) этого аргумента нам нужен. Например, предположим, что emp — таблица,
содержащая данные работников, и это же имя составного типа, представляющего каждую строку
таблицы. Следующая функция double_salary вычисляет, каким было бы чьё-либо жалование в
случае увеличения вдвое:
CREATE TABLE emp (
name
text,
salary
numeric,
age
integer,
cubicle
point
);
INSERT INTO emp VALUES (‘Bill’, 4200, 45, ‘(2,1)’);
CREATE FUNCTION double_salary(emp) RETURNS numeric AS <script type="math/tex">SELECT $1.salary * 2 AS salary;</script> LANGUAGE SQL;
SELECT name, double_salary(emp.<em>) AS dream
FROM emp
WHERE emp.cubicle ~= point ‘(2,1)’;
name | dream
——+——-
Bill | 8400
Обратите внимание на запись $1.salary позволяющую выбрать одно поле из значения строки ар-
гумента. Также заметьте, что в вызывающей команде SELECT указание имя_таблицы.</em> выбирает
всю текущую строку таблицы как составное значение. На строку таблицы можно сослаться и про-
сто по имени таблицы, например так:
SELECT name, double_salary(emp) AS dream
FROM emp
WHERE emp.cubicle ~= point ‘(2,1)’;
Однако это использование считается устаревшим, так как провоцирует путаницу. (Подробнее эти
две записи составных значений строки таблицы описаны в Подразделе 8.16.5.)
1002Расширение SQL
Иногда бывает удобно образовать составное значение аргумента на лету. Это позволяет сделать
конструкция ROW. Например, так можно изменить данные, передаваемые функции:
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
FROM emp;
Также возможно создать функцию, возвращающую составной тип. Например, эта функция возвра-
щает одну строку emp:
CREATE FUNCTION new_emp() RETURNS emp AS <script type="math/tex">SELECT text 'None' AS name,
1000.0 AS salary,
25 AS age,
point '(2,2)' AS cubicle;</script> LANGUAGE SQL;
В этом примере мы задали для каждого атрибута постоянное значение, но вместо этих констант
можно подставить любые вычисления.
Учтите два важных требования относительно определения функции:
• Порядок в списке выборки внутреннего запроса должен в точности совпадать с порядком сле-
дования столбцов в таблице, связанной с составным типом. (Имена столбцов, как показывает
пример выше, для системы значения не имеют.)
• Необходимо сделать так, чтобы каждое выражение имело тот же тип, что и соответствующий
столбец составного типа, при необходимости добавив приведение. В противном случае вы по-
лучите такие ошибки:
ERROR:
function declared to return emp returns varchar instead of text at column 1
(ОШИБКА: функция, объявленная как возвращающая emp, возвращает varchar вместо text в
столбце 1) Как и в случае с базовыми типами, автоматически никакие приведения в функцию
не добавляются.
Ту же функцию можно определить другим способом:
CREATE FUNCTION new_emp() RETURNS emp AS <script type="math/tex">SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;</script> LANGUAGE SQL;
Здесь мы записали SELECT, который возвращает один столбец нужного составного типа. В данной
ситуации этот вариант на самом деле не лучше, но в некоторых случаях он может быть удобной
альтернативой — например, если нам нужно вычислить результат, вызывая другую функцию, ко-
торая возвращает нужное составное значение. Этот вариант полезен и в случае, когда мы хотим
написать функцию, которая возвращает не обычный составной тип, а домен, определённый поверх
составного типа; тогда она в любом случае должна определяться как возвращающая единственный
столбец, так как никаким другим образом получить значение именно доменного типа нельзя.
Мы можем вызывать эту функцию напрямую, либо указав её в выражении значения:
SELECT new_emp();
new_emp
————————–
(None,1000.0,25,”(2,2)”)
либо обратившись к ней, как к табличной функции:
SELECT * FROM new_emp();
name | salary | age | cubicle
1003Расширение SQL
——+——–+—–+———
None | 1000.0 | 25 | (2,2)
Второй способ более подробно описан в Подразделе 38.5.7.
Когда используется функция, возвращающая составной тип, может возникнуть желание получить
из её результата только одно поле (атрибут). Это можно сделать, применяя такую запись:
SELECT (new_emp()).name;
name
——
None
Дополнительные скобки необходимы во избежание неоднозначности при разборе запроса. Если
вы попытаетесь выполнить запрос без них, вы получите ошибку:
SELECT new_emp().name;
ERROR: syntax error at or near “.”
LINE 1: SELECT new_emp().name;</p>
<p>(ОШИБКА: синтаксическая ошибка (примерное положение: “.”))
Функциональную запись также можно использовать и для извлечения атрибутов:
SELECT name(new_emp());
name
——
None
Как рассказывалось в Подразделе 8.16.5, запись с указанием поля и функциональная запись явля-
ются равнозначными.
Ещё один вариант использования функции, возвращающей составной тип, заключается в передаче
её результата другой функции, которая принимает этот тип строки на вход:
CREATE FUNCTION getname(emp) RETURNS text AS <script type="math/tex">SELECT $1.name;</script> LANGUAGE SQL;
SELECT getname(new_emp());
getname
———
None
(1 row)
38.5.4. Функции SQL с выходными параметрами
Альтернативный способ описать результаты функции — определить её с выходными параметрами,
как в этом примере:
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS ‘SELECT x + y’
LANGUAGE SQL;
SELECT add_em(3,7);
add_em
——–
10
(1 row)
1004Расширение SQL
Это по сути не отличается от версии add_em, показанной в Подразделе  38.5.2. Действительная
ценность выходных параметров в том, что они позволяют удобным способом определить функции,
возвращающие несколько столбцов. Например:
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS ‘SELECT x + y, x * y’
LANGUAGE SQL;
SELECT * FROM sum_n_product(11,42);
sum | product
—–+———
53 |
462
(1 row)
Фактически здесь мы определили анонимный составной тип для результата функции. Показанный
выше пример даёт тот же конечный результат, что и команды:
CREATE TYPE sum_prod AS (sum int, product int);
CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS ‘SELECT $1 + $2, $1 * $2’
LANGUAGE SQL;
Но предыдущий вариант зачастую удобнее, так как он не требует отдельно заниматься определе-
нием составного типа. Заметьте, что имена, назначаемые выходным параметрам, не просто деко-
ративные, а определяют имена столбцов анонимного составного типа. (Если вы опустите имя вы-
ходного параметра, система выберет имя сама.)
Заметьте, что выходные параметры не включаются в список аргументов при вызове такой функции
из SQL. Это объясняется тем, что PostgreSQL определяет сигнатуру вызова функции, рассматривая
только входные параметры. Это также значит, что при таких операциях, как удаление функции, в
ссылках на функцию учитываются только типы входных параметров. Таким образом, удалить эту
конкретную функцию можно любой из этих команд:
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
Параметры функции могут быть объявлены как IN (по умолчанию), OUT, INOUT или VARIADIC. Пара-
метр INOUT действует как входной (является частью списка аргументов при вызове) и как выход-
ной (часть типа записи результата). Параметры VARIADIC являются входными, но обрабатывается
специальным образом, как описано далее.
38.5.5. Функции SQL с переменным числом аргументов
Функции SQL могут быть объявлены как принимающие переменное число аргументов, с условием,
что все «необязательные» аргументы имеют один тип данных. Необязательные аргументы будут
переданы такой функции в виде массива. Для этого в объявлении функции последний параметр
помечается как VARIADIC; при этом он должен иметь тип массива. Например:
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS <script type="math/tex">SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);</script> LANGUAGE SQL;
SELECT mleast(10, -1, 5, 4.4);
mleast
——–
-1
(1 row)
По сути, все фактические аргументы, начиная с позиции VARIADIC, собираются в одномерный мас-
сив, как если бы вы написали
1005Расширение SQL
SELECT mleast(ARRAY[10, -1, 5, 4.4]);
– это не будет работать
На самом деле так вызвать эту функцию нельзя, или, по крайней мере, это не будет соответствовать
определению функции. Параметру VARIADIC соответствуют одно или несколько вхождений типа
его элемента, но не его собственного типа.
Но иногда бывает полезно передать функции с переменными параметрами уже подготовленный
массив; особенно когда одна функция с переменными параметрами хочет передавать свой массив
параметров другой. Также это более безопасный способ вызывать такую функцию, существующую
в схеме, где могут создавать объекты недоверенные пользователи; см. Раздел  10.3. Это можно
сделать, добавив VARIADIC в вызов:
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
Это предотвращает разворачивание переменного множества параметров функции в базовый тип,
что позволяет сопоставить с ним значение типа массива. VARIADIC можно добавить только к по-
следнему фактическому аргументу вызова функции.
Также указание VARIADIC даёт единственную возможность передать пустой массив функции с пе-
ременными параметрами, например, так:
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
Простой вызов SELECT mleast() не будет работать, так как переменным параметрам должен соот-
ветствовать минимум один фактический аргумент. (Можно определить вторую функцию с таким
же именем mleast, но без параметров, если вы хотите выполнять такие вызовы.)
Элементы массива, создаваемые из переменных параметров, считаются не имеющими собствен-
ных имён. Это означает, что передать функции с переменными параметрами именованные аргу-
менты нельзя (см. Раздел 4.3), если только при вызове не добавлено VARIADIC. Например, этот ва-
риант будет работать:
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
А эти варианты нет:
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
38.5.6. Функции SQL со значениями аргументов по умолчанию
Функции могут быть объявлены со значениями по умолчанию для некоторых или всех входных
аргументов. Значения по умолчанию подставляются, когда функция вызывается с недостаточным
количеством фактических аргументов. Так как аргументы можно опускать только с конца спис-
ка фактических аргументов, все параметры после параметра со значением по умолчанию также
получат значения по умолчанию. (Хотя запись с именованными аргументами могла бы ослабить
это ограничение, оно всё же остаётся в силе, чтобы позиционные ссылки на аргументы остава-
лись действительными.) Независимо от того, используете вы эту возможность или нет, она требует
осторожности при вызове функций в базах данных, где одни пользователи не доверяют другим;
см. Раздел 10.3.
Например:
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS <script type="math/tex">SELECT $1 + $2 + $3;</script>;
SELECT foo(10, 20, 30);
1006Расширение SQL
foo
—–
60
(1 row)
SELECT foo(10, 20);
foo
—–
33
(1 row)
SELECT foo(10);
foo
—–
15
(1 row)
SELECT foo(); – не работает из-за отсутствия значения по умолчанию для первого
аргумента
ERROR: function foo() does not exist
(ОШИБКА: функция foo() не существует) Вместо ключевого слова DEFAULT можно использовать
знак =.
38.5.7. Функции SQL, порождающие таблицы
Все функции SQL можно использовать в предложении FROM запросов, но наиболее полезно это для
функций, возвращающих составные типы. Если функция объявлена как возвращающая базовый
тип, она возвращает таблицу с одним столбцом. Если же функция объявлена как возвращающая
составной тип, она возвращает таблицу со столбцами для каждого атрибута составного типа.
Например:
CREATE
INSERT
INSERT
INSERT
TABLE foo (fooid int, foosubid int, fooname text);
INTO foo VALUES (1, 1, ‘Joe’);
INTO foo VALUES (1, 2, ‘Ed’);
INTO foo VALUES (2, 1, ‘Mary’);
CREATE FUNCTION getfoo(int) RETURNS foo AS <script type="math/tex">SELECT * FROM foo WHERE fooid = $1;</script> LANGUAGE SQL;
SELECT *, upper(fooname) FROM getfoo(1) AS t1;
fooid | foosubid | fooname | upper
——-+———-+———+——-
1 |
1 | Joe
| JOE
(1 row)
Как показывает этот пример, мы можем работать со столбцами результата функции так же, как
если бы это были столбцы обычной таблицы.
Заметьте, что мы получаем из данной функции только одну строку. Это объясняется тем, что мы
не использовали указание SETOF. Оно описывается в следующем разделе.
38.5.8. Функции SQL, возвращающие множества
Когда SQL-функция объявляется как возвращающая SETOF некий_тип, конечный запрос функции
выполняется до завершения и каждая строка выводится как элемент результирующего множества.
1007Расширение SQL
Это обычно используется, когда функция вызывается в предложении FROM. В этом случае каждая
строка, возвращаемая функцией, становится строкой таблицы, появляющейся в запросе. Напри-
мер, в предположении, что таблица foo имеет то же содержимое, что и раньше, мы выполняем:
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS <script type="math/tex">SELECT * FROM foo WHERE fooid = $1;</script> LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
Тогда в ответ мы получим:
fooid | foosubid | fooname
——-+———-+———
1 |
1 | Joe
1 |
2 | Ed
(2 rows)
Также возможно выдать несколько строк со столбцами, определяемыми выходными параметрами,
следующим образом:
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);
CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS <script type="math/tex">SELECT $1 + tab.y, $1 * tab.y FROM tab;</script> LANGUAGE SQL;
SELECT * FROM sum_n_product_with_tab(10);
sum | product
—–+———
11 |
10
13 |
30
15 |
50
17 |
70
(4 rows)
Здесь ключевая особенность заключается в записи RETURNS SETOF record, показывающей, что
функция возвращает множество строк вместо одной. Если существует только один выходной пара-
метр, укажите тип этого параметра вместо record.
Часто бывает полезно сконструировать результат запроса, вызывая функцию, возвращающую мно-
жество, несколько раз, передавая при каждом вызове параметры из очередных строк таблицы или
подзапроса. Для этого рекомендуется применить ключевое слово LATERAL, описываемое в Подраз-
деле 7.2.1.5. Ниже приведён пример использования функции, возвращающей множество, для пе-
речисления элементов древовидной структуры:
SELECT * FROM nodes;
name
| parent
———–+——–
Top
|
Child1
| Top
Child2
| Top
Child3
| Top
SubChild1 | Child1
SubChild2 | Child1
(6 rows)
CREATE FUNCTION listchildren(text) RETURNS SETOF text AS <script type="math/tex">1008Расширение SQL
SELECT name FROM nodes WHERE parent = $1</script> LANGUAGE SQL STABLE;
SELECT * FROM listchildren(‘Top’);
listchildren
————–
Child1
Child2
Child3
(3 rows)
SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
name |
child
——–+———–
Top
| Child1
Top
| Child2
Top
| Child3
Child1 | SubChild1
Child1 | SubChild2
(5 rows)
В этом примере не делается ничего такого, что мы не могли бы сделать, применив простое соеди-
нение, но для более сложных вычислений возможность поместить некоторую логику в функцию
может быть весьма удобной.
Функции, возвращающие множества, могут также вызываться в списке выборки запроса. Для каж-
дой строки, которая генерируется самим запросом, вызывается функция, возвращающая множе-
ство, и для каждого элемента набора её результатов генерируется отдельная строка. Предыдущий
пример можно было бы также переписать с применением запросов следующим образом:
SELECT listchildren(‘Top’);
listchildren
————–
Child1
Child2
Child3
(3 rows)
SELECT name, listchildren(name) FROM nodes;
name | listchildren
——–+————–
Top
| Child1
Top
| Child2
Top
| Child3
Child1 | SubChild1
Child1 | SubChild2
(5 rows)
Заметьте, что в последней команде SELECT для Child2, Child3 и т. д. строки не выдаются. Это
происходит потому, что listchildren возвращает пустое множество для этих аргументов, так что
строки результата не генерируются. Это же поведение мы получаем при внутреннем соединении
с результатом функции с применением LATERAL.
Поведение PostgreSQL с функциями, возвращающими множества, в списке выборки запроса прак-
тически не отличается от поведения с такими функциями, помещёнными в предложение LATERAL
FROM. Например, запрос:
SELECT x, generate_series(1,5) AS g FROM tab;
почти равнозначен
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
1009Расширение SQL
Он мог быть полностью идентичным, но в данном конкретном примере планировщик может ре-
шить перенести g во внешнюю сторону соединения, так как g не имеет фактической зависимости
по времени вычисления от tab. Такое решение привело бы к изменению порядка строк. Функции,
возвращающие множества, в списке выборки всегда вычисляются так, как они вычислялись бы
внутри соединения с вложенным циклом с остальным предложением FROM, так что эти функции
выполняются до завершения прежде чем начинается рассмотрение следующей строки из предло-
жения FROM.
Если в списке выборки запроса используются несколько функций, возвращающих запросы, они
вычисляются примерно так же, как если бы они были помещены в один элемент LATERAL ROWS
FROM( … ) предложения FROM. Для каждой строки из нижележащего запроса выдаётся строка
с первым результатом каждой функции, а затем строка со вторым результатом и так далее. Если
какие-либо из функций, возвращающих множества, выдают меньше результатов, чем другие, то
вместо недостающих данных подставляются значения NULL, так что общее число строк, выдава-
емых для одной нижележащей строки, равно числу строк, которое выдаёт функция с наибольшим
количеством строк в возвращаемом множестве. Таким образом, функции, возвращающие множе-
ства, выполняются совместно, пока все их множества не будут исчерпаны, а затем выполнение
продолжается со следующей нижележащей строкой.
Функции, возвращающие множества, могут быть вложенными в списке выборки, но это не допус-
кается в элементах предложения FROM. В таких случаях каждый уровень вложенности обрабаты-
вается отдельно, как если бы это был отдельный элемент LATERAL ROWS FROM( … ). Например, в
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
возвращающие множества функции srf2, srf3 и srf5 будут выполняться совместно для каждой
строки tab, а затем srf1 и srf4 будут совместно применяться к каждой строке, произведённой
нижними функциями.
Функции, возвращающие множества, нельзя использовать в конструкциях, вычисляемых по усло-
вию, например, CASE или COALESCE. Например, рассмотрите запрос
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
Может показаться, что он должен выдать пять экземпляров входных строк, в которых x &gt; 0, и по
одному экземпляру остальных строк; но на деле, так как generate_series(1, 5) будет выполнять-
ся в неявном элементе LATERAL FROM до того, как выражение CASE вообще будет рассматриваться,
должно было бы выдаваться пять экземпляров абсолютно всех выходных строк. Во избежание пу-
таницы в таких случаях выдаётся ошибка при разборе запроса.
Примечание
Если последняя команда функции — INSERT, UPDATE или DELETE с RETURNING, эта ко-
манда будет всегда выполняться до завершения, даже если функция не объявлена с
указанием SETOF или вызывающий запрос не выбирает все строки результата. Все до-
полнительные строки, выданные предложением RETURNING, просто игнорируются, но
соответствующие изменения в таблице всё равно произойдут (и будут завершены до
выхода из функции).
Примечание
В PostgreSQL до версии 10 при помещении нескольких функций, возвращающих мно-
жества, в один список выборки поведение было не очень разумным, если они возвра-
щали не одинаковое число строк. В таких случаях число выходных строк равнялось
наименьшему общему множителю количеств строк, возвращаемых этими функциями.
Также и вложенные функции, возвращающие множества, работали не так, как описа-
но выше; у такой функции мог быть максимум один аргумент, возвращающий множе-
1010Расширение SQL
ство, и каждая вложенность вычислялась независимо. Кроме того, ранее допускалось
и условное выполнение (вычисление таких функций внутри CASE и т. п.), что ещё боль-
ше всё усложняло. При написании запросов, которые должны работать и со старыми
версиями PostgreSQL, рекомендуется использовать синтаксис LATERAL, так как это га-
рантирует одинаковый результат с разными версиями. Если в вашем запросе использу-
ется условное вычисление функции, возвращающей множество, его можно исправить,
переместив проверку условия в специально созданную функцию, возвращающую мно-
жество. Например:
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
можно заменить на
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
RETURNS SETOF int AS <script type="math/tex">BEGIN
IF cond THEN
RETURN QUERY SELECT generate_series(start, fin);
ELSE
RETURN QUERY SELECT els;
END IF;
END</script> LANGUAGE plpgsql;
SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
Это будет работать одинаково во всех версиях PostgreSQL.
38.5.9. Функции SQL, возвращающие таблицы (TABLE)
Есть ещё один способ объявить функцию, возвращающую множества, — использовать синтаксис
RETURNS TABLE(столбцы). Это равнозначно использованию одного или нескольких параметров OUT
с объявлением функции как возвращающей SETOF record (или SETOF тип единственного параметра,
если это применимо). Этот синтаксис описан в последних версиях стандарта SQL, так что этот
вариант может быть более портируемым, чем SETOF.
Например, предыдущий пример с суммой и произведением можно также переписать так:
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS <script type="math/tex">SELECT $1 + tab.y, $1 * tab.y FROM tab;</script> LANGUAGE SQL;
Запись RETURNS TABLE не позволяет явно указывать OUT и INOUT для параметров — все выходные
столбцы необходимо записать в списке TABLE.
38.5.10. Полиморфные функции SQL
Функции SQL могут быть объявлены как принимающие и возвращающие полиморфные типы
anyelement, anyarray, anynonarray, anyenum и anyrange. За более подробным объяснением поли-
морфизма функций обратитесь к Подразделу 38.2.5. В следующем примере полиморфная функция
make_array создаёт массив из двух элементов произвольных типов:
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS <script type="math/tex">SELECT ARRAY[$1, $2];</script> LANGUAGE SQL;
SELECT make_array(1, 2) AS intarray, make_array(‘a’::text, ‘b’) AS textarray;
intarray | textarray
———-+———–
{1,2}
| {a,b}
1011Расширение SQL
(1 row)
Обратите внимание на приведение типа ‘a’::text, определяющее, что аргумент имеет тип text.
Оно необходимо, если аргумент задаётся просто строковой константой, так как иначе он будет
воспринят как имеющий тип unknown, а массив типов unknown является недопустимым. Без этого
приведения вы получите такую ошибку:
ERROR:
could not determine polymorphic type because input has type “unknown”
(ОШИБКА: не удалось определить полиморфный тип, так как входные аргументы имеют тип
“unknown”)
Функция с полиморфными аргументами может иметь фиксированный тип результата, однако об-
ратное не допускается. Например:
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS <script type="math/tex">SELECT $1 > $2;</script> LANGUAGE SQL;
SELECT is_greater(1, 2);
is_greater
————
f
(1 row)
CREATE FUNCTION invalid_func() RETURNS anyelement AS <script type="math/tex">SELECT 1;</script> LANGUAGE SQL;
ERROR: cannot determine result data type
DETAIL: A function returning a polymorphic type must have at least one polymorphic
argument.
(ОШИБКА: не удалось определить тип результата; ПОДРОБНОСТИ: Функция, возвращающая по-
лиморфный тип, должна иметь минимум один полиморфный аргумент.)
Полиморфизм можно применять и с функциями, имеющими выходные аргументы. Например:
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS ‘select $1, array[$1,$1]’ LANGUAGE SQL;
SELECT * FROM dup(22);
f2 |
f3
—-+———
22 | {22,22}
(1 row)
Полиморфизм также можно применять с функциями с переменными параметрами. Например:
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS <script type="math/tex">SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);</script> LANGUAGE SQL;
SELECT anyleast(10, -1, 5, 4);
anyleast
———-
-1
(1 row)
SELECT anyleast(‘abc’::text, ‘def’);
1012Расширение SQL
anyleast
———-
abc
(1 row)
CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS <script type="math/tex">SELECT array_to_string($2, $1);</script> LANGUAGE SQL;
SELECT concat_values(‘|’, 1, 4, 2);
concat_values
—————
1|4|2
(1 row)
38.5.11. Функции SQL с правилами сортировки
Когда функция SQL принимает один или несколько параметров сортируемых типов данных, пра-
вило сортировки определяется при каждом вызове функции, в зависимости от правил сортировки,
связанных с фактическими аргументами, как описано в Разделе 23.2. Если правило сортировки
определено успешно (то есть не возникло конфликтов между неявно установленными правилами
сортировки аргументов), оно неявно назначается для всех сортируемых параметров. Выбранное
правило будет определять поведение операций, связанных с сортировкой, в данной функции. На-
пример, для показанной выше функции anyleast, результат
SELECT anyleast(‘abc’::text, ‘ABC’);
будет зависеть от правила сортировки по умолчанию, заданного в базе данных. С локалью C ре-
зультатом будет строка ABC, но со многими другими локалями это будет abc. Нужное правило сор-
тировки можно установить принудительно, добавив предложение COLLATE к одному из аргументов
функции, например:
SELECT anyleast(‘abc’::text, ‘ABC’ COLLATE “C”);
С другой стороны, если вы хотите, чтобы функция работала с определённым правилом сортировки,
вне зависимости от того, с каким она была вызвана, вставьте предложения COLLATE где требуется
в определении функции. Эта версия anyleast всегда будет сравнивать строки по правилам локали
en_US:
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS <script type="math/tex">SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);</script> LANGUAGE SQL;
Но заметьте, что при попытке применить правило к несортируемому типу данных, возникнет ошиб-
ка.
Если для фактических аргументов не удаётся определить общее правило сортировки, функция SQL
считает, что им назначено правило сортировки по умолчанию для их типа данных (обычно это
то же правило сортировки, что определено по умолчанию для базы данных, но оно может быть и
другим для параметров доменных типов).
Поведение сортируемых параметров можно воспринимать как ограниченную форму полиморфиз-
ма, применимую только к текстовым типам данных.
38.6. Перегрузка функций
Вы можете определить несколько функций с одним именем SQL, если эти функции будут прини-
мать разные аргументы. Другими словами, имена функций можно перегружать. Независимо от
того, используете вы эту возможность или нет, она требует предосторожности при вызове функций
в базах данных, где одни пользователи не доверяют другим; см. Раздел 10.3. Когда выполняется
запрос, сервер определяет, какую именно функцию вызывать, по количеству и типам представлен-
1013Расширение SQL
ных аргументов. Перегрузка может быть полезна для имитации функций с переменным количе-
ством аргументов, до какого-то конечного числа.
Создавая семейство перегруженных функций, необходимо не допускать неоднозначности. Напри-
мер, если созданы функции:
CREATE FUNCTION test(int, real) RETURNS …
CREATE FUNCTION test(smallint, double precision) RETURNS …
не вполне понятно, какая функция будет вызвана с довольно простыми аргументами вроде test(1,
1.5). Реализованные в данный момент правила разрешения типов описаны в Главе 10, но разра-
батывать систему, которая будет незаметно полагаться на такие особенности, неразумно.
Функции, принимающей один аргумент составного типа, обычно не следует давать имя, совпада-
ющее с именем какого-либо атрибута (поля) этого типа. Вспомните, что запись атрибут(табли-
ца) считается равнозначной таблица.атрибут. В случае, когда возникает неоднозначность между
функцией, принимающей составной тип, и атрибутом составного типа, всегда будет выбираться
атрибут. Этот выбор можно переопределить, дополнив имя функции схемой (то есть, записав схе-
ма.функция(таблица) ), но лучше избежать этой проблемы, подобрав разные имена.
Другой тип конфликта возможен между обычными функциями и функциями с переменными па-
раметрами. Например, можно создать функции foo(numeric) и foo(VARIADIC numeric[]). В этом
случае будет непонятно, какая функция должна выбираться при передаче одного числового аргу-
мента, например foo(10.1). При разрешении этого конфликта предпочтение отдаётся функции,
найденной первой по пути поиска, либо, если две функции находятся в одной схеме, выбирается
функция с постоянными аргументами.
При перегрузке функций на языке C есть дополнительное ограничение: имя уровня C каждой
функции в семействе перегруженных функций должно отличаться от имён уровня C всех других
функций, как внутренних, так и загружаемых динамически. Если это правило нарушается, пове-
дение зависит от среды. Вы можете получить ошибку компоновщика во время выполнения, либо
будет вызвана не та функция (обычно внутренняя). Альтернативная форма предложения AS для
SQL-команды CREATE FUNCTION позволяет отвязать имя SQL-функции от имени, определённого в
исходном коде на C. Например:
CREATE FUNCTION test(int) RETURNS int
AS ‘имя_файла’, ‘test_1arg’
LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
AS ‘имя_файла’, ‘test_2arg’
LANGUAGE C;
Имена функций на C здесь следуют одному из множества возможных соглашений.
38.7. Категории изменчивости функций
Для каждой функции определяется характеристика изменчивости, с возможными вариантами:
VOLATILE, STABLE и IMMUTABLE. Если эта характеристика не задаётся явно в команде CREATE
FUNCTION, по умолчанию подразумевается VOLATILE. Категория изменчивости представляет со-
бой обещание некоторого поведения функции для оптимизатора:
• Изменчивая функция (VOLATILE) может делать всё, что угодно, в том числе, модифицировать
базу данных. Она может возвращать различные результаты при нескольких вызовах с оди-
наковыми аргументами. Оптимизатор не делает никаких предположений о поведении таких
функций. В запросе, использующем изменчивую функцию, она будет вычисляться заново для
каждой строки, когда потребуется её результат.
• Стабильная функция (STABLE) не может модифицировать базу данных и гарантированно воз-
вращает одинаковый результат, получая одинаковые аргументы, для всех строк в одном опе-
раторе. Эта характеристика позволяет оптимизатору заменить множество вызовов этой функ-
ции одним. В частности, выражение, содержащее такую функцию, можно безопасно исполь-
1014Расширение SQL
зовать в условии поиска по индексу. (Так как при поиске по индексу целевое значение вычис-
ляется только один раз, а не для каждой строки, использовать функцию с характеристикой
VOLATILE в условии поиска по индексу нельзя.)
• Постоянная функция (IMMUTABLE) не может модифицировать базу данных и гарантированно
всегда возвращает одинаковые результаты для одних и тех же аргументов. Эта характеристи-
ка позволяет оптимизатору предварительно вычислить функцию, когда она вызывается в за-
просе с постоянными аргументами. Например, запрос вида SELECT … WHERE x = 2 + 2 мож-
но упростить до SELECT … WHERE x = 4, так как нижележащая функция оператора сложе-
ния помечена как IMMUTABLE.
Для наилучших результатов оптимизации, функции следует назначать самую строгую характери-
стику изменчивости, которой она соответствует.
Любая функция с побочными эффектами должна быть помечена как VOLATILE, чтобы обращения к
ней не исключались при оптимизации. Даже если функция не имеет побочных эффектов, её нужно
пометить как VOLATILE, если её значение может меняться при выполнении одного запроса; таковы
функции random(), currval() и timeofday().
Другой важный пример представляет семейство функций current_timestamp, которые имеют ха-
рактеристику STABLE, потому что их значения не меняются в рамках одной транзакции.
Характеристики STABLE и IMMUTABLE мало различаются, когда речь идёт о простых интерактивных
запросах, которые планируются и сразу же выполняются; не имеет большого значения, будет ли
функция выполнена однократно на этапе планирования или в начале выполнения. Существенное
различие проявляется, когда план сохраняется и многократно используется позже. Если функция
помечена как IMMUTABLE, тогда как на самом деле она не является постоянной, она может быть
сведена к константе во время планирования, так что при последующих выполнениях плана вместо
неё будет использоваться неактуальное значение. Это опасно при использовании подготовленных
операторов или языков функций, кеширующих планы (например, PL/pgSQL).
У функций, написанных на SQL или на любом другом стандартном процедурном языке, есть ещё
одно важное свойство, определяемое характеристикой изменчивости, а именно видимость изме-
нений, произведённых командой SQL, которая вызывает эту функцию. Функция VOLATILE будет
видеть такие изменения, тогда как STABLE и IMMUTABLE — нет. Это поведение реализуется посред-
ством снимков в MVCC (см. Главу 13): STABLE и IMMUTABLE используют снимок, полученный в нача-
ле вызывающего запроса, тогда как функции VOLATILE получают свежий снимок в начале каждого
запроса, который они выполняют.
Примечание
Функции, написанные на C, могут работать со снимками как угодно, но обычно лучше
сделать так, чтобы они действовали аналогично.
Вследствие такой организации работы со снимками, функцию, содержащую только команды
SELECT, можно безопасно пометить как STABLE, даже если она выбирает данные из таблиц, которые
могут быть изменены параллельными запросами. PostgreSQL выполнит все команды в функции
STABLE со снимком, полученным для вызывающего запроса, так что они будут видеть одно пред-
ставление базы данных на протяжении всего запроса.
То же самое поведение со снимками распространяется на команды SELECT в функциях IMMUTABLE.
Вообще в функциях IMMUTABLE обычно неразумно выбирать данные из таблиц, так как «постоян-
ство» функции будет нарушено, если содержимое таблиц изменится. Однако PostgreSQL не при-
нуждает вас явно отказаться от этого.
Одна из распространённых ошибок — помечать функцию как IMMUTABLE, при том, что её резуль-
таты зависят от параметра конфигурации. Например, функция, работающая с временем, может
1015Расширение SQL
выдавать результаты, зависящие от параметра TimeZone. Для надёжности такие функции следует
помечать как STABLE.
Примечание
PostgreSQL требует, чтобы функции STABLE и IMMUTABLE не содержали SQL-команд, кро-
ме SELECT, для предотвращения модификации данных. (Это не совсем непробиваемое
ограничение, так как эти функции всё же могут вызывать функции VOLATILE, способ-
ные модифицировать базу данных. Если вы реализуете такую схему, вы увидите, что
функция STABLE и IMMUTABLE не замечает изменений в базе данных, произведённых вы-
званной функцией, так как они не проявляются в её снимке данных.)
38.8. Функции на процедурных языках
PostgreSQL позволяет разрабатывать собственные функции и на языках, отличных от SQL и C.
Эти другие языки в целом обычно называются процедурными языками (PL, Procedural Languages).
Процедурные языки не встроены в сервер PostgreSQL; они предлагаются загружаемыми модулями.
За дополнительной информацией обратитесь к Главе 42 и следующим главам.
38.9. Внутренние функции
Внутренние функции — это функции, написанные на языке C, и статически скомпонованные в
исполняемый код сервера PostgreSQL. В «теле» определения функции задаётся имя функции на
уровне C, которое не обязательно должно совпадать с именем, объявленным для использования в
SQL. (Обратной совместимости ради, тело функции может быть пустым, что будет означать, что
имя функции на уровне C совпадает с именем в SQL.)
Обычно все внутренние функции, представленные на сервере, объявляются в ходе инициализации
кластера баз данных (см. Раздел 18.2), но пользователь может воспользоваться командой CREATE
FUNCTION и добавить дополнительные псевдонимы для внутренней функции. Внутренние функции
объявляются в CREATE FUNCTION с именем языка internal. Например, так можно создать псевдоним
для функции sqrt:
CREATE FUNCTION square_root(double precision) RETURNS double precision
AS ‘dsqrt’
LANGUAGE internal
STRICT;
(Большинство внутренних функций должны объявляться как «strict».)
Примечание
Не все «предопределённые» функции являются «внутренними» в вышеописанном
смысле. Некоторые предопределённые функции написаны на SQL.
38.10. Функции на языке C
Пользовательские функции могут быть написаны на C (или на языке, который может быть совме-
стим с C, например C++). Такие функции компилируются в динамически загружаемые объекты
(также называемые разделяемыми библиотеками) и загружаются сервером по требованию. Имен-
но метод динамической загрузки отличает функции «на языке C» от «внутренних» функций —
правила написания кода по сути одни и те же. (Собственно, поэтому стандартная библиотека внут-
ренних функций может быть богатым источником примеров для написания собственных функций
на языке C.)
1016Расширение SQL
В настоящее время для функций на C применяется только одно соглашение о вызовах
(«версии 1»). Поддержка этого соглашения обозначается объявлением функции с макросом
(PG_FUNCTION_INFO_V1), как показано ниже.
38.10.1. Динамическая загрузка
В первый раз, когда в сеансе вызывается пользовательская функция в определённом внешнем объ-
ектном файле, загрузчик динамических модулей загружает этот файл в память, чтобы можно бы-
ло вызвать эту функцию. Таким образом, в команде CREATE FUNCTION, объявляющей пользователь-
скую функцию на языке C, необходимо определить две сущности для функции: имя загружаемого
объектного файла и имя уровня C (символ для компоновки) заданной функции в этом объектном
файле. Если имя уровня C не указано явно, предполагается, что оно совпадает с именем функции
в SQL.
Для нахождения разделяемого объектного файла по имени, заданному в команде CREATE FUNCTION,
применяется следующий алгоритм:</p>
<ol>
  <li>Если имя задаётся абсолютным путём, загружается заданный файл.</li>
  <li>Если имя начинается со строки $libdir, эта часть пути заменяется путём к каталогу библиотек
PostgreSQL, который определяется во время сборки.</li>
  <li>Если в имени не указывается каталог, поиск файла производится по пути, заданному конфигу-
рационной переменной dynamic_library_path.</li>
  <li>В противном случае (файл не был найден в пути поиска, или в его имени указывается не аб-
солютный путь к каталогу), загрузчик попытается принять имя как есть, что, скорее всего, не
увенчается успехом. (Полагаться на текущий рабочий каталог ненадёжно.)
Если эта последовательность не даёт положительный результат, к данному имени добавляется
принятое на данной платформе расширение файлов библиотек (часто .so) и последовательность
повторяется снова. Если и это не приводит к успеху, происходит сбой загрузки.
Для поиска разделяемых библиотек рекомендуется задавать либо путь относительно $libdir, ли-
бо путь динамических библиотек. Это упрощает обновление версии при перемещении новой ин-
сталляции в другое место. Какой именно каталог подразумевается под $libdir, можно узнать с
помощью команды pg_config –pkglibdir.
Пользователь, от имени которого работает сервер PostgreSQL, должен иметь возможность пройти
путь к файлу, который требуется загрузить. Очень распространённая ошибка — когда сам файл
или каталог верхнего уровня оказывается недоступным для чтения и/или исполнения для пользо-
вателя postgres.
В любом случае, имя файла, заданное в команде CREATE FUNCTION, записывается в системные ка-
талоги буквально, так что если этот файл потребуется загрузить ещё раз, та же процедура будет
проделана снова.
Примечание
PostgreSQL не будет компилировать функцию на C автоматически, поэтому прежде чем
ссылаться на объектный файл в команде CREATE FUNCTION, его нужно скомпилировать.
За дополнительными сведениями обратитесь к Подразделу 38.10.5.
Чтобы гарантировать, что динамически загружаемый объектный файл не будет загружен несовме-
стимым сервером, PostgreSQL проверяет, содержит ли этот файл «отличительный блок» с требу-
емым содержимым. Благодаря этому сервер может выявить очевидную несовместимость, напри-
мер, когда код скомпилирован для другой старшей версии PostgreSQL. Чтобы включить его в свой
модуль, напишите это в одном (и только одном) из исходных файлов модуля, после включения за-
головочного файла fmgr.h:
1017Расширение SQL
PG_MODULE_MAGIC;
После того как он был использован первый раз, динамически загружаемый объектный файл со-
храняется в памяти. Следующие обращения в том же сеансе к функциям в этом файле повлекут
только небольшие издержки, связанные с поиском в таблице символов. Если вам нужно принуди-
тельно перезагрузить объектный файл, например, после перекомпиляции, начните новый сеанс.
Динамически загружаемый файл может дополнительно содержать функции инициализации и за-
вершения работы библиотеки. Если в файле находится функция с именем _PG_init, эта функция
будет вызвана сразу после загрузки файла. Эта функция не принимает параметры и не должна
ничего возвращать. Если в файле находится функция _PG_fini, эта функция будет вызвана непо-
средственно перед выгрузкой файла. Эта функция так же не принимает параметры и не должна
ничего возвращать. Заметьте, что _PG_fini будет вызываться только при выгрузке файла, но не
при завершении процесса. (В настоящее время выгрузка отключена и не происходит никогда, но
в будущем это может измениться.)
38.10.2. Базовые типы в функциях на языке C
Чтобы понимать, как написать функцию на языке C, вы должны знать, как внутри PostgreSQL пред-
ставляются базовые типы данных и как их могут принимать и передавать функции. PostgreSQL
внутри воспринимает базовые типы как «блоки памяти». Пользовательские функции, устанавли-
ваемые для типов, в свою очередь, определяют, как PostgreSQL может работать с этими типами.
То есть, PostgreSQL только сохраняет и загружает данные с диска, а для ввода, обработки и вывода
данных он использует определяемые вами функции.
Базовые типы могут иметь один из трёх внутренних форматов:
• передаётся по значению, фиксированной длины
• передаётся по ссылке, фиксированной длины
• передаётся по ссылке, переменной длины
Типы, передаваемые по значению, могут иметь размер только 1, 2 или 4 байта (и 8 байт, если
sizeof(Datum) равен 8 на вашей машине). Определяя собственные типы, следует позаботиться о
том, чтобы они имели одинаковый размер (в байтах) во всех архитектурах. Например, тип long
опасен, так как он имеет размер 4 байта на одних машинах, и 8 байт на других, тогда как тип
int состоит из 4 байт в большинстве систем Unix. Поэтому разумной реализацией типа int4 на
платформе Unix может быть такая:
/* 4-байтное целое, передаётся по значению <em>/
typedef int int4;
(В коде собственно PostgreSQL этот тип называется int32, так как в C принято соглашение, что
intXX подразумевает XX бит. Заметьте, что вследствие этого тип int8 в C имеет размер 1 байт.
Тип int8, принятый в SQL, в C называется int64. См. также Таблицу 38.1.)
С другой стороны, типы фиксированной длины любого размера можно передавать по ссылке. На-
пример, взгляните на пример реализации типа PostgreSQL:
/</em> 16-байтная структура, передаётся по ссылке <em>/
typedef struct
{
double x, y;
} Point;
В функции PostgreSQL и из них могут передаваться только указатели на такие типы. Чтобы вернуть
значение такого типа, выделите для него нужное количество памяти функцией palloc, заполните
выделенную память и верните указатель на неё. (Если вы захотите просто вернуть то же значение,
что было получено во входном аргументе этого же типа данных, вы можете пропустить дополни-
тельный вызов palloc и просто вернуть указатель на это поступившее значение.)
1018Расширение SQL
Наконец, все типы переменной длины также должны передаваться по ссылке. Все типы перемен-
ной длины должны начинаться с обязательного поля длины размером ровно 4 байта, которая бу-
дет задаваться макросом SET_VARSIZE; никогда не устанавливайте это поле вручную! Все данные,
которые будут храниться в этом типе, должны размещаться в памяти непосредственно за этим
полем длины. Поле длины содержит полную длину структуры, то есть включает размер самого
поля длины.
Ещё один важный момент — старайтесь не оставлять неинициализированных байт в значениях
данных; например, обнуляйте все возможные байты выравнивания, которые могут присутствовать
в структурах. Если этого не делать, логически равные значения ваших данных могут представ-
ляться неравными планировщику, что приведёт к построению неэффективных (хотя и корректных)
планов.
Предупреждение
Никогда не изменяйте содержимое, передаваемое на вход по ссылке. Если вы сделаете
это, вы скорее всего испортите данные на диске, так как полученный вами указатель
указывает непосредственно на место в дисковом буфере. Единственное исключение из
этого правила освещается в Разделе 38.11.
В качестве примера мы можем определить тип text так:
typedef struct {
int32 length;
char data[FLEXIBLE_ARRAY_MEMBER];
} text;
Запись [FLEXIBLE_ARRAY_MEMBER] означает, что действительная длина массива данных в этом объ-
явлении не указывается.
Работая с типами переменной длины, мы должны аккуратно выделить нужный объём памяти и
записать его размер в поле длины. Например, если нужно сохранить 40 байт в структуре text,
можно применить такой код:
#include “postgres.h”
…
char buffer[40]; /</em> our source data <em>/
…
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination-&gt;data, buffer, 40);
…
VARHDRSZ совпадает с sizeof(int32), но для получения размера заголовка типа переменной длины
хорошим стилем считается применять макрос VARHDRSZ. Кроме того, поле длины должно устанав-
ливаться макросом SET_VARSIZE, а не простым присваиванием.
В Таблице 38.1 указано, какие типы языка C соответствуют типам SQL при написании функций
на C с использованием встроенных типов PostgreSQL. В столбце «Определён в» указывается, ка-
кой заголовочный файл необходимо подключить, чтобы получить определение типа. (Фактическое
определение может быть в другом файле, который подключается из указанного, однако рекомен-
дуется придерживаться обозначенного интерфейса.) Заметьте, что в любом исходном файле всегда
необходимо первым включать postgres.h, так как в нём объявляется ряд вещей, которые нужны
в любом случае.
Таблица 38.1. Типы C, эквивалентные встроенным типам SQL
Тип SQL Тип C Определён в
abstime AbsoluteTime utils/nabstime.h
1019Расширение SQL
Тип SQL Тип C Определён в
bigint (int8) int64 postgres.h
boolean bool postgres.h (может быть встро-
ен в компиляторе)
box BOX</em> utils/geo_decls.h
bytea bytea* postgres.h
“char” char (встроен в компиляторе)
character BpChar* postgres.h
cid CommandId postgres.h
date DateADT utils/date.h
smallint (int2) int16 postgres.h
int2vector int2vector* postgres.h
integer (int4) int32 postgres.h
real (float4) float4* postgres.h
double precision (float8) float8* postgres.h
interval Interval* datatype/timestamp.h
lseg LSEG* utils/geo_decls.h
name Name postgres.h
oid Oid postgres.h
oidvector oidvector* postgres.h
path PATH* utils/geo_decls.h
point POINT* utils/geo_decls.h
regproc regproc postgres.h
reltime RelativeTime utils/nabstime.h
text text* postgres.h
tid ItemPointer storage/itemptr.h
time TimeADT utils/date.h
time with time zone TimeTzADT utils/date.h
timestamp Timestamp* datatype/timestamp.h
tinterval TimeInterval utils/nabstime.h
varchar VarChar* postgres.h
xid TransactionId postgres.h
Теперь, когда мы рассмотрели все возможные структуры для базовых типов, мы можем перейти
к примерам реальных функций.
38.10.3. Соглашение о вызовах версии 1
Соглашение о вызовах версии 1 полагается на макросы, скрывающие основную долю сложностей,
связанных с передачей аргументов и результатов. По соглашению версии 1 функция на C должна
всегда определяться так:
Datum funcname(PG_FUNCTION_ARGS)
В дополнение к этому, в том же исходном файле должен присутствовать вызов макроса:
PG_FUNCTION_INFO_V1(funcname);
1020Расширение SQL
(Обычно его принято записывать непосредственно перед функцией.) Этот вызов макроса не нужен
для функций internal, так как PostgreSQL предполагает, что все внутренние функции используют
соглашении версии 1. Однако для функций, загружаемых динамически, этот макрос необходим.
В функции версии 1 каждый аргумент выбирается макросом PG_GETARG_xxx(), который соответ-
ствует типу данных аргумента. В нестрогих функциях этому вызову должна предшествовать про-
верка на NULL в аргументе с использованием PG_ARGNULL_xxx(). Результат возвращается макро-
сом PG_RETURN_xxx() для возвращаемого типа. PG_GETARG_xxx() принимает в качестве параметра
номер выбираемого аргумента функции (нумерация начинается с 0). PG_RETURN_xxx() принимает
фактическое значение, которое нужно возвратить.
Несколько примеров использования соглашения о вызовах версии 1:
#include
#include
#include
#include
“postgres.h”</li>
</ol>
<string.h>
"fmgr.h"
"utils/geo_decls.h"
PG_MODULE_MAGIC;
/* by value */
PG_FUNCTION_INFO_V1(add_one);
Datum
add_one(PG_FUNCTION_ARGS)
{
int32
arg = PG_GETARG_INT32(0);
PG_RETURN_INT32(arg + 1);
}
/* by reference, fixed length */
PG_FUNCTION_INFO_V1(add_one_float8);
Datum
add_one_float8(PG_FUNCTION_ARGS)
{
/* The macros for FLOAT8 hide its pass-by-reference nature. */
float8
arg = PG_GETARG_FLOAT8(0);
PG_RETURN_FLOAT8(arg + 1.0);
}
PG_FUNCTION_INFO_V1(makepoint);
Datum
makepoint(PG_FUNCTION_ARGS)
{
/* Here, the pass-by-reference nature of Point is not hidden. */
Point
*pointx = PG_GETARG_POINT_P(0);
Point
*pointy = PG_GETARG_POINT_P(1);
Point
*new_point = (Point *) palloc(sizeof(Point));
new_point-&gt;x = pointx-&gt;x;
new_point-&gt;y = pointy-&gt;y;
1021Расширение SQL
PG_RETURN_POINT_P(new_point);
}
/* by reference, variable length */
PG_FUNCTION_INFO_V1(copytext);
Datum
copytext(PG_FUNCTION_ARGS)
{
text
*t = PG_GETARG_TEXT_PP(0);
/*
* VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
* VARHDRSZ or VARHDRSZ_SHORT of its header. Construct the copy with a
* full-length header.
*/
text
*new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
/*
* VARDATA is a pointer to the data region of the new struct. The source
* could be a short datum, so retrieve its data through VARDATA_ANY.
*/
memcpy((void *) VARDATA(new_t), /* destination */
(void *) VARDATA_ANY(t), /* source */
VARSIZE_ANY_EXHDR(t));
/* how many bytes */
PG_RETURN_TEXT_P(new_t);
}
PG_FUNCTION_INFO_V1(concat_text);
Datum
concat_text(PG_FUNCTION_ARGS)
{
text *arg1 = PG_GETARG_TEXT_PP(0);
text *arg2 = PG_GETARG_TEXT_PP(1);
int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
text *new_text = (text *) palloc(new_text_size);
SET_VARSIZE(new_text, new_text_size);
memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
PG_RETURN_TEXT_P(new_text);
}
В предположении, что приведённый выше код был подготовлен в файле funcs.c и скомпилирован
в разделяемый объект, мы можем объявить эти функции в PostgreSQL следующими командами:
CREATE FUNCTION add_one(integer) RETURNS integer
AS 'КАТАЛОГ/funcs', 'add_one'
LANGUAGE C STRICT;
-- обратите внимание — это перегрузка SQL-функции "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
AS 'КАТАЛОГ/funcs', 'add_one_float8'
1022Расширение SQL
LANGUAGE C STRICT;
CREATE FUNCTION makepoint(point, point) RETURNS point
AS 'КАТАЛОГ/funcs', 'makepoint'
LANGUAGE C STRICT;
CREATE FUNCTION copytext(text) RETURNS text
AS 'КАТАЛОГ/funcs', 'copytext'
LANGUAGE C STRICT;
CREATE FUNCTION concat_text(text, text) RETURNS text
AS 'КАТАЛОГ/funcs', 'concat_text'
LANGUAGE C STRICT;
Здесь КАТАЛОГ — это путь к каталогу, в который помещён разделяемый библиотечный файл (на-
пример, каталог учебных материалов (tutorial) в исходном коде PostgreSQL, содержащий код при-
меров, использованных в этом разделе). (Лучше было бы просто написать 'funcs' в предложении
AS, предварительно добавив КАТАЛОГ в путь поиска. В любом случае, мы можем опустить принятое
в системе расширение файлов разделяемых библиотек, обычно .so.)
Заметьте, что мы объявили эти функции как «strict» (строгие) — это означает, что система бу-
дет автоматически подразумевать результат NULL, если в одном из входных значений передаётся
NULL. Благодаря этому, мы избегаем необходимости проверять входные значения на NULL в коде
функции. Без такого объявления нам пришлось бы явно проверять параметры на NULL, используя
PG_ARGISNULL().
На первый взгляд соглашения о вызовах версии 1 могут показаться всего лишь бессмысленным
мракобесием, по сравнению с соглашениями простого C. Однако они позволяют работать с аргу-
ментами и возвращаемыми значениями, в которых может передаваться NULL, а также со значени-
ями в формате TOAST (сжатыми или хранимыми отдельно).
Макрос PG_ARGISNULL(n) позволяет функции проверить на NULL каждый из её аргументов. (Ра-
зумеется, это нужно делать только в функциях, объявленных без характеристики «strict».) Как и
с макросом PG_GETARG_xxx(), входные аргументы нумеруются, начиная с нуля. Заметьте, что не
следует обращаться к макросу PG_GETARG_xxx(), не убедившись, что соответствующий аргумент не
NULL. Чтобы возвратить NULL в качестве результата, воспользуйтесь макросом PG_RETURN_NULL();
это работает и со строгими, и с нестрогими функциями.
Кроме того, в интерфейсе версии 1 появились две вариации макроса PG_GETARG_xxx(). Пер-
вая вариация, PG_GETARG_xxx_COPY(), гарантированно возвращает копию указанного аргумен-
та, которую можно безопасно модифицировать. (Обычный макрос иногда возвращает указатель
на значение, которое физически хранится в таблице, в которую нельзя писать. С макросом
PG_GETARG_xxx_COPY() гарантированно получается результат, доступный для записи.) Вторая ва-
риация представлена макросом PG_GETARG_xxx_SLICE(), принимающим три параметра. В первом
передаётся номер аргумента функции (как и раньше). Во втором и третьем передаётся смещение и
длина сегмента, который должен быть возвращён. Смещение отсчитывается с нуля, а отрицатель-
ная длина указывает, что запрашивается оставшаяся часть значения. Эти макросы дают более эф-
фективный доступ к частям больших значений, имеющим тип хранения «external». (Тип хранения
столбца может задаваться командой ALTER TABLE имя_таблицы ALTER COLUMN имя_столбца SET
STORAGE тип_хранения, где тип_хранения: plain, external, extended или main.)
Наконец соглашения о вызовах версии 1 позволяют возвращать множества (Подраздел 38.10.8) и
реализовывать триггерные функции (Глава 39) и обработчики вызовов процедурных языков (Гла-
ва 56). Дополнительные подробности можно найти в src/backend/utils/fmgr/README в пакете ис-
ходного кода.
38.10.4. Написание кода
Прежде чем перейти к более сложным темам, мы должны обсудить некоторые правила написания
кода функций на языке C для PostgreSQL. Хотя принципиально можно загружать в PostgreSQL
1023Расширение SQL
функции, написанные на языках, отличных от C, обычно это довольно сложно (когда вообще воз-
можно), так как другие языки, например C++, FORTRAN или Pascal часто не следуют соглашени-
ям, принятым в C. То есть другие языки могут передавать аргументы и возвращаемые значения
между функциями разными способами. Поэтому далее предполагается, что ваши функции на язы-
ке C действительно написаны на C.
Основные правила написания и компиляции функций на C таковы:
• Чтобы выяснить, где находятся заголовочные файлы сервера PostgreSQL, установленные в ва-
шей системе (или в системе, с которой будут работать ваши пользователи), воспользуйтесь ко-
мандой pg_config --includedir-server.
• Для компиляции и компоновки кода, который можно будет динамически загрузить в
PostgreSQL, требуется указать специальные флаги. Чтобы конкретнее узнать, как это сделать
в вашей конкретной операционной системе, обратитесь к Подразделу 38.10.5.
• Не забудьте определить «отличительный блок» для вашей разделяемой библиотеки, как опи-
сано в Подразделе 38.10.1.
• Для выделения памяти используйте функцию PostgreSQL palloc, а для освобождения pfree,
вместо соответствующих функций библиотеки C malloc и free. Память, выделяемая функцией
palloc, будет автоматически освобождаться в конце каждой транзакции, во избежание утечек
памяти.
• Всегда обнуляйте байты ваших структур, применяя memset (или сразу выделяйте память функ-
цией palloc0). Даже если вы присвоите значение каждому полю структуры, в ней могут оста-
ваться байты выравнивания (пустоты в структуре), содержащие случайные значения. Если ис-
ключить это требование, будет сложно поддерживать индексы или соединение по хешу, так
как для вычисления хеша придётся выбирать только значащие биты из вашей структуры дан-
ных. Планировщик также иногда полагается на побитовое сравнение констант, так что ре-
зультаты планирования могут оказаться неожиданными, если логически равные значения
окажутся неравными на битовом уровне.
• Большинство внутренних типов PostgreSQL объявлены в postgres.h, тогда как интерфейс ме-
неджера функций (PG_FUNCTION_ARGS и т. д.) определён в fmgr.h, так что потребуется под-
ключить как минимум два этих файла. По соображениям портируемости, лучше включить
postgres.h первым, до каких-либо других системных или пользовательских файлов заго-
ловков. При подключении postgres.h автоматически также будут подключены elog.h и
palloc.h.
• Имена символов, определённые в объектных файлах, не должны конфликтовать друг с другом
или с именами других символов, определённых в исполняемых файлах сервера PostgreSQL.
Если вы столкнётесь с ошибками, вызванными таким конфликтом, вам придётся переимено-
вать ваши функции или переменные.
38.10.5. Компиляция и компоновка динамически загружаемых
функций
Прежде чем вы сможете использовать ваши написанные на C функции, расширяющие возможно-
сти PostgreSQL, их необходимо скомпилировать и скомпоновать особым образом, чтобы сервер мог
динамически загрузить полученный файл. Точнее говоря, вам необходимо создать разделяемую
библиотеку.
За подробной информацией, дополняющей и поясняющей то, что описано в этом разделе, вам сле-
дует обратиться к документации вашей операционной системы, в частности, к страницам руковод-
ства компилятора C, cc, и компоновщика, ld. Кроме того, ряд рабочих примеров можно найти в
каталоге contrib исходного кода PostgreSQL. Однако, если вы непосредственно воспользуйтесь
этими примерами, ваши модули окажутся зависимыми от наличия исходного кода PostgreSQL.
Создание разделяемых библиотек в принципе не отличается от сборки исполняемых файлов: сна-
чала исходные файлы компилируются в объектные, а затем объектные связываются вместе. Объ-
ектные файлы должны создаваться так, чтобы они содержали позиционно-независимый код (PIC,
1024Расширение SQL
position-independent code), что означает, что при загрузке для выполнения этот код может быть по-
мещён в любое место в памяти. (Объектные файлы, предназначенные для сборки непосредствен-
но исполняемых файлов, обычно собираются не так.) Команда для компоновки разделяемой биб-
лиотеки принимает специальные флаги, что отличают её от компоновки исполняемого файла (по
крайней мере в теории — в некоторых системах реальность не так прекрасна).
В следующих примерах предполагается, что исходный код находится в файле foo.c и мы будем
создавать разделяемую библиотеку foo.so. Промежуточный объектный файл будет называться
foo.o, если не отмечено другое. Разделяемая библиотека может включать больше одного объект-
ного файла, но здесь мы ограничимся одним.
FreeBSD
Для создания кода PIC компилятору передаётся флаг -fPIC. Чтобы создать разделяемую биб-
лиотеку, используется флаг компилятора -shared.
gcc -fPIC -c foo.c
gcc -shared -o foo.so foo.o
Это применимо как минимум к FreeBSD версии 3.0.
HP-UX
Для создания кода PIC системному компилятору передаётся флаг +z, а компилятору GCC —
флаг -fPIC. Чтобы создать разделяемые библиотеки, используется флаг компоновщика -b. Та-
ким образом, нужно выполнить:
cc +z -c foo.c
или:
gcc -fPIC -c foo.c
а затем:
ld -b -o foo.sl foo.o
В HP-UX, в отличие от многих других систем, для разделяемых библиотек выбрано расширение
.sl.
Linux
Для создания кода PIC компилятору передаётся флаг -fPIC. Для создания разделяемой биб-
лиотеки компилятору передаётся флаг -shared. Полный пример будет выглядеть так:
cc -fPIC -c foo.c
cc -shared -o foo.so foo.o
macOS
Следующий пример показывает нужные команды, в предположении, что установлены инстру-
менты разработчика.
cc -c foo.c
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o
NetBSD
Для создания кода PIC компилятору передаётся флаг -fPIC. Для компоновки разделяемых биб-
лиотек в системах ELF компилятору передаётся флаг -shared, а в старых системах, не поддер-
живающих ELF, применяется команда ld -Bshareable.
gcc -fPIC -c foo.c
gcc -shared -o foo.so foo.o
OpenBSD
Для создания кода PIC компилятору передаётся флаг -fPIC, а для компоновки разделяемых
библиотек применяется команда ld -Bshareable.
1025Расширение SQL
gcc -fPIC -c foo.c
ld -Bshareable -o foo.so foo.o
Solaris
Для создания кода PIC компилятору Sun передаётся флаг -KPIC, а компилятору GCC — флаг -
fPIC. Для компоновки разделяемой библиотеки можно передать обоим компиляторам флаг -G
либо передать флаг -shared компилятору GCC.
cc -KPIC -c foo.c
cc -G -o foo.so foo.o
или
gcc -fPIC -c foo.c
gcc -G -o foo.so foo.o
Подсказка
Если это слишком сложно для вас, попробуйте использовать средство GNU Libtool, ко-
торое скрывает различия платформ за единым интерфейсом.
Полученную разделяемую библиотеку можно будет затем загрузить в PostgreSQL. Когда команде
CREATE FUNCTION передаётся имя файла, это должно быть имя файла разделяемой библиотеки,
а не промежуточного объектного файла. Заметьте, что принятое в системе расширение файлов
библиотек (как правило, .so или .sl) в команде CREATE FUNCTION можно опустить, и так обычно
следует делать для лучшей портируемости.
Чтобы уточнить, где сервер будет искать файлы разделяемых библиотек, вернитесь к Подразде-
лу 38.10.1.
38.10.6. Аргументы составного типа
Составные типы не имеют фиксированного макета данных, как структуры C. В частности, экзем-
пляры составного типа могут содержать поля NULL. Кроме того, в контексте наследования состав-
ные типы могут иметь разные поля для разных членов в одной иерархии наследования. Поэтому
PostgreSQL предоставляет функциям специальный интерфейс для обращения к полям составных
типов из C.
Предположим, что мы хотим написать функцию, отвечающую на запрос:
SELECT name, c_overpaid(emp, 1500) AS overpaid
FROM emp
WHERE name = 'Bill' OR name = 'Sam';
С соглашениями о вызовах версии 1 мы можем определить функцию c_overpaid так:
#include "postgres.h"
#include "executor/executor.h"
/* for GetAttributeByName() */
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(c_overpaid);
Datum
c_overpaid(PG_FUNCTION_ARGS)
{
HeapTupleHeader t = PG_GETARG_HEAPTUPLEHEADER(0);
int32
limit = PG_GETARG_INT32(1);
bool isnull;
Datum salary;
1026Расширение SQL
salary = GetAttributeByName(t, "salary", &amp;isnull);
if (isnull)
PG_RETURN_BOOL(false);
/* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */
PG_RETURN_BOOL(DatumGetInt32(salary) &gt; limit);
}
GetAttributeByName — это системная функция PostgreSQL, которая возвращает атрибуты указан-
ной строки. Она принимает три параметра: аргумент типа HeapTupleHeader, имя нужного атрибу-
та и выходной параметр, устанавливаемый, если значение атрибута — NULL. GetAttributeByName
возвращает значение Datum, которое вы можете привести к подходящему типу данных, используя
соответствующий макрос DatumGetXXX(). Заметьте, что возвращаемое значение недействительно,
если установлен флаг null; всегда проверяйте этот флаг, прежде чем что-либо делать с результа-
том.
Есть также функция GetAttributeByNum, которая выбирает целевой атрибут не по имени, а по но-
меру столбца.
Следующая команда объявляет функцию c_overpaid в SQL:
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
AS 'КАТАЛОГ/funcs', 'c_overpaid'
LANGUAGE C STRICT;
Заметьте, что мы использовали STRICT, чтобы нам не пришлось проверять входные аргументы на
равенство NULL.
38.10.7. Возврат строк (составных типов)
Чтобы вернуть строку или значение составного типа из функции на языке C, можно использовать
специальный API, предоставляющий макросы и функции, скрывающие основную сложность фор-
мирования составных типов данных. Для использования этого API необходимо включить в исход-
ный файл:
#include "funcapi.h"
Сформировать значение составного типа (далее «кортеж») можно двумя способами: его можно
построить из массива значений Datum, или из массива строк C, которые будут переданы функциям
преобразования ввода для типов столбцов кортежа. В любом случае, сначала нужно получить или
сконструировать дескриптор TupleDesc для структуры кортежа. Работая со значениями Datum,
вы передаёте TupleDesc функции BlessTupleDesc, а затем вызываете heap_form_tuple для каждой
строки. Работая со строками C, вы передаёте TupleDesc функции TupleDescGetAttInMetadata, а
затем для каждой строки вызываете BuildTupleFromCStrings. В случае функции, возвращающей
множество кортежей, все подготовительные действия можно выполнить один раз при первом вы-
зове функции.
Для получения требуемого дескриптора TupleDesc предлагается несколько дополнительных функ-
ций. Рекомендованный способ возврата составных значений заключается в вызове функции:
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
Oid *resultTypeId,
TupleDesc *resultTupleDesc)
При этом в fcinfo должна передаваться та же структура, что была передана самой вызываю-
щей функции. (Для этого, конечно, необходимо использовать соглашения о вызовах версии 1.) В
resultTypeId можно передать NULL или адрес локальной переменной, в которую будет записан
OID типа результата функции. В resultTupleDesc должен передаваться адрес локальной перемен-
ной TupleDesc. Убедить, что функция возвратила результат TYPEFUNC_COMPOSITE; в этом случае, в
resultTupleDesc оказывается требуемая структура TupleDesc. (Если получен другой результат, вы
1027Расширение SQL
можете выдать ошибку с сообщением «функция, возвращающая запись, вызвана в контексте, не
допускающем этот тип».)
Подсказка
get_call_result_type позволяет получить фактический тип результата полиморфной
функции, так что она полезна и в функциях, возвращающих скалярные полиморфные
результаты, не только в функциях, возвращающих составные типы. Выходной параметр
resultTypeId полезен в первую очередь для полиморфных скалярных функций.
Примечание
В дополнение к get_call_result_type есть схожая функция get_expr_result_type,
позволяющая получить ожидаемый тип результата для вызова функции, представлен-
ного деревом выражения. Её можно использовать, когда тип результата нужно опреде-
лить извне самой функции. Есть также функция get_func_result_type, которую мож-
но применять, когда известен только OID функции. Однако эти две функции неспособ-
ны выдать тип результата функций, возвращающих record, а get_func_result_type
неспособна разрешать полиморфные типы, так что вместо них лучше использовать
get_call_result_type.
Ранее для получения TupleDesc использовались теперь уже устаревшие функции:
TupleDesc RelationNameGetTupleDesc(const char *relname)
(возвращает TupleDesc для типа строк указанного отношения) и:
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
(возвращает TupleDesc для типа, задаваемого по OID). Применяя её, можно получить TupleDesc
для базового или составного типа. Однако она не подойдёт для функции, возвращающей тип
record, и не сможет разрешить полиморфные типы.
Получив TupleDesc, вызовите:
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
если вы планируете работать со структурами Datum, либо:
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
если планируете работать со строками C. Если вы разрабатываете функцию, возвращающую на-
бор данных, вы можете сохранить результаты этих функций в структуре FuncCallContext, в поле
tuple_desc или attinmeta, соответственно.
Если вы работаете со структурами Datum, воспользуйтесь функцией:
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
Она формирует HeapTuple из переданных ей данных в форме Datum.
Если вы работаете со строками C, воспользуйтесь функцией:
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
Она формирует HeapTuple из переданных ей данных в виде строк C. В параметре values ей переда-
ётся массив строк C, по одной для каждого атрибута выходной строки. Каждая из этих строк долж-
на иметь формат, принимаемый функцией ввода типа данных атрибута. Чтобы задать значение
NULL для одного из этих атрибутов, вместо соответствующего указателя в массиве values нужно
передать NULL. Эту функцию нужно вызывать для каждой строки, которую вы будете возвращать.
Получив кортеж, который вы будете возвращать из вашей функции, вы должны преобразовать его
в тип Datum. Чтобы преобразовать HeapTuple в Datum, воспользуйтесь функцией:
1028Расширение SQL
HeapTupleGetDatum(HeapTuple tuple)
Полученный тип Datum можно вернуть непосредственно, если должна возвращаться только одна
строка, либо использовать как текущее выдаваемое значение в функции, возвращающей набор
строк.
Пример приведён в следующем разделе.
38.10.8. Возврат множеств
Есть также специальный интерфейс, который позволяет функциям на C возвращать множества
(несколько строк). Функции, возвращающие множества, должны следовать соглашению о вызовах
версии 1. Кроме того, соответствующие исходные файлы должны включать funcapi.h, как пока-
зано выше.
Функция, возвращающая множество (SRF, Set-Returning Function), вызывается каждый раз для оче-
редной записи. Таким образом, SRF должна сохранять достаточно информации о состоянии, что-
бы понимать, что она делает, и выдать очередную запись при следующем вызове. Для облегче-
ния управления этим процессом представлена структура FuncCallContext. Для кода функции ука-
затель на эту структуру FuncCallContext сохраняется между вызовами в поле fcinfo-&gt;flinfo-
&gt;fn_extra.
typedef struct FuncCallContext
{
/*
* Счётчик числа ранее выполненных вызовов
*
* call_cntr сбрасывается в 0 макросом SRF_FIRSTCALL_INIT() и
* увеличивается на 1 каждый раз, когда вызывается SRF_RETURN_NEXT().
*/
uint64 call_cntr;
/*
* Максимальное число вызовов (может не использоваться)
*
* max_calls не является обязательным и присутствует здесь только для удобства.
* Если это значение не задано, вы должны предоставить другую возможность
определить,
* когда функция завершила свою работу.
*/
uint64 max_calls;
/*
* Указатель на слот результата (может не использоваться)
*
* Это поле устарело и представлено только для обратной совместимости, а именно,
* для пользовательских SRF, использующих устаревшую TupleDescGetSlot().
*/
TupleTableSlot *slot;
/*
* Указатель на разнообразную контекстную информацию,
* представленную пользователем; (может не использоваться)
*
* user_fctx используется как указатель на ваши собственные данные,
* позволяющий сохранить контекстную информацию между вызовами функции.
*/
void *user_fctx;
1029Расширение SQL
/*
* Указатель на структуру, содержащую метаданные ввода типа атрибута
* (может не использоваться)
*
* attinmeta задействуется, когда возвращаются кортежи (т. е. составные типы
данных),
* и не применяется для возврата базовых типов. Он нужен, только если
* вы планируете использовать BuildTupleFromCStrings() для формирования
возвращаемого
* кортежа.
*/
AttInMetadata *attinmeta;
/*
* Контекст памяти, нужный для структур, которые должны сохраняться при нескольких
вызовах
*
* Поле multi_call_memory_ctx заполняется в SRF_FIRSTCALL_INIT() и используется
* в SRF_RETURN_DONE() для очистки. Это наиболее подходящий контекст
* для любых блоков памяти, которые должны многократно использоваться при
* повторных вызовах SRF.
*/
MemoryContext multi_call_memory_ctx;
/*
* Указатель на структуру, содержащую описание кортежа (может не использоваться)
*
* tuple_desc задействуется, когда возвращаются кортежи (т. е. составные типы),
* и нужен только, если вы планируете формировать кортежи с помощью функции
* heap_form_tuple(), а не BuildTupleFromCStrings(). Заметьте, что сохраняемый
* здесь указатель TupleDesc обычно должен сначала пройти через вызов
* BlessTupleDesc().
*/
TupleDesc tuple_desc;
} FuncCallContext;
В SRF применяются различные функции и макросы, автоматически манипулирующие структурой
FuncCallContext (они обращаются к ней через fn_extra). В частности, чтобы определить, была ли
функция вызвана в первый или последующий раз, используйте:
SRF_IS_FIRSTCALL()
Чтобы инициализировать FuncCallContext при первом вызове (и только), используйте:
SRF_FIRSTCALL_INIT()
Чтобы подготовиться к использованию FuncCallContext и очистить все ранее возвращённые дан-
ные, оставшиеся после предыдущего прохода, при каждом вызове функции, в том числе, первом,
выполните:
SRF_PERCALL_SETUP()
Если у вашей функции есть данные, которые нужно возвратить, выполните:
SRF_RETURN_NEXT(funcctx, result)
для того, чтобы выдать их вызывающему. (Переменная result должна быть типа Datum, либо одним
значением, либо кортежем, подготовленным как описано выше.) Наконец, когда ваша функция
закончила возвращать данные, выполните:
SRF_RETURN_DONE(funcctx)
1030Расширение SQL
для того, чтобы провести очистку и завершить SRF.
Контекст памяти, в котором вызывается SRF, временный, он будет очищаться между вызовами.
Это значит, что вам не нужно вызывать pfree для всех блоков памяти, которые вы получили через
palloc; они всё равно будут освобождены. Однако, если вы хотите выделить структуры данных и
сохранить их между вызовами, вам нужно разместить их где-то в другом месте. Для размещения
таких данных, которые не должны уничтожаться, пока SRF не закончит работу, подходит контекст
памяти, на который указывает multi_call_memory_ctx. В большинстве случаев это означает, что
вы должны переключиться в контекст multi_call_memory_ctx в коде подготовки при первом вы-
зове.
Предупреждение
Тогда как фактические аргументы такой функции не меняются от вызова к вызову,
если вы распаковываете значения аргументов (что обычно прозрачно делают мак-
росы PG_GETARG_xxx) во временном контексте, распакованные копии будут освобож-
даться при каждом вызове. Соответственно, если вы сохраните ссылки на такие зна-
чения в своём контексте user_fctx, вы должны либо скопировать эти значения в
multi_call_memory_ctx после распаковки, либо распаковывать значения только в этом
контексте.
Полный пример с псевдокодом будет выглядеть так:
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
FuncCallContext *funcctx;
Datum
result;
другие необходимые объявления
if (SRF_IS_FIRSTCALL())
{
MemoryContext oldcontext;
funcctx = SRF_FIRSTCALL_INIT();
oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
/* Здесь размещается код подготовки при первом вызове: */
некоторый код
если возвращается составной тип
получить TupleDesc и, возможно, AttInMetadata
конец ветвления для составного типа
некоторый код
MemoryContextSwitchTo(oldcontext);
}
/* Здесь размещается код подготовки для каждого вызова: */
некоторый код
funcctx = SRF_PERCALL_SETUP();
некоторый код
/* это только один способ определить, не пора ли закончить работу: */
if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
{
/* Здесь мы хотим вернуть следующий результат: */
некоторый код
получить результирующий Datum
SRF_RETURN_NEXT(funcctx, result);
1031Расширение SQL
}
else
{
/* Здесь мы заканчиваем выдавать результаты и нам нужно провести очистку: */
некоторый код
SRF_RETURN_DONE(funcctx);
}
}
Полный пример простой SRF-функции, возвращающей составной тип, выглядит так:
PG_FUNCTION_INFO_V1(retcomposite);
Datum
retcomposite(PG_FUNCTION_ARGS)
{
FuncCallContext
*funcctx;
int
call_cntr;
int
max_calls;
TupleDesc
tupdesc;
AttInMetadata
*attinmeta;
/* stuff done only on the first call of the function */
if (SRF_IS_FIRSTCALL())
{
MemoryContext
oldcontext;
/* create a function context for cross-call persistence */
funcctx = SRF_FIRSTCALL_INIT();
/* switch to memory context appropriate for multiple function calls */
oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
/* total number of tuples to be returned */
funcctx-&gt;max_calls = PG_GETARG_UINT32(0);
/* Build a tuple descriptor for our result type */
if (get_call_result_type(fcinfo, NULL, &amp;tupdesc) != TYPEFUNC_COMPOSITE)
ereport(ERROR,
(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
errmsg("function returning record called in context "
"that cannot accept type record")));
/*
* generate attribute metadata needed later to produce tuples from raw
* C strings
*/
attinmeta = TupleDescGetAttInMetadata(tupdesc);
funcctx-&gt;attinmeta = attinmeta;
MemoryContextSwitchTo(oldcontext);
}
/* stuff done on every call of the function */
funcctx = SRF_PERCALL_SETUP();
call_cntr = funcctx-&gt;call_cntr;
max_calls = funcctx-&gt;max_calls;
attinmeta = funcctx-&gt;attinmeta;
1032Расширение SQL
if (call_cntr &lt; max_calls)
{
char
**values;
HeapTuple
tuple;
Datum
result;
/* do when there is more left to send */
/*
* Prepare a values array for building the returned tuple.
* This should be an array of C strings which will
* be processed later by the type input functions.
*/
values = (char **) palloc(3 * sizeof(char *));
values[0] = (char *) palloc(16 * sizeof(char));
values[1] = (char *) palloc(16 * sizeof(char));
values[2] = (char *) palloc(16 * sizeof(char));
snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));
/* build a tuple */
tuple = BuildTupleFromCStrings(attinmeta, values);
/* make the tuple into a datum */
result = HeapTupleGetDatum(tuple);
/* clean up (this is not really necessary) */
pfree(values[0]);
pfree(values[1]);
pfree(values[2]);
pfree(values);
SRF_RETURN_NEXT(funcctx, result);
}
else
{
/* do when there is no more left */
SRF_RETURN_DONE(funcctx);
}
}
В SQL её можно объявить следующим образом:
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);
CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
RETURNS SETOF __retcomposite
AS 'имя_файла', 'retcomposite'
LANGUAGE C IMMUTABLE STRICT;
Также её можно объявить с параметрами OUT:
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
OUT f1 integer, OUT f2 integer, OUT f3 integer)
RETURNS SETOF record
AS 'имя_файла', 'retcomposite'
LANGUAGE C IMMUTABLE STRICT;
Заметьте, что при таком подходе выходным типом функции формально является анонимный тип
record.
1033Расширение SQL
Каталог contrib/tablefunc в пакете исходного кода содержит дополнительные примеры функций,
возвращающих множества.
38.10.9. Полиморфные типы аргументов и результата
Функции на языке C могут быть объявлены как принимающие и возвращающие полиморфные
типы anyelement, anyarray, anynonarray, anyenum и anyrange. За более подробным объяснени-
ем полиморфных функций обратитесь к Подразделу  38.2.5. Когда типы аргументов или резуль-
тат определены как полиморфные, автор функции не может заранее знать, с какими типами
данных она будет вызываться и какой возвращать. Чтобы функция на C в стиле версии 1 мог-
ла определить фактические типы данных своих аргументов и тип, который она должна вернуть,
в fmgr.h предлагаются две функции. Они называются get_fn_expr_rettype(FmgrInfo *flinfo)
и get_fn_expr_argtype(FmgrInfo *flinfo, int argnum) и возвращают соответственно OID ти-
па результата и аргумента, либо InvalidOid, если информация о типе отсутствует. Структуру
flinfo обычно можно получить по ссылке fcinfo-&gt;flinfo. Номер аргумента argnum задаётся, на-
чиная с нуля. В качестве альтернативы get_fn_expr_rettype также можно использовать функ-
ции get_call_result_type. Кроме того, есть функция get_fn_expr_variadic, позволяющая опре-
делить, были ли переменные аргументы объединены в массив. Это полезно в основном для функ-
ций VARIADIC "any", так как такое объединение всегда имеет место для функций с переменными
аргументами, принимающих обычные типы.
Например, предположим, что нам нужно написать функцию, принимающую один элемент любого
типа и возвращающую одномерный массив этого типа:
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
ArrayType *result;
Oid
element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
Datum
element;
bool
isnull;
int16
typlen;
bool
typbyval;
char
typalign;
int
ndims;
int
dims[MAXDIM];
int
lbs[MAXDIM];
if (!OidIsValid(element_type))
elog(ERROR, "could not determine data type of input");
/* получить переданный элемент, учитывая, что это может быть NULL */
isnull = PG_ARGISNULL(0);
if (isnull)
element = (Datum) 0;
else
element = PG_GETARG_DATUM(0);
/* мы имеем дело с одной размерностью */
ndims = 1;
/* и одним элементом */
dims[0] = 1;
/* с нижней границей, равной 1 */
lbs[0] = 1;
/* получить требуемую информацию о типе элемента */
get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);
1034Расширение SQL
/* теперь создать массив */
result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
element_type, typlen, typbyval, typalign);
PG_RETURN_ARRAYTYPE_P(result);
}
Следующая команда объявляет функцию make_array в SQL:
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
AS 'КАТАЛОГ/funcs', 'make_array'
LANGUAGE C IMMUTABLE;
Существует один вариант полиморфизма, которым могут пользоваться только функции на языке
C: их можно объявить с параметрами типа "any". (Заметьте, что имя этого типа нужно заключать
в двойные кавычки, так как это также зарезервированное слово в SQL.) Он работает так же, как
anyelement, за исключением того, что он не требует, чтобы аргументы "any" имели одинаковый
тип, и не помогает определить тип результата функции. Функцию на языке C можно также объ-
явить с последним параметром VARIADIC "any". Ему будут соответствовать один или более факти-
ческих аргументов любого типа (не обязательно одинакового). Эти аргументы не будут собираться
в массив, как это происходит с обычными функциями с переменными аргументами; они просто бу-
дут переданы функции по отдельности. Если применяется этот вариант, то чтобы определить число
фактических аргументов и их типы, нужно использовать макрос PG_NARGS() и функции, описанные
выше. Пользователи такой функции также могут пожелать использовать ключевое слово VARIADIC
в вызове функции, ожидая, что функция обработает элементы массива как отдельные аргументы.
При необходимости соответствующее поведение должна реализовывать сама функция, определив
с помощью get_fn_expr_variadic, был ли фактический аргумент передан с указанием VARIADIC.
38.10.10. Функции преобразования
Некоторые вызовы функций можно упростить на стадии планирования, в зависимости от особых
свойств функции. Например, функцию умножения (int4mul(n, 1)) можно упростить просто до n.
Чтобы определить такую оптимизацию, нужно написать функцию преобразования и поместить её
OID в поле protransform записи основной функции в pg_proc. Функция преобразования должна
иметь в SQL сигнатуру protransform(internal) RETURNS internal. В аргументе, фактически име-
ющем тип FuncExpr *, передаётся фиктивный узел, представляющий вызов основной функции. Ес-
ли анализ дерева выражения в функции преобразования показывает, что вместо всех возможных
конкретных вызовов может быть подставлено дерево упрощённого выражения, эта функция долж-
на построить и вернуть это упрощённое выражение. В противном случае нужно вернуть указатель
NULL (не NULL языка SQL).
Мы не гарантируем, что PostgreSQL никогда не будет вызывать основную функцию во всех случаях,
когда функция преобразования может её упростить, поэтому важно, чтобы упрощённое выражение
строго соответствовало реальному вызову основной функции.
В настоящее время эта функциональность не предоставляется пользователям на уровне SQL из
соображений безопасности, так что на практике это можно использовать только для оптимизации
встроенных функций.
38.10.11. Разделяемая память и лёгкие блокировки
Модули расширений могут резервировать лёгкие блокировки и область в разделяемой памяти при
запуске сервера. Чтобы библиотека модуля предварительно загружалась на этапе запуска сервера,
нужно указать её в shared_preload_libraries. Чтобы зарезервировать разделяемую память, вызовите
из вашей функции _PG_init функцию:
void RequestAddinShmemSpace(int size)
Чтобы зарезервировать лёгкие блокировки, из _PG_init нужно вызвать:
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
1035Расширение SQL
В результате будет сформирован массив из num_lwlocks лёгких блокировок под име-
нем tranche_name. Чтобы получить указатель на этот массив, воспользуйтесь функцией
GetNamedLWLockTranche.
Во избежание возможных условий гонки каждый обслуживающий процесс должен вызывать
AddinShmemInitLock в момент подключения и при инициализации разделяемой памяти, как пока-
зано здесь:
static mystruct *ptr = NULL;
if (!ptr)
{
bool
*/
found;
LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
ptr = ShmemInitStruct("my struct name", size, &amp;found);
if (!found)
{
/* инициализировать содержимое области разделяемой памяти; */
/* получить все требуемые блокировки LWLocks:
ptr-&gt;locks = GetNamedLWLockTranche("my tranche name");
}
LWLockRelease(AddinShmemInitLock);
}
38.10.12. Использование C++ для расширяемости
Хотя код сервера PostgreSQL написан на C, расширения для него можно писать и на C++, если
соблюдать эти правила:
• Все функции, к которым будет обращаться сервер, должны предоставлять ему интерфейс C;
эти функции на C затем могут вызывать функции на языке C++. В частности, для функций,
доступных серверу, необходимо указать extern C. Это также необходимо для всех функций,
указатели на которые передаются между кодом сервера и подключаемым кодом на C++.
• Освобождайте память, применяя для этого подходящий метод. Например, память сервера в
основном выделяется функцией palloc(), так что освобождать её нужно, вызывая pfree().
Попытка использовать в таких случаях принятую в C++ операцию delete приведёт к ошибке.
• Не допускайте распространения исключений в код C (добавляйте блок, перехватывающий все
исключения, на верхнем уровне функций extern C). Это необходимо, даже если код на C++
не генерирует исключения явно, потому что исключения могут возникать, например, и при
нехватке памяти. Все исключения должны перехватываться, и в интерфейс C должны переда-
ваться соответствующие ошибки. Если возможно, скомпилируйте код C++ с указанием -fno-
exceptions, чтобы полностью отключить исключения; в таких случаях вы должны будете вы-
являть исключительные ситуации в коде C++, например, проверять на NULL адрес, возвра-
щённый new().
• Вызывая серверные функции из кода C++, убедитесь, что в стеке вызова C++ содержатся
только простые структуры данных. Это необходимо, потому что в случае ошибки сервера вы-
полняется функция longjmp(), а она не отматывает стек вызовов C++ должным образом для
объектов, отличных от простых структур.
Резюмируя, лучше всего поместить код C++ за ограду из функций extern C, которые будут до-
ступны серверу и смогут защитить от исключений, а также потери стека вызовов и утечки памяти.
38.11. Пользовательские агрегатные функции
Агрегатные функции в PostgreSQL определяются в терминах значений состояния и функций пе-
рехода состояния. То есть агрегатная функция работает со значением состояния, которое меня-
ется при обработке каждой последующей строки. Чтобы определить агрегатную функцию, нужно
1036Расширение SQL
выбрать тип данных для значения состояния, начальное значение состояния и функцию перехода
состояния. Функция перехода состояния принимает предыдущее значение состояния и входное
агрегируемое значение для текущей строки и возвращает новое значение состояния. Также мож-
но указать функцию завершения, на случай, если ожидаемый результат агрегатной функции от-
личается от данных, которые сохраняются в изменяющемся значении состояния. Функция завер-
шения принимает конечное значение состояния и возвращает то, что она хочет вернуть в виде ре-
зультата агрегирования. В принципе, функции перехода и завершения представляют собой просто
обычные функции, которые также могут применяться вне контекста агрегирования. (На практике
для большей производительности часто создаются специализированные функции перехода, кото-
рые работают, только когда вызываются при агрегировании.)
Таким образом, помимо типов данных аргументов и результата, с которыми имеет дело пользо-
ватель агрегатной функции, есть также тип данных внутреннего состояния, который может отли-
чаться от этих типов.
Если мы определяем агрегат, не использующий функцию завершения, наш агрегат будет вычис-
лять бегущее значение функции по столбцам каждой строки. Примером такой агрегатной функ-
ции является sum. Вычисление sum начинается с нуля, а затем к накапливаемой сумме всегда при-
бавляется значение из текущей строки. Например, если мы хотим сделать агрегатную функцию
sum для комплексных чисел, нам потребуется только функция сложения для такого типа данных.
Такая агрегатная функция может быть определена так:
CREATE AGGREGATE sum (complex)
(
sfunc = complex_add,
stype = complex,
initcond = '(0,0)'
);
Использовать её можно будет так:
SELECT sum(a) FROM test_complex;
sum
-----------
(34,53.9)
(Заметьте, что мы задействуем перегрузку функций: в системе есть несколько агрегатных функций
с именем sum, но PostgreSQL может определить, какая именно из них применима к столбцу типа
complex.)
Определённая выше функция sum вернёт ноль (начальное значение состояния), если в наборе дан-
ных не окажется значений, отличных от NULL. У нас может возникнуть желание вернуть NULL
в этом случае — стандарт SQL требует, чтобы sum работала так. Мы можем добиться этого, про-
сто опустив фразу initcond, так что начальным значением состояния будет NULL. Обычно это
будет означать, что в sfunc придётся проверять входное значение состояния на NULL. Но для sum
и некоторых других простых агрегатных функций, как max и min, достаточно вставить в перемен-
ную состояния первое входное значение не NULL, а затем начать применять функцию перехода со
следующего значения не NULL. PostgreSQL сделает это автоматически, если начальное значение
состояние равно NULL и функция перехода помечена как «strict» (то есть не должна вызываться
для аргументов NULL).
Ещё одна особенность поведения по умолчанию «строгой» функции перехода — предыдущее зна-
чение состояния остаётся без изменений, когда встречается значение NULL. Другими словами,
значения NULL игнорируются. Если вам нужно другое поведение для входных значений NULL, не
объявляйте свою функцию перехода строгой (strict); вместо этого, проверьте в ней поступающие
значения на NULL и обработайте их, как требуется.
Функция avg (вычисляющая среднее арифметическое) представляет собой более сложный пример
агрегатной функции. Ей необходимы два компонента текущего состояния: сумма входных значе-
ний и их количество. Окончательный результат получается как частное этих величин. При реали-
1037Расширение SQL
зации этой функции для значения состояния обычно используется массив. Например, встроенная
реализация avg(float8) выглядит так:
CREATE AGGREGATE avg (float8)
(
sfunc = float8_accum,
stype = float8[],
finalfunc = float8_avg,
initcond = '{0,0,0}'
);
Примечание
Функция float8_accum принимает массив из трёх, а не двух элементов, так как в до-
полнение к количеству и сумме значений она подсчитывает ещё сумму их квадратов.
Это сделано для того, чтобы её можно было применять для avg и для некоторых других
агрегатных функций.
Вызовы агрегатных функций SQL допускают указания DISTINCT и ORDER BY, которые определяют,
какие строки и в каком порядке будут поступать в функцию перехода агрегата. Это реализовано
на заднем плане и непосредственно не затрагивает функции, поддерживающие работу агрегата.
За дополнительными подробностями обратитесь к описанию CREATE AGGREGATE.
38.11.1. Режим движущегося агрегата
Агрегатные функции могут дополнительно поддерживать режим движущегося агрегата, который
позволяет значительно быстрее выполнять агрегатные функции в окнах со сдвигающимся нача-
лом рамки. (За информацией об использовании агрегатных функций в качестве оконных обрати-
тесь к Разделу 3.5 и Подразделу 4.2.8.) Основная идея состоит в том, что помимо добавления обыч-
ной функции перехода «вперёд», для агрегатной функции задаётся функция обратного перехода,
которая позволяет убирать строки из накапливаемого значения состояния, когда они покидают
рамку окна. Например, для sum в качестве функции прямого перехода выполняется сложение, а в
качестве функции обратного перехода выполняется вычитание. Без функции обратного перехода
механизм оконных функций вынужден вычислять агрегат заново при каждом перемещении нача-
ла рамки, в результате чего время обработки оказывается пропорциональным количеству входных
строк, помноженному на средний размер рамки. С функцией обратного перехода это время про-
порционально только количеству входных строк.
Функции обратного перехода передаётся текущее значение состояния и агрегируемое входное зна-
чение(я) для строки, ранее учтённой в текущем состоянии. Она должна восстановить то значение
состояния, которое было бы получено, если бы эта строка не агрегировалась, но агрегировались
все последующие. Иногда для этого нужно, чтобы функция обратного перехода сохраняла боль-
ше информации о состоянии, чем это требуется для простого режима агрегирования. Таким обра-
зом, для режима движущегося агрегата используется реализация, отличная от простого режима:
для него определяется отдельный тип данных, отдельная функция прямого перехода и отдельная
функция завершения, при необходимости. Они могут совпадать с типом данных и аналогичными
функциями обычного режима, если в дополнительном состоянии необходимости нет.
В качестве примера мы можем доработать показанную выше агрегатную функцию sum, чтобы она
поддерживала режим движущегося агрегата так:
CREATE AGGREGATE sum (complex)
(
sfunc = complex_add,
stype = complex,
initcond = '(0,0)',
msfunc = complex_add,
minvfunc = complex_sub,
mstype = complex,
1038Расширение SQL
minitcond = '(0,0)'
);
Параметры, имена которых начинаются с m, определяют реализацию для движущегося агрегата.
За исключением функции обратного перехода, minvfunc, они соответствуют параметрам обычного
агрегата без m.
Функции прямого перехода в режиме движущегося агрегата не разрешено возвращать NULL в ка-
честве нового значения состояния. Если функция обратного перехода возвращает NULL, это вос-
принимается как признак того, что она не может восстановить предыдущее состояние для полу-
ченных данных, и значит, агрегатное вычисление нужно производить заново с текущей позиции
начала рамки. Это соглашение позволяет применять режим движущегося агрегата и в ситуациях,
когда прокручивать назад значение состояния непрактично. Функция обратного перехода может
«спасовать» в таких случаях, но включаться в работу, насколько это возможно в большинстве слу-
чаев. Например, агрегатная функция, работающая с числами с плавающей точкой, может спасо-
вать, когда от неё потребуется убрать значение NaN (не число, not a number) из текущего значения
состояния.
Разрабатывая функции, реализующие режим движущегося агрегата, важно, чтобы функция обрат-
ного перехода могла восстановить в точности требуемое значение состояния. В противном случае,
в результатах могут проявляться различия, в зависимости от того, использовался ли режим дви-
жущегося агрегата. Например, на первый взгляд может показаться, что легко добавить функцию
обратного перехода для сложения, но заявленное требование не будет выполняться для sum с ти-
пом float4 или float8. Наивное объявление sum(float8) может быть таким:
CREATE AGGREGATE unsafe_sum (float8)
(
stype = float8,
sfunc = float8pl,
mstype = float8,
msfunc = float8pl,
minvfunc = float8mi
);
Однако такой агрегат может выдавать результаты, радикально отличающиеся от тех, что он выда-
вал бы без функции обратного перехода. Например, рассмотрите запрос
SELECT
unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
(2, 1.0::float8)) AS v (n,x);
Он возвращает 0 в качестве второго результата, а не ожидаемое значение 1. Это связано с огра-
ниченной точностью значений с плавающей точкой: при добавлении 1 к 1e20 снова получается
1e20, а при вычитании 1e20 из результата получается 0, а не 1. Заметьте, что это принципиальное
ограничение арифметики чисел с плавающей точкой, а не недостаток PostgreSQL.
38.11.2. Агрегатные функции с полиморфными и переменными
аргументами
Агрегатная функция может использовать полиморфные функции перехода состояния или функции
завершения, так что эти функции могут применяться для реализации нескольких агрегатов. За
объяснением полиморфных функций обратитесь к Подразделу 38.2.5. Более того, сама агрегатная
функция может описываться с полиморфными типами входных данных и состояния, так что одно
определение агрегатной функции может служить для использования с разными типами данных.
Пример полиморфного агрегата:
CREATE AGGREGATE array_accum (anyelement)
(
sfunc = array_append,
stype = anyarray,
initcond = '{}'
1039Расширение SQL
);
Здесь фактическим типом состояния для любого конкретного агрегатного вызова будет массив,
элементы которого будут иметь тип входных данных. Действие данного агрегата заключается в
накоплении всех входных значений в массиве этого типа. (К вашему сведению: встроенная агре-
гатная функция array_agg обеспечивает подобную функциональность, но работает быстрее, чем
могла бы функция с приведённым определением.)
Так будут выглядеть результаты с аргументами двух различных типов:
SELECT attrelid::regclass, array_accum(attname)
FROM pg_attribute
WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
GROUP BY attrelid;
attrelid
|
array_accum
---------------+---------------------------------------
pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)
SELECT attrelid::regclass, array_accum(atttypid::regtype)
FROM pg_attribute
WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
GROUP BY attrelid;
attrelid
|
array_accum
---------------+---------------------------
pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)
Обычно агрегатная функция с полиморфным типом результата имеет и полиморфный тип состоя-
ния, как в предыдущем примере. Это необходимо, так как иначе нельзя будет объявить функцию
завершения: она должна будет иметь полиморфный тип результата, но не будет иметь полиморф-
ного аргумента, что команда CREATE FUNCTION не примет на основании того, что тип результата
нельзя будет определить при вызове. Но иметь полиморфный тип состояния не всегда удобно. Ча-
ще всего эта проблема возникает, когда функции реализации агрегата пишутся на C и тип состоя-
ния должен объявляться как internal, так как для него нет соответствующего типа на уровне SQL.
Чтобы решить эту проблему, можно объявить функцию завершения как принимающую дополни-
тельные фиктивные аргументы, соответствующие входным аргументам агрегата. В этих фиктив-
ных аргументах всегда передаются значения NULL, так как при вызове функции завершения ка-
кое-либо определённое значение отсутствует. Единственное их предназначение — позволить свя-
зать тип результата полиморфной функции завершения с типом входных данных агрегата. Напри-
мер, определение встроенного агрегата array_agg выглядит так:
CREATE FUNCTION array_agg_transfn(internal, anynonarray)
RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anynonarray)
RETURNS anyarray ...;
CREATE AGGREGATE array_agg (anynonarray)
(
sfunc = array_agg_transfn,
stype = internal,
finalfunc = array_agg_finalfn,
finalfunc_extra
);
Здесь параметр finalfunc_extra указывает, что функция завершения помимо значения состояния
получит дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата.
Дополнительный аргумент anynonarray позволяет сделать объявление array_agg_finalfn допу-
стимым.
1040Расширение SQL
Агрегатную функцию можно сделать принимающей переменное число аргументов, объявив её по-
следний аргумент как массив VARIADIC, в том же ключе, как и обычную функцию; см. Подраз-
дел 38.5.5. При этом у функций перехода агрегата их последний аргумент должен иметь тот же
тип массива. Такие функции обычно также объявляются как VARIADIC, но строго это не требуется.
Примечание
Агрегатные функции с переменными аргументами легко допускают ошибочное исполь-
зование в сочетании с указанием ORDER BY (см. Подраздел 4.2.7), так как анализатор
запроса не может определить, было ли передано нужное количество фактических па-
раметров в такой комбинации. Помните, что всё, находящееся справа от ORDER BY, яв-
ляется ключом сортировки, а не аргументом агрегатной функции. Например, в
SELECT myaggregate(a ORDER BY a, b, c) FROM ...
анализатор запроса увидит один агрегатный аргумент функции и три ключа сортиров-
ки. Однако пользователь мог подразумевать и следующее:
SELECT myaggregate(a, b, c ORDER BY a) FROM ...
Если функция myaggregate принимает переменные аргументы, оба эти вызова будут
вполне допустимы.
По этой же причине, стоит подумать дважды, прежде чем создавать агрегатные функ-
ции с одинаковыми именами, но разным числом обычных аргументов.
38.11.3. Сортирующие агрегатные функции
Описанные выше агрегатные функции были «обычными» агрегатами. Но PostgreSQL также под-
держивает сортирующие агрегатные функции, которые имеют два отличия от обычных. Во-пер-
вых, в дополнение к обычным агрегируемым аргументам, вычисляемых для каждой входной стро-
ки, сортирующий агрегат может иметь «непосредственные» аргументы, которые должны вычис-
ляться в операции агрегирования только один раз. Во-вторых, для обычных агрегируемых аргу-
ментов порядок их сортировки задаётся явно, а сортирующий агрегат обычно выполняет вычисле-
ния, зависящие от конкретного порядка строк, например, вычисляет ранг или процентиль, так что
порядок сортировки критичен для каждого вызова. Например, встроенное определение функции
percentile_disc равнозначно следующему:
CREATE FUNCTION ordered_set_transition(internal, anyelement)
RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
RETURNS anyelement ...;
CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
sfunc = ordered_set_transition,
stype = internal,
finalfunc = percentile_disc_final,
finalfunc_extra
);
Этот агрегат принимает непосредственный аргумент float8 (дробь процентиля) и агрегируемые
данные, которые могут быть любого упорядочиваемого типа. Используя его, можно рассчитать
средний семейный доход следующим образом:
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
percentile_disc
-----------------
50489
В данном случае, 0.5 — это непосредственный аргумент; если бы дробь процентиля менялась от
строки к строке, это не имело бы смысла.
1041Расширение SQL
В отличие от случая с обычными агрегатами, сортировка входных строк для сортирующего агрега-
та не выполняется на заднем плане, а является задачей функций, реализующих агрегат. Типичная
реализация такого агрегата заключается в сохранении ссылки на объект «tuplesort» в значении
состояния агрегата, загрузке поступающих строк в этот объект, и собственно окончании сортиров-
ки и выдачи данных в функции завершения. При такой организации обработки функция заверше-
ния может выполнять специальные операции, в частности, вставлять дополнительные «гипотети-
ческие» строки в сортируемые данные. Тогда как обычные агрегаты часто реализуются функци-
ями, написанными на PL/pgSQL или другом процедурном языке, сортирующие агрегатные функ-
ции, как правило, должны быть написаны на C, так как их значение состояния нельзя выразить
каким-либо типом данных SQL. (Обратите внимание, что в приведённом выше примере значение
состояния объявлено как имеющее тип internal — это типичный вариант.) И вследствие того,
что сортировку выполняет функция завершения, нельзя возобновить добавление входных строк,
продолжая вызывать функцию перехода. Это означает, что функция завершения не может иметь
характеристику READ_ONLY; она должна объявляться командой CREATE AGGREGATE с характери-
стикой READ_WRITE или SHAREABLE (если она позволяет при последующих вызовах функции завер-
шения использовать уже отсортированное состояние).
Функция перехода состояния для сортирующего агрегата получает значение текущего состояния
плюс агрегируемые входные данные для каждой строки и возвращает изменённое значение со-
стояния. Это определение распространяется и на обычные агрегаты, но заметьте, что непосред-
ственные аргументы (если они есть) при этом не передаются. Функция завершения же получает
последнее значение состояния и значения непосредственных аргументов (если они есть), а также
(если присутствует указание finalfunc_extra) значения NULL, соответствующие агрегируемым
данным. С обычными агрегатами указание finalfunc_extra действительно полезно, только если
агрегат полиморфный; тогда дополнительные фиктивные аргументы необходимы, чтобы связать
тип результата функции завершения с типом(ами) входных данных агрегата.
В настоящее время сортирующие агрегаты не могут использоваться в качестве оконных функций,
поэтому от них поддержка режима движущегося агрегата не требуется.
38.11.4. Частичное агрегирование
Дополнительно агрегатная функция может поддерживать частичное агрегирование. Идея такого
агрегирования в том, чтобы вызывать функции перехода состояния для различных подмножеств
входных данных независимо, а затем комбинировать значения состояния, вычисленные по этим
подмножествам, и получать тот же результат, что был бы получен при сканировании сразу всех
входных данных. Этот режим может применяться для параллельного агрегирования, когда разные
рабочие процессы сканируют различные части таблицы. При этом каждый рабочий процесс вы-
даёт частичное значение состояния, а в конце эти значения комбинируются вместе и получается
окончательное значение состояния. (В будущем этот режим может также применяться, например
для комбинированного агрегирования локальных и удалённых таблиц, но пока это не реализовано.)
Для поддержки частичного агрегирования в определении агрегатной функции должна задаваться
комбинирующая функция, принимающая два значения типа состояния агрегата (представляющие
результаты агрегирования по двум подмножествам входных строк) и выдающая новое значение
типа состояния, представляющее то состояние, которое было бы получено при агрегировании со-
вокупности этих подмножеств строк. При этом относительный порядок входных строк в этих двух
множествах не оговаривается. Это значит, что для агрегатных функций, зависящих от порядка
входных строк, обычно невозможно определить осмысленную комбинирующую функцию.
В качестве простого примера, частичное агрегирование могут поддерживать функции MAX и MIN,
если задать в качестве комбинирующей соответственно функцию сравнения значений большее-из-
двух или меньшее-из-двух, ту же, что они используют и как функцию перехода. Для SUM комбини-
рующей функцией будет просто функция сложения. (И это опять же функция перехода, если толь-
ко значение состояния не выходит за рамки типа входных данных.)
Комбинирующая функция задействуется практически так же, как функция перехода, но прини-
мает в качестве второго аргумента значение типа состояния, а не нижележащего входного типа.
В частности, на неё распространяются те же правила строгости функции и передачи значений
NULL. Также учтите, что если в определении агрегатной функции задаётся отличное от NULL зна-
1042Расширение SQL
чение initcond, оно будет задавать начальное состояние не только для каждого прохода частич-
ного агрегирования, но также и начальное состояние для комбинирующей функции, которая будет
вызываться для комбинирования каждого частичного результата в этом состоянии.
Если типом состояния агрегатной функции выбран internal, комбинирующая функция отвечает
за то, чтобы её результат был помещён в контекст памяти, подходящий для значений агрегатного
состояния. В частности это значит, что, получив в первом аргументе NULL, нельзя просто возвра-
тить второй аргумент, так как это значение окажется в неверном контексте и не просуществует
достаточное время.
Когда типом состояния агрегатной функции выбран internal, обычно в определении агрегатной
функции также уместно задать функцию сериализации и функцию десериализации, которые поз-
воляют копировать значение состояния из одного процесса в другой. Без этих функций параллель-
ное агрегирование невозможно, а также вероятно не будут работать такие будущие приложения,
как локальное/удалённое агрегирование.
Функция сериализации должна принимать один аргумент типа internal и возвращать результат
типа bytea, представляющий значение состояния, упакованное в плоский набор байтов. Функция
десериализации, напротив, обращает это преобразование. Она должна принимать два аргумента
типов bytea и internal и возвращать результат типа internal. (Второй её аргумент не использу-
ется и всегда равен нулю, но он требуется из соображений типобезопасности.) Результат функции
десериализации следует просто разместить в текущем контексте памяти, так как в отличие от ре-
зультата комбинирующей функции он недолговечен.
Также стоит заметить, что для выполнения агрегатной функции в параллельном режиме она долж-
на иметь характеристику PARALLEL SAFE (безопасная для распараллеливания). Характеристики
допустимости распараллеливания её опорных функций значения не имеют.
38.11.5. Вспомогательные функции для агрегатов
Функция, написанная на C, может определить, была ли она вызвана как вспомогательная функция
агрегирования, вызвав AggCheckCallContext, например, так:
if (AggCheckCallContext(fcinfo, NULL))
Смысл такой проверки в том, что в случае положительного её результата первым входным аргу-
ментом является временное значение состояния, которое можно безопасно модифицировать на
месте, не создавая новую копию. Пример вы можете увидеть в функции int8inc(). (Хотя агре-
гатные функции перехода всегда могут изменить непосредственно переходное значение, агрегат-
ные функции завершения должны избегать этого; если они это делают, такое поведение долж-
но отмечаться при создании агрегата. За дополнительными подробностями обратитесь к CREATE
AGGREGATE.)
Второй аргумент AggCheckCallContext можно использовать, чтобы получить контекст памяти, в
котором содержатся значения агрегатного состояния. Это полезно для функций перехода, кото-
рые желают использовать «развёрнутые» объёкты (см. Подраздел  38.12.1) в качестве значений
состояния. При первом вызове такая функция перехода должна возвратить развёрнутый объект
в контексте памяти, относящемся к контексту состояния агрегата, а затем продолжать возвра-
щать тот же объект при последующих вызовах. Например, эту логику можно увидеть в функции
array_append(). (Функция array_append() не используется в качестве перехода никаким встроен-
ным агрегатом, но она написана так, чтобы работать эффективно в таком качестве в дополнитель-
ном агрегате.)
Ещё одна вспомогательная подпрограмма, предназначенная для агрегатных функций, написан-
ных на C, называется AggGetAggref. Эта функция возвращает узел разбора Aggref, описывающий
вызов агрегата. Это в основном полезно для сортирующих агрегатов, которые могут исследовать
структуру узла Aggref и выяснить, какой порядок сортировки они должны реализовать. Примеры
использования можно найти в orderedsetaggs.c в исходном коде PostgreSQL.
38.12. Пользовательские типы
1043Расширение SQL
Как описывалось в Разделе 38.2, PostgreSQL может расширяться и поддерживать новые типы дан-
ных. В этом разделе описывается, как определить новые базовые типы, то есть типы данных, опи-
санные ниже уровня языка SQL. Для создания нового базового типа необходимо реализовать функ-
ции, работающие с этим типом, на языке низкого уровня, обычно C.
Примеры, рассматриваемые в этой главе, можно найти в complex.sql и в complex.c в каталоге src/
tutorial пакета с исходным кодом. Инструкции по запуску этих примеров можно найти в файле
README в том же каталоге.
Пользовательский тип должен всегда иметь функции ввода и вывода. Эти функции определяют,
как тип будет выглядеть в строковом виде (при вводе и выводе для пользователя) и как этот тип
размещается в памяти. Функция ввода принимает в качестве аргумента строку символов, закан-
чивающуюся нулём, и возвращает внутреннее представление типа (в памяти). Функция вывода
принимает в качестве аргумента внутреннее представление типа и возвращает строку символов,
заканчивающуюся нулём. Если мы хотим не просто сохранить тип, но делать с ним нечто большее,
мы должны предоставить дополнительные функции, реализующие все операции, которые мы хо-
тели бы иметь для этого типа.
Предположим, что нам нужен тип complex, представляющий комплексные числа. Естественным
образом комплексное число можно представить в памяти в виде следующей структуры C:
typedef struct Complex {
double
x;
double
y;
} Complex;
Нам нужно будет передавать этот тип по ссылке, так как он слишком велик, чтобы уместиться в
одном значении Datum.
В качестве внешнего строкового представления типа мы выберем строку вида (x,y).
Функции ввода и вывода обычно несложно написать, особенно функцию вывода. Но определяя
внешнее строковое представление типа, помните, что в конце концов вам придётся реализовать
законченный и надёжный метод разбора этого представления в функции ввода. Например, так:
PG_FUNCTION_INFO_V1(complex_in);
Datum
complex_in(PG_FUNCTION_ARGS)
{
char
*str = PG_GETARG_CSTRING(0);
double
x,
y;
Complex
*result;
if (sscanf(str, " ( %lf , %lf )", &amp;x, &amp;y) != 2)
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg("invalid input syntax for complex: \"%s\"",
str)));
result = (Complex *) palloc(sizeof(Complex));
result-&gt;x = x;
result-&gt;y = y;
PG_RETURN_POINTER(result);
}
Функция вывода может быть простой:
PG_FUNCTION_INFO_V1(complex_out);
1044Расширение SQL
Datum
complex_out(PG_FUNCTION_ARGS)
{
Complex
*complex = (Complex *) PG_GETARG_POINTER(0);
char
*result;
result = psprintf("(%g,%g)", complex-&gt;x, complex-&gt;y);
PG_RETURN_CSTRING(result);
}
Вам нужно позаботиться о том, чтобы функции ввода и вывода были обратными друг к другу. В
противном случае вы столкнётесь с проблемами, когда вам потребуется выгрузить данные в файл,
а затем прочитать их. Это особенно распространённая проблема, когда дело касается чисел с пла-
вающей точкой.
Дополнительно пользовательский тип может предоставлять функции для ввода и вывода в двоич-
ном виде. Двоичный ввод/вывод обычно работает быстрее, но хуже портируется, чем текстовый.
Как и с текстовым представлением, выбор, каким будет двоичное представление, остаётся за вами.
Многие встроенные типы данных стараются обеспечить двоичное представление, независимое от
машинной архитектуры. Для типа complex мы воспользуемся функциями двоичного ввода/вывода
типа float8:
PG_FUNCTION_INFO_V1(complex_recv);
Datum
complex_recv(PG_FUNCTION_ARGS)
{
StringInfo buf = (StringInfo) PG_GETARG_POINTER(0);
Complex
*result;
result = (Complex *) palloc(sizeof(Complex));
result-&gt;x = pq_getmsgfloat8(buf);
result-&gt;y = pq_getmsgfloat8(buf);
PG_RETURN_POINTER(result);
}
PG_FUNCTION_INFO_V1(complex_send);
Datum
complex_send(PG_FUNCTION_ARGS)
{
Complex
*complex = (Complex *) PG_GETARG_POINTER(0);
StringInfoData buf;
pq_begintypsend(&amp;buf);
pq_sendfloat8(&amp;buf, complex-&gt;x);
pq_sendfloat8(&amp;buf, complex-&gt;y);
PG_RETURN_BYTEA_P(pq_endtypsend(&amp;buf));
}
Написав функции ввода/вывода и скомпилировав их в разделяемую библиотеку, мы можем опре-
делить тип complex в SQL. Сначала мы объявим его как тип-пустышку:
CREATE TYPE complex;
Это позволит нам ссылаться на этот тип, определяя для него функции ввода/вывода. Теперь мы
определим функции ввода/вывода:
CREATE FUNCTION complex_in(cstring)
1045Расширение SQL
RETURNS complex
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION complex_out(complex)
RETURNS cstring
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION complex_recv(internal)
RETURNS complex
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION complex_send(complex)
RETURNS bytea
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
Наконец, мы можем предоставить полное определение типа данных:
CREATE TYPE complex (
internallength = 16,
input = complex_in,
output = complex_out,
receive = complex_recv,
send = complex_send,
alignment = double
);
Когда определяется новый базовый тип, PostgreSQL автоматически обеспечивает поддержку мас-
сивов с элементами такого типа. Тип массива обычно получает имя по имени базового типа с до-
бавленным спереди символом подчёркивания (_).
Когда тип данных определён, мы можем объявить дополнительные функции для выполнения по-
лезных операций с этим типом. Затем поверх этих функций могут быть определены операторы, а
если потребуется, и классы операторов, для поддержки индексации этого типа. Эти дополнитель-
ные уровни обсуждаются в следующих разделах.
Если внутреннее представление типа данных имеет переменную длину, оно должно соответство-
вать стандартной схеме данных переменной длины: первые четыре байта должно занимать по-
ле char[4], к которому никогда не следует обращаться напрямую (по обыкновению названное
vl_len_). Чтобы сохранить в этом поле размер элемента (включая длину самого поля), вы долж-
ны использовать макрос SET_VARSIZE(), а чтобы получить его — макрос VARSIZE(). (Эти макросы
нужны, потому что поле длины может кодироваться по-разному на разных платформах.)
За дополнительными подробностями обратитесь к команде CREATE TYPE.
38.12.1. Особенности TOAST
Если значения вашего типа данных могут быть разного размера (во внутренней форме), обычно
для такого типа желательно реализовать поддержку TOAST (см. Раздел 68.2). Это следует делать,
даже если значения слишком малы для сжатия или внешнего хранения, так как TOAST позволяет
сэкономить пространство и с данными маленького размера, сокращая издержки в заголовке.
Для поддержки хранения TOAST функции на C, работающие с таким типом данных, должны
позаботиться о распаковке поступивших им данных, используя макрос PG_DETOAST_DATUM. (Эту
внутреннюю особенность обычно скрывает дополнительный, определяемый для типа макрос
GETARG_DATATYPE_P.) Затем, выполняя команду CREATE TYPE, укажите в качестве внутренней длины
variable и выберите подходящий вариант хранения (не plain).
1046Расширение SQL
Если выравнивание данных не имеет значения (либо только для некоторой функции, либо по-
тому что для типа данных в любом случае применяется выравнивание по байтам), некото-
рых издержек, связанных с макросом PG_DETOAST_DATUM, можно избежать. Вместо него можно
использовать PG_DETOAST_DATUM_PACKED (его обычно скрывает определяемый для типа макрос
GETARG_DATATYPE_PP) и воспользоваться макросами VARSIZE_ANY_EXHDR и VARDATA_ANY для обраще-
ния к потенциально сжатым данным. Стоит ещё раз отметить, что данные, возвращаемые этими
макросами, не выравниваются, даже если выравнивание задано в определении типа. Если вырав-
нивание важно, вы должны задействовать обычный интерфейс PG_DETOAST_DATUM.
Примечание
В старом коде поле vl_len_ часто объявлялось как int32, а не char[4]. Это ничем не
чревато до той поры, пока в определении структуры имеются другие поля с выравни-
ванием как минимум int32. Но с потенциально невыровненными данными такое опре-
деление структуры опасно; компилятор может воспринять его как право полагать, что
данные выровнены, что может привести к аварийным сбоям в архитектурах, строгих
к выравниванию.
Поддержка TOAST даёт также возможность иметь развёрнутое представление данных в памяти,
работать с которым будет удобнее, чем с форматом хранения на диске. Обычный или «плоский»
формат хранения varlena в конце концов представляет собой просто набор байт; он не может со-
держать указатели, так как эти байты могут быть скопированы в другие адреса. Для сложных ти-
пов данных работать с плоским форматом данных может быть довольно дорого, так что PostgreSQL
даёт возможность «развернуть» плоский формат в представление, более подходящее для вычис-
лений, и затем передавать эту структуру в памяти функциям, работающим с этим типом.
Для использования развёрнутого хранения тип данных должен определять развёрнутый формат по
правилам, описанным в src/include/utils/expandeddatum.h, и предоставлять функции для «раз-
ворачивания» плоского значения в этот формат, а также для «заворачивания» этого формата опять
в обычное представление varlena. Затем надо добиться, чтобы все функции на C могли принимать
любое представление, возможно выполняя преобразование одного в другое непосредственно при
получении. Для этого не требуется исправлять сразу все существующие функции для этого ти-
па данных, так как имеющийся стандартный макрос PG_DETOAST_DATUM способен преобразовывать
развёрнутые входные данные в обычный плоский формат. Таким образом, все существующие функ-
ции, работающие с плоским форматом varlena продолжат работать, хотя и не очень эффективно, с
развёрнутыми входными данными; их необязательно переделывать, пока не потребуется оптими-
зировать производительность.
Функции на C, умеющие работать с развёрнутым представлением, обычно делятся на две катего-
рии: те, что могут работать с развёрнутым форматом, и те, что могут принимать и развёрнутые, и
плоские данные varlena. Первые проще написать, но они могут быть менее эффективными в целом,
так как преобразование плоского значения в развёрнутую форму для использования только одной
функцией может стоить больше, чем сэкономится при обработке данных в развёрнутом формате.
Когда нужно работать только с развёрнутым форматом, преобразование плоских значений в раз-
вёрнутую форму можно скрыть в макросе, извлекающем аргументы, чтобы функция была не слож-
нее, чем работающая с традиционными входными данными varlena. Чтобы принимать оба вариан-
та входных значений, напишите функцию извлечения аргументов, которая будет распаковывать
значения с сокращённым заголовком, а также внешние и сжатые, но не развёрнутые данные. Та-
кую функцию можно определить как возвращающую указатель на объединение плоского форма-
та varlena и развёрнутого формата. Какой формат получен фактически, вызывающий код может
определить, вызвав макрос VARATT_IS_EXPANDED_HEADER().
Инфраструктура TOAST позволяет не только отличить обычные значения varlena от развёрнутых
значений, но и различить указатели «для чтения/записи» и «только для чтения» на развёрнутые
значения. Функции на C, которым нужно читать развёрнутое значение, или которые будут менять
его безопасным и невидимым извне образом, могут не обращать внимания на тип полученного
указателя. Если же функции на C выдают изменённую версию входного значения, они могут из-
1047Расширение SQL
менять развёрнутые входные данные на месте, только когда получают указатель для чтения/запи-
си, но не когда получен указатель только для чтения. В последнем случае они должны сначала
скопировать значение и получить новое значение, допускающее изменение. Функция на C, созда-
ющая новое развёрнутое значение, должна всегда возвращать указатель на него для чтения/запи-
си. Кроме того, функция, изменяющая развёрнутое значение непосредственно по указателю для
чтения/записи должна позаботиться о том, чтобы это значение осталось в приемлемом состоянии,
если она отработает не полностью.
Примеры работы с развёрнутыми значениями можно найти в стандартной инфраструктуре масси-
вов, в частности в src/backend/utils/adt/array_expanded.c.
38.13. Пользовательские операторы
Любой оператор представляет собой «синтаксический сахар» для вызова нижележащей функции,
выполняющей реальную работу; поэтому прежде чем вы сможете создать оператор, необходимо
создать нижележащую функцию. Однако оператор — не исключительно синтаксический сахар,
так как он несёт и дополнительную информацию, помогающую планировщику запросов оптими-
зировать запросы с этим оператором. Рассмотрению этой дополнительной информации будет по-
свящён следующий раздел.
PostgreSQL поддерживает левые унарные, правые унарные и бинарные операторы. Операторы мо-
гут быть перегружены;то есть одно имя оператора могут иметь различные операторы с разным
количеством и типами операндов. Когда выполняется запрос, система определяет, какой оператор
вызвать, по количеству и типам предоставленных операндов.
В следующем примере создаётся оператор сложения двух комплексных чисел. Предполагается,
что мы уже создали определение типа complex (см. Раздел 38.12). Сначала нам нужна функция,
собственно выполняющая операцию, а затем мы сможем определить оператор:
CREATE FUNCTION complex_add(complex, complex)
RETURNS complex
AS 'имя_файла', 'complex_add'
LANGUAGE C IMMUTABLE STRICT;
CREATE OPERATOR + (
leftarg = complex,
rightarg = complex,
function = complex_add,
commutator = +
);
Теперь мы можем выполнить такой запрос:
SELECT (a + b) AS c FROM test_complex;
c
-----------------
(5.2,6.05)
(133.42,144.95)
Мы продемонстрировали создание бинарного оператора. Чтобы создать унарный оператор, просто
опустите leftarg (для левого унарного) или rightarg (для правого унарного). Обязательными в
CREATE OPERATOR являются только предложение function и объявления аргументов. Предложение
commutator, добавленное в данном примере, представляет необязательную подсказку для оптими-
затора запросов. Подробнее о commutator и других подсказках для оптимизатора рассказывается
в следующем разделе.
38.14. Информация для оптимизации операторов
Определение оператора в PostgreSQL может включать различные дополнительные предложения,
которые сообщают системе полезные сведения о поведении оператора. Старайтесь задавать эти
1048Расширение SQL
предложения при возможности, так как они могут значительно ускорить выполнение запросов,
использующих данный оператор. Но если вы задаёте их, убедитесь, что они корректны! Непра-
вильное применение предложений оптимизации может привести к замедлению запросов, неоче-
видным ошибочным результатам и другим неприятностям. Если вы не уверены в правильности
предложения оптимизации, лучше вовсе не использовать его; единственным последствием будет
то, что запросы будут работать медленнее, чем могли бы.
В будущих версиях PostgreSQL могут быть добавлены и другие предложения. Здесь описываются
те, что поддерживаются версией 11.1.
38.14.1. COMMUTATOR
Предложение COMMUTATOR, если представлено, задаёт оператор, коммутирующий для определяе-
мого. Оператор A является коммутирующим для оператора B, если (x A y) равняется (y B x) для
всех возможных значений x, y. Заметьте, что B также будет коммутирующим для A. Например, опе-
раторы &lt; и &gt; для конкретного типа данных обычно являются коммутирующими друг для друга, а
оператор + — коммутирующий для себя. Но традиционный оператор - коммутирующего не имеет.
Тип левого операнда оператора должен совпадать с типом правого операнда коммутирующего для
него оператора, и наоборот. Поэтому имя коммутирующего оператора — это всё, что PostgreSQL
должен знать, чтобы найти коммутатор, и всё, что нужно указать в предложении COMMUTATOR.
Информация о коммутирующих операторах крайне важна для операторов, которые будут приме-
няться в индексах и условиях соединения, так как, используя её, оптимизатор запросов может
«переворачивать» такие выражения и получать формы, необходимые для разных типов планов.
Например, рассмотрим запрос с предложением WHERE tab1.x = tab2.y, где tab1.x и tab2.y име-
ют пользовательский тип, и предположим, что у нас есть индекс по столбцу tab2.y. Оптимизатор
сможет задействовать сканирование по индексу, только если ему удастся перевернуть выражение
tab2.y = tab1.x, так как механизм сканирования по индексу ожидает, что индексируемый стол-
бец находится слева от оператора. PostgreSQL сам по себе не будет полагать, что такое преобра-
зование возможно — это должен определить создатель оператора =, добавив информацию о ком-
мутирующем операторе.
Когда вы определяете оператор, коммутирующий сам для себя, вы делаете именно это. Если же вы
определяете пару коммутирующих операторов, возникает небольшое затруднение: как оператор,
определяемый первым, может ссылаться на другой, ещё не определённый? Есть два решения этой
проблемы:
• Во-первых, можно опустить предложение COMMUTATOR для первого оператора, который вы
определяете, а затем добавить его в определении второго. Так как PostgreSQL знает, что ком-
мутирующие операторы связаны парами, встречая второе определение, он автоматически воз-
вращается к первому и добавляет в него недостающее предложение COMMUTATOR.
• Во-вторых, можно добавить предложение COMMUTATOR в оба определения. Когда PostgreSQL об-
рабатывает первое определение и видит, что COMMUTATOR ссылается на несуществующий опе-
ратор, в системном каталоге создаётся фиктивная запись для этого оператора. В этой фиктив-
ной записи актуальны будут только имя оператора, типы левого и правого операндов, а также
тип результата, так как это всё, что PostgreSQL может определить в этот момент. Запись пер-
вого оператора будет связана с этой фиктивной записью. Затем, когда вы определите второй
оператор, система внесёт в эту фиктивную запись дополнительную информацию из второго
определения. Если вы попытаетесь применить фиктивный оператор, прежде чем он будет пол-
ностью определён, вы просто получите сообщение об ошибке.
38.14.2. NEGATOR
Предложение NEGATOR, если присутствует, задаёт оператор, обратный к определяемому. Оператор
A является обратным к оператору B, если они оба возвращают булевский результат и (x A y) равня-
ется NOT (x B y) для всех возможных x, y. Заметьте, что B так же является обратным к A. Например,
операторы &lt; и &gt;= составляют пару обратных друг к другу для большинства типов данных. Никакой
оператор не может быть обратным к себе же.
1049Расширение SQL
В отличие от коммутирующих операторов, два унарных оператора вполне могут быть обратными
к друг другу; это будет означать, что (A x) равняется NOT (B x) для всех x (и для правых унарных
операторов аналогично).
У оператора, обратного данному, типы левого и/или правого операнда должны соответствовать
типам данного оператора, так же как и с предложением COMMUTATOR; отличие только в том, что
имя оператора задаётся в предложении NEGATOR.
Указание обратного оператора очень полезно для оптимизатора запросов, так как это позволяет
упростить выражение вида NOT (x = y) до x &lt;&gt; y. Такие выражения не так редки, как может
показаться, так как операции NOT могут добавляться автоматически в результате реорганизаций
выражений.
Пару обратных операторов можно определить теми же способами, что были описаны ранее для
пары коммутирующих.
38.14.3. RESTRICT
Предложение RESTRICT, если представлено, определяет функцию оценки избирательности ограни-
чения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения
RESTRICT имеют смысл только для бинарных операторов, возвращающих boolean. Идея оценки из-
бирательности ограничения заключается в том, чтобы определить, какой процент строк в таблице
будет удовлетворять условию WHERE вида:
column OP constant
для текущего оператора и определённого значения константы. Это помогает оптимизатору при-
мерно определить, сколько строк будет исключено предложениями WHERE такого вида. (ВЫ спро-
сите, а что если константа находится слева? Ну, собственно для таких случаев и задаётся
COMMUTATOR...)
Рамки данной главы не позволяют описать разработку новых функций оценки избирательности
ограничения, но обычно можно использовать один из стандартных системных оценщиков для боль-
шинства дополнительных операторов. Стандартные оценщики ограничений следующие:
eqsel для =
neqsel для &lt;&gt;
scalarltsel для
scalarlesel для
scalargtsel для
scalargesel для
&lt;
&lt;=
&gt;
&gt;=
Часто вы можете обойтись функциями eqsel и neqsel для операторов с очень высокой или низкой
избирательностью, даже если это не операторы собственно равенства или неравенства. Например,
геометрические операторы приблизительного равенства используют eqsel в предположении, что
соответствующие (равные) элементы будут составлять только небольшой процент от всех записей
таблицы.
Функции scalarltsel, scalarlesel, scalargtsel и scalargesel можно использовать для сравне-
ний с типами данных, которые могут быть каким-либо осмысленным образом преобразованы в чис-
ловые скалярные значения для сравнения диапазонов. Если возможно, добавьте свой тип данных
в число типов, которые понимает функция convert_to_scalar(), реализованная в src/backend/
utils/adt/selfuncs.c. (Когда-нибудь на смену ей придут специализированные функции, кото-
рые будут устанавливаться для конкретных типов в определённом столбце системного каталога
pg_type; но пока этого не произошло.) Если вы этого не сделаете, всё будет работать, но оценки
оптимизатора будут не так хороши, как могли бы быть.
Для геометрических операторов разработаны дополнительные функции оценки избирательности
в src/backend/utils/adt/geo_selfuncs.c: areasel, positionsel и contsel. На момент написания
документации это просто заглушки, но вы, тем не менее, вполне можете использовать (или ещё
лучше, доработать) их.
1050Расширение SQL
38.14.4. JOIN
Предложение JOIN, если представлено, определяет функцию оценки избирательности соединения
для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения JOIN
имеют смысл только для бинарных операторов, возвращающих boolean. Идея оценки избиратель-
ности соединения заключается в том, чтобы угадать, какой процент строк в паре таблиц будет
удовлетворять условию WHERE следующего вида:
table1.column1 OP table2.column2
для текущего оператора. Как и RESTRICT, это предложение очень помогает оптимизатору, позволяя
ему выяснить, какой из возможных вариантов соединения скорее всего окажется выгоднее.
Как и ранее, в этой главе мы не будем пытаться рассказать, как написать функцию оценивания
избирательности соединения, а просто отметим, что вы можете использовать один из подходящих
стандартных оценщиков:
eqjoinsel для =
neqjoinsel для &lt;&gt;
scalarltjoinsel для &lt;
scalarlejoinsel для &lt;=
scalargtjoinsel для &gt;
scalargejoinsel для &gt;=
areajoinsel для сравнений областей в плоскости
positionjoinsel для сравнения положений в плоскости
contjoinsel для проверки на включение в плоскости
38.14.5. HASHES
Предложение HASHES, если присутствует, говорит системе, что для соединений с применением
этого оператора допустимо использовать метод соединения по хешу. HASHES имеет смысл только
для бинарного оператора, который возвращает boolean, и на практике этот оператор должен вы-
ражать равенство значений некоторого типа данных или пары типов данных.
Соединение по хешу базируется на том предположении, что оператор соединения возвращает ис-
тину только для таких пар значений слева и справа, для которых получается одинаковый хеш. Если
два значения оказываются в разных ячейках хеша, операция соединения никогда не будет срав-
нивать их, неявно подразумевая, что результат оператора соединения в этом случае должен быть
ложным. Поэтому не имеет никакого смысла указывать HASHES для операторов, которые не пред-
ставляют какую-любо форму равенства. В большинстве случаев практический смысл в поддержке
хеширования есть только для операторов, принимающих один тип данных с обеих сторон. Однако
иногда возможно разработать хеш-функции, совместимые сразу с несколькими типами данных; то
есть, функции, которые будут выдавать одинаковые хеш-коды для «равных» значений, несмотря на
то, что эти значения будут представлены по-разному. Например, довольно легко функции с такой
особенностью реализуются для хеширования целых чисел различного размера.
Чтобы оператор соединения имел характеристику HASHES, он должен входить в семейство опера-
торов индексирования по хешу. Это требование откладывается, когда оператор только создаётся,
ведь нужное семейство операторов, разумеется, ещё не может существовать. Но при попытке ис-
пользовать такой оператор для соединения по хешу, возникнет ошибка во время выполнения, ес-
ли такого семейства не окажется. Системе необходимо знать семейство операторов, чтобы найти
функции для хеширования типа(ов) входных данных оператора. Конечно, вы должны также опре-
делить подходящие функции хеширования, прежде чем сможете создать семейство операторов.
При подготовке функции хеширования обязательно позаботьтесь о том, чтобы она всегда выдавала
нужный результат, вне зависимости от особенностей машинной архитектуры. Например, если ваш
тип данных представлен в структуре, в которой есть незначащие дополняющие биты, нельзя про-
сто передать всю структуру функции hash_any. (Это возможно, только если все ваши операторы и
функции гарантированно очищают незначащие биты, что является рекомендуемой стратегией.) В
качестве другого примера можно привести типы с плавающей точкой в стандарте IEEE, в которых
отрицательный ноль и положительный ноль — различные значения (отличаются на уровне битов),
1051Расширение SQL
но при сравнении они считаются равными. Если значение с плавающей точкой может содержать
отрицательный ноль, требуются дополнительные действия, чтобы для него выдавался тот же хеш,
что и для положительного нуля.
Оператор соединения по хешу должен иметь коммутирующий (это может быть тот же оператор,
если у него два операнда одного типа, либо связанный оператор равенства, в противном случае),
относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использова-
ния оператора возможны ошибки планировщика. Также желательно (хотя это строго не требует-
ся), чтобы в семействе операторов хеширования, поддерживающем несколько типов данных, опре-
делялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей
оптимизации.
Примечание
Функция, реализующая оператор соединения по хешу, должна быть постоянной
(IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE),
система никогда не будет применять этот оператор для соединения по хешу.
Примечание
Если оператор соединения по хешу реализуется строгой функцией (STRICT), эта функ-
ция также должна быть полной: то есть она должна возвращать true или false, но не
NULL, для любых двух аргументов, отличных от NULL. Если это правило не соблюда-
ется, оптимизация операций IN с хешем может приводить к неверным результатам.
(В частности, выражение IN может вернуть false, когда правильным ответом, согласно
стандарту, должен быть NULL, либо выдать ошибку с сообщением о том, что оно не
готов к результату NULL.)
38.14.6. MERGES
Предложение MERGES, если присутствует, говорит системе, что для соединений с применением
этого оператора допустимо использовать метод соединения слиянием. MERGES имеет смысл только
для бинарного оператора, который возвращает boolean, и на практике этот оператор должен вы-
ражать равенство значений некоторого типа данных или пары типов данных.
Идея объединения слиянием заключается в упорядочивании таблиц слева и справа и затем парал-
лельном сканировании их. Поэтому оба типа данных должны поддерживать сортировку в полном
объёме, а оператор соединения должен давать положительный результат только для пар значений,
оказавшихся в «одном месте» при определённом порядке сортировки. На практике это означает,
что оператор соединения должен работать как проверка на равенство. Но при этом возможно объ-
единить слиянием два различных типа данных, если они совместимы логически. Например, опе-
ратор проверки равенства smallint и integer может применяться для соединений слиянием; по-
надобятся только операторы сортировки, приводящие оба типа данных в логически совместимые
последовательности.
Чтобы оператор соединения имел характеристику MERGES, он должен являться членом семейства
операторов индекса btree, реализующим равенство. Это требование откладывается, когда опера-
тор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать.
Но этот оператор не будет фактически применяться для соединений слиянием, пока не будет най-
дено соответствующее семейство операторов. Таким образом, флаг MERGES только подсказывает
планировщику, что стоит обратиться к соответствующему семейству.
Оператор соединения слиянием должен иметь коммутирующий (это может быть тот же оператор,
если у него два операнда одного типа, либо связанный оператор равенства, в противном случае),
относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использо-
вания оператора возможны ошибки планировщика. Также желательно (хотя это строго не требу-
1052Расширение SQL
ется), чтобы в семействе операторов btree, поддерживающем несколько типов данных, определя-
лись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оп-
тимизации.
Примечание
Функция, реализующая оператор соединения слиянием, должна быть постоянной
(IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE),
система никогда не будет применять этот оператор для соединения слиянием.
38.15. Интерфейсы расширений для индексов
Описанные до этого процедуры позволяли определять новые типы, функции и операторы. Однако,
мы ещё не можем определить индекс по столбцу нового типа данных. Для этого нам потребуется
создать класс операторов для нового типа данных. Далее в этом разделе мы продемонстрируем
эту концепцию на примере: мы создадим новый класс операторов для метода индекса-B-дерева,
в котором будут храниться комплексные числа и сортироваться по возрастанию абсолютного зна-
чения.
Классы операторов могут объединяться в семейства операторов, выражающие зависимости меж-
ду семантически совместимыми классами. Когда вводится один тип данных, достаточно класса
операторов, так что мы начнём с него, а к семействам операторов вернёмся позже.
38.15.1. Методы индексов и классы операторов
В системном каталоге есть таблица pg_am, содержащая записи для каждого метода индекса
(внутри называемого методом доступа). Поддержка обычного доступа к таблицам встроена в
PostgreSQL, но все методы доступа описываются в pg_am. Система позволяет добавлять новые ме-
тоды доступа — для этого нужно написать необходимый код, а затем добавить запись в pg_am, но
это выходит за рамки данной главы (см. Главу 61).
Процедуры метода индекса непосредственно ничего не знают о типах данных, с которыми будет
применяться этот метод. Вместо этого, набор операций, которые нужны методу индекса для рабо-
ты с конкретным типом данных, определяется классом операторов. Классы операторов называ-
ются так потому, что они определяют множество операторов в предложении WHERE, которые могут
использоваться с индексом (т. е. могут быть сведены к сканированию индекса). В классе опера-
торов могут также определяться некоторые опорные функции, необходимые для внутренних опе-
раций метода индекса, но они не соответствуют напрямую каким-либо операторам предложения
WHERE, которые могут обрабатываться с индексом.
Для одного типа данных и метода индекса можно определить несколько классов операторов. Бла-
годаря этому, для одного типа данных можно использовать несколько семантически разных ва-
риантов индексирования. Например, индекс-B-дерево требует, чтобы для каждого типа данных, с
которым он работает, определялся порядок сортировки. Для типа комплексных чисел может быть
полезен класс операторов B-дерева, сортирующий данные по модулю комплексного числа, и ещё
один, сортирующий по вещественной части, и т. п. Обычно предполагается, что один из классов
операторов будет применяться чаще других, и тогда он помечается как класс по умолчанию для
данного типа и метода индекса.
Одно и то же имя класса операторов может использоваться для разных методов индекса (напри-
мер, для методов индекса-B-дерева или хеш-индекса применяются классы операторов int4_ops),
но все такие классы являются независимыми и должны определяться отдельно.
38.15.2. Стратегии методов индексов
Операторам, которые связываются с классом операторов, назначаются «номера стратегий», опре-
деляющие роль каждого оператора в контексте его класса. Например, в B-дереве должен быть
строгий порядок ключей с отношениями меньше/больше, так что в данном контексте представля-
1053Расширение SQL
ют интерес операторы «меньше» и «больше или равно». Так как PostgreSQL позволяет пользова-
телям определять операторы произвольным образом, PostgreSQL не может просто посмотреть на
имя оператора (&lt; или &gt;=) и сказать, какое сравнение он выполняет. Вместо этого для метода ин-
декса определяется набор «стратегий», которые можно считать обобщёнными операторами. Каж-
дый класс операторов устанавливает, какие фактические операторы соответствуют стратегиям
для определённого типа данных и интерпретации семантики индекса.
Для метода индекса-B-дерева определены пять стратегий, описанных в Таблице 38.2.
Таблица 38.2. Стратегии B-дерева
Операция Номер стратегии
меньше 1
меньше или равно 2
равно 3
больше или равно 4
больше 5
Индексы по хешу поддерживают только сравнение на равенство, так что они используют только
одну стратегию, показанную в Таблице 38.3.
Таблица 38.3. Стратегии хеша
Операция Номер стратегии
равно 1
Индексы GiST более гибкие: для них вообще нет фиксированного набора стратегий. Вместо этого
опорная процедура «согласованности» каждого конкретного класса операторов GiST интерпрети-
рует номера стратегий как ей угодно. Например, некоторые из встроенных классов операторов
для индексов GiST индексируют двумерные геометрические объекты, и реализуют стратегии «R-
дерева», показанные в Таблице 38.4. Четыре из них являются истинно двумерными проверками
(overlaps, same, contains, contained by); другие четыре учитывают только ординаты, а ещё четыре
проводят же проверки только с абсциссами.
Таблица 38.4. Стратегии двумерного «R-дерева» индекса GiST
Операция Номер стратегии
строго слева от 1
не простирается правее 2
пересекается с 3
не простирается левее 4
строго справа от 5
одинаковы 6
содержит 7
содержится в 8
не простирается выше 9
строго ниже 10
строго выше 11
не простирается ниже 12
Индексы SP-GiST такие же гибкие, как и индексы GiST: для них не задаётся фиксированный набор
стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера
стратегий в соответствии с определением класса операторов. В качестве примера, в Таблице 38.5
приведены номера стратегий, установленные для встроенных классов операторов для точек.
1054Расширение SQL
Таблица 38.5. Стратегии SP-GiST для точек
Операция Номер стратегии
строго слева от 1
строго справа от 5
одинаковы 6
содержится в 8
строго ниже 10
строго выше 11
Индексы GIN такие же гибкие, как и индексы GiST и SP-GiST: для них не задаётся фиксированный
набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют
номера стратегий в соответствии с определением класса операторов. В качестве примера, в Таб-
лице  38.6 приведены номера стратегий, установленные для встроенного класса операторов для
массивов.
Таблица 38.6. Стратегии GIN для массивов
Операция Номер стратегии
пересекается с 1
содержит 2
содержится в 3
равно 4
Индексы BRIN такие же гибкие, как и индексы GiST, SP-GiST и GIN: для них не задаётся фиксиро-
ванный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпре-
тируют номера стратегий в соответствии с определением класса операторов. В качестве приме-
ра, в Таблице 38.7 приведены номера стратегий, используемые встроенными классами операторов
Minmax.
Таблица 38.7. Стратегии BRIN Minmax
Операция Номер стратегии
меньше 1
меньше или равно 2
равно 3
больше или равно 4
больше 5
Заметьте, что все вышеперечисленные операторы возвращают булевы значения. На практике все
операторы, определённые как операторы поиска для метода индекса, должны возвращать тип
boolean, так как они должны находиться на верхнем уровне предложения WHERE, чтобы для них
применялся индекс. (Некоторые методы доступа по индексу также поддерживают операторы
упорядочивания, которые обычно не возвращают булевы значения; это обсуждается в Подразде-
ле 38.15.7.)
38.15.3. Опорные процедуры метода индекса
Стратегии обычно не дают системе достаточно информации, чтобы понять, как использовать ин-
декс. На практике, чтобы методы индекса работали, необходимы дополнительные опорные проце-
дуры. Например, метод индекса-B-дерева должен уметь сравнивать два ключа и определять, боль-
ше, равен или меньше ли первый второго. Аналогично, метод индекса по хешу должен уметь срав-
нивать хеш-коды значений ключа. Эти операции не соответствуют операторам, которые применя-
ются в условиях в командах SQL; это внутрисистемные подпрограммы, используемые методами
индекса.
1055Расширение SQL
Так же, как и со стратегиями, класс операторов определяет, какие конкретные функции должны
играть каждую из ролей для определённого типа данных и интерпретации семантики индекса.
Для метода индекса определяется набор нужных ему функций, а класс оператора выбирает нуж-
ные функции для применения, назначая им «номера опорных функций», определяемые методом
индекса.
Для B-деревьев требуется опорная функция сравнения и могут предоставляться две дополнитель-
ные опорные функции по выбору разработчика класса операторов, описанные в Таблице 38.8. Тре-
бования к этим опорным функциям подробно рассматриваются в Разделе 63.3.
Таблица 38.8. Опорные функции B-деревьев
Функция
Номер опорной функции
Сравнивает два ключа и возвращает целое мень- 1
ше нуля, ноль или целое больше нуля, показыва-
ющее, что первый ключ меньше, равен или боль-
ше второго
Возвращает адреса вызываемых из C опорных 2
функций (или функции) сортировки (необяза-
тельная)
Сравнивает проверяемое значение с базовым 3
плюс/минус смещение и возвращает true или
false в зависимости от результата сравнения (
необязательная)
Для хеш-индексов требуется одна опорная функция, и ещё одна может задаваться по выбору раз-
работчика класса операторов, как показано в Таблице 38.9.
Таблица 38.9. Опорные функции хеша
Функция
Номер опорной функции
Вычисляет 32-битное значение хеша для ключа 1
Вычисляет 64-битное значение хеша для ключа 2
с заданной 64-битной солью; если значение со-
ли равно 0, младшие 32 бита результата должны
соответствовать значению, которое было бы вы-
числено функцией 1 (необязательная)
Для индексов GiST требуются девять опорных функций, две из которых необязательны; они опи-
саны в Таблице 38.10. (За дополнительными сведениями обратитесь к Главе 64.)
Таблица 38.10. Опорные функции GiST
Функция Описание
Номер опорной функции
consistent определяет, удовлетворяет ли 1
ключ условию запроса
union вычисляет объединение набора 2
ключей
compress вычисляет сжатое представле- 3
ние ключа или индексируемого
значения
decompress вычисляет развёрнутое пред- 4
ставление сжатого ключа
penalty вычисляет стоимость добавле- 5
ния нового ключа в поддерево с
заданным ключом
1056Расширение SQL
Функция Описание
Номер опорной функции
picksplit определяет, какие записи стра- 6
ницы должны быть перемещены
в новую страницу, и вычисляет
ключи объединения для резуль-
тирующих страниц
equal сравнивает два ключа и возвра- 7
щает true, если они равны
distance определяет дистанцию от клю- 8
ча до искомого значения (
необязательная)
fetch вычисляет исходное представ- 9
ление сжатого ключа для ска-
нирования только по индексу (
необязательная)
Для индексов SP-GiST требуются пять опорных функций, описанных в Таблице 38.11. (За дополни-
тельными сведениями обратитесь к Главе 65.)
Таблица 38.11. Опорные функции SP-GiST
Функция Описание
Номер опорной функции
config предоставляет основную ин- 1
формацию о классе операторов
choose определяет, как вставить новое 2
значение во внутренний эле-
мент
picksplit определяет, как разделить мно- 3
жество значений
inner_consistent определяет, в каких внутренних 4
ветвях нужно искать заданное
значение
leaf_consistent определяет, удовлетворяет ли 5
ключ условию запроса
Для индексов GIN требуются шесть опорных функций, три из которых необязательны; они описаны
в Таблице 38.12. (За дополнительными сведениями обратитесь к Главе 66.)
Таблица 38.12. Опорные функции GIN
Функция Описание
Номер опорной функции
compare сравнивает два ключа и возвра- 1
щает целое меньше нуля, ноль
или целое больше нуля, показы-
вающее, что первый ключ мень-
ше, равен или больше второго
extractValue извлекает ключи из индексиру- 2
емого значения
extractQuery извлекает ключи из условия за- 3
проса
consistent определяет, соответствует ли 4
значение условию запроса (бу-
левская вариация) (не требует-
ся, если присутствует опорная
функция 6)
1057Расширение SQL
Функция Описание
Номер опорной функции
comparePartial сравнивает частичный ключ из 5
запроса с ключом из индекса и
возвращает целое число мень-
ше нуля, ноль или больше нуля,
показывающее, что GIN должен
игнорировать эту запись индек-
са, принять её как соответству-
ющую или прекратить скани-
рование индекса (необязатель-
ная)
triConsistent определяет, соответствует ли 6
значение условию запроса (тро-
ичная вариация) (не требует-
ся, если присутствует опорная
функция 4)
Для индексов BRIN требуются четыре базовые опорные функции, перечисленные в Таблице 38.13;
для этих базовых функций может потребоваться предоставить дополнительные опорные функции.
(За дополнительными сведениями обратитесь к Разделу 67.3.)
Таблица 38.13. Опорные функции BRIN
Функция Описание
Номер опорной функции
opcInfo возвращает внутреннюю инфор- 1
мацию, описывающую сводные
данные по индексированным
столбцам
add_value добавляет новое значение в су- 2
ществующий сводный кортеж
индекса
consistent определяет, удовлетворяет ли 3
значение условию запроса
union вычисляет объединение
обобщающих кортежей
двух 4
В отличие от операторов поиска, опорные функции возвращают тот тип данных, который ожидает
конкретный метод индекса; например, функция сравнения для B-деревьев возвращает знаковое
целое. Количество и типы аргументов для каждой опорной функции так же зависят от метода
индекса. Для методов B-дерева и хеша функции сравнения и хеширования принимают те же типы
данных, что и операторы, включённые в класс операторов, но для большинства опорных функций
GiST, SP-GiST, GIN и BRIN это не так.
38.15.4. Пример
Теперь, когда мы познакомились с основными идеями, мы можем перейти к обещанному примеру
создания нового класса операторов. (Рабочую копию этого примера можно найти в src/tutorial/
complex.c и src/tutorial/complex.sql в пакете исходного кода.) Класс операторов включает опе-
раторы, сортирующие комплексные числа по порядку абсолютных значений, поэтому мы выбрали
для него имя complex_abs_ops. Во-первых, нам понадобится набор операторов. Процедура опреде-
ления операторов была рассмотрена в Разделе 38.13. Для класса операторов B-деревьев нам по-
надобятся операторы:
•
•
•
•
•
абсолютное-значение
абсолютное-значение
абсолютное-значение
абсолютное-значение
абсолютное-значение
меньше (стратегия 1)
меньше-или-равно (стратегия 2)
равно (стратегия 3)
больше-или-равно (стратегия 4)
больше (стратегия 5)
1058Расширение SQL
Чтобы не провоцировать ошибки при определении связанного набора операторов сравнения, луч-
ше всего сначала написать вспомогательную функцию сравнения для B-дерева, а затем написать
другие функции как однострочные оболочки этой вспомогательной функции. Это уменьшит веро-
ятность получения несогласованных результатов в исключительных случаях. Следуя этому подхо-
ду, мы сначала напишем:
#define Mag(c)
((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)
static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
double
amag = Mag(a),
bmag = Mag(b);
if (amag &lt;
return
if (amag &gt;
return
return 0;
bmag)
-1;
bmag)
1;
}
Теперь функция «меньше» будет выглядеть так:
PG_FUNCTION_INFO_V1(complex_abs_lt);
Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
Complex
*a = (Complex *) PG_GETARG_POINTER(0);
Complex
*b = (Complex *) PG_GETARG_POINTER(1);
PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}
Остальные четыре функции отличаются от неё только тем, как сравнивают результат внутренней
функции с нулём.
Затем мы объявим в SQL функции и операторы на основе этих функций:
CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
AS 'имя_файла', 'complex_abs_lt'
LANGUAGE C IMMUTABLE STRICT;
CREATE OPERATOR &lt; (
leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
commutator = &gt; , negator = &gt;= ,
restrict = scalarltsel, join = scalarltjoinsel
);
Важно правильно определить обратные и коммутирующие операторы, а также подходящие функ-
ции избирательности ограничения и соединения; иначе оптимизатор не сможет использовать наш
индекс эффективно.
Здесь также стоит обратить внимание на следующее:
• Учтите, что может быть только один оператор с именем, например, =, который будет прини-
мать тип complex с двух сторон. В этом случае у нас не будет другого оператора = для complex,
но если мы создаём практически полезный тип данных, вероятно, мы захотим, чтобы опера-
тор = проверял обычное равенство двух комплексных чисел (а не равенство их абсолютных
значений). В этом случае, для complex_abs_eq нужно выбрать какое-то другое имя оператора.
1059Расширение SQL
• Хотя в PostgreSQL разные функции могут иметь одинаковые имена SQL, если у них различные
типы аргументов, в C только одна глобальная функция может иметь заданное имя. Поэтому не
следует давать функции на C имя вроде abs_eq. Во избежание конфликтов с функциями для
других типов данных, в имя функции на C обычно включается имя конкретного типа данных.
• Мы могли быть дать нашей функции имя abs_eq в SQL, рассчитывая на то, что PostgreSQL от-
личит её от любых других одноимённых функций SQL по типам аргументов. Но в данном слу-
чае для упрощения примера мы дали ей одинаковые имена на уровне C и уровне SQL.
На следующем этапе регистрируется опорная процедура, необходимая для B-деревьев. В нашем
примере код C, реализующий её, находится в том же файле, что и функции операторов. Мы объ-
являем эту процедуру так:
CREATE FUNCTION complex_abs_cmp(complex, complex)
RETURNS integer
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
Теперь, когда мы объявили требуемые операторы и опорную функцию, мы наконец можем создать
класс операторов:
CREATE OPERATOR CLASS complex_abs_ops
DEFAULT FOR TYPE complex USING btree AS
OPERATOR
1
&lt; ,
OPERATOR
2
&lt;= ,
OPERATOR
3
= ,
OPERATOR
4
&gt;= ,
OPERATOR
5
&gt; ,
FUNCTION
1
complex_abs_cmp(complex, complex);
Вот и всё! Теперь должно быть возможно создавать и использовать индексы-B-деревья по столбцам
complex.
Операторы можно было записать более многословно, например, так:
OPERATOR
1
&lt; (complex, complex) ,
но в этом необходимости, так как эти операторы принимают тот же тип данных, для которого
определяется класс операторов.
В приведённом примере предполагается, что этот класс операторов будет классом операторов B-
дерева по умолчанию для типа complex. Если вам это не нужно, просто опустите слово DEFAULT.
38.15.5. Семейства и классы операторов
До этого мы неявно полагали, что класс операторов работает только с одним типом данных. Хотя
в конкретном индексируемом столбце, определённо, может быть только один тип данных, часто
бывает полезно индексировать операции, сравнивающие значение столбца со значением другого
типа. Также, если в сочетании с классом операторов возможно применение оператора, работаю-
щего с двумя типами, для другого типа данных обычно тоже создаётся собственный класс. В таких
случаях полезно установить явную связь между связанными классами, так как это поможет пла-
нировщику оптимизировать SQL-запросы (особенно для классов операторов B-дерева, потому что
планировщик хорошо знает, как работать с ними).
Для удовлетворения этих потребностей в PostgreSQL введена концепция семейства операторов.
Семейство операторов содержит один или несколько классов операторов и может также содержать
индексируемые операторы и соответствующие опорные функции, принадлежащие к семейству в
целом, но не к какому-то одному классу в нём. Мы называем такую связь операторов и функций с
семейством «слабой», в отличие от обычной связи с определённым классом. Как правило, классы
содержат операторы с операндами одного типа, тогда как межтиповые операторы слабо связыва-
ются с семейством.
1060Расширение SQL
Все операторы и функции в семействе операторов должны иметь совместимую семантику; требо-
вания к совместимости устанавливаются методом индекса. Вы можете спросить, зачем в таком
случае вообще выделять конкретные подмножества семейства в виде классов операторов; и на са-
мом деле во многих случаях деление на классы не имеет значения, важно только связывание с се-
мейством. Смысл классов операторов в том, что они определяют, какая часть семейства необходи-
ма для поддержки некоторого индекса. Если существует индекс, использующий класс операторов,
этот класс нельзя будет удалить, не удалив индекс — но другие части семейства, а именно, дру-
гие классы операторов и слабосвязанные операторы, удалить можно. Таким образом, класс опера-
торов должен определяться так, чтобы он содержал минимальный набор операторов и функций,
обоснованно требующихся для работы с индексом по определённому типу данных, а связанные,
но не существенные операторы могут добавляться в качестве слабосвязанных членов в семейство
операторов.
В качестве примера, в PostgreSQL есть встроенное семейство операторов B-дерева integer_ops,
включающее классы операторов int8_ops, int4_ops и int2_ops для индексов по столбцам bigint
(int8), integer (int4) и smallint (int2), соответственно. В этом семействе также содержатся опе-
раторы межтипового сравнения, позволяющие сравнивать значения любых двух этих типов, так
что индексом по любому из этих типов можно пользоваться, выполняя сравнение с другим типом.
Это семейство можно представить такими определениями:
CREATE OPERATOR FAMILY integer_ops USING btree;
CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
-- standard int8 comparisons
OPERATOR 1 &lt; ,
OPERATOR 2 &lt;= ,
OPERATOR 3 = ,
OPERATOR 4 &gt;= ,
OPERATOR 5 &gt; ,
FUNCTION 1 btint8cmp(int8, int8) ,
FUNCTION 2 btint8sortsupport(internal) ,
FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ;
CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
-- standard int4 comparisons
OPERATOR 1 &lt; ,
OPERATOR 2 &lt;= ,
OPERATOR 3 = ,
OPERATOR 4 &gt;= ,
OPERATOR 5 &gt; ,
FUNCTION 1 btint4cmp(int4, int4) ,
FUNCTION 2 btint4sortsupport(internal) ,
FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ;
CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
-- standard int2 comparisons
OPERATOR 1 &lt; ,
OPERATOR 2 &lt;= ,
OPERATOR 3 = ,
OPERATOR 4 &gt;= ,
OPERATOR 5 &gt; ,
FUNCTION 1 btint2cmp(int2, int2) ,
FUNCTION 2 btint2sortsupport(internal) ,
FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ;
ALTER OPERATOR FAMILY integer_ops USING btree ADD
1061Расширение SQL
-- cross-type comparisons int8 vs int2
OPERATOR 1 &lt; (int8, int2) ,
OPERATOR 2 &lt;= (int8, int2) ,
OPERATOR 3 = (int8, int2) ,
OPERATOR 4 &gt;= (int8, int2) ,
OPERATOR 5 &gt; (int8, int2) ,
FUNCTION 1 btint82cmp(int8, int2) ,
-- cross-type comparisons int8 vs int4
OPERATOR 1 &lt; (int8, int4) ,
OPERATOR 2 &lt;= (int8, int4) ,
OPERATOR 3 = (int8, int4) ,
OPERATOR 4 &gt;= (int8, int4) ,
OPERATOR 5 &gt; (int8, int4) ,
FUNCTION 1 btint84cmp(int8, int4) ,
-- cross-type comparisons int4 vs int2
OPERATOR 1 &lt; (int4, int2) ,
OPERATOR 2 &lt;= (int4, int2) ,
OPERATOR 3 = (int4, int2) ,
OPERATOR 4 &gt;= (int4, int2) ,
OPERATOR 5 &gt; (int4, int2) ,
FUNCTION 1 btint42cmp(int4, int2) ,
-- cross-type comparisons int4 vs int8
OPERATOR 1 &lt; (int4, int8) ,
OPERATOR 2 &lt;= (int4, int8) ,
OPERATOR 3 = (int4, int8) ,
OPERATOR 4 &gt;= (int4, int8) ,
OPERATOR 5 &gt; (int4, int8) ,
FUNCTION 1 btint48cmp(int4, int8) ,
-- cross-type comparisons int2 vs int8
OPERATOR 1 &lt; (int2, int8) ,
OPERATOR 2 &lt;= (int2, int8) ,
OPERATOR 3 = (int2, int8) ,
OPERATOR 4 &gt;= (int2, int8) ,
OPERATOR 5 &gt; (int2, int8) ,
FUNCTION 1 btint28cmp(int2, int8) ,
-- cross-type comparisons int2 vs int4
OPERATOR 1 &lt; (int2, int4) ,
OPERATOR 2 &lt;= (int2, int4) ,
OPERATOR 3 = (int2, int4) ,
OPERATOR 4 &gt;= (int2, int4) ,
OPERATOR 5 &gt; (int2, int4) ,
FUNCTION 1 btint24cmp(int2, int4) ,
-- cross-type in_range functions
FUNCTION 3 in_range(int4, int4, int8,
FUNCTION 3 in_range(int4, int4, int2,
FUNCTION 3 in_range(int2, int2, int8,
FUNCTION 3 in_range(int2, int2, int4,
boolean,
boolean,
boolean,
boolean,
boolean)
boolean)
boolean)
boolean)
,
,
,
;
Заметьте, что в определении семейства «перегружаются» номера стратегий операторов и опорных
функций: каждый номер фигурирует в семействе неоднократно. Это допускается, если для каж-
дого экземпляра определённого номера задаются свои типы данных. Экземпляры, у которых оба
1062Расширение SQL
входных типа совпадают с входным типом класса операторов, являются первичными операторами
и опорными функциями для этого класса, и в большинстве случаев они должны объявляться в со-
ставе класса операторов, а не быть слабосвязанными членами семейства.
В семействе операторов B-дерева все операторы должны быть совместимыми в контексте сорти-
ровки; это подробно описано в Разделе  63.2. Для каждого оператора в семействе должна суще-
ствовать опорная функция, принимающая на вход те же два типа, что и оператор. Семейство ре-
комендуется делать полным, то есть включать в него все операторы для каждого сочетания типов
данных. В классы операторов следует включать только однотиповые операторы и опорные функ-
ции для определённого типа данных.
Чтобы создать семейство операторов хеширования для нескольких типов данных, необходимо со-
здать совместимые функции поддержки хеша для каждого типа данных, который будет поддержи-
вать семейство. Здесь под совместимостью понимается гарантия получения одного хеш-кода для
любых двух значений, которые операторы сравнения в этом семействе считают равными, даже ес-
ли они имеют разные типы. Обычно это сложно осуществить, когда типы имеют разное физическое
представление, но в некоторых случаях всё же возможно. Более того, преобразование значения
одного типа данных, представленного в семействе операторов, к другому типу, также представ-
ленному в этом семействе, путём неявного или двоичного сведения не должно менять значение
вычисляемого хеша. Заметьте, что единственная опорная функция задаётся для типа данных, а не
для оператора равенства. Семейство рекомендуется делать полным, то есть включить в него опе-
ратор равенства для всех сочетаний типов данных. В классы операторов следует включать только
однотиповый оператор равенства и опорную функция для определённого типа данных.
В индексах GiST, SP-GiST и GIN межтиповые операции явно не выражены. Множество поддержи-
ваемых операторов определяется только теми операциями, которые могут выполнять основные
опорные функции заданного класса операторов.
В BRIN требования зависят от инфраструктуры, предоставляющей классы операторов. Для клас-
сов операторов, построенных на инфраструктуре minmax, требуется то же поведение, что и для се-
мейств операторов B-дерева: все операторы в семействе должны поддерживать совместимый по-
рядок, а приведения не должны влиять на установленный порядок сортировки.
Примечание
До версии 8.3 в PostgreSQL не было понятия семейства операторов, поэтому любые
межтиповые операторы, предназначенные для применения с индексом, должны бы-
ли привязываться непосредственно к классу оператора индекса. Хотя этот подход по-
прежнему работает, он считается устаревшим, потому что он создаёт слишком много
зависимостей для индекса, а также потому, что планировщик может выполнять межти-
повые сравнения более эффективно, когда для обоих типов данных определены опера-
торы в одном семействе.
38.15.6. Системные зависимости от классов операторов
PostgreSQL использует классы операторов для наделения операторов такими свойствами, которые
могут быть полезны не только для индексов. Поэтому классы операторов могут быть полезны, даже
если вы не намерены индексировать столбцы со значениями определённого вами типа.
В частности, это касается SQL-конструкций ORDER BY и DISTINCT, для которых требуется сравни-
вать и упорядочивать значения. Чтобы эти конструкции работали с определённым пользователем
типом данных, PostgreSQL задействует класс операторов B-дерева по умолчанию для этого типа.
Член «равно» этого класса определяет, как система будет понимать равенство значений для GROUP
BY и DISTINCT, а порядок сортировки, задаваемый классом операторов, определяет порядок ORDER
BY по умолчанию.
Если класс операторов B-дерева по умолчанию для типа данных не определён, система будет ис-
кать класс операторов хеширования по умолчанию. Но так как подобный класс поддерживает толь-
ко равенство, с ним будет возможна только группировка, но не сортировка.
1063Расширение SQL
Если для типа не определён класс операторов по умолчанию, попытавшись использовать эти кон-
струкции SQL с данным типом, вы получите ошибку вида «не удалось найти оператор сортировки».
Примечание
До версии PostgreSQL 7.4, в операциях сортировки и группировки неявно использова-
лись операторы с именами =, &lt; и &gt;. С новым подходом, опирающимся на классы опера-
торов по умолчанию, система не делает никаких предположений о поведении опера-
торов по их именам.
Сортировка с нестандартным классом операторов B-дерева возможна, если указать в предложении
USING оператор «меньше или равно» в данном классе:
SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;
Также возможно выполнить сортировку в порядке по убыванию, если указать в USING оператор
«больше или равно».
Сравнение массивов пользовательских типов также производится в зависимости от семантики,
определённой классом операторов B-дерева. Если класс операторов B-дерева по умолчанию для
данного типа не определён, но имеется класс операторов хеширования, то будет поддерживаться
сравнение массивов, но не упорядочивание.
Ещё одна возможность языка SQL, которая требует дополнительных знаний о типе данных — это
указание RANGE смещение PRECEDING/FOLLOWING для оконных функций (см. Подраздел  4.2.8). Для
запроса вида
SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
FROM mytable;
недостаточно знать, как упорядочить x; база данных должна также понимать, как «вычесть 5» или
«прибавить 10» к значению x в текущей строке для определения рамок текущего окна. Сравнивать
результирующие границы со значениями x в других строках можно используя операторы сравне-
ния, предоставленные классом операторов B-дерева, которые задают упорядочивание ORDER BY, но
операторы сложения и вычитания не входят в этот класс операторов. Так какие же использовать в
этом случае? Жёстко зафиксировать операторы в коде было бы нежелательно, так как при различ-
ных порядках сортировки (с различными классами операторов B-дерева) поведение может менять-
ся. Поэтому класс операторов B-дерева позволяет задать опорную функцию in_range, осуществля-
ющую сложение и вычитание в соответствии с порядком сортировки. Опорных функций in_range
может быть даже несколько, если в качестве смещения в предложениях RANGE имеет смысл пере-
давать данные разных типов. Если в классе операторов B-дерева, связанном с указанным для окна
предложением ORDER BY, нет подходящей опорной функции in_range, то указание RANGE смещение
PRECEDING/FOLLOWING не поддерживается.
Также важно отметить, что оператор равенства, указанный в семействе операторов хеширования,
является кандидатом для применения при слиянии и агрегации по хешу, а также при связанной
оптимизации. Семейство операторов хеширования играет в данном случае определяющую роль,
так как именно в нём задаётся функция хеширования.
38.15.7. Операторы упорядочивания
Некоторые методы доступа индексов (в настоящее время только GiST) поддерживают концепцию
операторов упорядочивания. Операторы, которые мы обсуждали до этого, были операторами по-
иска. Оператором поиска называется такой оператор, для которого можно выполнить поиск по
индексу и найти все строки, удовлетворяющие условию WHERE индексированный_столбец оператор
константа. Заметьте, что при этом ничего не говорится о порядке, в котором будут возвращены
подходящие строки. Оператор упорядочивания, напротив, не ограничивает набор возвращаемых
строк, но определяет их порядок. С таким оператором, просканировав индекс, можно получить
строки в порядке, заданным указанием ORDER BY индексированный_столбец оператор константа.
1064Расширение SQL
Такое определение объясняется тем, что оно поддерживает поиск ближайшего соседа, если этот
оператор вычисляет расстояние. Например, запрос
SELECT * FROM places ORDER BY location &lt;-&gt; point '(101,456)' LIMIT 10;
находит десять ближайших к заданной точке мест. Индекс GiST по столбцу location может сделать
это эффективно, так как &lt;-&gt; — это оператор упорядочивания.
Тогда как операторы поиска должны возвращать булевские результаты, операторы упорядочива-
ния обычно возвращают другой тип, например, float или numeric для расстояний. Этот тип, как
правило, отличается от типа индексируемых данных. Чтобы избежать жёстко запрограммирован-
ных предположений о поведении различных типов данных, при объявлении оператора упорядо-
чивания должно указываться семейство операторов B-дерева, определяющее порядок сортировки
результирующего типа данных. Как было отмечено в предыдущем разделе, семейства операторов
B-дерева определяют понятие упорядочивания для PostgreSQL, так что такое объявление оказы-
вается естественным. Так как оператор &lt;-&gt; для точек возвращает float8, его можно включить в
команду создания класса операторов так:
OPERATOR 15
&lt;-&gt; (point, point) FOR ORDER BY float_ops
где float_ops — встроенное семейство операторов, включающее операции с float8. Это объявле-
ние означает, что индекс может возвращать строки в порядке увеличения значений оператора &lt;-&gt;.
38.15.8. Особенности классов операторов
Есть ещё две особенности классов операторов, которые мы до этого не обсуждали, в первую оче-
редь потому, что они не востребованы для наиболее часто применяемых методов индексов.
Обычно объявление оператора в качестве члена класса операторов (или семейства) означает, что
метод индекса может получить точно набор строк, который удовлетворяет условию WHERE с этим
оператором. Например, запрос:
SELECT * FROM table WHERE integer_column &lt; 4;
может быть удовлетворён в точности индексом-B-деревом по целочисленному столбцу. Но быва-
ют случаи, когда индекс полезен как приблизительный указатель на соответствующие строки. На-
пример, если индекс GiST хранит только прямоугольники, описанные вокруг геометрических объ-
ектов, он не может точно удовлетворить условие WHERE, которое проверяет пересечение не пря-
моугольных объектов, а например, многоугольников. Однако этот индекс можно применить, что-
бы найти объекты, для которых описанные вокруг прямоугольники пересекаются с прямоугольни-
ком, описанным вокруг целевого объекта, а затем провести точную проверку пересечения только
для найденных по индексу объектов. Если это имеет место, такой индекс называется «неточным»
для оператора. Для реализации поиска по неточному индексу метод индекса возвращает флаг
recheck (перепроверить), когда строка может действительно удовлетворять, а может не удовлетво-
рять условию запроса. Затем исполнитель запроса перепроверяет полученную строку по исход-
ному условию запроса и определяет, должна ли она выдаваться как действительно соответствую-
щая ему. Этот подход работает, если индекс гарантированно выдаёт все требуемые строки плюс,
возможно, дополнительные строки, которые можно исключить, вызвав первоначальный оператор.
Методы индексов, поддерживающие неточный поиск (в настоящее время, GiST, SP-GiST и GIN),
позволяют устанавливать флаг recheck опорным функциям отдельных классов операторов, так что
по сути это особенность класса операторов.
Вернёмся к ситуации, когда мы храним в индексе только прямоугольник, описанный вокруг слож-
ного объекта, такого как многоугольник. В этом случае нет большого смысла хранить в элементе
индекса весь многоугольник — мы можем с тем же успехом хранить более простой объект типа
box. Это отклонение выражается указанием STORAGE в команде CREATE OPERATOR CLASS, которое
записывается примерно так:
CREATE OPERATOR CLASS polygon_ops
DEFAULT FOR TYPE polygon USING gist AS
1065Расширение SQL
...
STORAGE box;
В настоящее время, только методы индексов GiST, GIN и BRIN позволяют задать в STORAGE тип,
отличный от типа данных столбца. В GiST преобразованием данных, связанным с использовани-
ем STORAGE, должны заниматься опорные процедуры compress и decompress. В GIN тип STORAGE
определяет тип значений «ключа», который обычно отличается от типа индексируемого столбца
— например, в классе операторов для столбцов с целочисленным массивом ключами могут быть
просто целые числа. За извлечение ключей из индексированных значений в GIN отвечают опор-
ные функции extractValue и extractQuery. BRIN похож на GIN: в нём тип STORAGE определяет тип
хранимых обобщённых значений, а опорные процедуры классов операторов отвечают за правиль-
ное прочтение этих значений.
38.16. Упаковывание связанных объектов в расшире-
ние
Полезное расширение PostgreSQL обычно включает несколько объектов SQL; например, с появле-
нием нового типа данных могут потребоваться новые функции, новые операторы и новые классы
операторов. Все эти объекты удобно собрать в один пакет, с тем чтобы упростить управление базой
данных. В PostgreSQL такие пакеты называются расширениями. Чтобы определить расширение,
вам понадобится как минимум файл скрипта с командами SQL, создающими объекты расширения,
и управляющий файл, в котором определяются несколько базовых свойств самого расширения.
Если расширение написано на C, в него обычно также включается файл разделяемой библиотеки,
содержащий скомпилированный код. Обеспечив наличие этих файлов, загрузить их в базу данных
можно простой командой CREATE EXTENSION.
Основное преимущество расширений по сравнению с обычным SQL-скриптом, загружающим мно-
жество «разрозненных» объектов в базу данных, состоит в том, что PostgreSQL будет понимать,
что объекты расширения связаны вместе. Вы можете удалить все объекты одной командой DROP
EXTENSION (разрабатывать отдельный скрипт «uninstall» не требуется). Ещё полезнее то, что ути-
лита pg_dump знает, что не нужно выгружать отдельные объекты, составляющие расширение —
вместо этого она просто включит в архивный файл команду CREATE EXTENSION. Это кардинально
упрощает миграцию на новую версию расширения, которая может содержать новые или другие
объекты по сравнению с предыдущей версией. Заметьте, однако, что при загрузке такого архива в
базу данных обязательно наличие скрипта, управляющего файла и других файлов расширения.
PostgreSQL не позволит удалить отдельный объект, содержащийся в расширении, кроме как при
удалении всего расширения. Также имейте в виду, что вы можете изменить определение объекта,
относящегося к расширению (например, командой CREATE OR REPLACE FUNCTION для функции), но
изменённое определение не будет выгружено утилитой pg_dump. Такие изменения обычно разум-
ны, только если они параллельно отражаются в файле скрипта расширения. (Для таблиц, содер-
жащих конфигурационные данные, предусмотрены специальные средства; см. Подраздел 38.16.4.)
В производственной среде обычно лучше создавать скрипт обновления расширения, который бу-
дет изменять относящиеся к расширению объекты.
Скрипт расширения может устанавливать права доступа для объектов, являющихся частью рас-
ширения, выполняя команды GRANT и REVOKE. Окончательный набор прав для каждого объекта (ес-
ли они заданы) будет сохранён в системном каталоге pg_init_privs. При использовании pg_dump
в выгружаемый скрипт будет выведена команда CREATE EXTENSION с последующими операторами
GRANT и REVOKE, которые установят права, имевшие место в момент выгрузки.
PostgreSQL в настоящее время не поддерживает скрипты расширений, выполняющие операторы
CREATE POLICY или SECURITY LABEL. Ожидается, что такие команды будут выполняться после того,
как расширение будет создано. Выгружая данные, pg_dump будет также включать в вывод все
политики RLS и метки безопасности.
Механизм расширений также предоставляет средства для поддержки дополнительных скриптов,
призванных изменять определение объектов SQL, содержащихся в расширении. Например, если
1066Расширение SQL
версия расширения 1.1, по сравнению с версией 1.0, добавляет одну функцию и изменяет тело
другой функции, автор расширения может предоставить скрипт обновления, который произведёт
именно эти два изменения. Затем, воспользовавшись командой ALTER EXTENSION UPDATE, можно
будет применить эти изменения и отследить, какая версия расширения фактически установлена
в заданной базе данных.
Типы SQL-объектов, которые могут быть членами расширения, перечислены в описании ALTER
EXTENSION. Не могут быть его членами, в частности, объекты уровня кластера, такие как базы
данных, роли и табличные пространства, так как расширение существует только в рамках одной
базы данных. (Скрипту расширения не запрещается создавать такие объекты, но если он сделает
это, они не будут считаться частью расширения.) Также заметьте, что несмотря на то, что таблица
может быть членом расширения, её подчинённые объекты, такие как индексы, непосредственны-
ми членами расширения считаться не будут. Ещё один важный момент — схемы могут принадле-
жать расширениям, но не наоборот; поэтому расширение имеет неполное имя и не существует
«внутри» какой-либо схемы. Однако объекты-члены расширения, будут относиться к схемам, если
это уместно для их типов. Сами расширения могут иметь, а могут не иметь основания владеть схе-
мами, к которым относятся объекты-члены расширения.
Если скрипт расширения создаёт какие-либо временные объекты (например, временные таблицы),
эти объекты будут считаться членами расширения до конца текущего сеанса, но удалятся автома-
тически в конце сеанса, как и должны временные объекты. Это является исключением из правила,
запрещающего удаление объектов-членов расширения без удаления всего расширения.
38.16.1. Определение объектов расширения
В широко распространяемых расширениях должны закладываться минимальные предположения
о базе данных, которую они занимают. В частности, пока не выполнена команда SET search_path
= pg_temp, можно считать, что каждое неполное имя может быть разрешено в объект, созданный
злонамеренным пользователем. Опасайтесь конструкций, явно зависящих от search_path: IN и
CASE выражение WHEN всегда выбирают оператор по пути поиска. Вместо них следует использовать
OPERATOR(схема.=) ANY и CASE WHEN выражение.
38.16.2. Файлы расширений
Команда CREATE EXTENSION задействует управляющий файл расширения, который должен на-
зываться по имени расширения, с суффиксом .control, и должен быть помещён в каталог сервера
SHAREDIR/extension. Должен быть также ещё минимум один SQL-скрипт, с именем, соответствую-
щим шаблону расширение--версия.sql (например, foo--1.0.sql для версии 1.0 расширения foo).
По умолчанию скрипт(ы) также помещается в каталог SHAREDIR/extension; но в управляющем
файле можно задать и другой каталог.
Формат управляющего файла расширения не отличается от формата postgresql.conf, а именно
представляет собой список присвоений имя_параметра = значение, по одному в строке. В нём также
допускаются пустые строки и комментарии, начинающиеся с #. Все значения, отличные от един-
ственного слова или числа, в нём должны заключаться в кавычки.
В управляющем файле могут устанавливаться следующие параметры:
directory (string)
Каталог, содержащий SQL-скрипт(ы) расширения. Если только не задан абсолютный путь, это
имя рассматривается относительно каталога сервера SHAREDIR. По умолчанию подразумевает-
ся указание directory = 'extension'.
default_version (string)
Версия расширения по умолчанию (та, которая будет установлена, если в CREATE EXTENSION не
будет указана никакая версия). Хотя этот параметр можно опустить, это приведёт к ошибке в
CREATE EXTENSION без явного указания VERSION, что вряд ли будет желаемым поведением.
1067Расширение SQL
comment (string)
Комментарий (произвольная строка) к расширению. Комментарий применяется при изначаль-
ном создании расширения, но не при обновлениях расширения (так как при этом мог бы за-
меняться комментарий, заданный пользователем). Комментарий расширения также можно за-
дать посредством команды COMMENT в файле скрипта.
encoding (string)
Кодировка символов, используемая в файлах скриптов. Её следует указать, если эти файлы
содержат символы не из набора ASCII. По умолчанию предполагается, что эти файлы содержат
текст в кодировке базы данных.
module_pathname (string)
Значение этого параметра будет подставляться вместо каждого вхождения MODULE_PATHNAME
в скриптах. Если этот параметр не задан, подстановка не производится. Обычно для этого па-
раметра устанавливается значение $libdir/имя_разделяемой_библиотеки, а затем в командах
CREATE FUNCTION для функций на языке C указывается MODULE_PATHNAME, чтобы в скриптах не
приходилось жёстко задавать имя разделяемой библиотеки.
requires (string)
Список имён расширений, от которых зависит данное, например, requires = 'foo, bar'. Эти
расширения должны быть уже установлены, прежде чем можно будет установить данное.
superuser (boolean)
Если этот параметр имеет значение true (по умолчанию), только суперпользователи смогут
создать это расширение или обновить его до новой версии. Если он равен false, для этого будет
достаточно прав, необходимых для выполнения команд в установочном скрипте или скрипте
обновления.
relocatable (boolean)
Расширение является перемещаемым, если относящиеся к нему объекты после создания рас-
ширения можно переместить в другую схему. По умолчанию подразумевается false, то есть
расширение не считается перемещаемым. Подробнее об этом рассказывается в Подразде-
ле 38.16.3.
schema (string)
Этот параметр может задаваться только для неперемещаемых расширений. Если он задан, рас-
ширение можно будет загрузить только в указанную схему и не в какую другую. Подробнее
об этом рассказывается ниже. Параметр schema учитывается только при изначальном созда-
нии расширения, но не при его обновлении. Подробнее об этом рассказывается в Подразде-
ле 38.16.3.
Помимо главного управляющего файла расширение.control, расширение может включать допол-
нительные управляющие файлы с именами вида расширение--версия.control. Если они присут-
ствуют, они должны находиться в том же каталоге, что и основной скрипт. Дополнительные управ-
ляющие файлы имеют тот же формат, что и основной. Любые параметры, заданные в дополни-
тельном управляющем файле, переопределяют параметры основного файла, когда выполняет-
ся установка этой версии расширения или обновление до неё. Однако параметры directory и
default_version в дополнительных управляющих файлах задать нельзя.
SQL-скрипты расширений могут содержать любые команды SQL, за исключением команд управ-
ления транзакциями (BEGIN, COMMIT и т. д.) и команд, которые не могут выполняться внутри бло-
ка транзакции (например, VACUUM). Это объясняется тем, что эти скрипты неявно выполняются в
блоке транзакции.
SQL-скрипты расширений также могут содержать строки, начинающиеся с \echo, и они будут иг-
норироваться (восприниматься как комментарии) механизмом расширений. Это часто использу-
1068Расширение SQL
ется для вывода ошибки в случае, если этот скрипт выполняется в psql, а не загружается командой
CREATE EXTENSION (см. пример скрипта в Подразделе 38.16.7). Если такое выполнение не предот-
вратить, пользователи могут случайно загрузить содержимое расширения как «разрозненные»
объекты, а не как собственно расширение, и получить состояние, которое довольно сложно испра-
вить.
Тогда как файлы скриптов могут содержать любые символы, допустимые в указанной кодировке,
управляющие файлы могут содержать только ASCII-символы, так как указать кодировку этих фай-
лов в PostgreSQL нет никакой возможности. На практике это представляет проблему, только если
вы хотите использовать символы не из набора ASCII в комментарии расширения. В таких случаях
рекомендуется не использовать параметр comment в управляющем файле, а вместо этого задать
комментарий командой COMMENT ON EXTENSION в файле скрипта.
38.16.3. Перемещаемость расширений
У пользователей часто возникает желание загрузить объекты, содержащиеся в расширении, в схе-
му, отличную от той, что выбрал автор расширения. Насколько это поддерживает расширение,
описывается одним из трёх уровней:
• Полностью перемещаемое расширение может быть перемещено в другую схему в любое вре-
мя, даже после того, как оно загружено в базу данных. Это осуществляется командой ALTER
EXTENSION SET SCHEMA, которая автоматически переименовывает все объекты-члены расшире-
ния, перенося их в новую схему. Обычно это возможно, только если в расширении нет ника-
ких внутренних предположений о том, в какой схеме находятся все его объекты. Кроме того,
все объекты расширения должны находиться в одной исходной схеме (за исключением объек-
тов, не принадлежащих схемам, как например, процедурные языки). Чтобы пометить расши-
рение как полностью перемещаемое, установите relocatable = true в его управляющем фай-
ле.
• Расширение может быть перемещаемым в момент установки, но не после. Обычно это имеет
место, когда скрипту расширения необходимо явно ссылаться на целевую схему, например,
устанавливая свойства search_path для функций SQL. Для такого расширения нужно задать
relocatable = false в его управляющем файле и обращаться к целевой схеме в скрипте по
псевдоимени @extschema@. Все вхождения этого псевдоимени будут заменены именем выбран-
ной целевой схемы перед выполнением скрипта. Пользователь может выбрать целевую схему
в указании SCHEMA команды CREATE EXTENSION.
• Если расширение вовсе не поддерживает перемещение, установите в его управляющем фай-
ле relocatable = false, и также задайте в параметре schema имя предполагаемой целевой
схемы. Это предотвратит использование указания SCHEMA команды CREATE EXTENSION, если
только оно задаёт не то же имя, что определёно в управляющем файле. Этот выбор обыч-
но необходим, если в расширении делаются внутренние предположения об именах схемы,
которые нельзя свести к использованию псевдоимени @extschema@. Механизм подстановки
@extschema@ будет работать и в этом случае, хотя польза от него будет ограниченной, так как
имя схемы определяется управляющим файлом.
В любом случае, при выполнении файла скрипта параметр search_path изначально будет указывать
на целевую схему; то есть, CREATE EXTENSION делает то же, что и:
SET LOCAL search_path TO @extschema@;
Это позволяет направить объекты, создаваемые скриптом, в целевую схему. Скрипт может изме-
нить search_path, если пожелает, но обычно это нежелательно. Параметр search_path восстанав-
ливает предыдущее значение по завершении CREATE EXTENSION.
Целевая схема определяется параметром schema (если он задан) в управляющем файле, либо указа-
нием SCHEMA команды CREATE EXTENSION (если оно присутствует), а в противном случае выбирается
текущая схема для создания объектов по умолчанию (первая указанная в параметре search_path
вызывающего). Когда используется параметр управляющего файла schema, целевая схема будет
создана, если она ещё не существует, но в двух других случаях она должна уже существовать.
1069Расширение SQL
Если в параметре requires в файле управления указаны какие-либо расширения, необходимые для
данного, их целевые схемы добавляются к начальному значению search_path. Благодаря этому,
их объекты видны для скрипта нового расширения.
Хотя неперемещаемое расширение может содержать объекты, распределяемые по нескольким
схемам, обычно желательно поместить все объекты, предназначенные для внешнего использова-
ния, в одну схему, назначенную целевой схемой расширения. Такой порядок будет хорошо согла-
совываться со значением search_path по умолчанию в процессе создания зависимых расширений.
38.16.4. Конфигурационные таблицы расширений
Некоторые расширения включают конфигурационные таблицы, содержащие данные, которые мо-
гут быть добавлены или изменены пользователем после установки расширения. Обычно, если таб-
лица является частью расширения, ни определение таблицы, ни её содержимое не будет выгру-
жаться утилитой pg_dump. Но это поведение нежелательно для конфигурационных таблиц — из-
менения, внесённые в них пользователем, должны выгружаться; в противном случае расширение
будет вести себя по-другому, когда будет загружено вновь.
Чтобы решить эту проблему, скрипт расширения может пометить созданную им таблицу или по-
следовательность как конфигурационное отношение, в результате чего pg_dump включит в выгру-
жаемые данные содержимое (но не определение) этой таблицы или последовательности. Для это-
го нужно вызвать функцию pg_extension_config_dump(regclass, text) после создания таблицы
или последовательности, например так:
CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;
SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');
Так можно пометить любое число таблиц или последовательностей, в том числе последовательно-
сти, связанные со столбцами serial или bigserial.
Когда второй аргумент pg_extension_config_dump — пустая строка, pg_dump выгружает всё со-
держимое таблицы. Обычно это правильно, только если после создания скриптом расширения эта
таблица изначально пуста. Если же в таблице оказывается смесь начальных данных и данных,
добавленных пользователем, во втором аргументе pg_extension_config_dump передаётся условие
WHERE, которое отфильтровывает данные, подлежащие выгрузке. Например, имея таблицу, создан-
ную таким образом:
CREATE TABLE my_config (key text, value text, standard_entry boolean);
SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
можно сделать так, чтобы поле standard_entry содержало true только для строк, создаваемых
скриптом расширения.
Для последовательностей второй аргумент функции pg_extension_config_dump не имеет значе-
ния.
В более сложных ситуациях, когда пользователи могут модифицировать и изначально существо-
вавшие строки, можно создать триггеры для конфигурационной таблицы, которые корректно по-
метят изменённые строки.
Условие фильтра, связанное с конфигурационной таблицей, можно изменить, повторно вызвав
pg_extension_config_dump. (Обычно это находит применение в скрипте обновления расширения.)
Единственный способ обозначить, что некоторая таблица более не является конфигурационной —
разорвать её связь с расширением командой ALTER EXTENSION ... DROP TABLE.
Заметьте, что отношения внешних ключей между таблицами определяют порядок, в котором эти
таблицы будет выгружать pg_dump. В частности, pg_dump попытается выгрузить сначала основ-
1070Расширение SQL
ную таблицу, а затем подчинённую. Так как отношения внешних ключей устанавливаются во вре-
мя выполнения CREATE EXTENSION (до загрузки данных в таблицы), циклические зависимости
не поддерживаются. Когда образуются циклические зависимости, данные, тем не менее, будут
выгружены, но полученный архив нельзя будет восстановить обычным образом, потребуется вме-
шательство пользователя.
Последовательности, связанные со столбцами serial или bigserial, не обязательно помечать
непосредственно, чтобы их состояние было сохранено. Для этой цели достаточно пометить только
их родительское отношение.
38.16.5. Обновление расширений
Один из плюсов механизма расширений заключается в том, что он предоставляет удобные спо-
собы управления обновлениями SQL-команд, определяющих объекты расширения. В частности,
каждой выпускаемой версии установочного скрипта расширения назначается имя или номер вер-
сии. Кроме того, если вы хотите, чтобы пользователи могли динамически обновлять одну вер-
сию расширения до другой, вы должны предоставить скрипты обновления, которые внесут необ-
ходимые изменения для перехода от старой версии к новой. Скриптам обновлений назначают-
ся имена, соответствующие шаблону расширение--старая_версия--новая_версия.sql (например,
foo--1.0--1.1.sql будет содержать команды, меняющие версию 1.0 расширения foo на версию
1.1).
С условием, что имеется подходящий скрипт расширения, команда ALTER EXTENSION UPDATE об-
новит установленное расширение до указанной новой версии. Скрипт обновления запускается в
том же окружении, которое организует команда CREATE EXTENSION для установочных скриптов: в
частности, search_path устанавливается таким же образом, а любые новые объекты, созданные
скриптом, автоматически добавляются в расширение. И если скрипт решит удалить объекты-чле-
ны расширения, они будут автоматически исключены из его состава.
Если у расширения есть дополнительные управляющие файлы, для скрипта обновления применя-
ются те параметры, которые связаны с целевой (новой) версией скрипта.
Механизм обновления может использоваться для решения важной особой задачи: преобразование
«разрозненной» коллекции объектов в расширение. До того как механизм расширений появился
в PostgreSQL (в версии 9.1), многие писали модули разрешений, которые просто создавали мно-
жество неупакованных объектов. Но если у нас уже есть база данных с такими объектами, как их
можно преобразовать в правильно упакованное расширение? Один из вариантов — удалить их и
затем выполнить простую команду CREATE EXTENSION, но это нежелательно, если у объектов есть
зависимости (например, если в таблицах есть столбцы типа данных, созданного расширением).
Чтобы исправить эту ситуацию, можно создать пустое расширение, затем с помощью команды
ALTER EXTENSION ADD добавить в него каждый существующий объект, и наконец, создать все новые
объекты, которые есть в текущей версии расширения, но отсутствуют в неупакованном вариан-
те. CREATE EXTENSION поддерживает этот сценарий предложением FROM старая_версия, с которым
она не будет запускать обычный установочный скрипт для целевой версии, а запустит вместо это-
го скрипт обновления с именем расширение--старая_версия--новая_версия.sql. В качестве име-
ни старая_версия автор расширения может выбрать любое фиктивное имя, но обычно задаётся
unpackaged. Если у вас несколько предыдущих версий, которые нужно привести к стилю расшире-
ния, выберите разные фиктивные имена версий, чтобы различить их.
ALTER EXTENSION также может выполнять последовательности скриптов обновления для по-
лучения запрошенной версии. Например, если имеются только скрипты foo--1.0--1.1.sql и
foo--1.1--2.0.sql, ALTER EXTENSION будет применять их по порядку, если при установленной вер-
сии 1.0 запрошено обновлении до версии 2.0.
PostgreSQL не делает никаких предположений о свойствах имён версий: например, он не знает,
следует ли версия 1.1 за 1.0. Он просто сопоставляет имена имеющихся версий и следует пути,
который требует применить как можно меньше скриптов обновлений. (Именем версии на самом
деле может быть любая строка, которая не содержит -- и при этом не начинается и не заканчи-
вается символом -.)
1071Расширение SQL
Иногда бывают полезны скрипты «понижения версии», например, foo--1.1--1.0.sql, которые
позволяют откатить изменения, связанные с версией 1.1. Если вы применяете их, учтите, что есть
вероятность неожиданного выполнения такого скрипта, если он окажется в кратчайшем пути. Рис-
кованная ситуация возникает при наличии скрипта обновления по «короткому пути», который пе-
репрыгивает через несколько версий, и скрипта понижения версии до начальной точки первого
скрипта. В результате может получиться так, что понижение версии с последующим обновлением
по короткому пути окажется на несколько шагов короче, чем последовательное повышение вер-
сии. Если скрипт понижения версии удаляет какие-либо незаменимые объекты, это может приве-
сти к нежелательным результатам.
Чтобы убедиться, что при обновлении не будет выбран нежелательный путь, воспользуйтесь этой
командой:
SELECT * FROM pg_extension_update_paths('имя_расширения');
Она показывает каждую пару различных известных имён версий для указанного расшире-
ния, вместе с последовательностью обновления, которая будет выбрана для перехода от од-
ной версии к другой, либо NULL, если путь обновления не находится. Путь выводится в тексто-
вом виде с разделителями --. Если вы предпочитаете формат массива, вы можете применить
regexp_split_to_array(path,'--').
38.16.6. Установка расширений скриптами обновления
Расширение, существующее некоторое время, вероятно, будет иметь несколько версий, для ко-
торых автору надо будет писать скрипты обновления. Например, если вы выпустили расшире-
ние foo версий 1.0, 1.1 и 1.2, у вас должны быть скрипты обновления foo--1.0--1.1.sql и
foo--1.1--1.2.sql. До PostgreSQL версии 10 необходимо было также создавать файлы скриптов
foo--1.1.sql и foo--1.2.sql, которые устанавливают непосредственно новые версии скриптов; в
противном случае их можно было установить, только установив 1.0 и произведя обновление. Это
было утомительно и неэффективно, но теперь такой необходимости нет, так как команда CREATE
EXTENSION может сама построить цепочку обновлений. Например, если имеются только файлы
скриптов foo--1.0.sql, foo--1.0--1.1.sql и foo--1.1--1.2.sql, то запрос на установку версии
1.2 удовлетворяется запуском этих трёх скриптов по очереди. Это не будет отличаться от установ-
ки версии 1.0 с последующим обновлением до 1.2. (Как и с командой ALTER EXTENSION UPDATE,
при наличии нескольких путей выбирается самый короткий.) Организация скриптов расширения
по такой схеме может упростить сопровождение небольших обновлений.
Если вы используете дополнительные (ориентированные на версию) управляющие файлы для рас-
ширения, поддерживаемого по такой схеме, имейте в виду, что управляющий файл нужен для
каждой версии, даже если для неё нет отдельного скрипта установки, так как этот файл бу-
дет определять, как произвести неявное обновление до этой версии. Например, если в файле
foo--1.0.control задаётся requires = 'bar', а в других управляющих файлах foo — нет, зависи-
мость расширения от bar будет удалена при обновлении с версии 1.0 до другой.
38.16.7. Пример расширения
Здесь представлен полный пример расширения, в котором средствами исключительно SQL реа-
лизуется составной тип с двумя элементами, который может сохранить в своих слотах значения
любого типа, названные «k» и «v». Для хранения все значения переводятся в текстовый формат
(если они имеют другой формат).
Файл скрипта pair--1.0.sql выглядит так:
-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit
CREATE TYPE pair AS ( k text, v text );
CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';
1072Расширение SQL
CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);
-- "SET search_path" is easy to get right, but qualified names perform better.
CREATE OR REPLACE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;
CREATE OR REPLACE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
$1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';
Управляющий файл pair.control выглядит так:
# расширение pair
comment = 'Тип данных для пары ключ/значение'
default_version = '1.0'
relocatable = false
Хотя вам вряд ли понадобится сборочный файл, только для того, чтобы установить эти два файла
в нужный каталог, вы можете использовать Makefile следующего содержания:
EXTENSION = pair
DATA = pair--1.0.sql
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
Этот Makefile опирается на инфраструктуру PGXS, которая описывается в Разделе  38.17. С ним
команда make install установит управляющий файл и скрипт в правильный каталог, который
определит pg_config.
Когда эти файлы будут установлены, выполните команду CREATE EXTENSION, чтобы загрузить
объекты в определённую базу данных.
38.17. Инфраструктура сборки расширений
Если вы задумываетесь о распространении ваших модулей расширения PostgreSQL, знайте, что ор-
ганизовать для них портируемую систему сборки может быть довольно сложно. Поэтому инсталля-
ция PostgreSQL включает инфраструктуру сборки расширений, названную PGXS, так что неслож-
ные модули расширений можно собрать просто в среде установленного сервера. PGXS предназна-
чена в первую очередь для расширений, написанных на C, хотя её можно применять и для рас-
ширения на чистом SQL. Заметьте, что PGXS не претендует на роль универсальной инфраструк-
туры сборки, способной собрать любой программный объект, взаимодействующий с PostgreSQL;
она просто автоматизирует общие правила для сборки простых модулей расширения сервера. Для
более сложных пакетов вам придётся разработать собственную систему сборки.
Чтобы использовать инфраструктуру PGXS для вашего расширения, вы должны написать простой
сборочный файл. В нём вы должны установить нужные переменные и подключить глобальный сбо-
рочный файл PGXS. Следующий пример собирает модуль расширения с именем isbn_issn, кото-
рый включает разделяемую библиотеку, написанную на C, управляющий файл расширения, SQL-
скрипт, текстовый файл документации и заголовочный файл (он нужен, только если другие модули
будут вызывать функции данного расширения напрямую, без использования SQL):
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
1073Расширение SQL
DOCS = README.isbn_issn
HEADERS_isbn_issn = isbn_issn.h
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
Последние три строки всегда должны быть такими. Выше в файле вы определяете переменные или
добавляете собственные правила для make.
Установите одну из этих трёх переменных, чтобы указать, что будет собрано:
MODULES
список объектов разделяемых библиотек, которые должны быть собраны из исходных файлов
с одной основой (суффиксы библиотек в этом списке не указываются)
MODULE_big
разделяемая библиотека, которая должна быть собрана из нескольких исходных файлов (объ-
ектные файлы перечисляются в OBJS)
PROGRAM
исполняемая программа, которая должна быть собрана (объектные файлы перечисляются в
OBJS)
Также можно установить следующие переменные:
EXTENSION
имена расширений(я); для каждого имени вы должны предоставить файл расширение.control,
который будет установлен в префикс/share/extension
MODULEDIR
подкаталог в каталоге префикс/share, в который должны устанавливаться файлы DATA и DOCS
(если не задан, подразумевается extension, если установлена переменная EXTENSION, или
contrib в противном случае)
DATA
произвольные файлы, которые должны быть установлены в префикс/share/$MODULEDIR
DATA_built
произвольные файлы, которые должны быть сначала собраны, а затем установлены в префикс/
share/$MODULEDIR
DATA_TSEARCH
произвольные файлы, которые должны быть установлены в префикс/share/tsearch_data
DOCS
произвольные файлы, которые должны быть установлены в префикс/doc/$MODULEDIR
HEADERS
HEADERS_built
Файлы, которые будут устанавливаться (и, возможно, собираться) в префикс/include/server/
$MODULEDIR/$MODULE_big.
В отличие от файлов DATA_built, файлы в HEADERS_built не удаляются при выполнении цели
clean; если вы хотите удалять их, добавьте их в EXTRA_CLEAN или напишите собственные пра-
вила для этого.
1074Расширение SQL
HEADERS_$MODULE
HEADERS_built_$MODULE
Файлы, которые будут устанавливаться (если требуется, после сборки) в префикс/include/
server/$MODULEDIR/$MODULE, где в качестве $MODULE должно задаваться имя модуля, фигуриру-
ющее в MODULES или MODULE_big.
В отличие от файлов DATA_built, файлы в HEADERS_built_$MODULE не удаляются при выполне-
нии цели clean; если вы хотите удалять их, добавьте их в EXTRA_CLEAN или напишите собствен-
ные правила для этого.
Для одного модуля вполне можно использовать обе переменные в любом сочетании, если
только в вашем списке MODULES не присутствуют два имени, отличающиеся только префиксом
built_, что приводит к неоднозначности. В этом (очень маловероятном) случае следует исполь-
зовать только переменные HEADERS_built_$MODULE.
SCRIPTS
скрипты (не двоичные файлы), которые должны быть установлены в префикс/bin
SCRIPTS_built
скрипты (не двоичные файлы), которые должны быть сначала собраны, а затем установлены
в префикс/bin
REGRESS
список тестов регрессий (без суффикса), см. ниже
REGRESS_OPTS
дополнительные параметры, передаваемые pg_regress
NO_INSTALLCHECK
не определять цель installcheck; это полезно, если тестам требуется особая конфигурация
или pg_regress не используется
EXTRA_CLEAN
дополнительные файлы, которые должны быть удалены при make clean
PG_CPPFLAGS
флаги, добавляемые в CPPFLAGS
PG_LIBS
будет добавлено в строку компоновки PROGRAM
SHLIB_LINK
будет добавлено в строку компоновки MODULE_big
PG_CONFIG
путь к программе pg_config в инсталляции PostgreSQL, с которой будет выполняться сборка
(обычно указывается просто pg_config, и используется первый экземпляр, найденный по пути
в PATH)
Поместите этот сборочный файл под именем Makefile в каталог, где находится ваше расшире-
ние. После этого выполните make, чтобы скомпилировать, а затем make install, чтобы установить
ваш модуль. По умолчанию расширение компилируется и устанавливается для той инсталляции
PostgreSQL, которая соответствует экземпляру pg_config, найденному первым при поиске по пути
1075Расширение SQL
в PATH. Чтобы использовать другую инсталляцию, вы можете задать в PG_CONFIG путь к её экзем-
пляру pg_config либо внутри сборочного файла, либо в командном файле make.
Вы также можете запустить make в каталоге вне каталога исходного дерева вашего расширения,
если хотите отделить каталог сборки. Эта процедура называется сборкой с VPATH и выполняется
так:
mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install
Также вы можете подготовить каталог для сборки с VPATH таким же образом, как это делает-
ся в коде ядра сервера. Как один из вариантов, для этого можно воспользоваться скриптом ядра
config/prep_buildtree. Затем вы сможете выполнить сборку, установив переменную VPATH для
make таким образом:
make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install
Эта процедура поддерживает самые разные расположения каталогов.
Скрипты, перечисленные в переменной REGRESS, используются для тестирования регрессии в ва-
шем модуле, и вызвать их можно командой make installcheck после make install. Для проведе-
ния тестов необходим работающий сервер PostgreSQL. Файлы скриптов, перечисленные в REGRESS,
должны размещаться в подкаталоге sql/ каталога расширения. Эти файлы должны иметь рас-
ширение .sql, но указывать его в списке REGRESS в сборочном файле не нужно. Для каждого те-
ста также должен создаваться файл с ожидаемым выводом в подкаталоге expected/, с тем же ба-
зовым именем и расширением .out. Команда make installcheck выполнит каждый тест в psql
и сравнит полученный вывод с ожидаемым. Все выявленные различия будут записаны в файл
regression.diffs в формате команды diff -c. Заметьте, что при попытке запустить тест без файла
ожидаемого вывода этот тест будет отмечен как «проблемный», поэтому убедитесь, что все такие
файлы присутствуют.
Подсказка
Проще всего для этого создать пустые файлы ожидаемого вывода, а затем выполнить
тест (при этом конечно будут выявлены несоответствия). Изучите полученные файлы
результатов, сохранённые в каталоге results/, и, если они соответствуют вашим ожи-
даниям от теста, скопируйте их в expected/.
</string.h>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-037/" title="Глава 37. Информационная схема"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 37. Информационная схема"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-037/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~65 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-037/" rel="bookmark" title="Глава 37. Информационная схема" itemprop="url">Глава 37. Информационная схема</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 37. Информационная схема</p>

<p>Информационная схема состоит из набора представлений, содержащих информацию об объектах,
определённых в текущей базе данных. Информационная схема описана в стандарте SQL и поэтому
можно рассчитывать на её переносимость и стабильность — в отличие от системных каталогов,
которые привязаны к PostgreSQL, и моделируются, отталкиваясь от реализации. Представления
информационной схемы, однако, не содержат информацию о функциях, присущих исключительно
PostgreSQL; чтобы получить информацию о них, необходимо обратиться к системным каталогам
или другим специфическим представлениям PostgreSQL.
Примечание
Когда из базы данных запрашивается информация об ограничениях, возможна ситуа-
ция, когда соответствующий стандарту запрос, который должен возвращать одну стро-
ку, возвращает несколько. Это связано с тем, что стандарт SQL требует, чтобы имена
ограничений были уникальными в схеме, но в PostgreSQL такого требования нет. Име-
на ограничений, которые PostgreSQL генерирует автоматически, не должны дублиро-
ваться в одной схеме, но сами пользователи могут назначить подобные дублирующие-
ся имена.
Эта проблема может проявиться при обращении к таким представлениям ин-
формационной схемы, как check_constraint_routine_usage, check_constraints,
domain_constraints и referential_constraints. В некоторых других представле-
ниях она могла бы тоже иметь место, но они содержат имя таблицы, помо-
гающее различить дублирующиеся строки, например: constraint_column_usage,
constraint_table_usage, table_constraints.
37.1. Схема
Информационная схема сама по себе — это схема с именем information_schema. Данная схема
автоматически доступна во всех базах данных. Владельцем этой схемы является начальный поль-
зователь баз данных в кластере, и этот пользователь, естественно, имеет все права в ней, включая
возможность её удалить (хотя достигаемая при этом экономия пространства минимальна).
По умолчанию информационная схема отсутствует в пути поиска схем, так что ко всем объектам в
ней нужно обращаться по полным именам. Так как имена некоторых объектов в информационной
схеме довольно распространённые и могут встречаться и в пользовательских приложениях, будьте
осторожны, добавляя информационную схему в путь поиска.
37.2. Типы данных
Столбцы в представлениях информационной схемы имеют специальные типы данных, определён-
ные в информационной схеме. Они определены как простые домены поверх обычных встроенных
типов. Задействовать эти типы вне информационной схемы не следует, но тем не менее, приложе-
ния, выбирающие данные из информационной схеме должны быть готовы работать с ними.
Это следующие типы:
cardinal_number
Неотрицательное целое.
character_data
Строка символов (без определённого ограничения по длине).
sql_identifier
Строка символов. Этот тип применяется для идентификаторов SQL, тогда как тип
character_data для всех остальных видов текстовых данных.
939Информационная схема
time_stamp
Домен на базе типа timestamp with time zone
yes_or_no
Домен символьной строки, который принимает либо YES, либо NO. Этот домен применяется для
представления булевых данных (истина/ложь, true/false) в информационной схеме. (Информа-
ционная схема была введена до появления в стандарте SQL типа boolean, поэтому данный до-
мен необходим для сохранения обратной совместимости информационной схемы.)
Все столбцы в информационной схеме имеют один из этих пяти типов.
37.3. information_schema_catalog_name
Таблица information_schema_catalog_name всегда содержит одну строку и один столбец с именем
текущей базы данных (текущий каталог, в терминологии SQL).
Таблица 37.1. Столбцы information_schema_catalog_name
Имя Тип данных Описание
catalog_name sql_identifier Имя базы данных, содержащей
эту информационную схему
37.4. administrable_role_authorizations
Представление administrable_role_authorizations описывает все роли, для которых текущий
пользователь является администратором.
Таблица 37.2. Столбцы administrable_role_authorizations
Имя Тип данных Описание
grantee sql_identifier Имя роли, которой было разре-
шено участие в целевой роли (
может быть текущий пользова-
тель, либо другая роль, в случае
вложенного членства)
role_name sql_identifier Имя целевой роли
is_grantable yes_or_no Всегда YES
37.5. applicable_roles
Представление applicable_roles описывает все роли, права которых может использовать текущий
пользователь. Это означает, что существует некоторая цепочка ролей от текущего пользователя к
целевой роли. Роль самого пользователя также считается применимой. Набор применимых ролей
обычно используется для проверки разрешений.
Таблица 37.3. Столбцы applicable_roles
Имя Тип данных Описание
grantee sql_identifier Имя роли, которой было разре-
шено участие в целевой роли (
может быть текущий пользова-
тель, либо другая роль, в случае
вложенного членства)
role_name sql_identifier Имя целевой роли
is_grantable yes_or_no YES, если субъект является ад-
министратором для этой роли,
или NO в противном случае
940Информационная схема
37.6. attributes
Представление attributes содержит информацию об атрибутах составных типов данных, опреде-
лённых в базе. (Заметьте, что представление не даёт информацию о столбцах таблицы, которые
иногда называются атрибутами в контекстах PostgreSQL.) В нём показываются только те атрибу-
ты, к которым имеет доступ текущий пользователь (являясь владельцем или имея некоторое право
для использования типа).
Таблица 37.4. Столбцы attributes
Имя Тип данных Описание
udt_catalog sql_identifier Имя базы данных, содержащей
тип данных (всегда текущая ба-
за)
udt_schema sql_identifier Имя схемы, содержащей тип
данных
udt_name sql_identifier Имя типа данных
attribute_name sql_identifier Имя атрибута
ordinal_position cardinal_number Порядковый номер атрибута
внутри типа данных (нумерация
начинается с 1)
attribute_default character_data Выражение по умолчанию для
атрибута
is_nullable yes_or_no YES, если атрибут может содер-
жать NULL, или NO, если он не
принимает NULL
data_type character_data Тип данных атрибута, если это
встроенный тип, либо ARRAY,
если это массив (в этом слу-
чае обратитесь к представле-
нию element_types ), иначе —
USER-DEFINED (в этом случае
тип определяется в attribute_
udt_name
и связанных столб-
цах).
character_maximum_length cardinal_number Если в data_type указан тип
текстовой или битовой строки,
это поле задаёт её объявленную
максимальную длину; NULL для
всех других типов данных, ли-
бо если максимальная длина не
объявлена.
character_octet_length cardinal_number Если в data_type указан тип
символьной строки, это поле за-
даёт её максимально возмож-
ный размер в октетах (байтах);
NULL для всех других типов
данных. Максимальный размер
в октетах зависит от объявлен-
ной максимальной длины в сим-
волах (см. выше) и от кодировки
сервера.
941Информационная схема
Имя Тип данных Описание
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Имя базы данных, содержащей
правило сортировки атрибута (
это всегда текущая база), ли-
бо NULL, если это правило по
умолчанию или тип данных ат-
рибута несортируемый
collation_schema sql_identifier Имя схемы, содержащей пра-
вило сортировки атрибута, ли-
бо NULL, если это правило по
умолчанию или тип данных ат-
рибута несортируемый
collation_name sql_identifier Имя правила сортировки атри-
бута, либо NULL, если это пра-
вило по умолчанию или атрибут
несортируемый
numeric_precision cardinal_number Если в data_type указан чис-
ловой тип, этот столбец со-
держит точность (объявленную
или неявную) типа для этого
атрибута. Точность определя-
ет число значащих цифр. Она
может выражаться в десятич-
ных (по основанию 10) или дво-
ичных (по основанию 2) циф-
рах, согласно столбцу numeric_
precision_radix . Для всех
других типов данных этот стол-
бец содержит NULL.
numeric_precision_radix cardinal_number Если в data_type указан чис-
ловой тип, в этом столбце опре-
деляется, по какому основанию
задаются значения в столбцах
numeric_precision и numeric_
scale . Возможные варианты: 2
или 10. Для всех других типов
данных этот столбец содержит
NULL.
numeric_scale cardinal_number Если в data_type указан точ-
ный числовой тип, этот стол-
бец содержит масштаб (объяв-
ленный или неявный) типа для
этого атрибута. Масштаб опре-
деляет число значащих цифр
справа от десятичной точки. Он
942Информационная схема
Имя Тип данных Описание
может выражаться в десятич-
ных (по основанию 10) или дво-
ичных (по основанию 2) циф-
рах, согласно столбцу numeric_
precision_radix . Для всех
других типов данных этот стол-
бец содержит NULL.
datetime_precision cardinal_number Если в data_type указан тип
даты, времени, отметки време-
ни или интервала, этот стол-
бец содержит точность (объяв-
ленную или неявную) в долях
секунды типа этого атрибута,
то есть число десятичных цифр,
сохраняемых после десятичной
точки в значении секунд. Для
всех других типов данных этот
столбец содержит NULL.
interval_type character_data Если в data_type указан тип
интервала, этот столбец опреде-
ляет, какие поля принимает ин-
тервал в этом атрибуте, напри-
мер: YEAR TO MONTH, DAY TO
SECOND и т. д. Если ограничения
для полей не заданы (то есть,
интервал принимает все поля),
и для любых других типов дан-
ных это поле содержит NULL.
interval_precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL (см. поле datetime_
precision , определяющее точ-
ность в долях секунды для типов
интервалов)
attribute_udt_catalog sql_identifier Имя базы данных, в которой
определён тип данных атрибута
(всегда текущая база)
attribute_udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип данных атрибута
attribute_udt_name sql_identifier Имя типа данных атрибута
scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
maximum_cardinality cardinal_number Всегда NULL, так как массивы
имеют неограниченную макси-
мальную ёмкость в PostgreSQL
943Информационная схема
Имя Тип данных Описание
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных столбца, уникаль-
ный среди всех дескрипторов
типов, относящихся к таблице.
Он в основном полезен для со-
единения с другими экземпля-
рами таких идентификаторов. (
Конкретный формат идентифи-
катора не определён и не га-
рантируется, что он останется
неизменным в будущих верси-
ях.)
is_derived_reference_
attribute yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
Обратитесь также к описанию Раздел  37.16, представлению с похожей структурой, за дополни-
тельной информацией о некоторых столбцах.
37.7. character_sets
Представление character_sets описывает наборы символов, доступные в текущей базе данных.
Так как PostgreSQL не поддерживает несколько наборов символов в одной базе данных, этот набор
показывает только один набор, соответствующий кодировке базы.
Примите к сведению следующие термины, принятые в стандарте SQL:
совокупность символов
Абстрактная коллекция символов, например UNICODE, UCS или LATIN1. Не существует в виде
SQL-объекта, но показывается в этом представлении.
форма кодировки символов
Кодировка некоторой совокупности символов. Для большинства устаревших совокупностей ис-
пользуется только одна кодировка, так что эта кодировка не имеет отдельного имени (напри-
мер, LATIN1 — форма кодировки, применимая к совокупности LATIN1). Но например, Unicode
имеет формы кодировки UTF8, UTF16 и т. д. (не все они поддерживаются в PostgreSQL). Формы
кодировки не существуют в виде SQL-объектов, но показываются в этом представлении.
набор символов
Именованный SQL-объект, определяющий совокупность и кодировку символов, а также прави-
ло сортировки по умолчанию. Предопределённый набор символов обычно называется так же,
как форма кодировки, но пользователи могут определить другие имена. Например, набору сим-
волов UTF8 обычно соответствует совокупность символов UCS, форма кодировки UTF8 и некото-
рое правило сортировки по умолчанию.
Вы можете считать, что «кодировка» в PostgreSQL определяет набор или форму кодировки симво-
лов. Она имеет такое же имя и может быть только одной в определённой базе.
Таблица 37.5. Столбцы character_sets
Имя Тип данных Описание
character_set_catalog sql_identifier Наборы символов в настоящее
время не представлены в виде
объектов схемы, так что этот
столбец содержит NULL.
944Информационная схема
Имя Тип данных Описание
character_set_schema sql_identifier Наборы символов в настоящее
время не представлены в виде
объектов схемы, так что этот
столбец содержит NULL.
character_set_name sql_identifier Имя набора символов, в настоя-
щее время в качестве этого име-
ни показывается имя кодировки
базы данных
character_repertoire sql_identifier Совокупность символов — UCS
для кодировки UTF8, либо про-
сто имя кодировки
form_of_use sql_identifier Форма кодировки символов, то
же, что и кодировка базы дан-
ных
default_collate_catalog sql_identifier Имя базы данных, содержащей
правило сортировки по умолча-
нию (всегда текущая база, если
это правило установлено)
default_collate_schema sql_identifier Имя схемы, содержащей прави-
ло сортировки по умолчанию
default_collate_name sql_identifier Имя правила сортировки по
умолчанию. Правилом сорти-
ровки по умолчанию считается
правило, соответствующее па-
раметрам COLLATE и CTYPE теку-
щей базы данных. Если такого
правила нет, данный столбец и
связанные столбцы схемы и ка-
талога содержат NULL.
37.8. check_constraint_routine_usage
Представление check_constraint_routine_usage описывает подпрограммы (функции и процеду-
ры), участвующие в проверках ограничений. В нём показываются только те подпрограммы, кото-
рые принадлежат текущей активной роли.
Таблица 37.6. Столбцы check_constraint_routine_usage
Имя Тип данных Описание
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Подробнее оно описано в Разде-
ле 37.40.
945Информационная схема
37.9. check_constraints
Представление check_constraints показывает все ограничения-проверки, либо определённые для
таблицы или домена, либо принадлежащие текущей активной роли. (Владелец таблицы или домена
является владельцем ограничения.)
Таблица 37.7. Столбцы check_constraints
Имя Тип данных Описание
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
check_clause character_data Выражение проверки для огра-
ничения
37.10. collations
Представление collations показывает правила сортировки, доступные в текущей базе данных.
Таблица 37.8. Столбцы collations
Имя Тип данных Описание
collation_catalog sql_identifier Имя базы данных, содержащей
правило сортировки (всегда те-
кущая база)
collation_schema sql_identifier Имя схемы, содержащей прави-
ло сортировки
collation_name sql_identifier Имя правила сортировки
pad_attribute character_data Всегда NO PAD (Альтернативный
вариант PAD SPACE в PostgreSQL
не поддерживается.)
37.11. collation_character_set_applicability
Представление collation_character_set_applicability показывает, к каким наборам символов
применимы доступные правила сортировки. В PostgreSQL в базе данных может быть только один
набор символов (см. описание в Разделе 37.7), так что это представление даёт не так много полез-
ной информации.
Таблица 37.9. Столбцы collation_character_set_applicability
Имя Тип данных Описание
collation_catalog sql_identifier Имя базы данных, содержащей
правило сортировки (всегда те-
кущая база)
collation_schema sql_identifier Имя схемы, содержащей прави-
ло сортировки
collation_name sql_identifier Имя правила сортировки
character_set_catalog sql_identifier Наборы символов в настоящее
время не представлены в виде
объектов схемы, так что этот
столбец содержит NULL
946Информационная схема
Имя Тип данных Описание
character_set_schema sql_identifier Наборы символов в настоящее
время не представлены в виде
объектов схемы, так что этот
столбец содержит NULL
character_set_name sql_identifier Имя набора символов
37.12. column_domain_usage
Представление column_domain_usage описывает все столбцы (таблиц или представлений), которые
используют какие-либо домены, определённые в базе данных и принадлежащие текущей активной
роли.
Таблица 37.10. Столбцы column_domain_usage
Имя Тип данных Описание
domain_catalog sql_identifier Имя базы данных, содержащей
домен (всегда текущая база)
domain_schema sql_identifier Имя схемы, содержащей домен
domain_name sql_identifier Имя домена
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
column_name sql_identifier Имя столбца
37.13. column_options
Представление column_options показывает все параметры, определённые для столбцов сторонней
таблицы в текущей базе данных. В нём отражаются только те столбцы сторонних таблиц, к которым
имеет доступ текущий пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.11. Столбцы column_options
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
стороннюю таблицу (всегда те-
кущая база)
table_schema sql_identifier Имя схемы, содержащей сто-
роннюю таблицу
table_name sql_identifier Имя сторонней таблицы
column_name sql_identifier Имя столбца
option_name sql_identifier Имя параметра
option_value character_data Значение параметра
37.14. column_privileges
Представление column_privileges описывает все права, назначенные текущей активной роли или
текущей активной ролью для столбцов. Оно содержит отдельную строку для каждой комбинации
столбца, праводателя и правообладателя.
Если право даётся для всей таблицы, оно будет показываться как право для каждого столбца, но
только для типов прав, применимых к столбцам: SELECT, INSERT, UPDATE, REFERENCES.
947Информационная схема
Таблица 37.12. Столбцы column_privileges
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
table_catalog sql_identifier Имя базы данных, содержащей
таблицу с этим столбцом (все-
гда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу с этим столбцом
table_name sql_identifier Имя таблицы с этим столбцом
column_name sql_identifier Имя столбца
privilege_type character_data Тип права: SELECT, INSERT,
UPDATE или REFERENCES
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.15. column_udt_usage
Представление column_udt_usage описывает все столбцы, которые используют типы данных, при-
надлежащие текущей активной роли. Заметьте, что в PostgreSQL встроенные типы данных не от-
личаются от определённых пользователем, так что в этом представлении выводятся и они. За по-
дробностями обратитесь к Разделу 37.16.
Таблица 37.13. Столбцы column_udt_usage
Имя Тип данных Описание
udt_catalog sql_identifier Имя базы данных, в которой
определён тип (если примени-
мо, нижележащий тип домена)
столбца (всегда текущая база)
udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип (если применимо, ниже-
лежащий тип домена) столбца (
всегда текущая база)
udt_name sql_identifier Имя типа данных столбца (если
применимо, нижележащий тип
домена)
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
column_name sql_identifier Имя столбца
37.16. columns
Представление columns содержит информацию обо всех столбцах таблиц (или столбцах представ-
лений) в базе данных. Системные столбцы (oid и т. д.) в нём не отображаются. В нём показываются
948Информационная схема
только те столбцы, к которым имеет доступ текущий пользователь (являясь владельцем или имея
некоторые права).
Таблица 37.14. Столбцы columns
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
column_name sql_identifier Имя столбца
ordinal_position cardinal_number Порядковый номер столбца в
таблице (нумерация начинает-
ся с 1)
column_default character_data Выражение по умолчанию для
столбца
is_nullable yes_or_no YES, если столбец может содер-
жать NULL, или NO, если он не
принимает NULL. Не будет при-
нимать NULL столбец с ограни-
чением не-NULL, но возможны
и другие варианты.
data_type character_data Тип данных столбца, если это
встроенный тип, либо ARRAY,
если это массив (в этом слу-
чае обратитесь к представле-
нию element_types ), иначе —
USER-DEFINED (в этом случае тип
определяется в udt_name и свя-
занных столбцах). Если стол-
бец основан на домене, данный
столбец показывает нижележа-
щий тип домена (а сам домен
показывается в domain_name и
связанных столбцах).
character_maximum_length cardinal_number Если в data_type указан тип
текстовой или битовой строки,
это поле задаёт её объявленную
максимальную длину; NULL для
всех других типов данных, ли-
бо если максимальная длина не
объявлена.
character_octet_length cardinal_number Если в data_type указан тип
символьной строки, это поле за-
даёт её максимально возмож-
ный размер в октетах (байтах);
NULL для всех других типов
данных. Максимальный размер
в октетах зависит от объявлен-
ной максимальной длины в сим-
волах (см. выше) и от кодировки
сервера.
949Информационная схема
Имя Тип данных Описание
numeric_precision cardinal_number Если в data_type указан чис-
ловой тип, этот столбец со-
держит точность (объявленную
или неявную) типа для целево-
го столбца. Точность определя-
ет число значащих цифр. Она
может выражаться в десятич-
ных (по основанию 10) или дво-
ичных (по основанию 2) циф-
рах, согласно столбцу numeric_
precision_radix . Для всех
других типов данных этот стол-
бец содержит NULL.
numeric_precision_radix cardinal_number Если в data_type указан чис-
ловой тип, в этом столбце опре-
деляется, по какому основанию
задаются значения в столбцах
numeric_precision и numeric_
scale . Возможные варианты: 2
или 10. Для всех других типов
данных этот столбец содержит
NULL.
numeric_scale cardinal_number Если в data_type указан точ-
ный числовой тип, этот столбец
содержит масштаб (объявлен-
ный или неявный) типа для це-
левого столбца. Масштаб опре-
деляет число значащих цифр
справа от десятичной точки. Он
может выражаться в десятич-
ных (по основанию 10) или дво-
ичных (по основанию 2) циф-
рах, согласно столбцу numeric_
precision_radix . Для всех
других типов данных этот стол-
бец содержит NULL.
datetime_precision cardinal_number Если в data_type указан тип
даты, времени, отметки време-
ни или интервала, этот столбец
содержит точность (объявлен-
ную или неявную) в долях се-
кунды типа для целевого столб-
ца, то есть число десятичных
цифр, сохраняемых после деся-
тичной точки в значении се-
кунд. Для всех других типов
данных этот столбец содержит
NULL.
interval_type character_data Если в data_type указан тип
интервала, этот столбец опреде-
ляет, какие поля принимает ин-
тервал в целевом столбце, на-
пример: YEAR TO MONTH, DAY TO
SECOND и т. д. Если ограничения
950Информационная схема
Имя Тип данных Описание
для полей не заданы (то есть,
интервал принимает все поля),
и для любых других типов дан-
ных это поле содержит NULL.
interval_precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL (см. поле datetime_
precision , определяющее точ-
ность в долях секунды для типов
интервалов)
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Имя базы данных, содержащей
правило сортировки столбца (
это всегда текущая база), ли-
бо NULL, если это правило
по умолчанию или тип данных
столбца несортируемый
collation_schema sql_identifier Имя схемы, содержащей пра-
вило сортировки столбца, ли-
бо NULL, если это правило
по умолчанию или тип данных
столбца несортируемый
collation_name sql_identifier Имя правила сортировки столб-
ца, либо NULL, если это прави-
ло по умолчанию или тип дан-
ных столбца несортируемый
domain_catalog sql_identifier Если целевой столбец имеет тип
домена, этот столбец содержит
имя базы данных, в которой
определён домен (всегда теку-
щая база), иначе NULL.
domain_schema sql_identifier Если целевой столбец имеет тип
домена, этот столбец содержит
имя схемы, в которой определён
домен, иначе NULL.
domain_name sql_identifier Если целевой столбец имеет тип
домена, этот столбец содержит
имя домена, иначе NULL.
udt_catalog sql_identifier Имя базы данных, в которой
определён тип (если примени-
мо, нижележащий тип домена)
столбца (всегда текущая база)
udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип (если применимо, ниже-
951Информационная схема
Имя Тип данных Описание
лежащий тип домена) столбца (
всегда текущая база)
udt_name sql_identifier Имя типа данных столбца (если
применимо, нижележащий тип
домена)
scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
maximum_cardinality cardinal_number Всегда NULL, так как массивы
имеют неограниченную макси-
мальную ёмкость в PostgreSQL
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных столбца, уникаль-
ный среди всех дескрипторов
типов, относящихся к таблице.
Он в основном полезен для со-
единения с другими экземпля-
рами таких идентификаторов. (
Конкретный формат идентифи-
катора не определён и не га-
рантируется, что он останется
неизменным в будущих верси-
ях.)
is_self_referencing yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_identity yes_or_no Если целевой столбец является
столбцом идентификации, зна-
чение YES, иначе — NO.
identity_generation character_data Если целевой столбец яв-
ляется столбцом идентифика-
ции, значение ALWAYS или BY
DEFAULT, отражающее опреде-
ление столбца.
identity_start character_data Если целевой столбец является
столбцом идентификации, на-
чальное значение внутренней
последовательности, иначе —
NULL.
identity_increment character_data Если целевой столбец явля-
ется столбцом идентификации,
шаг внутренней последователь-
ности, иначе — NULL.
identity_maximum character_data Если целевой столбец является
столбцом идентификации, мак-
симальное значение внутрен-
952Информационная схема
Имя Тип данных Описание
ней последовательности, иначе
— NULL.
identity_minimum character_data Если целевой столбец является
столбцом идентификации, ми-
нимальное значение внутрен-
ней последовательности, иначе
— NULL.
identity_cycle yes_or_no Если целевой столбец является
столбцом идентификации, YES
показывает, что внутренняя по-
следовательность зацикливает-
ся, NO — не зацикливается, ина-
че — NULL.
is_generated character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
generation_expression character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_updatable yes_or_no YES, если столбец допускает из-
менение, или NO в противном
случае (столбцы в базовых таб-
лицах всегда изменяемые, но
в представлениях — не обяза-
тельно)
Так как типы данных могут определяться в SQL множеством способов и PostgreSQL добавляет
дополнительные варианты, представление типов в информационной схеме может быть довольно
сложным. Столбец data_type предназначен для идентификации нижележащего встроенного ти-
па столбца. В PostgreSQL это означает, что данный тип определён в схеме системного каталога
pg_catalog. Этот столбец может быть полезным, если приложение способно особым образом вос-
принимать встроенные типы (например, форматировать числовые типы по-другому или задейство-
вать данные в столбцах точности). Столбцы udt_name, udt_schema и udt_catalog всегда указывают
на нижележащий тип данных столбца, даже если столбец основан на домене. (Так как в PostgreSQL
встроенные типы не отличаются от определённых пользователем, в этом представлении выводят-
ся и они. Это расширение стандарта SQL.) Эти столбцы должны учитываться, когда приложению
нужно обрабатывать данные в зависимости от типа, так как в этом случае не важно, основан ли
столбец на домене. Если столбец основан на домене, на него указывают столбцы domain_name,
domain_schema и domain_catalog. Если вы хотите связать столбцы с их типами данных и обработать
домены как отдельные типы, вы можете записать coalesce(domain_name, udt_name) и т. п.
37.17. constraint_column_usage
Представление constraint_column_usage описывает все столбцы в текущей базе данных, связан-
ные с некоторым ограничением. В нём показываются только столбцы таблиц, принадлежащих те-
кущей активной роли. Для ограничений-проверок это представление содержит столбцы, задей-
ствованные в выражении проверки. Для ограничений внешнего ключа оно содержит столбцы, на
которые ссылается внешний ключ, а для ограничений уникальности или первичного ключа — огра-
ничиваемые столбцы.
Таблица 37.15. Столбцы constraint_column_usage
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
таблицу со столбцом, задейство-
953Информационная схема
Имя Тип данных Описание
ванным в некотором ограниче-
нии (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу со столбцом, задействован-
ным в некотором ограничении
table_name sql_identifier Имя таблицы со столбцом,
задействованным в некотором
ограничении
column_name sql_identifier Имя столбца, задействованного
в некотором ограничении
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
37.18. constraint_table_usage
Представление constraint_table_usage описывает все таблицы в текущей базе данных, связан-
ные с некоторым ограничением и принадлежащие текущей активной роли. (Это отличается от
представления table_constraints, в котором показываются все ограничения таблиц с таблица-
ми, для которых они определены.) Для ограничений внешнего ключа это представление показы-
вает таблицу, на которую ссылается ограничение. Для ограничений уникальности или первичного
ключа в этом представлении показывается таблица, которой принадлежит ограничение. Ограни-
чения-проверки и ограничения не-NULL в нём не отражаются.
Таблица 37.16. Столбцы constraint_table_usage
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, которая со-
держит таблицу, задействован-
ную некоторым ограничением (
всегда текущая база)
table_schema sql_identifier Имя схемы, которая содер-
жит таблицу, задействованную
некоторым ограничением
table_name sql_identifier Имя таблицы, задействованной
некоторым ограничением
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
37.19. data_type_privileges
Представление data_type_privileges описывает все дескрипторы типов данных, к которым имеет
доступ текущий пользователь, являясь их владельцем или имея некоторые права для них. Дескрип-
тор типа данных формируется, когда тип данных задействуется в определении столбца таблицы,
домена или функции (в качестве типа параметра или результата), и хранит некоторую информацию
954Информационная схема
о том, как этот тип используется в данном случае (например, объявленную максимальную длину,
если это применимо). Каждому дескриптору типа данных назначается уникальный идентифика-
тор, уникальный среди всех дескрипторов типов, назначаемых одному объекту (таблица, домен,
функция). Это представление, вероятно, не полезно для приложений, но на его базе определены
некоторые другие представления в информационной схеме.
Таблица 37.17. Столбцы data_type_privileges
Имя Тип данных Описание
object_catalog sql_identifier Имя базы данных, содержащей
описываемый объект (всегда те-
кущая база)
object_schema sql_identifier Имя схемы, содержащей описы-
ваемый объект
object_name sql_identifier Имя описываемого объекта
object_type character_data Тип описываемого объекта:
TABLE (дескриптор типа данных
относится к столбцу этой таб-
лицы), DOMAIN (дескриптор ти-
па данных относится к домену)
или ROUTINE (дескриптор типа
данных относится к типу дан-
ных параметра или результата
функции).
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных, уникальный сре-
ди дескрипторов типов для это-
го же объекта.
37.20. domain_constraints
Представление domain_constraints показывает все ограничения, принадлежащие доменам, опре-
делённым в текущей базе данных. В нём отражаются только те домены, к которым имеет доступ
текущий пользователь (являясь владельцем или имея некоторые права).
Таблица 37.18. Столбцы domain_constraints
Имя Тип данных Описание
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
domain_catalog sql_identifier Имя базы данных, содержащей
домен (всегда текущая база)
domain_schema sql_identifier Имя схемы, содержащей домен
domain_name sql_identifier Имя домена
is_deferrable yes_or_no YES, если ограничение отклады-
ваемое, или NO в противном слу-
чае
initially_deferred yes_or_no YES, если ограничение отклады-
ваемое и отложенное изначаль-
но, или NO в противном случае
955Информационная схема
37.21. domain_udt_usage
Представление domain_udt_usage описывает все домены, которые используют типы данных, при-
надлежащие текущей активной роли. Заметьте, что в PostgreSQL встроенные типы данных не от-
личаются от определённых пользователем, так что в этом представлении выводятся и они.
Таблица 37.19. Столбцы domain_udt_usage
Имя Тип данных Описание
udt_catalog sql_identifier Имя базы данных, в которой
определён тип данных домена (
всегда текущая база)
udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип данных домена
udt_name sql_identifier Имя типа данных домена
domain_catalog sql_identifier Имя базы данных, содержащей
домен (всегда текущая база)
domain_schema sql_identifier Имя схемы, содержащей домен
domain_name sql_identifier Имя домена
37.22. domains
Представление domains показывает все домены, определённые в текущей базе данных. В нём по-
казываются только те домены, к которым имеет доступ текущий пользователь (являясь владель-
цем или имея некоторые права).
Таблица 37.20. Столбцы domains
Имя Тип данных Описание
domain_catalog sql_identifier Имя базы данных, содержащей
домен (всегда текущая база)
domain_schema sql_identifier Имя схемы, содержащей домен
domain_name sql_identifier Имя домена
data_type character_data Тип данных домена, если это
встроенный тип, либо ARRAY,
если это массив (в этом слу-
чае обратитесь к представле-
нию element_types ), иначе —
USER-DEFINED (в этом случае тип
определяется в udt_name и свя-
занных столбцах).
character_maximum_length cardinal_number Если домен имеет тип тексто-
вой или битовой строки, это по-
ле задаёт её объявленную мак-
симальную длину; NULL для
всех других типов данных, или
если максимальная длина не
объявлена.
character_octet_length cardinal_number Если домен имеет тип сим-
вольной строки, это поле за-
даёт её максимально возмож-
ный размер в октетах (байтах);
NULL для всех других типов
данных. Максимальный размер
956Информационная схема
Имя Тип данных Описание
в октетах зависит от объявлен-
ной максимальной длины в сим-
волах (см. выше) и от кодировки
сервера.
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Имя базы данных, содержащей
правило сортировки домена (
это всегда текущая база), ли-
бо NULL, если это правило
по умолчанию или тип домена
несортируемый
collation_schema sql_identifier Имя схемы, содержащей пра-
вило сортировки домена, ли-
бо NULL, если это правило
по умолчанию или тип домена
несортируемый
collation_name sql_identifier Имя правила сортировки доме-
на, либо NULL, если это прави-
ло по умолчанию или тип доме-
на несортируемый
numeric_precision cardinal_number Если домен имеет числовой
тип, этот столбец содержит точ-
ность (объявленную или неяв-
ную) типа для этого доме-
на. Точность определяет чис-
ло значащих цифр. Она мо-
жет выражаться в десятичных
(по основанию 10) или дво-
ичных (по основанию 2) циф-
рах, согласно столбцу numeric_
precision_radix . Для всех
других типов данных этот стол-
бец содержит NULL.
numeric_precision_radix cardinal_number Если домен имеет числовой
тип, в этом столбце опреде-
ляется, по какому основанию
задаются значения в столбцах
numeric_precision и numeric_
scale . Возможные варианты:
2 и 10. Для всех других типов
данных этот столбец содержит
NULL.
numeric_scale cardinal_number Если домен имеет точный чис-
ловой тип, этот столбец со-
держит масштаб (объявленный
957Информационная схема
Имя Тип данных Описание
или неявный) типа для это-
го домена. Масштаб определя-
ет число значащих цифр спра-
ва от десятичной точки. Он
может выражаться в десятич-
ных (по основанию 10) или дво-
ичных (по основанию 2) циф-
рах, согласно столбцу numeric_
precision_radix . Для всех
других типов данных этот стол-
бец содержит NULL.
datetime_precision cardinal_number Если в data_type указан тип
даты, времени, отметки време-
ни или интервала, этот стол-
бец содержит точность (объяв-
ленную или неявную) в долях
секунды типа для этого домена,
то есть число десятичных цифр,
сохраняемых после десятичной
точки в значении секунд. Для
всех других типов данных этот
столбец содержит NULL.
interval_type character_data Если в data_type указан тип
интервала, этот столбец опре-
деляет, какие поля принимает
интервал в домене, например:
YEAR TO MONTH, DAY TO SECOND
и т. д. Если ограничения для по-
лей не заданы (то есть, интер-
вал принимает все поля), и для
любых других типов данных это
поле содержит NULL.
interval_precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL (см. поле datetime_
precision , определяющее точ-
ность в долях секунды для типов
интервалов)
domain_default character_data Выражение по умолчанию для
домена
udt_catalog sql_identifier Имя базы данных, в которой
определён тип данных домена (
всегда текущая база)
udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип данных домена
udt_name sql_identifier Имя типа данных домена
scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
958Информационная схема
Имя Тип данных Описание
scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
maximum_cardinality cardinal_number Всегда NULL, так как массивы
имеют неограниченную макси-
мальную ёмкость в PostgreSQL
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных целевого доме-
на, уникальный среди всех де-
скрипторов типов, относящих-
ся к домену (что тривиально,
так как домен содержит толь-
ко один дескриптор типа). Он
в основном полезен для соеди-
нения с другими экземплярами
таких идентификаторов. (Кон-
кретный формат идентификато-
ра не определён и не гарантиру-
ется, что он останется неизмен-
ным в будущих версиях.)
37.23. element_types
Представление element_types показывает дескрипторы типов элементов массива. Когда столбец
таблицы, атрибут составного типа, параметр или результат функции объявлены с типом массива,
соответствующее представление информационной схемы будет содержать только ARRAY в столбце
data_type. Чтобы получить информацию о типе элемента массива, можно связать соответствую-
щее представление с данным. Например, просмотреть столбцы таблицы с типами данных и типами
элементов массива (если это применимо) можно так:
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
ON ((c.table_catalog, c.table_schema, c.table_name, ‘TABLE’, c.dtd_identifier)
= (e.object_catalog, e.object_schema, e.object_name, e.object_type,
e.collection_type_identifier))
WHERE c.table_schema = ‘…’ AND c.table_name = ‘…’
ORDER BY c.ordinal_position;
Это представление показывает только те объекты, к которым имеет доступ текущий пользователь,
являясь владельцем или имея некоторые права.
Таблица 37.21. Столбцы element_types
Имя Тип данных Описание
object_catalog sql_identifier Имя базы данных, содержащей
объект, связанный с описывае-
мым массивом (всегда текущая
база)
object_schema sql_identifier Имя схемы, содержащей объ-
ект, связанный с описываемым
массивом
object_name sql_identifier Имя объекта, связанного с опи-
сываемым массивом
object_type character_data Тип объекта, связанного с опи-
сываемым массивом: TABLE (
массив задействован в столб-
959Информационная схема
Имя Тип данных Описание
це этой таблицы), USER-DEFINED
TYPE (массив задействован в ат-
рибуте составного типа), DOMAIN
(массив задействован в домене),
ROUTINE (массив задействован в
типе данных параметра или ре-
зультата функции).
collection_type_identifier sql_identifier Идентификатор
дескриптора
типа данных для описываемого
массива. Его можно использо-
вать для соединения со столб-
цами dtd_identifier других
представлений информацион-
ной схемы.
data_type character_data Тип данных элементов массива,
если это встроенный тип, либо
USER-DEFINED (в этом случае тип
определяется в udt_name и свя-
занных столбцах).
character_maximum_length cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
character_octet_length cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Имя базы данных, содержащей
правило сортировки типа эле-
мента (это всегда текущая ба-
за), либо NULL, если это прави-
ло по умолчанию или тип эле-
мента несортируемый
collation_schema sql_identifier Имя схемы, содержащей прави-
ло сортировки типа элемента,
либо NULL, если это правило
по умолчанию или тип элемен-
та несортируемый
collation_name sql_identifier Имя правила сортировки типа
элемента, либо NULL, если это
правило по умолчанию или тип
элемента несортируемый
960Информационная схема
Имя Тип данных Описание
numeric_precision cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
numeric_precision_radix cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
numeric_scale cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
datetime_precision cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
interval_type character_data Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
interval_precision cardinal_number Всегда NULL, так как эта
информация неприменима к
типам элементов массива в
PostgreSQL
domain_default character_data Ещё не реализовано
udt_catalog sql_identifier Имя базы данных, в которой
определён тип данных элемента
(всегда текущая база)
udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип данных элемента
udt_name sql_identifier Имя типа данных элемента
scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
maximum_cardinality cardinal_number Всегда NULL, так как массивы
имеют неограниченную макси-
мальную ёмкость в PostgreSQL
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных элемента. В насто-
ящее время бесполезен.
37.24. enabled_roles
Представление enabled_roles описывает «доступные роли». Список доступных ролей рекурсивно
определяется как роль текущего пользователя плюс роли, данные доступным ролям, с автомати-
961Информационная схема
ческим наследованием. Другими словами, это роли, которые даны текущему пользователю непо-
средственно или косвенно, посредством автоматического наследования.
Для проверки разрешений применяется набор «применимых ролей», который может быть шире
набора доступных ролей. Поэтому в общем случае вместо этого представления лучше использовать
представление applicable_roles (оно описывается в remap=”6” Раздел 37.5).
Таблица 37.22. Столбцы enabled_roles
Имя Тип данных Описание
role_name sql_identifier Имя целевой роли
37.25. foreign_data_wrapper_options
Представление foreign_data_wrapper_options показывает все параметры, определённые для
обёрток сторонних данных в текущей базе. В нём отражаются только те обёртки сторонних данных,
к которым имеет доступ текущий пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.23. Столбцы foreign_data_wrapper_options
Имя Тип данных Описание
foreign_data_wrapper_
catalog sql_identifier Имя базы данных, в которой
определена обёртка сторонних
данных (всегда текущая база)
foreign_data_wrapper_name sql_identifier Имя обёртки сторонних данных
option_name sql_identifier Имя параметра
option_value character_data Значение параметра
37.26. foreign_data_wrappers
Представление foreign_data_wrappers показывает все обёртки сторонних данных, определённые
в текущей базе. В нём показываются только те обёртки сторонних данных, к которым имеет доступ
текущий пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.24. Столбцы foreign_data_wrappers
Имя Тип данных Описание
foreign_data_wrapper_
catalog sql_identifier Имя базы данных, в которой
определена обёртка сторонних
данных (всегда текущая база)
foreign_data_wrapper_name sql_identifier Имя обёртки сторонних данных
authorization_identifier sql_identifier Имя владельца стороннего сер-
вера
library_name character_data Имя файла библиотеки, реали-
зующей эту обёртку сторонних
данных
foreign_data_wrapper_
language character_data Язык, на котором реализована
эта обёртка сторонних данных
37.27. foreign_server_options
Представление foreign_server_options показывает все параметры, определённые для сторонних
серверов в текущей базе данных. В нём отражаются только те сторонние серверы, к которым имеет
доступ текущий пользователь (являясь их владельцем или имея некоторые права).
962Информационная схема
Таблица 37.25. Столбцы foreign_server_options
Имя Тип данных Описание
foreign_server_catalog sql_identifier Имя базы данных, в которой
определён сторонний сервер (
всегда текущая база)
foreign_server_name sql_identifier Имя стороннего сервера
option_name sql_identifier Имя параметра
option_value character_data Значение параметра
37.28. foreign_servers
Представление foreign_servers показывает все сторонние серверы, определённые в текущей ба-
зе данных. В нём показываются только те сторонние серверы, к которым имеет доступ текущий
пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.26. Столбцы foreign_servers
Имя Тип данных Описание
foreign_server_catalog sql_identifier Имя базы данных, в которой
определён сторонний сервер (
всегда текущая база)
foreign_server_name sql_identifier Имя стороннего сервера
foreign_data_wrapper_
catalog sql_identifier Имя базы данных, в которой
определена обёртка сторонних
данных, используемая сторон-
ним сервером (всегда текущая
база)
foreign_data_wrapper_name sql_identifier Имя обёртки сторонних данных,
используемой сторонним серве-
ром
foreign_server_type character_data Информация о типе стороннего
сервера, если она была указана
при его создании
foreign_server_version character_data Информация о версии сторонне-
го сервера, если она была указа-
на при его создании
authorization_identifier sql_identifier Имя владельца стороннего сер-
вера
37.29. foreign_table_options
Представление foreign_table_options показывает все параметры, определённые для сторонних
таблиц в текущей базе данных. В нём отражаются только те сторонние таблицы, к которым имеет
доступ текущий пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.27. Столбцы foreign_table_options
Имя Тип данных Описание
foreign_table_catalog sql_identifier Имя базы данных, содержащей
стороннюю таблицу (всегда те-
кущая база)
foreign_table_schema sql_identifier Имя схемы, содержащей сто-
роннюю таблицу
963Информационная схема
Имя Тип данных Описание
foreign_table_name sql_identifier Имя сторонней таблицы
option_name sql_identifier Имя параметра
option_value character_data Значение параметра
37.30. foreign_tables
Представление foreign_tables показывает все сторонние таблицы, определённые в текущей ба-
зе данных. В нём показываются только те сторонние таблицы, к которым имеет доступ текущий
пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.28. Столбцы foreign_tables
Имя Тип данных Описание
foreign_table_catalog sql_identifier Имя базы данных, в которой
определена сторонняя таблица
(всегда текущая база)
foreign_table_schema sql_identifier Имя схемы, содержащей сто-
роннюю таблицу
foreign_table_name sql_identifier Имя сторонней таблицы
foreign_server_catalog sql_identifier Имя базы данных, в которой
определён сторонний сервер (
всегда текущая база)
foreign_server_name sql_identifier Имя стороннего сервера
37.31. key_column_usage
Представление key_column_usage описывает все столбцы в текущей базе, с которыми связано ка-
кое-либо ограничение уникальности, либо ограничение первичного или внешнего ключа. Ограни-
чения-проверки в этом представлении не показываются. В нём показываются только те столбцы,
к которым имеет доступ текущий пользователь (являясь владельцем или имея некоторые права).
Таблица 37.29. Столбцы key_column_usage
Имя Тип данных Описание
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
table_catalog sql_identifier Имя базы данных, содержащей
таблицу со столбцом, подчиня-
ющимся этому ограничению (
всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу со столбцом, подчиняющим-
ся этому ограничению
table_name sql_identifier Имя таблицы со столбцом, под-
чиняющимся этому ограниче-
нию
column_name sql_identifier Имя столбца, подчиняющегося
этому ограничению
964Информационная схема
Имя Тип данных Описание
ordinal_position cardinal_number Порядковый номер столбца в
ключе ограничения (нумерация
начинается с 1)
position_in_unique_
constraint cardinal_number Для ограничения внешнего
ключа это порядковый номер
целевого столбца в его огра-
ничении уникальности (нумера-
ция начинается с 1); в против-
ном случае NULL
37.32. parameters
Представление parameters содержит информацию о параметрах (аргументах) всех функций в те-
кущей базе данных. В нём отражаются только функции, к которым имеет доступ текущий пользо-
ватель (являясь владельцем или имея некоторые права).
Таблица 37.30. Столбцы parameters
Имя Тип данных Описание
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Подробнее оно описано в Разде-
ле 37.40.
ordinal_position cardinal_number Порядковый номер параметра
в списке аргументов функции (
нумерация начинается с 1)
parameter_mode character_data IN для входного параметра, OUT
для выходного, INOUT — для
входного и выходного парамет-
ра.
is_result yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
as_locator yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
parameter_name sql_identifier Имя параметра, либо NULL, ес-
ли параметр безымянный
data_type character_data Тип данных параметра, если это
встроенный тип, либо ARRAY,
если это массив (в этом слу-
чае обратитесь к представле-
нию element_types ), иначе —
USER-DEFINED (в этом случае тип
определяется в udt_name и свя-
занных столбцах).
character_maximum_length cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
965Информационная схема
Имя Тип данных Описание
character_octet_length cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
collation_schema sql_identifier Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
collation_name sql_identifier Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
numeric_precision cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
numeric_precision_radix cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
numeric_scale cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
datetime_precision cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
interval_type character_data Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
interval_precision cardinal_number Всегда NULL, так как эта ин-
формация не применима к ти-
пам параметров в PostgreSQL
udt_catalog sql_identifier Имя базы данных, в которой
определён тип данных парамет-
ра (всегда текущая база)
udt_schema sql_identifier Имя схемы, в которой опреде-
лён тип данных параметра
udt_name sql_identifier Имя типа данных параметра
scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
966Информационная схема
Имя Тип данных Описание
scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
maximum_cardinality cardinal_number Всегда NULL, так как массивы
имеют неограниченную макси-
мальную ёмкость в PostgreSQL
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных параметра, уни-
кальный среди всех дескрипто-
ров типов, относящихся к функ-
ции. Он в основном полезен для
соединения с другими экзем-
плярами таких идентификато-
ров. (Конкретный формат иден-
тификатора не определён и не
гарантируется, что он останет-
ся неизменным в будущих вер-
сиях.)
parameter_default character_data Выражение параметра по умол-
чанию, либо NULL, если тако-
го выражения нет или функция
не принадлежит текущей актив-
ной роли.
37.33. referential_constraints
Представление referential_constraints содержит все ссылочные ограничения (внешнего ключа)
в текущей базе данных. В нём показываются только ограничения, в которых ссылающаяся таблица
доступна текущему пользователю на запись (он является её владельцем или имеет не только право
SELECT).
Таблица 37.31. Столбцы referential_constraints
Имя Тип данных Описание
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
unique_constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение уникальности или
первичный ключ, на которые
ссылается ограничение внеш-
него ключа (всегда текущая ба-
за)
unique_constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение уникальности или пер-
вичный ключ, на которые ссы-
967Информационная схема
Имя Тип данных Описание
лается ограничение внешнего
ключа
unique_constraint_name sql_identifier Имя ограничения уникальности
или первичного ключа, на ко-
торые ссылается ограничение
внешнего ключа
match_option character_data Тип совпадения для ограни-
чения внешнего ключа: FULL,
PARTIAL или NONE.
update_rule character_data Правило изменения для огра-
ничения
внешнего
ключа:
CASCADE, SET NULL, SET DEFAULT,
RESTRICT или NO ACTION.
delete_rule character_data Правило удаления для огра-
ничения
внешнего
ключа:
CASCADE, SET NULL, SET DEFAULT,
RESTRICT или NO ACTION.
37.34. role_column_grants
Представление role_column_grants описывает все назначенные для столбцов права, в которых
праводателем или правообладателем является текущая активная роль. Дополнительную информа-
цию можно найти в column_privileges. Единственное существенное отличие этого представления
от column_privileges состоит в том, что в данном представлении опускаются столбцы, которые
доступны текущему пользователю косвенно через роль PUBLIC.
Таблица 37.32. Столбцы role_column_grants
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
table_catalog sql_identifier Имя базы данных, содержащей
таблицу с этим столбцом (все-
гда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу с этим столбцом
table_name sql_identifier Имя таблицы с этим столбцом
column_name sql_identifier Имя столбца
privilege_type character_data Тип права: SELECT, INSERT,
UPDATE или REFERENCES
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.35. role_routine_grants
Представление role_routine_grants описывает все назначенные для функций права, в которых
праводателем или правообладателем является текущая активная роль. Дополнительную информа-
цию можно найти в routine_privileges. Единственное существенное отличие этого представле-
968Информационная схема
ния от routine_privileges состоит в том, что в данном представлении опускаются функции, ко-
торые доступны текущему пользователю косвенно через роль PUBLIC.
Таблица 37.33. Столбцы role_routine_grants
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Подробнее оно описано в Разде-
ле 37.40.
routine_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
routine_schema sql_identifier Имя схемы, содержащей функ-
цию
routine_name sql_identifier Имя функции (может дублиро-
ваться в случае перегрузки)
privilege_type character_data Всегда EXECUTE (единственный
тип прав для функций)
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.36. role_table_grants
Представление role_table_grants описывает все назначенные для таблиц и представлений права,
в которых праводателем или правообладателем является текущая активная роль. Дополнительную
информацию можно найти в table_privileges. Единственное существенное отличие этого пред-
ставления от table_privileges состоит в том, что в данном представлении опускаются таблицы,
которые доступны текущему пользователю косвенно через роль PUBLIC.
Таблица 37.34. Столбцы role_table_grants
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
privilege_type character_data Тип права: SELECT, INSERT,
UPDATE, DELETE, TRUNCATE,
REFERENCES или TRIGGER
969Информационная схема
Имя Тип данных Описание
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
with_hierarchy yes_or_no В стандарте SQL имеется от-
дельное подчинённое разреше-
ние WITH HIERARCHY OPTION,
позволяющее выполнять опре-
делённые операции в иерар-
хии наследования таблиц. В
PostgreSQL так действует пра-
во SELECT, так что в этом столб-
це выводится YES для права
SELECT, а для других — NO.
37.37. role_udt_grants
Представление role_udt_grants предназначено для отображения прав USAGE, назначенных для
пользовательских типов, в которых праводателем или правообладателем является текущая актив-
ная роль. Дополнительную информацию можно найти в udt_privileges. Единственное существен-
ное отличие этого представления от udt_privileges состоит в том, что в данном представлении
опускаются объекты, которые доступны текущему пользователю косвенно через роль PUBLIC. Так
как с типами данных не связываются действующие права в PostgreSQL (только PUBLIC неявно да-
ётся право их использования), это представление пустое.
Таблица 37.35. Столбцы role_udt_grants
Имя Тип данных Описание
grantor sql_identifier Имя роли, которая дала это пра-
во
grantee sql_identifier Имя роли, которой было дано
это право
udt_catalog sql_identifier Имя базы данных, содержащей
тип (всегда текущая база)
udt_schema sql_identifier Имя схемы, содержащей тип
udt_name sql_identifier Имя типа
privilege_type character_data Всегда TYPE USAGE
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.38. role_usage_grants
Представление role_usage_grants описывает права USAGE, назначенные для объектов различных
типов, в которых праводателем или правообладателем является текущая активная роль. Допол-
нительную информацию можно найти в usage_privileges. Единственное существенное отличие
этого представления от usage_privileges состоит в том, что в данном представлении опускаются
объекты, которые доступны текущему пользователю косвенно через роль PUBLIC.
Таблица 37.36. Столбцы role_usage_grants
Имя Тип данных Описание
grantor sql_identifier Имя роли, которая дала это пра-
во
970Информационная схема
Имя Тип данных Описание
grantee sql_identifier Имя роли, которой было дано
это право
object_catalog sql_identifier Имя базы данных, содержащей
объект (всегда текущая база)
object_schema sql_identifier Имя схемы, содержащей объ-
ект, если это применимо, иначе
пустая строка
object_name sql_identifier Имя объекта
object_type character_data COLLATION или DOMAIN или
FOREIGN
DATA
WRAPPER или
FOREIGN SERVER или SEQUENCE
privilege_type character_data Всегда USAGE
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.39. routine_privileges
Представление routine_privileges описывает все права, назначенные текущей активной роли
или текущей активной ролью для функций. Оно содержит отдельный столбец для каждой комби-
нации функции, праводателя и правообладателя.
Таблица 37.37. Столбцы routine_privileges
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Подробнее оно описано в Разде-
ле 37.40.
routine_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
routine_schema sql_identifier Имя схемы, содержащей функ-
цию
routine_name sql_identifier Имя функции (может дублиро-
ваться в случае перегрузки)
privilege_type character_data Всегда EXECUTE (единственный
тип прав для функций)
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
971Информационная схема
37.40. routines
Представление routines отображает все функции и процедуры в текущей базе данных. В нём по-
казываются только те функции и процедуры, к которым имеет доступ текущий пользователь (яв-
ляясь владельцем или имея некоторые права).
Таблица 37.38. Столбцы routines
Имя Тип данных Описание
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Это имя однозначным образом
идентифицирует функцию в схе-
ме, даже если реальное имя
функции перегружено. Формат
однозначных имён не опреде-
лён, так что его следует исполь-
зовать только для сравнения
с другими экземплярами одно-
значных имён подпрограмм.
routine_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
routine_schema sql_identifier Имя схемы, содержащей функ-
цию
routine_name sql_identifier Имя функции (может дублиро-
ваться в случае перегрузки)
routine_type character_data FUNCTION
для
функций,
PROCEDURE для процедур
module_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
module_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
module_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
udt_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
udt_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
udt_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
data_type character_data Тип данных результата функ-
ции, если это встроенный тип,
либо ARRAY, если это мас-
сив (в этом случае обрати-
972Информационная схема
Имя Тип данных Описание
тесь к представлению element_
types ), иначе — USER-DEFINED (
в этом случае тип определяется
в type_udt_name
и связанных
столбцах). Для процедуры дан-
ное поле содержит NULL.
character_maximum_length cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
character_octet_length cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
collation_schema sql_identifier Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
collation_name sql_identifier Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
numeric_precision cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
numeric_precision_radix cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
numeric_scale cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
datetime_precision cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
interval_type character_data Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
interval_precision cardinal_number Всегда NULL, так как эта ин-
формация неприменима к ти-
пам результатов в PostgreSQL
type_udt_catalog sql_identifier Имя базы данных, в которой
определён тип данных резуль-
тата функции (всегда текущая
973Информационная схема
Имя Тип данных Описание
база). Для процедуры данное
поле содержит NULL.
type_udt_schema sql_identifier Имя схемы, в которой опре-
делён тип данных результата
функции. Для процедуры дан-
ное поле содержит NULL.
type_udt_name sql_identifier Имя типа данных результата
функции. Для процедуры дан-
ное поле содержит NULL.
scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
maximum_cardinality cardinal_number Всегда NULL, так как массивы
имеют неограниченную макси-
мальную ёмкость в PostgreSQL
dtd_identifier sql_identifier Идентификатор
дескриптора
типа данных результата функ-
ции, уникальный среди всех де-
скрипторов типов, относящихся
к функции. Он в основном по-
лезен для соединения с други-
ми экземплярами таких иден-
тификаторов. (Конкретный фор-
мат идентификатора не опреде-
лён и не гарантируется, что он
останется неизменным в буду-
щих версиях.)
routine_body character_data Если функция написана на SQL,
это поле содержит SQL, иначе
EXTERNAL.
routine_definition character_data Исходный текст функции (
NULL, если функция не принад-
лежит текущей активной роли).
(Согласно стандарту SQL, этот
столбец актуален, только если в
routine_body указано SQL, но в
PostgreSQL он будет содержать
любой исходный текст, задан-
ный при создании функции.)
external_name character_data Если это функция на C, этот
столбец содержит внешнее имя
(объектный символ) функции,
иначе NULL. (Это будет то же
значение, что содержит стол-
бец routine_definition .)
974Информационная схема
Имя Тип данных Описание
external_language character_data Язык, на
функция
parameter_style character_data Всегда GENERAL (В стандарте
SQL определены и другие сти-
ли параметров, но в PostgreSQL
они отсутствуют.)
is_deterministic yes_or_no Если функция объявлена как по-
стоянная (IMMUTABLE) (в стан-
дарте SQL она называется де-
терминированной), этот стол-
бец содержит YES, иначе — NO.
(Получить другие уровни пере-
менности функций, имеющиеся
в PostgreSQL, через информаци-
онную схему нельзя.)
sql_data_access character_data Всегда MODIFIES, что означа-
ет, что функция может моди-
фицировать данные SQL. Для
PostgreSQL эта информация
бесполезна.
is_null_call yes_or_no Если функция автоматически
возвращает NULL, когда один
из аргументов NULL, этот стол-
бец содержит YES, иначе — NO.
Для процедуры он содержит
NULL.
sql_path character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
schema_level_routine yes_or_no Всегда YES (Другое значение
было бы у методов пользова-
тельских типов, но в PostgreSQL
их нет.)
max_dynamic_result_sets cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_user_defined_cast yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_implicitly_invocable yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
security_type character_data Если функция выполняется с
правами вызывающего пользо-
вателя, этот столбец содержит
INVOKER, а если с правами поль-
зователя, создавшего её, то —
DEFINER.
to_sql_specific_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
975
котором
написанаИнформационная схема
Имя Тип данных Описание
to_sql_specific_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
to_sql_specific_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
as_locator yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
created time_stamp Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
last_altered time_stamp Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
new_savepoint_level yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_udt_dependent yes_or_no В настоящее время всегда NO.
Альтернативное значение YES
связано с возможностями, от-
сутствующими в PostgreSQL.
result_cast_from_data_
type character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_as_locator yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_char_max_
length cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_char_octet_
length character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_char_set_
catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_char_set_
schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_char_set_
name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_collation_
catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_collation_
schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
976Информационная схема
Имя Тип данных Описание
result_cast_collation_
name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_numeric_
precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_numeric_
precision_radix cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_numeric_scale cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_datetime_
precision character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_interval_type character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_interval_
precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_type_udt_
catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_type_udt_
schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_type_udt_
name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_scope_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_scope_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_scope_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_maximum_
cardinality cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
result_cast_dtd_
identifier sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
37.41. schemata
Представление schemata показывает все схемы в текущей базе данных, к которым имеет доступ
текущий пользователь (являясь их владельцем или имея некоторые права).
977Информационная схема
Таблица 37.39. Столбцы schemata
Имя Тип данных Описание
catalog_name sql_identifier Имя базы данных, содержащей
схему (всегда текущая база)
schema_name sql_identifier Имя схемы
schema_owner sql_identifier Имя владельца схемы
default_character_set_
catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
default_character_set_
schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
default_character_set_
name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
sql_path character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
37.42. sequences
Представление sequences показывает все последовательности, определённые в текущей базе дан-
ных. В нём показываются только те последовательности, к которым имеет доступ текущий поль-
зователь (являясь владельцем или имея некоторые права).
Таблица 37.40. Столбцы sequences
Имя Тип данных Описание
sequence_catalog sql_identifier Имя базы данных, содержащей
последовательность (всегда те-
кущая база)
sequence_schema sql_identifier Имя схемы, содержащей после-
довательность
sequence_name sql_identifier Имя последовательности
data_type character_data Тип данных последовательно-
сти.
numeric_precision cardinal_number Этот столбец содержит точ-
ность (объявленную или неяв-
ную) типа данных последова-
тельности (см. выше). Точность
определяет число значащих
цифр. Она может выражаться
в десятичных (по основанию
10) или двоичных (по основа-
нию 2) цифрах, согласно столб-
цу numeric_precision_radix .
numeric_precision_radix cardinal_number Этот столбец определяет, по ка-
кому основанию задаются зна-
чения в столбцах numeric_
precision и numeric_scale .
Возможные варианты: 2 и 10.
numeric_scale cardinal_number Этот столбец содержит мас-
штаб (объявленный или неяв-
978Информационная схема
Имя Тип данных Описание
ный) типа данных последова-
тельности (см. выше). Мас-
штаб определяет число знача-
щих цифр справа от десятич-
ной точки. Он может выражать-
ся в десятичных (по основанию
10) или двоичных (по основа-
нию 2) цифрах, согласно столб-
цу numeric_precision_radix .
start_value character_data Начальное значение последова-
тельности
minimum_value character_data Минимальное значение после-
довательности
maximum_value character_data Максимальное значение после-
довательности
increment character_data Шаг увеличения
тельности
cycle_option yes_or_no YES, если последовательность
зацикливается, или NO в против-
ном случае
последова-
Заметьте, что, согласно стандарту SQL, начальное, минимальное, максимальное значение и шаг
выдаются в виде символьных строк.
37.43. sql_features
Таблица sql_features содержит информацию о формальной функциональности, описанной в стан-
дарте и поддерживаемой PostgreSQL. Эта же информация представлена в Приложении D. Там вы
можете найти и дополнительные сведения.
Таблица 37.41. Столбцы sql_features
Имя Тип данных Описание
feature_id character_data Строка идентификатора функ-
циональности
feature_name character_data Описательное название функ-
циональности
sub_feature_id character_data Строка идентификатора под-
чинённой возможности, либо
строка нулевой длины, если это
не подчинённая возможность
sub_feature_name character_data Описательное название под-
чинённой возможности, либо
строка нулевой длины, если это
не подчинённая возможность
is_supported yes_or_no YES, если функциональность
полностью поддерживается те-
кущей версией PostgreSQL, ли-
бо NO в противном случае
is_verified_by character_data Всегда NULL, так как группа
разработки PostgreSQL не про-
водит формальное тестирова-
979Информационная схема
Имя Тип данных Описание
ние функционального соответ-
ствия
comments character_data Необязательный комментарий
о поддерживаемом состоянии
функциональности
37.44. sql_implementation_info
Таблица sql_implementation_info содержит информацию о различных аспектах, которые в стан-
дарте SQL оставлены на усмотрение реализации. Эта информация в основном предназначена для
применения в контексте интерфейса ODBC; пользователям других интерфейсов она вряд ли будет
нужна. Поэтому отдельные элементы особенностей реализации здесь не описываются; о них мож-
но прочитать в описании интерфейса ODBC.
Таблица 37.42. Столбцы sql_implementation_info
Имя Тип данных Описание
implementation_info_id character_data Строка идентификатора эле-
мента особенности реализации
implementation_info_name character_data Описательное название элемен-
та особенности реализации
integer_value cardinal_number Значение элемента особенно-
сти реализации, либо NULL, ес-
ли его значение содержится в
столбце character_value
character_value character_data Значение элемента особенно-
сти реализации, либо NULL, ес-
ли его значение содержится в
столбце integer_value
comments character_data Необязательный комментарий,
относящийся к элементу осо-
бенности реализации
37.45. sql_languages
Таблица sql_languages содержит одну строку для каждой привязки языка SQL, поддерживаемой
PostgreSQL. PostgreSQL поддерживает непосредственный SQL и SQL, встроенный в C; это всё, что
можно получить из этой таблицы.
Эта таблица была исключена из стандарта SQL в версии SQL:2008, так что она не содержит запи-
сей, относящихся к стандартам новее SQL:2003.
Таблица 37.43. Столбцы sql_languages
Имя Тип данных Описание
sql_language_source character_data Имя источника определения
языка; всегда ISO 9075, то есть
стандарт SQL
sql_language_year character_data Год, в котором был одобрен
стандарт, отмеченный в sql_
language_source .
sql_language_conformance character_data Уровень совместимости со стан-
дартом для привязки языка.
Для ISO 9075:2003 это всегда
CORE.
980Информационная схема
Имя Тип данных Описание
sql_language_integrity character_data Всегда NULL (Это значение бы-
ло актуально для более ранней
версии стандарта SQL.)
sql_language_
implementation character_data Всегда NULL
sql_language_binding_
style character_data Стиль привязки языка: DIRECT
или EMBEDDED
sql_language_programming_
language character_data Язык программирования, если
стиль привязки — EMBEDDED,
иначе NULL. PostgreSQL под-
держивает только язык C.
37.46. sql_packages
Таблица sql_packages содержит информацию о функциональных пакетах, определённых в стан-
дарте SQL и поддерживаемых PostgreSQL. За дополнительными сведениями о функциональных па-
кетах обратитесь к Приложению D.
Таблица 37.44. Столбцы sql_packages
Имя Тип данных Описание
feature_id character_data Строка идентификатора пакета
feature_name character_data Описательное название пакета
is_supported yes_or_no YES, если пакет полностью под-
держивается текущей версией
PostgreSQL, либо NO в против-
ном случае
is_verified_by character_data Всегда NULL, так как группа
разработки PostgreSQL не про-
водит формальное тестирова-
ние функционального соответ-
ствия
comments character_data Необязательный комментарий
о поддерживаемом состоянии
пакета
37.47. sql_parts
Таблица sql_parts содержит информацию о различных частях стандарта SQL, поддерживаемых
PostgreSQL.
Таблица 37.45. Столбцы sql_parts
Имя Тип данных Описание
feature_id character_data Строка идентификатора, содер-
жащая номер части
feature_name character_data Описательное название части
is_supported yes_or_no YES, если часть полностью под-
держивается текущей версией
PostgreSQL, либо NO в против-
ном случае
is_verified_by character_data Всегда NULL, так как группа
разработки PostgreSQL не про-
981Информационная схема
Имя Тип данных Описание
водит формальное тестирова-
ние функционального соответ-
ствия
comments character_data Необязательный комментарий
о поддерживаемом состоянии
части
37.48. sql_sizing
Таблица sql_sizing содержит информацию о различных ограничениях размера и максимальных
значениях в PostgreSQL. Эта информация в основном предназначена для применения в контексте
интерфейса ODBC; пользователям других интерфейсов она вряд ли будет нужна. Поэтому отдель-
ные элементы размеров здесь не описываются; о них можно прочитать в описании интерфейса
ODBC.
Таблица 37.46. Столбцы sql_sizing
Имя Тип данных Описание
sizing_id cardinal_number Идентификатор элемента раз-
меров
sizing_name character_data Описательное название элемен-
та размеров
supported_value cardinal_number Значение элемента размеров,
или 0, если размер неограни-
ченный или не может быть
определён, либо NULL, если
функциональность, к которой
относится размер, не поддер-
живается
comments character_data Необязательный комментарий,
относящийся к элементу разме-
ров
37.49. sql_sizing_profiles
Таблица sql_sizing_profiles содержит информацию о значениях sql_sizing, которые требуются
для различных профилей стандарта SQL. PostgreSQL не ориентируется на профили SQL, поэтому
данная таблица пуста.
Таблица 37.47. Столбцы sql_sizing_profiles
Имя Тип данных Описание
sizing_id cardinal_number Идентификатор элемента раз-
меров
sizing_name character_data Описательное название элемен-
та размеров
profile_id character_data Строка идентификатора профи-
ля
required_value cardinal_number Значение, которое требует про-
филь SQL для этого элемента
размеров, или 0, если профиль
не ограничивает данный эле-
мент, либо NULL, если профиль
не требует наличия функцио-
982Информационная схема
Имя Тип данных Описание
нальности, для которой приме-
ним этот элемент
comments character_data Необязательный комментарий,
относящийся к элементу разме-
ров в профиле
37.50. table_constraints
Представление table_constraints показывает все ограничения, принадлежащие таблицам, к ко-
торым имеет доступ текущий пользователь (являясь владельцем или имея некоторые права, кроме
SELECT).
Таблица 37.48. Столбцы table_constraints
Имя Тип данных Описание
constraint_catalog sql_identifier Имя базы данных, содержащей
ограничение (всегда текущая
база)
constraint_schema sql_identifier Имя схемы, содержащей огра-
ничение
constraint_name sql_identifier Имя ограничения
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
constraint_type character_data Тип
ограничения:
CHECK,
FOREIGN KEY, PRIMARY KEY или
UNIQUE
is_deferrable yes_or_no YES, если ограничение отклады-
ваемое, или NO в противном слу-
чае
initially_deferred yes_or_no YES, если ограничение отклады-
ваемое и отложенное изначаль-
но, или NO в противном случае
enforced yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL (в настоящее время
всегда равно YES)
37.51. table_privileges
Представление table_privileges описывает все права, назначенные текущей активной роли или
текущей активной ролью для таблиц и представлений. Оно содержит отдельную строку для каждой
комбинации таблицы, праводателя и правообладателя.
Таблица 37.49. Столбцы table_privileges
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
983Информационная схема
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
privilege_type character_data Тип права: SELECT, INSERT,
UPDATE, DELETE, TRUNCATE,
REFERENCES или TRIGGER
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
with_hierarchy yes_or_no В стандарте SQL имеется от-
дельное подчинённое разреше-
ние WITH HIERARCHY OPTION,
позволяющее выполнять опре-
делённые операции в иерар-
хии наследования таблиц. В
PostgreSQL так действует пра-
во SELECT, так что в этом столб-
це выводится YES для права
SELECT, а для других — NO.
37.52. tables
Представление tables показывает все таблицы и представления, определённые в текущей базе
данных. В нём показываются только те таблицы и представления, к которым имеет доступ текущий
пользователь (являясь их владельцем или имея некоторые права).
Таблица 37.50. Столбцы tables
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
таблицу (всегда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу
table_name sql_identifier Имя таблицы
table_type character_data Тип таблицы: BASE TABLE для
постоянных базовых таблиц (
таблиц обычного типа), VIEW
для представлений, FOREIGN для
сторонних таблиц, либо LOCAL
TEMPORARY для временных таб-
лиц
self_referencing_column_
name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
reference_generation character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
user_defined_type_catalog sql_identifier Если таблица является типизи-
рованной, это имя базы данных,
содержащей нижележащий тип
984Информационная схема
Имя Тип данных Описание
данных (всегда текущая база),
иначе NULL.
user_defined_type_schema sql_identifier Если таблица является типизи-
рованной, это имя схемы, содер-
жащей нижележащий тип дан-
ных, иначе NULL.
user_defined_type_name sql_identifier Если таблица является типизи-
рованной, это имя типа данных,
иначе NULL.
is_insertable_into yes_or_no YES, если в эту таблицу можно
добавлять данные, или NO в про-
тивном случае (Базовые табли-
цы всегда допускают добавле-
ние данных, но представления
— не обязательно.)
is_typed yes_or_no YES, если эта таблица является
типизированной, иначе NO
commit_action character_data Ещё не реализовано
37.53. transforms
Представление transforms содержит информацию о трансформациях, определённых в текущей
базе данных. Более точно, оно содержит строку для каждой функции, задействованной в транс-
формации (функцию «из SQL» или «в SQL»).
Таблица 37.51. Столбцы transforms
Имя Тип данных Описание
udt_catalog sql_identifier Имя базы данных, содержащей
тип, для которого предназначе-
на трансформация (всегда теку-
щая база)
udt_schema sql_identifier Имя схемы, содержащей тип,
для которого предназначена
трансформация
udt_name sql_identifier Имя типа, для которого предна-
значена трансформация
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Подробнее оно описано в Разде-
ле 37.40.
group_name sql_identifier Стандарт SQL позволяет опре-
делять «группы» трансформа-
ций и выбирать группу во вре-
мя выполнения. PostgreSQL это
не поддерживает. Вместо этого
трансформации привязываются
к языкам. В качестве компро-
мисса со стандартом, это по-
985Информационная схема
Имя Тип данных Описание
ле содержит язык, для которого
предназначена трансформация.
transform_type character_data FROM SQL или TO SQL
37.54. triggered_update_columns
Для триггеров в текущей базе данных, установленных для списка столбцов (например, UPDATE OF
column1, column2), представление triggered_update_columns показывает эти столбцы. Триггеры,
для которых не задаётся список столбцов, в этом представлении не отражаются. В нём показыва-
ются только столбцы, доступные текущему пользователю (как владельцу или имеющему некото-
рые права, кроме SELECT).
Таблица 37.52. Столбцы triggered_update_columns
Имя Тип данных Описание
trigger_catalog sql_identifier Имя базы данных, содержащей
триггер (всегда текущая база)
trigger_schema sql_identifier Имя схемы, содержащей триг-
гер
trigger_name sql_identifier Имя триггера
event_object_catalog sql_identifier Имя базы данных, содержащей
таблицу, для которой определён
триггер (всегда текущая база)
event_object_schema sql_identifier Имя схемы, содержащей табли-
цу, для которой определён триг-
гер
event_object_table sql_identifier Имя таблицы, для которой опре-
делён триггер
event_object_column sql_identifier Имя столбца, для
определён триггер
которого
37.55. triggers
Представление triggers показывает все триггеры, определённые в текущей базе данных для таб-
лиц и представлений, к которым имеет доступ текущий пользователь (являясь владельцем или
имея некоторые права, кроме SELECT).
Таблица 37.53. Столбцы triggers
Имя Тип данных Описание
trigger_catalog sql_identifier Имя базы данных, содержащей
триггер (всегда текущая база)
trigger_schema sql_identifier Имя схемы, содержащей триг-
гер
trigger_name sql_identifier Имя триггера
event_manipulation character_data Событие, вызывающие срабаты-
вание триггера (INSERT, UPDATE
или DELETE)
event_object_catalog sql_identifier Имя базы данных, содержащей
таблицу, для которой определён
триггер (всегда текущая база)
986Информационная схема
Имя Тип данных Описание
event_object_schema sql_identifier Имя схемы, содержащей табли-
цу, для которой определён триг-
гер
event_object_table sql_identifier Имя таблицы, для которой опре-
делён триггер
action_order cardinal_number Порядок срабатывания триг-
геров, имеющих одинаковые
свойства event_manipulation ,
action_timing
и action_
orientation . В PostgreSQL
триггеры срабатывают по по-
рядку их имён, что и отражает-
ся в этом столбце.
action_condition character_data Условие WHEN триггера, либо
NULL, если его нет (так же
NULL, если таблица не принад-
лежит текущей активной роли)
action_statement character_data Оператор, выполняемый триг-
гером (в настоящее время все-
гда EXECUTE FUNCTION функ-
ция(…) )
action_orientation character_data Определяет, срабатывает ли
триггер для каждой обрабаты-
ваемой строки или только для
каждого оператора (ROW или
STATEMENT)
action_timing character_data Момент срабатывания триггера
(BEFORE (до), AFTER (после) или
INSTEAD OF (вместо))
action_reference_old_
table sql_identifier Имя «старой» переходной таб-
лицы либо NULL, если её нет
action_reference_new_
table sql_identifier Имя «новой» переходной табли-
цы либо NULL, если её нет
action_reference_old_row sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
action_reference_new_row sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
created time_stamp Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
Триггеры в PostgreSQL несовместимы со стандартом в двух аспектах, которые влияют на их пред-
ставление в информационной схеме. Во-первых, имена триггеров являются локальными для каж-
дой таблицы в PostgreSQL, а не независимыми объектами схемы. Таким образом, в одной схеме
могут быть дублирующиеся имена триггеров, если они принадлежат разным таблицам. (Значения
trigger_catalog и trigger_schema на самом деле относятся к таблице, для которой определён
триггер.) Во-вторых, триггеры в PostgreSQL могут срабатывать при нескольких событиях (напри-
мер, ON INSERT OR UPDATE), тогда как стандарт SQL допускает только одно событие. Если триггер
настроен на несколько событий, он представляется в информационной схеме в виде нескольких
строк, по одной для каждого типа события. Вследствие этих двух особенностей, первичный ключ в
987Информационная схема
представлении triggers на самом деле (trigger_catalog, trigger_schema, event_object_table,
trigger_name, event_manipulation), а не (trigger_catalog, trigger_schema, trigger_name),
как должно быть согласно стандарту SQL. Однако, если определять триггеры в строгом соответ-
ствии со стандартом SQL (чтобы имена триггеров были уникальны в схеме и каждый триггер свя-
зывался только с одним событием), это расхождение никак не проявится.
Примечание
До
PostgreSQL
9.1
в
этом
представлении
столбцы
action_timing,
action_reference_old_table,
action_reference_new_table,
action_reference_old_row
и
action_reference_new_row
назывались
condition_timing, condition_reference_old_table, condition_reference_new_table,
condition_reference_old_row и condition_reference_new_row, соответственно. Ста-
рые имена были продиктованы стандартом SQL:1999. Новые имена соответствуют стан-
дарту SQL:2003 и более поздним.
37.56. udt_privileges
Представление udt_privileges описывает права USAGE, назначенные текущей активной роли или
текущей активной ролью для пользовательских типов. Оно содержит отдельную строку для каж-
дой комбинации типа, праводателя и правообладателя. Это представление показывает только со-
ставные типы (почему, говорится в Разделе 37.58); права, затрагивающие домены, описаны в Раз-
деле 37.57.
Таблица 37.54. Столбцы udt_privileges
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
udt_catalog sql_identifier Имя базы данных, содержащей
тип (всегда текущая база)
udt_schema sql_identifier Имя схемы, содержащей тип
udt_name sql_identifier Имя типа
privilege_type character_data Всегда TYPE USAGE
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.57. usage_privileges
Представление usage_privileges описывает права USAGE, назначенные текущей активной роли
или текущей активной ролью для различных типов объектов. В PostgreSQL на данный момент это
правила сортировки, домены, обёртки сторонних данных, сторонние серверы и последовательно-
сти. Оно содержит отдельную строку для каждой комбинации объекта, праводателя и правообла-
дателя.
Так как с правилами сортировки в PostgreSQL не связаны никакие действующие права, в этом
представлении показываются фиктивные права USAGE, якобы назначенные владельцем базы роли
PUBLIC для всех правил сортировки. Для других типов объектов, однако, в нём показываются фак-
тические права.
В PostgreSQL для последовательностей могут назначаться права SELECT и UPDATE, в дополнение к
USAGE. Но это нестандартные права и поэтому в информационной схеме они не видны.
988Информационная схема
Таблица 37.55. Столбцы usage_privileges
Имя Тип данных Описание
grantor sql_identifier Имя роли, давшей право (право-
датель)
grantee sql_identifier Имя роли, которой было дано
право (правообладатель)
object_catalog sql_identifier Имя базы данных, содержащей
объект (всегда текущая база)
object_schema sql_identifier Имя схемы, содержащей объ-
ект, если это применимо, иначе
пустая строка
object_name sql_identifier Имя объекта
object_type character_data COLLATION или DOMAIN или
FOREIGN
DATA
WRAPPER или
FOREIGN SERVER или SEQUENCE
privilege_type character_data Всегда USAGE
is_grantable yes_or_no YES, если право может переда-
ваться, или NO в противном слу-
чае
37.58. user_defined_types
Представление user_defined_types в данное время показывает все составные типы, определённые
в текущей базе данных. В нём показываются только те типы, к которым имеет доступ текущий
пользователь (являясь владельцем или имея некоторые права).
SQL знает два вида пользовательских типов: структурные типы (также называются составными
типами в PostgreSQL) и отдельные типы (не реализованы в PostgreSQL). Для уверенности в буду-
щем, нужно обратиться к столбцу user_defined_type_category, чтобы различить их. Другие поль-
зовательские типы, как например, базовые типы и перечисления, относящиеся к расширениям
PostgreSQL, в этом представлении не показываются. О доменах можно узнать в Разделе 37.22.
Таблица 37.56. Столбцы user_defined_types
Имя Тип данных Описание
user_defined_type_catalog sql_identifier Имя базы данных, содержащей
тип (всегда текущая база)
user_defined_type_schema sql_identifier Имя схемы, содержащей тип
user_defined_type_name sql_identifier Имя типа
user_defined_type_
category character_data На данный
STRUCTURED
is_instantiable yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_final yes_or_no Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
ordering_form character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
989
момент
всегдаИнформационная схема
Имя Тип данных Описание
ordering_category character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
ordering_routine_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
ordering_routine_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
ordering_routine_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
reference_type character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
data_type character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_maximum_length cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_octet_length cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
character_set_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_catalog sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_schema sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
collation_name sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
numeric_precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
numeric_precision_radix cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
990Информационная схема
Имя Тип данных Описание
numeric_scale cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
datetime_precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
interval_type character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
interval_precision cardinal_number Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
source_dtd_identifier sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
ref_dtd_identifier sql_identifier Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
37.59. user_mapping_options
Представление user_mapping_options показывает все параметры, заданные для сопоставлений
пользователей в текущей базе данных. В нём отражаются только сопоставления пользователей,
установленные для сторонних серверов, к которым имеет доступ текущий пользователь (являясь
владельцем или имея некоторые права).
Таблица 37.57. Столбцы user_mapping_options
Имя Тип данных Описание
authorization_identifier sql_identifier Имя сопоставляемого пользова-
теля, либо PUBLIC, если это со-
поставление для всех
foreign_server_catalog sql_identifier Имя базы данных, в которой
определён сторонний сервер,
задействованный в сопоставле-
нии (всегда текущая база)
foreign_server_name sql_identifier Имя стороннего сервера, задей-
ствованного в сопоставлении
option_name sql_identifier Имя параметра
option_value character_data Значение параметра. Этот стол-
бец будет содержать не NULL,
только если описывается сопо-
ставление текущего пользова-
теля, либо это сопоставление
для PUBLIC, а текущий поль-
зователь — владелец сторонне-
го сервера или суперпользова-
тель. Данное ограничение вве-
дено для защиты информации о
пароле, сохранённой в парамет-
рах сопоставления.
991Информационная схема
37.60. user_mappings
Представление user_mappings показывает все сопоставления пользователей, определённые в те-
кущей базе данных. В нём показываются только сопоставления, установленные для сторонних сер-
веров, к которым имеет доступ текущий пользователь (являясь владельцем или имея некоторые
права).
Таблица 37.58. Столбцы user_mappings
Имя Тип данных Описание
authorization_identifier sql_identifier Имя сопоставляемого пользова-
теля, либо PUBLIC, если это со-
поставление для всех
foreign_server_catalog sql_identifier Имя базы данных, в которой
определён сторонний сервер,
задействованный в сопоставле-
нии (всегда текущая база)
foreign_server_name sql_identifier Имя стороннего сервера, задей-
ствованного в сопоставлении
37.61. view_column_usage
Представление view_column_usage описывает все столбцы, задействованные в выражении запро-
са представления (операторе SELECT, определяющем представление). Столбец выводится в этом
списке, только если содержащая его таблица принадлежит текущей активной роли.
Примечание
Столбцы системных таблиц в этом представлении не отображаются. Это может быть
исправлено позже.
Таблица 37.59. Столбцы view_column_usage
Имя Тип данных Описание
view_catalog sql_identifier Имя базы данных, содержащей
представление (всегда текущая
база)
view_schema sql_identifier Имя схемы, содержащей пред-
ставление
view_name sql_identifier Имя представления
table_catalog sql_identifier Имя базы данных, содержащей
таблицу со столбцом, задейство-
ванным в представлении (все-
гда текущая база)
table_schema sql_identifier Имя схемы, содержащей табли-
цу со столбцом, задействован-
ным в представлении
table_name sql_identifier Имя таблицы со столбцом, за-
действованным в представле-
нии
column_name sql_identifier Имя столбца, задействованного
в представлении
992Информационная схема
37.62. view_routine_usage
Представление view_routine_usage описывает все подпрограммы (функции и процедуры), исполь-
зуемые в выражении запроса представления (операторе SELECT, определяющем представление).
Подпрограмма выводится в этом списке, только если она принадлежит текущей активной роли.
Таблица 37.60. Столбцы view_routine_usage
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
представление (всегда текущая
база)
table_schema sql_identifier Имя схемы, содержащей пред-
ставление
table_name sql_identifier Имя представления
specific_catalog sql_identifier Имя базы данных, содержащей
функцию (всегда текущая база)
specific_schema sql_identifier Имя схемы, содержащей функ-
цию
specific_name sql_identifier «Однозначное имя» функции.
Подробнее оно описано в Разде-
ле 37.40.
37.63. view_table_usage
Представление view_table_usage описывает все таблицы, задействованные в выражении запро-
са представления (операторе SELECT, определяющем представление). Таблица выводится в этом
списке, только если она принадлежит текущей активной роли.
Примечание
Системные таблицы в этом представлении не отображаются. Это может быть исправ-
лено позже.
Таблица 37.61. Столбцы view_table_usage
Имя Тип данных Описание
view_catalog sql_identifier Имя базы данных, содержащей
представление (всегда текущая
база)
view_schema sql_identifier Имя схемы, содержащей пред-
ставление
view_name sql_identifier Имя представления
table_catalog sql_identifier Имя базы данных, содержа-
щей таблицу, задействованную
в представлении (всегда теку-
щая база)
table_schema sql_identifier Имя схемы, содержащей таб-
лицу, задействованную в пред-
ставлении
table_name sql_identifier Имя таблицы, задействованной
в представлении
993Информационная схема
37.64. views
Представление views показывает все представления, определённые в текущей базе данных. В нём
показываются только представления, к которым имеет доступ текущий пользователь (являясь вла-
дельцем или имея некоторые права).
Таблица 37.62. Столбцы views
Имя Тип данных Описание
table_catalog sql_identifier Имя базы данных, содержащей
представление (всегда текущая
база)
table_schema sql_identifier Имя схемы, содержащей пред-
ставление
table_name sql_identifier Имя представления
view_definition character_data Выражение запроса, определя-
ющее представление (NULL, ес-
ли представление не принадле-
жит текущей активной роли)
check_option character_data Относится
к
функциональ-
ности,
отсутствующей
в
PostgreSQL
is_updatable yes_or_no YES, если представление до-
пускает изменение (команды
UPDATE и DELETE), или NO в про-
тивном случае
is_insertable_into yes_or_no YES, если представление допус-
кает добавление данных (ко-
манду INSERT), или NO в против-
ном случае
is_trigger_updatable yes_or_no YES, если для представления
определён триггер INSTEAD OF
UPDATE, или NO в противном слу-
чае
is_trigger_deletable yes_or_no YES, если для представления
определён триггер INSTEAD OF
DELETE, или NO в противном слу-
чае
is_trigger_insertable_
into yes_or_no YES, если для представления
определён триггер INSTEAD OF
INSERT, или NO в противном слу-
чае
994</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-036/" title="Глава 36. ECPG — встраиваемый SQL в C"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 36. ECPG — встраиваемый SQL в C"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-036/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~121 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-036/" rel="bookmark" title="Глава 36. ECPG — встраиваемый SQL в C" itemprop="url">Глава 36. ECPG — встраиваемый SQL в C</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 36. ECPG — встраиваемый SQL в C</p>

<p>В этой главе описывается встраиваемый SQL для PostgreSQL. Авторы этой разработки: Линус
Толке (<a href="mailto:linus@epact.se">linus@epact.se</a>) и Михаэль Мескес (<a href="mailto:meskes@postgresql.org">meskes@postgresql.org</a>). Изначально этот проект
предназначался для C. Сейчас он также работает с C++, но пока не распознаёт все конструкции
C++.
Эта документация не абсолютно полная, но так как этот интерфейс стандартизирован, дополни-
тельные сведения можно почерпнуть во многих ресурсах, посвящённых SQL.
36.1. Концепция
Программа со встраиваемым SQL состоит из кода, написанного на обычном языке программирова-
ния, в данном случае, С, дополненного командами SQL в специально обозначенных секциях. Чтобы
собрать программу, её исходный код (<em>.pgc) сначала нужно пропустить через препроцессор встра-
иваемого SQL, который превратит её в обычную программу на C (</em>.c), которую затем сможет об-
работать компилятор C. (Подробнее компиляция и компоновка описывается в Разделе 36.10). Пре-
образованные приложения ECPG вызывают функции в библиотеке libpq через библиотеку встраи-
ваемого SQL (ecpglib) и взаимодействуют с сервером PostgreSQL по обычному клиент-серверному
протоколу.
Встраиваемый SQL имеет ряд преимуществ по сравнению с другими методами вызова команд SQL
из кода C. Во-первых, этот механизм берёт на себя заботу о передаче информации через перемен-
ные в программе на C. Во-вторых, код SQL в программе проверяется на синтаксическую правиль-
ность во время сборки. В-третьих, встраиваемый SQL в C описан стандартом SQL и поддержива-
ется многими другими СУБД SQL. Реализация в PostgreSQL разработана так, чтобы максималь-
но соответствовать этому стандарту, поэтому обычно достаточно легко портировать в PostgreSQL
программы с встраиваемым SQL, написанные для других СУБД.
Как уже сказано, программы, написанные для интерфейса встраиваемого SQL, представляют со-
бой обычные программы на C с добавленным специальным кодом, который выполняет действия,
связанные с базой данных. Этот специальный код всегда имеет следующую форму:
EXEC SQL …;
Такие операторы синтаксически занимают место операторов C. В зависимости от конкретного опе-
ратора, они могут размещаться на глобальном уровне или внутри функции. Встраиваемые опера-
торы SQL следуют правилам учёта регистра, принятым в обычном коде SQL, а не в C. Они также
допускают вложенные комментарии в стиле C, разрешённые стандартом SQL. Однако остальная
часть программы, написанная на C, в соответствии со стандартом C содержать вложенные ком-
ментарии не может.
Все встраиваемые операторы SQL рассматриваются в следующих разделах.
36.2. Управление подключениями к базе данных
В этом разделе описывается, как открывать, закрывать и переключать подключения к базам дан-
ных.
36.2.1. Подключение к серверу баз данных
Подключение к базе данных выполняется следующим оператором:
EXEC SQL CONNECT TO цель-подключения [AS имя-подключения] [USER имя-пользователя];
Цель может задаваться следующими способами:
• имя_бд[@имя_сервера][:порт]
• tcp:postgresql://имя_сервера[:порт][/имя_бд][?параметры]
843ECPG — встраиваемый SQL в C
• unix:postgresql://имя_сервера[:порт][/имя_бд][?параметры]
• строковая константа SQL, содержащая одну из вышеприведённых записей
• ссылка на символьную переменную, содержащую одну из вышеприведённых записей (см. при-
меры)
• DEFAULT
Если цель подключения задаётся буквально (то есть не через переменную) и значение не заклю-
чается в кавычки, регистр в этой строке не учитывается, как в обычном SQL. В этом случае при
необходимости также можно заключить в двойные кавычки отдельные параметры. На практике,
чтобы не провоцировать ошибки, лучше заключать строку в апострофы, либо передавать её в пе-
ременной. С целью подключения DEFAULT устанавливается подключение к базе данных по умол-
чанию с именем пользователя по умолчанию. Другое имя пользователя или имя подключения в
этом случае указать нельзя.
Также разными способами можно указать имя пользователя:
• имя_пользователя
• имя_пользователя/пароль
• имя_пользователя IDENTIFIED BY пароль
• имя_пользователя USING пароль
В показанных выше строках имя_пользователя и пароль могут задаваться идентификатором или
строковой константой SQL, либо ссылкой на символьную переменную.
Указание имя-подключения применяется, когда в одной программе нужно использовать несколько
подключений. Его можно опустить, если программа работает только с одним подключением. Со-
единение, открытое последним, становится текущим и будет использоваться по умолчанию при
выполнении операторов SQL (это описывается далее в этой главе).
Если к базе данных, которая не приведена в соответствие шаблону безопасного использования
схем, имеют доступ недоверенные пользователи, начинайте сеанс с удаления доступных им для
записи схем из пути поиска (search_path). Например, добавьте options=-csearch_path= в options
или выполните EXEC SQL SELECT pg_catalog.set_config(‘search_path’, ‘’, false); после под-
ключения. Это касается не только ECPG, но и любых других интерфейсов для выполнения произ-
вольных SQL-команд.
Вот некоторые примеры оператора CONNECT:
EXEC SQL CONNECT TO mydb@sql.mydomain.com;
EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;
EXEC SQL BEGIN DECLARE SECTION;
const char <em>target = “mydb@sql.mydomain.com”;
const char *user = “john”;
const char *passwd = “secret”;
EXEC SQL END DECLARE SECTION;
…
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/</em> или EXEC SQL CONNECT TO :target USER :user/:passwd; */
В последней форме используется вариант, названный выше ссылкой на символьную переменную.
В последующих разделах вы узнаете, как в SQL-операторах можно использовать переменные C,
приставляя перед именем двоеточие.
Учтите, что формат цели подключения не описывается в стандарте SQL. Поэтому, если вы хотите
разрабатывать переносимые приложения, имеет смысл применить подход, показанный в послед-
нем примере, и сформировать строку подключения отдельно.
844ECPG — встраиваемый SQL в C
36.2.2. Выбор подключения
SQL-операторы в программах со встраиваемым SQL по умолчанию выполняются с текущим под-
ключением, то есть с подключением, которое было открыто последним. Если приложению нужно
управлять несколькими подключениями, это можно сделать двумя способами.
Первый вариант — явно выбирать подключение для каждого SQL-оператора, например, так:
EXEC SQL AT имя-подключения SELECT …;
Этот вариант хорошо подходит для случаев, когда приложению нужно использовать несколько
подключений в смешанном порядке.
Если ваше приложение выполняется в нескольких потоках, они не могут использовать подключе-
ние одновременно. Поэтому вы должны либо явно управлять доступом (используя мьютексы), либо
использовать отдельные подключения для каждого потока.
Второй вариант — выполнять оператор, переключающий текущее подключение. Этот оператор
записывается так:
EXEC SQL SET CONNECTION имя-подключения;
Этот вариант особенно удобен, когда с одним подключением нужно выполнить несколько опера-
торов.
Следующий пример программы демонстрирует управление несколькими подключениями к базам
данных:
#include <stdio.h>
EXEC SQL BEGIN DECLARE SECTION;
char dbname[1024];
EXEC SQL END DECLARE SECTION;
int
main()
{
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SQL
CONNECT TO testdb1 AS con1 USER testuser;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
CONNECT TO testdb2 AS con2 USER testuser;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
CONNECT TO testdb3 AS con3 USER testuser;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
/* This query would be executed in the last opened database "testdb3". */
EXEC SQL SELECT current_database() INTO :dbname;
printf("current=%s (should be testdb3)\n", dbname);
/* Using "AT" to run a query in "testdb2" */
EXEC SQL AT con2 SELECT current_database() INTO :dbname;
printf("current=%s (should be testdb2)\n", dbname);
/* Switch the current connection to "testdb1". */
EXEC SQL SET CONNECTION con1;
EXEC SQL SELECT current_database() INTO :dbname;
printf("current=%s (should be testdb1)\n", dbname);
EXEC SQL DISCONNECT ALL;
return 0;
}
845ECPG — встраиваемый SQL в C
Этот пример должен вывести следующее:
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
36.2.3. Закрытие подключения
Чтобы закрыть подключение, примените следующий оператор:
EXEC SQL DISCONNECT [подключение];
Подключение можно задать следующими способами:
• имя-подключения
• DEFAULT
• CURRENT
• ALL
Если имя подключения не задано, закрывается текущее подключение.
Хорошим стилем считается, когда приложение явно закрывает каждое подключение, которое оно
открыло.
36.3. Запуск команд SQL
В приложении со встраиваемым SQL можно запустить любую команду SQL. Ниже приведены
несколько примеров, показывающих как это делать.
36.3.1. Выполнение операторов SQL
Создание таблицы:
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
Добавление строк:
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
Удаление строк:
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
Изменение:
EXEC SQL UPDATE foo
SET ascii = 'foobar'
WHERE number = 9999;
EXEC SQL COMMIT;
Операторы SELECT, возвращающие одну строку результата, также могут выполняться непосред-
ственно командой EXEC SQL. Чтобы обработать наборы результатов с несколькими строками, при-
ложение должно использовать курсоры; см. Подраздел 36.3.2 ниже. (В отдельных случаях прило-
жение может выбрать сразу несколько строк в переменную массива; см. Подраздел 36.4.4.3.1.)
Выборка одной строки:
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
Так же можно получить параметр конфигурации командой SHOW:
846ECPG — встраиваемый SQL в C
EXEC SQL SHOW search_path INTO :var;
Идентификаторы вида :имя воспринимаются как переменные среды, то есть они ссылаются на
переменные программы C. Они рассматриваются в Разделе 36.4.
36.3.2. Использование курсоров
Чтобы получить набор результатов, содержащий несколько строк, приложение должно объявить
курсор и выбирать каждую строку через него. Использование курсора подразумевает следующие
шаги: объявление курсора, открытие его, выборку строки через курсор, повторение предыдущего
шага, и наконец, закрытие курсора.
Выборка с использованием курсоров:
EXEC SQL DECLARE foo_bar CURSOR FOR
SELECT number, ascii FROM foo
ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
Более подробно объявление курсора описывается в DECLARE, а команда FETCH описана в FETCH.
Примечание
Команда DECLARE в ECPG на самом деле не передаёт этот оператор серверу PostgreSQL.
Курсор открывается на сервере (командой сервера DECLARE) в момент, когда выполня-
ется команда OPEN.
36.3.3. Управление транзакциями
В режиме по умолчанию операторы фиксируются только когда выполняется EXEC SQL COMMIT. Ин-
терфейс встраиваемого SQL также поддерживает автофиксацию транзакций (так работает libpq
по умолчанию); она включается аргументом командной строки -t программы ecpg (см. ecpg) либо
оператором EXEC SQL SET AUTOCOMMIT TO ON. В режиме автофиксации каждая команда фиксиру-
ется автоматически, если только она не помещена в явный блок транзакции. Этот режим можно
выключить явным образом, выполнив EXEC SQL SET AUTOCOMMIT TO OFF.
Поддерживаются следующие команды управления транзакциями:
EXEC SQL COMMIT
Зафиксировать текущую транзакцию.
EXEC SQL ROLLBACK
Откатить текущую транзакцию.
EXEC SQL PREPARE TRANSACTIONид_транзакции
Подготовить текущую транзакцию для двухфазной фиксации.
EXEC SQL COMMIT PREPAREDид_транзакции
Зафиксировать транзакцию в подготовленном состоянии.
EXEC SQL ROLLBACK PREPAREDид_транзакции
Откатить транзакцию в подготовленном состоянии.
847ECPG — встраиваемый SQL в C
EXEC SQL SET AUTOCOMMIT TO ON
Включить режим автофиксации.
EXEC SQL SET AUTOCOMMIT TO OFF
Отключить режим автофиксации. По умолчанию он отключён.
36.3.4. Подготовленные операторы
Когда значения, передаваемые оператору SQL, неизвестны во время компиляции, или один и тот
же оператор будет использоваться многократно, могут быть полезны подготовленные операторы.
Оператор подготавливается командой PREPARE. Вместо значений, которые ещё неизвестны, встав-
ляются местозаполнители «?»:
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
Если оператор возвращает одну строку, приложение может вызвать EXECUTE после PREPARE для
выполнения этого оператора, указав фактические значения для местозаполнителей в предложе-
нии USING:
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
Если оператор возвращает несколько строк, приложение может использовать курсор, объявлен-
ный на базе подготовленного оператора. Чтобы привязать входные параметры, курсор нужно от-
крыть с предложением USING:
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
...
}
EXEC SQL CLOSE foo_bar;
Когда подготовленный оператор больше не нужен, его следует освободить:
EXEC SQL DEALLOCATE PREPARE имя;
Подробнее оператор PREPARE описан в PREPARE. Также обратитесь к Разделу 36.5 за дополнитель-
ными сведениями о местозаполнителях и входных параметрах.
36.4. Использование переменных среды
В Разделе 36.3 вы увидели, как можно выполнять операторы SQL в программе со встраиваемым
SQL. Некоторые из этих операторов использовали только фиксированные значения и не давали
возможности вставлять в операторы произвольные значения или обрабатывать значения, возвра-
щённые запросом. Операторы такого вида не очень полезны в реальных приложениях. В этом раз-
деле подробно описывается, как можно передавать данные между программой на C и встраивае-
мыми операторами SQL, используя простой механизм, так называемые переменные среды. В про-
грамме со встраиваемым SQL мы считаем SQL-операторы внедрёнными в код программы на C,
языке среды. Таким образом, переменные программы на C называются переменными среды.
Ещё один способ передать значения данных между сервером PostgreSQL и приложениями ECPG
заключается в использовании дескрипторов SQL, как описано в Разделе 36.7.
848ECPG — встраиваемый SQL в C
36.4.1. Обзор
Передавать данные между программой C и операторами SQL во встраиваемом SQL очень просто.
Вместо того, чтобы вставлять данные в оператор, что влечёт дополнительные усложнения, в част-
ности нужно правильно заключать значения в кавычки, можно просто записать имя переменной
C в операторе SQL, предварив его двоеточием. Например:
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
Этот оператор обращается к двум переменным C с именами v1 и v2 и также использует обычную
строковую константу SQL, показывая тем самым, что можно свободно сочетать разные виды дан-
ных.
Этот метод включения переменных C в операторы SQL работает везде, где оператор SQL прини-
мает выражение значения.
36.4.2. Секции объявлений
Чтобы передать данные из программы в базу данных, например, в виде параметров запроса, либо
получить данные из базы данных в программе, переменные C, которые должны содержать эти
данные, нужно объявить в специально помеченных секциях, чтобы препроцессор встраиваемого
SQL знал о них.
Секция начинается с:
EXEC SQL BEGIN DECLARE SECTION;
и заканчивается командой:
EXEC SQL END DECLARE SECTION;
Между этими строками должны располагаться обычные объявления переменных C, например:
int
char
x = 4;
foo[16], bar[16];
Как здесь показано, переменной можно присвоить начальное значение. Область видимости пере-
менной определяется расположением секции, в которой она объявляется в программе. Вы также
можете объявить переменную следующим образом (при этом неявно создаётся секция объявле-
ний):
EXEC SQL int i = 4;
Вы можете включать в программу столько секций объявлений, сколько захотите.
Эти объявления выводятся в результирующий файл как объявления обычных переменных C, так
что эти переменные не нужно объявлять снова. Переменные, которые не предназначены для ис-
пользования в командах SQL, можно объявить как обычно вне этих специальных секций.
Определение структуры или объединения тоже должно размещаться в секции DECLARE. В против-
ном случае препроцессор не сможет воспринять эти типы, так как не будет знать их определения.
36.4.3. Получение результатов запроса
Теперь вы умеете передавать данные, подготовленные вашей программой, в команду SQL. Но как
получить результаты запроса? Для этой цели во встраиваемом SQL есть особые вариации обычных
команд SELECT и FETCH. У этих команд есть специальное предложение INTO, определяющее, в ка-
кие переменные среды будут помещены получаемые значения. SELECT используется для запросов,
возвращающих только одну строку, а FETCH применяется с курсором для запросов, возвращающих
несколько строк.
Пример:
/*
849ECPG — встраиваемый SQL в C</stdio.h></p>
<ul>
  <li>предполагается существование такой таблицы:</li>
  <li>CREATE TABLE test1 (a int, b varchar(50));
*/
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;
…
EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
Предложение INTO размещается между списком выборки и предложением FROM. Число элементов
в списке выборки должно равняться числу элементов в списке после INTO (также называемом це-
левым списком).
Следующий пример демонстрирует использование команды FETCH:
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;
…
EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;
…
do
{
…
EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
…
} while (…);
Здесь предложение INTO размещается после всех остальных обычных предложений.
36.4.4. Сопоставление типов
Когда приложения ECPG передают данные между сервером PostgreSQL и программой на C, напри-
мер, получая результаты запроса с сервера или выполняя операторы SQL с входными параметрам,
эти данные должны преобразовываться из типов PostgreSQL в типы переменных языка среды (а
именно типы языка C) и наоборот. Одно из главных качеств ECPG состоит в том, что в большинстве
случаев он делает это автоматически.
В этом отношении можно выделить два вида типов данных. К первому относятся простые типы
данных PostgreSQL, такие как integer и text, которые приложение может непосредственно читать
и писать. С другими типами данных, такими как timestamp и numeric, можно работать только через
специальные функции; см. Подраздел 36.4.4.2.
В Таблице 36.1 показано, как типы данных PostgreSQL соответствуют типам данных C. Когда нужно
передать или получить значение определённого типа данных PostgreSQL, вы должны объявить
переменную C соответствующего типа C в секции объявлений.
Таблица 36.1. Соответствие между типами данных PostgreSQL и типами переменных C
Тип данных PostgreSQL Тип переменной среды
smallint short
850ECPG — встраиваемый SQL в C
Тип данных PostgreSQL Тип переменной среды
integer int
bigint long long int
decimal decimal
numeric numeric
real float
double precision double
smallserial short
serial int
bigserial long long int
oid unsigned int
character( n), varchar( n), text char[n+1], VARCHAR[n+1]
name char[NAMEDATALEN]
timestamp timestamp
interval interval
date date
boolean bool
bytea char *
a
a
b
a
a
a
c
a
С этим типом можно работать только через специальные функции; см. Подраздел 36.4.4.2.
b
c
объявляется в ecpglib.h
объявляется в ecpglib.h при отсутствии стандартного объявления
36.4.4.1. Работа с символьными строками
Для обработки типов символьных строк SQL, таких как varchar и text, предлагаются два варианта
объявления переменных среды.
Первый способ заключается в использовании char[], массива char, как чаще всего и представля-
ются символьные данные в C.
EXEC SQL BEGIN DECLARE SECTION;
char str[50];
EXEC SQL END DECLARE SECTION;
Заметьте, что о длине этого массива вы должны подумать сами. Если вы укажете данную перемен-
ную среды в качестве целевой переменной запроса, возвращающего строку длиннее 49 символов,
произойдёт переполнение буфера.
В качестве другого подхода можно использовать специальный тип VARCHAR, представленный в
ECPG. Определение массива типа VARCHAR преобразуется в структуру (struct) с собственным име-
нем для каждой переменной. Объявление вида:
VARCHAR var[180];
преобразуется в:
struct varchar_var { int len; char arr[180]; } var;
Член структуры arr содержит строку, включающую завершающий нулевой байт. Таким образом,
чтобы сохранить строку в переменной типа VARCHAR, эта переменная должна быть объявлена с
длиной, учитывающей завершающий нулевой байт. Член структуры len содержит длину строки,
сохранённой в arr, без завершающего нулевого байта. Когда на вход запросу подаётся переменная
среды, у которой strlen(arr) отличается от len, применяется наименьшее значение.
VARCHAR можно записать в верхнем или нижнем регистре, но не в смешанном.
851ECPG — встраиваемый SQL в C
Переменные char и VARCHAR также могут содержать значения других типов SQL в их строковом
представлении.
36.4.4.2. Обработка специальных типов данных
ECPG представляет некоторые особые типы, которые должны помочь вам легко оперировать неко-
торыми специальными типами данных PostgreSQL. В частности, в нём реализована поддержка ти-
пов numeric, decimal, date, timestamp и interval. Для этих типов нельзя подобрать полезное со-
ответствие с примитивными типами среды (например, int, long long int или char[]), так как
они имеют сложную внутреннюю структуру. Приложения, работающие с этими типами, должны
объявлять переменные особых типов и работать с ними, применяя функции из библиотеки pgtypes.
Эта библиотека, подробно описанная в Разделе 36.6 содержит базовые функции для оперирования
этими типами, чтобы вам не требовалось, например, передавать запрос SQL-серверу, когда нужно
просто добавить интервал к значению времени.
Эти особые типы данных описаны в следующих подразделах. Чтобы подробнее узнать о функциях
в библиотеке pgtypes, обратитесь к Разделу 36.6.
36.4.4.2.1. timestamp, date
Для работы с переменными timestamp в приложении ECPG применяется следующая схема.
Сначала в программу нужно включить заголовочный файл, чтобы получить определение типа
timestamp:
#include <pgtypes_timestamp.h>
Затем объявите в секции объявлений переменную типа timestamp:
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
Прочитав значение в эту переменную, выполняйте действия с ним, используя функции в библио-
теке pgtypes. В следующем примере значение timestamp преобразуется в текстовый вид (ASCII) с
помощью функции PGTYPEStimestamp_to_asc():
EXEC SQL SELECT now()::timestamp INTO :ts;
printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
Этот пример выведет такой результат:
ts = 2010-06-27 18:03:56.949343
Таким же образом можно работать и с типом DATE. В программу нужно включить pgtypes_date.h,
объявить переменную типа date, и затем можно будет преобразовать значение DATE в текстовый
вид, используя функцию PGTYPESdate_to_asc(). Чтобы подробнее узнать о функциях в библиотеке
pgtypes, обратитесь к Разделу 36.6.
36.4.4.2.2. interval
Принцип работы с типом interval тот же, что и с типами timestamp и date, однако для значения
типа interval нужно явно выделить память. Другими словами, блок памяти для этой переменной
должен размещаться в области кучи, а не в стеке.
Пример программы:
#include <stdio.h>
#include <stdlib.h>
#include <pgtypes_interval.h>
852ECPG — встраиваемый SQL в C
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
interval *in;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
in = PGTYPESinterval_new();
EXEC SQL SELECT '1 min'::interval INTO :in;
printf("interval = %s\n", PGTYPESinterval_to_asc(in));
PGTYPESinterval_free(in);
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
36.4.4.2.3. numeric, decimal
Типы numeric и decimal обрабатываются так же, как и тип interval: вы должны определить ука-
затель, выделить некоторое пространство памяти в куче и обращаться к переменной, используя
функции в библиотеке pgtypes. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обрати-
тесь к Разделу 36.6.
Для типа decimal никакие специальные функции не реализованы. Для дальнейшей обработки при-
ложение должно преобразовать его в переменную numeric, применив функцию из библиотеки
pgtypes.
Следующий пример демонстрирует работу с переменными типов numeric и decimal.
#include <stdio.h>
#include <stdlib.h>
#include <pgtypes_numeric.h>
EXEC SQL WHENEVER SQLERROR STOP;
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
numeric *num;
numeric *num2;
decimal *dec;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
num = PGTYPESnumeric_new();
dec = PGTYPESdecimal_new();
EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;
printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));
853ECPG — встраиваемый SQL в C
/* Преобразовать decimal в numeric, чтобы вывести десятичное значение. */
num2 = PGTYPESnumeric_new();
PGTYPESnumeric_from_decimal(dec, num2);
printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));
PGTYPESnumeric_free(num2);
PGTYPESdecimal_free(dec);
PGTYPESnumeric_free(num);
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
36.4.4.3. Переменные среды для непримитивных типов
В качестве переменных среды также можно использовать массивы, определения типов, структуры
и указатели.
36.4.4.3.1. Массивы
Для применения массивов в качестве переменных среды есть два варианта использования. Во-
первых, в массиве char[] или VARCHAR[] можно сохранить текстовую строку, как рассказывалось
в Подразделе 36.4.4.1. Во-вторых, в массив можно получить несколько строк из результата запро-
са, не используя курсор. Чтобы не применяя массивы, обработать результат запроса, состоящий
из нескольких строк, нужно использовать курсор и команду FETCH. Но с переменными-массивами
несколько строк можно получить сразу. Длина определяемого массива должна быть достаточной
для размещения всех строк, иначе скорее всего произойдёт переполнение буфера.
Следующий пример сканирует системную таблицу pg_database и показывает все OID и имена до-
ступных баз данных:
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
int dbid[8];
char dbname[8][16];
int i;
EXEC SQL END DECLARE SECTION;
memset(dbname, 0, sizeof(char)* 16 * 8);
memset(dbid, 0, sizeof(int) * 8);
EXEC SQL CONNECT TO testdb;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
/* Получить в массивы сразу несколько строк. */
EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;
for (i = 0; i &lt; 8; i++)
printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
854ECPG — встраиваемый SQL в C
Этот пример выводит следующий результат. (Точные значения зависят от локальных обстоя-
тельств.)
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
36.4.4.3.2. Структуры
Для получения значений сразу нескольких столбцов можно применить структуру, имена членов
которой совпадают с именами столбцов результата запроса. Структура позволяет обрабатывать
значения нескольких столбцов в одной переменной среды.
Следующий пример получает значения OID, имена и размеры имеющихся баз данных из систем-
ной таблицы pg_database, используя при этом функцию pg_database_size(). В этом примере пе-
ременная типа структуры dbinfo_t с членами, имена которых соответствуют именам всех столбцов
результата SELECT, применяется для получения одной строки результата без вовлечения в опера-
тор FETCH нескольких переменных среды.
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
int oid;
char datname[65];
long long int size;
} dbinfo_t;
dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;
memset(&amp;dbval, 0, sizeof(dbinfo_t));
EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size
FROM pg_database;
EXEC SQL OPEN cur1;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать несколько столбцов в одну структуру. */
EXEC SQL FETCH FROM cur1 INTO :dbval;
/* Напечатать члены структуры. */
printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname,
dbval.size);
}
EXEC SQL CLOSE cur1;
Этот пример показывает следующий результат. (Точные значения зависят от локальных обстоя-
тельств.)
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
855ECPG — встраиваемый SQL в C
oid=313780, datname=testdb, size=8183012
Переменные среды типа структуры «вбирают в себя» столько столбцов, сколько полей содержит
структура. Значения дополнительных столбцов можно присвоить другим переменным среды. На-
пример, приведённую выше программу можно видоизменить следующим образом, разместив пе-
ременную size вне структуры:
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
int oid;
char datname[65];
} dbinfo_t;
dbinfo_t dbval;
long long int size;
EXEC SQL END DECLARE SECTION;
memset(&amp;dbval, 0, sizeof(dbinfo_t));
EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size
FROM pg_database;
EXEC SQL OPEN cur1;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать несколько столбцов в одну структуру. */
EXEC SQL FETCH FROM cur1 INTO :dbval, :size;
/* Напечатать члены структуры. */
printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
}
EXEC SQL CLOSE cur1;
36.4.4.3.3. Определения типов
Чтобы сопоставить новые типы с уже существующими, используйте ключевое слово typedef.
EXEC SQL BEGIN DECLARE SECTION;
typedef char mychartype[40];
typedef long serial_t;
EXEC SQL END DECLARE SECTION;
Заметьте, что вы также можете написать:
EXEC SQL TYPE serial_t IS long;
Это объявление не обязательно должно находиться в секции объявлений.
36.4.4.3.4. Указатели
Вы можете объявлять указатели на самые распространённые типы. Учтите, однако, что указате-
ли нельзя использовать в качестве целевых переменных запросов без автовыделения. За дополни-
тельными сведениями об автовыделении обратитесь к Разделу 36.7.
EXEC SQL BEGIN DECLARE SECTION;
int
*intp;
char **charp;
EXEC SQL END DECLARE SECTION;
856ECPG — встраиваемый SQL в C
36.4.5. Обработка непримитивных типов данных SQL
В этом разделе описывается как работать с нескалярными и пользовательскими типами уровня
SQL в приложениях ECPG. Заметьте, что этот подход отличается от использования переменных
непримитивных типов, описанного в предыдущем разделе.
36.4.5.1. Массивы
Многомерные массивы уровня SQL в ECPG напрямую не поддерживаются, но одномерные масси-
вы уровня SQL могут быть сопоставлены с переменными-массивами среды C и наоборот. Однако
учтите, что когда создаётся оператор, ecpg не знает типов столбцов, поэтому не может проверить,
вводится ли массив C в соответствующий массив уровня SQL. Обрабатывая результат оператора
SQL, ecpg имеет необходимую информацию и таким образом может убедиться, что с обеих сторон
массивы.
Если запрос обращается к отдельным элементам массива, это избавляет от необходимости приме-
нять массивы в ECPG. В этом случае следует использовать переменную среды, имеющую тип, ко-
торый можно сопоставить типу элемента. Например, если типом столбца является массив integer,
можно использовать переменную среды типа int. Аналогично, если тип элемента — varchar или
text, можно использовать переменную типа char[] или VARCHAR[].
Предположим, что у нас есть таблица:
CREATE TABLE t3 (
ii integer[]
);
testdb=&gt; SELECT * FROM t3;
ii
-------------
{1,2,3,4,5}
(1 row)
Следующая программа получает 4-ый элемент массива и сохраняет его в переменной среды, име-
ющей тип int:
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH FROM cur1 INTO :ii ;
printf("ii=%d\n", ii);
}
EXEC SQL CLOSE cur1;
Этот пример выводит следующий результат:
ii=4
Чтобы сопоставить несколько элементов массива с несколькими элементами переменной-масси-
вом среды, каждый элемент массива SQL нужно по отдельности связать с каждым элементом мас-
сива среды, например:
EXEC SQL BEGIN DECLARE SECTION;
857ECPG — встраиваемый SQL в C
int ii_a[8];
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
...
}
Ещё раз обратите внимание, что в этом случае вариант
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* НЕПРАВИЛЬНО */
EXEC SQL FETCH FROM cur1 INTO :ii_a;
...
}
не будет работать корректно, так как столбец с типом массива нельзя напрямую сопоставить с
переменной-массивом среды.
Можно также применить обходное решение — хранить массивы в их внешнем строковом представ-
лении в переменных среды типа char[] или VARCHAR[]. Более подробно это представление описы-
вается в Подразделе 8.15.2. Заметьте, это означает, что с таким массивом в программе нельзя бу-
дет работать естественным образом (без дополнительного разбора текстового представления).
36.4.5.2. Составные типы
Составные типы в ECPG напрямую не поддерживаются, но есть простое обходное решение. Для
решения этой проблемы можно применить те же подходы, что были описаны выше для массивов:
обращаться к каждому атрибуту по отдельности или использовать внешнее строковое представле-
ние.
Для следующих примеров предполагается, что существует такой тип и таблица:
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
Самое очевидное решение заключается в обращении к каждому атрибуту по отдельности. Следу-
ющая программа получает данные из тестовой таблицы, выбирая атрибуты типа comp_t по одному:
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;
/* Указать каждый элемент столбца составного типа в списке SELECT. */
858ECPG — встраиваемый SQL в C
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать каждый элемент столбца составного типа в переменную среды. */
EXEC SQL FETCH FROM cur1 INTO :intval, :textval;
printf("intval=%d, textval=%s\n", intval, textval.arr);
}
EXEC SQL CLOSE cur1;
В развитие этого примера, переменные среды, в которые помещаются результаты команды FETCH,
можно собрать в одну структуру. Подробнее переменные среды в форме структуры описываются
в Подразделе 36.4.4.3.2. Чтобы перейти к структуре, пример можно изменить как показано ниже.
Переменные среды, intval и textval, становятся членами структуры comp_t, и эта структура ука-
зывается в команде FETCH.
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
int intval;
varchar textval[33];
} comp_t;
comp_t compval;
EXEC SQL END DECLARE SECTION;
/* Поместить каждый элемент составного типа в список SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Поместить все значения списка SELECT в одну структуру. */
EXEC SQL FETCH FROM cur1 INTO :compval;
printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
EXEC SQL CLOSE cur1;
Хотя в команде FETCH используется структура, имена атрибутов в предложении SELECT задаются
по одному. Это можно дополнительно улучшить, написав *, что будет обозначать все атрибуты
значения составного типа.
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать все значения в списке SELECT в одну структуру. */
859ECPG — встраиваемый SQL в C
EXEC SQL FETCH FROM cur1 INTO :compval;
printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
Таким образом составные типы можно сопоставить со структурами практически прозрачно, хотя
ECPG и не понимает составные типы.
Наконец, также можно сохранить значения составного типа в их внешнем строковом представле-
нии в переменных среды типа char[] или VARCHAR[]. Однако при таком подходе нет простой воз-
можности обращаться из программы к полям значения.
36.4.5.3. Пользовательские базовые типы
Определяемые пользователем базовые типы не поддерживаются ECPG напрямую. Для них можно
использовать внешнее строковое представление и переменные среды типа char[] или VARCHAR[],
и это решение действительно будет подходящим и достаточным для большинства типов.
Следующий фрагмент кода демонстрирует использование типа данных complex из примера в Раз-
деле  38.12. Внешнее строковое представление этого типа имеет форму (%f,%f) и определено в
функциях complex_in() и complex_out() в Разделе 38.12. Следующий пример вставляет значения
комплексного типа (1,1) и (3,3) в столбцы a и b, а затем выбирает их из таблицы.
EXEC SQL BEGIN DECLARE SECTION;
varchar a[64];
varchar b[64];
EXEC SQL END DECLARE SECTION;
EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');
EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH FROM cur1 INTO :a, :b;
printf("a=%s, b=%s\n", a.arr, b.arr);
}
EXEC SQL CLOSE cur1;
Этот пример выводит следующий результат:
a=(1,1), b=(3,3)
Другое обходное решение состоит в том, чтобы избегать прямого использования пользовательских
типов в ECPG, а вместо этого создать функцию или приведение, выполняющее преобразование
между пользовательским типом и примитивным типом, который может обработать ECPG. Заметь-
те, однако, что приведения типов, особенно неявные, нужно добавлять в систему типов очень осто-
рожно.
Например:
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
После такого определения следующий код
860ECPG — встраиваемый SQL в C
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;
a
b
c
d
=
=
=
=
1;
2;
3;
4;
EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b),
create_complex(:c, :d));
будет работать так же, как
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
36.4.6. Индикаторы
Приведённые выше примеры никак не обрабатывали значения NULL. На самом деле, в примерах с
извлечением данных возникнет ошибка, если они выберут из базы данных значение NULL. Чтобы
можно было передавать значения NULL в базу данных или получать их из базы данных, вы долж-
ны добавить объявление второй переменной среды для каждой переменной среды, содержащей
данные. Эта вторая переменная среды называется индикатором и содержит флаг, показывающий,
что в данных передаётся NULL, и при этом значение основной переменной среды игнорируется.
Следующий пример демонстрирует правильную обработку значений NULL:
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:
...
EXEC SQL SELECT b INTO :val :val_ind FROM test1;
Переменная индикатора val_ind будет равна нулю, если значение не NULL, или отрицательному
числу, если NULL.
Индикатор выполняет ещё одну функцию: если он содержит положительное число, это означает,
что значение не NULL, но оно было обрезано, когда сохранялось в переменной среды.
Если препроцессору ecpg передаётся аргумент -r no_indicator, он работает в режиме «без ин-
дикатора». В этом режиме, если переменная индикатора не определена, значения NULL обозна-
чаются (при вводе и выводе) для символьных строк пустой строкой, а для целочисленных типов
наименьшим возможным значением этого типа (например, INT_MIN для int).
36.5. Динамический SQL
Во многих случаях конкретные операторы SQL, которые должно выполнять приложение, известны
в момент написания приложения. В некоторых случаях, однако, операторы SQL формируются во
время выполнения или поступают из внешнего источника. В этих случаях операторы SQL нельзя
внедрить непосредственно в исходный код C, но есть средство, позволяющее вызывать произволь-
ные операторы SQL, передаваемые в строковой переменной.
36.5.1. Выполнение операторов без набора результатов
Самый простой способ выполнить произвольный оператор SQL — применить команду EXECUTE
IMMEDIATE. Например:
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;
861ECPG — встраиваемый SQL в C
EXEC SQL EXECUTE IMMEDIATE :stmt;
EXECUTE IMMEDIATE можно применять для SQL-операторов, которые не возвращают набор резуль-
татов (например, DDL, INSERT, UPDATE, DELETE). Выполнять операторы, которые получают данные,
(например, SELECT) таким образом нельзя. Как выполнять такие операторы, рассказывается в сле-
дующем разделе.
36.5.2. Выполнение оператора с входными параметрами
Более эффективно выполнять произвольный оператор SQL можно, подготовив его один раз, а за-
тем запуская подготовленный оператор столько, сколько нужно. Также можно подготовить обоб-
щённую версию оператора, а затем выполнять специализированные его версии, подставляя в него
параметры. Подготавливая оператор, поставьте знаки вопроса там, где позже хотите подставить
параметры. Например:
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE mystmt FROM :stmt;
...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
Когда подготовленный оператор больше не нужен, его следует освободить:
EXEC SQL DEALLOCATE PREPARE имя;
36.5.3. Выполнение оператора с набором результатов
Для выполнения оператора SQL с одной строкой результата можно применить команду EXECUTE.
Чтобы сохранить результат, добавьте предложение INTO.
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a &gt; ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE mystmt FROM :stmt;
...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
Команда EXECUTE может содержать предложение INTO и/или предложение USING, либо не содер-
жать ни того, ни другого.
Если ожидается, что запрос вернёт более одной строки результата, следует применять курсор, как
показано в следующем примере. (Подробно курсоры описываются в Подразделе 36.3.2.)
EXEC
char
char
char
SQL BEGIN DECLARE SECTION;
dbaname[128];
datname[128];
*stmt = "SELECT u.usename as dbaname, d.datname "
" FROM pg_database d, pg_user u "
" WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL PREPARE stmt1 FROM :stmt;
862ECPG — встраиваемый SQL в C
EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
printf("dbaname=%s, datname=%s\n", dbaname, datname);
}
EXEC SQL CLOSE cursor1;
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
36.6. Библиотека pgtypes
Библиотека pgtypes сопоставляет типы базы данных PostgreSQL с их эквивалентами в C, которые
можно использовать в программах на C. Она также предлагает функции для выполнения простых
вычислений с этими типами в C, то есть без помощи сервера PostgreSQL. Рассмотрите следующий
пример:
EXEC SQL BEGIN DECLARE SECTION;
date date1;
timestamp ts1, tsout;
interval iv1;
char *out;
EXEC SQL END DECLARE SECTION;
PGTYPESdate_today(&amp;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&amp;ts1, &amp;iv1, &amp;tsout);
out = PGTYPEStimestamp_to_asc(&amp;tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);
36.6.1. Символьные строки
Некоторые функции, в частности PGTYPESnumeric_to_asc, возвращают указатель на строку в выде-
ленной для неё памяти. Их результаты должны освобождаться функцией PGTYPESchar_free, а не
free. (Это важно только в Windows, где выделение и освобождение памяти в определённых случа-
ях должно производиться одной библиотекой.)
36.6.2. Тип numeric
Тип numeric позволяет производить вычисления с произвольной точностью. Эквивалентный ему
тип на сервере PostgreSQL описан в Разделе 8.1. Ввиду того, что переменная имеет произвольную
точность, она должна расширяться и сжиматься динамически. Поэтому такие переменные можно
создавать только в области кучи, используя функции PGTYPESnumeric_new и PGTYPESnumeric_free.
Тип decimal подобен numeric, но имеет ограниченную точность, и поэтому может размещаться и
в области кучи, и в стеке.
Для работы с типом numeric можно использовать следующие функции:
PGTYPESnumeric_new
Запрашивает указатель на новую переменную, размещённую в памяти.
863ECPG — встраиваемый SQL в C
numeric *PGTYPESnumeric_new(void);
PGTYPESnumeric_free
Освобождает переменную типа numeric, высвобождая всю её память.
void PGTYPESnumeric_free(numeric *var);
PGTYPESnumeric_from_asc
Разбирает числовой тип из строковой записи.
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
Допускаются в частности следующие форматы: -2, .794, +3.44, 592.49E07 и -32.84e-4. Если
значение удаётся разобрать успешно, возвращается действительный указатель, в противном
случае указатель NULL. На данный момент ECPG всегда разбирает строку до конца, так что эта
функция не может вернуть адрес первого недопустимого символа в *endptr. Поэтому в endptr
свободно можно передать NULL.
PGTYPESnumeric_to_asc
Возвращает указатель на строку, выделенную функцией malloc и содержащую строковое пред-
ставление значения num числового типа.
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
Числовое значение будет выводиться с заданным в dscale количеством цифр после запятой,
округлённое при необходимости. Результат нужно освободить функцией PGTYPESchar_free().
PGTYPESnumeric_add
Суммирует две числовые переменные и возвращает результат в третьей.
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
Эта функция суммирует переменные var1 и var2 в результирующую переменную result. Функ-
ция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_sub
Вычисляет разность двух числовых переменных и возвращает результат в третьей.
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
Эта функция вычитает переменную var2 из var1. Результат операции помещается в перемен-
ную result. Функция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_mul
Перемножает две числовые переменные и возвращает результат в третьей.
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
Эта функция перемножает переменные var1 и var2. Результат операции сохраняется в пере-
менной result. Функция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_div
Вычисляет частное двух числовых переменных и возвращает результат в третьей.
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
Эта функция делит переменную var1 на var2. Результат операции сохраняется в переменной
result. Функция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_cmp
Сравнивает две числовые переменные.
864ECPG — встраиваемый SQL в C
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
Эта функция производит сравнение двух числовых переменных. При ошибке возвращается
INT_MAX. В случае успеха функция возвращает одно из трёх возможных значений:
• 1, если var1 больше var2
• -1, если var1 меньше var2
• 0, если var1 и var2 равны
PGTYPESnumeric_from_int
Преобразует переменную int в переменную numeric.
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
Эта функция принимает целочисленную переменную со знаком типа signed int и сохраняет
её значение в переменной var типа numeric. Функция возвращает 0 в случае успеха и -1 при
ошибке.
PGTYPESnumeric_from_long
Преобразует переменную long int в переменную numeric.
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
Эта функция принимает целочисленную переменную со знаком типа signed long int и сохраняет
её значение в переменной var типа numeric. Функция возвращает 0 в случае успеха и -1 при
ошибке.
PGTYPESnumeric_copy
Копирует одну числовую переменную в другую.
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
Эта функция копирует значение переменной, на которую указывает src, в переменную, на ко-
торую указывает dst. Она возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_from_double
Преобразует переменную типа double в переменную numeric.
int
PGTYPESnumeric_from_double(double d, numeric *dst);
Эта функция принимает переменную типа double и сохраняет преобразованное значение в пе-
ременной, на которую указывает dst. Она возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_to_double
Преобразует переменную типа numeric в переменную double.
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
Эта функция преобразует значение типа numeric переменной, на которую указывает nv, в пе-
ременную типа double, на которую указывает dp. Она возвращает 0 в случае успеха и -1 при
ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной пере-
менной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
PGTYPESnumeric_to_int
Преобразует переменную типа numeric в переменную int.
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
Эта функция преобразует значение типа numeric переменной, на которую указывает nv, в це-
лочисленную переменную, на которую указывает ip. Она возвращает 0 в случае успеха и -1
при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной пе-
ременной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
865ECPG — встраиваемый SQL в C
PGTYPESnumeric_to_long
Преобразует переменную типа numeric в переменную long.
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
Эта функция преобразует значение типа numeric переменной, на которую указывает nv, в цело-
численную переменную типа long, на которую указывает lp. Она возвращает 0 в случае успеха
и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной
переменной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
PGTYPESnumeric_to_decimal
Преобразует переменную типа numeric в переменную decimal.
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
Эта функция преобразует значение типа numeric переменной, на которую указывает src, в пе-
ременную типа decimal, на которую указывает dst. Она возвращает 0 в случае успеха и -1 при
ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной пере-
менной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
PGTYPESnumeric_from_decimal
Преобразует переменную типа decimal в переменную numeric.
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
Эта функция преобразует значение типа decimal переменной, на которую указывает src, в пе-
ременную типа numeric, на которую указывает dst. Она возвращает 0 в случае успеха и -1 при
ошибке. Так как тип decimal реализован как ограниченная версия типа numeric, при таком
преобразовании переполнение невозможно.
36.6.3. Тип date
Тип date, реализованный в C, позволяет программам работать с данными типа date в SQL. Соот-
ветствующий тип сервера PostgreSQL описан в Разделе 8.5.
Для работы с типом date можно использовать следующие функции:
PGTYPESdate_from_timestamp
Извлекает часть даты из значения типа timestamp.
date PGTYPESdate_from_timestamp(timestamp dt);
Эта функция получает в единственном аргументе значение времени типа timestamp и возвра-
щает извлечённую из него дату.
PGTYPESdate_from_asc
Разбирает дату из её текстового представления.
date PGTYPESdate_from_asc(char *str, char **endptr);
Эта функция получает строку C char* str и указатель на строку C char* endptr. На данный
момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес
первого недопустимого символа в *endptr. Поэтому в endptr свободно можно передать NULL.
Заметьте, что эта функция всегда подразумевает формат дат MDY (месяц-день-год) и никакой
переменной для изменения этого формата в ECPG нет.
Все допустимые форматы ввода перечислены в Таблице 36.2.
Таблица 36.2. Допустимые форматы ввода для PGTYPESdate_from_asc
Ввод Результат
January 8, 1999 January 8, 1999
866ECPG — встраиваемый SQL в C
Ввод Результат
1999-01-08 January 8, 1999
1/8/1999 January 8, 1999
1/18/1999 January 18, 1999
01/02/03 February 1, 2003
1999-Jan-08 January 8, 1999
Jan-08-1999 January 8, 1999
08-Jan-1999 January 8, 1999
99-Jan-08 January 8, 1999
08-Jan-99 January 8, 1999
08-Jan-06 January 8, 2006
Jan-08-99 January 8, 1999
19990108 ISO 8601; January 8, 1999
990108 ISO 8601; January 8, 1999
1999.008 год и день года
J2451187 День по юлианскому календарю
January 8, 99 BC 99 год до нашей эры
PGTYPESdate_to_asc
Возвращает текстовое представление переменной типа date.
char *PGTYPESdate_to_asc(date dDate);
Эта функция получает в качестве единственного параметра дату dDate и выводит её в ви-
де 1999-01-18, то есть в формате YYYY-MM-DD. Результат необходимо освободить функцией
PGTYPESchar_free().
PGTYPESdate_julmdy
Извлекает значения дня, месяца и года из переменной типа date.
void PGTYPESdate_julmdy(date d, int *mdy);
Эта функция получает дату d и указатель на 3 целочисленных значения mdy. Имя переменной
указывает на порядок значений: в mdy[0] записывается номер месяца, в mdy[1] — номер дня,
а в mdy[2] — год.
PGTYPESdate_mdyjul
Образует значение даты из массива 3 целых чисел, задающих день, месяц и год даты.
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
Эта функция получает в первом аргументе массив из 3 целых чисел (mdy), а во втором указатель
на переменную типа date, в которую будет помещён результат операции.
PGTYPESdate_dayofweek
Возвращает число, представляющее день недели для заданной даты.
int PGTYPESdate_dayofweek(date d);
Эта функция принимает в единственном аргументе переменную d типа date и возвращает целое
число, выражающее день недели для этой даты.
• 0 — Воскресенье
• 1 — Понедельник
867ECPG — встраиваемый SQL в C
• 2 — Вторник
• 3 — Среда
• 4 — Четверг
• 5 — Пятница
• 6 — Суббота
PGTYPESdate_today
Выдаёт текущую дату.
void PGTYPESdate_today(date *d);
Эта функция получает указатель на переменную (d) типа date, в которую будет записана теку-
щая дата.
PGTYPESdate_fmt_asc
Преобразует переменную типа date в текстовое представление по маске формата.
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
Эта функция принимает дату для преобразования (dDate), маску формата (fmtstring) и строку,
в которую будет помещено текстовое представление даты (outbuf).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
В строке формата можно использовать следующие коды полей:
• dd — Номер дня в месяце.
• mm — Номер месяца в году.
• yy — Номер года в виде двух цифр.
• yyyy — Номер года в виде четырёх цифр.
• ddd — Название дня недели (сокращённое).
• mmm — Название месяца (сокращённое).
Все другие символы копируются в выводимую строку 1:1.
В Таблице  36.3 перечислены несколько возможных форматов. Это даёт представление, как
можно использовать эту функцию. Все строки вывода даны для одной даты: 23 ноября 1959 г.
Таблица 36.3. Допустимые форматы ввода для PGTYPESdate_fmt_asc
Формат Результат
mmddyy 112359
ddmmyy 231159
yymmdd 591123
yy/mm/dd 59/11/23
yy mm dd 59 11 23
yy.mm.dd 59.11.23
.mm.yyyy.dd. .11.1959.23.
mmm. dd, yyyy Nov. 23, 1959
mmm dd yyyy Nov 23 1959
yyyy dd mm 1959 23 11
ddd, mmm. dd, yyyy Mon, Nov. 23, 1959
(ddd) mmm. dd, yyyy (Mon) Nov. 23, 1959
868ECPG — встраиваемый SQL в C
PGTYPESdate_defmt_asc
Преобразует строку C char* в значение типа date по маске формата.
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
Эта функция принимает указатель на переменную типа date (d), в которую будет помещён ре-
зультат операции, маску формата для разбора даты (fmt) и строку C char*, содержащую тексто-
вое представление даты (str). Ожидается, что текстовое представление будет соответствовать
маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция
анализирует только порядок элементов и ищет в нём подстроки yy или yyyy, обозначающие по-
зицию года, подстроку mm, обозначающую позицию месяца, и dd, обозначающую позицию дня.
В Таблица  36.4 перечислены несколько возможных форматов. Это даёт представление, как
можно использовать эту функцию.
Таблица 36.4. Допустимые форматы ввода для rdefmtdate
Формат Строка Результат
ddmmyy 21-2-54 1954-02-21
ddmmyy 2-12-54 1954-12-02
ddmmyy 20111954 1954-11-20
ddmmyy 130464 1964-04-13
mmm.dd.yyyy MAR-12-1967 1967-03-12
yy/mm/dd 1954, February 3rd 1954-02-03
mmm.dd.yyyy 041269 1969-04-12
yy/mm/dd In the year 2525, in the
month of July, mankind will
be alive on the 28th day 2525-07-28
dd-mm-yy I said on the 28th of July 2525-07-28
in the year 2525
mmm.dd.yyyy 9/14/58 1958-09-14
yy/mm/dd 47/03/29 1947-03-29
mmm.dd.yyyy oct 28 1975 1975-10-28
mmddyy Nov 14th, 1985 1985-11-14
36.6.4. Тип timestamp
Тип timestamp, реализованный в C, позволяет программам работать с данными типа timestamp в
SQL. Соответствующий тип сервера PostgreSQL описан в Разделе 8.5.
Для работы с типом timestamp можно использовать следующие функции:
PGTYPEStimestamp_from_asc
Разбирает значение даты/времени из текстового представления в переменную типа timestamp.
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
Эта функция получает строку (str), которую нужно разобрать, и указатель на строку C char*
(endptr). На данный момент ECPG всегда разбирает строку до конца, так что эта функция не
может вернуть адрес первого недопустимого символа в *endptr. Поэтому в endptr свободно
можно передать NULL.
В случае успеха эта функция возвращает разобранное время, а в случае ошибки возвращается
PGTYPESInvalidTimestamp и в errno устанавливается значение PGTYPES_TS_BAD_TIMESTAMP. См.
замечание относительно PGTYPESInvalidTimestamp.
869ECPG — встраиваемый SQL в C
Вообще вводимая строка может содержать допустимое указание даты, пробельные символы и
допустимое указание времени в любом сочетании. Заметьте, что часовые пояса ECPG не под-
держивает. Эта функция может разобрать их, но не задействует их в вычислениях как это де-
лает, например, сервер PostgreSQL. Указания часового пояса во вводимой строке просто игно-
рируются.
В Таблица 36.5 приведены несколько примеров вводимых строк.
Таблица 36.5. Допустимые форматы ввода для PGTYPEStimestamp_from_asc
Ввод Результат
1999-01-08 04:05:06 1999-01-08 04:05:06
January 8 04:05:06 1999 PST 1999-01-08 04:05:06
1999-Jan-08 04:05:06.789-8 1999-01-08 04:05:06.789 (указание часово-
го пояса игнорируется)
J2451187 04:05-08:00 1999-01-08 04:05:00
пояса игнорируется)
(указание
часового
PGTYPEStimestamp_to_asc
Преобразует значение даты в строку C char*.
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
Эта функция принимает в качестве единственного аргумента tstamp значение типа timestamp
и возвращает размещённую в памяти строку, содержащую текстовое представление даты/вре-
мени. Результат необходимо освободить функцией PGTYPESchar_free().
PGTYPEStimestamp_current
Получает текущее время.
void PGTYPEStimestamp_current(timestamp *ts);
Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую
указывает ts.
PGTYPEStimestamp_fmt_asc
Преобразует переменную типа timestamp в строку C char* по маске формата.
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char
*fmtstr);
Эта функция получает в первом аргументе (ts) указатель на переменную типа timestamp, а в
последующих указатель на буфер вывода (output), максимальную длину строки, которую мо-
жет принять буфер (str_len), и маску формата, с которой будет выполняться преобразование
(fmtstr).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
В маске формата можно использовать коды формата, перечисленные ниже. Эти же коды при-
нимает функция strftime из библиотеки libc. Любые символы, не относящиеся к кодам форма-
та, будут просто скопированы в буфер вывода.
• %A — заменяется локализованным представлением полного названия дня недели.
• %a — заменяется локализованным представлением сокращённого названия дня недели.
• %B — заменяется локализованным представлением полного названия месяца.
• %b — заменяется локализованным представлением сокращённого названия месяца.
• %C — заменяется столетием (год / 100) в виде десятичного числа; одиночная цифра предва-
ряется нулём.
870ECPG — встраиваемый SQL в C
• %c — заменяется локализованным представлением даты и времени.
• %D — равнозначно %m/%d/%y.
• %d — заменяется днём месяца в виде десятичного числа (01-31).
• %E* %O* — расширения локали POSIX. Последовательности %Ec %EC %Ex %EX %Ey %EY %Od %Oe
%OH %OI %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy должны выводить альтернативные представле-
ния.
Кроме того, альтернативные названия месяцев представляет код формата %OB (использует-
ся отдельно, без упоминания дня).
• %e — заменяется днём в виде десятичного числа (1-31); одиночная цифра предваряется
пробелом.
• %F — равнозначно %Y-%m-%d.
• %G — заменяется годом в виде десятичного числа (со столетием). При этом годом считает-
ся тот, что содержит наибольшую часть недели (дни недели начинаются с понедельника).
• %g — заменяется тем же годом, что и %G, но в виде десятичного числа без столетия (00-99).
• %H — заменяется часами (в 24-часовом формате) в виде десятичного числа (00-23).
• %h — равнозначно %b.
• %I — заменяется часами (в 12-часовом формате) в виде десятичного числа (01-12).
• %j — заменяется днём года в виде десятичного числа (001-366).
• %k — заменяется часами (в 24-часовом формате) в виде десятичного числа (0-23); одиноч-
ная цифра предваряется пробелом.
• %l — заменяется часами (в 12-часовом формате) в виде десятичного числа (1-12); одиноч-
ная цифра предваряется пробелом.
• %M — заменяется минутами в виде десятичного числа (00-59).
• %m — заменяется номером месяца в виде десятичного числа (01-12).
• %n — заменяется символом новой строки.
• %O* — равнозначно %E*.
• %p — заменяется локализованным представлением «до полудня» или «после полудня» в за-
висимости от времени.
• %R — равнозначно %H:%M.
• %r — равнозначно %I:%M:%S %p.
• %S — заменяется секундами в виде десятичного числа (00-60).
• %s — заменяется числом секунд с начала эпохи, по мировому времени (UTC).
• %T — равнозначно %H:%M:%S
• %t — заменяется символом табуляции.
• %U — заменяется номером недели в году (первым днём недели считается воскресенье) в ви-
де десятичного числа (00-53).
• %u — заменяется номером дня недели (первым днём недели считается понедельник) в виде
десятичного числа (1-7).
• %V — заменяется номером недели в году (первым днём недели считается понедельник) в
виде десятичного числа (01-53). Если к недели, включающей 1 января, относятся 4 или
больше дней нового года, она считается неделей с номером 1; в противном случае это по-
следняя неделя предыдущего года, а неделей под номером 1 будет следующая.
• %v — равнозначно %e-%b-%Y.
871ECPG — встраиваемый SQL в C
• %W — заменяется номером недели в году (первым днём недели считается понедельник) в
виде десятичного числа (00-53).
• %w — заменяется номером дня недели (первым днём недели считается воскресенье) в виде
десятичного числа (0-6).
• %X — заменяется локализованным представлением времени.
• %x — заменяется локализованным представлением даты.
• %Y — заменяется годом со столетием в виде десятичного числа.
• %y — заменяется годом без столетия в виде десятичного числа (00-99).
• %Z — заменяется названием часового пояса.
• %z — заменяется смещением часового пояса от UTC; ведущий знак плюс обозначает сме-
щение к востоку от UTC, а знак минус — к западу, часы и минуты задаются парами цифр
без разделителя между ними (эта форма установлена для даты в RFC 822).
• %+ — заменяется локализованным представлением даты и времени.
• %-* — расширение GNU libc. Отключает дополнение чисел по ширине при выводе.
• $_* — расширение GNU libc. Явно включает дополнение пробелами.
• %0* — расширение GNU libc. Явно включает дополнение нулями.
• %% — заменяется символом %.
PGTYPEStimestamp_sub
Вычитает одно значение времени из другого и сохраняет результат в переменной типа interval.
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
Эта функция вычитает значение типа timestamp, на которое указывает ts2, из значения
timestamp, на которое указывает ts1, и сохраняет результат в переменной типа interval, на ко-
торую указывает iv.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
PGTYPEStimestamp_defmt_asc
Разбирает значение типа timestamp из текстового представления с заданной маской формата.
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
Эта функция получает текстовое представление даты/времени в переменной str, а также маску
формата для разбора в переменной fmt. Результат будет сохранён в переменной, на которую
указывает d.
Если вместо маски формата fmt передаётся NULL, эта функция переходит к стандартной маске
форматирования, а именно: %Y-%m-%d %H:%M:%S.
Данная функция является обратной к функции PGTYPEStimestamp_fmt_asc. Обратитесь к её до-
кументации, чтобы узнать о возможных вариантах маски формата.
PGTYPEStimestamp_add_interval
Добавляет переменную типа interval к переменной типа timestamp.
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
Эта функция получает указатель на переменную tin типа timestamp и указатель на перемен-
ную span типа interval. Она добавляет временной интервал к значению даты/времени и сохра-
няет полученную дату/время в переменной типа timestamp, на которую указывает tout.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
872ECPG — встраиваемый SQL в C
PGTYPEStimestamp_sub_interval
Вычитает переменную типа interval из переменной типа timestamp.
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
Эта функция вычитает значение типа interval, на которое указывает span, из значения типа
timestamp, на которое указывает tin, и сохраняет результат в переменной, на которую указы-
вает tout.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
36.6.5. Тип interval
Тип interval, реализованный в C, позволяет программам работать с данными типа interval в SQL.
Соответствующий тип сервера PostgreSQL описан в Разделе 8.5.
Для работы с типом interval можно использовать следующие функции:
PGTYPESinterval_new
Возвращает указатель на новую переменную interval, размещённую в памяти.
interval *PGTYPESinterval_new(void);
PGTYPESinterval_free
Освобождает место, занимаемое ранее размещённой в памяти переменной типа interval.
void PGTYPESinterval_new(interval *intvl);
PGTYPESinterval_from_asc
Разбирает значение типа interval из его текстового представления.
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
Эта функция разбирает входную строку str и возвращает указатель на размещённую в памяти
переменную типа interval. На данный момент ECPG всегда разбирает строку до конца, так что
эта функция не может вернуть адрес первого недопустимого символа в *endptr. Поэтому в
endptr свободно можно передать NULL.
PGTYPESinterval_to_asc
Преобразует переменную типа interval в текстовое представление.
char *PGTYPESinterval_to_asc(interval *span);
Эта функция преобразует переменную типа interval, на которую указывает span, в строку C
char*. Её вывод выглядит примерно так: @ 1 day 12 hours 59 mins 10 secs. Результат необ-
ходимо освободить функцией PGTYPESchar_free().
PGTYPESinterval_copy
Копирует переменную типа interval.
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
Эта функция копирует переменную типа interval, на которую указывает intvlsrc, в перемен-
ную, на которую указывает intvldest. Заметьте, что для целевой переменной необходимо пред-
варительно выделить память.
36.6.6. Тип decimal
Тип decimal похож на тип numeric, однако его максимальная точность ограничена 30 значащи-
ми цифрами. В отличие от типа numeric, который можно создать только в области кучи, тип
decimal можно создать и в стеке, и в области кучи (посредством функций PGTYPESdecimal_new и
PGTYPESdecimal_free). Для работы с типом decimal есть много других функций, подключаемых в
режиме совместимости с Informix, описанном в Разделе 36.15.
873ECPG — встраиваемый SQL в C
Для работы с типом decimal можно использовать следующие функции (содержащиеся не в библио-
теке libcompat).
PGTYPESdecimal_new
Запрашивает указатель на новую переменную decimal, размещённую в памяти.
decimal *PGTYPESdecimal_new(void);
PGTYPESdecimal_free
Освобождает переменную типа decimal, высвобождая всю её память.
void PGTYPESdecimal_free(decimal *var);
36.6.7. Значения errno, которые устанавливает pgtypeslib
PGTYPES_NUM_BAD_NUMERIC
Аргумент должен содержать переменную типа numeric (либо указывать на переменную типа
numeric), но представление этого типа в памяти оказалось некорректным.
PGTYPES_NUM_OVERFLOW
Произошло переполнение. Так как тип numeric может принимать значения практически любой
точности, при преобразовании этого типа в другие типы возможно переполнение.
PGTYPES_NUM_UNDERFLOW
Произошло антипереполнение. Так как тип numeric может принимать значения практически
любой точности, при преобразовании переменной этого типа в другие типы возможно антипе-
реполнение.
PGTYPES_NUM_DIVIDE_ZERO
Имела место попытка деления на ноль.
PGTYPES_DATE_BAD_DATE
Функции PGTYPESdate_from_asc передана некорректная строка даты.
PGTYPES_DATE_ERR_EARGS
Функции PGTYPESdate_defmt_asc переданы некорректные аргументы.
PGTYPES_DATE_ERR_ENOSHORTDATE
В строке, переданной функции PGTYPESdate_defmt_asc, оказался неправильный компонент да-
ты.
PGTYPES_INTVL_BAD_INTERVAL
Функции PGTYPESinterval_from_asc передана некорректная строка, задающая интервал, либо
функции PGTYPESinterval_to_asc передано некорректное значение интервала.
PGTYPES_DATE_ERR_ENOTDMY
Обнаружено несоответствие
PGTYPESdate_defmt_asc.
при
выводе
компонентов
день/месяц/год
в
PGTYPES_DATE_BAD_DAY
Функция PGTYPESdate_defmt_asc обнаружила некорректное значение дня месяца.
PGTYPES_DATE_BAD_MONTH
Функция PGTYPESdate_defmt_asc обнаружила некорректное значение месяца.
874
функцииECPG — встраиваемый SQL в C
PGTYPES_TS_BAD_TIMESTAMP
Функции PGTYPEStimestamp_from_asc передана некорректная строка даты/времени, либо функ-
ции PGTYPEStimestamp_to_asc передано некорректное значение типа timestamp.
PGTYPES_TS_ERR_EINFTIME
Значение типа timestamp, представляющее бесконечность, получено в недопустимом контек-
сте.
36.6.8. Специальные константы pgtypeslib
PGTYPESInvalidTimestamp
Значение типа timestamp, представляющее недопустимое время. Это значение возвраща-
ет функция PGTYPEStimestamp_from_asc при ошибке разбора. Заметьте, что вследствие осо-
бенности внутреннего представления типа timestamp, значение PGTYPESInvalidTimestamp в
то же время представляет корректное время (1899-12-31 23:59:59). Поэтому для выяв-
ления ошибок необходимо, чтобы приложение не только сравнивало результат функции
с PGTYPESInvalidTimestamp, но и проверяло условие errno != 0 после каждого вызова
PGTYPEStimestamp_from_asc.
36.7. Использование областей дескрипторов
Области дескрипторов SQL дают возможности для более сложной обработки результатов опера-
торов SELECT, FETCH и DESCRIBE. Область дескриптора SQL объединяет в одной структуре данные
одной строки и элементы метаданных. Эти метаданные особенно полезны при выполнении дина-
мических SQL-операторов, когда характер результирующих столбцов может быть неизвестен за-
ранее. PostgreSQL предлагает два подхода к использованию областей дескрипторов: именованные
области SQL-дескрипторов и области SQLDA в структурах C.
36.7.1. Именованные области SQL-дескрипторов
Именованная область SQL-дескриптора состоит из заголовка, содержащего сведения обо всём де-
скрипторе, и одного или нескольких дескрипторов элементов, которые по сути описывают отдель-
ные столбцы в строке результата.
Прежде чем вы сможете использовать область SQL-дескриптора, её нужно выделить:
EXEC SQL ALLOCATE DESCRIPTOR идентификатор;
Заданный идентификатор играет роль «имени переменной» области дескриптора. Когда дескрип-
тор оказывается ненужным, его следует освободить:
EXEC SQL DEALLOCATE DESCRIPTOR идентификатор;
Чтобы воспользоваться областью дескриптора, её нужно указать в качестве целевого объекта в
предложении INTO, вместо перечисления переменных среды:
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
Если набор результатов пуст, в области дескриптора будут, тем не менее, содержаться метаданные
из запроса, то есть имена полей.
Получить метаданные набора результатов для ещё не выполненных подготовленных запросов мож-
но, воспользовавшись оператором DESCRIBE:
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
875ECPG — встраиваемый SQL в C
До PostgreSQL версии 9.0 ключевое слово SQL было необязательным, так что предложения
DESCRIPTOR и SQL DESCRIPTOR создавали именованные области SQL-дескрипторов. Теперь оно ста-
ло обязательным; без слова SQL создаются области SQLDA, см. Подраздел 36.7.2.
В операторах DESCRIBE и FETCH ключевые слова INTO и USING действуют примерно одинаково: они
указывают вывести набор результатов и метаданные в область дескриптора.
Возникает вопрос: а как же получить данные из области дескриптора? Область дескриптора можно
представить как структуру с именованными полями. Чтобы получить значение поля из заголовка
и сохранить его в переменной среды, нужно выполнить команду:
EXEC SQL GET DESCRIPTOR имя :переменная_среды = поле;
В настоящее время определено только одно поле заголовка: COUNT, которое говорит, сколько об-
ластей дескрипторов элементов существует (то есть, сколько столбцов содержится в результате).
Переменная среды должна иметь целочисленный тип. Чтобы получить поле из области дескрип-
тора элемента, нужно выполнить команду:
EXEC SQL GET DESCRIPTOR имя VALUE номер :переменная_среды = поле;
В качестве num можно задать обычное целое или переменную среды, содержащую целое число.
Допустимые поля:
CARDINALITY (integer)
число строк в наборе результатов
DATA
собственно элемент данных (тип данных поля зависит от запроса)
DATETIME_INTERVAL_CODE (целое)
Когда TYPE равно 9, DATETIME_INTERVAL_CODE содержит значение 1 для DATE, 2 для TIME, 3 для
TIMESTAMP, 4 для TIME WITH TIME ZONE, либо 5 для TIMESTAMP WITH TIME ZONE.
DATETIME_INTERVAL_PRECISION (целое)
не реализовано
INDICATOR (целое)
индикатор (отмечающий значение NULL или усечение значения)
KEY_MEMBER (целое)
не реализовано
LENGTH (целое)
длина данных в символах
NAME (строка)
имя столбца
NULLABLE (целое)
не реализовано
OCTET_LENGTH (целое)
длина символьного представления данных в байтах
PRECISION (целое)
точность (для типа numeric)
876ECPG — встраиваемый SQL в C
RETURNED_LENGTH (целое)
длина данных в символах
RETURNED_OCTET_LENGTH (целое)
длина символьного представления данных в байтах
SCALE (целое)
масштаб (для типа numeric)
TYPE (целое)
числовой код типа данных столбца
В операторах EXECUTE, DECLARE и OPEN ключевые слова INTO и USING действуют по-разному. Область
дескриптора также можно сформировать вручную, чтобы передать входные параметры запросу
или курсору, а команда USING SQL DESCRIPTOR имя даёт возможность передать входные аргументы
параметризованному запросу. Оператор, формирующий именованную область SQL-дескриптора,
выглядит так:
EXEC SQL SET DESCRIPTOR имя VALUE номер поле = :переменная_среды;
PostgreSQL поддерживает выборку сразу нескольких записей в одном операторе FETCH и может
сохранить их данные в переменной среды, если эта переменная — массив. Например:
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;
EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
36.7.2. Области дескрипторов SQLDA
Область дескриптора SQLDA представляет собой структуру языка C, в которую можно получить
набор результатов и метаданные запроса. Одна такая структура содержит одну запись из набора
данных.
EXEC SQL include sqlda.h;
sqlda_t
*mysqlda;
EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
Заметьте, что ключевое слово SQL в этом случае опускается. Замечания относительно применения
ключевых слов INTO и USING в Подразделе 36.7.1 применимы и здесь, с дополнением. В операто-
ре DESCRIBE можно полностью опустить ключевое слово DESCRIPTOR, если присутствует ключевое
слово INTO:
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
Общая схема использования SQLDA выглядит так:
</pgtypes_numeric.h></stdlib.h></stdio.h></pgtypes_interval.h></stdlib.h></stdio.h></pgtypes_timestamp.h>    <ol>
      <li>Подготовить запрос и объявить курсор для него.</li>
      <li>Объявить SQLDA для строк результата.</li>
      <li>Объявить SQLDA для входных параметров и инициализировать их (выделить память, задать
параметры).</li>
      <li>Открыть курсор с входной SQLDA.</li>
      <li>Выбрать строки из курсора и сохранить их в выходной SQLDA.
877ECPG — встраиваемый SQL в C</li>
      <li>Прочитать значения из выходной SQLDA в переменные среды (и преобразовать при необходи-
мости).</li>
      <li>Закрыть курсор.</li>
      <li>Освободить область памяти, выделенную для входной SQLDA.
36.7.2.1. Структура данных SQLDA
Для SQLDA используются три типа данных: sqlda_t, sqlvar_t и struct sqlname.
Подсказка
Структура данных SQLDA в PostgreSQL подобна той, что используется в IBM DB2
Universal Database, так что часть технической информации по SQLDA в DB2 может быть
полезна и для понимания устройства SQLDA в PostgreSQL.
36.7.2.1.1. Структура sqlda_t
Тип структуры sqlda_t представляет тип собственно SQLDA. Эта структура описывает одну запись.
Две или более структур sqlda_t могут объединяться в связанный список по указателям в поле
desc_next, и таким образом образовывать упорядоченный набор строк. Поэтому, когда выбираются
две или более строк, приложение может прочитать их, проследуя по указателям desc_next во всех
узлах sqlda_t.
Тип sqlda_t определяется так:
struct sqlda_struct
{
char
sqldaid[8];
long
sqldabc;
short
sqln;
short
sqld;
struct sqlda_struct *desc_next;
struct sqlvar_struct sqlvar[1];
};
typedef struct sqlda_struct sqlda_t;
Его поля имеют следующее назначение:
sqldaid
Содержит строковую константу “SQLDA “.
sqldabc
Содержит размер выделенного пространства в байтах.
sqln
Содержит число входных параметров для параметризованного запроса, когда передаётся в опе-
раторы OPEN, DECLARE или EXECUTE с ключевым словом USING. В структуре, выводимой операто-
рами SELECT, EXECUTE или FETCH, данное значение совпадает с sqld.
sqld
Содержит число полей в наборе результатов.
desc_next
Если запрос выдаёт несколько записей, возвращается несколько связанных структур SQLDA, а
desc_next содержит указатель на следующую запись в списке.
878ECPG — встраиваемый SQL в C
sqlvar
Это массив столбцов в наборе результатов.
36.7.2.1.2. Структура sqlvar_t
Тип структуры sqlvar_t содержит значение столбца и метаданные, в частности, тип и длину. Эта
структура определяется так:
struct sqlvar_struct
{
short
sqltype;
short
sqllen;
char
*sqldata;
short
*sqlind;
struct sqlname sqlname;
};
typedef struct sqlvar_struct sqlvar_t;
Её поля имеют следующее назначение:
sqltype
Содержит идентификатор типа данного поля. Возможные значения перечислены в enum
ECPGttype в ecpgtype.h.
sqllen
Содержит двоичную длину поля, например, 4 байта для ECPGt_int.
sqldata
Указывает на данные. Формат данных описан в Подразделе 36.4.4.
sqlind
Указывает на индикатор NULL. 0 соответствует значению не NULL, -1 — NULL.
sqlname
Имя поля.
36.7.2.1.3. Структура struct sqlname
Структура struct sqlname содержит имя столбца. Она включена в sqlvar_t в качестве члена. Эта
структура определена так:
#define NAMEDATALEN 64
struct sqlname
{
short
char
};
length;
data[NAMEDATALEN];
Её поля имеют следующее назначение:
length
Содержит длину имени поля.
data
Содержит собственно имя поля.
36.7.2.2. Получение набора результатов с применением SQLDA
Чтобы получить набор результатов запроса через SQLDA, нужно проделать примерно следующее:
879ECPG — встраиваемый SQL в C</li>
      <li>Объявить структуру sqlda_t для получения набора результатов.</li>
      <li>Выполнить команды FETCH/EXECUTE/DESCRIBE для обработки запроса с указанной SQLDA.</li>
      <li>Определить число записей в наборе результатов, прочитав sqln, член структуры sqlda_t.</li>
      <li>Получить значения каждого столбца из элементов sqlvar[0], sqlvar[1] и т. д., составляющих
массив, включённый в структуру sqlda_t.</li>
      <li>Перейти к следующей строке (структуре sqlda_t) по указателю desc_next, члену структуры
sqlda_t.</li>
      <li>При необходимости повторить эти действия.
Далее показывается, как получить набор результатов через SQLDA.
Сначала объявите структуру sqlda_t, в которую будет помещён набор результатов.
sqlda_t <em>sqlda1;
Затем укажите эту SQLDA в команде. В данном примере это команда FETCH.
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
Обработайте все строки в цикле с переходом по связанному списку.
sqlda_t *cur_sqlda;
for (cur_sqlda = sqlda1;
cur_sqlda != NULL;
cur_sqlda = cur_sqlda-&gt;desc_next)
{
…
}
Внутри этого цикла реализуйте ещё один цикл чтения данных каждого столбца (структуры
sqlvar_t) в строке.
for (i = 0; i &lt; cur_sqlda-&gt;sqld; i++)
{
sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
char *sqldata = v.sqldata;
short sqllen = v.sqllen;
…
}
Чтобы получить значение столбца, прочитайте значение поля sqltype, члена структуры sqlvar_t.
Затем выберите подходящий способ, в зависимости от типа столбца, копирования данных из поля
sqlvar в переменную среды.
char var_buf[1024];
switch (v.sqltype)
{
case ECPGt_char:
memset(&amp;var_buf, 0, sizeof(var_buf));
memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 :
sqllen));
break;
case ECPGt_int: /</em> integer */
memcpy(&amp;intval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), “%d”, intval);
break;
880ECPG — встраиваемый SQL в C
…
}
36.7.2.3. Передача значений параметров через SQLDA
Чтобы передать параметры подготовленному запросу через SQLDA, нужно проделать примерно
следующее:</li>
      <li>Создать подготовленный запрос (подготовленный оператор)</li>
      <li>Объявить структуру sqlda_t в качестве входной SQLDA.</li>
      <li>Выделить область памяти (структуру sqlda_t) для входной SQLDA.</li>
      <li>Установить (скопировать) входные значения в выделенной памяти.</li>
      <li>Открыть курсор, указав входную SQLDA.
Рассмотрим это на примере.
Сначала создайте подготовленный оператор.
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = “SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid
= s.datid AND (d.datname = ? OR d.oid = ?)”;
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE stmt1 FROM :query;
Затем выделите память для SQLDA и установите число входных параметров в поле sqln, члене
структуры sqlda_t. Когда для подготовленного запроса требуются два или более входных пара-
метров, приложение должно выделить дополнительное место в памяти, размер которого вычисля-
ется как (число параметров - 1) * sizeof(sqlvar_t). В показанном здесь примере выделяется место
для двух параметров.
sqlda_t <em>sqlda2;
sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
sqlda2-&gt;sqln = 2; /</em> число входных переменных <em>/
Выделив память, сохраните значения параметров в массиве sqlvar[]. (Этот же массив использу-
ется для значений столбцов, когда SQLDA получает набор результатов.) В данном примере пере-
даются два параметра: “postgres” (строкового типа) и 1 (целочисленного типа).
sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = “postgres”;
sqlda2-&gt;sqlvar[0].sqllen = 8;
int intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2-&gt;sqlvar[1].sqllen = sizeof(intval);
Откройте курсор с указанием ранее созданной SQLDA, чтобы входные параметры были переданы
подготовленному оператору.
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
Наконец, закончив использование входных SQLDA, необходимо явно освободить выделенную для
них память, в отличие от SQLDA, получающих результаты запросов.
free(sqlda2);
881ECPG — встраиваемый SQL в C
36.7.2.4. Пример приложения, использующего SQLDA
Представленный здесь пример программы показывает, как выбрать из системных каталогов ста-
тистику доступа к базам данных, определённых входными параметрами.
Это приложение соединяет записи двух системных таблиц, pg_database и pg_stat_database по OID
базы данных, и также выбирает и показывает статистику, принимая два входных параметра (база
данных postgres и OID 1).
Сначала создайте SQLDA для ввода параметров и SQLDA для вывода результатов.
EXEC SQL include sqlda.h;
sqlda_t *sqlda1; /</em> выходной дескриптор <em>/
sqlda_t *sqlda2; /</em> входной дескриптор <em>/
Затем подключитесь к базе данных, подготовьте оператор и объявите курсор для подготовленного
оператора.
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = “SELECT d.oid,</em> FROM pg_database d, pg_stat_database s WHERE
d.oid=s.datid AND ( d.datname=? OR d.oid=? )”;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config(‘search_path’, ‘’, false); EXEC SQL COMMIT;
EXEC SQL PREPARE stmt1 FROM :query;
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
Затем запишите некоторые значения параметров во входную SQLDA. Выделите память для входной
SQLDA и установите количество параметров в sqln. Запишите тип, значение и длину значения в
поля sqltype, sqldata и sqllen структуры sqlvar.
/* Создать структуру SQLDA для входных параметров. <em>/
sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
sqlda2-&gt;sqln = 2; /</em> число входных переменных <em>/
sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = “postgres”;
sqlda2-&gt;sqlvar[0].sqllen = 8;
intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *)&amp;intval;
sqlda2-&gt;sqlvar[1].sqllen = sizeof(intval);
Подготовив входную SQLDA, откройте курсор с ней.
/</em> Открыть курсор с входными параметрами. <em>/
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
Выберите строки из открытого курсора в выходную SQLDA. (Обычно, чтобы выбрать все строки в
наборе результатов, нужно повторять FETCH в цикле.)
while (1)
{
sqlda_t *cur_sqlda;
882ECPG — встраиваемый SQL в C
/</em> Назначить дескриптор курсору <em>/
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
Затем прочитайте выбранные записи из SQLDA, следуя по связанному списку структуры sqlda_t.
for (cur_sqlda = sqlda1 ;
cur_sqlda != NULL ;
cur_sqlda = cur_sqlda-&gt;desc_next)
{
…
Прочитайте все столбцы первой записи. Количество столбцов хранится в поле sqld, а данные пер-
вого столбца в sqlvar[0], оба эти поля — члены структуры sqlda_t.
/</em> Вывести каждый столбец в строке. <em>/
for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
{
sqlvar_t v = sqlda1-&gt;sqlvar[i];
char *sqldata = v.sqldata;
short sqllen = v.sqllen;
strncpy(name_buf, v.sqlname.data, v.sqlname.length);
name_buf[v.sqlname.length] = ‘\0’;
Теперь данные столбцов сохранены в переменной v. Скопируйте все элементы данных в перемен-
ные среды, определив тип столбца по полю v.sqltype.
switch (v.sqltype) {
int intval;
double doubleval;
unsigned long long int longlongval;
case ECPGt_char:
memset(&amp;var_buf, 0, sizeof(var_buf));
memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ?
sizeof(var_buf)-1 : sqllen));
break;
case ECPGt_int: /</em> integer */
memcpy(&amp;intval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), “%d”, intval);
break;
…
default:
…
}
printf(“%s = %s (type: %d)\n”, name_buf, var_buf, v.sqltype);
}
Закончив обработку всех записей, закройте курсор и отключитесь от базы данных.
EXEC SQL CLOSE cur1;
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
Вся программа показана в Примере 36.1.
883ECPG — встраиваемый SQL в C
Пример 36.1. Пример программы на базе SQLDA
#include
#include
#include
#include
#include</li>
    </ol>
  </li>
</ul>
<stdlib.h>
<string.h>
<stdlib.h>
<stdio.h>
<unistd.h>
EXEC SQL include sqlda.h;
sqlda_t *sqlda1; /* дескриптор для выходных данных */
sqlda_t *sqlda2; /* дескриптор для входных данных */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE
d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
int intval;
unsigned long long int longlongval;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL PREPARE stmt1 FROM :query;
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
/* Создать структуру SQLDA для входных параметров */
sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
sqlda2-&gt;sqln = 2; /* число входных переменных */
sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = "postgres";
sqlda2-&gt;sqlvar[0].sqllen = 8;
intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *) &intval;
sqlda2-&gt;sqlvar[1].sqllen = sizeof(intval);
/* Открыть курсор с входными параметрами. */
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
while (1)
{
sqlda_t *cur_sqlda;
/* Присвоить дескриптор курсору */
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
for (cur_sqlda = sqlda1 ;
884ECPG — встраиваемый SQL в C
cur_sqlda != NULL ;
cur_sqlda = cur_sqlda-&gt;desc_next)
{
int i;
char name_buf[1024];
char var_buf[1024];
/* Напечатать каждый столбец в строке. */
for (i=0 ; i<cur_sqlda->sqld ; i++)
{
sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
char *sqldata = v.sqldata;
short sqllen = v.sqllen;
strncpy(name_buf, v.sqlname.data, v.sqlname.length);
name_buf[v.sqlname.length] = '\0';
switch (v.sqltype)
{
case ECPGt_char:
memset(&amp;var_buf, 0, sizeof(var_buf));
memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ?
sizeof(var_buf)-1 : sqllen) );
break;
case ECPGt_int: /* integer */
memcpy(&amp;intval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), "%d", intval);
break;
case ECPGt_long_long: /* bigint */
memcpy(&amp;longlongval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
break;
default:
{
int i;
memset(var_buf, 0, sizeof(var_buf));
for (i = 0; i &lt; sqllen; i++)
{
char tmpbuf[16];
snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char)
sqldata[i]);
strncat(var_buf, tmpbuf, sizeof(var_buf));
}
}
break;
}
printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
}
printf("\n");
}
}
EXEC SQL CLOSE cur1;
885ECPG — встраиваемый SQL в C
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
Вывод этой программы должен быть примерно таким (некоторые числа будут меняться).
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig = (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig = (type: 1)
datacl = (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
886ECPG — встраиваемый SQL в C
36.8. Обработка ошибок
В этом разделе описывается, как можно обрабатывать исключительные условия и предупрежде-
ния в программе со встраиваемым SQL. Для этого предназначены два средства, которые могут
дополнять друг друга.
• Можно настроить функции-обработчики для обработки предупреждений и ошибок, воспользо-
вавшись командой WHENEVER.
• Подробную информацию об ошибке или предупреждении можно получить через переменную
sqlca.
36.8.1. Установка обработчиков
Один простой метод перехвата ошибок и предупреждений заключается в назначении определён-
ного действия, которое будет выполняться при некотором условии. В общем виде:
EXEC SQL WHENEVER условие действие;
Здесь условие может быть следующим:
SQLERROR
Указанное действие вызывается, когда при выполнении оператора SQL происходит ошибка.
SQLWARNING
Указанное действие вызывается, когда при выполнении оператора SQL выдаётся предупрежде-
ние.
NOT FOUND
Указанное действие вызывается, когда оператор SQL получает или обрабатывает ноль строк.
(Это обстоятельство не считается ошибкой, но бывает полезно отследить его.)
действие может быть следующим:
CONTINUE
Это фактически означает, что условие игнорируется. Это поведение по умолчанию.
GOTO метка
GO TO метка
Перейти к указанной метке (используя оператор goto языка C).
SQLPRINT
Вывести сообщение в устройство стандартного вывода. Это полезно для простых программ или
при разработке прототипов. Содержание этого сообщения не настраивается.
STOP
Вызвать exit(1), что приведёт к завершению программы.
DO BREAK
Выполнить оператор break языка C. Этот вариант следует использовать только в циклах или
операторах switch.
DO CONTINUE
Выполнить оператор continue языка C. Этот вариант следует использовать только в циклах.
Данный оператор передаёт управление в начало цикла.
CALL имя (аргументы)
DO имя (аргументы)
Вызвать указанные функции C с заданными аргументами. (Эти вызовы имеют смысловые отли-
чия от CALL и DO в обычной грамматике PostgreSQL.)
887ECPG — встраиваемый SQL в C
В стандарте SQL описаны только действия CONTINUE и GOTO (и GO TO).
Ниже показан простой пример использования этих команд. Эта конструкция выводит простое со-
общение при выдаче предупреждения и прерывает программу в случае ошибки:
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
Оператор EXEC SQL WHENEVER является директивой препроцессора SQL, а не оператором языка C.
Устанавливаемое им действие при ошибках или предупреждениях применяется ко всем встраива-
емым операторам SQL ниже точки, где устанавливается обработчик, если только это действие не
было изменено после первой команды EXEC SQL WHENEVER, и до SQL-оператора, вызвавшего это
условие, вне зависимости от хода выполнения программы на C. Поэтому обе следующие програм-
мы на C не дадут желаемого эффекта:
/*
* НЕПРАВИЛЬНО
*/
int main(int argc, char *argv[])
{
...
if (verbose) {
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
}
...
EXEC SQL SELECT ...;
...
}
/*
* НЕПРАВИЛЬНО
*/
int main(int argc, char *argv[])
{
...
set_error_handler();
...
EXEC SQL SELECT ...;
...
}
static void set_error_handler(void)
{
EXEC SQL WHENEVER SQLERROR STOP;
}
36.8.2. sqlca
Для более гибкой обработки ошибок в интерфейсе встраиваемого SQL представлена глобальная
переменная с именем sqlca (SQL Communication Area, Область сведений SQL), имеющая следую-
щую структуру:
struct
{
char sqlcaid[8];
long sqlabc;
long sqlcode;
struct
{
int sqlerrml;
char sqlerrmc[SQLERRMC_LEN];
888ECPG — встраиваемый SQL в C
} sqlerrm;
char sqlerrp[8];
long sqlerrd[6];
char sqlwarn[8];
char sqlstate[5];
} sqlca;
(В многопоточной программе каждый поток автоматически получает собственную копию sqlca.
Это работает подобно стандартной в C глобальной переменной errno.)
Структура sqlca покрывает и предупреждения, и ошибки. Если в процессе выполнения операто-
ра выдаётся несколько предупреждений или ошибок, sqlca будет содержать сведения только о
последнем(ей) из них.
Если последний оператор SQL выполняется без ошибки, sqlca.sqlcode будет содержать 0, а
sqlca.sqlstate — "00000". Если выдаётся предупреждение или ошибка, в sqlca.sqlcode будет
содержаться отрицательное число, а sqlca.sqlstate будет отличаться от "00000". Положительное
значение sqlca.sqlcode устанавливается при нейтральном событии, например, когда последний
запрос возвращает ноль строк. Поля sqlcode и sqlstate представляют две различные схемы кодов
ошибок; подробнее они описаны ниже.
Если последний оператор SQL был успешным, в sqlca.sqlerrd[1] содержится OID обработан-
ной строки (если это уместно), а в sqlca.sqlerrd[2] количество обработанных или возвращённых
строк (если это уместно для команды).
В случае ошибки или предупреждения sqlca.sqlerrm.sqlerrmc будет содержать строку, описы-
вающую ошибку. Поле sqlca.sqlerrm.sqlerrml содержит длину сообщения об ошибке, которое
хранится в sqlca.sqlerrm.sqlerrmc (результат функции strlen(), который не очень интересен
для программиста C). Заметьте, что некоторые сообщения могут не умещаться в массив sqlerrmc
фиксированного размера; они будут обрезаться.
В случае предупреждения, в sqlca.sqlwarn[2] записывается символ W. (Во всех других случаях
значение будет отличным от W.) Символ W в sqlca.sqlwarn[1] показывает, что значение было об-
резано при сохранении в переменной среды. W в sqlca.sqlwarn[0] устанавливается, если преду-
преждение отмечается в каком-либо другом элементе массива.
Поля sqlcaid, sqlcabc, sqlerrp и остальные элементы sqlerrd и sqlwarn в настоящее время не
содержат полезной информации.
Структура sqlca не определена в стандарте SQL, но реализована в нескольких других СУБД SQL.
Принципиально она определяется одинаково, но если вы хотите, чтобы ваши приложения были
переносимыми, тщательно изучите различия реализаций.
В следующем примере, демонстрирующем применение WHENEVER в сочетании с sqlca, выводится
содержимое sqlca при возникновении ошибки. Это может быть полезно для отладки или в прото-
типах, пока не реализован более «дружественный пользователю» обработчик ошибок.
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();
void
print_sqlca()
{
fprintf(stderr, "==== sqlca ====\n");
fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n",
sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
889ECPG — встраиваемый SQL в C
fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0],
sqlca.sqlwarn[1], sqlca.sqlwarn[2],
sqlca.sqlwarn[3],
sqlca.sqlwarn[4], sqlca.sqlwarn[5],
sqlca.sqlwarn[6],
sqlca.sqlwarn[7]);
fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
fprintf(stderr, "===============\n");
}
Результат может выглядеть следующим образом (при ошибке, вызванной опечаткой в имени таб-
лицы):
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
36.8.3. SQLSTATE и SQLCODE
Поля sqlca.sqlstate и sqlca.sqlcode отражают две различные схемы, представляющие коды
ошибок. Обе схемы пришли из стандарта SQL, но схема SQLCODE была признана устаревшей в ре-
дакции SQL-92 и исключена в последующих редакциях. Поэтому в новых приложениях настоятель-
но рекомендуется использовать SQLSTATE.
SQLSTATE задаётся в массиве из пяти символов. Эти пять символов содержат цифры или буквы в
верхнем регистре, представляющие коды различных условий ошибок и предупреждений. SQLSTATE
определяется по иерархической схеме: первые два символа обозначают общий класс условия, а
следующие три — подкласс общего условия. Успешное состояние обозначается кодом 00000. По
большей части коды SQLSTATE определены в стандарте SQL. Сервер PostgreSQL поддерживает ко-
ды ошибок SQLSTATE естественным образом; поэтому используя во всех приложениях именно эту
схему кодов ошибок, можно добиться высокой степени согласованности. За дальнейшими сведе-
ниями обратитесь к Приложению A.
SQLCODE — устаревшая схема, в которой коды ошибок представлены просто целыми числами. Зна-
чение 0 обозначает успешное завершение, положительное значение — успешное завершение с
дополнительной информацией, а отрицательное говорит об ошибке. В стандарте SQL определено
только положительное значение +100, показывающее, что последняя команда вернула или затро-
нула ноль строк, но отрицательные значения не определены. Таким образом, с этой схемой нель-
зя рассчитывать на переносимость и она не имеет иерархической структуры. Исторически сложи-
лось, что процессор встраиваемого SQL для PostgreSQL назначает некоторые определённые зна-
чения SQLCODE для собственного использования; они перечислены ниже с числовыми значениями
и символьными именами. Помните, что эти коды несовместимы с другими реализациями SQL. По-
этому для упрощения перевода приложений на схему SQLSTATE вместе с этими кодами перечисля-
ются соответствующие значения SQLSTATE. Однако однозначного соответствия один-к-одному или
один-ко-многим между этими двумя схемами не существует (на самом деле это соответствие мно-
гие-ко-многим), поэтому следует свериться со списком SQLSTATE в Приложении A в каждом случае.
SQLCODE может принимать следующие значения:
0 (ECPG_NO_ERROR)
Показывает, что ошибки нет. (SQLSTATE 00000)
100 (ECPG_NOT_FOUND)
Это нейтральное условие, показывающее, что последняя команда вернула или обработала ноль
строк, либо курсор достиг конца. (SQLSTATE 02000)
890ECPG — встраиваемый SQL в C
Выбирая данные из курсора в цикле, можно проверять этот код, чтобы понять, когда нужно
прервать цикл, следующим образом:
while (1)
{
EXEC SQL FETCH ... ;
if (sqlca.sqlcode == ECPG_NOT_FOUND)
break;
}
Но WHENEVER NOT FOUND DO BREAK внутри по сути делает это же, поэтому такое явное условие
обычно ничем не лучше.
-12 (ECPG_OUT_OF_MEMORY)
Указывает, что закончилась виртуальная память. Числовое значение определено как -ENOMEM.
(SQLSTATE YE001)
-200 (ECPG_UNSUPPORTED)
Указывает, что препроцессор сгенерировал код, который не понимает библиотека. Возможно,
вы используете несовместимые версии препроцессора и библиотеки. (SQLSTATE YE002)
-201 (ECPG_TOO_MANY_ARGUMENTS)
Это означает, что в команде было указано больше переменных среды, чем она ожидает.
(SQLSTATE 07001 или 07002)
-202 (ECPG_TOO_FEW_ARGUMENTS)
Это означает, что в команде было указано меньше переменных среды, чем она ожидает.
(SQLSTATE 07001 или 07002)
-203 (ECPG_TOO_MANY_MATCHES)
Это означает, что запрос вернул несколько строк, но оператор был подготовлен только для
одной строки результата (например, потому что переданные переменные — не массивы).
(SQLSTATE 21000)
-204 (ECPG_INT_FORMAT)
Переменная среды типа int и данные в базе имеют разные типы, и в этих данных содержится
значение, которое нельзя преобразовать в int. Для этого преобразования библиотека исполь-
зует функцию strtol(). (SQLSTATE 42804)
-205 (ECPG_UINT_FORMAT)
Переменная среды типа unsigned int и данные в базе имеют разные типы, и в этих данных
содержится значение, которое нельзя преобразовать в unsigned int. Для этого преобразования
библиотека использует функцию strtoul(). (SQLSTATE 42804)
-206 (ECPG_FLOAT_FORMAT)
Переменная среды типа float и данные в базе имеют разные типы, и в этих данных содержит-
ся значение, которое нельзя преобразовать во float. Для этого преобразования библиотека
использует функцию strtod(). (SQLSTATE 42804)
-207 (ECPG_NUMERIC_FORMAT)
Переменная среды типа numeric и данные в базе имеют разные типы, и в этих данных содер-
жится значение, которое нельзя преобразовать в numeric. (SQLSTATE 42804)
-208 (ECPG_INTERVAL_FORMAT)
Переменная среды типа interval и данные в базе имеют разные типы, и в этих данных содер-
жится значение, которое нельзя преобразовать в interval. (SQLSTATE 42804)
891ECPG — встраиваемый SQL в C
-209 (ECPG_DATE_FORMAT)
Переменная среды типа date и данные в базе имеют разные типы, и в этих данных содержится
значение, которое нельзя преобразовать в date. (SQLSTATE 42804)
-210 (ECPG_TIMESTAMP_FORMAT)
Переменная среды типа timestamp и данные в базе имеют разные типы, и в этих данных содер-
жится значение, которое нельзя преобразовать в timestamp. (SQLSTATE 42804)
-211 (ECPG_CONVERT_BOOL)
Это означает, что переменная среды имеет тип bool, а значение в базе данных отличается от
't' или 'f'. (SQLSTATE 42804)
-212 (ECPG_EMPTY)
Серверу PostgreSQL был передан пустой оператор. (Этого обычно не должно происходить в про-
грамме со встраиваемым SQL, так что это может указывать на внутреннюю ошибку.) (SQLSTATE
YE002)
-213 (ECPG_MISSING_INDICATOR)
Возвращено значение NULL, но переменная-индикатор NULL не задана. (SQLSTATE 22002)
-214 (ECPG_NO_ARRAY)
Там, где требуется массив, была передана обычная переменная. (SQLSTATE 42804)
-215 (ECPG_DATA_NOT_ARRAY)
База данных возвратила обычную переменную там, где требуется значение-массив. (SQLSTATE
42804)
-216 (ECPG_ARRAY_INSERT)
Не удалось вставить значение в массив. (SQLSTATE 42804)
-220 (ECPG_NO_CONN)
Программа попыталась использовать несуществующее подключение. (SQLSTATE 08003)
-221 (ECPG_NOT_CONN)
Программа попыталась использовать подключение, которое существует, но не было открыто.
(Это внутренняя ошибка.) (SQLSTATE YE002)
-230 (ECPG_INVALID_STMT)
Оператор, который вы пытаетесь выполнить, не был подготовлен. (SQLSTATE 26000)
-239 (ECPG_INFORMIX_DUPLICATE_KEY)
Ошибка повторяющегося ключа, нарушение ограничения уникальности (режим совместимо-
сти с Informix). (SQLSTATE 23505)
-240 (ECPG_UNKNOWN_DESCRIPTOR)
Указанный дескриптор не найден. Оператор, который вы пытаетесь использовать, не был под-
готовлен. (SQLSTATE 33000)
-241 (ECPG_INVALID_DESCRIPTOR_INDEX)
Указанный индекс дескриптора вне диапазона. (SQLSTATE 07009)
-242 (ECPG_UNKNOWN_DESCRIPTOR_ITEM)
Запрошен неверный элемент дескриптора. (Это внутренняя ошибка.) (SQLSTATE YE002)
892ECPG — встраиваемый SQL в C
-243 (ECPG_VAR_NOT_NUMERIC)
При выполнении динамического оператора база данных возвратила числовое значение, тогда
как переменная среды — не числовая. (SQLSTATE 07006)
-244 (ECPG_VAR_NOT_CHAR)
При выполнении динамического оператора база данных возвратила не числовое значение, то-
гда как переменная среды — числовая. (SQLSTATE 07006)
-284 (ECPG_INFORMIX_SUBSELECT_NOT_ONE)
Результат подзапроса представлен не одной строкой (режим совместимости с Informix).
(SQLSTATE 21000)
-400 (ECPG_PGSQL)
Ошибка произошла на стороне сервера PostgreSQL. В тексте ошибки содержится сообщение
об ошибке от сервера PostgreSQL.
-401 (ECPG_TRANS)
Сервер PostgreSQL сообщает, что клиент не может запускать, фиксировать или отменять тран-
закцию. (SQLSTATE 08007)
-402 (ECPG_CONNECT)
Попытка подключения к базе данных была неудачной. (SQLSTATE 08001)
-403 (ECPG_DUPLICATE_KEY)
Ошибка повторяющегося ключа, нарушение ограничения уникальности. (SQLSTATE 23505)
-404 (ECPG_SUBSELECT_NOT_ONE)
Результат подзапроса представлен не одной строкой. (SQLSTATE 21000)
-602 (ECPG_WARNING_UNKNOWN_PORTAL)
Указано неверное имя курсора. (SQLSTATE 34000)
-603 (ECPG_WARNING_IN_TRANSACTION)
Транзакция в процессе выполнения. (SQLSTATE 25001)
-604 (ECPG_WARNING_NO_TRANSACTION)
Нет активной (выполняющейся) транзакции. (SQLSTATE 25P01)
-605 (ECPG_WARNING_PORTAL_EXISTS)
Было указано имя существующего курсора. (SQLSTATE 42P03)
36.9. Директивы препроцессора
Препроцессор ecpg поддерживает ряд директив, которые позволяют управлять разбором и обра-
боткой исходных файлов.
36.9.1. Включение файлов
Для включения внешнего файла в программу со встраиваемым SQL, используется конструкция:
EXEC SQL INCLUDE имя_файла;
EXEC SQL INCLUDE <имя_файла>;
EXEC SQL INCLUDE "имя_файла";
Встретив такую директиву, препроцессор встраиваемого SQL будет искать файл имя_файла.h, об-
рабатывать его и включать в выходной код C. В результате встраиваемые операторы SQL во вклю-
чённом таким образом файле будут обработаны корректно.
893ECPG — встраиваемый SQL в C
Препроцессор ecpg будет искать указанный файл в нескольких каталогах в следующем порядке:
• текущий каталог
• /usr/local/include
• каталог включаемых файлов PostgreSQL, определённый во время сборки (например, /usr/
local/pgsql/include)
• /usr/include
Но когда используется форма EXEC SQL INCLUDE "имя_файла", просматривается только текущий
каталог.
В каждом каталоге препроцессор будет сначала искать файл с заданным именем, а если не об-
наружит его, попытается найти файл с добавленным расширением .h (если только заданное имя
файла уже не содержит это расширение).
Заметьте, что команда EXEC SQL INCLUDE не равнозначна включению:
#include <имя_файла.h>
так как во втором случае включаемый файл не проходит через препроцессор SQL-команд. Есте-
ственно, директиву C #include можно по-прежнему применять для включения других заголовоч-
ных файлов.
Примечание
Имя включаемого файла чувствительно к регистру, несмотря на то, что остальная ко-
манда EXEC SQL INCLUDE подчиняется обычным правилам чувствительности к регистру
SQL.
36.9.2. Директивы define и undef
Во встраиваемом SQL есть конструкция, подобная директиве #define, известной в C:
EXEC SQL DEFINE имя;
EXEC SQL DEFINE имя значение;
Используя её, можно определить имя:
EXEC SQL DEFINE HAVE_FEATURE;
И также можно определить константы:
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
Удалить предыдущее определение позволяет команда undef:
EXEC SQL UNDEF MYNUMBER;
Разумеется, в программе со встраиваемым SQL можно продолжать использовать версии #define
и #undef языка C. Отличие состоит в том, когда вычисляются определяемые значения. Когда при-
меняется команда EXEC SQL DEFINE, вычислять определения и подставлять значения будет пре-
процессор ecpg. Например, если написать:
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
подстановку выполнит ecpg и компилятор C никогда не увидит имени или идентификатора
MYNUMBER. Заметьте, что с другой стороны #define не подходит для определения константы, кото-
рую вы хотите использовать во встраиваемом SQL, так как препроцессор встраиваемого SQL не
сможет увидеть это определение.
894ECPG — встраиваемый SQL в C
36.9.3. Директивы ifdef, ifndef, else, elif и endif
Для условной компиляции блоков кода можно использовать следующие указания:
EXEC SQL ifdef имя;
Проверяет имя и обрабатывает последующие строки, если имя было определено командой EXEC
SQL define имя.
EXEC SQL ifndef имя;
Проверяет имя и обрабатывает последующие строки, если имя не было определено командой
EXEC SQL define имя.
EXEC SQL else;
Начинает альтернативную ветвь условия, открытого командой EXEC SQL ifdef имя или EXEC
SQL ifndef имя.
EXEC SQL elif имя;
Проверяет имя и начинает альтернативную ветвь условия, если имя было определено командой
EXEC SQL define имя.
EXEC SQL endif;
Завершает ветвь условия.
Пример:
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SQL
SQL
ifndef TZVAR;
SET TIMEZONE TO 'GMT';
elif TZNAME;
SET TIMEZONE TO TZNAME;
else;
SET TIMEZONE TO TZVAR;
endif;
36.10. Компиляция программ со встраиваемым SQL
Теперь, когда вы получили представление, как писать программы на C со встраиваемым SQL, вы
наверное хотите узнать, как их компилировать. Прежде чем компилировать код C, необходимо
пропустить исходный файл через препроцессор встраиваемого SQL в C, который преобразует за-
писанные вами операторы SQL в вызовы специальных функций. После компиляции полученный
объектный код нужно скомпоновать со специальной библиотекой, содержащей необходимые функ-
ции. Эти функции получают информацию из аргументов, выполняют команды SQL через интер-
фейс libpq, и помещают результат в аргументы, заданные для вывода.
Программа препроцессора называется ecpg и входит в состав обычной инсталляции PostgreSQL.
Программам со встраиваемым SQL, как правило, даются имена с расширением .pgc. Если вы со-
здали код программы в файле prog1.pgc, вы можете обработать его, просто выполнив:
ecpg prog1.pgc
При этом будет создан файл prog1.c. Если имена входных файлов не следуют этому соглашению,
имя выходного файла можно задать явно в аргументе -o.
Обработанный препроцессором файл можно скомпилировать обычным образом, например, так:
cc -c prog1.c
В сгенерированные исходные файлы C включаются заголовочные файлы из инсталляции
PostgreSQL, поэтому если вы установили PostgreSQL так, что соответствующий каталог не про-
895ECPG — встраиваемый SQL в C
сматривается по умолчанию, вам придётся добавить указание вида -I/usr/local/pgsql/include
в командную строку компиляции.
Чтобы скомпоновать программу со встраиваемым SQL, необходимо подключить библиотеку
libecpg примерно так:
cc -o myprog prog1.o prog2.o ... -lecpg
Возможно, и для этого понадобится добавить в командную строку указание вида -L/usr/local/
pgsql/lib.
Чтобы узнать пути вашей инсталляции, можно воспользоваться командой pg_configили pkg-
config(в качестве имени пакета нужно указать libecpg).
Если вы организуете процесс сборки большого проекта с применением make, может быть удобно
включить в ваши сборочные файлы следующее неявное правило:
ECPG = ecpg
%.c: %.pgc
$(ECPG) $&lt;
Полный синтаксис вызова команды ecpg приведён в описании ecpg.
Библиотека ecpg по умолчанию потокобезопасна. Однако для компиляции клиентского кода могут
потребоваться параметры командной строки для настройки многопоточности.
36.11. Библиотечные функции
Библиотека libecpg в основном содержит «скрытые» функции, применяемые для реализации
функциональности, выражаемой встраиваемыми командами SQL. Но есть также некоторые функ-
ции, которые можно вызывать напрямую. Заметьте, что код, задействующий эти функции, будет
непереносимым.
• ECPGdebug(int вкл, FILE *поток) с первым аргументом, отличным от нуля, включает вывод
отладочных сообщений в заданный поток. Журнал сообщений, полученный таким образом, бу-
дет содержать все операторы SQL с заданными входными переменными и результаты, выдан-
ные сервером PostgreSQL. Это может быть очень полезно для поиска ошибок в командах SQL.
Примечание
В Windows, если библиотека ecpg и приложение скомпилированы с разными фла-
гами, эта функция может вызвать крах приложения из-за различий внутреннего
представления указателей FILE. В частности, флаги многопоточной/однопоточной,
выпускаемой/отладочной или статической/динамической сборки должны быть
одинаковыми для библиотеки и всех использующих её приложений.
• ECPGget_PGconn(const char *имя_подключения) возвращает указатель на подключение к ба-
зе данных, имеющее заданное имя. Если аргумент имя_подключения равен NULL, возвращается
указатель на текущее подключение. Если определить подключение не удаётся, возвращается
NULL. Полученный указатель на подключение, если требуется, можно использовать при вызо-
ве любых других функций libpq.
Примечание
Манипулировать подключениями, открытыми средствами ecpg, напрямую через
libpq не следует.
896ECPG — встраиваемый SQL в C
• ECPGtransactionStatus(const char *имя_подключения) возвращает состояние текущей тран-
закции для подключения, на которое указывает имя_подключения. Возвращаемые коды со-
стояния перечислены в описании входящей в libpq функции PQtransactionStatus() в Разде-
ле 34.2.
• ECPGstatus(int номер_строки, const char* имя_подключения) возвращает true при наличии
подключения к базе данных и false в противном случае. В аргументе имя_подключения можно
передать NULL, если применяется одно подключение.
36.12. Большие объекты
ECPG не поддерживает большие объекты напрямую, но приложение на базе ECPG может ра-
ботать с большими объектами, используя предназначенные для этого функции, получив необ-
ходимый объект PGconn в результате вызова ECPGget_PGconn(). (Однако использовать функцию
ECPGget_PGconn() и напрямую воздействовать на объекты PGconn следует очень осторожно; в иде-
але стоит исключить при этом другие обращения к базе данных через ECPG.)
Подробнее функция ECPGget_PGconn() описана в Разделе 36.11. Интерфейс функций для работы с
большими объектами рассмотрен в Главе 35.
Функции для работы с большими объектами должны вызываться в блоке транзакций, поэтому если
режим автофиксации отключён, необходимо явно выдавать команды BEGIN.
В Примере 36.2 приведён пример программы, показывающий, как создать, записать и прочитать
большой объект в приложении ECPG.
Пример 36.2. Программа на базе ECPG, работающая с большими объектами
#include
#include
#include
#include
<stdio.h>
<stdlib.h>
<libpq-fe.h>
&lt;libpq/libpq-fs.h&gt;
EXEC SQL WHENEVER SQLERROR STOP;
int
main(void)
{
PGconn
Oid
int
char
int
char
int
*conn;
loid;
fd;
buf[256];
buflen = 256;
buf2[256];
rc;
memset(buf, 1, buflen);
EXEC SQL CONNECT TO testdb AS con1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
conn = ECPGget_PGconn("con1");
printf("conn = %p\n", conn);
/* create */
loid = lo_create(conn, 0);
if (loid &lt; 0)
printf("lo_create() failed: %s", PQerrorMessage(conn));
printf("loid = %d\n", loid);
897ECPG — встраиваемый SQL в C
/* write test */
fd = lo_open(conn, loid, INV_READ|INV_WRITE);
if (fd &lt; 0)
printf("lo_open() failed: %s", PQerrorMessage(conn));
printf("fd = %d\n", fd);
rc = lo_write(conn, fd, buf, buflen);
if (rc &lt; 0)
printf("lo_write() failed\n");
rc = lo_close(conn, fd);
if (rc &lt; 0)
printf("lo_close() failed: %s", PQerrorMessage(conn));
/* read test */
fd = lo_open(conn, loid, INV_READ);
if (fd &lt; 0)
printf("lo_open() failed: %s", PQerrorMessage(conn));
printf("fd = %d\n", fd);
rc = lo_read(conn, fd, buf2, buflen);
if (rc &lt; 0)
printf("lo_read() failed\n");
rc = lo_close(conn, fd);
if (rc &lt; 0)
printf("lo_close() failed: %s", PQerrorMessage(conn));
/* check */
rc = memcmp(buf, buf2, buflen);
printf("memcmp() = %d\n", rc);
/* cleanup */
rc = lo_unlink(conn, loid);
if (rc &lt; 0)
printf("lo_unlink() failed: %s", PQerrorMessage(conn));
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
36.13. Приложения на C++
ECPG обеспечивает поддержку языка C++ в ограниченном объёме. Некоторые её особенности
описаны в этом разделе.
Препроцессор ecpg принимает входной файл, написанный на C (или языке, подобном C) со встра-
иваемыми командами SQL, преобразует встроенные команды SQL в конструкции языка C и в ре-
зультате формирует файл .c. Объявления библиотечных функций, вызываемых в конструкциях C,
которые генерирует ecpg, заворачиваются в блоки extern "C" { ... } при использовании C++,
так что они должны прозрачно работать в C++.
Однако вообще говоря, препроцессор ecpg понимает только C; он не воспринимает особый синтак-
сис и зарезервированные слова языка C++. Поэтому какой-то код SQL, встроенный в код прило-
898ECPG — встраиваемый SQL в C
жения на C++, в котором используются сложные особенности C++, может корректно не обрабо-
таться препроцессором или не работать как ожидается.
Надёжный подход к применению внедрённого кода SQL в приложении на C++ заключается в том,
чтобы скрыть вызовы ECPG в модуле C, который будет вызываться приложением на C++ для рабо-
ты с базой данных и который будет скомпонован с остальным кодом C++. Подробнее это описано
в Подразделе 36.13.2.
36.13.1. Область видимости переменных среды
Препроцессор ecpg имеет понимание области видимости переменных в C. С языком C это довольно
просто, так как область видимости переменных определяется их блоками кода. В C++, однако,
переменные-члены класса задействуются не в том блоке кода, в каком они объявлены, так что
препроцессор ecpg не сможет корректно определить область видимости таких переменных.
Например, в следующем случае препроцессор ecpg не сможет найти определение переменной
dbname в методе test, так что произойдёт ошибка.
class TestCpp
{
EXEC SQL BEGIN DECLARE SECTION;
char dbname[1024];
EXEC SQL END DECLARE SECTION;
public:
TestCpp();
void test();
~TestCpp();
};
TestCpp::TestCpp()
{
EXEC SQL CONNECT TO testdb1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}
void Test::test()
{
EXEC SQL SELECT current_database() INTO :dbname;
printf("current_database = %s\n", dbname);
}
TestCpp::~TestCpp()
{
EXEC SQL DISCONNECT ALL;
}
При обработке данного кода будет выдано сообщение:
ecpg test_cpp.pgc
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
(test_cpp.pgc:28: ОШИБКА: переменная "dbname" не объявлена)
Для решения этой проблемы можно немного изменить метод test и задействовать в нём локальную
переменную для промежуточного хранения. Но предложенный подход нельзя считать хорошим,
так как это портит код и снижает производительность.
void TestCpp::test()
{
EXEC SQL BEGIN DECLARE SECTION;
899ECPG — встраиваемый SQL в C
char tmp[1024];
EXEC SQL END DECLARE SECTION;
EXEC SQL SELECT current_database() INTO :tmp;
strlcpy(dbname, tmp, sizeof(tmp));
printf("current_database = %s\n", dbname);
}
36.13.2. Разработка приложения на C++ с внешним модулем на C
Если вы поняли технические ограничения препроцессора ecpg с C++, вы можете прийти к заклю-
чению, что для использования ECPG в приложениях на C++ лучше связывать код C с кодом C+
+ на стадии компоновки, а не внедрять команды SQL непосредственно в код на C++. В данном
разделе показывается, как отделить встраиваемые команды SQL от кода приложения на C++, на
простом примере. В этом примере приложение реализуется на C++, а взаимодействие с сервером
PostgreSQL построено на C и ECPG.
Для сборки нужно создать три типа файлов: файл на C (*.pgc), заголовочный файл и файл на C++:
test_mod.pgc
Модуль подпрограмм будет выполнять SQL-команды, встроенные в C. Этот код нужно будет
преобразовать в test_mod.c с помощью препроцессора.
#include "test_mod.h"
#include <stdio.h>
void
db_connect()
{
EXEC SQL CONNECT TO testdb1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL
COMMIT;
}
void
db_test()
{
EXEC SQL BEGIN DECLARE SECTION;
char dbname[1024];
EXEC SQL END DECLARE SECTION;
EXEC SQL SELECT current_database() INTO :dbname;
printf("current_database = %s\n", dbname);
}
void
db_disconnect()
{
EXEC SQL DISCONNECT ALL;
}
test_mod.h
Заголовочный файл с объявлениями функций в модуле на языке C (test_mod.pgc). Он включа-
ется в test_cpp.cpp. Объявления в этом файле должны заключаться в блок extern "C", так как
он будет связываться с модулем C++.
#ifdef __cplusplus
extern "C" {
900ECPG — встраиваемый SQL в C
#endif
void db_connect();
void db_test();
void db_disconnect();
#ifdef __cplusplus
}
#endif
test_cpp.cpp
Основной код приложения, содержащий функцию main, а также, в данном примере, класс C++.
#include "test_mod.h"
class TestCpp
{
public:
TestCpp();
void test();
~TestCpp();
};
TestCpp::TestCpp()
{
db_connect();
}
void
TestCpp::test()
{
db_test();
}
TestCpp::~TestCpp()
{
db_disconnect();
}
int
main(void)
{
TestCpp *t = new TestCpp();
t-&gt;test();
return 0;
}
Для сборки приложения проделайте следующее. Преобразуйте test_mod.pgc в test_mod.c с помо-
щью ecpg, а затем получите test_mod.o, скомпилировав test_mod.c компилятором C:
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
После этого получите test_cpp.o, скомпилировав test_cpp.cpp компилятором C++:
c++ -c test_cpp.cpp -o test_cpp.o
Наконец, свяжите полученные объектные файлы, test_cpp.o и test_mod.o, в один исполняемый
файл, выполнив компоновку под управлением компилятора C++:
901ECPG — встраиваемый SQL в C
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
36.14. Команды встраиваемого SQL
В этом разделе описаны все команды, предназначенные специально для встраиваемого SQL. В
Справке: «Команды SQL» также описаны обычные команды SQL, которые можно использовать и
как встраиваемые, если явно не отмечено обратное.
902ECPG — встраиваемый SQL в C
ALLOCATE DESCRIPTOR
ALLOCATE DESCRIPTOR — выделить область SQL-дескриптора
Синтаксис
ALLOCATE DESCRIPTOR имя
Описание
ALLOCATE DESCRIPTOR выделяет новую именованную область SQL-дескриптора, через которую мож-
но обмениваться данными между сервером PostgreSQL и программой на C.
После использования области дескрипторов должны освобождаться командой DEALLOCATE
DESCRIPTOR.
Параметры
имя
Имя SQL-дескриптора, задаётся с учётом регистра. Это может быть идентификатор SQL или
переменная среды.
Примеры
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
Совместимость
Команда ALLOCATE DESCRIPTOR описана в стандарте SQL.
См. также
DEALLOCATE DESCRIPTOR, GET DESCRIPTOR, SET DESCRIPTOR
903ECPG — встраиваемый SQL в C
CONNECT
CONNECT — установить подключение к базе данных
Синтаксис
CONNECT TO цель_подключения [ AS имя_подключения ] [ USER пользователь_подключения ]
CONNECT TO DEFAULT
CONNECT пользователь_подключения
DATABASE цель_подключения
Описание
Команда CONNECT устанавливает подключение клиента к серверу PostgreSQL.
Параметры
цель_подключения
цель_соединения задаёт целевой сервер и базу для подключения в одной из нескольких форм.
[ имя_бд ] [ @сервер ] [ :порт ]
Подключение по TCP/IP
unix:postgresql://сервер [ :порт ] / [ имя_бд ] [ ?параметр_подключения ]
Подключение через Unix-сокеты
tcp:postgresql://сервер [ :порт ] / [ имя_бд ] [ ?параметр_подключения ]
Подключение по TCP/IP
Строковая константа SQL
содержащая значение в одной из показанных выше форм
переменная среды
переменная среды типа char[] или VARCHAR[], содержащая значение в одной из показанных
выше форм
объект_соединения
Необязательный идентификатор подключения, позволяющий обращаться к этому подключе-
нию в других командах. Это может быть идентификатор SQL или переменная среды.
пользователь_подключения
Имя пользователя для подключения к базе данных.
В этом параметре также можно передать имя и пароль одним из следующих способов:
имя_пользователя/пароль, имя_пользователя IDENTIFIED BY пароль или имя_пользователя
USING пароль.
В качестве имени пользователя и пароля можно задать идентификаторы SQL, строковые кон-
станты или переменные среды.
DEFAULT
Использовать все параметры подключения по умолчанию, которые определены библиотекой
libpq.
Примеры
Несколько вариантов указания параметров подключения:
904ECPG — встраиваемый SQL в C
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
connectuser;
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
connectpw;
EXEC SQL CONNECT
BY connectpw;
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
BY "connectpw";
EXEC SQL CONNECT
"connectpw";
EXEC SQL CONNECT
connectuser;
TO "connectdb" AS main;
TO "connectdb" AS second;
TO "unix:postgresql://200.46.204.71/connectdb" AS main USER
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
"unix:postgresql://localhost/connectdb" AS main USER connectuser;
'connectdb' AS main;
'unix:postgresql://localhost/connectdb' AS main USER :user;
:db AS :id;
:db USER connectuser USING :pw;
@localhost AS main USER connectdb;
REGRESSDB1 as main;
AS main USER connectdb;
connectdb AS :id;
connectdb AS main USER connectuser/connectdb;
connectdb AS main;
connectdb@localhost AS main;
tcp:postgresql://localhost/ USER connectdb;
tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY
TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED
TO unix:postgresql://localhost/ AS main USER connectdb;
TO unix:postgresql://localhost/connectdb AS main USER connectuser;
TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED
TO unix:postgresql://localhost/connectdb USER connectuser USING
TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER
Следующий пример программы демонстрирует применение переменных среды для определения
параметров подключения:
int
main(void)
{
EXEC SQL BEGIN DECLARE
char *dbname
=
char *user
=
char *connection =
SECTION;
"testdb";
/* имя базы данных */
"testuser"; /* имя пользователя подключения */
"tcp:postgresql://localhost:5432/testdb";
/* строка подключения */
char ver[256];
/* буфер для хранения строки версии */
EXEC SQL END DECLARE SECTION;
ECPGdebug(1, stderr);
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
CONNECT TO :dbname USER :user;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
SELECT version() INTO :ver;
DISCONNECT;
printf("version: %s\n", ver);
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
CONNECT TO :connection USER :user;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
SELECT version() INTO :ver;
DISCONNECT;
printf("version: %s\n", ver);
905ECPG — встраиваемый SQL в C
return 0;
}
Совместимость
Команда CONNECT описана в стандарте SQL, но формат параметров подключения определяется ре-
ализацией.
См. также
DISCONNECT, SET CONNECTION
906ECPG — встраиваемый SQL в C
DEALLOCATE DESCRIPTOR
DEALLOCATE DESCRIPTOR — освободить область SQL-дескриптора
Синтаксис
DEALLOCATE DESCRIPTOR имя
Описание
DEALLOCATE DESCRIPTOR освобождает область именованного SQL-дескриптора.
Параметры
имя
Имя дескриптора, подлежащего освобождению, задаётся с учётом регистра. Это может быть
идентификатор SQL или переменная среды.
Примеры
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
Совместимость
Команда DEALLOCATE DESCRIPTOR описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, GET DESCRIPTOR, SET DESCRIPTOR
907ECPG — встраиваемый SQL в C
DECLARE
DECLARE — определить курсор
Синтаксис
DECLARE имя_курсора [
WITHOUT } HOLD ] FOR
DECLARE имя_курсора [
WITHOUT } HOLD ] FOR
BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH |
подготовленный_оператор
BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH |
запрос
Описание
DECLARE объявляет курсор для прохода по набору результатов подготовленного оператора. Эта ко-
манда несколько отличается от обычной SQL-команды DECLARE: тогда как последняя выполняет за-
прос и подготавливает набор результатов для получения, встраиваемая SQL-команда просто объ-
являет имя в качестве «переменной цикла» для прохода по набору результатов запроса; фактиче-
ски запрос выполнится, когда курсор будет открыт командой OPEN.
Параметры
имя_курсора
Имя курсора, задаётся с учётом регистра. Это может быть идентификатор SQL или переменная
среды.
подготовленный_оператор
Имя подготовленного запроса, задаваемое SQL-идентификатором или переменной среды.
запрос
Команда SELECT или VALUES, выдающая строки, которые будут получены через курсор.
Параметры курсора рассматриваются в описании DECLARE.
Примеры
Примеры объявления курсора для запроса:
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
Пример объявления курсора для подготовленного оператора:
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
Совместимость
Команда DECLARE описана в стандарте SQL.
См. также
OPEN, CLOSE, DECLARE
908ECPG — встраиваемый SQL в C
DESCRIBE
DESCRIBE — получить информацию о подготовленном операторе или наборе результатов
Синтаксис
DESCRIBE [ OUTPUT ] подготовленный_оператор USING [ SQL ] DESCRIPTOR имя_дескриптора
DESCRIBE [ OUTPUT ] подготовленный_оператор INTO [ SQL ] DESCRIPTOR имя_дескриптора
DESCRIBE [ OUTPUT ] подготовленный_оператор INTO имя_sqlda
Описание
DESCRIBE получает метаданные о результирующих столбцах, содержащихся в подготовленном опе-
раторе, не считывая собственно строки результата.
Параметры
подготовленный_оператор
Имя подготовленного оператора. Это может быть идентификатор SQL или переменная среды.
имя_дескриптора
Имя дескриптора, задаётся с учётом регистра. Это может быть идентификатор SQL или пере-
менная среды.
имя_sqlda
Имя переменной SQLDA.
Примеры
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
ALLOCATE DESCRIPTOR mydesc;
PREPARE stmt1 FROM :sql_stmt;
DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
DEALLOCATE DESCRIPTOR mydesc;
Совместимость
Команда DESCRIBE описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, GET DESCRIPTOR
909ECPG — встраиваемый SQL в C
DISCONNECT
DISCONNECT — закрыть подключение к базе данных
Синтаксис
DISCONNECT
DISCONNECT
DISCONNECT
DISCONNECT
имя_подключения
[ CURRENT ]
DEFAULT
ALL
Описание
DISCONNECT закрывает подключение (или все подключения) к базе данных.
Параметры
имя_подключения
Имя подключения к базе данных устанавливается командой CONNECT.
CURRENT
Закрывает «текущее» подключение, то есть подключение, открытое последним, либо установ-
ленное командой SET CONNECTION. Текущее подключение подразумевается по умолчанию, если
DISCONNECT выполняется без аргументов.
DEFAULT
Закрывает подключение по умолчанию.
ALL
Закрывает все открытые подключения.
Примеры
int
main(void)
{
EXEC SQL
EXEC SQL
EXEC SQL
EXEC SQL
CONNECT
CONNECT
CONNECT
CONNECT
TO
TO
TO
TO
testdb
testdb
testdb
testdb
AS
AS
AS
AS
EXEC SQL DISCONNECT CURRENT;
EXEC SQL DISCONNECT DEFAULT;
EXEC SQL DISCONNECT ALL;
DEFAULT USER testuser;
con1 USER testuser;
con2 USER testuser;
con3 USER testuser;
/* закрывает con3
*/
/* закрывает DEFAULT
*/
/* закрывает con2 и con1 */
return 0;
}
Совместимость
Команда DISCONNECT описана в стандарте SQL.
См. также
CONNECT, SET CONNECTION
910ECPG — встраиваемый SQL в C
EXECUTE IMMEDIATE
EXECUTE IMMEDIATE — динамически подготовить и выполнить оператор
Синтаксис
EXECUTE IMMEDIATE строка
Описание
EXECUTE IMMEDIATE немедленно подготавливает и выполняет динамически задаваемый оператор
SQL, не получая при этом строки результата.
Параметры
строка
Строковая константа C или переменная среды, содержащая SQL-оператор, который нужно вы-
полнить.
Примеры
Пример выполнения оператора INSERT с применением команды EXECUTE IMMEDIATE и переменной
среды command:
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1,
'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
Совместимость
Команда EXECUTE IMMEDIATE описана в стандарте SQL.
911ECPG — встраиваемый SQL в C
GET DESCRIPTOR
GET DESCRIPTOR — получить информацию из области дескриптора SQL
Синтаксис
GET DESCRIPTOR имя_дескриптора :cvariable = элемент_заголовка_дескриптора [, ... ]
GET DESCRIPTOR имя_дескриптора VALUE номер_столбца :cvariable = элемент_дескриптора
[, ... ]
Описание
GET DESCRIPTOR получает информацию о наборе результатов запроса из области дескриптора SQL
и сохраняет её в переменные среды. Область дескриптора обычно предварительно заполняется
командами FETCH или SELECT, чтобы из неё можно было перенести сопутствующую информацию
в переменные среды.
Эта команда имеет две формы: первая форма выдаёт элементы из «заголовка» дескриптора, ко-
торый относится ко всему набору результатов в целом. Например, это число строк. Другая фор-
ма, требующая указания в дополнительном параметре номера столбца, выдаёт информацию о кон-
кретном столбце строки. В качестве примеров можно привести имя столбца и фактическое значе-
ние в этом столбце.
Параметры
имя_дескриптора
Имя дескриптора.
элемент_заголовка_дескриптора
Идентификатор, определяющий, какой элемент заголовка нужно получить. В настоящее время
поддерживается только COUNT, позволяющий получить число столбцов в наборе результатов.
номер_столбца
Номер столбца, информацию о котором нужно получить. Нумерация начинается с 1.
элемент_дескриптора
Идентификатор, определяющий, какой элемент информации о столбце нужно получить. Спи-
сок поддерживаемых элементов приведён в Подразделе 36.7.1.
cvariable
Переменная среды, в которую будут сохранены данные, полученные из области дескриптора.
Примеры
Пример получения числа столбцов в наборе результатов:
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
Пример получения размера данных в первом столбце:
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
Пример получения содержимого данных второго столбца в виде строки:
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
Следующий пример демонстрирует всю процедуру выполнения SELECT current_database(); и вы-
вода числа столбцов, длины данных в столбце и содержимого столбца:
int
912ECPG — встраиваемый SQL в C
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
int d_count;
char d_data[1024];
int d_returned_octet_length;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL ALLOCATE DESCRIPTOR d;
/* Объявить, открыть курсор и присвоить ему дескриптор */
EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
EXEC SQL OPEN cur;
EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
/* Получить общее число столбцов */
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
printf("d_count
= %d\n", d_count);
/* Получить размер возвращённого столбца */
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
printf("d_returned_octet_length = %d\n", d_returned_octet_length);
/* Выбрать возвращённый столбец в виде текстовой строки */
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
printf("d_data
= %s\n", d_data);
/* Закрытие */
EXEC SQL CLOSE cur;
EXEC SQL COMMIT;
EXEC SQL DEALLOCATE DESCRIPTOR d;
EXEC SQL DISCONNECT ALL;
return 0;
}
При выполнении этого примера будет получен такой результат:
d_count
= 1
d_returned_octet_length = 6
d_data
= testdb
Совместимость
Команда GET DESCRIPTOR описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, SET DESCRIPTOR
913ECPG — встраиваемый SQL в C
OPEN
OPEN — открыть динамический курсор
Синтаксис
OPEN имя_курсора
OPEN имя_курсора USING значение [, ... ]
OPEN имя_курсора USING SQL DESCRIPTOR имя_дескриптора
Описание
OPEN открывает курсор и в дополнение может связывать фактические значения с местозаполни-
телями в объявлении курсора. Курсор должен быть предварительно объявлен командой DECLARE.
Команда OPEN запускает выполнение запроса на сервере.
Параметры
имя_курсора
Имя открываемого курсора. Этот может быть идентификатор SQL или переменная среды.
значение
Значение, связываемое с местозаполнителем в курсоре. Это может быть константа SQL, пере-
менная среды или переменная среды с индикатором.
имя_дескриптора
Имя дескриптора, содержащего значения, которые должны быть связаны с местозаполнителя-
ми в курсоре. Это может быть идентификатор SQL или переменная среды.
Примеры
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
OPEN
OPEN
OPEN
OPEN
a;
d USING 1, 'test';
c1 USING SQL DESCRIPTOR mydesc;
:curname1;
Совместимость
Команда OPEN описана в стандарте SQL.
См. также
DECLARE, CLOSE
914ECPG — встраиваемый SQL в C
PREPARE
PREPARE — подготовить оператор к выполнению
Синтаксис
PREPARE имя FROM строка
Описание
Команда PREPARE подготавливает к выполнению динамический оператор, задаваемый в виде стро-
ки. Она отличается от обычного SQL-оператора PREPARE, который также можно использовать
во встраиваемых командах. Для обоих типов подготовленных операторов применяется команда
EXECUTE.
Параметры
подготовленный_оператор
Идентификатор для подготовленного запроса.
строка
Строковая константа C или переменная среды, содержащая подготавливаемый оператор:
SELECT, INSERT, UPDATE или DELETE.
Примеры
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";
EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;
EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
Совместимость
Команда PREPARE описана в стандарте SQL.
См. также
EXECUTE
915ECPG — встраиваемый SQL в C
SET AUTOCOMMIT
SET AUTOCOMMIT — установить режим автофиксации для текущего сеанса
Синтаксис
SET AUTOCOMMIT { = | TO } { ON | OFF }
Описание
SET AUTOCOMMIT устанавливает режим автофиксации для текущего сеанса использования базы дан-
ных. По умолчанию программы со встраиваемым SQL работают не в режиме автофиксации, так что
в определённые моменты нужно явно выполнять COMMIT. Эта команда может переключить сеанс в
режим автофиксации, когда неявно фиксируется каждый отдельный оператор.
Совместимость
SET AUTOCOMMIT — расширение PostgreSQL ECPG.
916ECPG — встраиваемый SQL в C
SET CONNECTION
SET CONNECTION — выбрать подключение к базе данных
Синтаксис
SET CONNECTION [ TO | = ] имя_подключения
Описание
SET CONNECTION устанавливает «текущее» подключение к базе данных, которое будет использо-
ваться командами, не задающими подключение явно.
Параметры
имя_подключения
Имя подключения к базе данных устанавливается командой CONNECT.
DEFAULT
Устанавливает заданное подключение подключением по умолчанию.
Примеры
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
Совместимость
Команда SET CONNECTION описана в стандарте SQL.
См. также
CONNECT, DISCONNECT
917ECPG — встраиваемый SQL в C
SET DESCRIPTOR
SET DESCRIPTOR — внести информацию в область дескриптора SQL
Синтаксис
SET DESCRIPTOR имя_дескриптора элемент_заголовка_дескриптора = значение [, ... ]
SET DESCRIPTOR имя_дескриптора VALUE номер элемент_дескриптора = значение [, ...]
Описание
SET DESCRIPTOR заполняет область SQL-дескриптора значениями. Заполненная область дескрипто-
ра обычно применяется для привязывания параметров при выполнении подготовленного запроса.
Эта команда имеет две формы: первая применяется к «заголовку» дескриптора, который не за-
висит от конкретных данных. Вторая форма устанавливает значения для определённых полей по
номерам.
Параметры
имя_дескриптора
Имя дескриптора.
элемент_заголовка_дескриптора
Идентификатор, определяющий, какой элемент заголовка нужно задать. В настоящее время
поддерживается только COUNT, позволяющий задать число элементов в дескрипторе.
номер
Номер элемента дескриптора, для которого задаётся значение. Нумерация начинается с 1.
элемент_дескриптора
Идентификатор, определяющий, какой элемент нужно установить в дескрипторе. Список под-
держиваемых элементов приведён в Подразделе 36.7.1.
значение
Значение, которое нужно поместить в элемент дескриптора. Это может быть константа SQL
или переменная среды.
Примеры
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SET
SET
SET
SET
SET
DESCRIPTOR
DESCRIPTOR
DESCRIPTOR
DESCRIPTOR
DESCRIPTOR
indesc
indesc
indesc
indesc
indesc
COUNT
VALUE
VALUE
VALUE
VALUE
=
1
1
2
2
1;
DATA = 2;
DATA = :val1;
INDICATOR = :val1, DATA = 'some string';
INDICATOR = :val2null, DATA = :val2;
Совместимость
Команда SET DESCRIPTOR описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, GET DESCRIPTOR
918ECPG — встраиваемый SQL в C
TYPE
TYPE — создать новый тип данных
Синтаксис
TYPE имя_типа IS тип_С
Описание
Команда TYPE определяет новый тип C. Она равнозначна добавлению typedef в секции объявлений.
Эта команда принимается, только когда ecpg запускается с параметром -c.
Параметры
имя_типа
Имя нового типа. Это имя должно быть допустимым для типа в языке C.
тип_С
Определение типа C.
Примеры
EXEC SQL TYPE customer IS
struct
{
varchar name[50];
int
phone;
};
EXEC SQL TYPE cust_ind IS
struct ind
{
short
name_ind;
short
phone_ind;
};
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
TYPE
TYPE
TYPE
TYPE
TYPE
c IS char reference;
ind IS union { int integer; short smallint; };
intarray IS int[AMOUNT];
str IS varchar[BUFFERSIZ];
string IS char[11];
Пример программы, в которой используется EXEC SQL TYPE:
EXEC SQL WHENEVER SQLERROR SQLPRINT;
EXEC SQL TYPE tt IS
struct
{
varchar v[256];
int
i;
};
EXEC SQL TYPE tt_ind IS
struct ind {
short
v_ind;
short
i_ind;
};
919ECPG — встраиваемый SQL в C
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
tt t;
tt_ind t_ind;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;
printf("t.v = %s\n", t.v.arr);
printf("t.i = %d\n", t.i);
printf("t_ind.v_ind = %d\n", t_ind.v_ind);
printf("t_ind.i_ind = %d\n", t_ind.i_ind);
EXEC SQL DISCONNECT con1;
return 0;
}
Эта программа выдаёт следующее:
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
Совместимость
Команда TYPE — расширение PostgreSQL.
920ECPG — встраиваемый SQL в C
VAR
VAR — определить переменную
Синтаксис
VAR имя_переменной IS тип_С
Описание
Команда VAR назначает переменной среды новый тип данных C. Переменная среды должна быть
объявлена ранее в секции объявлений.
Параметры
имя_переменной
Имя переменной C.
тип_С
Определение типа C.
Примеры
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
Совместимость
Команда VAR — расширение PostgreSQL.
921ECPG — встраиваемый SQL в C
WHENEVER
WHENEVER — определить действие, которое должно выполняться, когда при обработке SQL-опе-
ратора возникает определённое условие
Синтаксис
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } действие
Описание
Устанавливает поведение в случае определённых условий (строки не найдены, выданы предупре-
ждения или ошибки SQL и т. д.), возникающих в ходе выполнения SQL.
Параметры
Описание параметров приведено в Подразделе 36.8.1.
Примеры
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
NOT FOUND CONTINUE;
NOT FOUND DO BREAK;
NOT FOUND DO CONTINUE;
SQLWARNING SQLPRINT;
SQLWARNING DO warn();
SQLERROR sqlprint;
SQLERROR CALL print2();
SQLERROR DO handle_error("select");
SQLERROR DO sqlnotice(NULL, NONO);
SQLERROR DO sqlprint();
SQLERROR GOTO error_label;
SQLERROR STOP;
Типичное применение конструкция WHENEVER NOT FOUND BREAK находит в обработке результатов
запроса в цикле:
int
main(void)
{
EXEC SQL
EXEC SQL
EXEC SQL
EXEC SQL
EXEC SQL
CONNECT TO testdb AS con1;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
ALLOCATE DESCRIPTOR d;
DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
OPEN cur;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
...
}
EXEC SQL CLOSE cur;
EXEC SQL COMMIT;
EXEC SQL DEALLOCATE DESCRIPTOR d;
EXEC SQL DISCONNECT ALL;
922ECPG — встраиваемый SQL в C
return 0;
}
Совместимость
Команда WHENEVER описана в стандарте SQL, но большинство действий относятся к расширениям
PostgreSQL.
36.15. Режим совместимости с Informix
Препроцессор ecpg может работать в так называемом режиме совместимости с Informix. Если
этот режим включён, ecpg старается работать как предкомпилятор Informix для кода Informix E/
SQL. Вообще говоря, это позволяет записывать встраиваемые команды SQL, используя знак дол-
лара вместо слов EXEC SQL:
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
Примечание
Между $ и последующей директивой препроцессора (в частности, include, define,
ifdef и т. п.) не должно быть пробельных символов. В противном случае препроцессор
воспримет следующее слово как имя переменной среды.
Поддерживаются два режима совместимости: INFORMIX и INFORMIX_SE
При компоновке программ, использующих этот режим совместимости, обязательно подключите
библиотеку libcompat, поставляемую с ECPG.
Помимо ранее упомянутого синтаксического сахара, режим совместимости с Informix приносит из
E/SQL в ECPG набор функций для ввода, вывода и преобразования данных, а также встраиваемые
операторы SQL.
Режим совместимости с Informix тесно связан с библиотекой pgtypeslib из ECPG. Библиотека
pgtypeslib сопоставляет типы данных SQL с типами данных в ведущей программе на C, а большин-
ство дополнительных функций режима совместимости с Informix позволяют работать с этими ти-
пами C. Заметьте, однако, что степень совместимости ограничена. ECPG не пытается копировать
поведение Informix; вы можете выполнять примерно те же операции и пользоваться функции с
теми же именами и с тем же поведением, но если вы используете Informix, просто заменить одно
средство другим на данный момент нельзя. Более того, есть различия и в типах данных. В част-
ности, типы даты и интервала в PostgreSQL не воспринимают диапазоны, как например, YEAR TO
MINUTE, так что и в ECPG это не будет поддерживаться.
36.15.1. Дополнительные типы
Теперь в режиме Informix без указания typedef поддерживается специальный псевдотип Informix
"string" для хранения символьной строки, обрезаемой справа. На самом деле, в режиме Informix
ECPG откажется обрабатывать исходные файлы, содержащие определение типа typedef некото-
рый_тип string;
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* эта переменная будет содержать обрезанные данные */
EXEC SQL END DECLARE SECTION;
EXEC SQL FETCH MYCUR INTO :userid;
923ECPG — встраиваемый SQL в C
36.15.2. Дополнительные/недостающие операторы встраиваемого
SQL
CLOSE DATABASE
Этот оператор закрывает текущее подключение. Фактически это синоним команды DISCONNECT
CURRENT в ECPG:
$CLOSE DATABASE;
EXEC SQL CLOSE DATABASE;
/* закрыть текущее подключение */
FREE имя_курсора
Из-за различий в подходах ECPG и ESQL/C Informix (т. е. другого разделения на чисто грамма-
тические преобразования и вызовы нижележащей библиотеки времени выполнения), в ECPG
нет оператора FREE имя_курсора. Это связано с тем, что в ECPG команда DECLARE CURSOR не
сводится к вызову функции в библиотеке времени выполнения, которая бы принимала имя кур-
сора. Это значит, что курсоры SQL в библиотеке ECPG не требуют обслуживания, оно требует-
ся только на уровне сервера PostgreSQL.
FREE имя_оператора
Команда FREE имя_оператора является синонимом команды DEALLOCATE PREPARE имя_опера-
тора.
36.15.3. Области дескрипторов SQLDA, совместимые с Informix
Режим совместимости с Informix поддерживает структуру, отличную от описанной в Подразде-
ле 36.7.2. См. ниже:
struct sqlvar_compat
{
short
sqltype;
int
sqllen;
char
*sqldata;
short *sqlind;
char
*sqlname;
char
*sqlformat;
short
sqlitype;
short
sqlilen;
char
*sqlidata;
int
sqlxid;
char
*sqltypename;
short
sqltypelen;
short
sqlownerlen;
short
sqlsourcetype;
char
*sqlownername;
int
sqlsourceid;
char
*sqlilongdata;
int
sqlflags;
void
*sqlreserved;
};
struct sqlda_compat
{
short sqld;
struct sqlvar_compat *sqlvar;
char
desc_name[19];
short desc_occ;
struct sqlda_compat *desc_next;
void *reserved;
924ECPG — встраиваемый SQL в C
};
typedef struct sqlvar_compat
typedef struct sqlda_compat
sqlvar_t;
sqlda_t;
Глобальные свойства:
sqld
Число полей в дескрипторе SQLDA.
sqlvar
Указатель на свойства по полям.
desc_name
Не используется, заполняется нулями.
desc_occ
Размер структуры в памяти.
desc_next
Указатель на следующую структуру SQLDA, если набор результатов содержит больше одной
записи.
reserved
Неиспользуемый указатель, содержит NULL. Сохраняется для совместимости с Informix.
Свойства, относящиеся к полям, описаны ниже, они хранятся в массиве sqlvar:
sqltype
Тип поля. Соответствующие константы представлены в sqltypes.h
sqllen
Длина данных поля.
sqldata
Указатель на данные поля. Этот указатель имеет тип char *, но он указывает на данные в
двоичном формате. Например:
int intval;
switch (sqldata-&gt;sqlvar[i].sqltype)
{
case SQLINTEGER:
intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;
break;
...
}
sqlind
Указатель на индикатор NULL. Если возвращается командами DESCRIBE или FETCH, это все-
гда действительный указатель. Если передаётся на вход команде EXECUTE ... USING sqlda;,
NULL вместо указателя означает, что значение этого поля отлично от NULL. Чтобы обозначить
NULL в поле, необходимо корректно установить этот указатель и sqlitype. Например:
if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)
printf("value is NULL\n");
925ECPG — встраиваемый SQL в C
sqlname
Имя поля, в виде строки с завершающим 0.
sqlformat
Зарезервировано в Informix, значение PQfformat() для данного поля.
sqlitype
Тип данных индикатора NULL. При получении данных с сервера это всегда SQLSMINT. Когда
SQLDA используется в параметризованном запросе, данные индикатора обрабатываются в соот-
ветствии с указанным здесь типом.
sqlilen
Длина данных индикатора NULL.
sqlxid
Расширенный тип поля, результат функции PQftype().
sqltypename
sqltypelen
sqlownerlen
sqlsourcetype
sqlownername
sqlsourceid
sqlflags
sqlreserved
Не используются.
sqlilongdata
Совпадает с sqldata, если sqllen превышает 32 Кбайта.
Например:
EXEC SQL INCLUDE sqlda.h;
sqlda_t
SECTION */
*sqlda; /* Это объявление не обязательно должно быть внутри DECLARE
EXEC SQL BEGIN DECLARE SECTION;
char *prep_stmt = "select * from table1";
int i;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL PREPARE mystmt FROM :prep_stmt;
EXEC SQL DESCRIBE mystmt INTO sqlda;
printf("# of fields: %d\n", sqlda-&gt;sqld);
for (i = 0; i &lt; sqlda-&gt;sqld; i++)
printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);
EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
EXEC SQL OPEN mycursor;
EXEC SQL WHENEVER NOT FOUND GOTO out;
926ECPG — встраиваемый SQL в C
while (1)
{
EXEC SQL FETCH mycursor USING sqlda;
}
EXEC SQL CLOSE mycursor;
free(sqlda); /* Освобождать нужно только основную структуру,
* sqlda и sqlda-&gt;sqlvar находятся в одной выделенной области. */
Дополнительную информацию можно найти в заголовочном файле sqlda.h и в регрессионном те-
сте src/interfaces/ecpg/test/compat_informix/sqlda.pgc.
36.15.4. Дополнительные функции
decadd
Складывает два значения типа decimal.
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
Эта функция получает указатель на первый операнд типа decimal (arg1), указатель на второй
операнд типа decimal (arg2) и указатель на переменную типа decimal, в которую будет записана
сумма (sum). В случае успеха эта функция возвращает 0. ECPG_INFORMIX_NUM_OVERFLOW возвра-
щается в случае переполнения, а ECPG_INFORMIX_NUM_UNDERFLOW в случае антипереполнения.
При любых других ошибках возвращается -1, а в errno устанавливается код errno из pgtypeslib.
deccmp
Сравнивает два значения типа decimal.
int deccmp(decimal *arg1, decimal *arg2);
Эта функция получает указатель на первое значение типа decimal (arg1), указатель на второе
значение типа decimal (arg2) и возвращает целое, отражающее результат сравнения этих чи-
сел.
• 1, если значение, на которое указывает arg1, больше значения, на которое указывает var2
• -1, если значение, на которое указывает arg1, меньше значения, на которое указывает
arg2
• 0, если значение, на которое указывает arg1, равно значению, на которое указывает arg2
deccopy
Копирует значение типа decimal.
void deccopy(decimal *src, decimal *target);
Функция принимает в первом аргументе (src) указатель на значение decimal, которое долж-
но быть скопировано, а во втором аргументе (target) принимает указатель на структуру типа
decimal для скопированного значения.
deccvasc
Преобразует значение из представления ASCII в тип decimal.
int deccvasc(char *cp, int len, decimal *np);
Эта функция получает указатель на строку, содержащую строковое представление числа, ко-
торое нужно преобразовать, (cp), а также его длину len. В np передаётся указатель на пере-
менную типа decimal, в которую будет помещён результат преобразования.
Допустимыми являются, например следующие форматы: -2, .794, +3.44, 592.49E07 или
-32.84e-4.
927ECPG — встраиваемый SQL в C
В случае успеха эта функция возвращает 0. При переполнении или антипереполнении возвра-
щается ECPG_INFORMIX_NUM_OVERFLOW или ECPG_INFORMIX_NUM_UNDERFLOW, соответственно. Ес-
ли разобрать ASCII-представление не удаётся, возвращается ECPG_INFORMIX_BAD_NUMERIC или
ECPG_INFORMIX_BAD_EXPONENT, если не удаётся разобрать компонент экспоненты.
deccvdbl
Преобразует значение double в значение типа decimal.
int deccvdbl(double dbl, decimal *np);
Данная функция принимает в первом аргументе (dbl) переменную типа double, которая долж-
на быть преобразована. Во втором аргументе (np) она принимает указатель на переменную
decimal, в которую будет помещён результат операции.
Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить пре-
образование не удалось.
deccvint
Преобразует значение int в значение типа decimal.
int deccvint(int in, decimal *np);
Данная функция принимает в первом аргументе (in) переменную типа int, которая должна быть
преобразована. Во втором аргументе (np) она принимает указатель на переменную decimal, в
которую будет помещён результат операции.
Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить пре-
образование не удалось.
deccvlong
Преобразует значение long в значение типа decimal.
int deccvlong(long lng, decimal *np);
Данная функция принимает в первом аргументе (lng) переменную типа long, которая долж-
на быть преобразована. Во втором аргументе (np) она принимает указатель на переменную
decimal, в которую будет помещён результат операции.
Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить пре-
образование не удалось.
decdiv
Делит одну переменную типа decimal на другую.
int decdiv(decimal *n1, decimal *n2, decimal *result);
Эта функция получает указатели на переменные (n1 и n2) и вычисляет частное n1/n2. В result
передаётся указатель на переменную, в которую будет помещён результат операции.
В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае перепол-
нения или антипереполнения данная функция возвращает ECPG_INFORMIX_NUM_OVERFLOW или
ECPG_INFORMIX_NUM_UNDERFLOW, соответственно. При попытке деления на ноль возвращается
ECPG_INFORMIX_DIVIDE_ZERO.
decmul
Перемножает два значения типа decimal.
int decmul(decimal *n1, decimal *n2, decimal *result);
Эта функция получает указатели на переменные (n1 и n2) и вычисляет произведение n1*n2. В
result передаётся указатель на переменную, в которую будет помещён результат операции.
928ECPG — встраиваемый SQL в C
В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае перепол-
нения или антипереполнения данная функция возвращает ECPG_INFORMIX_NUM_OVERFLOW или
ECPG_INFORMIX_NUM_UNDERFLOW, соответственно.
decsub
Вычитает одно значение типа decimal из другого.
int decsub(decimal *n1, decimal *n2, decimal *result);
Эта функция получает указатели на переменные (n1 и n2) и вычисляет разность n1-n2. В result
передаётся указатель на переменную, в которую будет помещён результат операции.
В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае перепол-
нения или антипереполнения данная функция возвращает ECPG_INFORMIX_NUM_OVERFLOW или
ECPG_INFORMIX_NUM_UNDERFLOW, соответственно.
dectoasc
Преобразует переменную типа decimal в представление ASCII (в строку C char*).
int dectoasc(decimal *np, char *cp, int len, int right)
Эта функция получает указатель на переменную типа decimal (np), которая будет преобразо-
вана в текстовое представление. Аргумент cp указывает на буфер, в который будет помещён
результат операции. Аргумент right определяет, сколько должно выводиться цифр правее де-
сятичной точки. Результат будет округлён до этого числа десятичных цифр. Значение right,
равное -1, указывает, что выводиться должны все имеющиеся десятичные цифры. Если длина
выходного буфера, которую задаёт len, недостаточна для помещения в него текстового пред-
ставления, включая завершающий нулевой байт, в буфере сохраняется один знак * и возвра-
щается -1.
Эта функция возвращает -1, если буфер cp слишком мал, либо ECPG_INFORMIX_OUT_OF_MEMORY
при нехватке памяти.
dectodbl
Преобразует переменную типа decimal в тип double.
int dectodbl(decimal *np, double *dblp);
Эта функция получает указатель (np) на значение decimal, которое нужно преобразовать, и
указатель (dblp) на переменную double, в которую будет помещён результат операции.
В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование
не удалось.
dectoint
Преобразует переменную типа decimal в тип integer.
int dectoint(decimal *np, int *ip);
Эта функция получает указатель (np) на значение decimal, которое нужно преобразовать, и
указатель (ip) на целочисленную переменную, в которую будет помещён результат операции.
В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование
не удалось. В случае переполнения возвращается ECPG_INFORMIX_NUM_OVERFLOW.
Заметьте, что реализация ECPG отличается от реализации Informix. В Informix целое ограни-
чивается диапазоном -32767 .. 32767, тогда как в ECPG ограничение зависит от архитектуры
(-INT_MAX .. INT_MAX).
dectolong
Преобразует переменную типа decimal в тип long.
929ECPG — встраиваемый SQL в C
int dectolong(decimal *np, long *lngp);
Эта функция получает указатель (np) на значение decimal, которое нужно преобразовать, и
указатель (lngp) на переменную типа long, в которую будет помещён результат операции.
В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование
не удалось. В случае переполнения возвращается ECPG_INFORMIX_NUM_OVERFLOW.
Заметьте, что реализация ECPG отличается от реализации Informix. В Informix длинное целое
ограничено диапазоном -2 147 483 647 .. 2 147 483 647, тогда как в ECPG ограничение зависит
от архитектуры (-LONG_MAX .. LONG_MAX).
rdatestr
Преобразует дату в строку C char*.
int rdatestr(date d, char *str);
Эта функция принимает два аргумента. В первом (d) передаётся дата, которую нужно преобра-
зовать, а во втором указатель на целевую строку. Результат всегда выводится в формате yyyy-
mm-dd, так что для этой строки нужно выделить минимум 11 байт (включая завершающий ну-
левой байт).
Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.
Заметьте, что реализация ECPG отличается от реализации Informix. В Informix формат вывода
можно изменить переменными окружения, а в ECPG он фиксирован.
rstrdate
Разбирает текстовое представление даты.
int rstrdate(char *str, date *d);
Эта функция получает текстовое представление (str) даты, которую нужно преобразовать, и
указатель на переменную типа date (d). Для данной функции нельзя задать маску формата. Она
использует стандартную маску формата Informix, а именно: mm/dd/yyyy. Внутри эта функция
вызывает rdefmtdate. Таким образом, rstrdate не будет быстрее, и если у вас есть выбор, ис-
пользуйте функцию rdefmtdate, которая позволяет явно задать маску формата.
Эта функция возвращает те же значения, что и rdefmtdate.
rtoday
Выдаёт текущую дату.
void rtoday(date *d);
Эта функция получает указатель на переменную (d) типа date, в которую будет записана теку-
щая дата.
Внутри эта функция вызывает PGTYPESdate_today.
rjulmdy
Извлекает значения дня, месяца и года из переменной типа date.
int rjulmdy(date d, short mdy[3]);
Эта функция получает дату d и указатель на 3 коротких целочисленных значения mdy. Имя
переменной указывает на порядок значений: в mdy[0] записывается номер месяца, в mdy[1] —
номер дня, а в mdy[2] — год.
В текущем состоянии эта функция всегда возвращает 0.
Внутри эта функция вызывает PGTYPESdate_julmdy.
930ECPG — встраиваемый SQL в C
rdefmtdate
Преобразует символьную строку в значение типа date по маске формата.
int rdefmtdate(date *d, char *fmt, char *str);
Эта функция принимает указатель на переменную типа date (d), в которую будет помещён ре-
зультат операции, маску формата для разбора даты (fmt) и строку C char*, содержащую тексто-
вое представление даты (str). Ожидается, что текстовое представление будет соответствовать
маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция
анализирует только порядок элементов и ищет в нём подстроки yy или yyyy, обозначающие по-
зицию года, подстроку mm, обозначающую позицию месяца, и dd, обозначающую позицию дня.
Эта функция возвращает следующие значения:
• 0 — Функция выполнена успешно.
• ECPG_INFORMIX_ENOSHORTDATE — Дата не содержит разделителей между днём, месяцем и
годом. С таким форматом входная строка должна быть длиной ровно 6 или 8 байт, но это
не так.
• ECPG_INFORMIX_ENOTDMY — Строка формата не определяет корректно последовательный по-
рядок года, месяца и дня.
• ECPG_INFORMIX_BAD_DAY — Во входной строке отсутствует корректное указание дня.
• ECPG_INFORMIX_BAD_MONTH — Во входной строке отсутствует корректное указание месяца.
• ECPG_INFORMIX_BAD_YEAR — Во входной строке отсутствует корректное указание года.
В реализации этой функции вызывается PGTYPESdate_defmt_asc. Примеры вводимых строк при-
ведены в таблице в её описании.
rfmtdate
Преобразует переменную типа date в текстовое представление по маске формата.
int rfmtdate(date d, char *fmt, char *str);
Эта функция принимает дату для преобразования (d), маску формата (fmt) и строку, в которую
будет помещено текстовое представление даты (str).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
Внутри эта функция вызывает PGTYPESdate_fmt_asc, примеры форматов можно найти в её опи-
сании.
rmdyjul
Образует значение даты из массива 3 коротких целых, задающих день, месяц и год даты.
int rmdyjul(short mdy[3], date *d);
Эта функция получает в первом аргументе массив из 3 коротких целых (mdy), а во втором ука-
затель на переменную типа date, в которую будет помещён результат операции.
В настоящее время эта функция всегда возвращает 0.
В реализации этой функции вызывается PGTYPESdate_mdyjul.
rdayofweek
Возвращает число, представляющее день недели для заданной даты.
int rdayofweek(date d);
Эта функция принимает в единственном аргументе переменную d типа date и возвращает целое
число, выражающее день недели для этой даты.
931ECPG — встраиваемый SQL в C
• 0 — Воскресенье
• 1 — Понедельник
• 2 — Вторник
• 3 — Среда
• 4 — Четверг
• 5 — Пятница
• 6 — Суббота
В реализации этой функции вызывается PGTYPESdate_dayofweek.
dtcurrent
Получает текущее время.
void dtcurrent(timestamp *ts);
Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую
указывает ts.
dtcvasc
Разбирает время из текстового представления в переменную типа timestamp.
int dtcvasc(char *str, timestamp *ts);
Эта функция получает строку (str), которую нужно разобрать, и указатель на переменную типа
timestamp, в которую будет помещён результат операции (ts).
Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.
Внутри эта функция вызывает PGTYPEStimestamp_from_asc. Примеры вводимых строк приведе-
ны в таблице в её описании.
dtcvfmtasc
Разбирает время из текстового представления в переменную типа timestamp по маске формата.
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
Эта функция получает строку (inbuf), которую нужно разобрать, маску формата (fmtstr) и ука-
затель на переменную timestamp, в которой будет содержаться результат операции (dtvalue).
В реализации этой функции используется PGTYPEStimestamp_defmt_asc. Список допустимых
кодов формата приведён в её описании.
Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.
dtsub
Вычитает одно значение времени из другого и возвращает переменную типа interval.
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
Эта функция вычитает значение timestamp, на которое указывает ts2, из значения timestamp,
на которое указывает ts1, и сохраняет результат в переменной типа interval, на которую ука-
зывает iv.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
dttoasc
Преобразует переменную типа timestamp в строку C char*.
int dttoasc(timestamp *ts, char *output);
932ECPG — встраиваемый SQL в C
Эта функция получает указатель (ts) на переменную типа timestamp, которую нужно преобра-
зовать, и строку (output) для сохранения результата операции. Она преобразует ts в текстовое
представление согласно стандарту SQL, то есть по маске YYYY-MM-DD HH:MM:SS.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
dttofmtasc
Преобразует переменную типа timestamp в строку C char* по маске формата.
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
Эта функция получает в первом аргументе (ts) указатель на переменную типа timestamp, а в
последующих указатель на буфер вывода (output), максимальную длину строки, которую мо-
жет принять буфер (str_len), и маску формата, с которой будет выполняться преобразование
(fmtstr).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
Внутри эта функция использует PGTYPEStimestamp_fmt_asc. Примеры допустимых масок фор-
мата можно найти в её описании.
intoasc
Преобразует переменную типа interval в строку C char*.
int intoasc(interval *i, char *str);
Эта функция получает указатель (i) на переменную типа interval, которую нужно преобразо-
вать, и строку (str) для сохранения результата операции. Она преобразует i в текстовое пред-
ставление согласно стандарту SQL, то есть по маске YYYY-MM-DD HH:MM:SS.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
rfmtlong
Преобразует длинное целое в текстовое представление по маске формата.
int rfmtlong(long lng_val, char *fmt, char *outbuf);
Эта функция принимает значение типа long (lng_val), маску формата (fmt) и указатель на вы-
ходной буфер (outbuf). Она преобразует длинное целое в его текстовое представление соглас-
но заданной маске формата.
Маску формата можно составить из следующих символов, определяющих формат:
• * (звёздочка) — если в данной позиции будет пусто, заполнить её звёздочкой.
• &amp; (амперсанд) — если в данной позиции будет пусто, заполнить её нулём.
• # — заменить ведущие нули пробелами.
• &lt; — выровнять число в строке по левой стороне.
• , (запятая) — сгруппировать числа, содержащие четыре и более цифр, в группы по три
цифры через запятую.
• . (точка) — этот символ отделяет целую часть числа от дробной.
• - (минус) — с отрицательным числом должен выводиться знак минус.
• + (плюс) — с положительным числом должен выводиться знак плюс.
• ( — это символ заменяет знак минус перед отрицательным числом. Сам знак минус выво-
диться не будет.
• ) — этот символ заменяет минус и выводится после отрицательного числа.
• $ — символ денежной суммы.
933ECPG — встраиваемый SQL в C
rupshift
Приводит строку к верхнему регистру.
void rupshift(char *str);
Эта функция получает указатель на строку и приводит в ней каждый символ в нижнем регистре
к верхнему регистру.
byleng
Возвращает число символов в строке, не считая завершающих пробелов.
int byleng(char *str, int len);
Эта функция принимает в первом аргументе (str) строку фиксированной длины, а во втором
(len) её длину. Она возвращает число значимых символов, то есть длину строки без заверша-
ющих пробелов.
ldchar
Копирует строку фиксированной длины в строку с завершающим нулём.
void ldchar(char *src, int len, char *dest);
Эта функция принимает строку фиксированной длины (src), которую нужно скопировать, её
длину (len) и указатель на целевой буфер в памяти (dest). Учтите, что для буфера, на который
указывает dest, необходимо выделить как минимум len+1 байт. Данная функция копирует в
новую область не больше len байт (меньше, если в исходной строке есть завершающие пробелы)
и добавляет завершающий 0.
rgetmsg
int rgetmsg(int msgnum, char *s, int maxsize);
Эта функция определена, но не реализована на данный момент!
rtypalign
int rtypalign(int offset, int type);
Эта функция определена, но не реализована на данный момент!
rtypmsize
int rtypmsize(int type, int len);
Эта функция определена, но не реализована на данный момент!
rtypwidth
int rtypwidth(int sqltype, int sqllen);
Эта функция определена, но не реализована на данный момент!
rsetnull
Присваивает переменной NULL.
int rsetnull(int t, char *ptr);
Эта функция получает целое, определяющее тип переменной, и указатель на саму переменную,
приведённый к указателю C char*.
Определены следующие типы:
• CCHARTYPE — для переменной типа char или char*
• CSHORTTYPE — для переменной типа short int
• CINTTYPE — для переменной типа int
934ECPG — встраиваемый SQL в C
• CBOOLTYPE — для переменной типа boolean
• CFLOATTYPE — для переменной типа float
• CLONGTYPE — для переменной типа long
• CDOUBLETYPE — для переменной типа double
• CDECIMALTYPE — для переменной типа decimal
• CDATETYPE — для переменной типа date
• CDTIMETYPE — для переменной типа timestamp
Примеры вызова этой функции:
$char c[] = "abc
$short s = 17;
$int i = -74874;
";
rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &amp;s);
rsetnull(CINTTYPE, (char *) &amp;i);
risnull
Проверяет содержимое переменной на NULL.
int risnull(int t, char *ptr);
Эта функция получает тип проверяемой переменной (t), а также указатель на неё (ptr). За-
метьте, что этот указатель нужно привести к char*. Список возможных типов переменных при-
ведён в описании функции rsetnull.
Примеры использования этой функции:
$char c[] = "abc
$short s = 17;
$int i = -74874;
";
risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &amp;s);
risnull(CINTTYPE, (char *) &amp;i);
36.15.5. Дополнительные константы
Заметьте, что все эти константы относятся к ошибкам и все они представлены отрицательными
значениями. Из описаний различных констант вы также можете узнать, какими именно числами
они представлены в текущей реализации. Однако полагаться на эти числа не следует. Тем не ме-
нее, вы можете рассчитывать на то, что все эти значения будут отрицательными.
ECPG_INFORMIX_NUM_OVERFLOW
Функции возвращают это значение, если при вычислении происходит переполнение. Внутри
оно представляется числом -1200 (определение Informix).
ECPG_INFORMIX_NUM_UNDERFLOW
Функции возвращают это значение, если при вычислении происходит антипереполнение. Внут-
ри оно представляется числом -1201 (определение Informix).
ECPG_INFORMIX_DIVIDE_ZERO
Функции возвращают это значение при попытке деления на ноль. Внутри оно представляется
числом -1202 (определение Informix).
935ECPG — встраиваемый SQL в C
ECPG_INFORMIX_BAD_YEAR
Функции возвращают это значение, если при разборе даты встретилось некорректное указание
года. Внутри оно представляется числом -1204 (определение Informix).
ECPG_INFORMIX_BAD_MONTH
Функции возвращают это значение, если при разборе даты встретилось некорректное указание
месяца. Внутри оно представляется числом -1205 (определение Informix).
ECPG_INFORMIX_BAD_DAY
Функции возвращают это значение, если при разборе даты встретилось некорректное указание
дня. Внутри оно представляется числом -1206 (определение Informix).
ECPG_INFORMIX_ENOSHORTDATE
Функции возвращают это значение, если процедуре разбора даты требуется короткая запись
даты, но строка даты имеет неподходящую длину. Внутри оно представляется числом -1209
(определение Informix).
ECPG_INFORMIX_DATE_CONVERT
Функции возвращают это значение, если при форматировании даты происходит ошибка. Внутри
оно представляется числом -1210 (определение Informix).
ECPG_INFORMIX_OUT_OF_MEMORY
Функции возвращают это значение, если им не хватает памяти для выполнения операций. Внут-
ри оно представляется числом -1211 (определение Informix).
ECPG_INFORMIX_ENOTDMY
Функции возвращают это значение, если процедура разбора должна была получить маску фор-
мата (например, mmddyy), но не все поля были записаны правильно. Внутри оно представляется
числом -1212 (определение Informix).
ECPG_INFORMIX_BAD_NUMERIC
Функции возвращают это значение, если процедура разбора не может получить числовое зна-
чение из текстового представления, потому что оно некорректно, либо если процедура вычис-
ления не может произвести операцию с числовыми переменными из-за недопустимого значе-
ния минимум одной из этих переменных. Внутри оно представляется числом -1213 (определе-
ние Informix).
ECPG_INFORMIX_BAD_EXPONENT
Функции возвращают это значение, если процедура разбора не может воспринять экспоненту
в числе. Внутри оно представляется числом -1216 (определение Informix).
ECPG_INFORMIX_BAD_DATE
Функции возвращают это значение, если процедура разбора не может разобрать дату. Внутри
оно представляется числом -1218 (определение Informix).
ECPG_INFORMIX_EXTRA_CHARS
Функции возвращают это значение, если процедуре разбора передаются посторонние симво-
лы, которая она не может разобрать. Внутри оно представляется числом -1264 (определение
Informix).
36.16. Внутреннее устройство
В этом разделе рассказывается, как препроцессор ECPG устроен внутри. Эта информация может
оказаться полезной для пользователей, желающих понять, как использовать ECPG.
936ECPG — встраиваемый SQL в C
Первые четыре строки, которые ecpg записывает в вывод, фиксированы. Первые две строки содер-
жат комментарии, а следующие две директивы включения, подключающие интерфейс к библио-
теке. Затем препроцессор прочитывает файл и продолжает запись в вывод. Обычно он просто пе-
чатает всё в устройство вывода.
Встречая команду EXEC SQL, он вмешивается и изменяет её. Данная команда начинается со слов
EXEC SQL и заканчивается знаком ;. Всё между ними воспринимается как оператор SQL и разби-
рается для подстановки переменных.
Подстановка переменных имеет место, когда символ начинается с двоеточия (:). ECPG будет
искать переменную с таким именем среди переменных, ранее объявленных в секции EXEC SQL
DECLARE.
Самая важная функция в библиотеке — ECPGdo, которая осуществляет выполнение большинства
команд. Она принимает переменное число аргументов (это число легко может достигать 50, и мы
надеемся, что это не приведёт к проблемам ни на какой платформе).
Ей передаются следующие аргументы:
Номер строки
Номер исходной строки; используется только в сообщениях об ошибках.
Строка
Команда SQL, которая должна быть выполнена. На её содержимое влияют входные перемен-
ные, то есть переменные, добавленные в команду, но неизвестные во время компиляции. Ме-
ста, в которые должны вставляться переменные, обозначаются знаками ?.
Входные переменные
Для каждой входной переменной формируются десять аргументов. (См. ниже.)
ECPGt_EOIT
Перечисление (enum), показывающее, что больше входных переменных нет.
Выходные переменные
Для каждой входной переменной формируются десять аргументов. (См. ниже.) Эти переменные
заполняются данной функцией.
ECPGt_EORT
Перечисление (enum), показывающее, что больше выходных переменных нет.
Для каждой переменной, включённой в команду SQL, эта функция принимает десять аргументов:
1. Тип в виде специального символа.
2. Указатель на значение или указатель на указатель.
3. Размер переменной, если она имеет тип char или varchar.
4. Число элементов в массиве (при выборке данных в массив).
5. Смещение следующего элемента в массиве (при выборке данных в массив).
6. Тип переменной-индикатора в виде специального символа.
7. Указатель на переменную-индикатор.
8. 0
9. Число элементов в массиве индикаторов (при выборке данных в массив).
10.Смещение следующего элемента в массиве индикаторов (при выборке данных в массив).
937ECPG — встраиваемый SQL в C
Заметьте, что не все команды SQL обрабатываются таким образом. Например, команда открытия
курсора вида:
EXEC SQL OPEN курсор;
не копируется в вывод. Вместо этого в позиции команды OPEN применяется команда DECLARE этого
курсора, так как на самом деле курсор открывает она.
Ниже показан полный пример, демонстрирующий результат обработки препроцессором файла
foo.pgc (детали могут меняться от версии к версии препроцессора):
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
преобразуется в:
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;
/* exec sql begin declare section */
#line 1 "foo.pgc"
int index;
int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?
ECPGt_int,&amp;(index),1L,1L,sizeof(int),
ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
ECPGt_int,&amp;(result),1L,1L,sizeof(int),
ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
(Отступы здесь добавлены для читаемости, препроцессор их не вставляет.)
938
</ecpglib.h></ecpgtype.h></stdio.h></libpq-fe.h></stdlib.h></stdio.h></имя_файла.h></имя_файла></cur_sqlda-></unistd.h></stdio.h></stdlib.h></string.h></stdlib.h>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page14/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page13/">13</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page14/">14</a></li>
      
    
      
        <li><strong class="current-page">15</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page16/">16</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page17/">17</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page16/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>