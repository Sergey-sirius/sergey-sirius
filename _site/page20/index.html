<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page20/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page20/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-022/" title="Глава 22. Управление базами данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 22. Управление базами данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-022/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~11 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-022/" rel="bookmark" title="Глава 22. Управление базами данных" itemprop="url">Глава 22. Управление базами данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 22. Управление базами данных</p>

<p>Каждый работающий экземпляр сервера PostgreSQL обслуживает одну или несколько баз данных.
Поэтому базы данных представляют собой вершину иерархии SQL-объектов («объектов базы дан-
ных»). Данная глава описывает свойства баз данных, процессы создания, управления и удаления.
22.1. Обзор
База данных — именованная коллекция объектов SQL («объектов базы данных»). В целом, каждый
объект базы данных (таблицы, функции и т. д.) принадлежит одной и только одной базе данных.
(Правда есть несколько системных каталогов, например, pg_database, которые принадлежат всему
кластеру и доступны для каждой базы данных этого кластера.) Если точнее, база данных это набор
схем, которые включают в себя таблицы, функции и т. д. Таким образом, полная иерархия включает
в себя: сервер, базу данных, схему, таблицу (или иные типы объектов, к примеру, функции).
При подключении к серверу базы данных, клиент должен указать в параметрах подключения имя
базы данных, с которой нужно соединиться. Одно соединение не может иметь доступ более чем
к одной базе данных. Однако приложение не ограничено в количестве соединений к одной и той
же или разным базам данных. Базы данных разделены физически и контроль доступа осуществ-
ляется на уровне соединения. В случае, когда один экземпляр сервера PostgreSQL обслуживает
проекты или пользователей, которых необходимо изолировать друг от друга, рекомендуется раз-
мещать их в раздельных базах данных. В случае, когда проекты или пользователи взаимосвязаны
и должны иметь возможность использовать общие ресурсы, они должны размещаться в одной базе
данных, но, возможно, в раздельных схемах. Схемы — в чистом виде логическая структура, и кто
к чему может получить доступ управляется системой привилегий. Более подробная информация
по управлению схемами приведена в Разделе 5.8.
Базы данных создаются командой CREATE DATABASE (см. Раздел 22.2), а удаляются командой DROP
DATABASE (см. Раздел 22.5). Список существующих баз данных можно посмотреть в системном ка-
талоге pg_database, например,
SELECT datname FROM pg_database;
Метакоманда \l или ключ -l командной строки приложения psql также позволяют вывести список
существующих баз данных.
Примечание
Стандарт SQL называет базы данных «каталогами», но на практике у них нет отличий.
22.2. Создание базы данных
Для создания базы данных сервер PostgreSQL должен быть развёрнут и запущен (см. Раздел 18.3).
База данных создаётся SQL-командой CREATE DATABASE:
CREATE DATABASE имя;
где имя подчиняется правилам именования идентификаторов SQL. Текущий пользователь автома-
тически назначается владельцем. Владелец может удалить свою базу, что также приведёт к уда-
лению всех её объектов, в том числе, имеющих других владельцев.
Создание баз данных это привилегированная операция. Как предоставить права доступа, описано
в Разделе 21.2.
Поскольку для выполнения команды CREATE DATABASE необходимо подключение к серверу базы
данных, возникает вопрос как создать самую первую базу данных. Первая база данных всегда со-
здаётся командой initdb при инициализации пространства хранения данных (см. Раздел  18.2.)
598Управление базами данных
Эта база данных называется postgres.Далее для создания первой «обычной» базы данных можно
подключиться к postgres.
Вторая база данных template1,также создаётся во время инициализации кластера. При каждом
создании новой базы данных в рамках кластера по факту производится клонирование шаблона
template1. При этом любые изменения сделанные в template1 распространяются на все создан-
ные впоследствии базы данных. Следует избегать создания объектов в template1, за исключением
ситуации, когда их необходимо автоматически добавлять в новые базы. Более подробно в Разде-
ле 22.3.
Для удобства, есть утилита командной строки для создания баз данных, createdb.
createdb dbname
Утилита createdb не делает ничего волшебного, она просто подключается к базе данных postgres
и выполняет ранее описанную SQL-команду CREATE DATABASE. Подробнее о её вызове можно узнать
в createdb. Обратите внимание, что команда createdb без параметров создаст базу данных с име-
нем текущего пользователя.
Примечание
Глава 20 содержит информацию о том, как ограничить права на подключение к задан-
ной базе данных.
Иногда необходимо создать базу данных для другого пользователя и назначить его владельцем,
чтобы он мог конфигурировать и управлять ею. Для этого используйте одну из следующих команд:
CREATE DATABASE имя_базы OWNER имя_роли;
из среды SQL, или:
createdb -O имя_роли имя_базы
из командной строки ОС. Лишь суперпользователь может создавать базы данных для других (для
ролей, членом которых он не является).
22.3. Шаблоны баз данных
По факту команда CREATE DATABASE выполняет копирование существующей базы данных. По умол-
чанию копируется стандартная системная база template1. Таким образом, template1 это шаблон,
на основе которого создаются новые базы. Если добавить объекты в template1, то впоследствии
они будут копироваться в новые базы данных. Это позволяет внести изменения в стандартный на-
бор объектов. Например, если в template1 установить процедурный язык PL/Perl, то он будет до-
ступен в новых базах без дополнительных действий.
Также существует вторая системная база template0.При инициализации она содержит те же са-
мые объекты, что и template1, предопределённые в рамках устанавливаемой версии PostgreSQL.
Не нужно вносить никаких изменений в template0 после инициализации кластера. Если в команде
CREATE DATABASE указать на необходимость копирования template0 вместо template1, то на выходе
можно получить «чистую» пользовательскую базу данных без изменений, внесённых в template1.
Это удобно, когда производится восстановление из дампа данных с помощью утилиты pg_dump:
скрипт дампа лучше выполнять в чистую базу, во избежание каких-либо конфликтов с объектами,
которые могли быть добавлены в template1.
Другая причина, для копирования template0 вместо template1 заключается в том, что можно ука-
зать новые параметры локали и кодировку при копировании template0, в то время как для копий
template1 они не должны меняться. Это связано с тем, что template1 может содержать данные в
специфических кодировках и локалях, в отличие от template0.
Для создания базы данных на основе template0, используйте:
599Управление базами данных
CREATE DATABASE dbname TEMPLATE template0;
из среды SQL, или:
createdb -T template0 dbname
из командной строки ОС.
Можно создавать дополнительные шаблоны баз данных, и, более того, можно копировать любую
базу данных кластера, если указать её имя в качестве шаблона в команде CREATE DATABASE. Важно
понимать, что это (пока) не рассматривается в качестве основного инструмента для реализации
возможности «COPY DATABASE». Важным является то, что при копировании все сессии к копиру-
емой базе данных должны быть закрыты. CREATE DATABASE выдаст ошибку, если есть другие под-
ключения; во время операции копирования новые подключения к этой базе данных не разрешены.
В таблице pg_databaseесть два полезных флага для каждой базы данных: столбцы datistemplate
и datallowconn. datistemplate указывает на факт того, что база данных может выступать в каче-
стве шаблона в команде CREATE DATABASE. Если флаг установлен, то для пользователей с правом
CREATEDB клонирование доступно; если флаг не установлен, то лишь суперпользователь и владелец
базы данных могут её клонировать. Если datallowconn не установлен, то новые подключения к
этой базе не допустимы (однако текущие сессии не закрываются при сбросе этого флага). База
template0 обычно помечена как datallowconn = false для избежания любых её модификаций. И
template0, и template1 всегда должны быть помечены флагом datistemplate = true.
Примечание
template1 и template0 не выделены как-то особенно, кроме того факта, что template1
используется по умолчанию в команде CREATE DATABASE. Например, можно удалить
template1 и безболезненно создать заново из template0. Это можно посоветовать в слу-
чае, если template1 был замусорен. (Чтобы удалить template1, необходимо сбросить
флаг pg_database.datistemplate = false.)
База данных postgres также создаётся при инициализации кластера. Она использу-
ется пользователями и приложениями для подключения по умолчанию. Представля-
ет собой всего лишь копию template1, и может быть удалена и повторно создана при
необходимости.
22.4. Конфигурирование баз данных
Обратившись к Главе  19 можно выяснить, что сервер PostgreSQL имеет множество параметров
конфигурации времени исполнения. Можно выставить специфичные для базы данных значения
по умолчанию.
Например, если по какой-то причине необходимо выключить GEQO оптимизатор в какой-то из
баз, то можно, либо выключить его для всех баз данных одновременно, либо убедиться, что все
клиенты заботятся об этом, выполняя команду SET geqo TO off. Для того чтобы это действовало
по умолчанию в конкретной базе данных, необходимо выполнить команду:
ALTER DATABASE mydb SET geqo TO off;
Установка сохраняется, но не применяется тотчас. В последующих подключениях к этой базе дан-
ных, эффект будет таким, будто перед началом сессии была выполнена команда SET geqo TO off;.
Стоит обратить внимание, что пользователь по-прежнему может изменять этот параметр во время
сессии; ведь это просто значение по умолчанию. Чтобы сбросить такое установленное значение,
используйте ALTER DATABASE dbname RESET varname.
22.5. Удаление базы данных
Базы данных удаляются командой DROP DATABASE:
600Управление базами данных
DROP DATABASE имя;
Лишь владелец базы данных или суперпользователь могут удалить базу. При удалении также уда-
ляются все её объекты. Удаление базы данных это необратимая операция.
Невозможно выполнить команду DROP DATABASE пока существует хоть одно подключение к задан-
ной базе. Однако можно подключиться к любой другой, в том числе и template1. template1 мо-
жет быть единственной возможностью при удалении последней пользовательской базы данных
кластера.
Также существует утилита командной строки для удаления баз данных dropdb:
dropdb dbname
(В отличие от команды createdb утилита не использует имя текущего пользователя по умолча-
нию).
22.6. Табличные пространства
Табличные пространства в PostgreSQL позволяют администраторам организовать логику разме-
щения файлов объектов базы данных в файловой системе. К однажды созданному табличному про-
странству можно обращаться по имени на этапе создания объектов.
Табличные пространства позволяют администратору управлять дисковым пространством для ин-
сталляции PostgreSQL. Это полезно минимум по двум причинам. Во-первых, это нехватка места в
разделе, на котором был инициализирован кластер и невозможность его расширения. Табличное
пространство можно создать в другом разделе и использовать его до тех пор, пока не появится
возможность переконфигурирования системы.
Во-вторых, табличные пространства позволяют администраторам оптимизировать производитель-
ность согласно бизнес-процессам, связанным с объектами базы данных. Например, часто исполь-
зуемый индекс можно разместить на очень быстром и надёжном, но дорогом SSD-диске. В то же
время таблица с архивными данными, которые редко используются и скорость к доступа к ним не
важна, может быть размещена в более дешёвом и медленном хранилище.
Предупреждение
Несмотря на внешнее размещение относительно основного каталога хранения данных
PostgreSQL, табличные пространства являются неотъемлемой частью кластера и не
могут трактоваться, как самостоятельная коллекция файлов данных. Они зависят от
метаданных, расположенных в главном каталоге, и потому не могут быть подключены
к другому кластеру, или копироваться по отдельности. Также, в случае потери таблич-
ного пространства (при удалении файлов, сбое диска и т. п.), кластер может оказаться
недоступным или не сможет запуститься. Таким образом, при размещении таблично-
го пространства во временной файловой системе, например, в RAM-диске, возникает
угроза надёжности всего кластера.
Для создания табличного пространства используется команда CREATE TABLESPACE, например::
CREATE TABLESPACE fastspace LOCATION ‘/ssd1/postgresql/data’;
Каталог должен существовать, быть пустым и принадлежать пользователю ОС, под которым за-
пущен PostgreSQL. Все созданные впоследствии объекты, принадлежащие целевому табличному
пространству, будут храниться в файлах расположенных в этом каталоге. Каталог не должен раз-
мещаться на съёмных или устройствах временного хранения, так как кластер может перестать
функционировать из-за потери этого пространства.
Примечание
Обычно нет смысла создавать более одного пространства на одну логическую файло-
вую систему, так как нет возможности контролировать расположение отдельных фай-
601Управление базами данных
лов в файловой системе. Однако PostgreSQL не накладывает никаких ограничений в
этом отношении, и более того, напрямую не заботится о точках монтирования файло-
вой системы. Просто осуществляется хранение файлов в указанных каталогах.
Создавать табличное пространство должен суперпользователь базы данных, но после этого можно
разрешить обычным пользователям его использовать. Для этого необходимо предоставить приви-
легию CREATE на табличное пространство.
Таблицы, индексы и целые базы данных могут храниться в отдельных табличных пространствах.
Для этого пользователь с правом CREATE на табличное пространство должен указать его имя в
качестве параметра соответствующей команды. Например, далее создаётся таблица в табличном
пространстве space1:
CREATE TABLE foo(i int) TABLESPACE space1;
Как вариант, используйте параметр default_tablespace:
SET default_tablespace = space1;
CREATE TABLE foo(i int);
Когда default_tablespace имеет значение отличное от пустой строки, он будет использоваться
неявно в качестве значения параметра TABLESPACE в командах CREATE TABLE и CREATE INDEX, если
в самой команде не задано иное.
Существует параметр temp_tablespaces, который указывает на размещение временных таблиц и
индексов, а также файлов, создаваемых, например, при операциях сортировки больших наборов
данных. Предпочтительнее, в качестве значения этого параметра, указывать не одно имя, а спи-
сок из нескольких табличных пространств. Это поможет распределить нагрузку, связанную с вре-
менными объектами, по различным табличным пространствам. При каждом создании временного
объекта будет случайным образом выбираться имя из указанного списка табличных пространств.
Табличное пространство, связанное с базой данных, также используется для хранения её систем-
ных каталогов. Более того, это табличное пространство используется по умолчанию для таблиц,
индексов и временных файлов, создаваемых в базе данных, если не указано иное в выражении
TABLESPACE, или переменной default_tablespace, или temp_tablespaces (соответственно). Если
база данных создана без указания конкретного табличного пространства, то используется про-
странство, к которому принадлежит копируемый шаблон.
При инициализации кластера автоматически создаются два табличных пространства. Табличное
пространство pg_global используется для общих системных каталогов. Табличное пространство
pg_default используется по умолчанию для баз данных template1 и template0 (в свою очередь,
также является пространством по умолчанию для других баз данных, пока не будет явно указано
иное в выражении TABLESPACE команды CREATE DATABASE).
После создания, табличное пространство можно использовать в рамках любой базы данных, при
условии, что у пользователя имеются необходимые права. Это означает, что табличное простран-
ство невозможно удалить до тех пор, пока не будут удалены все объекты баз данных, использую-
щих это пространство.
Для удаления пустого табличного пространства используйте команду DROP TABLESPACE.
Чтобы получить список табличных пространств можно сделать запрос к системному каталогу
pg_tablespace, например,
SELECT spcname FROM pg_tablespace;
Метакоманда \db утилиты psql также позволяет отобразить список существующих табличных про-
странств.
PostgreSQL использует символические ссылки для упрощения реализации табличных про-
странств. Это означает, что табличные пространства могут использоваться только в системах,
поддерживающих символические ссылки.
602Управление базами данных
Каталог $PGDATA/pg_tblspc содержит символические ссылки, которые указывают на внешние таб-
личные пространства кластера. Хоть и не рекомендуется, но возможно регулировать табличные
пространства вручную, переопределяя эти ссылки. Ни при каких обстоятельствах эти операции
нельзя проводить, пока запущен сервер баз данных. Обратите внимание, что в версии PostgreSQL
9.1 и более ранних также необходимо обновить информацию в pg_tablespace о новых расположе-
ниях. (Если это не сделать, то pg_dump будет продолжать выводить старые расположения таблич-
ных пространств.)</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-021/" title="Глава 21. Роли базы данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 21. Роли базы данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-021/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~12 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-021/" rel="bookmark" title="Глава 21. Роли базы данных" itemprop="url">Глава 21. Роли базы данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 21. Роли базы данных</p>

<p>PostgreSQL использует концепцию ролей (roles) для управления разрешениями на доступ к базе
данных. Роль можно рассматривать как пользователя базы данных или как группу пользователей,
в зависимости от того, как роль настроена. Роли могут владеть объектами базы данных (например,
таблицами и функциями) и выдавать другим ролям разрешения на доступ к этим объектам, управ-
ляя тем, кто имеет доступ и к каким объектам. Кроме того, можно предоставить одной роли член-
ство в другой роли, таким образом одна роль может использовать привилегии других ролей.
Концепция ролей включает в себя концепцию пользователей («users») и групп («groups»). До вер-
сии 8.1 в PostgreSQL пользователи и группы были отдельными сущностями, но теперь есть только
роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.
В этой главе описывается как создавать и управлять ролями. Дополнительную информацию о при-
вилегиях для ролей на различные объекты базы данных можно найти в Разделе 5.6.
21.1. Роли базы данных
Роли базы данных концептуально полностью отличаются от пользователей операционной системы.
На практике поддержание соответствия между ними может быть удобным, но не является обяза-
тельным. Роли базы данных являются глобальными для всей установки кластера базы данных (не
для отдельной базы данных). Для создания роли используется команда SQL CREATE ROLE:
CREATE ROLE имя;
Здесь имя соответствует правилам именования идентификаторов SQL: либо обычное, без специ-
альных символов, либо в двойных кавычках. (На практике, к команде обычно добавляются другие
указания, такие как LOGIN. Подробнее об этом ниже.) Для удаления роли используется команда
DROP ROLE:
DROP ROLE имя;
Для удобства поставляются программы createuser и dropuser, которые являются обёртками для
этих команд SQL и вызываются из командной строки оболочки ОС:
createuser имя
dropuser имя
Для получения списка существующих ролей, рассмотрите pg_roles системного каталога, напри-
мер:
SELECT rolname FROM pg_roles;
Метакоманда \du программы psql также полезна для получения списка существующих ролей.
Для начальной настройки кластера базы данных, система сразу после инициализации всегда со-
держит одну предопределённую роль. Эта роль является суперпользователем («superuser») и по
умолчанию (если не изменено при запуске initdb) имеет такое же имя, как и пользователь опера-
ционной системы, инициализирующий кластер баз данных. Обычно эта роль называется postgres.
Для создания других ролей, вначале нужно подключиться с этой ролью.
Каждое подключение к серверу базы данных выполняется под именем конкретной роли и эта роль
определяет начальные привилегии доступа для команд выполняемых в этом соединении. Имя ро-
ли для конкретного подключения к базе данных указывается клиентской программой характер-
ным для неё способом, таким образом инициируя запрос на подключение. Например, программа
psql для указания роли использует аргумент командной строки -U. Многие приложения предпо-
лагают, что по умолчанию нужно использовать имя пользователя операционной системы (включая
createuser и psql). Поэтому часто бывает удобным поддерживать соответствие между именами
ролей и именами пользователей операционной системы.
591Роли базы данных
Список доступных для подключения ролей, который могут использовать клиенты, определяется
конфигурацией аутентификации, как описывалось в Главе 20. (Поэтому, клиент не ограничен толь-
ко ролью, соответствующей имени пользователя операционной системы, также как и имя для вхо-
да может не соответствовать реальному имени.) Так как роль определяет набор доступных приви-
легий, очень важно тщательно настраивать привилегии в многопользовательской среде.
21.2. Атрибуты ролей
Роль базы данных может иметь атрибуты, определяющие её полномочия и взаимодействие с си-
стемой аутентификации клиентов.
Право подключения
Только роли с атрибутом LOGIN могут использоваться для начального подключения к базе дан-
ных. Роль с атрибутом LOGIN можно рассматривать как пользователя базы данных. Для созда-
ния роли такой роли можно использовать любой из вариантов:
CREATE ROLE имя LOGIN;
CREATE USER имя;
(Команда CREATE USER эквивалентна CREATE ROLE за исключением того, что CREATE USER по
умолчанию включает атрибут LOGIN, в то время как CREATE ROLE — нет.)
Статус суперпользователя
Суперпользователь базы данных обходит все проверки прав доступа, за исключением права на
вход в систему. Это опасная привилегия и она не должна использоваться небрежно. Лучше
всего выполнять большую часть работы не как суперпользователь. Для создания нового супер-
пользователя используется CREATE ROLE имя SUPERUSER. Это нужно выполнить из под роли,
которая также является суперпользователем.
Создание базы данных
Роль должна явно иметь разрешение на создание базы данных (за исключением суперпользо-
вателей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEDB.
Создание роли
Роль должна явно иметь разрешение на создание других ролей (за исключением суперполь-
зователей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEROLE. Роль с привилегией CREATEROLE может также изменять и удалять другие
роли, а также выдавать и отзывать членство в ролях. Однако, для создания, изменения, удале-
ния суперпользовательских ролей, а также изменения в них членства, требуется иметь статус
суперпользователя; привилегии CREATEROLE в таких случаях недостаточно.
Запуск репликации
Роль должна иметь явное разрешение на запуск потоковой репликации (за исключением су-
перпользователей, которые пропускают все проверки). Роль, используемая для потоковой ре-
пликации, также должна иметь атрибут LOGIN. Для создания такой роли используется CREATE
ROLE имя REPLICATION LOGIN.
Пароль
Пароль имеет значение, если метод аутентификации клиентов требует, чтобы пользователи
предоставляли пароль при подключении к базе данных. Методы аутентификации password и
md5 используют пароли. База данных и операционная система используют раздельные пароли.
Пароль указывается при создании роли: CREATE ROLE имя PASSWORD ‘строка’.
Атрибуты ролей могут быть изменены после создания командой ALTER ROLE.Более детальная ин-
формация в справке по командам CREATE ROLE и ALTER ROLE.
592Роли базы данных
Подсказка
Рекомендуется создать роль с привилегиями CREATEDB и CREATEROLE, но не суперполь-
зователя и в последующем использовать её для управления базами данных и ролями.
Такой подход позволит избежать опасностей, связанных с использованием полномочий
суперпользователя для задач, которые их не требуют.
На уровне ролей можно устанавливать многие конфигурационные параметры времени выполне-
ния, описанные в Главе 19. Например, если по некоторым причинам всякий раз при подключении
к базе данных требуется отключить использование индексов (подсказка: плохая идея) можно вы-
полнить:
ALTER ROLE myname SET enable_indexscan TO off;
Установленное значение параметра будет сохранено (но не будет применено сразу). Для по-
следующих подключений с этой ролью это будет выглядеть как выполнение команды SET
enable_indexscan TO off перед началом сессии. Но это только значение по умолчанию, в течение
сессии эту установку можно изменить. Для удаления установок на уровне ролей для параметров
конфигурации используется ALTER ROLE rolename RESET varname. Обратите внимание, что уста-
новка параметров конфигурации на уровне роли без привилегии LOGIN лишено смысла, т. к. они
никогда не будут применены,
21.3. Членство в роли
Часто бывает удобным сгруппировать пользователей для упрощения администрирования приви-
легий: привилегии выдаются или отзываются на всю группу. В PostgreSQL для этого создаётся
роль, которая представляет группу, а затем членство (membership) в этой группе выдаётся ролям
индивидуальных пользователей.
Для настройки групповой роли, сначала нужно создать саму роль:
CREATE ROLE имя;
Обычно групповая роль не имеет атрибута LOGIN, хотя при желании его можно установить.
После того как групповая роль создана, в неё можно добавлять или удалять членов, используя
команды GRANT и REVOKE:
GRANT group_role TO role1, … ;
REVOKE group_role FROM role1, … ;
Можно выдавать членство в групповой роли другим групповым ролям (потому что в действитель-
ности нет никаких различий между групповыми и не групповыми ролями). База данных не позво-
лит замкнуть предоставление членства по кругу. Также, не допускается выдача членства в роли
для PUBLIC.
Члены групповой роли могут использовать её привилегии двумя способами. Во-первых, каждый
член группы может явно выполнить SET ROLE, чтобы временно «стать» групповой ролью. В этом
состоянии, сессия базы данных использует полномочия групповой роли, вместо оригинальной ро-
ли, под которой был выполнен вход в систему. При этом для всех создаваемых объектов базы дан-
ных владельцем считается групповая, а не оригинальная роль. Во-вторых, роли, имеющие атрибут
INHERIT, автоматически используют привилегии всех ролей, членами которых они являются, в том
числе и унаследованными этими ролями привилегиями. Например:
CREATE ROLE
CREATE ROLE
CREATE ROLE
GRANT admin
GRANT wheel
joe LOGIN INHERIT;
admin NOINHERIT;
wheel NOINHERIT;
TO joe;
TO admin;
После подключения с ролью joe, сессия базы данных будет использовать полномочия выданные
напрямую joe и привилегии выданные admin, так как joe “наследует” привилегии admin. Однако
593Роли базы данных
привилегии выданные wheel не будут доступны, потому что, хотя joe неявно и является членом
wheel, это членство получено через роль admin, которая имеет атрибут NOINHERIT. После выпол-
нения команды:
SET ROLE admin;
сессия будет использовать только привилегии выданные admin, привилегии выданные joe не будут
доступны. После выполнения команды:
SET ROLE wheel;
сессия будет использовать только привилегии выданные wheel, привилегии joe и admin не будут
доступны. Начальный набор привилегий можно вернуть любой из команд:
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
Примечание
Команда SET ROLE в любой момент разрешает выбрать любую роль, прямым или кос-
венным членом которой является оригинальная роль, под которой был выполнен вход
в систему. Поэтому, в примере выше, не обязательно сначала становиться admin, перед
тем как стать wheel.
Примечание
В стандарте SQL есть чёткое различие между пользователями и ролями. При этом поль-
зователи не наследуют автоматически привилегии, а роли наследуют автоматически.
Такое поведение может быть получено в PostgreSQL, если для ролей, используемых как
роли в стандарте SQL, устанавливать атрибут INHERIT, а для ролей, используемых как
пользователи в стандарте SQL, устанавливать атрибут NOINHERIT. Однако, в PostgreSQL
все роли по умолчанию имеют атрибут INHERIT. Это сделано для обратной совместимо-
сти с версиями предшествующими 8.1, в которых пользователи всегда могли исполь-
зовать привилегии групп, членами которых они являются.
Атрибуты роли LOGIN, SUPERUSER, CREATEDB и CREATEROLE можно рассматривать как особые приви-
легии, но они никогда не наследуются, как обычные привилегии на объекты базы данных. Необхо-
димо через SET ROLE установить роль, имеющую один из этих атрибутов, чтобы им воспользовать-
ся. Продолжая предыдущий пример, можно установить атрибуты CREATEDB и CREATEROLE для роли
admin. Затем при входе с ролью joe, получить доступ к этим привилегиям будет возможно только
после выполнения SET ROLE admin.
Для удаления групповой роли используется DROP ROLE:
DROP ROLE имя;
Любое членство в групповой роли будет автоматически отозвано (в остальном на членов этой роли
это никак не повлияет).
21.4. Удаление ролей
Так как роли могут владеть объектами баз данных и иметь права доступа к объектам других, уда-
ление роли не сводится к немедленному действию DROP ROLE. Сначала должны быть удалены и
переданы другим владельцами все объекты, принадлежащие роли; также должны быть отозваны
все права, данные роли.
594Роли базы данных
Владение объектами можно передавать в индивидуальном порядке, применяя команду ALTER, на-
пример:
ALTER TABLE bobs_table OWNER TO alice;
Кроме того, для переназначения какой-либо другой роли владения сразу всеми объектами, при-
надлежащих удаляемой роли, можно применить команду REASSIGN OWNED. Так как REASSIGN
OWNED не может обращаться к объектам в других базах данных, её необходимо выполнить в каждой
базе, которая содержит объекты, принадлежащие этой роли. (Заметьте, что первая такая команда
REASSIGN OWNED изменит владельца для всех разделяемых между базами объектов, то есть для баз
данных или табличных пространств, принадлежащих удаляемой роли.)
После того как все ценные объекты будут переданы новым владельцам, все оставшиеся объекты,
принадлежащие удаляемой роли, могут быть удалены с помощью команды DROP OWNED. И эта
команда не может обращаться к объектам в других базах данных, так что её нужно запускать в
каждой базе, которая содержит объекты, принадлежащие роли. Также заметьте, что DROP OWNED не
удаляет табличные пространства или базы данных целиком, так что это необходимо сделать вруч-
ную, если роли принадлежат базы или табличные пространства, не переданные новым владельцам.
DROP OWNED также удаляет все права, которые даны целевой роли для объектов, не принадлежа-
щих ей. Так как REASSIGN OWNED такие объекты не затрагивает, обычно необходимо запустить и
REASSIGN OWNED, и DROP OWNED (в этом порядке!), чтобы полностью ликвидировать зависимости
удаляемой роли.
С учётом этого, общий рецепт удаления роли, которая владела объектами, вкратце таков:
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
– повторить предыдущие команды для каждой базы в кластере
DROP ROLE doomed_role;
Когда не все объекты нужно передать одному новому владельцу, лучше сначала вручную отрабо-
тать исключения, а в завершение выполнить показанные выше действия.
При попытке выполнить DROP ROLE для роли, у которой сохраняются зависимые объекты, будут
выданы сообщения, говорящие, какие объекты нужно передать другому владельцу или удалить.
21.5. Предопределённые роли
В PostgreSQL имеется набор предопределённых ролей, которые дают доступ к некоторым часто
востребованным, но не общедоступным функциям и данным. Администраторы могут назначать
(GRANT) эти роли пользователям и/или ролям в своей среде, таким образом открывая этим поль-
зователям доступ к указанной функциональности и информации.
Имеющиеся предопределённые роли описаны в Таблице 21.1. Заметьте, что конкретные разреше-
ния для каждой из предопределённых ролей в будущем могут изменяться по мере добавления до-
полнительной функциональности. Администраторы должны следить за этими изменениями, про-
сматривая замечания к выпускам.
Таблица 21.1. Предопределённые роли
Роль Разрешаемый доступ
pg_read_all_settings Читать все конфигурационные переменные, да-
же те, что обычно видны только суперпользова-
телям.
pg_read_all_stats Читать все представления pg_stat_* и использо-
вать различные расширения, связанные со ста-
тистикой, даже те, что обычно видны только су-
перпользователям.
595Роли базы данных
Роль Разрешаемый доступ
pg_stat_scan_tables Выполнять функции мониторинга, которые мо-
гут устанавливать блокировки ACCESS SHARE в
таблицах, возможно, на длительное время.
pg_signal_backend Передавать сигналы другим обслуживающим
процессам (например, отменять запрос, завер-
шать процесс).
pg_read_server_files Читать файлы в любом месте файловой системы,
куда имеет доступ СУБД на сервере, выполняя
COPY и другие функции работы с файлами.
pg_write_server_files Записывать файлы в любом месте файловой си-
стемы, куда имеет доступ СУБД на сервере, вы-
полняя COPY и другие функции работы с файла-
ми.
pg_execute_server_program Выполнять программы на сервере (от имени
пользователя, запускающего СУБД), так же, как
это делает команда COPY и другие функции, вы-
полняющие программы на стороне сервера.
pg_monitor Читать/выполнять различные представления и
функции для мониторинга. Эта роль включена в
роли pg_read_all_settings
, pg_read_all_
stats и pg_stat_scan_tables
.
Роли pg_read_server_files, pg_write_server_files и pg_execute_server_program предназначе-
ны для того, чтобы администраторы могли выделить доверенные, но не имеющие права суперполь-
зователей роли для доступа к файлам и запуска программ на сервере БД от имени пользователя,
запускающего СУБД. Так как эти роли могут напрямую обращаться к любым файлам в файловой
системе сервера, они обходят все проверки разрешений на уровне базы данных, а значит, восполь-
зовавшись ими, можно получить права суперпользователя. Поэтому назначать их пользователям
следует со всей осторожностью.
Роли pg_monitor, pg_read_all_settings, pg_read_all_stats и pg_stat_scan_tables созданы для
того, чтобы администраторы могли легко настроить роль для мониторинга сервера БД. Эти роли
наделяют своих членов набором общих прав, позволяющих читать различные полезные парамет-
ры конфигурации, статистику и другую системную информацию, что обычно доступно только су-
перпользователям.
Управлять членством в этих ролях следует осмотрительно, чтобы они использовались только по
необходимости и только с пониманием, что они открывают доступ к закрытой информации.
Администраторы могут давать пользователям доступ к этим ролям, используя команду GRANT:
GRANT pg_signal_backend TO admin_user;
21.6. Безопасность функций
Функции, триггеры и политики защиты на уровне строк позволяют пользователям внедрять код
в обслуживающие процессы, который может быть непреднамеренно выполнен другими пользова-
телями. Таким образом эти механизмы позволяют пользователям запускать «троянский код» от-
носительно просто. Лучшая защита от этого — строгое ограничение круга лиц, которые могут со-
здавать объекты. Там где это невозможно, пишите запросы так, чтобы они ссылались только на
объекты с доверенными владельцами. Удалите из search_path схему public и любые другие схемы,
в которых могут создавать объекты недоверенные пользователи.
Функции выполняются внутри серверного процесса с полномочиями пользователя операционной
системы, запускающего сервер базы данных. Если используемый для функций язык программи-
рования разрешает неконтролируемый доступ к памяти, то это даёт возможность изменить внут-
596Роли базы данных
ренние структуры данных сервера. Таким образом, помимо всего прочего, такие функции могут
обойти ограничения доступа к системе. Языки программирования, допускающие такой доступ,
считаются «недоверенными» и создавать функции на этих языках PostgreSQL разрешает только
суперпользователям.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-020/" title="Глава 20. Аутентификация клиентского приложения"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 20. Аутентификация клиентского приложения"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-020/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~37 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-020/" rel="bookmark" title="Глава 20. Аутентификация клиентского приложения" itemprop="url">Глава 20. Аутентификация клиентского приложения</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 20. Аутентификация клиентского приложения</p>

<p>При подключении к серверу базы данных, клиентское приложение указывает имя пользователя
PostgreSQL, так же как и при обычном входе пользователя на компьютер с ОС Unix. При работе в
среде SQL по имени пользователя определяется, какие у него есть права доступа к объектам базы
данных (подробнее это описывается в Главе 21). Следовательно, важно указать на этом этапе, к
каким базам пользователь имеет право подключиться.
Примечание
Как можно узнать из Главы  21, PostgreSQL управляет правами и привилегиями, ис-
пользуя так называемые «роли». В этой главе под пользователем мы подразумеваем
«роль с привилегией LOGIN».
Аутентификация это процесс идентификации клиента сервером базы данных, а также определе-
ние того, может ли клиентское приложение (или пользователь запустивший приложение) подклю-
читься с указанным именем пользователя.
PostgreSQL предлагает несколько различных методов аутентификации клиентов. Метод аутенти-
фикации конкретного клиентского соединения может основываться на адресе компьютера клиен-
та, имени базы данных, имени пользователя.
Имена пользователей базы данных PostgreSQL не имеют прямой связи с пользователями операци-
онной системы на которой запущен сервер. Если у всех пользователей базы данных заведена учёт-
ная запись в операционной системе сервера, то имеет смысл назначить им точно такие же име-
на для входа в PostgreSQL. Однако, сервер, принимающий удалённые подключения, может иметь
большое количество пользователей базы данных, у которых нет учётной записи в ОС. В таких слу-
чаях не требуется соответствие между именами пользователей базы данных и именами пользова-
телей операционной системы.
20.1. Файл pg_hba.conf
Аутентификация клиентов управляется конфигурационным файлом, который традиционно назы-
вается pg_hba.conf и расположен в каталоге с данными кластера базы данных. (HBA расшифро-
вывается как host-based authentication — аутентификации по имени узла.) Файл pg_hba.conf, со
стандартным содержимым, создаётся командой initdb при инициализации каталога с данными.
Однако его можно разместить в любом другом месте; см. конфигурационный параметр hba_file.
Обычный формат файла pg_hba.conf представляет собой набор записей, по одной в строке. Пустые
строки игнорируются, как и любой текст комментария после знака #. Записи не продолжаются
на следующей строке. Записи состоят из некоторого количества полей, разделённых между собой
пробелом и/или tabs. В полях могут быть использованы пробелы, если они взяты в кавычки. Если в
кавычки берётся какое-либо зарезервированное слово в поле базы данных, пользователя или адре-
сации (например, all или replication), то слово теряет своё особое значение и просто обозначает
базу данных, пользователя или сервер с данным именем.
Каждая запись обозначает тип соединения, диапазон IP-адресов клиента (если он соотносится с
типом соединения), имя базы данных, имя пользователя, и способ аутентификации, который бу-
дет использован для соединения в соответствии с этими параметрами. Первая запись с соответ-
ствующим типом соединения, адресом клиента, указанной базой данных и именем пользователя
применяется для аутентификации. Процедур «fall-through» или «backup» не предусмотрено: если
выбрана запись и аутентификация не прошла, последующие записи не рассматриваются. Если же
ни одна из записей не подошла, в доступе будет отказано.
Запись может быть сделана в одном из семи форматов:
572Аутентификация кли-
ентского приложения
local
база
host
база
hostssl
база
hostnossl база
host
база
аутентификации]
hostssl
база
аутентификации]
hostnossl база
аутентификации]
пользователь
пользователь
пользователь
пользователь
пользователь метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
IP-адрес IP-маска метод-аутентификации [параметры-
пользователь IP-адрес
IP-маска
метод-аутентификации
[параметры-
пользователь IP-адрес
IP-маска
метод-аутентификации
[параметры-
Значения полей описаны ниже:
local
Управляет подключениями через Unix-сокеты. Без подобной записи подключения через Unix-
сокеты невозможны.
host
Управляет подключениями, устанавливаемыми по TCP/IP. Записи host соответствуют подклю-
чениям с SSL и без SSL.
Примечание
Удалённое соединение по TCP/IP невозможно, если сервер запущен без определе-
ния соответствующих значений для параметра конфигурации listen_addresses, по-
скольку по умолчанию система принимает подключения по TCP/IP только для ло-
кального адреса замыкания localhost.
hostssl
Управляет подключениями, устанавливаемыми по TCP/IP с применением шифрования SSL.
Чтобы использовать эту возможность, сервер должен быть собран с поддержкой SSL. Более
того, механизм SSL должен быть включён параметром конфигурации ssl (подробнее об этом в
Разделе 18.9). В противном случае запись hostssl игнорируется (не считая предупреждения о
том, что ей не будут соответствовать никакие подключения).
hostnossl
Этот тип записей противоположен hostssl, ему соответствуют только подключения по TCP/IP
без шифрования SSL.
база
Определяет, каким именам баз данных соответствует эта запись. Значение all определяет, что
подходят все базы данных. Значение sameuser определяет, что данная запись соответствует
только, если имя запрашиваемой базы данных совпадает с именем запрашиваемого пользова-
теля. Значение samerole определяет, что запрашиваемый пользователь должен быть членом
роли с таким же именем, как и у запрашиваемой базы данных. (samegroup - это устаревший, но
допустимый вариант значения samerole.) Суперпользователи не становятся членами роли ав-
томатически из-за samerole, а только если они являются явными членами роли, прямо или кос-
венно, и не только из-за того, что они суперпользователи. Значение replication показывает,
что запись соответствует, если запрашивается подключение физической репликации (имейте в
виду, что подключения репликации не определяют какую-то конкретную базу данных). В про-
тивном случае, это имя определённой базы данных PostgreSQL. Несколько имён баз данных
можно указать, разделяя их запятыми. Файл, содержащий имена баз данных, можно указать,
поставив знак @ в начале его имени.
573Аутентификация кли-
ентского приложения
пользователь
Указывает, какому имени (или именам) пользователя базы данных соответствует эта запись.
Значение all показывает, что это подходит всем пользователям. В противном случае, это либо
имя конкретного пользователя базы данных, или имя группы, в начале которого стоит знак
+. (Напомним, что в PostgreSQL нет никакой разницы между пользователем и группой; знак +
означает « совпадение любых ролей, которые прямо или косвенно являются членами роли»,
тогда как имя без знака + является подходящей только для этой конкретной роли.) В связи
с этим, суперпользователь рассматривается как член роли, только если он явно является чле-
ном этой роли, прямо или косвенно, а не только потому, что он является суперпользователем.
Несколько имён пользователей можно указать, разделяя их запятыми. Файл, содержащий име-
на пользователей, можно указать, поставив знак @ в начале его имени.
адрес
Указывает адрес (или адреса) клиентской машины, которым соответствует данная запись. Это
поле может содержать или имя компьютера, или диапазон IP-адресов, или одно из нижеупомя-
нутых ключевых слов.
Диапазон IP-адресов указывается в виде начального адреса диапазона, дополненного косой
чертой (/) и длиной маски CIDR. Длина маски задаёт количество старших битов клиентского IP-
адреса, которые должны совпадать с битами IP-адреса диапазона. Биты, находящиеся правее, в
указанном IP-адресе должны быть нулевыми. Между IP-адресом, знаком / и длиной маски CIDR
не должно быть пробельных символов.
Типичные примеры диапазонов адресов IPv4, указанных таким образом: 172.20.143.89/32 для
одного компьютера, 172.20.143.0/24 для небольшой и 10.6.0.0/16 для крупной сети. Диапа-
зон адресов IPv6 может выглядеть как ::1/128 для одного компьютера (это адрес замыкания
IPv6) или как fe80::7a31:c1ff:0000:0000/96 для небольшой сети. 0.0.0.0/0 представляет все
адреса IPv4, а ::0/0 — все адреса IPv6. Чтобы указать один компьютер, используйте длину мас-
ки 32 для IPv4 или 128 для IPv6. Опускать замыкающие нули в сетевом адресе нельзя.
Запись, сделанная в формате IPv4, подойдёт только для подключений по IPv4, а запись в фор-
мате IPv6 подойдёт только для подключений по IPv6, даже если представленный адрес нахо-
дится в диапазоне IPv4-в-IPv6. Имейте в виду, что записи в формате IPv6 не будут приниматься,
если системная библиотека С не поддерживает адреса IPv6.
Вы также можете прописать значение all, чтобы указать любой IP-адрес, samehost, чтобы ука-
зать любые IP-адреса данного сервера, или samenet, чтобы указать любой адрес любой подсети,
к которой сервер подключён напрямую.
Если определено имя компьютера (всё, что не является диапазоном IP-адресов или специаль-
ным ключевым словом, воспринимается как имя компьютера), то оно сравнивается с результа-
том обратного преобразования IP-адреса клиента (например, обратного DNS-запроса, если ис-
пользуется DNS). При сравнении имён компьютеров регистр не учитывается. Если имена сов-
пали, выполняется прямое преобразование имени (например, прямой DNS-запрос) для провер-
ки, относится ли клиентский IP-адрес к адресам, соответствующим имени. Если двусторонняя
проверка пройдена, запись считается соответствующей компьютеру. (В качестве имени узла
в файле pg_hba.conf должно указываться то, что возвращается при преобразовании IP-адре-
са клиента в имя, иначе строка не будет соответствовать узлу. Некоторые базы данных имён
позволяют связать с одним IP-адресом несколько имён узлов, но операционная система при
попытке разрешить IP-адрес возвращает только одно имя.)
Указание имени, начинающееся с точки (.), соответствует суффиксу актуального имени узла.
Так, .example.com будет соответствовать foo.example.com (а не только example.com).
Когда в pg_hba.conf указываются имена узлов, следует добиться, чтобы разрешение имён вы-
полнялось достаточно быстро. Для этого может быть полезен локальный кеш разрешения имён,
например, nscd. Вы также можете включить конфигурационный параметр log_hostname, чтобы
видеть в журналах имя компьютера клиента вместо IP-адреса.
574Аутентификация кли-
ентского приложения
Это поле применимо только к записям host, hostssl и hostnossl.
Примечание
Пользователи часто задаются вопросом, почему имена серверов обрабатываются
таким сложным, на первый взгляд, способом, с разрешением двух имён, включая
обратный запрос клиентского IP-адреса. Это усложняет процесс в случае, если об-
ратная DNS-запись клиента не установлена или включает в себя нежелательное
имя узла. Такой способ избран, в первую очередь, для повышения эффективности:
в этом случае соединение требует максимум два запроса разрешения, один прямой
и один обратный. Если есть проблема разрешения с каким-то адресом, то она оста-
ётся проблемой этого клиента. Гипотетически, могла бы быть реализована возмож-
ность во время каждой попытки соединения выполнять только прямой запрос для
разрешения каждого имени сервера, упомянутого в pg_hba.conf. Но если список
имён велик, процесс был бы довольно медленным, а в случае наличия проблемы
разрешения у одного имени сервера, это стало бы общей проблемой.
Также обратный запрос необходим для того, чтобы реализовать возможность со-
ответствия суффиксов, поскольку для сопоставления с шаблоном требуется знать
фактическое имя компьютера клиента.
Обратите внимание, что такое поведение согласуется с другими популярными ре-
ализациями контроля доступа на основе имён, такими как Apache HTTP Server и
TCP Wrappers.
IP-адрес
IP-маска
Эти два поля могут быть использованы как альтернатива записи IP-адрес/длина-маски. Вместо
того, чтобы указывать длину маски, в отдельном столбце указывается сама маска. Например,
255.0.0.0 представляет собой маску CIDR для IPv4 длиной 8 бит, а 255.255.255.255 представ-
ляет маску CIDR длиной 32 бита.
Эти поля применимы только к записям host, hostssl и hostnossl.
метод-аутентификации
Указывает метод аутентификации, когда подключение соответствует этой записи. Варианты
выбора приводятся ниже; подробности в Разделе 20.3.
trust
Разрешает безусловное подключение. Этот метод позволяет тому, кто может подключить-
ся к серверу с базой данных PostgreSQL, войти под любым желаемым пользователем
PostgreSQL без введения пароля и без какой-либо другой аутентификации. За подробностя-
ми обратитесь к Разделу 20.4.
reject
Отклоняет подключение безусловно. Эта возможность полезна для «фильтрации» некото-
рых серверов группы, например, строка reject может отклонить попытку подключения од-
ного компьютера, при этом следующая строка позволяет подключиться остальным компью-
терам в той же сети.
scram-sha-256
Проверяет пароль пользователя, производя аутентификацию SCRAM-SHA-256. За подроб-
ностями обратитесь к Разделу 20.5.
md5
Проверяет пароль пользователя, производя аутентификацию SCRAM-SHA-256 или MD5. За
подробностями обратитесь к Разделу 20.5.
575Аутентификация кли-
ентского приложения
password
Требует для аутентификации введения клиентом незашифрованного пароля. Поскольку па-
роль посылается простым текстом через сеть, такой способ не стоит использовать, если сеть
не вызывает доверия. За подробностями обратитесь к Разделу 20.5.
gss
Для аутентификации пользователя использует GSSAPI. Этот способ доступен только для
подключений по TCP/IP. За подробностями обратитесь к Разделу 20.6.
sspi
Для аутентификации пользователя использует SSPI. Способ доступен только для Windows.
За подробностями обратитесь к Разделу 20.7.
ident
Получает имя пользователя операционной системы клиента, связываясь с сервером Ident,
и проверяет, соответствует ли оно имени пользователя базы данных. Аутентификация ident
может использоваться только для подключений по TCP/IP. Для локальных подключений при-
меняется аутентификация peer. За подробностями обратитесь к Разделу 20.8.
peer
Получает имя пользователя операционной системы клиента из операционной системы и
проверяет, соответствует ли оно имени пользователя запрашиваемой базы данных. Доступ-
но только для локальных подключений. За подробностями обратитесь к Разделу 20.9.
ldap
Проводит аутентификацию, используя сервер LDAP. За подробностями обратитесь к Разде-
лу 20.10.
radius
Проводит аутентификацию, используя сервер RADIUS. За подробностями обратитесь к Раз-
делу 20.11
cert
Проводит аутентификацию, используя клиентский сертификат SSL. За подробностями об-
ратитесь к Разделу 20.12
pam
Проводит аутентификацию, используя службу подключаемых модулей аутентификации
(PAM), предоставляемую операционной системой. За подробностями обратитесь к Разде-
лу 20.13.
bsd
Проводит аутентификацию, используя службу аутентификации BSD, предоставляемую опе-
рационной системой. За подробностями обратитесь к Разделу 20.14.
.
параметры-аутентификации
После поля метод-аутентификации может идти поле (поля) вида имя=значение, определяющее
параметры метода аутентификации. Подробнее о параметрах, доступных для различных мето-
дов аутентификации, рассказывается ниже.
Помимо описанных далее параметров, относящихся к различным методам, есть один общий
параметр аутентификации clientcert, который можно задать в любой записи hostssl. Если он
равен 1, клиент должен представить подходящий (доверенный) сертификат SSL, в дополнение
к другим требованиям метода проверки подлинности.
576Аутентификация кли-
ентского приложения
Файлы, включённые в конструкции, начинающиеся с @, читаются, как список имён, разделённых
запятыми или пробелами. Комментарии предваряются знаком #, как и в файле pg_hba.conf, и
вложенные @ конструкции допустимы. Если только имя файла, начинающегося с @ не является
абсолютным путём.
Поскольку записи файла pg_hba.conf рассматриваются последовательно для каждого подключе-
ния, порядок записей имеет большое значение. Обычно, более ранние записи определяют чёткие
критерии для соответствия параметров подключения, но для методов аутентификации допускают
послабления. Напротив, записи более поздние смягчают требования к соответствию параметров
подключения, но усиливают их в отношении методов аутентификации. Например, некто желает
использовать trust аутентификацию для локального подключения по TCP/IP, но при этом запра-
шивать пароль для удалённых подключений по TCP/IP. В этом случае, запись, указывающая trust
аутентификацию для подключения адреса 127.0.0.1 должна появиться до записи, определяющей
аутентификацию через пароль для более широкого диапазона клиентских IP-адресов.
Файл pg_hba.conf прочитывается во время запуска и в момент получения основным процессом
сервера сигнала SIGHUP. Если вы редактируете файл во время работы системы, необходимо по-
слать сигнал процессу postmaster (используя pg_ctl reload или kill -HUP), чтобы он прочел об-
новленный файл.
Примечание
Предыдущее утверждение не касается Microsoft Windows: там любые изменения в
pg_hba.conf сразу применяются к последующим подключениям.
Системное представление pg_hba_file_rules может быть полезно для предварительной проверки
изменений в файле pg_hba.conf или для диагностики проблем, когда перезагрузка этого файла
не даёт желаемого эффекта. Строки в этом представлении, содержащие в поле error не NULL,
указывают на проблемы в соответствующих строках файла.
Подсказка
Чтобы подключиться к конкретной базе данных, пользователь не только должен прой-
ти все проверки файла pg_hba.conf, но должен иметь привилегию CONNECT для под-
ключения к базе данных. Если вы хотите ограничить доступ к базам данных для опре-
делённых пользователей, проще предоставить/отозвать привилегию CONNECT, нежели
устанавливать правила в записях файла pg_hba.conf.
Примеры записей файла pg_hba.conf показаны в Примере 20.1. Обратитесь к следующему разделу
за более подробной информацией по методам аутентификации.
Пример 20.1. Примеры записей pg_hba.conf</p>
<h1 id="Позволяет-любому-пользователю-локальной-системы-подключаться">Позволяет любому пользователю локальной системы подключаться</h1>
<h1 id="к-любой-базе-данных-используя-любое-имя-пользователя-баз-данных-через">к любой базе данных, используя любое имя пользователя баз данных, через</h1>
<h1 id="unix-сокеты-по-умолчанию-для-локальных-подключений">Unix-сокеты (по умолчанию для локальных подключений).</h1>
<p>#</p>
<h1 id="type-database">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
local
all
all
trust</p>
<h1 id="То-же-но-для-локальных-замкнутых-подключений-по-tcpip">То же, но для локальных замкнутых подключений по TCP/IP.</h1>
<p>#</p>
<h1 id="type-database-1">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
all
all
127.0.0.1/32</p>
<h1 id="То-же-что-и-в-предыдущей-строке-но-с-указанием">То же, что и в предыдущей строке, но с указанием</h1>
<h1 id="сетевой-маски-в-отдельном-столбце">сетевой маски в отдельном столбце</h1>
<p>#
577
METHOD
trustАутентификация кли-
ентского приложения</p>
<h1 id="type">TYPE</h1>
<p>host
DATABASE
all</p>
<h1 id="То-же-для-ipv6">То же для IPv6.</h1>
<p>#</p>
<h1 id="type-database-2">TYPE DATABASE</h1>
<p>host
all
USER
all IP-ADDRESS
127.0.0.1
USER
all ADDRESS
::1/128
IP-MASK
255.255.255.255
METHOD
trust
METHOD
trust</p>
<h1 id="То-же-самое-но-с-использованием-имени-компьютера">То же самое, но с использованием имени компьютера</h1>
<h1 id="обычно-покрывает-и-ipv4-и-ipv6">(обычно покрывает и IPv4, и IPv6).</h1>
<p>#</p>
<h1 id="type-database-3">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
all
all
localhost METHOD
trust</p>
<h1 id="Позволяет-любому-пользователю-любого-компьютера-с-ip-адресом">Позволяет любому пользователю любого компьютера с IP-адресом</h1>
<h1 id="19216893x-подключаться-к-базе-данных-postgres">192.168.93.x подключаться к базе данных “postgres”</h1>
<h1 id="с-именем-которое-сообщает-для-данного-подключения-ident">с именем, которое сообщает для данного подключения ident</h1>
<h1 id="как-правило-имя-пользователя-операционной-системы">(как правило, имя пользователя операционной системы).</h1>
<p>#</p>
<h1 id="type-database-4">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
postgres
all
192.168.93.0/24 METHOD
ident</p>
<h1 id="Позволяет-любому-пользователю-компьютера-1921681210-подключаться">Позволяет любому пользователю компьютера 192.168.12.10 подключаться</h1>
<h1 id="к-базе-данных-postgres-если-он-передаёт-правильный-пароль">к базе данных “postgres”, если он передаёт правильный пароль.</h1>
<p>#</p>
<h1 id="type-database-5">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
postgres
all
192.168.12.10/32
scram-sha-256</p>
<h1 id="Позволяет-любым-пользователям-с-компьютеров-в-домене-examplecom">Позволяет любым пользователям с компьютеров в домене example.com</h1>
<h1 id="подключаться-к-любой-базе-данных-если-передаётся-правильный-пароль">подключаться к любой базе данных, если передаётся правильный пароль.</h1>
<p>#</p>
<h1 id="Для-всех-пользователей-требуется-аутентификация-scram-за-исключением">Для всех пользователей требуется аутентификация SCRAM, за исключением</h1>
<h1 id="пользователя-mike-который-использует-старый-клиент-не-поддерживающий">пользователя ‘mike’, который использует старый клиент, не поддерживающий</h1>
<h1 id="аутентификацию-scram">аутентификацию SCRAM.</h1>
<p>#</p>
<h1 id="type-database-6">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
mike
.example.com
md5
host
all
all
.example.com
scram-sha-256</p>
<h1 id="В-случае-отсутствия-предшествующих-строчек-с-host-следующие-две-строки">В случае отсутствия предшествующих строчек с “host”, следующие две строки</h1>
<h1 id="откажут-в-подключении-с-192168541-поскольку-данная-запись-будет">откажут в подключении с 192.168.54.1 (поскольку данная запись будет</h1>
<h1 id="выбрана-первой-но-разрешат-подключения-gssapi-с-любых-других">выбрана первой), но разрешат подключения GSSAPI с любых других</h1>
<h1 id="адресов-С-нулевой-маской-ни-один-бит-из-ip-адреса-компьютера">адресов. С нулевой маской ни один бит из IP-адреса компьютера</h1>
<h1 id="не-учитывается-так-что-этой-строке-соответствует-любой-компьютер">не учитывается, так что этой строке соответствует любой компьютер.</h1>
<p>#</p>
<h1 id="type-database-7">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
all
192.168.54.1/32
reject
host
all
all
0.0.0.0/0
gss</p>
<h1 id="Позволяет-пользователям-с-любого-компьютера-192168xx-подключаться">Позволяет пользователям с любого компьютера 192.168.x.x подключаться</h1>
<h1 id="к-любой-базе-данных-если-они-проходят-проверку-ident-Если-же-ident">к любой базе данных, если они проходят проверку ident. Если же ident</h1>
<h1 id="говорит-например-что-это-пользователь-bryanh-и-он-запрашивает">говорит, например, что это пользователь “bryanh” и он запрашивает</h1>
<h1 id="подключение-как-пользователь-postgresql-guest1-подключение">подключение как пользователь PostgreSQL “guest1”, подключение</h1>
<h1 id="будет-разрешено-если-в-файле-pg_identconf-есть-сопоставление">будет разрешено, если в файле pg_ident.conf есть сопоставление</h1>
<h1 id="omicron-позволяющее-пользователю-bryanh-подключаться-как-guest1">“omicron”, позволяющее пользователю “bryanh” подключаться как “guest1”.</h1>
<p>#</p>
<h1 id="type-database-8">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
all
192.168.0.0/16
ident map=omicron
578Аутентификация кли-
ентского приложения</p>
<h1 id="Если-для-локальных-подключений-предусмотрены-только-эти-три-строки">Если для локальных подключений предусмотрены только эти три строки,</h1>
<h1 id="они-позволят-локальным-пользователям-подключаться-только-к-своим">они позволят локальным пользователям подключаться только к своим</h1>
<h1 id="базам-данных-базам-данных-с-именами-совпадающими-с">базам данных (базам данных с именами, совпадающими с</h1>
<h1 id="именами-пользователей-баз-данных-кроме-администраторов">именами пользователей баз данных), кроме администраторов</h1>
<h1 id="или-членов-роли-support-которые-могут-подключиться-к-любой-БД">или членов роли “support”, которые могут подключиться к любой БД.</h1>
<h1 id="Список-имён-администраторов-содержится-в-файле-pgdataadmins">Список имён администраторов содержится в файле $PGDATA/admins.</h1>
<h1 id="Пароли-запрашиваются-в-любом-случае">Пароли запрашиваются в любом случае.</h1>
<p>#</p>
<h1 id="type-database-9">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
local
sameuser
all
md5
local
all
@admins
md5
local
all
+support
md5</p>
<h1 id="Последние-две-строчки-выше-могут-быть-объединены-в-одну">Последние две строчки выше могут быть объединены в одну:</h1>
<p>local
all
@admins,+support
md5</p>
<h1 id="В-столбце-database-также-могут-указываться-списки-и-имена-файлов">В столбце DATABASE также могут указываться списки и имена файлов:</h1>
<p>local
db1,db2,@demodbs all
md5
20.2. Файл сопоставления имён пользователей
Когда используется внешняя система аутентификации, например Ident или GSSAPI, имя пользова-
теля операционной системы, устанавливающего подключение, может не совпадать с именем це-
левого пользователя (роли) базы данных. В этом случае можно применить сопоставление имён
пользователей, чтобы сменить имя пользователя операционной системы на имя пользователя БД.
Чтобы задействовать сопоставление имён, укажите map=имя-сопоставления в поле параметров в
pg_hba.conf. Этот параметр поддерживается для всех методов аутентификации, которые принима-
ют внешние имена пользователей. Так как для разных подключений могут требоваться разные со-
поставления, сопоставление определяется параметром имя-сопоставления в pg_hba.conf для каж-
дого отдельного подключения.
Сопоставления имён пользователя определяются в файле сопоставления ident, который по умол-
чанию называется pg_ident.confи хранится в каталоге данных кластера. (Файл сопоставления мо-
жет быть помещён и в другое место, обратитесь к информации о настройке параметра ident_file.)
Файл сопоставления ident содержит строки общей формы:
map-name system-username database-username
Комментарии и пробелы применяются так же, как и в файле pg_hba.conf. map-name является про-
извольным именем, на которое будет ссылаться файл сопоставления файла pg_hba.conf. Два дру-
гих поля указывают имя пользователя операционной системы и соответствующее имя пользовате-
ля базы данных. Имя map-name может быть использовано неоднократно, чтобы указывать множе-
ственные сопоставления пользовательских имён в рамках одного файла сопоставления.
Нет никаких ограничений по количеству пользователей баз данных, на которые может ссылаться
пользователь операционной системы, и наоборот. Тем не менее, записи в файле скорее подразу-
мевают, что « пользователь этой операционной системы может подключиться как пользователь
этой базы данных», нежели показывают, что эти имена пользователей эквивалентны. Подключе-
ние разрешается, если существует запись в файле сопоставления, соединяющая имя, полученное
от внешней системы аутентификации, с именем пользователя базы данных, под которым пользо-
ватель хочет подключиться.
Если поле system-username начинается со знака (/), оставшаяся его часть рассматривается как
регулярное выражение. (Подробнее синтаксис регулярных выражений PostgreSQL описан в Под-
разделе 9.7.3.1.) Регулярное выражение может включать в себя одну группу, или заключённое в
скобки подвыражение, на которое можно сослаться в поле database-username, написав \1 (с одной
обратной косой). Это позволяет сопоставить несколько имён пользователя с одной строкой, что
особенно удобно для простых замен. Например, эти строки
579Аутентификация кли-
ентского приложения
mymap
mymap
/^(.<em>)@mydomain.com$
/^(.</em>)@otherdomain.com$
\1
guest
удалят часть домена для имён пользователей, которые заканчиваются на @mydomain.com, и позво-
лят пользователям, чьё имя пользователя системы заканчивается на @otherdomain.com, подклю-
читься как guest.
Подсказка
Помните, что по умолчанию, регулярное выражение может совпасть только с частью
строки. Разумным выходом будет использование символов ^ и $, как показано в при-
мере выше, для принудительного совпадения со всем именем пользователя операци-
онной системы
Файл pg_ident.conf читается при запуске системы, а также в тот момент, когда основной сервер
получает сигнал SIGHUP. Если вы редактируете файл во время работы системы, необходимо по-
слать сигнал процессу postmaster (используя pg_ctl reload или kill -HUP), чтобы он прочел об-
новленный файл.
Файл pg_ident.conf, который может быть использован в сочетании с файлом pg_hba.conf (см.
Пример 20.1), показан в Примере 20.2. В этом примере любым пользователям компьютеров в сети
192.168 с именами, отличными от bryanh, ann или robert, будет отказано в доступе. Пользователь
системы robert получит доступ только тогда, когда подключается как пользователь PostgreSQL
bob, а не как robert, или какой-либо другой пользователь. Пользователь ann сможет подключиться
только как ann. Пользователь bryanh сможет подключиться как bryanh или как guest1.
Пример 20.2. Пример файла pg_ident.conf</p>
<h1 id="mapname">MAPNAME</h1>
<p>SYSTEM-USERNAME
PG-USERNAME
omicron
bryanh
bryanh
omicron
ann
ann</p>
<h1 id="на-этих-машинах-bob-может-подключаться-как-robert">на этих машинах bob может подключаться как robert</h1>
<p>omicron
robert
bob</p>
<h1 id="bryanh-также-может-подключаться-как-guest1">bryanh также может подключаться как guest1</h1>
<p>omicron
bryanh
guest1
20.3. Методы аутентификации
Более подробно методы аутентификации рассматриваются в следующих разделах.
20.4. Аутентификация trust
Когда указан способ аутентификации trust, PostgreSQL предполагает, что любой подключающий-
ся к серверу авторизован для доступа к базе данных вне зависимости от указанного имени пользо-
вателя базы данных (даже если это имя суперпользователя). Конечно, ограничения, прописанные
в столбцах база и пользователь, продолжают работать. Этот метод должен применяться только в
том случае, когда на уровне операционной системы обеспечена адекватная защита от подключе-
ний к серверу.
Аутентификация trust очень удобна для локальных подключений на однопользовательской
рабочей станции. Но сам по себе этот метод обычно не подходит для машин с нескольки-
ми пользователями. Однако вы можете использовать trust даже на многопользовательской
машине, если ограничите доступ к файлу Unix-сокета сервера на уровне файловой системы.
Для этого установите конфигурационные параметры unix_socket_permissions (и, возможно,
unix_socket_group) как описано в Разделе 19.3. Либо вы можете установить конфигурационный
параметр unix_socket_directories, чтобы разместить файл сокета в должным образом защищён-
ном каталоге.
580Аутентификация кли-
ентского приложения
Установка разрешений на уровне файловой системы помогает только в случае подключений через
Unix-сокеты. На локальные подключения по TCP/IP ограничения файловой системы не влияют.
Поэтому, если вы хотите использовать разрешения файловой системы для обеспечения локальной
безопасности, уберите строку host … 127.0.0.1 … из pg_hba.conf или смените метод аутен-
тификации.
Метод аутентификации trust для подключений по TCP/IP допустим только в случае, если вы до-
веряете каждому пользователю компьютера, получившему разрешение на подключение к серверу
строками файла pg_hba.conf, указывающими метод trust. Не стоит использовать trust для любых
подключений по TCP/IP, отличных от localhost (127.0.0.1).
20.5. Аутентификация password
Существует несколько методов аутентификации по паролю. Они работают примерно одинаково,
но различаются тем, как пароли пользователей хранятся на сервере и как пароль передаётся от
клиента по каналу связи.
scram-sha-256
С методом scram-sha-256 выполняется аутентификация SCRAM-SHA-256, как описано в RFC</p>
<ol>
  <li>Она производится по схеме вызов-ответ, которая предотвращает перехват паролей через
недоверенные соединения и поддерживает хранение паролей на сервере в виде криптографи-
ческого хеша, что считается безопасным.
Это наиболее безопасный из существующих на данный момент методов, но он не поддержива-
ется старыми клиентскими библиотеками.
md5
Для метода md5 реализован менее безопасный механизм вызов-ответ. Он предотвращает пере-
хват паролей и предусматривает хранение паролей на сервере в зашифрованном виде, но не
защищает в случае похищения хешей паролей с сервера. Кроме того, алгоритм хеширования
MD5 в наши дни уже может не защитить от целенаправленных атак.
Метод md5 несовместим с функциональностью db_user_namespace.
Для облегчения перехода от метода md5 к более новому методу SCRAM, если в качестве метода
аутентификации в pg_hba.conf указан md5, но пароль пользователя на сервере зашифрован для
SCRAM (см. ниже), автоматически будет производиться аутентификация на базе SCRAM.
password
С методом password пароль передаётся в открытом виде и поэтому является уязвимым для атак
с перехватом трафика. Его следует избегать всегда, если это возможно. Однако, если подклю-
чение защищено SSL, метод password может быть безопасен. (Хотя аутентификация по серти-
фикату SSL может быть лучшим выбором когда используется SSL).
Пароли баз данных PostgreSQL отделены от паролей пользователей операционной системы. Па-
роли всех пользователей базы данных хранятся в системном каталоге pg_authid. Управлять паро-
лями можно либо используя SQL-команды CREATE ROLE и ALTER ROLE, например, CREATE ROLE
foo WITH LOGIN PASSWORD ‘secret’, либо с помощью команды psql \password. Если пароль для
пользователя не задан, вместо него хранится NULL, и пройти аутентификацию по паролю этот
пользователь не сможет.
Доступность различных методов аутентификации по паролю зависит от того, как пароли пользо-
вателей шифруются на сервере (или, говоря точнее, хешируются). Это определяется параметром
конфигурации password_encryption в момент назначения пароля. Если пароль шифруется в режи-
ме scram-sha-256, его можно будет использовать для методов аутентификации scram-sha-256 и
password (но в последнем случае он будет передаваться открытым текстом). В случае указания ме-
тода аутентификации md5 при этом произойдёт автоматический переход к использованию scram-
sha-256, как сказано выше, так что этот вариант тоже будет работать. Если пароль шифруется в
581Аутентификация кли-
ентского приложения
режиме md5, его можно будет использовать только для методов аутентификации md5 и password (и
в последнем случае он так же будет передаваться открытым текстом). (Ранние версии PostgreSQL
поддерживали хранение паролей на сервере в открытом виде, но теперь это невозможно.) Чтобы
просмотреть хранящиеся в БД хеши паролей, обратитесь к системному каталогу pg_authid.
Для перевода существующей инсталляции с md5 на scram-sha-256, после того как все клиентские
библиотеки будут обновлены до версий, поддерживающих SCRAM, задайте password_encryption
= ‘scram-sha-256’ в postgresql.conf, добейтесь, чтобы все пользователи сменили свои пароли, а
затем поменяйте указания метода аутентификации в pg_hba.conf на scram-sha-256.
20.6. Аутентификация GSSAPI
GSSAPI является протоколом отраслевого стандарта для безопасной авторизации, определённым
в RFC 2743. PostgreSQL поддерживает GSSAPI с Kerberos аутентификацией с соответствии с RFC</li>
  <li>GSSAPI обеспечивает автоматическую аутентификацию (single sign-on), для систем, которые
её поддерживают. Сама по себе аутентификация безопасна, но данные, отсылаемые в ходе под-
ключения к базе данных, не защищены, если не используется SSL.
Поддержка GSSAPI должна быть включена при сборке PostgreSQL; за дополнительными сведени-
ями обратитесь к Главе 16.
При работе с Kerberos GSSAPI использует стандартные учётные записи в формате servicename/
hostname@realm. Сервер PostgreSQL примет любого принципала, включённого в используемый сер-
вером файл таблицы ключей, но необходимо проявить осторожность в указании корректных дета-
лей принципала в ходе соединения с клиентом, применяющим параметр подключения krbsrvname.
(См. также Подраздел 34.1.2.) Значение имени сервиса по умолчанию postgres может быть изме-
нено во время сборки с помощью ./configure –with-krb-srvnam=whatever. В большинстве сред
изменять данный параметр не требуется. Однако некоторые реализации Kerberos могут потребо-
вать иного имени сервиса, например, Microsoft Active Directory требует, чтобы имя сервиса было
набрано заглавными буквами (POSTGRES).
hostname здесь — это полное доменное имя компьютера, где работает сервер. Областью субъек-
та-службы является предпочитаемая область данного компьютера.
Принципалы клиентов могут быть сопоставлены с различными именами пользователей баз данных
PostgreSQL в pg_ident.conf. Например, принципалу pgusername@realm может быть сопоставлено
просто pgusername. Так же возможно использовать в качестве имени роли в PostgreSQL полное
имя принципала username@realm без какого-либо сопоставления.
PostgreSQL также поддерживает возможность убирать область из имени принципала. Эта возмож-
ность оставлена для обратной совместимости и использовать её крайне нежелательно, так как
при этом оказывается невозможно различить разных пользователей, имеющих одинаковые име-
на, но приходящих из разных областей. Чтобы включить её, установите для include_realm значе-
ние 0. В простых конфигурациях с одной областью исключение области в сочетании с парамет-
ром krb_realm (который позволяет ограничить область пользователя одним значением, заданным
в krb_realm parameter) будет безопасным, но менее гибким вариантом по сравнению с явным опи-
санием сопоставлений в pg_ident.conf.
Убедитесь, что файл ключей вашего сервера доступен для чтения (и желательно недоступен для
записи) учётной записи сервера PostgreSQL. (См. также Раздел  18.1.) Расположение этого фай-
ла ключей указывается параметром krb_server_keyfile. По умолчанию это /usr/local/pgsql/etc/
krb5.keytab (каталог может быть другим, в зависимости от значения sysconfdir при сборке).
Из соображений безопасности рекомендуется использовать отдельный файл keytab для сервера
PostgreSQL, а не открывать доступ к общесистемному файлу.
Файл таблицы ключей генерируется программным обеспечением Kerberos; подробнее это описано
в документации Kerberos. Следующий пример для MIT-совместимых реализаций Kerberos 5:
kadmin% ank -randkey postgres/server.my.domain.org
kadmin% ktadd -k krb5.keytab postgres/server.my.domain.org
582Аутентификация кли-
ентского приложения
При подключении к базе данных убедитесь, что у вас есть разрешение на сопоставление прин-
ципала с именем пользователя базы данных. Например, для имени пользователя базы данных
fred, принципал fred@EXAMPLE.COM сможет подключиться. Чтобы дать разрешение на подклю-
чение принципалу fred/users.example.com@EXAMPLE.COM, используйте файл сопоставления имён
пользователей, как описано в Разделе 20.2.
Для метода GSSAPI доступны следующие параметры конфигурации:
include_realm
Когда этот параметр равен 0, из принципала аутентифицированного пользователя убирается
область, и оставшееся имя проходит сопоставление имён (см. Раздел 20.2). Этот вариант не ре-
комендуется и поддерживается в основном для обратной совместимости, так как он небезопа-
сен в окружениях с несколькими областями, если только дополнительно не задаётся krb_realm.
Более предпочтительный вариант — оставить значение include_realm по умолчанию (1) и за-
дать в pg_ident.conf явное сопоставление для преобразования имён принципалов в имена
пользователей PostgreSQL.
map
Разрешает сопоставление имён пользователей системы и пользователей баз данных. За
подробностями обратитесь к Разделу  20.2. Для принципала GSSAPI/Kerberos, такого как
username@EXAMPLE.COM (или более редкого username/hostbased@EXAMPLE.COM), именем пользо-
вателя в сопоставлении будет username@EXAMPLE.COM (или username/hostbased@EXAMPLE.COM,
соответственно), если include_realm не равно 0; в противном случае именем системного поль-
зователя в сопоставлении будет username (или username/hostbased).
krb_realm
Устанавливает область, с которой будут сверяться имена принципалов пользователей. Если
этот параметр задан, подключаться смогут только пользователи из этой области. Если не за-
дан, подключаться смогут пользователи из любой области, в зависимости от установленного
сопоставления имён пользователей.
20.7. Аутентификация SSPI
SSPI — технология Windows для защищённой аутентификации с единственным входом. PostgreSQL
использует SSPI в режиме negotiate, который применяет Kerberos, когда это возможно, и автома-
тически возвращается к NTLM в других случаях. Аутентификация SSPI работает только, когда и
сервер, и клиент работают на платформе Windows, или, на не-Windows платформах, если доступен
GSSAPI.
Если используется аутентификация Kerberos, SSPI работает так же, как GSSAPI; подробнее об этом
рассказывается в Разделе 20.6.
Для SSPI доступны следующие параметры конфигурации:
include_realm
Когда этот параметр равен 0, из принципала аутентифицированного пользователя убирается
область, и оставшееся имя проходит сопоставление имён (см. Раздел 20.2). Этот вариант не ре-
комендуется и поддерживается в основном для обратной совместимости, так как он небезопа-
сен в окружениях с несколькими областями, если только дополнительно не задаётся krb_realm.
Более предпочтительный вариант — оставить значение include_realm по умолчанию (1) и за-
дать в pg_ident.conf явное сопоставление для преобразования имён принципалов в имена
пользователей PostgreSQL.
compat_realm
Если равен 1, для параметра include_realm применяется имя домена, совместимое с SAM
(также известное как имя NetBIOS). Это вариант по умолчанию. Если он равен 0, для имени
принципала Kerberos применяется действительное имя области.
583Аутентификация кли-
ентского приложения
Этот параметр можно отключить, только если ваш сервер работает под именем доменного поль-
зователя (в том числе, виртуального пользователя службы на компьютере, включённом в до-
мен) и все клиенты, проходящие проверку подлинности через SSPI, также используют домен-
ные учётные записи; в противном случае аутентификация не будет выполнена.
upn_username
Если этот параметр включён вместе с compat_realm, для аутентификации применяется имя
Kerberos UPN. Если он отключён (по умолчанию), применяется SAM-совместимое имя пользо-
вателя. По умолчанию у новых учётных записей эти два имени совпадают.
Заметьте, что libpq использует имя, совместимое с SAM, если имя не задано явно. Если вы
применяете libpq или драйвер на его базе, этот параметр следует оставить отключённым, либо
явно задавать имя пользователя в строке подключения.
map
Позволяет сопоставить пользователей системы с пользователями баз данных. За подробностя-
ми обратитесь к Разделу 20.2. Для принципала SSPI/Kerberos, такого как username@EXAMPLE.COM
(или более редкого username/hostbased@EXAMPLE.COM), именем пользователя в сопоставле-
нии будет username@EXAMPLE.COM (или username/hostbased@EXAMPLE.COM, соответственно), если
include_realm не равно 0; в противном случае именем системного пользователя в сопоставле-
нии будет username (или username/hostbased).
krb_realm
Устанавливает область, с которой будут сверяться имена принципалов пользователей. Если
этот параметр задан, подключаться смогут только пользователи из этой области. Если не за-
дан, подключаться смогут пользователи из любой области, в зависимости от установленного
сопоставления имён пользователей.
20.8. Аутентификация Ident
Метод аутентификации ident работает, получая имя пользователя операционной системы клиента
от сервера Ident и используя его в качестве разрешённого имени пользователя базы данных (с воз-
можным сопоставлением имён пользователя). Способ доступен только для подключений по TCP/IP.
Примечание
Когда для локального подключения (не TCP/IP) указан ident, вместо него используется
метод аутентификации peer (см. Раздел 20.9).
Для метода ident доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
Протокол «Identification» (Ident) описан в RFC 1413. Практически каждая Unix-подобная операци-
онная система поставляется с сервером Ident, по умолчанию слушающим TCP-порт 113. Базовая
функция этого сервера — отвечать на вопросы, вроде «Какой пользователь инициировал подклю-
чение, которое идет через твой порт X и подключается к моему порту Y?». Поскольку после уста-
новления физического подключения PostgreSQL знает и X, и Y, он может опрашивать сервер Ident
на компьютере клиента и теоретически может определять пользователя операционной системы
при каждом подключении.
Недостатком этой процедуры является то, что она зависит от интеграции с клиентом: если кли-
ентская машина не вызывает доверия или скомпрометирована, злоумышленник может запустить
584Аутентификация кли-
ентского приложения
любую программу на порту 113 и вернуть любое имя пользователя на свой выбор. Поэтому этот
метод аутентификации подходит только для закрытых сетей, где каждая клиентская машина нахо-
дится под жёстким контролем и где администраторы операционных систем и баз данных работают
в тесном контакте. Другими словами, вы должны доверять машине, на которой работает сервер
Ident. Помните предупреждение:
Протокол Ident не предназначен для использования как протокол авторизации и кон-
троля доступа.
—RFC 1413
У некоторых серверов Ident есть нестандартная возможность, позволяющая зашифровать возвра-
щаемое имя пользователя, используя ключ, который известен только администратору исходного
компьютера. Эту возможность нельзя использовать с PostgreSQL, поскольку PostgreSQL не сможет
расшифровать возвращаемую строку и получить фактическое имя пользователя.
20.9. Аутентификация peer
Метод аутентификации peer работает, получая имя пользователя операционной системы клиента
из ядра и используя его в качестве разрешённого имени пользователя базы данных (с возможно-
стью сопоставления имён пользователя). Этот метод поддерживается только для локальных под-
ключений.
Для метода peer доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
Аутентификация peer доступна только в операционных системах, поддерживающих функцию
getpeereid(), параметр сокета SO_PEERCRED или подобные механизмы. В настоящее время это
Linux, большая часть разновидностей BSD, включая macOS, и Solaris.
20.10. Аутентификация LDAP
Данный метод аутентификации работает сходным с методом password образом, за исключением
того, что он использует LDAP как метод подтверждения пароля. LDAP используется только для
подтверждения пары “имя пользователя/пароль”. Поэтому пользователь должен уже существовать
в базе данных до того, как для аутентификации будет использован LDAP.
Аутентификация LDAP может работать в двух режимах. Первый режим называется простое связы-
вание. В ходе аутентификации сервер связывается с характерным именем, составленным следую-
щим образом: prefix username suffix. Обычно, параметр prefix используется для указания cn=
или DOMAIN\ в среде Active Directory. suffix используется для указания оставшейся части DN или
в среде, отличной от Active Directory.
Во втором режиме, который мы называем поиск+связывание, сервер сначала связывается с ка-
талогом LDAP с предопределённым именем пользователя и паролем, указанным в ldapbinddn и
ldapbindpasswd, и выполняет поиск пользователя, пытающегося подключиться к базе данных. Ес-
ли имя пользователя и пароль не определены, сервер пытается связаться с каталогом анонимно.
Поиск выполняется в поддереве ldapbasedn, при этом проверятся точное соответствие имени поль-
зователя атрибуту ldapsearchattribute. Как только при поиске находится пользователь, сервер
отключается и заново связывается с каталогом уже как этот пользователь, с паролем, передан-
ным клиентом, чтобы удостовериться, что учётная запись корректна. Этот же режим использует-
ся в схемах LDAP-аутентификации в другом программном обеспечении, например, в pam_ldap и
mod_authnz_ldap в Apache. Данный вариант даёт больше гибкости в выборе расположения объек-
тов пользователей, но при этом требует дважды подключаться к серверу LDAP.
В обоих режимах используются следующие параметры конфигурации:
585Аутентификация кли-
ентского приложения
ldapserver
Имена и IP-адреса LDAP-серверов для связи. Можно указать несколько серверов, разделяя их
пробелами.
ldapport
Номер порта для связи с LDAP-сервером. Если порт не указан, используется установленный по
умолчанию порт библиотеки LDAP.
ldapscheme
Значение ldaps выбирает протокол LDAPS. Это нестандартный способ использования LDAP по-
верх SSL, поддерживаемый некоторыми серверами LDAP. Альтернативную возможность предо-
ставляет параметр ldaptls.
ldaptls
Значение 1 включает TLS-шифрование для защиты соединения PostgreSQL с LDAP-сервером.
При этом используется операция StartTLS, описанная в RFC 4513. Альтернативную возмож-
ность предоставляет параметр ldapscheme.
Заметьте, что при использовании ldapscheme или ldaptls шифруется только трафик между серве-
ром PostgreSQL и сервером LDAP. Соединение между сервером PostgreSQL и клиентом остаётся
незашифрованным, если только и для него не включён SSL.
Следующие параметры используются только в режиме простого связывания:
ldapprefix
Эта строка подставляется перед именем пользователя во время формирования DN для связы-
вания при аутентификации в режиме простого связывания.
ldapsuffix
Эта строка размещается после имени пользователя во время формирования DN для связыва-
ния, при аутентификации в режиме простого связывания.
Следующие параметры используются только в режиме поиск+связывание:
ldapbasedn
Корневая папка DN для начала поиска пользователя при аутентификации в режиме поиск+свя-
зывание.
ldapbinddn
DN пользователя для связи с каталогом при выполнении поиска в ходе аутентификации в ре-
жиме поиск+связывание.
ldapbindpasswd
Пароль пользователя для связывания с каталогом при выполнении поиска в ходе аутентифика-
ции в режиме поиск+связывание.
ldapsearchattribute
Атрибут для соотнесения с именем пользователя в ходе аутентификации поиск+связывание.
Если атрибут не указан, будет использован атрибут uid.
ldapsearchfilter
Фильтр поиска, используемый для аутентификации в режиме поиск+связывание. Вхождения
$username в нём будут заменяться именем пользователя. Это позволяет задавать более гибкие
фильтры поиска, чем ldapsearchattribute.
586Аутентификация кли-
ентского приложения
ldapurl
Адрес LDAP по стандарту RFC 4516. Это альтернативный способ записи некоторых других па-
раметров LDAP в более компактном и стандартном виде. Формат адреса таков:
ldap[s]://сервер[:порт]/basedn[?[атрибут][?[scope][?[фильтр]]]]
Здесь scope принимает значение base, one или sub (обычно последнее). По умолчанию под-
разумевается base, что не очень полезно при таком применении. В качестве атрибута мо-
жет указываться один атрибут; в этом случае он используется как значение параметра
ldapsearchattribute. Если атрибут не указан, в качестве значения ldapsearchfilter может
использоваться фильтр.
Схема адреса ldaps выбирает для установления LDAP-подключений поверх SSL метод LDAPS,
что равнозначно указанию ldapscheme=ldaps. Для применения шифрования LDAP с использо-
ванием операции StartTLS используйте обычную схему URL ldap и укажите параметр ldaptls
в дополнение к ldapurl.
Для неанонимного связывания ldapbinddn и ldapbindpasswd должны быть указаны как раз-
дельные параметры.
В настоящее время URL-адреса LDAP поддерживаются только с OpenLDAP, не в Windows.
Нельзя путать параметры конфигурации для режима простого связывания с параметрами для ре-
жима поиск+связывание, это ошибка.
В режиме поиск+связывание поиск может выполняться либо по одному атрибуту, указанному в
ldapsearchattribute, либо по произвольному фильтру поиска, заданному в ldapsearchfilter. Ука-
зание ldapsearchattribute=foo равнозначно указанию ldapsearchfilter=”(foo=$username)”. Ес-
ли не указан ни один параметр, по умолчанию подразумевается ldapsearchattribute=uid.
Это пример конфигурации LDAP для простого связывания:
host … ldap ldapserver=ldap.example.net ldapprefix=”cn=” ldapsuffix=”, dc=example,
dc=net”
Когда запрашивается подключение к серверу базы данных в качестве пользователя базы дан-
ных someuser, PostgreSQL пытается связаться с LDAP-сервером, используя DN cn=someuser,
dc=example, dc=net и пароль, предоставленный клиентом. Если это подключение удалось, то до-
ступ к базе данных будет открыт.
Пример конфигурации для режима поиск+связывание:
host … ldap ldapserver=ldap.example.net ldapbasedn=”dc=example, dc=net”
ldapsearchattribute=uid
Когда запрашивается подключение к серверу базы данных в качестве пользователя базы данных
someuser, PostgreSQL пытается связаться с сервером LDAP анонимно (поскольку ldapbinddn не
был указан), выполняет поиск для (uid=someuser) под указанной базой DN. Если запись найдена,
проводится попытка связывание с использованием найденной информации и паролем, предостав-
ленным клиентом. Если вторая попытка подключения проходит успешно, предоставляется доступ
к базе данных.
Пример той же конфигурации для режима поиск+связывание, но записанной в виде URL:
host … ldap ldapurl=”ldap://ldap.example.net/dc=example,dc=net?uid?sub”
Такой URL-формат используется и другим программным обеспечением, поддерживающим аутен-
тификацию по протоколу LDAP, поэтому распространять такую конфигурацию будет легче.
Пример конфигурации поиск+связывание, в котором ldapsearchfilter используется вместо
ldapsearchattribute для прохождения аутентификации по идентификатору или почтовому адре-
су пользователя:
587Аутентификация кли-
ентского приложения
host … ldap ldapserver=ldap.example.net ldapbasedn=”dc=example, dc=net”
ldapsearchfilter=”(|(uid=$username)(mail=$username))”
Подсказка
Поскольку LDAP часто применяет запятые и пробелы для разделения различных ча-
стей DN, необходимо использовать кавычки при определении значения параметров,
как показано в наших примерах.
20.11. Аутентификация RADIUS
Данный метод аутентификации работает сходным с методом password образом, за исключением
того, что он использует RADIUS как метод проверки пароля. RADIUS используется только для под-
тверждения пары имя пользователя/пароль. Поэтому пользователь должен уже существовать в ба-
зе данных до того, как для аутентификации будет использован RADIUS.
В ходе аутентификации RADIUS настроенному RADIUS-серверу посылается запрос доступа. Это
сообщение типа Только Аутентификация, которое включает в себя параметры имя пользователя,
пароль (зашифрованный) и идентификатор NAS. Запрос зашифровывается с использованием общего
с сервером секрета. RADIUS-сервер отвечает на запрос сервера либо Доступ принят, либо Доступ
отклонён. Система ведения учёта RADIUS не поддерживается.
Указать можно адреса нескольких серверов RADIUS, тогда они будут перебираться по очереди.
В случае получения от любого сервера отрицательного ответа произойдёт сбой аутентификации.
Если ответ не будет получен, последует попытка подключения к следующему серверу в списке.
Чтобы задать имена нескольких серверов, заключите их в кавычки и разделите запятыми. Если
указывается несколько серверов, все остальные параметры RADIUS так же должны записываться
в списке через запятую, чтобы каждый сервер получил собственное значение. Возможно также
задавать их единственным значением, в этом случае это значение будет применяться ко всем сер-
верам.
Для метода RADIUS доступны следующие параметры конфигурации:
radiusservers
Имена или IP-адреса серверов RADIUS для подключения. Это обязательный параметр.
radiussecrets
Общие секреты, используемые при общении с сервером RADIUS. Секрет должен быть одинако-
вым на серверах PostgreSQL и RADIUS. Рекомендуется использовать строку как минимум из 16
символов. Это обязательный параметр.
Примечание
Шифровальный вектор будет достаточно эффективен только в том случае, если
PostgreSQL собран с поддержкой OpenSSL. В противном случае, передача данных
серверу RADIUS будет лишь замаскированной, но не защищённой, поэтому необхо-
димо принять дополнительные меры безопасности.
radiusports
Номер порта для подключения к серверам RADIUS. Если порт не указан, по умолчанию исполь-
зуется порт 1812.
radiusidentifiers
Строка, используемая в запросах сервера RADIUS как Идентификатор NAS. Этот параметр мо-
жет использоваться как второй параметр, выявляющий, например, какой пользователь пыта-
588Аутентификация кли-
ентского приложения
ется подключиться под каким пользователем базы данных, что может быть использовано для
формирования соответствий на сервере RADIUS. Если не указан идентификатор, по умолчанию
используется postgresql.
20.12. Аутентификация по сертификату
Для аутентификации в рамках этого метода используется клиентский сертификат SSL, поэтому
данный способ применим только для SSL-подключений. Когда используется этот метод, сервер
потребует от клиента предъявления действительного и доверенного сертификата. Пароль у кли-
ента не запрашивается. Атрибут cn (Обычное имя) сертификата сравнивается с запрашиваемым
именем пользователя базы данных, и если они соответствуют, вход разрешается. Если cn отлича-
ется от имени пользователя базы данных, то может быть использовано сопоставление имён поль-
зователей.
Для аутентификации по SSL сертификату доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
В записи pg_hba.conf, описывающей аутентификацию по сертификату, параметр clientcert пред-
полагается равным 1, и его нельзя отключить, так как для этого метода клиентский сертификат
является обязательным. Метод cert отличается от простой проверки пригодности сертификата
clientcert только тем, что также проверяет, соответствует ли атрибут cn имени пользователя ба-
зы данных.
20.13. Аутентификация PAM
Данный метод аутентификации работает подобно методу password, но использует в качестве ме-
ханизма проверки подлинности PAM (Pluggable Authentication Modules, Подключаемые модули
аутентификации). По умолчанию имя службы PAM — postgresql. PAM используется только для
проверки пар “имя пользователя/пароль” и может дополнительно проверять имя или IP-адрес уда-
лённого компьютера. Поэтому пользователь должен уже существовать в базе данных, чтобы PAM
можно было использовать для аутентификации. За дополнительной информацией о PAM обрати-
тесь к Странице описания Linux-PAM.
Для аутентификации PAM доступны следующие параметры конфигурации:
pamservice
Имя службы PAM
pam_use_hostname
Указывает, предоставляется ли модулям PAM через поле PAM_RHOST IP-адрес либо имя удалён-
ного компьютера. По умолчанию выдаётся IP-адрес. Установите в этом параметре 1, чтобы ис-
пользовать имя узла. Разрешение имени узла может приводить к задержкам при подключении.
(Обычно конфигурации PAM не задействуют эту информацию, так что этот параметр следует
учитывать, только если создана специальная конфигурация, в которой он используется.)
Примечание
Если PAM настроен для чтения /etc/shadow, произойдёт сбой аутентификации, потому
что сервер PostgreSQL запущен не пользователем root. Однако это не имеет значения,
когда PAM настроен для использования LDAP или других методов аутентификации.
20.14. Аутентификация BSD
589Аутентификация кли-
ентского приложения
Данный метод аутентификации работает подобно методу password, но использует для проверки
пароля механизм аутентификации BSD. Аутентификация BSD используется только для проверки
пар “имя пользователя/пароль”. Поэтому роль пользователя должна уже существовать в базе дан-
ных, чтобы эта аутентификация была успешной. Механизм аутентификации BSD в настоящее вре-
мя может применяться только в OpenBSD.
Для аутентификации BSD в PostgreSQL применяется тип входа auth-postgresql и класс
postgresql, если он определён в login.conf. По умолчанию этот класс входа не существует и
PostgreSQL использует класс входа по умолчанию.
Примечание
Для использования аутентификации BSD необходимо сначала добавить учётную за-
пись пользователя PostgreSQL (то есть, пользователя ОС, запускающего сервер) в груп-
пу auth. Группа auth существует в системах OpenBSD по умолчанию.
20.15. Проблемы аутентификации
Сбои и другие проблемы с аутентификацией обычно дают о себе знать через сообщения об ошиб-
ках, например:
FATAL: no pg_hba.conf entry for host “123.123.123.123”, user “andym”, database
“testdb”
Это сообщение вы, скорее всего, получите, если сможете связаться с сервером, но он не захочет
с вами общаться. В сообщении содержится предположение, что сервер отказывает вам в подклю-
чении, поскольку не может найти подходящую запись в файле pg_hba.conf.
FATAL:
password authentication failed for user “andym”
Такое сообщение показывает, что вы связались с сервером, он готов общаться с вами, но только
после того, как вы прошли авторизацию по методу, указанному в файле pg_hba.conf. Проверьте
пароль, который вы вводите, и как настроен Kerberos или ident, если в сообщении упоминается
один из этих типов аутентификации.
FATAL:
user “andym” does not exist
Указанное имя пользователя базы данных не найдено.
FATAL:
database “testdb” does not exist
База данных, к которой вы пытаетесь подключиться, не существует. Имейте в виду, что если вы
не указали имя базы данных, по умолчанию берётся имя пользователя базы данных, что может
приводить к ошибкам.
Подсказка
В журнале сервера может содержаться больше информации, чем в выдаваемых кли-
енту сообщениях об ошибке аутентификации, поэтому, если вас интересуют причины
сбоя, проверьте журнал сервера.
590</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page19/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page18/">18</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page19/">19</a></li>
      
    
      
        <li><strong class="current-page">20</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page21/">21</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page22/">22</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page21/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>