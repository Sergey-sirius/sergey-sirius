<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page20/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page20/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-021/" title="Глава 21. Роли базы данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 21. Роли базы данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-021/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~12 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-021/" rel="bookmark" title="Глава 21. Роли базы данных" itemprop="url">Глава 21. Роли базы данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 21. Роли базы данных</p>

<p>PostgreSQL использует концепцию ролей (roles) для управления разрешениями на доступ к базе
данных. Роль можно рассматривать как пользователя базы данных или как группу пользователей,
в зависимости от того, как роль настроена. Роли могут владеть объектами базы данных (например,
таблицами и функциями) и выдавать другим ролям разрешения на доступ к этим объектам, управ-
ляя тем, кто имеет доступ и к каким объектам. Кроме того, можно предоставить одной роли член-
ство в другой роли, таким образом одна роль может использовать привилегии других ролей.
Концепция ролей включает в себя концепцию пользователей («users») и групп («groups»). До вер-
сии 8.1 в PostgreSQL пользователи и группы были отдельными сущностями, но теперь есть только
роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.
В этой главе описывается как создавать и управлять ролями. Дополнительную информацию о при-
вилегиях для ролей на различные объекты базы данных можно найти в Разделе 5.6.
21.1. Роли базы данных
Роли базы данных концептуально полностью отличаются от пользователей операционной системы.
На практике поддержание соответствия между ними может быть удобным, но не является обяза-
тельным. Роли базы данных являются глобальными для всей установки кластера базы данных (не
для отдельной базы данных). Для создания роли используется команда SQL CREATE ROLE:
CREATE ROLE имя;
Здесь имя соответствует правилам именования идентификаторов SQL: либо обычное, без специ-
альных символов, либо в двойных кавычках. (На практике, к команде обычно добавляются другие
указания, такие как LOGIN. Подробнее об этом ниже.) Для удаления роли используется команда
DROP ROLE:
DROP ROLE имя;
Для удобства поставляются программы createuser и dropuser, которые являются обёртками для
этих команд SQL и вызываются из командной строки оболочки ОС:
createuser имя
dropuser имя
Для получения списка существующих ролей, рассмотрите pg_roles системного каталога, напри-
мер:
SELECT rolname FROM pg_roles;
Метакоманда \du программы psql также полезна для получения списка существующих ролей.
Для начальной настройки кластера базы данных, система сразу после инициализации всегда со-
держит одну предопределённую роль. Эта роль является суперпользователем («superuser») и по
умолчанию (если не изменено при запуске initdb) имеет такое же имя, как и пользователь опера-
ционной системы, инициализирующий кластер баз данных. Обычно эта роль называется postgres.
Для создания других ролей, вначале нужно подключиться с этой ролью.
Каждое подключение к серверу базы данных выполняется под именем конкретной роли и эта роль
определяет начальные привилегии доступа для команд выполняемых в этом соединении. Имя ро-
ли для конкретного подключения к базе данных указывается клиентской программой характер-
ным для неё способом, таким образом инициируя запрос на подключение. Например, программа
psql для указания роли использует аргумент командной строки -U. Многие приложения предпо-
лагают, что по умолчанию нужно использовать имя пользователя операционной системы (включая
createuser и psql). Поэтому часто бывает удобным поддерживать соответствие между именами
ролей и именами пользователей операционной системы.
591Роли базы данных
Список доступных для подключения ролей, который могут использовать клиенты, определяется
конфигурацией аутентификации, как описывалось в Главе 20. (Поэтому, клиент не ограничен толь-
ко ролью, соответствующей имени пользователя операционной системы, также как и имя для вхо-
да может не соответствовать реальному имени.) Так как роль определяет набор доступных приви-
легий, очень важно тщательно настраивать привилегии в многопользовательской среде.
21.2. Атрибуты ролей
Роль базы данных может иметь атрибуты, определяющие её полномочия и взаимодействие с си-
стемой аутентификации клиентов.
Право подключения
Только роли с атрибутом LOGIN могут использоваться для начального подключения к базе дан-
ных. Роль с атрибутом LOGIN можно рассматривать как пользователя базы данных. Для созда-
ния роли такой роли можно использовать любой из вариантов:
CREATE ROLE имя LOGIN;
CREATE USER имя;
(Команда CREATE USER эквивалентна CREATE ROLE за исключением того, что CREATE USER по
умолчанию включает атрибут LOGIN, в то время как CREATE ROLE — нет.)
Статус суперпользователя
Суперпользователь базы данных обходит все проверки прав доступа, за исключением права на
вход в систему. Это опасная привилегия и она не должна использоваться небрежно. Лучше
всего выполнять большую часть работы не как суперпользователь. Для создания нового супер-
пользователя используется CREATE ROLE имя SUPERUSER. Это нужно выполнить из под роли,
которая также является суперпользователем.
Создание базы данных
Роль должна явно иметь разрешение на создание базы данных (за исключением суперпользо-
вателей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEDB.
Создание роли
Роль должна явно иметь разрешение на создание других ролей (за исключением суперполь-
зователей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEROLE. Роль с привилегией CREATEROLE может также изменять и удалять другие
роли, а также выдавать и отзывать членство в ролях. Однако, для создания, изменения, удале-
ния суперпользовательских ролей, а также изменения в них членства, требуется иметь статус
суперпользователя; привилегии CREATEROLE в таких случаях недостаточно.
Запуск репликации
Роль должна иметь явное разрешение на запуск потоковой репликации (за исключением су-
перпользователей, которые пропускают все проверки). Роль, используемая для потоковой ре-
пликации, также должна иметь атрибут LOGIN. Для создания такой роли используется CREATE
ROLE имя REPLICATION LOGIN.
Пароль
Пароль имеет значение, если метод аутентификации клиентов требует, чтобы пользователи
предоставляли пароль при подключении к базе данных. Методы аутентификации password и
md5 используют пароли. База данных и операционная система используют раздельные пароли.
Пароль указывается при создании роли: CREATE ROLE имя PASSWORD ‘строка’.
Атрибуты ролей могут быть изменены после создания командой ALTER ROLE.Более детальная ин-
формация в справке по командам CREATE ROLE и ALTER ROLE.
592Роли базы данных
Подсказка
Рекомендуется создать роль с привилегиями CREATEDB и CREATEROLE, но не суперполь-
зователя и в последующем использовать её для управления базами данных и ролями.
Такой подход позволит избежать опасностей, связанных с использованием полномочий
суперпользователя для задач, которые их не требуют.
На уровне ролей можно устанавливать многие конфигурационные параметры времени выполне-
ния, описанные в Главе 19. Например, если по некоторым причинам всякий раз при подключении
к базе данных требуется отключить использование индексов (подсказка: плохая идея) можно вы-
полнить:
ALTER ROLE myname SET enable_indexscan TO off;
Установленное значение параметра будет сохранено (но не будет применено сразу). Для по-
следующих подключений с этой ролью это будет выглядеть как выполнение команды SET
enable_indexscan TO off перед началом сессии. Но это только значение по умолчанию, в течение
сессии эту установку можно изменить. Для удаления установок на уровне ролей для параметров
конфигурации используется ALTER ROLE rolename RESET varname. Обратите внимание, что уста-
новка параметров конфигурации на уровне роли без привилегии LOGIN лишено смысла, т. к. они
никогда не будут применены,
21.3. Членство в роли
Часто бывает удобным сгруппировать пользователей для упрощения администрирования приви-
легий: привилегии выдаются или отзываются на всю группу. В PostgreSQL для этого создаётся
роль, которая представляет группу, а затем членство (membership) в этой группе выдаётся ролям
индивидуальных пользователей.
Для настройки групповой роли, сначала нужно создать саму роль:
CREATE ROLE имя;
Обычно групповая роль не имеет атрибута LOGIN, хотя при желании его можно установить.
После того как групповая роль создана, в неё можно добавлять или удалять членов, используя
команды GRANT и REVOKE:
GRANT group_role TO role1, … ;
REVOKE group_role FROM role1, … ;
Можно выдавать членство в групповой роли другим групповым ролям (потому что в действитель-
ности нет никаких различий между групповыми и не групповыми ролями). База данных не позво-
лит замкнуть предоставление членства по кругу. Также, не допускается выдача членства в роли
для PUBLIC.
Члены групповой роли могут использовать её привилегии двумя способами. Во-первых, каждый
член группы может явно выполнить SET ROLE, чтобы временно «стать» групповой ролью. В этом
состоянии, сессия базы данных использует полномочия групповой роли, вместо оригинальной ро-
ли, под которой был выполнен вход в систему. При этом для всех создаваемых объектов базы дан-
ных владельцем считается групповая, а не оригинальная роль. Во-вторых, роли, имеющие атрибут
INHERIT, автоматически используют привилегии всех ролей, членами которых они являются, в том
числе и унаследованными этими ролями привилегиями. Например:
CREATE ROLE
CREATE ROLE
CREATE ROLE
GRANT admin
GRANT wheel
joe LOGIN INHERIT;
admin NOINHERIT;
wheel NOINHERIT;
TO joe;
TO admin;
После подключения с ролью joe, сессия базы данных будет использовать полномочия выданные
напрямую joe и привилегии выданные admin, так как joe “наследует” привилегии admin. Однако
593Роли базы данных
привилегии выданные wheel не будут доступны, потому что, хотя joe неявно и является членом
wheel, это членство получено через роль admin, которая имеет атрибут NOINHERIT. После выпол-
нения команды:
SET ROLE admin;
сессия будет использовать только привилегии выданные admin, привилегии выданные joe не будут
доступны. После выполнения команды:
SET ROLE wheel;
сессия будет использовать только привилегии выданные wheel, привилегии joe и admin не будут
доступны. Начальный набор привилегий можно вернуть любой из команд:
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
Примечание
Команда SET ROLE в любой момент разрешает выбрать любую роль, прямым или кос-
венным членом которой является оригинальная роль, под которой был выполнен вход
в систему. Поэтому, в примере выше, не обязательно сначала становиться admin, перед
тем как стать wheel.
Примечание
В стандарте SQL есть чёткое различие между пользователями и ролями. При этом поль-
зователи не наследуют автоматически привилегии, а роли наследуют автоматически.
Такое поведение может быть получено в PostgreSQL, если для ролей, используемых как
роли в стандарте SQL, устанавливать атрибут INHERIT, а для ролей, используемых как
пользователи в стандарте SQL, устанавливать атрибут NOINHERIT. Однако, в PostgreSQL
все роли по умолчанию имеют атрибут INHERIT. Это сделано для обратной совместимо-
сти с версиями предшествующими 8.1, в которых пользователи всегда могли исполь-
зовать привилегии групп, членами которых они являются.
Атрибуты роли LOGIN, SUPERUSER, CREATEDB и CREATEROLE можно рассматривать как особые приви-
легии, но они никогда не наследуются, как обычные привилегии на объекты базы данных. Необхо-
димо через SET ROLE установить роль, имеющую один из этих атрибутов, чтобы им воспользовать-
ся. Продолжая предыдущий пример, можно установить атрибуты CREATEDB и CREATEROLE для роли
admin. Затем при входе с ролью joe, получить доступ к этим привилегиям будет возможно только
после выполнения SET ROLE admin.
Для удаления групповой роли используется DROP ROLE:
DROP ROLE имя;
Любое членство в групповой роли будет автоматически отозвано (в остальном на членов этой роли
это никак не повлияет).
21.4. Удаление ролей
Так как роли могут владеть объектами баз данных и иметь права доступа к объектам других, уда-
ление роли не сводится к немедленному действию DROP ROLE. Сначала должны быть удалены и
переданы другим владельцами все объекты, принадлежащие роли; также должны быть отозваны
все права, данные роли.
594Роли базы данных
Владение объектами можно передавать в индивидуальном порядке, применяя команду ALTER, на-
пример:
ALTER TABLE bobs_table OWNER TO alice;
Кроме того, для переназначения какой-либо другой роли владения сразу всеми объектами, при-
надлежащих удаляемой роли, можно применить команду REASSIGN OWNED. Так как REASSIGN
OWNED не может обращаться к объектам в других базах данных, её необходимо выполнить в каждой
базе, которая содержит объекты, принадлежащие этой роли. (Заметьте, что первая такая команда
REASSIGN OWNED изменит владельца для всех разделяемых между базами объектов, то есть для баз
данных или табличных пространств, принадлежащих удаляемой роли.)
После того как все ценные объекты будут переданы новым владельцам, все оставшиеся объекты,
принадлежащие удаляемой роли, могут быть удалены с помощью команды DROP OWNED. И эта
команда не может обращаться к объектам в других базах данных, так что её нужно запускать в
каждой базе, которая содержит объекты, принадлежащие роли. Также заметьте, что DROP OWNED не
удаляет табличные пространства или базы данных целиком, так что это необходимо сделать вруч-
ную, если роли принадлежат базы или табличные пространства, не переданные новым владельцам.
DROP OWNED также удаляет все права, которые даны целевой роли для объектов, не принадлежа-
щих ей. Так как REASSIGN OWNED такие объекты не затрагивает, обычно необходимо запустить и
REASSIGN OWNED, и DROP OWNED (в этом порядке!), чтобы полностью ликвидировать зависимости
удаляемой роли.
С учётом этого, общий рецепт удаления роли, которая владела объектами, вкратце таков:
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
– повторить предыдущие команды для каждой базы в кластере
DROP ROLE doomed_role;
Когда не все объекты нужно передать одному новому владельцу, лучше сначала вручную отрабо-
тать исключения, а в завершение выполнить показанные выше действия.
При попытке выполнить DROP ROLE для роли, у которой сохраняются зависимые объекты, будут
выданы сообщения, говорящие, какие объекты нужно передать другому владельцу или удалить.
21.5. Предопределённые роли
В PostgreSQL имеется набор предопределённых ролей, которые дают доступ к некоторым часто
востребованным, но не общедоступным функциям и данным. Администраторы могут назначать
(GRANT) эти роли пользователям и/или ролям в своей среде, таким образом открывая этим поль-
зователям доступ к указанной функциональности и информации.
Имеющиеся предопределённые роли описаны в Таблице 21.1. Заметьте, что конкретные разреше-
ния для каждой из предопределённых ролей в будущем могут изменяться по мере добавления до-
полнительной функциональности. Администраторы должны следить за этими изменениями, про-
сматривая замечания к выпускам.
Таблица 21.1. Предопределённые роли
Роль Разрешаемый доступ
pg_read_all_settings Читать все конфигурационные переменные, да-
же те, что обычно видны только суперпользова-
телям.
pg_read_all_stats Читать все представления pg_stat_* и использо-
вать различные расширения, связанные со ста-
тистикой, даже те, что обычно видны только су-
перпользователям.
595Роли базы данных
Роль Разрешаемый доступ
pg_stat_scan_tables Выполнять функции мониторинга, которые мо-
гут устанавливать блокировки ACCESS SHARE в
таблицах, возможно, на длительное время.
pg_signal_backend Передавать сигналы другим обслуживающим
процессам (например, отменять запрос, завер-
шать процесс).
pg_read_server_files Читать файлы в любом месте файловой системы,
куда имеет доступ СУБД на сервере, выполняя
COPY и другие функции работы с файлами.
pg_write_server_files Записывать файлы в любом месте файловой си-
стемы, куда имеет доступ СУБД на сервере, вы-
полняя COPY и другие функции работы с файла-
ми.
pg_execute_server_program Выполнять программы на сервере (от имени
пользователя, запускающего СУБД), так же, как
это делает команда COPY и другие функции, вы-
полняющие программы на стороне сервера.
pg_monitor Читать/выполнять различные представления и
функции для мониторинга. Эта роль включена в
роли pg_read_all_settings
, pg_read_all_
stats и pg_stat_scan_tables
.
Роли pg_read_server_files, pg_write_server_files и pg_execute_server_program предназначе-
ны для того, чтобы администраторы могли выделить доверенные, но не имеющие права суперполь-
зователей роли для доступа к файлам и запуска программ на сервере БД от имени пользователя,
запускающего СУБД. Так как эти роли могут напрямую обращаться к любым файлам в файловой
системе сервера, они обходят все проверки разрешений на уровне базы данных, а значит, восполь-
зовавшись ими, можно получить права суперпользователя. Поэтому назначать их пользователям
следует со всей осторожностью.
Роли pg_monitor, pg_read_all_settings, pg_read_all_stats и pg_stat_scan_tables созданы для
того, чтобы администраторы могли легко настроить роль для мониторинга сервера БД. Эти роли
наделяют своих членов набором общих прав, позволяющих читать различные полезные парамет-
ры конфигурации, статистику и другую системную информацию, что обычно доступно только су-
перпользователям.
Управлять членством в этих ролях следует осмотрительно, чтобы они использовались только по
необходимости и только с пониманием, что они открывают доступ к закрытой информации.
Администраторы могут давать пользователям доступ к этим ролям, используя команду GRANT:
GRANT pg_signal_backend TO admin_user;
21.6. Безопасность функций
Функции, триггеры и политики защиты на уровне строк позволяют пользователям внедрять код
в обслуживающие процессы, который может быть непреднамеренно выполнен другими пользова-
телями. Таким образом эти механизмы позволяют пользователям запускать «троянский код» от-
носительно просто. Лучшая защита от этого — строгое ограничение круга лиц, которые могут со-
здавать объекты. Там где это невозможно, пишите запросы так, чтобы они ссылались только на
объекты с доверенными владельцами. Удалите из search_path схему public и любые другие схемы,
в которых могут создавать объекты недоверенные пользователи.
Функции выполняются внутри серверного процесса с полномочиями пользователя операционной
системы, запускающего сервер базы данных. Если используемый для функций язык программи-
рования разрешает неконтролируемый доступ к памяти, то это даёт возможность изменить внут-
596Роли базы данных
ренние структуры данных сервера. Таким образом, помимо всего прочего, такие функции могут
обойти ограничения доступа к системе. Языки программирования, допускающие такой доступ,
считаются «недоверенными» и создавать функции на этих языках PostgreSQL разрешает только
суперпользователям.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-020/" title="Глава 20. Аутентификация клиентского приложения"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 20. Аутентификация клиентского приложения"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-020/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~37 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-020/" rel="bookmark" title="Глава 20. Аутентификация клиентского приложения" itemprop="url">Глава 20. Аутентификация клиентского приложения</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 20. Аутентификация клиентского приложения</p>

<p>При подключении к серверу базы данных, клиентское приложение указывает имя пользователя
PostgreSQL, так же как и при обычном входе пользователя на компьютер с ОС Unix. При работе в
среде SQL по имени пользователя определяется, какие у него есть права доступа к объектам базы
данных (подробнее это описывается в Главе 21). Следовательно, важно указать на этом этапе, к
каким базам пользователь имеет право подключиться.
Примечание
Как можно узнать из Главы  21, PostgreSQL управляет правами и привилегиями, ис-
пользуя так называемые «роли». В этой главе под пользователем мы подразумеваем
«роль с привилегией LOGIN».
Аутентификация это процесс идентификации клиента сервером базы данных, а также определе-
ние того, может ли клиентское приложение (или пользователь запустивший приложение) подклю-
читься с указанным именем пользователя.
PostgreSQL предлагает несколько различных методов аутентификации клиентов. Метод аутенти-
фикации конкретного клиентского соединения может основываться на адресе компьютера клиен-
та, имени базы данных, имени пользователя.
Имена пользователей базы данных PostgreSQL не имеют прямой связи с пользователями операци-
онной системы на которой запущен сервер. Если у всех пользователей базы данных заведена учёт-
ная запись в операционной системе сервера, то имеет смысл назначить им точно такие же име-
на для входа в PostgreSQL. Однако, сервер, принимающий удалённые подключения, может иметь
большое количество пользователей базы данных, у которых нет учётной записи в ОС. В таких слу-
чаях не требуется соответствие между именами пользователей базы данных и именами пользова-
телей операционной системы.
20.1. Файл pg_hba.conf
Аутентификация клиентов управляется конфигурационным файлом, который традиционно назы-
вается pg_hba.conf и расположен в каталоге с данными кластера базы данных. (HBA расшифро-
вывается как host-based authentication — аутентификации по имени узла.) Файл pg_hba.conf, со
стандартным содержимым, создаётся командой initdb при инициализации каталога с данными.
Однако его можно разместить в любом другом месте; см. конфигурационный параметр hba_file.
Обычный формат файла pg_hba.conf представляет собой набор записей, по одной в строке. Пустые
строки игнорируются, как и любой текст комментария после знака #. Записи не продолжаются
на следующей строке. Записи состоят из некоторого количества полей, разделённых между собой
пробелом и/или tabs. В полях могут быть использованы пробелы, если они взяты в кавычки. Если в
кавычки берётся какое-либо зарезервированное слово в поле базы данных, пользователя или адре-
сации (например, all или replication), то слово теряет своё особое значение и просто обозначает
базу данных, пользователя или сервер с данным именем.
Каждая запись обозначает тип соединения, диапазон IP-адресов клиента (если он соотносится с
типом соединения), имя базы данных, имя пользователя, и способ аутентификации, который бу-
дет использован для соединения в соответствии с этими параметрами. Первая запись с соответ-
ствующим типом соединения, адресом клиента, указанной базой данных и именем пользователя
применяется для аутентификации. Процедур «fall-through» или «backup» не предусмотрено: если
выбрана запись и аутентификация не прошла, последующие записи не рассматриваются. Если же
ни одна из записей не подошла, в доступе будет отказано.
Запись может быть сделана в одном из семи форматов:
572Аутентификация кли-
ентского приложения
local
база
host
база
hostssl
база
hostnossl база
host
база
аутентификации]
hostssl
база
аутентификации]
hostnossl база
аутентификации]
пользователь
пользователь
пользователь
пользователь
пользователь метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
IP-адрес IP-маска метод-аутентификации [параметры-
пользователь IP-адрес
IP-маска
метод-аутентификации
[параметры-
пользователь IP-адрес
IP-маска
метод-аутентификации
[параметры-
Значения полей описаны ниже:
local
Управляет подключениями через Unix-сокеты. Без подобной записи подключения через Unix-
сокеты невозможны.
host
Управляет подключениями, устанавливаемыми по TCP/IP. Записи host соответствуют подклю-
чениям с SSL и без SSL.
Примечание
Удалённое соединение по TCP/IP невозможно, если сервер запущен без определе-
ния соответствующих значений для параметра конфигурации listen_addresses, по-
скольку по умолчанию система принимает подключения по TCP/IP только для ло-
кального адреса замыкания localhost.
hostssl
Управляет подключениями, устанавливаемыми по TCP/IP с применением шифрования SSL.
Чтобы использовать эту возможность, сервер должен быть собран с поддержкой SSL. Более
того, механизм SSL должен быть включён параметром конфигурации ssl (подробнее об этом в
Разделе 18.9). В противном случае запись hostssl игнорируется (не считая предупреждения о
том, что ей не будут соответствовать никакие подключения).
hostnossl
Этот тип записей противоположен hostssl, ему соответствуют только подключения по TCP/IP
без шифрования SSL.
база
Определяет, каким именам баз данных соответствует эта запись. Значение all определяет, что
подходят все базы данных. Значение sameuser определяет, что данная запись соответствует
только, если имя запрашиваемой базы данных совпадает с именем запрашиваемого пользова-
теля. Значение samerole определяет, что запрашиваемый пользователь должен быть членом
роли с таким же именем, как и у запрашиваемой базы данных. (samegroup - это устаревший, но
допустимый вариант значения samerole.) Суперпользователи не становятся членами роли ав-
томатически из-за samerole, а только если они являются явными членами роли, прямо или кос-
венно, и не только из-за того, что они суперпользователи. Значение replication показывает,
что запись соответствует, если запрашивается подключение физической репликации (имейте в
виду, что подключения репликации не определяют какую-то конкретную базу данных). В про-
тивном случае, это имя определённой базы данных PostgreSQL. Несколько имён баз данных
можно указать, разделяя их запятыми. Файл, содержащий имена баз данных, можно указать,
поставив знак @ в начале его имени.
573Аутентификация кли-
ентского приложения
пользователь
Указывает, какому имени (или именам) пользователя базы данных соответствует эта запись.
Значение all показывает, что это подходит всем пользователям. В противном случае, это либо
имя конкретного пользователя базы данных, или имя группы, в начале которого стоит знак
+. (Напомним, что в PostgreSQL нет никакой разницы между пользователем и группой; знак +
означает « совпадение любых ролей, которые прямо или косвенно являются членами роли»,
тогда как имя без знака + является подходящей только для этой конкретной роли.) В связи
с этим, суперпользователь рассматривается как член роли, только если он явно является чле-
ном этой роли, прямо или косвенно, а не только потому, что он является суперпользователем.
Несколько имён пользователей можно указать, разделяя их запятыми. Файл, содержащий име-
на пользователей, можно указать, поставив знак @ в начале его имени.
адрес
Указывает адрес (или адреса) клиентской машины, которым соответствует данная запись. Это
поле может содержать или имя компьютера, или диапазон IP-адресов, или одно из нижеупомя-
нутых ключевых слов.
Диапазон IP-адресов указывается в виде начального адреса диапазона, дополненного косой
чертой (/) и длиной маски CIDR. Длина маски задаёт количество старших битов клиентского IP-
адреса, которые должны совпадать с битами IP-адреса диапазона. Биты, находящиеся правее, в
указанном IP-адресе должны быть нулевыми. Между IP-адресом, знаком / и длиной маски CIDR
не должно быть пробельных символов.
Типичные примеры диапазонов адресов IPv4, указанных таким образом: 172.20.143.89/32 для
одного компьютера, 172.20.143.0/24 для небольшой и 10.6.0.0/16 для крупной сети. Диапа-
зон адресов IPv6 может выглядеть как ::1/128 для одного компьютера (это адрес замыкания
IPv6) или как fe80::7a31:c1ff:0000:0000/96 для небольшой сети. 0.0.0.0/0 представляет все
адреса IPv4, а ::0/0 — все адреса IPv6. Чтобы указать один компьютер, используйте длину мас-
ки 32 для IPv4 или 128 для IPv6. Опускать замыкающие нули в сетевом адресе нельзя.
Запись, сделанная в формате IPv4, подойдёт только для подключений по IPv4, а запись в фор-
мате IPv6 подойдёт только для подключений по IPv6, даже если представленный адрес нахо-
дится в диапазоне IPv4-в-IPv6. Имейте в виду, что записи в формате IPv6 не будут приниматься,
если системная библиотека С не поддерживает адреса IPv6.
Вы также можете прописать значение all, чтобы указать любой IP-адрес, samehost, чтобы ука-
зать любые IP-адреса данного сервера, или samenet, чтобы указать любой адрес любой подсети,
к которой сервер подключён напрямую.
Если определено имя компьютера (всё, что не является диапазоном IP-адресов или специаль-
ным ключевым словом, воспринимается как имя компьютера), то оно сравнивается с результа-
том обратного преобразования IP-адреса клиента (например, обратного DNS-запроса, если ис-
пользуется DNS). При сравнении имён компьютеров регистр не учитывается. Если имена сов-
пали, выполняется прямое преобразование имени (например, прямой DNS-запрос) для провер-
ки, относится ли клиентский IP-адрес к адресам, соответствующим имени. Если двусторонняя
проверка пройдена, запись считается соответствующей компьютеру. (В качестве имени узла
в файле pg_hba.conf должно указываться то, что возвращается при преобразовании IP-адре-
са клиента в имя, иначе строка не будет соответствовать узлу. Некоторые базы данных имён
позволяют связать с одним IP-адресом несколько имён узлов, но операционная система при
попытке разрешить IP-адрес возвращает только одно имя.)
Указание имени, начинающееся с точки (.), соответствует суффиксу актуального имени узла.
Так, .example.com будет соответствовать foo.example.com (а не только example.com).
Когда в pg_hba.conf указываются имена узлов, следует добиться, чтобы разрешение имён вы-
полнялось достаточно быстро. Для этого может быть полезен локальный кеш разрешения имён,
например, nscd. Вы также можете включить конфигурационный параметр log_hostname, чтобы
видеть в журналах имя компьютера клиента вместо IP-адреса.
574Аутентификация кли-
ентского приложения
Это поле применимо только к записям host, hostssl и hostnossl.
Примечание
Пользователи часто задаются вопросом, почему имена серверов обрабатываются
таким сложным, на первый взгляд, способом, с разрешением двух имён, включая
обратный запрос клиентского IP-адреса. Это усложняет процесс в случае, если об-
ратная DNS-запись клиента не установлена или включает в себя нежелательное
имя узла. Такой способ избран, в первую очередь, для повышения эффективности:
в этом случае соединение требует максимум два запроса разрешения, один прямой
и один обратный. Если есть проблема разрешения с каким-то адресом, то она оста-
ётся проблемой этого клиента. Гипотетически, могла бы быть реализована возмож-
ность во время каждой попытки соединения выполнять только прямой запрос для
разрешения каждого имени сервера, упомянутого в pg_hba.conf. Но если список
имён велик, процесс был бы довольно медленным, а в случае наличия проблемы
разрешения у одного имени сервера, это стало бы общей проблемой.
Также обратный запрос необходим для того, чтобы реализовать возможность со-
ответствия суффиксов, поскольку для сопоставления с шаблоном требуется знать
фактическое имя компьютера клиента.
Обратите внимание, что такое поведение согласуется с другими популярными ре-
ализациями контроля доступа на основе имён, такими как Apache HTTP Server и
TCP Wrappers.
IP-адрес
IP-маска
Эти два поля могут быть использованы как альтернатива записи IP-адрес/длина-маски. Вместо
того, чтобы указывать длину маски, в отдельном столбце указывается сама маска. Например,
255.0.0.0 представляет собой маску CIDR для IPv4 длиной 8 бит, а 255.255.255.255 представ-
ляет маску CIDR длиной 32 бита.
Эти поля применимы только к записям host, hostssl и hostnossl.
метод-аутентификации
Указывает метод аутентификации, когда подключение соответствует этой записи. Варианты
выбора приводятся ниже; подробности в Разделе 20.3.
trust
Разрешает безусловное подключение. Этот метод позволяет тому, кто может подключить-
ся к серверу с базой данных PostgreSQL, войти под любым желаемым пользователем
PostgreSQL без введения пароля и без какой-либо другой аутентификации. За подробностя-
ми обратитесь к Разделу 20.4.
reject
Отклоняет подключение безусловно. Эта возможность полезна для «фильтрации» некото-
рых серверов группы, например, строка reject может отклонить попытку подключения од-
ного компьютера, при этом следующая строка позволяет подключиться остальным компью-
терам в той же сети.
scram-sha-256
Проверяет пароль пользователя, производя аутентификацию SCRAM-SHA-256. За подроб-
ностями обратитесь к Разделу 20.5.
md5
Проверяет пароль пользователя, производя аутентификацию SCRAM-SHA-256 или MD5. За
подробностями обратитесь к Разделу 20.5.
575Аутентификация кли-
ентского приложения
password
Требует для аутентификации введения клиентом незашифрованного пароля. Поскольку па-
роль посылается простым текстом через сеть, такой способ не стоит использовать, если сеть
не вызывает доверия. За подробностями обратитесь к Разделу 20.5.
gss
Для аутентификации пользователя использует GSSAPI. Этот способ доступен только для
подключений по TCP/IP. За подробностями обратитесь к Разделу 20.6.
sspi
Для аутентификации пользователя использует SSPI. Способ доступен только для Windows.
За подробностями обратитесь к Разделу 20.7.
ident
Получает имя пользователя операционной системы клиента, связываясь с сервером Ident,
и проверяет, соответствует ли оно имени пользователя базы данных. Аутентификация ident
может использоваться только для подключений по TCP/IP. Для локальных подключений при-
меняется аутентификация peer. За подробностями обратитесь к Разделу 20.8.
peer
Получает имя пользователя операционной системы клиента из операционной системы и
проверяет, соответствует ли оно имени пользователя запрашиваемой базы данных. Доступ-
но только для локальных подключений. За подробностями обратитесь к Разделу 20.9.
ldap
Проводит аутентификацию, используя сервер LDAP. За подробностями обратитесь к Разде-
лу 20.10.
radius
Проводит аутентификацию, используя сервер RADIUS. За подробностями обратитесь к Раз-
делу 20.11
cert
Проводит аутентификацию, используя клиентский сертификат SSL. За подробностями об-
ратитесь к Разделу 20.12
pam
Проводит аутентификацию, используя службу подключаемых модулей аутентификации
(PAM), предоставляемую операционной системой. За подробностями обратитесь к Разде-
лу 20.13.
bsd
Проводит аутентификацию, используя службу аутентификации BSD, предоставляемую опе-
рационной системой. За подробностями обратитесь к Разделу 20.14.
.
параметры-аутентификации
После поля метод-аутентификации может идти поле (поля) вида имя=значение, определяющее
параметры метода аутентификации. Подробнее о параметрах, доступных для различных мето-
дов аутентификации, рассказывается ниже.
Помимо описанных далее параметров, относящихся к различным методам, есть один общий
параметр аутентификации clientcert, который можно задать в любой записи hostssl. Если он
равен 1, клиент должен представить подходящий (доверенный) сертификат SSL, в дополнение
к другим требованиям метода проверки подлинности.
576Аутентификация кли-
ентского приложения
Файлы, включённые в конструкции, начинающиеся с @, читаются, как список имён, разделённых
запятыми или пробелами. Комментарии предваряются знаком #, как и в файле pg_hba.conf, и
вложенные @ конструкции допустимы. Если только имя файла, начинающегося с @ не является
абсолютным путём.
Поскольку записи файла pg_hba.conf рассматриваются последовательно для каждого подключе-
ния, порядок записей имеет большое значение. Обычно, более ранние записи определяют чёткие
критерии для соответствия параметров подключения, но для методов аутентификации допускают
послабления. Напротив, записи более поздние смягчают требования к соответствию параметров
подключения, но усиливают их в отношении методов аутентификации. Например, некто желает
использовать trust аутентификацию для локального подключения по TCP/IP, но при этом запра-
шивать пароль для удалённых подключений по TCP/IP. В этом случае, запись, указывающая trust
аутентификацию для подключения адреса 127.0.0.1 должна появиться до записи, определяющей
аутентификацию через пароль для более широкого диапазона клиентских IP-адресов.
Файл pg_hba.conf прочитывается во время запуска и в момент получения основным процессом
сервера сигнала SIGHUP. Если вы редактируете файл во время работы системы, необходимо по-
слать сигнал процессу postmaster (используя pg_ctl reload или kill -HUP), чтобы он прочел об-
новленный файл.
Примечание
Предыдущее утверждение не касается Microsoft Windows: там любые изменения в
pg_hba.conf сразу применяются к последующим подключениям.
Системное представление pg_hba_file_rules может быть полезно для предварительной проверки
изменений в файле pg_hba.conf или для диагностики проблем, когда перезагрузка этого файла
не даёт желаемого эффекта. Строки в этом представлении, содержащие в поле error не NULL,
указывают на проблемы в соответствующих строках файла.
Подсказка
Чтобы подключиться к конкретной базе данных, пользователь не только должен прой-
ти все проверки файла pg_hba.conf, но должен иметь привилегию CONNECT для под-
ключения к базе данных. Если вы хотите ограничить доступ к базам данных для опре-
делённых пользователей, проще предоставить/отозвать привилегию CONNECT, нежели
устанавливать правила в записях файла pg_hba.conf.
Примеры записей файла pg_hba.conf показаны в Примере 20.1. Обратитесь к следующему разделу
за более подробной информацией по методам аутентификации.
Пример 20.1. Примеры записей pg_hba.conf</p>
<h1 id="Позволяет-любому-пользователю-локальной-системы-подключаться">Позволяет любому пользователю локальной системы подключаться</h1>
<h1 id="к-любой-базе-данных-используя-любое-имя-пользователя-баз-данных-через">к любой базе данных, используя любое имя пользователя баз данных, через</h1>
<h1 id="unix-сокеты-по-умолчанию-для-локальных-подключений">Unix-сокеты (по умолчанию для локальных подключений).</h1>
<p>#</p>
<h1 id="type-database">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
local
all
all
trust</p>
<h1 id="То-же-но-для-локальных-замкнутых-подключений-по-tcpip">То же, но для локальных замкнутых подключений по TCP/IP.</h1>
<p>#</p>
<h1 id="type-database-1">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
all
all
127.0.0.1/32</p>
<h1 id="То-же-что-и-в-предыдущей-строке-но-с-указанием">То же, что и в предыдущей строке, но с указанием</h1>
<h1 id="сетевой-маски-в-отдельном-столбце">сетевой маски в отдельном столбце</h1>
<p>#
577
METHOD
trustАутентификация кли-
ентского приложения</p>
<h1 id="type">TYPE</h1>
<p>host
DATABASE
all</p>
<h1 id="То-же-для-ipv6">То же для IPv6.</h1>
<p>#</p>
<h1 id="type-database-2">TYPE DATABASE</h1>
<p>host
all
USER
all IP-ADDRESS
127.0.0.1
USER
all ADDRESS
::1/128
IP-MASK
255.255.255.255
METHOD
trust
METHOD
trust</p>
<h1 id="То-же-самое-но-с-использованием-имени-компьютера">То же самое, но с использованием имени компьютера</h1>
<h1 id="обычно-покрывает-и-ipv4-и-ipv6">(обычно покрывает и IPv4, и IPv6).</h1>
<p>#</p>
<h1 id="type-database-3">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
all
all
localhost METHOD
trust</p>
<h1 id="Позволяет-любому-пользователю-любого-компьютера-с-ip-адресом">Позволяет любому пользователю любого компьютера с IP-адресом</h1>
<h1 id="19216893x-подключаться-к-базе-данных-postgres">192.168.93.x подключаться к базе данных “postgres”</h1>
<h1 id="с-именем-которое-сообщает-для-данного-подключения-ident">с именем, которое сообщает для данного подключения ident</h1>
<h1 id="как-правило-имя-пользователя-операционной-системы">(как правило, имя пользователя операционной системы).</h1>
<p>#</p>
<h1 id="type-database-4">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
postgres
all
192.168.93.0/24 METHOD
ident</p>
<h1 id="Позволяет-любому-пользователю-компьютера-1921681210-подключаться">Позволяет любому пользователю компьютера 192.168.12.10 подключаться</h1>
<h1 id="к-базе-данных-postgres-если-он-передаёт-правильный-пароль">к базе данных “postgres”, если он передаёт правильный пароль.</h1>
<p>#</p>
<h1 id="type-database-5">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
postgres
all
192.168.12.10/32
scram-sha-256</p>
<h1 id="Позволяет-любым-пользователям-с-компьютеров-в-домене-examplecom">Позволяет любым пользователям с компьютеров в домене example.com</h1>
<h1 id="подключаться-к-любой-базе-данных-если-передаётся-правильный-пароль">подключаться к любой базе данных, если передаётся правильный пароль.</h1>
<p>#</p>
<h1 id="Для-всех-пользователей-требуется-аутентификация-scram-за-исключением">Для всех пользователей требуется аутентификация SCRAM, за исключением</h1>
<h1 id="пользователя-mike-который-использует-старый-клиент-не-поддерживающий">пользователя ‘mike’, который использует старый клиент, не поддерживающий</h1>
<h1 id="аутентификацию-scram">аутентификацию SCRAM.</h1>
<p>#</p>
<h1 id="type-database-6">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
mike
.example.com
md5
host
all
all
.example.com
scram-sha-256</p>
<h1 id="В-случае-отсутствия-предшествующих-строчек-с-host-следующие-две-строки">В случае отсутствия предшествующих строчек с “host”, следующие две строки</h1>
<h1 id="откажут-в-подключении-с-192168541-поскольку-данная-запись-будет">откажут в подключении с 192.168.54.1 (поскольку данная запись будет</h1>
<h1 id="выбрана-первой-но-разрешат-подключения-gssapi-с-любых-других">выбрана первой), но разрешат подключения GSSAPI с любых других</h1>
<h1 id="адресов-С-нулевой-маской-ни-один-бит-из-ip-адреса-компьютера">адресов. С нулевой маской ни один бит из IP-адреса компьютера</h1>
<h1 id="не-учитывается-так-что-этой-строке-соответствует-любой-компьютер">не учитывается, так что этой строке соответствует любой компьютер.</h1>
<p>#</p>
<h1 id="type-database-7">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
all
192.168.54.1/32
reject
host
all
all
0.0.0.0/0
gss</p>
<h1 id="Позволяет-пользователям-с-любого-компьютера-192168xx-подключаться">Позволяет пользователям с любого компьютера 192.168.x.x подключаться</h1>
<h1 id="к-любой-базе-данных-если-они-проходят-проверку-ident-Если-же-ident">к любой базе данных, если они проходят проверку ident. Если же ident</h1>
<h1 id="говорит-например-что-это-пользователь-bryanh-и-он-запрашивает">говорит, например, что это пользователь “bryanh” и он запрашивает</h1>
<h1 id="подключение-как-пользователь-postgresql-guest1-подключение">подключение как пользователь PostgreSQL “guest1”, подключение</h1>
<h1 id="будет-разрешено-если-в-файле-pg_identconf-есть-сопоставление">будет разрешено, если в файле pg_ident.conf есть сопоставление</h1>
<h1 id="omicron-позволяющее-пользователю-bryanh-подключаться-как-guest1">“omicron”, позволяющее пользователю “bryanh” подключаться как “guest1”.</h1>
<p>#</p>
<h1 id="type-database-8">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
all
192.168.0.0/16
ident map=omicron
578Аутентификация кли-
ентского приложения</p>
<h1 id="Если-для-локальных-подключений-предусмотрены-только-эти-три-строки">Если для локальных подключений предусмотрены только эти три строки,</h1>
<h1 id="они-позволят-локальным-пользователям-подключаться-только-к-своим">они позволят локальным пользователям подключаться только к своим</h1>
<h1 id="базам-данных-базам-данных-с-именами-совпадающими-с">базам данных (базам данных с именами, совпадающими с</h1>
<h1 id="именами-пользователей-баз-данных-кроме-администраторов">именами пользователей баз данных), кроме администраторов</h1>
<h1 id="или-членов-роли-support-которые-могут-подключиться-к-любой-БД">или членов роли “support”, которые могут подключиться к любой БД.</h1>
<h1 id="Список-имён-администраторов-содержится-в-файле-pgdataadmins">Список имён администраторов содержится в файле $PGDATA/admins.</h1>
<h1 id="Пароли-запрашиваются-в-любом-случае">Пароли запрашиваются в любом случае.</h1>
<p>#</p>
<h1 id="type-database-9">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
local
sameuser
all
md5
local
all
@admins
md5
local
all
+support
md5</p>
<h1 id="Последние-две-строчки-выше-могут-быть-объединены-в-одну">Последние две строчки выше могут быть объединены в одну:</h1>
<p>local
all
@admins,+support
md5</p>
<h1 id="В-столбце-database-также-могут-указываться-списки-и-имена-файлов">В столбце DATABASE также могут указываться списки и имена файлов:</h1>
<p>local
db1,db2,@demodbs all
md5
20.2. Файл сопоставления имён пользователей
Когда используется внешняя система аутентификации, например Ident или GSSAPI, имя пользова-
теля операционной системы, устанавливающего подключение, может не совпадать с именем це-
левого пользователя (роли) базы данных. В этом случае можно применить сопоставление имён
пользователей, чтобы сменить имя пользователя операционной системы на имя пользователя БД.
Чтобы задействовать сопоставление имён, укажите map=имя-сопоставления в поле параметров в
pg_hba.conf. Этот параметр поддерживается для всех методов аутентификации, которые принима-
ют внешние имена пользователей. Так как для разных подключений могут требоваться разные со-
поставления, сопоставление определяется параметром имя-сопоставления в pg_hba.conf для каж-
дого отдельного подключения.
Сопоставления имён пользователя определяются в файле сопоставления ident, который по умол-
чанию называется pg_ident.confи хранится в каталоге данных кластера. (Файл сопоставления мо-
жет быть помещён и в другое место, обратитесь к информации о настройке параметра ident_file.)
Файл сопоставления ident содержит строки общей формы:
map-name system-username database-username
Комментарии и пробелы применяются так же, как и в файле pg_hba.conf. map-name является про-
извольным именем, на которое будет ссылаться файл сопоставления файла pg_hba.conf. Два дру-
гих поля указывают имя пользователя операционной системы и соответствующее имя пользовате-
ля базы данных. Имя map-name может быть использовано неоднократно, чтобы указывать множе-
ственные сопоставления пользовательских имён в рамках одного файла сопоставления.
Нет никаких ограничений по количеству пользователей баз данных, на которые может ссылаться
пользователь операционной системы, и наоборот. Тем не менее, записи в файле скорее подразу-
мевают, что « пользователь этой операционной системы может подключиться как пользователь
этой базы данных», нежели показывают, что эти имена пользователей эквивалентны. Подключе-
ние разрешается, если существует запись в файле сопоставления, соединяющая имя, полученное
от внешней системы аутентификации, с именем пользователя базы данных, под которым пользо-
ватель хочет подключиться.
Если поле system-username начинается со знака (/), оставшаяся его часть рассматривается как
регулярное выражение. (Подробнее синтаксис регулярных выражений PostgreSQL описан в Под-
разделе 9.7.3.1.) Регулярное выражение может включать в себя одну группу, или заключённое в
скобки подвыражение, на которое можно сослаться в поле database-username, написав \1 (с одной
обратной косой). Это позволяет сопоставить несколько имён пользователя с одной строкой, что
особенно удобно для простых замен. Например, эти строки
579Аутентификация кли-
ентского приложения
mymap
mymap
/^(.<em>)@mydomain.com$
/^(.</em>)@otherdomain.com$
\1
guest
удалят часть домена для имён пользователей, которые заканчиваются на @mydomain.com, и позво-
лят пользователям, чьё имя пользователя системы заканчивается на @otherdomain.com, подклю-
читься как guest.
Подсказка
Помните, что по умолчанию, регулярное выражение может совпасть только с частью
строки. Разумным выходом будет использование символов ^ и $, как показано в при-
мере выше, для принудительного совпадения со всем именем пользователя операци-
онной системы
Файл pg_ident.conf читается при запуске системы, а также в тот момент, когда основной сервер
получает сигнал SIGHUP. Если вы редактируете файл во время работы системы, необходимо по-
слать сигнал процессу postmaster (используя pg_ctl reload или kill -HUP), чтобы он прочел об-
новленный файл.
Файл pg_ident.conf, который может быть использован в сочетании с файлом pg_hba.conf (см.
Пример 20.1), показан в Примере 20.2. В этом примере любым пользователям компьютеров в сети
192.168 с именами, отличными от bryanh, ann или robert, будет отказано в доступе. Пользователь
системы robert получит доступ только тогда, когда подключается как пользователь PostgreSQL
bob, а не как robert, или какой-либо другой пользователь. Пользователь ann сможет подключиться
только как ann. Пользователь bryanh сможет подключиться как bryanh или как guest1.
Пример 20.2. Пример файла pg_ident.conf</p>
<h1 id="mapname">MAPNAME</h1>
<p>SYSTEM-USERNAME
PG-USERNAME
omicron
bryanh
bryanh
omicron
ann
ann</p>
<h1 id="на-этих-машинах-bob-может-подключаться-как-robert">на этих машинах bob может подключаться как robert</h1>
<p>omicron
robert
bob</p>
<h1 id="bryanh-также-может-подключаться-как-guest1">bryanh также может подключаться как guest1</h1>
<p>omicron
bryanh
guest1
20.3. Методы аутентификации
Более подробно методы аутентификации рассматриваются в следующих разделах.
20.4. Аутентификация trust
Когда указан способ аутентификации trust, PostgreSQL предполагает, что любой подключающий-
ся к серверу авторизован для доступа к базе данных вне зависимости от указанного имени пользо-
вателя базы данных (даже если это имя суперпользователя). Конечно, ограничения, прописанные
в столбцах база и пользователь, продолжают работать. Этот метод должен применяться только в
том случае, когда на уровне операционной системы обеспечена адекватная защита от подключе-
ний к серверу.
Аутентификация trust очень удобна для локальных подключений на однопользовательской
рабочей станции. Но сам по себе этот метод обычно не подходит для машин с нескольки-
ми пользователями. Однако вы можете использовать trust даже на многопользовательской
машине, если ограничите доступ к файлу Unix-сокета сервера на уровне файловой системы.
Для этого установите конфигурационные параметры unix_socket_permissions (и, возможно,
unix_socket_group) как описано в Разделе 19.3. Либо вы можете установить конфигурационный
параметр unix_socket_directories, чтобы разместить файл сокета в должным образом защищён-
ном каталоге.
580Аутентификация кли-
ентского приложения
Установка разрешений на уровне файловой системы помогает только в случае подключений через
Unix-сокеты. На локальные подключения по TCP/IP ограничения файловой системы не влияют.
Поэтому, если вы хотите использовать разрешения файловой системы для обеспечения локальной
безопасности, уберите строку host … 127.0.0.1 … из pg_hba.conf или смените метод аутен-
тификации.
Метод аутентификации trust для подключений по TCP/IP допустим только в случае, если вы до-
веряете каждому пользователю компьютера, получившему разрешение на подключение к серверу
строками файла pg_hba.conf, указывающими метод trust. Не стоит использовать trust для любых
подключений по TCP/IP, отличных от localhost (127.0.0.1).
20.5. Аутентификация password
Существует несколько методов аутентификации по паролю. Они работают примерно одинаково,
но различаются тем, как пароли пользователей хранятся на сервере и как пароль передаётся от
клиента по каналу связи.
scram-sha-256
С методом scram-sha-256 выполняется аутентификация SCRAM-SHA-256, как описано в RFC</p>
<ol>
  <li>Она производится по схеме вызов-ответ, которая предотвращает перехват паролей через
недоверенные соединения и поддерживает хранение паролей на сервере в виде криптографи-
ческого хеша, что считается безопасным.
Это наиболее безопасный из существующих на данный момент методов, но он не поддержива-
ется старыми клиентскими библиотеками.
md5
Для метода md5 реализован менее безопасный механизм вызов-ответ. Он предотвращает пере-
хват паролей и предусматривает хранение паролей на сервере в зашифрованном виде, но не
защищает в случае похищения хешей паролей с сервера. Кроме того, алгоритм хеширования
MD5 в наши дни уже может не защитить от целенаправленных атак.
Метод md5 несовместим с функциональностью db_user_namespace.
Для облегчения перехода от метода md5 к более новому методу SCRAM, если в качестве метода
аутентификации в pg_hba.conf указан md5, но пароль пользователя на сервере зашифрован для
SCRAM (см. ниже), автоматически будет производиться аутентификация на базе SCRAM.
password
С методом password пароль передаётся в открытом виде и поэтому является уязвимым для атак
с перехватом трафика. Его следует избегать всегда, если это возможно. Однако, если подклю-
чение защищено SSL, метод password может быть безопасен. (Хотя аутентификация по серти-
фикату SSL может быть лучшим выбором когда используется SSL).
Пароли баз данных PostgreSQL отделены от паролей пользователей операционной системы. Па-
роли всех пользователей базы данных хранятся в системном каталоге pg_authid. Управлять паро-
лями можно либо используя SQL-команды CREATE ROLE и ALTER ROLE, например, CREATE ROLE
foo WITH LOGIN PASSWORD ‘secret’, либо с помощью команды psql \password. Если пароль для
пользователя не задан, вместо него хранится NULL, и пройти аутентификацию по паролю этот
пользователь не сможет.
Доступность различных методов аутентификации по паролю зависит от того, как пароли пользо-
вателей шифруются на сервере (или, говоря точнее, хешируются). Это определяется параметром
конфигурации password_encryption в момент назначения пароля. Если пароль шифруется в режи-
ме scram-sha-256, его можно будет использовать для методов аутентификации scram-sha-256 и
password (но в последнем случае он будет передаваться открытым текстом). В случае указания ме-
тода аутентификации md5 при этом произойдёт автоматический переход к использованию scram-
sha-256, как сказано выше, так что этот вариант тоже будет работать. Если пароль шифруется в
581Аутентификация кли-
ентского приложения
режиме md5, его можно будет использовать только для методов аутентификации md5 и password (и
в последнем случае он так же будет передаваться открытым текстом). (Ранние версии PostgreSQL
поддерживали хранение паролей на сервере в открытом виде, но теперь это невозможно.) Чтобы
просмотреть хранящиеся в БД хеши паролей, обратитесь к системному каталогу pg_authid.
Для перевода существующей инсталляции с md5 на scram-sha-256, после того как все клиентские
библиотеки будут обновлены до версий, поддерживающих SCRAM, задайте password_encryption
= ‘scram-sha-256’ в postgresql.conf, добейтесь, чтобы все пользователи сменили свои пароли, а
затем поменяйте указания метода аутентификации в pg_hba.conf на scram-sha-256.
20.6. Аутентификация GSSAPI
GSSAPI является протоколом отраслевого стандарта для безопасной авторизации, определённым
в RFC 2743. PostgreSQL поддерживает GSSAPI с Kerberos аутентификацией с соответствии с RFC</li>
  <li>GSSAPI обеспечивает автоматическую аутентификацию (single sign-on), для систем, которые
её поддерживают. Сама по себе аутентификация безопасна, но данные, отсылаемые в ходе под-
ключения к базе данных, не защищены, если не используется SSL.
Поддержка GSSAPI должна быть включена при сборке PostgreSQL; за дополнительными сведени-
ями обратитесь к Главе 16.
При работе с Kerberos GSSAPI использует стандартные учётные записи в формате servicename/
hostname@realm. Сервер PostgreSQL примет любого принципала, включённого в используемый сер-
вером файл таблицы ключей, но необходимо проявить осторожность в указании корректных дета-
лей принципала в ходе соединения с клиентом, применяющим параметр подключения krbsrvname.
(См. также Подраздел 34.1.2.) Значение имени сервиса по умолчанию postgres может быть изме-
нено во время сборки с помощью ./configure –with-krb-srvnam=whatever. В большинстве сред
изменять данный параметр не требуется. Однако некоторые реализации Kerberos могут потребо-
вать иного имени сервиса, например, Microsoft Active Directory требует, чтобы имя сервиса было
набрано заглавными буквами (POSTGRES).
hostname здесь — это полное доменное имя компьютера, где работает сервер. Областью субъек-
та-службы является предпочитаемая область данного компьютера.
Принципалы клиентов могут быть сопоставлены с различными именами пользователей баз данных
PostgreSQL в pg_ident.conf. Например, принципалу pgusername@realm может быть сопоставлено
просто pgusername. Так же возможно использовать в качестве имени роли в PostgreSQL полное
имя принципала username@realm без какого-либо сопоставления.
PostgreSQL также поддерживает возможность убирать область из имени принципала. Эта возмож-
ность оставлена для обратной совместимости и использовать её крайне нежелательно, так как
при этом оказывается невозможно различить разных пользователей, имеющих одинаковые име-
на, но приходящих из разных областей. Чтобы включить её, установите для include_realm значе-
ние 0. В простых конфигурациях с одной областью исключение области в сочетании с парамет-
ром krb_realm (который позволяет ограничить область пользователя одним значением, заданным
в krb_realm parameter) будет безопасным, но менее гибким вариантом по сравнению с явным опи-
санием сопоставлений в pg_ident.conf.
Убедитесь, что файл ключей вашего сервера доступен для чтения (и желательно недоступен для
записи) учётной записи сервера PostgreSQL. (См. также Раздел  18.1.) Расположение этого фай-
ла ключей указывается параметром krb_server_keyfile. По умолчанию это /usr/local/pgsql/etc/
krb5.keytab (каталог может быть другим, в зависимости от значения sysconfdir при сборке).
Из соображений безопасности рекомендуется использовать отдельный файл keytab для сервера
PostgreSQL, а не открывать доступ к общесистемному файлу.
Файл таблицы ключей генерируется программным обеспечением Kerberos; подробнее это описано
в документации Kerberos. Следующий пример для MIT-совместимых реализаций Kerberos 5:
kadmin% ank -randkey postgres/server.my.domain.org
kadmin% ktadd -k krb5.keytab postgres/server.my.domain.org
582Аутентификация кли-
ентского приложения
При подключении к базе данных убедитесь, что у вас есть разрешение на сопоставление прин-
ципала с именем пользователя базы данных. Например, для имени пользователя базы данных
fred, принципал fred@EXAMPLE.COM сможет подключиться. Чтобы дать разрешение на подклю-
чение принципалу fred/users.example.com@EXAMPLE.COM, используйте файл сопоставления имён
пользователей, как описано в Разделе 20.2.
Для метода GSSAPI доступны следующие параметры конфигурации:
include_realm
Когда этот параметр равен 0, из принципала аутентифицированного пользователя убирается
область, и оставшееся имя проходит сопоставление имён (см. Раздел 20.2). Этот вариант не ре-
комендуется и поддерживается в основном для обратной совместимости, так как он небезопа-
сен в окружениях с несколькими областями, если только дополнительно не задаётся krb_realm.
Более предпочтительный вариант — оставить значение include_realm по умолчанию (1) и за-
дать в pg_ident.conf явное сопоставление для преобразования имён принципалов в имена
пользователей PostgreSQL.
map
Разрешает сопоставление имён пользователей системы и пользователей баз данных. За
подробностями обратитесь к Разделу  20.2. Для принципала GSSAPI/Kerberos, такого как
username@EXAMPLE.COM (или более редкого username/hostbased@EXAMPLE.COM), именем пользо-
вателя в сопоставлении будет username@EXAMPLE.COM (или username/hostbased@EXAMPLE.COM,
соответственно), если include_realm не равно 0; в противном случае именем системного поль-
зователя в сопоставлении будет username (или username/hostbased).
krb_realm
Устанавливает область, с которой будут сверяться имена принципалов пользователей. Если
этот параметр задан, подключаться смогут только пользователи из этой области. Если не за-
дан, подключаться смогут пользователи из любой области, в зависимости от установленного
сопоставления имён пользователей.
20.7. Аутентификация SSPI
SSPI — технология Windows для защищённой аутентификации с единственным входом. PostgreSQL
использует SSPI в режиме negotiate, который применяет Kerberos, когда это возможно, и автома-
тически возвращается к NTLM в других случаях. Аутентификация SSPI работает только, когда и
сервер, и клиент работают на платформе Windows, или, на не-Windows платформах, если доступен
GSSAPI.
Если используется аутентификация Kerberos, SSPI работает так же, как GSSAPI; подробнее об этом
рассказывается в Разделе 20.6.
Для SSPI доступны следующие параметры конфигурации:
include_realm
Когда этот параметр равен 0, из принципала аутентифицированного пользователя убирается
область, и оставшееся имя проходит сопоставление имён (см. Раздел 20.2). Этот вариант не ре-
комендуется и поддерживается в основном для обратной совместимости, так как он небезопа-
сен в окружениях с несколькими областями, если только дополнительно не задаётся krb_realm.
Более предпочтительный вариант — оставить значение include_realm по умолчанию (1) и за-
дать в pg_ident.conf явное сопоставление для преобразования имён принципалов в имена
пользователей PostgreSQL.
compat_realm
Если равен 1, для параметра include_realm применяется имя домена, совместимое с SAM
(также известное как имя NetBIOS). Это вариант по умолчанию. Если он равен 0, для имени
принципала Kerberos применяется действительное имя области.
583Аутентификация кли-
ентского приложения
Этот параметр можно отключить, только если ваш сервер работает под именем доменного поль-
зователя (в том числе, виртуального пользователя службы на компьютере, включённом в до-
мен) и все клиенты, проходящие проверку подлинности через SSPI, также используют домен-
ные учётные записи; в противном случае аутентификация не будет выполнена.
upn_username
Если этот параметр включён вместе с compat_realm, для аутентификации применяется имя
Kerberos UPN. Если он отключён (по умолчанию), применяется SAM-совместимое имя пользо-
вателя. По умолчанию у новых учётных записей эти два имени совпадают.
Заметьте, что libpq использует имя, совместимое с SAM, если имя не задано явно. Если вы
применяете libpq или драйвер на его базе, этот параметр следует оставить отключённым, либо
явно задавать имя пользователя в строке подключения.
map
Позволяет сопоставить пользователей системы с пользователями баз данных. За подробностя-
ми обратитесь к Разделу 20.2. Для принципала SSPI/Kerberos, такого как username@EXAMPLE.COM
(или более редкого username/hostbased@EXAMPLE.COM), именем пользователя в сопоставле-
нии будет username@EXAMPLE.COM (или username/hostbased@EXAMPLE.COM, соответственно), если
include_realm не равно 0; в противном случае именем системного пользователя в сопоставле-
нии будет username (или username/hostbased).
krb_realm
Устанавливает область, с которой будут сверяться имена принципалов пользователей. Если
этот параметр задан, подключаться смогут только пользователи из этой области. Если не за-
дан, подключаться смогут пользователи из любой области, в зависимости от установленного
сопоставления имён пользователей.
20.8. Аутентификация Ident
Метод аутентификации ident работает, получая имя пользователя операционной системы клиента
от сервера Ident и используя его в качестве разрешённого имени пользователя базы данных (с воз-
можным сопоставлением имён пользователя). Способ доступен только для подключений по TCP/IP.
Примечание
Когда для локального подключения (не TCP/IP) указан ident, вместо него используется
метод аутентификации peer (см. Раздел 20.9).
Для метода ident доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
Протокол «Identification» (Ident) описан в RFC 1413. Практически каждая Unix-подобная операци-
онная система поставляется с сервером Ident, по умолчанию слушающим TCP-порт 113. Базовая
функция этого сервера — отвечать на вопросы, вроде «Какой пользователь инициировал подклю-
чение, которое идет через твой порт X и подключается к моему порту Y?». Поскольку после уста-
новления физического подключения PostgreSQL знает и X, и Y, он может опрашивать сервер Ident
на компьютере клиента и теоретически может определять пользователя операционной системы
при каждом подключении.
Недостатком этой процедуры является то, что она зависит от интеграции с клиентом: если кли-
ентская машина не вызывает доверия или скомпрометирована, злоумышленник может запустить
584Аутентификация кли-
ентского приложения
любую программу на порту 113 и вернуть любое имя пользователя на свой выбор. Поэтому этот
метод аутентификации подходит только для закрытых сетей, где каждая клиентская машина нахо-
дится под жёстким контролем и где администраторы операционных систем и баз данных работают
в тесном контакте. Другими словами, вы должны доверять машине, на которой работает сервер
Ident. Помните предупреждение:
Протокол Ident не предназначен для использования как протокол авторизации и кон-
троля доступа.
—RFC 1413
У некоторых серверов Ident есть нестандартная возможность, позволяющая зашифровать возвра-
щаемое имя пользователя, используя ключ, который известен только администратору исходного
компьютера. Эту возможность нельзя использовать с PostgreSQL, поскольку PostgreSQL не сможет
расшифровать возвращаемую строку и получить фактическое имя пользователя.
20.9. Аутентификация peer
Метод аутентификации peer работает, получая имя пользователя операционной системы клиента
из ядра и используя его в качестве разрешённого имени пользователя базы данных (с возможно-
стью сопоставления имён пользователя). Этот метод поддерживается только для локальных под-
ключений.
Для метода peer доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
Аутентификация peer доступна только в операционных системах, поддерживающих функцию
getpeereid(), параметр сокета SO_PEERCRED или подобные механизмы. В настоящее время это
Linux, большая часть разновидностей BSD, включая macOS, и Solaris.
20.10. Аутентификация LDAP
Данный метод аутентификации работает сходным с методом password образом, за исключением
того, что он использует LDAP как метод подтверждения пароля. LDAP используется только для
подтверждения пары “имя пользователя/пароль”. Поэтому пользователь должен уже существовать
в базе данных до того, как для аутентификации будет использован LDAP.
Аутентификация LDAP может работать в двух режимах. Первый режим называется простое связы-
вание. В ходе аутентификации сервер связывается с характерным именем, составленным следую-
щим образом: prefix username suffix. Обычно, параметр prefix используется для указания cn=
или DOMAIN\ в среде Active Directory. suffix используется для указания оставшейся части DN или
в среде, отличной от Active Directory.
Во втором режиме, который мы называем поиск+связывание, сервер сначала связывается с ка-
талогом LDAP с предопределённым именем пользователя и паролем, указанным в ldapbinddn и
ldapbindpasswd, и выполняет поиск пользователя, пытающегося подключиться к базе данных. Ес-
ли имя пользователя и пароль не определены, сервер пытается связаться с каталогом анонимно.
Поиск выполняется в поддереве ldapbasedn, при этом проверятся точное соответствие имени поль-
зователя атрибуту ldapsearchattribute. Как только при поиске находится пользователь, сервер
отключается и заново связывается с каталогом уже как этот пользователь, с паролем, передан-
ным клиентом, чтобы удостовериться, что учётная запись корректна. Этот же режим использует-
ся в схемах LDAP-аутентификации в другом программном обеспечении, например, в pam_ldap и
mod_authnz_ldap в Apache. Данный вариант даёт больше гибкости в выборе расположения объек-
тов пользователей, но при этом требует дважды подключаться к серверу LDAP.
В обоих режимах используются следующие параметры конфигурации:
585Аутентификация кли-
ентского приложения
ldapserver
Имена и IP-адреса LDAP-серверов для связи. Можно указать несколько серверов, разделяя их
пробелами.
ldapport
Номер порта для связи с LDAP-сервером. Если порт не указан, используется установленный по
умолчанию порт библиотеки LDAP.
ldapscheme
Значение ldaps выбирает протокол LDAPS. Это нестандартный способ использования LDAP по-
верх SSL, поддерживаемый некоторыми серверами LDAP. Альтернативную возможность предо-
ставляет параметр ldaptls.
ldaptls
Значение 1 включает TLS-шифрование для защиты соединения PostgreSQL с LDAP-сервером.
При этом используется операция StartTLS, описанная в RFC 4513. Альтернативную возмож-
ность предоставляет параметр ldapscheme.
Заметьте, что при использовании ldapscheme или ldaptls шифруется только трафик между серве-
ром PostgreSQL и сервером LDAP. Соединение между сервером PostgreSQL и клиентом остаётся
незашифрованным, если только и для него не включён SSL.
Следующие параметры используются только в режиме простого связывания:
ldapprefix
Эта строка подставляется перед именем пользователя во время формирования DN для связы-
вания при аутентификации в режиме простого связывания.
ldapsuffix
Эта строка размещается после имени пользователя во время формирования DN для связыва-
ния, при аутентификации в режиме простого связывания.
Следующие параметры используются только в режиме поиск+связывание:
ldapbasedn
Корневая папка DN для начала поиска пользователя при аутентификации в режиме поиск+свя-
зывание.
ldapbinddn
DN пользователя для связи с каталогом при выполнении поиска в ходе аутентификации в ре-
жиме поиск+связывание.
ldapbindpasswd
Пароль пользователя для связывания с каталогом при выполнении поиска в ходе аутентифика-
ции в режиме поиск+связывание.
ldapsearchattribute
Атрибут для соотнесения с именем пользователя в ходе аутентификации поиск+связывание.
Если атрибут не указан, будет использован атрибут uid.
ldapsearchfilter
Фильтр поиска, используемый для аутентификации в режиме поиск+связывание. Вхождения
$username в нём будут заменяться именем пользователя. Это позволяет задавать более гибкие
фильтры поиска, чем ldapsearchattribute.
586Аутентификация кли-
ентского приложения
ldapurl
Адрес LDAP по стандарту RFC 4516. Это альтернативный способ записи некоторых других па-
раметров LDAP в более компактном и стандартном виде. Формат адреса таков:
ldap[s]://сервер[:порт]/basedn[?[атрибут][?[scope][?[фильтр]]]]
Здесь scope принимает значение base, one или sub (обычно последнее). По умолчанию под-
разумевается base, что не очень полезно при таком применении. В качестве атрибута мо-
жет указываться один атрибут; в этом случае он используется как значение параметра
ldapsearchattribute. Если атрибут не указан, в качестве значения ldapsearchfilter может
использоваться фильтр.
Схема адреса ldaps выбирает для установления LDAP-подключений поверх SSL метод LDAPS,
что равнозначно указанию ldapscheme=ldaps. Для применения шифрования LDAP с использо-
ванием операции StartTLS используйте обычную схему URL ldap и укажите параметр ldaptls
в дополнение к ldapurl.
Для неанонимного связывания ldapbinddn и ldapbindpasswd должны быть указаны как раз-
дельные параметры.
В настоящее время URL-адреса LDAP поддерживаются только с OpenLDAP, не в Windows.
Нельзя путать параметры конфигурации для режима простого связывания с параметрами для ре-
жима поиск+связывание, это ошибка.
В режиме поиск+связывание поиск может выполняться либо по одному атрибуту, указанному в
ldapsearchattribute, либо по произвольному фильтру поиска, заданному в ldapsearchfilter. Ука-
зание ldapsearchattribute=foo равнозначно указанию ldapsearchfilter=”(foo=$username)”. Ес-
ли не указан ни один параметр, по умолчанию подразумевается ldapsearchattribute=uid.
Это пример конфигурации LDAP для простого связывания:
host … ldap ldapserver=ldap.example.net ldapprefix=”cn=” ldapsuffix=”, dc=example,
dc=net”
Когда запрашивается подключение к серверу базы данных в качестве пользователя базы дан-
ных someuser, PostgreSQL пытается связаться с LDAP-сервером, используя DN cn=someuser,
dc=example, dc=net и пароль, предоставленный клиентом. Если это подключение удалось, то до-
ступ к базе данных будет открыт.
Пример конфигурации для режима поиск+связывание:
host … ldap ldapserver=ldap.example.net ldapbasedn=”dc=example, dc=net”
ldapsearchattribute=uid
Когда запрашивается подключение к серверу базы данных в качестве пользователя базы данных
someuser, PostgreSQL пытается связаться с сервером LDAP анонимно (поскольку ldapbinddn не
был указан), выполняет поиск для (uid=someuser) под указанной базой DN. Если запись найдена,
проводится попытка связывание с использованием найденной информации и паролем, предостав-
ленным клиентом. Если вторая попытка подключения проходит успешно, предоставляется доступ
к базе данных.
Пример той же конфигурации для режима поиск+связывание, но записанной в виде URL:
host … ldap ldapurl=”ldap://ldap.example.net/dc=example,dc=net?uid?sub”
Такой URL-формат используется и другим программным обеспечением, поддерживающим аутен-
тификацию по протоколу LDAP, поэтому распространять такую конфигурацию будет легче.
Пример конфигурации поиск+связывание, в котором ldapsearchfilter используется вместо
ldapsearchattribute для прохождения аутентификации по идентификатору или почтовому адре-
су пользователя:
587Аутентификация кли-
ентского приложения
host … ldap ldapserver=ldap.example.net ldapbasedn=”dc=example, dc=net”
ldapsearchfilter=”(|(uid=$username)(mail=$username))”
Подсказка
Поскольку LDAP часто применяет запятые и пробелы для разделения различных ча-
стей DN, необходимо использовать кавычки при определении значения параметров,
как показано в наших примерах.
20.11. Аутентификация RADIUS
Данный метод аутентификации работает сходным с методом password образом, за исключением
того, что он использует RADIUS как метод проверки пароля. RADIUS используется только для под-
тверждения пары имя пользователя/пароль. Поэтому пользователь должен уже существовать в ба-
зе данных до того, как для аутентификации будет использован RADIUS.
В ходе аутентификации RADIUS настроенному RADIUS-серверу посылается запрос доступа. Это
сообщение типа Только Аутентификация, которое включает в себя параметры имя пользователя,
пароль (зашифрованный) и идентификатор NAS. Запрос зашифровывается с использованием общего
с сервером секрета. RADIUS-сервер отвечает на запрос сервера либо Доступ принят, либо Доступ
отклонён. Система ведения учёта RADIUS не поддерживается.
Указать можно адреса нескольких серверов RADIUS, тогда они будут перебираться по очереди.
В случае получения от любого сервера отрицательного ответа произойдёт сбой аутентификации.
Если ответ не будет получен, последует попытка подключения к следующему серверу в списке.
Чтобы задать имена нескольких серверов, заключите их в кавычки и разделите запятыми. Если
указывается несколько серверов, все остальные параметры RADIUS так же должны записываться
в списке через запятую, чтобы каждый сервер получил собственное значение. Возможно также
задавать их единственным значением, в этом случае это значение будет применяться ко всем сер-
верам.
Для метода RADIUS доступны следующие параметры конфигурации:
radiusservers
Имена или IP-адреса серверов RADIUS для подключения. Это обязательный параметр.
radiussecrets
Общие секреты, используемые при общении с сервером RADIUS. Секрет должен быть одинако-
вым на серверах PostgreSQL и RADIUS. Рекомендуется использовать строку как минимум из 16
символов. Это обязательный параметр.
Примечание
Шифровальный вектор будет достаточно эффективен только в том случае, если
PostgreSQL собран с поддержкой OpenSSL. В противном случае, передача данных
серверу RADIUS будет лишь замаскированной, но не защищённой, поэтому необхо-
димо принять дополнительные меры безопасности.
radiusports
Номер порта для подключения к серверам RADIUS. Если порт не указан, по умолчанию исполь-
зуется порт 1812.
radiusidentifiers
Строка, используемая в запросах сервера RADIUS как Идентификатор NAS. Этот параметр мо-
жет использоваться как второй параметр, выявляющий, например, какой пользователь пыта-
588Аутентификация кли-
ентского приложения
ется подключиться под каким пользователем базы данных, что может быть использовано для
формирования соответствий на сервере RADIUS. Если не указан идентификатор, по умолчанию
используется postgresql.
20.12. Аутентификация по сертификату
Для аутентификации в рамках этого метода используется клиентский сертификат SSL, поэтому
данный способ применим только для SSL-подключений. Когда используется этот метод, сервер
потребует от клиента предъявления действительного и доверенного сертификата. Пароль у кли-
ента не запрашивается. Атрибут cn (Обычное имя) сертификата сравнивается с запрашиваемым
именем пользователя базы данных, и если они соответствуют, вход разрешается. Если cn отлича-
ется от имени пользователя базы данных, то может быть использовано сопоставление имён поль-
зователей.
Для аутентификации по SSL сертификату доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
В записи pg_hba.conf, описывающей аутентификацию по сертификату, параметр clientcert пред-
полагается равным 1, и его нельзя отключить, так как для этого метода клиентский сертификат
является обязательным. Метод cert отличается от простой проверки пригодности сертификата
clientcert только тем, что также проверяет, соответствует ли атрибут cn имени пользователя ба-
зы данных.
20.13. Аутентификация PAM
Данный метод аутентификации работает подобно методу password, но использует в качестве ме-
ханизма проверки подлинности PAM (Pluggable Authentication Modules, Подключаемые модули
аутентификации). По умолчанию имя службы PAM — postgresql. PAM используется только для
проверки пар “имя пользователя/пароль” и может дополнительно проверять имя или IP-адрес уда-
лённого компьютера. Поэтому пользователь должен уже существовать в базе данных, чтобы PAM
можно было использовать для аутентификации. За дополнительной информацией о PAM обрати-
тесь к Странице описания Linux-PAM.
Для аутентификации PAM доступны следующие параметры конфигурации:
pamservice
Имя службы PAM
pam_use_hostname
Указывает, предоставляется ли модулям PAM через поле PAM_RHOST IP-адрес либо имя удалён-
ного компьютера. По умолчанию выдаётся IP-адрес. Установите в этом параметре 1, чтобы ис-
пользовать имя узла. Разрешение имени узла может приводить к задержкам при подключении.
(Обычно конфигурации PAM не задействуют эту информацию, так что этот параметр следует
учитывать, только если создана специальная конфигурация, в которой он используется.)
Примечание
Если PAM настроен для чтения /etc/shadow, произойдёт сбой аутентификации, потому
что сервер PostgreSQL запущен не пользователем root. Однако это не имеет значения,
когда PAM настроен для использования LDAP или других методов аутентификации.
20.14. Аутентификация BSD
589Аутентификация кли-
ентского приложения
Данный метод аутентификации работает подобно методу password, но использует для проверки
пароля механизм аутентификации BSD. Аутентификация BSD используется только для проверки
пар “имя пользователя/пароль”. Поэтому роль пользователя должна уже существовать в базе дан-
ных, чтобы эта аутентификация была успешной. Механизм аутентификации BSD в настоящее вре-
мя может применяться только в OpenBSD.
Для аутентификации BSD в PostgreSQL применяется тип входа auth-postgresql и класс
postgresql, если он определён в login.conf. По умолчанию этот класс входа не существует и
PostgreSQL использует класс входа по умолчанию.
Примечание
Для использования аутентификации BSD необходимо сначала добавить учётную за-
пись пользователя PostgreSQL (то есть, пользователя ОС, запускающего сервер) в груп-
пу auth. Группа auth существует в системах OpenBSD по умолчанию.
20.15. Проблемы аутентификации
Сбои и другие проблемы с аутентификацией обычно дают о себе знать через сообщения об ошиб-
ках, например:
FATAL: no pg_hba.conf entry for host “123.123.123.123”, user “andym”, database
“testdb”
Это сообщение вы, скорее всего, получите, если сможете связаться с сервером, но он не захочет
с вами общаться. В сообщении содержится предположение, что сервер отказывает вам в подклю-
чении, поскольку не может найти подходящую запись в файле pg_hba.conf.
FATAL:
password authentication failed for user “andym”
Такое сообщение показывает, что вы связались с сервером, он готов общаться с вами, но только
после того, как вы прошли авторизацию по методу, указанному в файле pg_hba.conf. Проверьте
пароль, который вы вводите, и как настроен Kerberos или ident, если в сообщении упоминается
один из этих типов аутентификации.
FATAL:
user “andym” does not exist
Указанное имя пользователя базы данных не найдено.
FATAL:
database “testdb” does not exist
База данных, к которой вы пытаетесь подключиться, не существует. Имейте в виду, что если вы
не указали имя базы данных, по умолчанию берётся имя пользователя базы данных, что может
приводить к ошибкам.
Подсказка
В журнале сервера может содержаться больше информации, чем в выдаваемых кли-
енту сообщениях об ошибке аутентификации, поэтому, если вас интересуют причины
сбоя, проверьте журнал сервера.
590</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-019/" title="Глава 19. Настройка сервера"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 19. Настройка сервера"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-019/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~144 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-019/" rel="bookmark" title="Глава 19. Настройка сервера" itemprop="url">Глава 19. Настройка сервера</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 19. Настройка сервера</p>

<p>На работу системы баз данных оказывают влияние множество параметров конфигурации. В первом
разделе этой главы рассказывается, как управлять этими параметрами, а в последующих разделах
подробно описывается каждый из них.
19.1. Изменение параметров
19.1.1. Имена и значения параметров
Имена всех параметров являются регистронезависимыми. Каждый параметр принимает значение
одного из пяти типов: логический, строка, целое, число с плавающей точкой или перечисление.
От типа значения зависит синтаксис установки этого параметра:
• Логический: Значения могут задаваться строками on, off, true, false, yes, no, 1, 0 (регистр не
имеет значения), либо как достаточно однозначный префикс одной из этих строк.
• Строка: Обычно строковое значение заключается в апострофы (при этом внутренние апо-
строфы дублируются). Однако, если значение является простым числом или идентификато-
ром, апострофы обычно можно опустить.
• Число (целое или с плавающей точкой): Десятичная точка как разделитель целой и дробной
части допускается только для параметров, принимающих числа с плавающей точкой. Разде-
лители разрядов в записи числа не принимаются. Заключать в апострофы число не требуется.
• Число с единицей измерения: Некоторые числовые параметры задаются с единицами из-
мерения, так как они описывают количества информации или времени. Единицами могут
быть байты, килобайты, блоки (обычно восемь килобайт), миллисекунды, секунды или ми-
нуты. При указании только числового значения для такого параметра единицей измере-
ния будет считаться установленная для него единица по умолчанию, которая указывается в
pg_settings.unit. Для удобства параметры также можно задавать, указывая единицу изме-
рения явно, например, задать ‘120 ms’ для значения времени. При этом такое значение бу-
дет переведено в основную единицу измерения параметра. Заметьте, что для этого значение
должно записываться в виде строки (в апострофах). Имя единицы является регистронезависи-
мым, а между ним и числом допускаются пробельные символы.
• Допустимые единицы информации: B (байты), kB (килобайты), MB (мегабайты), GB (гигабай-
ты) и TB (терабайты). Множителем единиц информации считается 1024, не 1000.
• Допустимые единицы времени: ms (миллисекунды), s (секунды), min (минуты), h (часы) и d
(дни).
• Перечисление: Параметры, имеющие тип перечисление, записываются так же, как строковые
параметры, но могут иметь только ограниченный набор значений. Список допустимых значе-
ний такого параметра задаётся в pg_settings.enumvals. В значениях перечислений регистр
не учитывается.
19.1.2. Определение параметров в файле конфигурации
Самый основной способ установки этих параметров — определение их значений в файле
postgresql.conf, который обычно находится в каталоге данных. При инициализации каталога кла-
стера БД в этот каталог помещается копия стандартного файла. Например, он может выглядеть
так:</p>
<h1 id="Это-комментарий">Это комментарий</h1>
<p>log_connections = yes
log_destination = ‘syslog’
search_path = ‘“$user”, public’
shared_buffers = 128MB
Каждый параметр определяется в отдельной строке. Знак равенства в ней между именем и зна-
чением является необязательным. Пробельные символы в строке не играют роли (кроме значе-
503Настройка сервера
ний, заключённых в апострофы), а пустые строки игнорируются. Знаки решётки (#) обозначают
продолжение строки как комментарий. Значения параметров, не являющиеся простыми иденти-
фикаторами или числами, должны заключаться в апострофы. Чтобы включить в такое значение
собственно апостроф, его следует продублировать (предпочтительнее) или предварить обратной
косой чертой.
Параметры, установленные таким образом, задают значения по умолчанию для данного кластера.
Эти значения будут действовать в активных сеансах, если не будут переопределены. В следующих
разделах описывается, как их может переопределить администратор или пользователь.
Основной процесс сервера перечитывает файл конфигурации заново, получая сигнал SIGHUP; по-
слать его проще всего можно, запустив pg_ctl reload в командной строке или вызвав SQL-функ-
цию pg_reload_conf(). Основной процесс сервера передаёт этот сигнал всем остальным запущен-
ным серверным процессам, так что существующие сеансы тоже получают новые значения (после
того, как завершится выполнение текущей команды клиента). Также возможно послать этот сиг-
нал напрямую одному из серверных процессов. Учтите, что некоторые параметры можно устано-
вить только при запуске сервера; любые изменения их значений в файле конфигурации не будут
учитываться до перезапуска сервера. Более того, при обработке SIGHUP игнорируются неверные
значения параметров (но об этом сообщается в журнале).
В дополнение к postgresql.conf в каталоге данных PostgreSQL содержится файл
postgresql.auto.conf, который имеет тот же формат, что и postgresql.conf, но не должен редак-
тироваться вручную. Этот файл содержит параметры, задаваемые командой ALTER SYSTEM. Он
считывается автоматически одновременно с postgresql.conf и заданные в нём параметры дей-
ствуют таким же образом. Параметры в postgresql.auto.conf переопределяют те, что указаны в
postgresql.conf.
Системное представление pg_file_settings может быть полезным для предварительной провер-
ки изменений в файле конфигурации или диагностики проблем, если сигнал SIGHUP не даёт же-
лаемого эффекта.
19.1.3. Управление параметрами через SQL
В PostgreSQL есть три SQL-команды, задающие для параметров значения по умолчанию. Уже упо-
мянутая команда ALTER SYSTEM даёт возможность изменять глобальные значения средствами
SQL; она функционально равнозначна редактированию postgresql.conf. Кроме того, есть ещё две
команды, которые позволяют задавать значения по умолчанию на уровне баз данных и ролей:
• Команда ALTER DATABASE позволяет переопределить глобальные параметры на уровне базы
данных.
• Команда ALTER ROLE позволяет переопределить для конкретного пользователя как глобаль-
ные, так и локальные для базы данных параметры.
Значения, установленные командами ALTER DATABASE и ALTER ROLE, применяются только при но-
вом подключении к базе данных. Они переопределяют значения, полученные из файлов конфигу-
рации или командной строки сервера, и применяются по умолчанию в рамках сеанса. Заметьте,
что некоторые параметры невозможно изменить после запуска сервера, поэтому их нельзя уста-
новить этими командами (или командами, перечисленными ниже).
Когда клиент подключён к базе данных, он может воспользоваться двумя дополнительными ко-
мандами SQL (и равнозначными функциями), которые предоставляет PostgreSQL для управления
параметрами конфигурации:
• Команда SHOW позволяет узнать текущее значение всех параметров. Соответствующая ей
функция — current_setting(имя_параметра text).
• Команда SET позволяет изменить текущее значение параметров, которые действуют ло-
кально в рамках сеанса; на другие сеансы она не влияет. Соответствующая ей функция —
set_config(имя_параметра, новое_значение, локально).
504Настройка сервера
Кроме того, просмотреть и изменить значения параметров для текущего сеанса можно в систем-
ном представлении pg_settings:
• Запрос на чтение представления выдаёт ту же информацию, что и SHOW ALL, но более подроб-
но. Этот подход и более гибкий, так как в нём можно указать условия фильтра или связать ре-
зультат с другими отношениями.
• Выполнение UPDATE для этого представления, а именно присвоение значения столбцу, равно-
сильно выполнению команды SET. Например, команде
SET configuration_parameter TO DEFAULT;
равнозначен запрос:
UPDATE pg_settings SET setting = reset_val WHERE name = ‘configuration_parameter’;
19.1.4. Управление параметрами в командной строке
Помимо изменения глобальных значений по умолчанию и переопределения их на уровне базы
данных или роли, параметры PostgreSQL можно изменить, используя средства командной строки.
Управление через командную строку поддерживают и сервер, и клиентская библиотека libpq.
• При запуске сервера, значения параметров можно передать команде postgres в аргументе ко-
мандной строки -c. Например:
postgres -c log_connections=yes -c log_destination=’syslog’
Параметры, заданные таким образом, переопределяют те, что были установлены в
postgresql.conf или командой ALTER SYSTEM, так что их нельзя изменить глобально без пере-
запуска сервера.
• При запуске клиентского сеанса, использующего libpq, значения параметров можно указать
в переменной окружения PGOPTIONS. Заданные таким образом параметры будут определять
значения по умолчанию на время сеанса, но никак не влияют на другие сеансы. По истори-
ческим причинам формат PGOPTIONS похож на тот, что применяется при запуске команды
postgres; в частности, в нём должен присутствовать флаг -c. Например:
env PGOPTIONS=”-c geqo=off -c statement_timeout=5min” psql
Другие клиенты и библиотеки могут иметь собственные механизмы управления параметрами,
через командную строку или как-то иначе, используя которые пользователь сможет менять
параметры сеанса, не выполняя непосредственно команды SQL.
19.1.5. Упорядочение содержимого файлов конфигурации
PostgreSQL предоставляет несколько возможностей для разделения сложных файлов
postgresql.conf на вложенные файлы. Эти возможности особенно полезны при управлении мно-
жеством серверов с похожими, но не одинаковыми конфигурациями.
Помимо присвоений значений параметров, postgresql.conf может содержать директивы вклю-
чения файлов, которые будут прочитаны и обработаны, как если бы их содержимое было вставлено
в данном месте файла конфигурации. Это позволяет разбивать файл конфигурации на физически
отдельные части. Директивы включения записываются просто:
include ‘имя_файла’
Если имя файла задаётся не абсолютным путём, оно рассматривается относительно каталога, в
котором находится включающий файл конфигурации. Включения файлов могут быть вложенными.
Кроме того, есть директива include_if_exists, которая работает подобно include, за исключени-
ем случаев, когда включаемый файл не существует или не может быть прочитан. Обычная дирек-
тива include считает это критической ошибкой, но include_if_exists просто выводит сообщение
и продолжает обрабатывать текущий файл конфигурации.
505Настройка сервера
Файл postgresql.conf может также содержать директивы include_dir, позволяющие подключать
целые каталоги с файлами конфигурации. Они записываются так:
include_dir ‘каталог’
Имена, заданные не абсолютным путём, рассматриваются относительно каталога, содержащего
текущий файл конфигурации. В заданном каталоге включению подлежат только файлы с именами,
оканчивающимися на .conf. При этом файлы с именами, начинающимися с «.», тоже игнориру-
ются, для предотвращения ошибок, так как они считаются скрытыми в ряде систем. Набор файлов
во включаемом каталоге обрабатывается по порядку имён (определяемому правилами, принятыми
в C, т. е. цифры идут перед буквами, а буквы в верхнем регистре — перед буквами в нижнем).
Включение файлов или каталогов позволяет разделить конфигурацию базы данных на логические
части, а не вести один большой файл postgresql.conf. Например, представьте, что в некоторой
компании есть два сервера баз данных, с разным объёмом ОЗУ. Скорее всего при этом их конфи-
гурации будут иметь общие элементы, например, параметры ведения журналов. Но параметры,
связанные с памятью, у них будут различаться. Кроме того, другие параметры могут быть специ-
фическими для каждого сервера. Один из вариантов эффективного управления такими конфигу-
рациями — разделить изменения стандартной конфигурации на три файла. Чтобы подключить эти
файлы, можно добавить в конец файла postgresql.conf следующие директивы:
include ‘shared.conf’
include ‘memory.conf’
include ‘server.conf’
Общие для всех серверов параметры будут помещаться в shared.conf. Файл memory.conf может
иметь два варианта — первый для серверов с 8ГБ ОЗУ, а второй для серверов с 16 ГБ. Наконец,
server.conf может содержать действительно специфические параметры для каждого отдельного
сервера.
Также возможно создать каталог с файлами конфигурации и поместить туда все эти файлы. На-
пример, так можно подключить каталог conf.d в конце postgresql.conf:
include_dir ‘conf.d’
Затем можно дать файлам в каталоге conf.d следующие имена:
00shared.conf
01memory.conf
02server.conf
Такое именование устанавливает чёткий порядок подключения этих файлов, что важно, так как
если параметр определяется несколько раз в разных файлах конфигурации, действовать будет по-
следнее определение. В рамках данного примера, установленное в conf.d/02server.conf значе-
ние переопределит значение того же параметра, заданное в conf.d/01memory.conf.
Вы можете применить этот подход и с описательными именами файлов:
00shared.conf
01memory-8GB.conf
02server-foo.conf
При таком упорядочивании каждому варианту файла конфигурации даётся уникальное имя. Это
помогает исключить конфликты, если конфигурации разных серверов нужно хранить в одном ме-
сте, например, в репозитории системы управления версиями. (Кстати, хранение файлов конфигу-
рации в системе управления версиями — это ещё один эффективный приём, который стоит при-
менять.)
19.2. Расположения файлов
В дополнение к вышеупомянутому postgresql.conf, PostgreSQL обрабатывает два редактируемых
вручную файла конфигурации, в которых настраивается аутентификация клиентов (их использо-
506Настройка сервера
вание рассматривается в Главе 20). По умолчанию все три файла конфигурации размещаются в
каталоге данных кластера БД. Параметры, описанные в этом разделе, позволяют разместить их
и в любом другом месте. (Это позволяет упростить администрирование, в частности, выполнять
резервное копирование этих файлов обычно проще, когда они хранятся отдельно.)
data_directory (string)
Задаёт каталог, в котором хранятся данные. Этот параметр можно задать только при запуске
сервера.
config_file (string)
Задаёт основной файл конфигурации сервера (его стандартное имя — postgresql.conf). Этот
параметр можно задать только в командной строке postgres.
hba_file (string)
Задаёт файл конфигурации для аутентификации по сетевым узлам (его стандартное имя —
pg_hba.conf). Этот параметр можно задать только при старте сервера.
ident_file (string)
Задаёт файл конфигурации для сопоставлений имён пользователей (его стандартное имя —
pg_ident.conf). Этот параметр можно задать только при запуске сервера. См. также Раз-
дел 20.2.
external_pid_file (string)
Задаёт имя дополнительного файла с идентификатором процесса (PID), который будет созда-
вать сервер для использования программами администрирования. Этот параметр можно задать
только при запуске сервера.
При стандартной установке ни один из этих параметров не задаётся явно. Вместо них задаётся
только каталог данных, аргументом командной строки -D или переменной окружения PGDATA, и
все необходимые файлы конфигурации загружаются из этого каталога.
Если вы хотите разместить файлы конфигурации не в каталоге данных, то аргумент командной
строки postgres -D или переменная окружения PGDATA должны указывать на каталог, содержащий
файлы конфигурации, а в postgresql.conf (или в командной строке) должен задаваться параметр
data_directory, указывающий, где фактически находятся данные. Учтите, что data_directory пе-
реопределяет путь, задаваемый в -D или PGDATA как путь каталога данных, но не расположение
файлов конфигурации.
При желании вы можете задать имена и расположение файлов конфигурации по отдельности, вос-
пользовавшись параметрами config_file, hba_file и/или ident_file. Параметр config_file мож-
но задать только в командной строке postgres, тогда как остальные можно задать и в основном
файле конфигурации. Если явно заданы все три эти параметра плюс data_directory, то задавать
-D или PGDATA не нужно.
Во всех этих параметрах относительный путь должен задаваться от каталога, в котором запуска-
ется postgres.
19.3. Подключения и аутентификация
19.3.1. Параметры подключений
listen_addresses (string)
Задаёт адреса TCP/IP, по которым сервер будет принимать подключения клиентских приложе-
ний. Это значение принимает форму списка, разделённого запятыми, из имён и/или числовых
507Настройка сервера
IP-адресов компьютеров. Особый элемент, *, обозначает все имеющиеся IP-интерфейсы. Запись
0.0.0.0 позволяет задействовать все адреса IPv4, а :: — все адреса IPv6. Если список пуст,
сервер не будет привязываться ни к какому IP-интерфейсу, а значит, подключиться к нему
можно будет только через Unix-сокеты. По умолчанию этот параметр содержит localhost, что
допускает подключение к серверу по TCP/IP только через локальный интерфейс «замыкания».
Хотя механизм аутентификации клиентов (см. Главу 20) позволяет гибко управлять доступом
пользователей к серверу, параметр listen_addresses может ограничить интерфейсы, через
которые будут приниматься соединения, что бывает полезно для предотвращения злонамерен-
ных попыток подключения через незащищённые сетевые интерфейсы. Этот параметр можно
задать только при запуске сервера.
port (integer)
TCP-порт, открываемый сервером; по умолчанию, 5432. Заметьте, что этот порт используется
для всех IP-адресов, через которые сервер принимает подключения. Этот параметр можно за-
дать только при запуске сервера.
max_connections (integer)
Определяет максимальное число одновременных подключений к серверу БД. По умолчанию
обычно это 100 подключений, но это число может быть меньше, если ядро накладывает свои
ограничения (это определяется в процессе initdb). Этот параметр можно задать только при
запуске сервера.
Для ведомого сервера значение этого параметра должно быть больше или равно значению на
ведущем. В противном случае на ведомом сервере не будут разрешены запросы.
superuser_reserved_connections (integer)
Определяет количество «слотов» подключений, которые PostgreSQL будет резервировать
для суперпользователей. При этом всего одновременно активными могут быть максимум
max_connections подключений. Когда число активных одновременных подключений больше
или равно max_connections минус superuser_reserved_connections, принимаются только под-
ключения суперпользователей, а все другие подключения, в том числе подключения для ре-
пликации, запрещаются.
По умолчанию резервируются три соединения. Это значение должно быть меньше значения
max_connections минус max_wal_senders. Задать этот параметр можно только при запуске сер-
вера.
unix_socket_directories (string)
Задаёт каталог Unix-сокета, через который сервер будет принимать подключения клиентских
приложений. Создать несколько сокетов можно, перечислив в этом значении несколько ката-
логов через запятую. Пробелы между элементами этого списка игнорируются; если в пути ка-
талога содержатся пробелы, его нужно заключать в двойные кавычки. При пустом значении
сервер не будет работать с Unix-сокетами, в этом случае к нему можно будет подключиться
только по TCP/IP. Значение по умолчанию обычно /tmp, но его можно изменить во время сбор-
ки. Задать этот параметр можно только при запуске сервера.
Помимо самого файла сокета, который называется .s.PGSQL.nnnn (где nnnn — номер
порта сервера), в каждом каталоге unix_socket_directories создаётся обычный файл
.s.PGSQL.nnnn.lock. Ни в коем случае не удаляйте эти файлы вручную.
Этот параметр не действует в системе Windows, так как в ней нет Unix-сокетов.
unix_socket_group (string)
Задаёт группу-владельца Unix-сокетов. (Пользователем-владельцем сокетов всегда будет поль-
зователь, запускающий сервер.) В сочетании с unix_socket_permissions данный параметр
можно использовать как дополнительный механизм управления доступом к Unix-сокетам. По
508Настройка сервера
умолчанию он содержит пустую строку, то есть группой-владельцем становится основная груп-
па пользователя, запускающего сервер. Задать этот параметр можно только при запуске сер-
вера.
Этот параметр не действует в системе Windows, так как в ней нет Unix-сокетов.
unix_socket_permissions (integer)
Задаёт права доступа к Unix-сокетам. Для Unix-сокетов применяется обычный набор разреше-
ний Unix. Значение параметра ожидается в числовом виде, который принимают функции chmod
и umask. (Для применения обычного восьмеричного формата число должно начинаться с 0 (ну-
ля).)
По умолчанию действуют разрешения 0777, при которых подключаться к сокету могут все.
Другие разумные варианты — 0770 (доступ имеет только пользователь и группа, см. также
unix_socket_group) и 0700 (только пользователь). (Заметьте, что для Unix-сокетов требуется
только право на запись, так что добавлять или отзывать права на чтение/выполнение не имеет
смысла.)
Этот механизм управления доступом не зависит от описанного в Главе 20.
Этот параметр можно задать только при запуске сервера.
Данный параметр неприменим для некоторых систем, в частности, Solaris (а именно Solaris
10), которые полностью игнорируют разрешения для сокетов. В таких системах примерно тот
же эффект можно получить, указав в параметре unix_socket_directories каталог, доступ к
которому ограничен должным образом. Этот параметр также неприменим в Windows, где нет
Unix-сокетов.
bonjour (boolean)
Включает объявления о существовании сервера посредством Bonjour. По умолчанию выключен.
Задать этот параметр можно только при запуске сервера.
bonjour_name (string)
Задаёт имя службы в среде Bonjour. Если значение этого параметра — пустая строка (‘’) (это
значение по умолчанию), в качестве этого имени используется имя компьютера. Этот параметр
игнорируется, если сервер был скомпилирован без поддержки Bonjour. Задать этот параметр
можно только при запуске сервера.
tcp_keepalives_idle (integer)
Задаёт период неактивности (в секундах), после которого по TCP клиенту должен отправлять-
ся сигнал сохранения соединения. При значении 0 действует системный параметр. Этот пара-
метр поддерживается только в системах, воспринимающих параметр сокета TCP_KEEPIDLE или
равнозначный, и в Windows; в других системах он должен быть равен нулю. В сеансах, подклю-
чённых через Unix-сокеты, он игнорируется и всегда считается равным 0.
Примечание
В Windows при нулевом значении этот период устанавливается равным 2 часам, так
как Windows не позволяет прочитать системное значение по умолчанию.
tcp_keepalives_interval (integer)
Задаёт интервал (в секундах), по истечении которого следует повторять сигнал сохранения со-
единения, если ответ от клиента не был получен. При значении 0 действует системное зна-
чение. Этот параметр поддерживается только в системах, воспринимающих параметр сокета
509Настройка сервера
TCP_KEEPINTVL или равнозначный, и в Windows; в других системах он должен быть равен нулю.
В сеансах, подключённых через Unix-сокеты, он игнорируется и всегда считается равным 0.
Примечание
В Windows при нулевом значении этот интервал устанавливается равным 1 секунде,
так как Windows не позволяет прочитать системное значение по умолчанию.
tcp_keepalives_count (integer)
Задаёт число TCP-сигналов сохранения соединения, которые могут быть потеряны до того, как
соединение сервера с клиентом будет признано прерванным. При значении 0 действует си-
стемное значение. Этот параметр поддерживается только в системах, воспринимающих пара-
метр сокета TCP_KEEPCNT или равнозначный; в других системах он должен быть равен нулю. В
сеансах, подключённых через Unix-сокеты, он игнорируется и всегда считается равным 0.
Примечание
В Windows данный параметр не поддерживается и должен быть равен нулю.
19.3.2. Аутентификация
authentication_timeout (integer)
Максимальное время, за которое должна произойти аутентификация (в секундах). Если потен-
циальный клиент не сможет пройти проверку подлинности за это время, сервер закроет соеди-
нение. Благодаря этому, зависшие при подключении клиенты не будут занимать соединения
неограниченно долго. Значение этого параметра по умолчанию — одна минута (1m). Задать этот
параметр можно только в postgresql.conf или в командной строке при запуске сервера.
password_encryption (enum)
Когда в CREATE ROLE или ALTER ROLE задаётся пароль, этот параметр определяет, каким
алгоритмом его шифровать. Значение по умолчанию — md5 (пароль сохраняется в виде хеша
MD5), также в качестве псевдонима md5 принимается значение on. Значение scram-sha-256
указывает, что пароль будет шифроваться алгоритмом SCRAM-SHA-256.
Учтите, что старые клиенты могут не поддерживать механизм проверки подлинности SCRAM
и поэтому не будут работать с паролями, зашифрованными алгоритмом SCRAM-SHA-256. За
подробностями обратитесь к Разделу 20.5.
krb_server_keyfile (string)
Задаёт размещение файла ключей для сервера Kerberos. За подробностями обратитесь к Раз-
делу 20.6. Задать этот параметр можно только в postgresql.conf или в командной строке при
запуске сервера.
krb_caseins_users (boolean)
Определяет, должны ли имена пользователей GSSAPI обрабатываться без учёта регистра. По
умолчанию значение этого параметра — off (регистр учитывается). Задать этот параметр мож-
но только в postgresql.conf или в командной строке при запуске сервера.
db_user_namespace (boolean)
Этот параметр позволяет относить имена пользователей к базам данных. По умолчанию он
имеет значение off (выключен). Задать этот параметр можно только в postgresql.conf или в
командной строке при запуске сервера.
510Настройка сервера
Если он включён, имена создаваемых пользователей должны иметь вид имя_пользователя@ба-
за_данных. Когда подключающийся клиент передаёт имя_пользователя, к этому имени добав-
ляется @ с именем базы данных, и сервер идентифицирует пользователя по этому полному име-
ни. Заметьте, что для создания пользователя с именем, содержащим @, в среде SQL потребует-
ся заключить это имя в кавычки.
Когда этот параметр включён, он не мешает создавать и использовать обычных глобальных
пользователей. Чтобы подключиться с таким именем пользователя, достаточно добавить к име-
ни @, например так: joe@. Получив такое имя, сервер отбросит @, и будет идентифицировать
пользователя по начальному имени.
Параметр db_user_namespace порождает расхождение между именами пользователей на сто-
роне сервера и клиента. Но проверки подлинности всегда выполняются с именем с точки зре-
ния сервера, так что, настраивая аутентификацию, следует указывать серверное представле-
ние имени, а не клиентское. Так как метод аутентификации md5 подмешивает имя пользовате-
ля в качестве соли и на стороне сервера, и на стороне клиента, при включённом параметре
db_user_namespace использовать md5 невозможно.
Примечание
Эта возможность предлагается в качестве временной меры, пока не будет найдено
полноценное решение. Тогда этот параметр будет ликвидирован.
19.3.3. SSL
Дополнительную информацию о настройке SSL можно получить в Разделе 18.9.
ssl (boolean)
Разрешает подключения SSL. Этот параметр можно задать только в postgresql.conf или в
командной строке при запуске сервера. Значение по умолчанию — off.
ssl_ca_file (string)
Задаёт имя файла, содержащего сертификаты центров сертификации (ЦС) для SSL-сервера.
При указании относительного пути он рассматривается от каталога данных. Этот параметр
можно задать только в postgresql.conf или в командной строке при запуске сервера. По умол-
чанию этот параметр пуст, что означает, что файл сертификатов ЦС не загружается и проверка
клиентских сертификатов не производится.
ssl_cert_file (string)
Задаёт имя файла, содержащего сертификат этого SSL-сервера. При указании относитель-
ного пути он рассматривается от каталога данных. Этот параметр можно задать только в
postgresql.conf или в командной строке при запуске сервера. Значение по умолчанию —
server.crt.
ssl_crl_file (string)
Задаёт имя файла, содержащего список отзыва сертификатов (CRL, Certificate Revocation List)
для SSL-сервера. При указании относительного пути он рассматривается от каталога данных.
Этот параметр можно задать только в postgresql.conf или в командной строке при запуске
сервера. По умолчанию этот параметр пуст, что означает, что файл CRL не загружается.
ssl_key_file (string)
Задаёт имя файла, содержащего закрытый ключ SSL-сервера. Этот параметр можно задать
только в postgresql.conf или в командной строке при запуске сервера. Значение по умолча-
нию — server.key.
511Настройка сервера
ssl_ciphers (string)
Задаёт список наборов шифров SSL, которые могут применяться для защиты соединений. Син-
таксис этого параметра и список поддерживаемых значений можно найти на странице ciphers
руководства по OpenSSL. Этот параметр можно задать только в postgresql.conf или в команд-
ной строке при запуске сервера. Значение по умолчанию — HIGH:MEDIUM:+3DES:!aNULL. Обыч-
но оно вполне приемлемо при отсутствии особых требований по безопасности.
Объяснение значения по умолчанию:
HIGH
Наборы шифров, в которых используются шифры из группы высокого уровня (HIGH), (напри-
мер: AES, Camellia, 3DES)
MEDIUM
Наборы шифров, в которых используются шифры из группы среднего уровня (MEDIUM) (на-
пример, RC4, SEED)
+3DES
Порядок шифров для группы HIGH по умолчанию в OpenSSL определён некорректно. В нём
3DES оказывается выше AES128, что неправильно, так как он считается менее безопасным,
чем AES128, и работает гораздо медленнее. Включение +3DES меняет этот порядок, чтобы
данный алгоритм следовал после всех шифров групп HIGH и MEDIUM.
!aNULL
Отключает наборы анонимных шифров, не требующие проверки подлинности. Такие наборы
уязвимы для атак с посредником, поэтому использовать их не следует.
Конкретные наборы шифров и их свойства очень различаются от версии к версии OpenSSL.
Чтобы получить фактическую информацию о них для текущей установленной версии OpenSSL,
выполните команду openssl ciphers -v ‘HIGH:MEDIUM:+3DES:!aNULL’. Учтите, что этот список
фильтруется во время выполнения, в зависимости от типа ключа сервера.
ssl_prefer_server_ciphers (boolean)
Определяет, должны ли шифры SSL сервера предпочитаться клиентским. Этот параметр мож-
но задать только в postgresql.conf или в командной строке при запуске сервера. Значение по
умолчанию — true.
В старых версиях PostgreSQL этот параметр отсутствовал и предпочтение отдавалось выбору
клиента. Введён этот параметр в основном для обеспечения совместимости с этими версиями.
Вообще же обычно лучше использовать конфигурацию сервера, так как в конфигурации на
стороне клиента более вероятны ошибки.
ssl_ecdh_curve (string)
Задаёт имя кривой для использования при обмене ключами ECDH. Эту кривую должны поддер-
живать все подключающиеся клиенты. Это не обязательно должна быть кривая, с которой был
получен ключ сервера. Этот параметр можно задать только в postgresql.conf или в командной
строке при запуске сервера. Значение по умолчанию — prime256v1.
Наиболее распространённые кривые в OpenSSL — prime256v1 (NIST P-256), secp384r1 (NIST
P-384), secp521r1 (NIST P-521). Полный список доступных кривых можно получить командой
openssl ecparam -list_curves. Однако не все из них пригодны для TLS.
ssl_dh_params_file (string)
Задаёт имя файла с параметрами алгоритма Диффи-Хеллмана, применяемого для так называ-
емого эфемерного семейства DH шифров SSL. По умолчанию значение пустое, то есть исполь-
зуются стандартные параметры DH, заданные при компиляции. Использование нестандартных
512Настройка сервера
параметров DH защищает от атаки, рассчитанной на взлом хорошо известных встроенных па-
раметров DH. Создать собственный файл с параметрами DH можно, выполнив команду openssl
dhparam -out dhparams.pem 2048.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
ssl_passphrase_command (string)
Задаёт внешнюю команду, которая будет вызываться, когда потребуется пароль для расшиф-
ровывания SSL-файла, например закрытого ключа. По умолчанию этот параметр не определён,
то есть пароль будет запрашиваться встроенным механизмом.
Эта команда должна вывести пароль на устройство стандартного вывода и завершиться с кодом</p>
<ol>
  <li>В строке параметра %p заменяется строкой приглашения. (Напишите %%, чтобы вывести %
буквально.) Заметьте, что строка приглашения, вероятно, будет содержать пробелы, так что
её нужно будет заключить в кавычки. Если в конце добавлен один перевод строки, он будет
отфильтрован при выводе.
Эта команда не обязательно должна запрашивать пароль у пользователя. Она может считать
его из файла, извлечь из системной связки ключей или получить другими подобными средства-
ми. Ответственность за выбор достаточно безопасного механизма возлагается на пользователя.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
ssl_passphrase_command_supports_reload (boolean)
Этот параметр определяет, будет ли заданная параметром ssl_passphrase_command коман-
да, запрашивающая пароль, также вызываться при перезагрузке конфигурации, если для
файла ключа требуется пароль. Если этот параметр равен false (по умолчанию), команда
ssl_passphrase_command будет игнорироваться при перезагрузке, и конфигурация SSL не бу-
дет обновляться, если требуется пароль. Это значение подходит для команды, требующей для
ввода пароля наличия терминала TTY, который может быть недоступен в процессе работы сер-
вера. Значение true для данного параметра может быть уместно, если, например, пароль счи-
тывается из файла.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
19.4. Потребление ресурсов
19.4.1. Память
shared_buffers (integer)
Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделя-
емой памяти. По умолчанию это обычно 128 мегабайт (128MB), но может быть и меньше, ес-
ли конфигурация вашего ядра накладывает дополнительные ограничения (это определяется
в процессе initdb). Это значение не должно быть меньше 128 килобайт. (Этот минимум зави-
сит от величины BLCKSZ.) Однако для хорошей производительности обычно требуются гораздо
большие значения. Задать этот параметр можно только при запуске сервера.
Если вы используете выделенный сервер с объёмом ОЗУ 1 ГБ и более, разумным начальным
значением shared_buffers будет 25% от объёма памяти. Существуют варианты нагрузки, при
которых эффективны будут и ещё большие значения shared_buffers, но так как PostgreSQL
использует и кеш операционной системы, выделять для shared_buffers более 40% ОЗУ вряд ли
будет полезно. При увеличении shared_buffers обычно требуется соответственно увеличить
max_wal_size, чтобы растянуть процесс записи большого объёма новых или изменённых данных
на более продолжительное время.
513Настройка сервера
В системах с объёмом ОЗУ меньше 1 ГБ стоит ограничиться меньшим процентом ОЗУ, чтобы
оставить достаточно места операционной системе.
huge_pages (enum)
Определяет, будут ли огромные страницы запрашиваться из основной области общей памяти.
Допустимые значения: try (по умолчанию), on и off. Когда параметр huge_pages равен try,
сервер будет пытаться запрашивать огромные страницы, но если это ему не удастся, вернётся
к стандартному поведению. Со значением on, если получить огромные страницы не удастся,
сервер не будет запущен. Со значением off большие страницы не будут запрашиваться.
В настоящее время это поддерживается только в Linux и Windows. Во всех других системах
значение try просто игнорируется.
В результате использования огромных страниц уменьшаются таблицы страниц, и процессор
тратит меньше времени на управление памятью, что приводит к увеличению быстродействия.
За более подробной информацией об использовании огромных страниц в Linux обратитесь к
Подразделу 18.4.5.
Огромные страницы в Windows называются большими страницами. Чтобы использовать их,
необходимо дать пользователю Windows, от имени которого работает PostgreSQL, право блоки-
ровать страницы. Для назначения пользователю этого права вы можете воспользоваться сред-
ством управления групповой политикой Windows (gpedit.msc). Чтобы сервер баз данных запус-
кался в командной строке как отдельный процесс, а не как служба Windows, приглашение ко-
мандной строки должно запускаться от имени администратора или должен быть отключён ме-
ханизм UAC (User Access Control, Контроль учётных записей пользователей). Когда UAC вклю-
чён, в обычном командном приглашении пользователь лишается права блокировать большие
страницы в памяти.
Заметьте, что этот параметр влияет только на основную область общей памяти. В операцион-
ных системах, таких как Linux, FreeBSD и Illumos огромные страницы (также называемые «су-
перстраницами» или «большими» страницами) могут также автоматически использоваться при
обычном выделении памяти, без явного запроса со стороны PostgreSQL. В Linux это называется
«прозрачными огромными страницами»(Transparent Huge Pages, THP). Известно, что это при-
водит к снижению быстродействия PostgreSQL в некоторых системах Linux у ряда пользовате-
лей, поэтому использовать этот механизм в настоящее время не рекомендуется (в отличие от
явного использования huge_pages).
temp_buffers (integer)
Задаёт максимальное число временных буферов для каждого сеанса, По умолчанию объём вре-
менных буферов составляет восемь мегабайт (1024 буфера). Этот параметр можно изменить в
отдельном сеансе, но только до первого обращения к временным таблицам; после этого изме-
нить его значение для текущего сеанса не удастся.
Сеанс выделяет временные буферы по мере необходимости до достижения предела, заданного
параметром temp_buffers. Если сеанс не задействует временные буферы, то для него хранятся
только дескрипторы буферов, которые занимают около 64 байтов (в количестве temp_buffers).
Однако если буфер действительно используется, он будет дополнительно занимать 8192 байта
(или в общем случае, BLCKSZ байтов).
max_prepared_transactions (integer)
Задаёт максимальное число транзакций, которые могут одновременно находиться в «подготов-
ленном» состоянии (см. PREPARE TRANSACTION). При нулевом значении (по умолчанию) ме-
ханизм подготовленных транзакций отключается. Задать этот параметр можно только при за-
пуске сервера.
Если использовать транзакции не планируется, этот параметр следует обнулить, чтобы не до-
пустить непреднамеренного создания подготовленных транзакций. Если же подготовленные
514Настройка сервера
транзакции применяются, то max_prepared_transactions, вероятно, должен быть не меньше,
чем max_connections, чтобы подготовить транзакцию можно было в каждом сеансе.
Для ведомого сервера значение этого параметра должно быть больше или равно значению на
ведущем. В противном случае на ведомом сервере не будут разрешены запросы.
work_mem (integer)
Задаёт объём памяти, который будет использоваться для внутренних операций сортировки и
хеш-таблиц, прежде чем будут задействованы временные файлы на диске. Значение по умол-
чанию — четыре мегабайта (4MB). Заметьте, что в сложных запросах одновременно могут вы-
полняться несколько операций сортировки или хеширования, так что этот объём памяти будет
доступен для каждой операции. Кроме того, такие операции могут выполняться одновременно
в разных сеансах. Таким образом, общий объём памяти может многократно превосходить зна-
чение work_mem; это следует учитывать, выбирая подходящее значение. Операции сортировки
используются для ORDER BY, DISTINCT и соединений слиянием. Хеш-таблицы используются при
соединениях и агрегировании по хешу, а также обработке подзапросов IN с применением хеша.
maintenance_work_mem (integer)
Задаёт максимальный объём памяти для операций обслуживания БД, в частности VACUUM,
CREATE INDEX и ALTER TABLE ADD FOREIGN KEY. По умолчанию его значение — 64 мегабайта
(64MB). Так как в один момент времени в сеансе может выполняться только одна такая опе-
рация, и обычно они не запускаются параллельно, это значение вполне может быть гораздо
больше work_mem. Увеличение этого значения может привести к ускорению операций очистки
и восстановления БД из копии.
Учтите, что когда выполняется автоочистка, этот объём может быть выделен
autovacuum_max_workers раз, поэтому не стоит устанавливать значение по умолчанию слиш-
ком большим. Возможно, будет лучше управлять объёмом памяти для автоочистки отдельно,
изменяя autovacuum_work_mem.
autovacuum_work_mem (integer)
Задаёт максимальный объём памяти, который будет использовать каждый рабочий процесс
автоочистки. По умолчанию равен -1, что означает, что этот объём определяется значением
maintenance_work_mem. Этот параметр не влияет на поведение команды VACUUM, выполняемой
в других контекстах.
max_stack_depth (integer)
Задаёт максимальную безопасную глубину стека для исполнителя. В идеале это значение долж-
но равняться предельному размеру стека, ограниченному ядром (как устанавливает команда
ulimit -s или равнозначные ей), за вычетом запаса примерно в мегабайт. Этот запас необхо-
дим, потому что сервер проверяет глубину стека не в каждой процедуре, а только в потенци-
ально рекурсивных процедурах, например, при вычислении выражений. Значение по умолча-
нию — два мегабайта (2MB), выбрано с большим запасом, так что риск переполнения стека ми-
нимален. Однако, с другой стороны, его может быть недостаточно для выполнения сложных
функций. Изменить этот параметр могут только суперпользователи.
Если max_stack_depth будет превышать фактический предел ядра, то функция с неограничен-
ной рекурсией сможет вызвать крах отдельного процесса сервера. В системах, где PostgreSQL
может определить предел, установленный ядром, он не позволит установить для этого пара-
метра небезопасное значение. Однако эту информацию выдают не все системы, поэтому выби-
рать это значение следует с осторожностью.
dynamic_shared_memory_type (enum)
Выбирает механизм динамической разделяемой памяти, который будет использовать сервер.
Допустимые варианты: posix (для выделения разделяемой памяти POSIX функцией shm_open),
sysv (для выделения разделяемой памяти System V функцией shmget), windows (для выделения
515Настройка сервера
разделяемой памяти в Windows), mmap (для эмуляции разделяемой памяти через отображение
в память файлов, хранящихся в каталоге данных) и none (для отключения этой функциональ-
ности). Не все варианты поддерживаются на разных платформах; первый из поддерживаемых
данной платформой вариантов становится для неё вариантом по умолчанию. Применять mmap,
который нигде не выбирается по умолчанию, вообще не рекомендуется, так как операционная
система может периодически записывать на диск изменённые страницы, что создаст дополни-
тельную нагрузку; однако, это может быть полезно для отладки, когда каталог pg_dynshmem
находится в RAM-диске или когда другие механизмы разделяемой памяти недоступны.
19.4.2. Диск
temp_file_limit (integer)
Задаёт максимальный объём дискового пространства, который сможет использовать один про-
цесс для временных файлов, например, при сортировке и хешировании, или для сохранения
удерживаемого курсора. Транзакция, которая попытается превысить этот предел, будет отме-
нена. Этот параметр задаётся в килобайтах, а значение -1 (по умолчанию) означает, что пре-
дел отсутствует. Изменить этот параметр могут только суперпользователи.
Этот параметр ограничивает общий объём, который могут занимать в момент времени все вре-
менные файлы, задействованные в данном процессе PostgreSQL. Следует отметить, что при
этом учитывается только место, занимаемое явно создаваемыми временными таблицами; на
временные файлы, которые создаются неявно при выполнении запроса, это ограничение не
распространяется.
19.4.3. Использование ресурсов ядра
max_files_per_process (integer)
Задаёт максимальное число файлов, которые могут быть одновременно открыты каждым сер-
верным подпроцессом. Значение по умолчанию — 1000 файлов. Если ядро реализует безопас-
ное ограничение по процессам, об этом параметре можно не беспокоиться. Но на некоторых
платформах (а именно, в большинстве систем BSD) ядро позволяет отдельному процессу от-
крыть больше файлов, чем могут открыть несколько процессов одновременно. Если вы столкнё-
тесь с ошибками «Too many open files» (Слишком много открытых файлов), попробуйте умень-
шить это число. Задать этот параметр можно только при запуске сервера.
19.4.4. Задержка очистки по стоимости
Во время выполнения команд VACUUM и ANALYZE система ведёт внутренний счётчик, в котором
суммирует оцениваемую стоимость различных выполняемых операций ввода/вывода. Когда накоп-
ленная стоимость превышает предел (vacuum_cost_limit), процесс, выполняющий эту операцию,
засыпает на некоторое время (vacuum_cost_delay). Затем счётчик сбрасывается и процесс продол-
жается.
Данный подход реализован для того, чтобы администраторы могли снизить влияние этих команд
на параллельную работу с базой, за счёт уменьшения нагрузки на подсистему ввода-вывода. Очень
часто не имеет значения, насколько быстро выполнятся команды обслуживания (например, VACUUM
и ANALYZE), но очень важно, чтобы они как можно меньше влияли на выполнение других опера-
ций с базой данных. Администраторы имеют возможность управлять этим, настраивая задержку
очистки по стоимости.
По умолчанию этот режим отключён для выполняемых вручную команд VACUUM. Чтобы включить
его, нужно установить в vacuum_cost_delay ненулевое значение.
vacuum_cost_delay (integer)
Продолжительность времени, в миллисекундах, в течение которого будет простаивать процесс,
превысивший предел стоимости. По умолчанию его значение равно нулю, то есть задержка
очистки отсутствует. При положительных значениях интенсивность очистки будет зависеть от
516Настройка сервера
стоимости. Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому
если задать в vacuum_cost_delay значение, не кратное 10, фактически будет получен тот же
результат, что и со следующим за ним кратным 10.
При настройке интенсивности очистки для vacuum_cost_delay обычно выбираются довольно
небольшие значения, например 10 или 20 миллисекунд. Чтобы точнее ограничить потребление
ресурсов при очистке, лучше всего изменять другие параметры стоимости очистки.
vacuum_cost_page_hit (integer)
Примерная стоимость очистки буфера, оказавшегося в общем кеше. Это подразумевает блоки-
ровку пула буферов, поиск в хеш-таблице и сканирование содержимого страницы. По умолча-
нию этот параметр равен одному.
vacuum_cost_page_miss (integer)
Примерная стоимость очистки буфера, который нужно прочитать с диска. Это подразумевает
блокировку пула буферов, поиск в хеш-таблице, чтение требуемого блока с диска и сканирова-
ние его содержимого. По умолчанию этот параметр равен 10.
vacuum_cost_page_dirty (integer)
Примерная стоимость очистки, при которой изменяется блок, не модифицированный ранее.
В неё включается дополнительная стоимость ввода/вывода, связанная с записью изменённого
блока на диск. По умолчанию этот параметр равен 20.
vacuum_cost_limit (integer)
Общая стоимость, при накоплении которой процесс очистки будет засыпать. По умолчанию
этот параметр равен 200.
Примечание
Некоторые операции устанавливают критические блокировки и поэтому должны за-
вершаться как можно быстрее. Во время таких операций задержка очистки по стои-
мости не осуществляется, так что накопленная за это время стоимость может намно-
го превышать установленный предел. Во избежание ненужных длительных задержек
в таких случаях, фактическая задержка вычисляется по формуле vacuum_cost_delay
    <ul>
      <li>accumulated_balance / vacuum_cost_limit и ограничивается максимумом, равным
vacuum_cost_delay * 4.
19.4.5. Фоновая запись
В числе специальных процессов сервера есть процесс фоновой записи, задача которого — осу-
ществлять запись «грязных» (новых или изменённых) общих буферов на диск. Он старается за-
писывать данные из буферов так, чтобы обычным серверным процессам, обрабатывающим запро-
сы, не приходилось ждать записи или это ожидание было минимальным. Однако процесс фоновой
записи увеличивает общую нагрузку на подсистему ввода/вывода, так как он может записывать
неоднократно изменяемую страницу при каждом изменении, тогда как она может быть записана
всего раз в контрольной точке. Параметры, рассматриваемые в данном подразделе, позволяют на-
строить поведение фоновой записи для конкретных нужд.
bgwriter_delay (integer)
Задаёт задержку между раундами активности процесса фоновой записи. Во время раунда этот
процесс осуществляет запись некоторого количество загрязнённых буферов (это настраивает-
ся следующими параметрами). Затем он засыпает на время bgwriter_delay (задаваемое в мил-
лисекундах), и всё повторяется снова. Однако если в пуле не остаётся загрязнённых буферов,
он может быть неактивен более длительное время. По умолчанию этот параметр равен 200
517Настройка сервера
миллисекундам (200ms). Заметьте, что во многих системах разрешение таймера составляет 10
мс, поэтому если задать в bgwriter_delay значение, не кратное 10, фактически будет получен
тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только
в postgresql.conf или в командной строке при запуске сервера.
bgwriter_lru_maxpages (integer)
Задаёт максимальное число буферов, которое сможет записать процесс фоновой записи за ра-
унд активности. При нулевом значении фоновая запись отключается. (Учтите, что на контроль-
ные точки, которые управляются отдельным вспомогательным процессом, это не влияет.) По
умолчанию значение этого параметра — 100 буферов. Задать этот параметр можно только в
postgresql.conf или в командной строке при запуске сервера.
bgwriter_lru_multiplier (floating point)
Число загрязнённых буферов, записываемых в очередном раунде, зависит от того, сколько
новых буферов требовалось серверным процессам в предыдущих раундах. Средняя недавняя
потребность умножается на bgwriter_lru_multiplier и предполагается, что именно столь-
ко буферов потребуется на следующем раунде. Процесс фоновой записи будет записывать
на диск и освобождать буферы, пока число свободных буферов не достигнет целевого зна-
чения. (При этом число буферов, записываемых за раунд, ограничивается сверху парамет-
ром bgwriter_lru_maxpages.) Таким образом, со множителем, равным 1.0, записывается ровно
столько буферов, сколько требуется по предположению («точно по плану»). Увеличение этого
множителя даёт некоторую страховку от резких скачков потребностей, тогда как уменьшение
отражает намерение оставить некоторый объём записи для серверных процессов. По умолча-
нию он равен 2.0. Этот параметр можно установить только в файле postgresql.conf или в ко-
мандной строке при запуске сервера.
bgwriter_flush_after (integer)
Когда процессом фоновой записи записывается больше чем bgwriter_flush_after байт, сервер
даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничи-
вает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность затормажи-
вания при выполнении fsync в конце контрольной точки или когда ОС сбрасывает данные на
диск большими порциями в фоне. Часто это значительно уменьшает задержки транзакций, но
бывают ситуации, особенно когда объём рабочей нагрузки больше shared_buffers, но меньше
страничного кеша ОС, когда производительность может упасть. Этот параметр действует не на
всех платформах. Он может принимать значение от 0 (при этом управление отложенной запи-
сью отключается) до 2 Мбайт (2MB). Значение по умолчанию — 512kB в Linux и 0 в других ОС.
(Если BLCKSZ отличен от 8 Кбайт, значение по умолчанию и максимум корректируются про-
порционально.) Задать этот параметр можно только в postgresql.conf или в командной строке
при запуске сервера.
С маленькими значениями bgwriter_lru_maxpages и bgwriter_lru_multiplier уменьшается ак-
тивность ввода/вывода со стороны процесса фоновой записи, но увеличивается вероятность того,
что запись придётся производить непосредственно серверным процессам, что замедлит выполне-
ние запросов.
19.4.6. Асинхронное поведение
effective_io_concurrency (integer)
Задаёт допустимое число параллельных операций ввода/вывода, которое говорит PostgreSQL
о том, сколько операций ввода/вывода могут быть выполнены одновременно. Чем больше это
число, тем больше операций ввода/вывода будет пытаться выполнить параллельно PostgreSQL
в отдельном сеансе. Допустимые значения лежат в интервале от 1 до 1000, а нулевое значение
отключает асинхронные запросы ввода/вывода. В настоящее время этот параметр влияет толь-
ко на сканирование по битовой карте.
Для магнитных носителей хорошим начальным значением этого параметра будет число отдель-
ных дисков, составляющих массив RAID 0 или RAID 1, в котором размещена база данных. (Для
518Настройка сервера
RAID 5 следует исключить один диск (как диск с чётностью).) Однако, если база данных часто
обрабатывает множество запросов в различных сеансах, и при небольших значениях дисковый
массив может быть полностью загружен. Если продолжать увеличивать это значение при пол-
ной загрузке дисков, это приведёт только к увеличению нагрузки на процессор. Диски SSD и
другие виды хранилища в памяти часто могут обрабатывать множество параллельных запро-
сов, так что оптимальным числом может быть несколько сотен.
Асинхронный ввод/вывод зависит от эффективности функции posix_fadvise, которая отсут-
ствует в некоторых операционных системах. В случае её отсутствия попытка задать для этого
параметра любое ненулевое значение приведёт к ошибке. В некоторых системах (например, в
Solaris), эта функция присутствует, но на самом деле ничего не делает.
Значение по умолчанию равно 1 в системах, где это поддерживается, и 0 в остальных. Это зна-
чение можно переопределить для таблиц в определённом табличном пространстве, установив
одноимённый параметр табличного пространства (см. ALTER TABLESPACE).
max_worker_processes (integer)
Задаёт максимальное число фоновых процессов, которое можно запустить в текущей системе.
Этот параметр можно задать только при запуске сервера. Значение по умолчанию — 8.
Для ведомого сервера значение этого параметра должно быть больше или равно значению на
ведущем. В противном случае на ведомом сервере не будут разрешены запросы.
Одновременно с изменением этого значения также может быть полезно изменить
max_parallel_workers, max_parallel_maintenance_workers и max_parallel_workers_per_gather.
max_parallel_workers_per_gather (integer)
Задаёт максимальное число рабочих процессов, которые могут запускаться одним узлом
Gather или Gather Merge. Параллельные рабочие процессы берутся из пула процессов, кон-
тролируемого параметром max_worker_processes, в количестве, ограничиваемом значением
max_parallel_workers. Учтите, что запрошенное количество рабочих процессов может быть
недоступно во время выполнения. В этом случае план будет выполняться с меньшим числом
процессов, что может быть неэффективно. Значение по умолчанию — 2. Значение 0 отключает
параллельное выполнение запросов.
Учтите, что параллельные запросы могут потреблять значительно больше ресурсов, чем не па-
раллельные, так как каждый рабочий процесс является отдельным процессом и оказывает на
систему примерно такое же влияние, как дополнительный пользовательский сеанс. Это сле-
дует учитывать, выбирая значение этого параметра, а также настраивая другие параметры,
управляющие использованием ресурсов, например work_mem. Ограничения ресурсов, такие
как work_mem, применяются к каждому рабочему процессу отдельно, что означает, что общая
нагрузка для всех процессов может оказаться гораздо больше, чем при обычном использова-
нии одного процесса. Например, параллельный запрос, задействующий 4 рабочих процесса,
может использовать в 5 раз больше времени процессора, объёма памяти, ввода/вывода и т. д.,
по сравнению с запросом, не задействующим рабочие процессы вовсе.
За дополнительными сведениями о параллельных запросах обратитесь к Главе 15.
max_parallel_maintenance_workers (integer)
Задаёт максимальное число рабочих процессов, которые могут запускаться одной служеб-
ной командой. В настоящее время параллельные процессы может использовать только од-
на служебная команда, CREATE INDEX, и только при построении индекса-B-дерева. Па-
раллельные рабочие процессы берутся из пула процессов, контролируемого параметром
max_worker_processes, в количестве, ограничиваемом значением max_parallel_workers. Учтите,
что запрошенное количество рабочих процессов может быть недоступно во время выполнения.
В этом случае служебная операция будет выполняться с меньшим числом процессов, чем ожи-
далось. Значение по умолчанию — 2. Значение 0 отключает использование параллельных ис-
полнителей служебными командами.
519Настройка сервера
Заметьте, что параллельно выполняемые служебные команды не должны потреблять зна-
чительно больше памяти, чем равнозначные непараллельные операции. Это отличает их
от параллельных запросов, при выполнении которых ограничения ресурсов действуют на
отдельные рабочие процессы. Для параллельных служебных команд ограничение ресурсов
maintenance_work_mem считается действующим на команду в целом, вне зависимости от числа
параллельных рабочих процессов. Тем не менее, параллельные служебные команды могут го-
раздо больше нагружать процессор и каналы ввода/вывода.
max_parallel_workers (integer)
Задаёт максимальное число рабочих процессов, которое система сможет поддерживать для
параллельных операций. Значение по умолчанию — 8. При увеличении или уменьшения это-
го значения также может иметь смысл скорректировать max_parallel_maintenance_workers и
max_parallel_workers_per_gather. Заметьте, что значение данного параметра, превышающее
max_worker_processes, не будет действовать, так как параллельные рабочие процессы берутся
из пула рабочих процессов, ограничиваемого этим параметром.
backend_flush_after (integer)
Когда одним обслуживающим процессом записывается больше backend_flush_after байт, сер-
вер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограни-
чивает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность заторма-
живания при выполнении fsync в конце контрольной точки или когда ОС сбрасывает данные
на диск большими порциями в фоне. Часто это значительно сокращает задержки транзакций,
но бывают ситуации, особенно когда объём рабочей нагрузки больше shared_buffers, но мень-
ше страничного кеша ОС, когда производительность может упасть. Этот параметр действует
не на всех платформах. Он может принимать значение от 0 (при этом управление отложенной
записью отключается) до 2 Мбайт (2MB). По умолчанию он имеет значение 0, то есть это пове-
дение отключено. (Если BLCKSZ отличен от 8 Кбайт, максимальное значение корректируется
пропорционально.)
old_snapshot_threshold (integer)
Задаёт минимальное время, которое можно пользоваться снимком без риска получить ошибку
снимок слишком стар. Этот параметр можно задать только при запуске сервера.
По истечении этого времени старые данные могут вычищены. Это предотвращает замусорива-
ние данными снимков, которые остаются задействованными долгое время. Во избежание полу-
чения некорректных результатов из-за очистки данных, которые должны были бы наблюдаться
в снимке, клиенту будет выдана ошибка, если возраст снимка превысит заданный предел и из
этого снимка будет запрошена страница, изменённая со времени его создания.
Значение -1 (по умолчанию) отключает это поведение. Полезные значения для производствен-
ной среды могут лежать в интервале от нескольких часов до нескольких дней. Заданное значе-
ние округляется до минут, а минимальные значения (как например, 0 или 1min) допускаются
только потому, что они могут быть полезны при тестировании. Хотя допустимым будет и зна-
чение 60d (60 дней), учтите, что при многих видах нагрузки критичное замусоривание базы
или зацикливание идентификаторов транзакций может происходить в намного меньших вре-
менных отрезках.
Когда это ограничение действует, освобождённое пространство в конце отношения не может
быть отдано операционной системе, так как при этом будет удалена информация, необходимая
для выявления условия снимок слишком стар. Всё пространство, выделенное отношению, оста-
нется связанным с ним до тех пор, пока не будет освобождено явно (например, с помощью ко-
манды VACUUM FULL).
Установка этого параметра не гарантирует, что обозначенная ошибка будет выдаваться при
всех возможных обстоятельствах. На самом деле, если можно получить корректные результа-
ты, например, из курсора, материализовавшего результирующий набор, ошибка не будет вы-
дана, даже если нижележащие строки в целевой таблице были ликвидированы при очистке.
520Настройка сервера
Некоторые таблицы, например системные каталоги, не могут быть безопасно очищены в сжа-
тые сроки, так что на них этот параметр не распространяется. Для таких таблиц этот параметр
не сокращает раздувание, но и не чреват ошибкой снимок слишком стар при сканировании.
19.5. Журнал предзаписи
За дополнительной информацией о настройке этих параметров обратитесь к Разделу 30.4.
19.5.1. Параметры
wal_level (enum)
Параметр wal_level определяет, как много информации записывается в WAL. Со значением
replica (по умолчанию) в журнал записываются данные, необходимые для поддержки архиви-
рования WAL и репликации, включая запросы только на чтение на ведомом сервере. Вариант
minimal оставляет только информацию, необходимую для восстановления после сбоя или ава-
рийного отключения. Наконец, logical добавляет информацию, требующуюся для поддержки
логического декодирования. Каждый последующий уровень включает информацию, записыва-
емую на всех уровнях ниже. Задать этот параметр можно только при запуске сервера.
На уровне minimal некоторые массовые операции могут выполняться в обход журнала без рис-
ка потери данных, и при этом они выполнятся гораздо быстрее (см. Подраздел 14.4.7). В част-
ности, такая оптимизация возможна с операциями:
CREATE TABLE AS
CREATE INDEX
CLUSTER
COPY с таблицами, которые были созданы или опустошены в той же транзакции
Однако такой минимальный журнал не будет содержать достаточно информации для восста-
новления данных из базовой копии и журналов, поэтому для реализации стратегии архивации
WAL (см. archive_mode) и потоковой репликации необходим уровень replica или более высокий.
На уровне logical в журнал записывается та же информация, что и на уровне replica, плюс
информация, необходимая для извлечения из журнала наборов логических изменений. Повы-
шение уровня до logical приводит к значительному увеличению объёма WAL, особенно если
многие таблицы имеют характеристику REPLICA IDENTITY FULL и выполняется множество ко-
манд UPDATE и DELETE.
В выпусках до 9.6 для этого параметра допускались значения archive и hot_standby. Эти зна-
чения по-прежнему принимаются, но теперь отображаются в значение replica.
fsync (boolean)
Если этот параметр установлен, сервер PostgreSQL старается добиться, чтобы изменения были
записаны на диск физически, выполняя системные вызовы fsync() или другими подобными
методами (см. wal_sync_method). Это даёт гарантию, что кластер баз данных сможет вернуться
в согласованное состояние после сбоя оборудования или операционной системы.
Хотя отключение fsync часто даёт выигрыш в скорости, это может привести к неисправимой
порче данных в случае отключения питания или сбоя системы. Поэтому отключать fsync ре-
комендуется, только если вы легко сможете восстановить всю базу из внешнего источника.
В качестве примеров, когда отключение fsync неопасно, можно привести начальное наполне-
ние нового кластера данными из копии, обработку массива данных, после которой базу данных
можно удалить и создать заново, либо эксплуатацию копии базы данных только для чтения,
которая регулярно пересоздаётся и не используется для отработки отказа. Качественное обо-
рудование само по себе не является достаточной причиной для отключения fsync.
При смене значения fsync с off на on для надёжного восстановления также необходимо сбро-
сить все изменённые буферы из ядра в надёжное хранилище. Это можно сделать, когда сервер
521Настройка сервера
остановлен или когда режим fsync включён, с помощью команды initdb –sync-only, либо
выполнить команду sync, размонтировать файловую систему или перезагрузить сервер.
Во многих случаях отключение synchronous_commit для некритичных транзакций может дать
больший выигрыш в скорости, чем отключение fsync, при этом не добавляя риски повреждения
данных.
Параметр fsync можно задать только в файле postgresql.conf или в командной строке при
запуске сервера. Если вы отключаете этот параметр, возможно, имеет смысл отключить также
и full_page_writes.
synchronous_commit (enum)
Определяет, будет ли сервер при фиксировании транзакции ждать, пока записи из WAL сохра-
нятся на диске, прежде чем сообщить клиенту об успешном завершении операции. Допустимые
значения: on, remote_apply, remote_write, local и off. Значение по умолчанию (оно же самое
безопасное) — on. Со значением off может образоваться окно от момента, когда клиент узнаёт
об успешном завершении, до момента, когда транзакция действительно гарантированно защи-
щена от сбоя. (Максимальный размер окна равен тройному значению wal_writer_delay.) В отли-
чие от fsync, значение off для этого параметра не угрожает целостности данных: сбой операци-
онной системы или базы данных может привести к потере последних транзакций, считавшихся
зафиксированными, но состояние базы данных будет точно таким же, как и в случае штатного
прерывания этих транзакций. Поэтому выключение режима synchronous_commit может быть
полезной альтернативой отключению fsync, когда производительность важнее, чем надёжная
гарантия сохранности каждой транзакции. Подробнее это обсуждается в Разделе 30.3.
Если задано значение synchronous_standby_names, этот параметр также определяет, будет ли
сервер при фиксировании транзакции ждать, пока выполнится репликация соответствующих
записей WAL на ведомый сервер(ы). Со значением on фиксирование завершается только по-
сле получения ответов от текущих синхронных ведомых серверов, подтверждающих, что они
получили запись о фиксировании транзакции и сохранили её на диске. Это гарантирует, что
транзакция не будет потеряна, если только база данных не будет повреждена и на ведущем,
и на всех синхронных ведомых серверах. Со значением remote_apply фиксирование заверша-
ется после получения ответов от синхронных ведомых серверов, говорящих, что они получили
запись о фиксировании транзакции и применили её, так что она стала видна для запросов на
этих серверах. Со значением remote_write фиксирование завершается после получения отве-
тов от текущих синхронных серверов, говорящих, что они получили запись о фиксировании
транзакции и передали её ОС для сохранения на диске. Этот вариант позволяет гарантировать
сохранность данных даже в случае отказа ведомого сервера PostgreSQL, но не в случае сбоя
на уровне ОС, так как данные могут ещё не достичь надёжного хранилища на этом сервере.
Наконец, со значением local фиксирование завершается после локального сброса данных, не
дожидаясь репликации. Обычно это нежелательный вариант при синхронной репликации, но
он представлен для полноты.
Если параметр synchronous_standby_names пуст, варианты on, remote_apply, remote_write и
local реализуют одинаковый уровень синхронизации: при фиксировании транзакции сервер
ждёт только сохранения данных на локальный диск.
Этот параметр можно изменить в любое время; поведение каждой конкретной транзакции
определяется значением, действующим в момент её фиксирования. Таким образом, есть воз-
можность и смысл фиксировать некоторые транзакции синхронно, а другие — асинхронно.
Например, чтобы зафиксировать одну транзакцию из нескольких команд асинхронно, когда
по умолчанию выбран противоположный вариант, выполните в этой транзакции SET LOCAL
synchronous_commit TO OFF.
wal_sync_method (enum)
Метод, применяемый для принудительного сохранения изменений WAL на диске. Если режим
fsync отключён, данный параметр не действует, так как принудительное сохранение измене-
ний WAL не производится вовсе. Возможные значения этого параметра:
522Настройка сервера
• open_datasync (для сохранения файлов WAL открывать их функцией open() с параметром
O_DSYNC)
• fdatasync (вызывать fdatasync() при каждом фиксировании)
• fsync (вызывать fsync() при каждом фиксировании)
• fsync_writethrough (вызывать fsync() при каждом фиксировании, форсируя сквозную за-
пись кеша)
• open_sync (для сохранения файлов WAL открывать их функцией open() с параметром
O_SYNC)
Варианты open_* также применяют флаг O_DIRECT, если он доступен. Не все эти методы под-
держивается в разных системах. По умолчанию выбирается первый из этих методов, который
поддерживается текущей системой, с одним исключением — в Linux по умолчанию выбирается
fdatasync. Выбираемый по умолчанию вариант не обязательно будет идеальным; в зависимо-
сти от требований к отказоустойчивости или производительности может потребоваться скор-
ректировать выбранное значение или внести другие изменения в конфигурацию вашей систе-
мы. Соответствующие аспекты конфигурации рассматриваются в Разделе 30.1. Этот параметр
можно задать только в файле postgresql.conf или в командной строке при запуске сервера.
full_page_writes (boolean)
Когда этот параметр включён, сервер PostgreSQL записывает в WAL всё содержимое каждой
страницы при первом изменении этой страницы после контрольной точки. Это необходимо,
потому что запись страницы, прерванная при сбое операционной системы, может выполнить-
ся частично, и на диске окажется страница, содержащая смесь старых данных с новыми. При
этом информации об изменениях на уровне строк, которая обычно сохраняется в WAL, будет
недостаточно для получения согласованного содержимого такой страницы при восстановле-
нии после сбоя. Сохранение образа всей страницы гарантирует, что страницу можно восста-
новить корректно, ценой увеличения объёма данных, которые будут записываться в WAL. (Так
как воспроизведение WAL всегда начинается от контрольной точки, достаточно сделать это
при первом изменении каждой страницы после контрольной точки. Таким образом, уменьшить
затраты на запись полных страниц можно, увеличив интервалы контрольных точек.)
Отключение этого параметра ускоряет обычные операции, но может привести к неисправимо-
му повреждению или незаметной порче данных после сбоя системы. Так как при этом возни-
кают практически те же риски, что и при отключении fsync, хотя и в меньшей степени, отклю-
чать его следует только при тех же обстоятельствах, которые перечислялись в рекомендациях
для вышеописанного параметра.
Отключение этого параметра не влияет на возможность применения архивов WAL для восста-
новления состояния на момент времени (см. Раздел 25.3).
Этот параметр можно задать только в postgresql.conf или в командной строке при запуске
сервера. По умолчанию этот параметр имеет значение on.
wal_log_hints (boolean)
Когда этот параметр имеет значение on, сервер PostgreSQL записывает в WAL всё содержимое
каждой страницы при первом изменении этой страницы после контрольной точки, даже при
второстепенных изменениях так называемых вспомогательных битов.
Если включён расчёт контрольных сумм данных, изменения вспомогательных битов всегда про-
ходят через WAL и этот параметр игнорируется. С помощью этого параметра можно проверить,
насколько больше дополнительной информации записывалось бы в журнал, если бы для базы
данных был включён подсчёт контрольных сумм.
Этот параметр можно задать только при запуске сервера. По умолчанию он имеет значение
off.
523Настройка сервера
wal_compression (boolean)
Когда этот параметр имеет значение on, сервер PostgreSQL сжимает образ полной страницы,
записываемый в WAL, когда включён режим full_page_writes или при создании базовой копии.
Сжатый образ страницы будет развёрнут при воспроизведении WAL. Значение по умолчанию
— off. Изменить этот параметр могут только суперпользователи.
Этот параметр позволяет без дополнительных рисков повреждения данных уменьшить объём
WAL, ценой дополнительной нагрузки на процессор, связанной со сжатием данных при записи
в WAL и разворачиванием их при воспроизведении WAL.
wal_buffers (integer)
Объём разделяемой памяти, который будет использоваться для буферизации данных WAL, ещё
не записанных на диск. Значение по умолчанию, равное -1, задаёт размер, равный 1/32 (около
3%) от shared_buffers, но не меньше, чем 64 КБ и не больше, чем размер одного сегмента WAL
(обычно 16 МБ). Это значение можно задать вручную, если выбираемое автоматически слишком
мало или велико, но при этом любое положительное число меньше 32 КБ будет восприниматься
как 32 КБ. Этот параметр можно задать только при запуске сервера.
Содержимое буферов WAL записывается на диск при фиксировании каждой транзакции, так
что очень большие значения вряд ли принесут значительную пользу. Однако значение как ми-
нимум в несколько мегабайт может увеличить быстродействие при записи на нагруженном
сервере, когда сразу множество клиентов фиксируют транзакции. Автонастройка, действую-
щая при значении по умолчанию (-1), в большинстве случаев выбирает разумные значения.
wal_writer_delay (integer)
Определяет, как часто процесс записи WAL будет сбрасывать WAL на диск. После очередного
сброса WAL он делает паузу на wal_writer_delay миллисекунд, но может быть пробуждён асин-
хронно фиксируемой транзакцией. Если предыдущая операция сброса имела место в последние
wal_writer_delay миллисекунд и за это время было получено меньше wal_writer_flush_after
байт WAL, данные WAL только передаются ОС, но не сбрасываются на диск. Значение по умол-
чанию — 200 миллисекунд (200ms). Заметьте, что во многих системах разрешение таймера па-
узы составляет 10 мс; если задать в wal_writer_delay значение, не кратное 10, может быть
получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно
только в postgresql.conf или в командной строке при запуске сервера.
wal_writer_flush_after (integer)
Определяет, как часто процесс записи WAL будет сбрасывать WAL на диск. Если предыдущая
операция сброса имела место в последние wal_writer_delay миллисекунд и за это время было
получено меньше wal_writer_flush_after байт WAL, данные WAL только передаются операци-
онной системе, но не сбрасываются на диск. Если wal_writer_flush_after равен 0, WAL сбра-
сывается на диск немедленно. Значение по умолчанию — 1 Мбайт (1MB). Задать этот параметр
можно только в postgresql.conf или в командной строке при запуске сервера.
commit_delay (integer)
Параметр commit_delay добавляет паузу (в микросекундах) перед собственно выполнением со-
хранения WAL. Эта задержка может увеличить быстродействие при фиксировании множества
транзакций, позволяя зафиксировать большее число транзакций за одну операции сохранения
WAL, если система нагружена достаточно сильно и за заданное время успевают зафиксиро-
ваться другие транзакции. Однако этот параметр также увеличивает задержку максимум до
commit_delay микросекунд при каждом сохранении WAL. Эта задержка окажется бесполезной,
если никакие другие транзакции не будут зафиксированы за это время, поэтому она добавляет-
ся, только в если момент запроса сохранения WAL активны как минимум commit_siblings дру-
гих транзакций. Кроме того, эти задержки не добавляются при выключенном fsync. По умол-
чанию значение commit_delay равно нулю (задержка отсутствует). Изменить этот параметр
могут только суперпользователи.
524Настройка сервера
В PostgreSQL до версии 9.3, параметр commit_delay работал по-другому и не так эффективно:
он задерживал только фиксирование транзакций, а не все операции сохранения WAL, и задан-
ная пауза выдерживалась полностью, даже если WAL удавалось сохранить быстрее. Начиная с
версии 9.3, заданное время ожидает только первый процесс, готовый произвести сохранение,
тогда как все последующие процессы ждут только, когда он закончит эту операцию.
commit_siblings (integer)
Минимальное число одновременно открытых транзакций, при котором будет добавляться за-
держка commit_delay. Чем больше это значение, тем больше вероятность, что минимум одна
транзакция окажется готовой к фиксированию за время задержки. По умолчанию это число
равно пяти.
19.5.2. Контрольные точки
checkpoint_timeout (integer)
Максимальное время между автоматическими контрольными точками в WAL (в секундах). До-
пускаются значения от 30 секунд до одного дня. Значение по умолчанию — пять минут (5min).
Увеличение этого параметра может привести к увеличению времени, которое потребуется для
восстановления после сбоя. Задать этот параметр можно только в postgresql.conf или в ко-
мандной строке при запуске сервера.
checkpoint_completion_target (floating point)
Задаёт целевое время для завершения процедуры контрольной точки, как коэффициент для
общего времени между контрольными точками. По умолчанию это значение равно 0.5. Задать
этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.
checkpoint_flush_after (integer)
Когда в процессе контрольной точки записывается больше чем checkpoint_flush_after байт,
сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это огра-
ничивает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность затор-
маживания при выполнении fsync в конце этой контрольной точки или когда ОС сбрасывает
данные на диск большими блоками в фоне. Часто это значительно уменьшает задержки тран-
закций, но бывают ситуации, особенно когда объём рабочей нагрузки больше shared_buffers,
но меньше страничного кеша ОС, когда производительность может упасть. Этот параметр дей-
ствует не на всех платформах. Он может принимать значение от 0 (при этом управление отло-
женной записью отключается) до 2 Мбайт (2MB). Значение по умолчанию — 256kB в Linux и 0 в
других ОС. (Если BLCKSZ отличен от 8 Кбайт, значение по умолчанию и максимум корректиру-
ются пропорционально.) Задать этот параметр можно только в postgresql.conf или в команд-
ной строке при запуске сервера.
checkpoint_warning (integer)
Записывать в журнал сервера сообщение в случае, если контрольные точки, вызванные запол-
нением файлов сегментов WAL, выполняются быстрее, чем через заданное число секунд (что
говорит о том, что значение max_wal_size нужно увеличить). Значение по умолчанию равно 30
секундам (30s). При нуле это предупреждение отключается. Если checkpoint_timeout меньше,
чем checkpoint_warning, предупреждения так же не будут выводиться. Задать этот параметр
можно только в postgresql.conf или в командной строке при запуске сервера.
max_wal_size (integer)
Максимальный размер, до которого может вырастать WAL между автоматическими контроль-
ными точками в WAL. Это мягкий предел; размер WAL может превышать max_wal_size при осо-
бых обстоятельствах, например, при высокой нагрузке, сбое в archive_command или при боль-
шом значении wal_keep_segments. Значение по умолчанию — 1 ГБ. Увеличение этого пара-
метра может привести к увеличению времени, которое потребуется для восстановления после
525Настройка сервера
сбоя. Задать этот параметр можно только в postgresql.conf или в командной строке при за-
пуске сервера.
min_wal_size (integer)
Пока WAL занимает на диске меньше этого объёма, старые файлы WAL в контрольных точках
всегда перерабатываются, а не удаляются. Это позволяет зарезервировать достаточно места
для WAL, чтобы справиться с резкими скачками использования WAL, например, при выполне-
нии больших пакетных заданий. Значение по умолчанию — 80 МБ. Этот параметр можно уста-
новить только в postgresql.conf или в командной строке сервера.
19.5.3. Архивация
archive_mode (enum)
Когда параметр archive_mode включён, полные сегменты WAL передаются в хранилище архива
командой archive_command. Помимо значения off (выключающего архивацию) есть ещё два:
on (вкл.) и always (всегда). В обычном состоянии эти два режима не различаются, но в режиме
always архивация WAL активна и во время восстановления архива, и в резерве. В этом режиме
все файлы, восстановленные из архива или полученные при потоковой репликации, будут ар-
хивироваться (снова). За подробностями обратитесь к Подразделу 26.2.9.
Параметры archive_mode и archive_command разделены, чтобы команду архивации
(archive_command) можно было изменять, не отключая режим архивации. Этот параметр мож-
но задать только при запуске сервера. Режим архивации нельзя включить, когда установлен
минимальный уровень WAL (wal_level имеет значение minimal).
archive_command (string)
Команда локальной оболочки, которая будет выполняться для архивации завершённого сегмен-
та WAL. Любое вхождение %p в этой строке заменяется путём архивируемого файла, а вхожде-
ние %f заменяется только его именем. (Путь задаётся относительно рабочего каталога сервера,
то есть каталога данных кластера.) Чтобы вставить в команду символ %, его нужно записать
как %%. Важно, чтобы команда возвращала нулевой код выхода, только если она завершается
успешно. За дополнительной информацией обратитесь к Подразделу 25.3.1.
Этот параметр можно задать только в postgresql.conf или в командной строке при запус-
ке сервера. Если режим архивации (archive_mode) не был включён при запуске, этот па-
раметр игнорируется. Если значение archive_command — пустая строка (по умолчанию), но
archive_mode включён, архивация WAL временно отключается, но сервер продолжает накап-
ливать файлы сегментов WAL в ожидании, что команда будет вскоре определена. Если в каче-
стве archive_command задать команду, которая ничего не делает, но сообщает об успешном за-
вершении, например /bin/true (или REM в Windows), архивация по сути отключается, но при
этом нарушается цепочка файлов WAL, необходимых для восстановления архива, поэтому та-
кой вариант следует использовать только в особых случаях.
archive_timeout (integer)
Команда archive_command вызывается только для завершённых сегментов WAL. Поэтому, если
ваш сервер записывает мало данных WAL (или это наблюдается в некоторые периоды времени),
от завершения транзакции до надёжного сохранения её в архивном хранилище может пройти
довольно много времени. Для ограничения времени существования неархивированных данных
можно установить значение archive_timeout, чтобы сервер периодически переключался на
новый файл сегмента WAL. Когда этот параметр больше нуля, сервер будет переключаться на
новый файл сегмента, если с момента последнего переключения на новый файл пройдёт задан-
ное число секунд, и наблюдалась какая-то активность базы данных, даже если это была просто
контрольная точка. (Контрольные точки пропускаются, если в базе отсутствует активность).
Заметьте, что архивируемые файлы, закрываемые досрочно из-за принудительного переклю-
чения, всё равно будут иметь тот же размер, что и полностью заполненные. Поэтому устанав-
ливать для archive_timeout очень маленькое значение неразумно — это ведёт к замусорива-
нию архивного хранилища. Обычно для archive_timeout имеет смысл задавать значение около
526Настройка сервера
минуты. Если вам нужно, чтобы данные копировались с главного сервера быстрее, вам следует
подумать о переходе от архивации к потоковой репликации. Этот параметр можно задать толь-
ко в postgresql.conf или в командной строке при запуске сервера.
19.6. Репликация
Эти параметры управляют поведением встроенного механизма потоковой репликации (см. Под-
раздел 26.2.5). Когда он применяется, один сервер является ведущим, а другие — ведомыми. Ве-
дущий сервер всегда передаёт, а ведомые всегда принимают данные репликации, но когда настро-
ена каскадная репликация (см. Подраздел 26.2.7), ведомые серверы могут быть и передающими.
Следующие параметры в основном относятся к передающим и ведомым серверам, хотя некоторые
параметры имеют смысл только для ведущего. Все эти параметры могут быть разными в рамках
одного кластера, если это требуется.
19.6.1. Передающие серверы
Эти параметры можно задать на любом сервере, который передаёт данные репликации одному или
нескольким ведомым. Ведущий сервер всегда является передающим, так что на нём они должны
задаваться всегда. Роль и значение этих параметров не меняются после того, как ведомый сервер
становится ведущим.
max_wal_senders (integer)
Задаёт максимально допустимое число одновременных подключений ведомых серверов или
клиентов потокового копирования (т. е. максимальное количество одновременно работа-
ющих процессов передачи WAL). Значение по умолчанию — 10. Нулевое значение от-
ключает репликацию. Процессы-передатчики WAL учитываются в общем числе соедине-
ний, так что значение этого параметра должно быть меньше чем max_connections минус
superuser_reserved_connections. При неожиданном отключении клиента потоковой передачи
слот его подключения может оставаться в подвисшем состоянии до достижения тайм-аута, так
что этот параметр должен быть немного больше максимального ожидаемого числа клиентов,
чтобы отключившиеся клиенты могли переподключиться немедленно. Задать этот параметр
можно только при запуске сервера. Чтобы к данному серверу могли подключаться ведомые,
нужно также установить в wal_level уровень replica или выше.
max_replication_slots (integer)
Задаёт максимальное число слотов репликации (см. Подраздел 26.2.6), которое сможет поддер-
живать сервер. Значение по умолчанию — 10. Этот параметр можно задать только при запуске
сервера. Если заданное значение данного параметра будет меньше, чем число уже существу-
ющих слотов репликации, сервер не запустится. Чтобы слоты репликации можно было исполь-
зовать, нужно также установить в wal_level уровень replica или выше.
wal_keep_segments (integer)
Задаёт минимальное число файлов прошлых сегментов журнала, которые будут сохраняться
в каталоге pg_wal, чтобы ведомый сервер мог выбрать их при потоковой репликации. Обычно
сегмент имеет размер 16 мегабайт. Если ведомый сервер, подключённый к передающему, от-
стаёт больше чем на wal_keep_segments сегментов, передающий удаляет сегменты WAL, всё
ещё необходимые ведомому, и в этом случае соединение репликации прерывается. В результа-
те этого затем также будут прерваны зависимые соединения. (Однако ведомый сервер сможет
восстановиться, выбрав этот сегмент из архива, если осуществляется архивация WAL.)
Этот параметр задаёт только минимальное число сегментов, сохраняемое в каталоге pg_wal;
система может сохранить больше сегментов для архивации WAL или для восстановления с мо-
мента контрольной точки. Если wal_keep_segments равен нулю (это значение по умолчанию),
система не сохраняет никакие дополнительные сегменты для ведомых серверов, поэтому число
старых сегментов WAL, доступных для ведомых, зависит от положения предыдущей контроль-
ной точки и состояния архивации WAL. Задать этот параметр можно только в postgresql.conf
или в командной строке при запуске сервера.
527Настройка сервера
wal_sender_timeout (integer)
Задаёт период времени (в миллисекундах), по истечении которого прерываются неактивные
соединения репликации. Это помогает передающему серверу обнаружить сбой ведомого или
разрывы в сети. При значении, равном нулю, тайм-аут отключается. Задать этот параметр мож-
но только в postgresql.conf или в командной строке при запуске сервера. Значение по умол-
чанию — 60 секунд.
track_commit_timestamp (boolean)
Включает запись времени фиксации транзакций. Этот параметр можно задать только в
postgresql.conf или в командной строке при запуске сервера. По умолчанию этот параметр
имеет значение off.
19.6.2. Главный сервер
Эти параметры можно задать на главном/ведущем сервере, который должен передавать данные
репликации одному или нескольким ведомым. Заметьте, что помимо этих параметров на ведущем
сервере должен быть правильно установлен wal_level, а также может быть включена архивация
WAL (см. Подраздел  19.5.3). Значения этих параметров на ведомых серверах не важны, хотя их
можно подготовить заранее, на случай, если ведомый сервер придётся сделать ведущим.
synchronous_standby_names (string)
Определяет список ведомых серверов, которые могут поддерживать синхронную репликацию,
как описано в Подразделе  26.2.8. Активных синхронных ведомых серверов может быть один
или несколько; транзакции, ожидающие фиксации, будут завершаться только после того, как
эти ведомые подтвердят получение их данных. Синхронными ведомыми будут те, имена кото-
рых указаны в этом списке и которые подключены к ведущему и принимают поток данных в
реальном времени (что показывает признак streaming в представлении pg_stat_replication).
Указание нескольких имён ведомых серверов позволяет обеспечить очень высокую степень до-
ступности и защиту от потери данных.
Именем ведомого сервера в этом контексте считается значение application_name этого серве-
ра, задаваемое в свойствах подключения. При организации физической репликации оно зада-
ётся в строке primary_conninfo в recovery.conf (по умолчанию — walreceiver). Для логиче-
ской репликации его можно задать в строке подключения для подписки (по умолчанию это имя
подписки). Как задать его для других потребителей потоков репликации, вы можете узнать в
их документации.
Этот параметр принимает список ведомых серверов в одной из следующих форм:
[FIRST] число_синхронных ( имя_ведомого [, …] )
ANY число_синхронных ( имя_ведомого [, …] )
имя_ведомого [, …]
здесь число_синхронных — число синхронных ведомых серверов, от которых необходимо дожи-
даться ответов для завершения транзакций, а имя_ведомого — имя ведомого сервера. Слова
FIRST и ANY задают метод выбора синхронных ведомых из перечисленных серверов.
Ключевое слово FIRST, в сочетании с числом_синхронных, выбирает синхронную репликацию
на основе приоритетов, когда транзакции фиксируются только после того, как их записи в WAL
реплицируются на число_синхронных ведомых серверов, выбираемых согласно приоритетам.
Например, со значением FIRST 3 (s1, s2, s3, s4) для фиксации транзакции необходимо
дождаться ответа от трёх наиболее приоритетных из серверов s1, s2, s3 и s4. Ведомые серверы,
имена которых идут в этом списке первыми, будут иметь больший приоритет и будут считаться
синхронными. Серверы, следующие в списке за ними, будут считаться потенциальными син-
хронными. Если один из текущих синхронных серверов по какой-то причине отключается, он
немедленно будет заменён следующим сервером с наибольшим приоритетом. Ключевое слово
FIRST может быть опущено.
528Настройка сервера
Ключевое слово ANY, в сочетании с числом_синхронных, выбирает синхронную репликацию на
основе кворума, когда транзакции фиксируются только после того, как их записи в WAL реп-
лицируются на как минимум число_синхронных перечисленных серверов. Например, со значе-
нием ANY 3 (s1, s2, s3, s4) для фиксации транзакции необходимо дождаться ответа от как
минимум трёх из серверов s1, s2, s3 и s4.
Ключевые слова FIRST и ANY воспринимаются без учёта регистра. Если такое же имя оказыва-
ется у одного из ведомых серверов, его имя_ведомого нужно заключить в двойные кавычки.
Третья форма использовалась в PostgreSQL до версии 9.6 и по-прежнему поддерживается. По
сути она равнозначна первой с FIRST и числом_синхронным, равным 1. Например, FIRST 1 (s1,
s2) и s1, s2 действуют одинаково: в качестве синхронного ведомого выбирается либо s1, либо
s2.
Специальному элементу * соответствует любой сервер.
Уникальность имён ведомых серверов не контролируется. В случае дублирования имён более
приоритетным будет один из серверов с подходящим именем, хотя какой именно, не опреде-
лено.
Примечание
Каждое имя_ведомого должно задаваться в виде допустимого идентификатора SQL,
кроме *. При необходимости его можно заключать в кавычки. Но заметьте, что
идентификаторы имя_ведомого сравниваются с именами приложений без учёта ре-
гистра, независимо от того, заключены ли они в кавычки или нет.
Если имена синхронных ведомых серверов не определены, синхронная репликация не включа-
ется и фиксируемые транзакции не будут ждать репликации. Это поведение по умолчанию.
Даже когда синхронная репликация включена, для отдельных транзакций можно отключить
ожидание репликации, задав для параметра synchronous_commit значение local или off.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
vacuum_defer_cleanup_age (integer)
Задаёт число транзакций, на которое будет отложена очистка старых версий строк при VACUUM
и изменениях HOT. По умолчанию это число равно нулю, то есть старые версии строк могут
удаляться сразу, как только перестанут быть видимыми в открытых транзакциях. Это значение
можно сделать ненулевым на ведущем сервере, работающим с серверами горячего резерва,
как описано в Разделе 26.5. В результате увеличится время, в течение которого будут успешно
выполняться запросы на ведомом сервере без конфликтов из-за ранней очистки строк. Однако
ввиду того, что эта отсрочка определяется числом записывающих транзакций, выполняющихся
на ведущем сервере, сложно предсказать, каким будет дополнительное время отсрочки на ве-
домом сервере. Задать этот параметр можно только в postgresql.conf или в командной строке
при запуске сервера.
В качестве альтернативы этому параметру можно также рассмотреть hot_standby_feedback на
ведомом сервере.
Этот параметр не предотвращает очистку старых строк, которые достигли возраста, заданного
параметром old_snapshot_threshold.
19.6.3. Ведомые серверы
Эти параметры управляют поведением ведомого сервера, который будет получать данные репли-
кации. На ведущем сервере они не играют никакой роли.
529Настройка сервера
hot_standby (boolean)
Определяет, можно ли будет подключаться к серверу и выполнять запросы в процессе восста-
новления, как описано в Разделе 26.5. Значение по умолчанию — on (подключения разреша-
ются). Задать этот параметр можно только при запуске сервера. Данный параметр играет роль
только в режиме ведомого сервера или при восстановлении архива.
max_standby_archive_delay (integer)
В режиме горячего резерва этот параметр определяет, как долго должен ждать ведомый сер-
вер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как
описано в Подразделе 26.5.2. Задержка max_standby_archive_delay применяется при обработ-
ке данных WAL, считываемых из архива (не текущих данных). Значение этого параметра зада-
ётся в миллисекундах (если явно не указаны другие единицы) и по умолчанию равно 30 секун-
дам. При значении, равном -1, ведомый может ждать завершения конфликтующих запросов
неограниченное время. Задать этот параметр можно только в postgresql.conf или в команд-
ной строке при запуске сервера.
Заметьте, что параметр max_standby_archive_delay определяет не максимальное время, ко-
торое отводится для выполнения каждого запроса, а максимальное общее время, за которое
должны быть применены изменения из одного сегмента WAL. Таким образом, если один запрос
привёл к значительной задержке при обработке сегмента WAL, остальным конфликтующим
запросам будет отведено гораздо меньше времени.
max_standby_streaming_delay (integer)
В режиме горячего резерва этот параметр определяет, как долго должен ждать ведомый сер-
вер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как
описано в Подразделе 26.5.2. Задержка max_standby_streaming_delay применяется при обра-
ботке данных WAL, поступающих при потоковой репликации. Значение этого параметра зада-
ётся в миллисекундах (если явно не указаны другие единицы) и по умолчанию равно 30 секун-
дам. При значении, равном -1, ведомый может ждать завершения конфликтующих запросов
неограниченное время. Задать этот параметр можно только в postgresql.conf или в команд-
ной строке при запуске сервера.
Заметьте, что параметр max_standby_streaming_delay определяет не максимальное время, ко-
торое отводится для выполнения каждого запроса, а максимальное общее время, за которое
должны быть применены изменения из WAL после получения от главного сервера. Таким обра-
зом, если один запрос привёл к значительной задержке, остальным конфликтующим запросам
будет отводиться гораздо меньше времени, пока резервный сервер не догонит главный.
wal_receiver_status_interval (integer)
Определяет минимальную частоту, с которой процесс, принимающий WAL на ведомом серве-
ре, будет сообщать о состоянии репликации ведущему или вышестоящему ведомому, где это
состояние можно наблюдать в представлении pg_stat_replication. В этом сообщении переда-
ются следующие позиции в журнале предзаписи: позиция изменений записанных, изменений,
сохранённых на диске, и изменений применённых. Значение параметра задаётся в секундах и
определяет максимальный интервал между сообщениями. Сообщения о состоянии передаются
при каждом продвижении позиций записанных или сохранённых на диске изменений, но с про-
межутком не больше, чем заданный этим параметром. Таким образом, последняя переданная
позиция применённых изменений может немного отставать от фактической в текущий момент.
При нулевом значении этого параметра передача состояния полностью отключается. Задать
этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.
По умолчанию его значение равно 10 секундам.
hot_standby_feedback (boolean)
Определяет, будет ли сервер горячего резерва сообщать ведущему или вышестоящему ве-
домому о запросах, которые он выполняет в данный момент. Это позволяет исключить
необходимость отмены запросов, вызванную очисткой записей, но при некоторых типах на-
грузки это может приводить к раздуванию базы данных на ведущем сервере. Эти сообще-
530Настройка сервера
ния о запросах будут отправляться не чаще, чем раз в интервал, задаваемый параметром
wal_receiver_status_interval. Значение данного параметра по умолчанию — off. Задать этот
параметр можно только в postgresql.conf или в командной строке при запуске сервера.
Если используется каскадная репликация, сообщения о запросах передаются выше, пока в ито-
ге не достигнут ведущего сервера. На промежуточных серверах эта информация больше никак
не задействуется.
Этот параметр не переопределяет поведение old_snapshot_threshold, установленное на ве-
дущем сервере; снимок на ведомом сервере, имеющий возраст больше заданного указанным
параметром на ведущем, может стать недействительным, что приведёт к отмене транзакций
на ведомом. Это объясняется тем, что предназначение old_snapshot_threshold заключается
в указании абсолютного ограничения времени, в течение которого могут накапливаться мёрт-
вые строки, которое иначе могло бы нарушаться из-за конфигурации ведомого.
wal_receiver_timeout (integer)
Задаёт период времени (в миллисекундах), по истечении которого прерываются неактивные
соединения репликации. Это помогает принимающему ведомому серверу обнаружить сбой ве-
дущего или разрыв сети. При значении, равном нулю, тайм-аут отключается. Задать этот пара-
метр можно только в postgresql.conf или в командной строке при запуске сервера. Значение
по умолчанию — 60 секунд.
wal_retrieve_retry_interval (integer)
Определяет, сколько ведомый сервер должен ждать поступления данных WAL из любых источ-
ников (потоковая репликация, локальный pg_wal или архив WAL), прежде чем повторять по-
пытку получения WAL. Задать этот параметр можно только в postgresql.conf или в командной
строке сервера. Значение по умолчанию — 5 секунд. Если единицы не задаются, подразумева-
ются миллисекунды.
Этот параметр полезен в конфигурациях, когда для узла в схеме восстановления нужно регу-
лировать время ожидания новых данных WAL. Например, при восстановлении архива можно
ускорить реакцию на появление нового файла WAL, уменьшив значение этого параметра. В си-
стеме с низкой активностью WAL увеличение этого параметра приведёт к сокращению числа
запросов, необходимых для отслеживания архивов WAL, что может быть полезно в облачных
окружениях, где учитывается число обращений к инфраструктуре.
19.6.4. Подписчики
Эти параметры управляют поведением подписчика логической репликации. На публикующем сер-
вере они не играют роли.
Заметьте, что параметры конфигурации wal_receiver_timeout, wal_receiver_status_interval и
wal_retrieve_retry_interval также воздействуют на рабочие процессы логической репликации.
max_logical_replication_workers (int)
Задаёт максимально возможное число рабочих процессов логической репликации. В это число
входят и рабочие процессы, применяющие изменения, и процессы, синхронизирующие табли-
цы.
Рабочие процессы логической репликации берутся из пула, контролируемого параметром
max_worker_processes.
Значение по умолчанию — 4.
max_sync_workers_per_subscription (integer)
Максимальное число рабочих процессов, выполняющих синхронизацию, для одной подписки.
Этот параметр управляет степенью распараллеливания копирования начальных данных в про-
цессе инициализации подписки или при добавлении новых таблиц.
531Настройка сервера
В настоящее время одну таблицу может обрабатывать только один рабочий процесс синхрони-
зации.
Рабочие процессы синхронизации
max_logical_replication_workers.
берутся
из
пула,
контролируемого
параметром
Значение по умолчанию — 2.
19.7. Планирование запросов
19.7.1. Конфигурация методов планировщика
Эти параметры конфигурации дают возможность грубо влиять на планы, выбираемые оптимизато-
ром запросов. Если автоматически выбранный оптимизатором план конкретного запроса оказал-
ся неоптимальным, в качестве временного решения можно воспользоваться одним из этих пара-
метров и вынудить планировщик выбрать другой план. Улучшить качество планов, выбираемых
планировщиком, можно и более подходящими способами, в частности, скорректировать констан-
ты стоимости (см. Подраздел 19.7.2), выполнить ANALYZE вручную, изменить значение параметра
конфигурации default_statistics_target и увеличить объём статистики, собираемой для отдельных
столбцов, воспользовавшись командой ALTER TABLE SET STATISTICS.
enable_bitmapscan (boolean)
Включает или отключает использование планов сканирования по битовой карте. По умолчанию
имеет значение on (вкл.).
enable_gathermerge (boolean)
Включает или отключает использование планов соединения посредством сбора. По умолчанию
имеет значение on (вкл.).
enable_hashagg (boolean)
Включает или отключает использование планов агрегирования по хешу. По умолчанию имеет
значение on (вкл.).
enable_hashjoin (boolean)
Включает или отключает использование планов соединения по хешу. По умолчанию имеет зна-
чение on (вкл.).
enable_indexscan (boolean)
Включает или отключает использование планов сканирования по индексу. По умолчанию име-
ет значение on (вкл.).
enable_indexonlyscan (boolean)
Включает или отключает использование планов сканирования только индекса (см. Раз-
дел 11.11). По умолчанию имеет значение on (вкл.).
enable_material (boolean)
Включает или отключает использование материализации при планировании запросов. Полно-
стью исключить материализацию невозможно, но при выключении этого параметра планиров-
щик не будет вставлять узлы материализации, за исключением случаев, где они требуются для
правильности. По умолчанию этот параметр имеет значение on (вкл.).
enable_mergejoin (boolean)
Включает или отключает использование планов соединения слиянием. По умолчанию имеет
значение on (вкл.).
532Настройка сервера
enable_nestloop (boolean)
Включает или отключает использование планировщиком планов соединения с вложенными
циклами. Полностью исключить вложенные циклы невозможно, но при выключении этого па-
раметра планировщик не будет использовать данный метод, если можно применить другие. По
умолчанию этот параметр имеет значение on.
enable_parallel_append (boolean)
Включает или отключает использование планировщиком планов с распараллеливанием добав-
ления данных. По умолчанию имеет значение on (вкл.).
enable_parallel_hash (boolean)
Включает или отключает использование планировщиком планов соединения по хешу с распа-
раллеливанием хеширования. Не действует, если планы соединения по хешу отключены. По
умолчанию имеет значение on (вкл.).
enable_partition_pruning (boolean)
Включает или отключает в планировщике возможность устранять секции секционированных
таблиц из планов запроса. Также влияет на возможность планировщика генерировать планы за-
просов, позволяющие исполнителю пропускать (игнорировать) секции при выполнении запро-
сов. По умолчанию имеет значение on (вкл.). За подробностями обратитесь к Подразделу 5.10.4.
enable_partitionwise_join (boolean)
Включает или отключает использование планировщиком соединения с учётом секционирова-
ния, что позволяет выполнять соединение секционированных таблиц путём соединения соот-
ветствующих секций. Соединение с учётом секционирования в настоящее время может при-
меняться, только когда условия соединения включают все ключи секционирования; при этом
ключи должны быть одного типа данных и наборы дочерних секций должны быть одинаковыми.
Так как для планирования соединения с учётом секций может потребоваться гораздо больше
процессорного времени и памяти, по умолчанию этот параметр выключен (off).
enable_partitionwise_aggregate (boolean)
Включает или отключает использование планировщиком группировки или агрегирования с
учётом секционирования, что позволяет выполнять группировку или агрегирование в секцио-
нированных таблицах по отдельности для каждой секции. Если предложение GROUP BY не вклю-
чает ключи секционирования, на уровне секций может быть выполнено только частичное аг-
регирование, а затем требуется итоговая обработка. Так как для планирования группировки
или агрегирования может потребоваться гораздо больше процессорного времени и памяти, по
умолчанию этот параметр выключен (off).
enable_seqscan (boolean)
Включает или отключает использование планировщиком планов последовательного сканиро-
вания. Полностью исключить последовательное сканирование невозможно, но при выключе-
нии этого параметра планировщик не будет использовать данный метод, если можно приме-
нить другие. По умолчанию этот параметр имеет значение on.
enable_sort (boolean)
Включает или отключает использование планировщиком шагов с явной сортировкой. Полно-
стью исключить явную сортировку невозможно, но при выключении этого параметра плани-
ровщик не будет использовать данный метод, если можно применить другие. По умолчанию
этот параметр имеет значение on.
enable_tidscan (boolean)
Включает или отключает использование планов сканирования TID. По умолчанию имеет зна-
чение on (вкл.).
533Настройка сервера
19.7.2. Константы стоимости для планировщика
Переменные стоимости, описанные в данном разделе, задаются по произвольной шкале. Значе-
ние имеют только их отношения, поэтому умножение или деление всех переменных на один коэф-
фициент никак не повлияет на выбор планировщика. По умолчанию эти переменные определяются
относительно стоимости чтения последовательной страницы: то есть, переменную seq_page_cost
удобно задать равной 1.0, а все другие переменные стоимости определить относительно неё. Но
при желании можно использовать и другую шкалу, например, выразить в миллисекундах факти-
ческое время выполнения запросов на конкретной машине.
Примечание
К сожалению, какого-либо чётко определённого способа определения идеальных зна-
чений стоимости не существует. Лучше всего выбирать их как средние показатели при
выполнении целого ряда разнообразных запросов, которые будет обрабатывать кон-
кретная СУБД. Это значит, что менять их по результатам всего нескольких экспери-
ментов очень рискованно.
seq_page_cost (floating point)
Задаёт приблизительную стоимость чтения одной страницы с диска, которое выполняется в
серии последовательных чтений. Значение по умолчанию равно 1.0. Это значение можно пе-
реопределить для таблиц и индексов в определённом табличном пространстве, установив од-
ноимённый параметр табличного пространства (см. ALTER TABLESPACE).
random_page_cost (floating point)
Задаёт приблизительную стоимость чтения одной произвольной страницы с диска. Значение
по умолчанию равно 4.0. Это значение можно переопределить для таблиц и индексов в опреде-
лённом табличном пространстве, установив одноимённый параметр табличного пространства
(см. ALTER TABLESPACE).
При уменьшении этого значения по отношению к seq_page_cost система начинает предпочи-
тать сканирование по индексу; при увеличении такое сканирование становится более дорого-
стоящим. Оба эти значения также можно увеличить или уменьшить одновременно, чтобы из-
менить стоимость операций ввода/вывода по отношению к стоимости процессорных операций,
которая определяется следующими параметрами.
Произвольный доступ к механическому дисковому хранилищу обычно гораздо дороже после-
довательного доступа, более чем в четыре раза. Однако по умолчанию выбран небольшой ко-
эффициент (4.0), в предположении, что большой объём данных при произвольном доступе, на-
пример, при чтении индекса, окажется в кеше. Таким образом, можно считать, что значение
по умолчанию моделирует ситуацию, когда произвольный доступ в 40 раз медленнее последо-
вательного, но 90% операций произвольного чтения удовлетворяются из кеша.
Если вы считаете, что для вашей рабочей нагрузки процент попаданий не достигает 90%, вы
можете увеличить параметр random_page_cost, чтобы он больше соответствовал реальной сто-
имости произвольного чтения. И напротив, если ваши данные могут полностью поместиться в
кеше, например, когда размер базы меньше общего объёма памяти сервера, может иметь смысл
уменьшить random_page_cost. С хранилищем, у которого стоимость произвольного чтения не
намного выше последовательного, как например, у твердотельных накопителей, так же лучше
выбрать меньшее значение random_page_cost.
Подсказка
Хотя система позволяет сделать random_page_cost меньше, чем seq_page_cost, это
лишено физического смысла. Однако сделать их равными имеет смысл, если база
данных полностью кешируется в ОЗУ, так как в этом случае с обращением к страни-
цам в произвольном порядке не связаны никакие дополнительные издержки. Кроме
534Настройка сервера
того, для сильно загруженной базы данных оба этих параметра следует понизить по
отношению к стоимости процессорных операций, так как стоимость выборки стра-
ницы, уже находящейся в ОЗУ, оказывается намного меньше, чем обычно.
cpu_tuple_cost (floating point)
Задаёт приблизительную стоимость обработки каждой строки при выполнении запроса. Значе-
ние по умолчанию — 0.01.
cpu_index_tuple_cost (floating point)
Задаёт приблизительную стоимость обработки каждой записи индекса при сканировании ин-
декса. Значение по умолчанию — 0.005.
cpu_operator_cost (floating point)
Задаёт приблизительную стоимость обработки оператора или функции при выполнении запро-
са. Значение по умолчанию — 0.0025.
parallel_setup_cost (floating point)
Задаёт приблизительную стоимость запуска параллельных рабочих процессов. Значение по
умолчанию — 1000.
parallel_tuple_cost (floating point)
Задаёт приблизительную стоимость передачи одного кортежа от параллельного рабочего про-
цесса другому процессу. Значение по умолчанию — 0.1.
min_parallel_table_scan_size (integer)
Задаёт минимальный объём данных таблицы, подлежащий сканированию, при котором может
применяться параллельное сканирование. Для параллельного последовательного сканирова-
ния объём сканируемых данных всегда равняется размеру таблицы, но когда используются ин-
дексы, этот объём обычно меньше. Значение по умолчанию — 8 мегабайт (8MB).
min_parallel_index_scan_size (integer)
Задаёт минимальный объём данных индекса, подлежащий сканированию, при котором может
применяться параллельное сканирование. Заметьте, что при параллельном сканировании по
индексу обычно не затрагивается весь индекс; здесь учитывается число страниц, которое по
мнению планировщика будет затронуто при сканировании. Значение по умолчанию — 512 ки-
лобайт (512kB).
effective_cache_size (integer)
Определяет представление планировщика об эффективном размере дискового кеша, доступ-
ном для одного запроса. Это представление влияет на оценку стоимости использования индек-
са; чем выше это значение, тем больше вероятность, что будет применяться сканирование по
индексу, чем ниже, тем более вероятно, что будет выбрано последовательное сканирование.
При установке этого параметра следует учитывать и объём разделяемых буферов PostgreSQL, и
процент дискового кеша ядра, который будут занимать файлы данных PostgreSQL, хотя некото-
рые данные могут оказаться и там, и там. Кроме того, следует принять во внимание ожидаемое
число параллельных запросов к разным таблицам, так как общий размер будет разделяться
между ними. Этот параметр не влияет на размер разделяемой памяти, выделяемой PostgreSQL,
и не задаёт размер резервируемого в ядре дискового кеша; он используется только в качестве
ориентировочной оценки. При этом система не учитывает, что данные могут оставаться в дис-
ковом кеше от запроса к запросу. Значение этого параметра по умолчанию — 4 гигабайта (4GB).
jit_above_cost (floating point)
Устанавливает предел стоимости запроса, при превышении которого включается JIT-компиля-
ция, если она поддерживается (см. Главу 32). Применение JIT занимает время при планирова-
535Настройка сервера
нии, но может ускорить выполнение запроса в целом. Значение -1 отключает JIT-компиляцию.
Значение по умолчанию — 100000.
jit_inline_above_cost (floating point)
Устанавливает предел стоимости, при превышении которого будет допускаться встраивание
функций и операторов в процессе JIT-компиляции. Встраивание занимает время при планиро-
вании, но в целом может ускорить выполнение. Присваивать этому параметру значение, мень-
шее чем jit_above_cost, не имеет смысла. Значение -1 отключает встраивание. Значение по
умолчанию — 500000.
jit_optimize_above_cost (floating point)
Устанавливает предел стоимости, при превышении которого в JIT-компилированных програм-
мах может применяться дорогостоящая оптимизация. Такая оптимизация увеличивает вре-
мя планирования, но в целом может ускорить выполнение. Присваивать этому параметру
значение, меньшее чем jit_above_cost, не имеет смысла, а при значениях, превышающих
jit_inline_above_cost, положительный эффект маловероятен. Значение -1 отключает доро-
гостоящие оптимизации. Значение по умолчанию — 500000.
19.7.3. Генетический оптимизатор запросов
Генетический оптимизатор запросов (GEnetic Query Optimizer, GEQO) осуществляет планирова-
ние запросов, применяя эвристический поиск. Это позволяет сократить время планирования для
сложных запросов (в которых соединяются множество отношений), ценой того, что иногда полу-
ченные планы уступают по качеству планам, выбираемым при полном переборе. За дополнитель-
ными сведениями обратитесь к Главе 60.
geqo (boolean)
Включает или отключает генетическую оптимизацию запросов. По умолчанию она включена.
В производственной среде её лучше не отключать; более гибко управлять GEQO можно с по-
мощью переменной geqo_threshold.
geqo_threshold (integer)
Задаёт минимальное число элементов во FROM, при котором для планирования запроса будет
привлечён генетический оптимизатор. (Заметьте, что конструкция FULL OUTER JOIN считает-
ся одним элементом списка FROM.) Значение по умолчанию — 12. Для более простых запросов
часто лучше использовать обычный планировщик, производящий полный перебор, но для за-
просов со множеством таблиц полный перебор займёт слишком много времени, чаще гораздо
больше, чем будет потеряно из-за выбора не самого эффективного плана. Таким образом, огра-
ничение по размеру запроса даёт удобную возможность управлять GEQO.
geqo_effort (integer)
Управляет выбором между сокращением временем планирования и повышением качества пла-
на запроса в GEQO. Это значение должна задаваться целым числом от 1 до 10. Значение по
умолчанию равно пяти. Чем больше значение этого параметра, тем больше времени будет по-
трачено на планирование запроса, но и тем больше вероятность, что будет выбран эффектив-
ный план.
Параметр geqo_effort сам по себе ничего не делает, он используется только для вычисления
значений по умолчанию для других переменных, влияющих на поведение GEQO (они описаны
ниже). При желании эти переменные можно просто установить вручную.
geqo_pool_size (integer)
Задаёт размер пула для алгоритма GEQO, то есть число особей в генетической популяции. Это
число должно быть не меньше двух, но полезные значения обычно лежат в интервале от 100
до 1000. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается,
исходя из значения geqo_effort и числа таблиц в запросе.
536Настройка сервера
geqo_generations (integer)
Задаёт число поколений для GEQO, то есть число итераций этого алгоритма. Оно должно быть
не меньше единицы, но полезные значения находятся в том же диапазоне, что и размер пула.
Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя
из geqo_pool_size.
geqo_selection_bias (floating point)
Задаёт интенсивность селекции для GEQO, то есть селективное давление в популяции. Допу-
стимые значения лежат в диапазоне от 1.50 до 2.00 (это значение по умолчанию).
geqo_seed (floating point)
Задаёт начальное значение для генератора случайных чисел, который применяется в GEQO для
выбора случайных путей в пространстве поиска порядка соединений. Может иметь значение от
нуля (по умолчанию) до одного. При изменении этого значения меняется набор анализируемых
путей, в результате чего может быть найден как более, так и менее оптимальный путь.
19.7.4. Другие параметры планировщика
default_statistics_target (integer)
Устанавливает целевое ограничение статистики по умолчанию, распространяющееся на столб-
цы, для которых командой ALTER TABLE SET STATISTICS не заданы отдельные ограничения.
Чем больше установленное значение, тем больше времени требуется для выполнения ANALYZE,
но тем выше может быть качество оценок планировщика. Значение этого параметра по умол-
чанию — 100. За дополнительными сведениями об использовании статистики планировщиком
запросов PostgreSQL обратитесь к Разделу 14.2.
constraint_exclusion (enum)
Управляет использованием планировщиком ограничений таблицы для оптимизации запросов.
Допустимые значения constraint_exclusion: on (задействовать ограничения всех таблиц), off
(никогда не задействовать ограничения) и partition (задействовать ограничения только для
дочерних таблиц и подзапросов UNION ALL). Значение по умолчанию — partition. Оно часто
помогает увеличить производительность, когда применяется наследование.
Когда данный параметр разрешает это для таблицы, планировщик сравнивает условия запроса
с ограничениями CHECK данной таблицы и не сканирует её, если они оказываются несовмести-
мыми. Например:
CREATE
CREATE
CREATE
…
SELECT
TABLE parent(key integer, …);
TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);</li>
      <li>FROM parent WHERE key = 2400;
Если включено исключение по ограничению, команда SELECT не будет сканировать таблицу
child1000, в результате чего запрос выполнится быстрее.
В настоящее время исключение по ограничению разрешено по умолчанию только в условиях,
возникающих при реализации секционированных таблиц через наследование. Включение этой
возможности для всех таблиц влечёт дополнительные издержки на планирование, довольно за-
метные для простых запросов, но не приносит никакого выигрыша. Если вы не применяете сек-
ционированные таблицы с наследованием, лучше всего полностью отключить эту возможность.
За дополнительными сведениями об исключении по ограничению и секционировании таблиц
обратитесь к Подразделу 5.10.5.
cursor_tuple_fraction (floating point)
Задаёт для планировщика оценку процента строк, которые будут получены через курсор. Зна-
чение по умолчанию — 0.1 (10%). При меньших значениях планировщик будет склонен исполь-
537Настройка сервера
зовать для курсоров планы с «быстрым стартом», позволяющие получать первые несколько
строк очень быстро, хотя для выборки всех строк может уйти больше времени. При больших
значениях планировщик стремится оптимизировать общее время запроса. При максимальном
значении, равном 1.0, работа с курсорами планируется так же, как и обычные запросы — ми-
нимизируется только общее время, а не время получения первых строк.
from_collapse_limit (integer)
Задаёт максимальное число элементов в списке FROM, до которого планировщик будет объеди-
нять вложенные запросы с внешним запросом. При меньших значениях сокращается время
планирования, но план запроса может стать менее эффективным. По умолчанию это значение
равно восьми. За дополнительными сведениями обратитесь к Разделу 14.3.
Если это значение сделать равным geqo_threshold или больше, при таком объединении запро-
сов может включиться планировщик GEQO и в результате будет получен неоптимальный план.
См. Подраздел 19.7.3.
jit (boolean)
Определяет, может ли PostgreSQL использовать компиляцию JIT, если она поддерживается (см.
Главу 32). По умолчанию он выключен (off).
join_collapse_limit (integer)
Задаёт максимальное количество элементов в списке FROM, до достижения которого планиров-
щик будет сносить в него явные конструкции JOIN (за исключением FULL JOIN). При меньших
значениях сокращается время планирования, но план запроса может стать менее эффектив-
ным.
По умолчанию эта переменная имеет то же значение, что и from_collapse_limit, и это при-
емлемо в большинстве случаев. При значении, равном 1, предложения JOIN переставляться не
будут, так что явно заданный в запросе порядок соединений определит фактический порядок,
в котором будут соединяться отношения. Так как планировщик не всегда выбирает оптималь-
ный порядок соединений, опытные пользователи могут временно задать для этой переменной
значение 1, а затем явно определить желаемый порядок. За дополнительными сведениями об-
ратитесь к Разделу 14.3.
Если это значение сделать равным geqo_threshold или больше, при таком объединении запро-
сов может включиться планировщик GEQO и в результате будет получен неоптимальный план.
См. Подраздел 19.7.3.
parallel_leader_participation (boolean)
Позволяет ведущему процессу выполнять план запроса ниже узлов Gather и Gather Merge, не
ожидая рабочие процессы. По умолчанию этот параметр включён (on). Значение off снижает
вероятность блокировки рабочих процессов в случае, если ведущий процесс будет читать кор-
тежи недостаточно быстро, но тогда ведущему приходится дожидаться запуска рабочих про-
цессов, и только затем выдавать первые кортежи. Степень положительного или отрицательно-
го влияния ведущего зависит от типа плана, числа рабочих процессов и длительности запроса.
force_parallel_mode (enum)
Позволяет распараллеливать запрос в целях тестирования, даже когда от этого не ожидается
никакого выигрыша в скорости. Допустимые значения параметра force_parallel_mode — off
(использовать параллельный режим только когда ожидается увеличение производительности),
on (принудительно распараллеливать все запросы, для которых это безопасно) и regress (как
on, но с дополнительными изменениями поведения, описанными ниже).
Говоря точнее, со значением on узел Gather добавляется в вершину любого плана запроса, для
которого допускается распараллеливание, так что запрос выполняется внутри параллельного
исполнителя. Даже когда параллельный исполнитель недоступен или не может быть исполь-
538Настройка сервера
зован, такие операции, как запуск подтранзакции, которые не должны выполняться в контек-
сте параллельного запроса, не будут выполняться в этом режиме, если только планировщик
не решит, что это приведёт к ошибке запроса. Если при включении этого параметра возни-
кают ошибки или выдаются неожиданные результаты, вероятно, некоторые функции, задей-
ствованные в этом запросе, нужно пометить как PARALLEL UNSAFE (или, возможно, PARALLEL
RESTRICTED).
Значение regress действует так же, как и значение on, с некоторыми дополнительными особен-
ностями, предназначенными для облегчения автоматического регрессионного тестирования.
Обычно сообщения от параллельных исполнителей включают строку контекста, отмечающую
это, но значение regress подавляет эту строку, так что вывод не отличается от выполнения
в не параллельном режиме. Кроме того, узлы Gather, добавляемые в планы с этим значением
параметра, скрываются в выводе EXPLAIN, чтобы вывод соответствовал тому, что будет получен
при отключении этого параметра (со значением off).
19.8. Регистрация ошибок и протоколирование работы
сервера
19.8.1. Куда протоколировать
log_destination (string)
PostgreSQL поддерживает несколько методов протоколирования сообщений сервера: stderr,
csvlog и syslog. На Windows также поддерживается eventlog. В качестве значения
log_destination указывается один или несколько методов протоколирования, разделённых за-
пятыми. По умолчанию используется stderr. Параметр можно задать только в конфигурацион-
ных файлах или в командной строке при запуске сервера.
Если в log_destination включено значение csvlog, то протоколирование ведётся в форма-
те CSV (разделённые запятыми значения). Это удобно для программной обработки журнала.
Подробнее об этом в Подразделе  19.8.4. Для вывода в формате CSV должен быть включён
logging_collector.
Если присутствует указание stderr или csvlog, создаётся файл current_logfiles, в который за-
писывается расположение файла(ов) журнала, в настоящее время используемого сборщиком
сообщений для соответствующего назначения. Это позволяет легко определить, какие файлы
журнала используются в данный момент экземпляром сервера. Например, он может иметь та-
кое содержание:
stderr log/postgresql.log
csvlog log/postgresql.csv
current_logfiles переписывается когда при прокрутке создаётся новый файл журнала или
когда изменяется значение log_destination. Он удаляется, когда в log_destination не зада-
ётся ни stderr, ни csvlog, а также когда сборщик сообщений отключён.
Примечание
В большинстве систем Unix потребуется изменить конфигурацию системного демо-
на syslog для использования варианта syslog в log_destination. Для указания типа
протоколируемой программы (facility), PostgreSQL может использовать значения с
LOCAL0 по LOCAL7 (см. syslog_facility). Однако, на большинстве платформ, конфигу-
рация syslog по умолчанию не учитывает сообщения подобного типа. Чтобы это ра-
ботало, потребуется добавить в конфигурацию демона syslog что-то подобное:
local0.*
/var/log/postgresql
Для использования eventlog в log_destination на Windows, необходимо зареги-
стрировать источник событий и его библиотеку в операционной системе. Тогда
539Настройка сервера
Windows Event Viewer сможет отображать сообщения журнала событий. Подробнее
в Разделе 18.11.
logging_collector (boolean)
Параметр включает сборщик сообщений (logging collector). Это фоновый процесс, который со-
бирает отправленные в stderr сообщения и перенаправляет их в журнальные файлы. Такой под-
ход зачастую более полезен чем запись в syslog, поскольку некоторые сообщения в syslog могут
не попасть. (Типичный пример с сообщениями об ошибках динамического связывания, другой
пример — ошибки в скриптах типа archive_command.) Для установки параметра требуется пе-
резапуск сервера.
Примечание
Можно обойтись без сборщика сообщений и просто писать в stderr. Сообщения бу-
дут записываться в место, куда направлен поток stderr. Такой способ подойдёт толь-
ко для небольших объёмов протоколирования, потому что не предоставляет удоб-
ных средств для организации ротации журнальных файлов. Кроме того, на некото-
рых платформах отказ от использования сборщика сообщений может привести к
потере или искажению сообщений, так как несколько процессов, одновременно пи-
шущих в один журнальный файл, могут перезаписывать информацию друг друга.
Примечание
Сборщик спроектирован так, чтобы сообщения никогда не терялись. А это значит,
что при очень высокой нагрузке, серверные процессы могут быть заблокированы
при попытке отправить сообщения во время сбоя фонового процесса сборщика. В
противоположность этому, syslog предпочитает удалять сообщения, при невозмож-
ности их записать. Поэтому часть сообщений может быть потеряна, но система не
будет блокироваться.
log_directory (string)
При включённом logging_collector, определяет каталог, в котором создаются журнальные
файлы. Можно задавать как абсолютный путь, так и относительный от каталога данных класте-
ра. Параметр можно задать только в конфигурационных файлах или в командной строке при
запуске сервера. Значение по умолчанию — log.
log_filename (string)
При включённом logging_collector задаёт имена журнальных файлов. Значение трактуется
как строка формата в функции strftime, поэтому в ней можно использовать спецификаторы
% для включения в имена файлов информации о дате и времени. (При наличии зависящих от
часового пояса спецификаторов % будет использован пояс, заданный в log_timezone.) Поддер-
живаемые спецификаторы % похожи на те, что перечислены в описании strftime спецификации
Open Group. Обратите внимание, что системная функция strftime напрямую не используется.
Поэтому нестандартные, специфичные для платформы особенности не будут работать. Значе-
ние по умолчанию postgresql-%Y-%m-%d_%H%M%S.log.
Если для задания имени файлов не используются спецификаторы %, то для избежания пере-
полнения диска, следует использовать утилиты для ротации журнальных файлов. В версиях до
8.4, при отсутствии спецификаторов %, PostgreSQL автоматически добавлял время в формате
Epoch к имени файла. Сейчас в этом больше нет необходимости.
Если в log_destination включён вывод в формате CSV, то к имени журнального файла будет
добавлено расширение .csv. (Если log_filename заканчивается на .log, то это расширение
заменится на .csv.)
540Настройка сервера
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
log_file_mode (integer)
В системах Unix задаёт права доступа к журнальным файлам, при включённом
logging_collector. (В Windows этот параметр игнорируется.) Значение параметра должно
быть числовым, в формате команд chmod и umask. (Для восьмеричного формата, требуется за-
дать лидирующий 0 (ноль).)
Права доступа по умолчанию 0600, т. е. только владелец сервера может читать и писать в жур-
нальные файлы. Также, может быть полезным значение 0640, разрешающее чтение файлов
членам группы. Однако, чтобы установить такое значение, нужно каталог для хранения жур-
нальных файлов (log_directory) вынести за пределы каталога данных кластера. В любом случае,
нежелательно открывать для всех доступ на чтение журнальных файлов, так как они могут со-
держать конфиденциальные данные.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
log_rotation_age (integer)
Определяет максимальное время жизни отдельного журнального файла, при включённом
logging_collector. После того как прошло заданное количество минут, создаётся новый жур-
нальный файл. Для запрета создания нового файла по прошествии определённого времени,
нужно установить значение 0. Параметр можно задать только в конфигурационных файлах или
в командной строке при запуске сервера.
log_rotation_size (integer)
Определяет максимальный размер отдельного журнального файла, при включённом
logging_collector. После того как заданное количество килобайт записано в текущий файл,
создаётся новый журнальный файл. Для запрета создания нового файла при превышении
определённого размера, нужно установить значение 0. Задать этот параметр можно только в
postgresql.conf или в командной строке при запуске сервера.
log_truncate_on_rotation (boolean)
Если параметр logging_collector включён, PostgreSQL будет перезаписывать существующие
журнальные файлы, а не дописывать в них. Однако, перезапись при переключении на новый
файл возможна только в результате ротации по времени, но не при старте сервера или ро-
тации по размеру файла. При выключенном параметре всегда продолжается запись в суще-
ствующий файл. Например, включение этого параметра в комбинации с log_filename равным
postgresql-%H.log, приведёт к генерации 24-х часовых журнальных файлов, которые цикли-
чески перезаписываются. Параметр можно задать только в конфигурационных файлах или в
командной строке при запуске сервера.
Пример: для хранения журнальных файлов в течение 7 дней, по одному файлу на каж-
дый день с именами вида server_log.Mon, server_log.Tue и т. д., а также с автоматиче-
ской перезаписью файлов прошлой недели, нужно установить log_filename в server_log.%a,
log_truncate_on_rotation в on и log_rotation_age в 1440.
Пример: для хранения журнальных файлов в течение 24 часов, по одному файлу на час, с допол-
нительной возможностью переключения файла при превышения 1ГБ, установите log_filename
в server_log.%H%M, log_truncate_on_rotation в on, log_rotation_age в 60 и log_rotation_size
в 1000000. Добавление %M в log_filename позволит при переключении по размеру указать дру-
гое имя файла в пределах одного часа.
syslog_facility (enum)
При включённом протоколировании в syslog, этот параметр определяет значение «facility». До-
пустимые значения LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7. По умолча-
541Настройка сервера
нию используется LOCAL0. Подробнее в документации на системный демон syslog. Параметр
можно задать только в конфигурационных файлах или в командной строке при запуске сервера.
syslog_ident (string)
При включённом протоколировании в syslog, этот параметр задаёт имя программы, которое
будет использоваться в syslog для идентификации сообщений относящихся к PostgreSQL. По
умолчанию используется postgres. Задать этот параметр можно только в postgresql.conf или
в командной строке при запуске сервера.
syslog_sequence_numbers (boolean)
Когда сообщения выводятся в syslog и этот параметр включён (по умолчанию), все сообщения
будут предваряться последовательно увеличивающимися номерами (например, [2]). Это поз-
воляет обойти подавление повторов «— последнее сообщение повторилось N раз —», которое по
умолчанию осуществляется во многих реализациях syslog. В более современных реализациях
syslog подавление повторных сообщений можно настроить (например, в rsyslog есть директива
$RepeatedMsgReduction), так что это может излишне. Если же вы действительно хотите, чтобы
повторные сообщения подавлялись, вы можете отключить этот параметр.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
syslog_split_messages (boolean)
Когда активен вывод сообщений в syslog, этот параметр определяет, как будут доставляться
сообщения. Если он включён (по умолчанию), сообщения разделяются по строкам, а длин-
ные строки разбиваются на строки не длиннее 1024 байт, что составляет типичное ограни-
чение размера для традиционных реализаций syslog. Когда он отключён, сообщения сервера
PostgreSQL передаются службе syslog как есть, и она должна сама корректно воспринять по-
тенциально длинные сообщения.
Если syslog в итоге выводит сообщения в текстовый файл, результат будет тем же и лучше оста-
вить этот параметр включённым, так как многие реализации syslog не способны обрабатывать
большие сообщения или их нужно специально настраивать для этого. Но если syslog направля-
ет сообщения в некоторую другую среду, может потребоваться или будет удобнее сохранять
логическую целостность сообщений.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
event_source (string)
При включённом протоколировании в event log, этот параметр задаёт имя программы, кото-
рое будет использоваться в журнале событий для идентификации сообщений относящихся к
PostgreSQL. По умолчанию используется PostgreSQL. Параметр можно задать только в конфи-
гурационных файлах или в командной строке при запуске сервера.
19.8.2. Когда протоколировать
client_min_messages (enum)
Управляет минимальным уровнем сообщений, посылаемых клиенту. Допустимые значения
DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, LOG, NOTICE, WARNING, ERROR, FATAL и PANIC. Каждый из
перечисленных уровней включает все идущие после него. Чем дальше в этом списке уровень
сообщения, тем меньше сообщений будет посылаться клиенту. По умолчанию используется
NOTICE. Обратите внимание, что LOG расположен по-разному здесь и в log_min_messages.
log_min_messages (enum)
Управляет минимальным уровнем сообщений, записываемых в журнал сервера. Допустимые
значения DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, INFO, NOTICE, WARNING, ERROR, LOG, FATAL и
PANIC. Каждый из перечисленных уровней включает все идущие после него. Чем дальше в этом
542Настройка сервера
списке уровень сообщения, тем меньше сообщений будет записано в журнал сервера. По умол-
чанию используется WARNING. Обратите внимание, что LOG расположен по-разному здесь и в
client_min_messages. Только суперпользователи могут изменить этот параметр.
log_min_error_statement (enum)
Управляет тем, какие SQL-операторы, завершившиеся ошибкой, записываются в журнал сер-
вера. SQL-оператор будет записан в журнал, если он завершится ошибкой с указанным уров-
нем важности или выше. Допустимые значения: DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1, INFO,
NOTICE, WARNING, ERROR, LOG, FATAL и PANIC. По умолчанию используется ERROR. Это означает,
что в журнал сервера будут записаны все операторы, завершившиеся сообщением с уровнем
важности ERROR, LOG, FATAL и PANIC. Чтобы фактически отключить запись операторов с ошиб-
ками, установите для этого параметра значение PANIC. Изменить этот параметр могут только
суперпользователи.
log_min_duration_statement (integer)
Записывает в журнал продолжительность выполнения всех команд, время работы которых рав-
но или превышает указанное количество миллисекунд. Значение 0 (ноль) заставляет записы-
вать продолжительность работы всех команд. Значение -1 (по умолчанию) запрещает регистри-
ровать продолжительность выполнения операторов. Например, при значении 250ms, все коман-
ды, которые выполняются за 250 миллисекунд и дольше будут записаны в журнал сервера.
Включение параметра полезно для выявления плохо оптимизированных запросов в приложе-
нии. Только суперпользователи могут изменить этот параметр.
Для клиентов, использующих расширенный протокол запросов, будет записываться продолжи-
тельность фаз: разбор, связывание и выполнение.
Примечание
При использовании совместно с log_statement, текст SQL-операторов будет записы-
ваться только один раз (от использования log_statement) и не будет задублирован
в сообщении о длительности выполнения. Если не используется вывод в syslog, то
рекомендуется в log_line_prefix включить идентификатор процесса или сессии. Это
позволит связать текст запроса с записью о продолжительности выполнения, кото-
рая появится позже.
В Таблице 19.1 поясняются уровни важности сообщений в PostgreSQL. Также в этой таблице пока-
зано, как эти уровни транслируются в системные при использовании syslog или eventlog в Windows.
Таблица 19.1. Уровни важности сообщений
Уровень Использование
syslog
DEBUG1..DEBUG5 Более детальная ин- DEBUG
формация для разра-
ботчиков. Чем больше
номер, тем детальнее. INFORMATION
INFO Неявно
запрошенная INFO
пользователем инфор-
мация, например вы-
вод команды VACUUM
VERBOSE. INFORMATION
NOTICE Информация, которая NOTICE
может
быть
полез-
ной пользователям. На-
пример, уведомления
об усечении длинных
идентификаторов. INFORMATION
543
eventlogНастройка сервера
Уровень Использование
syslog
eventlog
WARNING Предупреждения о воз- NOTICE
можных проблемах. На-
пример, COMMIT вне
транзакционного бло-
ка. WARNING
ERROR Сообщает об ошибке, WARNING
из-за которой прервана
текущая команда. ERROR
LOG Информация, полезная INFO
для администраторов.
Например, выполнение
контрольных точек. INFORMATION
FATAL Сообщает об ошибке, ERR
из-за которой прервана
текущая сессия. ERROR
PANIC Сообщает об ошибке, CRIT
из-за которой прерваны
все сессии. ERROR
19.8.3. Что протоколировать
application_name (string)
application_name это любая строка, не превышающая NAMEDATALEN символов (64 символа при
стандартной сборке). Обычно устанавливается приложением при подключении к серверу. Зна-
чение отображается в представлении pg_stat_activity и добавляется в журнал сервера, при
использовании формата CSV. Для прочих форматов, application_name можно добавить в жур-
нал через параметр log_line_prefix. Значение application_name может содержать только печат-
ные ASCII символы. Остальные символы будут заменены знаками вопроса (?).
debug_print_parse (boolean)
debug_print_rewritten (boolean)
debug_print_plan (boolean)
Эти параметры включают вывод различной отладочной информации. А именно: вывод дере-
ва запроса, дерево запроса после применения правил или плана выполнения запроса, соот-
ветственно. Все эти сообщения имеют уровень LOG. Поэтому, по умолчанию, они записывают-
ся в журнал сервера, но не отправляются клиенту. Отправку клиенту можно настроить через
client_min_messages и/или log_min_messages. По умолчанию параметры выключены.
debug_pretty_print (boolean)
Включает выравнивание сообщений, выводимых debug_print_parse, debug_print_rewritten
или debug_print_plan. В результате сообщения легче читать, но они значительно длиннее, чем
в формате «compact», который используется при выключенном значении. По умолчанию вклю-
чён.
log_checkpoints (boolean)
Включает протоколирование выполнения контрольных точек и точек перезапуска сервера. При
этом записывается некоторая статистическая информация. Например, число записанных бу-
феров и время, затраченное на их запись. Параметр можно задать только в конфигурационных
файлах или в командной строке при запуске сервера. По умолчанию выключен.
log_connections (boolean)
Включает протоколирование всех попыток подключения к серверу, в том числе успешного за-
вершения аутентификации клиентов. Изменить его можно только в начале сеанса и сделать
это могут только суперпользователи. Значение по умолчанию — off.
544Настройка сервера
Примечание
Некоторые программы, например psql, предпринимают две попытки подключения
(первая для определения, нужен ли пароль). Поэтому дублирование сообщения
«connection received» не обязательно говорит о наличии проблемы.
log_disconnections (boolean)
Включает протоколирование завершения сеанса. В журнал выводится примерно та же инфор-
мация, что и с log_connections, плюс длительность сеанса. Изменить этот параметр можно
только в начале сеанса и сделать это могут только суперпользователи. Значение по умолчанию
— off.
log_duration (boolean)
Записывает продолжительность каждой завершённой команды. По умолчанию выключен.
Только суперпользователи могут изменить этот параметр.
Для клиентов, использующих расширенный протокол запросов, будет записываться продолжи-
тельность фаз: разбор, связывание и выполнение.
Примечание
Включение этого параметра и установка log_min_duration_statement в 0
(ноль) различаются. Разница в том, что при превышении значения
log_min_duration_statement, в журнал записывается текст запроса, а при
включении log_duration нет. Таким образом, при log_duration = on и
log_min_duration_statement больше нуля, в журнал сервера будет записываться
продолжительность выполнения всех команд, а текст запросов только для команд,
превысивших заданное значение. Такое поведение может оказаться полезным при
сборе статистики в условиях большой нагрузки.
log_error_verbosity (enum)
Управляет количеством детальной информации, записываемой в журнал сервера для каждого
сообщения. Допустимые значения: TERSE, DEFAULT и VERBOSE. Каждое последующее значение
добавляет больше полей в выводимое сообщение. Для TERSE из сообщения об ошибке исклю-
чаются поля DETAIL, HINT, QUERY и CONTEXT. Для VERBOSE в сообщение включается код ошибки
SQLSTATE (см. Приложение  A), а также имя файла с исходным кодом, имя функции и номер
строки сгенерировавшей ошибку. Только суперпользователи могут изменить этот параметр.
log_hostname (boolean)
По умолчанию, сообщения журнала содержат лишь IP-адрес подключившегося клиента. При
включении этого параметра, дополнительно будет фиксироваться и имя сервера. Обратите вни-
мание, что в зависимости от применяемого способа разрешения имён, это может отрицательно
сказаться на производительности. Задать этот параметр можно только в postgresql.conf или
в командной строке при запуске сервера.
log_line_prefix (string)
Строка, в стиле функции printf, которая выводится в начале каждой строки журнала сообще-
ний. С символов % начинаются управляющие последовательности, которые заменяются статус-
ной информацией, описанной ниже. Неизвестные управляющие последовательности игнори-
руются. Все остальные символы напрямую копируются в выводимую строку. Некоторые управ-
ляющие последовательности используются только для пользовательских процессов и будут иг-
норироваться фоновыми процессами, например основным процессом сервера. Статусная ин-
545Настройка сервера
формация может быть выровнена по ширине влево или вправо указанием числа после % и пе-
ред кодом последовательности. Отрицательное число дополняет значение пробелами справа
до заданной ширины, а положительное число — слева. Выравнивание может быть полезно для
улучшения читаемости. Этот параметр можно задать только в файле postgresql.conf или в
командной строке при запуске сервера. Со значением по умолчанию, ‘%m [%p] ‘, в журнал
выводится метка времени и идентификатор процесса.
Спецсимвол Назначение
Только для пользователь-
ского процесса
%a Имя приложения (application_ да
name)
%u Имя пользователя
да
%d Имя базы данных
да
%r Имя удалённого узла или IP- да
адрес, а также номер порта
%h Имя удалённого узла или IP- да
адрес
%p Идентификатор процесса
%t Штамп времени, без миллисе- нет
кунд
%m Штамп времени, с миллисе- нет
кундами
%n Штамп времени, с миллисе- нет
кундами (в виде времени Unix)
%i Тег команды: тип текущей ко- да
манды в сессии
%e Код ошибки SQLSTATE
%c Идентификатор сессии.
дробности ниже
%l Номер строки журнала для нет
каждой сессии или процесса.
Начинается с 1
%s Штамп времени начала про- нет
цесса
%v Идентификатор
ной транзакции
localXID)
%x Идентификатор транзакции (0 нет
если не присвоен)
%q Ничего не выводит. Непользо- нет
вательские процессы останав-
ливаются в этой точке. Иг-
норируется пользовательски-
ми процессами
%% Выводит %
нет
нет
По- нет
виртуаль- нет
(backendID/
нет
%c выводит псевдоуникальный номер сеанса, состоящий из двух 4-байтных шестнадцатерич-
ных чисел (без ведущих нулей), разделённых точкой. Эти числа представляют время старта
процесса и идентификатор процесса, поэтому %c можно использовать для экономии места при
выводе этих значений. Например, для получения идентификатора сеанса из pg_stat_activity
используйте запрос:
546Настройка сервера
SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || ‘.’ ||
to_hex(pid)
FROM pg_stat_activity;
Подсказка
Последним символом в log_line_prefix лучше оставлять пробел, чтобы отделить
от остальной строки. Можно использовать и символы пунктуации.
Подсказка
Syslog также формирует штамп времени и идентификатор процесса, поэтому веро-
ятно нет смысла использовать соответствующие управляющие последовательности
при использовании syslog.
Подсказка
Спецпоследовательность %q полезна для включения информации, которая суще-
ствует только в контексте сеанса (обслуживающего процесса), например, имя поль-
зователя или базы данных. Например:
log_line_prefix = ‘%m [%p] %q%u@%d/%a ‘
log_lock_waits (boolean)
Определяет, нужно ли фиксировать в журнале события, когда сеанс ожидает получения блоки-
ровки дольше, чем указано в deadlock_timeout. Это позволяет выяснить, не связана ли низкая
производительность с ожиданием блокировок. По умолчанию отключено. Только суперпользо-
ватели могут изменить этот параметр.
log_statement (enum)
Управляет тем, какие SQL-команды записывать в журнал. Допустимые значения: none (отклю-
чено), ddl, mod и all (все команды). ddl записывает все команды определения данных, такие как
CREATE, ALTER, DROP. mod записывает все команды ddl, а также команды изменяющие данные,
такие как INSERT, UPDATE, DELETE, TRUNCATE и COPY FROM. PREPARE, EXECUTE и EXPLAIN ANALYZE
также записываются, если вызваны для команды соответствующего типа. Если клиент исполь-
зует расширенный протокол запросов, то запись происходит на фазе выполнения и содержит
значения всех связанных переменных (если есть символы одиночных кавычек, то они удваива-
ются).
По умолчанию none. Только суперпользователи могут изменить этот параметр.
Примечание
Команды с синтаксическими ошибками не записываются, даже если log_statement
= all, так как сообщение формируется только после выполнения предварительного
разбора, определяющего тип команды. При расширенном протоколе запросов, по-
хожим образом не будут записываться команды, неуспешно завершившиеся до фа-
зы выполнения (например, при разборе или построении плана запроса). Для вклю-
чения в журнал таких команд установите log_min_error_statement в ERROR (или
ниже).
547Настройка сервера
log_replication_commands (boolean)
Включает запись в журнал сервера всех команд репликации. Подробнее о командах реплика-
ции можно узнать в Разделе 53.4. Значение по умолчанию — off. Изменить этот параметр мо-
гут только суперпользователи.
log_temp_files (integer)
Управляет включением в журнал информации об именах и размерах временных файлов. Вре-
менные файлы могут использоваться для сортировок, хеширования и временного хранения ре-
зультатов запросов. На каждый временный файл, при его удалении, в журнал записывается
отдельное сообщение. Значение 0 говорит о том, что нужно записывать информацию о всех
временных файлах. Положительное значение задаёт размер временных файлов в килобайтах,
при достижении или превышении которого, информация о временном файле будет записана.
Значение по умолчанию -1, что отключает запись информации о временных файлах. Только
суперпользователи могут изменить этот параметр.
log_timezone (string)
Устанавливает часовой пояс для штампов времени при записи в журнал сервера. В отличие
от TimeZone, это значение одинаково для всех баз данных кластера, поэтому для всех сессий
используются согласованные значения штампов времени. Встроенное значение по умолчанию
GMT, но оно переопределяется в postgresql.conf: initdb записывает в него значение, соответ-
ствующее системной среде. Подробнее об этом в Подразделе 8.5.3. Задать этот параметр мож-
но только в postgresql.conf или в командной строке при запуске сервера.
19.8.4. Использование вывода журнала в формате CSV
Добавление csvlog в log_destination делает удобным загрузку журнальных файлов в таблицу
базы данных. Строки журнала представляют собой значения разделённые запятыми (CSV фор-
мат) со следующими полями: штамп времени с миллисекундами; имя пользователя; имя базы
данных; идентификатор процесса; клиентский узел:номер порта; идентификатор сессии; номер
строки каждой сессии; тег команды; время начала сессии; виртуальный идентификатор транзак-
ции; идентификатор транзакции; уровень важности ошибки; код ошибки SQLSTATE; сообщение
об ошибке; подробности к сообщению об ошибке; подсказка к сообщению об ошибке; внутрен-
ний запрос, приведший к ошибке (если есть); номер символа внутреннего запроса, где произо-
шла ошибка; контекст ошибки; запрос пользователя, приведший к ошибке (если есть и включён
log_min_error_statement); номер символа в запросе пользователя, где произошла ошибка; распо-
ложение ошибки в исходном коде PostgreSQL (если log_error_verbosity установлен в verbose) и
имя приложения. Вот пример определения таблицы, для хранения журналов в формате CSV:
CREATE TABLE postgres_log
(
log_time timestamp(3) with time zone,
user_name text,
database_name text,
process_id integer,
connection_from text,
session_id text,
session_line_num bigint,
command_tag text,
session_start_time timestamp with time zone,
virtual_transaction_id text,
transaction_id bigint,
error_severity text,
sql_state_code text,
message text,
detail text,
hint text,
internal_query text,
548Настройка сервера
internal_query_pos integer,
context text,
query text,
query_pos integer,
location text,
application_name text,
PRIMARY KEY (session_id, session_line_num)
);
Для загрузки журнального файла в такую таблицу можно использовать команду COPY FROM:
COPY postgres_log FROM ‘/full/path/to/logfile.csv’ WITH csv;
Для упрощения загрузки журналов в CSV формате используйте следующее:</li>
    </ul>
  </li>
  <li>Установите для log_filename и log_rotation_age значения, гарантирующие согласованную и
предсказуемую схему именования журнальных файлов. Зная, какие имена будут у журнальных
файлов, можно определить, когда конкретный файл заполнен и готов к загрузке.</li>
  <li>Установите log_rotation_size в 0, чтобы запретить ротацию файлов по достижении определён-
ного размера, так как это делает непредсказуемой схему именования журнальных файлов.</li>
  <li>Установите log_truncate_on_rotation в on, чтобы новые сообщения не смешивались со старыми
при переключении на существующий файл.</li>
  <li>Определение таблицы содержит первичный ключ. Это полезно для предотвращения случайной
повторной загрузки данных. Команда COPY фиксирует изменения один раз, поэтому любая ошиб-
ка приведёт к отмене всей загрузки. Если сначала загрузить неполный журнальный файл, то
его повторная загрузка (по заполнении) приведёт к нарушению первичного ключа и, следова-
тельно, к ошибке загрузки. Поэтому необходимо дожидаться окончания записи в журнальный
файл перед началом загрузки. Похожим образом предотвращается случайная загрузка частич-
но сформированной строки сообщения, что также приведёт к сбою в команде COPY.
19.8.5. Заголовок процесса
Эти параметры влияют на то, как формируются заголовки серверных процессов. Заголовок про-
цесса обычно можно наблюдать в программах типа ps, а в Windows — в Process Explorer. За подроб-
ностями обратитесь к Разделу 28.1.
cluster_name (string)
Задаёт имя кластера, которое отображается в заголовке процесса для всех серверных процес-
сов данного кластера. Это имя может быть любой строкой не длиннее NAMEDATALEN символов
(64 символа в стандартной сборке). В строке cluster_name могут использоваться только печа-
таемые ASCII-символы. Любой другой символ будет заменён символом вопроса (?). Если этот
параметр содержит пустую строку ‘’ (это значение по умолчанию), никакое имя не выводится.
Этот параметр можно задать только при запуске сервера.
update_process_title (boolean)
Включает изменение заголовка процесса при получении сервером каждой очередной команды
SQL. На большинстве платформ он включён (имеет значение on), но в Windows по умолчанию
выключен (off) ввиду больших издержек на изменение этого заголовка. Изменить этот пара-
метр могут только суперпользователи.
19.9. Статистика времени выполнения
19.9.1. Сбор статистики по запросам и индексам
Эти параметры управляет функциями сбора статистики на уровне сервера. Когда ведётся сбор ста-
тистики, собираемые данные можно просмотреть в семействе системных представлений pg_stat
и pg_statio. За дополнительными сведениями обратитесь к Главе 28.
549Настройка сервера
track_activities (boolean)
Включает сбор сведений о текущих командах, выполняющихся во всех сеансах (в частности,
отслеживается время запуска команды). По умолчанию этот параметр включён. Заметьте, что
даже когда сбор ведётся, собранная информация доступна не для всех пользователей, а толь-
ко для суперпользователей и пользователя-владельца сеанса, в котором выполняется текущая
команда. Поэтому это не должно повлечь риски, связанные с безопасностью. Изменить этот
параметр могут только суперпользователи.
track_activity_query_size (integer)
Задаёт число байт, которое будет зарезервировано для отслеживания выполняемой в данной
момент команды в каждом активном сеансе, для поля pg_stat_activity.query. Значение по
умолчанию — 1024. Задать этот параметр можно только при запуске сервера.
track_counts (boolean)
Включает сбор статистики активности в базе данных. Этот параметр по умолчанию включён,
так как собранная информация требуется демону автоочистки. Изменить этот параметр могут
только суперпользователи.
track_io_timing (boolean)
Включает замер времени операций ввода/вывода. Этот параметр по умолчанию отключён, так
как для этого требуется постоянно запрашивать текущее время у операционной системы, что
может значительно замедлить работу на некоторых платформах. Для оценивания издержек за-
мера времени на вашей платформе можно воспользоваться утилитой pg_test_timing. Статисти-
ку ввода/вывода можно получить через представление pg_stat_database, в выводе EXPLAIN (ко-
гда используется параметр BUFFERS) и через представление pg_stat_statements. Изменить этот
параметр могут только суперпользователи.
track_functions (enum)
Включает подсчёт вызовов функций и времени их выполнения. Значение pl включает отсле-
живание только функций на процедурном языке, а all — также функций на языках SQL и C.
Значение по умолчанию — none, то есть сбор статистики по функциям отключён. Изменить
этот параметр могут только суперпользователи.
Примечание
Функции на языке SQL, достаточно простые для «внедрения» в вызывающий запрос,
отслеживаться не будут вне зависимости от этого параметра.
stats_temp_directory (string)
Задаёт каталог, в котором будут храниться временные данные статистики. Этот путь может
быть абсолютным или задаваться относительно каталога данных. Значение по умолчанию —
pg_stat_tmp. Если разместить целевой каталог в файловой системе в ОЗУ, это снизит нагрузку
на физическое дисковое хранилище и может увеличить быстродействие. Задать этот параметр
можно только в postgresql.conf или в командной строке при запуске сервера.
19.9.2. Мониторинг статистики
log_statement_stats (boolean)
log_parser_stats (boolean)
log_planner_stats (boolean)
log_executor_stats (boolean)
Эти параметры включают вывод статистики по производительности соответствующего моду-
ля в протокол работы сервера. Это грубый инструмент профилирования, похожий на функцию
getrusage() в операционной системе. Параметр log_statement_stats включает вывод общей
550Настройка сервера
статистики по операторам, тогда как другие управляют статистикой по модулям (разбор, пла-
нирование, выполнение). Включить log_statement_stats одновременно с параметрами, управ-
ляющими модулями, нельзя. По умолчанию все эти параметры отключены. Изменить эти па-
раметры могут только суперпользователи.
19.10. Автоматическая очистка
Эти параметры управляют поведением механизма автоочистки. За дополнительными сведениями
обратитесь к Подразделу 24.1.6. Заметьте, что многие из этих параметров могут быть переопреде-
лены на уровне таблиц; см. Подраздел «Параметры хранения».
autovacuum (boolean)
Управляет состоянием демона, запускающего автоочистку. По умолчанию он включён, но что-
бы автоочистка работала, нужно также включить track_counts. Задать этот параметр можно
только в postgresql.conf или в командной строке при запуске сервера. Однако автоочистку
можно отключить для отдельных таблиц, изменив их параметры хранения.
Заметьте, что даже если этот параметр отключён, система будет запускать процессы автоочист-
ки, когда это необходимо для предотвращения зацикливания идентификаторов транзакций. За
дополнительными сведениями обратитесь к Подразделу 24.1.5.
log_autovacuum_min_duration (integer)
Задаёт время (в миллисекундах) выполнения действия автоочистки, при превышении которого
информация об этом действии записывается в протокол. При нулевом значении в протоколе
фиксируются все действия автоочистки. Значение -1 (по умолчанию) отключает протоколиро-
вание действий автоочистки. Например, если задать значение 250ms, в протоколе будут фикси-
роваться все операции автоматической очистки и анализа, выполняемые дольше 250 мс. Кроме
того, когда этот параметр имеет любое значение, отличное от -1, в протокол будет записывать-
ся сообщение в случае пропуска действия автоочистки из-за конфликтующей блокировки или
параллельного удаления отношения. Таким образом, включение этого параметра позволяет
отслеживать активность автоочистки. Задать этот параметр можно только в postgresql.conf
или в командной строке при запуске сервера. Однако его можно переопределить для отдельных
таблиц, изменив их параметры хранения.
autovacuum_max_workers (integer)
Задаёт максимальное число процессов автоочистки (не считая процесс, запускающий авто-
очистку), которые могут выполняться одновременно. По умолчанию это число равно трём. За-
дать этот параметр можно только при запуске сервера.
autovacuum_naptime (integer)
Задаёт минимальную задержку между двумя запусками автоочистки для отдельной базы дан-
ных. Демон автоочистки проверяет базу данных через заданный интервал времени и выдаёт
команды VACUUM и ANALYZE, когда это требуется для таблиц этой базы. Задержка задаётся в
секундах и по умолчанию равна одной минуте (1min). Этот параметр можно задать только в
postgresql.conf или в командной строке при запуске сервера.
autovacuum_vacuum_threshold (integer)
Задаёт минимальное число изменённых или удалённых кортежей, при котором будет выпол-
няться VACUUM для отдельно взятой таблицы. Значение по умолчанию — 50 кортежей. Задать
этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.
Однако данное значение можно переопределить для избранных таблиц, изменив их параметры
хранения.
autovacuum_analyze_threshold (integer)
Задаёт минимальное число добавленных, изменённых или удалённых кортежей, при котором
будет выполняться ANALYZE для отдельно взятой таблицы. Значение по умолчанию — 50 корте-
551Настройка сервера
жей. Этот параметр можно задать только в postgresql.conf или в командной строке при запус-
ке сервера. Однако данное значение можно переопределить для избранных таблиц, изменив
их параметры хранения.
autovacuum_vacuum_scale_factor (floating point)
Задаёт
процент
от
размера
таблицы,
который
будет
добавляться
к
autovacuum_vacuum_threshold при выборе порога срабатывания команды VACUUM. Значение
по умолчанию — 0.2 (20% от размера таблицы). Задать этот параметр можно только в
postgresql.conf или в командной строке при запуске сервера. Однако данное значение можно
переопределить для избранных таблиц, изменив их параметры хранения.
autovacuum_analyze_scale_factor (floating point)
Задаёт
процент
от
размера
таблицы,
который
будет
добавляться
к
autovacuum_analyze_threshold при выборе порога срабатывания команды ANALYZE. Значе-
ние по умолчанию — 0.1 (10% от размера таблицы). Задать этот параметр можно только в
postgresql.conf или в командной строке при запуске сервера. Однако данное значение можно
переопределить для избранных таблиц, изменив их параметры хранения.
autovacuum_freeze_max_age (integer)
Задаёт максимальный возраст (в транзакциях) для поля pg_class.relfrozenxid некоторой таб-
лицы, при достижении которого будет запущена операция VACUUM для предотвращения зацик-
ливания идентификаторов транзакций в этой таблице. Заметьте, что система запустит процес-
сы автоочистки для предотвращения зацикливания, даже если для всех других целей авто-
очистка отключена.
При очистке могут также удаляться старые файлы из подкаталога pg_xact, поэтому значение
по умолчанию сравнительно мало — 200 миллионов транзакций. Задать этот параметр можно
только при запуске сервера, но для отдельных таблиц его можно определить по-другому, изме-
нив их параметры хранения. За дополнительными сведениями обратитесь к Подразделу 24.1.5.
autovacuum_multixact_freeze_max_age (integer)
Задаёт максимальный возраст (в мультитранзакциях) для поля pg_class.relminmxid таблицы,
при достижении которого будет запущена операция VACUUM для предотвращения зацикливания
идентификаторов мультитранзакций в этой таблице. Заметьте, что система запустит процессы
автоочистки для предотвращения зацикливания, даже если для всех других целей автоочистка
отключена.
При очистке мультитранзакций могут также удаляться старые файлы из подкаталогов
pg_multixact/members и pg_multixact/offsets, поэтому значение по умолчанию сравнитель-
но мало — 400 миллионов мультитранзакций. Этот параметр можно задать только при запуске
сервера, но для отдельных таблиц его можно определить по-другому, изменив их параметры
хранения. За дополнительными сведениями обратитесь к Подразделу 24.1.5.1.
autovacuum_vacuum_cost_delay (integer)
Задаёт задержку при превышении предела стоимости, которая будет применяться при
автоматических операциях VACUUM. При значении -1 применяется обычная задержка
vacuum_cost_delay. Значение по умолчанию — 20 миллисекунд. Задать этот параметр можно
только в postgresql.conf или в командной строке при запуске сервера. Однако его можно пе-
реопределить для отдельных таблиц, изменив их параметры хранения.
autovacuum_vacuum_cost_limit (integer)
Задаёт предел стоимости, который будет учитываться при автоматических операциях VACUUM.
При значении -1 (по умолчанию) применяется обычное значение vacuum_cost_limit. Заметьте,
что это значение распределяется пропорционально среди всех работающих процессов авто-
очистки, если их больше одного, так что сумма ограничений всех процессов никогда не превос-
ходит данный предел. Задать этот параметр можно только в postgresql.conf или в командной
552Настройка сервера
строке при запуске сервера. Однако его можно переопределить для отдельных таблиц, изменив
их параметры хранения.
19.11. Параметры клиентских сеансов по умолчанию
19.11.1. Поведение команд
search_path (string)
Эта переменная определяет порядок, в котором будут просматриваться схемы при поиске объ-
екта (таблицы, типа данных, функции и т. д.), к которому обращаются просто по имени, без
указания схемы. Если объекты с одинаковым именем находятся в нескольких схемах, исполь-
зоваться будет тот, что встретится первым при просмотре пути поиска. К объекту, который не
относится к схемам, перечисленным в пути поиска, можно обратиться только по полному име-
ни (с точкой), с указанием содержащей его схемы.
Значением search_path должен быть список имён схем через запятую. Если для имени, ука-
занного в этом списке, не находится существующая схема, либо пользователь не имеет права
USAGE для схемы с этим именем, такое имя просто игнорируется.
Если список содержит специальный элемент $user, вместо него подставляется схема с име-
нем, возвращаемым функцией SESSION_USER, если такая схема существует и пользователь име-
ет право USAGE для неё. (В противном случае элемент $user игнорируется.)
Схема системных каталогов, pg_catalog, просматривается всегда, независимо от того, указана
она в пути или нет. Если она указана в пути, она просматривается в заданном порядке. Если же
pg_catalog отсутствует в пути, эта схема будет просматриваться перед остальными элементами
пути.
Аналогично всегда просматривается схема временных таблиц текущего сеанса, pg_temp_nnn,
если она существует. Её можно включить в путь поиска, указав её псевдоним pg_temp. Если
она отсутствует в пути, она будет просматриваться первой (даже перед pg_catalog). Временная
схема просматривается только при поиске отношений (таблиц, представлений, последователь-
ностей и т. д.) и типов данных, но никогда при поиске функций и операторов.
Когда объекты создаются без указания определённой целевой схемы, они помещаются в
первую пригодную схему, указанную в search_path. Если путь поиска схем пуст, выдаётся
ошибка.
По умолчанию этот параметр имеет значение “$user”, public. При таком значении поддер-
живается совместное использование базы данных (когда пользователи не имеют личных схем,
все используют схему public), использование личных схем, а также комбинация обоих вариан-
тов. Другие подходы можно реализовать, изменяя значение пути по умолчанию, либо глобаль-
но, либо индивидуально для каждого пользователя.
Более подробно обработка схем описана в Разделе 5.8. В частности, стандартная конфигура-
ция схем подходит только для баз данных с одним пользователем или с взаимно доверяющими
пользователями.
Текущее действующее значение пути поиска можно получить, воспользовавшись SQL-функ-
цией current_schemas (см. Раздел  9.25). Это значение может отличаться от значения
search_path, так как current_schemas показывает, как были преобразованы элементы, фигу-
рирующие в search_path.
row_security (boolean)
Эта переменная определяет, должна ли выдаваться ошибка при применении политик защиты
строк. Со значением on политики применяются в обычном режиме. Со значением off запросы,
ограничиваемые минимум одной политикой, будут выдавать ошибку. Значение по умолчанию
— on. Значение off рекомендуется, когда ограничение видимости строк чревато некорректны-
553Настройка сервера
ми результатами; например, pg_dump устанавливает это значение. Эта переменная не влияет
на роли, которые обходят все политики защиты строк, а именно, на суперпользователей и роли
с атрибутом BYPASSRLS.
Подробнее о политиках защиты строк можно узнать в описании CREATE POLICY.
default_tablespace (string)
Эта переменная устанавливает табличное пространство по умолчанию, в котором будут созда-
ваться объекты (таблицы и индексы), когда в команде CREATE табличное пространство не ука-
зывается явно.
Её значением может быть либо имя табличного пространства, либо пустая строка, подразуме-
вающая использование табличного пространства по умолчанию в текущей базе данных. Если
табличное пространство с заданным именем не существует, PostgreSQL будет автоматически
использовать табличное пространство по умолчанию. Если используется не пространство по
умолчанию, пользователь должен иметь право CREATE для него, иначе он не сможет создавать
объекты.
Эта переменная
temp_tablespaces.
не
используется
для
временных
таблиц;
для
них
задействуется
Эта переменная также не используется при создании баз данных. По умолчанию, новая база
данных наследует выбор табличного пространства от базы-шаблона, из которой она копирует-
ся.
За дополнительными сведениями о табличных пространствах обратитесь к Разделу 22.6.
temp_tablespaces (string)
Эта переменная задаёт табличные пространства, в которых будут создаваться временные объ-
екты (временные таблицы и индексы временных таблиц), когда в команде CREATE табличное
пространство не указывается явно. В этих табличных пространствах также создаются времен-
ные файлы для внутреннего использования, например, для сортировки больших наборов дан-
ных.
Её значение содержит список имён табличных пространств. Когда этот список содержит боль-
ше одного имени, PostgreSQL выбирает из этого списка случайный элемент при создании каж-
дого временного объекта; однако при создании последующих объектов внутри транзакции таб-
личные пространства перебираются последовательно. Если в этом списке оказывается пустая
строка, PostgreSQL будет автоматически использовать вместо этого элемента табличное про-
странство по умолчанию для текущей базы данных.
Когда temp_tablespaces задаётся интерактивно, указание несуществующего табличного про-
странства считается ошибкой, как и указание табличного пространства, для которого поль-
зователь не имеет права CREATE. Однако при использовании значения, заданного ранее,
несуществующие табличные пространства и пространства, для которых у пользователя
нет права CREATE, просто игнорируются. В частности, это касается значения, заданного в
postgresql.conf.
По умолчанию значение этой переменной — пустая строка. С таким значением все временные
объекты создаются в табличном пространстве по умолчанию, установленном для текущей базы
данных.
См. также default_tablespace.
check_function_bodies (boolean)
Этот параметр обычно включён. Выключение этого параметра (присвоение ему значения off)
отключает проверку строки с телом функции, передаваемой команде CREATE FUNCTION. От-
ключение проверки позволяет избежать побочных эффектов процесса проверки и исключить
ложные срабатывания из-за таких проблем, как ссылки вперёд. Этому параметру нужно при-
554Настройка сервера
сваивать значение off перед загрузкой функций от лица других пользователей; pg_dump дела-
ет это автоматически.
default_transaction_isolation (enum)
Для каждой транзакции в SQL устанавливается уровень изоляции: «read uncommitted», «read
committed», «repeatable read» или «serializable». Этот параметр задаёт уровень изоляции, ко-
торый будет устанавливаться по умолчанию для новых транзакций. Значение этого параметра
по умолчанию — «read committed».
Дополнительную информацию вы можете найти в Главе 13 и SET TRANSACTION.
default_transaction_read_only (boolean)
SQL-транзакции в режиме «только чтение» не могут модифицировать не временные таблицы.
Этот параметр определяет, будут ли новые транзакции по умолчанию иметь характеристику
«только чтение». Значение этого параметра по умолчанию — off (допускается чтение и за-
пись).
За дополнительной информацией обратитесь к SET TRANSACTION.
default_transaction_deferrable (boolean)
Транзакция, работающая на уровне изоляции serializable, в режиме «только чтение» может
быть задержана, прежде чем будет разрешено её выполнение. Однако, когда она начинает вы-
полняться, для обеспечения сериализуемости не требуется никаких дополнительных усилий,
так что коду сериализации ни при каких условиях не придётся прерывать её из-за параллель-
ных изменений, поэтому это вполне подходит для длительных транзакций в режиме «только
чтение».
Этот параметр определяет, будет ли каждая новая транзакция по умолчанию откладываемой.
В настоящее время его действие не распространяется на транзакции, для которых устанавли-
вается режим «чтение/запись» или уровень изоляции ниже serializable. Значение по умол-
чанию — off (выкл.).
За дополнительной информацией обратитесь к SET TRANSACTION.
session_replication_role (enum)
Управляет срабатыванием правил и триггеров, связанных с репликацией, в текущем сеансе.
Изменение этой переменной требует наличия прав суперпользователя и приводит к сбросу
всех ранее кешированных планов запросов. Она может принимать следующие значения: origin
(значение по умолчанию), replica и local.
Предполагается, что системы логической репликации будут устанавливать для него значение
replica, применяя реплицированные изменения. В результате триггеры и правила (с конфигу-
рацией по умолчанию) не будут срабатывать в репликах. Подробнее об этом говорится в опи-
сании предложений ENABLE TRIGGER и ENABLE RULE команды ALTER TABLE.
Внутри PostgreSQL значения origin и local воспринимаются как равнозначные. Сторонние
системы репликации могут различать их для своих внутренних целей, например, отмечать зна-
чением local сеанс, изменения в котором не должны реплицироваться.
Так как внешние ключи реализованы посредством триггеров, присвоение этому параметру зна-
чения replica влечёт отключение всех проверок внешних ключей, что может привести к на-
рушению согласованности данных при некорректном использовании.
statement_timeout (integer)
Задаёт максимальное время выполнения оператора (в миллисекундах), начиная с момента по-
лучения сервером команды от клиента, по истечении которого оператор прерывается. Если
log_min_error_statement имеет значение ERROR или ниже, оператор, прерванный по тайм-ауту,
555Настройка сервера
будет также записан в журнал. При значении, равном нулю (по умолчанию), этот контроль
длительности отключается.
Устанавливать значение statement_timeout в postgresql.conf не рекомендуется, так как это
повлияет на все сеансы.
lock_timeout (integer)
Задаёт максимальную длительность ожидания (в миллисекундах) любым оператором получе-
ния блокировки таблицы, индекса, строки или другого объекта базы данных. Если ожидание не
закончилось за указанное время, оператор прерывается. Это ограничение действует на каж-
дую попытку получения блокировки по отдельности и применяется как к явным запросам бло-
кировки (например, LOCK TABLE или SELECT FOR UPDATE без NOWAIT), так и к неявным. Если
log_min_error_statement имеет значение ERROR или ниже, оператор, прерванный по тайм-ауту,
будет также записан в журнал. При значении, равном нулю (по умолчанию), этот контроль
длительности отключается.
В отличие от statement_timeout, этот тайм-аут может произойти только при ожидании блоки-
ровки. Заметьте, что при ненулевом statement_timeout бессмысленно задавать в lock_timeout
такое же или большее значение, так как тайм-аут оператора всегда будет происходить раньше.
Устанавливать значение lock_timeout в postgresql.conf не рекомендуется, так как это повли-
яет на все сеансы.
idle_in_transaction_session_timeout (integer)
Завершать любые сеансы, в которых открытая транзакция простаивает дольше заданного (в
миллисекундах) времени. Это позволяет освободить все блокировки сеанса и вновь задейство-
вать слот подключения; также это позволяет очистить кортежи, видимые только для этой тран-
закции. Подробнее это описано в Разделе 24.1.
Значение по умолчанию (0) отключает это поведение.
vacuum_freeze_table_age (integer)
Задаёт максимальный возраст для поля pg_class.relfrozenxid таблицы, при достижении ко-
торого VACUUM будет производить агрессивное сканирование. Агрессивное сканирование отли-
чается от обычного сканирования VACUUM тем, что затрагивает все страницы, которые могут
содержать незамороженные XID или MXID, а не только те, что могут содержать мёртвые кор-
тежи. Значение по умолчанию — 150 миллионов транзакций. Хотя пользователи могут задать
любое значение от нуля до двух миллиардов, в VACUUM введён внутренний предел для действую-
щего значения, равный 95% от autovacuum_freeze_max_age, чтобы периодически запускаемая
вручную команда VACUUM имела шансы выполниться, прежде чем для таблицы будет запущена
автоочистка для предотвращения зацикливания. За дополнительными сведениями обратитесь
к Подразделу 24.1.5.
vacuum_freeze_min_age (integer)
Задаёт возраст для отсечки (в транзакциях), при достижении которого команда VACUUM долж-
на замораживать версии строк при сканировании таблицы. Значение по умолчанию — 50 мил-
лионов транзакций. Хотя пользователи могут задать любое значение от нуля до одного мил-
лиарда, в VACUUM введён внутренний предел для действующего значения, равный половине
autovacuum_freeze_max_age, чтобы принудительная автоочистка выполнялась не слишком ча-
сто. За дополнительными сведениями обратитесь к Подразделу 24.1.5.
vacuum_multixact_freeze_table_age (integer)
Задаёт максимальный возраст для поля pg_class.relminmxid таблицы, при достижении кото-
рого команда VACUUM будет выполнять агрессивное сканирование. Агрессивное сканирование
отличается от обычного сканирования VACUUM тем, что затрагивает все страницы, которые мо-
гут содержать незамороженные XID или MXID, а не только те, что могут содержать мёртвые
кортежи. Значение по умолчанию — 150 миллионов мультитранзакций. Хотя пользователи мо-
556Настройка сервера
гут задать любое значение от нуля до двух миллиардов, в VACUUM введён внутренний предел
для действующего значения, равный 95% от autovacuum_multixact_freeze_max_age, чтобы пе-
риодически запускаемая вручную команда VACUUM имела шансы выполниться, прежде чем для
таблицы будет запущена автоочистка для предотвращения зацикливания. За дополнительными
сведениями обратитесь к Подразделу 24.1.5.1.
vacuum_multixact_freeze_min_age (integer)
Задаёт возраст для отсечки (в мультитранзакциях), при достижении которого команда VACUUM
должна заменять идентификаторы мультитранзакций новыми идентификаторами транзакций
или мультитранзакций при сканировании таблицы. Значение по умолчанию — 5 миллионов
мультитранзакций. Хотя пользователи могут задать любое значение от нуля до одного мил-
лиарда, в VACUUM введён внутренний предел для действующего значения, равный полови-
не autovacuum_multixact_freeze_max_age, чтобы принудительная автоочистка не выполнялась
слишком часто. За дополнительными сведениями обратитесь к Подразделу 24.1.5.1.
vacuum_cleanup_index_scale_factor (floating point)
Определяет процент от общего числа кортежей кучи, подсчитанных при последнем сборе ста-
тистики, который может быть вставлен без необходимости сканирования индекса на стадии
очистки при выполнении VACUUM. В настоящее время этот параметр применяется только к ин-
дексам-B-деревьям.
Если из кучи не удалялись кортежи, индексы-B-деревья будут в любом случае сканироваться
на стадии очистки VACUUM, когда выполняется хотя бы одно из следующих условий: статистика
индексов устарела; индекс содержит удалённые страницы, которые могут быть переработаны
при очистке. Статистика индекса считается устаревшей, если число недавно вставленных кор-
тежей превышает процент vacuum_cleanup_index_scale_factor от общего числа кортежей в
куче, полученного при предыдущем сборе статистики. Общее число кортежей в куче хранится
в метастранице индекса. Заметьте, что эти данные появятся в ней только после того, как про-
цедура VACUUM не обнаружит ни одного «мёртвого» кортежа, поэтому сканирование индекса-B-
дерева на стадии очистки может быть пропущено, только если «мёртвые» кортежи не будут
найдены на втором и последующих циклах VACUUM.
Параметр
может
принимать
значения
от
0
до
10000000000.
Когда
vacuum_cleanup_index_scale_factor равен 0, сканирование индекса на этапе очистки VACUUM
не пропускается никогда. Значение по умолчанию — 0.1.
bytea_output (enum)
Задаёт выходной формат для значения типа bytea. Это может быть формат hex (по умолчанию)
или escape (традиционный формат PostgreSQL). За дополнительными сведениями обратитесь
к Разделу 8.4. Входные значения bytea воспринимаются в обоих форматах, независимо от дан-
ного параметра.
xmlbinary (enum)
Задаёт способ кодирования двоичных данных в XML. Это кодирование применяется, например,
когда значения bytea преобразуются в XML функциями xmlelement или xmlforest. Допусти-
мые варианты, определённые в стандарте XML-схем: base64 и hex. Значение по умолчанию —
base64. Чтобы узнать больше о функциях для работы с XML, обратитесь к Разделу 9.14.
Конечный выбор в основном дело вкуса, ограничения могут накладываться только клиентски-
ми приложениями. Оба метода поддерживают все возможные значения, хотя результат коди-
рования в base64 немного компактнее шестнадцатеричного вида (hex).
xmloption (enum)
Задаёт подразумеваемый по умолчанию тип преобразования между XML и символьными стро-
ками (DOCUMENT или CONTENT). За описанием этого преобразования обратитесь к Разделу 8.13.
Значение по умолчанию — CONTENT (кроме него допускается значение DOCUMENT).
557Настройка сервера
Согласно стандарту SQL этот параметр должен задаваться командой
SET XML OPTION { DOCUMENT | CONTENT };
Этот синтаксис тоже поддерживается в PostgreSQL.
gin_pending_list_limit (integer)
Задаёт максимальный размер очереди записей GIN, которая используется, когда включён ре-
жим fastupdate. Если размер очереди превышает заданный предел, записи из неё массово пе-
реносятся в основную структуру данных GIN и очередь очищается. Размер по умолчанию — че-
тыре мегабайта (4MB). Этот предел можно переопределить для отдельных индексов GIN, изме-
нив их параметры хранения. За дополнительными сведениями обратитесь к Подразделу 66.4.1
и Разделу 66.5.
19.11.2. Языковая среда и форматы
DateStyle (string)
Задаёт формат вывода значений даты и времени, а также правила интерпретации неоднознач-
ных значений даты. По историческим причинам эта переменная содержит два независимых
компонента: указание выходного формата (ISO, Postgres, SQL и German) и указание порядка
год(Y)/месяц(M)/день(D) для вводимых и выводимых значений (DMY, MDY или YMD). Эти два ком-
понента могут задаваться по отдельности или вместе. Ключевые слова Euro и European явля-
ются синонимами DMY, а ключевые слова US, NonEuro и NonEuropean — синонимы MDY. За допол-
нительными сведениями обратитесь к Разделу 8.5. Встроенное значение по умолчанию — ISO,
MDY, но initdb при инициализации записывает в файл конфигурации значение, соответствующее
выбранной локали lc_time.
IntervalStyle (enum)
Задаёт формат вывода для значений-интервалов. В формате sql_standard интервал выводится
в виде, установленном стандартом SQL. В формате postgres (выбранном по умолчанию) интер-
вал выводится в виде, применявшемся в PostgreSQL до версии 8.4, когда параметр DateStyle
имел значение ISO. В формате postgres_verbose интервал выводится в виде, применявшемся в
PostgreSQL до версии 8.4, когда параметр DateStyle имел значение не ISO. В формате iso_8601
выводимая строка будет соответствовать «формату с кодами», определённому в разделе 4.4.3.2
стандарта ISO 8601.
На интерпретацию неоднозначных вводимых данных также влияет параметр IntervalStyle.
За дополнительными сведениями обратитесь к Подразделу 8.5.4.
TimeZone (string)
Задаёт часовой пояс для вывода и ввода значений времени. Встроенное значение по умолча-
нию — GMT, но обычно оно переопределяется в postgresql.conf; initdb устанавливает в нём
значение, соответствующее системному окружению. За дополнительными сведениями обрати-
тесь к Подразделу 8.5.3.
timezone_abbreviations (string)
Задаёт набор сокращений часовых поясов, которые будут приниматься сервером во вводимых
значениях даты и времени. Значение по умолчанию — ‘Default’, которое представляет набор
основных сокращений, принятых в мире; допускаются также значения ‘Australia’ и ‘India’,
кроме них для конкретной инсталляции можно определить и другие наборы. За дополнитель-
ными сведениями обратитесь к Разделу B.3.
extra_float_digits (integer)
Этот параметр корректирует число цифр, выводимых при отображении чисел с плавающей точ-
кой, включая типы float4, float8 и геометрические типы. Значение параметра добавляется к
стандартному числу цифр (FLT_DIG или DBL_DIG, в зависимости от типа). Значение может быть
положительным, до 3, и тогда в выводе добавляются частично значимые цифры (это особенно
558Настройка сервера
полезно для выгрузки чисел с плавающей точкой, которые должны быть восстановлены точно),
или отрицательным, тогда в выводе будут подавляться нежелательные цифры. См. также Под-
раздел 8.1.3.
client_encoding (string)
Задаёт кодировку (набор символов) на стороне клиента. По умолчанию выбирается кодиров-
ка базы данных. Наборы символов, которые поддерживает сервер PostgreSQL, перечислены в
Подразделе 23.3.1.
lc_messages (string)
Устанавливает язык выводимых сообщений. Набор допустимых значений зависит от системы;
за дополнительными сведениями обратитесь к Разделу 23.1. Если эта переменная определена
как пустая строка (по умолчанию), то действующее значение получается из среды выполнения
сервера, в зависимости от системы.
В некоторых системах такая категория локали отсутствует, так что даже если задать значение
этой переменной, действовать оно не будет. Также может оказаться, что переведённые сооб-
щения для запрошенного языка отсутствуют. В этих случаях вы по-прежнему будете получать
сообщения на английском языке.
Изменить этот параметр могут только суперпользователи. Он влияет и на сообщения, которые
сервер передаёт клиентам, и на те, что записываются в журнал, поэтому неподходящее значе-
ние может сделать серверные журналы нечитаемыми.
lc_monetary (string)
Устанавливает локаль для форматирования денежных сумм, например с использованием функ-
ций семейства to_char. Набор допустимых значений зависит от системы; за дополнительными
сведениями обратитесь к Разделу 23.1. Если эта переменная определена как пустая строка (по
умолчанию), то действующее значение получается из среды выполнения сервера, в зависимо-
сти от системы.
lc_numeric (string)
Устанавливает локаль для форматирования чисел, например с использованием функций семей-
ства to_char. Набор допустимых значений зависит от системы; за дополнительными сведени-
ями обратитесь к Разделу 23.1. Если эта переменная определена как пустая строка (по умол-
чанию), то действующее значение получается из среды выполнения сервера, в зависимости от
системы.
lc_time (string)
Устанавливает локаль для форматирования даты и времени, например с использованием функ-
ций семейства to_char. Набор допустимых значений зависит от системы; за дополнительными
сведениями обратитесь к Разделу 23.1. Если эта переменная определена как пустая строка (по
умолчанию), то действующее значение получается из среды выполнения сервера, в зависимо-
сти от системы.
default_text_search_config (string)
Выбирает конфигурацию текстового поиска для тех функций текстового поиска, которым не
передаётся аргумент, явно указывающий конфигурацию. За дополнительной информацией об-
ратитесь к Главе 12. Встроенное значение по умолчанию — pg_catalog.simple, но initdb при
инициализации записывает в файл конфигурации сервера значение, соответствующее выбран-
ной локали lc_ctype, если удастся найти такую конфигурацию текстового поиска.
19.11.3. Предзагрузка разделяемых библиотек
Для настройки предварительной загрузки разделяемых библиотек в память сервера, в целях под-
ключения дополнительной функциональности или увеличения быстродействия, предназначены
559Настройка сервера
несколько параметров. Значения этих параметров задаются однотипно, например, со значением
‘$libdir/mylib’ в память будет загружена mylib.so (или в некоторых ОС, mylib.sl) из стандарт-
ного каталога библиотек данной инсталляции сервера. Различаются эти параметры тем, когда они
вступают в силу и какие права требуются для их изменения.
Таким же образом можно загрузить библиотеки на процедурных языках PostgreSQL, обычно в виде
‘$libdir/plXXX’, где XXX — имя языка: pgsql, perl, tcl или python.
Этим способом можно загрузить только разделяемые библиотеки, предназначенные специально
для использования с PostgreSQL. PostgreSQL при загрузке библиотеки проверяет наличие «отли-
чительного блока» для гарантии совместимости. Поэтому загрузить библиотеки не для PostgreSQL
таким образом нельзя. Для этого вы можете воспользоваться средствами операционной системы,
например, переменной окружения LD_PRELOAD.
В общем случае, чтобы узнать, какой способ рекомендуется для загрузки модуля, следует обра-
титься к документации этого модуля.
local_preload_libraries (string)
В этом параметре задаются одна или несколько разделяемых библиотек, которые будут загру-
жаться при установлении соединения. Он содержит разделённый запятыми список имён биб-
лиотек, и каждое имя в нём должно восприниматься командой LOAD. Пробельные символы
между именами игнорируются; если в имя нужно включить пробелы или запятые, заключите
его в двойные кавычки. Заданное значение параметра действует только в начале соединения,
так что последующие изменения ни на что не влияют. Если указанная в нём библиотека не
найдена, установить подключение не удастся.
Этот параметр разрешено устанавливать всем пользователям. Поэтому библиотеки, кото-
рые так можно загрузить, ограничиваются теми, что находятся в подкаталоге plugins стан-
дартного каталога библиотек установленного сервера. (Ответственность за то, чтобы в этом
подкаталоге находились только «безопасные» библиотеки, лежит на администраторе.) В
local_preload_libraries этот каталог можно задать явно (например, так: $libdir/plugins/
mylib), либо просто указать имя библиотеки — mylib (оно будет воспринято как $libdir/
plugins/mylib).
Данный механизм предназначен для того, чтобы непривилегированные пользователи могли за-
гружать отладочные или профилирующие библиотеки в избранных сеансах, обходясь без явной
команды LOAD. Для такого применения этот параметр обычно устанавливается в переменной
окружения PGOPTIONS на клиенте или с помощью команды ALTER ROLE SET.
Обычно этот параметр не следует использовать, если только модуль не предназначен специ-
ально для такой загрузки обычными пользователями. Предпочтительная альтернатива ему —
session_preload_libraries.
session_preload_libraries (string)
В этом параметре задаются одна или несколько разделяемых библиотек, которые будут загру-
жаться при установлении соединения. Он содержит разделённый запятыми список имён биб-
лиотек, и каждое имя в нём должно восприниматься командой LOAD. Пробельные символы
между именами игнорируются; если в имя нужно включить пробелы или запятые, заключите
его в двойные кавычки. Заданное значение параметра действует только в начале соединения,
так что последующие изменения ни на что не влияют. Если указанная в нём библиотека не
найдена, установить подключение не удастся. Изменить его могут только суперпользователи.
Данный параметр предназначен для загрузки отладочных или профилирующих библиотек в
избранных сеансах, без явного выполнения команды LOAD. Например, можно загрузить модуль
auto_explain во всех сеансах пользователя с заданным именем, установив этот параметр коман-
дой ALTER ROLE SET. Кроме того, этот параметр можно изменить без перезапуска сервера (хотя
изменения вступают в силу только при запуске нового сеанса), так что таким образом проще
подгружать новые модули, даже если это нужно сделать для всех сеансов.
560Настройка сервера
В отличие от shared_preload_libraries, этот вариант загрузки библиотеки не даёт большого вы-
игрыша в скорости по сравнению с вариантом загрузки при первом использовании. Однако он
оказывается выигрышным, когда используется пул соединений.
shared_preload_libraries (string)
В этом параметре задаются одна или несколько разделяемых библиотек, которые будут загру-
жаться при запуске сервера. Он содержит разделённый запятыми список имён библиотек, и
каждое имя в нём должно восприниматься командой LOAD. Пробельные символы между име-
нами игнорируются; если в имя нужно включить пробелы или запятые, заключите его в двой-
ные кавычки. Этот параметр можно задать только при запуске сервера. Если указанная в нём
библиотека не будет найдена, сервер не запустится.
Некоторые библиотеки при загрузке должны выполнять операции, которые могут иметь ме-
сто только при запуске главного процесса, например, выделять разделяемую память, резерви-
ровать легковесные блокировки или запускать фоновые рабочие процессы. Такие библиотеки
должны загружаться при запуске сервера посредством этого параметра. За подробностями об-
ратитесь к документации библиотек.
Также можно предварительно загрузить и другие библиотеки. Предварительная загрузка поз-
воляет избавиться от задержки, возникающей при первом использовании библиотеки. Однако
при этом может несколько увеличиться время запуска каждого нового процесса, даже если
он не будет использовать эту библиотеку. Поэтому применять этот параметр рекомендуется
только для библиотек, которые будут использоваться большинством сеансов. Кроме того, при
изменении этого параметра необходимо перезапускать сервер, так что этот вариант не подхо-
дит, например, для краткосрочных задач отладки. В таких случаях используйте вместо него
session_preload_libraries.
Примечание
В системе Windows загрузка библиотек при запуске сервера не сокращает время
запуска каждого нового серверного процесса; каждый процесс будет заново загру-
жать все библиотеки. Однако параметр shared_preload_libraries всё же может
быть полезен в Windows для загрузки библиотек, которые должны выполнять неко-
торые операции при запуске главного процесса.
jit_provider (string)
В этой переменной указывается библиотека провайдера JIT, которая будет использоваться (см.
Подраздел 32.4.2). Значение по умолчанию — llvmjit. Этот параметр можно задать только при
запуске сервера.
Если указывается несуществующая библиотека, JIT не будет работать, но это не считается
ошибкой. Такое поведение позволяет устанавливать поддержку JIT отдельно от основного па-
кета PostgreSQL.
19.11.4. Другие параметры по умолчанию
dynamic_library_path (string)
Когда требуется открыть динамически загружаемый модуль и его имя, заданное в команде
CREATE FUNCTION или LOAD не содержит имён каталогов (т. е. в этом имени нет косой черты),
система будет искать запрошенный файл в данном пути.
Значением параметра dynamic_library_path должен быть список абсолютных путей, разделён-
ных двоеточием (или точкой с запятой в Windows). Если элемент в этом списке начинается со
специальной строки $libdir, вместо неё подставляется заданный при компиляции путь ката-
лога библиотек PostgreSQL; в этот каталог устанавливаются модули, поставляемые в составе
стандартного дистрибутива PostgreSQL. (Чтобы узнать имя этого каталога, можно выполнить
pg_config –pkglibdir.) Например:
561Настройка сервера
dynamic_library_path = ‘/usr/local/lib/postgresql:/home/my_project/lib:$libdir’
Или в среде Windows:
dynamic_library_path = ‘C:\tools\postgresql;H:\my_project\lib;$libdir’
Значение по умолчанию этого параметра — ‘$libdir’. Если его значение — пустая строка,
автоматический поиск по заданному пути отключается.
Суперпользователи могут изменить этот параметр в процессе работы сервера, но такое изме-
нение будет действовать только до завершения клиентского соединения, так что этот вариант
следует оставить для целей разработки. Для других целей этот параметр рекомендуется уста-
навливать в файле конфигурации postgresql.conf.
gin_fuzzy_search_limit (integer)
Задаёт мягкий верхний лимит для размера набора, возвращаемого при сканировании индексов
GIN. За дополнительными сведениями обратитесь к Разделу 66.5.
19.12. Управление блокировками
deadlock_timeout (integer)
Время ожидания блокировки (в миллисекундах), по истечении которого будет выполняться
проверка состояния взаимоблокировки. Эта проверка довольно дорогостоящая, поэтому сервер
не выполняет её при всяком ожидании блокировки. Мы оптимистично полагаем, что взаимо-
блокировки редки в производственных приложениях и поэтому просто ждём некоторое время,
прежде чем пытаться выявить взаимоблокировку. При увеличении значения этого параметра
сокращается время, уходящее на ненужные проверки взаимоблокировки, но замедляется ре-
акция на реальные взаимоблокировки. Значение по умолчанию — одна секунда (1s), что близ-
ко к минимальному значению, которое стоит применять на практике. На сервере с большой
нагрузкой имеет смысл увеличить его. В идеале это значение должно превышать типичное
время транзакции, чтобы повысить шансы на то, что блокировка всё-таки будет освобождена,
прежде чем ожидающая транзакция решит проверить состояние взаимоблокировки. Изменить
этот параметр могут только суперпользователи.
Когда включён параметр log_lock_waits, данный параметр также определяет, спустя какое вре-
мя в журнал сервера будут записываться сообщения об ожидании блокировки. Если вы пытае-
тесь исследовать задержки, вызванные блокировками, имеет смысл уменьшить его по сравне-
нию с обычным значением deadlock_timeout.
max_locks_per_transaction (integer)
Общая таблица блокировок отслеживает блокировки для max_locks_per_transaction *
(max_connections + max_prepared_transactions) объектов (например, таблиц); таким образом, в
любой момент времени может быть заблокировано не больше этого числа различных объек-
тов. Этот параметр управляет средним числом блокировок объектов, выделяемым для каждой
транзакции; отдельные транзакции могут заблокировать и больше объектов, если все они уме-
щаются в таблице блокировок. Заметьте, что это не число строк, которое может быть забло-
кировано; их количество не ограничено. Значение по умолчанию, 64, как показала практика,
вполне приемлемо, но может возникнуть потребность его увеличить, если запросы обращают-
ся ко множеству различных таблиц в одной транзакции, как например, запрос к родительской
таблице со многими потомками. Этот параметр можно задать только при запуске сервера.
Для ведомого сервера значение этого параметра должно быть больше или равно значению на
ведущем. В противном случае на ведомом сервере не будут разрешены запросы.
max_pred_locks_per_transaction (integer)
Общая
таблица
предикатных
блокировок
отслеживает
блокировки
для
max_pred_locks_per_transaction * (max_connections + max_prepared_transactions) объектов
(например, таблиц); таким образом, в одним момент времени может быть заблокировано не
562Настройка сервера
больше этого число различных объектов. Этот параметр управляет средним числом блокировок
объектов, выделяемым для каждой транзакции; отдельные транзакции могут заблокировать и
больше объектов, если все они умещаются в таблице блокировок. Заметьте, что это не число
строк, которое может быть заблокировано; их количество не ограничено. Значение по умол-
чанию, 64, как показала практика, вполне приемлемо, но может возникнуть потребность его
увеличить, если запросы обращаются ко множеству различных таблиц в одной сериализуемой
транзакции, как например, запрос к родительской таблице со многими потомками. Этот пара-
метр можно задать только при запуске сервера.
max_pred_locks_per_relation (integer)
Этот параметр определяет, для скольких страниц или кортежей одного отношения могут уста-
навливаться предикатные блокировки, прежде чем вместо них будет затребована одна блоки-
ровка для всего отношения. Значения, большие или равные нулю, задают абсолютный предел,
а с отрицательным значением пределом будет значение max_pred_locks_per_transaction, делён-
ное на модуль данного. По умолчанию действует значение -2, что даёт то же поведение, что
наблюдалось в предыдущих версиях PostgreSQL. Этот параметр можно задать только в файле
postgresql.conf или в командной строке при запуске сервера.
max_pred_locks_per_page (integer)
Этот параметр определяет, для скольких строк на одной странице могут устанавливаться пре-
дикатные блокировки, прежде чем вместо них будет затребована одна блокировка для всей
страницы. Этот параметр можно задать только в файле postgresql.conf или в командной стро-
ке при запуске сервера.
19.13. Совместимость с разными версиями и платфор-
мами
19.13.1. Предыдущие версии PostgreSQL
array_nulls (boolean)
Этот параметр определяет, будет ли при разборе вводимого массива распознаваться строка
NULL без кавычек как элемент массива, равный NULL. Значение по умолчанию, on, позволяет
задавать NULL в качестве элементов вводимого массива. Однако до версии 8.2 PostgreSQL не
поддерживал ввод элементов NULL в массивах, а воспринимал NULL как обычный элемент мас-
сива со строковым значением «NULL». Для обратной совместимости с приложениями, завися-
щими от старого поведения, эту переменную можно отключить (присвоив ей off).
Заметьте, что массивы, содержащие NULL, можно создать, даже когда эта переменная имеет
значение off.
backslash_quote (enum)
Этот параметр определяет, можно ли будет представить знак апострофа в строковой констан-
те в виде '. В стандарте SQL определён другой, предпочитаемый вариант передачи апостро-
фа, удвоением (‘’), но PostgreSQL исторически также принимал вариант '. Однако примене-
ние варианта ' сопряжено с угрозами безопасности, так как в некоторых клиентских коди-
ровках существуют многобайтные символы, последний байт которых численно равен ASCII-ко-
ду . Если код на стороне клиента выполнит экранирование некорректно, это может открыть
возможности для SQL-инъекции. Предотвратить этот риск можно, запретив серверу принимать
запросы, в которых апостроф экранируется обратной косой. Допустимые значения параметра
backslash_quote: on (принимать ' всегда), off (не принимать никогда) и safe_encoding (при-
нимать, только если клиентская кодировка не допускает присутствия ASCII-кода \ в многобайт-
ных символах). Значение по умолчанию — safe_encoding.
Заметьте, что в строковой константе, записанной согласно стандарту, знаки \ обозначают про-
сто . Этот параметр влияет только на восприятие строк, не соответствующих стандарту, в том
числе с синтаксисом спецпоследовательностей (E’…’).
563Настройка сервера
default_with_oids (boolean)
Этот параметр определяет, будут ли команды CREATE TABLE и CREATE TABLE AS без явных ука-
заний WITH OIDS и WITHOUT OIDS добавлять столбец OID в создаваемые таблицы. Он также уста-
навливает, будут ли столбцы OID добавляться в таблицы, создаваемые командой SELECT INTO.
По умолчанию значение этого параметра — off (столбцы OID не добавляются); в PostgreSQL
версии 8.0 и ранее он был включён (on).
Практика использования OID в пользовательских таблицах считается устаревшей, так что в
большинстве инсталляций не следует включать этот параметр. Приложения, которым требует-
ся столбец OID в определённой таблице, могут явно указать WITH OIDS при создании таблицы.
Этот параметр следует включать только для совместимости со старыми приложениями, кото-
рые не делают этого.
escape_string_warning (boolean)
Когда этот параметр включён, сервер выдаёт предупреждение, если обратная косая чер-
та () встречается в обычной строковой константе (с синтаксисом ‘…’) и параметр
standard_conforming_strings отключён. Значение по умолчанию — on (вкл.).
Приложения, которые предпочитают использовать обратную косую в виде спецсимвола, долж-
ны перейти к применению синтаксиса спецстрок (E’…’), так как по умолчанию теперь в обыч-
ных строках обратная косая воспринимается как обычный символ, в соответствии со стандар-
том SQL. Включение данного параметра помогает найти код, нуждающийся в модификации.
lo_compat_privileges (boolean)
В PostgreSQL до версии 9.0 для больших объектов не назначались права доступа, и поэтому они
были всегда доступны на чтение и запись для всех пользователей. Если установить для этого
параметра значение on, существующие теперь проверки прав отключаются для совместимости
с предыдущими версиями. Значение по умолчанию — off. Изменить этот параметр могут толь-
ко суперпользователи.
Установка данного параметра не приводит к отключению всех проверок безопасности, свя-
занных с большими объектами — затрагиваются только те проверки, которые изменились в
PostgreSQL 9.0.
operator_precedence_warning (boolean)
Когда этот параметр включён, анализатор запроса будет выдавать предупреждение для всех
конструкций, которые поменяли поведение после PostgreSQL 9.4 в результате изменения при-
оритетов операторов. Это полезно для аудита, так как позволяет понять, не сломалось ли что-
то вследствие этого изменения. Но в производственной среде включать его не следует, так как
предупреждения могут выдаваться и тогда, когда код абсолютно правильный и соответствует
стандарту SQL. Значение по умолчанию — off.
За подробностями обратитесь к Подразделу 4.1.6.
quote_all_identifiers (boolean)
Принудительно заключать в кавычки все идентификаторы, даже если это не ключевые слова
(сегодня), при получении SQL из базы данных. Это касается вывода EXPLAIN, а также резуль-
татов функций типа pg_get_viewdef. См. также описание аргумента –quote-all-identifiers
команд pg_dump и pg_dumpall.
standard_conforming_strings (boolean)
Этот параметр определяет, будет ли обратная косая черта в обычных строковых констан-
тах (‘…’) восприниматься буквально, как того требует стандарт SQL. Начиная с версии
PostgreSQL 9.1, он имеет значение on (в предыдущих версиях значение по умолчанию было
off). Приложения могут выяснить, как обрабатываются строковые константы, проверив этот
параметр. Наличие этого параметра может также быть признаком того, что поддерживается
564Настройка сервера
синтаксис спецпоследовательностей (E’…’). Этот синтаксис (Подраздел 4.1.2.2) следует ис-
пользовать, если приложению нужно, чтобы обратная косая воспринималась как спецсимвол.
synchronize_seqscans (boolean)
Этот параметр включает синхронизацию обращений при последовательном сканировании
больших таблиц, чтобы эти операции читали один блок примерно в одно и то же время, и, таким
образом, нагрузка разделялась между ними. Когда он включён, сканирование может начаться
в середине таблицы, чтобы синхронизироваться со сканированием, которое уже выполняется.
По достижении конца таблицы сканирование «заворачивается» к началу и завершает обработ-
ку пропущенных строк. Это может привести к непредсказуемому изменению порядка строк,
возвращаемых запросами, в которых отсутствует предложение ORDER BY. Когда этот параметр
выключен (имеет значение off), реализуется поведение, принятое до версии 8.3, когда после-
довательное сканирование всегда начиналось с начала таблицы. Значение по умолчанию — on.
19.13.2. Совместимость с разными платформами и клиентами
transform_null_equals (boolean)
Когда этот параметр включён, проверки вида выражение = NULL (или NULL = выражение) воспри-
нимаются как выражение IS NULL, то есть они истинны, если выражение даёт значение NULL, и
ложны в противном случае. Согласно спецификации SQL, сравнение выражение = NULL долж-
но всегда возвращать NULL (неизвестное значение). Поэтому по умолчанию этот параметр вы-
ключен (равен off).
Однако формы фильтров в Microsoft Access генерируют запросы, в которых проверка на значе-
ние NULL записывается как выражение = NULL, так что если вы используете этот интерфейс
для обращения к базе данных, имеет смысл включить данный параметр. Так как проверки вида
выражение = NULL всегда возвращают значение NULL (следуя правилам стандарта SQL), они
не очень полезны и не должны встречаться в обычных приложениях, так что на практике от
включения этого параметра не будет большого вреда. Однако начинающие пользователи часто
путаются в семантике выражений со значениями NULL, поэтому по умолчанию этот параметр
выключен.
Заметьте, что этот параметр влияет только на точную форму сравнения = NULL, но не на другие
операторы сравнения или выражения, результат которых может быть равнозначен сравнению
с применением оператора равенства (например, конструкцию IN). Поэтому данный параметр
не может быть универсальной защитой от плохих приёмов программирования.
За сопутствующей информацией обратитесь к Разделу 9.2.
19.14. Обработка ошибок
exit_on_error (boolean)
Если этот параметр включён, любая ошибка приведёт к прерыванию текущего сеанса. По умол-
чанию он отключён, так что сеанс будет прерываться только при критических ошибках.
restart_after_crash (boolean)
Когда этот параметр включён (это состояние по умолчанию), PostgreSQL будет автоматически
перезагружаться после сбоя серверного процесса. Такой вариант позволяет обеспечить макси-
мальную степень доступности базы данных. Однако в некоторых обстоятельствах, например,
когда PostgreSQL управляется кластерным ПО, такую перезагрузку лучше отключить, чтобы
кластерное ПО могло вмешаться и выполнить, возможно, более подходящие действия.
19.15. Предопределённые параметры
Следующие «параметры» доступны только для чтения, их значения задаются при компиляции или
при установке PostgreSQL. По этой причине они исключены из примера файла postgresql.conf.
Эти параметры сообщают различные аспекты поведения PostgreSQL, которые могут быть интерес-
ны для определённых приложений, например, средств администрирования.
565Настройка сервера
block_size (integer)
Сообщает размер блока на диске. Он определяется значением BLCKSZ при сборке сервера. Зна-
чение по умолчанию — 8192 байта. Значение block_size влияет на некоторые другие перемен-
ные конфигурации (например, shared_buffers). Об этом говорится в Разделе 19.4.
data_checksums (boolean)
Сообщает, включён ли в этом кластере контроль целостности данных. За дополнительными
сведениями обратитесь к data checksums.
data_directory_mode (integer)
В Unix-системах этот параметр показывает разрешения для каталога данных (data_directory),
определённые при запуске. (В Microsoft Windows этот параметр всегда показывает 0700). За
дополнительными сведениями обратитесь к group access.
debug_assertions (boolean)
Сообщает, был ли PostgreSQL собран с проверочными утверждениями. Это имеет место, ко-
гда при сборке PostgreSQL определён макрос USE_ASSERT_CHECKING (для этого нужно передать
configure флаг –enable-cassert). По умолчанию PostgreSQL собирается без проверочных
утверждений.
integer_datetimes (boolean)
Сообщает, был ли PostgreSQL собран с поддержкой даты и времени в 64-битных целых. Начиная
с PostgreSQL версии 10, он всегда равен on.
lc_collate (string)
Сообщает локаль, по правилам которой выполняется сортировка текстовых данных. За допол-
нительными сведениями обратитесь к Разделу 23.1. Это значение определяется при создании
базы данных.
lc_ctype (string)
Сообщает локаль, определяющую классификацию символов. За дополнительными сведениями
обратитесь к Разделу 23.1. Это значение определяется при создании базы данных. Обычно оно
не отличается от lc_collate, но для некоторых приложений оно может быть определено по-
другому.
max_function_args (integer)
Сообщает верхний предел для числа аргументов функции. Он определяется константой
FUNC_MAX_ARGS при сборке сервера. По умолчанию установлен предел в 100 аргументов.
max_identifier_length (integer)
Сообщает максимальную длину идентификатора. Она определяется числом на 1 меньше, чем
NAMEDATALEN, при сборке сервера. По умолчанию константа NAMEDATALEN равна 64; следователь-
но max_identifier_length по умолчанию равна 63 байтам, но число символов в многобайтной
кодировке будет меньше.
max_index_keys (integer)
Сообщает верхний предел для числа ключей индекса. Он определяется константой
INDEX_MAX_KEYS при сборке сервера. По умолчанию установлен предел в 32 ключа.
segment_size (integer)
Сообщает, сколько блоков (страниц) можно сохранить в одном файловом сегменте. Это число
определяется константой RELSEG_SIZE при сборке сервера. Максимальный размер сегмента в
файлах равен произведению segment_size и block_size; по умолчанию это 1 гигабайт.
566Настройка сервера
server_encoding (string)
Сообщает кодировку базы данных (набор символов). Она определяется при создании базы дан-
ных. Обычно клиентов должно интересовать только значение client_encoding.
server_version (string)
Сообщает номер версии сервера. Она определяется константой PG_VERSION при сборке сервера.
server_version_num (integer)
Сообщает номер версии сервера в виде целого числа. Она определяется константой
PG_VERSION_NUM при сборке сервера.
wal_block_size (integer)
Сообщает размер блока WAL на диске. Он определяется константой XLOG_BLCKSZ при сборке
сервера. Значение по умолчанию — 8192 байта.
wal_segment_size (integer)
Сообщает число блоков (страниц) в файле сегмента WAL. Общий размер файла сегмента WAL
равняется произведению wal_segment_size и wal_block_size; по умолчанию это 16 мегабайт.
За дополнительными сведениями обратитесь к Разделу 30.4.
19.16. Внесистемные параметры
Поддержка внесистемных параметров была реализована, чтобы дополнительные модули (на-
пример, процедурные языки) могли добавлять собственные параметры, неизвестные серверу
PostgreSQL. Это позволяет единообразно настраивать модули расширения.
Имена параметров расширений записываются следующим образом: имя расширения, точка
и затем собственно имя параметра, подобно полным именам объектов в SQL. Например:
plpgsql.variable_conflict.
Так как внесистемные параметры могут быть установлены в процессах, не загружающих соответ-
ствующий модуль расширения, PostgreSQL принимает значения для любых имён с двумя компо-
нентами. Такие параметры воспринимаются как заготовки и не действуют до тех пор, пока не
будет загружен определяющий их модуль. Когда модуль расширения загружается, он добавляет
свои определения параметров и присваивает все заготовленные значения этим параметрам, либо
выдаёт предупреждение, если начинающееся с имени данного расширения имя заготовленного
параметра оказывается нераспознанным.
19.17. Параметры для разработчиков
Следующие параметры предназначены для работы над исходным кодом PostgreSQL, а в некоторых
случаях они могут помочь восстановить сильно повреждённые базы данных. Для использования
их в производственной среде не должно быть причин, поэтому они исключены из примера файла
postgresql.conf. Заметьте, что для работы с многими из этих параметров требуются специальные
флаги компиляции.
allow_system_table_mods (boolean)
Разрешает модификацию структуры системных таблиц. Этот параметр используется командой
initdb. Задать этот параметр можно только при запуске сервера.
ignore_system_indexes (boolean)
Отключает использование индексов при чтении системных таблиц (при этом индексы всё же
будут изменяться при записи в эти таблицы). Это полезно для восстановления работоспособ-
ности при повреждённых системных индексах. Этот параметр нельзя изменить после запуска
сеанса.
567Настройка сервера
post_auth_delay (integer)
При ненулевом значении этот параметр задаёт задержку (в секундах) при запуске нового сер-
верного процесса после выполнения процедуры аутентификации. Он предназначен для того,
чтобы разработчики имели возможность подключить отладчик к серверному процессу. Этот
параметр нельзя изменить после начала сеанса.
pre_auth_delay (integer)
При ненулевом значении этот параметр задаёт задержку (в секундах), добавляемую сразу по-
сле порождения нового серверного процесса, до выполнения процедуры аутентификации. Он
предназначен для того, чтобы разработчики имели возможность подключить отладчик к сер-
верному процессу при решении проблем с аутентификацией. Задать этот параметр можно толь-
ко в postgresql.conf или в командной строке при запуске сервера.
trace_notify (boolean)
Включает вывод очень подробной отладочной информации при выполнении команд LISTEN
и NOTIFY. Чтобы эти сообщения передавались клиенту или в журнал сервера, параметр
client_min_messages или log_min_messages, соответственно, должен иметь значение DEBUG1 или
ниже.
trace_recovery_messages (enum)
Включает вывод в журнал отладочных сообщений, связанных с восстановлением, которые ина-
че не выводятся. Этот параметр позволяет пользователю переопределить обычное значение
log_min_messages, но только для специфических сообщений. Он предназначен для отладки ре-
жима горячего резерва. Допустимые значения: DEBUG5, DEBUG4, DEBUG3, DEBUG2, DEBUG1 и LOG.
Значение по умолчанию, LOG, никак не влияет на запись этих сообщений в журнал. С другими
значениями отладочные сообщения, связанные с восстановлением, имеющие заданный прио-
ритет или выше, выводятся, как если бы они имели приоритет LOG; при стандартных значениях
log_min_messages это означает, что они будут фиксироваться в журнале сервера. Задать этот
параметр можно только в postgresql.conf или в командной строке при запуске сервера.
trace_sort (boolean)
Включает вывод информации об использовании ресурсов во время операций сортировки. Этот
параметр доступен, только если при сборке PostgreSQL был определён макрос TRACE_SORT. (По
умолчанию макрос TRACE_SORT определён.)
trace_locks (boolean)
Включает вывод подробной информации о блокировках. Она содержит вид операции блокиров-
ки, тип блокировки и уникальный идентификатор объекта, который блокируется или разбло-
кируется. Кроме того, в её составе выводятся битовые маски для типов блокировок, уже полу-
ченных для данного объекта, и для типов блокировок, ожидающих его освобождения. В допол-
нение к этому выводится количество полученных и ожидающих блокировок для каждого типа
блокировок, а также их общее количество. Ниже показан пример вывода в журнал:
LOG:
LOG:
LOG:
LOG:
LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)
grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
wait(0) type(AccessShareLock)
GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)
grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1
wait(0) type(AccessShareLock)
UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)
grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
wait(0) type(AccessShareLock)
CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)
grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
wait(0) type(INVALID)
Подробнее о структуре выводимой информации можно узнать в src/include/storage/lock.h.
568Настройка сервера
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
LOCK_DEBUG.
trace_lwlocks (boolean)
Включает вывод информации об использовании легковесных блокировок. Такие блокировки
предназначены в основном для взаимоисключающего доступа к общим структурам данных в
памяти.
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
LOCK_DEBUG.
trace_userlocks (boolean)
Включает вывод информации об использовании пользовательских блокировок. Она выводится
в том же формате, что и с trace_locks, но по рекомендательным блокировкам.
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
LOCK_DEBUG.
trace_lock_oidmin (integer)
Если этот параметр установлен, при трассировке блокировок не будут отслеживаться таблицы
с OID меньше заданного (это используется для исключения из трассировки системных таблиц).
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
LOCK_DEBUG.
trace_lock_table (integer)
Безусловно трассировать блокировки для таблицы с заданным OID.
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
LOCK_DEBUG.
debug_deadlocks (boolean)
Включает вывод информации обо всех текущих блокировках при тайм-ауте взаимоблокировки.
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
LOCK_DEBUG.
log_btree_build_stats (boolean)
Включает вывод статистики использования системных ресурсов (памяти и процессора) при раз-
личных операциях с B-деревом.
Этот параметр доступен, только если при компиляции PostgreSQL был определён макрос
BTREE_BUILD_STATS.
wal_consistency_checking (string)
Этот параметр предназначен для проверки ошибок в процедурах воспроизведения WAL. Ко-
гда он включён, в записи WAL добавляются полные образы страниц всех изменяемых буферов,
Когда запись впоследствии воспроизводится, система сначала применяет эту запись, а затем
проверяет, соответствуют ли буферы, изменённые записью, сохранённым образам. В опреде-
лённых случаях (например, во вспомогательных битах) небольшие изменения допускаются и
будут игнорироваться. Если выявляются неожиданные различия, это считается критической
ошибкой и восстановление прерывается.
По умолчанию значение этого параметра — пустая строка, так что эта функциональность от-
ключена. Его значением может быть all (будут проверяться все записи) или список имён мене-
джеров ресурсов через запятую (будут проверяться записи, выдаваемые этими менеджерами).
В настоящее время поддерживаются менеджеры heap, heap2, btree, hash, gin, gist, sequence,
spgist, brin и generic. Изменять этот параметр могут только суперпользователи.
569Настройка сервера
wal_debug (boolean)
Включает вывод отладочной информации, связанной с WAL. Этот параметр доступен, только
если при компиляции PostgreSQL был определён макрос WAL_DEBUG.
ignore_checksum_failure (boolean)
Этот параметр действует, только если включён data checksums.
При обнаружении ошибок контрольных сумм при чтении PostgreSQL обычно сообщает об ошиб-
ке и прерывает текущую транзакцию. Если параметр ignore_checksum_failure включён, си-
стема игнорирует проблему (но всё же предупреждает о ней) и продолжает обработку. Это по-
ведение может привести к краху, распространению или сокрытию повреждения данных и
другим серьёзными проблемам. Однако, включив его, вы можете обойти ошибку и получить
неповреждённые данные, которые могут находиться в таблице, если цел заголовок блока. Если
же повреждён заголовок, будет выдана ошибка, даже когда этот параметр включён. По умол-
чанию этот параметр отключён (имеет значение off) и изменить его состояние может только
суперпользователь.
zero_damaged_pages (boolean)
При выявлении повреждённого заголовка страницы PostgreSQL обычно сообщает об ошибке
и прерывает текущую транзакцию. Если параметр zero_damaged_pages включён, вместо этого
система выдаёт предупреждение, обнуляет повреждённую страницу в памяти и продолжает
обработку. Это поведение разрушает данные, а именно все строки в повреждённой странице.
Однако, включив его, вы можете обойти ошибку и получить строки из неповреждённых стра-
ниц, которые могут находиться в таблице. Это бывает полезно для восстановления данных, ис-
порченных в результате аппаратной или программной ошибки. Обычно включать его следует
только тогда, когда не осталось никакой другой надежды на восстановление данных в повре-
ждённых страницах таблицы. Обнулённые страницы не сохраняются на диск, поэтому прежде
чем выключать этот параметр, рекомендуется пересоздать проблемные таблицы или индексы.
По умолчанию этот параметр отключён (имеет значение off) и изменить его состояние может
только суперпользователь.
jit_debugging_support (boolean)
При наличии требуемой функциональности LLVM регистрировать генерируемые функции в
GDB. Это позволяет упростить отладку. Значение по умолчанию — off (выкл.). Изменить этот
параметр можно только при запуске сервера.
jit_dump_bitcode (boolean)
Записывать сгенерированный LLVM IR-код в файловую систему, в каталог data_directory. Это
полезно только для работы с внутренним механизмом JIT. Значение по умолчанию — off (вы-
кл.). Изменить этот параметр может только суперпользователь.
jit_expressions (boolean)
Определяет, будут ли JIT-компилироваться выражения, когда JIT-компиляция включена (см.
Раздел 32.2). Значение по умолчанию — on (вкл.).
jit_profiling_support (boolean)
При наличии требуемой функциональности LLVM выдавать данные, необходимые для профи-
лирования с помощью perf функций, которые генерирует JIT. Выходные файлы записываются
в каталог $HOME/.debug/jit/; удалять их при желании должен сам пользователь. Значение по
умолчанию — off (выкл.). Задать этот параметр можно только при запуске сервера.
jit_tuple_deforming (boolean)
Определяет, будет ли JIT-компилироваться преобразование кортежей, когда JIT-компиляция
включена (см. Раздел 32.2). Значение по умолчанию — on (вкл.).
570Настройка сервера
19.18. Краткие аргументы
Для удобства с некоторыми параметрами сопоставлены однобуквенные аргументы командной
строки. Все они описаны в Таблице 19.2. Некоторые из этих сопоставлений существуют по истори-
ческим причинам, так что наличие однобуквенного синонима не обязательно является признаком
того, что этот аргумент часто используется.
Таблица 19.2. Ключ краткого аргумента
Краткий аргумент Эквивалент
-B x shared_buffers =
-d x log_min_messages = DEBUG
-e datestyle = euro
-fb, -fh, -fi, -fm, -fn, -fo, -fs, -ft enable_bitmapscan = off , enable_hashjoin
= off, enable_indexscan = off , enable_
mergejoin = off , enable_nestloop = off ,
enable_indexonlyscan = off , enable_seqscan
= off, enable_tidscan = off
-F fsync = off
-h x listen_addresses =
-i listen_addresses = ‘*’
-k x unix_socket_directories =
-l ssl = on
-N x max_connections =
-O allow_system_table_mods = on
-p x port = x
-P ignore_system_indexes = on
-s log_statement_stats = on
-S x work_mem =
-tpa, -tpl, -te log_parser_stats = on , log_planner_stats
= on, log_executor_stats = on
-W x post_auth_delay =
571
x
x
x
x
x
x
x</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page19/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page18/">18</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page19/">19</a></li>
      
    
      
        <li><strong class="current-page">20</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page21/">21</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page22/">22</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page21/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>