<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 13. Управление конкурентным доступом &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 13. Управление конкурентным доступом">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 13. Управление конкурентным доступом">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-013/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-013/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 13. Управление конкурентным доступом">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-013/" rel="bookmark" title="Глава 13. Управление конкурентным доступом">Глава 13. Управление конкурентным доступом</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~34 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 13. Управление конкурентным доступом</p>

<p>В этой главе описывается поведение СУБД PostgreSQL в ситуациях, когда два или более сеансов
пытаются одновременно обратиться к одним и тем же данным. В таких ситуациях важно, чтобы
все сеансы могли эффективно работать с данными, и при этом сохранялась целостность данных.
Обсуждаемые в этой главе темы заслуживают внимания всех разработчиков баз данных.
13.1. Введение
PostgreSQL предоставляет разработчикам богатый набор средств для управления конкурент-
ным доступом к данным. Внутри он поддерживает целостность данных, реализуя модель MVCC
(Multiversion Concurrency Control, Многоверсионное управление конкурентным доступом). Это
означает, что каждый SQL-оператор видит снимок данных (версию базы данных) на определённый
момент времени, вне зависимости от текущего состояния данных. Это защищает операторы от
несогласованности данных, возможной, если другие конкурирующие транзакции внесут измене-
ния в те же строки данных, и обеспечивает тем самым изоляцию транзакций для каждого сеан-
са баз данных. MVCC, отходя от методик блокирования, принятых в традиционных СУБД, снижа-
ет уровень конфликтов блокировок и таким образом обеспечивает более высокую производитель-
ность в многопользовательской среде.
Основное преимущество использования модели MVCC по сравнению с блокированием заключа-
ется в том, что блокировки MVCC, полученные для чтения данных, не конфликтуют с блокиров-
ками, полученными для записи, и поэтому чтение никогда не мешает записи, а запись чтению.
PostgreSQL гарантирует это даже для самого строгого уровня изоляции транзакций, используя ин-
новационный уровень изоляции SSI (Serializable Snapshot Isolation, Сериализуемая изоляция сним-
ков).
Для приложений, которым в принципе не нужна полная изоляция транзакций и которые предпо-
читают явно определять точки конфликтов, в PostgreSQL также есть средства блокировки на уров-
не таблиц и строк. Однако при правильном использовании MVCC обычно обеспечивает лучшую
производительность, чем блокировки. Кроме этого, приложения могут использовать рекоменда-
тельные блокировки, не привязанные к какой-либо одной транзакции.
13.2. Изоляция транзакций
Стандарт SQL определяет четыре уровня изоляции транзакций. Наиболее строгий из них — сериа-
лизуемый, определяется одним абзацем, говорящем, что при параллельном выполнении несколь-
ко сериализуемых транзакций должны гарантированно выдавать такой же результат, как если бы
они запускались по очереди в некотором порядке. Остальные три уровня определяются через опи-
сания особых явлений, которые возможны при взаимодействии параллельных транзакций, но не
допускаются на определённом уровне. Как отмечается в стандарте, из определения сериализуе-
мого уровня вытекает, что на этом уровне ни одно из этих явлений не возможно. (В самом деле
— если эффект транзакций должен быть тем же, что и при их выполнении по очереди, как можно
было бы увидеть особые явления, связанные с другими транзакциями?)
Стандарт описывает следующие особые условия, недопустимые для различных уровней изоляции:
«грязное» чтение
Транзакция читает данные, записанные параллельной незавершённой транзакцией.
неповторяемое чтение
Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изме-
нены другой транзакцией (которая завершилась после первого чтения).
407Управление конку-
рентным доступом
фантомное чтение
Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия,
и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, за-
вершившейся за это время.
аномалия сериализации
Результат успешной фиксации группы транзакций оказывается несогласованным при всевоз-
можных вариантах исполнения этих транзакций по очереди.
Уровни изоляции транзакций, описанные в стандарте SQL и реализованные в PostgreSQL, описы-
ваются в Таблице 13.1.
Таблица 13.1. Уровни изоляции транзакций
Уровень
ции
изоля- «Грязное»
ние
Read uncommited Допускается,
(Чтение незафик- не в PG
сированных дан-
ных)
чте- Неповторяемое
чтение
Фантомное
ние
чте- Аномалия сериа-
лизации
но Возможно Возможно Возможно
Read committed ( Невозможно
Чтение зафикси-
рованных данных) Возможно Возможно Возможно
Repeatable read ( Невозможно
Повторяемое чте-
ние) Невозможно Допускается,
не в PG Serializable (Сери- Невозможно
ализуемость) Невозможно Невозможно
но Возможно
Невозможно
В PostgreSQL вы можете запросить любой из четырёх уровней изоляции транзакций, однако внут-
ри реализованы только три различных уровня, то есть режим Read Uncommitted в PostgreSQL дей-
ствует как Read Committed. Причина этого в том, что только так можно сопоставить стандартные
уровни изоляции с реализованной в PostgreSQL архитектурой многоверсионного управления кон-
курентным доступом.
В этой таблице также показано, что реализация Repeatable Read в PostgreSQL не допускает фан-
томное чтение. Стандарт SQL допускает возможность более строгого поведения: четыре уровня
изоляции определяют только, какие особые условия не должны наблюдаться, но не какие обяза-
тельно должны. Поведение имеющихся уровней изоляции подробно описывается в следующих
подразделах.
Для выбора нужного уровня изоляции транзакций используется команда SET TRANSACTION.
Важно
Поведение некоторых функций и типов данных PostgreSQL в транзакциях подчиняет-
ся особым правилам. В частности, изменения последовательностей (и следовательно,
счётчика в столбце, объявленному как serial) немедленно видны во всех остальных
транзакциях и не откатываются назад, если выполнившая их транзакция прерывается.
См. Раздел 9.16 и Подраздел 8.1.4.
13.2.1. Уровень изоляции Read Committed
Read Committed — уровень изоляции транзакции, выбираемый в PostgreSQL по умолчанию. В тран-
закции, работающей на этом уровне, запрос SELECT (без предложения FOR UPDATE/SHARE) видит
только те данные, которые были зафиксированы до начала запроса; он никогда не увидит неза-
фиксированных данных или изменений, внесённых в процессе выполнения запроса параллельны-
408Управление конку-
рентным доступом
ми транзакциями. По сути запрос SELECT видит снимок базы данных в момент начала выполнения
запроса. Однако SELECT видит результаты изменений, внесённых ранее в этой же транзакции, да-
же если они ещё не зафиксированы. Также заметьте, что два последовательных оператора SELECT
могут видеть разные данные даже в рамках одной транзакции, если какие-то другие транзакции
зафиксируют изменения после запуска первого SELECT, но до запуска второго.
Команды UPDATE, DELETE, SELECT FOR UPDATE и SELECT FOR SHARE ведут себя подобно SELECT при
поиске целевых строк: они найдут только те целевые строки, которые были зафиксированы на мо-
мент начала команды. Однако к моменту, когда они будут найдены, эти целевые строки могут быть
уже изменены (а также удалены или заблокированы) другой параллельной транзакцией. В этом
случае запланированное изменение будет отложено до фиксирования или отката первой изменя-
ющей данные транзакции (если она ещё выполняется). Если первая изменяющая транзакция от-
катывается, её результат отбрасывается и вторая изменяющая транзакция может продолжить из-
менение изначально полученной строки. Если первая транзакция зафиксировалась, но в резуль-
тате удалила эту строку, вторая будет игнорировать её, а в противном случае попытается выпол-
нить свою операцию с изменённой версией строки. Условие поиска в команде (предложение WHERE)
вычисляется повторно для выяснения, соответствует ли по-прежнему этому условию изменённая
версия строки. Если да, вторая изменяющая транзакция продолжают свою работу с изменённой
версией строки. Применительно к командам SELECT FOR UPDATE и SELECT FOR SHARE это означает,
что изменённая версия строки блокируется и возвращается клиенту.
Похожим образом ведёт себя INSERT с предложением ON CONFLICT DO UPDATE. В режиме Read
Committed каждая строка, предлагаемая для добавления, будет либо вставлена, либо изменена. Ес-
ли не возникнет несвязанных ошибок, гарантируется один из этих двух исходов. Если конфликт бу-
дет вызван другой транзакцией, результат которой ещё не видим для INSERT, предложение UPDATE
подействует на эту строку, даже несмотря на то, что эта команда обычным образом может не ви-
деть никакую версию этой строки.
При выполнении INSERT с предложением ON CONFLICT DO NOTHING строка может не добавиться в
результате действия другой транзакции, эффект которой не виден в снимке команды INSERT. Это
опять же имеет место только в режиме Read Committed.
Вследствие описанных выше правил, изменяющая команда может увидеть несогласованное состо-
яние: она может видеть результаты параллельных команд, изменяющих те же строки, что пытает-
ся изменить она, но при этом она не видит результаты этих команд в других строках таблиц. Из-за
этого поведения уровень Read Committed не подходит для команд со сложными условиями поиска;
однако он вполне пригоден для простых случаев. Например, рассмотрим изменение баланса счёта
в таких транзакциях:
BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
Если две такие транзакции пытаются параллельно изменить баланс счёта 12345, мы, естественно,
хотим, чтобы вторая транзакция работала с изменённой версией строки счёта. Так как каждая
команда влияет только на определённую строку, если она будет видеть изменённую версию строки,
это не приведёт к проблемам несогласованности.
В более сложных ситуациях уровень Read Committed может приводить к нежелательным резуль-
татам. Например, рассмотрим команду DELETE, работающую со строками, которые параллельно
добавляет и удаляет из множества, определённого её условием, другая команда. Например, пред-
положим, что website — таблица из двух строк, в которых website.hits равны 9 и 10:
BEGIN;
UPDATE website SET hits = hits + 1;
– выполняется параллельно: DELETE FROM website WHERE hits = 10;
COMMIT;
Команда DELETE не сделает ничего, даже несмотря на то, что строка с website.hits = 10 была в
таблице и до, и после выполнения UPDATE. Это происходит потому, что строка со значением 9 до
409Управление конку-
рентным доступом
изменения пропускается, а когда команда UPDATE завершается и DELETE получает освободившуюся
блокировку, строка с 10 теперь содержит 11, а это значение уже не соответствует условию.
Так как в режиме Read Committed каждая команда начинается с нового снимка состояния, кото-
рый включает результаты всех транзакций, зафиксированных к этому моменту, последующие ко-
манды в одной транзакции будут в любом случае видеть эффекты всех параллельных зафиксиро-
ванных транзакций. Вопрос здесь состоит в том, видит ли одна команда абсолютно согласованное
состояние базы данных.
Частичная изоляция транзакция, обеспечиваемая в режиме Read Committed, приемлема для мно-
жества приложений. Этот режим быстр и прост в использовании, однако он подходит не для всех
случаев. Приложениям, выполняющим сложные запросы и изменения, могут потребоваться более
строго согласованное представление данных, чем то, что даёт Read Committed.
13.2.2. Уровень изоляции Repeatable Read
В режиме Repeatable Read видны только те данные, которые были зафиксированы до начала тран-
закции, но не видны незафиксированные данные и изменения, произведённые другими транзак-
циями в процессе выполнения данной транзакции. (Однако запрос будет видеть эффекты предыду-
щих изменений в своей транзакции, несмотря на то, что они не зафиксированы.) Это самое стро-
гое требование, которое стандарт SQL вводит для этого уровня изоляции, и при его выполнении
предотвращаются все явления, описанные в Таблице 13.1, за исключением аномалий сериализа-
ции. Как было сказано выше, это не противоречит стандарту, так как он определяет только мини-
мальную защиту, которая должна обеспечиваться на каждом уровне изоляции.
Этот уровень отличается от Read Committed тем, что запрос в транзакции данного уровня видит
снимок данных на момент начала первого оператора в транзакции (не считая команд управле-
ния транзакциями), а не начала текущего оператора. Таким образом, последовательные команды
SELECT в одной транзакции видят одни и те же данные; они не видят изменений, внесённых и за-
фиксированных другими транзакциями после начала их текущей транзакции.
Приложения, использующие этот уровень, должны быть готовы повторить транзакции в случае
сбоев сериализации.
Команды UPDATE, DELETE, SELECT FOR UPDATE и SELECT FOR SHARE ведут себя подобно SELECT при
поиске целевых строк: они найдут только те целевые строки, которые были зафиксированы на мо-
мент начала транзакции. Однако к моменту, когда они будут найдены, эти целевые строки могут
быть уже изменены (а также удалены или заблокированы) другой параллельной транзакцией. В
этом случае транзакция в режиме Repeatable Read будет ожидать фиксирования или отката первой
изменяющей данные транзакции (если она ещё выполняется). Если первая изменяющая транзак-
ция откатывается, её результат отбрасывается и текущая транзакция может продолжить измене-
ние изначально полученной строки. Если же первая транзакция зафиксировалась и в результате
изменила или удалила эту строку, а не просто заблокировала её, произойдёт откат текущей тран-
закции с сообщением
ОШИБКА: не удалось сериализовать доступ из-за параллельного изменения
так как транзакция уровня Repeatable Read не может изменять или блокировать строки, изменён-
ные другими транзакциями с момента её начала.
Когда приложение получает это сообщение об ошибке, оно должна прервать текущую транзакцию
и попытаться повторить её с самого начала. Во второй раз транзакция увидит внесённое до этого
изменение как часть начального снимка базы данных, так что новая версия строки вполне может
использоваться в качестве отправной точки для изменения в повторной транзакции.
Заметьте, что потребность в повторении транзакции может возникнуть, только если эта транзак-
ция изменяет данные; в транзакциях, которые только читают данные, конфликтов сериализации
не бывает.
Режим Repeatable Read строго гарантирует, что каждая транзакция видит полностью стабильное
представление базы данных. Однако это представление не обязательно будет согласовано с неко-
410Управление конку-
рентным доступом
торым последовательным выполнением транзакций одного уровня. Например, даже транзакция,
которая только читает данные, в этом режиме может видеть строку, показывающую, что некото-
рое задание завершено, но не видеть одну из строк логических частей задания, так как эта тран-
закция может прочитать более раннюю версию строки задания, чем ту, для которой параллельно
добавлялась очередная логическая часть. Строго исполнить бизнес-правила в транзакциях, рабо-
тающих на этом уровне изоляции, скорее всего не удастся без явных блокировок конфликтующих
транзакций.
Примечание
До версии 9.1 в PostgreSQL при запросе режима Serializable поведение системы в точ-
ности соответствовало вышеописанному. Таким образом, чтобы сейчас получить ста-
рое поведение Serializable, нужно запрашивать режим Repeatable Read.
13.2.3. Уровень изоляции Serializable
Уровень Serializable обеспечивает самую строгую изоляцию транзакций. На этом уровне модели-
руется последовательное выполнение всех зафиксированных транзакций, как если бы транзак-
ции выполнялись одна за другой, последовательно, а не параллельно. Однако, как и на уровне
Repeatable Read, на этом уровне приложения должны быть готовы повторять транзакции из-за сбо-
ев сериализации. Фактически этот режим изоляции работает так же, как и Repeatable Read, только
он дополнительно отслеживает условия, при которых результат параллельно выполняемых сери-
ализуемых транзакций может не согласовываться с результатом этих же транзакций, выполняе-
мых по очереди. Это отслеживание не привносит дополнительных препятствий для выполнения,
кроме тех, что присущи режиму Repeatable Read, но тем не менее создаёт некоторую добавочную
нагрузку, а при выявлении исключительных условий регистрируется аномалия сериализации и
происходит сбой сериализации.
Например, рассмотрим таблицу mytab, изначально содержащую:
class | value
——-+——-
1 |
10
1 |
20
2 |
100
2 |
200
Предположим, что сериализуемая транзакция A вычисляет:
SELECT SUM(value) FROM mytab WHERE class = 1;
а затем вставляет результат (30) в поле value в новую строку со значением class = 2. В это же
время сериализуемая транзакция B вычисляет:
SELECT SUM(value) FROM mytab WHERE class = 2;
получает результат 300 и вставляет его в новую строку со значением class = 1. Затем обе транзак-
ции пытаются зафиксироваться. Если бы одна из этих транзакций работала в режиме Repeatable
Read, зафиксироваться могли бы обе; но так как полученный результат не соответствовал бы по-
следовательному порядку, в режиме Serializable будет зафиксирована только одна транзакция, а
вторая закончится откатом с сообщением:
ОШИБКА: не удалось сериализовать доступ из-за зависимостей чтения/записи между
транзакциями
Это объясняется тем, что при выполнении A перед B транзакция B вычислила бы сумму 330, а не
300, а при выполнении в обратном порядке A вычислила бы другую сумму.
Рассчитывая, что сериализуемые транзакции предотвратят аномалии, важно понимать, что любые
данные, полученные из постоянной таблицы пользователя, не должны считаться действительны-
ми, пока транзакция, прочитавшая их, не будет успешно зафиксирована. Это верно даже для тран-
закций, не модифицирующих данные, за исключением случая, когда данные считываются в от-
411Управление конку-
рентным доступом
кладываемой транзакции такого типа. В этом случае данные могут считаться действительными,
так как такая транзакция ждёт, пока не сможет получить снимок, гарантированно предотвраща-
ющий подобные проблемы. Во всех остальных случаях приложения не должны полагаться на ре-
зультаты чтения данных в транзакции, которая не была зафиксирована; в случае ошибки и отката
приложения должны повторять транзакцию, пока она не будет завершена успешно.
Для полной гарантии сериализуемости в PostgreSQL применяются предикатные блокировки, то
есть блокировки, позволяющие определить, когда запись могла бы повлиять на результат преды-
дущего чтения параллельной транзакции, если бы эта запись выполнялась сначала. В PostgreSQL
эти блокировки не приводят к фактическим блокировкам данным и следовательно никоим обра-
зом не могут повлечь взаимоблокировки транзакций. Они помогают выявить и отметить зависимо-
сти между параллельными транзакциями уровня Serializable, которые в определённых сочетани-
ях могут приводить к аномалиям сериализации. Транзакции Read Committed или Repeatable Read
для обеспечения целостности данных, напротив, должны либо блокировать таблицы целиком, что
помешает пользователям обращаться к этим таблицам, либо применять SELECT FOR UPDATE или
SELECT FOR SHARE, что не только заблокирует другие транзакции, но и создаст дополнительную
нагрузку на диск.
Предикатные блокировки в PostgreSQL, как и в большинстве других СУБД, устанавливаются для
данных, фактически используемых в транзакции. Они отображаются в системном представлении
pg_locks со значением mode равным SIReadLock. Какие именно блокировки будут затребованы при
выполнении запроса, зависит от плана запроса, при этом детализированные блокировки (напри-
мер, блокировки строк) могут объединяться в более общие (например, в блокировки страниц) в
процессе транзакции для экономии памяти, расходуемой для отслеживания блокировок. Транзак-
ция READ ONLY может даже освободить свои блокировки SIRead до завершения, если обнаружива-
ется, что конфликты, которые могли бы привести к аномалии сериализации, исключены. На самом
деле для транзакций READ ONLY этот факт чаще всего устанавливается в самом начале, так что
они обходятся без предикатных блокировок. Если же вы явно запросите транзакцию SERIALIZABLE
READ ONLY DEFERRABLE, она будет заблокирована до тех пор, пока не сможет установить этот
факт. (Это единственный случай, когда транзакции уровня Serializable блокируются, а транзакции
Repeatable Read — нет.) С другой стороны, блокировки SIRead часто должны сохраняться и после
фиксирования транзакции, пока не будут завершены другие, наложившиеся на неё транзакции.
При правильном использовании сериализуемые транзакции могут значительно упростить разра-
ботку приложений. Гарантия того, что любое сочетание успешно зафиксированных параллельных
сериализуемых транзакций даст тот же результат, что и последовательность этих транзакций, вы-
полненных по очереди, означает, что если вы уверены, что единственная транзакция определён-
ного содержания работает правильно, когда она запускается отдельно, вы можете быть уверены,
что она будет работать так же правильно в любом сочетании сериализуемых транзакций, вне за-
висимости от того, что они делают, либо же она не будет зафиксирована успешно. При этом важно,
чтобы в среде, где применяется этот подход, была реализована общая обработка сбоев сериализа-
ции (которые можно определить по значению SQLSTATE ‘40001’), так как заведомо определить,
какие именно транзакции могут стать жертвами зависимостей чтения/записи и не будут зафик-
сированы для предотвращения аномалий сериализации, обычно очень сложно. Отслеживание за-
висимостей чтения-записи неизбежно создаёт дополнительную нагрузку, как и перезапуск тран-
закций, не зафиксированных из-за сбоев сериализации, но если на другую чашу весов положить
нагрузку и блокирование, связанные с применением явных блокировок и SELECT FOR UPDATE или
SELECT FOR SHARE, использовать сериализуемые транзакции в ряде случаев окажется выгоднее.
Тогда как уровень изоляции транзакций Serializable в PostgreSQL позволяет фиксировать парал-
лельные транзакции, только если есть уверенность, что тот же результат будет получен при по-
следовательном их выполнении, он не всегда предотвращает ошибки, которые не возникли бы при
действительно последовательном выполнении. В частности, можно столкнуться с нарушениями
ограничений уникальности, вызванными наложением сериализуемых транзакций, даже после яв-
ной проверки отсутствия ключа перед добавлением его. Этого можно избежать, если все сериа-
лизуемые транзакции, добавляющие потенциально конфликтующие ключи, будут предварительно
явно проверять, можно ли вставить ключ. Например, приложение, добавляющее новый ключ, мо-
жет запрашивать его у пользователя и затем проверять, существует ли он, сначала пытаясь найти
его, либо генерировать новый ключ, выбирая максимальное существующее значение и увеличивая
412Управление конку-
рентным доступом
его на один. Если некоторые сериализуемые транзакции добавляют новые ключи сразу, не следуя
этому протоколу, возможны нарушения ограничений уникальности, даже когда они не наблюда-
лись бы при последовательном выполнении этих транзакций.
Применяя сериализуемые транзакции для управления конкурентным доступом, примите к сведе-
нию следующие рекомендации:
• Объявляйте транзакции как READ ONLY, если это отражает их суть.
• Управляйте числом активных подключений, при необходимости используя пул соединений.
Это всегда полезно для увеличения производительности, но особенно важно это в загружен-
ной системе с сериализуемыми транзакциями.
• Заключайте в одну транзакцию не больше команд, чем необходимо для обеспечения целост-
ности.
• Не оставляйте соединения «простаивающими в транзакции» дольше, чем необходимо. Для ав-
томатического отключения затянувшихся транзакций можно применить параметр конфигура-
ции idle_in_transaction_session_timeout.
• Исключите явные блокировки, SELECT FOR UPDATE и SELECT FOR SHARE там, где они не нужны
благодаря защите, автоматически предоставляемой сериализуемыми транзакциями.
• Когда система вынуждена объединять предикатные блокировки уровня страницы в одну пре-
дикатную блокировку уровня таблицы из-за нехватки памяти, может возрасти частота сбо-
ев сериализации. Избежать этого можно, увеличив параметр max_pred_locks_per_transaction,
max_pred_locks_per_relation и/или max_pred_locks_per_page.
• Последовательное сканирование всегда влечёт за собой предикатную блокировку на уровне
таблицы. Это приводит к увеличению сбоев сериализации. В таких ситуациях бывает полезно
склонить систему к использованию индексов, уменьшая random_page_cost и/или увеличивая
cpu_tuple_cost. Однако тут важно сопоставить выигрыш от уменьшения числа откатов и пере-
запусков транзакций с проигрышем от возможного менее эффективного выполнения запро-
сов.
13.3. Явные блокировки
Для управления параллельным доступом к данным в таблицах PostgreSQL предоставляет несколь-
ко режимов явных блокировок. Эти режимы могут применяться для блокировки данных со стороны
приложения в ситуациях, когда MVCC не даёт желаемый результат. Кроме того, большинство ко-
манд PostgreSQL автоматически получают блокировки соответствующих режимов, защищающие
от удаления или изменения задействованных таблиц, несовместимого с характером выполняемой
команды. (Например, TRUNCATE не может безопасно выполняться одновременно с другими опера-
циями с этой таблицей, так что во избежание конфликта эта команда получает исключительную
блокировку для данной таблицы.)
Список текущих активных блокировок на сервере можно получить, прочитав системное представ-
ление pg_locks. За дополнительными сведениями о наблюдении за состоянием менеджера блоки-
ровок обратитесь к Главе 28.
13.3.1. Блокировки на уровне таблицы
В приведённом ниже списке перечислены имеющиеся режимы блокировок и контексты, где их ав-
томатически применяет PostgreSQL. Вы можете также явно запросить любую из этих блокировок
с помощью команды LOCK. Помните, что все эти режимы работают на уровне таблицы, даже если
имя режима содержит слово «row»; такие имена сложились исторически. В некоторой степени эти
имена отражают типичное применение каждого режима блокировки, но смысл у всех один. Един-
ственное, что действительно отличает один режим блокировки от другого, это набор режимов, с
которыми конфликтует каждый из них (см. Таблицу 13.2). Две транзакции не могут одновременно
владеть блокировками конфликтующих режимов для одной и той же таблицы. (Однако учтите, что
транзакция никогда не конфликтует с собой. Например, она может запросить блокировку ACCESS
EXCLUSIVE, а затем ACCESS SHARE для той же таблицы.) При этом разные транзакции свободно могут
одновременно владеть блокировками неконфликтующих режимов. Заметьте, что некоторые режи-
413Управление конку-
рентным доступом
мы блокировки конфликтуют сами с собой (например, блокировкой ACCESS EXCLUSIVE в один мо-
мент времени может владеть только одна транзакция), а некоторые — нет (например, блокировку
ACCESS SHARE могут получить сразу несколько транзакций).
Режимы блокировок на уровне таблицы
ACCESS SHARE
Конфликтует только с режимом блокировки ACCESS EXCLUSIVE.
Команда SELECT получает такую блокировку для таблиц, на которые она ссылается. Вообще
говоря, блокировку в этом режиме получает любой запрос, который только читает таблицу,
но не меняет её данные.
ROW SHARE
Конфликтует с режимами блокировки EXCLUSIVE и ACCESS EXCLUSIVE.
Команды SELECT FOR UPDATE и SELECT FOR SHARE получают такую блокировку для своих целе-
вых таблиц (помимо блокировок ACCESS SHARE для любых таблиц, которые используется в этих
запросов, но не в предложении FOR UPDATE/FOR SHARE).
ROW EXCLUSIVE
Конфликтует с режимами блокировки SHARE, SHARE
EXCLUSIVE.
ROW
EXCLUSIVE, EXCLUSIVE и ACCESS
Команды UPDATE, DELETE и INSERT получают такую блокировку для целевой таблицы (в допол-
нение к блокировкам ACCESS SHARE для всех других задействованных таблиц). Вообще говоря,
блокировку в этом режиме получает любая команда, которая изменяет данные в таблице.
SHARE UPDATE EXCLUSIVE
Конфликтует с режимами блокировки SHARE UPDATE EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE,
EXCLUSIVE и ACCESS EXCLUSIVE. Этот режим защищает таблицу от параллельного изменения
схемы и запуска процесса VACUUM.
Запрашивается командами VACUUM (без FULL), ANALYZE, CREATE INDEX CONCURRENTLY, CREATE
STATISTICS, ALTER TABLE VALIDATE и другими видами ALTER TABLE (за подробностями обрати-
тесь к ALTER TABLE).
SHARE
Конфликтует с режимами блокировки ROW EXCLUSIVE, SHARE UPDATE EXCLUSIVE, SHARE ROW
EXCLUSIVE, EXCLUSIVE и ACCESS EXCLUSIVE. Этот режим защищает таблицу от параллельного
изменения данных.
Запрашивается командой CREATE INDEX (без параметра CONCURRENTLY).
SHARE ROW EXCLUSIVE
Конфликтует с режимами блокировки ROW EXCLUSIVE, SHARE UPDATE EXCLUSIVE, SHARE, SHARE
ROW EXCLUSIVE, EXCLUSIVE и ACCESS EXCLUSIVE. Этот режим защищает таблицу от параллельных
изменений данных и при этом он является самоисключающим, так что такую блокировку может
получить только один сеанс.
Запрашивается командой CREATE COLLATION, CREATE TRIGGER и многими формами ALTER TABLE
(см. ALTER TABLE).
EXCLUSIVE
Конфликтует с режимами блокировки ROW SHARE, ROW EXCLUSIVE, SHARE UPDATE EXCLUSIVE,
SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE и ACCESS EXCLUSIVE. Этот режим совместим только с
блокировкой ACCESS SHARE, то есть параллельно с транзакцией, получившей блокировку в этом
режиме, допускается только чтение таблицы.
414Управление конку-
рентным доступом
Запрашивается командой REFRESH MATERIALIZED VIEW CONCURRENTLY.
ACCESS EXCLUSIVE
Конфликтует со всеми режимами блокировки (ACCESS SHARE, ROW SHARE, ROW EXCLUSIVE, SHARE
UPDATE EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE и ACCESS EXCLUSIVE). Этот режим
гарантирует, что кроме транзакции, получившей эту блокировку, никакая другая транзакция
не может обращаться к таблице каким-либо способом.
Запрашивается командами DROP TABLE, TRUNCATE, REINDEX, CLUSTER, VACUUM FULL и REFRESH
MATERIALIZED VIEW (без CONCURRENTLY). Блокировку на этом уровне запрашивают также многие
виды ALTER TABLE. В этом режиме по умолчанию запрашивают блокировку и операторы LOCK
TABLE, если явно не выбран другой режим.
Подсказка
Только блокировка ACCESS EXCLUSIVE блокирует оператор SELECT (без FOR UPDATE/
SHARE).
Полученная транзакцией блокировка обычно сохраняется до конца транзакции. Но если блокиров-
ка получена после установки точки сохранения, она освобождается немедленно в случае отката
к этой точке. Это согласуется с принципом действия ROLLBACK — эта команда отменяет эффекты
всех команд после точки сохранения. То же справедливо и для блокировок, полученных в блоке
исключений PL/pgSQL: при выходе из блока с ошибкой такие блокировки освобождаются.
Таблица 13.2. Конфликтующие режимы блокировки
Запраши Текущий режим блокировки
ваемый ACCESS ROW
ROW
SHARE
SHARE
режим
SHARE
SHARE
EXCLUSIVE
UPDATE
блоки
EXCLUSIVE
ровки
SHARE
EXCLU
ROW
SIVE
EXCLUSIVE
ACCESS
EXCLUSIVE
ACCESS
SHARE               X
ROW
SHARE             X X
ROW
EXCLUSIVE         X X X X
SHARE
UPDATE
EXCLUSIVE       X X X X X
SHARE     X X   X X X
SHARE
ROW
EXCLUSIVE     X X X X X X
EXCLU
SIVE   X X X X X X X
ACCESS
EXCLUSIVE X X X X X X X X
13.3.2. Блокировки на уровне строк
В дополнение к блокировкам на уровне таблицы, существуют блокировки на уровне строк, пере-
численные ниже с контекстами, где PostgreSQL применяет их по умолчанию. Полный перечень
конфликтов блокировок на уровне строк приведён в Таблице 13.3. Заметьте, что одна транзакция
415Управление конку-
рентным доступом
может владеть несколькими конфликтующими блокировками одной строки, даже в разных под-
транзакциях; но две разных транзакции никогда не получат конфликтующие блокировки одной и
той же строки. Блокировки на уровне строк блокируют только запись в определённые строки, но
никак не влияют на выборку.
Режимы блокировки на уровне строк
FOR UPDATE
В режиме FOR UPDATE строки, выданные оператором SELECT, блокируются как для изменения.
При этом они защищаются от блокировки, изменения и удаления другими транзакциями до за-
вершения текущей. То есть другие транзакции, пытающиеся выполнить UPDATE, DELETE, SELECT
FOR UPDATE, SELECT FOR NO KEY UPDATE, SELECT FOR SHARE или SELECT FOR KEY SHARE с эти-
ми строками, будут заблокированы до завершения текущей транзакции; и наоборот, команда
SELECT FOR UPDATE будет ожидать окончания параллельной транзакции, в которой выполни-
лась одна из этих команд с той же строкой, а затем установит блокировку и вернёт изменён-
ную строку (или не вернёт, если она была удалена). Однако в транзакции REPEATABLE READ или
SERIALIZABLE возникнет ошибка, если блокируемая строка изменилась с момента начала тран-
закции. Подробнее это обсуждается в Разделе 13.4.
Режим блокировки FOR UPDATE также запрашивается на уровне строки любой командой DELETE
и командой UPDATE, изменяющей значения определённых столбцов. В настоящее время блоки-
ровка с UPDATE касается столбцов, по которым создан уникальный индекс, применимый в каче-
стве внешнего ключа (так что на частичные индексы и индексы выражений это не распростра-
няется), но в будущем это может поменяться.
FOR NO KEY UPDATE
Действует подобно FOR UPDATE, но запрашиваемая в этом режиме блокировка слабее: она не
будет блокировать команды SELECT FOR KEY SHARE, пытающиеся получить блокировку тех же
строк. Этот режим блокировки также запрашивается любой командой UPDATE, которая не тре-
бует блокировки FOR UPDATE.
FOR SHARE
Действует подобно FOR NO KEY UPDATE, за исключением того, что для каждой из полученных
строк запрашивается разделяемая, а не исключительная блокировка. Разделяемая блокировка
не позволяет другим транзакциям выполнять с этими строками UPDATE, DELETE, SELECT FOR
UPDATE или SELECT FOR NO KEY UPDATE, но допускает SELECT FOR SHARE и SELECT FOR KEY SHARE.
FOR KEY SHARE
Действует подобно FOR SHARE, но устанавливает более слабую блокировку: блокируется SELECT
FOR UPDATE, но не SELECT FOR NO KEY UPDATE. Блокировка разделяемого ключа не позволяет
другим транзакциям выполнять команды DELETE и UPDATE, только если они меняют значение
ключа (но не другие UPDATE), и при этом допускает выполнение команд SELECT FOR NO KEY
UPDATE, SELECT FOR SHARE и SELECT FOR KEY SHARE.
PostgreSQL не держит информацию об изменённых строках в памяти, так что никаких ограниче-
ний на число блокируемых строк нет. Однако блокировка строки может повлечь запись на диск,
например, если SELECT FOR UPDATE изменяет выбранные строки, чтобы заблокировать их, при этом
происходит запись на диск.
Таблица 13.3. Конфликтующие блокировки на уровне строк
Запрашиваемый Текущий режим блокировки
режим
блоки FOR KEY SHARE FOR SHARE
ровки
FOR
NO
UPDATE
KEY FOR UPDATE
FOR KEY SHARE       X
FOR SHARE     X X
416Управление конку-
рентным доступом
Запрашиваемый Текущий режим блокировки
режим
блоки FOR KEY SHARE FOR SHARE
ровки
FOR
NO
UPDATE
FOR UPDATE
KEY
FOR
NO
UPDATE
KEY FOR UPDATE
  X X X
X X X X
13.3.3. Блокировки на уровне страниц
В дополнение к блокировкам на уровне таблицы и строк, для управления доступом к страницам
таблиц в общих буферах используются блокировки на уровне страниц, исключительные и разде-
ляемые. Эти блокировки освобождаются немедленно после выборки или изменения строк. Разра-
ботчикам приложений обычно можно не задумываться о блокировках страниц, здесь они упоми-
наются только для полноты картины.
13.3.4. Взаимоблокировки
Частое применение явных блокировок может увеличить вероятность взаимоблокировок, то есть
ситуаций, когда две (или более) транзакций держат блокировки так, что взаимно блокируют друг
друга. Например, если транзакция 1 получает исключительную блокировку таблицы A, а затем пы-
тается получить исключительную блокировку таблицы B, которую до этого получила транзакция
2, в данный момент требующая исключительную блокировку таблицы A, ни одна из транзакций
не сможет продолжить работу. PostgreSQL автоматически выявляет такие ситуации и разрешает
их, прерывая одну из сцепившихся транзакций и тем самым позволяя другой (другим) продолжить
работу. (Какая именно транзакция будет прервана, обычно сложно предсказать, так что рассчи-
тывать на определённое поведение не следует.)
Заметьте, что взаимоблокировки могут вызываться и блокировками на уровне строк (таким обра-
зом, они возможны, даже если не применяются явные блокировки). Рассмотрим случай, когда две
параллельных транзакции изменяют таблицу. Первая транзакция выполняет:
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
При этом она получает блокировку строки с указанным номером счёта. Затем вторая транзакция
выполняет:
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
Первый оператор UPDATE успешно получает блокировку указанной строки и изменяет данные в
ней. Однако второй оператор UPDATE обнаруживает, что строка, которую он пытается изменить,
уже заблокирована, так что он ждёт завершения транзакции, получившей блокировку. Таким об-
разом, вторая транзакция сможет продолжиться только после завершения первой. Теперь первая
транзакция выполняет:
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
Первая транзакция пытается получить блокировку заданной строки, но ей это не удаётся: эта бло-
кировка уже принадлежит второй транзакции. Поэтому первой транзакции остаётся только ждать
завершения второй. В результате первая транзакция блокируется второй, а вторая — первой: про-
исходит взаимоблокировка. PostgreSQL выявляет эту ситуацию и прерывает одну из транзакций.
Обычно лучший способ предотвращения взаимоблокировок — добиться, чтобы все приложения,
обращающиеся к базе данных, запрашивали блокировки нескольких объектов единообразно. В дан-
ном примере, если бы обе транзакции изменяли строки в одном порядке, взаимоблокировка бы не
произошла. Блокировки в транзакции следует упорядочивать так, чтобы первой для какого-либо
объекта запрашивалась наиболее ограничивающая из тех, которые для него потребуются. Если
заранее обеспечить такой порядок нельзя, взаимоблокировки можно обработать по факту, повто-
ряя прерванные транзакции.
Если ситуация взаимоблокировки не будет выявлена, транзакция, ожидающая блокировки на уров-
не таблицы или строки, будет ждать её освобождения неограниченное время. Это означает, что
417Управление конку-
рентным доступом
приложения не должны оставлять транзакции открытыми долгое время (например, ожидая ввода
пользователя).
13.3.5. Рекомендательные блокировки
PostgreSQL также имеет средства создания блокировок, смысл которых определяют сами прило-
жения. Такие блокировки называются рекомендательными, так как система не форсирует их ис-
пользование — правильно их использовать должно само приложение. Рекомендательные блоки-
ровки бывают полезны для реализаций стратегий блокирования, плохо вписывающихся в модель
MVCC. Например, рекомендательные блокировки часто применяются для исполнения стратегии
пессимистичной блокировки, типичной для систем управления данными «плоский файл». Хотя для
этого можно использовать и дополнительные флаги в таблицах, рекомендательные блокировки ра-
ботают быстрее, не нагружают таблицы и автоматически ликвидируется сервером в конце сеанса.
В PostgreSQL есть два варианта получить рекомендательные блокировки: на уровне сеанса и на
уровне транзакции. Рекомендательная блокировка, полученная на уровне сеанса, удерживается,
пока она не будет явно освобождена, или до конца сеанса. В отличие от стандартных рекомен-
дательные блокировки уровня сеанса нарушают логику транзакций — блокировка, полученная в
транзакции, даже если произойдёт откат этой транзакции, будет сохраняться в сеансе; аналогич-
но, освобождение блокировки остаётся в силе, даже если транзакция, в которой оно было выпол-
нено, позже прерывается. Вызывающий процесс может запросить блокировку несколько раз; при
этом каждому запросу блокировки должен соответствовать запрос освобождения, чтобы она была
действительно освобождена. Рекомендательные блокировки на уровне транзакций, напротив, во
многом похожи на обычные блокировки: они автоматически освобождаются в конце транзакций и
не требуют явного освобождения. Для кратковременного применения блокировок это поведение
часто более уместно, чем поведение рекомендательных блокировок на уровне сеанса. Запросы ре-
комендательных блокировок одного идентификатора на уровне сеанса и на уровне транзакции бу-
дут блокировать друг друга вполне предсказуемым образом. Если сеанс уже владеет данной реко-
мендуемой блокировкой, дополнительные запросы её в том же сеансе будут всегда успешны, даже
если её ожидают другие сеансы. Это утверждение справедливо вне зависимости от того, на каком
уровне (сеанса или транзакции) установлены или запрашиваются новые блокировки.
Как и остальные блокировки в PostgreSQL, все рекомендательные блокировки, связанные с любы-
ми сеансами, можно просмотреть в системном представлении pg_locks.
И рекомендательные, и обычные блокировки сохраняются в области общей памяти, размер кото-
рой определяется параметрами конфигурации max_locks_per_transaction и max_connections. Важ-
но, чтобы этой памяти было достаточно, так как в противном случае сервер не сможет выдать ника-
кую блокировку. Таким образом, число рекомендуемых блокировок, которые может выдать сервер,
ограничивается обычно десятками или сотнями тысяч в зависимости от конфигурации сервера.
В определённых случаях при использовании рекомендательных блокировок, особенно в запросах
с явными указаниями ORDER BY и LIMIT, важно учитывать, что получаемые блокировки могут за-
висеть от порядка вычисления SQL-выражений. Например:
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; – ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; – опасно!
SELECT pg_advisory_lock(q.id) FROM
(
SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; – ok
В этом примере второй вариант опасен, так как LIMIT не обязательно будет применяться перед
вызовом функции блокировки. В результате приложение может получить блокировки, на которые
оно не рассчитывает и которые оно не сможет освободить (до завершения сеанса). С точки зрения
приложения такие блокировки окажутся в подвешенном состоянии, хотя они и будут отображаться
в pg_locks.
Функции, предназначенные для работы с рекомендательными блокировками, описаны в Подраз-
деле 9.26.10.
418Управление конку-
рентным доступом
13.4. Проверки целостности данных на уровне прило-
жения
Используя транзакции Read Committed, очень сложно обеспечить целостность данных с точки зре-
ния бизнес-логики, так как представление данных смещается с каждым оператором и даже один
оператор может не ограничиваться своим снимком состояния в случае конфликта записи.
Хотя транзакция Repeatable Read получает стабильное представление данных в процессе выпол-
нения, с использованием снимков MVCC для проверки целостности данных всё же связаны тонкие
моменты, включая так называемые конфликты чтения/записи. Если одна транзакция записыва-
ет данные, а другая в это же время пытается их прочитать (до или после записи), она не может
увидеть результат работы первой. В таком случае создаётся впечатление, что читающая транзак-
ция выполняется первой вне зависимости от того, какая из них была начата или зафиксирована
раньше. Если этим всё и ограничивается, нет никаких проблем, но если читающая транзакция
также пишет данные, которые читает параллельная транзакция, получается, что теперь эта тран-
закция будет исполняться, как будто она запущена перед другими вышеупомянутыми. Если же
транзакция, которая должна исполняться как последняя, на самом деле зафиксирована первой, в
графе упорядоченных транзакций легко может возникнуть цикл. И когда он возникает, проверки
целостности не будут работать правильно без дополнительных мер.
Как было сказано в Подразделе  13.2.3, сериализуемые транзакции представляют собой те же
транзакции Repeatable Read, но дополненные неблокирующим механизмом отслеживания опас-
ных условий конфликтов чтения/записи. Когда выявляется условие, приводящее к циклу в порядке
транзакций, одна из этих транзакций откатывается и этот цикл таким образом разрывается.
13.4.1. Обеспечение согласованности в сериализуемых транзак-
циях
Если для всех операций чтения и записи, нуждающихся в согласованном представлении данных,
используются транзакции уровня изоляции Serializable, это обеспечивает необходимую согласо-
ванность без дополнительных усилий. Приложения из других окружений, применяющие сериали-
зуемые транзакции для обеспечения целостности, в PostgreSQL в этом смысле будут «просто ра-
ботать».
Применение этого подхода избавляет программистов приложений от лишних сложностей, если
приложение использует инфраструктуру, которая автоматически повторяет транзакции в случае
отката из-за сбоев сериализации. Возможно, serializable стоит даже установить в качестве уров-
ня изоляции по умолчанию (default_transaction_isolation). Также имеет смысл принять меры
для предотвращения использования других уровней изоляции, непреднамеренного или с целью
обойти проверки целостности, например проверять уровень изоляции в триггерах.
Рекомендации по увеличению быстродействия приведены в Подразделе 13.2.3.
Предупреждение
Защита целостности с применением сериализуемых транзакций пока ещё не поддер-
живается в режиме горячего резерва (Раздел 26.5). Поэтому там, где применяется го-
рячий резерв, следует использовать уровень Repeatable Read и явные блокировки на
главном сервере.
13.4.2. Применение явных блокировок для обеспечения согласо-
ванности
Когда возможны несериализуемые операции записи, для обеспечения целостности строк и защи-
ты от одновременных изменений, следует использовать SELECT FOR UPDATE, SELECT FOR SHARE
или соответствующий оператор LOCK TABLE. (SELECT FOR UPDATE и SELECT FOR SHARE защищают
419Управление конку-
рентным доступом
от параллельных изменений только возвращаемые строки, тогда как LOCK TABLE блокирует всю
таблицу.) Это следует учитывать, перенося в PostgreSQL приложения из других СУБД.
Мигрируя в PostgreSQL из других СУБД также следует учитывать, что команда SELECT FOR UPDATE
сама по себе не гарантирует, что параллельная транзакция не изменит или не удалит выбранную
строку. Для получения такой гарантии в PostgreSQL нужно именно изменить эту строку, даже ес-
ли никакие значения в ней менять не требуется. SELECT FOR UPDATE временно блокирует другие
транзакции, не давая им получить ту же блокировку или выполнить команды UPDATE или DELETE,
которые бы повлияли на заблокированную строку, но как только транзакция, владеющая этой бло-
кировкой, фиксируется или откатывается, заблокированная транзакция сможет выполнить кон-
фликтующую операцию, если только для данной строки действительно не был выполнен UPDATE,
пока транзакция владела блокировкой.
Реализация глобальной целостности с использованием несериализуемых транзакций MVCC тре-
бует более вдумчивого подхода. Например, банковскому приложению может потребоваться про-
верить, равняется ли сумма всех расходов в одной таблице сумме приходов в другой, при том, что
обе таблицы активно изменяются. Просто сравнивать результаты двух успешных последователь-
ных команд SELECT sum(…) в режиме Read Committed нельзя, так как вторая команда может
захватить результаты транзакций, пропущенных первой. Подсчитывая суммы в одной транзакции
Repeatable Read, можно получить точную картину только для транзакций, которые были зафикси-
рованы до начала данной, но при этом может возникнуть законный вопрос — будет ли этот резуль-
тат актуален тогда, когда он будет выдан. Если транзакция Repeatable Read сама вносит какие-то
изменения, прежде чем проверять равенство сумм, полезность этой проверки становится ещё бо-
лее сомнительной, так как при проверке будут учитываться некоторые, но не все изменения, про-
изошедшие после начала транзакции. В таких случаях предусмотрительный разработчик может
заблокировать все таблицы, задействованные в проверке, чтобы получить картину действитель-
ности, не вызывающую сомнений. Для этого применяется блокировка SHARE (или более строгая),
которая гарантирует, что в заблокированной таблице не будет незафиксированных изменений, за
исключением тех, что внесла текущая транзакция.
Также заметьте, что, применяя явные блокировки для предотвращения параллельных операций
записи, следует использовать либо режим Read Committed, либо в режиме Repeatable Read обяза-
тельно получать блокировки прежде, чем выполнять запросы. Блокировка, получаемая транзакци-
ей Repeatable Read, гарантирует, что никакая другая транзакция, изменяющая таблицу, не выпол-
няется, но если снимок состояния, полученный транзакцией, предшествует блокировке, он может
не включать на данный момент уже зафиксированные изменения. Снимок состояния в транзакции
Repeatable Read создаётся фактически на момент начала первой команды выборки или изменения
данных (SELECT, INSERT, UPDATE или DELETE), так что получить явные блокировки можно до того,
как он будет сформирован.
13.5. Ограничения
Некоторые команды DDL, в настоящее время это TRUNCATE и формы ALTER TABLE, перезаписы-
вающие таблицу, не являются безопасными с точки зрения MVCC. Это значит, что после фиксации
усечения или перезаписи таблица окажется пустой для всех параллельных транзакций, если они
работают со снимком, полученным перед фиксацией такой команды DDL. Это может проявиться
только в транзакции, которая не обращалась к таблице до момента начала команды DDL — лю-
бая транзакция, которая обращалась к ней раньше, получила бы как минимум блокировку ACCESS
SHARE, которая заблокировала бы эту команду DDL до завершения транзакции. Поэтому такие ко-
манды не приводят ни к каким видимым несоответствиям с содержимым таблицы при последова-
тельных запросах к целевой таблице, хотя возможно видимое несоответствие между содержимым
целевой таблицы и другими таблицами в базе данных.
Поддержка уровня изоляции Serializable ещё не реализована для целевых серверов горячего ре-
зерва (они описываются в Разделе 26.5). На данный момент самый строгий уровень изоляции, под-
держиваемый в режиме горячего резерва, это Repeatable Read. Хотя и тогда, когда главный сервер
выполняет запись в транзакциях Serializable, все резервные серверы в итоге достигают согласо-
ванного состояния, но транзакция Repeatable Read на резервном сервере иногда может увидеть
420Управление конку-
рентным доступом
промежуточное состояние, не соответствующее результату последовательного выполнения тран-
закций на главном сервере.
13.6. Блокировки и индексы
Хотя PostgreSQL обеспечивает неблокирующий доступ на чтение/запись к данным таблиц, для ин-
дексов в настоящий момент это поддерживается не в полной мере. PostgreSQL управляет доступом
к различным типам индексов следующим образом:
Индексы типа B-дерево, GiST и SP-GiST
Для управления чтением/записью используются кратковременные блокировки на уровне стра-
ницы, исключительные и разделяемые. Блокировки освобождаются сразу после извлечения
или добавления строки индекса. Эти типы индексов обеспечивают максимальное распаралле-
ливание операций, не допуская взаимоблокировок.
Хеш-индексы
Для управления чтением/записью используются блокировки на уровне групп хеша. Блокиров-
ки освобождаются после обработки всей группы. Такие блокировки с точки зрения распарал-
леливания лучше, чем блокировки на уровне индекса, но не исключают взаимоблокировок, так
как они сохраняются дольше, чем выполняется одна операция с индексом.
Индексы GIN
Для управления чтением/записью используются кратковременные блокировки на уровне стра-
ницы, исключительные и разделяемые. Блокировки освобождаются сразу после извлечения
или добавления строки индекса. Но заметьте, что добавление значения в поле с GIN-индексом
обычно влечёт добавление нескольких ключей индекса, так что GIN может проделывать целый
ряд операций для одного значения.
В настоящее время в многопоточной среде наиболее производительны индексы-B-деревья; и так
как они более функциональны, чем хеш-индексы, их рекомендуется использовать в такой среде
для приложений, когда нужно индексировать скалярные данные. Если же нужно индексировать
не скалярные данные, B-деревья не подходят, и вместо них следует использовать индексы GiST,
SP-GiST или GIN.</p>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-013/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-013/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-013/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-012/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
