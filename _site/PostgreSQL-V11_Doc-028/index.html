<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 28. Мониторинг работы СУБД &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 28. Мониторинг работы СУБД">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 28. Мониторинг работы СУБД">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-028/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-028/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 28. Мониторинг работы СУБД">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-028/" rel="bookmark" title="Глава 28. Мониторинг работы СУБД">Глава 28. Мониторинг работы СУБД</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~63 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 28. Мониторинг работы СУБД</p>

<p>Администратор базы данных часто задумывается — «чем в данный момент занята система?» В
этой главе рассказывается о том, как это выяснить.
Для мониторинга работы СУБД и анализа её производительности существуют различные инстру-
менты. Большая часть этой главы посвящена описанию работы сборщика статистики PostgreSQL,
однако не следует пренебрегать и обычными командами мониторинга Unix, такими как ps, top,
iostat, и vmstat. Кроме того, после обнаружения запроса с низкой производительностью может
потребоваться дополнительное исследование с использованием PostgreSQL команды EXPLAIN. В
Разделе 14.1 рассматриваются EXPLAIN и другие методы для изучения поведения отдельного за-
проса.
28.1. Стандартные инструменты Unix
В большинстве Unix-платформ PostgreSQL модифицирует заголовок команды, который выводится
на экран при выполнении команды ps, так что серверные процессы можно легко различить. При-
мер вывода этой команды:
$ ps auxww | grep ^postgres
postgres 15551 0.0 0.1 57536 7132 pts/0
postgres 15554 0.0 0.0 57536 1184 ?
writer
postgres 15555 0.0 0.0 57536
916 ?
checkpointer
postgres 15556 0.0 0.0 57536
916 ?
postgres 15557 0.0 0.0 58504 2244 ?
launcher
postgres 15558 0.0 0.0 17512 1068 ?
collector
postgres 15582 0.0 0.0 58772 3080 ?
127.0.0.1 idle
postgres 15606 0.0 0.0 58772 3052 ?
regression [local] SELECT waiting
postgres 15610 0.0 0.0 58772 3056 ?
regression [local] idle in transaction
S
Ss 18:02
18:02 0:00 postgres -i
0:00 postgres: background
Ss 18:02 0:00 postgres:
Ss
Ss 18:02
18:02 0:00 postgres: walwriter
0:00 postgres: autovacuum
Ss 18:02 0:00 postgres: stats
Ss 18:04 0:00 postgres: joe runbug
Ss 18:07 0:00 postgres: tgl
Ss 18:07 0:00 postgres: tgl
(Формат вызова ps, а также детали отображаемой информации зависят от платформы. Это пример
для одной из последних Linux-систем.) Первым здесь отображается главный процесс сервера. Для
этого процесса отображены аргументы команды, которые использовались при его запуске. Следу-
ющие пять процессов — это фоновые рабочие процессы, которые были автоматически запущены
процессом сервера. (Процесса «stats collector» в этом списке не будет, если запуск сборщика ста-
тистики отключён в системе; аналогично может быть отключён и процесс «autovacuum launcher»
— фоновый процесс автоочистки.) Во всех остальных строках перечислены серверные процессы,
каждый из которых обслуживает одно клиентское подключение. Командная строка каждого тако-
го процесса имеет следующий формат:
postgres: имя_сервера база_данных компьютер активность
Пользователь, СУБД и компьютер (клиента) остаются неизменными на протяжении всего клиент-
ского подключения, а индикатор деятельности меняется. Возможные виды деятельности: idle (т.
е. ожидание команды клиента), idle in transaction (ожидание клиента внутри блока BEGIN) или
название типа команды, например, SELECT. Кроме того, если в настоящий момент серверный про-
цесс ожидает высвобождения блокировки, которую держит другая сессия, то к виду деятельности
добавляется waiting. В приведённом выше примере мы видим, что процесс 15606 ожидает, ко-
гда процесс 15610 завершит свою транзакцию и, следовательно, освободит какую-то блокировку.
(Процесс 15610 является блокирующим, поскольку никаких других активных сессий нет. В более
сложных случаях может потребоваться обращение к системному представлению pg_locks, для то-
го чтобы определить, кто кого блокирует.)
674Мониторинг работы СУБД
Если установлено значение cluster_name, имя кластера также будет показываться в выводе коман-
ды ps:
$ psql -c ‘SHOW cluster_name’
cluster_name
————–
server1
(1 row)
$ ps aux|grep server1
postgres
27093 0.0
background writer
…
0.0
30096
2752 ?
Ss
11:34
0:00 postgres: server1:
Если параметр update_process_title был отключён, то индикатор деятельности не обновляется; на-
звание процесса устанавливается только один раз при запуске нового процесса. На некоторых
платформах это позволяет значительно сократить накладные расходы при выполнении команды;
на других платформах этот выигрыш может быть незначителен.
Подсказка
В Solaris требуется особый подход. Следует использовать /usr/ucb/ps вместо /bin/ps.
Также следует использовать два флага w, а не один. Кроме того, при выводе статусов
команд с помощью ps статус для исходной команды postgres должен отображаться
в сокращённом формате для каждого серверного процесса. Если вы не сделаете все
три вещи, то вывод ps для каждого серверного процесса будет исходной командной
строкой postgres.
28.2. Сборщик статистики
Сборщик статистики в PostgreSQL представляет собой подсистему, которая собирает и отобра-
жает информацию о работе сервера. В настоящее время сборщик может подсчитывать количество
обращений к таблицам и индексам — в виде количества прочитанных блоков или строк с диска.
Кроме того, он отслеживает общее число строк в каждой таблице, информацию о выполнении
очистки и сбора статистики для каждой таблицы. Он также может подсчитывать вызовы пользо-
вательских функций и общее время, затраченное на выполнение каждой из них.
Кроме того, PostgreSQL может предоставить динамическую информацию о том, что происходит
в системе прямо сейчас, в частности, сообщить, какие именно команды выполняются другими
серверными процессами и какие другие соединения существуют в системе. Эта возможность не
зависит от процесса сборщика.
28.2.1. Конфигурация системы сбора статистики
Поскольку сбор статистики несколько увеличивает накладные расходы при выполнении запроса,
есть возможность настроить СУБД так, чтобы выполнять или не выполнять сбор статистической
информации. Это контролируется конфигурационными параметрами, которые обычно устанавли-
ваются в файле postgresql.conf. (Подробно установка конфигурационных параметров описыва-
ется в Главе 19.)
Параметр track_activities включает мониторинг текущих команд, выполняемой любым серверным
процессом.
Параметр track_counts определяет необходимость сбора статистики по обращениям к таблицам и
индексам.
Параметр track_functions включает отслеживание использования пользовательских функций.
Параметр track_io_timing включает мониторинг времени чтения и записи блоков.
675Мониторинг работы СУБД
Обычно эти параметры устанавливаются в postgresql.conf, поэтому они применяются ко всем
серверным процессам, однако, используя команду SET, их можно включать и выключать в отдель-
ных сессиях. (Для того чтобы обычные пользователи не скрывали свою работу от администратора
СУБД, изменять эти параметры с помощью команды SET могут только суперпользователи.)
Сборщик статистики использует временные файлы для передачи собранной информации дру-
гим процессам PostgreSQL. Имя каталога, в котором хранятся эти файлы, задаётся параметром
stats_temp_directory, по умолчанию он называется pg_stat_tmp. Для повышения производительно-
сти stats_temp_directory может указывать на каталог, расположенный в оперативной памяти,
что сокращает время физического ввода/вывода. При остановке сервера постоянная копия стати-
стической информации сохраняется в подкаталоге pg_stat, поэтому статистику можно хранить
на протяжении нескольких перезапусков сервера. Когда восстановление выполняется при запус-
ке сервера (например, после непосредственного завершения работы, катастрофического отказа
сервера, и восстановлении на заданную точку во времени), все статистические данные счётчиков
сбрасываются.
28.2.2. Просмотр статистики
Для просмотра текущего состояния системы предназначены несколько предопределённых пред-
ставлений, которые перечислены в Таблице 28.1. В дополнение к ним есть несколько других пред-
ставлений, перечисленных в Таблице 28.2, позволяющих просмотреть результаты сбора статисти-
ки. Кроме того, на базе нижележащих статистических функций можно создать собственные пред-
ставления, как описано в Подразделе 28.2.3.
Наблюдая собранные данные в сборщике статистики, важно понимать, что эта информация обнов-
ляется не сразу. Каждый серверный процесс передаёт новые статистические данные сборщику
статистики непосредственно перед переходом в режим ожидания; то есть запрос или транзакция
в процессе выполнения не влияют на отображаемые данные статистики. К тому же, сам сборщик
статистики формирует новый отчёт не чаще, чем раз в PGSTAT_STAT_INTERVAL миллисекунд (500
мс, если этот параметр не изменялся при компиляции сервера). Так что отображаемая информа-
ция отстаёт от того, что происходит в настоящий момент. Однако информация о текущем запросе,
собираемая с параметром track_activities, всегда актуальна.
Ещё одним важным моментом является то, что когда в серверном процессе запрашивают какую-ли-
бо статистику, сначала он получает наиболее свежий моментальный снимок от сборщика стати-
стики и затем до окончания текущей транзакции использует этот снимок для всех статистических
представлений и функций. Так что на протяжении одной транзакции статистическая информация
меняться не будет. Подобным же образом информация о текущих запросах во всех сессиях соби-
рается в тот момент, когда она впервые запрашивается в рамках транзакции, и эта же самая ин-
формация будет отображаться на протяжении всей транзакции. Это не ошибка, а полезное свой-
ство СУБД, поскольку оно позволяет выполнять запросы к статистическим данным и сравнивать
результаты, не беспокоясь о том, что статистические данные изменяются. Но если для каждого
запроса вам нужны новые результаты, то их следует выполнять вне любых транзакционных блоков.
Или же можно вызывать функцию pg_stat_clear_snapshot(), которая сбросит ранее полученный
снимок статистики в текущей транзакции (если он был). При следующем обращении к статисти-
ческой информации будет сформирован новый моментальный снимок.
Через
представления
pg_stat_xact_all_tables,
pg_stat_xact_sys_tables,
pg_stat_xact_user_tables, и pg_stat_xact_user_functions транзакции также доступна её соб-
ственная статистика (ещё не переданная сборщику статистики). Данные в этих представлениях
ведут себя не так, как описано выше; наоборот, в течение транзакции они постоянно обновляются.
Таблица 28.1. Динамические статистические представления
Имя представления Описание
pg_stat_activity Одна строка для каждого серверного процесса
c информацией по текущей активности процес-
са, такой как состояние и текущий запрос. За по-
дробностями обратитесь к pg_stat_activity.
676Мониторинг работы СУБД
Имя представления Описание
pg_stat_replication По одной строке для каждого процесса-передат-
чика WAL со статистикой по репликации на ве-
домом сервере, к которому подключён этот про-
цесс. За подробностями обратитесь к pg_stat_
replication.
pg_stat_wal_receiver Только одна строка со статистикой приёмника
WAL, полученной с сервера, на котором работа-
ет приёмник. За подробностями обратитесь к pg_
stat_wal_receiver.
pg_stat_subscription Как минимум одна строка для подписки, сообща-
ющая о рабочих процессах подписки. За подроб-
ностями обратитесь к pg_stat_subscription.
pg_stat_ssl Одна строка для каждого подключения (обычно-
го и реплицирующего), в которой показывается
информация об использовании SSL для данного
подключения. Подробности описаны в pg_stat_
ssl.
pg_stat_progress_vacuum По одной строке с текущим состоянием для каж-
дого обслуживающего процесса (включая рабо-
чие процессы автоочистки), в котором работает
VACUUM. См. Подраздел 28.4.1.
Таблица 28.2. Представления собранной статистики
Имя представления Описание
pg_stat_archiver Только одна строка со статистикой о работе ак-
тивности процесса архивации WAL. Более по-
дробно смотрите pg_stat_archiver.
pg_stat_bgwriter Только одна строка со статистикой о работе фо-
нового процесса записи. Более подробно смот-
рите pg_stat_bgwriter.
pg_stat_database Одна строка для каждой базы данных со стати-
стикой на уровне базы. Более подробно смотри-
те pg_stat_database.
pg_stat_database_conflicts По одной строке на каждую базу данных со
статистикой по отменам запросов, выполнен-
ным вследствие конфликта с процессами восста-
новления на ведомых серверах. Более подробно
смотрите pg_stat_database_conflicts.
pg_stat_all_tables По одной строке на каждую таблицу в текущей
базе данных со статистикой по обращениям к
этой таблице. Более подробно смотрите pg_stat_
all_tables.
pg_stat_sys_tables Аналогично pg_stat_all_tables
, за исклю-
чением того, что отображаются только систем-
ные таблицы.
pg_stat_user_tables Аналогично pg_stat_all_tables
, за исклю-
чением того, что отображаются только пользо-
вательские таблицы.
pg_stat_xact_all_tables Подобно pg_stat_all_tables
, но подсчиты-
вает действия, выполненные в текущей транзак-
ции к настоящему моменту (которые ещё не во-
677Мониторинг работы СУБД
Имя представления Описание
шли в pg_stat_all_tables
и связанные пред-
ставления). Столбцы для числа живых и мёртвых
строк, а также количества операций очистки и
сбора статистики, в этом представлении отсут-
ствуют.
pg_stat_xact_sys_tables Аналогично pg_stat_xact_all_tables
, за
исключением того, что отображаются только си-
стемные таблицы.
pg_stat_xact_user_tables Аналогично pg_stat_xact_all_tables
, за
исключением того, что отображаются только
пользовательские таблицы.
pg_stat_all_indexes По одной строке для каждого индекса в теку-
щей базе данных со статистикой по обращениям
к этому индексу. Более подробно смотрите pg_
stat_all_indexes.
pg_stat_sys_indexes Аналогично pg_stat_all_indexes
, за исклю-
чением того, что показываются только индексы
по системным таблицам.
pg_stat_user_indexes Аналогично pg_stat_all_indexes
, за исклю-
чением того, что показываются только индексы
по пользовательским таблицам.
pg_statio_all_tables По одной строке для каждой таблицы в теку-
щей базе данных со статистикой по операциям
ввода/вывода для этой таблицы. Более подробно
смотрите pg_statio_all_tables.
pg_statio_sys_tables Аналогично pg_statio_all_tables
, за ис-
ключением того, что показываются только си-
стемные таблицы.
pg_statio_user_tables Аналогично pg_statio_all_tables
, за ис-
ключением того, что показываются только поль-
зовательские таблицы.
pg_statio_all_indexes По одной строке для каждого индекса в теку-
щей базе данных со статистикой по операциям
ввода/вывода для этого индекса. Более подробно
смотрите pg_statio_all_indexes.
pg_statio_sys_indexes Аналогично pg_statio_all_indexes
, за ис-
ключением того, что показываются только ин-
дексы по системным таблицам.
pg_statio_user_indexes Аналогично pg_statio_all_indexes
, за ис-
ключением того, что показываются только ин-
дексы по пользовательским таблицам.
pg_statio_all_sequences По одной строке для каждой последователь-
ности в текущей базе данных со статистикой
по операциям ввода/вывода для этой последова-
тельности. Более подробно смотрите pg_statio_
all_sequences.
pg_statio_sys_sequences Аналогично pg_statio_all_sequences
, за ис-
ключением того, что показываются только си-
стемные последовательности. (В настоящее вре-
мя системных последовательностей нет, поэто-
му это представление всегда пусто.)
678Мониторинг работы СУБД
Имя представления Описание
pg_statio_user_sequences Аналогично pg_statio_all_sequences
, за ис-
ключением того, что показываются только поль-
зовательские последовательности.
pg_stat_user_functions По одной строке для каждой отслеживаемой
функции со статистикой по выполнениям этой
функции. Более подробно смотрите pg_stat_
user_functions.
pg_stat_xact_user_functions Аналогично pg_stat_user_functions
, одна-
ко подсчитываются только вызовы функций,
выполненные в текущей транзакции (которые
ещё не были включены в pg_stat_user_
functions ).
Статистика по отдельным индексам особенно полезна для определения того, какие индексы ис-
пользуются и насколько они эффективны.
Представления pg_statio_ полезны, прежде всего, для определения эффективности буферного
кеша. Если количество фактических дисковых чтений существенно меньше количества чтений
из буферного кеша, то это означает, что кеш справляется с большинством запросов на чтение
без обращения к ядру. Однако эта статистика не даёт полной картины: PostgreSQL обрабатывает
дисковый ввод/вывод так, что данные, не находящиеся в буферном кеше PostgreSQL, могут все ещё
располагаться в кеше ввода/вывода ядра, и, следовательно, для их получения физическое чтение
может не использоваться. Для получения более детальной информации о процессе ввода/вывода в
PostgreSQL рекомендуется использовать сборщик статистики PostgreSQL в сочетании с утилитами
операционной системы, которые дают более полное представление о том, как ядро осуществляет
ввод/вывод.
Таблица 28.3. Представление pg_stat_activity
Столбец Тип Описание
datid oid OID базы данных, к которой под-
ключён этот серверный процесс
datname name Имя базы данных, к которой
подключён этот серверный про-
цесс
pid integer Идентификатор процесса этого
серверного процесса
usesysid oid OID пользователя, подключён-
ного к этому серверному про-
цессу
usename name Имя пользователя, подключён-
ного к этому серверному про-
цессу
application_name text Название приложения, подклю-
чённого к этому серверному
процессу
client_addr inet IP-адрес клиента, подключённо-
го к этому серверному процес-
су. Значение null в этом поле
означает, что клиент подклю-
чён через сокет Unix на стороне
сервера или что это внутренний
процесс, например, автоочист-
ка.
679Мониторинг работы СУБД
Столбец Тип Описание
client_hostname text Имя компьютера для подклю-
чённого клиента, получаемое в
результате обратного поиска в
DNS по client_addr . Это поле
будет отлично от null только в
случае соединений по IP и толь-
ко при включённом режиме log_
hostname.
client_port integer Номер TCP-порта, который ис-
пользуется клиентом для соеди-
нения с этим серверным про-
цессом, или -1, если использу-
ется сокет Unix
backend_start timestamp with time zone Время
запуска
процесса.
Для процессов, обслуживающих
клиентов, это время подключе-
ния клиента к серверу.
xact_start timestamp with time zone Время начала текущей транзак-
ции в этом процессе или null
при отсутствии активной тран-
закции. Если текущий запрос
был первым в своей транзак-
ции, то значение в этом столбце
совпадает со значением столб-
ца query_start .
query_start timestamp with time zone Время начала выполнения ак-
тивного в данный момент запро-
са, или, если state не active, то
время начала выполнения по-
следнего запроса
state_change timestamp with time zone Время последнего изменения
состояния (поля state)
wait_event_type text Тип события, которого ждёт
обслуживающий процесс, если
это имеет место; в противном
случае — NULL. Возможные
значения:
• LWLock: обслуживающий
процесс ожидает лёгкую
блокировку. Такие блоки-
ровки защищают определён-
ные структуры данных в раз-
деляемой памяти. В wait_
event будет содержаться
имя, отражающее цель по-
лучения лёгкой блокиров-
ки. (Некоторые блокировки
имеют особые имена; другие
объединяются в группы бло-
кировок со схожим предна-
значением.)
• Lock: Обслуживающий про-
цесс ожидает тяжёлую бло-
680Мониторинг работы СУБД
Столбец
Тип
Описание
кировку. Тяжёлые блокиров-
ки, также называемые бло-
кировками менеджера бло-
кировок или просто блоки-
ровками, в основном защи-
щают объекты уровня SQL,
такие как таблицы. Однако
они также применяются для
взаимоисключающего вы-
полнения некоторых внут-
ренних операций, например,
для расширения отношений.
Тип ожидаемой блокировки
показывается в wait_event .
• BufferPin: Серверный про-
цесс ожидает доступа к бу-
феру данных, когда никакой
другой процесс не обраща-
ется к этому буферу. Ожи-
дание закрепления буфера
может растягиваться, если
другой процесс удержива-
ет открытый курсор, кото-
рый читал данные из нужно-
го буфера.
• Activity: Серверный про-
цесс простаивает. Это состо-
яние наблюдается в систем-
ных процессах, ожидающих
активности в основном цик-
ле обработки. В wait_event
обозначается конкретное
место ожидания.
• Extension: Серверный про-
цесс ожидает активности в
модуле расширения. Эта ка-
тегория полезна при исполь-
зовании модулей, она помо-
гает отслеживать нестан-
дартные места ожидания.
• Client: Серверный процесс
ожидает в сокете некоторую
активность пользовательско-
го приложения, и события,
ожидаемые сервером, не
зависят от его внутренних
процессов. В wait_event
обозначается конкретное
место ожидания.
• IPC: Серверный процесс
ожидает некоторой актив-
ности другого процесса на
сервере. В wait_event обо-
681Мониторинг работы СУБД
Столбец
Тип
Описание
значается конкретное место
ожидания.
• Timeout: Серверный процесс
ожидает истечения опреде-
лённого времени. В wait_
event обозначается кон-
кретное место ожидания.
• IO: Серверный процесс ожи-
дает завершения операции
ввода/вывода. В wait_event
обозначается конкретное
место ожидания.
wait_event text Имя ожидаемого события, ес-
ли обслуживающий процесс на-
ходится в состоянии ожидания,
а в противном случае — NULL.
За подробностями обратитесь к
Таблице 28.4.
state text Общее текущее состояние этого
серверного процесса. Возмож-
ные значения:
• active: серверный процесс
выполняет запрос.
• idle: серверный процесс
ожидает новой команды от
клиента.
• idle in transaction: сер-
верный процесс находится
внутри транзакции, но в на-
стоящее время не выполня-
ет никакой запрос.
• idle in transaction (
aborted) : Это состо-
яние подобно idle in
transaction, за исключени-
ем того, что один из опера-
торов в транзакции вызывал
ошибку.
• fastpath function call:
серверный процесс выполня-
ет fast-path функцию.
• disabled: Это состояние
отображается для сервер-
ных процессов, у которых
параметр track_activities от-
ключён.
backend_xid
Идентификатор верхнего уров-
ня транзакции этого серверного
процесса или любой другой.
xid
682Мониторинг работы СУБД
Столбец Тип Описание
backend_xmin xid текущая граница xmin для сер-
верного процесса.
query text Текст последнего запроса это-
го серверного процесса. Если
state имеет значение active,
то в этом поле отображается
запрос, который выполняется в
настоящий момент. Если про-
цесс находится в любом дру-
гом состоянии, то в этом по-
ле отображается последний вы-
полненный запрос. По умолча-
нию текст запроса обрезает-
ся до 1024 символов; это чис-
ло определяется параметром
track_activity_query_size.
backend_type text Тип текущего серверного про-
цесса.
Возможные
вариан-
ты: autovacuum
launcher,
autovacuum
worker,
background
worker,
background
writer, client
backend, checkpointer, startup,
walreceiver, walsender и
walwriter.
В представлении pg_stat_activity для каждого серверного процесса будет присутствовать по од-
ной строке с информацией, относящейся к текущей деятельности этого процесса.
Примечание
Значения в столбцах wait_event и state не зависят друг от друга. Если обслуживаю-
щий процесс находится в состоянии active (активен), он может ожидать какое-то со-
бытие, или не ожидать никакое. Если состояние active и поле wait_event содержит
не NULL, это означает, что запрос выполняется, но заблокирован чем-то в системе.
Таблица 28.4. Описание wait_event
Тип события ожидания Название
ния
события
LWLock ShmemIndexLock Ожидание при поиске или вы-
делении области в разделяемой
памяти.
OidGenLock Ожидание при выделении или
назначении OID.
XidGenLock Ожидание
при
выделении
или назначении идентификато-
ра транзакции.
ProcArrayLock Ожидание при получении сним-
ка или очистке идентификато-
ра транзакции в конце транзак-
ции.
683
ожида- ОписаниеМониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
SInvalReadLock Ожидание при получении или
удалении из общей очереди со-
общений аннулирования.
SInvalWriteLock Ожидание при добавлении в об-
щую очередь сообщения анну-
лирования.
WALBufMappingLock Ожидание при замене страни-
цы в буферах WAL.
WALWriteLock Ожидание при записи буферов
WAL на диск.
ControlFileLock Ожидание при чтении или из-
менении управляющего файла
либо при создании нового фай-
ла WAL.
CheckpointLock Ожидание при выполнении кон-
трольной точки.
CLogControlLock Ожидание при чтении или из-
менении состояния транзак-
ции.
SubtransControlLock Ожидание при чтении или из-
менении информации о под-
транзакции.
MultiXactGenLock Ожидание при чтении или
изменении общего состояния
мультитранзакций.
MultiXactOffsetControlLock Ожидание при чтении или из-
менении смещений мультит-
ранзакций.
MultiXactMemberControlLock Ожидание при чтении или из-
менении членов мультитран-
закций.
RelCacheInitLock Ожидание при чтении или запи-
си файла инициализации кеша
отношения.
CheckpointerCommLock Ожидание при управлении за-
просами fsync.
TwoPhaseStateLock Ожидание при чтении или из-
менении состояния подготов-
ленных транзакций.
TablespaceCreateLock Ожидание при создании или
удалении табличного простран-
ства.
BtreeVacuumLock Ожидание при чтении или из-
менении информации, связан-
ной с очисткой, для индекса-B-
дерева.
AddinShmemInitLock Ожидание при управлении вы-
делением блоков в общей памя-
ти.
684Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
AutovacuumLock Ожидание в рабочем процес-
се или процедуре запуска ав-
тоочистки при изменении или
чтении текущего состояния ра-
бочих процессов автоочистки.
AutovacuumScheduleLock Ожидание при подтверждении,
что таблица, выбранная для
очистки, всё ещё нуждается в
очистке.
SyncScanLock Ожидание при получении на-
чального положения сканиро-
вания таблицы для синхронизи-
рованного сканирования.
RelationMappingLock Ожидание при изменении в
файле сопоставления отноше-
ний, используемого для хране-
ния связей файловых узлов с ка-
талогом БД.
AsyncCtlLock Ожидание при чтении или из-
менении общего состояния уве-
домлений.
AsyncQueueLock Ожидание при чтении или из-
менении сообщений уведомле-
ний.
SerializableXactHashLock Ожидание при получении или
сохранении информации о сери-
ализуемых транзакциях.
SerializableFinishedListLock Ожидание при обращении к
списку завершённых сериали-
зуемых транзакций.
Ожидание при выполнении опе-
SerializablePredicateLockListLock
рации со списком блокировок,
удерживаемых сериализуемы-
ми транзакциями.
OldSerXidLock Ожидание при чтении или запи-
си информации о конфликтую-
щих сериализуемых транзакци-
ях.
SyncRepLock Ожидание при чтении или из-
менении сведений о синхрон-
ных репликах.
BackgroundWorkerLock Ожидание при чтении или из-
менении состояния фонового
рабочего процесса.
Ожидание при чтении или из-
DynamicSharedMemoryControlLock
менении состояния динамиче-
ской общей памяти.
AutoFileLock
685
Ожидание при изменении фай-
ла postgresql.auto.conf.Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
ReplicationSlotAllocationLockОжидание при выделении или
освобождении слота реплика-
ции.
ReplicationSlotControlLock Ожидание при чтении или из-
менении состояния слота ре-
пликации.
CommitTsControlLock Ожидание при чтении или из-
менении времени фиксирова-
ния транзакции.
CommitTsLock Ожидание при чтении или из-
менении последнего значения,
заданного в качестве времени
транзакции.
ReplicationOriginLock Ожидание при подготовке, уда-
лении или использовании ис-
точника репликации.
MultiXactTruncationLock Ожидание при чтении или
очистке информации мультит-
ранзакций.
OldSnapshotTimeMapLock Ожидание при чтении или из-
менении информации о старом
снимке.
BackendRandomLock Ожидание генерирования слу-
чайного числа.
LogicalRepWorkerLock Ожидание завершения дей-
ствия процесса логической ре-
пликации.
CLogTruncationLock Ожидание при усечении жур-
нала предзаписи или ожидание
завершения усечения журнала
предзаписи.
clog Ожидание при вводе/выводе с
буфером clog (буфер состояния
транзакций).
commit_timestamp Ожидание при вводе/выводе с
буфером времени фиксирова-
ния транзакций.
subtrans Ожидание при вводе/выводе с
буфером подтранзакций.
multixact_offset Ожидание при вводе/выводе с
буфером смещений мультитран-
закций.
multixact_member Ожидание при вводе/выводе с
буфером multixact_member.
async Ожидание при вводе/выводе с
буфером асинхронных сообще-
ний (уведомлений).
oldserxid Ожидание ввода/вывода для бу-
фера oldserxid.
686Мониторинг работы СУБД
Тип события ожидания
Lock
Название
ния
события
ожида- Описание
wal_insert Ожидание при добавлении за-
писей WAL в буфер в памяти.
buffer_content Ожидание при чтении или запи-
си страницы данных в памяти.
buffer_io Ожидание при вводе/выводе,
связанном со страницей дан-
ных.
replication_origin Ожидание при чтении или из-
менении состояния реплика-
ции.
replication_slot_io Ожидание при вводе/выводе со
слотом репликации.
proc Ожидание при чтении или из-
менении информации о блоки-
ровках по быстрому пути.
buffer_mapping Ожидание при связывании бло-
ка данных с буфером в пуле бу-
феров.
lock_manager Ожидание при добавлении или
обращении к блокировкам об-
служивающих процессов либо
ожидание входа или выхода из
группы блокировок (использу-
ется в параллельных запросах).
predicate_lock_manager Ожидание при добавлении или
обращении к информации о пре-
дикатных блокировках.
parallel_query_dsa Ожидание блокировки выделе-
ния динамической общей памя-
ти для параллельного запроса.
tbm Ожидание блокировки общего
итератора TBM.
parallel_append Ожидание выбора следующего
подплана в процессе выполне-
ния узла параллельного добав-
ления (Parallel Append).
parallel_hash_join Ожидание выделения или обме-
на блока памяти либо обновле-
ния счётчиков при выполнении
плана параллельного хеширова-
ния (Parallel Hash).
relation Ожидание при запросе блоки-
ровки для отношения.
extend Ожидание при расширении от-
ношения.
page Ожидание при запросе блоки-
ровки для страницы отношения.
tuple Ожидание при запросе блоки-
ровки для кортежа.
687Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
transactionid Ожидание завершения транзак-
ции.
virtualxid Ожидание при запросе блоки-
ровки виртуального xid.
speculative token Ожидание при запросе блоки-
ровки спекулятивного добавле-
ния.
object Ожидание при запросе блоки-
ровки для нереляционного объ-
екта БД.
userlock Ожидание при запросе пользо-
вательской блокировки.
advisory Ожидание при запросе ре-
комендательной пользователь-
ской блокировки.
BufferPin BufferPin Ожидание при закреплении бу-
фера.
Activity ArchiverMain Ожидание в основном цикле
процесса архиватора.
AutoVacuumMain Ожидание в основном цикле
процесса запуска автоочистки.
BgWriterHibernate Ожидание в фоновом процессе
записи, переход в режим «замо-
розки».
BgWriterMain Ожидание в основном цикле ра-
бочего процесса фоновой запи-
си.
CheckpointerMain Ожидание в основном цикле
процесса контрольной точки.
LogicalApplyMain Ожидание в основном цикле
процесса применения логиче-
ской репликации.
LogicalLauncherMain Ожидание в основном цикле
процесса запуска обработчиков
логической репликации.
PgStatMain Ожидание в основном цикле
процесса сборщика статистики.
RecoveryWalAll Ожидание поступления WAL из
любого источника (локального,
архива или потока) при восста-
новлении.
RecoveryWalStream Ожидание поступления WAL из
потока при восстановлении.
SysLoggerMain Ожидание в основном цикле
процесса системного журнала (
syslogger).
WalReceiverMain Ожидание в основном цикле
процесса-приёмника WAL.
688Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
WalSenderMain Ожидание в основном цикле
процесса-передатчика WAL.
WalWriterMain Ожидание в основном цикле
процесса, пишущего WAL.
ClientRead Ожидание при чтении данных,
получаемых от клиента.
ClientWrite Ожидание при записи данных,
передаваемых клиенту.
LibPQWalReceiverConnect Ожидание в приёмнике WAL
установления подключения к
удалённому серверу.
LibPQWalReceiverReceive Ожидание в приёмнике WAL по-
ступления данных от удалённо-
го сервера.
SSLOpenServer Ожидание SSL при попытке
установления соединения.
WalReceiverWaitStart Ожидание от стартового про-
цесса передачи начальных дан-
ных для потоковой репликации.
WalSenderWaitForWAL Ожидание сброса WAL в процес-
се-передатчике WAL.
WalSenderWriteData Ожидание какой-либо активно-
сти при обработке ответов от
WAL-приёмника в процессе-пе-
редатчике WAL.
Extension Extension Ожидание в расширении.
IPC BgWorkerShutdown Ожидание завершения фоново-
го рабочего процесса.
BgWorkerStartup Ожидание запуска фонового ра-
бочего процесса.
BtreePage Ожидание доступности номе-
ра страницы, необходимого
для продолжения параллельно-
го сканирования B-дерева.
ClogGroupUpdate Ожидание изменения состоя-
ния завершённой транзакции
ведущим процессом группы.
ExecuteGather Ожидание активности дочерне-
го процесса при выполнении уз-
ла Gather.
Hash/Batch/Allocating Ожидание выделения хеш-таб-
лицы выбранным участником
параллельного хеширования.
Hash/Batch/Electing Выбор участника параллельно-
го хеширования для выделения
хеш-таблицы.
Hash/Batch/Loading Ожидание завершения загруз-
ки хеш-таблицы другими участ-
Client
689Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
никами параллельного хеширо-
вания.
Hash/Build/Allocating Ожидание выделения началь-
ной хеш-таблицы выбранным
участником параллельного хе-
ширования.
Hash/Build/Electing Выбор участника параллельно-
го хеширования для выделения
начальной хеш-таблицы.
Hash/Build/HashingInner Ожидание завершения хеши-
рования внутреннего отноше-
ния другими участниками па-
раллельного хеширования.
Hash/Build/HashingOuter Ожидание завершения хеширо-
вания внешнего отношения дру-
гими участниками параллель-
ного хеширования.
Hash/GrowBatches/Allocating Ожидание выделения допол-
нительных пакетов выбранным
участником параллельного хе-
ширования.
Hash/GrowBatches/Deciding Выбор участника параллельно-
го хеширования для принятия
решений о предстоящем добав-
лении пакетов.
Hash/GrowBatches/Electing Выбор участника параллельно-
го хеширования для выделения
дополнительных пакетов.
Hash/GrowBatches/Finishing Ожидание решения о предстоя-
щем добавлении пакетов участ-
ником параллельного хеширо-
вания.
Hash/GrowBatches/
Repartitioning Ожидание завершения перераз-
биения другими участниками
параллельного хеширования.
Hash/GrowBuckets/Allocating Ожидание завершения выде-
ления дополнительных групп
выбранным участником парал-
лельного хеширования.
Hash/GrowBuckets/Electing Выбор участника параллельно-
го хеширования для выделения
дополнительных групп.
Hash/GrowBuckets/Reinserting Ожидание завершения добавле-
ния кортежей в новые груп-
пы другими участниками парал-
лельного хеширования.
LogicalSyncData
690
Ожидание от удалённого серве-
ра логической репликации пе-
редачи данных для начальной
синхронизации таблиц.Мониторинг работы СУБД
Тип события ожидания
Timeout
IO
Название
ния
события
ожида- Описание
LogicalSyncStateChange Ожидание изменения состоя-
ния удалённого сервера логиче-
ской репликации.
MessageQueueInternal Ожидание подключения друго-
го процесса к общей очереди со-
общений.
MessageQueuePutMessage Ожидание записи сообщения
протокола в общую очередь со-
общений.
MessageQueueReceive Ожидание получения байтов из
общей очереди сообщений.
MessageQueueSend Ожидание передачи байтов в
общую очередь сообщений.
ParallelBitmapScan Ожидание инициализации па-
раллельного сканирования по
битовой карте.
ParallelCreateIndexScan Ожидание завершения скани-
рования кучи параллельными
исполнителями CREATE INDEX.
ParallelFinish Ожидание завершения вычис-
лений параллельными рабочи-
ми процессами.
ProcArrayGroupUpdate Ожидание очистки ведущим
группы идентификатора тран-
закции в конце транзакции.
ReplicationOriginDrop Ожидание перехода источника
репликации в неактивное состо-
яние для последующего удале-
ния.
ReplicationSlotDrop Ожидание перехода слота ре-
пликации в неактивное состо-
яние для последующего удале-
ния.
SafeSnapshot Ожидание снимка для транзак-
ции READ ONLY DEFERRABLE.
SyncRep Ожидание подтверждения от
удалённого сервера при син-
хронной репликации.
BaseBackupThrottle Ожидание в процессе базового
резервного копирования из-за
ограничения активности.
PgSleep Ожидание в процессе, вызвав-
шем pg_sleep .
RecoveryApplyDelay Ожидание применения WAL
при восстановлении из-за за-
держки.
BufFileRead Ожидание чтения из буферизо-
ванного файла.
691Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
BufFileWrite Ожидание записи в буферизо-
ванный файл.
ControlFileRead Ожидание чтения из управляю-
щего файла.
ControlFileSync Ожидание помещения управля-
ющего файла в надёжное храни-
лище.
ControlFileSyncUpdate Ожидание переноса изменений
управляющего файла в надёж-
ное хранилище.
ControlFileWrite Ожидание записи в управляю-
щий файл.
ControlFileWriteUpdate Ожидание записи для измене-
ния управляющего файла.
CopyFileRead Ожидание чтения во время опе-
рации копирования файла.
CopyFileWrite Ожидание записи во время опе-
рации копирования файла.
DataFileExtend Ожидание расширения файла
данных отношения.
DataFileFlush Ожидание помещения файла
данных отношения в надёжное
хранилище.
DataFileImmediateSync Ожидание немедленной син-
хронизации файла данных от-
ношения с надёжным хранили-
щем.
DataFilePrefetch Ожидание асинхронной пред-
выборки из файла данных отно-
шения.
DataFileRead Ожидание чтения из файла дан-
ных отношения.
DataFileSync Ожидание переноса изменений
в файле данных отношений в на-
дёжное хранилище.
DataFileTruncate Ожидание усечения файла дан-
ных отношения.
DataFileWrite Ожидание записи в файл дан-
ных отношения.
DSMFillZeroWrite Ожидание записи нулевых байт
в файл, поддерживающий рабо-
ту динамической общей памя-
ти.
LockFileAddToDataDirRead Ожидание чтения при добавле-
нии строки в файл блокировки
каталога данных.
LockFileAddToDataDirSync Ожидание помещения данных
в надёжное хранилище при до-
692Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
бавлении строки в файл блоки-
ровки каталога данных.
LockFileAddToDataDirWrite Ожидание записи при добавле-
нии строки в файл блокировки
каталога данных.
LockFileCreateRead Ожидание чтения при созда-
нии файла блокировки каталога
данных.
LockFileCreateSync Ожидание помещения данных
в надёжное хранилище при со-
здании файла блокировки ката-
лога данных.
LockFileCreateWrite Ожидание записи при созда-
нии файла блокировки каталога
данных.
LockFileReCheckDataDirRead Ожидание чтения во время пе-
репроверки файла блокировки
каталога данных.
LogicalRewriteCheckpointSync Ожидание помещения отобра-
жений логической перезаписи
в надёжное хранилище во время
контрольной точки.
LogicalRewriteMappingSync Ожидание помещения данных
отображений в надёжное хра-
нилище в процессе логической
перезаписи.
LogicalRewriteMappingWrite Ожидание записи данных отоб-
ражений в процессе логической
перезаписи.
LogicalRewriteSync Ожидание помещения отобра-
жений логической перезаписи
в надёжное хранилище.
LogicalRewriteWrite Ожидание сохранения отобра-
жений логической перезаписи.
RelationMapRead Ожидание чтения файла отоб-
ражений отношений.
RelationMapSync Ожидание помещения файла
отображений отношений в на-
дёжное хранилище.
RelationMapWrite Ожидание записи в файл отоб-
ражений отношений.
ReorderBufferRead Ожидание чтения при работе с
буфером переупорядочивания.
ReorderBufferWrite Ожидание записи при работе с
буфером переупорядочивания.
ReorderLogicalMappingRead Ожидание чтения логического
отображения при работе с буфе-
ром переупорядочивания.
693Мониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
ReplicationSlotRead Ожидание чтения из управляю-
щего файла слота репликации.
ReplicationSlotRestoreSync Ожидание помещения в надёж-
ное хранилище управляющего
файла слота репликации при
восстановлении его в памяти.
ReplicationSlotSync Ожидание помещения в надёж-
ное хранилище управляющего
файла слота репликации.
ReplicationSlotWrite Ожидание записи в управляю-
щий файл слота репликации.
SLRUFlushSync Ожидание помещения данных
SLRU в надёжное хранилище во
время контрольной точки или
отключения базы данных.
SLRURead Ожидание
SLRU.
SLRUSync Ожидание помещения данных
SLRU в надёжное хранилище
после записи страницы.
SLRUWrite Ожидание
SLRU.
SnapbuildRead Ожидание чтения сериализо-
ванного исторического снимка
каталога БД.
SnapbuildSync Ожидание помещения сериали-
зованного исторического сним-
ка каталога БД в надёжное хра-
нилище.
SnapbuildWrite Ожидание записи сериализо-
ванного исторического снимка
каталога БД.
TimelineHistoryFileSync Ожидание помещения в надёж-
ное хранилище файла истории
линии времени, полученного
через потоковую репликацию.
TimelineHistoryFileWrite Ожидание записи файла исто-
рии линии времени, получен-
ного через потоковую реплика-
цию.
TimelineHistoryRead Ожидание чтения файла исто-
рии линии времени.
TimelineHistorySync Ожидание помещения в надёж-
ное хранилище только что со-
зданного файла истории линии
времени.
TimelineHistoryWrite Ожидание записи только что со-
зданного файла истории линии
времени.
694
чтения
записи
страницы
страницыМониторинг работы СУБД
Тип события ожидания
Название
ния
события
ожида- Описание
TwophaseFileRead Ожидание чтения файла двух-
фазного состояния.
TwophaseFileSync Ожидание помещения файла
двухфазного состояния в на-
дёжное хранилище.
TwophaseFileWrite Ожидание записи файла двух-
фазного состояния.
WALBootstrapSync Ожидание помещения WAL в
надёжное хранилище в процес-
се начальной загрузки.
WALBootstrapWrite Ожидание записи страницы
WAL в процессе начальной за-
грузки.
WALCopyRead Ожидание чтения при создании
нового сегмента WAL путём ко-
пирования существующего.
WALCopySync Ожидание помещения в надёж-
ное хранилище нового сегмента
WAL, созданного путём копиро-
вания существующего.
WALCopyWrite Ожидание записи при создании
нового сегмента WAL путём ко-
пирования существующего.
WALInitSync Ожидание помещения в надёж-
ное хранилище нового инициа-
лизированного файла WAL.
WALInitWrite Ожидание записи при инициа-
лизации нового файла WAL.
WALRead Ожидание
WAL.
чтения
из
файла
WALSenderTimelineHistoryRead Ожидание чтения из файла ис-
тории линии времени при обра-
ботки процессом walsender ко-
манды timeline.
WALSyncMethodAssign Ожидание помещения данных в
надёжное хранилище при смене
метода синхронизации WAL.
WALWrite Ожидание записи в файл WAL.
Примечание
Для траншей, регистрируемых расширениями, в поле wait_event выводится имя, ука-
зываемое расширением. Пользователь вполне может зарегистрировать транш и в об-
служивающем процессе (воспользовавшись динамической общей памятью), в резуль-
тате чего другие процессы не получат доступа к этой информации; в таких случаях в
этом поле выводится extension.
Следующая команда показывает, как можно просмотреть события ожидания:
695Мониторинг работы СУБД
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT
NULL;
pid | wait_event_type | wait_event
——+—————–+—————
2540 | Lock
| relation
6644 | LWLock
| ProcArrayLock
(2 rows)
Таблица 28.5. Представление pg_stat_replication
Столбец Тип Описание
pid integer Идентификатор процесса-пере-
датчика WAL
usesysid oid OID пользователя, подключён-
ного к этому процессу-передат-
чику WAL
usename name Имя пользователя, подключён-
ного к этому процессу-передат-
чику WAL
application_name text Имя приложения, которое под-
ключено к этому процессу-пере-
датчику WAL
client_addr inet IP-адрес клиента, подключённо-
го к этому процессу-передатчи-
ку WAL. Значение null в этом
поле говорит о том, что клиент
подсоединён через сокет Unix
на сервере.
client_hostname text Имя компьютера для подклю-
чённого клиента, получаемое в
результате обратного поиска в
DNS по client_addr . Это поле
будет отлично от null только в
случае соединений по IP и толь-
ко при включённом режиме log_
hostname.
client_port integer Номер TCP-порта, который ис-
пользуется клиентом для вза-
имодействия с процессом-пере-
датчиком WAL, или -1, если ис-
пользуется сокет Unix
backend_start timestamp with time zone Время запуска процесса, т. е.
время подключения клиента
к этому процессу-передатчику
WAL
backend_xmin xid Значение xmin, полученное от
ведомого сервера при включён-
ном hot_standby_feedback.
state text Текущее состояние процес-
са-передатчика WAL. Возмож-
ные значения:
• startup: Передатчик WAL
запускается.
696Мониторинг работы СУБД
Столбец
Тип
Описание
• catchup: Подключённый к
этому передатчику WAL ве-
домый сервер догоняет веду-
щий.
• streaming: Передатчик WAL
транслирует изменения по-
сле того, как подключённый
к нему ведомый сервер на-
гнал ведущий.
• backup: Передатчик WAL пе-
редаёт резервную копию.
• stopping: Передатчик WAL
останавливается.
sent_lsn pg_lsn Последняя позиция в журнале
предзаписи, переданная через
это соединение
write_lsn pg_lsn Последняя позиция в журна-
ле предзаписи, записанная на
диск этим ведомым сервером
flush_lsn pg_lsn Последняя позиция в журна-
ле предзаписи, сброшенная на
диск этим ведомым сервером
replay_lsn pg_lsn Последняя позиция в журнале
предзаписи, воспроизведённая
в базе данных этим ведомым
сервером
write_lag interval Время, прошедшее с момента
локального сброса последних
данных WAL до получения уве-
домления о том, что этот ве-
домый сервер записал их (но
ещё не сбросил на диск и не
применил). Это позволяет оце-
нить задержку, возникающую
при фиксации транзакции, ко-
гда в synchronous_commit вы-
бран уровень remote_write , ес-
ли данный сервер будет настро-
ен как синхронный ведомый.
flush_lag interval Время, прошедшее с момента
локального сброса последних
данных WAL до получения уве-
домления о том, что этот ве-
домый сервер записал и сбро-
сил их на диск (но ещё не
применил). Это позволяет оце-
нить задержку, возникающую
при фиксации транзакции, ко-
гда в synchronous_commit вы-
бран уровень remote_flush , ес-
ли данный сервер будет настро-
ен как синхронный ведомый.
697Мониторинг работы СУБД
Столбец Тип Описание
replay_lag interval Время, прошедшее с момен-
та локального сброса послед-
них данных WAL до получе-
ния уведомления о том, что
этот ведомый сервер записал,
сбросил на диск и приме-
нил их. Это позволяет оце-
нить задержку, возникающую
при фиксации транзакции, ко-
гда в synchronous_commit вы-
бран уровень remote_apply , ес-
ли данный сервер будет настро-
ен как синхронный ведомый.
sync_priority integer Приоритет этого ведомого сер-
вера для выбора в качестве
синхронного ведомого при син-
хронной репликации с учётом
приоритетов. При синхронной
репликации с учётом кворума
не имеет значения.
sync_state text Состояние синхронизации это-
го ведомого сервера. Возмож-
ные значения:
• async: Этот ведомый сервер
является асинхронным.
• potential: Этот ведомый
сервер сейчас является
асинхронным, но может
стать синхронным в случае
отказа одного из текущих
синхронных серверов.
• sync: Этот ведомый сервер
является синхронным.
• quorum: Этот ведомый сер-
вер считается кандитатом
на участие в кворуме.
Представление pg_stat_replication для каждого процесса-передатчика WAL будет содержать по
одной строке со статистикой о репликации на ведомый сервер, к которому подключён этот про-
цесс. В представлении перечисляются только ведомые серверы, подключённые напрямую; инфор-
мация о ведомых серверах, подключённых опосредованно, не представлена.
Длительность задержек, показываемая в представлении pg_stat_replication, включает время,
которое потребовалось для того, чтобы записать, сбросить на диск и воспроизвести последние за-
писи WAL и для того, чтобы передатчик WAL узнал об этом. Эта длительность отражает задерж-
ку фиксации, которая была (или могла быть) добавлена на уровнях синхронной фиксации, если
ведомый сервер был настроен как синхронный. Для асинхронного ведомого в столбце replay_lag
показывается примерная задержка перед тем, как последние транзакции становятся видны для
запросов. Если ведомый сервер нагоняет передающий и в WAL отсутствует активность, последние
длительности задержек будут отображаться ещё некоторое время, а затем сменятся на NULL.
Длительность задержек автоматически определяется при физической репликации. Модули логи-
ческого декодирования могут не выдавать необходимые контрольные сообщения; в их отсутствие
механизм отслеживания просто выводит задержку NULL.
698Мониторинг работы СУБД
Примечание
Выдаваемые длительности задержек не являются предсказанием времени, которое по-
требуется ведомому серверу, чтобы нагнать передающий сервер с учётом текущей ско-
рости воспроизведения. Эти показатели будут близки в процессе генерирования ново-
го WAL, но не в то время, когда передающий сервер будет простаивать. В частности,
когда ведомый сервер нагоняет ведущий, в pg_stat_replication показывается, сколь-
ко времени потребовалось для записи, сброса на диск и воспроизведения последних
данных WAL, а не 0, как могли ожидать некоторые пользователи. Это соответствует
задаче измерения задержек синхронной фиксации и видимости транзакций для недав-
но записанных транзакций. Чтобы меньше смущать пользователей, ожидающих видеть
другую модель задержек, столбцы задержек сбрасываются в NULL после небольшой
паузы в системе, которая воспроизвела все изменения и теперь простаивает. Системы
мониторинга могут представлять это как отсутствующие данные, 0 или продолжать
показывать последнее известное значение.
Таблица 28.6. Представление pg_stat_wal_receiver
Столбец Тип Описание
pid integer Идентификатор процесса WAL-
приёмника
status text Состояние активности процесса
WAL-приёмника
receive_start_lsn pg_lsn Первая позиция в журнале
предзаписи в момент запуска
приёмника WAL
receive_start_tli integer Первый номер линии времени
в момент запуска приёмника
WAL
received_lsn pg_lsn Последняя позиция в журнале
предзаписи, уже полученная и
сброшенная на диск; началь-
ным значением этого поля бу-
дет первая позиция в журна-
ле в момент запуска приёмника
WAL
received_tli integer Номер линии времени послед-
ней позиции в журнале предза-
писи, уже полученной и сбро-
шенной на диск; начальным
значением этого поля будет но-
мер линии времени первой по-
зиции в момент запуска приём-
ника WAL
last_msg_send_time timestamp with time zone Время отправки последнего со-
общения, полученного от изна-
чального передатчика WAL
last_msg_receipt_time timestamp with time zone Время поступления последнего
сообщения, полученного от из-
начального передатчика WAL
latest_end_lsn pg_lsn Последняя позиция в журнале
предзаписи, сообщённая изна-
чальному передатчику WAL
699Мониторинг работы СУБД
Столбец Тип Описание
latest_end_time timestamp with time zone Время последней позиции в
журнале предзаписи, сообщён-
ной изначальному передатчику
WAL
slot_name text Имя слота репликации, исполь-
зуемого этим приёмником WAL
sender_host text Узел, где работает сервер
PostgreSQL,
обслуживающий
данный приёмник WAL. Может
задаваться именем или IP-адре-
сом компьютера либо путём ка-
талога (если подключение уста-
новлено через сокет Unix). (
Подключение к сокету легко
распознать, потому что путь
всегда абсолютный и начинает-
ся с /.)
sender_port integer Номер
порта
сервера
PostgreSQL, к которому подклю-
чён этот приёмник WAL.
conninfo text Строка подключения, использу-
емая этим приёмником WAL (
секретные поля в ней скрыты).
Представление pg_stat_wal_receiver будет иметь только одну строку со статистикой приёмника
WAL от сервера, на котором работает приёмник.
Таблица 28.7. Представление pg_stat_subscription
Столбец Тип Описание
subid oid OID подписки
subname text Имя подписки
pid integer Идентификатор рабочего про-
цесса, обслуживающего под-
писку
relid Oid OID отношения, которое син-
хронизирует рабочий процесс
сейчас; null для основного про-
цесса применения изменений
received_lsn pg_lsn Последняя позиция в журнале
предзаписи (начальное значе-
ние этого поля — 0)
last_msg_send_time timestamp with time zone Время отправки последнего со-
общения, полученного от изна-
чального передатчика WAL
last_msg_receipt_time timestamp with time zone Время поступления последнего
сообщения, полученного от из-
начального передатчика WAL
latest_end_lsn pg_lsn Последняя позиция в журнале
предзаписи, сообщённая изна-
чальному передатчику WAL
700Мониторинг работы СУБД
Столбец Тип Описание
latest_end_time timestamp with time zone Время последней позиции в
журнале предзаписи, сообщён-
ной изначальному передатчику
WAL
Представление pg_stat_subscription содержит по одной строке для подписки для основного ра-
бочего процесса (с NULL в PID, если процесс не работает) и дополнительные строки для рабочих
процессов, осуществляющих копирование начальных данных для таблиц в подписке.
Таблица 28.8. Представление pg_stat_ssl
Столбец Тип Описание
pid integer Идентификатор
обслуживаю-
щего процесса или процесса,
передающего WAL
ssl boolean True, если для этого подключе-
ния используется SSL
version text Версия SSL либо NULL, если
SSL для этого подключения не
используется
cipher text Имя применяемого шифра SSL
либо NULL, если SSL для этого
подключения не используется
bits integer Число бит в применяемом алго-
ритме шифрования либо NULL,
если SSL для этого подключе-
ния не используется
compression boolean True, если применяется сжатие
SSL, false в противном случае,
либо NULL, если SSL для этого
подключения не используется
clientdn text Поле DN (Distinguished Name,
Уникальное имя) из используе-
мого клиентского сертификата
либо NULL, если клиент не пе-
редал сертификат или SSL для
этого подключения не исполь-
зуется. Это значение усекает-
ся, если поле DN оказывает-
ся длиннее NAMEDATALEN симво-
лов (64 символов в стандартной
сборке)
Представление pg_stat_ssl содержит по одной строке для каждого обслуживающего процесса
и процесса, передающего WAL, и показывает статистику использования SSL для подключений.
Его можно соединить с pg_stat_activity или pg_stat_replication по столбцу pid и получить
дополнительные сведения о подключении.
Таблица 28.9. Представление pg_stat_archiver
Столбец Тип Описание
archived_count bigint Число файлов WAL, которые бы-
ли успешно архивированы
701Мониторинг работы СУБД
Столбец Тип Описание
last_archived_wal text Имя последнего файла WAL
успешно архивированного
last_archived_time timestamp with time zone Время последней успешной ар-
хивации
failed_count bigint Число неудачных попыток архи-
вации файлов WAL
last_failed_wal text Имя файла WAL последней
неудавшейся архивации
last_failed_time timestamp with time zone Время последней неудавшейся
архивации
stats_reset timestamp with time zone Последнее время сброса этих
статистических данных
Представление pg_stat_archiver всегда будет иметь одну строку, содержащую данные о текущем
состоянии процесса архивации кластера.
Таблица 28.10. Представление pg_stat_bgwriter
Столбец Тип Описание
checkpoints_timed bigint Количество запланированных
контрольных точек, которые
уже были выполнены
checkpoints_req bigint Количество запрошенных кон-
трольных точек, которые уже
были выполнены
checkpoint_write_time double precision Общее время, которое было за-
трачено на этап обработки кон-
трольной точки, в котором фай-
лы записываются на диск, в
миллисекундах
checkpoint_sync_time double precision Общее время, которое было за-
трачено на этап обработки кон-
трольной точки, в котором фай-
лы синхронизируются с диском,
в миллисекундах
buffers_checkpoint bigint Количество буферов, записан-
ных при выполнении контроль-
ных точек
buffers_clean bigint Количество буферов, записан-
ных фоновым процессом записи
maxwritten_clean bigint Сколько раз фоновый про-
цесс записи останавливал сброс
грязных страниц на диск из-за
того, что записал слишком мно-
го буферов
buffers_backend bigint Количество буферов, записан-
ных самим серверным процес-
сом
buffers_backend_fsync bigint Сколько раз серверному про-
цессу
пришлось
выполнить
fsync самостоятельно (обычно
702Мониторинг работы СУБД
Столбец Тип Описание
фоновый процесс записи сам об-
рабатывает эти вызовы, даже
когда серверный процесс вы-
полняет запись самостоятель-
но)
buffers_alloc bigint Количество выделенных буфе-
ров
stats_reset timestamp with time zone Последнее время сброса этих
статистических данных
В представлении pg_stat_bgwriter всегда будет только одна строка, в которой будут представлены
общие данные по всему кластеру.
Таблица 28.11. Представление pg_stat_database
Столбец Тип Описание
datid oid OID базы данных
datname name Имя базы данных
numbackends integer Количество серверных процес-
сов, в настоящее время подклю-
чённых к этой базе данных. Это
единственный столбец в этом
представлении, значение в ко-
тором отражает текущее состо-
яние; все другие столбцы воз-
вращают суммарные значения
со времени последнего сброса
статистики.
xact_commit bigint Количество зафиксированных
транзакций в этой базе данных
xact_rollback bigint Количество транзакций в этой
базе данных, для которых был
выполнен откат транзакции
blks_read bigint Количество прочитанных дис-
ковых блоков в этой базе данных
blks_hit bigint Сколько раз дисковые блоки об-
наруживались в буферном ке-
ше, так что чтение с диска не
потребовалось (в значение вхо-
дят только случаи обнаружения
в буферном кеше PostgreSQL,
а не в кеше файловой системы
ОС)
tup_returned bigint Количество строк, возвращён-
ное запросами в этой базе дан-
ных
tup_fetched bigint Количество строк, извлечённое
запросами в этой базе данных
tup_inserted bigint Количество строк, вставленное
запросами в этой базе данных
tup_updated bigint Количество строк, изменённое
запросами в этой базе данных
703Мониторинг работы СУБД
Столбец Тип Описание
tup_deleted bigint Количество строк, удалённое
запросами в этой базе данных
conflicts bigint Количество запросов, отменён-
ных из-за конфликта с восста-
новлением в этой базе данных.
(Конфликты происходят толь-
ко на ведомых серверах; бо-
лее подробно смотрите pg_stat_
database_conflicts.)
temp_files bigint Количество временных файлов,
созданных запросами в этой ба-
зе данных. Подсчитываются все
временные файлы независимо
от причины их создания (напри-
мер, для сортировки или для
хеширования) и независимо от
установленного значения log_
temp_files
temp_bytes bigint Общий объём данных, записан-
ных во временные файлы запро-
сами в этой базе данных. Учиты-
ваются все временные файлы,
вне зависимости от того, по ка-
кой причине они созданы и вне
зависимости от значения log_
temp_files.
deadlocks bigint Количество взаимных блокиро-
вок, зафиксированное в этой ба-
зе данных
blk_read_time double precision Время, затраченное серверны-
ми процессами в этой базе дан-
ных, на чтение блоков из фай-
лов данных, в миллисекундах
blk_write_time double precision Время, затраченное серверны-
ми процессами в этой базе дан-
ных, на запись блоков в файлы
данных, в миллисекундах
stats_reset timestamp with time zone Последнее время сброса этих
статистических данных
Представление pg_stat_database содержит одну строку со статистикой на каждую базу данных
кластера.
Таблица 28.12. Представление pg_stat_database_conflicts
Столбец Тип Описание
datid oid OID базы данных
datname name Имя базы данных
confl_tablespace bigint Количество запросов в этой ба-
зе данных, отменённых из-за то-
го, что табличные пространства
были удалены
704Мониторинг работы СУБД
Столбец Тип Описание
confl_lock bigint Количество запросов в этой ба-
зе данных, отменённых по исте-
чении времени ожидания бло-
кировки
confl_snapshot bigint Количество запросов в этой ба-
зе данных, отменённых из-за
устаревших снимков данных
confl_bufferpin bigint Количество запросов в этой ба-
зе данных, отменённых из-за
прикреплённых страниц буфера
confl_deadlock bigint Количество запросов в этой ба-
зе данных, отменённых из-за
взаимных блокировок
Представление pg_stat_database_conflicts для каждой базы данных будет содержать по одной
строке со статистикой на уровне базы по отменам запросов, произошедшим вследствие конфлик-
тов с процессами восстановления на ведомых серверах. В этом представлении будет содержаться
только информация по ведомым серверам, поскольку на главных серверах конфликты не возника-
ют.
Таблица 28.13. Представление pg_stat_all_tables
Столбец Тип Описание
relid oid OID таблицы
schemaname name Имя схемы, в которой располо-
жена эта таблица
relname name Имя таблицы
seq_scan bigint Количество последовательных
чтений, запущенных по этой
таблице
seq_tup_read bigint Количество “живых” строк, про-
читанных при последователь-
ных чтениях
idx_scan bigint Количество сканирований по
индексу, запущенных по этой
таблице
idx_tup_fetch bigint Количество “живых” строк, ото-
бранных при сканированиях по
индексу
n_tup_ins bigint Количество вставленных строк
n_tup_upd bigint Количество изменённых строк
(включая изменения по схеме
HOT)
n_tup_del bigint Количество удалённых строк
n_tup_hot_upd bigint Количество строк, обновлённых
в режиме HOT (т. е. без отдель-
ного изменения индекса)
n_live_tup bigint Оценочное количество “живых”
строк
n_dead_tup bigint Оценочное количество “мёрт-
вых” строк
705Мониторинг работы СУБД
Столбец Тип Описание
n_mod_since_analyze bigint Оценочное число строк, изме-
нённых в этой таблице, с момен-
та последнего сбора статистики
last_vacuum timestamp with time zone Время последней очистки этой
таблицы вручную (VACUUM FULL
не учитывается)
last_autovacuum timestamp with time zone Время последней очистки таб-
лицы фоновым процессом авто-
очистки
last_analyze timestamp with time zone Время последнего выполнения
сбора статистики для этой таб-
лицы вручную
last_autoanalyze timestamp with time zone Время последнего выполнения
сбора статистики для этой таб-
лицы фоновым процессом авто-
очистки
vacuum_count bigint Сколько раз очистка этой таб-
лицы была выполнена вручную
(VACUUM FULL не учитывается)
autovacuum_count bigint Сколько раз очистка этой таб-
лицы была выполнена фоновым
процессом автоочистки
analyze_count bigint Сколько раз сбор статистики
для этой таблицы был выполнен
вручную
autoanalyze_count bigint Сколько раз сбор статистики
для этой таблицы был выполнен
фоновым процессом автоочист-
ки
Представление pg_stat_all_tables будет содержать по одной строке на каждую таблицу в теку-
щей базе данных (включая таблицы TOAST) со статистикой по обращениям к этой таблице. Пред-
ставления pg_stat_user_tables и pg_stat_sys_tables содержат ту же самую информацию, но от-
фильтрованную так, чтобы показывать только пользовательские и системные таблицы соответ-
ственно.
Таблица 28.14. Представление pg_stat_all_indexes
Столбец Тип Описание
relid oid OID таблицы для индекса
indexrelid oid OID индекса
schemaname name Имя схемы, в которой располо-
жен индекс
relname name Имя таблицы для индекса
indexrelname name Имя индекса
idx_scan bigint Количество запущенных скани-
рований по этому индексу
idx_tup_read bigint Количество элементов индекса,
возвращённых при сканирова-
ниях по этому индексу
706Мониторинг работы СУБД
Столбец Тип Описание
idx_tup_fetch bigint Количество живых строк таб-
лицы, отобранных при простых
сканированиях по этому индек-
су
Представление pg_stat_all_indexes для каждого индекса в текущей базе данных будет со-
держать по одной строке со статистикой по обращениям к этому индексу. Представления
pg_stat_user_indexes и pg_stat_sys_indexes содержат ту же самую информацию, но отфильтро-
ванную так, чтобы показывать только пользовательские и системные индексы соответственно.
Индексы могут использоваться при простом сканировании по индексу, при сканировании «бито-
вой карты» индекса и в работе оптимизатора. Результаты сканирования битовых карт разных ин-
дексов могут объединяться логическим умножением или сложением, поэтому когда применяются
битовые карты, сложно связать выборки отдельных строк с определёнными индексами. Поэтому
при сканировании битовых карт увеличиваются счётчики pg_stat_all_indexes.idx_tup_read для
задействованных индексов и счётчик pg_stat_all_tables.idx_tup_fetch для каждой таблицы, а
pg_stat_all_indexes.idx_tup_fetch не меняется. Оптимизатор тоже обращается к индексам для
проверки переданных констант, значения которых оказываются вне диапазона, записанного в ста-
тистике оптимизатора, так как эта статистика может быть неактуальной.
Примечание
Значения счётчиков idx_tup_read и idx_tup_fetch могут различаться, даже если ска-
нирование с использованием битовой карты не используется, поскольку idx_tup_read
подсчитывает полученные из индекса элементы, а idx_tup_fetch — количество “жи-
вых” строк, выбранных из таблицы. Различие будет меньше, если “мёртвые” или ещё
незафиксированные строки будут извлекаться с использованием индекса или если для
получения строк таблицы будет использоваться сканирование только по индексу.
Таблица 28.15. Представление pg_statio_all_tables
Столбец Тип Описание
relid oid OID таблицы
schemaname name Имя схемы, в которой располо-
жена эта таблица
relname name Имя таблицы
heap_blks_read bigint Количество дисковых блоков,
прочитанных из этой таблицы
heap_blks_hit bigint Число попаданий в буфер для
этой таблицы
idx_blks_read bigint Количество дисковых блоков,
прочитанных из всех индексов
этой таблицы
idx_blks_hit bigint Число попаданий в буфер для
всех индексов по этой таблице
toast_blks_read bigint Количество прочитанных дис-
ковых блоков TOAST (если есть)
для этой таблицы
toast_blks_hit bigint Число попаданий в буфер в таб-
лице TOAST для этой таблицы (
если такие есть)
tidx_blks_read bigint Количество прочитанных дис-
ковых блоков из индекса по
707Мониторинг работы СУБД
Столбец Тип Описание
TOAST (если есть) для этой таб-
лицы
tidx_blks_hit bigint Число попаданий в буфер для
индекса по TOAST (если есть)
для этой таблицы
Представление pg_statio_all_tables для каждой таблицы (включая таблицы TOAST) в текущей
базе данных будет содержать по одной строке со статистикой по операциям ввода/вывода для этой
таблицы. Представления pg_statio_user_tables и pg_statio_sys_tables содержат ту же самую
информацию, но отфильтрованную так, чтобы показывать только пользовательские или системные
таблицы соответственно.
Таблица 28.16. Представление pg_statio_all_indexes
Столбец Тип Описание
relid oid OID таблицы для индекса
indexrelid oid OID индекса
schemaname name Имя схемы, в которой располо-
жен индекс
relname name Имя таблицы для индекса
indexrelname name Имя индекса
idx_blks_read bigint Количество дисковых блоков,
прочитанных из этого индекса
idx_blks_hit bigint Число попаданий в буфер для
этого индекса
Представление pg_statio_all_indexes для каждого индекса в текущей базе данных будет содер-
жать по одной строке со статистикой по операциям ввода/вывода для этого индекса. Представле-
ния pg_statio_user_indexes и pg_statio_sys_indexes содержат ту же самую информацию, но от-
фильтрованную так, чтобы показывать только пользовательские или системные индексы соответ-
ственно.
Таблица 28.17. Представление pg_statio_all_sequences
Столбец Тип Описание
relid oid OID последовательности
schemaname name Имя схемы, в которой располо-
жена эта последовательность
relname name Имя последовательности
blks_read bigint Количество дисковых блоков,
прочитанных из этой последо-
вательности
blks_hit bigint Число попаданий в буфер в этой
последовательности
Представление pg_statio_all_sequences для каждой последовательности в текущей базе данных
будет содержать по одной строке со статистикой по операциям ввода/вывода для этой последова-
тельности.
Таблица 28.18. Представление pg_stat_user_functions
Столбец Тип Описание
funcid oid OID функции
708Мониторинг работы СУБД
Столбец Тип Описание
schemaname name Имя схемы, в которой располо-
жена функция
funcname name Имя функции
calls bigint Сколько раз вызывалась функ-
ция
total_time double precision Общее время, потраченное на
выполнение этой функции и
всех других функций, вызван-
ных ею, в миллисекундах
self_time double precision Общее время, потраченное на
выполнение самой функции, без
учёта других функций, которые
были ею вызваны, в миллисе-
кундах
Представление pg_stat_user_functions для каждой отслеживаемой функции будет содержать по
одной строке со статистикой по выполнениям этой функции. Отслеживаемые функции определя-
ются параметром track_functions.
28.2.3. Статистические функции
Статистическую информацию можно просматривать и другими способами. Для этого можно напи-
сать запросы, использующие те же функции доступа к статистике, что лежат в основе описанных
выше стандартных представлений. За более подробной информацией, например, об именах этих
функций, обратитесь к определениям этих стандартных представлений. (Например, в psql мож-
но выполнить \d+ pg_stat_activity.) В качестве аргумента функции, предоставляющие доступ к
статистике на уровне базы, принимают OID базы данных, по которой должна быть выдана инфор-
мация. Функции, которые работают на уровне таблиц и индексов, принимают в качестве аргумен-
та OID таблицы или индекса. Аргументом для функции, предоставляющей статистику на уровне
функций, является OID функции. Обратите внимание, что с помощью этих функций можно полу-
чить информацию по таблицам, индексам и функциям исключительно в текущей базе данных.
Дополнительные функции, связанные со сбором статистики, перечислены в Таблице 28.19.
Таблица 28.19. Дополнительные статистические функции
Функция Тип результата Описание
pg_backend_pid() integer Идентификатор
серверного
процесса, выполняющего теку-
щую сессию
setof record Возвращает запись с информа-
цией о серверном процессе с за-
данным PID или по одной стро-
ке для каждого активного сер-
верного процесса в системе, ес-
ли был указан NULL. Возвраща-
емые поля являются подмноже-
ством столбцов представления
pg_stat_activity .
pg_stat_get_snapshot_
timestamp() timestamp with time zone Возвращает время снимка теку-
щей статистики
pg_stat_clear_snapshot() void Сбросить текущий снимок ста-
тистики
pg_stat_reset() void Сбросить в ноль все статисти-
ческие счётчики в текущей ба-
pg_stat_get_activity
integer)
(
709Мониторинг работы СУБД
Функция
Тип результата Описание
зе данных (по умолчанию раз-
решено только суперпользова-
телям, но право выполнения (
EXECUTE) этой функции можно
дать и другим)
void Сбросить в ноль некоторые ста-
тистические счётчики на уров-
не кластера, в зависимости
от заданного аргумента (по
умолчанию разрешено только
суперпользователям, но право
выполнения (EXECUTE) этой
функции можно дать и дру-
гим). Вызов pg_stat_reset_
shared(‘bgwriter’)
сбросит
в ноль все счётчики, которые
показываются в представле-
нии pg_stat_bgwriter , а вы-
зов pg_stat_reset_shared(
‘archiver’)
— все счётчи-
ки в представлении pg_stat_
archiver .
pg_stat_reset_single_
table_counters (oid) void Сбросить в ноль статистику по
отдельной таблице или индексу
в текущей базе данных (по умол-
чанию разрешено только супер-
пользователям, но право выпол-
нения (EXECUTE) этой функции
можно дать и другим)
pg_stat_reset_single_
function_counters (oid) void Сбросить в ноль статистику по
отдельной функции в текущей
базе данных (по умолчанию раз-
решено только суперпользова-
телям, но право выполнения (
EXECUTE) этой функции можно
дать и другим)
pg_stat_reset_shared
text)
(
Функция pg_stat_get_activity, на которой основано представление pg_stat_activity, возвраща-
ет набор строк, содержащих всю доступную информацию о каждом серверном процессе. Иногда
более удобным оказывается получение только части этой информации. В таких случаях можно
использовать набор более старых функций, дающих доступ к статистике на уровне серверных про-
цессов; эти функции описаны в Таблице 28.20. Эти функции используют идентификатор серверно-
го процесса, значение которого варьируется от единицы до числа активных в настоящий момент
серверных процессов. Функция pg_stat_get_backend_idset генерирует по одной строке для каж-
дого активного серверного процесса, что необходимо для вызова этих функций. Например, для то-
го, чтобы отобразить значения PID и текущие запросы всех серверных процессов:
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
pg_stat_get_backend_activity(s.backendid) AS query
FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
Таблица 28.20. Статистические функции на уровне серверных процессов
Функция Тип результата Описание
pg_stat_get_backend_
idset() setof integer Набор значений идентификато-
ров активных в настоящий мо-
710Мониторинг работы СУБД
Функция Тип результата Описание
мент серверных процессов (от
1 до числа активных серверных
процессов)
pg_stat_get_backend_
activity(integer) text Текст последнего запроса этого
серверного процесса
pg_stat_get_backend_
activity_start(integer) timestamp with time zone Время запуска последнего за-
проса
pg_stat_get_backend_
client_addr(integer) inet IP-адрес клиента, подключённо-
го к этому серверному процессу
pg_stat_get_backend_
client_port(integer) integer Номер TCP-порта, который кли-
ент использует для взаимодей-
ствия
pg_stat_get_backend_
dbid(integer) oid OID базы данных, к которой под-
ключён этот серверный процесс
pg_stat_get_backend_pid(
integer) integer Идентификатор процесса этого
серверного процесса
pg_stat_get_backend_
start(integer) timestamp with time zone Время запуска этого процесса
pg_stat_get_backend_
userid(integer) oid OID пользователя, подключён-
ного к этому серверному про-
цессу
pg_stat_get_backend_
wait_event_type(integer) text Имя типа ожидаемого события,
если обслуживающий процесс
находится в состоянии ожида-
ния, а в противном случае —
NULL. За подробностями обра-
титесь к Таблице 28.4.
pg_stat_get_backend_
wait_event(integer) text Имя ожидаемого события, ес-
ли обслуживающий процесс на-
ходится в состоянии ожидания,
а в противном случае — NULL.
За подробностями обратитесь к
Таблице 28.4.
pg_stat_get_backend_
xact_start(integer) timestamp with time zone Время начала текущей транзак-
ции
28.3. Просмотр информации о блокировках
Ещё одним удобным средством для отслеживания работы базы данных является системная таб-
лица pg_locks. Она позволяет администратору базы просматривать информацию об имеющихся
блокировках в менеджере блокировок. Например, это может использоваться для:
• просмотра всех имеющихся на данный момент блокировок, всех блокировок на отношения в
определённой базе данных, всех блокировок на определённое отношение или всех блокиро-
вок, которые удерживает определённая сессия PostgreSQL.
• определения отношения в текущей базе данных с наибольшим количеством неразрешённых
блокировок (оно может быть причиной конкуренции между клиентами базы данных).
• определения воздействия конкуренции за блокировку на производительность базы данных в
целом, а так же то, как меняется конкуренция в зависимости от загруженности базы.
Более детально представление pg_locks описано в Разделе 52.73. Более подробную информацию
о блокировках и управлению параллельным доступом в PostgreSQL можно получить в Главе 13.
711Мониторинг работы СУБД
28.4. Отслеживание выполнения
PostgreSQL имеет возможность отслеживать выполнение определённых команд. В настоящее вре-
мя такое отслеживание поддерживает только команда VACUUM, но в будущем сфера его применения
может быть расширена.
28.4.1. Отслеживание выполнения VACUUM
Во время выполнения VACUUM представление pg_stat_progress_vacuum будет содержать по одной
строке для каждого обслуживающего процесса (включая рабочие процессы автоочистки), произ-
водящего очистку. Таблицы ниже показывают, какая информация будет отслеживаться, и расска-
зывают, как её интерпретировать. В настоящее время отслеживание выполнения не поддержива-
ется для команды VACUUM FULL, так что процессы, выполняющие VACUUM FULL, не будут видны в
этом представлении.
Таблица 28.21. Представление pg_stat_progress_vacuum
Столбец Тип Описание
pid integer Идентификатор (PID) этого об-
служивающего процесса
datid oid OID базы данных, к которой под-
ключён этот обслуживающий
процесс.
datname name Имя базы данных, к которой
подключён этот обслуживаю-
щий процесс.
relid oid OID очищаемой таблицы.
phase text Текущая фаза очистки. См. Таб-
лицу 28.22.
heap_blks_total bigint Общее число блоков кучи в таб-
лице. Это число отражает со-
стояние в начале сканирова-
ния; блоки, добавленные позже,
не будут (и не должны) обра-
батываться текущей командой
VACUUM.
heap_blks_scanned bigint Число просканированных бло-
ков кучи. Так как для оптими-
зации сканирования применя-
ется карта видимости, некото-
рые блоки могут пропускаться
без осмотра; пропущенные бло-
ки входят в это общее число, так
что по завершении очистки это
число станет равно heap_blks_
total . Этот счётчик увеличи-
вается только в фазе scanning
heap.
heap_blks_vacuumed bigint Число очищенных блоков ку-
чи. Если в таблице нет индек-
сов, этот счётчик увеличива-
ется только в фазе vacuuming
heap (очистка кучи). Блоки, не
содержащие «мёртвых» корте-
жей, при этом пропускаются,
712Мониторинг работы СУБД
Столбец Тип Описание
так что этот счётчик иногда
может увеличиваться резкими
рывками.
index_vacuum_count bigint Количество завершённых цик-
лов очистки индекса.
max_dead_tuples bigint Число «мёртвых» кортежей, ко-
торое мы можем сохранить,
прежде чем потребуется вы-
полнить цикл очистки индекса,
в зависимости от maintenance_
work_mem.
num_dead_tuples bigint Число «мёртвых» кортежей, со-
бранных со времени последнего
цикла очистки индекса.
Таблица 28.22. Фазы VACUUM
Фаза Описание
initializing Инициализация — VACUUM готовится начать ска-
нирование кучи. Эта фаза должна быть очень
быстрой.
scanning heap Сканирование кучи — VACUUM в настоящее время
сканирует кучу. При этом будет очищена и, если
требуется, дефрагментирована каждая страни-
ца, а возможно, также будет произведена замо-
розка. Отслеживать процесс сканирования мож-
но, следя за содержимым столбца heap_blks_
scanned .
vacuuming indexes Очистка индексов — VACUUM в настоящее вре-
мя очищает индексы. Если у таблицы есть ка-
кие-либо индексы, эта фаза будет наблюдаться
минимум единожды в процессе очистки, после
того, как куча будет просканирована полностью.
Она может повторяться несколько раз в процес-
се очистки, если объёма maintenance_work_mem
оказывается недостаточно для сохранения всех
найденных «мёртвых» кортежей.
vacuuming heap Очистка кучи — VACUUM в настоящее время очи-
щает кучу. Очистка кучи отличается от скани-
рования, так как она происходит после каждой
операции очистки индексов. Если heap_blks_
scanned меньше чем heap_blks_total , систе-
ма вернётся к сканированию кучи после завер-
шения этой фазы; в противном случае она нач-
нёт уборку индексов.
cleaning up indexes Уборка индексов — VACUUM в настоящее время
производит уборку в индексах. Это происходит
после завершения полного сканирования кучи и
очистки индексов и кучи.
truncating heap Усечение кучи — VACUUM в настоящее время усе-
кает кучу, чтобы возвратить операционной си-
стеме объём пустых страниц в конце отношения.
Это происходит после уборки индексов.
713Мониторинг работы СУБД
Фаза Описание
performing final cleanup Выполнение окончательной очистки — VACUUM
выполняет окончательную очистку. На этой ста-
дии VACUUM очищает карту свободного простран-
ства, обновляет статистику в pg_class и пе-
редаёт статистику сборщику статистики, После
этой фазы VACUUM завершит свою работу.
28.5. Динамическая трассировка
PostgreSQL позволяет выполнять динамическую трассировку сервера базы данных. Имеющиеся
возможности позволяют вызывать внешнюю утилиту в определённых точках кода и таким образом
отслеживать его выполнение.
Несколько подобных точек сбора метрик, или точек трассировки, уже встроено в исходный код.
Предполагается, что эти точки будут использоваться разработчиками и администраторами базы
данных. По умолчанию точки трассировки не входят в сборку PostgreSQL; пользователь должен
явно указать конфигурационному скрипту необходимость включения этих макросов.
В настоящее время поддерживается только утилита DTrace, которая доступна для Solaris, macOS,
FreeBSD, NetBSD и Oracle Linux. Проект SystemTap для Linux представляет собой эквивалент
DTrace и также может быть использован. Теоретически возможна поддержка и других утилит
динамической трассировки, для этого необходимо изменить определения для макроса в src/
include/utils/probes.h.
28.5.1. Компиляция для включения динамической трассировки
По умолчанию точки трассировки недоступны, поэтому в конфигурационном скрипте PostgreSQL
требуется явно указать необходимость их подключения. Для поддержки утилиты DTrace укажите
–enable-dtrace в конфигурационном файле. Более подробно смотрите Раздел 16.4.
28.5.2. Встроенные точки трассировки
В исходный код входит несколько стандартных точек трассировки, которые представлены в Табли-
це 28.23; в Таблице 28.24 показаны типы данных, которые используются для этих точек. Конечно,
для более детального отслеживания работы PostgreSQL можно добавлять и другие точки трасси-
ровки.
Таблица 28.23. Встроенные точки трассировки DTrace
Имя Параметры Описание
transaction-start (LocalTransactionId) Срабатывает в начале новой
транзакции. arg0 задаёт иден-
тификатор транзакции.
transaction-commit (LocalTransactionId) Срабатывает при успешном за-
вершении транзакции. arg0 за-
даёт идентификатор транзак-
ции.
transaction-abort (LocalTransactionId) Срабатывает, когда транзакция
завершается с ошибкой. arg0
задаёт идентификатор транзак-
ции.
query-start (const char *) Срабатывает, когда начинается
обработка запроса. arg0 задаёт
текст запроса.
query-done (const char *) Срабатывает по завершении об-
работки запроса. arg0 задаёт
текст запроса.
714Мониторинг работы СУБД
Имя Параметры Описание
query-parse-start (const char *) Срабатывает, когда начинает-
ся разбор запроса. arg0 задаёт
текст запроса.
query-parse-done (const char *) Срабатывает по завершении
разбора (parsing) запроса. arg0
задаёт текст запроса.
query-rewrite-start (const char *) Срабатывает, когда начинается
модификация запроса. arg0 за-
даёт текст запроса.
query-rewrite-done (const char *) Срабатывает по завершении мо-
дификации запроса. arg0 задаёт
текст запроса.
query-plan-start () Срабатывает, когда начинает
работать планировщик выпол-
нения запроса.
query-plan-done () Срабатывает по завершении ра-
боты планировщика запроса.
query-execute-start () Срабатывает, когда начинается
выполнение запроса.
query-execute-done () Срабатывает по завершении вы-
полнения запроса.
statement-status (const char *) Срабатывает каждый раз, ко-
гда серверный процесс обнов-
ляет свой статус в pg_stat_
activity .status. arg0 задаёт
новую строку состояния.
checkpoint-start (int) Срабатывает в начале контроль-
ной точки. arg0 содержит би-
товые флаги, с помощью ко-
торых задаются разные типы
контрольных точек, такие как
shutdown, immediate или force.
checkpoint-done (int,
int) clog-checkpoint-start (bool) Срабатывает, когда начинает-
ся запись контрольной точки в
CLOG. arg0 = true для обыч-
ных контрольных точек и false
для контрольных точек типа
shutdown.
clog-checkpoint-done (bool) Срабатывает по завершении
записи контрольной точки в
int,
715
int,
int,
Срабатывает по завершении
контрольной точки. (Перечис-
ленные далее точки трассиров-
ки срабатывают последователь-
но при обработке контрольной
точки.) arg0 задаёт число запи-
санных буферов. arg1 — общее
число буферов. arg2, arg3 и arg4
задают число файлов WAL, ко-
торые были добавлены, удале-
ны или переработаны, соответ-
ственно.Мониторинг работы СУБД
Имя Параметры Описание
CLOG. Значение arg0 задаётся
аналогично значению для clog-
checkpoint-start.
subtrans-checkpoint-start (bool) Срабатывает, когда начинает-
ся запись контрольной точки
в SUBTRANS. arg0 = true для
обычных контрольных точек и
false для контрольных точек ти-
па shutdown.
subtrans-checkpoint-done (bool) Срабатывает по завершении
записи контрольной точки в
SUBTRANS. Значение arg0 зада-
ётся аналогично значению для
subtrans-checkpoint-start.
multixact-checkpoint-start (bool) Срабатывает, когда начинает-
ся запись контрольной точки
в MultiXact. arg0 = true для
обычных контрольных точек и
false для контрольных точек ти-
па shutdown.
multixact-checkpoint-done (bool) Срабатывает по завершении
записи контрольной точки в
MultiXact. Значение arg0 зада-
ётся аналогично значению для
multixact-checkpoint-start.
buffer-checkpoint-start (int) Срабатывает, когда начинает-
ся запись буферов контрольной
точки. arg0 содержит битовые
флаги, с помощью которых за-
даются разные типы контроль-
ных точек, такие как shutdown,
immediate или force.
buffer-sync-start (int, int) Срабатывает во время кон-
трольной точки, когда начина-
ется запись грязных буферов (
после нахождения буферов, ко-
торые должны быть записаны).
arg0 задаёт общее число буфе-
ров. arg1 задаёт число буферов,
которые в настоящий момент
являются грязными и должны
быть записаны.
buffer-sync-written (int) Срабатывает после записи каж-
дого буфера при выполнении
контрольной точки. arg0 задаёт
идентификатор буфера.
buffer-sync-done (int, int, int) Срабатывает после записи всех
грязных буферов. arg0 задаёт
общее число буферов. arg1 зада-
ёт число буферов, которые фак-
тически были записаны процес-
сом выполнения контрольной
точки. arg2 задаёт число буфе-
716Мониторинг работы СУБД
Имя
Параметры
Описание
ров, которое должно было быть
записано (arg1 из buffer-sync-
start); разные значения гово-
рят о том, что во время выпол-
нения этой контрольной точки
буферы сбрасывались другими
процессами.
buffer-checkpoint-sync-start () Срабатывает после записи гряз-
ных буферов в ядро и до начала
формирования запросов fsync.
buffer-checkpoint-done () Срабатывает по завершении
синхронизации буферов с дис-
ком.
twophase-checkpoint-start () Срабатывает, когда начинает-
ся двухфазный этап выполне-
ния контрольной точки.
twophase-checkpoint-done () Срабатывает по завершении
двухфазного этапа выполнения
контрольной точки.
buffer-read-start (ForkNumber,
Oid, Oid,
bool) BlockNumber,
Oid, int, Срабатывает, когда начинается
чтение из буфера. arg0 и arg1
содержат номер слоя и бло-
ка этой страницы (arg1 будет
иметь значение -1, если выпол-
няется запрос на расширение
места для таблицы). arg2, arg3
и arg4 содержат OID-ы таблич-
ного пространства, базы дан-
ных и отношения, которые од-
нозначно идентифицируют от-
ношение. arg5 для локального
буфера задаёт идентификатор
серверного процесса, создавше-
го временное отношение, или
InvalidBackendId (-1) — для
разделяемого буфера. arg6 =
true для запросов на расшире-
ние места для таблицы, false —
в случае обычного чтения.
buffer-read-done (ForkNumber,
Oid, Oid,
bool, bool) BlockNumber,
Oid, int, Срабатывает по завершении
чтения буфера. arg0 и arg1 со-
держат номер слоя и номер бло-
ка этой страницы (arg1 будет со-
держать номер только что до-
бавленного блока, если выпол-
няется запрос на расширение
места для таблицы). arg2, arg3
и arg4 содержат OID-ы таблич-
ного пространства, базы дан-
ных и отношения, которые од-
нозначно идентифицируют от-
ношение. arg5 для локального
буфера задаёт идентификатор
серверного процесса, создавше-
717Мониторинг работы СУБД
Имя Параметры Описание
го временное отношение, или
InvalidBackendId (-1) — для
разделяемого буфера. arg6 =
true для запросов на расшире-
ние места для таблицы, false — в
случае обычного чтения. arg7 =
true, если буфер был обнаружен
в пуле, false — если нет.
buffer-flush-start (ForkNumber, BlockNumber,
Oid, Oid, Oid) Срабатывает перед формирова-
нием любого запроса на за-
пись в разделяемый буфер. arg0
и arg1 содержат номер слоя
и номер блока этой страницы.
arg2, arg3 и arg4 содержат OID-
ы табличного пространства, ба-
зы данных и отношения, кото-
рые однозначно идентифициру-
ют отношение.
buffer-flush-done (ForkNumber, BlockNumber,
Oid, Oid, Oid) Срабатывает по завершении за-
проса на запись. (Учтите, что
это отражает только момент пе-
редачи данных в ядро; обычно
на диск они ещё не записаны.)
Аргументы аналогичны buffer-
flush-start.
buffer-write-dirty-start (ForkNumber, BlockNumber,
Oid, Oid, Oid) Срабатывает, когда серверный
процесс начинает запись гряз-
ного буфера. (Частое повторе-
ние такой пробы означает, что
значение shared_buffers слиш-
ком мало или что необходи-
мо откорректировать управляю-
щие параметры процесса фоно-
вой записи.) arg0 и arg1 содер-
жат номер слоя и блока этой
страницы. arg2, arg3 и arg4 со-
держат OID-ы табличного про-
странства, базы данных и от-
ношения, которые однозначно
идентифицируют отношение.
buffer-write-dirty-done (ForkNumber, BlockNumber,
Oid, Oid, Oid) Срабатывает по завершении за-
писи грязного буфера. Аргумен-
ты аналогичны buffer-write-
dirty-start.
wal-buffer-write-dirty-start () Срабатывает, когда серверный
процесс начинает запись гряз-
ного WAL буфера из-за того, что
свободные WAL буферы закон-
чились. (Частое повторение та-
кой ситуации означает, что зна-
чение wal_buffers слишком ма-
ло.)
wal-buffer-write-dirty-done Срабатывает по завершении за-
писи грязного WAL буфера.
()
718Мониторинг работы СУБД
Имя Параметры wal-insert (unsigned
char) wal-switch () Срабатывает при запросе на пе-
реключение сегмента WAL.
smgr-md-read-start (ForkNumber, BlockNumber,
Oid, Oid, Oid, int) Срабатывает, когда начинает-
ся чтение блока из отноше-
ния. arg0 and arg1 содержат
номер слоя и номер блока
этой страницы. arg2, arg3 и
arg4 содержат OID-ы таблич-
ного пространства, базы дан-
ных и отношения, которые од-
нозначно идентифицируют от-
ношение. arg5 для локального
буфера задаёт идентификатор
серверного процесса, создавше-
го временное отношение, или
InvalidBackendId (-1) для раз-
деляемого буфера.
smgr-md-read-done (ForkNumber, BlockNumber,
Oid, Oid, Oid, int, int,
int) Срабатывает по завершении
чтения блока. arg0 и arg1 со-
держат номер слоя и номер
блока страницы. arg2, arg3 и
arg4 содержат OID-ы таблич-
ного пространства, базы дан-
ных и отношения, которые од-
нозначно идентифицируют от-
ношение. arg5 для локально-
го буфера задаёт идентифика-
тор серверного процесса, со-
здавшего временное отноше-
ние, или InvalidBackendId (-1)
— для разделяемого буфера.
arg6 задаёт количество факти-
чески прочитанных байтов, то-
гда как arg7 задаёт количество
запрошенных байтов (различия
говорят о наличии проблемы).
smgr-md-write-start (ForkNumber, BlockNumber,
Oid, Oid, Oid, int) Срабатывает, когда начинается
запись блока в отношение. arg0
и arg1 содержат номер слоя
и номер блока этой страницы.
arg2, arg3 и arg4 содержат OID-
ы табличного пространства, ба-
зы данных и отношения, ко-
торые однозначно идентифици-
руют отношение. arg5 для ло-
кального буфера задаёт иденти-
фикатор серверного процесса,
создавшего временное отноше-
char,
719
Описание
unsigned
Срабатывает при добавлении
записи в WAL. arg0 задаёт иден-
тификатор менеджера ресурсов
(rmid) для этой записи. arg1 за-
даёт информационные флаги.Мониторинг работы СУБД
Имя Параметры Описание
ние, или InvalidBackendId (-1)
— для разделяемого буфера.
smgr-md-write-done (ForkNumber, BlockNumber,
Oid, Oid, Oid, int, int,
int) Срабатывает по завершении за-
писи блока. arg0 и arg1 содер-
жат номер слоя и номер бло-
ка этой страницы. arg2, arg3
и arg4 содержат OID-ы таблич-
ного пространства, базы дан-
ных и отношения, которые од-
нозначно идентифицируют от-
ношение. arg5 для локального
буфера задаёт идентификатор
серверного процесса, создавше-
го временное отношение, или
InvalidBackendId (-1) — для
разделяемого буфера. arg6 за-
даёт количество фактически за-
писанных байтов, тогда как arg7
задаёт количество запрошен-
ных байтов (различия говорят о
наличии проблемы).
sort-start (int, bool,
bool, int) Срабатывает, когда начинается
операция сортировки. arg0 за-
даёт сортировку таблицы, ин-
декса или элемента данных.
arg1 = true, если данные ожи-
даются уникальными. arg2 за-
даёт число ключевых столбцов.
arg3 задаёт объём доступной
рабочей памяти в килобайтах.
arg4 = true, если требуется про-
извольный доступ к результа-
ту сортировки. В arg5 значение
0 указывает на последователь-
ный процесс, 1 — на параллель-
ный, а 2 показывает, что это ве-
дущий процесс в параллельной
сортировке.
sort-done (bool, long) Срабатывает по завершении
сортировки. arg0 = true для
внешней сортировки, false —
для внутренней сортировки.
arg1 задаёт число дисковых бло-
ков, использованных для внеш-
ней сортировки, или объём па-
мяти, использованной для внут-
ренней сортировки, в килобай-
тах.
lwlock-acquire (char *, LWLockMode) Срабатывает, когда выдаётся
блокировка LWLock. В arg0 пе-
редаётся транш блокировки, в
arg1 запрошенный режим бло-
кировки (исключительная или
разделяемая).
720
int,
int,Мониторинг работы СУБД
Имя Параметры Описание
lwlock-release (char *) Срабатывает, когда блокиров-
ка LWLock освобождается (но
учтите, что никакие ждущие
процессы ещё не пробуждены).
В arg0 передаётся транш блоки-
ровки.
lwlock-wait-start (char *, LWLockMode) Срабатывает, когда блокировка
LWLock не доступна моменталь-
но, и серверный процесс начал
ожидать её доступности. В arg0
передаётся транш блокировки,
в arg1 запрошенный режим бло-
кировки (исключительная или
разделяемая).
lwlock-wait-done (char *, LWLockMode) Срабатывает, когда серверный
процесс прекращает ожидание
блокировки LWLock (но саму
блокировку он ещё не получил).
В arg0 передаётся транш блоки-
ровки, в arg1 запрошенный ре-
жим блокировки (исключитель-
ная или разделяемая).
lwlock-condacquire (char *, LWLockMode) Срабатывает, когда блокировка
LWLock была успешно получе-
на процессом, запросившим её
в режиме без ожидания. В arg0
передаётся транш блокировки,
в arg1 запрошенный режим бло-
кировки (исключительная или
разделяемая).
lwlock-condacquire-fail (char *, LWLockMode) Срабатывает, когда блокировка
LWLock не была успешно полу-
чена процессом, запросившим
её в режиме без ожидания. В
arg0 передаётся транш блоки-
ровки, в arg1 запрошенный ре-
жим блокировки (исключитель-
ная или разделяемая).
lock-wait-start (unsigned
int,
unsigned
int, unsigned int, unsigned
int,
unsigned
int,
LOCKMODE) Срабатывает, когда запрос на
тяжёлую блокировку (блоки-
ровку lmgr) переходит в состо-
яние ожидания, поскольку бло-
кировка недоступна. Аргумен-
ты с arg0 до arg3 задают атрибу-
ты, идентифицирующие объект,
на который накладывается бло-
кировка. arg4 задаёт тип объек-
та, на который накладывается
блокировка. arg5 задаёт тип за-
прошенной блокировки.
lock-wait-done (unsigned
int,
unsigned
int, unsigned int, unsigned
int,
unsigned
int,
LOCKMODE) Срабатывает, когда запрос на
тяжёлую блокировку (блоки-
ровку lmgr) выходит из состо-
яния ожидания (т. е. получает
721Мониторинг работы СУБД
Имя Параметры Описание
блокировку). Аргументы анало-
гичны lock-wait-start.
deadlock-found () Срабатывает, когда детектор
взаимных блокировок обнару-
живает такую взаимную блоки-
ровку
Таблица 28.24. Предопределённые типы, используемые в параметрах точек трассировки
Тип Определение
LocalTransactionId unsigned int
LWLockMode int
LOCKMODE int
BlockNumber unsigned int
Oid unsigned int
ForkNumber int
bool char
28.5.3. Использование точек трассировки
В приведённом ниже примере показан скрипт DTrace для анализа числа транзакций в системе,
который можно использовать в качестве альтернативы созданию снимка данных pg_stat_database
до и после выполнения теста производительности:
#!/usr/sbin/dtrace -qs
postgresql$1:::transaction-start
{
@start[“Start”] = count();
self-&gt;ts = timestamp;
}
postgresql$1:::transaction-abort
{
@abort[“Abort”] = count();
}
postgresql$1:::transaction-commit
/self-&gt;ts/
{
@commit[“Commit”] = count();
@time[“Total time (ns)”] = sum(timestamp - self-&gt;ts);
self-&gt;ts=0;
}
При выполнении этот D-скрипт возвращает результат вида:</p>
<h1 id="txn_countd-pgrep--n-postgres-or-txn_countd-">./txn_count.d <code class="highlighter-rouge">pgrep -n postgres</code> or ./txn_count.d <PID></PID></h1>
<p>^C
Start
Commit
Total time (ns)
71
70
2312105013
722Мониторинг работы СУБД
Примечание
SystemTap использует отличную от DTrace нотацию для скриптов трассировки, хотя
лежащие в их основе точки трассировки совместимы. Стоит отметить, что на момент
написания этой главы в скриптах SystemTap имена точек трассировки должны обрам-
ляться двойными подчёркиваниями, а не дефисами. Ожидается, что эта проблема бу-
дет решена в следующих версиях SystemTap.
Необходимо помнить, что скрипты DTrace должны быть аккуратно написаны и отлажены, в про-
тивном случае собранная трассировочная информация может оказаться бессмысленной. В боль-
шинстве случаев причиной обнаруженных проблем является инструментарий, а не сама система.
Отправляя на рассмотрение данные, полученные с использованием динамической трассировки,
обязательно прилагайте скрипт, с помощью которого они были получены, для того чтобы его также
проверить и обсудить.
28.5.4. Задание новых точек трассировки
Новые точки трассировки разработчик может определить в любом участке кода, однако это по-
требует перекомпиляции. Ниже приведены шаги, необходимые для добавления новых точек трас-
сировки:</p>
<ol>
  <li>Определить имена точек трассировки и данные, которые будут доступны в этих точках</li>
  <li>Добавить описание точек трассировки в src/backend/utils/probes.d</li>
  <li>Включить pg_trace.h, если его ещё не использовали в модуле (модулях), содержащих точки
трассировки, и вставить TRACE_POSTGRESQL отладочные макросы в нужные места исходного ко-
да</li>
  <li>Перекомпилировать и убедиться в доступности новых точек трассировки
Пример:  Вот пример того, как можно добавить точку для трассировки всех новых транзакций
по их идентификатору.</li>
  <li>Устанавливаем, что проба будет называться transaction-start и принимать параметр типа
LocalTransactionId</li>
  <li>Добавляем определение пробы в src/backend/utils/probes.d:
probe transaction__start(LocalTransactionId);
Обратите внимание на использование двойного подчёркивания в имени пробы. В скрипте
DTrace, использующем эту точку, двойное подчёркивание нужно будет заменить дефисом, по-
этому в документации для пользователей имя этой пробы — transaction-start.
3.
Во
время
компиляции
transaction__start
преобразуется
в
макрос
TRACE_POSTGRESQL_TRANSACTION_START (обратите внимание, что здесь используется одинарное
подчёркивание), который доступен в результате включения pg_trace.h. Добавим вызов мак-
роса в требуемую точку исходного кода. В данном случае это будет выглядеть приблизительно
так:
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
4.
После перекомпиляции и запуска нового бинарного файла используйте следующую команду
DTrace, чтобы проверить доступность только что добавленной пробы. Должен получиться ре-
зультат, подобный этому:
    <h1 id="dtrace--ln-transaction-start">dtrace -ln transaction-start</h1>
    <p>ID
PROVIDER
MODULE
18705 postgresql49878
postgres
18755 postgresql49877
postgres
18805 postgresql49876
postgres
FUNCTION NAME
StartTransactionCommand transaction-start
StartTransactionCommand transaction-start
StartTransactionCommand transaction-start
723Мониторинг работы СУБД
18855 postgresql49875
18986 postgresql49873
postgres
postgres
StartTransactionCommand transaction-start
StartTransactionCommand transaction-start
При добавлении макросов трассировки в код, написанный на языке C, необходимо позаботиться
о следующем:
• Нужно убедиться, что типы данных, определённые в параметрах пробы, совпадают с типами
данных переменных, которые используются в макросе. В противном случае компиляция за-
вершится с ошибками.
• В большинстве платформ в случае, если PostgreSQL собран с указанием –enable-dtrace, то
аргументы макроса трассировки вычисляются каждый раз, когда макрос получает управле-
ние, даже если трассировка не выполняется. Об этом не стоит беспокоиться, если вы просто
возвращаете значения небольшого числа локальных переменных. Однако избегайте использо-
вания ресурсоёмких вызовов функций в аргументах. Если это необходимо, то постарайтесь за-
щитить макрос проверкой, которая будет определять, действительно ли включена трассиров-
ка:
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
TRACE_POSTGRESQL_TRANSACTION_START(some_function(…));
Каждый макрос трассировки имеет соответствующий макрос ENABLED.
724</p>
  </li>
</ol>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-028/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-028/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-028/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-027/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Mount_new_HardDisk/" title="Монтирование новых жестких дисков в системе Ubuntu">Монтирование новых жестких дисков в системе Ubuntu</a></h3>
      <p>Подключаем новые диски в систему Ubuntu <a href="http://localhost:4000/Mount_new_HardDisk/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Installed_Docker_Ubuntu/" title="Установка Docker">Установка Docker</a></h4>
        <span>Published on January 20, 2019</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Entered_in_to_Docker/" title="Как Войти В Docker-Контейнер">Как Войти В Docker-Контейнер</a></h4>
        <span>Published on January 20, 2019</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
