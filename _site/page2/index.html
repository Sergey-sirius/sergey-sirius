<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page2/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page2/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Приложение F. Дополнительно поставляемые модули"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~226 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" rel="bookmark" title="Приложение F. Дополнительно поставляемые модули" itemprop="url">Приложение F. Дополнительно поставляемые модули</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Приложение F. Дополнительно поставляемые модули</p>

<p>В этом и следующем приложении содержится информация о модулях, которые можно найти в ка-
талоге contrib дистрибутива PostgreSQL. В их число входят средства портирования, утилиты ана-
лиза и подключаемые функции, не включённые в состав основной системы PostgreSQL, в основном
потому что они адресованы ограниченной аудитории или находятся в экспериментальном состоя-
нии, неподходящем для основного дерева кода. Однако это всё не умаляет их полезность.
В этом приложении описываются расширения и другие подключаемые серверные модули, вклю-
чённые в contrib. В Приложении G описываются вспомогательные программы.
При сборке сервера из дистрибутивного исходного кода эти компоненты собираются, только если
выбрана цель “world” (см. Шаг 2). Вы можете собрать и установить их отдельно, выполнив:
make
make install
в каталоге contrib в настроенном дереве исходного кода; либо собрать и установить только один
выбранный модуль, проделав то же самое в его подкаталоге. Для многих модулей имеются регрес-
сионные тесты, которые можно выполнить, запустив:
make check
перед установкой или
make installcheck
, когда сервер PostgreSQL будет работать.
Если вы используете готовую собранную версию PostgreSQL, эти модули обычно поставляются в
виде отдельного подпакета, например postgresql-contrib.
Многие модули предоставляют дополнительные пользовательские функции, операторы и типы.
Чтобы использовать один из таких модулей, когда его исполняемый код установлен, вы должны за-
регистрировать новые объекты SQL в СУБД. В PostgreSQL версии 9.1 и новее для этого нужно вос-
пользоваться командой CREATE EXTENSION. В чистой базе данных вы можете просто выполнить:
CREATE EXTENSION имя_модуля;
Запускать эту команду должен суперпользователь баз данных. При этом новые объекты SQL будут
зарегистрированы только в текущей базе данных, так что эту команду нужно выполнять в каждой
базе данных, в которой вы хотите пользоваться функциональностью этого модуля. Вы также може-
те запустить её в template1, чтобы установленное расширение копировалось во все впоследствии
создаваемые базы по умолчанию.
Многие модули позволяют устанавливать свои объекты в схему по выбору. Для этого нужно доба-
вить SCHEMA имя_схемы в команду CREATE EXTENSION. По умолчанию объекты устанавливаются в
текущую схему для создаваемых объектов, которой по умолчанию становится public.
Если ваша база данных была получена в результате выгрузки/перезагрузки данных PostgreSQL
версии до 9.1, и вы ранее использовали версию этого модуля, рассчитанную на версию до 9.1,
вместо этого вы должны выполнить:
CREATE EXTENSION имя_модуля FROM unpackaged;
При этом объекты этого модуля версии до 9.1 будут упакованы в соответствующий объект расши-
рения. После этого обновления расширения будут осуществляться командой ALTER EXTENSION.
За дополнительными сведениями об обновлении расширении обратитесь к Разделу 38.16.
Однако некоторые из этих модулей не являются «расширениями» в этом смысле, а подключаются к
серверу по-другому, например, через параметр конфигурации shared_preload_libraries. Подробнее
об этом говорится в документации каждого модуля.
2472Дополнительно по-
ставляемые модули
F.1. adminpack
Модуль adminpack предоставляет несколько вспомогательных функций, которыми могут пользо-
ваться pgAdmin и другие средства администрирования и управления базами данных, например,
для удалённого управления файлами журналов сервера. По умолчанию использовать все эти функ-
ции разрешено только суперпользователям, но такое право можно дать и другим пользователям
с помощью команды GRANT.
Функции, приведённые в Таблице F.1, предоставляют возможность записи в файлы на компьюте-
ре, где работает сервер. (См. также функции в Таблице 9.88, которые открывают доступ только на
чтение.) Они позволяют обычным пользователям обращаться только к файлам в каталоге класте-
ра баз данных, но не ограничивают суперпользователей и членов ролей pg_read_server_files или
pg_write_server_files. При этом путь может задаваться и как абсолютный, и как относительный.
Таблица F.1. Функции модуля adminpack
Имя Тип результата Описание
pg_catalog.pg_file_write(
filename text, data text,
append boolean) bigint Записать или дописать в тексто-
вый файл
pg_catalog.pg_file_
rename(oldname
text,
newname
text
[,
archivename text]) boolean Переименовать файл
pg_catalog.pg_file_
unlink(filename text) boolean Удалить файл
pg_catalog.pg_logdir_ls(
) setof record Получить список файлов жур-
налов
в
каталоге
log_
directory
Функция pg_file_write записывает данные (data) в файл с именем filename. Если флаг append
сброшен, этот файл не должен существовать. Если же флаг append установлен, существование
файла допускается и в этом случае данные будут дописаны в него. Возвращает число записанных
байтов.
Функция pg_file_rename переименовывает файл. Если параметр archivename опущен или равен
NULL, она просто переименовывает файл oldname в newname (файл с новым именем не должен суще-
ствовать). Если параметр archivename задан, она сначала переименовывает newname в archivename
(такой файл не должен существовать), а затем переименовывает oldname в newname. В случае ошиб-
ки на втором этапе переименования она попытается переименовать archivename назад в newname,
прежде чем выдать ошибку. Возвращает true в случае успеха и false, если исходные файлы отсут-
ствуют или их невозможно изменить; в других случаях выдаются ошибки.
Функция pg_file_unlink удаляет заданный файл. Возвращает true в случае успеха, false в случае
отсутствия указанного файла либо при сбое в вызове unlink(); в других случаях выдаются ошибки.
Функция pg_logdir_ls возвращает время создания и пути всех файлов журналов в каталоге
log_directory. Чтобы эта функция работала, параметр log_filename должен иметь значение по умол-
чанию (postgresql-%Y-%m-%d_%H%M%S.log).
F.2. amcheck
Модуль amcheck предоставляет функции, позволяющие проверять логическую целостность струк-
туры отношений. Если нарушения структуры не обнаруживаются, эти функции отрабатывают без
ошибок.
2473Дополнительно по-
ставляемые модули
Эти функции проверяют различные инварианты в структуре представления определённых отно-
шений. Правильность работы функций методов доступа, стоящих за сканированием индекса и дру-
гими важными операциями, зависит от всегда соблюдаемых инвариантов. Например, определён-
ные функции проверяют, помимо остальных вещей, что все страницы B-дерева содержат элемен-
ты в «логическом» порядке (например, индекс-B-дерево, построенный по столбцу text, должен
содержать кортежи, упорядоченные в лексическом порядке с учётом правила сортировки). Если
этот конкретный инвариант каким-то образом нарушается, следует ожидать, что бинарный поиск
на затронутой странице введёт в заблуждение процедуру сканирования индекса, что приведёт к
неверным результатам запросов SQL.
Проверка выполняется теми же процедурами, что используются при сканировании индекса, и это
может быть код пользовательского класса операторов. Например, проверка индекса-B-дерева за-
действует сравнения, выполняемые одной или несколькими опорными функциями B-дерева под
номером 1. Подробнее опорные функции класса операторов описываются в Подразделе 38.15.3.
Функции amcheck могут выполнять только суперпользователи.
F.2.1. Функции
bt_index_check(index regclass, heapallindexed boolean) returns void
bt_index_check проверяет, соблюдаются ли в целевом индексе-B-дереве различные инвариан-
ты. Пример использования:
test=# SELECT bt_index_check(index =&gt; c.oid, heapallindexed =&gt; i.indisunique),
c.relname,
c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = ‘btree’ AND n.nspname = ‘pg_catalog’
– Не проверять временные таблицы (они могут относиться к другим сеансам):
AND c.relpersistence != ‘t’
– Функция может выдать ошибку без этих условий:
AND c.relkind = ‘i’ AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;
bt_index_check |
relname
| relpages
—————-+———————————+———-
| pg_depend_reference_index
|
43
| pg_depend_depender_index
|
40
| pg_proc_proname_args_nsp_index |
31
| pg_description_o_c_o_index
|
21
| pg_attribute_relid_attnam_index |
14
| pg_proc_oid_index
|
10
| pg_attribute_relid_attnum_index |
9
| pg_amproc_fam_proc_index
|
5
| pg_amop_opr_fam_index
|
5
| pg_amop_fam_strat_index
|
5
(10 rows)
Этот пример демонстрирует сеанс проверки 10 самых больших индексов системных каталогов
в базе данных «test». Проверка всех кортежей кучи на предмет наличия соответствующих кор-
тежей индекса запрашивается только для тех из этих индексов, которые являются уникальны-
ми. Так как ошибки не было, все проверенные индексы представляются логически целостными.
Естественно, этот запрос можно легко изменить, чтобы функция bt_index_check вызывалась
для всех индексов в базе, которые поддерживают эту проверку.
Функция bt_index_check запрашивает блокировку AccessShareLock для целевого индекса и от-
ношения, которому он принадлежит. Это тот же режим блокировки, что запрашивается для от-
2474Дополнительно по-
ставляемые модули
ношений обычными операторами SELECT. bt_index_check не проверяет инварианты, существу-
ющие в иерархии потомок/родитель, но проверяет представление всех кортежей кучи в индек-
се в виде индексных кортежей, когда параметр heapallindexed равен true. Когда в работаю-
щей производственной среде требуется регулярная лёгкая проверка на наличие нарушений,
использование bt_index_check часто будет подходящим компромиссом между полнотой про-
верки и минимизацией влияния на производительность и доступность приложения.
bt_index_parent_check(index regclass, heapallindexed boolean) returns void
Функция bt_index_parent_check проверяет, соблюдаются ли в целевом объекте, индексе-B-
дереве, различные инварианты. Кроме того, если аргумент heapallindexed равен true, эта
функция проверяет наличие в индексе всех кортежей из кучи, которые должны в него по-
пасть, и отсутствие потерянных связей в структуре индекса. Проверки, которые может про-
изводить bt_index_parent_check, включают в себя все проверки, выполняемые функцией
bt_index_check. Функцию bt_index_parent_check можно считать более полноценным вариан-
том bt_index_check: в отличие от bt_index_check, bt_index_parent_check проверяет ещё и
инварианты, существующие в иерархии родитель/потомок. bt_index_parent_check следует об-
щему соглашению и выдаёт ошибку в случае обнаружения логической несогласованности или
другой проблемы.
Функция bt_index_parent_check запрашивает в целевом индексе блокировку ShareLock (также
ShareLock запрашивается и в основном отношении). Эти блокировки предотвращают одновре-
менное изменение данных командами INSERT, UPDATE и DELETE. Эти блокировки также препят-
ствуют одновременной обработке нижележащего отношения командой VACUUM и другими вспо-
могательными командами. Заметьте, что эта функция удерживает блокировки только во время
выполнения, а не на протяжении всей транзакции.
Дополнительные проверки, проводимые функцией bt_index_parent_check, более ориентиро-
ваны на выявление различных патологических случаев. В том числе это может быть непра-
вильно реализованный класс операторов B-дерева, используемый проверяемым индексом, или,
гипотетически, неизвестные ошибки в нижележащем коде метода доступа индекса-B-дерева.
Заметьте, что функцию bt_index_parent_check нельзя применять, когда включён режим го-
рячего резерва (то есть на физических репликах в режиме «только чтение»), в отличие от
bt_index_check.
F.2.2. Дополнительная проверка heapallindexed
Когда аргумент heapallindexed проверяющих функций равен true, для таблицы, связанной с от-
ношением целевого индекса, добавляется дополнительная фаза проверки. Она включает «фиктив-
ную» операцию CREATE INDEX, которая проверяет присутствие всех гипотетических новых индекс-
ных кортежей по временной сводной структуре в памяти (она создаётся при необходимости на
первом этапе проверки). Сводная структура «помечает» каждый кортеж, который находится в це-
левом индексе. На высоком уровне идея проверки heapallindexed состоит в том, чтобы убедиться,
что новый индекс, равнозначный целевому, содержит только те записи, которые можно найти в
существующей структуре.
С дополнительным этапом heapallindexed связаны значительные издержки: проверка обычно бу-
дет выполняться в несколько раз дольше. Однако никакие новые блокировки уровня отношения
при проверке heapallindexed не запрашиваются.
Сводная структура ограничивается по объёму значением maintenance_work_mem. Для выявления
несогласованности в представленных в индексе кортежах с вероятностью упущений в пределах
2% требуется приблизительно 2 байта памяти на кортеж. По мере уменьшения объёма памяти в
пересчёте на кортеж этот процент медленно растёт. Этот подход значительно ограничивает из-
держки такой проверки, и при этом лишь немного уменьшается вероятность выявления пробле-
мы, особенно в инсталляциях, где эта проверка включена в процедуру регулярного обслуживания.
Даже если единичное отсутствие или повреждение кортежа упущено, есть все шансы выявить его
при очередной проверке.
2475Дополнительно по-
ставляемые модули
F.2.3. Эффективное использование amcheck
Модуль amcheck может быть полезен для выявления различных типов проблем, которые могут
остаться незамеченными при включении контрольных сумм страниц данных. В частности это:
• Структурные несоответствия, возникающие при некорректной реализации класса операторов.
В том числе это проблемы, возникающие при изменении правил сравнения в операционной
системе. Сравнения данных сортируемого типа, например text, должны быть постоянными
(как и все сравнения, применяемые при сканировании индекса-B-дерева), что подразумевает
неизменность правил сортировки в операционной системе. Проблемы могут возникать при об-
новлениях правил в операционной системе, хотя такие случаи редки. Чаще проявляются несо-
ответствия порядка сортировки между ведущим и ведомым сервером, например, из-за разли-
чий основных версий используемых операционных систем. Возникающие расхождения обыч-
но наблюдаются только на ведомых серверах, так что и выявить их обычно можно только на
них.
Когда возникает подобная проблема, она может затрагивать не абсолютно все индексы, по-
строенные с порочным правилом сортировки, просто потому что индексированные значения
могут иметь тот же абсолютный порядок, независящий от различий поведения. За дополни-
тельными сведениями об использовании в PostgreSQL правил сортировки и локалей операци-
онной системы обратитесь к Разделу 23.1 и Разделу 23.2.
• Несоответствия структуры между индексами и проиндексированными отношениями в куче
(когда выполняется проверка heapallindexed).
Во время обычных операций перекрёстная проверка индексов по отношениям в куче не про-
изводится. Симптомы повреждения данных в куче могут быть неочевидными.
• Повреждения, вызванные гипотетическими неизвестными ошибками в нижележащем коде
методов доступа, коде сортировки и управления транзакциями PostgreSQL.
Автоматическая проверка структурной целостности индексов играет важную роль в общем те-
стировании новых или предлагаемых возможностей PostgreSQL, с которыми может возник-
нуть логическая несогласованность. Такую же роль играет проверка структуры таблицы и свя-
занной информации о видимости и состоянии транзакций. И поэтому одна из очевидных стра-
тегий тестирования — регулярно вызывать функции amcheck при проведении стандартных ре-
грессионных тестов. Подробнее о выполнении тестов можно узнать в Разделе 33.1.
• Ошибки в файловой системе или подсистеме хранения, когда просто не включены контроль-
ные суммы.
Заметьте, что amcheck рассматривает страницу в том виде, как она представлена в некотором
буфере разделяемой памяти к моменту проверки, если при обращению к нужному блоку он
уже находится в разделяемом буфере. Вследствие этого, amcheck не обязательно видит дан-
ные, находящиеся в файловой системе в момент проверки. Заметьте, что когда контрольные
суммы включены, amcheck может выдать ошибку из-за несоответствия контрольных сумм, ес-
ли в буфер будет считываться испорченный блок.
• Повреждения, вызванные дефектными чипами ОЗУ или вообще подсистемой памяти.
PostgreSQL не защищает от ошибок памяти; предполагается, что в эксплуатируемом вами
сервере установлена память с ECC (Error Correcting Codes, Коды исправления ошибок) или
лучшая защита. Однако память ECC обычно защищает только от ошибок в одном бите и не
следует считать её абсолютной защитой от сбоев, приводящих к повреждению памяти.
Когда выполняется проверка heapallindexed, в целом значительно увеличивается шанс выяв-
ления ошибок в отдельных битах, так как она тестирует точное двоичное равенство и сверяет
проиндексированные атрибуты с кучей.
Вообще говоря, amcheck может доказать только наличие повреждений, но не доказать их отсут-
ствие.
2476Дополнительно по-
ставляемые модули
F.2.4. Исправление повреждений
Когда amcheck сигнализирует о повреждении данных, ложные срабатывания практически исклю-
чены. amcheck считает ошибочными ситуации, которые никогда не должны наблюдаться по опре-
делению, поэтому ошибки amcheck, как правило, требуют тщательного анализа.
Общего метода устранения проблем, которые может выявить amcheck, не существует. Начать нуж-
но с поиска корня проблемы, приводящей к нарушению инварианта. Полезную роль в диагностике
повреждений, которые выявляет amcheck, может сыграть pageinspect. Одна лишь команда REINDEX
может быть неэффективна, когда потребуется исправить повреждения.
F.3. auth_delay
Модуль auth_delay добавляет небольшую задержку в процессе проверки подлинности перед тем,
как выдаётся сообщение об ошибке, чтобы усложнить подбор паролей к базам данных. Заметьте,
что это никоим образом не препятствует атакам типа «отказ в обслуживании», а даже наоборот,
может помочь их осуществить, так как процессы, ожидающие сообщения об ошибке, всё равно
занимают слоты подключения.
Чтобы эта функция работала, данный модуль нужно загрузить посредством параметра конфигура-
ции shared_preload_libraries в postgresql.conf.
F.3.1. Параметры конфигурации
auth_delay.milliseconds (int)
Число миллисекунд, которое нужно подождать, прежде чем сообщать об ошибке аутентифика-
ции. По умолчанию 0.
Эти параметры должны задаваться в postgresql.conf. Обычное использование выглядит так:</p>
<h1 id="postgresqlconf">postgresql.conf</h1>
<p>shared_preload_libraries = ‘auth_delay’
auth_delay.milliseconds = ‘500’
F.3.2. Автор
КайГай Кохэй <a href="mailto:kaigai@ak.jp.nec.com">kaigai@ak.jp.nec.com</a>
F.4. auto_explain
Модуль auto_explain предоставляет возможность автоматического протоколирования планов вы-
полнения медленных операторов, что позволяет обойтись без выполнения EXPLAIN вручную. Это
особенно полезно для выявления неоптимизированных запросов в больших приложениях.
Этот модуль не предоставляет функций, доступных из SQL. Чтобы использовать его, просто загру-
зите его в процесс сервера. Это можно сделать в отдельном сеансе:
LOAD ‘auto_explain’;
(Для этого нужно быть суперпользователем.) Более типична конфигурация, когда он загру-
жается в некоторые или все сеансы в результате включения auto_explain в переменную
session_preload_libraries или в shared_preload_libraries в файле postgresql.conf. Загрузив этот мо-
дуль, вы можете отслеживать исключительно медленные запросы, вне зависимости от того, когда
они происходят. Конечно, это имеет свою цену.
F.4.1. Параметры конфигурации
Есть несколько параметров конфигурации, которые управляют поведением auto_explain. Заметь-
те, что поведение по умолчанию сводится к бездействию, так что необходимо установить как ми-
нимум переменную auto_explain.log_min_duration, если вы хотите получить какие-либо резуль-
таты.
2477Дополнительно по-
ставляемые модули
auto_explain.log_min_duration (integer)
Переменная auto_explain.log_min_duration задаёт время выполнения оператора, в миллисе-
кундах, при превышении которого план оператора будет протоколироваться. Если это значе-
ние равно 0, протоколироваться будут планы всех операторов. При значении -1 (по умолчанию)
протоколирование планов полностью отключается. Например, если вы установите значение
250ms, протоколироваться будут все запросы, выполняющиеся 250 мс и дольше. Изменить этот
параметр могут только суперпользователи.
auto_explain.log_analyze (boolean)
При включении параметра auto_explain.log_analyze в протокол будет записываться вывод
команды EXPLAIN ANALYZE, а не простой EXPLAIN. По умолчанию этот параметр отключён. Из-
менить его могут только суперпользователи.
Примечание
Когда этот параметр включён, замер времени на уровне узлов плана производится
для всех операторов, даже если они выполняются недостаточно долго для протоко-
лирования. Это может оказать крайне негативное влияние на производительность.
Отключение auto_explain.log_timing исключает это влияние, но при этом соби-
рается меньше информации.
auto_explain.log_buffers (boolean)
Параметр auto_explain.log_buffers определяет, будет ли при протоколировании пла-
на выполнения выводиться статистика об использовании буферов; он равносилен указа-
нию BUFFERS команды EXPLAIN. Этот параметр действует, только если включён параметр
auto_explain.log_analyze. По умолчанию этот параметр отключён. Изменить его могут толь-
ко суперпользователи.
auto_explain.log_timing (boolean)
Параметр auto_explain.log_timing определяет, будет ли при протоколировании плана выпол-
нения выводиться длительность на уровне узлов: он равнозначен указанию TIMING команды
EXPLAIN. Издержки от постоянного чтения системных часов могут значительно замедлить за-
просы в некоторых системах, так что может иметь смысл отключать этот параметр, когда нуж-
но знать только знать количество строк, но не точную длительность каждого узла. Этот пара-
метр действует, только если включён auto_explain.log_analyze. По умолчанию этот параметр
отключён. Изменить его могут только суперпользователи.
auto_explain.log_triggers (boolean)
При включении параметра auto_explain.log_triggers в протокол будет записываться ста-
тистика выполнения триггеров. Этот параметр действует, только если включён параметр
auto_explain.log_analyze. По умолчанию этот параметр отключён. Изменить его могут толь-
ко суперпользователи.
auto_explain.log_verbose (boolean)
Параметр auto_explain.log_verbose определяет, будут ли при протоколировании плана
выполнения выводиться подробные сведения; он равнозначен указанию VERBOSE команды
EXPLAIN. По умолчанию этот параметр отключён. Изменить его могут только суперпользовате-
ли.
auto_explain.log_format (enum)
Параметр auto_explain.log_format выбирает формат вывода для EXPLAIN. Он может прини-
мать значение text, xml, json и yaml. Значение по умолчанию — text. Изменить этот параметр
могут только суперпользователи.
2478Дополнительно по-
ставляемые модули
auto_explain.log_nested_statements (boolean)
При включении параметра auto_explain.log_nested_statements протоколированию могут
подлежать и вложенные операторы (операторы, выполняемые внутри функции). Когда он от-
ключён, протоколируются планы запросов только верхнего уровня. Изменить этот параметр
могут только суперпользователи.
auto_explain.sample_rate (real)
Параметр auto_explain.sample_rate задаёт для auto_explain процент операторов, которые бу-
дут отслеживаться в каждом сеансе. Значение по умолчанию — 1, то есть отслеживаются все
запросы. Вложенные операторы отслеживаются совместно — либо все, либо никакой из них.
Изменить этот параметр могут только суперпользователи.
В обычной ситуации эти параметры устанавливаются в postgresql.conf, хотя суперпользователи
могут изменить их «на лету» в рамках своих сеансов. Типичное их использование может выглядеть
так:</p>
<h1 id="postgresqlconf-1">postgresql.conf</h1>
<p>session_preload_libraries = ‘auto_explain’
auto_explain.log_min_duration = ‘3s’
F.4.2. Пример
postgres=#
postgres=#
postgres=#
postgres=#
LOAD ‘auto_explain’;
SET auto_explain.log_min_duration = 0;
SET auto_explain.log_analyze = true;
SELECT count(<em>)
FROM pg_class, pg_index
WHERE oid = indrelid AND indisunique;
В результате этих команд может быть получен такой вывод:
LOG: duration: 3.651 ms plan:
Query Text: SELECT count(</em>)
FROM pg_class, pg_index
WHERE oid = indrelid AND indisunique;
Aggregate (cost=16.79..16.80 rows=1 width=0) (actual time=3.626..3.627 rows=1
loops=1)
-&gt; Hash Join (cost=4.17..16.55 rows=92 width=0) (actual time=3.349..3.594 rows=92
loops=1)
Hash Cond: (pg_class.oid = pg_index.indrelid)
-&gt; Seq Scan on pg_class (cost=0.00..9.55 rows=255 width=4) (actual
time=0.016..0.140 rows=255 loops=1)
-&gt; Hash (cost=3.02..3.02 rows=92 width=4) (actual time=3.238..3.238 rows=92
loops=1)
Buckets: 1024 Batches: 1 Memory Usage: 4kB
-&gt; Seq Scan on pg_index (cost=0.00..3.02 rows=92 width=4) (actual
time=0.008..3.187 rows=92 loops=1)
Filter: indisunique
F.4.3. Автор
Такахиро Итагаки <a href="mailto:itagaki.takahiro@oss.ntt.co.jp">itagaki.takahiro@oss.ntt.co.jp</a>
F.5. bloom
Модуль bloom предоставляет метод доступа индекса, основанный на фильтрах Блума.
Фильтр Блума представляет собой компактную структуру данных, позволяющую проверить, явля-
ется ли элемент членом множества. В виде метода доступа индекса он позволяет быстро исклю-
чать неподходящие кортежи по сигнатурам, размер которых определяется при создании индекса.
2479Дополнительно по-
ставляемые модули
Сигнатура — это неточное представление проиндексированных атрибутов, вследствие чего оно
допускает ложные положительные срабатывания; то есть оно может показывать, что элемент со-
держится в множестве, хотя это не так. Поэтому результаты поиска по такому индексу должны
всегда перепроверяться по фактическим значениям атрибутов записи в таблице. Чем больше раз-
мер сигнатуры, тем меньше вероятность ложного срабатывания и число напрасных обращений к
таблице, но это, разумеется, влечёт увеличение индекса и замедление сканирования.
Этот тип индекса наиболее полезен, когда в таблице много атрибутов и в запросах проверяются
их произвольные сочетания. Традиционный индекс-B-дерево быстрее индекса Блума, но для под-
держки всевозможных запросов может потребоваться множество индексов типа B-дерево, при том
что индекс Блума нужен всего один. Заметьте, однако, что индексы Блума поддерживают только
проверки на равенство, тогда как индексы-B-деревья также полезны при проверке неравенств и
поиске в диапазоне.
F.5.1. Параметры
Индекс bloom принимает в своём предложении WITH следующие параметры:
length
Длина каждой сигнатуры (элемента индекса) в битах, округлённая вверх до ближайшего числа,
кратного 16. Значение по умолчанию — 80, а максимальное значение — 4096.
col1 — col32
Число битов, генерируемых для каждого столбца индекса. В имени параметра отражается но-
мер столбца индекса, для которого это число задаётся. Значение по умолчанию — 2 бита, а
максимум — 4095. Параметры для неиспользуемых столбцов индекса игнорируются.
F.5.2. Примеры
Пример создания индекса bloom:
CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)
WITH (length=80, col1=2, col2=2, col3=4);
Эта команда создаёт индекс с длиной сигнатуры 80 бит, в которой атрибуты i1 и i2 отображаются
в 2 бита, а атрибут i3 — в 4. Мы могли бы опустить указания length, col1 и col2, так как в них
задаются значения по умолчанию.
Ниже представлен более полный пример определения и использования индекса Блума, а также
приводится сравнение его с равнозначным индексом-B-деревом. Видно, что индекс Блума значи-
тельно меньше индекса-B-дерева, и при этом он может работать быстрее.
=# CREATE TABLE tbloom AS
SELECT
(random() * 1000000)::int as i1,
(random() * 1000000)::int as i2,
(random() * 1000000)::int as i3,
(random() * 1000000)::int as i4,
(random() * 1000000)::int as i5,
(random() * 1000000)::int as i6
FROM
generate_series(1,10000000);
SELECT 10000000
=# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);
CREATE INDEX
=# SELECT pg_size_pretty(pg_relation_size(‘bloomidx’));
pg_size_pretty
—————-
153 MB
(1 row)
2480Дополнительно по-
ставляемые модули
=# CREATE index btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);
CREATE INDEX
=# SELECT pg_size_pretty(pg_relation_size(‘btreeidx’));
pg_size_pretty
—————-
387 MB
(1 row)
Последовательное сканирование по этой большой таблице выполняется долго:
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
——————————————————————————————–
Seq Scan on tbloom (cost=0.00..213694.08 rows=1 width=24) (actual
time=1445.438..1445.438 rows=0 loops=1)
Filter: ((i2 = 898732) AND (i5 = 123451))
Rows Removed by Filter: 10000000
Planning time: 0.177 ms
Execution time: 1445.473 ms
(5 rows)
Поэтому планировщик обычно предпочтёт сканирование по индексу, если это возможно. Ин-
декс-B-дерево даёт такие результаты:
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
——————————————————————————————–
Index Only Scan using btreeidx on tbloom (cost=0.56..298311.96 rows=1 width=24)
(actual time=445.709..445.709 rows=0 loops=1)
Index Cond: ((i2 = 898732) AND (i5 = 123451))
Heap Fetches: 0
Planning time: 0.193 ms
Execution time: 445.770 ms
(5 rows)
При таком поиске Блум оказывается лучше B-дерева:
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
——————————————————————————————–
Bitmap Heap Scan on tbloom (cost=178435.39..178439.41 rows=1 width=24) (actual
time=76.698..76.698 rows=0 loops=1)
Recheck Cond: ((i2 = 898732) AND (i5 = 123451))
Rows Removed by Index Recheck: 2439
Heap Blocks: exact=2408
-&gt; Bitmap Index Scan on bloomidx (cost=0.00..178435.39 rows=1 width=0) (actual
time=72.455..72.455 rows=2439 loops=1)
Index Cond: ((i2 = 898732) AND (i5 = 123451))
Planning time: 0.475 ms
Execution time: 76.778 ms
(8 rows)
Обратите внимание на относительно большое количество ложных срабатываний: для перепровер-
ки по куче были отобраны 2439 строк, но на самом деле ни одна из них не удовлетворила запросу.
Мы можем уменьшить это количество, создав сигнатуру большей длины. В данном примере при
создании индекса с length=200 число ложных срабатываний уменьшилось до 55, но размер индек-
са удвоился (до 306 Мбайт) и запрос стал выполняться дольше (125 мс).
При таком подходе основная проблема поиска по B-дереву состоит в том, что B-дерево неэффек-
тивно, когда условия поиска не ограничивают ведущие столбцы индекса. Поэтому, применяя ин-
дексы типа B-дерево, лучше создавать отдельные индексы для каждого столбца. В этом случае
планировщик построит примерно такой план:
2481Дополнительно по-
ставляемые модули
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
——————————————————————————————–
Bitmap Heap Scan on tbloom (cost=9.29..13.30 rows=1 width=24) (actual
time=0.148..0.148 rows=0 loops=1)
Recheck Cond: ((i5 = 123451) AND (i2 = 898732))
-&gt; BitmapAnd (cost=9.29..9.29 rows=1 width=0) (actual time=0.145..0.145 rows=0
loops=1)
-&gt; Bitmap Index Scan on tbloom_i5<em>idx (cost=0.00..4.52 rows=11 width=0)
(actual time=0.089..0.089 rows=10 loops=1)
Index Cond: (i5 = 123451)
-&gt; Bitmap Index Scan on tbloom_i2_idx (cost=0.00..4.52 rows=11 width=0)
(actual time=0.048..0.048 rows=8 loops=1)
Index Cond: (i2 = 898732)
Planning time: 2.049 ms
Execution time: 0.280 ms
(9 rows)
Хотя этот запрос выполняется гораздо быстрее, чем с каким-либо одиночным индексом, мы платим
за это увеличением размера индекса. Каждый индекс-B-дерево занимает 214 Мбайт, так что общий
объём индексов превышает 1.2 Гбайта, что в 8 раз больше размера индекса Блума.
F.5.3. Интерфейс класса операторов
Класс операторов для индексов Блума требует наличия только хеш-функции для индексируемо-
го типа данных и оператора равенства для поиска. Этот пример демонстрирует соответствующее
определение класса операторов для типа text:
CREATE OPERATOR CLASS text_ops
DEFAULT FOR TYPE text USING bloom AS
OPERATOR
1
=(text, text),
FUNCTION
1
hashtext(text);
F.5.4. Ограничения
• В этот модуль включены только классы операторов для int4 и text.
• При поиске поддерживается только оператор =. Но в будущем возможно добавление поддерж-
ки для массивов с операциями объединения и пересечения.
• Метод доступа bloom не поддерживает уникальные индексы (UNIQUE).
• Метод доступа bloom не поддерживает поиск значений NULL.
F.5.5. Авторы
Фёдор Сигаев <a href="mailto:teodor@postgrespro.ru">teodor@postgrespro.ru</a>, Postgres Professional, Москва, Россия
Александр Коротков <a href="mailto:a.korotkov@postgrespro.ru">a.korotkov@postgrespro.ru</a>, Postgres Professional, Москва, Россия
Олег Бартунов <a href="mailto:obartunov@postgrespro.ru">obartunov@postgrespro.ru</a>, Postgres Professional, Москва, Россия
F.6. btree_gin
Модуль btree_gin предоставляет показательные классы операторов GIN, реализующие поведе-
ние, подобное тому, что реализуют обычные классы B-дерева, для типов данных int2, int4, int8,
float4, float8, timestamp with time zone, timestamp without time zone, time with time zone,
time without time zone, date, interval, oid, money, “char”, varchar, text, bytea, bit, varbit,
macaddr, macaddr8, inet, cidr, uuid, name, bool, bpchar и всех типов-перечислений (enum).
Вообще говоря, эти классы операторов не будут работать быстрее аналогичных стандартных ме-
тодов индекса-B-дерева, и им не хватает одной важной возможности стандартной реализации B-
дерева: возможности ограничивать уникальность. Тем не менее, их можно применять для тести-
2482Дополнительно по-
ставляемые модули
рования GIN или взять за основу для разработки других классов операторов GIN. Также, для за-
просов, где проверяется и столбец с индексом GIN, и столбец с индексом-B-деревом, может быть
более эффективным создать составной индекс GIN, который использует один из этих классов опе-
раторов, чем использовать два отдельных индекса, выборку из которых придётся объединять, вы-
числяя AND битовых карт.
F.6.1. Пример использования
CREATE TABLE test (a int4);
– создать индекс
CREATE INDEX testidx ON test USING GIN (a);
– запрос
SELECT * FROM test WHERE a &lt; 10;
F.6.2. Авторы
Фёдор Сигаев (<a href="mailto:teodor@stack.net">teodor@stack.net</a>) и Олег Бартунов (<a href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>). Подробности можно
найти на странице http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin.
F.7. btree_gist
Модуль btree_gist предоставляет показательные классы операторов GiST, реализующие поведе-
ние, подобное тому, что реализуют обычные классы B-дерева, для типов данных int2, int4, int8,
float4, float8, numeric, timestamp with time zone, timestamp without time zone, time with time
zone, time without time zone, date, interval, oid, money, char, varchar, text, bytea, bit, varbit,
macaddr, macaddr8, inet, cidr, uuid и всех типов enum.
Вообще говоря, эти классы операторов не будут работать быстрее аналогичных стандартных ме-
тодов индекса-B-дерева, и им не хватает одной важной возможности стандартной реализации B-
дерева: возможности ограничивать уникальность. Однако они предлагают несколько других воз-
можностей, описанных ниже. Также эти классы операторов полезны, когда требуется составной
индекс GiST, в котором некоторые столбцы имеют типы данных, индексируемые только с GiST, а
другие — простые типы. Наконец, эти классы операторов можно применять для тестирования GiST
или взять за основу для разработки других классов операторов GiST.
Помимо типичных операторов поиска по B-дереву, btree_gist также поддерживает использование
индекса для операции &lt;&gt; («не равно»). Это может быть полезно в сочетании с ограничением-ис-
ключением, как описано ниже.
Также, для типов данных, имеющих естественную метрику расстояния, btree_gist определяет
оператор расстояния &lt;-&gt; и поддерживает использование индексов GiST для поиска ближайших
соседей с применением этого оператора. Операторы расстояния определены для типов int2, int4,
int8, float4, float8, timestamp with time zone, timestamp without time zone, time without
time zone, date, interval, oid и money.
F.7.1. Пример использования
Простой пример использования btree_gist вместо btree:
CREATE TABLE test (a int4);
– создать индекс
CREATE INDEX testidx ON test USING GIST (a);
– запрос
SELECT * FROM test WHERE a &lt; 10;
– поиск ближайших соседей: найти десять записей, ближайших к “42”
SELECT *, a &lt;-&gt; 42 AS dist FROM test ORDER BY a &lt;-&gt; 42 LIMIT 10;
Так можно использовать ограничение-исключение, состоящее в том, что в клетке в зоопарке могут
содержаться животные только одного типа:
=&gt; CREATE TABLE zoo (
cage
INTEGER,
2483Дополнительно по-
ставляемые модули
animal TEXT,
EXCLUDE USING GIST (cage WITH =, animal WITH &lt;&gt;)
);
=&gt; INSERT INTO zoo VALUES(123, ‘zebra’);
INSERT 0 1
=&gt; INSERT INTO zoo VALUES(123, ‘zebra’);
INSERT 0 1
=&gt; INSERT INTO zoo VALUES(123, ‘lion’);
ERROR: conflicting key value violates exclusion constraint “zoo_cage_animal_excl”
DETAIL: Key (cage, animal)=(123, lion) conflicts with existing key (cage,
animal)=(123, zebra).
=&gt; INSERT INTO zoo VALUES(124, ‘lion’);
INSERT 0 1
F.7.2. Авторы
Фёдор Сигаев (<a href="mailto:teodor@stack.net">teodor@stack.net</a>), Олег Бартунов (<a href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>), Янко Рихтер
(<a href="mailto:jankorichter@yahoo.de">jankorichter@yahoo.de</a>) и Пол Юнгвирт (<a href="mailto:pj@illuminatedcomputing.com">pj@illuminatedcomputing.com</a>). Подробности мож-
но найти на странице http://www.sai.msu.su/~megera/postgres/gist/.
F.8. citext
Модуль citext предоставляет тип данных для строк, нечувствительных к регистру, citext. По сути
он сравнивает значения, вызывая внутри себя функцию lower. В остальном он почти не отличается
от типа text.
F.8.1. Обоснование
Стандартный способ выполнить сравнение строк без учёта регистра в PostgreSQL заключается в
использовании функции lower при сравнении значений, например
SELECT * FROM tab WHERE lower(col) = LOWER(?);
Этот подход работает довольно хорошо, но имеет ряд недостатков:
• Операторы SQL становятся громоздкими, и нужно не забывать всегда обрабатывать функцией
lower и столбец, и значение.
• Индекс не будет использоваться, если только дополнительно не создать функциональный ин-
декс с функцией lower.
• Если вы объявляете столбец как UNIQUE или PRIMARY KEY, неявно создаваемый индекс будет
чувствительным к регистру. Поэтому он бесполезен для регистронезависимого поиска, так же
как он не будет обеспечивать уникальность без учёта регистра.
Тип данных citext позволяет исключить вызовы lower в SQL-запросах и позволяет сделать пер-
вичный ключ регистронезависимым. Тип citext учитывает локаль, так же, как и тип text, что
означает, что сравнение символов в верхнем и нижнем регистре зависит от правил LC_CTYPE для
базы данных. Это поведение, опять же, не отличается от вызовов lower в запросах. Но так как оно
реализуется прозрачно типом данных, в самих запросах дополнительно не нужно ничего делать.
F.8.2. Как его использовать
Простой пример использования:
CREATE TABLE users (
nick CITEXT PRIMARY KEY,
pass TEXT
NOT NULL
);
INSERT INTO users VALUES ( ‘larry’,
INSERT INTO users VALUES ( ‘Tom’,
sha256(random()::text::bytea) );
sha256(random()::text::bytea) );
2484Дополнительно по-
ставляемые модули
INSERT INTO users VALUES ( ‘Damian’, sha256(random()::text::bytea) );
INSERT INTO users VALUES ( ‘NEAL’,
sha256(random()::text::bytea) );
INSERT INTO users VALUES ( ‘Bjørn’, sha256(random()::text::bytea) );
SELECT * FROM users WHERE nick = ‘Larry’;
Оператор SELECT вернёт один кортеж, несмотря на то, что в столбец nick записано значение larry,
а в запросе фигурирует Larry.
F.8.3. Поведение при сравнении строк
Модуль citext выполняет сравнения, приводя каждую строку к нижнему регистру (как если бы
вызывалась функция lower) и затем производя сравнения как обычно. Так, например, две строки
будут считаться равными, если функция lower, обработав их, выдаст одинаковые результаты.
Чтобы имитировать правило сортировки без учёта регистра в максимально возможной степени,
этот модуль предоставляет специальные, ориентированные на citext, операторы и функции для
обработки строки. Так, например, операторы регулярных выражений ~ и ~* действуют в том же
ключе, когда применяются к типу citext: оба они не учитывают регистр. Это же распространяется
на операторы !~ и !~*, а также операторы LIKE <del>, ~~*, !</del> и !~~*. Если же вы хотите, чтобы эти
операторы учитывали регистр, вы можете привести их аргументы к типу text.
Подобным образом, все следующие функции выполняют сопоставления без учёта регистра, если
их аргументы имеют тип citext:
• regexp_match()
• regexp_matches()
• regexp_replace()
• regexp_split_to_array()
• regexp_split_to_table()
• replace()
• split_part()
• strpos()
• translate()
Для функций с регулярными выражениями, если вам нужно регистрозависимое сопоставление,
вы можете добавить флаг «c», чтобы принудительно включить этот режим. Чтобы получить реги-
строзависимое поведение без этого флага, вы должны привести аргумент к типу text, прежде чем
вызывать эту функцию.
F.8.4. Ограничения
• Смена регистра символов в citext зависит от параметра LC_CTYPE вашей базы данных. Таким
образом, как будут сравниваться значения, определяется при создании базы данных. На са-
мом деле, по определениям стандарта Unicode, это сравнение не будет истинно регистронеза-
висимым. По сути это означает, что если вас устраивает установленное правило сортировки,
вас должны устраивать и сравнения citext. Но если в вашей базе данных хранятся строки на
разных языках, пользователи одного языка могут получать неожиданные результаты запро-
сов, если правило сортировки предназначено для другого языка.
• Начиная с PostgreSQL версии 9.1, вы можете добавлять указание COLLATE к значениям дан-
ных или столбцам citext. В настоящее время операторы citext принимают во внимание та-
кое явное указание COLLATE, сравнивая строки в нижнем регистре, но изначальное приведе-
ние в нижний регистр всегда выполняется согласно параметру LC_CTYPE базы данных (как ес-
ли бы указывалось COLLATE “default”). Это может быть изменено в будущем, чтобы на обоих
этапах учитывалось указание COLLATE во входных данных.
• Тип citext не так эффективен, как text, так как функции операторов и функции сравнения
для B-дерева должны делать копии данных и переводить их в нижний регистр для сравнения.
2485Дополнительно по-
ставляемые модули
Однако он несколько эффективнее варианта с применением lower для получения регистроне-
зависимого сравнения.
• Тип citext малополезен в ситуациях, когда вам нужно сравнивать данные без учёта регистра
в одних контекстах, и с учётом регистра — в других. Обычно в таких случаях используют text
и вручную применяют функцию lower, когда нужно выполнить сравнение без учёта регистра;
это прекрасно работает, если регистронезависимое сравнение требуется выполнять относи-
тельно редко. Если же почти всегда сравнение должно быть регистронезависимым и толь-
ко иногда регистрозависимым, имеет смысл сохранить данные в столбце типа citext, и явно
приводить их к типу text для регистрозависимого сравнения. В любом случае, чтобы оба ва-
рианта поиска были быстрыми, вам потребуются два индекса.
• Схема, содержащая операторы citext, должна находиться в текущем пути search_path (обыч-
но это схема public); в противном случае будут вызываться регистрозависимые операторы
для типа text.
F.8.5. Автор
Дэвид Е. Уилер <a href="mailto:david@kineticode.com">david@kineticode.com</a>
Разработку вдохновил оригинальный модуль citext Дональда Фрейзера.
F.9. cube
Этот модуль реализует тип данных cube для представления многомерных кубов.
F.9.1. Синтаксис
В Таблице F.2 показаны внешние представления типа cube. Буквы x, y и т. д. обозначают числа с
плавающей точкой.
Таблица F.2. Внешние представления кубов
Внешний синтаксис Значение
x Одномерная точка (или одномерный интервал
нулевой длины)
( x) То же, что и выше
x1, x2,…,
( x1, x2,…,
( x),(
Точка в n-мерном пространстве, представленная
внутри как куб нулевого объёма
xn
То же, что и выше
xn)
Одномерный интервал, начинающийся в точке x
и заканчивающийся в y, либо наоборот; порядок
значения не имеет
y)
[( x),(
То же, что и выше
y)]
( x1,…,
[( x1,…,
xn),(
xn),(
y1,…,
y1,…,
N-мерный куб, представленный парой диаго-
нально противоположных углов
yn)
То же, что и выше
yn)]
В каком порядке вводятся противоположные углы куба, не имеет значения. Функции, принима-
ющие тип cube, автоматически меняют углы местами, чтобы получить единое внутреннее пред-
ставление «левый нижний — правый верхний». Когда эти углы совмещаются, в cube для экономии
пространства хранится только один угол с флагом «является точкой».
Пробельные символы игнорируются, так что [(x),(y)] не отличается от [ ( x ), ( y ) ].
F.9.2. Точность
Значения хранятся внутри как 64-битные числа с плавающей точкой. Это значит, что числа с более
чем 16 значащими цифрами будут усекаться.
2486Дополнительно по-
ставляемые модули
F.9.3. Использование
В Таблице F.3 показаны операторы, предназначенные для работы с типом cube.
Таблица F.3. Операторы для кубов
Оператор Результат Описание
a = b boolean Кубы a и b идентичны.
a &amp;&amp; b boolean Кубы a и b пересекаются.
a @&gt; b boolean Куб a включает куб b.
a &lt;@ b boolean Куб a включён в куб b.
a &lt; b boolean Куб a меньше куба b.
a &lt;= b boolean Куб a меньше или равен кубу b.
a &gt; b boolean Куб a больше куба b.
a &gt;= b boolean Куб a больше или равен кубу b.
a &lt;&gt; b boolean Куб a не равен кубу b.
a -&gt; n float8 Выдаёт n-ную координату куба (
отсчитывая с 1).
a ~&gt; n float8 Выдаёт n-ную координату ку-
ба следующим образом: n =
2 * k - 1 обозначает нижнюю
границу k-той размерности, n
= 2 * k обозначает верхнюю
границу k-той размерности. От-
рицательные n обозначают об-
ратное значение соответствую-
щей положительной координа-
ты. Этот оператор предназна-
чен для поддержки KNN-GiST.
a &lt;-&gt; b float8 Евклидово расстояние между a
и b.
a &lt;#&gt; b float8 Расстояние городских кварта-
лов (метрика L-1) между a и b.
a &lt;=&gt; b float8 Расстояние Чебышева (метрика
L-inf) между a и b.
(До версии PostgreSQL 8.2 операторы включения @&gt; и &lt;@ обозначались соответственно как @ и ~.
Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упраздне-
ны. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые
геометрические типы данных!)
Скалярные операторы упорядочивания (&lt;, &gt;= и т. д.) не имеют большого смысла ни для каких прак-
тических целей, кроме сортировки. Эти операторы сначала сравнивают первые координаты и если
они равны, сравнивают вторые и т. д. Они предназначены в основном для поддержки класса опе-
раторов индекса-B-дерева для типа cube, который может быть полезен, например, если вы хотите
создать ограничение UNIQUE для столбца типа cube.
Модуль cube также предоставляет класс операторов индекса GiST для значений cube. Индекс GiST
для cube может применяться для поиска значений в выражениях с операторами =, &amp;&amp;, @&gt; и &lt;@ в
предложениях WHERE.
GiST-индекс для cube может быть полезен и для поиска ближайших соседей с использованием
операторов метрики &lt;-&gt;, &lt;#&gt; и &lt;=&gt; в предложениях ORDER BY. Например, ближайшего соседа точки
в трёхмерном пространстве (0.5, 0.5, 0.5) можно эффективно найти так:
2487Дополнительно по-
ставляемые модули
SELECT c FROM test ORDER BY c &lt;-&gt; cube(array[0.5,0.5,0.5]) LIMIT 1;
Оператор ~&gt; может также использоваться таким образом, чтобы эффективно выдавать первые
несколько значений, отсортированных по выбранной координате. Например, чтобы получить пер-
вые несколько кубов, упорядоченных по возрастанию первой координаты (левого нижнего угла),
можно использовать следующий запрос:
SELECT c FROM test ORDER BY c ~&gt; 1 LIMIT 5;
А чтобы получить двумерные кубы, отсортированные по убыванию первой координаты правого
верхнего угла:
SELECT c FROM test ORDER BY c ~&gt; 3 DESC LIMIT 5;
В Таблице F.4 перечислены все доступные функции.
Таблица F.4. Функции для работы с кубами
Функция Результат Описание
cube(float8) cube Создаёт
одномерный cube(1) == ‘(1)’
куб, у которого обе ко-
ординаты равны.
cube(float8,
float8) cube Создаёт
куб.
cube(float8[]) cube Создаёт куб нулево- cube(ARRAY[1,2]) ==
го объёма по коорди- ‘(1,2)’
натам, определяемым
массивом.
cube(float8[],
float8[]) cube Создаёт куб с коорди- cube(ARRAY[1,2],
натами правого верхне- ARRAY[3,4]) == ‘(
го и левого нижнего 1,2),(3,4)’
углов, определяемыми
двумя массивами, кото-
рые должны быть оди-
наковой длины.
cube(cube, float8) cube Создаёт новый куб, до-
бавляя размерность к
существующему кубу с
одинаковым значением
новой координаты для
обеих углов. Это быва-
ет полезно, когда нуж-
но построить кубы по-
этапно из вычисляемых
значений.
cube(‘(1,2),(3,
4)’::cube,
5)
== ‘(1,2,5),(3,
4,5)’
cube(cube,
float8) cube Создаёт новый куб, до-
бавляя размерность к
существующему кубу.
Это бывает полезно, ко-
гда нужно построить
кубы поэтапно из вы-
числяемых значений.
cube(‘(1,2),(3,
4)’::cube, 5, 6)
== ‘(1,2,5),(3,
4,6)’
cube_dim(cube) integer Возвращает число раз- cube_dim(‘(1,2),
мерностей куба.
(3,4)’) == ‘2’
cube_ll_coord(
cube, integer) float8 Возвращает значение cube_ll_coord(‘(
n-ной координаты лево- 1,2),(3,4)’, 2)
го нижнего угла куба. == ‘2’
float8,
2488
Пример
одномерный cube(1,2) == ‘(1),
(2)’Дополнительно по-
ставляемые модули
Функция Результат Описание
cube_ur_coord(
cube, integer) float8 Возвращает значение cube_ur_coord(‘(
n-ной координаты пра- 1,2),(3,4)’, 2)
вого верхнего угла ку- == ‘4’
ба.
cube_is_point(
cube) boolean Возвращает true, если
куб является точкой, то
есть если два определя-
ющих его угла совпада-
ют.
cube_distance(cube,
cube) float8 Возвращает расстояние
между двумя кубами.
Если оба куба являют-
ся точками, вычисля-
ется обычная функция
расстояния.
cube_subset(cube,
integer[]) cube Создаёт
новый
куб
из существующего, ис-
пользуя список раз-
мерностей из масси-
ва. Может применяться
для получения коорди-
нат углов в одном изме-
рении, для удаления из-
мерений и изменения
их порядка.
cube_union(cube,
cube) cube Создаёт объединение
двух кубов.
cube_inter(cube,
cube) cube Создаёт
пересечение
двух кубов.
cube Увеличивает размер ку-
ба на заданный ра-
диус r как минимум
в n измерениях. Если
радиус отрицательный,
куб, наоборот, умень-
шается. Все определён-
ные измерения изменя-
ются на величину ради-
уса r. Координаты лево-
го нижнего угла умень-
шаются на r, а коорди-
наты правого верхнего
увеличиваются на r. Ес-
ли координата левого
нижнего угла становит-
ся больше соответству-
ющей координаты пра-
вого верхнего (это воз-
можно, только когда r
&lt; 0), обоим координа-
там присваивается их
среднее значение. Ес-
ли n превышает чис-
cube_enlarge(c
cube, r double,
integer)
n
2489
Пример
cube_subset(cube(
‘(1,3,5),(6,7,
8)’),
ARRAY[2])
== ‘(3),(7)’
cube</em>
subset(cube(‘(1,
3,5),(6,7,8)’),
ARRAY[3,2,1,1])
== ‘(5,3,1,1),(
8,7,6,6)’
cube_enlarge(‘(1,
2),(3,4)’, 0.5,
3) == ‘(0.5,1.5,
-0.5),(3.5,4.5,
0.5)’Дополнительно по-
ставляемые модули
Функция
Результат
Описание
Пример
ло определённых изме-
рений и куб увеличива-
ется (r &gt; 0), добавля-
ются дополнительные
размерности, недоста-
ющие до n; началь-
ным значением для до-
полнительных коорди-
нат считается ноль. Эта
функция полезна для
создания окружающих
точку прямоугольников
для поиска ближайших
точек.
F.9.4. Поведение по умолчанию
Я полагаю, что это объединение:
select cube_union(‘(0,5,2),(2,3,1)’, ‘0’);
cube_union
——————-
(0, 0, 0),(2, 5, 2)
(1 row)
не противоречит здравому смыслу, как и это пересечение
select cube_inter(‘(0,-1),(1,1)’, ‘(-2),(2)’);
cube_inter
————-
(0, 0),(1, 0)
(1 row)
Во всех бинарных операциях с кубами разных размерностей, я полагаю, что куб с меньшей размер-
ностью является декартовой проекцией; то есть в опущенных в строковом представлении коорди-
натах предполагаются нули. Таким образом, показанные выше вызовы равнозначны следующим:
cube_union(‘(0,5,2),(2,3,1)’,’(0,0,0),(0,0,0)’);
cube_inter(‘(0,-1),(1,1)’,’(-2,0),(2,0)’);
В следующем предикате включения применяется синтаксис точек, хотя фактически второй аргу-
мент представляется внутри кубом. Этот синтаксис избавляет от необходимости определять от-
дельный тип точек и функции для предикатов (cube,point).
select cube_contains(‘(0,0),(1,1)’, ‘0.5,0.5’);
cube_contains
————–
t
(1 row)
F.9.5. Замечания
Примеры использования можно увидеть в регрессионном тесте sql/cube.sql.
Во избежание некорректного применения этого типа, число размерностей кубов искусственно
ограничено значением 100. Если это ограничение вас не устраивает, его можно изменить в
cubedata.h.
2490Дополнительно по-
ставляемые модули
F.9.6. Благодарности
Первый автор: Джин Селков мл. <a href="mailto:selkovjr@mcs.anl.gov">selkovjr@mcs.anl.gov</a>, Аргоннская национальная лаборатория,
Отдел математики и компьютерных наук
Я очень благодарен в первую очередь профессору Джо Геллерштейну (http://db.cs.berkeley.edu/
jmh/) за пояснение сути GiST (http://gist.cs.berkeley.edu/) и его бывшему студенту, Энди Донгу, за
пример, написанный для Illustra. Я также признателен всем разработчикам Postgres в настоящем
и прошлом за возможность создать свой собственный мир и спокойно жить в нём. Ещё я хотел
бы выразить признательность Аргоннской лаборатории и Министерству энергетики США за годы
постоянной поддержки моих исследований в области баз данных.
Небольшие изменения в этот пакет внёс Бруно Вольф III <a href="mailto:bruno@wolff.to">bruno@wolff.to</a> в августе/сентябре 2002
г. В том числе он перешёл от одинарной к двойной точности и добавил несколько новых функций.
Дополнительные изменения внёс Джошуа Рейх <a href="mailto:josh@root.net">josh@root.net</a> в июле 2006 г. В частности, он
добавил cube(float8[], float8[]), подчистил код и перевёл его на протокол вызовов версии V1
с устаревшего протокола V0.
F.10. dblink
Модуль dblink обеспечивает подключения к другим базам данных PostgreSQL из сеанса базы дан-
ных.
См. также описание модуля postgres_fdw, который предоставляет примерно ту же функциональ-
ность, но через более современную и стандартизированную инфраструктуру.
2491Дополнительно по-
ставляемые модули
dblink_connect
dblink_connect — открывает постоянное подключение к удалённой базе данных
Синтаксис
dblink_connect(text connstr) returns text
dblink_connect(text connname, text connstr) returns text
Описание
Функция dblink_connect() устанавливает подключение к удалённой базе данных PostgreSQL. Це-
левой сервер и база данных указываются в стандартной строке подключения libpq. Если требу-
ется, этому подключению можно назначить имя. В один момент времени могут быть открытыми
несколько именованных подключений, но только одно подключение без имени. Подключение бу-
дет сохраняться, пока не будет закрыто или до завершения сеанса базы данных.
В строке подключения также может задаваться имя существующего стороннего сервера. Для опре-
деления стороннего сервера рекомендуется использовать обёртку сторонних данных dblink_fdw.
См. пример ниже, а также CREATE SERVER и CREATE USER MAPPING.
Аргументы
connname
Имя, назначаемое этому подключению; если опускается, открывается безымянное подключе-
ние, заменяющее ранее существующее безымянное подключение.
connstr
Строка подключения в стиле libpq, например hostaddr=127.0.0.1 port=5432 dbname=mydb
user=postgres password=mypasswd options=-csearch_path=. За подробностями обратитесь к
Подразделу 34.1.1. В ней также может задаваться имя стороннего сервера.
Возвращаемое значение
Возвращает состояние (это всегда строка OK, так как в случае любой ошибки функция прерывается,
выдавая исключение).
Замечания
Если к базе данных, которая не приведена в соответствие шаблону безопасного использова-
ния схем, имеют доступ недоверенные пользователи, начинайте сеанс с удаления доступных им
для записи схем из пути поиска (search_path). Например, для этого можно добавить options=-
csearch_path= в connstr. Это касается не только dblink, но и любых других интерфейсов для вы-
полнения произвольных SQL-команд.
Создавать подключения, не требующие аутентификации по паролю, с помощью dblink_connect
разрешено только суперпользователям. Если эта возможность нужна обычным пользователям,
следует воспользоваться функцией dblink_connect_u.
Использовать в именах подключений знаки «равно» не рекомендуется, так как при этом возможна
путаница со строками подключений в других функциях dblink.
Примеры
SELECT dblink_connect(‘dbname=postgres options=-csearch_path=’);
dblink_connect
—————-
OK
(1 row)
SELECT dblink_connect(‘myconn’, ‘dbname=postgres options=-csearch_path=’);
2492Дополнительно по-
ставляемые модули
dblink_connect
—————-
OK
(1 row)
– Функциональность обёртки сторонних данных (FOREIGN DATA WRAPPER)
– Замечание: чтобы это работало, для локальных подключений требуется аутентификация по
паролю
–
В противном случае, вызвав dblink_connect(), вы получите:
–
———————————————————————-
–
ERROR: password is required
–
DETAIL: Non-superuser cannot connect if the server does not request a
password.
–
HINT: Target server’s authentication method must be changed.
–
–
ОШИБКА: требуется пароль
–
ПОДРОБНОСТИ: Обычный пользователь не может подключиться, если сервер не
требует пароль.
–
ПОДСКАЗКА: Необходимо изменить метод аутентификации целевого сервера.
CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr ‘127.0.0.1’,
dbname ‘contrib_regression’);
CREATE USER regress_dblink_user WITH PASSWORD ‘secret’;
CREATE USER MAPPING FOR regress_dblink_user SERVER fdtest OPTIONS (user
‘regress_dblink_user’, password ‘secret’);
GRANT USAGE ON FOREIGN SERVER fdtest TO regress_dblink_user;
GRANT SELECT ON TABLE foo TO regress_dblink_user;
\set ORIGINAL_USER :USER
\c - regress_dblink_user
SELECT dblink_connect(‘myconn’, ‘fdtest’);
dblink_connect
—————-
OK
(1 row)
SELECT * FROM dblink(‘myconn’,’SELECT * FROM foo’) AS t(a int, b text, c text[]);
a | b |
c
—-+—+—————
0 | a | (a0,b0,c0)
1 | b | (a1,b1,c1)
2 | c | (a2,b2,c2)
3 | d | (a3,b3,c3)
4 | e | (a4,b4,c4)
5 | f | (a5,b5,c5)
6 | g | (a6,b6,c6)
7 | h | (a7,b7,c7)
8 | i | (a8,b8,c8)
9 | j | (a9,b9,c9)
10 | k | (a10,b10,c10)
(11 rows)
\c - :ORIGINAL_USER
REVOKE USAGE ON FOREIGN SERVER fdtest FROM regress_dblink_user;
REVOKE SELECT ON TABLE foo FROM regress_dblink_user;
DROP USER MAPPING FOR regress_dblink_user SERVER fdtest;
DROP USER regress_dblink_user;
2493Дополнительно по-
ставляемые модули
DROP SERVER fdtest;
2494Дополнительно по-
ставляемые модули
dblink_connect_u
dblink_connect_u — открывает постоянное подключение к удалённой базе данных, небезопасно
Синтаксис
dblink_connect_u(text connstr) returns text
dblink_connect_u(text connname, text connstr) returns text
Описание
Функция dblink_connect_u() не отличается от dblink_connect(), за исключением того, что она
позволяет подключаться с любым методом аутентификации обычным пользователям.
Если удалённый сервер выбирает режим аутентификации без пароля, возможно олицетворение
и последующее повышение привилегий, так как сеанс будет установлен от имени пользователя,
который исполняет локальный процесс PostgreSQL. Кроме того, даже если удалённый сервер за-
прашивает пароль, этот пароль можно получить из среды сервера, например, из файла ~/.pgpass,
принадлежащего пользователю сервера. Это чревато не только олицетворением, но и выдачей па-
роля не заслуживающему доверия удалённому серверу. Поэтому dblink_connect_u() изначально
устанавливается так, что роль PUBLIC лишена всех прав на её использование, то есть вызывать
её могут только суперпользователи. В некоторых ситуациях допустимо дать право EXECUTE для
dblink_connect_u() определённым пользователям, которым можно доверять, но это нужно делать
осторожно. Также рекомендуется убедиться в том, что файл ~/.pgpass, принадлежащий пользо-
вателю сервера, не содержит никаких записей со звёздочкой в качестве имени узла.
За дополнительными подробностями обратитесь к описанию dblink_connect().
2495Дополнительно по-
ставляемые модули
dblink_disconnect
dblink_disconnect — закрывает постоянное подключение к удалённой базе данных
Синтаксис
dblink_disconnect() returns text
dblink_disconnect(text connname) returns text
Описание
dblink_disconnect() закрывает подключение, ранее открытое функцией dblink_connect(). Фор-
ма без аргументов закрывает безымянное подключение.
Аргументы
connname
Имя закрываемого именованного подключения.
Возвращаемое значение
Возвращает состояние (это всегда строка OK, так как в случае любой ошибки функция прерывается,
выдавая исключение).
Примеры
SELECT dblink_disconnect();
dblink_disconnect
——————-
OK
(1 row)
SELECT dblink_disconnect(‘myconn’);
dblink_disconnect
——————-
OK
(1 row)
2496Дополнительно по-
ставляемые модули
dblink
dblink — выполняет запрос в удалённой базе данных
Синтаксис
dblink(text connname, text sql [, bool fail_on_error]) returns setof record
dblink(text connstr, text sql [, bool fail_on_error]) returns setof record
dblink(text sql [, bool fail_on_error]) returns setof record
Описание
dblink выполняет запрос (обычно SELECT, но это может быть и любой другой оператор SQL, воз-
вращающий строки) в удалённой базе данных.
Когда этой функции передаются два аргумента типа text, первый сначала рассматривается как
имя постоянного подключения; если такое подключение находится, команда выполняется для
него. Если не находится, первый аргумент воспринимается как строка подключения, как для функ-
ции dblink_connect, и заданное подключение устанавливается только на время выполнения этой
команды.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
connstr
Строка подключения, описанная ранее для dblink_connect
sql
SQL-запрос, который вы хотите выполнить в удалённой базе данных, например select * from
foo.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и функция не возвращает строки.
Возвращаемое значение
Эта функция возвращает строки, выдаваемые в результате запроса. Так как dblink может выпол-
нять произвольные запросы, она объявлена как возвращающая тип record, а не некоторый опре-
делённый набор столбцов. Это означает, что вы должны указать ожидаемый набор столбцов в вы-
зывающем запросе — в противном случае PostgreSQL не будет знать, чего ожидать. Например:
SELECT *
FROM dblink(‘dbname=mydb options=-csearch_path=’,
‘select proname, prosrc from pg_proc’)
AS t1(proname name, prosrc text)
WHERE proname LIKE ‘bytea%’;
В части «псевдонима» предложения FROM должны указываться имена столбцов и типы, которые
будет возвращать функция. (Указание имён столбцов в псевдониме таблицы предусмотрено стан-
дартом SQL, но определение типов столбцов является расширением PostgreSQL.) Это позволяет
системе понять, во что должно разворачиваться обозначение *, и на что ссылается proname в пред-
ложении WHERE, прежде чем пытаться выполнять эту функцию. Во время выполнения произойдёт
ошибка, если действительный результат запроса из удалённой базы данных не будет содержать
2497Дополнительно по-
ставляемые модули
столько столбцов, сколько указано в предложении FROM. Однако имена столбцов могут не совпа-
дать, так же, как dblink не настаивает на точном совпадении типов. Функция завершится успеш-
но, если возвращаемые строки данных будут допустимыми для ввода в тип столбца, объявленный
в предложении FROM.
Замечания
Использовать dblink с предопределёнными запросами будет удобнее, если создать представление.
Это позволит скрыть в его определении информацию о типах столбцов и не выписывать её в каждом
запросе. Например:
CREATE VIEW myremote_pg_proc AS
SELECT *
FROM dblink(‘dbname=postgres options=-csearch_path=’,
‘select proname, prosrc from pg_proc’)
AS t1(proname name, prosrc text);
SELECT * FROM myremote_pg_proc WHERE proname LIKE ‘bytea%’;
Примеры
SELECT * FROM dblink(‘dbname=postgres options=-csearch_path=’,
‘select proname, prosrc from pg_proc’)
AS t1(proname name, prosrc text) WHERE proname LIKE ‘bytea%’;
proname
|
prosrc
————+————
byteacat
| byteacat
byteaeq
| byteaeq
bytealt
| bytealt
byteale
| byteale
byteagt
| byteagt
byteage
| byteage
byteane
| byteane
byteacmp
| byteacmp
bytealike | bytealike
byteanlike | byteanlike
byteain
| byteain
byteaout
| byteaout
(12 rows)
SELECT dblink_connect(‘dbname=postgres options=-csearch_path=’);
dblink_connect
—————-
OK
(1 row)
SELECT * FROM dblink(‘select proname, prosrc from pg_proc’)
AS t1(proname name, prosrc text) WHERE proname LIKE ‘bytea%’;
proname
|
prosrc
————+————
byteacat
| byteacat
byteaeq
| byteaeq
bytealt
| bytealt
byteale
| byteale
byteagt
| byteagt
byteage
| byteage
byteane
| byteane
byteacmp
| byteacmp
bytealike | bytealike
byteanlike | byteanlike
2498Дополнительно по-
ставляемые модули
byteain
byteaout
(12 rows)
| byteain
| byteaout
SELECT dblink_connect(‘myconn’, ‘dbname=regression options=-csearch_path=’);
dblink_connect
—————-
OK
(1 row)
SELECT * FROM dblink(‘myconn’, ‘select proname, prosrc from pg_proc’)
AS t1(proname name, prosrc text) WHERE proname LIKE ‘bytea%’;
proname
|
prosrc
————+————
bytearecv | bytearecv
byteasend | byteasend
byteale
| byteale
byteagt
| byteagt
byteage
| byteage
byteane
| byteane
byteacmp
| byteacmp
bytealike | bytealike
byteanlike | byteanlike
byteacat
| byteacat
byteaeq
| byteaeq
bytealt
| bytealt
byteain
| byteain
byteaout
| byteaout
(14 rows)
2499Дополнительно по-
ставляемые модули
dblink_exec
dblink_exec — выполняет команду в удалённой базе данных
Синтаксис
dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
dblink_exec(text sql [, bool fail_on_error]) returns text
Описание
Функция dblink_exec выполняет команду (то есть любой SQL-оператор, не возвращающий строки)
в удалённой базе данных.
Когда этой функции передаются два аргумента типа text, первый сначала рассматривается как
имя постоянного подключения; если такое подключение находится, команда выполняется для
него. Если не находится, первый аргумент воспринимается как строка подключения, как для функ-
ции dblink_connect, и заданное подключение устанавливается только на время выполнения этой
команды.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
connstr
Строка подключения, описанная ранее для dblink_connect
sql
SQL-запрос, который вы хотите выполнить в удалённой базе данных, например insert into
foo values(0,’a’,’(“a0”,”b0”,”c0”)’).
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и возвращаемым значением функции будет ERROR.
Возвращаемое значение
Возвращает состояние (либо строку состояния команды, либо ERROR).
Примеры
SELECT dblink_connect(‘dbname=dblink_test_standby’);
dblink_connect
—————-
OK
(1 row)
SELECT dblink_exec(‘insert into foo values(21,’‘z’’,’’(“a0”,”b0”,”c0”)’’);’);
dblink_exec
—————–
INSERT 943366 1
(1 row)
2500Дополнительно по-
ставляемые модули
SELECT dblink_connect(‘myconn’, ‘dbname=regression’);
dblink_connect
—————-
OK
(1 row)
SELECT dblink_exec(‘myconn’, ‘insert into foo values(21,’‘z’’,’’(“a0”,”b0”,”c0”)’’);’);
dblink_exec
——————
INSERT 6432584 1
(1 row)
SELECT dblink_exec(‘myconn’, ‘insert into pg_class values (‘‘foo’’)’,false);
NOTICE: sql error
DETAIL: ERROR: null value in column “relnamespace” violates not-null constraint
dblink_exec
————-
ERROR
(1 row)
2501Дополнительно по-
ставляемые модули
dblink_open
dblink_open — открывает курсор в удалённой базе данных
Синтаксис
dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text
dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns
text
Описание
Функция dblink_open() открывает курсор в удалённой базе данных. Открытым курсором можно
будет манипулировать функциями dblink_fetch() и dblink_close().
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
cursorname
Имя, назначаемое курсору.
sql
Оператор SELECT, который вы хотите выполнять в удалённой базе данных, например select *
from pg_class.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и возвращаемым значением функции будет ERROR.
Возвращаемое значение
Возвращает состояние, OK или ERROR.
Замечания
Так как курсор может существовать только в рамках транзакции, функция dblink_open начина-
ет явный блок транзакции (командой BEGIN) на удалённой стороне, если транзакция там ещё
не открыта. Эта транзакция будет снова закрыта при соответствующем вызове dblink_close. За-
метьте, что если вы с помощью dblink_exec изменяете данные между вызовами dblink_open
и dblink_close, а затем происходит ошибка, либо если вы вызываете dblink_disconnect перед
dblink_close, ваши изменения будут потеряны, так как транзакция будет прервана.
Примеры
SELECT dblink_connect(‘dbname=postgres options=-csearch_path=’);
dblink_connect
—————-
OK
(1 row)
SELECT dblink_open(‘foo’, ‘select proname, prosrc from pg_proc’);
dblink_open
————-
2502Дополнительно по-
ставляемые модули
OK
(1 row)
2503Дополнительно по-
ставляемые модули
dblink_fetch
dblink_fetch — возвращает строки из открытого курсора в удалённой базе данных
Синтаксис
dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record
dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error])
returns setof record
Описание
dblink_fetch выбирает строки из курсора, ранее открытого функцией dblink_open.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
cursorname
Имя курсора, из которого выбираются данные.
howmany
Максимальное число строк, которое нужно получить. Данная функция выбирает через курсор
следующие howmany строк, начиная с текущей позиции курсора и двигаясь вперёд. Когда курсор
доходит до конца, строки больше не выдаются.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и функция не возвращает строки.
Возвращаемое значение
Эта функция возвращает строки, выбираемые через курсор. Для использования этой функции
необходимо задать ожидаемый набор столбцов, как ранее говорилось в описании dblink.
Замечания
При несовпадении числа возвращаемых столбцов, определённого в предложении FROM, с фактиче-
ским числом столбцов, возвращённых удалённым курсором, выдаётся ошибка. В этом случае уда-
лённый курсор всё равно продвигается на столько строк, на сколько он продвинулся бы, если бы
ошибка не произошла. То же самое верно для любых других ошибок, происходящих при локальной
обработке результатов после выполнения удалённой команды FETCH.
Примеры
SELECT dblink_connect(‘dbname=postgres options=-csearch_path=’);
dblink_connect
—————-
OK
(1 row)
SELECT dblink_open(‘foo’, ‘select proname, prosrc from pg_proc where proname like
‘‘bytea%’’’);
dblink_open
————-
2504Дополнительно по-
ставляемые модули
OK
(1 row)
SELECT * FROM dblink_fetch(‘foo’, 5) AS (funcname name, source text);
funcname | source
———-+———-
byteacat | byteacat
byteacmp | byteacmp
byteaeq | byteaeq
byteage | byteage
byteagt | byteagt
(5 rows)
SELECT * FROM dblink_fetch(‘foo’, 5) AS (funcname name, source text);
funcname | source
———–+———–
byteain
| byteain
byteale
| byteale
bytealike | bytealike
bytealt
| bytealt
byteane
| byteane
(5 rows)
SELECT * FROM dblink_fetch(‘foo’, 5) AS (funcname name, source text);
funcname |
source
————+————
byteanlike | byteanlike
byteaout
| byteaout
(2 rows)
SELECT * FROM dblink_fetch(‘foo’, 5) AS (funcname name, source text);
funcname | source
———-+——–
(0 rows)
2505Дополнительно по-
ставляемые модули
dblink_close
dblink_close — закрывает курсор в текущей базе данных
Синтаксис
dblink_close(text cursorname [, bool fail_on_error]) returns text
dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text
Описание
dblink_close закрывает курсор, ранее открытый функцией dblink_open.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
cursorname
Имя курсора, который будет закрыт.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и возвращаемым значением функции будет ERROR.
Возвращаемое значение
Возвращает состояние, OK или ERROR.
Замечания
Если вызов dblink_open начал явный блок транзакции и это последний открытый курсор, оставав-
шийся в этом подключении, то dblink_close выполнит соответствующую команду COMMIT.
Примеры
SELECT dblink_connect(‘dbname=postgres options=-csearch_path=’);
dblink_connect
—————-
OK
(1 row)
SELECT dblink_open(‘foo’, ‘select proname, prosrc from pg_proc’);
dblink_open
————-
OK
(1 row)
SELECT dblink_close(‘foo’);
dblink_close
————–
OK
(1 row)
2506Дополнительно по-
ставляемые модули
dblink_get_connections
dblink_get_connections — возвращает имена всех открытых именованных подключений dblink
Синтаксис
dblink_get_connections() returns text[]
Описание
dblink_get_connections возвращает массив имён всех открытых именованных подключений
dblink.
Возвращаемое значение
Возвращает текстовый массив имён подключений, либо NULL, если они отсутствуют.
Примеры
SELECT dblink_get_connections();
2507Дополнительно по-
ставляемые модули
dblink_error_message
dblink_error_message — выдаёт сообщение последней ошибки для именованного подключения
Синтаксис
dblink_error_message(text connname) returns text
Описание
dblink_error_message извлекает самое последнее сообщение удалённой ошибки для заданного
подключения.
Аргументы
connname
Имя используемого подключения.
Возвращаемое значение
Возвращает сообщение последней ошибки, либо пустую строку, если в сеансе этого подключения
не было ошибок.
Примеры
SELECT dblink_error_message(‘dtest1’);
2508Дополнительно по-
ставляемые модули
dblink_send_query
dblink_send_query — передаёт асинхронный запрос в удалённую базу данных
Синтаксис
dblink_send_query(text connname, text sql) returns int
Описание
dblink_send_query передаёт запрос для асинхронного выполнения, то есть не дожидается получе-
ния результата. С этим подключением не должен быть связан уже выполняющийся асинхронный
запрос.
После успешной передачи асинхронного запроса состояние его завершения можно проверять,
вызывая функцию dblink_is_busy, и в итоге получать данные, вызвав dblink_get_result. Также
можно попытаться отменить активный асинхронный запрос, вызвав dblink_cancel_query.
Аргументы
connname
Имя используемого подключения.
sql
Оператор SQL, который вы хотите выполнить в удалённой базе данных, например select *
from pg_class.
Возвращаемое значение
Возвращает 1, если запрос был успешно отправлен на обработку, или 0 в противном случае.
Примеры
SELECT dblink_send_query(‘dtest1’, ‘SELECT * FROM foo WHERE f1 &lt; 3’);
2509Дополнительно по-
ставляемые модули
dblink_is_busy
dblink_is_busy — проверяет, не выполняется ли через подключение асинхронный запрос
Синтаксис
dblink_is_busy(text connname) returns int
Описание
dblink_is_busy проверяет, не выполняется ли асинхронный запрос.
Аргументы
connname
Имя проверяемого подключения.
Возвращаемое значение
Возвращает 1, если подключение занято, или 0 в противном случае. Если эта функция возвращает
0, гарантируется, что вызов dblink_get_result не будет заблокирован.
Примеры
SELECT dblink_is_busy(‘dtest1’);
2510Дополнительно по-
ставляемые модули
dblink_get_notify
dblink_get_notify — выдаёт асинхронные уведомления подключения
Синтаксис
dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)
dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra
text)
Описание
dblink_get_notify выдаёт уведомления либо безымянного подключения, либо подключения с
заданным именем. Чтобы получать уведомления через dblink, необходимо сначала выполнить
LISTEN, воспользовавшись функцией dblink_exec. За подробностями обратитесь к LISTEN и
NOTIFY.
Аргументы
connname
Имя именованного подключения, уведомления которого нужно получить.
Возвращаемое значение
Возвращает setof (notify_name text, be_pid int, extra text) или пустой набор, если уведом-
лений нет.
Примеры
SELECT dblink_exec(‘LISTEN virtual’);
dblink_exec
————-
LISTEN
(1 row)
SELECT * FROM dblink_get_notify();
notify_name | be_pid | extra
————-+——–+——-
(0 rows)
NOTIFY virtual;
NOTIFY
SELECT * FROM dblink_get_notify();
notify_name | be_pid | extra
————-+——–+——-
virtual
|
1229 |
(1 row)
2511Дополнительно по-
ставляемые модули
dblink_get_result
dblink_get_result — получает результат асинхронного запроса
Синтаксис
dblink_get_result(text connname [, bool fail_on_error]) returns setof record
Описание
dblink_get_result получает результаты асинхронного запроса, запущенного ранее вызовом
dblink_send_query. Если запрос ещё выполняется, dblink_get_result будет ждать его заверше-
ния.
Аргументы
connname
Имя используемого подключения.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и функция не возвращает строки.
Возвращаемое значение
Для асинхронного запроса (то есть, SQL-оператора, возвращающего строки) эта функция выдаёт
строки, полученные в результате запроса. Чтобы использовать эту функцию, вы должны задать
ожидаемый набор столбцов, как ранее говорилось в описании dblink.
Для асинхронной команды (то есть, SQL-оператора, не возвращающего строки), эта функция воз-
вращает одну строку с одним текстовым столбцом, содержащим строку состояния команды. Для
такого вызова в предложении FROM так же необходимо определить, что результат будет содержать
один текстовый столбец.
Замечания
Эта функция должна вызываться, если dblink_send_query возвращает 1. Её нужно вызывать по
одному разу для каждого отправленного запроса, а затем ещё раз для получения пустого набора
данных, прежде чем подключением можно будет пользоваться снова.
Когда используются dblink_send_query и dblink_get_result, подсистема dblink получает весь на-
бор удалённых результатов, прежде чем передавать его для локальной обработки. Если запрос
возвращает большое количество строк, это может занимать много памяти в локальном сеансе.
Поэтому может быть лучше открыть такой запрос как курсор, вызвав dblink_open, а затем выби-
рать результаты удобоваримыми порциями. Кроме того, можно воспользоваться простой функци-
ей dblink(), которая не допускает заполнения памяти, выгружая большие наборы результатов на
диск.
Примеры
contrib_regression=# SELECT dblink_connect(‘dtest1’, ‘dbname=contrib_regression’);
dblink_connect
—————-
OK
(1 row)
contrib_regression=# SELECT * FROM
2512Дополнительно по-
ставляемые модули
contrib_regression-# dblink_send_query(‘dtest1’, ‘select * from foo where f1 &lt; 3’) AS
t1;
t1
—-
1
(1 row)
contrib_regression=# SELECT * FROM dblink_get_result(‘dtest1’) AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 |
f3
—-+—-+————
0 | a | (a0,b0,c0)
1 | b | (a1,b1,c1)
2 | c | (a2,b2,c2)
(3 rows)
contrib_regression=# SELECT * FROM dblink_get_result(‘dtest1’) AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 | f3
—-+—-+—-
(0 rows)
contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query(‘dtest1’, ‘select * from foo where f1 &lt; 3;
select * from foo where f1 &gt; 6’) AS t1;
t1
—-
1
(1 row)
contrib_regression=# SELECT * FROM dblink_get_result(‘dtest1’) AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 |
f3
—-+—-+————
0 | a | (a0,b0,c0)
1 | b | (a1,b1,c1)
2 | c | (a2,b2,c2)
(3 rows)
contrib_regression=# SELECT * FROM dblink_get_result(‘dtest1’) AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 |
f3
—-+—-+—————
7 | h | (a7,b7,c7)
8 | i | (a8,b8,c8)
9 | j | (a9,b9,c9)
10 | k | (a10,b10,c10)
(4 rows)
contrib_regression=# SELECT * FROM dblink_get_result(‘dtest1’) AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 | f3
—-+—-+—-
(0 rows)
2513Дополнительно по-
ставляемые модули
dblink_cancel_query
dblink_cancel_query — отменяет любой активный запрос в заданном подключении
Синтаксис
dblink_cancel_query(text connname) returns text
Описание
Функция dblink_cancel_query пытается отменить любой запрос, выполняющийся через заданное
подключение. Заметьте, что её вызов не обязательно будет успешным (например, потому что уда-
лённый запрос уже завершился). Запрос отмены просто увеличивает шансы того, что выполняю-
щийся запрос будет вскоре прерван. При этом всё равно нужно завершить обычную процедуру
обработки запроса, например, вызвать dblink_get_result.
Аргументы
connname
Имя используемого подключения.
Возвращаемое значение
Возвращает OK, если запрос отмены был отправлен, либо текст сообщения об ошибке в случае
неудачи.
Примеры
SELECT dblink_cancel_query(‘dtest1’);
2514Дополнительно по-
ставляемые модули
dblink_get_pkey
dblink_get_pkey — возвращает позиции и имена полей первичного ключа отношения
Синтаксис
dblink_get_pkey(text relname) returns setof dblink_pkey_results
Описание
Функция dblink_get_pkey выдаёт информацию о первичном ключе отношения в локальной базе
данных. Иногда это полезно при формировании запросов, отправляемых в удалённые базы данных.
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
“FooBar”; без кавычек эта строка приводится к нижнему регистру.
Возвращаемое значение
Возвращает одну строку для каждого поля первичного ключа, либо не возвращает строк, если в
отношении нет первичного ключа. Тип результирующей строки определён как
CREATE TYPE dblink_pkey_results AS (position int, colname text);
В столбце position содержится число от 1 до N; это номер поля в первичном ключе, а не номер
столбца в списке столбцов таблицы.
Примеры
CREATE TABLE foobar (
f1 int,
f2 int,
f3 int,
PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE
SELECT * FROM dblink_get_pkey(‘foobar’);
position | colname
———-+———
1 | f1
2 | f2
3 | f3
(3 rows)
2515Дополнительно по-
ставляемые модули
dblink_build_sql_insert
dblink_build_sql_insert — формирует оператор INSERT из локального кортежа, заменяя значения
полей первичного ключа переданными альтернативными значениями
Синтаксис
dblink_build_sql_insert(text relname,
int2vector primary_key_attnums,
integer num_primary_key_atts,
text[] src_pk_att_vals_array,
text[] tgt_pk_att_vals_array) returns text
Описание
Функция dblink_build_sql_insert может быть полезна при избирательной репликации локальной
таблицы с удалённой базой данных. Она выбирает строку из локальной таблицы по заданному
первичному ключу, а затем формирует SQL-команду INSERT, дублирующую эту строку, но заменяет
в ней значения первичного ключа данными из последнего аргумента. (Чтобы получить точную
копию строки, просто укажите одинаковые значения в двух последних аргументах.)
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
“FooBar”; без кавычек эта строка приводится к нижнему регистру.
primary_key_attnums
Номера атрибутов (начиная с 1) полей первичного ключа, например 1 2.
num_primary_key_atts
Число полей первичного ключа.
src_pk_att_vals_array
Значения полей первичного ключа, по которым будет выполняться поиск локального кортежа.
Каждое поле здесь представляется в текстовом виде. Если локальной строки с этими значени-
ями первичного ключа нет, выдаётся ошибка.
tgt_pk_att_vals_array
Значения полей первичного ключа, которые будут помещены в результирующую команду
INSERT. Каждое поле представляется в текстовом виде.
Возвращаемое значение
Возвращает запрошенный SQL-оператор в текстовом виде.
Замечания
Начиная с PostgreSQL 9.0, номера атрибутов в primary_key_attnums воспринимаются как логиче-
ские номера столбцов, соответствующие позициям столбцов в SELECT * FROM relname. Предыду-
щие версии воспринимали эти номера как физические позиции столбцов. Отличие этих подходов
проявляется, когда на протяжении жизни таблицы из неё удаляются столбцы левее указанных.
Примеры
SELECT dblink_build_sql_insert(‘foo’, ‘1 2’, 2, ‘(“1”, “a”)’, ‘(“1”, “b’‘a”)’);
2516Дополнительно по-
ставляемые модули
dblink_build_sql_insert
————————————————–
INSERT INTO foo(f1,f2,f3) VALUES(‘1’,’b’‘a’,’1’)
(1 row)
2517Дополнительно по-
ставляемые модули
dblink_build_sql_delete
dblink_build_sql_delete — формирует оператор DELETE со значениями, передаваемыми для полей
первичного ключа
Синтаксис
dblink_build_sql_delete(text relname,
int2vector primary_key_attnums,
integer num_primary_key_atts,
text[] tgt_pk_att_vals_array) returns text
Описание
Функция dblink_build_sql_delete может быть полезна при избирательной репликации локальной
таблицы с удалённой базой данных. Она формирует SQL-команду DELETE, которая удалит строку с
заданными значениями первичного ключа.
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
“FooBar”; без кавычек эта строка приводится к нижнему регистру.
primary_key_attnums
Номера атрибутов (начиная с 1) полей первичного ключа, например 1 2.
num_primary_key_atts
Число полей первичного ключа.
tgt_pk_att_vals_array
Значения полей первичного ключа, которые будут использоваться в результирующей команде
DELETE. Каждое поле представляется в текстовом виде.
Возвращаемое значение
Возвращает запрошенный SQL-оператор в текстовом виде.
Замечания
Начиная с PostgreSQL 9.0, номера атрибутов в primary_key_attnums воспринимаются как логиче-
ские номера столбцов, соответствующие позициям столбцов в SELECT * FROM relname. Предыду-
щие версии воспринимали эти номера как физические позиции столбцов. Отличие этих подходов
проявляется, когда на протяжении жизни таблицы из неё удаляются столбцы левее указанных.
Примеры
SELECT dblink_build_sql_delete(‘“MyFoo”’, ‘1 2’, 2, ‘(“1”, “b”)’);
dblink_build_sql_delete
———————————————
DELETE FROM “MyFoo” WHERE f1=’1’ AND f2=’b’
(1 row)
2518Дополнительно по-
ставляемые модули
dblink_build_sql_update
dblink_build_sql_update — формирует оператор UPDATE из локального кортежа, заменяя значения
первичного ключа переданными альтернативными значениями
Синтаксис
dblink_build_sql_update(text relname,
int2vector primary_key_attnums,
integer num_primary_key_atts,
text[] src_pk_att_vals_array,
text[] tgt_pk_att_vals_array) returns text
Описание
Функция dblink_build_sql_update может быть полезна при избирательной репликации локаль-
ной таблицы с удалённой базой данных. Она выбирает строку из локальной таблицы по заданному
первичному ключу, а затем формирует SQL-команду UPDATE, дублирующую эту строку, но заме-
няющую в ней значения первичного ключа данными из последнего аргумента. (Чтобы получить
точную копию строки, просто укажите одинаковые значения в двух последних аргументах.) Ко-
манда UPDATE всегда присваивает значения всем полям строки — основное отличие этой функции
от dblink_build_sql_insert в том, что она предполагает, что целевая строка уже существует в
удалённой таблице.
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
“FooBar”; без кавычек эта строка приводится к нижнему регистру.
primary_key_attnums
Номера атрибутов (начиная с 1) полей первичного ключа, например 1 2.
num_primary_key_atts
Число полей первичного ключа.
src_pk_att_vals_array
Значения полей первичного ключа, по которым будет выполняться поиск локального кортежа.
Каждое поле здесь представляется в текстовом виде. Если локальной строки с этими значени-
ями первичного ключа нет, выдаётся ошибка.
tgt_pk_att_vals_array
Значения полей первичного ключа, которые будут помещены в результирующую команду
UPDATE. Каждое поле представляется в текстовом виде.
Возвращаемое значение
Возвращает запрошенный SQL-оператор в текстовом виде.
Замечания
Начиная с PostgreSQL 9.0, номера атрибутов в primary_key_attnums воспринимаются как логиче-
ские номера столбцов, соответствующие позициям столбцов в SELECT * FROM relname. Предыду-
щие версии воспринимали эти номера как физические позиции столбцов. Отличие этих подходов
проявляется, когда на протяжении жизни таблицы из неё удаляются столбцы левее указанных.
Примеры
SELECT dblink_build_sql_update(‘foo’, ‘1 2’, 2, ‘(“1”, “a”)’, ‘(“1”, “b”)’);
2519Дополнительно по-
ставляемые модули
dblink_build_sql_update
————————————————————-
UPDATE foo SET f1=’1’,f2=’b’,f3=’1’ WHERE f1=’1’ AND f2=’b’
(1 row)
F.11. dict_int
Модуль dict_int представляет собой пример дополнительного шаблона словаря для полнотексто-
вого поиска. Этот словарь был создан для управляемой индексации целых чисел (со знаком и без);
он позволяет индексировать такие числа и при этом избежать чрезмерного разрастания списка
уникальных слов, и тем самым значительно увеличивает скорость поиска.
F.11.1. Конфигурирование
Этот словарь принимает два параметра:
• Параметр maxlen задаёт максимальное число цифр, из которого может состоять целое число.
Значение по умолчанию — 6.
• Параметр rejectlong определяет, должны ли чрезмерно длинные числа усекаться или игно-
рироваться. Если rejectlong имеет значение false (по умолчанию), этот словарь возвраща-
ет первые maxlen цифр целого числа. Если rejectlong равен true, чрезмерное длинное целое
воспринимается как стоп-слово, и в результате не индексируется. Заметьте, это означает, что
такое целое нельзя будет найти.
F.11.2. Использование
При установке расширения dict_int в базе создаётся шаблон текстового поиска intdict_template
и словарь intdict на его базе, с параметрами по умолчанию. Вы можете изменить параметры
словаря, например так:
mydb# ALTER TEXT SEARCH DICTIONARY intdict (MAXLEN = 4, REJECTLONG = true);
ALTER TEXT SEARCH DICTIONARY
или создать новые словари на базе этого шаблона.
Протестировать этот словарь можно так:
mydb# select ts_lexize(‘intdict’, ‘12345678’);
ts_lexize
———–
(123456)
Но для практического применения его нужно включить в конфигурацию текстового поиска, как
описано в Главе 12. Это может выглядеть примерно так:
ALTER TEXT SEARCH CONFIGURATION english
ALTER MAPPING FOR int, uint WITH intdict;
F.12. dict_xsyn
Модуль dict_xsyn (Extended Synonym Dictionary, расширенный словарь синонимов) представляет
собой пример дополнительного шаблона словаря для полнотекстового поиска. Этот словарь заме-
няет слова группами их синонимов, что позволяет находить слово по одному из его синонимов.
F.12.1. Конфигурирование
Словарь dict_xsyn принимает следующие параметры:
• Параметр matchorig определяет, будет ли словарь принимать изначальное слово. По умолча-
нию он включён (имеет значение true).
• Параметр matchsynonyms определяет, будет ли словарь принимать синонимы. По умолчанию
он отключён (имеет значение false).
2520Дополнительно по-
ставляемые модули
• Параметр keeporig определяет, будет ли исходное слово включаться в вывод словаря. По
умолчанию он включён (имеет значение true).
• Параметр keepsynonyms определяет, будут ли в вывод словаря включаться синонимы. По
умолчанию он включён (имеет значение true).
• Параметр rules задаёт базовое имя файла со списком синонимов. Этот файл должен нахо-
диться в каталоге $SHAREDIR/tsearch_data/ (где под $SHAREDIR понимается каталог с общими
данными инсталляции PostgreSQL). Имя файла должно заканчиваться расширением .rules
(которое не нужно указывать в параметре rules).
Файл правил имеет следующий формат:
• Каждая строка представляет группу синонимов для одного слова, которое задаётся первым в
этой строке. Символы разделяются пробельными символами, так что строка выглядит так:
word syn1 syn2 syn3
• Символ решётки (#) обозначает начало комментария. Он может находиться в любом месте
строки. Следующая за ним часть строки игнорируется.
Пример словаря можно найти в файле xsyn_sample.rules, устанавливаемом в $SHAREDIR/
tsearch_data/.
F.12.2. Использование
При установке расширения dict_xsyn в базе создаётся шаблон текстового поиска xsyn_template и
словарь xsyn на его базе, с параметрами по умолчанию. Вы можете изменить параметры словаря,
например так:
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES=’my_rules’, KEEPORIG=false);
ALTER TEXT SEARCH DICTIONARY
или создать новые словари на базе этого шаблона.
Протестировать этот словарь можно так:
mydb=# SELECT ts_lexize(‘xsyn’, ‘word’);
ts_lexize
———————–
(syn1,syn2,syn3)
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES=’my_rules’, KEEPORIG=true);
ALTER TEXT SEARCH DICTIONARY
mydb=# SELECT ts_lexize(‘xsyn’, ‘word’);
ts_lexize
———————–
(word,syn1,syn2,syn3)
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES=’my_rules’, KEEPORIG=false,
MATCHSYNONYMS=true);
ALTER TEXT SEARCH DICTIONARY
mydb=# SELECT ts_lexize(‘xsyn’, ‘syn1’);
ts_lexize
———————–
(syn1,syn2,syn3)
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES=’my_rules’, KEEPORIG=true,
MATCHORIG=false, KEEPSYNONYMS=false);
ALTER TEXT SEARCH DICTIONARY
mydb=# SELECT ts_lexize(‘xsyn’, ‘syn1’);
2521Дополнительно по-
ставляемые модули
ts_lexize
———————–
(word)
Но для практического применения его нужно включить в конфигурацию текстового поиска, как
описано в Главе 12. Это может выглядеть примерно так:
ALTER TEXT SEARCH CONFIGURATION english
ALTER MAPPING FOR word, asciiword WITH xsyn, english_stem;
F.13. earthdistance
Модуль earthdistance реализует два разных варианта вычисления ортодромии (расстояния между
точками на поверхности Земли). Описанный первым вариант зависит от модуля cube (который
должен быть установлен, чтобы можно было установить earthdistance). Второй вариант основан
на встроенном типе данных point, в котором в качестве координат задаётся широта и долгота.
В этом модуле Земля считается идеальной сферой. (Если для вас это слишком грубо, обратите
внимание на проект PostGIS project.)
F.13.1. Земные расстояния по кубам
Данные хранятся в кубах, представляющих точки (оба угла куба совпадают) по 3 координатам,
выражающим смещения x, y и z от центра Земли. Этот модуль предоставляет домен earth на базе
cube, включающий проверки того, что значение соответствует этим ограничениям и представляет
точку, достаточно близкую к сферической поверхности Земли.
Радиус Земли выдаёт функция earth() (в метрах). Изменив одну эту функцию, вы можете сделать
так, чтобы модуль работал с другими единицами, либо выдать другое значение радиуса, которое
кажется вам более подходящим.
Этот пакет может также применяться и для астрономических расчётов. Астрономы обычно меня-
ют функцию earth(), чтобы она возвращала радиус, равный 180/pi(), и расстояния в результате
выдавались в градусах.
В этом модуле реализованы функции для ввода данных, выражающих широту и долготу (в граду-
сах), для вывода ширины и долготы, для вычисления ортодромии между двумя точками и простого
указания окружающего прямоугольника, что полезно для поиска по индексу.
Предоставляемые этим модулем функции показаны в Таблица F.5.
Таблица F.5. Функции земных расстояний по кубам
Функция Возвращает Описание
earth() float8 Возвращает
предполагаемый
радиус Земли.
sec_to_gc(float8) float8 Переводит расстояние по обыч-
ной прямой (по секущей) меж-
ду двумя точками на поверхно-
сти Земли в расстояние между
ними по сфере.
gc_to_sec(float8) float8 Переводит расстояние по сфе-
ре между двумя точками на по-
верхности Земли в расстояние
по обычной прямой (по секу-
щей) между ними.
ll_to_earth(float8,
float8) earth Возвращает положение точки
на поверхности Земли по задан-
ной широте (аргумент 1) и дол-
готе (аргумент 2) в градусах.
2522Дополнительно по-
ставляемые модули
Функция Возвращает Описание
latitude(earth) float8 Возвращает широту (в градусах)
точки на поверхности Земли.
longitude(earth) float8 Возвращает долготу (в граду-
сах) точки на поверхности Зем-
ли.
earth_distance(earth,
earth) float8 Возвращает расстояние по сфе-
ре между двумя точками на по-
верхности Земли.
earth_box(earth, float8) cube Возвращает охватывающий куб,
подходящий для поиска по ин-
дексу с применением операто-
ра кубов @&gt; точек в пределах
заданной ортодромии от цели.
Некоторые точки в этом кубе
будут отстоять от цели дальше,
чем на заданную ортодромию,
поэтому в запрос нужно вклю-
чить вторую проверку с функци-
ей earth_distance .
F.13.2. Земные расстояния по точкам
Вторая часть этого модуля основана на представлении точек на Земле в виде значений типа point,
в которых первый компонент представляет долготу в градусах, а второй — широту. Точки воспри-
нимаются как (долгота, широта), а не наоборот, так как долгота ближе к интуитивному представ-
лению как оси X, а широта — оси Y.
В модуле реализован один оператор, показанный в Таблице F.6.
Таблица F.6. Операторы земных расстояний по точкам
Оператор Возвращает Описание
point &lt;@&gt; point float8 Выдаёт расстояние в сухопут-
ных милях между точками на
поверхности Земли.
Заметьте, что в этой части модуля, в отличие от части, построенной на cube, единицы зашиты
жёстко: изменение функции earth() не повлияет на результат этого оператора.
Представление в виде долготы/широты плохо тем, что вам придётся учитывать граничные условия
возле полюсов и в районе +/- 180 градусов долготы. Представление на базе cube лишено таких
нарушений непрерывности.
F.14. file_fdw
Модуль file_fdw реализует обёртку сторонних данных file_fdw, с помощью которой можно об-
ращаться к файлам данных в файловой системе сервера или выполнять программы на сервере и
читать их вывод. Файлы и вывод программ должны быть в формате, который понимает команда
COPY FROM; он рассматривается в описании COPY. В настоящее время файлы доступны только для
чтения.
Для сторонней таблицы, создаваемой через эту обёртку, можно задать следующие параметры:
filename
Определяет имя файла, который нужно прочитать. Это имя должно задаваться абсолютным
путём. Необходимо определить либо параметр filename, либо program, но не оба сразу.
2523Дополнительно по-
ставляемые модули
program
Определяет команду, которая будет выполнена. Поток стандартного вывода этой команды бу-
дет прочитан так же, как и с COPY FROM PROGRAM. Необходимо определить либо параметр
program, либо filename, но не оба сразу.
format
Определяет формат файла (аналогично указанию FORMAT в команде COPY).
header
Указывает, что данные содержат строку заголовка с именами столбцов (аналогично указанию
HEADER в команде COPY).
delimiter
Задаёт символ, разделяющий столбцы в данных (аналогично указанию DELIMITER в команде
COPY).
quote
Задаёт символ, используемый для заключения данных в кавычки (аналогично указанию QUOTE
в команде COPY).
escape
Задаёт символ, используемый для экранирования данных (аналогично указанию ESCAPE в ко-
манде COPY).
null
Определяет строку, задающую значение NULL в данных (аналогично указанию NULL в команде
COPY).
encoding
Задаёт кодировку данных (аналогично указанию ENCODING в команде COPY).
Заметьте, что хотя COPY принимает указания, такие как HEADER, без соответствующего значения,
синтаксис обёртки сторонних данных требует, чтобы значение присутствовало во всех случаях.
Чтобы активировать указания COPY, которым значение обычно не передаётся, им можно просто
передать значение TRUE, так как все они являются логическими.
Для столбцов сторонней таблицы, создаваемой через эту обёртку, можно задать следующие пара-
метры:
force_not_null
Логическое значение. Если true, то значение столбца не должно сверяться со значением NULL
(заданным в параметре null на уровне таблицы). Аналогично включению столбца в список ука-
зания FORCE_NOT_NULL команды COPY.
force_null
Логическое значение. Если true, значения столбцов нужно сверять со значением NULL (задан-
ным в параметре NULL), даже если они заключены в кавычки. Без этого параметра только зна-
чения без кавычек, соответствующие значению null, будут возвращаться как NULL. Аналогич-
но включению столбца в список указания FORCE_NULL команды COPY.
В настоящий момент file_fdw не поддерживает указания OIDS и FORCE_QUOTE команды COPY.
Перечисленные параметры применимы только для сторонних таблиц или их столбцов. Их нельзя
указать для обёртки сторонних данных file_fdw, серверов или сопоставлений пользователей, ис-
пользующих эту обёртку.
2524Дополнительно по-
ставляемые модули
Для изменения параметров, определяемых для таблицы, требуется быть суперпользователем или
иметь права стандартной роли pg_read_server_files (для указания имени файла) или стандарт-
ной роли pg_execute_server_programs (для указания программы). Это сделано в целях безопасно-
сти: только избранные пользователи должны выбирать, какой файл читать или какую программу
запускать. В принципе право изменения остальных параметров можно предоставить и обычным
пользователям, но в настоящий момент это не реализовано.
Задавая параметр program, помните, что эта строка выполняется оболочкой ОС. Если вы хотите
передавать заданной команде параметры из недоверенного источника, позаботьтесь об исключе-
нии или экранировании всех символов, которые могут иметь особое назначение в оболочке. По
соображениям безопасности лучше, чтобы эта командная строка была фиксированной или как ми-
нимум в ней не передавались данные, поступающие от пользователя.
Для сторонних таблиц, работающих через file_fdw, команда EXPLAIN показывает имя используе-
мого файла или запускаемой программы. Если не указывать COSTS OFF, то выводится и размер
файла (в байтах).
Пример F.1. Создание сторонней таблицы для журнала сервера PostgreSQL
Одно из очевидных применений file_fdw это предоставление доступа к журналу сообщений
PostgreSQL как к таблице. Для этого необходимо предварительно настроить вывод сообщений в
файл CSV (дальше мы будем считать, что это файл pglog.csv). Сначала установите расширение
file_fdw:
CREATE EXTENSION file_fdw;
Затем создайте сторонний сервер:
CREATE SERVER pglog FOREIGN DATA WRAPPER file_fdw;
Всё готово для создания сторонней таблицы. В команде CREATE FOREIGN TABLE нужно перечислить
столбцы таблицы, указать файл CSV и его формат:
CREATE FOREIGN TABLE pglog (
log_time timestamp(3) with time zone,
user_name text,
database_name text,
process_id integer,
connection_from text,
session_id text,
session_line_num bigint,
command_tag text,
session_start_time timestamp with time zone,
virtual_transaction_id text,
transaction_id bigint,
error_severity text,
sql_state_code text,
message text,
detail text,
hint text,
internal_query text,
internal_query_pos integer,
context text,
query text,
query_pos integer,
location text,
application_name text
) SERVER pglog
OPTIONS ( filename ‘/home/josh/data/log/pglog.csv’, format ‘csv’ );
Вот и всё. Теперь для просмотра журнала сервера можно просто выполнять запросы к таблице. В
производственной среде, разумеется, ещё потребуется как-то учесть ротацию файлов журнала.
2525Дополнительно по-
ставляемые модули
F.15. fuzzystrmatch
Модуль fuzzystrmatch содержит несколько функций для вычисления схожести и расстояния меж-
ду строками.
Внимание
В настоящее время функции soundex, metaphone, dmetaphone и dmetaphone_alt плохо
работают с многобайтными кодировками (в частности, с UTF-8).
F.15.1. Soundex
Система Soundex позволяет вычислить похожие по звучанию имена, приводя их к одинаковым
кодам. Изначально она использовалась для обработки данных переписи населения США в 1880,
1900 и 1910 г. Заметьте, что эта система не очень полезна для неанглоязычных имён.
Модуль fuzzystrmatch предоставляет две функции для работы с кодами Soundex:
soundex(text) returns text
difference(text, text) returns int
Функция soundex преобразует строку в код Soundex. Функция difference преобразует две строки
в их коды Soundex и затем сообщает количество совпадающих позиций в этих кодах. Так как коды
Soundex состоят из четырёх символов, результатом может быть число от нуля до четырёх (0 обо-
значает полное несоответствие, а 4 — точное совпадение). (Таким образом, имя этой функции не
вполне корректное — лучшим именем для неё было бы similarity.)
Несколько примеров использования:
SELECT soundex(‘hello world!’);
SELECT soundex(‘Anne’), soundex(‘Ann’), difference(‘Anne’, ‘Ann’);
SELECT soundex(‘Anne’), soundex(‘Andrew’), difference(‘Anne’, ‘Andrew’);
SELECT soundex(‘Anne’), soundex(‘Margaret’), difference(‘Anne’, ‘Margaret’);
CREATE TABLE s (nm text);
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
s
s
s
s
VALUES
VALUES
VALUES
VALUES
(‘john’);
(‘joan’);
(‘wobbly’);
(‘jack’);
SELECT * FROM s WHERE soundex(nm) = soundex(‘john’);
SELECT * FROM s WHERE difference(s.nm, ‘john’) &gt; 2;
F.15.2. Левенштейн
Эта функция вычисляет расстояние Левенштейна между двумя строками:
levenshtein(text source, text target, int ins_cost, int del_cost, int sub_cost) returns
int
levenshtein(text source, text target) returns int
levenshtein_less_equal(text source, text target, int ins_cost, int del_cost, int
sub_cost, int max_d) returns int
levenshtein_less_equal(text source, text target, int max_d) returns int
И в source, и в target может быть передана любая строка, отличная от NULL, не длиннее 255
символов. Параметры стоимости (ins_cost, del_cost, sub_cost) определяют цену добавления, удале-
2526Дополнительно по-
ставляемые модули
ния или замены символов, соответственно. Эти параметры можно опустить, как во второй версии
функции; в этом случае все они по умолчанию равны 1.
Функция levenshtein_less_equal является ускоренной версией функции Левенштейна, предна-
значенной для использования, только когда интерес представляют небольшие расстояния. Если
фактическое расстояние меньше или равно max_d, то levenshtein_less_equal возвращает точное
его значение; в противном случае она возвращает значение, большее чем max_d. Если значение
max_d отрицательное, она работает так же, как функция levenshtein.
Примеры:
test=# SELECT levenshtein(‘GUMBO’, ‘GAMBOL’);
levenshtein
————-
2
(1 row)
test=# SELECT levenshtein(‘GUMBO’, ‘GAMBOL’, 2, 1, 1);
levenshtein
————-
3
(1 row)
test=# SELECT levenshtein_less_equal(‘extensive’, ‘exhaustive’, 2);
levenshtein_less_equal
————————
3
(1 row)
test=# SELECT levenshtein_less_equal(‘extensive’, ‘exhaustive’, 4);
levenshtein_less_equal
————————
4
(1 row)
F.15.3. Metaphone
Metaphone, как и Soundex, построен на идее составления кода, представляющего входную строку.
Две строки признаются похожими, если их коды совпадают.
Эта функция вычисляет код метафона входной строки:
metaphone(text source, int max_output_length) returns text
В качестве source должна передаваться строка, отличная от NULL, не длиннее 255 символов. Па-
раметр max_output_length задаёт максимальную длину выходного кода метафона; если код ока-
зывается длиннее, он обрезается до этой длины.
Пример:
test=# SELECT metaphone(‘GUMBO’, 4);
metaphone
———–
KM
(1 row)
F.15.4. Double Metaphone
Алгоритм Double Metaphone (Двойной метафон) вычисляет две строки «похожего звучания» для
заданной строки — «первичную» и «альтернативную». В большинстве случаев они совпадают, но
2527Дополнительно по-
ставляемые модули
для неанглоязычных имён в особенности они могут быть весьма различными, в зависимости от
произношения. Эти функции вычисляют первичный и альтернативный коды:
dmetaphone(text source) returns text
dmetaphone_alt(text source) returns text
Длина входных строк может быть любой.
Пример:
test=# SELECT dmetaphone(‘gumbo’);
dmetaphone
————
KMP
(1 row)
F.16. hstore
Этот модуль реализует тип данных hstore для хранения пар ключ/значение внутри одного значе-
ния PostgreSQL. Это может быть полезно в самых разных сценариях, например для хранения строк
со множеством редко анализируемых атрибутов или частично структурированных данных. Ключи
и значения задаются простыми текстовыми строками.
F.16.1. Внешнее представление hstore
Текстовое представление типа hstore, применяемое для ввода и вывода, включает ноль или более
пар ключ =&gt; значение, разделённых запятыми. Несколько примеров:
k =&gt; v
foo =&gt; bar, baz =&gt; whatever
“1-a” =&gt; “anything at all”
Порядок пар не имеет значения (и может не воспроизводиться при выводе). Пробелы между па-
рами и вокруг знака =&gt; игнорируются. Ключи и значения, содержащие пробелы, запятые и знаки
= или &gt;, нужно заключать в двойные кавычки. Если в ключ или значение нужно вставить символ
кавычек или обратную косую черту, добавьте перед ним обратную косую черту.
Все ключи в hstore уникальны. Если вы объявите тип hstore с дублирующимися ключами, в hstore
будет сохранён только один ключ без гарантии определённого выбора:
SELECT ‘a=&gt;1,a=&gt;2’::hstore;
hstore
———-
“a”=&gt;”1”
В качестве значения (но не ключа) может задаваться SQL NULL. Например:
key =&gt; NULL
В ключевом слове NULL регистр не имеет значения. Если требуется, чтобы текст NULL восприни-
мался как обычная строка «NULL», заключите его в кавычки.
Примечание
Учтите, что когда текстовый формат hstore используется для ввода данных, он приме-
няется до обработки кавычек или спецсимволов. Таким образом, если значение hstore
передаётся в параметре, дополнительная обработка не требуется. Но если вы переда-
ёте его в виде строковой константы, то все символы апострофов и (в зависимости от
параметра конфигурации standard_conforming_strings) обратной косой черты нужно
корректно экранировать. Подробнее о записи строковых констант можно узнать в Под-
разделе 4.1.2.1.
2528Дополнительно по-
ставляемые модули
При выводе значения и ключи всегда заключаются в кавычки, даже когда без этого можно обой-
тись.
F.16.2. Операторы и функции hstore
Реализованные в модуле hstore операторы перечислены в Таблице F.7, функции — в Таблице F.8.
Таблица F.7. Операторы hstore
Оператор Описание hstore -&gt; text выдаёт значение для ‘a=&gt;x, b=&gt;y’::hstore
ключа (или NULL при -&gt; ‘a’
его отсутствии) x
hstore -&gt; text[] выдаёт значения для ‘a=&gt;x,
b=&gt;y,
ключей (или NULL при
c=&gt;z’::hstore
-&gt;
их отсутствии)
ARRAY[‘c’,’a’] (“z”,”x”)
hstore || hstore объединяет два набора ‘a=&gt;b, c=&gt;d’::hstore “a”=&gt;”b”,
hstore
||
‘c=&gt;x, “d”=&gt;”q”
d=&gt;q’::hstore
hstore ? text набор hstore включает ‘a=&gt;1’::hstore ? ‘a’
ключ? t
hstore ?&amp; text[] набор hstore включает ‘a=&gt;1,
все указанные ключи? b=&gt;2’::hstore
ARRAY[‘a’,’b’] t
hstore ?| text[]
Пример
набор hstore включает ‘a=&gt;1,
какой-либо из указан- b=&gt;2’::hstore
ных ключей?
ARRAY[‘b’,’c’]
Результат
“c”=&gt;”x”,
?&amp;
t
?|
hstore @&gt; hstore левый операнд включа- ‘a=&gt;b,
b=&gt;1,
ет правый?
c=&gt;NULL’::hstore @&gt;
‘b=&gt;1’ hstore &lt;@ hstore левый операнд вклю- ‘a=&gt;c’::hstore
&lt;@ f
чён в правый?
‘a=&gt;b,
b=&gt;1,
c=&gt;NULL’
hstore - text удаляет ключ из левого ‘a=&gt;1,
b=&gt;2,
операнда
c=&gt;3’::hstore
-
‘b’::text “a”=&gt;”1”, “c”=&gt;”3”
hstore - text[] удаляет ключи из лево- ‘a=&gt;1,
b=&gt;2,
го операнда
c=&gt;3’::hstore
-
ARRAY[‘a’,’b’] “c”=&gt;”3”
hstore - hstore удаляет соответствую- ‘a=&gt;1,
b=&gt;2,
щие пары из левого
c=&gt;3’::hstore
-
операнда
‘a=&gt;4, b=&gt;2’::hstore “a”=&gt;”1”, “c”=&gt;”3”
record #= hstore заменяет поля в record см. раздел Примеры
соответствующими зна-
чениями из hstore %% hstore преобразует hstore в %%
‘a=&gt;foo, (a,foo,b,bar)
массив
перемежаю- b=&gt;bar’::hstore
щихся ключей и значе-
ний
%# hstore преобразует hstore в %#
‘a=&gt;foo, ((a,foo),(b,bar))
двумерный массив клю- b=&gt;bar’::hstore
чей/значений
2529
tДополнительно по-
ставляемые модули
Примечание
До версии PostgreSQL 8.2 операторы включения @&gt; и &lt;@ обозначались соответственно
как @ и ~. Эти имена по-прежнему действуют, но считаются устаревшими и в конце
концов будут упразднены. Заметьте, что старые имена произошли из соглашения, ко-
торому раньше следовали геометрические типы данных!
Таблица F.8. Функции hstore
Функция Тип результата Описание hstore(record) hstore формирует hstore hstore(ROW(1,
из записи или кор- 2))
тежа f1=&gt;1,f2=&gt;2
hstore(text[]) hstore формирует hstore
из массива, кото-
рый может содер-
жать попарно клю-
чи/значения, ли-
бо быть двумер-
ным массивом a=&gt;1,
b=&gt;2,
c=&gt;3, d=&gt;4
hstore(text[],
text[]) hstore формирует hstore hstore(
из отдельных мас- ARRAY[‘a’,
сивов ключей и ‘b’],
значений
ARRAY[‘1’,
‘2’]) “a”=&gt;”1”,
“b”=&gt;”2”
hstore(text,
text) hstore формирует hstore hstore(‘a’,
с одним элемен- ‘b’)
том “a”=&gt;”b”
akeys(hstore) text[] выдаёт
ключи akeys(‘a=&gt;1,
hstore в виде мас- b=&gt;2’)
сива (a,b)
skeys(hstore) setof text выдаёт
ключи skeys(‘a=&gt;1,
hstore в виде мно- b=&gt;2’)
жества a
b
avals(hstore) text[] выдаёт
ключи avals(‘a=&gt;1,
hstore в виде мас- b=&gt;2’)
сива (1,2)
svals(hstore) setof text выдаёт значения svals(‘a=&gt;1,
hstore в виде мно- b=&gt;2’)
жества 1
2
hstore_to_
array(hstore) text[] выдаёт ключи и hstore_to_
значения hstore в array(‘a=&gt;1,
виде массива пере- b=&gt;2’)
межающихся клю-
чей и значений (a,1,b,2)
hstore_to_
matrix(hstore) text[] выдаёт ключи и hstore_to_
значения hstore matrix(‘a=&gt;1,
в виде двумерного b=&gt;2’)
массива ((a,1),(b,2))
hstore_to_
json(hstore) json выдаёт hstore в hstore_to_
виде
значения json(‘“a
json, преобразуя key”=&gt;1,
b=&gt;t, (“a
2530
Пример
hstore(
ARRAY[‘a’,’1’,
‘b’,’2’])
||
hstore(
ARRAY[[‘c’,
‘3’],[‘d’,
‘4’]])
Результат
key”: “1”,
“b”:
“t”,
“c”:
null,Дополнительно по-
ставляемые модули
Функция Тип результата Описание
Пример
все отличные от
c=&gt;null,
NULL значения в
d=&gt;12345,
строки JSON
e=&gt;012345,
f=&gt;1.234,
g=&gt;2.345e+4’) Результат
“d”: “12345”,
“e”: “012345”,
“f”: “1.234”,
“g”: “2.345e
+4”)
hstore_to_
jsonb(hstore) jsonb выдаёт hstore в hstore_to_
виде
значения jsonb(‘“a
jsonb, преобразуя key”=&gt;1,
b=&gt;t,
все отличные от
c=&gt;null,
NULL значения в
d=&gt;12345,
строки JSON
e=&gt;012345,
f=&gt;1.234,
g=&gt;2.345e+4’) (“a
hstore_to_
json_loose(
hstore) json выдаёт hstore в
виде
значения
json, по возмож-
ности распознавая
числовые и логи-
ческие значения
и передавая их в
JSON без кавычек hstore_to_
json_loose(
‘“a
key”=&gt;1,
b=&gt;t, c=&gt;null,
d=&gt;12345,
e=&gt;012345,
f=&gt;1.234,
g=&gt;2.345e+4’) (“a
hstore_to_
jsonb_loose(
hstore) jsonb выдаёт hstore в
виде
значения
jsonb, по возмож-
ности распознавая
числовые и логи-
ческие значения
и передавая их в
JSON без кавычек hstore_to_
jsonb_loose(
‘“a
key”=&gt;1,
b=&gt;t, c=&gt;null,
d=&gt;12345,
e=&gt;012345,
f=&gt;1.234,
g=&gt;2.345e+4’) (“a
slice(hstore,
text[]) hstore извлекает подмно- slice(‘a=&gt;1,
жество из hstore b=&gt;2,
c=&gt;3’::hstore,
ARRAY[‘b’,’c’,
‘x’]) each(hstore) setof(key text,
value text) выдаёт ключи и select</p>
<ul>
  <li>key | value
значения hstore в from each(‘a=&gt;1, —–+——-
a
| 1
виде множества
b=&gt;2’)
b
| 2
exist(hstore,
text) boolean набор
hstore exist(‘a=&gt;1’,
включает ключ?
‘a’) t
defined(hstore,
text) boolean набор
hstore defined(
включает для клю- ‘a=&gt;NULL’,’a’)
ча значение, от-
личное от NULL? f
delete(hstore,
text) hstore удаляет
пару delete(‘a=&gt;1,
с
соответствую- b=&gt;2’,’b’)
щим ключом “a”=&gt;”1”
delete(hstore,
text[]) hstore удаляет
пары delete(‘a=&gt;1,
с соответствующи- b=&gt;2,c=&gt;3’,
ми ключами
ARRAY[‘a’,
‘b’]) “c”=&gt;”3”
2531
key”: “1”,
“b”:
“t”,
“c”:
null,
“d”: “12345”,
“e”: “012345”,
“f”: “1.234”,
“g”: “2.345e
+4”)
key”:
1,
“b”:
true,
“c”:
null,
“d”:
12345,
“e”: “012345”,
“f”:
1.234,
“g”: 2.345e+4)
key”:
1,
“b”:
true,
“c”:
null,
“d”:
12345,
“e”: “012345”,
“f”:
1.234,
“g”: 2.345e+4)
“b”=&gt;”2”,
“c”=&gt;”3”Дополнительно по-
ставляемые модули
Функция Тип результата Описание
Пример
delete(hstore,
hstore) hstore удаляет пары, со- delete(‘a=&gt;1,
ответствующие па- b=&gt;2’,’a=&gt;4,
рам во втором ар- b=&gt;2’::hstore)
гументе
populate_
record(record,
hstore) record заменяет поля в см. раздел Приме-
record
соответ- ры
ствующими значе-
ниями из hstore
Результат
“a”=&gt;”1”
Примечание
Функция hstore_to_json применяется, когда значение hstore нужно привести к json.
Подобным образом, hstore_to_jsonb применяется, когда значение hstore нужно при-
вести к jsonb.
Примечание
Функция populate_record на самом деле объявлена как принимающая в первом аргу-
менте anyelement, а не record, но если ей будет передан не тип записи, она выдаст
ошибку.
F.16.3. Индексы
Тип hstore поддерживает индексы GiST и GIN для операторов @&gt;, ?, ?&amp; и ?|. Например:
CREATE INDEX hidx ON testhstore USING GIST (h);
CREATE INDEX hidx ON testhstore USING GIN (h);
Тип hstore также поддерживает индексы btree и hash для оператора =. Это позволяет объявлять
столбцы hstore как уникальные (UNIQUE) и использовать их в выражениях GROUP BY, ORDER BY или
DISTINCT. Порядок сортировки значений hstore не имеет практического смысла, но эти индексы
могут быть полезны для поиска по равенству. Индексы для сравнений (с помощью =) можно создать
так:
CREATE INDEX hidx ON testhstore USING BTREE (h);
CREATE INDEX hidx ON testhstore USING HASH (h);
F.16.4. Примеры
Добавление ключа или изменение значения для существующего ключа:
UPDATE tab SET h = h || hstore(‘c’, ‘3’);
Удаление ключа:
UPDATE tab SET h = delete(h, ‘k1’);
Приведение типа record к типу hstore:
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, ‘foo’, ‘bar’);
SELECT hstore(t) FROM test AS t;
hstore
———————————————
2532Дополнительно по-
ставляемые модули
“col1”=&gt;”123”, “col2”=&gt;”foo”, “col3”=&gt;”bar”
(1 row)
Приведение типа hstore к предопределённому типу record:
CREATE TABLE test (col1 integer, col2 text, col3 text);
SELECT * FROM populate_record(null::test,
‘“col1”=&gt;”456”, “col2”=&gt;”zzz”’);
col1 | col2 | col3
——+——+——
456 | zzz |
(1 row)
Изменение существующей записи по данным из hstore:
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, ‘foo’, ‘bar’);
SELECT (r).* FROM (SELECT t #= ‘“col3”=&gt;”baz”’ AS r FROM test t) s;
col1 | col2 | col3
——+——+——
123 | foo | baz
(1 row)
F.16.5. Статистика
Тип hstore, вследствие присущей ему либеральности, может содержать множество самых разных
ключей. Контроль допустимости ключей является задачей приложения. Следующие примеры де-
монстрируют несколько приёмов проверки ключей и получения статистики.
Простой пример:
SELECT * FROM each(‘aaa=&gt;bq, b=&gt;NULL, “”=&gt;1’);
С таблицей:
SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;
Актуальная статистика:
SELECT key, count(<em>) FROM
(SELECT (each(h)).key FROM testhstore) AS stat
GROUP BY key
ORDER BY count DESC, key;
key
| count
———–+——-
line
|
883
query
|
207
pos
|
203
node
|
202
space
|
197
status
|
195
public
|
194
title
|
190
org
|
189
……………….
F.16.6. Совместимость
Начиная с PostgreSQL 9.0, hstore использует внутреннее представление, отличающееся от преды-
дущих версий. Это не проблема при обновлении путём выгрузки/перезагрузки данных, так как
текстовое представление (используемое при выгрузке) не меняется.
2533Дополнительно по-
ставляемые модули
В случае двоичного обновления обратная совместимость поддерживается благодаря тому, что но-
вый код понимает данные в старом формате. При таком обновлении возможно небольшое сниже-
ние производительности при обработке данных, которые ещё не были изменены новым кодом.
Все значения в столбце таблицы можно обновить принудительно, выполнив следующий оператор
UPDATE:
UPDATE tablename SET hstorecol = hstorecol || ‘’;
Это можно сделать и так:
ALTER TABLE tablename ALTER hstorecol TYPE hstore USING hstorecol || ‘’;
Вариант с командой ALTER TABLE требует расширенной блокировки таблицы, но не приводит к
замусориванию таблицы старыми версиями строк.
F.16.7. Трансформации
Также имеются дополнительные расширения, реализующие трансформации типа hstore для язы-
ков PL/Perl и PL/Python. Расширения для PL/Perl называются hstore_plperl и hstore_plperlu для
доверенного и недоверенного PL/Perl, соответственно. Если вы установите эти трансформации и
укажете их при создании функции, значения hstore будут отображаться в хеши Perl. Расширения
для PL/Python называются hstore_plpythonu, hstore_plpython2u и hstore_plpython3u (соглаше-
ния об именовании, принятые для интерфейса PL/Python, описаны в Разделе 46.1). Если вы вос-
пользуетесь ими, значения hstore будут отображаться в словари Python.
F.16.8. Авторы
Олег Бартунов <a href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>, Москва, Московский Государственный Университет, Россия
Фёдор Сигаев <a href="mailto:teodor@sigaev.ru">teodor@sigaev.ru</a>, Москва, ООО «Дельта-Софт», Россия
Дополнительные улучшения внёс Эндрю Гирт <a href="mailto:andrew@tao11.riddles.org.uk">andrew@tao11.riddles.org.uk</a>, Великобритания
F.17. intagg
Модуль intagg предоставляет агрегатор и нумератор целых чисел. На данный момент имеются
встроенные функции, предлагающие более широкие возможности, поэтому intagg считается уста-
ревшим. Однако этот модуль продолжает существовать для обратной совместимости, теперь как
набор обёрток встроенных функций.
F.17.1. Функции
Агрегатор реализуется функцией int_array_aggregate(integer), которая выдаёт массив целых
чисел, содержащий в точности те числа, что переданы ей. Это обёртка встроенной функции
array_agg, которая делает то же самое для массива любого типа.
Нумератор реализуется функцией int_array_enum(integer[]), которая возвращает набор целых
(setof integer). По сути его действие обратно действие агрегатора: получив массив целых, он
разворачивает его в набор строк. Это оболочка функции unnest, которая делает то же самое для
массива любого типа.
F.17.2. Примеры использования
Во многих СУБД есть понятие таблицы соотношений «один ко многим». Такая таблица обычно
находится между двумя индексированными таблицами, например:
CREATE TABLE left (id INT PRIMARY KEY, …);
CREATE TABLE right (id INT PRIMARY KEY, …);
CREATE TABLE one_to_many(left INT REFERENCES left, right INT REFERENCES right);
Как правило, она используется так:
2534Дополнительно по-
ставляемые модули
SELECT right.</em> from right JOIN one_to_many ON (right.id = one_to_many.right)
WHERE one_to_many.left = item;
Этот запрос вернёт все элементы из таблицы справа для записи в таблице слева. Это очень рас-
пространённая конструкция в SQL.
Однако этот подход может вызывать затруднения с очень большим количеством записей в таблице
one_to_many. Часто такое соединение влечёт сканирование индекса и выборку каждой записи в
таблице справа для конкретного элемента слева. Если у вас динамическая система, с этим ничего
не поделать. Но если какое-то множество данных довольно статическое, вы можете создать свод-
ную таблицу, применив агрегатор.
CREATE TABLE summary AS
SELECT left, int_array_aggregate(right) AS right
FROM one_to_many
GROUP BY left;
Эта команда создаст таблицу, содержащую одну строку для каждого элемента слева с массивом
элементов справа. Она малополезна, пока не найден подходящий способ использования этого мас-
сива; именно для этого и нужен нумератор массива. Вы можете выполнить:
SELECT left, int_array_enum(right) FROM summary WHERE left = элемент;
Приведённый выше запрос с вызовом int_array_enum выдаёт те же результаты, что и
SELECT left, right FROM one_to_many WHERE left = элемент;
Отличие состоит в том, что запрос к сводной таблице должен выдать только одну строку таблицы,
тогда как непосредственный запрос к one_to_many потребует сканирования индекса и выборки
строки для каждой записи.
На тестовом компьютере команда EXPLAIN показала, что стоимость запроса снизилась с 8488 до
    <ol>
      <li>Исходный запрос выполнял соединение с таблицей one_to_many и был заменён на:
SELECT right, count(right) FROM
( SELECT left, int_array_enum(right) AS right
FROM summary JOIN (SELECT left FROM left_table WHERE left = элемент) AS lefts
ON (summary.left = lefts.left)
) AS list
GROUP BY right
ORDER BY count DESC;
F.18. intarray
Модуль intarray предоставляет ряд полезных функций и операторов для работы с массивами це-
лых чисел без NULL. Также он поддерживает поиск по индексу для некоторых из этих операторов.
Все эти операции выдают ошибку, если в передаваемом массиве оказываются значения NULL.
Многие из этих операций имеют смысл только с одномерными массивами. Хотя им можно передать
входной массив и большей размерности, значения будут считываться из него как из линейного
массива в порядке хранения.
F.18.1. Функции и операторы intarray
Реализованные в модуле intarray функции перечислены в Таблице F.9, а операторы — в Табли-
це F.10.
Таблица F.9. Функции intarray
Функция Тип результата Описание
icount(int[]) int число элементов в icount(‘(1,2,
массиве
3)’::int[])
2535
Пример
Результат
3Дополнительно по-
ставляемые модули
Функция Тип результата Описание sort(int[],
text dir) int[] сортирует массив sort(‘(1,2,
— в dir должно 3)’::int[],
задаваться asc (по ‘desc’)
возрастанию) или
desc (по убыва-
нию) (3,2,1)
sort(int[]) int[] сортирует в поряд- sort(array[11,
ке возрастания
77,44]) (11,44,77)
sort_asc(
int[]) int[] сортирует в поряд-
ке возрастания sort_desc(
int[]) int[] сортирует в поряд-
ке убывания uniq(int[]) int[] удаляет
ты int индекс
первого idx(array[11,
элемента, равного 22,33,22,
item (0, если тако- 11], 22)
го нет) 2
subarray(int[],
int start, int
len) int[] часть массива, на- subarray(‘(1,
чинающаяся с по- 2,3,2,
зиции start и со- 1)’::int[], 2,
стоящая из len 3)
элементов (2,3,2)
subarray(int[],
int start) int[] часть массива, на- subarray(‘(1,
чинающаяся с по- 2,3,2,
зиции start
1)’::int[], 2) (2,3,2,1)
intset(int) int[] создаёт массив с intset(42)
одним элементом (42)
idx(int[],
item)
int
Пример
дублика- uniq(sort(‘(1,
2,3,2,
1)’::int[]))
Результат
(1,2,3)
Таблица F.10. Операторы intarray
Оператор Возвращает Описание
int[] &amp;&amp; int[] boolean пересекается с — true, если
массивы имеют минимум один
общий элемент
int[] @&gt; int[] boolean включает — true, если левый
массив содержит правый мас-
сив
int[] &lt;@ int[] boolean включается в — true, если ле-
вый массив содержится в пра-
вом массиве
        <h1 id="int-int-число-элементов-в-массиве">int[] int число элементов в массиве</h1>
        <p>int[] # int int индекс элемента (делает то же,
что и функция idx)
int[] + int int[] вставляет элемент в массив (до-
бавляет его в конец массива)
int[] + int[] int[] соединяет массивы (правый
массив добавляется в конец ле-
вого)
2536Дополнительно по-
ставляемые модули
Оператор Возвращает Описание
int[] - int int[] удаляет из массива записи, рав-
ные правому аргументу
int[] - int[] int[] удаляет из левого массива эле-
менты правого массива
int[] | int int[] объединение аргументов
int[] | int[] int[] объединение массивов
int[] &amp; int[] int[] пересечение массивов
int[] @@ query_int boolean true, если массив удовлетворя-
ет запросу (см. ниже)
query_int ~~ int[] boolean true, если запросу удовлетво-
ряет массив (коммутирующий
оператор к @@)
(До версии PostgreSQL 8.2 операторы включения @&gt; и &lt;@ обозначались соответственно как @ и ~.
Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упраздне-
ны. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые
геометрические типы данных!)
Операторы &amp;&amp;, @&gt; и &lt;@ равнозначны встроенным операторам PostgreSQL с теми же именами, за ис-
ключением того, что они работают только с целочисленными массивами, не содержащими NULL,
тогда как встроенные операторы работают с массивами любых типов. Благодаря этому ограниче-
нию, в большинстве случаев они работают быстрее, чем встроенные операторы.
Операторы @@ и ~~ проверяют, удовлетворяет ли массив запросу, представляемому в виде значения
специализированного типа данных query_int. Запрос содержит целочисленные значения, сравни-
ваемые с элементами массива, возможно с использованием операторов &amp; (AND), | (OR) и ! (NOT).
При необходимости могут использоваться скобки. Например, запросу 1&amp;(2|3) удовлетворяют за-
просы, которые содержат 1 и также содержат 2 или 3.
F.18.2. Поддержка индексов
Модуль intarray поддерживает индексы для операторов &amp;&amp;, @&gt;, &lt;@ и @@, а также обычную проверку
равенства массивов.
Модуль предоставляет два класса операторов GiST: gist__int_ops (используется по умолчанию),
подходящий для маленьких и средних по размеру наборов данных, и gist__intbig_ops, применя-
ющий сигнатуру большего размера и подходящий для индексации больших наборов данных (то
есть столбцов, содержащих много различных значений массива). В этой реализации используется
структура данных RD-дерева со встроенным сжатием с потерями.
Есть также нестандартный класс операторов GIN, gin__int_ops, поддерживающий те же операто-
ры.
Выбор между индексами GiST и GIN зависит от относительных характеристик производительности
GiST и GIN, которые здесь не рассматриваются.
F.18.3. Пример
– сообщение может относиться к одной или нескольким «секциям»
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], …);
– создать специализированный индекс
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);
– вывести сообщения из секций 1 или 2 — оператор пересечения
SELECT message.mid FROM message WHERE message.sections &amp;&amp; ‘(1,2)’;
2537Дополнительно по-
ставляемые модули
– вывести сообщения из секций 1 и 2 — оператор включения
SELECT message.mid FROM message WHERE message.sections @&gt; ‘(1,2)’;
– тот же результат, но с оператором запроса
SELECT message.mid FROM message WHERE message.sections @@ ‘1&amp;2’::query_int;
F.18.4. Тестирование производительности
В каталоге исходного кода contrib/intarray/bench содержится набор тестов, которые можно про-
вести на установленном сервере PostgreSQL. (Для этого нужно установить пакет DBD::Pg.) Чтобы
запустить эти тесты, выполните:
cd …/contrib/intarray/bench
createdb TEST
psql -c “CREATE EXTENSION intarray” TEST
./create_test.pl | psql TEST
./bench.pl
Скрипт bench.pl принимает несколько аргументов, о которых можно узнать, запустив его без ар-
гументов.
F.18.5. Авторы
Разработку
осуществили
Фёдор
Сигаев
(<a href="mailto:teodor@sigaev.ru">teodor@sigaev.ru</a>)
и
Олег
Бартунов
(<a href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>). Дополнительные сведения можно найти на странице http://www.sai.msu.su/
~megera/postgres/gist/. Андрей Октябрьский проделал отличную работу, добавив новые функции
и операторы.
F.19. isn
Модуль isn предоставляет типы данных для следующих международных стандартов нумерации
товаров: EAN13, UPC, ISBN (книги), ISMN (музыка) и ISSN (серийные номера). Номера проверя-
ются на входе согласно жёстко заданному списку префиксов: этот список префиксов также при-
меняется для группирования цифр при выводе. Так как время от времени появляются новые пре-
фиксы, этот список префиксов может устаревать. Ожидается, что будущая версия этого модуля
будет получать список префиксов из одной или нескольких таблиц, благодаря чему его при необ-
ходимости смогут легко обновлять пользователи; однако в настоящее время этот список можно
изменить, только модифицировав исходный код и перекомпилировав его. Также есть вероятность,
что в будущем этот модуль лишится функций проверки префиксов и группирования цифр.
F.19.1. Типы данных
В Таблице F.11 перечислены типы данных, реализованные модулем isn.
Таблица F.11. Типы данных isn
Тип данных Описание
EAN13 European Article Number (Европейский номер то-
вара), всегда выводится в формате EAN13
ISBN13 International Standard Book Number (Междуна-
родный стандартный книжный номер), выводи-
мый в новом формате EAN13
ISMN13 International Standard Music Number (Междуна-
родный стандартный музыкальный номер), вы-
водимый в новом формате EAN13
ISSN13 International Standard Serial Number (Междуна-
родный стандартный серийный номер), выводи-
мый в новом формате EAN13
2538Дополнительно по-
ставляемые модули
Тип данных Описание
ISBN Международный стандартный книжный номер,
выводимый в старом коротком формате
ISMN Международный стандартный музыкальный но-
мер, выводимый в старом коротком формате
ISSN Международный стандартный серийный номер,
выводимый в старом коротком формате
UPC Universal Product Code (Универсальный код то-
вара)
Замечания:</p>
      </li>
      <li>Номера ISBN13, ISMN13, ISSN13 являются номерами EAN13.</li>
      <li>Не все номера EAN13 (только их подмножество) представляют ISBN13, ISMN13 или ISSN13.</li>
      <li>Некоторые номера ISBN13 можно вывести в формате ISBN.</li>
      <li>Некоторые номера ISMN13 можно вывести в формате ISMN.</li>
      <li>Некоторые номера ISSN13 можно вывести в формате ISSN.</li>
      <li>Номера UPC являются подмножеством номеров EAN13 (по сути они являются номерами EAN13
без первой цифры 0).</li>
      <li>Любые номера UPC, ISBN, ISMN и ISSN можно представить как номера EAN13.
Внутри все эти типы представляются одинаково (64-битными целыми числами) и все они взаимо-
заменяемы. Различные типы введены для управления форматированием при выводе и для строгой
проверки правильности ввода, что и определяет конкретный тип номера.
Типы ISBN, ISMN и ISSN выводят короткую версию числа (ISxN 10), когда это возможно, либо выби-
рают формат ISxN 13 для чисел, не умещающихся в короткую версию. Типы EAN13, ISBN13, ISMN13
и ISSN13 всегда выводят длинную версию ISxN (EAN13).
F.19.2. Приведения
Модуль isn предоставляет следующие пары приведений типов:
• ISBN13 &lt;=&gt; EAN13
• ISMN13 &lt;=&gt; EAN13
• ISSN13 &lt;=&gt; EAN13
• ISBN &lt;=&gt; EAN13
• ISMN &lt;=&gt; EAN13
• ISSN &lt;=&gt; EAN13
• UPC &lt;=&gt; EAN13
• ISBN &lt;=&gt; ISBN13
• ISMN &lt;=&gt; ISMN13
• ISSN &lt;=&gt; ISSN13
При приведении EAN13 к другому типу выполняется проверка времени выполнения, соответствует
ли исходное значение целевому типу, и если это не так, выдаётся ошибка. При других приведениях
значения просто перемечаются, так что они успешно выполняются всегда.
F.19.3. Функции и операторы
Модуль isn предоставляет стандартные операторы сравнения плюс поддержку индексов по хешу
и B-деревьев для этих типов данных. Кроме того, он реализует ряд специализированных функций;
они перечислены в Таблице F.12. В этой таблице под isn понимается один из типов данных модуля.
2539Дополнительно по-
ставляемые модули
Таблица F.12. Функции isn
Функция Возвращает Описание
isn_weak(boolean) boolean Устанавливает ослабленный ре-
жим проверки ввода (возвраща-
ет новое состояние)
isn_weak() boolean Выдаёт
текущее
состояние
ослабленного режима
make_valid(isn) isn Делает неверный номер верным
(сбрасывает флаг ошибки)
is_valid(isn) boolean Проверяет присутствие флага
ошибки
Ослабленный режим позволяет вставлять в таблицу неверные значения. Под неверным значением
понимается номер, в котором не сходится проверочная цифра, а не номер отсутствует вовсе.
Зачем может понадобиться ослабленный режим? Ну например, у вас может быть большой набор
номеров ISBN, и очень многие из них по каким-то странным причинам содержат неверную кон-
трольную цифру (возможно, номера были отсканированы с печатного листа и были распознаны
неправильно, или они вводились вручную, кто знает…). В любом случае, суть в том, что вы хотите
с этим разобраться, но вам нужно загрузить все эти номера в базу данных, а затем, возможно,
использовать дополнительное средство поиска неверных номеров в базе данных с тем, чтобы про-
верить и исправить данные; так что, например, вам нужно будет выбрать все неверные номера в
таблице.
Если попытаться вставить в таблицу неверный номер в ослабленном режиме проверки, номер бу-
дет вставлен с исправленной проверочной цифрой, но выводиться будет с восклицательным знаком
(!) в конце, например 0-11-000322-5!. Этот маркер ошибки можно проверить с помощью функции
is_valid и очистить функцией make_valid.
Вы также можете принудительно вставить числа даже не в ослабленном режиме, добавив символ
! в конце номера.
Есть ещё одна особенность — во вводимом номере вместо проверочной цифры можно указать ? и
нужная проверочная цифра будет вставлена автоматически.
F.19.4. Примеры
– Использование типов напрямую:
SELECT isbn(‘978-0-393-04002-9’);
SELECT isbn13(‘0901690546’);
SELECT issn(‘1436-4522’);
– Приведение типов:
– заметьте, что номер ean13 можно привести к другому типу, только когда
– этот номер будет допустимым для целевого типа;
– таким образом, это НЕ будет работать: select isbn(ean13(‘0220356483481’));
– а это будет:
SELECT upc(ean13(‘0220356483481’));
SELECT ean13(upc(‘220356483481’));
– Создание таблицы с одним столбцом, который будет содержать номера ISBN:
CREATE TABLE test (id isbn);
INSERT INTO test VALUES(‘9780393040029’);
– Автоматическое вычисление проверочных цифр (обратите внимание на ‘?’):
INSERT INTO test VALUES(‘220500896?’);
2540Дополнительно по-
ставляемые модули
INSERT INTO test VALUES(‘978055215372?’);
SELECT issn(‘3251231?’);
SELECT ismn(‘979047213542?’);
– Использование ослабленного режима:
SELECT isn_weak(true);
INSERT INTO test VALUES(‘978-0-11-000533-4’);
INSERT INTO test VALUES(‘9780141219307’);
INSERT INTO test VALUES(‘2-205-00876-X’);
SELECT isn_weak(false);
SELECT id FROM test WHERE NOT is_valid(id);
UPDATE test SET id = make_valid(id) WHERE id = ‘2-205-00876-X!’;
SELECT * FROM test;
SELECT isbn13(id) FROM test;
F.19.5. Библиография
Информация, на основе которой реализован этот модуль, была собрана с нескольких сайтов, вклю-
чая:
• https://www.isbn-international.org/
• http://www.issn.org/
• https://www.ismn-international.org/
• https://www.wikipedia.org/
Префиксы, используемые для группирования цифр, были также взяты с:
• https://www.gs1.org/standards/id-keys
• https://en.wikipedia.org/wiki/List_of_ISBN_identifier_groups
• https://www.isbn-international.org/content/isbn-users-manual
• https://en.wikipedia.org/wiki/International_Standard_Music_Number
• https://www.ismn-international.org/ranges.html
Алгоритмы реализованы со всей тщательностью и скрупулёзно сверены с алгоритмами, предлага-
емыми в официальных руководствах ISBN, ISMN, ISSN.
F.19.6. Автор
Герман Мендез Браво (Kronuz), 2004 — 2006
Этот модуль написан под влиянием кода isbn_issn Гаретта А. Уоллмена.
F.20. lo
Модуль lo поддерживает управление большими объектами (БО или LO, Large Objects, иногда BLOB,
Binary Large OBjects). Он реализует тип данных lo и триггер lo_manage.
F.20.1. Обоснование
Одна из проблема драйвера JDBC (она распространяется и на драйвер ODBC) в том, что специфи-
кация типа предполагает, что ссылки на BLOB хранятся в таблице, и если запись меняется, свя-
занный BLOB удаляется из базы.
2541Дополнительно по-
ставляемые модули
Но с PostgreSQL этого не происходит. Большие объекты обрабатываются как самостоятельные объ-
екты; запись в таблице может ссылаться на большой объект по OID, но при этом на один и тот же
объект могут ссылаться несколько записей таблицы, так что система не удаляет большой объект,
только потому что вы меняете или удаляете такую запись.
Это не проблема для приложений, ориентированных на PostgreSQL, но стандартный код, исполь-
зующий JDBC или ODBC, не будет удалять эти объекты, в результате чего они окажутся потерян-
ными — объектами, которые никак не задействованы, а просто занимают место на диске.
Модуль lo позволяет решить эту проблему, добавляя триггер к таблицам, которые содержат столб-
цы, ссылающиеся на БО. Этот триггер по сути просто вызывает lo_unlink, когда вы удаляете или
изменяете значение, ссылающееся на большой объект. Данный триггер предполагает, что на лю-
бой большой объект, на который ссылается контролируемый им столбец, указывает только одна
ссылка!
Этот модуль также предоставляет тип данных lo, который просто является доменом на базе oid.
Он может быть полезен для выделения столбцов, содержащих ссылки на большие объекты, среди
столбцов, содержащих другие OID. Для использования триггера применять тип lo необязательно,
но этот тип может быть полезен для отслеживания столбцов в вашей базе, представляющих боль-
шие объекты, с которыми работает триггер. Кроме того, поступали сообщения, что драйвер ODBC
не работает корректно, если для столбцов BLOB используется не тип lo.
F.20.2. Как его использовать
Пример его использования:
CREATE TABLE image (title text, raster lo);
CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON image
FOR EACH ROW EXECUTE FUNCTION lo_manage(raster);
Для каждого столбца, который будет содержать уникальные ссылки на большие объекты, создайте
триггер BEFORE UPDATE OR DELETE и передайте имя столбца в качестве единственного аргумента
триггера. Вы также можете сделать, чтобы триггер срабатывал только при изменениях в столбце,
указав BEFORE UPDATE OF имя_столбца. Если вам нужно иметь в одной таблице несколько столбцов
lo, создайте отдельный триггер для каждого (при этом обязательно нужно дать всем триггерам в
одной таблице разные имена).
F.20.3. Ограничения
• При удалении таблицы, однако, всё равно будут потеряны относящиеся к ней объекты, так
как триггер не будет выполняться. Этого можно избежать, выполнив перед DROP TABLE коман-
ду DELETE FROM таблица.
То же касается и команды TRUNCATE.
Если у вас уже есть, или вы подозреваете, что есть потерянные большие объекты, обратите
внимание на модуль vacuumlo, который может помочь вычистить их. Имеет смысл периодиче-
ски запускать vacuumlo в качестве меры, дополняющей действие триггера lo_manage.
• Некоторые клиентские программы могут создавать собственные таблицы, но не создавать для
них соответствующие триггеры. Кроме того, и пользователи могут не создавать такие тригге-
ры (забывая о них, либо не зная, как это сделать).
F.20.4. Автор
Питер Маунт <a href="mailto:peter@retep.org.uk">peter@retep.org.uk</a>
F.21. ltree
2542Дополнительно по-
ставляемые модули
Этот модуль реализует тип данных ltree для представления меток данных в иерархической дре-
вовидной структуре. Он также предоставляет расширенные средства для поиска в таких деревьях.
F.21.1. Определения
Метка — это последовательность алфавитно-цифровых символов и знаков подчёркивания (напри-
мер, в локали C допускаются символы A-Za-z0-9_). Метки должны занимать меньше 256 байт.
Примеры: 42, Personal_Services
Путь метки — это последовательность из нуля или нескольких разделённых точками меток (на-
пример, L1.L2.L3), представляющая путь от корня иерархического дерева к конкретному узлу.
Длина пути метки должна быть меньше 65 КБ, но лучше, если она будет в пределах 2 КБ.
Пример: Top.Countries.Europe.Russia
Модуль ltree предоставляет несколько типов данных:
• ltree хранит путь метки.
• lquery представляет напоминающий регулярные выражения запрос для поиска нужных зна-
чений ltree. Простое слово выбирает путь с этой меткой. Звёздочка (<em>) выбирает ноль или бо-
лее меток. Например:
foo
*.foo.</em>
<em>.foo
Выбирает в точности путь метки foo
Выбирает путь, содержащий метку foo
Выбирает путь, в котором последняя метка foo
Звёздочке можно также добавить числовую характеристику, ограничивающую число потенци-
ально совпадающих меток:
*(n)
*(n,)
*(n,m)
*(,m)
Выбирает
Выбирает
Выбирает
Выбирает
ровно n меток
не меньше n меток
не меньше n и не больше m меток
не больше m меток — то же самое, что и
*(0,m)
В конце метки, отличной от звёздочки, в lquery можно добавить модификаторы, чтобы найти
что-то сложнее, чем точное соответствие:
@
*
Выбирать метки без учёта регистра, например, запросу a@ соответствует A
Выбирать любую метку с данным префиксом, например запросу foo</em>
соответствует foobar
%
Выбирать начальные слова, разделённые подчёркиваниями
Поведение модификатора % несколько нетривиальное. Он пытается найти соответствие по
словам, а не по всей метке. Например, запросу foo_bar% соответствует foo_bar_baz но не
foo_barbaz. В сочетании с <em>, сопоставление префикса применяется отдельно к каждому сло-
ву, например запросу foo_bar%</em> соответствует foo1_bar2_baz, но не foo1_br2_baz.
Также вы можете записать несколько различных меток через знак | (обозначающий ИЛИ)
для выборки любой из этих меток, либо добавить знак ! (НЕ) в начале, чтобы выбрать все мет-
ки, не соответствующие указанным альтернативам.
Расширенный пример lquery:
Top.<em>(0,2).sport</em>@.!football|tennis.Russ<em>|Spain
a. b.
c.
d.
e.
Этот запрос выберет путь, который:
a. начинается с метки Top
b. и затем включает от нуля до двух меток до
c. метки, начинающейся с префикса sport (без учёта регистра)
2543Дополнительно по-
ставляемые модули
d. затем метку, отличную от football и tennis
e. и заканчивается меткой, которая начинается подстрокой Russ или в точности равна Spain.
• ltxtquery представляет подобный полнотекстовому запрос поиска подходящих значений
ltree. Значение ltxtquery содержит слова, возможно с модификаторами @, *, % в конце; эти
модификаторы имеют то же значение, что и в lquery. Слова можно объединять символами &amp;
(И), | (ИЛИ), ! (НЕ) и скобками. Ключевое отличие от lquery состоит в том, что ltxtquery вы-
бирает слова независимо от их положения в пути метки.
Пример ltxtquery:
Europe &amp; Russia</em>@ &amp; !Transportation
Этот запрос выберет пути, содержащие метку Europe или любую метку с начальной подстро-
кой Russia (без учёта регистра), но не пути, содержащие метку Transportation. Положение
этих слов в пути не имеет значения. Кроме того, когда применяется %, слово может быть сопо-
ставлено с любым другим отделённым подчёркиваниями словом в метке, вне зависимости от
его положения.
Замечание: ltxtquery допускает пробелы между символами, а ltree и lquery — нет.
F.21.2. Операторы и функции
Для типа ltree определены обычные операторы сравнения =, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=. Сравнение сортирует
пути в порядке движения по дереву, а потомки узла сортируются по тексту метки. В дополнение
к ним есть и специализированные операторы, перечисленные в Таблице F.13.
Таблица F.13. Операторы ltree
Оператор Возвращает Описание
ltree @&gt; ltree boolean левый аргумент является пред-
ком правого (или равен ему)?
ltree &lt;@ ltree boolean левый аргумент является по-
томком правого (или равен
ему)?
ltree ~ lquery boolean значение ltree соответствует
lquery?
lquery ~ ltree boolean значение ltree соответствует
lquery?
ltree ? lquery[] boolean значение ltree соответствует
одному из lquery в массиве?
lquery[] ? ltree boolean значение ltree соответствует
одному из lquery в массиве?
ltree @ ltxtquery boolean значение ltree соответствует
ltxtquery?
ltxtquery @ ltree boolean значение ltree соответствует
ltxtquery?
ltree || ltree ltree объединяет два пути ltree
ltree || text ltree преобразует текст в ltree и объ-
единяет с путём
text || ltree ltree преобразует текст в ltree и объ-
единяет с путём
ltree[] @&gt; ltree boolean массив содержит предка ltree?
ltree &lt;@ ltree[] boolean массив содержит предка ltree?
2544Дополнительно по-
ставляемые модули
Оператор Возвращает Описание
ltree[] &lt;@ ltree boolean массив
ltree?
содержит
потомка
ltree @&gt; ltree[] boolean массив
ltree?
содержит
потомка
ltree[] ~ lquery boolean массив содержит путь, соответ-
ствующий lquery?
lquery ~ ltree[] boolean массив содержит путь, соответ-
ствующий lquery?
ltree[] ? lquery[] boolean массив ltree содержит путь,
соответствующий любому из
lquery?
lquery[] ? ltree[] boolean массив ltree содержит путь,
соответствующий любому из
lquery?
ltree[] @ ltxtquery boolean массив содержит путь, соответ-
ствующий ltxtquery?
ltxtquery @ ltree[] boolean массив содержит путь, соответ-
ствующий ltxtquery?
ltree[] ?@&gt; ltree ltree первый элемент массива, явля-
ющийся предком ltree; NULL,
если такого нет
ltree[] ?&lt;@ ltree ltree первый элемент массива, явля-
ющийся потомком ltree; NULL,
если такого нет
ltree[] ?~ lquery ltree первый элемент массива, соот-
ветствующий lquery; NULL, ес-
ли такого нет
ltree[] ?@ ltxtquery ltree первый элемент массива, соот-
ветствующий ltxtquery; NULL,
если такого нет
Операторы &lt;@, @&gt;, @ и ~ имеют аналоги в виде ^&lt;@, ^@&gt;, ^@, ^~, которые отличатся только тем, что
не используют индексы. Они полезны только для тестирования.
Доступные функции перечислены в Таблице F.14.
Таблица F.14. Функции ltree
Функция Тип результата Описание subltree(ltree,
int start, int
end) ltree подпуть ltree от subltree(
позиции start до ‘Top.Child1.
позиции end-1 (на- Child2’,1,2)
чиная с 0) Child1
subpath(ltree,
int
offset,
int len) ltree подпуть ltree, на- subpath(
чиная
с
пози- ‘Top.Child1.
ции offset, дли- Child2’,0,2)
ной
len.
Если
offset меньше ну-
ля, подпуть начи-
нается с этого сме-
щения от конца пу- Top.Child1
2545
Пример
РезультатДополнительно по-
ставляемые модули
Функция Тип результата Описание
Пример
ти. Если len мень-
ше нуля, будет от-
брошено заданное
число меток с кон-
ца строки. Результат
subpath(ltree,
int offset) ltree подпуть ltree, на- subpath(
чиная с позиции ‘Top.Child1.
offset и до конца Child2’,1)
пути. Если offset
меньше нуля, под-
путь начинается с
этого смещения от
конца пути. Child1.Child2
nlevel(ltree) integer число меток в пути nlevel(
‘Top.Child1.
Child2’) 3
a, integer позиция первого
вхождения b в a;
-1, если вхождения
нет index(
6
‘0.1.2.3.5.4.5.6.
8.5.6.8’,
‘5.6’)
index(ltree
a,
ltree b, int
offset) integer позиция первого
вхождения b в a,
найденного от по-
зиции offset; ес-
ли offset меньше
0, поиск начинает-
ся с -offset меток
от конца пути index(
9
‘0.1.2.3.5.4.5.6.
8.5.6.8’,
‘5.6’,-4)
text2ltree(
text) ltree приводит text
типу ltree ltree2text(
ltree) text приводит ltree к
типу text lca(ltree,
ltree, …) ltree наибольший
об- lca(‘1.2.3’,
щий предок путей ‘1.2.3.4.5.6’)
(принимается до 8
аргументов) lca(ltree[]) ltree наибольший
об- lca(
1.2
щий предок путей array[‘1.2.3’::ltree,
в массиве
‘1.2.3.4’])
index(ltree
ltree b)
к
1.2
F.21.3. Индексы
ltree поддерживает несколько типов индексов, которые могут ускорить означенные операции:
• B-дерево по значениям ltree: &lt;, &lt;=, =, &gt;=, &gt;
• GiST по значениям ltree: &lt;, &lt;=, =, &gt;=, &gt;, @&gt;, &lt;@, @, ~, ?
Пример создания такого индекса:
CREATE INDEX path_gist_idx ON test USING GIST (path);
• GiST по столбцу ltree[]: ltree[] &lt;@ ltree, ltree @&gt; ltree[], @, ~, ?
Пример создания такого индекса:
2546Дополнительно по-
ставляемые модули
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
Примечание: Индекс этого типа является неточным.
F.21.4. Пример
Для этого примера используются следующие данные (это же описание данных находится в файле
contrib/ltree/ltreetest.sql в дистрибутиве исходного кода):
CREATE
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
CREATE
CREATE
TABLE test (path ltree);
INTO test VALUES (‘Top’);
INTO test VALUES (‘Top.Science’);
INTO test VALUES (‘Top.Science.Astronomy’);
INTO test VALUES (‘Top.Science.Astronomy.Astrophysics’);
INTO test VALUES (‘Top.Science.Astronomy.Cosmology’);
INTO test VALUES (‘Top.Hobbies’);
INTO test VALUES (‘Top.Hobbies.Amateurs_Astronomy’);
INTO test VALUES (‘Top.Collections’);
INTO test VALUES (‘Top.Collections.Pictures’);
INTO test VALUES (‘Top.Collections.Pictures.Astronomy’);
INTO test VALUES (‘Top.Collections.Pictures.Astronomy.Stars’);
INTO test VALUES (‘Top.Collections.Pictures.Astronomy.Galaxies’);
INTO test VALUES (‘Top.Collections.Pictures.Astronomy.Astronauts’);
INDEX path_gist_idx ON test USING GIST (path);
INDEX path_idx ON test USING BTREE (path);
В итоге мы получаем таблицу test, наполненную данными, представляющими следующую иерар-
хию:
Top
/
| \
Science Hobbies Collections
/
|
\
Astronomy
Amateurs_Astronomy Pictures
/ \
|
Astrophysics Cosmology
Astronomy
/ |
\
Galaxies Stars Astronauts
Мы можем выбрать потомки в иерархии наследования:
ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ ‘Top.Science’;
path
————————————
Top.Science
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
(4 rows)
Несколько примеров выборки по путям:
ltreetest=&gt; SELECT path FROM test WHERE path ~ ‘<em>.Astronomy.</em>’;
path
———————————————–
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
Top.Collections.Pictures.Astronomy
Top.Collections.Pictures.Astronomy.Stars
Top.Collections.Pictures.Astronomy.Galaxies
2547Дополнительно по-
ставляемые модули
Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)
ltreetest=&gt; SELECT path FROM test WHERE path ~ ‘<em>.!pictures@.</em>.Astronomy.<em>’;
path
————————————
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
(3 rows)
Ещё несколько примеров полнотекстового поиска:
ltreetest=&gt; SELECT path FROM test WHERE path @ ‘Astro</em>% &amp; !pictures@’;
path
————————————
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
Top.Hobbies.Amateurs_Astronomy
(4 rows)
ltreetest=&gt; SELECT path FROM test WHERE path @ ‘Astro* &amp; !pictures@’;
path
————————————
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
(3 rows)
Образование пути с помощью функций:
ltreetest=&gt; SELECT subpath(path,0,2)||’Space’||subpath(path,2) FROM test WHERE path &lt;@
‘Top.Science.Astronomy’;
?column?
——————————————
Top.Science.Space.Astronomy
Top.Science.Space.Astronomy.Astrophysics
Top.Science.Space.Astronomy.Cosmology
(3 rows)
Эту процедуру можно упростить, создав функцию SQL, вставляющую метку в определённую пози-
цию в пути:
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
AS ‘select subpath($1,0,$2) || $3 || subpath($1,$2);’
LANGUAGE SQL IMMUTABLE;
ltreetest=&gt; SELECT ins_label(path,2,’Space’) FROM test WHERE path &lt;@
‘Top.Science.Astronomy’;
ins_label
——————————————
Top.Science.Space.Astronomy
Top.Science.Space.Astronomy.Astrophysics
Top.Science.Space.Astronomy.Cosmology
(3 rows)
F.21.5. Трансформации
Также имеются дополнительные расширения, реализующие трансформации типа ltree для языка
PL/Python. Эти расширения называются ltree_plpythonu, ltree_plpython2u и ltree_plpython3u
2548Дополнительно по-
ставляемые модули
(соглашения об именовании, принятые для интерфейса PL/Python, описаны в Разделе  46.1). Ес-
ли вы установите эти трансформации и укажете их при создании функции, значения ltree будут
отображаться в списки Python. (Однако обратное преобразование не поддерживается.)
F.21.6. Авторы
Разработку
осуществили
Фёдор
Сигаев
(<a href="mailto:teodor@stack.net">teodor@stack.net</a>)
и
Олег
Бартунов
(<a href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>). Дополнительные сведения можно найти на странице http://www.sai.msu.su/
~megera/postgres/gist/. Авторы выражают благодарность Евгению Родичеву за полезные дискус-
сии. Замечания и сообщения об ошибках приветствуются.
F.22. pageinspect
Модуль pageinspect предоставляет функции, позволяющие исследовать страницы баз данных на
низком уровне, что бывает полезно для отладки. Все эти функции могут вызывать только супер-
пользователи.
F.22.1. Функции общего назначения
get_raw_page(relname text, fork text, blkno int) returns bytea
Функция get_raw_page считывает указанный блок отношения с заданным именем и возвращает
копию значения bytea. Это позволяет получить одну согласованную во времени копию блока.
В параметре fork нужно передать ‘main’, чтобы обратиться к основному слою данных, ‘fsm’
— к карте свободного пространства, ‘vm’ — к карте видимости, либо ‘init’ — к слою иници-
ализации.
get_raw_page(relname text, blkno int) returns bytea
Упрощённая версия get_raw_page для
get_raw_page(relname, ‘main’, blkno)
чтения
данных
из
основного
слоя.
Синоним
page_header(page bytea) returns record
Функция page_header показывает поля, общие для всех страниц кучи и индекса PostgreSQL.
В качестве аргумента ей передаётся образ страницы, полученный в результате вызова
get_raw_page. Например:
test=# SELECT * FROM page_header(get_raw_page(‘pg_class’, 0));
lsn
| checksum | flags | lower | upper | special | pagesize | version |
prune_xid
———–+———-+——–+——-+——-+———+———-+———
+———–
0/24A1B50 |
0 |
1 |
232 |
368 |
8192 |
8192 |
4 |
0
Возвращаемые столбцы соответствуют полям в структуре PageHeaderData. За подробностями
обратитесь к src/include/storage/bufpage.h.
Поле checksum содержит контрольную сумму, сохранённую для страницы. Эта сумма может
быть неверной при повреждении страницы. Если в данном экземпляре кластера контрольные
суммы отключены, это значение не имеет смысла.
page_checksum(page bytea, blkno int4) returns smallint
Функция page_checksum вычисляет контрольную сумму страницы, которая должна была бы на-
ходиться в заданном блоке.
В качестве аргумента ей передаётся образ страницы, полученный в результате вызова
get_raw_page. Например:
2549Дополнительно по-
ставляемые модули
test=# SELECT page_checksum(get_raw_page(‘pg_class’, 0), 0);
page_checksum
—————
13443
Заметьте, что вычисление контрольной суммы зависит от номера блока, поэтому обеим функ-
циям нужно передавать одинаковые номера (за исключением случаев эзотерической отладки).
Контрольную сумму, вычисленную этой функцией, можно сравнить с полем checksum резуль-
тата функции page_header. Если контрольные суммы для текущего экземпляра БД включены,
эти значения должны быть равны.
heap_page_items(page bytea) returns setof record
Функция heap_page_items показывает все указатели линейных блоков на странице кучи. Для
используемых блоков также выводятся заголовки кортежей. При этом показываются все кор-
тежи, независимо от того, были ли видны они в снимке MVCC в момент копирования исходной
страницы.
В качестве аргумента ей передаётся образ страницы кучи, полученный в результате вызова
get_raw_page. Например:
test=# SELECT * FROM heap_page_items(get_raw_page(‘pg_class’, 0));
Описание возвращаемых полей можно найти в src/include/storage/itemid.h и src/include/
access/htup_details.h.
tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 integer, t_bits
text [, do_detoast bool]) returns bytea[]
Функция tuple_data_split разделяет данные кортежей на атрибуты так, как это происходит
внутри сервера.
test=# SELECT tuple_data_split(‘pg_class’::regclass, t_data, t_infomask,
t_infomask2, t_bits) FROM heap_page_items(get_raw_page(‘pg_class’, 0));
В качестве аргументов этой функции должны передаваться атрибуты, возвращаемые функцией
heap_page_items.
Если параметр do_detoast равен true, полученные атрибуты будут распакованы по мере необ-
ходимости. Если он не задан, подразумевается false.
heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns bytea[]
Функция heap_page_item_attrs похожа на heap_page_items, но возвращает неструктурирован-
ное содержимое кортежа в виде массива атрибутов, которые могут быть распакованы, если
установлен флаг do_detoast (по умолчанию они не распаковываются).
В качестве аргумента ей передаётся образ страницы кучи, полученный в результате вызова
get_raw_page. Например:
test=# SELECT * FROM heap_page_item_attrs(get_raw_page(‘pg_class’, 0),
‘pg_class’::regclass);
fsm_page_contents(page bytea) returns text
Функция fsm_page_contents показывает внутреннюю структуру узла на странице FSM. Она вы-
даёт текст из нескольких строк, по одной строке на узел двоичного дерева на заданной стра-
нице. При этом выдаются только ненулевые узлы. Также выводится так называемый указатель
«следующего слота», который указывает на следующий слот, получаемый с этой страницы.
Подробнее структура страницы FSM описана в src/backend/storage/freespace/README.
2550Дополнительно по-
ставляемые модули
F.22.2. Функции для индексов-B-деревьев
bt_metap(relname text) returns record
Функция bt_metap возвращает информацию о метастранице индекса-B-дерева. Например:
test=# SELECT * FROM bt_metap(‘pg_cast_oid_index’);
-[ RECORD 1 ]———–+——-
magic
| 340322
version
| 3
root
| 1
level
| 0
fastroot
| 1
fastlevel
| 0
oldest_xact
| 582
last_cleanup_num_tuples | 1000
bt_page_stats(relname text, blkno int) returns record
bt_page_stats возвращает сводную информацию по единичным страницам B-дерева. Напри-
мер:
test=# SELECT * FROM bt_page_stats(‘pg_cast_oid_index’, 1);
-[ RECORD 1 ]-+—–
blkno
| 1
type
| l
live_items
| 256
dead_items
| 0
avg_item_size | 12
page_size
| 8192
free_size
| 4056
btpo_prev
| 0
btpo_next
| 0
btpo
| 0
btpo_flags
| 3
bt_page_items(relname text, blkno int) returns setof record
bt_page_items возвращает детализированную информацию обо всех элементах на странице B-
дерева. Например:
test=# SELECT * FROM bt_page_items(‘pg_cast_oid_index’, 1);
itemoffset | ctid
| itemlen | nulls | vars |
data
————+———+———+——-+——+————-
1 | (0,1)
|
12 | f
| f
| 23 27 00 00
2 | (0,2)
|
12 | f
| f
| 24 27 00 00
3 | (0,3)
|
12 | f
| f
| 25 27 00 00
4 | (0,4)
|
12 | f
| f
| 26 27 00 00
5 | (0,5)
|
12 | f
| f
| 27 27 00 00
6 | (0,6)
|
12 | f
| f
| 28 27 00 00
7 | (0,7)
|
12 | f
| f
| 29 27 00 00
8 | (0,8)
|
12 | f
| f
| 2a 27 00 00
На странице уровня листьев B-дерева, ctid указывает на кортеж в куче. На внутренней стра-
нице часть ctid, содержащая номер блока, указывает на другую страницу в самом индексе, а
часть смещения (второе число) игнорируется и обычно равняется 1.
Заметьте, что первый элемент в любой, кроме самой правой, странице (то есть в любой стра-
нице с ненулевым значением в поле btpo_next) представляет собой «верхний ключ», то есть
его поле data задаёт верхнюю границу всех элементов, находящихся на странице, а поле ctid
лишено смысла. Кроме того, на внутренних страницах первый действительный элемент дан-
ных (первый элемент после верхнего ключа) представляет элемент «минус бесконечность», без
2551Дополнительно по-
ставляемые модули
фактического значения в поле data. Однако такой элемент содержит в своём поле ctid кор-
ректную ссылку на данные.
bt_page_items(page bytea) returns setof record
Также можно передать функции bt_page_items страницу в виде значения bytea. Образ стра-
ницы для передачи в аргументе можно получить в результате вызова get_raw_page. Таким об-
разом, последний пример можно также переписать так:
test=# SELECT * FROM bt_page_items(get_raw_page(‘pg_cast_oid_index’, 1));
itemoffset | ctid
| itemlen | nulls | vars |
data
————+———+———+——-+——+————-
1 | (0,1)
|
12 | f
| f
| 23 27 00 00
2 | (0,2)
|
12 | f
| f
| 24 27 00 00
3 | (0,3)
|
12 | f
| f
| 25 27 00 00
4 | (0,4)
|
12 | f
| f
| 26 27 00 00
5 | (0,5)
|
12 | f
| f
| 27 27 00 00
6 | (0,6)
|
12 | f
| f
| 28 27 00 00
7 | (0,7)
|
12 | f
| f
| 29 27 00 00
8 | (0,8)
|
12 | f
| f
| 2a 27 00 00
Все остальные детали те же, что и с предыдущим вариантом вызова.
F.22.3. Функции для индексов BRIN
brin_page_type(page bytea) returns text
Функция brin_page_type возвращает тип страницы для заданной страницы индекса BRIN или
выдаёт ошибку, если эта страница не является корректной страницей индекса BRIN. Например:
test=# SELECT brin_page_type(get_raw_page(‘brinidx’, 0));
brin_page_type
—————-
meta
brin_metapage_info(page bytea) returns record
Функция brin_metapage_info возвращает разнообразные сведения о метастранице индекса
BRIN. Например:
test=# SELECT * FROM brin_metapage_info(get_raw_page(‘brinidx’, 0));
magic
| version | pagesperrange | lastrevmappage
————+———+—————+—————-
0xA8109CFA |
1 |
4 |
2
brin_revmap_data(page bytea) returns setof tid
Функция brin_revmap_data выдаёт список идентификаторов кортежей со страницы сопостав-
лений зон индекса BRIN. Например:
test=# SELECT * FROM brin_revmap_data(get_raw_page(‘brinidx’, 2)) LIMIT 5;
pages
———
(6,137)
(6,138)
(6,139)
(6,140)
(6,141)
brin_page_items(page bytea, index oid) returns setof record
Функция brin_page_items выдаёт содержимое, сохранённое в странице данных BRIN. Напри-
мер:
2552Дополнительно по-
ставляемые модули
test=# SELECT * FROM brin_page_items(get_raw_page(‘brinidx’, 5),
‘brinidx’)
ORDER BY blknum, attnum LIMIT 6;
itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |
value
————+——–+——–+———-+———-+————-+————–
137 |
0 |
1 | t
| f
| f
|
137 |
0 |
2 | f
| f
| f
| (1 .. 88)
138 |
4 |
1 | t
| f
| f
|
138 |
4 |
2 | f
| f
| f
| (89 .. 176)
139 |
8 |
1 | t
| f
| f
|
139 |
8 |
2 | f
| f
| f
| (177 .. 264)
Возвращаемые столбцы соответствуют полям в структурах BrinMemTuple и BrinValues. Подроб-
нее они описаны в src/include/access/brin_tuple.h.
F.22.4. Функции для индексов GIN
gin_metapage_info(page bytea) returns record
Функция gin_metapage_info выдаёт информацию о метастранице индекса GIN. Например:
test=# SELECT * FROM gin_metapage_info(get_raw_page(‘gin_index’, 0));
-[ RECORD 1 ]—-+———–
pending_head
| 4294967295
pending_tail
| 4294967295
tail_free_size
| 0
n_pending_pages | 0
n_pending_tuples | 0
n_total_pages
| 7
n_entry_pages
| 6
n_data_pages
| 0
n_entries
| 693
version
| 2
gin_page_opaque_info(page bytea) returns record
Функция gin_page_opaque_info выдаёт информацию из непрозрачной области индекса GIN,
например, тип страницы. Например:
test=# SELECT * FROM gin_page_opaque_info(get_raw_page(‘gin_index’, 2));
rightlink | maxoff |
flags
———–+——–+————————
5 |
0 | (data,leaf,compressed)
(1 row)
gin_leafpage_items(page bytea) returns setof record
Функция gin_leafpage_items выдаёт информацию о данных, хранящихся в странице индекса
GIN на уровне листьев. Например:
test=# SELECT first_tid, nbytes, tids[0:5] AS some_tids
FROM gin_leafpage_items(get_raw_page(‘gin_test_idx’, 2));
first_tid | nbytes |
some_tids
———–+——–+———————————————————-
(8,41)
|
244 | (“(8,41)”,”(8,43)”,”(8,44)”,”(8,45)”,”(8,46)”)
(10,45)
|
248 | (“(10,45)”,”(10,46)”,”(10,47)”,”(10,48)”,”(10,49)”)
(12,52)
|
248 | (“(12,52)”,”(12,53)”,”(12,54)”,”(12,55)”,”(12,56)”)
(14,59)
|
320 | (“(14,59)”,”(14,60)”,”(14,61)”,”(14,62)”,”(14,63)”)
(167,16) |
376 | (“(167,16)”,”(167,17)”,”(167,18)”,”(167,19)”,”(167,20)”)
(170,30) |
376 | (“(170,30)”,”(170,31)”,”(170,32)”,”(170,33)”,”(170,34)”)
(173,44) |
197 | (“(173,44)”,”(173,45)”,”(173,46)”,”(173,47)”,”(173,48)”)
2553Дополнительно по-
ставляемые модули
(7 rows)
F.22.5. Функции для хеш-индексов
hash_page_type(page bytea) returns text
Функция hash_page_type возвращает тип страницы для заданной страницы хеш-индекса. На-
пример:
test=# SELECT hash_page_type(get_raw_page(‘con_hash_index’, 0));
hash_page_type
—————-
metapage
hash_page_stats(page bytea) returns setof record
Функция hash_page_stats возвращает информацию о странице группы или переполнения хеш-
индекса. Например:
test=# SELECT * FROM hash_page_stats(get_raw_page(‘con_hash_index’, 1));
-[ RECORD 1 ]—+———–
live_items
| 407
dead_items
| 0
page_size
| 8192
free_size
| 8
hasho_prevblkno | 4096
hasho_nextblkno | 8474
hasho_bucket
| 0
hasho_flag
| 66
hasho_page_id
| 65408
hash_page_items(page bytea) returns setof record
Функция hash_page_items возвращает информацию о данных, хранящихся на странице группы
или переполнения хеш-индекса. Например:
test=# SELECT * FROM hash_page_items(get_raw_page(‘con_hash_index’, 1)) LIMIT 5;
itemoffset |
ctid
|
data
————+———–+————
1 | (899,77) | 1053474816
2 | (897,29) | 1053474816
3 | (894,207) | 1053474816
4 | (892,159) | 1053474816
5 | (890,111) | 1053474816
hash_bitmap_info(index oid, blkno int) returns record
Функция hash_bitmap_info показывает состояние бита в странице битовой карты для опреде-
лённой страницы переполнения хеш-индекса. Например:
test=# SELECT * FROM hash_bitmap_info(‘con_hash_index’, 2052);
bitmapblkno | bitmapbit | bitstatus
————-+———–+———–
65 |
3 | t
hash_metapage_info(page bytea) returns record
hash_metapage_info возвращает информацию, хранящуюся в метастранице хеш-индекса. На-
пример:
test=# SELECT magic, version, ntuples, ffactor, bsize, bmsize, bmshift,
test-#
maxbucket, highmask, lowmask, ovflpoint, firstfree, nmaps, procid,
test-#
regexp_replace(spares::text, ‘(,0)<em>)’, ‘)’) as spares,
2554Дополнительно по-
ставляемые модули
test-#
regexp_replace(mapp::text, ‘(,0)</em>)’, ‘)’) as mapp
test-# FROM hash_metapage_info(get_raw_page(‘con_hash_index’, 0));
-[ RECORD
1 ]——————————————————————————-
spares
|
(0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204)
magic
| 105121344
version
| 3
ntuples
| 500500
ffactor
| 40
bsize
| 8152
bmsize
| 4096
bmshift
| 15
maxbucket | 12512
highmask | 16383
lowmask
| 8191
ovflpoint | 28
firstfree | 1204
nmaps
| 1
procid
| 450
spares
|
(0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204)
mapp
| (65)
F.23. passwordcheck
Модуль passwordcheck проверяет пароли пользователей, задаваемые командами CREATE ROLE и
ALTER ROLE. Если пароль признаётся слишком слабым, он не принимается и команда завершается
ошибкой.
Чтобы задействовать этот модуль, добавьте строку ‘$libdir/passwordcheck’ в переменную
shared_preload_libraries в postgresql.conf, а затем перезапустите сервер.
Этот модуль можно приспособить к вашим нуждам, изменив исходный код. Например, для провер-
ки паролей вы можете использовать библиотеку CrackLib — для этого нужно только раскомменти-
ровать две строки в Makefile и пересобрать модуль. (Мы не можем включить CrackLib по умолча-
нию из-за лицензии.) Без CrackLib этот модуль проверяет стойкость пароля по простым правилам,
которые вы можете изменить или расширить по своему усмотрению.
Внимание
Чтобы незашифрованные пароли не передавались по сети, не записывались в жур-
нал сервера и не стали каким-либо образом известны администратору баз данных,
PostgreSQL позволяет пользователю передавать предварительно зашифрованные па-
роли. Используя это, клиентские программы могут шифровать пароль, прежде чем пе-
редавать его серверу.
Это ограничивает полезность модуля passwordcheck, так как в этом случае можно толь-
ко попытаться угадать пароль. Поэтому использовать passwordcheck не рекомендует-
ся, когда требуется высокий уровень безопасности. Более безопасно будет применить
внешний вариант проверки подлинности, например GSSAPI (см. Главу 20), а не исполь-
зовать пароли, хранящиеся в базе данных.
Также можно изменить passwordcheck, чтобы предварительно зашифрованные паро-
ли не принимались, но если пользователи будут задавать пароли открытым текстом, с
этим связаны свои риски безопасности.
2555Дополнительно по-
ставляемые модули
F.24. pg_buffercache
Модуль pg_buffercache даёт возможность понять, что происходит в общем кеше буферов в реаль-
ном времени.
Этот модуль предоставляет функцию на C pg_buffercache_pages, возвращающую набор записей,
плюс представление pg_buffercache, которое является удобной обёрткой этой функции.
По умолчанию его использование разрешено только суперпользователям и членам роли
pg_read_all_stats. Дать доступ другим можно с помощью GRANT.
F.24.1. Представление pg_buffercache
Определения столбцов, содержащихся в представлении, показаны в Таблице F.15.
Таблица F.15. Столбцы pg_buffercache
Имя Тип
Ссылки
Описание
bufferid integer relfilenode oid pg_class.relfilenode Номер файлового узла
для отношения
reltablespace oid pg_tablespace.oid OID табличного про-
странства, содержаще-
го отношение
reldatabase oid pg_database.oid OID базы данных, со-
держащей отношение
relforknumber smallint Номер слоя в отно-
шении; см. include/
common/relpath.h
relblocknumber bigint Номер страницы в отно-
шении
isdirty boolean Страница загрязнена?
usagecount smallint Счётчик обращений по
часовой стрелке
pinning_backends integer Число обслуживающих
процессов,
закрепив-
ших этот буфер
ID,
в
диапазоне
1..shared_buffers
Для каждого буфера в общем кеше выдаётся одна строка. Для неиспользуемых буферов все поля
равны NULL, за исключением bufferid. Общие системные каталоги показываются как относящи-
еся к базе данных под номером 0.
Так как кеш используется совместно всеми базами данных, обычно в нём находятся и страницы из
отношений, не принадлежащих текущей базе данных. Это означает, что для некоторых строк при
соединении с pg_class не найдутся соответствующие строки, либо соединение будет некоррект-
ным. Если вы хотите выполнить соединение с pg_class, будет правильным ограничить соединение
строками, в которых reldatabase содержит OID текущей базы данных или ноль.
При обращении к представлению pg_buffercache устанавливаются блокировки менеджера внут-
ренних буферов на время, достаточное для копирования всех данных состояния буферов, которые
будут выводиться в представлении. Благодаря этому представление выдаёт согласованный набор
результатов, не блокируя при этом обычные операции с буфером дольше, чем необходимо. Тем не
менее, это может повлиять на производительность базы данных, если обращаться к этому пред-
ставлению часто.
2556Дополнительно по-
ставляемые модули
F.24.2. Пример вывода
regression=# SELECT c.relname, count(*) AS buffers
FROM pg_buffercache b INNER JOIN pg_class c
ON b.relfilenode = pg_relation_filenode(c.oid) AND
b.reldatabase IN (0, (SELECT oid FROM pg_database
WHERE datname = current_database()))
GROUP BY c.relname
ORDER BY 2 DESC
LIMIT 10;
relname
| buffers
———————————+———
tenk2
|
345
tenk1
|
141
pg_proc
|
46
pg_class
|
45
pg_attribute
|
43
pg_class_relname_nsp_index
|
30
pg_proc_proname_args_nsp_index |
28
pg_attribute_relid_attnam_index |
26
pg_depend
|
22
pg_depend_reference_index
|
20
(10 rows)
F.24.3. Авторы
Марк Кирквуд <a href="mailto:markir@paradise.net.nz">markir@paradise.net.nz</a>
Предложения по конструкции: Нейл Конвей <a href="mailto:neilc@samurai.com">neilc@samurai.com</a>
Советы по отладке: Том Лейн <a href="mailto:tgl@sss.pgh.pa.us">tgl@sss.pgh.pa.us</a>
F.25. pgcrypto
Модуль pgcrypto предоставляет криптографические функции для PostgreSQL.
F.25.1. Стандартные функции хеширования
F.25.1.1. digest()
digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea
Вычисляет двоичный хеш данных (data). Параметр type выбирает используемый алгоритм. Под-
держиваются стандартные алгоритмы: md5, sha1, sha224, sha256, sha384 и sha512. Если модуль
pgcrypto собирался с OpenSSL, становятся доступны и другие алгоритмы, как описано в Табли-
це F.19.
Если вы хотите получить дайджест в виде шестнадцатеричной строки, примените encode() к ре-
зультату. Например:
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS <script type="math/tex">SELECT encode(digest($1, 'sha1'), 'hex')</script> LANGUAGE SQL STRICT IMMUTABLE;
F.25.1.2. hmac()
hmac(data text, key text, type text) returns bytea
2557Дополнительно по-
ставляемые модули
hmac(data bytea, key bytea, type text) returns bytea
Вычисляет имитовставку на основе хеша для данных data с ключом key. Параметр type имеет то
же значение, что и для digest().
Эта функция похожа на digest(), но вычислить хеш с ней можно, только зная ключ. Это защищает
от сценария подмены данных и хеша вместе с ними.
Если размер ключа больше размера блока хеша, он сначала хешируется, а затем используется в
качестве ключа хеширования данных.
F.25.2. Функции хеширования пароля
Функции crypt() и gen_salt() разработаны специально для хеширования паролей. Функция
crypt() выполняет хеширование, а gen_salt() подготавливает параметры алгоритма для неё.
Алгоритмы в crypt() отличаются от обычных алгоритмов хеширования MD5 и SHA1 в следующих
аспектах:</li>
      <li>Они медленные. Так как объём данных невелик, это единственный способ усложнить перебор
паролей.</li>
      <li>Они используют случайное значение, называемое солью, чтобы у пользователей с одинаковыми
паролями зашифрованные пароли оказывались разными. Это также обеспечивает дополнитель-
ную защиту от получения обратного алгоритма.</li>
      <li>Они включают в результат тип алгоритма, что допускает сосуществование паролей, хеширован-
ных разными алгоритмами.</li>
      <li>Некоторые из них являются адаптируемыми — то есть с ростом производительности компьюте-
ров эти алгоритмы можно настроить так, чтобы они стали медленнее, при этом сохраняя совме-
стимость с существующими паролями.
В Таблице F.16 перечислены алгоритмы, поддерживаемые функцией crypt().
Таблица F.16. Алгоритмы, которые поддерживает crypt()
Алгоритм Макс. длина Адаптивный? Размер соли ( Размер
пароля
бит)
зультата
bf 72
md5 без
ний
xdes 8
des 8
да
ре- Описание
128 60 На
базе
Blowfish, вариа-
ция 2a
48 34 crypt
MD5
да 24 20 Расширенный
DES
нет 12 13 Изначальный
crypt из UNIX
ограниче- нет
на
базе
F.25.2.1. crypt()
crypt(password text, salt text) returns text
Вычисляет хеш пароля (password) в стиле crypt(3). Для сохранения нового пароля необходимо вы-
звать gen_salt(), чтобы сгенерировать новое значение соли (salt). Для проверки пароля нужно
передать сохранённое значение хеша в параметре salt и проверить, соответствует ли результат
сохранённому значению.
Пример установки нового пароля:
2558Дополнительно по-
ставляемые модули
UPDATE … SET pswhash = crypt(‘new password’, gen_salt(‘md5’));
Пример проверки пароля:
SELECT (pswhash = crypt(‘entered password’, pswhash)) AS pswmatch FROM … ;
Этот запрос возвращает true, если введённый пароль правильный.
F.25.2.2. gen_salt()
gen_salt(type text [, iter_count integer ]) returns text
Вычисляет новое случайное значение соли для функции crypt(). Строка соли также говорит
crypt(), какой алгоритм использовать.
Параметр type задаёт алгоритм хеширования. Принимаются следующие варианты: des, xdes, md5
и bf.
Параметр iter_count позволяет пользователю указать счётчик итераций для алгоритма, который
его принимает. Чем больше это число, тем больше времени уйдёт на вычисление хеша пароля, а
значит, тем больше времени понадобится, чтобы взломать его. Хотя со слишком большим значе-
нием время вычисления хеша может вырасти до нескольких лет — это вряд ли практично. Когда
параметр iter_count опускается, применяется количество итераций по умолчанию. Множество
допустимых значений для iter_count зависит от алгоритма, как показано в Таблице F.17.
Таблица F.17. Счётчики итераций для crypt()
Алгоритм По умолчанию Мин. Макс.
xdes 725 1 16777215
bf 6 4 31
Для xdes есть дополнительное ограничение: счётчик итераций должен быть нечётным.
При выборе подходящего числа итераций учтите, что оригинальный алгоритм DES crypt был рас-
считан так, чтобы выдавать 4 хеша в секунду на компьютерах того времени. Если за секунду будет
вычисляться меньше 4 хешей, скорее всего, возникнут определённые неудобства при пользовании.
С другой стороны, скорость больше, чем 100 хешей в секунду, вероятно, будет слишком высокой.
В Таблице F.18 дана сводка относительной скорости различных алгоритмов хеширования. В табли-
це показано, сколько времени уйдёт на перебор всех комбинацией символов в восьмисимвольном
пароле, в предположении, что пароль содержит только буквы в нижнем регистре, либо буквы в
верхнем и нижнем регистре, а также цифры. В строках crypt-bf числа после косой черты показы-
вают значение параметра iter_count функции gen_salt.
Таблица F.18. Скорости алгоритмов хеширования
Алгоритм Хешей/сек. Для [a-z] Для [A-Za-z0-9] Длительность
относительно
md5
crypt-bf/8 1792 4 года 3927 лет 100k
crypt-bf/7 3648 2 года 1929 лет 50k
crypt-bf/6 7168 1 год 982 лет 25k
crypt-bf/5 13504 188 дней 521 лет 12.5k
crypt-md5 171584 15 дней 41 год 1k
crypt-des 23221568 157.5 минут 108 дней 7
sha1 37774272 90 минут 68 дней 4
2559Дополнительно по-
ставляемые модули
Алгоритм Хешей/сек. Для [a-z] Для [A-Za-z0-9] Длительность
относительно
md5
md5 (хеш) 150085504 22.5 минут 17 дней 1
Замечания:
• Для расчётов использовался процессор Intel Mobile Core i3.
• Показатели алгоритмов crypt-des и crypt-md5 взяты из вывода теста программы John the
Ripper v1.6.38.
• Показатели md5 получены программой mdcrack 1.2.
• Показатели sha1 получены программой lcrack-20031130-beta.
• Показатели crypt-bf получены простой программой, обрабатывающей в цикле 1000 паро-
лей из 8-символов. Таким способом можно показать скорость с разным числом итераций. Для
справки: john -test показывает 13506 циклов/с для crypt-bf/5. (Это очень небольшое разли-
чие в результатах согласуется с тем фактом, что реализация crypt-bf в pgcrypto не отличает-
ся от применяемой в программе John the Ripper.)
Заметьте, что вариант «перепробовать все комбинации» не вполне реалистичен. Обычно перебор
паролей производится с применением словарей, которые содержат и обычные слова, и их различ-
ные видоизменения. Поэтому даже похожие на слова пароли обычно можно подобрать быстрее,
чем за указанное время, тогда как 6-символьный несловесный пароль может избежать взлома. А
может и не избежать.
F.25.3. Функции шифрования на базе PGP
Функции, описанные здесь, реализуют часть стандарта OpenPGP (RFC 4880), относящуюся к шиф-
рованию. Они поддерживают шифрование как с симметричным, так и с закрытым ключом.
Зашифрованное PGP сообщение состоит из 2 частей или пакетов:
• Пакет, содержащий сеансовый ключ — либо симметричный, либо открытый (в зашифрован-
ном виде).
• Пакет, содержащий данные, зашифрованные сеансовым ключом.
При шифровании с симметричным ключом (то есть, паролем):</li>
      <li>Заданный пароль хешируется по алгоритму String2Key (S2K). Этот алгоритм подобен алгорит-
мам crypt() — специально замедлен и добавляет случайную соль — но на выход выдаёт двоич-
ный ключ полной длины.</li>
      <li>Если требуется отдельный сеансовый ключ, генерируется новый случайный ключ. В противном
случае в качестве сеансового будет использоваться непосредственно ключ S2K.</li>
      <li>Когда используется непосредственно ключ S2K, в пакет сеансового ключа помещаются только
параметры S2K. В противном случае сеансовый ключ шифруется ключом S2K и результат поме-
щается в пакет сеансового ключа.
При шифровании с открытым ключом:</li>
      <li>Генерируется новый случайный сеансовый ключ.</li>
      <li>Он зашифровывается открытым ключом и помещается в пакет сеансового ключа.
В любом случае данные, которые должны быть зашифрованы, обрабатываются так:</li>
      <li>Необязательная подготовка данных: сжатие, перекодировка в UTF-8 и/или преобразование кон-
цов строк.
2560Дополнительно по-
ставляемые модули</li>
      <li>Перед данными добавляется блок случайных байт. Это равносильно использованию случайного
вектора инициализации.</li>
      <li>В конце добавляется хеш SHA1 случайного префикса и данных.</li>
      <li>Всё это шифруется сеансовым ключом и помещается в пакет данных.
F.25.3.1. pgp_sym_encrypt()
pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
Шифрует данные (data) симметричным ключом PGP psw. В options могут передаваться крипто-
графические параметры, описанные ниже.
F.25.3.2. pgp_sym_decrypt()
pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
Расшифровывает сообщение, зашифрованное симметричным ключом PGP.
Расшифровывать данные bytea функцией pgp_sym_decrypt запрещено. Это ограничение введено,
чтобы не допустить вывода некорректных символьных данных. Расшифровывать изначально тек-
стовые данные с помощью pgp_sym_decrypt_bytea можно без ограничений.
Аргумент options может содержать криптографические параметры, описанные ниже.
F.25.3.3. pgp_pub_encrypt()
pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
Зашифровывает данные (data) открытым ключом PGP (key). Если передать этой функции закрытый
ключ, она выдаст ошибку.
Аргумент options может содержать криптографические параметры, описанные ниже.
F.25.3.4. pgp_pub_decrypt()
pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns
bytea
Расшифровывает сообщение, зашифрованное открытым ключом. В key должен передаваться за-
крытый ключ, соответствующий открытому ключу, применяющемуся при шифровании. Если сек-
ретный ключ защищён паролем, этот пароль нужно передать в параметре psw. Если пароля нет,
но необходимо передать криптографические параметры, вы должны передать пустой пароль.
Расшифровывать данные bytea функцией pgp_pub_decrypt запрещено. Это ограничение введено,
чтобы не допустить вывода недопустимых символьных данных. Расшифровывать изначально тек-
стовые данные с помощью pgp_pub_decrypt_bytea можно без ограничений.
Аргумент options может содержать криптографические параметры, описанные ниже.
F.25.3.5. pgp_key_id()
pgp_key_id(bytea) returns text
pgp_key_id извлекает идентификатор ключа из открытого или закрытого ключа PGP. Она также
может выдать идентификатор ключа, которым были зашифрованы данные, если ей передаётся
зашифрованное сообщение.
Она может выдать два специальных идентификатора ключа:
2561Дополнительно по-
ставляемые модули
• SYMKEY
Сообщение зашифровано симметричным ключом.
• ANYKEY
Сообщение зашифровано открытом ключом, но идентификатор ключа был удалён. Это означа-
ет, что вам надо будет перепробовать ключи, чтобы подобрать подходящий. Сама библиотека
pgcrypto не генерирует такие сообщения.
Заметьте, что разные ключи могут иметь одинаковый идентификатор. Это редкое, но не невероят-
ное явление. В таком случае клиентское приложение должно пытаться расшифровать данные с
каждым ключом, пока не найдёт подходящий — примерно так же, как и с ANYKEY.
F.25.3.6. armor(), dearmor()
armor(data bytea [ , keys text[], values text[] ]) returns text
dearmor(data text) returns bytea
Эти функции переводят двоичные данные в/из формата PGP «ASCII Armor», по сути представляю-
щий собой кодировку Base64 с контрольными суммами и дополнительным форматированием.
Если задаются массивы keys и values, для каждой пары ключ/значения в формат Armor добавля-
ется заголовок Armor. Оба массива должны быть одномерными и иметь одинаковую длину. Зада-
ваемые ключи и значения могут содержать только символы ASCII.
F.25.3.7. pgp_armor_headers
pgp_armor_headers(data text, key out text, value out text) returns setof record
Функция pgp_armor_headers() извлекает заголовки Armor из параметра data. Она возвращает на-
бор строк с двумя столбцами, key и value. Если в ключах или значениях оказываются символы не
ASCII, они воспринимаются как UTF-8.
F.25.3.8. Параметры функций PGP
Имена параметров подобны принятым в GnuPG. Значение параметра должно задаваться после
знака равно; друг от друга параметры отделяются запятыми. Например:
pgp_sym_encrypt(data, psw, ‘compress-algo=1, cipher-algo=aes256’)
Все эти параметры, кроме convert-crlf, применяются только к функциям шифрования. Функции
расшифровывания получают параметры из данных PGP.
Вероятно, самые интересные параметры — это compress-algo и unicode-mode. Остальные должны
иметь достаточно адекватные значения по умолчанию.
F.25.3.8.1. cipher-algo
Выбирает алгоритм шифрования.
Значения: bf, aes128, aes192, aes256 (только OpenSSL: 3des, cast5)
По умолчанию: aes128
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.2. compress-algo
Выбирает алгоритм сжатия. Принимается, только если PostgreSQL собран с zlib.
Значения:
0 — без сжатия
1 — сжатие ZIP
2 — сжатие ZLIB (= ZIP плюс метаданные и CRC блоков)
По умолчанию: 0
2562Дополнительно по-
ставляемые модули
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.3. compress-level
Определяет уровень сжатия. Чем больше уровень, тем меньшего объёма результат, но длительнее
процесс. Значение 0 отключает сжатие.
Значения: 0, 1-9
По умолчанию: 6
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.4. convert-crlf
Определяет, преобразовывать ли \n в \r\n при шифровании и \r\n в \n при дешифровании. В RFC
4880 требуется, чтобы текстовые данные хранились с переводами строк в виде \r\n. Воспользуй-
тесь этим параметром, чтобы поведение полностью соответствовало RFC.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
F.25.3.8.5. disable-mdc
Не защищать данные хешем SHA-1. Единственная разумная причина использовать этот параметр
— добиться совместимости с древними программами PGP, вышедшими до того, как в RFC 4880
была предусмотрена защита пакетов с SHA-1. Все последние реализации с gnupg.org и pgp.com
прекрасно поддерживают это.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.6. sess-key
Использовать отдельный сеансовый ключ. Для шифрования с открытым ключом всегда использу-
ется отдельный сеансовый ключ; этот параметр предназначен для шифрования с симметричным
ключом, которое по умолчанию использует непосредственно ключ S2K.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt
F.25.3.8.7. s2k-mode
Режим алгоритма S2K.
Значения:
0 — Без соли. Опасно!
1 — С солью, но с фиксированным числом итераций.
3 — С переменным числом итераций.
По умолчанию: 3
Применим к: pgp_sym_encrypt
F.25.3.8.8. s2k-count
Число итераций для алгоритма S2K. Оно должно быть не меньше 1024 и не больше 65011712.
По умолчанию: случайное значение между 65536 и 253952
Применим к: pgp_sym_encrypt, только с s2k-mode=3
F.25.3.8.9. s2k-digest-algo
Выбирает алгоритм хеширования, который будет использоваться для вычисления S2K.
2563Дополнительно по-
ставляемые модули
Значения: md5, sha1
По умолчанию: sha1
Применим к: pgp_sym_encrypt
F.25.3.8.10. s2k-cipher-algo
Выбирает шифр, который будет использоваться для шифрования отдельного сеансового ключа.
Значения: bf, aes, aes128, aes192, aes256
По умолчанию: используется cipher-algo
Применим к: pgp_sym_encrypt
F.25.3.8.11. unicode-mode
Определяет, преобразовывать ли текстовые данные из внутренней кодировки базы данных в UTF-8
и обратно. Если кодировка базы уже UTF-8, перекодировка не производится, но сообщение поме-
чается как UTF-8. Без данного параметра этого не происходит.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.9. Формирование ключей PGP с применением GnuPG
Формирование нового ключа:
gpg –gen-key
Предпочитаемый тип ключей: «DSA and Elgamal».
Для шифрования RSA вы должны создать главный ключ либо DSA, либо RSA только для подписа-
ния, а затем добавить подключ для шифрования, выполнив команду gpg –edit-key.
Просмотр списка ключей:
gpg –list-secret-keys
Экспорт открытого ключа в формате «ASCII Armor»:
gpg -a –export KEYID &gt; public.key
Экспорт закрытого ключа в формате «ASCII Armor»:
gpg -a –export-secret-keys KEYID &gt; secret.key
Прежде чем передавать эти ключи функциям PGP, вы должны применить функцию dearmor() к
этим ключам. Либо, если вы можете обработать двоичные данные, уберите -a из команды.
Дополнительную информацию вы можете получить в руководстве man gpg, The GNU Privacy
Handbook (Руководство GNU по обеспечению конфиденциальности) и другой документации на сай-
те https://www.gnupg.org/.
F.25.3.10. Ограничения кода PGP
• Не поддерживается подписывание. Это также означает, что принадлежность подключа шиф-
рования главному ключу не проверяется.
• Не поддерживается использование ключа шифрования в качестве главного ключа. Так как по-
добная практика обычно не приветствуется, это не должно быть проблемой.
• Нет поддержки нескольких подключей. Это может представляться проблемой, так как такие
ключи не редкость. С другой стороны, вы всё равно не должны использовать обычные ключи
GPG/PGP с pgcrypto, а должны создать новые, учитывая, что это другой сценарий использова-
ния.
2564Дополнительно по-
ставляемые модули
F.25.4. Низкоуровневые функции шифрования
Эти функции выполняют только шифрование данных; они не предоставляют расширенные возмож-
ности шифрования PGP. Таким образом, с ними связаны следующие проблемы:</li>
      <li>Они используют ключ пользователя непосредственно в качестве ключа шифрования.</li>
      <li>Они не обеспечивают проверку целостности, которая должна выявлять модификацию зашифро-
ванных данных.</li>
      <li>Они рассчитаны на то, что пользователи будут управлять всеми параметрами шифрования са-
мостоятельно, даже вектором инициализации.</li>
      <li>Они не рассчитаны на текст.
Поэтому с появлением поддержки шифрования PGP использовать низкоуровневые функции шиф-
рования не рекомендуется.
encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea
encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
Эти функции зашифровывают/расшифровывают данные, применяя метод шифрования, заданный
параметром type. Строка type имеет следующий формат:
алгоритм [ - режим ] [ /pad: дозаполнение ]
где допустимый алгоритм:
• bf — Blowfish
• aes — AES (Rijndael-128, -192 или -256)
допустимый режим:
• cbc — следующий блок зависит от предыдущего (по умолчанию)
• ecb — каждый блок шифруется отдельно (только для тестирования)
и допустимое дозаполнение:
• pkcs — данные могут быть любой длины (по умолчанию)
• none — размер данных должен быть кратен размеру блока шифра
Так что, например, эти вызовы равнозначны:
encrypt(data, ‘fooz’, ‘bf’)
encrypt(data, ‘fooz’, ‘bf-cbc/pad:pkcs’)
Для функций encrypt_iv и decrypt_iv параметр iv задаёт начальное значение для режима CBC;
для ECB он игнорируется. Оно обрезается или дополняется нулями, если его размер не равен ровно
размеру блока. В функциях без этого параметра оно по умолчанию заполняется нулями.
F.25.5. Функции получения случайных данных
gen_random_bytes(count integer) returns bytea
Возвращает криптографически стойкие случайные байты в количестве count. За один вызов можно
получить максимум 1024 байт. Это ограничение предотвращает исчерпание пула энтропии.
gen_random_uuid() returns uuid
2565Дополнительно по-
ставляемые модули
Возвращает UUID версии 4 (случайный).
F.25.6. Замечания
F.25.6.1. Конфигурирование
Модуль pgcrypto настраивается согласно установкам, полученным в главном скрипте configure
PostgreSQL. На его конфигурацию влияют аргументы –with-zlib и –with-openssl.
При компиляции с zlib шифрующие функции PGP могут сжимать данные перед шифрованием.
При компиляции с OpenSSL будут доступны дополнительные алгоритмы. Кроме того, функции
шифрования с открытым ключом будут быстрее, так как OpenSSL содержит оптимизированные
функции для работы с большими числами (BIGNUM).
Таблица F.19. Обзор функциональности с и без OpenSSL
Функциональность Встроенная С OpenSSL
MD5 да да
SHA1 да да
SHA224/256/384/512 да да
Другие алгоритмы хеширова- нет
ния да (Примечание 1)
Blowfish да да
AES да да
DES/3DES/CAST5 нет да
Низкоуровневое шифрование да да
шифрование да да
Шифрование PGP с открытым да
ключом да
Симметричное
PGP
Замечания:</li>
      <li>Автоматически выбирается любой алгоритм хеширования, который поддерживает OpenSSL. Это
невозможно с шифрами, они должны поддерживаться явно.
F.25.6.2. Обработка NULL
Как и положено по стандарту SQL, все эти функции возвращают NULL, если один из аргументов
— NULL. Это может угрожать безопасности при неаккуратном использовании.
F.25.6.3. Ограничения безопасности
Все функции pgcrypto выполняются внутри сервера баз данных. Это означает, что все данные и
пароли передаются между функциями pgcrypto и клиентскими приложениями открытым текстом.
Поэтому вы должны:</li>
      <li>Подключаться локально или использовать подключения SSL.</li>
      <li>Доверять и системе, и администратору баз данных.
Если это невозможно, лучше произвести шифрование в клиентском приложении.
Эта реализация не противостоит атакам по сторонним каналам. Например, время, требующееся
для выполнения функции дешифрования pgcrypto, будет разным для разного шифротекста задан-
ного размера.
2566Дополнительно по-
ставляемые модули
F.25.6.4. Полезное чтение
• https://www.gnupg.org/gph/en/manual.html
The GNU Privacy Handbook (Руководство GNU по обеспечению конфиденциальности)
• http://www.openwall.com/crypt/
Описывает алгоритм crypt-blowfish.
• http://www.iusmentis.com/security/passphrasefaq/
Как выбрать хороший пароль.
• http://world.std.com/~reinhold/diceware.html
Интересный способ выбора пароля.
• http://www.interhack.net/people/cmcurtin/snake-oil-faq.html
Описывает хорошую и плохую криптографию.
F.25.6.5. Техническая информация
• https://tools.ietf.org/html/rfc4880
Формат сообщений OpenPGP.
• https://tools.ietf.org/html/rfc1321
Алгоритм вычисления дайджеста сообщения MD5.
• https://tools.ietf.org/html/rfc2104
HMAC: Хеширование по ключу для аутентификации сообщений.
• https://www.usenix.org/legacy/events/usenix99/provos.html
Сравнение алгоритмов crypt-des, crypt-md5 и bcrypt.
• https://en.wikipedia.org/wiki/Fortuna_(PRNG)
Описание Fortuna CSPRNG.
• http://jlcooke.ca/random/
Драйвер /dev/random для Linux на базе Fortuna, написанный Жан-Люком Куком.
F.25.7. Автор
Марко Крин <a href="mailto:markokr@gmail.com">markokr@gmail.com</a>
Модуль pgcrypto заимствует код из следующих источников:
Алгоритм Автор Источник исходного кода
Шифрование DES Дэвид Буррен и другие FreeBSD, libcrypt
Хеширование MD5 Пол-Хеннинг Камп FreeBSD, libcrypt
Шифрование Blowfish Solar Designer www.openwall.com
Шифр Blowfish Саймон Тэтем PuTTY
Шифр Rijndael Брайан Глэдмен OpenBSD, sys/crypto
Хеш MD5 и SHA1 Проект WIDE KAME, kame/sys/crypto
SHA256/384/512 Аарон Д. Гиффорд OpenBSD, sys/crypto
2567Дополнительно по-
ставляемые модули
Алгоритм Автор Источник исходного кода
Математика BIGNUM Майкл Дж. Фромбергер dartmouth.edu/~sting/sw/imath
F.26. pg_freespacemap
Модуль pg_freespacemap предоставляет средства для исследования карты свободного простран-
ства (FSM). В нём реализована функция pg_freespace, точнее, две перегруженных функции. Эти
функции показывают значение, записанное в карте свободного пространства для данной страни-
цы, либо для всех страниц отношения.
По умолчанию его использование разрешено только суперпользователям и членам роли
pg_stat_scan_tables. Дать доступ другим можно с помощью GRANT.
F.26.1. Функции
pg_freespace(rel regclass IN, blkno bigint IN) returns int2
Возвращает объём свободного пространства на странице для отношения, заданного парамет-
ром blkno, согласно FSM.
pg_freespace(rel regclass IN, blkno OUT bigint, avail OUT int2)
Выдаёт объём свободного пространства на каждой странице отношения, согласно FSM. Возвра-
щается набор кортежей (blkno bigint, avail int2), по одному кортежу для каждой страницы
в отношении.
Значения, хранимые в карте свободного пространства, не являются точными. Они округляются до
1/256 величины BLCKSZ (до 32 байт со значением BLCKSZ по умолчанию) и не поддерживаются в
актуальном состоянии при каждом добавлении и изменении кортежей.
Для индексов отслеживаются полностью неиспользованные страницы, а не свободное простран-
ство в страницах. Таким образом, эти значения отражают только то, что страница занята или сво-
бодна.
Примечание
Интерфейс был изменён в версии 8.4, в соответствии с нововведениями реализации
FSM, которые появились в этой версии.
F.26.2. Пример вывода
postgres=# SELECT * FROM pg_freespace(‘foo’);
blkno | avail
——-+——-
0 |
0
1 |
0
2 |
0
3 |
32
4 |
704
5 |
704
6 |
704
7 | 1216
8 |
704
9 |
704
10 |
704
11 |
704
2568Дополнительно по-
ставляемые модули
12 |
704
13 |
704
14 |
704
15 |
704
16 |
704
17 |
704
18 |
704
19 | 3648
(20 rows)
postgres=# SELECT * FROM pg_freespace(‘foo’, 7);
pg_freespace
————–
1216
(1 row)
F.26.3. Автор
Исходную версию разработал Марк Кирквуд <a href="mailto:markir@paradise.net.nz">markir@paradise.net.nz</a>. Для версии 8.4 с новой
реализацией FSM код адаптировал Хейкки Линнакангас <a href="mailto:heikki@enterprisedb.com">heikki@enterprisedb.com</a>
F.27. pg_prewarm
Модуль pg_prewarm предоставляет удобную возможность загружать данные отношений в кеш
операционной системы или в кеш буферов PostgreSQL. Предварительную загрузку можно
выполнить вручную, вызвав функцию pg_prewarm, или автоматически, добавив pg_prewarm в
shared_preload_libraries. Во втором случае система запустит фоновый процесс, который будет пе-
риодически записывать содержимое разделяемых буферов в файл autoprewarm.blocks с тем, что-
бы эти блоки подгружались в память при запуске сервера, используя два дополнительных фоновых
процесса.
F.27.1. Функции
pg_prewarm(regclass, mode text default ‘buffer’, fork text default ‘main’,
first_block int8 default null,
last_block int8 default null) RETURNS int8
Первый аргумент задаёт отношение, которое будет «разогрето». Во втором указывается метод
«разогрева», из описанных ниже; в третьем задаётся целевой слой отношения, обычно main. В чет-
вёртом аргументе можно передать номер первого разогреваемого блока (NULL принимается как
синоним нуля), а в пятом — номер последнего блока (NULL означает последний блок отношения).
Возвращает эта функция количество разогретых блоков.
Эта функция поддерживает три режима разогрева. В режиме prefetch выдаются асинхронные за-
просы предвыборки данных операционной системе, если они поддерживаются, либо происходит
ошибка. В режиме read считывается заданный диапазон блоков; в отличие от prefetch это проис-
ходит синхронно и поддерживается во всех ОС и любыми сборками, но может быть медленнее. В
режиме buffer запрошенный диапазон блоков считывается в кеш буферов базы данных.
Заметьте, что с любым из этих методов попытка разогреть больше блоков, чем может уместиться
в кеше (в кеше ОС в режимах prefetch и read, либо в кеше PostgreSQL в режиме buffer) скорее
всего приведёт к тому, что блоки с меньшими номерами будут вытеснены из кеша при чтении по-
следующих блоков. Кроме того, разогретые данные никаким специальным образом не защищают-
ся от вытеснения из кеша, так что возможна ситуация, когда из-за другой активности только что
разогретые блоки будут вытеснены вскоре после чтения; с другой стороны при таком разогреве
из кеша могут быть вытеснены другие данные. Поэтому разогрев обычно наиболее полезен при
загрузке, когда кеши в основном пусты.
autoprewarm_start_worker() RETURNS void
2569Дополнительно по-
ставляемые модули
Запустить основной рабочий процесс авторазогрева. Обычно он запускается автоматически, но
эта функция полезна, если автоматический разогрев не был настроен при запуске сервера и вы
хотите запустить этот процесс позже.
autoprewarm_dump_now() RETURNS int8
Обновить autoprewarm.blocks немедленно. Это может быть полезно, если рабочий процесс авто-
разогрева не работает, но вы хотите, чтобы авторазогрев был произведён при перезапуске. Эта
функция возвращает число записей, внесённых в autoprewarm.blocks.
F.27.2. Параметры конфигурации
pg_prewarm.autoprewarm (boolean)
Указывает, должен ли сервер запускать рабочий процесс авторазогрева. По умолчанию он
включён. Задать этот параметр можно только при запуске сервера.
pg_prewarm.autoprewarm_interval (int)
Задаёт интервал между обновлениями файла autoprewarm.blocks. Значение по умолчанию —
300 сек. При значении, равном 0, файл будет сохраняться не периодически, а только при от-
ключении сервера.
F.27.3. Автор
Роберт Хаас <a href="mailto:rhaas@postgresql.org">rhaas@postgresql.org</a>
F.28. pgrowlocks
Модуль pgrowlocks предоставляет функцию, показывающую информацию о блокировке строк для
заданной таблицы.
По
умолчанию
его
использование
разрешено
суперпользователям,
pg_stat_scan_tables и пользователям с правом SELECT в заданной таблице.
членам
роли
F.28.1. Обзор
pgrowlocks(text) returns setof record
В параметре передаётся имя таблицы. В результате возвращается набор записей, в котором строка
соответствует строке, заблокированной в таблице. Столбцы результата показаны в Таблице F.20.
Таблица F.20. Столбцы результата pgrowlocks
Имя Тип Описание
locked_row tid Идентификатор кортежа (TID)
блокированной строки
locker xid Идентификатор блокирующей
транзакции или идентифика-
тор мультитранзакции, если это
мультитранзакция
multi boolean True, если блокирующий субъ-
ект — мультитранзакция
xids xid[] Идентификаторы блокирующих
транзакций (больше одной для
мультитранзакции)
modes text[] Режим блокирования (больше
одного для мультитранзакции),
массив со значениями Key
2570Дополнительно по-
ставляемые модули
Имя Тип Описание
Share, Share, For No Key Update,
No Key Update, For Update,
Update.
pids integer[] Идентификаторы блокирующих
обслуживающих процессов (
больше одного для мультитран-
закции)
Функция pgrowlocks запрашивает блокировку AccessShareLock для целевой таблицы и считывает
строку за строкой для сбора информации о блокировке строк. Это происходит небыстро для боль-
шой таблицы. Заметьте, что:</li>
      <li>Если таблица в целом заблокирована кем-то ещё, функция pgrowlocks будет блокироваться.</li>
      <li>Функция pgrowlocks не гарантирует внутреннюю согласованность результатов. В ходе её выпол-
нения могут быть установлены новые блокировки строк, либо освобождены старые.
Функция pgrowlocks не показывает содержимое заблокированных строк. Если вы хотите парал-
лельно взглянуть на содержимое строк, можно проделать примерно следующее:
SELECT * FROM accounts AS a, pgrowlocks(‘accounts’) AS p
WHERE p.locked_row = a.ctid;
Однако учтите, что такой запрос будет очень неэффективным.
F.28.2. Пример вывода
=# SELECT * FROM pgrowlocks(‘t1’);
locked_row | locker | multi | xids |
modes
| pids
————+——–+——-+——-+—————-+——–
(0,1)
|
609 | f
| (609) | (“For Share”) | (3161)
(0,2)
|
609 | f
| (609) | (“For Share”) | (3161)
(0,3)
|
607 | f
| (607) | (“For Update”) | (3107)
(0,4)
|
607 | f
| (607) | (“For Update”) | (3107)
(4 rows)
F.28.3. Автор
Тацуо Исии
F.29. pg_stat_statements
Модуль pg_stat_statements предоставляет возможность отслеживать статистику выполнения сер-
вером всех операторов SQL.
Этот модуль нужно загружать, добавив pg_stat_statements в shared_preload_libraries в файле
postgresql.conf, так как ему требуется дополнительная разделяемая память. Это значит, что для
загрузки или выгрузки модуля необходимо перезапустить сервер.
Когда модуль pg_stat_statements загружается, он отслеживает статистику по всем базам
данных на сервере. Для получения и обработки этой статистики этот модуль предоставля-
ет представление pg_stat_statements и вспомогательные функции pg_stat_statements_reset и
pg_stat_statements. Эти объекты не доступны глобально, но их можно установить в определённой
базе данных, выполнив команду CREATE EXTENSION pg_stat_statements.
F.29.1. Представление pg_stat_statements
Статистика, собираемая модулем, выдаётся через представление с именем pg_stat_statements.
Это представление содержит отдельные строки для каждой комбинации идентификатора базы дан-
2571Дополнительно по-
ставляемые модули
ных, идентификатора пользователя и идентификатора запроса (но в количестве, не превышающем
максимальное число различных операторов, которые может отслеживать модуль). Столбцы пред-
ставления показаны в Таблице F.21.
Таблица F.21. Столбцы pg_stat_statements
Имя Тип Ссылки Описание
userid oid pg_authid .oid OID пользователя, вы-
полнявшего оператор
dbid oid pg_database .oid OID базы данных, в ко-
торой выполнялся опе-
ратор
queryid bigint Внутренний
хеш-код,
вычисленный по дереву
разбора оператора
query text Текст,
представляю-
щий оператор
calls bigint Число выполнений
total_time double precision Общее время, потра-
ченное на оператор, в
миллисекундах
min_time double precision Минимальное
время,
потраченное на опера-
тор, в миллисекундах
max_time double precision Максимальное время,
потраченное на опера-
тор, в миллисекундах
mean_time double precision Среднее время, потра-
ченное на оператор, в
миллисекундах
stddev_time double precision Стандартное отклоне-
ние во времени, потра-
ченном на оператор, в
миллисекундах
rows bigint Общее число строк, по-
лученных или затрону-
тых оператором
shared_blks_hit bigint Общее число попада-
ний в разделяемый кеш
блоков для данного опе-
ратора
shared_blks_read bigint Общее
число
чте-
ний разделяемых бло-
ков для данного опера-
тора
shared_blks_dirtied bigint Общее число разделя-
емых блоков, «загряз-
нённых» данным опера-
тором
shared_blks_written bigint Общее число разделя-
емых блоков, записан-
ных данным операто-
ром
2572Дополнительно по-
ставляемые модули
Имя Тип
Ссылки
Описание
local_blks_hit bigint Общее число попада-
ний в локальный кеш
блоков для данного опе-
ратора
local_blks_read bigint Общее число чтений
локальных блоков для
данного оператора
local_blks_dirtied bigint Общее число локаль-
ных блоков, «загряз-
нённых» данным опера-
тором
local_blks_written bigint Общее число локаль-
ных блоков, записан-
ных данным операто-
ром
temp_blks_read bigint Общее число чтений
временных блоков для
данного оператора
temp_blks_written bigint Общее число записей
временных блоков для
данного оператора
blk_read_time double precision Общее время, потра-
ченное оператором на
чтение блоков, в мил-
лисекундах (если вклю-
чён track_io_timing, или
ноль в противном слу-
чае)
blk_write_time double precision Общее время, потра-
ченное оператором на
запись блоков, в мил-
лисекундах (если вклю-
чён track_io_timing, или
ноль в противном слу-
чае)
По соображениям безопасности только суперпользователям и членам роли pg_read_all_stats
разрешено видеть текст SQL и queryid запросов, выполняемых другими пользователями. Однако
другие пользователи могут видеть статистику, если это представление установлено в их базу дан-
ных.
Планируемые запросы (то есть, SELECT, INSERT, UPDATE и DELETE) объединяются в одну запись в
pg_stat_statements, когда они имеют идентичные структуры запросов согласно внутреннему вы-
численному хешу. Обычно два запроса будут считаться равными при таком сравнении, если они
семантически равнозначны, не считая значений констант, фигурирующих в запросе. Однако слу-
жебные команды (то есть все другие команды) сравниваются строго по текстовым строкам запро-
сов.
Когда значение константы игнорируется в целях сравнения запроса с другими запросами, эта кон-
станта заменяется в выводе pg_stat_statements обозначением параметра, например, $1. В осталь-
ном этот вывод содержит текст первого запроса, хеш которого равнялся значению queryid, свя-
занному с записью в pg_stat_statements.
В некоторых случаях запросы с визуально различными текстами могут быть объединены в одну
запись pg_stat_statements. Обычно это происходит только для семантически равнозначных за-
2573Дополнительно по-
ставляемые модули
просов, но есть небольшая вероятность, что из-за наложений хеша несвязанные запросы могут
оказаться объединёнными в одной записи. (Однако это невозможно для запросов, принадлежащих
разным пользователям баз данных.)
Так как значение хеша queryid вычисляется по представлениям запроса на стадии после разбора,
возможна и обратная ситуация: запросы с одинаковым текстом могут оказаться в разных записях,
если они получили различные представления по разным причинам, например, из-за изменения
search_path.
Потребители статистики pg_stat_statements могут пожелать использовать в качестве более ста-
бильного и надёжного идентификатора для каждой записи не текст запроса, а queryid (возможно,
в сочетании с dbid и userid). Однако важно понимать, что стабильность значения хеша queryid
гарантируется с ограничениями. Так как этот идентификатор получается из дерева запроса по-
сле анализа, его значение будет, помимо прочего, зависеть от внутренних идентификаторов объ-
ектов, фигурирующих в этом представлении. С этим связано несколько неинтуитивных следствий.
Например, pg_stat_statements будет считать два одинаково выглядящих запроса разными, если
они обращаются к таблице, которая была удалена, а затем воссоздана между этими запросами. Ре-
зультат хеширования также чувствителен к различиям в машинной архитектуре и другим особен-
ностям платформы. Более того, не стоит рассчитывать на то, что queryid будет оставаться неиз-
менным при обновлении основных версий PostgreSQL.
Как правило, значения queryid можно считать надёжными и сравнимыми, только с условием, что
версия сервера и детали метаданных каталога неизменны. Следовательно, можно ожидать, что два
сервера, участвующие в репликации на основе воспроизведения физического WAL, будут иметь
одинаковые queryid для одного запроса. Однако схемы с логической репликацией не гарантируют
сохранения идентичности реплик во всех имеющих значение деталях, так что queryid не будет по-
лезным идентификатором для накопления показателей стоимости по набору логических реплик.
В случае сомнений в том или ином подходе, рекомендуется непосредственно протестировать его.
Обозначения параметров, применяемые для замены констант в представляющем запросы тексте,
нумеруются, начиная со следующего за последним параметром $n в исходном тексте запроса, или
с $1 в отсутствие параметров в нём. Стоит отметить, что в некоторых случаях на эту нумерацию
могут влиять скрытые символы параметров. Например, PL/pgSQL применяет такие символы для
добавления в запросы значений локальных переменных функций, так что оператор PL/pgSQL вида
SELECT i + 1 INTO j будет представлен в тексте как SELECT i + $2.
Текст, представляющий запрос, сохраняется во внешнем файле не диске и не занимает разделя-
емую память. Поэтому даже очень объёмный текст запроса может быть сохранён успешно. Одна-
ко, если в файле накапливается много длинных текстов запросов, он может вырасти до неудобова-
римого размера. В качестве решения этой проблемы, pg_stat_statements может решить стереть
текст запросов, и в результате во всех существующих записях в представлении pg_stat_statements
в поле query окажутся значения NULL, хотя статистика, связанная с каждым queryid будет сохра-
нена. Если это происходит и мешает анализу, возможно, стоит уменьшить pg_stat_statements.max
для предотвращения таких ситуаций.
F.29.2. Функции
pg_stat_statements_reset() returns void
Функция pg_stat_statements_reset очищает всю статистику, собранную к этому времени мо-
дулем pg_stat_statements. По умолчанию эту функцию могут выполнять только суперпользо-
ватели.
pg_stat_statements(showtext boolean) returns setof record
Представление pg_stat_statements реализовано на базе функции, которая тоже называется
pg_stat_statements. Клиенты могут вызывать функцию pg_stat_statements непосредственно,
и могут указать showtext := false и получить результат без текста запроса (то есть, выход-
ной аргумент (OUT), соответствующий столбцу представления query, будет содержать NULL).
Эта возможность предназначена для поддержки внешних инструментов, для которых жела-
тельно избежать издержек, связанных с получением текстов запросов неопределённой дли-
2574Дополнительно по-
ставляемые модули
ны. Такие инструменты могут кешировать текст первого запроса, который они получат само-
стоятельно, как это и делает pg_stat_statements, а затем запрашивать тексты запросов толь-
ко при необходимости. Так как сервер сохраняет тексты запросов в файле, этот подход сокра-
щает объём физического ввода/вывода, порождаемого при постоянном обращении к данным
pg_stat_statements.
F.29.3. Параметры конфигурации
pg_stat_statements.max (integer)
Параметр pg_stat_statements.max задаёт максимальное число операторов, отслеживаемых
модулем (то есть, максимальное число строк в представлении pg_stat_statements). Когда на
обработку поступает больше, чем заданное число различных операторов, информация о редко
выполняемых операторах отбрасывается. Значение по умолчанию — 5000. Этот параметр мож-
но задать только при запуске сервера.
pg_stat_statements.track (enum)
Параметр pg_stat_statements.track определяет, какие операторы будут отслеживаться моду-
лем. Со значением top отслеживаются операторы верхнего уровня (те, что непосредственно
выполняются клиентами), со значением all также отслеживаются вложенные операторы (на-
пример, операторы, вызываемые внутри функций), а значение none полностью отключает сбор
статистики по операторам. Значение по умолчанию — top. Изменять этот параметр могут толь-
ко суперпользователи.
pg_stat_statements.track_utility (boolean)
Параметр pg_stat_statements.track_utility определяет, будет ли этот модуль отслеживать
служебные команды. Служебными командами считаются команды, отличные от SELECT, INSERT,
UPDATE и DELETE. Значение по умолчанию — on (вкл.). Изменить этот параметр могут только
суперпользователи.
pg_stat_statements.save (boolean)
Параметр pg_stat_statements.save определяет, должна ли статистика операторов сохранять-
ся после перезагрузки сервера. Если он отключён (имеет значение off), статистика не сохра-
няется при остановке сервера и не перезагружается при запуске. Значение по умолчанию — on
(вкл.). Этот параметр можно задать только в postgresql.conf или в командной строке сервера.
Этому модулю требуется дополнительная разделяемая память в объёме, пропорциональном
pg_stat_statements.max. Заметьте, что эта память будет занята при загрузке модуля, даже если
pg_stat_statements.track имеет значение none.
Эти параметры должны задаваться в postgresql.conf. Обычное использование выглядит так:
        <h1 id="postgresqlconf-2">postgresql.conf</h1>
        <p>shared_preload_libraries = ‘pg_stat_statements’
pg_stat_statements.max = 10000
pg_stat_statements.track = all
F.29.4. Пример вывода
bench=# SELECT pg_stat_statements_reset();
$ pgbench -i bench
$ pgbench -c10 -t300 bench
bench=# \x
bench=# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5;
-[ RECORD 1 ]———————————————————————
2575Дополнительно по-
ставляемые модули
query
calls
total_time
rows
hit_percent
-[ RECORD 2
query
calls
total_time
rows
hit_percent
-[ RECORD 3
query
calls
total_time
rows
hit_percent
-[ RECORD 4
query
calls
total_time
rows
hit_percent
-[ RECORD 5
query
calls
total_time
rows
hit_percent
| UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2;
| 3000
| 9609.00100000002
| 2836
| 99.9778970000200936
]———————————————————————
| UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2;
| 3000
| 8015.156
| 2990
| 99.9731126579631345
]———————————————————————
| copy pgbench_accounts from stdin
| 1
| 310.624
| 100000
| 0.30395136778115501520
]———————————————————————
| UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2;
| 3000
| 271.741999999997
| 3000
| 93.7968855088209426
]———————————————————————
| alter table pgbench_accounts add primary key (aid)
| 1
| 81.42
| 0
| 34.4947735191637631
F.29.5. Авторы
Такахиро Итагаки <a href="mailto:itagaki.takahiro@oss.ntt.co.jp">itagaki.takahiro@oss.ntt.co.jp</a>. Нормализацию запросов добавил Питер
Геохеган <a href="mailto:peter@2ndquadrant.com">peter@2ndquadrant.com</a>.
F.30. pgstattuple
Модуль pgstattuple предоставляет различные функции для получения статистики на уровне кор-
тежей.
Так как эти функции возвращают подробную информацию, относящуюся к уровню страни-
цы, доступ к ним по умолчанию ограничен. Право EXECUTE для них имеет только роль
pg_stat_scan_tables. Разумеется, суперпользователи могут обойти это ограничение. После того
как это расширение установлено, можно поменять права доступа к этим функциям командами
GRANT и разрешить их выполнение другим пользователям. Однако предпочтительнее будет доба-
вить этих пользователей в роль pg_stat_scan_tables.
F.30.1. Функции
pgstattuple(regclass) returns record
Функция pgstattuple возвращает физическую длину отношения, процент «мёртвых» кортежей
и другую информацию. Она может быть полезна для принятия решения о необходимости очист-
ки. В аргументе передаётся имя (возможно, дополненное схемой) или OID целевого отношения.
Например:
test=&gt; SELECT * FROM pgstattuple(‘pg_catalog.pg_proc’);
-[ RECORD 1 ]——+——-
table_len
| 458752
tuple_count
| 1470
2576Дополнительно по-
ставляемые модули
tuple_len
tuple_percent
dead_tuple_count
dead_tuple_len
dead_tuple_percent
free_space
free_percent
|
|
|
|
|
|
|
438896
95.67
11
3157
0.69
8932
1.95
Столбцы результата описаны в Таблице F.22.
Таблица F.22. Столбцы результата pgstattuple
Столбец Тип Описание
table_len bigint Физическая длина отношения
в байтах
tuple_count bigint Количество
жей
tuple_len bigint Общая длина «живых» корте-
жей в байтах
tuple_percent float8 Процент «живых» кортежей
dead_tuple_count bigint Количество «мёртвых» корте-
жей
dead_tuple_len bigint Общая длина «мёртвых» кор-
тежей в байтах
dead_tuple_percent float8 Процент «мёртвых» кортежей
free_space bigint Общий объём свободного про-
странства в байтах
free_percent float8 Процент свободного простран-
ства
«живых»
корте-
Примечание
Значение table_len всегда будет больше суммы tuple_len, dead_tuple_len и
free_space. Разница объясняется фиксированными издержками, внутристранич-
ной таблицей указателей на кортежи и пропусками, добавляемыми для выравнива-
ния кортежей.
Функция pgstattuple получает блокировку отношения только для чтения. Таким образом, её
результаты отражают не мгновенный снимок; на них будут влиять параллельные изменения.
pgstattuple считает кортеж «мёртвым», если HeapTupleSatisfiesDirty возвращает false.
pgstattuple(text) returns record
Эта функция равнозначна функции pgstattuple(regclass) за исключением того, что для неё
целевое отношение задаётся в текстовом виде. Данная функция оставлена для обратной сов-
местимости, в будущем она может перейти в разряд устаревших.
pgstatindex(regclass) returns record
Функция pgstatindex возвращает запись с информацией об индексе типа B-дерево. Например:
test=&gt; SELECT * FROM pgstatindex(‘pg_cast_oid_index’);
-[ RECORD 1 ]——+——
version
| 2
tree_level
| 0
index_size
| 16384
root_block_no
| 1
2577Дополнительно по-
ставляемые модули
internal_pages
leaf_pages
empty_pages
deleted_pages
avg_leaf_density
leaf_fragmentation
|
|
|
|
|
|
0
1
0
0
54.27
0
Столбцы результата:
Столбец Тип Описание
version integer Номер версии B-дерева
tree_level integer Уровень корневой страницы в
дереве
index_size bigint Общий объём индекса в байтах
root_block_no bigint Расположение страницы кор-
ня (0, если её нет)
internal_pages bigint Количество
«внутренних»
страниц (верхнего уровня)
leaf_pages bigint Количество страниц на уровне
листьев
empty_pages bigint Количество пустых страниц
deleted_pages bigint Количество удалённых стра-
ниц
avg_leaf_density float8 Средняя плотность страниц на
уровне листьев
leaf_fragmentation float8 Фрагментация на уровне ли-
стьев
Выдаваемый размер индекса (index_size) обычно вычисляется по формуле internal_pages +
leaf_pages + empty_pages + deleted_pages плюс одна страница, так как в нём учитывается
и метастраница индекса.
Как и pgstattuple, эта функция собирает данные страница за страницей и не следует ожидать,
что её результат представляет мгновенный снимок всего индекса.
pgstatindex(text) returns record
Эта функция равнозначна функции pgstatindex(regclass) за исключением того, что для неё
целевое отношение задаётся в текстовом виде. Данная функция оставлена для обратной сов-
местимости, в будущем она может перейти в разряд устаревших.
pgstatginindex(regclass) returns record
Функция pgstatginindex возвращает запись с информацией об индексе типа GIN. Например:
test=&gt; SELECT * FROM pgstatginindex(‘test_gin_index’);
-[ RECORD 1 ]–+–
version
| 1
pending_pages | 0
pending_tuples | 0
Столбцы результата:
Столбец Тип Описание
version integer Номер версии GIN
pending_pages integer Количество страниц в списке
ожидающих обработки
2578Дополнительно по-
ставляемые модули
Столбец Тип Описание
pending_tuples bigint Количество кортежей в списке
ожидающих обработки
pgstathashindex(regclass) returns record
Функция pgstathashindex возвращает запись с информацией о хеш-индексе. Например:
test=&gt; select * from pgstathashindex(‘con_hash_index’);
-[ RECORD 1 ]–+—————–
version
| 4
bucket_pages
| 33081
overflow_pages | 0
bitmap_pages
| 1
unused_pages
| 32455
live_items
| 10204006
dead_items
| 0
free_percent
| 61.8005949100872
Столбцы результата:
Столбец Тип Описание
version integer Номер версии HASH
bucket_pages bigint Количество страниц групп
overflow_pages bigint Количество страниц перепол-
нения
bitmap_pages bigint Количество страниц битовой
карты
unused_pages bigint Количество неиспользованных
страниц
live_items bigint Количество
жей
dead_tuples bigint Количество «мёртвых» корте-
жей
free_percent float Процент свободного простран-
ства
«живых»
корте-
pg_relpages(regclass) returns bigint
Функция pg_relpages возвращает число страниц в отношении.
pg_relpages(text) returns bigint
Эта функция равнозначна функции pg_relpages(regclass) за исключением того, что для неё
целевое отношение задаётся в текстовом виде. Данная функция оставлена для обратной сов-
местимости, в будущем она может перейти в разряд устаревших.
pgstattuple_approx(regclass) returns record
Функция pgstattuple_approx является более быстрой альтернативой pgstattuple, возвращаю-
щей приблизительные результаты. В качестве аргумента ей передаётся имя или OID целевого
отношения. Например:
test=&gt; SELECT * FROM pgstattuple_approx(‘pg_catalog.pg_proc’::regclass);
-[ RECORD 1 ]——–+——-
table_len
| 573440
scanned_percent
| 2
approx_tuple_count
| 2740
approx_tuple_len
| 561210
2579Дополнительно по-
ставляемые модули
approx_tuple_percent
dead_tuple_count
dead_tuple_len
dead_tuple_percent
approx_free_space
approx_free_percent
|
|
|
|
|
|
97.87
0
0
0
11996
2.09
Выходные столбцы описаны в Таблице F.23.
Тогда как pgstattuple всегда производит полное сканирование таблицы и возвращает точное
число живых и мёртвых кортежей (и их размер), а также точный объём свободного простран-
ства, функция pgstattuple_approx пытается избежать полного сканирования и возвращает
точную статистику только по мёртвым кортежам, а количество и объём живых кортежей, как
и объём свободного пространства определяет приблизительно.
Она делает это, пропуская страницы, в которых, согласно карте видимости, есть только види-
мые кортежи (если для страницы установлен соответствующий бит, предполагается, что она
не содержит мёртвых кортежей). Для таких страниц эта функция узнаёт объём свободного про-
странства из карты свободного пространства и предполагает, что остальное пространство на
странице занято живыми кортежами.
На страницах, которые нельзя пропустить, она сканирует каждый кортеж, отражает его нали-
чие и размер в соответствующих счётчиках и суммирует свободное пространство на странице. В
конце она оценивает приблизительно общее число живых кортежей, исходя из числа проскани-
рованных страниц и кортежей (так же, как VACUUM рассчитывает значение pg_class.reltuples).
Таблица F.23. Столбцы результата pgstattuple_approx
Столбец Тип Описание
table_len bigint Физическая длина отношения
в байтах (точная)
scanned_percent float8 Просканированный
таблицы
approx_tuple_count bigint Количество «живых» корте-
жей (приблизительное)
approx_tuple_len bigint Общая длина «живых» корте-
жей в байтах (приблизитель-
ная)
approx_tuple_percent float8 Процент «живых» кортежей
dead_tuple_count bigint Количество «мёртвых» корте-
жей (точное)
dead_tuple_len bigint Общая длина «мёртвых» кор-
тежей в байтах (точная)
dead_tuple_percent float8 Процент «мёртвых» кортежей
approx_free_space bigint Общий объём свободного про-
странства в байтах (приблизи-
тельный)
approx_free_percent float8 Процент свободного простран-
ства
процент
В показанном выше выводе показатели свободного пространства могут не соответствовать вы-
воду pgstattuple в точности, потому что карта свободного пространства показывает верное
значение, но не гарантируется, что оно будет точным до байта.
F.30.2. Авторы
Тацуо Исии, Сатоши Нагаясу и Абхиджит Менон-Сен
2580Дополнительно по-
ставляемые модули
F.31. pg_trgm
Модуль pg_trgm предоставляет функции и операторы для определения схожести алфавитно-циф-
ровых строк на основе триграмм, а также классы операторов индексов, поддерживающие быстрый
поиск схожих строк.
F.31.1. Понятия, связанные с триграммами (или триграфами)
Триграмма — это группа трёх последовательных символов, взятых из строки. Мы можем измерить
схожесть двух строк, подсчитав число триграмм, которые есть в обеих. Эта простая идея оказыва-
ется очень эффективной для измерения схожести слов на многих естественных языках.
Примечание
pg_trgm, извлекая триграммы из строк, игнорирует символы, не относящиеся к словам
(не алфавитно-цифровые). При выделении триграмм, содержащихся в строке, считает-
ся, что перед каждым словом находятся два пробела, а после — один пробел. Напри-
мер, из строки «cat» выделяется набор триграмм: « c», « ca», «cat» и «at ». Из строки
«foo|bar» выделяются триграммы: « f», « fo», «foo», «oo », « b», « ba», «bar» и «ar ».
F.31.2. Функции и операторы
Реализованные в модуле pg_trgm функции перечислены в Таблице F.24, а операторы — в Табли-
це F.25.
Таблица F.24. Функции pg_trgm
Функция Возвращает Описание
similarity(text, text) real Возвращает число, показываю-
щее, насколько близки два ар-
гумента. Диапазон результатов
— от нуля (это значение указы-
вает, что две строки полностью
различны) до одного (это значе-
ние указывает, что две строки
идентичны).
show_trgm(text) text[] Возвращает массив всех три-
грамм в заданной строке. (На
практике это редко бывает по-
лезно, кроме как для отладки.)
word_similarity(text,
text) real Возвращает число, представ-
ляющее наибольшую степень
схожести между набором три-
грамм в первой строке и любым
непрерывным фрагментом упо-
рядоченного набора триграмм
во второй строке. Подробнее об
этом рассказывается ниже.
strict_word_similarity(
text, text) real Подобна
word_similarity(
text,
text) , но подгоня-
ет границы фрагментов к гра-
ницам слов. Так как триграм-
мы не пересекают слова, эта
функция фактически выдаёт
наибольшую степень схожести
между первой строкой и любой
2581Дополнительно по-
ставляемые модули
Функция Возвращает Описание
непрерывной последовательно-
стью слов во второй строке.
show_limit() real Возвращает текущий порог схо-
жести, который использует опе-
ратор %. Это значение задаёт
минимальную схожесть между
двумя словами, при которой они
считаются настолько близкими,
что одно может быть, например,
ошибочным написанием друго-
го (устаревшая).
set_limit(real) real Задаёт текущий порог схоже-
сти, который использует опе-
ратор %. Это значение должно
быть в диапазоне от 0 до 1 (по
умолчанию 0.3). Возвращает то
же значение, что было переда-
но на вход (устаревшая).
Рассмотрим следующий пример:</p>
        <h1 id="select-word_similarityword-two-words">SELECT word_similarity(‘word’, ‘two words’);</h1>
        <p>word_similarity
—————–
0.8
(1 row)
Набор триграмм для первой строки: (“ w”,” wo”,”wor”,”ord”,”rd “). Во второй строке упоря-
доченный набор триграмм: (“ t”,” tw”,”two”,”wo “,” w”,” wo”,”wor”,”ord”,”rds”,”ds “).
Наиболее близкий фрагмент упорядоченного множества триграмм во второй строке: (“ w”,”
wo”,”wor”,”ord”), а коэффициент схожести равен 0.8.
Эта функция возвращает значение, которое можно примерно воспринимать как максимальную
оценку схожести первой строки с любой подстрокой второй строки. Данная функция не добавляет
пробелы к границам фрагмента, поэтому совпадение с отдельным словом оценивается выше, чем
совпадение с частью слова.
При этом strict_word_similarity(text, text) выбирает последовательность слов во вто-
рой строке. В показанном выше примере strict_word_similarity(text,
text) выберет
последовательность из одного слова ‘words’, которой соответствуют триграммы (“
w”,”
wo”,”wor”,”ord”,”rds”,”ds “).</p>
        <h1 id="select-strict_word_similarityword-two-words-similarityword-words">SELECT strict_word_similarity(‘word’, ‘two words’), similarity(‘word’, ‘words’);</h1>
        <p>strict_word_similarity | similarity
————————+————
0.571429 |
0.571429
(1 row)
Таким образом, функция strict_word_similarity(text, text) полезна для определения схожести
целых слов, а word_similarity(text, text) больше подходит для определения схожести частей
слов.
Таблица F.25. Операторы pg_trgm
Оператор Возвращает Описание
text % text boolean Возвращает true, если схо-
жесть аргументов выше теку-
2582Дополнительно по-
ставляемые модули
Оператор Возвращает Описание
щего порога, заданного пара-
метром pg_trgm.similarity_
threshold .
text &lt;% text boolean Возвращает true, если схо-
жесть между набором три-
грамм в первом аргументе и
непрерывным фрагментом упо-
рядоченного набора триграмм
во втором превышает уровень
схожести,
устанавливаемый
параметром
pg_trgm.word_
similarity_threshold .
text %&gt; text boolean Коммутирующий оператор для
&lt;%.
text «% text boolean Возвращает true, если во вто-
ром аргументе имеется непре-
рывный фрагмент упорядочен-
ного набора триграмм, соот-
ветствующего границам слов,
и его схожесть с набором
триграмм первого аргумен-
та превышает уровень схоже-
сти, устанавливаемый парамет-
ром
pg_trgm.strict_word_
similarity_threshold .
text %» text boolean Коммутирующий оператор для
«%.
text &lt;-&gt; text real Возвращает «расстояние» меж-
ду аргументами, то есть один
минус значение similarity() .
text «-&gt; text real Возвращает «расстояние» меж-
ду
аргументами,
то
есть
один минус значение word_
similarity() .
text &lt;-» text real Коммутирующий оператор для
«-&gt;.
text «&lt;-&gt; text real Возвращает «расстояние» меж-
ду аргументами, то есть один
минус значение strict_word_
similarity() .
text &lt;-»&gt; text real Коммутирующий оператор для
«&lt;-&gt;.
F.31.3. Параметры GUC
pg_trgm.similarity_threshold (real)
Задаёт текущий порог схожести, который использует оператор %. Это значение должно быть в
диапазоне от 0 до 1 (по умолчанию 0.3).
pg_trgm.word_similarity_threshold (real)
Задаёт текущий порог схожести, который используют операторы &lt;% и %&gt;. Это значение должно
быть в диапазоне от 0 до 1 (по умолчанию 0.6).
2583Дополнительно по-
ставляемые модули
F.31.4. Поддержка индексов
Модуль pg_trgm предоставляет классы операторов индексов GiST и GIN, позволяющие создавать
индекс по текстовым столбцам для очень быстрого поиска по критерию схожести. Эти типы ин-
дексов поддерживают вышеописанные операторы схожести и дополнительно поддерживают поиск
на основе триграмм для запросов с LIKE, ILIKE, ~ и ~<em>. (Эти индексы не поддерживают простые
операторы сравнения и равенства, так что вам может понадобиться и обычный индекс-B-дерево.)
Пример:
CREATE TABLE test_trgm (t text);
CREATE INDEX trgm_idx ON test_trgm USING GIST (t gist_trgm_ops);
или
CREATE INDEX trgm_idx ON test_trgm USING GIN (t gin_trgm_ops);
На этот момент у вас будет индекс по столбцу t, используя который можно осуществлять поиск
по схожести. Пример типичного запроса:
SELECT t, similarity(t, ‘слово’) AS sml
FROM test_trgm
WHERE t % ‘слово’
ORDER BY sml DESC, t;
Он выдаст все значения в текстовом столбце, которые достаточно схожи со словом word, в поряд-
ке сортировки от наиболее к наименее схожим. Благодаря использованию индекса, эта операция
будет быстрой даже с очень большими наборами данных.
Другой вариант предыдущего запроса:
SELECT t, t &lt;-&gt; ‘слово’ AS dist
FROM test_trgm
ORDER BY dist LIMIT 10;
Он может быть довольно эффективно выполнен с применением индексов GiST, а не GIN. Обычно он
выигрышнее первого варианта только когда требуется получить небольшое количество близких
совпадений.
Также вы можете использовать индекс по столбцу t для оценки схожести слов условных и оценки
схожести слов в строгом смысле. Примеры типичных запросов:
SELECT t, word_similarity(‘слово’, t) AS sml
FROM test_trgm
WHERE ‘слово’ &lt;% t
ORDER BY sml DESC, t;
и
SELECT t, strict_word_similarity(‘слово’, t) AS sml
FROM test_trgm
WHERE ‘слово’ «% t
ORDER BY sml DESC, t;
В результате будут возвращены все значения в текстовом столбце, для которых найдется непре-
рывный фрагмент в упорядоченном наборе триграмм, достаточно схожий с набором триграмм
строки слово. Данные значения будут отсортированы по порядку от наиболее к наименее схожим.
Этот индекс позволит ускорить поиск даже с очень большим объёмом данных.
Другие возможные варианты предыдущих запросов:
SELECT t, ‘слово’ «-&gt; t AS dist
FROM test_trgm
ORDER BY dist LIMIT 10;
и
2584Дополнительно по-
ставляемые модули
SELECT t, ‘слово’ «&lt;-&gt; t AS dist
FROM test_trgm
ORDER BY dist LIMIT 10;
Они могут быть довольно эффективно выполнены с применением индексов GiST, а не GIN.
Начиная с PostgreSQL 9.1, эти типы индексов также поддерживают поиск с операторами LIKE и
ILIKE, например:
SELECT * FROM test_trgm WHERE t LIKE ‘%foo%bar’;
При таком поиске по индексу сначала из искомой строки извлекаются триграммы, а затем они
ищутся в индексе. Чем больше триграмм оказывается в искомой строке, тем более эффективным
будет поиск по индексу. В отличие от поиска по B-дереву, искомая строка не должна привязывать-
ся к левому краю.
Начиная с PostgreSQL 9.3, индексы этих типов также поддерживают поиск по регулярным выра-
жениям (операторы ~ и ~</em>), например:
SELECT * FROM test_trgm WHERE t ~ ‘(foo|bar)’;
При таком поиске из регулярного выражения извлекаются триграммы, а затем они ищутся в ин-
дексе. Чем больше триграмм удаётся извлечь из регулярного выражения, тем более эффективным
будет поиск по индексу. В отличие от поиска по B-дереву, искомая строка не должна привязывать-
ся к левому краю.
Относительно поиска по регулярному выражению или с LIKE, имейте в виду, что при отсутствии
триграмм в искомом шаблоне поиск сводится к полному сканирования индекса.
Выбор между индексами GiST и GIN зависит от относительных характеристик производительности
GiST и GIN, которые здесь не рассматриваются.
F.31.5. Интеграция с текстовым поиском
Сопоставление триграмм — очень полезный приём в сочетании с применением полнотекстового
индекса. В частности это может помочь найти слова, написанные неправильно, которые не будут
находиться непосредственно механизмом полнотекстового поиска.
В первую очередь нужно построить дополнительную таблицу, содержащую все уникальные слова
в документе:
CREATE TABLE words AS SELECT word FROM
ts_stat(‘SELECT to_tsvector(‘‘simple’’, bodytext) FROM documents’);
Здесь documents — это таблица с текстовым полем bodytext, по которому мы будем выполнять по-
иск. Конфигурация simple используется с функцией to_tsvector вместо конфигурации для опре-
делённого языка по той причине, что нам нужен список исходных (необработанных стеммером)
слов.
Затем нужно создать индекс триграмм по столбцу со словами:
CREATE INDEX words_idx ON words USING GIN (word gin_trgm_ops);
Теперь мы можем использовать запрос SELECT, подобный показанному в предыдущем примере, и
предлагать варианты исправлений слов, введённых пользователем с ошибками. Кроме того, может
быть полезно дополнительно проверить, что выбранные слова также имеют длину, примерно рав-
ную длине ошибочных слов.
Примечание
Так как таблица words была сформирована как отдельная статическая таблица, её нуж-
но периодически обновлять, чтобы она достаточно хорошо соответствовала набору до-
кументов. Постоянно поддерживать её в полностью актуальном состоянии обычно не
требуется.
2585Дополнительно по-
ставляемые модули
F.31.6. Ссылки
Сайт разработки GiST http://www.sai.msu.su/~megera/postgres/gist/
Сайт разработки Tsearch2 http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/
F.31.7. Авторы
Олег Бартунов <a href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>, Москва, Московский Государственный Университет, Россия
Фёдор Сигаев <a href="mailto:teodor@sigaev.ru">teodor@sigaev.ru</a>, Москва, ООО «Дельта-Софт», Россия
Александр Коротков <a href="mailto:a.korotkov@postgrespro.ru">a.korotkov@postgrespro.ru</a>, Москва, Postgres Professional, Россия
Документация: Кристофер Кингс-Линн
Разработку этого модуля спонсировало ООО «Дельта-Софт», г. Москва, Россия.
F.32. pg_visibility
Модуль pg_visibility даёт возможность исследовать для определённой таблицы карту видимости
(Visibility Map, VM) и информацию о видимости на уровне страниц. Он также предоставляет функ-
ции для проверки целостности карты видимости и принудительного её пересоздания.
Для хранения информации о видимости на уровне страниц применяются по три различных бита.
Бит полной видимости в карте показывает, что каждый кортеж в соответствующей странице отно-
шения является видимым для всех текущих и будущих транзакций. Бит полной заморозки в карте
видимости показывает, что все кортежи в данной странице являются замороженными; то есть ни-
какой операции очистки в будущем не придётся обрабатывать эту страницу, пока в ней не будет
добавлен, изменён, удалён или заблокирован кортеж. Бит PD_ALL_VISIBLE в заголовке страницы
имеет то же значение, что и бит полной видимости в карте видимости, но он хранится в самой
странице данных, а не в отдельной структуре данных. В обычной ситуации эти два бита будут со-
гласованы, но бит полной видимости в странице иногда может быть установлен, тогда как в карте
видимости он оказывается сброшенным при восстановлении после сбоя. Считываемые значения
могут также различаться, если они подвергаются изменению в промежутке между обращениями
pg_visibility к карте видимости и к странице данных. Разумеется, эти биты также могут разли-
чаться при событиях, приводящих к разрушению данных.
Функции, выдающие информацию о битах PD_ALL_VISIBLE, более дорогостоящие, чем те, что обра-
щаются только к карте видимости, так как они должны читать блоки отношения, а не только карту
видимости (которая намного меньше). Дорогостоящими являются также и функции, проверяющие
блоки данных отношения.
F.32.1. Функции
pg_visibility_map(relation regclass, blkno bigint, all_visible OUT boolean, all_frozen
OUT boolean) returns record
Возвращает биты полной видимости и полной заморозки в карте видимости для указанного
блока заданного отношения.
pg_visibility(relation regclass, blkno bigint, all_visible OUT boolean, all_frozen OUT
boolean, pd_all_visible OUT boolean) returns record
Возвращает биты полной видимости и полной заморозки в карте видимости для указанного
блока заданного отношения, а также бит PD_ALL_VISIBLE этого блока.
pg_visibility_map(relation regclass, blkno
all_frozen OUT boolean) returns setof record
OUT
bigint,
all_visible
OUT
boolean,
Возвращает биты полной видимости и полной заморозки в карте видимости для каждого блока
заданного отношения.
2586Дополнительно по-
ставляемые модули
pg_visibility(relation regclass, blkno OUT bigint, all_visible OUT boolean, all_frozen
OUT boolean, pd_all_visible OUT boolean) returns setof record
Возвращает биты полной видимости и полной заморозки в карте видимости для каждого блока
заданного отношения, а также бит PD_ALL_VISIBLE каждого блока.
pg_visibility_map_summary(relation
bigint) returns record
regclass,
all_visible
OUT
bigint,
all_frozen
OUT
Возвращает число полностью видимых страниц и полностью замороженных страниц в отноше-
нии, согласно карте видимости.
pg_check_frozen(relation regclass, t_ctid OUT tid) returns setof tid
Возвращает идентификаторы TID незамороженных кортежей в страницах, помеченных как пол-
ностью замороженные в карте видимости. Если эта функция возвращает непустой набор TID,
карта видимости испорчена.
pg_check_visible(relation regclass, t_ctid OUT tid) returns setof tid
Возвращает идентификаторы TID не полностью видимых кортежей в страницах, помеченных
как полностью видимые в карте видимости. Если эта функция возвращает непустой набор TID,
карта видимости испорчена.
pg_truncate_visibility_map(relation regclass) returns void
Аннулирует карту видимости для заданного отношения. Эта функция полезна, если вы счита-
ете, что карта видимости для указанного отношения испорчена, и хотите принудительно пере-
создать её. Первая же команда VACUUM, выполняемая с данным отношением после этой функ-
ции, просканирует все страницы в отношении и пересоздаст карту видимости. (Пока это не
произойдёт, для запросов карта видимости будет выглядеть как полностью нулевая.)
По умолчанию эти функции разрешено выполнять только суперпользователям и членам роли
pg_stat_scan_tables, за исключением pg_truncate_visibility_map(relation regclass), кото-
рую могут выполнять только суперпользователи.
F.32.2. Автор
Роберт Хаас <a href="mailto:rhaas@postgresql.org">rhaas@postgresql.org</a>
F.33. postgres_fdw
Модуль postgres_fdw предоставляет обёртку сторонних данных postgres_fdw, используя которую
можно обращаться к данным, находящимся на внешних серверах PostgreSQL.
Функциональность этого модуля во многом пересекается с функциональностью старого модуля
dblink. Однако postgres_fdw предоставляет более прозрачный и стандартизированный синтаксис
для обращения к удалённым таблицам и во многих случаях даёт лучшую производительность.
Чтобы подготовиться к обращению к удалённым данным через postgres_fdw:</p>
      </li>
      <li>Установите расширение postgres_fdw с помощью команды CREATE EXTENSION.</li>
      <li>Создайте объект стороннего сервера, используя CREATE SERVER, который будет представлять
удалённую базу данных, к которой вы хотите подключаться. Укажите свойства подключения,
кроме user и password, в параметрах объекта сервера.</li>
      <li>Создайте сопоставление пользователей, используя CREATE USER MAPPING, для каждого поль-
зователя базы, которому нужен доступ к удалённому серверу. Укажите имя и пароль удалённого
пользователя в параметрах user и password сопоставления.</li>
      <li>Создайте стороннюю таблицу, используя CREATE FOREIGN TABLE или IMPORT FOREIGN
SCHEMA, для каждой удалённой таблицы, к которой вы хотите обращаться. Столбцы сторонней
таблицы должны соответствовать столбцам целевой удалённой таблицы. Однако вы можете ис-
пользовать локально имена таблиц и/или столбцов, отличные от удалённых, если укажете кор-
ректные удалённые имена в параметрах объекта сторонней таблицы.
2587Дополнительно по-
ставляемые модули
После этого для обращения к данным, хранящимся в нижележащей удалённой таблице, вам нуж-
но только выполнять SELECT. Вы также можете изменять данные в удалённой таблице, выполняя
INSERT, UPDATE или DELETE. (Разумеется, удалённый пользователь, указанный в сопоставлении, дол-
жен иметь необходимые права для этого.)
Заметьте, что в настоящее время в postgres_fdw не поддерживаются операторы INSERT с предло-
жением ON CONFLICT DO UPDATE. Однако предложение ON CONFLICT DO NOTHING поддерживается,
при отсутствии указания для выбора уникального индекса.
Обычно рекомендуется объявлять столбцы сторонней таблицы точно с теми же типами данных и
правилами сортировки, если они применимы, как у целевых столбцов удалённой таблицы. Хотя
postgres_fdw в настоящее время довольно лоялен к преобразованиям типов данных при необхо-
димости, но когда типы или правила сортировки не совпадают, возможны неожиданные семанти-
ческие аномалии, вследствие того, что удалённый сервер будет обрабатывать предложения WHERE
не совсем так, как локальный сервер.
Заметьте, что сторонняя таблица может быть объявлена с меньшим количеством или с другим
порядком столбцов, чем в нижележащей удалённой таблице. Сопоставление столбцов удалённой
таблицы осуществляется по имени, а не по позиции.
F.33.1. Параметры обёртки для postgres_fdw
F.33.1.1. Параметры подключения
Для стороннего сервера, настраиваемого с использованием обёртки сторонних данных
postgres_fdw, можно задать те же параметры, что принимает libpq в строках подключения, как
описано в Подразделе 34.1.2, за исключением следующих недопустимых параметров:
• user и password (их следует задавать в сопоставлениях пользователей)
• client_encoding (автоматически принимается равной локальной кодировке сервера)
• fallback_application_name (всегда postgres_fdw)
Подключаться к сторонним серверам без аутентификации по паролю могут только суперполь-
зователи, поэтому в сопоставлениях для обычных пользователей всегда нужно задавать пароль
(password).
F.33.1.2. Параметры имени объекта
Эти параметры позволяют управлять тем, как на удалённый сервер PostgreSQL будут передавать-
ся имена, фигурирующие в операторах SQL. Данные параметры нужны, когда сторонняя таблица
создаётся с именами, отличными от имён удалённой таблицы.
schema_name
Этот параметр, который может задаваться для сторонней таблицы, указывает имя схемы для
обращения к этой таблице на удалённом сервере. Если данный параметр опускается, приме-
няется схема сторонней таблицы.
table_name
Этот параметр, который может задаваться для сторонней таблицы, указывает имя таблицы для
обращения к этой таблице на удалённом сервере. Если данный параметр опускается, приме-
няется имя сторонней таблицы.
column_name
Этот параметр, который может задаваться для столбца сторонней таблицы, указывает имя
столбца для обращения к этому столбцу на удалённом сервере. Если данный параметр опуска-
ется, применяется исходное имя столбца.
F.33.1.3. Параметры оценки стоимости
Модуль postgres_fdw получает удалённые данные, выполняя запросы на удалённых серверах, по-
этому в идеале ожидаемая стоимость сканирования сторонней таблицы должна равняться стоимо-
2588Дополнительно по-
ставляемые модули
сти выполнения на удалённом сервере плюс издержки сетевого взаимодействия. Самый надёжный
способ получить такие оценки — узнать стоимость у удалённого сервера и добавить некоторую
надбавку — но для простых запросов может быть невыгодно передавать дополнительный запрос,
только чтобы получить оценку стоимости. Поэтому postgres_fdw предоставляет следующие пара-
метры, позволяющие управлять вычислением оценки стоимости:
use_remote_estimate
Этот параметр, который может задаваться для сторонней таблицы или для стороннего сервера,
определяет, будет ли postgres_fdw выполнять удалённо команды EXPLAIN для получения оце-
нок стоимости. Параметр, заданный для сторонней таблицы, переопределяет параметр серве-
ра, но только для данной таблицы. Значение по умолчанию — false (выкл.).
fdw_startup_cost
Этот параметр, который может задаваться для стороннего сервера, устанавливает числовое
значение, добавляемое к оценке стоимости запуска для любого сканирования сторонней таб-
лицы на этом сервере. Он выражает дополнительные издержки на установление подключения,
разбор и планирование запроса на удалённой стороне и т. д. Значение по умолчанию — 100.
fdw_tuple_cost
Этот параметр, который может задаваться для стороннего сервера, устанавливает числовое
значение, выражающее дополнительную цену чтения одного кортежа из сторонней таблицы
на этом сервере. Это число можно увеличить или уменьшить, отражая меньшую или большую
фактическую скорость сетевого взаимодействия с удалённым сервером. Значение по умолча-
нию — 0.01.
Когда поведение use_remote_estimate включено, postgres_fdw получает количество строк и оцен-
ку стоимости с удалённого сервера, а затем добавляет к оценке стоимости fdw_startup_cost
и fdw_tuple_cost. Когда поведение use_remote_estimate отключено, postgres_fdw рассчиты-
вает число строк и оценку стоимости локально, а затем так же добавляет к этой оценке
fdw_startup_cost и fdw_tuple_cost. Локальная оценка может быть точной только при условии
наличия локальной копии статистики удалённых таблиц. Обновить эту статистику для сторонней
таблицы можно с помощью команды ANALYZE; при этом удалённая таблица будет просканирова-
на, и по её содержимому будут вычислена и сохранена статистика как для локальной таблицы.
Локальное хранение статистики может быть полезно для сокращения издержек планирования для
удалённой таблицы — но если удалённая таблица меняется часто, локальная статистика будет
быстро устаревать.
F.33.1.4. Параметры удалённого выполнения
По умолчанию ограничения WHERE, содержащие встроенные операторы и функции, обрабатывают-
ся на удалённом сервере, а ограничения, содержащие вызовы не встроенных функций, проверя-
ются локально после получения строк. Если же расширенные функции доступны на удалённом
сервере и можно рассчитывать, что они дадут те же результаты, что и локально, производитель-
ность можно увеличить, передавая и такие предложения WHERE для удалённого выполнения. Этим
поведением позволяет управлять следующий параметр:
extensions
В этом параметре задаётся список имён расширений PostgreSQL через запятую, которые уста-
новлены и имеют совместимые версии и на локальном, и на удалённом сервере. Относящиеся
к перечисленным расширениям и при этом постоянные (immutable) функции и операторы мо-
гут передаваться на выполнение удалённому серверу. Этот параметр можно задать только для
стороннего сервера, но не для таблицы.
При использовании параметра extensions пользователь сам отвечает за то, чтобы перечис-
ленные расширения существовали и их поведение было одинаковым на локальном и удалённом
сервере. В противном случае удалённые запросы могут выдавать ошибки или неожиданные ре-
зультаты.
2589Дополнительно по-
ставляемые модули
fetch_size
Этот параметр определяет, сколько строк должна получать postgres_fdw в одной операции вы-
борки. Его можно задать для сторонней таблицы или стороннего сервера. Значение по умол-
чанию — 100 строк.
F.33.1.5. Параметры изменения данных
По умолчанию все сторонние таблицы, доступные через postgres_fdw, считаются допускающими
изменения. Это можно переопределить с помощью следующего параметра:
updatable
Этот параметр определяет, будет ли postgres_fdw допускать изменения в сторонних таблицах
посредством команд INSERT, UPDATE и DELETE. Его можно задать для сторонней таблицы или для
стороннего сервера. Параметр, определённый на уровне таблицы, переопределяет параметр
уровня сервера. Значение по умолчанию — true (изменения разрешены).
Конечно, если удалённая таблица на самом деле не допускает изменения, всё равно произойдёт
ошибка. Использование этого параметра прежде всего позволяет выдать ошибку локально, не
обращаясь к удалённому серверу. Заметьте, однако, что представление information_schema
будет показывать, что определённая сторонняя таблица postgres_fdw является изменяемой
(или нет), согласно значению данного параметра, не проверяя это на удалённом сервере.
F.33.1.6. Параметры импорта
Обёртка postgres_fdw позволяет импортировать определения сторонних таблиц с применением
команды IMPORT FOREIGN SCHEMA. Эта команда создаёт на локальном сервере определения
сторонних таблиц, соответствующие таблицам или представлениям, существующим на удалённом
сервере. Если импортируемые удалённые таблицы содержат столбцы пользовательских типов дан-
ных, на локальном сервере должны быть совместимые типы с теми же именами.
Поведение процедуры импорта можно настроить следующими параметрами (задаваемыми в ко-
манде IMPORT FOREIGN SCHEMA):
import_collate
Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с
внешнего сервера, включаться характеристики столбцов COLLATE. По умолчанию они включа-
ются. Вам может потребоваться отключить его, если на удалённом сервере набор имён правил
сортировки отличается от локального, что скорее всего будет иметь место, если серверы рабо-
тают в разных операционных системах.
import_default
Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с
внешнего сервера, включаться заданные для столбцов выражения DEFAULT. По умолчанию они
не включаются. Если вы включите этот параметр, остерегайтесь выражений по умолчанию,
которые могут вычисляться на локальном сервере не так, как на удалённом; например, частый
источник проблем — nextval(). Если в импортируемом выражении используются функции или
операторы, несуществующие локально, команда IMPORT в целом выдаст сбой.
import_not_null
Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с
внешнего сервера, включаться ограничения столбцов NOT NULL. По умолчанию они включают-
ся.
Заметьте, что никакие другие ограничения, кроме NOT NULL, из удалённых таблиц импортировать-
ся не будут. Хотя PostgreSQL поддерживает ограничения CHECK для сторонних таблиц, никаких
средств для автоматического импорта их нет из-за риска различного вычисления выражения огра-
2590Дополнительно по-
ставляемые модули
ничения на локальном и удалённом серверах. Любая такая несогласованность в поведении огра-
ничений CHECK могла бы привести к сложно выявляемым ошибкам в оптимизации запросов. Поэто-
му, если вы хотите импортировать ограничения CHECK, вы должны сделать это вручную и должны
внимательно проверить семантику каждого. Более подробно интерпретация ограничений CHECK
для сторонних таблиц описана в CREATE FOREIGN TABLE.
Таблицы или сторонние таблицы, являющиеся секциями некоторой другой таблицы, исключаются
автоматически. Секционированные таблицы импортируются, только если они не являются секци-
ями каких-либо других таблиц. Так как все данные могут быть доступны через секционированную
таблицу, являющуюся вершиной в иерархии секционирования, при таком подходе должен быть
возможен доступ ко всем данным без создания дополнительных объектов.
F.33.2. Управление соединением
Модуль postgres_fdw устанавливает соединение со сторонним сервером при первом запросе, в ко-
тором участвует сторонняя таблица, связанная со сторонним сервером. Это соединение сохраня-
ется и повторно используется для последующих запросов в том же сеансе. Однако, если для обра-
щения к стороннему серверу задействуются разные пользователи (сопоставления пользователей),
отдельное соединение устанавливается для каждого сопоставления пользователей.
F.33.3. Управление транзакциями
В процессе выполнения запроса, в котором участвуют какие-либо удалённые таблицы на сторон-
нем сервере, postgres_fdw открывает транзакцию на удалённом сервере, если такая транзакция
ещё не была открыта для текущей локальной транзакции. Эта удалённая транзакция фиксируется
или прерывается, когда фиксируется или прерывается локальная транзакция. Подобным образом
реализуется и управление точками сохранения.
Для удалённой транзакции выбирается режим изоляции SERIALIZABLE, когда локальная транзак-
ция открыта в режиме SERIALIZABLE; в противном случае применяется режим REPEATABLE READ.
Этот выбор гарантирует, что если запрос сканирует несколько таблиц на удалённом сервере, он
будет получать согласованные данные одного снимка для всех сканирований. Как следствие, по-
следовательные запросы в одной транзакции будут видеть одни данные удалённого сервера, даже
если на нём параллельно происходят изменения, вызванные другими действиями. Это поведение
ожидаемо для локальной транзакции в режимах SERIALIZABLE и REPEATABLE READ, но для локаль-
ной транзакции в режиме READ COMMITTED оно может быть неожиданным. В будущих выпусках
PostgreSQL эти правила могут быть изменены.
F.33.4. Оптимизация удалённых запросов
Обёртка postgres_fdw пытается оптимизировать удалённые запросы, уменьшая объём обмена дан-
ными со сторонними серверами. Для этого она может передавать на выполнение удалённому сер-
веру предложения WHERE и не получать столбцы таблицы, не требующиеся для текущего запроса.
Чтобы уменьшить риск некорректного выполнения запросов, предложения WHERE передаются уда-
лённому серверу, только если в них используются типы данных, операторы и функции, встроен-
ные в ядро или относящиеся к расширениям, перечисленным в параметре extensions. Операто-
ры и функции в таких предложениях также должны быть постоянными (IMMUTABLE). Для запросов
UPDATE или DELETE обёртка postgres_fdw пытается оптимизировать выполнение, передавая весь
запрос на удалённый сервер, если в запросе нет предложения WHERE, которое нельзя было бы пере-
дать, не выполняется локальное соединение, в целевой таблице отсутствуют локальные триггеры
BEFORE/AFTER уровня строки и в родительских представлениях нет ограничения CHECK OPTION. Кро-
ме того, в запросах UPDATE выражения, присваиваемые целевым столбцам, должны задействовать
только встроенные типы данных и постоянные (IMMUTABLE) операторы и функции, чтобы уменьшить
риск неверного выполнения запроса.
Когда обёртка postgres_fdw обнаруживает соединение сторонних таблиц на одном стороннем сер-
вере, она передаёт всё соединение этому серверу, если только по какой-то причине не решит, что
будет эффективнее выбирать строки из каждой таблицы по отдельности, или сопоставляемые при
2591Дополнительно по-
ставляемые модули
обращении к таблицам пользователи оказываются разными. При передаче предложений JOIN при-
нимаются те же меры предосторожности, что были описаны выше для предложений WHERE.
Запрос, фактически отправляемый удалённому серверу для выполнения, можно изучить с помо-
щью команды EXPLAIN VERBOSE.
F.33.5. Окружение удалённого выполнения запросов
В удалённых сеансах, установленных обёрткой postgres_fdw, в параметре search_path задаётся
только pg_catalog, так что без указания схемы видны только встроенные объекты. Это не про-
блема для запросов, которые генерирует сама postgres_fdw, так как она всегда добавляет такие
указания. Однако это может быть опасно для функций, которые выполняются на удалённом сер-
вере при срабатывании триггеров или правил для удалённых таблиц. Например, если удалённая
таблица на самом деле представляет собой представление, любые функции, используемые в этом
представлении, будут выполняться с таким ограниченным путём поиска. Поэтому рекомендуется
в таких функциях дополнять схемой все имена либо добавлять параметры SET search_path (см.
CREATE FUNCTION) в определения таких функций, чтобы установить ожидаемый ими путь поиска
в окружении.
Обёртка postgres_fdw подобным образом устанавливает для удалённого сеанса различные пара-
метры:
•
•
•
•
TimeZone — UTC
DateStyle — ISO
IntervalStyle — postgres
extra_float_digits принимает значение 3 для удалённых серверов версии 9.0 и новее либо 2 для
более старых версий
С ними проблемы менее вероятны, чем с search_path, но если они возникнут, их можно урегули-
ровать, установив нужные значения с помощью SET.
Это поведение не рекомендуется переопределять, устанавливая значения этих параметров на
уровне сеанса; это скорее всего приведёт к поломке postgres_fdw.
F.33.6. Совместимость с разными версиями
Модуль postgres_fdw может применяться с удалёнными серверами версий, начиная с PostgreSQL
8.3. Способность только чтения данных доступна, начиная с 8.1. Однако, при этом есть ограниче-
ние, вызванное тем, что postgres_fdw полагает, что постоянные встроенные функции и операто-
ры могут безопасно передаваться на удалённый сервер для выполнения, если они фигурируют в
предложении WHERE для сторонней таблицы. Таким образом, встроенная функция, добавленная в
более новой версии, чем на удалённом сервере, может быть отправлена на выполнение, что в ре-
зультате приведёт к ошибке «функция не существует» или подобной. Отказы такого типа можно
предотвратить, переписав запрос, например, поместив ссылку на стороннюю таблицу во вложен-
ный SELECT с OFFSET 0 в качестве защиты от оптимизации, и применив проблематичную функцию
или оператор снаружи этого вложенного SELECT.
F.33.7. Примеры
Ниже приведёт пример создания сторонней таблицы с применением postgres_fdw. Сначала уста-
новите расширение:
CREATE EXTENSION postgres_fdw;
Затем создайте сторонний сервер с помощью команды CREATE SERVER. В данном примере мы
хотим подключиться к серверу PostgreSQL, работающему по адресу 192.83.123.89, порт 5432. База
данных, к которой устанавливается подключение, на удалённом сервере называется foreign_db:
CREATE SERVER foreign_server
FOREIGN DATA WRAPPER postgres_fdw
2592Дополнительно по-
ставляемые модули
OPTIONS (host ‘192.83.123.89’, port ‘5432’, dbname ‘foreign_db’);
Для определения роли, которая будет задействована на удалённом сервере, с помощью CREATE
USER MAPPING задаётся сопоставление пользователей:
CREATE USER MAPPING FOR local_user
SERVER foreign_server
OPTIONS (user ‘foreign_user’, password ‘password’);
Теперь можно создать стороннюю таблицу, применив команду CREATE FOREIGN TABLE. В этом
примере мы хотим обратиться к таблице some_schema.some_table на удалённом сервере. Локаль-
ным именем этой таблицы будет foreign_table:
CREATE FOREIGN TABLE foreign_table (
id integer NOT NULL,
data text
)
SERVER foreign_server
OPTIONS (schema_name ‘some_schema’, table_name ‘some_table’);
Важно, чтобы типы данных и другие свойства столбцов, объявленных в CREATE FOREIGN TABLE, соот-
ветствовали фактической удалённой таблице. Также должны соответствовать имена столбцов, ес-
ли только вы не добавите параметры column_name для отдельных столбцов, задающие их реальные
имена в удалённой таблице. Во многих случаях использовать IMPORT FOREIGN SCHEMA предпо-
чтительнее, чем конструировать определения сторонних таблиц вручную.
F.33.8. Автор
Шигеру Ханада <a href="mailto:shigeru.hanada@gmail.com">shigeru.hanada@gmail.com</a>
F.34. seg
Этот модуль реализует тип данных seg для представления отрезков или интервалов чисел с пла-
вающей точкой. Тип seg может выражать отсутствие уверенности в границах интервала, что поз-
воляет применять его для представления лабораторных измерений.
F.34.1. Обоснование
Геометрия измерений обычно более сложна, чем точка в числовом континууме. Измерение обыч-
но представляет собой отрезок этого континуума с нечёткими границами. Измеряемые показате-
ли выражаются интервалами вследствие неопределённости и случайности, а также того, что из-
меряемое значение может отражать некоторое условие, например, диапазон температур стабиль-
ности протеина.
Руководствуясь только здравым смыслом, кажется более удобным хранить такие данные в виде
интервалов, а не в виде двух отдельных чисел. На практике это оказывается даже эффективнее в
большинстве приложений.
Более того, вследствие нечёткости границ использование традиционных числовых типов данных
приводит к определённой потере информации. Рассмотрим такой пример: ваш инструмент выдаёт
6.50 и вы вводите это значение в базу данных. Что вы получите, прочитав это значение из базы?
Смотрите:
test=&gt; select 6.50 :: float8 as “pH”;
pH
—
6.5
(1 row)
В мире измерений, 6.50 — не то же самое, что 6.5. И разница между этими измерениями иногда
бывает критической. Экспериментаторы обычно записывают (и публикуют) цифры, которые за-
2593Дополнительно по-
ставляемые модули
служивают доверия. Запись 6.50 на самом деле представляет неточный интервал, содержащийся
внутри большего и ещё более неточного интервала, 6.5, и единственное, что у них может быть об-
щего, это их центральные точки. Поэтому мы определённо не хотим, чтобы такие разные элементы
данных выглядели одинаково.
Вывод? Удобно иметь специальный тип данных, в котором можно сохранить границы интервала
с произвольной переменной точностью. В данном случае точность переменная в том смысле, что
для каждого элемента данных она может записываться индивидуально.
Проверьте это:
test=&gt; select ‘6.25 .. 6.50’::seg as “pH”;
pH
————
6.25 .. 6.50
(1 row)
F.34.2. Синтаксис
Внешнее представление интервала образуется одним или двумя числами с плавающей точкой, со-
единёнными оператором диапазона (.. или …). Кроме того, интервал можно задать центральной
точкой плюс/минус отклонение. Также этот тип позволяет сохранить дополнительные индикаторы
достоверности (&lt;, &gt; или ~). (Однако индикаторы достоверности игнорируются всеми встроенными
операторами.) Допустимые представления показаны в Таблице F.26; некоторые примеры приведе-
ны в Таблице F.27.
В Таблице F.26 символы x, y и delta обозначают числа с плавающей точкой. Перед значениями x
и y, но не delta, может быть добавлен индикатор достоверности.
Таблица F.26. Внешнее представление seg
x Одно значение (интервал нулевой длины)
x .. y Интервал от x до y
x (+-)
Интервал от x - delta до x + delta
delta
x .. Открытый интервал с нижней границей x
.. x Открытый интервал с верхней границей x
Таблица F.27. Примеры допустимых вводимых значений seg
5.0 Создаёт сегмент нулевой длины (или точку, если
хотите)
~5.0 Создаёт сегмент нулевой длины и записывает ~
в данные. Знак ~ игнорируется при операциях с
seg, но сохраняется как комментарий.
&lt;5.0 Создаёт точку с координатой 5.0. Знак &lt; игнори-
руется, но сохраняется как комментарий.
        <blockquote>
          <p>5.0 Создаёт точку с координатой 5.0. Знак &gt; игнори-
руется, но сохраняется как комментарий.
5(+-)0.3 Создаёт интервал 4.7 .. 5.3. Заметьте, что за-
пись (+-) не сохраняется.
50 .. Всё, что больше или равно 50
.. 0 Всё, что меньше или равно 0
1.5e-2 .. 2E-2 Создаёт интервал 0.015 .. 0.02
1 … 2 То же, что и 1…2, либо 1 .. 2, либо 1..2 (пробе-
лы вокруг оператора диапазона игнорируются)
2594Дополнительно по-
ставляемые модули
Так как … часто используется в источниках данных, он принимается в качестве альтернативного
написания … К сожалению, это порождает неоднозначность при разборе: неясно, какая верхняя
граница имеется в виду в записи 0…23 — 23 или 0.23. Для разрешения этой неоднозначности во
входных числах seg перед десятичной точкой всегда должна быть минимум одна цифра.
В качестве меры предосторожности, seg не принимает интервалы с нижней границей, превыша-
ющей верхнюю, например: 5 .. 2.
F.34.3. Точность
Значения seg хранятся внутри как пары 32-битных чисел с плавающей точкой. Это значит, что
числа с более чем 7 значащими цифрами будут усекаться.
Числа, содержащие 7 и меньше значащих цифр, сохраняют изначальную точность. То есть, если
запрос возвращает 0.00, вы можете быть уверены, что конечные нули не являются артефактами
форматирования: они отражают точность исходных данных. Количество ведущих нулей не влияет
на точность: значение 0.0067 будет считаться имеющим только две значащих цифры.
F.34.4. Использование
Модуль seg включает класс операторов индекса GiST для значений seg. Операторы, поддержива-
емые этим классом операторов, перечислены в Таблице F.28.
Таблица F.28. Операторы seg для GiST
Оператор Описание
[a, b] « [c, d] [a, b] полностью находится левее [c, d]. То есть,
[a, b] « [c, d] — true, если b &lt; c, и false в про-
тивном случае.
[a, b] » [c, d] [a, b] полностью находится правее [c, d]. То есть,
[a, b] » [c, d] — true, если a &gt; d, и false в про-
тивном случае.
[a, b] &amp;&lt; [c, d] Пересекает или левее — Ещё лучше это читает-
ся как «не простирается правее». Результатом
будет true, когда b &lt;= d.
[a, b] &amp;&gt; [c, d] Пересекает или правее — Ещё лучше это чита-
ется как «не простирается левее». Результатом
будет true, когда a &gt;= c.
[a, b] = [c, d] Равенство — сегменты [a, b] и [c, d] равны, то
есть, a = c и b = d.
[a, b] &amp;&amp; [c, d] Сегменты [a, b] и [c, d] пересекаются.
[a, b] @&gt; [c, d] Сегмент [a, b] содержит сегмент [c, d], то есть,
a &lt;= c и b &gt;= d.
[a, b] &lt;@ [c, d] Сегмент [a, b] содержится в [c, d], то есть, a &gt;=
c и b &lt;= d.
(До версии PostgreSQL 8.2 операторы включения @&gt; и &lt;@ обозначались соответственно как @ и ~.
Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упраздне-
ны. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые
геометрические типы данных!)
Также поддерживаются стандартные операторы для B-дерева, например:
Оператор Описание
[a, b] &lt; [c, d] Меньше
2595Дополнительно по-
ставляемые модули
Оператор Описание
[a, b] &gt; [c, d] Больше
Эти операторы не имеют большого смысла ни для какой практической цели, кроме сортировки.
Эти операторы сначала сравнивают (a) с (c), и если они равны, сравнивают (b) с (d). Результат
сравнения позволяет упорядочить значения образом, подходящим для большинства случаев, что
полезно, если вы хотите применять ORDER BY с этим типом.
F.34.5. Замечания
Примеры использования можно увидеть в регрессионном тесте sql/seg.sql.
Механизм, преобразующий (+-) в обычные диапазоны, не вполне точно определяет число знача-
щих цифр для границ. Например, он добавляет дополнительную цифру к нижней границе, если
результирующий интервал включает степень десяти:
postgres=&gt; select ‘10(+-)1’::seg as seg;
seg
———
9.0 .. 11
– должно быть: 9 .. 11
Производительность индекса-R-дерева может значительно зависеть от начального порядка вводи-
мых значений. Может быть очень полезно отсортировать входную таблицу по столбцу seg; пример
можно найти в скрипте sort-segments.pl.
F.34.6. Благодарности
Первый автор: Джин Селков мл. <a href="mailto:selkovjr@mcs.anl.gov">selkovjr@mcs.anl.gov</a>, Аргоннская национальная лаборатория,
Отдел математики и компьютерных наук
Я очень благодарен в первую очередь профессору Джо Геллерштейну (http://dbcsberkeleyedu/jmh/
) за пояснение сути GiST (http://gistcsberkeleyedu/). Я также признателен всем разработчикам
Postgres в настоящем и прошлом за возможность создать свой собственный мир и спокойно жить
в нём. Ещё я хотел бы выразить признательность Аргоннской лаборатории и Министерству энер-
гетики США за годы постоянной поддержки моих исследований в области баз данных.
F.35. sepgsql
Загружаемый модуль sepgsql поддерживает мандатное управление доступом (MAC, Mandatory
Access Control) с метками, построенное на базе политик безопасности SELinux.
Предупреждение
Текущая реализация имеет существенные ограничения и контролирует не все дей-
ствия. См. Подраздел F.35.7.
F.35.1. Обзор
Этот модуль интегрируется в SELinux и обеспечивает дополнительный уровень проверок безопас-
ности, расширяющий и дополняющий обычные средства PostgreSQL. С точки зрения SELinux, дан-
ный модуль позволяет PostgreSQL выполнять роль менеджера объектов в пространстве пользова-
теля. При выполнении запроса DML обращение к каждой таблице или функции в нём будет кон-
тролироваться согласно системной политике безопасности. Эта проверка дополняет штатную про-
верку разрешений SQL, которую производит PostgreSQL.
Механизм SELinux принимает решения о разрешении доступа на основе меток безопасности, пред-
ставляемых строками вида system_u:object_r:sepgsql_table_t:s0. В каждом решении учитыва-
ются две метки: метка субъекта, пытающегося выполнить действие, и метка объекта, над которым
2596Дополнительно по-
ставляемые модули
должно совершаться это действие. Так как эти метки могут применяться к объекту любого вида,
решения о разрешении доступа к объектам внутри базы данных могут подчиняться (и с этим моду-
лем фактически подчиняются) общим критериям, применяемым к объектам любого другого типа,
например, к файлам. Эта схема позволяет организовать централизованную политику безопасности
для защиты информационных активов, не зависящую от того, как именно хранятся эти активы.
Назначить метку безопасности объекту баз данных позволяет команда SECURITY LABEL.
F.35.2. Установка
Модуль sepgsql может работать только в Linux 2.6.28 и новее с включённым SELinux. На остальных
платформах он не поддерживается. Вам также понадобится libselinux 2.1.10 или новее и selinux-
policy 3.9.13 или новее (хотя в некоторых дистрибутивах необходимые правила могут быть адапти-
рованы к политике старой версии).
Команда sestatus позволяет проверить состояние SELinux. Типичный её вывод выглядит так:
$ sestatus
SELinux status:
SELinuxfs mount:
Current mode:
Mode from config file:
Policy version:
Policy from config file:
enabled
/selinux
enforcing
enforcing
24
targeted
Если SELinux отключён или не установлен, его необходимо привести в рабочее состояние, прежде
чем устанавливать этот модуль.
Чтобы собрать этот модуль, добавьте параметр –with-selinux в команду PostgreSQL configure.
Убедитесь в том, что в момент сборки установлен RPM-пакет libselinux-devel.
Чтобы использовать этот модуль, вы должны включить sepgsql в shared_preload_libraries в
postgresql.conf. Этот модуль не будет корректно работать, если загрузить его каким-либо другим
способом. Загрузив его, нужно выполнить sepgsql.sql в каждой базе данных. Этот скрипт устано-
вит функции, необходимые для управления метками безопасности, и назначит начальные метки
безопасности.
Следующий пример показывает, как инициализировать новый кластер баз данных и установить в
него функции и метки безопасности sepgsql. Измените пути в соответствии с размещением вашей
инсталляции:
$ export PGDATA=/path/to/data/directory
$ initdb
$ vi $PGDATA/postgresql.conf
изменить
#shared_preload_libraries = ‘’</p>
          <h1 id="после-изменения-требуется">(после изменения требуется</h1>
          <p>перезапуск)
на
shared_preload_libraries = ‘sepgsql’</p>
          <h1 id="после-изменения-требуется-1">(после изменения требуется</h1>
          <p>перезапуск)
$ for DBNAME in template0 template1 postgres; do
postgres –single -F -c exit_on_error=true $DBNAME \
&lt;/usr/local/pgsql/share/contrib/sepgsql.sql &gt;/dev/null
done
Заметьте, что вы можете увидеть следующие уведомления, в зависимости от конкретных установ-
ленных версий libselinux и selinux-policy:
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
2597
line 33 has invalid object type
line 36 has invalid object typeДополнительно по-
ставляемые модули
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
line 37 has invalid object type
line 38 has invalid object type
line 39 has invalid object type
line 40 has invalid object type
Эти сообщения не критичны и их можно игнорировать.
Если процесс установки завершается без ошибок, вы можете запустить сервер обычным образом.
F.35.3. Регрессионные тесты
Природа SELinux такова, что для проведения регрессионных тестов sepgsql требуются дополни-
тельные действия по настройке и некоторые из них должен выполнять root. Регрессионные тесты
не будут запускаться обычной командой make check или make installcheck; вы должны настроить
конфигурацию и затем вызвать тестовый скрипт вручную. Тесты должны запускаться в каталоге
contrib/sepgsql настроенного дерева сборки PostgreSQL. Хотя им требуется дерево сборки, эти
тесты рассчитаны на использование установленного сервера, то есть они примерно соответствуют
make installcheck, но не make check.
Сначала установите sepgsql в рабочую базу данных по инструкциям, приведённым в Подразде-
ле F.35.2. Заметьте, что для этого текущий пользователь операционной системы должен подклю-
чаться к базе данных как суперпользователь без аутентификации по паролю.
На втором шаге соберите и установите пакет политики для регрессионного теста. Политика
sepgsql-regtest представляет собой политику особого назначения, предоставляющую набор пра-
вил, включаемых во время регрессионных тестов. Её следует скомпилировать из исходного фай-
ла sepgsql-regtest.te, что можно сделать командой make со скриптом Makefile, поставляемым с
SELinux. Вам нужно будет найти нужный Makefile в своей системе; путь, показанный ниже, при-
ведён только в качестве примера. Скомпилировав пакет политики, его нужно установить с помо-
щью команды semodule, которая загружает переданные ей пакеты в ядро. Если пакет установлен
корректно, команда semodule -l должна вывести sepgsql-regtest в списке доступных пакетов
политик:
$ cd …/contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.07
На третьем шаге включите параметр sepgsql_regression_test_mode. По соображени-
ям безопасности, правила в sepgsql-regtest по умолчанию неактивны; параметр
sepgsql_regression_test_mode активирует правила, необходимые для проведения регрессионных
тестов. Включить этот параметр можно командой setsebool:
$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode –&gt; on
На четвёртом шаге убедитесь в том, что ваша оболочка работает в домене unconfined_t:
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
Если необходимо сменить рабочий домен, в подробностях это описывается в Подразделе F.35.8.
Наконец, запустите скрипт регрессионного теста:
$ ./test_sepgsql
2598Дополнительно по-
ставляемые модули
Этот скрипт попытается проверить, все ли шаги по настройке конфигурации выполнены коррект-
но, а затем запустит регрессионные тесты для модуля sepgsql.
Завершив тесты, рекомендуется отключить параметр sepgsql_regression_test_mode:
$ sudo setsebool sepgsql_regression_test_mode off
Другой, возможно, более предпочтительный вариант — удалить политику sepgsql-regtest полно-
стью:
$ sudo semodule -r sepgsql-regtest
F.35.4. Параметры GUC
sepgsql.permissive (boolean)
Этот параметр переводит sepgsql в разрешительный режим, вне зависимости от режима си-
стемы. По умолчанию он имеет значение off (отключён). Задать этот параметр можно только в
postgresql.conf или в командной строке при запуске сервера.
Когда этот параметр включён, sepgsql действует в разрешительном режиме, даже если
SELinux в целом находится в ограничительном режиме. Этот параметр полезен в первую оче-
редь для тестирования.
sepgsql.debug_audit (boolean)
Этот параметр включает вывод сообщений аудита вне зависимости от параметров системной
политики. По умолчанию он отключён (имеет значение off), что означает, что сообщения будут
выводиться согласно параметрам системы.
Политики безопасности SELinux также содержит правила, определяющие, будут ли фиксиро-
ваться в журнале определённые события. По умолчанию фиксируются нарушения доступа, а
успешный доступ — нет.
Этот параметр принудительно включает фиксирование в журнале всех возможных событий,
вне зависимости от системной политики.
F.35.5. Функциональные возможности
F.35.5.1. Управляемые классы объектов
Модель безопасности SELinux описывает все правила доступа в виде отношений между сущностью
субъекта (обычно, это клиент базы данных) и сущностью объекта (например, объектом базы дан-
ных), каждая из которых определяется меткой безопасности. Если осуществляется попытка досту-
па к непомеченному объекту, он обрабатывается как объект, имеющий метку unlabeled_t.
В настоящее время sepgsql позволяет назначать метки безопасности схемам, таблицам, столбцам,
последовательностям, представлениям и функциям. Когда sepgsql активен, метки безопасности
автоматически назначаются поддерживаемым объектам базы в момент создания. Такая метка на-
зывается меткой безопасности по умолчанию и устанавливается согласно политике безопасности
системы, которая учитывает метку создателя, метку, назначенную родительскому объекту созда-
ваемого объекта и, возможно, имя создаваемого объекта.
Новый объект базы, как правило, наследует метку безопасности, назначенную родительскому объ-
екту, если только в политике безопасности не заданы специальные правила, называемые правила-
ми перехода типов (в этом случае может быть назначена другая метка). Для схем родительским
объектом является текущая база данных; для таблиц, последовательностей, представлений и функ-
ций — схема, содержащая эти объекты; для столбцов — таблица.
F.35.5.2. Разрешения для DML
Для таблиц, задействованных в запросе в качестве целевых, проверяются разрешения
db_table:select, db_table:insert, db_table:update или db_table:delete в зависимости от ти-
2599Дополнительно по-
ставляемые модули
па оператора; кроме того, для всех таблиц, содержащих столбцы, фигурирующие в предложении
WHERE или RETURNING, или служащих источником данных для UPDATE и т. п., также проверяется
разрешение db_table:select.
Для всех задействованных столбцов также проверяются разрешения на уровне столбцов. Раз-
решение db_column:select проверяется не только для столбцов, которые считываются операто-
ром SELECT, но и для тех, к которым обращаются другие операторы DML; db_column:update или
db_column:insert также проверяется для столбцов, изменяемых операторами UPDATE или INSERT.
Например, рассмотрим запрос:
UPDATE t1 SET x = 2, y = func1(y) WHERE z = 100;
В данном случае db_column:update будет проверяться для столбца t1.x, так как он изменяется,
db_column:(select update) будет проверяться для t1.y, так как он и считывается, и изменяется,
а db_column:select — для столбца t1.z, так как он только считывается. На уровне таблицы также
будет проверяться разрешение db_table:(select update).
Для последовательностей проверяется разрешение db_sequence:get_value, когда имеет место об-
ращение к объекту последовательности в SELECT; заметьте, однако, что в настоящее время разре-
шения на выполнение связанных функций, таких как, lastval(), не проверяются.
Для представлений проверяется db_view:expand, а затем все другие соответствующие разрешения
для объектов, развёрнутых из определения представления, в индивидуальном порядке.
Для функций проверяется db_procedure:(execute), когда пользователь пытается выполнить функ-
цию в составе запроса, либо при вызове по быстрому пути. Если эта функция является доверенной
процедурой, также проверяется разрешение db_procedure:(entrypoint), чтобы удостовериться,
что эта функция может быть точкой входа в доверенную процедуру.
При обращении к любому объекту схемы необходимо иметь разрешение db_schema:search для
содержащей его схемы. Когда имя целевого объекта не дополняется схемой, схемы, для которых
данное разрешение отсутствует, не будут просматриваться (то же происходит, если у пользователя
нет права USAGE для этой схемы). Когда схема указывается явно, пользователь получит ошибку,
если он не имеет требуемого разрешения для доступа к указанной схеме.
Клиенту должен быть разрешён доступ ко всем задействованным в запросе таблицам и столбцам,
даже если они проявились в нём в результате разворачивания представлений, так что правила
применяются согласованно вне зависимости от варианта обращения к содержимому таблиц.
Стандартная система привилегий позволяет суперпользователям баз данных изменять системные
каталоги с помощью команд DML и обращаться к таблицам TOAST или модифицировать их. Когда
модуль sepgsql активен, эти операции запрещаются.
F.35.5.3. Разрешения для DDL
SELinux определяет набор разрешений для управления стандартными операциями для каждого
типа объекта: создание, изменение определения, удаление и смена метки безопасности. В допол-
нение к ним для некоторых типов объектов предусмотрены специальные разрешения для управ-
ления их специфическими операциями, как например, добавление или удаление объектов в опре-
делённой схеме.
Для создания нового объекта базы данных требуется разрешение create. SELinux разрешает или
запрещает выполнение этой операции в зависимости от метки безопасности клиента и предпола-
гаемой метки безопасности нового объекта. В некоторых случаях требуются дополнительные раз-
решения:
• CREATE DATABASE дополнительно требует разрешения getattr в исходной или шаблонной
базе данных.
• Создание объекта схемы дополнительно требует разрешения add_name в родительской схеме.
2600Дополнительно по-
ставляемые модули
• Создание таблицы дополнительно требует разрешения на создание каждой отдельного столб-
ца таблицы, как если бы каждый столбец таблицы был отдельным объектом верхнего уровня.
• Создание функции с атрибутом LEAKPROOF дополнительно требует разрешения install. (Это
разрешение также проверяется, когда атрибут LEAKPROOF устанавливается для существующей
функции.)
Когда выполняется команда DROP, для удаляемого объекта будет проверяться разрешение drop.
Разрешения будут также проверяться и для объектов, удаляемых косвенно, вследствие указания
CASCADE. Для удаления объектов, содержащихся в определённой схеме, (таблиц, представления,
последовательностей и процедур) дополнительно нужно иметь разрешение remove_name в этой схе-
ме.
Когда выполняется команда ALTER, для каждого модифицируемого объекта проверяется разреше-
ние setattr, кроме подчинённых объектов, таких как индексы или триггеры таблиц (на них распро-
страняются разрешения родительского объекта). В некоторых случаях требуются дополнительные
разрешения:
• При перемещении объекта в новую схему дополнительно требуется разрешение remove_name в
старой схеме и add_name в новой.
• Для установки атрибута LEAKPROOF для функции требуется разрешение install.
• Для использования SECURITY LABEL дополнительно требуется разрешение relabelfrom для
объекта с его старой меткой безопасности и relabelto для этого объекта с новой меткой без-
опасности. (В случаях, когда установлено несколько поставщиков меток и пользователь пы-
тается задать метку, неподконтрольную SELinux, должно проверяться только разрешение
setattr. В настоящее время этого не происходит из-за ограничений реализации.)
F.35.5.4. Доверенные процедуры
Доверенные процедуры похожи на функции, определяющие контекст безопасности, или команды
setuid. В SELinux реализована возможность запускать доверенный код с меткой безопасности, от-
личной от метки клиента, как правило, для предоставления чётко контролируемого доступа к важ-
ным данным (при этом например, могут отсеиваться строки или хранимые значения могут выво-
диться с меньшей точностью). Будет ли функция вызываться как доверенная процедура, опреде-
ляется её меткой безопасности и политикой операционной системы. Например:
postgres=# CREATE TABLE customer (
cid
int primary key,
cname
text,
credit text
);
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
IS ‘system_u:object_r:sepgsql_secret_table_t:s0’;
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
AS ‘SELECT regexp_replace(credit, ‘’-[0-9]+$’’, ‘‘-xxxx’’, ‘‘g’’)
FROM customer WHERE cid = $1’
LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
IS ‘system_u:object_r:sepgsql_trusted_proc_exec_t:s0’;
SECURITY LABEL
Показанные выше операции должен выполнять пользователь с правами администратора.
postgres=# SELECT * FROM customer;
ERROR: SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
cid | cname |
show_credit
2601Дополнительно по-
ставляемые модули
—–+——–+———————
1 | taro
| 1111-2222-3333-xxxx
2 | hanako | 5555-6666-7777-xxxx
(2 rows)
В данном случае обычный пользователь не может обращаться к customer.credit напрямую, но
доверенная процедура show_credit позволяет ему получить номера кредитных карт клиентов, в
которых будут скрыты некоторые цифры.
F.35.5.5. Динамические переключения домена
Возможность динамического перехода из домена в домен SELinux позволяет переводить метку
безопасности клиентского процесса, клиентский домен в новый контекст, если это допускается
политикой безопасности. Для этого клиент должен иметь разрешение setcurrent, а также разре-
шение dyntransition для перехода из старого в новый домен.
Динамические переключения домена следует тщательно продумывать, так как таким образом
пользователи могут менять свои метки, а значит и привилегии, по собственному желанию, а не
(как в случае с доверенными процедурами) по правилам, диктуемым системой. Таким образом,
разрешение dyntransition считается безопасным, только когда применяется для переключения
в домен с более ограниченным набором привилегий, чем текущий. Например:
regression=# select sepgsql_getcon();
sepgsql_getcon
——————————————————-
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)
regression=# SELECT sepgsql_setcon(‘unconfined_u:unconfined_r:unconfined_t:s0-
s0:c1.c4’);
sepgsql_setcon
—————-
t
(1 row)
regression=# SELECT sepgsql_setcon(‘unconfined_u:unconfined_r:unconfined_t:s0-
s0:c1.c1023’);
ERROR: SELinux: security policy violation
В показанном выше примере мы смогли переключиться из более широкого диапазона MCS
c1.c1023 в более узкий c1.c4, но переключение в обратную сторону было запрещено.
Сочетание динамического переключения домена с доверенными процедурами позволяет полу-
чить интересное решение, подходящее для реализации жизненного цикла процессов с пулом со-
единений. Даже если вашему менеджеру пула соединений не разрешается запускать многие ко-
манды SQL, вы можете разрешить ему сменить метку безопасности клиента, вызвав функцию
sepgsql_setcon() из доверенной процедуры; для этого может передаваться удостоверение для ав-
торизации запроса на смену метки клиента. После этого сеанс получит привилегии целевого поль-
зователя, а не пользователя пула соединений. Позднее менеджер пула может отменить смену кон-
текста безопасности, вызвав sepgsql_setcon() с аргументом NULL, так же из доверенной процеду-
ры с необходимыми проверками разрешений. Идея этого подхода в том, что только этой доверен-
ной процедуре будет разрешено менять действующую метку безопасности и только в том случае,
когда ей передаётся правильное удостоверение. Разумеется, чтобы это решение было безопасным,
хранилище удостоверений (таблица, определение процедуры или что-то другое) не должно быть
общедоступным.
F.35.5.6. Разное
Выполнение команды LOAD в активном режиме запрещается, так как любой загруженный модуль
может легко обойти ограничения политики безопасности.
2602Дополнительно по-
ставляемые модули
F.35.6. Функции sepgsql
В Таблице F.29 перечислены все доступные функции.
Таблица F.29. Функции sepgsql
sepgsql_getcon() returns text Возвращает клиентский домен, текущую метку
безопасности клиента.
sepgsql_setcon(text) returns bool Переключает домен клиента текущего сеанса в
новый домен, если это допускает политика без-
опасности. Эта функция также принимает в ар-
гументе NULL как запрос на переход в начальный
домен клиента.
sepgsql_mcstrans_in(text) returns text Переводит заданный диапазон MLS/MCS из пол-
ной записи в низкоуровневый формат, если ра-
ботает демон mcstrans.
sepgsql_mcstrans_out(text) returns text Переводит заданный диапазон MLS/MCS из низ-
коуровневого формата в полную запись, если ра-
ботает демон mcstrans.
sepgsql_restorecon(text) returns bool Устанавливает начальные метки безопасности
для всех объектов в текущей базе данных. В аргу-
менте может передаваться NULL или имя файла
со спецификациями контекстов, который будет
применяться вместо стандартного системного.
F.35.7. Ограничения
Разрешения для языка определения данных (DDL, Data Definition Language)
Вследствие ограничений реализации, для некоторых операций DDL разрешения не проверя-
ются.
Разрешения для языка управления данными (DCL, Data Control Language)
Вследствие ограничений реализации, для операций DCL разрешения не проверяются.
Управление доступом на уровне строк
PostgreSQL поддерживает ограничение доступа на уровне строк, а sepgsql — нет.
Скрытые каналы
Модуль sepgsql не пытается скрыть существование определённого объекта, даже если поль-
зователю не разрешено обращаться к нему. Например, возможно догадаться о существовании
невидимого объекта по конфликтам первичного ключа, нарушениям внешних ключей и т. д.,
даже когда нельзя получить содержимое этого объекта. Существование совершенно секретной
таблицы невозможно скрыть; надеяться можно только на то, что будет защищено её содержи-
мое.
F.35.8. Внешние ресурсы
SE-PostgreSQL Introduction, Введение в SE-PostgreSQL
На этой вики-странице даётся краткий обзор этого решения и рассказывается об архитектуре
и конструкции безопасности, администрировании и ожидаемых в будущем возможностях.
SELinux User’s and Administrator’s Guide, Руководство пользователя и администратора SELinux
В этом документе представлен широкий спектр знаний по администрированию SELinux в ОС.
В первую очередь он ориентирован на системы Red Hat, но его область применения не ограни-
чена ими.
2603Дополнительно по-
ставляемые модули
Fedora SELinux FAQ, Часто задаваемые вопросы по SELinux в ОС Fedora
В этом документе даются ответы на часто задаваемые вопросы по SELinux. В первую очередь
он ориентирован на ОС Fedora, но его область применения не ограничена ей.
F.35.9. Автор
КайГай Кохэй <a href="mailto:kaigai@ak.jp.nec.com">kaigai@ak.jp.nec.com</a>
F.36. spi
Модуль spi предоставляет несколько рабочих примеров использования Интерфейса программиро-
вания сервера (Server Programming Interface, SPI) и триггеров. Хотя эти функции имеют некото-
рую ценность сами по себе, они ещё более полезны как заготовки, которые можно приспособить
под собственные нужды. Эти функции достаточно общие, чтобы работать с любой таблицей, но вы
должны явно указать имена таблицы и полей (как описано ниже) при создании триггера.
Каждая группа функций, описанная ниже, представлена в виде отдельно устанавливаемого рас-
ширения.
F.36.1. refint — функции для реализации ссылочной целостности
Функции check_primary_key() и check_foreign_key() применяются для проверки ограничений
внешних ключей. (Эта функциональность уже давно вытеснена встроенным механизмом внешних
ключей, но этот модуль всё ещё полезен в качестве примера.)
Функция check_primary_key() проверяет ссылающуюся таблицу. Чтобы воспользоваться ей, со-
здайте триггер BEFORE INSERT OR UPDATE с этой функцией для таблицы, ссылающейся на другую.
Укажите в аргументах триггера: имена столбцов ссылающейся таблицы, образующих внешний
ключ, имя целевой таблицы и имена столбцов в ней, образующих первичный/уникальный ключ.
Чтобы контролировать несколько внешних ключей, создайте триггер для каждой такой ссылки.
Функция check_foreign_key() проверяет целевую таблицу. Чтобы использовать её, создайте триг-
гер BEFORE DELETE OR UPDATE с этой функцией для таблицы, на которую ссылаются другие. Ука-
жите в аргументах триггера: число ссылающихся таблиц, для которых функция должна выполнить
проверки, действие в случае обнаружения ссылающегося ключа (cascade — удалить ссылающу-
юся строку, restrict — прервать транзакцию, setnull — установить в ссылающихся полях зна-
чения NULL), имена столбцов целевой таблицы, образующих первичный/уникальный ключ, а за-
тем имена таблиц и столбцов (в количестве, задаваемом первым аргументом). Заметьте, что поля
первичных/уникальных столбцов должны иметь пометку NOT NULL и по ним должен быть создан
уникальный индекс.
Примеры приведены в refint.example.
F.36.2. timetravel — функции для реализации перемещений во
времени
В далёком прошлом в PostgreSQL была встроенная возможность перемещений во времени, для ко-
торой фиксировалось время добавления и удаления каждого кортежа. Эти функции позволяют её
имитировать. Чтобы использовать их, вы должны добавить в таблицу два столбца типа abstime, в
которых будет храниться дата/время, когда кортеж был вставлен (start_date) и когда изменён/уда-
лён (stop_date):
CREATE TABLE mytab (
…
start_date
stop_date
…
);
…
abstime,
abstime
…
2604Дополнительно по-
ставляемые модули
Эти столбцы могут называться как угодно, но в данном описании они называются start_date и
stop_date.
Когда вставляется новая строка, в start_date обычно устанавливается текущее время, а в stop_date
— infinity (бесконечность). Триггер автоматически подставит эти значения, если добавляемая
строка содержит NULL в этих столбцах. Обычно не-NULL в этих столбцах может оказаться только
при загрузке в базу выгруженных данных.
Кортежи, в которых поле stop_date равно infinity, считаются «актуальными сейчас» и могут быть
изменены. Кортежи с определённой датой stop_date больше не могут быть изменены — триггер
будет препятствовать этому. (Если вам нужно сделать это, вы можете отключить машину времени
как показано ниже.)
Если кортеж является изменяемым, при модификации в нём меняется только stop_date (на те-
кущее время), но в таблицу вставляется новый кортеж с модифицированными данными. В поле
start_date в этом новом кортеже записывается текущее время, а в stop_date записывается infinity.
При удалении кортеж на самом деле не удаляется; в нём только записывается текущее время в
stop_date.
Чтобы запросить кортежи «актуальные сейчас», добавьте stop_date = ‘infinity’ в условие
WHERE вашего запроса. (Возможно, вы захотите завернуть это условие в представление.) Анало-
гичным образом вы можете запрашивать кортежи, которые были актуальны в любой момент в про-
шлом, задав подходящие условия для start_date и stop_date.
Функция timetravel() реализует код универсального триггера, поддерживающего это поведение.
Чтобы использовать её, создайте триггер BEFORE INSERT OR UPDATE OR DELETE с этой функцией для
каждой таблицы, перемещающейся во времени. Передайте триггеру два аргумента: фактические
имена столбцов start_date и stop_date. Вы также можете дополнительно передать от одного до
трёх аргументов, задающих имена столбцов типа text. Данный триггер сохранит имя текущего
пользователя в первый из этих столбцов при INSERT, во второй — при UPDATE, и в третий — при
DELETE.
Функция set_timetravel() позволяет включить или отключить машину времени для табли-
цы. Вызов set_timetravel(‘mytab’, 1) включает машину времени для таблицы mytab, а
set_timetravel(‘mytab’, 0) — отключает её для таблицы mytab. В обоих случаях возвращает-
ся прежнее состояние. Когда машина времени выключена, вы можете свободно модифицировать
столбцы start_date и stop_date. Заметьте, что состояние активности машины является локальным
для текущего сеанса базы данных — в новых сеансах машина времени всегда включена для всех
таблиц.
Функция get_timetravel() возвращает состояние перемещения во времени для таблицы, не меняя
его.
Пример приведён в timetravel.example.
F.36.3. autoinc — функции для автоувеличения полей
Функция autoinc() реализует код триггера, сохраняющего следующее значение последовательно-
сти в целочисленном поле. Это в некоторой степени пересекается со встроенной функционально-
стью столбца «serial», но есть и отличия: autoinc() препятствует попыткам вставить другое зна-
чение поля при добавлении строк и может увеличивать значение поля при изменениях.
Чтобы использовать её, создайте триггер BEFORE INSERT (или BEFORE INSERT OR UPDATE) с этой
функцией. Передайте триггеру два аргумента: имя целочисленного столбца, который будет ме-
няться, и имя объекта последовательности, который будет поставлять значения. (Вообще вы мо-
жете задать любое число пар таких имён, если хотите поддерживать несколько автоувеличиваю-
щихся столбцов.)
Пример приведён в autoinc.example.
2605Дополнительно по-
ставляемые модули
F.36.4. insert_username — функции для отслеживания пользовате-
ля, вносящего изменения
Функция insert_username() реализует код триггера, сохраняющего имя текущего пользователя в
текстовом поле. Это может быть полезно для отслеживания пользователя, изменившего конкрет-
ную строку таблицы последним.
Чтобы использовать её, создайте триггер BEFORE INSERT и/или UPDATE с этой функцией. Передайте
триггеру один аргумент: имя целевого текстового столбца.
Пример приведён в insert_username.example.
F.36.5. moddatetime — функции для отслеживания времени по-
следнего изменения
Функция moddatetime() реализует код триггера, сохраняющего текущее время в поле типа
timestamp. Это может быть полезно для отслеживания времени последней модификации конкрет-
ной строки таблицы.
Чтобы использовать её, создайте триггер BEFORE UPDATE с этой функцией. Передайте триггеру один
аргумент: имя целевого столбца. Столбец должен иметь тип timestamp или timestamp with time
zone.
Пример приведён в moddatetime.example.
F.37. sslinfo
Модуль sslinfo выдаёт информацию о SSL-сертификате, который был представлен текущим кли-
ентом при подключении к PostgreSQL. Этот модуль бесполезен (большинство функций возвратят
NULL), если для текущего подключения не задействуется SSL.
Это расширение не будет собираться, если конфигурация была произведена без ключа –with-
openssl.
F.37.1. Предоставляемые функции
ssl_is_used() returns boolean
Возвращает true, если текущее подключение использует SSL, и false в противном случае.
ssl_version() returns text
Возвращает имя протокола, по которому организовано SSL-подключение (например TLSv1.0,
TLSv1.1 или TLSv1.2).
ssl_cipher() returns text
Возвращает имя шифра, используемого для SSL-подключения (например, DHE-RSA-AES256-
SHA).
ssl_client_cert_present() returns boolean
Возвращает true, если текущий клиент предоставил серверу действительный клиентский SSL-
сертификат, и false в противном случае. (Сервер может требовать, а может и не требовать
предоставления клиентского сертификата.)
ssl_client_serial() returns numeric
Возвращает серийный номер текущего клиентского сертификата. Сочетание серийного номе-
ра сертификата с выдавшим его центром сертификации гарантирует однозначную идентифи-
2606Дополнительно по-
ставляемые модули
кацию сертификата (но не его владелец — владелец должен регулярно менять свои ключи и
получать сертификаты в центре сертификации).
Поэтому, если вы используете собственный ЦС и настроили сервер, чтобы он принимал серти-
фикаты только от этого ЦС, серийный номер будет наиболее надёжным (хотя не очень запоми-
нающимся) ключом идентификации пользователя.
ssl_client_dn() returns text
Возвращает полное имя субъекта из текущего клиентского сертификата, преобразуя символь-
ные данные в кодировку текущей базы данных. Предполагается, что если в именах в сертифи-
катах используются символы вне таблицы ASCII, то ваша база данных может представить эти
символы. Если в вашей базе используется кодировка SQL_ASCII, символы вне ASCII в имени
будут представлены последовательностями UTF-8.
Результат выглядит примерно так: /CN=Somebody /C=Some country/O=Some organization.
ssl_issuer_dn() returns text
Возвращает полное имя издателя текущего клиентского сертификата, преобразуя символьные
данные в кодировку текущей базы данных. Преобразования кодировки осуществляются так же,
как и в ssl_client_dn.
Сочетание возвращаемого значения этой функции с серийным номером сертификата однознач-
но идентифицирует сертификат.
Эта функция полезна, только если в установленном на сервере файле с сертификатами ЦС со-
держатся сертификаты нескольких ЦС или если один ЦС выдаёт сертификаты для промежу-
точных центров сертификации.
ssl_client_dn_field(fieldname text) returns text
Эта функция возвращает значение указанного поля данных субъекта сертификата, либо NULL,
если это поле отсутствует. Имена полей задаются строковыми константами, которые затем
преобразуются в идентификаторы объектов ASN1, используя базу данных объектов OpenSSL.
Принимаются следующие значения:
commonName (или CN)
surname (или SN)
name
givenName (или GN)
countryName (или C)
localityName (или L)
stateOrProvinceName (или ST)
organizationName (или O)
organizationUnitName (или OU)
title
description
initials
postalCode
streetAddress
generationQualifier
description
dnQualifier
x500UniqueIdentifier
pseudonym
role
emailAddress
Все эти поля являются необязательными, за исключением commonName. Какие из них будут
включены в сертификат, а какие нет, зависит полностью от политики вашего ЦС. Значение
2607Дополнительно по-
ставляемые модули
этих полей, однако, строго определено стандартами X.500 и X.509, так что их нельзя интерпре-
тировать произвольным образом.
ssl_issuer_field(fieldname text) returns text
То же, что ssl_client_dn_field, но для издателя, а не для субъекта сертификата.
ssl_extension_info() returns setof record
Предоставляет информацию о расширениях клиентского сертификата: имя расширения, зна-
чение расширения и является ли это расширение критическим.
F.37.2. Автор
Виктор Вагнер <a href="mailto:vitus@cryptocom.ru">vitus@cryptocom.ru</a>, ООО «Криптоком»
Дмитрий Воронин <a href="mailto:carriingfate92@yandex.ru">carriingfate92@yandex.ru</a>
Электронный адрес группы разработчиков OpenSSL в Криптокоме: <a href="mailto:openssl@cryptocom.ru">openssl@cryptocom.ru</a>
F.38. tablefunc
Модуль tablefunc содержит ряд функций, возвращающих таблицы (то есть, множества строк). Эти
функции полезны и сами по себе, и как примеры написания на C функций, возвращающих наборы
строк.
F.38.1. Предоставляемые функции
Функции, предоставляемые модулем tablefunc, перечислены в Таблице F.30.
Таблица F.30. Функции tablefunc
Функция Возвращает Описание
normal_rand(int
numvals,
float8
mean,
float8
stddev) setof float8 Выдаёт набор случайных значе-
ний, имеющих нормальное рас-
пределение
crosstab(text sql) setof record Выдаёт «повёрнутую таблицу»,
содержащую имена строк плюс
N столбцов значений, где N опре-
деляется видом строк, задан-
ным в вызывающем запросе
crosstabN(text sql) setof table_crosstab_ crosstab(text source_sql,
text category_sql) setof record Выдаёт «повёрнутую таблицу»
со столбцами значений, задан-
ными вторым запросом
crosstab(text sql, int N) setof record Устаревшая версия crosstab(
text) . Параметр N теперь игно-
рируется, так как число столб-
цов значений всегда определя-
ется вызывающим запросом
connectby(text
relname,
text keyid_fld, text setof record Выдаёт представление иерархи-
ческой древовидной структуры
2608
N
Выдаёт «повёрнутую таблицу»,
содержащую имена строк плюс
N столбцов значений. Функ-
ции crosstab2, crosstab3 и
crosstab4 предопределены, но
вы можете создать дополни-
тельные функции crosstabN,
как описано нижеДополнительно по-
ставляемые модули
Функция
parent_keyid_fld [, text
orderby_fld ], text start_
with, int max_depth [,
text branch_delim ])
Возвращает
Описание
F.38.1.1. normal_rand
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
Функция normal_rand выдаёт набор случайных значений, имеющих нормальное распределение
(распределение Гаусса).
Параметр numvals задаёт количество значений, которое выдаст эта функция. Параметр mean зада-
ёт медиану нормального распределения, а stddev — стандартное отклонение.
Например, этот вызов запрашивает 1000 значений с медианой 5 и стандартным отклонением 3:
test=# SELECT * FROM normal_rand(1000, 5, 3);
normal_rand
———————-
1.56556322244898
9.10040991424657
5.36957140345079
-0.369151492880995
0.283600703686639
.
.
.
4.82992125404908
9.71308014517282
2.49639286969028
(1000 rows)
F.38.1.2. crosstab(text)
crosstab(text sql)
crosstab(text sql, int N)
Функция crosstab применяется для формирования «повёрнутых» отображений, в которых данные
идут вдоль строк, а не сверху вниз. Например, мы можем иметь такие данные:
row1
row1
row1
…
row2
row2
row2
…
val11
val12
val13
val21
val22
val23
и хотим видеть их так:
row1
row2
…
val11
val21
val12
val22
val13
val23
…
…
Функция crosstab принимает в текстовом параметре SQL-запрос, выдающий исходные данные пер-
вым способом, и выдаёт таблицу, отформатированную вторым способом.
В параметре sql передаётся SQL-запрос, выдающий исходный набор данных. Этот запрос должен
возвращать один столбец row_name, один столбец category и один столбец value. Параметр N яв-
ляется устаревшим и игнорируется, если передаётся при вызове (раньше он должен был соответ-
2609Дополнительно по-
ставляемые модули
ствовать количеству выходных столбцов значений, но теперь это количество определяется вызы-
вающим запросом).
Например, заданный запрос может выдавать такой результат:
row_name
cat
value
———-+——-+——-
row1
cat1
val1
row1
cat2
val2
row1
cat3
val3
row1
cat4
val4
row2
cat1
val5
row2
cat2
val6
row2
cat3
val7
row2
cat4
val8
Функция crosstab объявлена как возвращающая setof record, так что фактические имена и типы
столбцов должны определяться в предложении FROM вызывающего оператора SELECT, например
так:
SELECT * FROM crosstab(‘…’) AS ct(row_name text, category_1 text, category_2 text);
Этот запрос выдаст примерно такой результат:
&lt;== столбцы значений ==&gt;
row_name
category_1
category_2
———-+————+————
row1
val1
val2
row2
val5
val6
Предложение FROM должно определять результат со столбцом row_name (того же типа данных, что
у первого результирующего столбца SQL-запроса), за которым следуют N столбцов значений (все
того же типа данных, что и третий результирующий столбец SQL-запроса). Количество выходных
столбцов значений может быть произвольным и имена выходных столбцов определяете вы сами.
Функция crosstab выдаёт одну выходную строку для каждой последовательной группы с одним
значением row_name. Она заполняет столбцы значений слева направо полями value из этих строк.
Если в группе оказывается меньше строк, чем выходных столбцов значений, дополнительные
столбцы принимают значения NULL; если же строк оказывается больше, лишние строки игнори-
руются.
На практике в SQL-запросе всегда должно указываться ORDER BY 1,2, чтобы входные строки были
отсортированы должным образом, то есть, чтобы данные с одинаковым значением row_name соби-
рались вместе и корректно упорядочивались в строке. Заметьте, что сама crosstab не учитывает
второй столбец результата запроса; он присутствует только для того, чтобы определять порядок,
в котором значения третьего столбца будут следовать в строке.
Полный пример:
CREATE
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
TABLE ct(id SERIAL, rowid
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
TEXT, attribute TEXT, value TEXT);
value) VALUES(‘test1’,’att1’,’val1’);
value) VALUES(‘test1’,’att2’,’val2’);
value) VALUES(‘test1’,’att3’,’val3’);
value) VALUES(‘test1’,’att4’,’val4’);
value) VALUES(‘test2’,’att1’,’val5’);
value) VALUES(‘test2’,’att2’,’val6’);
value) VALUES(‘test2’,’att3’,’val7’);
value) VALUES(‘test2’,’att4’,’val8’);
SELECT *
FROM crosstab(
‘select rowid, attribute, value
2610Дополнительно по-
ставляемые модули
from ct
where attribute = ‘‘att2’’ or attribute = ‘‘att3’’
order by 1,2’)
AS ct(row_name text, category_1 text, category_2 text, category_3 text);
row_name | category_1 | category_2 | category_3
———-+————+————+————
test1
| val2
| val3
|
test2
| val6
| val7
|
(2 rows)
Вы можете в любом случае обойтись без написания предложения FROM, определяющего выходные
столбцы, создав собственную функцию crosstab, в определении которой будет зашит желательный
тип выходной строки. Это описывается в следующем разделе. Также имеется возможность вклю-
чить требуемое предложение FROM в определение представления.
Примечание
Также изучите команду \crosstabview в psql, реализующую функциональность, подоб-
ную crosstab().
F.38.1.3. crosstabN(text)
crosstabN(text sql)
Функции crosstabN являются примерами того, как можно создать собственные обёртки универ-
сальной функции crosstab, чтобы не приходилось выписывать имена и типы столбцов в вызыва-
ющем запросе SELECT. Модуль tablefunc включает функции crosstab2, crosstab3 и crosstab4,
определяющие типы выходных строк так:
CREATE TYPE tablefunc_crosstab_N AS (
row_name TEXT,
category_1 TEXT,
category_2 TEXT,
.
.
.
category_N TEXT
);
Таким образом, эти функции могут применяться непосредственно, когда входной запрос выдаёт
столбцы row_name и value типа text и вы хотите получить на выходе 2, 3 или 4 столбца значений.
В остальном эти функции ведут себя в точности так же, как и универсальная функция crosstab.
Так, пример, приведённый в предыдущем разделе, можно переписать и в таком виде:
SELECT *
FROM crosstab3(
‘select rowid, attribute, value
from ct
where attribute = ‘‘att2’’ or attribute = ‘‘att3’’
order by 1,2’);
Эти функции представлены в основном в демонстрационных целях. Вы можете создать соб-
ственные типы возвращаемых данных и реализовать функции на базе нижележащей функции
crosstab(). Это можно сделать двумя способами:
• Создать составной тип, описывающий желаемые выходные столбцы, примерно как это дела-
ется в примерах в contrib/tablefunc/tablefunc–1.0.sql. Затем нужно выбрать уникальное
имя для функции, принимающей один параметр text и возвращающей setof имя_вашего_ти-
2611Дополнительно по-
ставляемые модули
па, и связать его с той же нижележащей функцией crosstab на C. Например, если ваш источ-
ник данных выдаёт имена строк типа text и значения типа float8, и вы хотите получить 5
столбцов значений:
CREATE TYPE my_crosstab_float8<em>5_cols AS (
my_row_name text,
my_category_1 float8,
my_category_2 float8,
my_category_3 float8,
my_category_4 float8,
my_category_5 float8
);
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
RETURNS setof my_crosstab_float8_5_cols
AS ‘$libdir/tablefunc’,’crosstab’ LANGUAGE C STABLE STRICT;
• Использовать выходные параметры (OUT), чтобы явно определить возвращаемый тип. Тот же
пример можно реализовать и таким способом:
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
IN text,
OUT my_row_name text,
OUT my_category_1 float8,
OUT my_category_2 float8,
OUT my_category_3 float8,
OUT my_category_4 float8,
OUT my_category_5 float8)
RETURNS setof record
AS ‘$libdir/tablefunc’,’crosstab’ LANGUAGE C STABLE STRICT;
F.38.1.4. crosstab(text, text)
crosstab(text source_sql, text category_sql)
Основное ограничение формы crosstab с одним параметром состоит в том, что она воспринимает
все значения в группе одинаково и вставляет очередное значение в первый свободный столбец.
Если вы хотите, чтобы столбцы значений соответствовали определённым категориям данных и
некоторые группы могли содержать данные не для всех категорий, этот подход не будет работать.
Форма crosstab с двумя параметрами решает эту задачу, принимая явный список категорий, со-
ответствующих выходным столбцам.
В параметре source_sql передаётся SQL-оператор, выдающий исходный набор данных. Этот опе-
ратор должен выдавать строки со столбцом row_name, столбцом category и столбцом value. Также
он может выдать один или несколько «дополнительных» столбцов. Столбец row_name должен быть
первым, а столбцы category и value — последними двумя, именно в этом порядке. Все столб-
цы между row_name и category воспринимаются как «дополнительные». Ожидается, что «допол-
нительные» столбцы будут содержать одинаковые значения для всех строк с одним значением
row_name.
Например, source_sql может выдать такой набор данных:
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;
row_name
extra_col
cat
value
———-+————+—–+———
row1
extra1
cat1
val1
row1
extra1
cat2
val2
row1
extra1
cat4
val4
row2
extra2
cat1
val5
row2
extra2
cat2
val6
2612Дополнительно по-
ставляемые модули
row2
row2
extra2
extra2
cat3
cat4
val7
val8
В параметре category_sql передаётся оператор SQL, выдающий набор категорий. Этот оператор
должен возвращать всего один столбец. Он должен выдать минимум одну строку; в противном
случае произойдёт ошибка. Кроме того, выдаваемые им значения не должны повторяться, иначе
так же произойдёт ошибка. В качестве category_sql можно передать, например, такой запрос:
SELECT DISTINCT cat FROM foo ORDER BY 1;
cat
——-
cat1
cat2
cat3
cat4
Функция crosstab объявлена как возвращающая тип setof record, так что фактические имена
и типы выходных столбцов должны определяться в предложении FROM вызывающего оператора
SELECT, например так:
SELECT * FROM crosstab(‘…’, ‘…’)
AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
При этом будет получен примерно такой результат:
&lt;== столбцы значений
==&gt;
row_name
extra
cat1
cat2
cat3
cat4
———+——-+——+——+——+——
row1
extra1 val1
val2
val4
row2
extra2 val5
val6
val7
val8
В предложении FROM должно определяться нужное количество выходных столбцов соответствую-
щих типов данных. Если запрос source_sql выдаёт N столбцов, первые N-2 из них должны соот-
ветствовать первым N-2 выходным столбцам. Оставшиеся выходные столбцы должны иметь тип
последнего столбца результата source_sql и их должно быть столько, сколько строк оказалось в
результате запроса category_sql.
Функция crosstab выдаёт одну выходную строку для каждой последовательной группы входных
строк с одним значением row_name. Выходной столбец row_name плюс все «дополнительные» столб-
цы копируются из первой строки группы. Выходные столбцы значений заполняются содержимым
полей value из строк с соответствующими значениями category. Если в поле category оказыва-
ется значение, отсутствующее в результате запроса category_sql, содержимое поля value в этой
строке игнорируется. Выходные столбцы, для которых соответствующая категория не представле-
на ни в одной из входных строк группы, принимают значения NULL.
На практике в запросе source_sql всегда нужно указывать ORDER BY 1, чтобы все значения с од-
ним row_name гарантированно выводились вместе. Порядок же категорий внутри группы не важен.
Кроме того, важно, чтобы порядок значений, выдаваемых запросом category_sql, соответствовал
заданному порядку выходных столбцов.
Два законченных примера:
create
insert
insert
insert
insert
insert
insert
table sales(year int, month int, qty int);
into sales values(2007, 1, 1000);
into sales values(2007, 2, 1500);
into sales values(2007, 7, 500);
into sales values(2007, 11, 1500);
into sales values(2007, 12, 2000);
into sales values(2008, 1, 1000);
select * from crosstab(
2613Дополнительно по-
ставляемые модули
‘select year, month, qty from sales order by 1’,
‘select m from generate_series(1,12) m’
) as (
year int,
“Jan” int,
“Feb” int,
“Mar” int,
“Apr” int,
“May” int,
“Jun” int,
“Jul” int,
“Aug” int,
“Sep” int,
“Oct” int,
“Nov” int,
“Dec” int
);
year | Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec
——+——+——+—–+—–+—–+—–+—–+—–+—–+—–+——+——
2007 | 1000 | 1500 |
|
|
|
| 500 |
|
|
| 1500 | 2000
2008 | 1000 |
|
|
|
|
|
|
|
|
|
|
(2 rows)
CREATE
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
TABLE cth(rowid text, rowdt
INTO cth VALUES(‘test1’,’01
INTO cth VALUES(‘test1’,’01
INTO cth VALUES(‘test1’,’01
INTO cth VALUES(‘test2’,’02
INTO cth VALUES(‘test2’,’02
INTO cth VALUES(‘test2’,’02
INTO cth VALUES(‘test2’,’02
timestamp, attribute text, val text);
March 2003’,’temperature’,’42’);
March 2003’,’test_result’,’PASS’);
March 2003’,’volts’,’2.6987’);
March 2003’,’temperature’,’53’);
March 2003’,’test_result’,’FAIL’);
March 2003’,’test_startdate’,’01 March 2003’);
March 2003’,’volts’,’3.1234’);
SELECT * FROM crosstab
(
‘SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1’,
‘SELECT DISTINCT attribute FROM cth ORDER BY 1’
)
AS
(
rowid text,
rowdt timestamp,
temperature int4,
test_result text,
test_startdate timestamp,
volts float8
);
rowid |
rowdt
| temperature | test_result |
test_startdate
| volts
——-+————————–+————-+————-
+————————–+——–
test1 | Sat Mar 01 00:00:00 2003 |
42 | PASS
|
| 2.6987
test2 | Sun Mar 02 00:00:00 2003 |
53 | FAIL
| Sat Mar 01 00:00:00
2003 | 3.1234
(2 rows)
Вы можете создать предопределённые функции, чтобы не выписывать имена и типы результирую-
щих столбцов в каждом запросе. Примеры приведены в предыдущем разделе. Нижележащая функ-
ция C для этой формы crosstab называется crosstab_hash.
2614Дополнительно по-
ставляемые модули
F.38.1.5. connectby
connectby(text relname, text keyid_fld, text parent_keyid_fld
[, text orderby_fld ], text start_with, int max_depth
[, text branch_delim ])
Функция connectby выдаёт отображение данных, содержащихся в таблице, в иерархическом виде.
Таблица должна содержать поле ключа, однозначно идентифицирующее строки, и поле ключа
родителя, ссылающееся на родителя строки (если он есть). Функция connectby может вывести
вложенное дерево, начиная с любой строки.
Параметры описаны в Таблице F.31.
Таблица F.31. Параметры connectby
Параметр Описание
relname Имя исходного отношения
keyid_fld Имя поля ключа
parent_keyid_fld Имя поля, содержащего ключ родителя
orderby_fld Имя поля, по которому сортируются потомки (
необязательно)
start_with Значение ключа отправной строки
max_depth Максимальная глубина, на которую можно по-
грузиться, либо ноль для неограниченного по-
гружения
branch_delim Строка, разделяющая ключи в выводе ветви (
необязательно)
Поля ключа и ключа родителя могут быть любого типа, но должны иметь общий тип. Заметьте, что
значение start_with должно задаваться текстовой строкой, вне зависимости от типа поля ключа.
Функция connectby объявлена как возвращающая setof record, так что фактические имена и типы
выходных столбцов должны определяться в предложении FROM вызывающего оператора SELECT,
например так:
SELECT * FROM connectby(‘connectby_tree’, ‘keyid’, ‘parent_keyid’, ‘pos’, ‘row2’, 0,
‘~’)
AS t(keyid text, parent_keyid text, level int, branch text, pos int);
Первые два выходных столбца используются для вывода ключа текущей строки и ключа её ро-
дителя; их тип должен соответствовать типу поля ключа. Третий выходной столбец задаёт глуби-
ну в дереве и должен иметь тип integer. Если передаётся параметр branch_delim, в следующем
столбце выводятся ветви, и этот столбец должен иметь тип text. Наконец, если передаётся пара-
метр orderby_fld, в последнем столбце выводятся последовательные числа, и он должен иметь
тип integer.
В столбце «branch» показывается путь по ключам, приведший к текущей строке. Ключи разде-
ляются заданной строкой branch_delim. Если выводить ветви не требуется, опустите параметр
branch_delim и столбец branch в списке выходных столбцов.
Если порядок потомков одного родителя имеет значение, добавьте параметр orderby_fld, указы-
вающий поле для упорядочивания потомков. Это поле может иметь любой тип, допускающий сор-
тировку. Список выходных столбцов должен включать последним столбцом целочисленный стол-
бец с последовательными значениями, если и только если передаётся параметр orderby_fld.
Параметры, представляющие имена таблицы и полей, копируются как есть в SQL-запросы, кото-
рые connectby генерирует внутри. Таким образом, их нужно заключить в двойные кавычки, если
они содержат буквы в разном регистре или специальные символы. Также может понадобиться до-
полнить имя таблицы схемой.
2615Дополнительно по-
ставляемые модули
С большими таблицами производительность будет неудовлетворительной, если не создать индекс
по полю с ключом родителя.
Важно, чтобы строка branch_delim не фигурировала в значениях ключа, иначе connectby мо-
жет некорректно сообщить об ошибке бесконечной вложенности. Заметьте, что если параметр
branch_delim не задаётся, для выявления зацикленности применяется символ ~.
Пример:
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
VALUES(‘row1’,NULL, 0);
VALUES(‘row2’,’row1’, 0);
VALUES(‘row3’,’row1’, 0);
VALUES(‘row4’,’row2’, 1);
VALUES(‘row5’,’row2’, 0);
VALUES(‘row6’,’row4’, 0);
VALUES(‘row7’,’row3’, 0);
VALUES(‘row8’,’row6’, 0);
VALUES(‘row9’,’row5’, 0);
– с ветвями без orderby_fld (порядок результатов не гарантируется)
SELECT * FROM connectby(‘connectby_tree’, ‘keyid’, ‘parent_keyid’, ‘row2’, 0, ‘~’)
AS t(keyid text, parent_keyid text, level int, branch text);
keyid | parent_keyid | level |
branch
——-+————–+——-+———————
row2 |
|
0 | row2
row4 | row2
|
1 | row2~row4
row6 | row4
|
2 | row2~row4~row6
row8 | row6
|
3 | row2~row4~row6~row8
row5 | row2
|
1 | row2~row5
row9 | row5
|
2 | row2~row5~row9
(6 rows)
– без ветвей и без orderby_fld (порядок результатов не гарантируется)
SELECT * FROM connectby(‘connectby_tree’, ‘keyid’, ‘parent_keyid’, ‘row2’, 0)
AS t(keyid text, parent_keyid text, level int);
keyid | parent_keyid | level
——-+————–+——-
row2 |
|
0
row4 | row2
|
1
row6 | row4
|
2
row8 | row6
|
3
row5 | row2
|
1
row9 | row5
|
2
(6 rows)
– с ветвями и с orderby_fld (заметьте, что row5 идёт перед row4)
SELECT * FROM connectby(‘connectby_tree’, ‘keyid’, ‘parent_keyid’, ‘pos’, ‘row2’, 0,
‘~’)
AS t(keyid text, parent_keyid text, level int, branch text, pos int);
keyid | parent_keyid | level |
branch
| pos
——-+————–+——-+———————+—–
row2 |
|
0 | row2
|
1
row5 | row2
|
1 | row2~row5
|
2
row9 | row5
|
2 | row2~row5~row9
|
3
row4 | row2
|
1 | row2~row4
|
4
row6 | row4
|
2 | row2~row4~row6
|
5
row8 | row6
|
3 | row2~row4~row6~row8 |
6
2616Дополнительно по-
ставляемые модули
(6 rows)
– без ветвей, с orderby_fld (заметьте, что row5 идёт перед row4)
SELECT * FROM connectby(‘connectby_tree’, ‘keyid’, ‘parent_keyid’, ‘pos’, ‘row2’, 0)
AS t(keyid text, parent_keyid text, level int, pos int);
keyid | parent_keyid | level | pos
——-+————–+——-+—–
row2 |
|
0 |
1
row5 | row2
|
1 |
2
row9 | row5
|
2 |
3
row4 | row2
|
1 |
4
row6 | row4
|
2 |
5
row8 | row6
|
3 |
6
(6 rows)
F.38.2. Автор
Джо Конвей
F.39. tcn
Модуль tcn предлагает триггерную функцию, уведомляющую приёмники уведомлений об измене-
ниях в любой таблице, к которой привязан триггер. Она должна использоваться в качестве триг-
гера AFTER вида FOR EACH ROW.
Этой функции в операторе CREATE TRIGGER передаётся только один параметр, и он не является
обязательным. Если этот параметр присутствует, он задаёт имя канала для уведомлений. В случае
его отсутствия именем канала будет tcn.
Сообщение уведомления включает имя таблицы, букву, обозначающую тип выполняемой операции
и пары имя столбца/значение для столбца первичного ключа. Каждая часть сообщения отделяет-
ся от следующей запятой. Для упрощения разбора сообщения регулярными выражениями имена
таблицы и столбцов всегда заключаются в двойные кавычки, а значения данных — в апострофы.
Внутренние кавычки и апострофы дублируются.
Далее приведена краткая демонстрация использования расширения.
test=# create table tcndata
test-#
(
test(#
a int not null,
test(#
b date not null,
test(#
c text,
test(#
primary key (a, b)
test(#
);
CREATE TABLE
test=# create trigger tcndata_tcn_trigger
test-#
after insert or update or delete on tcndata
test-#
for each row execute function triggered_change_notification();
CREATE TRIGGER
test=# listen tcn;
LISTEN
test=# insert into tcndata values (1, date ‘2012-12-22’, ‘one’),
test-#
(1, date ‘2012-12-23’, ‘another’),
test-#
(2, date ‘2012-12-23’, ‘two’);
INSERT 0 3
Asynchronous notification “tcn” with payload ““tcndata”,I,”a”=’1’,”b”=’2012-12-22’”
received from server process with PID 22770.
Asynchronous notification “tcn” with payload ““tcndata”,I,”a”=’1’,”b”=’2012-12-23’”
received from server process with PID 22770.
2617Дополнительно по-
ставляемые модули
Asynchronous notification “tcn” with payload ““tcndata”,I,”a”=’2’,”b”=’2012-12-23’”
received from server process with PID 22770.
test=# update tcndata set c = ‘uno’ where a = 1;
UPDATE 2
Asynchronous notification “tcn” with payload ““tcndata”,U,”a”=’1’,”b”=’2012-12-22’”
received from server process with PID 22770.
Asynchronous notification “tcn” with payload ““tcndata”,U,”a”=’1’,”b”=’2012-12-23’”
received from server process with PID 22770.
test=# delete from tcndata where a = 1 and b = date ‘2012-12-22’;
DELETE 1
Asynchronous notification “tcn” with payload ““tcndata”,D,”a”=’1’,”b”=’2012-12-22’”
received from server process with PID 22770.
F.40. test_decoding
Модуль test_decoding представляет пример модуля вывода логического декодирования. Он не де-
лает ничего особенно полезного, но может послужить отправной точкой для разработки собствен-
ного модуля вывода.
Модуль test_decoding получает WAL через механизм логического декодирования и переводит его
в текстовое представление выполняемых операций.
Типичный вывод этого модуля, работающего через интерфейс логического декодирования SQL,
может выглядеть так:
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘test_slot’, NULL, NULL, ‘include-
xids’, ‘0’);
lsn
| xid |
data
———–+—–+————————————————–
0/16D30F8 | 691 | BEGIN
0/16D32A0 | 691 | table public.data: INSERT: id[int4]:2 data[text]:’arg’
0/16D32A0 | 691 | table public.data: INSERT: id[int4]:3 data[text]:’demo’
0/16D32A0 | 691 | COMMIT
0/16D32D8 | 692 | BEGIN
0/16D3398 | 692 | table public.data: DELETE: id[int4]:2
0/16D3398 | 692 | table public.data: DELETE: id[int4]:3
0/16D3398 | 692 | COMMIT
(8 rows)
F.41. tsm_system_rows
Модуль tsm_system_rows предоставляет метод извлечения выборки SYSTEM_ROWS, который можно
использовать в предложении TABLESAMPLE команды SELECT.
Этот метод извлечения выборки принимает один целочисленный аргумент, задающий максималь-
ное число выбираемых строк. Результирующая выборка будет содержать в точности столько строк,
если только в таблице не оказывается меньше заданного числа строк (в этом случае выдаётся вся
таблица).
Как и встроенный метод извлечения выборки SYSTEM, SYSTEM_ROWS производит выборку на уровне
блоков, так что выборка будет не полностью случайной, а может подвергаться эффектам класте-
ризации, особенно когда запрашивается небольшое число строк.
SYSTEM_ROWS не поддерживает предложение REPEATABLE.
F.41.1. Примеры
Пример получения выборки из таблицы с применением метода SYSTEM_ROWS. Сначала нужно уста-
новить расширение:
2618Дополнительно по-
ставляемые модули
CREATE EXTENSION tsm_system_rows;
Затем вы можете использовать его в команде SELECT, например так:
SELECT * FROM my_table TABLESAMPLE SYSTEM_ROWS(100);
Эта команда выдаст выборку из 100 строк из таблицы my_table (а если в таблице не окажется 100
видимых строк, будут возвращены все строки).
F.42. tsm_system_time
Модуль tsm_system_time предоставляет метод извлечения выборки SYSTEM_TIME, который можно
использовать в предложении TABLESAMPLE команды SELECT.
Этот метод извлечения выборки принимает в единственном аргументе число с плавающей точкой,
задающее максимальное время (в миллисекундах), которое отводится на чтение таблицы. Это да-
ёт возможность непосредственно управлять длительностью выполнения запроса, ценой того, что
размер выборки оказывается трудно предсказуемым. Результирующая выборка будет содержать
столько строк, сколько удастся прочитать за отведённое время, если только быстрее не будет про-
читана вся таблица.
Как и встроенный метод извлечения выборки SYSTEM, SYSTEM_TIME производит выборку на уровне
блоков, так что выборка будет не полностью случайной, а может подвергаться эффектам класте-
ризации, особенно когда выбирается небольшое число строк.
SYSTEM_TIME не поддерживает предложение REPEATABLE.
F.42.1. Примеры
Пример получения выборки из таблицы с применением метода SYSTEM_TIME. Сначала нужно уста-
новить расширение:
CREATE EXTENSION tsm_system_time;
Затем вы можете использовать его в команде SELECT, например так:
SELECT * FROM my_table TABLESAMPLE SYSTEM_TIME(1000);
Эта команда выдаст настолько большую выборку из my_table, насколько много строк она успеет
прочитать за 1 секунду (1000 миллисекунд). Разумеется, если за 1 секунду удастся прочитать всю
таблицу, будут возвращены все её строки.
F.43. unaccent
Модуль unaccent представляет словарь текстового поиска, который убирает надстрочные (диакри-
тические) знаки из лексем. Это фильтрующий словарь, что значит, что выводимые им данные все-
гда передаются следующему словарю (если он есть), в отличие от нормальных словарей. Применяя
его, можно выполнить полнотекстовый поиск без учёта ударений (диакритики).
Текущую реализацию unaccent нельзя использовать в качестве нормализующего словаря для сло-
варя thesaurus.
F.43.1. Конфигурирование
Словарь unaccent принимает следующие параметры:
• Параметр RULES задаёт базовое имя файла со списком правил преобразования. Этот файл дол-
жен находиться в каталоге $SHAREDIR/tsearch_data/ (где под $SHAREDIR понимается каталог
с общими данными инсталляции PostgreSQL). Имя файла должно заканчиваться расширением
.rules (которое не нужно указывать в параметре RULES).
Файл правил имеет следующий формат:
2619Дополнительно по-
ставляемые модули
• Каждая строка представляет одно правило перевода, состоящее из символа с диакритикой, за
которым следует символ без диакритики. Первый символ переводится во второй. Например,
À
Á
Â
Ã
Ä
Å
Æ
A
A
A
A
A
A
AE
Эти два символа должны разделяться пробельным символом, а любые начальные или конеч-
ные пробельные символы в этой строке игнорируются.
• В качестве альтернативного варианта, если в строке задан всего один символ, вхождения это-
го символа будут удаляться; это полезно для языков, в которых диакритика представляется
отдельными символами.
• На самом деле роль «символа» может играть любая строка, не содержащая пробельные сим-
волы, так что словари unaccent могут быть полезны и для другого рода замены подстрок, а не
только для удаления диакритик.
• Как и другие файлы конфигурации текстового поиска в PostgreSQL, файл правил должен
иметь кодировку UTF-8. При загрузке данные из него будут автоматически преобразованы
в кодировку текущей базы данных. Все строки в нём, содержащие непереводимые символы,
просто игнорируются, так что файлы правил могут содержать правила, неприменимые в теку-
щей кодировке.
Более полный набор правил, непосредственно пригодный для большинства европейских языков,
можно найти в файле unaccent.rules, который помещается в $SHAREDIR/tsearch_data/, когда
устанавливается модуль unaccent. Этот файл правил переводит буквы с диакритикой в те же бук-
вы без диакритики, а также разворачивает лигатуры в равнозначные последовательности простых
символов (например, Æ в AE).
F.43.2. Использование
При установке расширения unaccent в базе создаётся шаблон текстового поиска unaccent
и словарь unaccent на его основе. Для словаря unaccent по умолчанию определяется пара-
метр RULES=’unaccent’, благодаря чему его можно сразу использовать со стандартным файлом
unaccent.rules. При желании вы можете изменить этот параметр, например, так
mydb=# ALTER TEXT SEARCH DICTIONARY unaccent (RULES=’my_rules’);
или создать новые словари на основе этого шаблона.
Протестировать этот словарь можно так:
mydb=# select ts_lexize(‘unaccent’,’Hôtel’);
ts_lexize
———–
(Hotel)
(1 row)
Следующий пример показывает, как вставить словарь unaccent в конфигурацию текстового поис-
ка:
mydb=# CREATE TEXT SEARCH CONFIGURATION fr ( COPY = french );
mydb=# ALTER TEXT SEARCH CONFIGURATION fr
ALTER MAPPING FOR hword, hword_part, word
WITH unaccent, french_stem;
mydb=# select to_tsvector(‘fr’,’Hôtels de la Mer’);
to_tsvector
——————-
‘hotel’:1 ‘mer’:4
2620Дополнительно по-
ставляемые модули
(1 row)
mydb=# select to_tsvector(‘fr’,’Hôtel de la Mer’) @@ to_tsquery(‘fr’,’Hotels’);
?column?
———-
t
(1 row)
mydb=# select ts_headline(‘fr’,’Hôtel de la Mer’,to_tsquery(‘fr’,’Hotels’));
ts_headline
————————
<b>Hôtel</b> de la Mer
(1 row)
F.43.3. Функции
Функция unaccent() удаляет надстрочные (диакритические) знаки из заданной строки. По сути
она представляет собой обёртку вокруг словарей в стиле unaccent, но может вызываться и вне
обычного контекста текстового поиска.
unaccent([словарь regdictionary,] строка text) returns text
Если аргумент словарь опущен, будет использоваться словарь с именем unaccent, находящийся в
той же схеме, что и сама функция unaccent().
Пример:
SELECT unaccent(‘unaccent’, ‘Hôtel’);
SELECT unaccent(‘Hôtel’);
F.44. uuid-ossp
Модуль uuid-ossp предоставляет функции для генерирования универсальных уникальных иденти-
фикаторов (UUID) по одному из нескольких стандартных алгоритмов. В нём также есть функции,
выдающие специальные UUID-константы.
F.44.1. Функции uuid-ossp
В Таблице F.32 показаны функции, предназначенные для генерации UUID. Четыре алгоритма для
генерации UUID, обозначаемые номерами версий 1, 3, 4 и 5, описаны в стандартах ITU-T Rec. X.667,
ISO/IEC 9834-8:2005 и RFC 4122. (Алгоритма версии 2 нет.) Каждый из этих алгоритмов предна-
значен для различных сфер применения.
Таблица F.32. Функции для генерирования UUID
Функция Описание
uuid_generate_v1() Эта функция генерирует UUID версии 1. Такой
UUID включает в себя MAC-адрес компьютера и
текущее время. Заметьте, что UUID такого типа
раскрывают «личность» компьютера, создавше-
го идентификатор, и время этой операции, что
может быть неприемлемым для определённых
приложений, где важна конфиденциальность.
uuid_generate_v1mc() Эта функция генерирует UUID версии 1, но вме-
сто реального MAC-адреса компьютера исполь-
зуется случайный групповой MAC-адрес.
uuid_generate_v3(namespace
text)
uuid,
Эта функция генерирует UUID версии 3 для за-
данного пространства имён UUID и указанного
имени. Пространство имён должно задаваться
name
2621Дополнительно по-
ставляемые модули
Функция
Описание
одной из специальных констант, которые выда-
ются функциями uuid_ns</em>*()
, перечислен-
ными в Таблице F.33. (Хотя теоретически это мо-
жет быть любой UUID.) Имя задаёт идентифика-
тор в выбранном пространстве имён.
Например:
SELECT uuid_generate_v3(uuid_ns_url(),
‘http://www.postgresql.org’);
Из параметра name будет получен MD5-хеш, так
что из сгенерированного UUID нельзя будет вос-
становить имя. В генерируемых таким алгорит-
мом UUID нет элемента случайности или зави-
симости от окружения, так что они могут быть
воспроизведены.
Эта функция генерирует UUID версии 4, кото-
рый всецело определяется случайными числа-
ми.
uuid_generate_v4()
uuid_generate_v5(namespace
text)
uuid,
Эта функция генерирует UUID версии 5, кото-
рый похож на версию 3, но хеш рассчитывает-
ся по алгоритму SHA-1. Версия 5 предпочтитель-
нее версии 3, так как SHA-1 считается более без-
опасным, чем MD5.
name
Таблица F.33. Функции, возвращающие UUID-константы
uuid_nil() «Нулевой» UUID, который не считается действи-
тельным UUID.
uuid_ns_dns() Константа, обозначающая пространство имён
DNS для UUID.
uuid_ns_url() Константа, обозначающая пространство имён
URL для UUID.
uuid_ns_oid() Константа, обозначающая пространство имён
идентификаторов объектов ISO (OID, ISO Object
Identifier) для UUID. (Здесь имеются в виду иден-
тификаторы объектов ASN.1, которые никак не
связаны с OID, применяемыми в PostgreSQL.)
uuid_ns_x500() Константа, обозначающая пространство имён с
уникальными именами X.500 для UUID.
F.44.2. Сборка uuid-ossp
В прошлом этот модуль зависел от библиотеки OSSP UUID, что отразилось в его имени. Хотя биб-
лиотеку OSSP UUID всё ещё можно найти по адресу http://www.ossp.org/pkg/lib/uuid/, она плохо под-
держивается и её становится всё сложнее портировать на новые платформы. Поэтому модуль uuid-
ossp теперь на некоторых платформах можно собирать без библиотеки OSSP. Во FreeBSD, NetBSD
и некоторых других ОС на базе BSD подходящие функции формирования UUID включены в систем-
ную библиотеку libc. В Linux, macOS и некоторых других платформах подходящие функции предо-
ставляются библиотекой libuuid, которая изначально пришла из проекта e2fsprogs (хотя в совре-
менных дистрибутивах Linux она является частью пакета util-linux-ng). Вызывая configure, пе-
редайте ключ –with-uuid=bsd, чтобы использовать функции BSD, либо –with-uuid=e2fs, чтобы
использовать libuuid из e2fsprogs, либо ключ –with-uuid=ossp, чтобы использовать библиотеку
OSSP UUID. В конкретной системе может быть установлено сразу несколько библиотек, поэтому
configure не выбирает библиотеку автоматически.
2622Дополнительно по-
ставляемые модули
Примечание
Если вам нужны только случайные UUID (версии 4), в качестве альтернативы вы мо-
жете использовать функцию gen_random_uuid() из модуля pgcrypto.
F.44.3. Автор
Питер Эйзентраут <a href="mailto:peter_e@gmx.net">peter_e@gmx.net</a>
F.45. xml2
Модуль xml2 предоставляет функции для выполнения запросов XPath и преобразований XSLT.
F.45.1. Уведомление об актуальности
Начиная с PostgreSQL 8.3, функциональность, связанная с XML, основана на стандарте SQL/XML
и включена в ядро сервера. Эта функциональность охватывает проверку синтаксиса XML и запро-
сы XPath, что в частности делает и этот модуль, но он имеет абсолютно несовместимый API. Этот
модуль планируется удалить в будущей версии PostgreSQL в пользу нового стандартного API, так
что мы рекомендуем вам попробовать перевести свои приложения на новый API. Если вы обнару-
жите, что какая-то функциональность этого модуля не представлена новым API в подходящей фор-
ме, пожалуйста, напишите о вашем затруднении в <a href="mailto:pgsql-hackers@postgresql.org">pgsql-hackers@postgresql.org</a>, чтобы этот
недостаток был рассмотрен и, возможно, устранён.
F.45.2. Описание функций
Функции, предоставляемые этим модулем, перечислены в Таблице F.34. Эти функции позволяют
выполнять простой разбор XML и запросы XPath. Все их аргументы имеют тип text, поэтому для
краткости типы опущены.
Таблица F.34. Функции
Функция Возвращает Описание
xml_valid(document) bool Эта функция разбирает текст
документа, переданный в пара-
метре, и возвращает true, ес-
ли это правильно сформиро-
ванный XML. (Замечание: это
псевдоним стандартной функ-
ции PostgreSQL xml_is_well_
formed() . Имя xml_valid(
) технически некорректно, так
как понятия правильности фор-
мата (well-formed) и допустимо-
сти (valid) в XML различаются.)
xpath_string(document,
query) text xpath_number(document,
query) float4 Эти функции обрабатывают за-
прос XPath для переданного до-
кумента и приводят результат к
указанному типу.
xpath_bool(document,
query) bool xpath_nodeset(document,
query, toptag, itemtag) text
Эта функция обрабатывает за-
прос для документа и помещает
результат внутрь XML-тегов. Ес-
ли результат содержит несколь-
ко значений, она выдаст:
2623Дополнительно по-
ставляемые модули
Функция
Возвращает
Описание</p>
        </blockquote>
      </li>
    </ol>
  </li>
</ul>
<toptag>
<itemtag>Значение 1, которое
может быть фрагментом XML&lt;/
itemtag&gt;
<itemtag>Значение 2....&lt;/
itemtag&gt;
&lt;/toptag&gt;
Если toptag или itemtag — пу-
стая строка, соответствующий
тег опускается.
xpath_nodeset(document,
query) text Подобна
xpath_nodeset(
document, query, toptag,
itemtag) , но выводит резуль-
тат без обоих тегов.
xpath_nodeset(document,
query, itemtag) text Подобна
xpath_nodeset(
document, query, toptag,
itemtag) , но выводит резуль-
тат без toptag.
xpath_list(document,
query, separator) text Эта
функция
возвращает
несколько значений, вставляя
между ними заданный раздели-
тель, например: Значение 1,
Значение 2,Значение 3 , если
разделитель — знак , .
xpath_list(document,
query) text Это обёртка предыдущей функ-
ции, устанавливающая в каче-
стве разделителя знак , .
F.45.3. xpath_table
xpath_table(text key, text document, text relation, text xpaths, text criteria) returns
setof record
Табличная функция xpath_table выполняет набор запросов XPath для каждого из набора докумен-
тов и возвращает результаты в виде таблицы. В первом столбце результата возвращается первич-
ный ключ из таблицы документов, так что результат оказывается готовым к применению в соеди-
нениях. Параметры функции описаны в Таблице F.35.
Таблица F.35. Параметры xpath_table
Параметр Описание
key имя «ключевого» поля — содержимое этого по-
ля просто окажется в первом столбце выходной
таблицы, то есть оно указывает на запись, из
которой была получена определённая выходная
строка (см. замечание о нескольких значениях
ниже)
document имя поля, содержащего XML-документ
relation имя таблицы (или представления), содержащей
документы
xpaths одно или несколько выражений XPath, разделён-
ных символом |
criteria содержимое предложения WHERE. Оно не мо-
жет быть пустым, так что если вам нужно обра-
2624Дополнительно по-
ставляемые модули
Параметр
Описание
ботать все строки в отношении, напишите true
или 1=1
Эти параметры (за исключением строк XPath) просто подставляются в обычный оператор SQL
SELECT, так что у вас есть определённая гибкость — оператор выглядит так:
SELECT <key>, <document> FROM <relation> WHERE <criteria>
поэтому в этих параметрах можно передать всё, что будет корректно воспринято в этих позициях.
Этот SELECT должен возвращать ровно два столбца (что и будет иметь место, если только вы не
перечислите несколько полей в параметрах key или document). Будьте осторожны — при таком
примитивном подходе обязательно нужно проверять все значения, получаемые от пользователя,
во избежание атак с инъекцией SQL.
Эта функция предназначена для использования в выражении FROM, с предложением AS, задающим
выходные столбцы; например:
SELECT * FROM
xpath_table('article_id',
'article_xml',
'articles',
'/article/author|/article/pages|/article/title',
'date_entered &gt; ''2003-01-01'' ')
AS t(article_id integer, author text, page_count integer, title text);
Предложение AS определяет имена и типы столбцов в выходной таблице. Первым определяется
«ключевое» поле, а за ним поля, соответствующие запросам XPath. Если запросов XPath боль-
ше, чем столбцов в результате, лишние запросы будут игнорироваться. Если же результирующих
столбцов больше, чем запросов XPath, дополнительные столбцы принимают значение NULL.
Заметьте, что в этом примере столбец результата page_count определён как целочисленный. Дан-
ная функция внутри имеет дело со строковыми значениями, так что, когда вы указываете, что в
результате нужно получить целое число, она берёт текстовое представление результата XPath и,
применяя функции ввода PostgreSQL, преобразует её в целое число (или в тот тип, который указан
в предложении AS). Если она не сможет сделать это, произойдёт ошибка — например, если резуль-
тат пустой — так что если вы допускаете возможность таких проблем с данными, возможно, будет
лучше просто оставить для столбца тип text.
Вызывающий оператор SELECT не обязательно должен быть простым SELECT * — он может обра-
щаться к выходным столбцам по именам и соединять их с другими таблицами. Эта функция форми-
рует виртуальную таблицу, с которой вы можете выполнять любые операции, какие пожелаете (на-
пример, агрегировать, соединять, сортировать данные и т. д.). Поэтому возможен и такой запрос:
SELECT t.title, p.fullname, p.email
FROM xpath_table('article_id', 'article_xml', 'articles',
'/article/title|/article/author/@id',
'xpath_string(article_xml,''/article/@date'') &gt; ''2003-03-20'' ')
AS t(article_id integer, title text, author_id integer),
tblPeopleInfo AS p
WHERE t.author_id = p.person_id;
в качестве более сложного примера. Разумеется, для удобства вы можете завернуть весь этот за-
прос в представление.
F.45.3.1. Результаты с набором значений
Функция xpath_table рассчитана на то, что результатом каждого запроса XPath может быть набор
данных, так что количество возвращённых этой функцией строк может не совпадать с количеством
входных документов. В первой строке возвращается первый результат каждого запроса, во второй
2625Дополнительно по-
ставляемые модули
— второй результат и т. д. Если один из запросов возвращает меньше значений, чем другие, вместо
недостающих значений будет возвращаться NULL.
В некоторых случаях пользователь знает, что некоторый запрос XPath будет возвращать только
один результат (возможно, уникальный идентификатор документа) — если он используется рядом
с запросом XPath, возвращающим несколько результатов, результат с одним значением будет вы-
веден только в первой выходной строке. Чтобы исправить это, можно воспользоваться полем клю-
ча и соединить результат с более простым запросом XPath. Например:
CREATE TABLE test (
id int PRIMARY KEY,
xml text
);
INSERT INTO test VALUES (1, '<doc num="C1">
<line num="L1"><a>1</a><b>2</b><c>3</c></line>
<line num="L2"><a>11</a><b>22</b><c>33</c></line>
</doc>');
INSERT INTO test VALUES (2, '<doc num="C2">
<line num="L1"><a>111</a><b>222</b><c>333</c></line>
<line num="L2"><a>111</a><b>222</b><c>333</c></line>
</doc>');
SELECT * FROM
xpath_table('id','xml','test',
'/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
'true')
AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int, val2 int, val3 int)
WHERE id = 1 ORDER BY doc_num, line_num
id | doc_num | line_num | val1 | val2 | val3
----+---------+----------+------+------+------
1 | C1
| L1
|
1 |
2 |
3
1 |
| L2
|
11 |
22 |
33
Чтобы получить doc_num в каждой строке, можно вызывать xpath_table дважды и соединить ре-
зультаты:
SELECT t.*,i.doc_num FROM
xpath_table('id', 'xml', 'test',
'/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
'true')
AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),
xpath_table('id', 'xml', 'test', '/doc/@num', 'true')
AS i(id int, doc_num varchar(10))
WHERE i.id=t.id AND i.id=1
ORDER BY doc_num, line_num;
id | line_num | val1 | val2 | val3 | doc_num
----+----------+------+------+------+---------
1 | L1
|
1 |
2 |
3 | C1
1 | L2
|
11 |
22 |
33 | C1
(2 rows)
F.45.4. Функции XSLT
Если установлена libxslt, доступны следующие функции:
F.45.4.1. xslt_process
2626Дополнительно по-
ставляемые модули
xslt_process(text document, text stylesheet, text paramlist) returns text
Эта функция применяет стиль XSL к документу и возвращает результат преобразования. В
paramlist передаётся список присвоений значений параметрам, которые будут использоваться в
преобразовании, в форме a=1,b=2. Учтите, что разбор параметров выполнен очень просто: значе-
ния параметров не могут содержать запятые!
Есть также версия xslt_process с двумя аргументами, которая не передаёт никакие параметры
преобразованию.
F.45.5. Автор
Джон Грей &lt;jgray@azuli.co.uk&gt;
Разработку этого модуля спонсировала компания Torchbox Ltd. (www.torchbox.com). Этот модуль
выпускается под той же лицензией BSD, что и PostgreSQL.
2627
</criteria></relation></document></key></itemtag></itemtag></toptag>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Приложение E. Замечания к выпуску"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~375 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" rel="bookmark" title="Приложение E. Замечания к выпуску" itemprop="url">Приложение E. Замечания к выпуску</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Приложение E. Замечания к выпуску</p>

<p>В замечаниях к выпуску отмечаются значительные изменения, имевшие место в каждом выпуске
PostgreSQL, при этом ключевые изменения и вопросы миграции освещаются в самом начале. В
эти замечания не включаются изменения, затрагивающие лишь нескольких пользователей, как
и изменения внутренние и поэтому пользователям не заметные. Например, оптимизатор усовер-
шенствуется почти в каждом выпуске, но для пользователей эти улучшения проявляются обычно
просто в ускорении запросов.
Полный список изменений каждого выпуска можно получить, просмотрев журналы Git для этого
выпуска. Также все изменения в исходном коде отражаются в списке рассылки pgsql-committers.
Кроме того, имеется веб-интерфейс, в котором можно просмотреть изменения в разрезе файлов.
Имя, указанное рядом с каждым пунктом, показывает, кто был основным разработчиком этого из-
менения. Но, конечно, с каждым из изменений связано обсуждение в сообществе и анализ пред-
лагаемой правки, так что на самом деле каждый из этих пунктов — плод работы сообщества.
E.1. Выпуск 11.1
Дата выпуска:
2018-11-08
В этот выпуск вошли различные исправления, внесённые после версии 11.0. За информацией о
нововведениях версии 11 обратитесь к Разделу E.2.
E.1.1. Миграция на версию 11.1
Если используется версия 11.X, выгрузка/восстановление базы не требуется.
Однако если вы используете расширение pg_stat_statements, прочитайте запись о нём в списке
изменений.
E.1.2. Изменения
• Корректное заключение в кавычки имён переходных таблиц в командах CREATE TRIGGER …
REFERENCING, которые выдаёт pg_dump (Том Лейн)
Отсутствием кавычек мог воспользоваться непривилегированный пользователь с целью полу-
чения прав суперпользователя при последующем восстановлении выгруженных данных или
выполнении pg_upgrade. (CVE-2018-16850)
• Размещение создаваемого дочернего индекса в табличном пространстве, выбранном для сек-
ционированного индекса (Альваро Эррера)
Ранее дочерние индексы всегда создавались в табличном пространстве по умолчанию.
• Исправление обработки NULL при выполнении распараллеливаемых многопакетных левых со-
единений по хешу (Эндрю Гирт, Томас Мунро)
Ранее строки внешнего отношения, содержащие значения NULL в ключе хеширования, не по-
падали в результат соединения.
• Исправление некорректной обработки выражения, содержащего приведение типа к масси-
ву, внутри предложения CASE, в котором проверяемое выражение является константой (Том
Лейн)
• Исправление некорректного расширения кортежей, не содержащих недавно добавленных
столбцов (Эндрю Дунстан, Амит Ланготе)
В результате этого дефекта наблюдался крах сервера в коде триггера таблицы, в которую до-
бавлялись столбцы; однако были возможны и другие проявления.
• Исправление ошибок в обработке аргументов с именами или значениями по умолчанию, пере-
даваемых в списке аргументов команде CALL (Том Лейн, Павел Стехуле)
2277Замечания к выпуску
• Исправление проверки строгости для агрегатов со столбцами ORDER BY (Эндрю Гирт, Андрес
Фройнд)
Логика проверки строгости функции ошибочно игнорировала строки, в которых значения
столбцов ORDER BY были равны NULL.
• Отключение оптимизации recheck_on_update (Том Лейн)
Эта появившаяся в 11 версии функциональность оказалась не готовой к публичному выступ-
лению. Поэтому решено было её убрать, пока она не будет исправлена.
• Недопущение создания секции в триггере, присоединённом к родительской таблице (Амит
Ланготе)
В идеале такое создание можно было бы разрешить, но в данный момент оно блокируется во
избежание сбоев.
• Устранение проблем с применением ON COMMIT DELETE ROWS к секционированной временной
таблице (Амит Ланготе)
• Исправление проверок классов символов для корректной поддержки в Windows символов
Unicode выше U+FFFF (Том Лейн, Кэндзи Уно)
Эта ошибка проявлялась в операциях полнотекстового поиска, а также в работе модулей
contrib/ltree и contrib/pg_trgm.
• Обеспечение обработки сервером уже полученных прерываний NOTIFY и SIGTERM до начала
ожидания данных от клиента (Джефф Джейнс, Том Лейн)
• Ликвидация утечки памяти при сканировании индекса SP-GiST (Том Лейн)
Сколько-нибудь значительное проявление этой утечки наблюдалось, только когда для ограни-
чения-исключения, использующего SP-GiST, в индекс поступало много записей.
• Предотвращение запуска сервера со значением wal_level, недостаточно большим для под-
держки существующего слота репликации (Андрес Фройнд)
• Исправление кода psql, а также примеров в документации, чтобы функция PQconsumeInput()
вызывалась перед PQnotifies() (Том Лейн)
Тем самым решена проблема, когда psql не выдавал полученное сообщение NOTIFY до следую-
щей команды.
• Исправление в pg_verify_checksums выбора файлов для проверки контрольных сумм (Микаэль
Пакье)
В некоторых случаях несоответствие контрольной суммы выявлялось в тех файлах, в которых
она не должна проверяться.
• В contrib/pg_stat_statements роли pg_read_all_stats запрещено выполнение
pg_stat_statements_reset() (Харибабу Комми)
Роли pg_read_all_stats должно позволяться только чтение статистики, но не её изменение,
поэтому разрешение на выполнение этой функции ей было дано некорректно.
Чтобы это изменение вступило в силу, выполните ALTER EXTENSION pg_stat_statements
UPDATE в каждой базе данных, где установлено расширение pg_stat_statements. (Для баз дан-
ных, изначально созданных в версии 11.0, это не должно требоваться, но базы, обновлённые
с предыдущей версии, могут содержать старую версию pg_stat_statements. Если модуль был
обновлён ранее, команда UPDATE не сделает ничего.)
• Переход в названиях функций поддержки red-black tree (красно-чёрного дерева) от префикса
rb к rbt (Том Лейн)
Это позволяет избежать конфликта имён с функциями Ruby, нарушающего работу PL/Ruby. Хо-
чется надеяться, что в результате не пострадают другие расширения.
2278Замечания к выпуску
• Устранение проблем при сборке в macOS 10.14 (Mojave) (Том Лейн)
Усовершенствование скрипта configure, чтобы в CPPFLAGS добавлялся ключ -isysroot; без
этого PL/Perl и PL/Tcl нельзя сконфигурировать или собрать в macOS 10.14. Значение sysroot
можно переопределить во время конфигурирования или сборки, установив переменную
PG_SYSROOT в аргументах configure или make.
Теперь рекомендуется, чтобы для связанных с Perl расширений во флагах компилятора указы-
валось $(perl_includespec), а не -I$(perl_archlibexp)/CORE. Второй вариант по-прежнему
будет работать на большинстве платформ, но не в последних macOS.
Также теперь не требуется указывать вручную ключ –with-tclconfig, чтобы собрать PL/Tcl в
последних версиях macOS.
• Исправление скриптов сборки с MSVC и регрессионного тестирования для работы с последни-
ми версиями Perl (Эндрю Дунстан)
Это изменение вызвано тем, что Perl теперь по умолчанию не включает текущий каталог в
свой путь поиска.
• Реализована возможность запускать регрессионные тесты в Windows с учётной записью адми-
нистратора (Эндрю Дунстан)
Чтобы это было безопасно, pg_regress теперь лишает себя расширенных прав при запуске.
• Обновление данных часовых поясов до версии tzdata 2018g, включающее изменений правил
перехода на летнее время в России (Волгограде), Чили, Марокко и на Фиджи, а также коррек-
тировку исторических данных для Китая, Гавайев, Японии, Макао и Северной Кореи.
E.2. Выпуск 11
Дата выпуска:
2018-10-18
E.2.1. Обзор
В число ключевых усовершенствований PostgreSQL 11 входят:
• Усовершенствования, связанные с секционированием:
• Реализована поддержка секционирования по хешу
• Реализована поддержка ключей PRIMARY KEY, FOREIGN KEY, индексов и триггеров в секцио-
нированных таблицах
• Добавлена возможность создания секции по умолчанию, содержащей строки, не попадаю-
щие ни в одну другую секцию
• При изменении операторами UPDATE значений ключа разбиения в строках секционирован-
ной таблицы эти строки теперь будут переноситься в соответствующие секции
• Улучшена производительность SELECT благодаря стратегиям оптимизированного устране-
ния секций при планировании и выполнении запросов
• Усовершенствования, связанные с распараллеливанием:
• Команда CREATE INDEX теперь может строить индекс-B-дерево параллельно
• Стало возможным параллельное выполнение CREATE TABLE .. AS, CREATE MATERIALIZED
VIEW и некоторых запросов с UNION
• Распараллеливаемые соединения по хешу и распараллеливаемые последовательные скани-
рования теперь выполняются эффективнее
• Хранимые процедуры на SQL, поддерживающие внутренние транзакции
• Возможность JIT-компиляции некоторого кода SQL, позволяющая ускорить вычисление выра-
жений
2279Замечания к выпуску
• Оконные функции теперь поддерживают все варианты описания рамки, определённые в стан-
дарте SQL:2011, включая RANGE смещение PRECEDING/FOLLOWING, режим GROUPS и рамки с ис-
ключением
• Возможность создания покрывающих индексов, которые определяются предложением
INCLUDE команды CREATE INDEX
• Много других улучшений, увеличивающих производительность, в частности возможность
избежать перезаписи таблицы при выполнении ALTER TABLE .. ADD COLUMN с отличным от
NULL значением по умолчанию
Предыдущие пункты более подробно описаны в следующих разделах.
E.2.2. Миграция на версию 11
Тем, кто хочет мигрировать данные из любой предыдущей версии, необходимо выполнить выгруз-
ку/загрузку данных с помощью pg_dumpall или воспользоваться pg_upgrade.
В версии 11 реализован ряд изменений, которые могут повлиять на совместимость с предыдущими
выпусками. Рассмотрите следующие несовместимые аспекты:
• pg_dump теперь выгружает и свойства базы данных, а не только её содержимое (Харибабу
Комми)
Ранее такие атрибуты базы данных, как разрешения GRANT/REVOKE уровня базы данных и на-
значения переменных ALTER DATABASE SET, выгружались только утилитой pg_dumpall. Теперь
при выполнении pg_dump –create и pg_restore –create в дополнение к объектам базы бу-
дут восстанавливаться и такие её свойства. При этом pg_dumpall -g будет выводить только
атрибуты, связанные с ролями и табличными пространствами. Содержимое полного вывода
pg_dumpall (без -g) не изменилось.
Команды pg_dump и pg_restore без ключа –create теперь не выгружают/не восстанавливают
комментарии на уровне базы и метки безопасности; эти атрибуты теперь считаются свойства-
ми базы данных.
При восстановлении вывода pg_dumpall теперь базы данных всегда должны восстанавливаться
с исходными локалями и кодировками, и поэтому, если локаль или кодировка окажется неиз-
вестной в целевой системе, произойдёт ошибка. Ранее команда CREATE DATABASE выдавалась
без таких указаний, если локаль и кодировка базы данных не отличались от установленных по
умолчанию в старом кластере.
pg_dumpall –clean теперь позволяет восстановить исходные параметры локали и кодировки
для баз данных postgres и template1, а не только для баз, создаваемых пользователями.
• Неоднозначность между вызовом функции и обращением к столбцу теперь разрешается с учё-
том синтаксической формы (Том Лейн)
В предположении, что x — имя таблицы или составного столбца, PostgreSQL традиционно
считал синтаксические формы f(x) и x.f равнозначными. Это позволяло использовать такие
приёмы, как вызов специально написанной функции в виде обращения к вычисляемому столб-
цу. Однако в случаях, допускающих оба прочтения, ранее всегда выбиралось прочтение столб-
ца, что приводило к неожиданным результатам, когда пользователь намеревался именно вы-
звать функцию. Теперь в случае подобной неоднозначности прочтение выбирается в зависи-
мости от синтаксической формы.
• Строгое требование уникальности для имён ограничений таблиц и доменов (Том Лейн)
PostgreSQL ожидает, что имена ограничений таблицы, как и имена ограничений доменов, бу-
дут уникальными. Однако ранее это не контролировалось явно, и в особых случаях могли по-
являться дублирующиеся имена.
• Обработка в функциях power(numeric, numeric) и power(float8, float8) аргументов NaN в
соответствии со стандартом POSIX (Том Лейн, Дан Мин Хыонг)
2280Замечания к выпуску
Согласно стандарту POSIX, NaN ^ 0 = 1 и 1 ^ NaN = 1, а во всех других случаях с аргумен-
тами NaN должно возвращаться значение NaN. Ранее power(numeric, numeric) просто всегда
возвращала NaN; сейчас она учитывает эти два исключения. power(float8, float8) следовала
стандарту в зависимости от поведения нижележащей библиотеки C; однако на некоторых ста-
рых платформах Unix эта библиотека работала некорректно, и кроме того, возникали расхож-
дения в некоторых версиях Windows.
• Недопущение игнорирования функцией to_number() символов, которые не соответствуют сим-
волам в шаблоне (Оливер Форд)
В частности, SELECT to_number(‘1234’, ‘9,999’) раньше возвращала 134. Теперь она возвра-
щает 1234. Символы в шаблоне L и TH теперь будут поглощать только символы, отличные от
цифр, знаков плюс/минус, десятичной точки и запятой.
• Исправление поведения to_date(), to_number(), и to_timestamp(), чтобы для каждого симво-
ла в шаблоне пропускался один символ в данных (Том Лейн)
Ранее они пропускали один байт для каждого байта, составляющего символ шаблона, что
приводило к неадекватному поведению при наличии многобайтных символов в шаблоне или
вводимой строке.
• В to_char(), to_number() и to_timestamp() исправлена обработка символов обратной косой
черты в двойных кавычках внутри строки шаблона.
Такие символы теперь экранируют следующий за ними символ, а именно символ кавычек или
другую обратную косую черту.
• Корректная обработка выражений с относительными путями в xmltable(), xpath() и других
функциях, работающих с XML (Маркус Винанд)
Согласно стандарту SQL, относительные пути нужно рассматривать от узла документа XML, а
не от корневого узла, как раньше это делали данные функции.
• В протоколе расширенных запросов значение statement_timeout должно применяться к каж-
дому отдельному сообщению Execute, а не ко всем командам до Sync (Тацуо Исии, Андрес
Фройнд)
• Удаление столбца relhaspkey из системного каталога pg_class (Питер Эйзентраут)
Приложения, которым нужно проверить первичный ключ, должны обращаться в pg_index.
• Замена столбцов proisagg и proiswindow в системном каталоге pg_proc на prokind (Питер Эй-
зентраут)
Новый столбец более чётко выделяет функции, процедуры, а также агрегатные и оконные
функции.
• Откорректировано содержимое столбца информационной схемы tables.table_type — значе-
ние FOREIGN TABLE изменено на FOREIGN (Питер Эйзентраут)
Новое содержимое соответствует стандарту SQL.
• Изменены отображаемые в ps имена фоновых рабочих процессов для соответствия меткам
pg_stat_activity.backend_type (Питер Эйзентраут)
• Проверка разрешений для использования больших объектов теперь происходит при открытии
объекта, в функции lo_open(), а не при попытке чтения/записи (Том Лейн, Микаэль Пакье)
Теперь в случае отсутствия прав на запись будет выдаваться ошибка, тогда как раньше её мог-
ло не быть, если собственно запись в большой объект вообще не производилась.
• Разрешение переиндексирования общих каталогов только для суперпользователей (Микаэль
Пакье, Роберт Хаас)
2281Замечания к выпуску
Ранее это также могли делать владельцы баз данных, но теперь эта операция считается выхо-
дящей за рамки их полномочий.
• Удаление устаревших функций adminpack pg_file_read(), pg_file_length() и
pg_logfile_rotate() (Стивен Фрост)
Равнозначная функциональность теперь представлена в ядре сервера. Старые инсталляции
adminpack продолжат использовать эти функции, пока не будут обновлены посредством ALTER
EXTENSION … UPDATE.
• Параметры команд, заключённые в двойные кавычки, стали восприниматься с учётом реги-
стра (Даниэль Густафссон)
Ранее имена параметров в определённых SQL-командах принудительно приводились к нижне-
му регистру, даже когда они задавались в кавычках; так, например, “FillFactor” восприни-
малось как имя параметра хранения индекса, тогда как правильное имя должно записываться
строчными буквами. Теперь в подобных случаях будет выдаваться ошибка.
• Ликвидация серверного параметра replacement_sort_tuples (Питер Геохеган)
Было решено, что сортировка с замещением в настоящее время не имеет практической поль-
зы.
• Удаление предложения WITH в CREATE FUNCTION (Микаэль Пакье)
PostgreSQL уже долгое время поддерживает более стандартный вариант записи для этой воз-
можности.
E.2.3. Изменения
Ниже вы найдёте подробный список изменений, произошедших между предыдущим основным вы-
пуском и выпуском PostgreSQL 11.
E.2.3.1. Сервер
E.2.3.1.1. Секционирование
• Возможность создания секций по хешу ключевого столбца (Амул Сул)
• Поддержка индексов в секционированных таблицах (Альваро Эррера, Амит Ланготе)
«Индекс» в секционированной таблице надо понимать не как физический индекс, построен-
ный по всей этой таблице, а скорее как шаблон автоматического создания подобных индексов
в каждой секции таблицы.
Если ключ секционирования входит в набор столбцов индекса, секционированный индекс мо-
жет иметь характеристику UNIQUE. В этом случае он будет представлять собой полноценное
ограничение уникальности во всей секционированной таблице, несмотря на то, что каждый
физический индекс обеспечивает уникальность только в отдельной секции.
Новая команда ALTER INDEX ATTACH PARTITION позволяет связать существующий в определён-
ной секции индекс с соответствующим шаблоном индекса для содержащей её секционирован-
ной таблицы. Это даёт возможность гибко образовывать новые секционированные индексы
для существующих секционированных таблиц.
• Возможность создавать внешние ключи с секционированными таблицами (Альваро Эррера)
• Поддержка триггеров FOR EACH ROW в секционированных таблицах (Альваро Эррера)
При создании триггера в секционированной таблице автоматически создаются триггеры во
всех её существующих и в добавляемых впоследствии секциях. Это также позволяет реализо-
вать отложенные ограничения уникальности в секционированных таблицах.
• Возможность определить для секционированной таблицы секцию по умолчанию (Дживан Лад-
хе, Бина Эмерсон, Ашутош Бапат, Рахила Сьед, Роберт Хаас)
2282Замечания к выпуску
Секция по умолчанию будет содержать строки, не попадающие ни в одну из других секций,
что соответствующим образом учитывается при поиске.
• При изменении операторами UPDATE значений ключа разбиения в строках секционированной
таблицы эти строки теперь будут переноситься в соответствующие секции (Амит Хандекар)
• При выполнении в секционированных таблицах команд INSERT, UPDATE и COPY строки долж-
ным образом перенаправляются в секции, размещённые в сторонних таблицах (Эцуро Фудзи-
та, Амит Ланготе)
Эта функциональность поддерживается обёрткой сторонних таблиц postgres_fdw.
• Реализована возможность быстрого устранения секций при обработке запросов (Амит Ланго-
те, Дэвид Роули, Дилип Кумар)
Она позволяет ускорить доступ к секционированным таблицам со многими секциями.
• Реализована возможность устранения секций при выполнении запроса (Дэвид Роули, Бина
Эмерсон)
Ранее секции исключались только во время планирования, так что во многих соединениях и
подготовленных запросах осуществить исключение секций было невозможно.
• При соединении секционированных таблиц по равенству строк реализована возможность со-
единения непосредственно соответствующих секций (Ашутош Бапат)
По умолчанию эта возможность отключена, но её можно включить, изменив параметр
enable_partitionwise_join.
• Возможность вычисления агрегатных функций в секционированных таблицах по отдельным
секциям с последующим объединением результатов (Дживан Чок, Ашутош Бапат, Роберт Ха-
ас)
Эта функциональность по умолчанию отключена, но её можно включить, изменив параметр
enable_partitionwise_aggregate.
• В postgres_fdw реализована возможность распределять агрегатные вычисления в секциони-
рованных таблицах по сторонним таблицам-секциям (Дживан Чок)
E.2.3.1.2. Параллельное выполнение запросов
• Возможность параллельного построения индексов btree (Питер Геохеган, Рушаб Латиа, Хейк-
ки Линнакангас)
• Возможность выполнения соединения по хешу в параллельном режиме с использованием об-
щей хеш-таблицы (Томас Мунро)
• При выполнении UNION образующие его запросы SELECT могут выполняться параллельно, если
отдельный SELECT не может быть распараллелен (Амит Хандекар, Роберт Хаас, Амул Сул)
• Сканирование секций может более эффективно использовать параллельные исполнители
(Амит Хандекар, Роберт Хаас, Амул Сул)
• Указание LIMIT может передаваться параллельным исполнителям (Роберт Хаас, Том Лейн)
Благодаря этому рабочие процессы могут возвращать меньший объём результатов и использо-
вать целенаправленное сканирование индекса.
• Возможность распараллеливания запросов, выполняемых разово, например, агрегатных за-
просов в предложении WHERE и функций в выходном списке запроса (Амит Капила, Роберт Ха-
ас)
• Добавление серверного параметра parallel_leader_participation, управляющего участием
ведущего процесса в выполнении подпланов (Томас Мунро)
По умолчанию этот параметр включён, то есть ведущий будет исполнять подпланы.
2283Замечания к выпуску
• Возможность распараллеливания команд CREATE TABLE … AS, SELECT INTO и CREATE
MATERIALIZED VIEW (Харибабу Комми)
• Увеличение скорости последовательного сканирования со множеством параллельных испол-
нителей (Дэвид Роули)
• Добавление в вывод EXPLAIN информации о действиях, выполняемых при сортировке с парал-
лельными исполнителями (Роберт Хаас, Том Лейн)
E.2.3.1.3. Индексы
• Возможность включать в индексы-B-деревья столбцы, которые не входят в ограничение уни-
кальности или ключ поиска, но могут быть прочитаны при сканировании только индекса (Ана-
стасия Лубенникова, Александр Коротков, Фёдор Сигаев)
Для определения таких индексов предназначено новое предложение INCLUDE команды CREATE
INDEX. Таким образом стало возможным создавать «покрывающие индексы», оптимизирую-
щие некоторые типы запросов. В покрывающий индекс могут включаться столбцы даже с та-
кими типами данных, которые не поддерживает B-дерево.
• Ускорение добавления в индекс монотонно увеличивающихся ключей (Паван Деоласи, Питер
Геохеган)
• Улучшение производительности сканирования хеш-индекса (Томаш Вондра, Роберт Хаас)
• Добавление предикатных блокировок для индексов GiST, GIN и хеш-индексов (Шубхам Барай)
Благодаря этому уменьшается вероятность конфликтов сериализации для транзакций в сериа-
лизуемом режиме.
E.2.3.1.3.1. SP-GiST
• Добавление оператора сопоставления префиксов text ^@ text и реализация его поддержки в
SP-GiST (Ильдус Курбангалиев)
Он действует подобно конструкции переменная LIKE ‘слово%’ с индексом btree, но обрабаты-
вается более эффективно.
• Возможность индексирования многоугольников с SP-GiST (Никита Глухов, Александр Корот-
ков)
• Возможность использования в SP-GiST неточного представления ключей на уровне листьев
(Фёдор Сигаев, Хейкки Линнакангас, Александр Коротков, Никита Глухов)
E.2.3.1.4. Оптимизатор
• Улучшение выбора наиболее типичных значений для статистики (Джефф Джейнс, Дин Ра-
шид)
Ранее наиболее типичные значения (Most-Common-Values, MCV) выбирались с учётом их ча-
стоты относительно всех других значений столбца. Теперь MCV выбираются с учётом их ча-
стоты относительно значений, не попадающих в число MCV. Это способствует улучшению ста-
тистики для равномерного и неравномерного распределения.
• Улучшение оценок избирательности для &gt;= и &lt;= (Том Лейн)
Ранее для них применялась та же оценка избирательности, что и для операторов &gt; и &lt;, соот-
ветственно, за исключением сравнения с константами из числа MCV. Это изменение особенно
полезно для условий BETWEEN с маленькими диапазонами.
• Сведение выражения переменная = переменная к выражению переменная IS NOT NULL там, где
они равнозначны (Том Лейн)
Благодаря этому улучшается оценка избирательности.
• Улучшение оценки числа строк оптимизатором для запросов EXISTS и NOT EXISTS (Том Лейн)
2284Замечания к выпуску
• Усовершенствование оптимизатора, чтобы он учитывал стоимость вычислений и избиратель-
ность для предложений HAVING (Том Лейн)
E.2.3.1.5. Общая производительность
• Реализация JIT-компиляции некоторых частей планов для ускорения выполнения запросов
(Андрес Фройнд)
Для этой функциональности требуется наличие LLVM. По умолчанию она отключена, даже в
сборках, обеспечивающих её поддержку.
• Возможность выполнения при определённых условиях сканирования битовой карты подобно
сканированию только индекса (Александр Кузьменков)
• Обновление карты свободного пространства во время VACUUM (Клаудио Фрейре)
Это позволяет задействовать освободившееся пространство более оперативно.
• Исключение ненужных операций сканирований индекса при выполнении VACUUM (Масахико
Савада, Александр Коротков)
• Увеличение производительности при одновременном фиксировании множества транзакций
(Амит Капила)
• Более эффективное использование памяти при выполнении запросов, в списках результатов
которых фигурируют функции, возвращающие множества (Андрес Фройнд)
• Ускорение агрегатных вычислений (Андрес Фройнд)
• Реализация в postgres_fdw возможности передавать на сторонние серверы запросы UPDATE и
DELETE, использующие соединения (Эцуро Фудзита)
Ранее могли передаваться только UPDATE и DELETE без соединений.
• Добавление поддержки больших страниц в Windows (Такаюки Цунакава, Томас Мунро)
Эта поддержка включается параметром конфигурации huge_pages.
E.2.3.1.6. Мониторинг
• Добавление информации об использовании памяти в вывод log_statement_stats,
log_parser_stats, log_planner_stats и log_executor_stats (Джастин Призби, Питер Эйзен-
траут)
• Добавление поля pg_stat_activity.backend_type, в котором показывается тип рабочего про-
цесса (Питер Эйзентраут)
Этот тип также можно увидеть в выводе ps.
• В режиме log_autovacuum_min_duration добавлен вывод сообщений о таблицах, которые были
удалены, пока выполнялась очистка (Натан Боссарт)
E.2.3.1.6.1. Информационная схема
• Добавление столбцов в представления information_schema, связанные с ограничениями таб-
лиц и триггерами (Питер Эйзентраут)
А именно, поля triggers.action_order, triggers.action_reference_old_table и
triggers.action_reference_new_table, ранее всегда содержавшие NULL, теперь заполнены
значениями. Также добавилось поле table_constraints.enforced, но оно пока не содержит
полезного значения.
E.2.3.1.7. Аутентификация
• Возможность задавать на сервере более сложные конструкции LDAP в режиме поиск+связы-
вание (Томас Мунро)
В частности, в ldapsearchfilter можно задавать шаблоны с комбинациями атрибутов LDAP.
2285Замечания к выпуску
• Возможность аутентификации LDAP с использованием шифрованного протокола LDAP (Томас
Мунро)
Ранее мы поддерживали работу LDAP поверх TLS с параметром ldaptls=1. Новый ме-
тод TLS LDAP для зашифрованного LDAP включается параметром ldapscheme=ldaps или
ldapurl=ldaps://.
• Улучшен вывод сообщений об ошибках LDAP (Томас Мунро)
E.2.3.1.8. Разрешения
• Добавление стандартных ролей для управления доступом к файловой системе (Стивен Фрост)
А именно, добавлены роли: pg_read_server_files, pg_write_server_files и
pg_execute_server_program. Эти роли теперь также определяют, кому разрешено выполнять
COPY на стороне сервера и использовать расширение file_fdw. Ранее эти функции были до-
ступны только суперпользователям, и сейчас по умолчанию другим пользователям они недо-
ступны.
• Вместо явных проверок суперпользователей ограничение доступа к функциям, которые рабо-
тают с файловой системой, теперь обеспечивается разрешениями, управляемыми командами
GRANT/REVOKE (Стивен Фрост)
Соответствующим образом были изменены функции: pg_ls_dir(), pg_read_file(),
pg_read_binary_file() и pg_stat_file().
• Переход к использованию GRANT/REVOKE для ограничения доступа к функциям lo_import() и
lo_export() (Микаэль Пакье, Том Лейн)
Ранее к этим функциям имели доступ только суперпользователи.
Удалён параметр времени компиляции ALLOW_DANGEROUS_LO_FUNCTIONS.
• Для ограничения доступа без пароля к таблицам postgres_fdw через представление теперь
проверяется владелец представления, а не пользователь сеанса (Роберт Хаас)
PostgreSQL позволяет только суперпользователям обращаться к таблицам postgres_fdw без
паролей, то есть в режиме peer. Ранее для получения такого доступа суперпользователем
должен был быть владелец сеанса; теперь же проверяется владелец представления.
• Исправление некорректной проверки разрешений для блокировки в SELECT FOR UPDATE с
представлениями (Том Лейн)
E.2.3.1.9. Конфигурация сервера
• Добавление серверного параметра ssl_passphrase_command, позволяющего передать пароль,
требующийся для расшифровывания файлов ключей SSL (Питер Эйзентраут)
Вместе с этим добавлен параметр ssl_passphrase_command_supports_reload, указывающий,
нужно ли перезагружать конфигурацию SSL и вызывать ssl_passphrase_command при переза-
грузке конфигурации сервера.
• Добавление параметра хранилища toast_tuple_target, определяющего минимальный размер
кортежа для рассмотрения возможности применения TOAST (Саймон Риггс)
Подразумеваемое по умолчанию пороговое значение для применения TOAST осталось преж-
ним.
• Возможность задавать значения серверных параметров, связанных с объёмом файлов и памя-
ти, в байтах (Бина Эмерсон)
Новая единица обозначается «B». Она дополняет прежний набор из «kB», «MB», «GB» и «TB».
E.2.3.1.10. Журнал предзаписи (WAL)
• Возможность указания размера файлов WAL при вызове initdb (Бина Эмерсон)
2286Замечания к выпуску
Ранее размер по умолчанию составлял 16 Мбайт, и изменить его можно было только при ком-
пиляции.
• Сохранение данных WAL только для одной контрольной точки (Саймон Риггс)
Ранее записи WAL сохранялись для двух контрольных точек.
• Заполнение нулями неиспользованной части принудительно переключаемых сегментов WAL
для более эффективного их сжатия (Чепмен Флэк)
E.2.3.2. Базовое резервное копирование и потоковая репликация
• Репликация действия TRUNCATE в ходе логической репликации (Саймон Риггс, Марко Ненча-
рини, Питер Эйзентраут)
• Передача информации о подготовленных транзакциях подписчикам логической репликации
(Никхил Сонтакке, Стас Кельвич)
• Исключение нежурналируемых и временных таблиц, а также файлов pg_internal.init из
транслируемых базовых копий (Дэвид Стил)
Копировать такие файлы нет необходимости.
• Возможность проверки контрольных сумм страниц кучи при трансляции базовой резервной
копии (Михаэль Банк)
• Возможность программного сдвига позиции в слотах репликации, без участия подписчиков
(Петр Желинек)
Это позволяет эффективно продвигаться вперёд в слоте репликации, когда считы-
вать его содержимое не требуется. Данная возможность реализована в функции
pg_replication_slot_advance().
• Добавление информации о линии времени в файл backup_label (Микаэль Пакье)
Также добавлена проверка на соответствие линии времени в WAL линии времени в файле
backup_label.
• Добавление адреса узла и порта в системное представление pg_stat_wal_receiver (Харибабу
Комми)
E.2.3.3. Служебные команды
• Возможность избежать перезаписи таблицы при добавлении в ALTER TABLE столбца с отлич-
ным от NULL значением по умолчанию (Эндрю Дунстан, Серж Рило)
Эта оптимизация включается, когда значение по умолчанию задаётся константой.
• Возможность блокирования представлений в результате блокирования нижележащих таблиц
(Юго Нагата)
• Возможность определения в ALTER INDEX ориентиров сбора статистики для индексов по выра-
жению (Александр Коротков, Адриен Найрат)
В psql команда \d+ теперь показывает ориентир статистики для индексов.
• Возможность указания нескольких таблиц в одной команде VACUUM или ANALYZE (Натан Бос-
сарт)
Кроме того, если для какой-либо таблицы, упомянутой в VACUUM, задаётся список столбцов,
необходимо добавить ключевое слово ANALYZE; ранее в таких случаях указание ANALYZE подра-
зумевалось.
• В ANALYZE добавлен синтаксис указания параметров в скобках (Натан Боссарт)
Подобный синтаксис поддерживает команда VACUUM.
2287Замечания к выпуску
• Добавление в CREATE AGGREGATE параметра, отмечающего поведение функции завершения аг-
регата (Том Лейн)
Это позволяет оптимизировать пользовательские агрегатные функции и использовать их как
оконные функции.
E.2.3.4. Типы данных
• Возможность создания массивов доменов (Том Лейн)
Это также позволяет использовать array_agg() с доменами.
• Поддержка доменов поверх составных типов (Том Лейн)
В дополнение к этому языки PL/Perl, PL/Python и PL/Tcl получили возможность принимать ар-
гументы и выдавать результаты с составными доменными типами. Также улучшена поддерж-
ка доменных типов в PL/Python.
• Добавление приведений скаляров JSONB к числовому и логическому типу данных (Анастасия
Лубенникова)
E.2.3.5. Функции
• Реализация всех описанных в SQL:2011 вариантов определения рамки для оконных функций
(Оливер Форд, Том Лейн)
В режиме RANGE теперь допускается указание в PRECEDING и FOLLOWING смещений для выбора
строк с группирующими значениями плюс/минус заданное смещение. Кроме того, был добав-
лен режим GROUPS, в котором в рамку включается плюс/минус заданное число групп родствен-
ных строк. Также добавлен синтаксис для описания рамки с исключением.
• Добавление семейства хеш-функций SHA-2 (Питер Эйзентраут)
А именно, были добавлены функции: sha224(), sha256(), sha384() и sha512().
• Добавление поддержки 64-битных функций хеширования без криптографической стойкости
(Роберт Хаас, Амул Сул)
• Возможность указания в to_char() и to_timestamp() смещения часового пояса от UTC в ча-
сах и минутах (Никита Глухов, Эндрю Дунстан)
Для этого предназначены указания формата TZH и TZM.
• Добавление функции текстового поиска websearch_to_tsquery(), поддерживающей синтаксис
запросов, подобный принятому в поисковых системах в Интернете (Виктор Дробный, Дмитрий
Иванов)
• Добавление функций json(b)_to_tsvector(), создающих запрос текстового поиска для соот-
ветствующих значений JSON/JSONB (Дмитрий Долгов)
E.2.3.6. Языки программирования на стороне сервера
• Реализация процедур на уровне SQL, которые могут начинать и фиксировать собственные
транзакции (Питер Эйзентраут)
Для создания хранимых процедур предназначена новая команда CREATE PROCEDURE, а для вы-
полнения — CALL
Новые команды ALTER/DROP ROUTINE позволяют изменять/удалять все виды объектов-подпро-
грамм, а именно процедуры, функции и агрегаты.
Кроме того, теперь запись FUNCTION в командах CREATE OPERATOR и CREATE TRIGGER предпочти-
тельнее, чем PROCEDURE, так как целевой объект должен быть функцией, а не процедурой. Од-
нако для совместимости старый синтаксис по-прежнему поддерживается.
2288Замечания к выпуску
• Добавление возможностей управления транзакциями в серверные языки PL/pgSQL, PL/Perl,
PL/Python, PL/Tcl и SPI (Питер Эйзентраут)
Управление транзакциями возможно только в процедурах на верхнем уровне транзакций и
вложенных блоках CALL и DO, которые могут содержать только другие блоки CALL и DO.
• Добавление в PL/pgSQL возможности обозначать типы записей составного типа как не прини-
мающие NULL, постоянные, или имеющие начальные значения (Том Лейн)
• В PL/pgSQL добавлена обработка изменений составных типов (например, записи, кортежа),
происходящих между первым и последующими вызовами функции в одном сеансе (Том Лейн)
Ранее в таких обстоятельствах выдавались ошибки.
• Добавление расширения jsonb_plpython для преобразования JSONB в типы PL/Python и в об-
ратном направлении (Антон Быков)
• Добавление расширения jsonb_plperl для преобразования JSONB в типы PL/Perl и в обратном
направлении (Антон Быков)
E.2.3.7. Клиентские интерфейсы
• По умолчанию сжатие теперь отключено в libpq (Питер Эйзентраут)
В современных версиях OpenSSL сжатие отключено, так что соответствующий параметр libpq
в них фактически не действовал.
• Добавление указания DO CONTINUE в команду ecpg WHENEVER (Винаяк Покале)
При этом генерируется команда continue языка C, приводящая к передаче управления в на-
чало цикла, содержащего указанное условие.
• Добавление в ecpg режима обработки символьных массивов в стиле Oracle Pro<em>C.
Этот режим включается ключом -C.
E.2.3.8. Клиентские приложения
• Добавление в psql команды \gdesc, выводящей названия и типы столбцов в результате запро-
са (Павел Стехуле)
• Добавление переменных psql для управление выводом ошибок и действий запросов (Фабьен
Коэльо)
А именно, были добавлены переменные: ERROR, SQLSTATE, ROW_COUNT, LAST_ERROR_MESSAGE и
LAST_ERROR_SQLSTATE.
• Добавление в psql возможности проверить существование переменной (Фабьен Коэльо)
Для проверки существования переменной в операторе \if реализован синтаксис :{?имя_пе-
ременной}.
• Добавление переменной окружения PSQL_PAGER для управления постраничником в psql (Па-
вел Стехуле)
Эта переменная позволяет задать для psql постраничник по умолчанию, отличный от постра-
ничника, который выбран для других программ. Значение PAGER по-прежнему действует, если
переменная PSQL_PAGER не определена.
• Безусловное добавление информации о секционировании в вывод команды psql \d+ (Амит Лан-
готе, Ашутош Бапат)
Ранее эта информация не выводилась для секционированной таблицы, в которой не было сек-
ций. Также теперь обозначается, какие секции сами являются секционированными.
• Вывод в psql правильного имени пользователя при запросе пароля (Том Лейн)
2289Замечания к выпуску
Ранее, когда имя пользователя задавалось в адресе URI и одновременно использовался ключ
-U, в приглашении выдавалось некорректное имя. Теперь также подавляется имя при запросе
пароля, когда указывается ключ –password.
• Выполнение выхода из psql при вводе команд quit и exit, когда в буфере ввода больше ничего
нет (Брюс Момджян)
Добавление подсказки о том, как выйти из программы, когда команды quit и exit вводятся в
отдельной строке при непустом буфере ввода. Эта же информация добавлена в справку (help).
• Добавление в psql подсказки об использовании Control-D, когда \q вводится в отдельной стро-
ке, но при этом игнорируется (Брюс Момджян)
Например, ввод \q не приведёт к выходу, если эти символы введены внутри текстовой строки.
• Улучшение дополнения табуляцией для команды ALTER INDEX RESET/SET (Масахико Савада)
• Добавление в psql инфраструктуры для адаптации запросов, требующихся для дополнения та-
буляцией, к версии сервера (Том Лейн)
Ранее запросы, выполняемые механизмом дополнения табуляцией, могли не работать на ста-
рых серверах.
E.2.3.8.2. pgbench
• Добавление в pgbench поддержки выражений с NULL, логическими значениями, а также
нескольких функций и операторов (Фабьен Коэльо)
• Добавление условий \if в pgbench (Фабьен Коэльо)
• Возможность использовать в именах переменных pgbench не только символы ASCII (Фабьен
Коэльо)
• Добавление в pgbench ключа –init-steps, позволяющего управлять этапами инициализации
(Масахико Савада)
• Добавление в pgbench генератора случайных чисел с распределением, приблизительно соот-
ветствующим закону Ципфа (Алик Хилажев)
• Возможность указания затравки для генератора случайных чисел в pgbench (Фабьен Коэльо)
• Добавление в pgbench функций pow() и power() для возведения в степень (Раул Марин Родри-
гес)
• Добавление в pgbench функций хеширования (Ильдар Мусин)
• Улучшение точности статистики pgbench при использовании параметров –latency-limit и
–rate (Фабьен Коэльо)
E.2.3.9. Серверные приложения
• Добавление в pg_basebackup параметра для создания слота репликации с заданным именем
(Михаэль Банк)
С ключом –create-slot будет создаваться слот репликации (с именем, заданным ключом –
slot), когда используется метод потоковой трансляции WAL (–wal-method=stream).
• Возможность разрешения в initdb доступа группы к каталогу данных (Дэвид Стил)
Для этого предназначен добавленный ключ initdb –allow-group-access. Администраторы
также могут установить разрешения для группы в пустом каталоге данных до запуска initdb.
Узнать, разрешено ли группе чтение в каталоге данных, позволяет серверная переменная
data_directory_mode.
• Добавление утилиты pg_verify_checksums для проверки контрольных сумм базы данных в от-
ключённом состоянии (Магнус Хагандер)
• Возможность изменить в pg_resetwal размер сегмента WAL с помощью ключа –wal-segsize
(Натан Боссарт)
2290Замечания к выпуску
• Добавление длинных параметров в pg_resetwal и pg_controldata (Натан Боссарт, Питер Эйзен-
траут)
• Добавление в pg_receivewal ключа –no-sync, отключающего синхронную запись WAL в целях
тестирования (Микаэль Пакье)
• Добавление в pg_receivewal ключа –endpos, указывающего, когда нужно остановить приём
WAL (Микаэль Пакье)
• Включение в pg_ctl возможности посылать процессам сигналы SIGKILL (Андрес Фройнд)
Ранее эта возможность не поддерживалась из-за опасений потенциальных злоупотреблений
ей.
• Уменьшение числа файлов, копируемых утилитой pg_rewind (Микаэль Пакье)
• Недопущение запуска pg_rewind от имени root (Микаэль Пакье)
E.2.3.9.1. pg_dump, pg_dumpall, pg_restore
• Добавление в pg_dumpall ключа –encoding для управления выводом указаний кодировок (Ми-
каэль Пакье)
В pg_dump этот ключ уже был раньше.
• Добавление в pg_dump ключа –load-via-partition-root, указывающего, что данные долж-
ны загружаться в корневую таблицу секционирования, а не в исходную секцию (Рушаб Латиа)
Это полезно, если в целевой системе окажутся другие правила сортировки или порядок бай-
тов, при которых может потребоваться поместить строки в секции, отличные от прежних.
• Добавление ключа для отключения выгрузки и восстановления комментариев объекта базы
данных (Робинс Таракан)
Новый ключ утилит pg_dump, pg_dumpall и pg_restore называется –no-comments.
E.2.3.10. Исходный код
• Добавление в PGXS возможности устанавливать заголовочные файлы (Эндрю Гирт)
Это позволяет создавать модули расширений, зависящие от других модулей. Ранее для зави-
симого модуля не было простой возможности найти заголовочные файлы нужного ему моду-
ля. Также был скорректирован ряд существующих модулей в contrib, определяющих типы
данных, чтобы при их установке устанавливались и соответствующие заголовки. Кроме того,
реализации PL/Perl и PL/Python теперь устанавливают свои заголовочные файлы для поддерж-
ки создания модулей преобразования для этих языков.
• Установка файла errcodes.txt при инсталляции, что позволяет расширениям получать спи-
сок кодов ошибок, известных в PostgreSQL (Томас Мунро)
• Преобразование документации в формат DocBook XML (Питер Эйзентраут, Александр Лахин,
Юрген Пуртц)
Имена файлов по-прежнему имеют расширение sgml для совместимости с ветвями старых
версий.
• Использование определения типа bool из stdbool.h там, где это возможно, то есть на подав-
ляющем большинстве платформ (Питер Эйзентраут)
Тем самым устранены трудности, связанные с написанием модулей расширений, в исходный
код которых требовалось включить stdbool.h.
• Кардинальное изменение способа описания начальных системных каталогов (Джон Нейлор)
Теперь исходные данные представляются в структурах Perl, что значительно упрощает меха-
ническую работу с ними.
2291Замечания к выпуску
• Недопущение создания расширениями собственных серверных параметров, принимающих
значения в виде списка в кавычках (Том Лейн)
Сейчас нет возможности это поддерживать, так как об этом свойстве параметра необходимо
знать до того, как расширение будет загружено.
• Добавление возможности применять связывание каналов при использовании аутентификации
SCRAM (Микаэль Пакье)
Связывание каналов предназначено для предотвращения атак посредника; SCRAM сам по се-
бе не обеспечивает такую защиту — связывание необходимо включать явно. К сожалению,
libpq не позволяет это сделать. Необходимая поддержка ожидается в будущих версиях libpq и
в интерфейсах, построенных не на базе libpq, например, в JDBC.
• Предоставление фоновым исполнителям возможности подключения к базам данных, которые
обычно не допускают подключения (Магнус Хагандер)
• Поддержка аппаратного вычисления CRC на платформе ARMv8 (Юки Гу, Хейкки Линнакан-
гас, Томас Мунро)
• Ускорение поиска встроенных функций по OID (Андрес Фройнд)
Теперь вместо двоичного поиска используется массив индексов.
• Ускорение форматирования результатов запроса (Андрес Фройнд)
• Увеличение скорости доступа к кешам системы (Андрес Фройнд)
• Добавление механизма управления памятью, построенного на модели поколений, оптимизи-
рованной для последовательного выделения/освобождения блоков (Томаш Вондра)
С новым механизмом уменьшается потребление памяти при логическом декодировании.
• Согласование вычисления pg_class.reltuples при VACUUM с вычислением этого же значения
при выполнении ANALYZE (Томаш Вондра)
• Переход к использованию более новой версии perltidy, 20170521 (Том Лейн, Питер Эйзентра-
ут)
E.2.3.11. Дополнительные модули
• В расширение pg_prewarm добавлена возможность восстанавливать предыдущее содержимое
общего буфера при запуске (Митхун Сай, Роберт Хаас)
Для этого информацию об отношениях и номерах блоков, наблюдаемых в общем буфере,
pg_prewarm периодически сохраняет на диск во время работы и при отключении сервера.
• Добавление в pg_trgm функции strict_word_similarity() для вычисления схожести целых
слов (Александр Коротков)
Для подобной цели уже существовала функция word_similarity(), но она была предназначе-
на для поиска схожих частей слов, тогда как strict_word_similarity() вычисляет схожесть
целых слов.
• Возможность создания индексов, которые можно использовать в сравнениях LIKE со столбца-
ми citext (Алексей Чернышов)
Для этого индексы должны создаваться с использованием класса операторов
citext_pattern_ops.
• Возможность создания индексов btree_gin по значениям типов данных bool, bpchar, name и
uuid (Матеус Оливейра)
• Возможность выполнения расширениями cube и seg сканирования только индекса при ис-
пользовании индексов GiST (Андрей Бородин)
• Реализация извлечения отрицательных координат куба оператором ~&gt; (Александр Коротков)
Это полезно для поиска kNN-GiST, когда нужно выбрать координаты в возрастающем порядке.
2292Замечания к выпуску
• Обработка букв вьетнамского языка в расширении unaccent (Дан Мин Хыонг, Микаэль Пакье)
• Добавление в amcheck проверки наличия для каждого кортежа в куче соответствующей запи-
си в индексе (Питер Геохеган)
• Переход в модуле adminpack к использованию новых стандартных ролей для доступа к файло-
вой системе (Стивен Фрост)
Ранее функции adminpack могли вызывать только администраторы, теперь проверяются разре-
шения ролей.
• Расширение идентификатора запроса в pg_stat_statement до 64 бит (Роберт Хаас)
Это значительно сокращает вероятность совпадений хеша для разных идентификаторов за-
просов. Теперь эти идентификаторы могут отображаться и в виде отрицательных чисел.
• Удаление скриптов contrib/start-scripts/osx, так как использовать их более не рекоменду-
ется (вместо них следует использовать contrib/start-scripts/macos) (Том Лейн)
• Удаление расширения chkpass (Питер Эйзентраут)
Это расширение более не считается полезным средством безопасности и примером написа-
ния расширения.
E.2.4. Благодарственный список
Перечисленные ниже (в алфавитном порядке) лица сделали вклад в этот выпуск, разрабатывая,
совершенствуя и рецензируя код, принимая правки, проводя тестирование или сообщая о пробле-
мах.
Абхиджит Менон-Сен (Abhijit Menon-Sen)
Адам Беланьский (Adam Bielanski)
Адам Брайтвелл (Adam Brightwell)
Адам Брюссельбек (Adam Brusselback)
Адитья Тошнивал (Aditya Toshniwal)
Адриан Эскомс (Adrián Escoms)
Адриен Найрат (Adrien Nayrat)
Акос Вандра (Akos Vandra)
Александр Алексеев (Aleksander Alekseev)
Александр Парфёнов (Aleksandr Parfenov)
Александр Коротков (Alexander Korotkov)
Александр Кукушкин (Alexander Kukushkin)
Александр Кузьменков (Alexander Kuzmenkov)
Александр Лахин (Alexander Lakhin)
Александре Гарсия (Alexandre Garcia)
Алексей Баштанов (Alexey Bashtanov)
Алексей Чернышов (Alexey Chernyshov)
Алексей Крючков (Alexey Kryuchkov)
Алик Хилажев (Alik Khilazhev)
Альваро Эррера (Álvaro Herrera)
Амит Капила (Amit Kapila)
Амит Хандекар (Amit Khandekar)
Амит Ланготе (Amit Langote)
Амул Сул (Amul Sul)
Анастасия Лубенникова (Anastasia Lubennikova)
Андреас Джозеф Крог (Andreas Joseph Krogh)
Андреас Карлссон (Andreas Karlsson)
Андреас Зельтенрейх (Andreas Seltenreich)
Андре Гензель (André Hänsel)
Андрей Горита (Andrei Gorita)
Андрес Фройнд (Andres Freund)
Эндрю Дунстан (Andrew Dunstan)
2293Замечания к выпуску
Эндрю Флетчер (Andrew Fletcher)
Эндрю Гирт (Andrew Gierth)
Эндрю Гроссман (Andrew Grossman)
Андрей Красичков (Andrew Krasichkov)
Андрей Бородин (Andrey Borodin)
Андрей Лизенко (Andrey Lizenko)
Энди Абелисто (Andy Abelisto)
Антон Быков (Anthony Bykov)
Антуан Семама (Antoine Scemama)
Антон Дигнос (Anton Dignös)
Антонин Хоуска (Antonin Houska)
Арсений Шароглазов (Arseniy Sharoglazov)
Арсений Шер (Arseny Sher)
Артур Закиров (Artur Zakirov)
Ашутош Бапат (Ashutosh Bapat)
Ашутош Шарма (Ashutosh Sharma)
Ашвин Агравал (Ashwin Agrawal)
Асим Правин (Asim Praveen)
Атсуши Торикоши (Atsushi Torikoshi)
Бадрул Чоудхури (Badrul Chowdhury)
Балаж Силфаи (Balazs Szilfai)
Бейзил Бурк (Basil Bourque)
Бина Эмерсон (Beena Emerson)
Бен Чобот (Ben Chobot)
Бенджамин Кутю (Benjamin Coutu)
Бернд Хелмле (Bernd Helmle)
Блаз Мерела (Blaz Merela)
Брэд Дейонг (Brad DeJong)
Брент Дерт (Brent Dearth)
Брайан Клотье (Brian Cloutier)
Брюс Момджян (Bruce Momjian)
Каталин Якоб (Catalin Iacob)
Чад Трабант (Chad Trabant)
Чепмен Флэк (Chapman Flack)
Кристиан Дута (Christian Duta)
Кристиан Ульрих (Christian Ullrich)
Кристоф Берг (Christoph Berg)
Кристоф Дрейс (Christoph Dreis)
Кристоф Куртуа (Christophe Courtois)
Кристофер Джонс (Christopher Jones)
Клаудио Фрейре (Claudio Freire)
Клейтон Салем (Clayton Salem)
Крейг Рингер (Craig Ringer)
Дагфинн Ильмари Маннсакер (Dagfinn Ilmari Mannsåker)
Дан Вианелло (Dan Vianello)
Дэн Ватсон (Dan Watson)
Дан Мин Хыонг
Даниэль Густафссон (Daniel Gustafsson)
Даниэль Верите (Daniel Vérité)
Даниель Вестерман (Daniel Westermann)
Даниель Вуд (Daniel Wood)
Дорофей Пролесковский (Darafei Praliaskouski)
Дейв Крамер (Dave Cramer)
Дейв Пейдж (Dave Page)
Дэвид Биндерман (David Binderman)
Дэвид Карлье (David Carlier)
Давид Феттер (David Fetter)
Дэвид Дж. Джонстон (David G. Johnston)
2294Замечания к выпуску
Дэвид Гулд (David Gould)
Дэвид Хинкль (David Hinkle)
Давид Перейро Лагарес (David Pereiro Lagares)
Дэвид Рэйдер (David Rader)
Дэвид Роули (David Rowley)
Дэвид Стил (David Steele)
Дэви Мачадо (Davy Machado)
Дин Рашид (Dean Rasheed)
Диан Фей (Dian Fay)
Дилип Кумар (Dilip Kumar)
Дмитрий Сарафанников (Dmitriy Sarafannikov)
Дмитрий Долгов (Dmitry Dolgov)
Дмитрий Иванов (Dmitry Ivanov)
Дмитрий Шалашов (Dmitry Shalashov)
Дон Зейлер (Don Seiler)
Даг Дул (Doug Doole)
Даг Рэди (Doug Rady)
Эдмунд Хорнер (Edmund Horner)
Эйдзи Сэки (Eiji Seki)
Элвис Пранскевичус (Elvis Pranskevichus)
Эмре Хасегели (Emre Hasegeli)
Эрик Рижкерс (Erik Rijkers)
Эрвин Брандштеттер (Erwin Brandstetter)
Эцуро Фудзита (Etsuro Fujita)
Эйлер Тавейра (Euler Taveira)
Эверальдо Кануто (Everaldo Canuto)
Фабьен Коэльо (Fabien Coelho)
Фабрицио де Ройес Мелло (Fabrízio de Royes Mello)
Фейке Стинберген (Feike Steenbergen)
Фриц Ялвинг (Frits Jalvingh)
Фудзии Масао (Fujii Masao)
Гао Цзэнци (Gao Zengqi)
Джанни Чиолли (Gianni Ciolli)
Грег Старк (Greg Stark)
Гуннлаугур Тор Брием (Gunnlaugur Thor Briem)
Го Сян Тань (Guo Xiang Tan)
Хади Мошаеди (Hadi Moshayedi)
Хайлун Ли (Hailong Li)
Харибабу Комми (Haribabu Kommi)
Хит Лорд (Heath Lord)
Хейкки Линнакангас (Heikki Linnakangas)
Хьюго Мерсье (Hugo Mercier)
Игорь Корот (Igor Korot)
Игорь Нейман (Igor Neyman)
Ильдар Мусин (Ildar Musin)
Ильдус Курбангалиев (Ildus Kurbangaliev)
Йозеф Ким (Ioseph Kim)
Джейкоб Чемпион (Jacob Champion)
Хайме Казанова (Jaime Casanova)
Якоб Еггер (Jakob Egger)
Жан-Пьер Пельтье (Jean-Pierre Pelletier)
Дживан Чок (Jeevan Chalke)
Дживан Ладхе (Jeevan Ladhe)
Джефф Девис (Jeff Davis)
Джефф Джейнс (Jeff Janes)
Джереми Эванс (Jeremy Evans)
Джереми Финцель (Jeremy Finzel)
Джереми Шнайдер (Jeremy Schneider)
2295Замечания к выпуску
Джеспер Педерсен (Jesper Pedersen)
Джим Нэсби (Jim Nasby)
Джимми Йи (Jimmy Yih)
Цзин Ван (Jing Wang)
Жобен Августин (Jobin Augustine)
Джо Конвей (Joe Conway)
Джон Горман (John Gorman)
Джон Нейлор (John Naylor)
Йон Нельсон (Jon Nelson)
Джон Вольский (Jon Wolski)
Джонатан Аллен (Jonathan Allen)
Джонатан С. Кац (Jonathan S. Katz)
Жульен Рухо (Julien Rouhaud)
Юрген Пуртц (Jürgen Purtz)
Джастин Призби (Justin Pryzby)
КайГай Кохэй (KaiGai Kohei)
Кайтин Чен (Kaiting Chen)
Карл Лехенбауэр (Karl Lehenbauer)
Кит Фиске (Keith Fiske)
Кевин Блох (Kevin Bloch)
Ка Нгуен (Kha Nguyen)
Ким Росе Карлсен (Kim Rose Carlsen)
Константин Книжник (Konstantin Knizhnik)
Кунтал Гхош (Kuntal Ghosh)
Кайл Самсон (Kyle Samson)
Кётаро Хоригути (Kyotaro Horiguchi)
Летиция Аврот (Lætitia Avrot)
Ларс Канис (Lars Kanis)
Лауренц Альбе (Laurenz Albe)
Леонардо Чекки (Leonardo Cecchi)
Людмила Мантрова (Liudmila Mantrova)
Лисиань Цзоу (Lixian Zou)
Ллойд Альбин (Lloyd Albin)
Лука Феррари (Luca Ferrari)
Лукас Фэйрчайлд (Lucas Fairchild)
Лукас Эдер (Lukas Eder)
Лукас Фиттл (Lukas Fittl)
Магнус Хагандер (Magnus Hagander)
Май Пэн (Mai Peng)
Максим Милютин (Maksim Milyutin)
Максим Богук (Maksym Boguk)
Мансур Галиев (Mansur Galiev)
Марк Дилгер (Marc Dilger)
Марко Ненчарини (Marco Nenciarini)
Марина Полякова (Marina Polyakova)
Марио де Фрутос Диегес (Mario de Frutos Dieguez)
Марк Кейв-Айланд (Mark Cave-Ayland)
Марк Дилгер (Mark Dilger)
Марк Вуд (Mark Wood)
Марко Тииккая (Marko Tiikkaja)
Маркус Винанд (Markus Winand)
Мартин Маркес (Martín Marqués)
Масахико Савада (Masahiko Sawada)
Матеус Оливейра (Matheus Oliveira)
Мэтью Стикни (Matthew Stickney)
Метин Дослу (Metin Doslu)
Михаэль Банк (Michael Banck)
Михаэль Мескес (Michael Meskes)
2296Замечания к выпуску
Микаэль Пакье (Michael Paquier)
Михаил Николаев (Michail Nikolaev)
Майк Блэквелл (Mike Blackwell)
Мин-Цюань Тран (Minh-Quan Tran)
Митхун Сай (Mithun Cy)
Морган Оуэнс (Morgan Owens)
Натан Боссарт (Nathan Bossart)
Натан Вагнер (Nathan Wagner)
Нейл Конвей (Neil Conway)
Ник Барнс (Nick Barnes)
Николас Товен (Nicolas Thauvin)
Никхил Сонтакке (Nikhil Sontakke)
Никита Глухов (Nikita Glukhov)
Николай Шаплов (Nikolay Shaplov)
Ной Миш (Noah Misch)
Нориёси Синода (Noriyoshi Shinoda)
Олег Бартунов (Oleg Bartunov)
Олег Самойлов (Oleg Samoilov)
Оливер Форд (Oliver Ford)
Пан Бянь (Pan Bian)
Паскаль Легран (Pascal Legrand)
Патрик Хеммер (Patrick Hemmer)
Патрик Крекер (Patrick Krecker)
Поль Боно (Paul Bonaud)
Пол Гуо (Paul Guo)
Пол Рамсей (Paul Ramsey)
Паван Деоласи (Pavan Deolasee)
Паван Маддамсетти (Pavan Maddamsetti)
Павел Голубь (Pavel Golub)
Павел Стехуле (Pavel Stehule)
Питер Эйзентраут (Peter Eisentraut)
Питер Геохеган (Peter Geoghegan)
Петр Желинек (Petr Jelínek)
Петру-Флорин Миханча (Petru-Florin Mihancea)
Фил Флорент (Phil Florent)
Филипп Бодуэн (Philippe Beaudoin)
Пьер Дюкроке (Pierre Ducroquet)
Пётр Стефаняк (Piotr Stefaniak)
Прабхат Саху (Prabhat Sahu)
Пу Квун (Pu Qun)
Куэль Чжо (QL Zhuo)
Рафия Сабих (Rafia Sabih)
Рахила Сьед (Rahila Syed)
Райнер Орт (Rainer Orth)
Раджкумар Рагхуванши (Rajkumar Raghuwanshi)
Рауль Марин Родригес (Raúl Marín Rodríguez)
Регина Обе (Regina Obe)
Ричард Йен (Richard Yen)
Роберт Хаас (Robert Haas)
Робинс Таракан (Robins Tharakan)
Род Тейлор (Rod Taylor)
Рушаб Латиа (Rushabh Lathia)
Райан Мерфи (Ryan Murphy)
Шахап Ашчи (Sahap Asci)
Самуэль Хорвиц (Samuel Horwitz)
Скотт Уре (Scott Ure)
Шон Джонстон (Sean Johnston)
Шао Брет (Shao Bret)
2297Замечания к выпуску
Шэй Роджански (Shay Rojansky)
Шубхам Барай (Shubham Barai)
Саймон Риггс (Simon Riggs)
Симоне Готти (Simone Gotti)
Шивасубраманьян Рамасубраманьян (Sivasubramanian Ramasubramanian)
Стас Кельвич (Stas Kelvich)
Стефан Кальтенбруннер (Stefan Kaltenbrunner)
Стефан Фройлих (Stephen Froehlich)
Стивен Фрост (Stephen Frost)
Стив Сингер (Steve Singer)
Стивен Винфилд (Steven Winfield)
Свен Кунце (Sven Kunze)
Тайки Кондо (Taiki Kondo)
Такаюки Цунакава (Takayuki Tsunakawa)
Такэси Идэриха (Takeshi Ideriha)
Тацуо Исии (Tatsuo Ishii)
Тацуро Ямада (Tatsuro Yamada)
Фёдор Сигаев (Teodor Sigaev)
Том Браун (Thom Brown)
Томас Келлерер (Thomas Kellerer)
Томас Мунро (Thomas Munro)
Томас Рейсс (Thomas Reiss)
Тобиас Бусман (Tobias Bussmann)
Тодд А. Кук (Todd A. Cook)
Том Казимирс (Tom Kazimiers)
Том Лейн (Tom Lane)
Томаш Вондра (Tomas Vondra)
Томонари Кацумата (Tomonari Katsumata)
Торстен Груст (Torsten Grust)
Тушар Ахуджа (Tushar Ahuja)
Вайшнави Прабакаран (Vaishnavi Prabakaran)
Васундар Боддапати (Vasundhar Boddapati)
Виктор Дробный (Victor Drobny)
Виктор Вагнер (Victor Wagner)
Виктор Егоров (Victor Yegorov)
Вик Фиринг (Vik Fearing)
Винаяк Покале (Vinayak Pokale)
Винсент Лаченал (Vincent Lachenal)
Виталий Гарнашевич (Vitaliy Garnashevich)
Виталий Буровой (Vitaly Burovoy)
Владимир Баранов (Vladimir Baranoff)
Синь Чжан (Xin Zhang)
И Вэнь Вон (Yi Wen Wong)
Йорик Петерс (Yorick Peterse)
Юго Нагата (Yugo Nagata)
Юки Гу (Yuqi Gu)
Юрий Соколов (Yura Sokolov)
Ив Герген (Yves Goergen)
Чжоу Дигоал (Zhou Digoal)
E.3. Выпуск 10.6
Дата выпуска:
2018-11-08
В этот выпуск вошли различные исправления, внесённые после версии 10.5. За информацией о
нововведениях версии обратитесь к Разделу E.9.
2298Замечания к выпуску
E.3.1. Миграция на версию 10.6
Если используется версия 10.X, выгрузка/восстановление базы не требуется.
Однако если вы используете расширение pg_stat_statements, прочитайте запись о нём в списке
изменений.
Если вы обновляете сервер с более ранней версии, чем 10.4, см. также Раздел E.5.
E.3.2. Изменения
• Корректное заключение в кавычки имён переходных таблиц в командах CREATE TRIGGER …
REFERENCING, которые выдаёт pg_dump (Том Лейн)
Отсутствием кавычек мог воспользоваться непривилегированный пользователь с целью полу-
чения прав суперпользователя при последующем восстановлении выгруженных данных или
выполнении pg_upgrade. (CVE-2018-16850)
• Устранение сбоев, которые могли возникать в особых случаях в семействе функций has_объ-
ект_privilege() (Том Лейн)
Эти функции должны возвращать NULL, а не выдавать ошибку при получении неверного
OID. Некоторые из этих функций делали это и прежде, но не все. Кроме того, в функции
has_column_privilege() на некоторых платформах могли иметь место и другие сбои.
• Исправление функции pg_get_partition_constraintdef(), чтобы при получении неверного
OID отношения не происходил сбой, а выдавался NULL (Том Лейн)
• Недопущение замедления порядка O(N^2) в функциях match/split с регулярными выражения-
ми при обработке длинных строк (Эндрю Гирт)
• Исправление дефекта в обработке стандартных многосимвольных операторов, следующих
непосредственно за комментарием или символами + и - (Эндрю Гирт)
Следствием данного упущения могли быть ошибки при разборе или неправильное определе-
ние приоритета операторов.
• Недопущение замедления порядка O(N^3) при обработке лексическим анализатором длин-
ных строк из символов + или - (Эндрю Гирт)
• Исправление некорректного выполнения подчинённых планов при сканировании внешнего
запроса в обратном направлении (Эндрю Гирт)
• Исправление ошибочного поведения UPDATE/DELETE … WHERE CURRENT OF … после переме-
щения курсора (Том Лейн)
Курсор, сканирующий несколько отношений (в частности, дерево наследования), мог работать
неправильно, возвращаясь к предыдущему отношению.
• Исправление в функции EvalPlanQual обработки узлов InitPlan, которые выполняются по
условию (Эндрю Гирт, Том Лейн)
Вследствие ошибки реализации могли возникать сложновоспроизводимые сбои или выдавать-
ся неправильные результаты при одновременных запросах на изменение, содержащих изоли-
рованные вложенные SELECT в конструкции CASE.
• Недопущение создания секции в триггере, присоединённом к родительской таблице (Амит
Ланготе)
В идеале такое создание можно было бы разрешить, но в данный момент оно блокируется во
избежание сбоев.
• Устранение проблем с применением ON COMMIT DELETE ROWS к секционированной временной
таблице (Амит Ланготе)
• Исправление проверок классов символов для корректной поддержки в Windows символов
Unicode выше U+FFFF (Том Лейн, Кэндзи Уно)
2299Замечания к выпуску
Эта ошибка проявлялась в операциях полнотекстового поиска, а также в работе модулей
contrib/ltree и contrib/pg_trgm.
• Недопущение передачи вложенных SELECT с оконными функциями, а также с указаниями
LIMIT или OFFSET, параллельным исполнителям (Амит Капила)
В таких случаях поведение могло быть несогласованным из-за того, что разные исполнители
получали разные результаты вследствие вариативности в порядке строк.
• Смена владельца последовательности, принадлежащей сторонней таблице, при выполнении
ALTER OWNER для этой таблицы (Питер Эйзентраут)
Операция смены владельца должна распространяться и на такие последовательности, но
раньше сторонние таблицы она не затрагивала.
• Обеспечение обработки сервером уже полученных прерываний NOTIFY и SIGTERM до начала
ожидания данных от клиента (Джефф Джейнс, Том Лейн)
• Устранение ошибки, приводившей к выделению лишней памяти для строки результатов
array_out() (Кэйити Хиробэ)
• Предотвращение утечки памяти на время выполнения запроса при работе с XMLTABLE (Эндрю
Гирт)
• Ликвидация утечки памяти при сканировании индекса SP-GiST (Том Лейн)
Сколько-нибудь значительное проявление этой утечки наблюдалось, только когда для ограни-
чения-исключения, использующего SP-GiST, в индекс поступало много записей.
• Закрытие файла сопоставлений в ApplyLogicalMappingFile() после завершения его использо-
вания (Томаш Вондра)
Ранее дескриптор файла терялся, что могло в итоге приводить к сбоям при логическом деко-
дировании.
• Устранение ошибки логического декодирования в случаях, когда сопоставленная таблица ка-
талога постоянно перезаписывается, например, в результате действия VACUUM FULL (Андрес
Фройнд)
• Предотвращение запуска сервера со значением wal_level, недостаточно большим для под-
держки существующего слота репликации (Андрес Фройнд)
• Предотвращение сбоя в случаях, когда служебная команда создаёт бесконечную рекурсию
(Том Лейн)
• Устранение в процессе инициализации горячего резерва проблемы дублирующихся XID, ко-
торые образуются при выполнении двухфазных транзакций на ведущем сервере (Микаэль Па-
кье, Константин Книжник)
• Исправление поведения событийных триггеров при обработке вложенных команд ALTER TABLE
(Микаэль Пакье, Альваро Эррера)
• Передача параллельным исполнителям времени начала оператора и транзакции от родитель-
ского процесса (Константин Книжник)
Тем самым исправлено поведение таких функций, как transaction_timestamp(), выполняю-
щихся в параллельном исполнителе.
• Обеспечение корректного выравнивания при передаче расширенных значений данных парал-
лельным исполнителям, что позволяет избежать сбоев на платформах, требовательных к вы-
равниванию (Том Лейн, Амит Капила)
• Исправление логики переработки файла WAL для правильного выполнения этой операции на
ведомых серверах (Микаэль Пакье)
В зависимости от значения параметра archive_mode ведомый сервер мог не удалить некото-
рые файлы WAL, подлежащие удалению.
2300Замечания к выпуску
• Исправление обработки времени фиксации транзакций в процессе восстановления (Масахико
Савада, Микаэль Пакье)
Если отслеживание времени фиксации не было включено постоянно, в процессе восстановле-
ния мог произойти сбой при попытке получить время фиксации транзакции, для которой оно
не было записано.
• Использование случайной затравки для random() в initdb, а также в сервере, запускаемом в
режиме начальной загрузки и в монопольном режиме (Ной Миш)
Практическая польза этого изменения состоит прежде всего в разрешении проблемы, когда
программа initdb не могла использовать общую память POSIX, считая её недоступной, из-за
конфликтов имён, вызванных использованием одинаковой затравки.
• Предотвращение повреждения общей памяти в логике DSA (Томас Мунро)
• Возможность прерывания операции выделения памяти в DSM (Крис Трэверс)
• Предупреждение сбоя в параллельном исполнителе при загрузке расширения, пытающегося
обратиться к системным кешам в своей функции инициализации (Томас Мунро)
Мы не считаем это удачным приёмом программирования расширений, но до внедрения парал-
лельных запросов это работало, а значит должно поддерживаться и теперь.
• Исправление поведения при динамическом включении параметра full_page_writes (Кётаро
Хоригути)
• Недопущение возможного сбоя в результате двойного освобождения памяти при повторном
сканировании SP-GiST (Эндрю Гирт)
• Предотвращение некорректной компоновки функций в src/port и src/common на платформах
BSD, использующих формат ELF, а также в HP-UX и Solaris (Эндрю Гирт, Том Лейн)
Разделяемые библиотеки, загружаемые в адресное пространство сервера, могли использовать
серверные версии этих функций, а не собственные реализации, как должно быть. Так как в по-
ведении этих двух наборов функций имеются различия, это приводило к проблемам.
• Предупреждение возможного переполнения буфера при воспроизведении операции распаков-
ки страницы GIN из WAL (Александр Коротков, Шивасубраманьян Рамасубраманьян)
• Предотвращение переполнения метастраницы хеш-индекса в случаях, когда размер BLCKSZ
меньше значения по умолчанию (Дилип Кумар)
• Добавление ранее упущенного пересчёта контрольной суммы страницы в хеш-индексах (Амит
Капила)
• Выполнение операции fsync, ранее упущенной, для каталога слотов репликации (Константин
Книжник, Микаэль Пакье)
• Устранение неожиданных тайм-аутов при использовании wal_sender_timeout на медленном
сервере (Ной Миш)
• Исправление вычисления подходящей точки согласованности WAL в процессах горячего ре-
зерва (Александр Кукушкин, Микаэль Пакье)
Выбор правильной точки позволяет предотвратить некорректное поведение сразу после того,
как ведомый сервер достигает согласованного состояния базы при воспроизведении WAL.
• Корректная остановка фоновых рабочих процессов при получении главным процессом запро-
са на быстрое отключение до завершения запуска базы (Александр Кукушкин)
• Обновление карты свободного пространства при воспроизведении из WAL изменений флагов
замороженных/полностью видимых страниц (Альваро Эррера)
Ранее мы не заботились об этом, считая, что в карте свободного пространства в любом слу-
чае нет важной информации. Однако если она сильно устаревает, это может привести к зна-
чительному снижению производительности после повышения ведомого сервера до основного.
Эта карта в конце концов будет исправлена в результате обновлений, но мы хотим иметь её в
2301Замечания к выпуску
хорошем состоянии раньше, поэтому стоит приложить дополнительные усилия и поддержи-
вать её актуальность при воспроизведении WAL.
• Предотвращение преждевременного освобождения ресурсов параллельных исполнителей по
окончании запроса или при достижении предельного числа кортежей (Амит Капила)
В этот момент завершение исполнителя допустимо, только если вызывающий процесс не мо-
жет запросить обратное сканирование.
• Отказ от вызова обработчиков atexit при обработке SIGQUIT (Хейкки Линнакангас)
• Исключение сопоставлений пользователей для сторонних серверов из состава расширений
(Том Лейн)
При выполнении CREATE USER MAPPING в скрипте расширения для создаваемого сопоставле-
ния добавлялась зависимость, чего не должно быть. Сопоставления пользователей, как и ро-
ли, не могут быть членами расширений.
• Исправление поведения syslogger в случае ошибок при попытке открыть файлы CSV (Том
Лейн)
• При передаче в libpq нескольких имён узлов они должны разрешаться в DNS не все сразу, а
каждое в свою очередь (Том Лейн)
Это предотвращает отказы, которых можно избежать, и замедления подключения после
успешного соединения с одним из предыдущих серверов в списке.
• Исправление поведения libpq, чтобы тайм-ауты при подключении корректно применялись для
отдельного имени или IP-адреса узла (Том Лейн)
Ранее при некоторых условиях таймер при переключении на следующий узел не перезапус-
кался, что могло приводить к преждевременному тайм-ауту.
• Исправление кода psql, а также примеров в документации, чтобы функция PQconsumeInput()
вызывалась перед PQnotifies() (Том Лейн)
Тем самым решена проблема, когда psql не выдавал полученное сообщение NOTIFY до следую-
щей команды.
• Исправление в pg_dump обработки ключа –no-publications, чтобы с ним также игнорирова-
лись таблицы публикации (Жиль Даролд)
• Исключение из выгрузки pg_dump идентификационной последовательности при исключении
её родительской таблицы (Дэвид Роули)
• Устранение возможной несогласованности при сортировке различных имён объектов в
pg_dump (Джейкоб Чемпион)
• Исправление pg_restore, чтобы при выдаче команд DISABLE/ENABLE TRIGGER имя таблицы до-
полнялось схемой (Том Лейн)
Это предотвращает сбои, возможные при новой политике выполнения восстановления с огра-
ниченным путём поиска.
• В pg_upgrade исправлена обработка событийных триггеров в расширениях (Харибабу Комми)
Ранее pg_upgrade не сохранял связь событийных триггеров с расширениями.
• Исправление проверки состояния кластера в pg_upgrade, чтобы она корректно выполнялась
на ведомом сервере (Брюс Момджян)
• Ограничение числа размерностей в значениях cube во всех функциях contrib/cube (Андрей
Бородин)
Ранее в некоторых функциях, связанных с кубами, можно было создать такие значения, кото-
рые затем не принимала функция cube_in(), что вызывало ошибки при восстановлении вы-
груженных данных.
2302Замечания к выпуску
• В contrib/pg_stat_statements роли pg_read_all_stats запрещено выполнение
pg_stat_statements_reset() (Харибабу Комми)
Роли pg_read_all_stats должно позволяться только чтение статистики, но не её изменение,
поэтому разрешение на выполнение этой функции ей было дано некорректно.
Чтобы это изменение вступило в силу, выполните ALTER EXTENSION pg_stat_statements
UPDATE в каждой базе данных, где установлено расширение pg_stat_statements.
• Недопущение передачи расширением contrib/postgres_fdw предложений ORDER BY, не со-
держащих переменных, на удалённый сервер (Эндрю Гирт)
• Исправление функции unaccent() в расширении contrib/unaccent, чтобы она использовала
словарь текстового поиска unaccent, находящийся в той же схеме, где и сама функция (Том
Лейн)
Ранее она пыталась найти словарь по пути поиска, но могла не обнаружить его, если путь по-
иска был ограничен.
• Устранение проблем при сборке в macOS 10.14 (Mojave) (Том Лейн)
Усовершенствование скрипта configure, чтобы в CPPFLAGS добавлялся ключ -isysroot; без
этого PL/Perl и PL/Tcl нельзя сконфигурировать или собрать в macOS 10.14. Значение sysroot
можно переопределить во время конфигурирования или сборки, установив переменную
PG_SYSROOT в аргументах configure или make.
Теперь рекомендуется, чтобы для связанных с Perl расширений во флагах компилятора указы-
валось $(perl_includespec), а не -I$(perl_archlibexp)/CORE. Второй вариант по-прежнему
будет работать на большинстве платформ, но не в последних macOS.
Также теперь не требуется указывать вручную ключ –with-tclconfig, чтобы собрать PL/Tcl в
последних версиях macOS.
• Исправление скриптов сборки с MSVC и регрессионного тестирования для работы с последни-
ми версиями Perl (Эндрю Дунстан)
Это изменение вызвано тем, что Perl теперь по умолчанию не включает текущий каталог в
свой путь поиска.
• Реализована возможность запускать регрессионные тесты в Windows с учётной записью адми-
нистратора (Эндрю Дунстан)
Чтобы это было безопасно, pg_regress теперь лишает себя расширенных прав при запуске.
• Снятие запрета на возврат из функций сравнения btree значений INT_MIN (Том Лейн)
До настоящего времени мы не позволяли типозависимым функциям сравнения возвращать
INT_MIN, благодаря чему вызывающий код мог сменить порядок сортировки, просто изменив
знак результата сравнения. Однако это могло вызывать проблемы с функциями сравнения,
возвращающими непосредственно результат memcmp(), strcmp() и подобных функций, так как
POSIX не накладывает на него никаких ограничений. Как минимум некоторые последние вер-
сии memcmp() могут возвращать INT_MIN, что приводило к нарушению порядка сортировки. В
связи с этим мы убрали это ограничение. Там же, где требуется поменять порядок сортировки
на противоположный, теперь нужно использовать макрос INVERT_COMPARE_RESULT().
• Устранение риска рекурсии при обработке сообщений об аннулировании общего кеша (Том
Лейн)
Эта ошибка могла привести, например, к сбою при обращении к системному каталогу или ин-
дексу, который был только что обработан командой VACUUM FULL.
В результате этого изменения функция LockAcquire теперь может возвращать новый код ре-
зультата, что теоретически может вызвать проблемы при использовании этой функции, хо-
2303Замечания к выпуску
тя для этого схема её использования должна быть весьма необычной. Также был изменён API
функции LockAcquireExtended.
• Сохранение и восстановление глобальных переменных SPI в SPI_connect() и SPI_finish()
(Чепмен Флэк, Том Лейн)
Это предотвращает накладки, возможные при вызове из одной функции, использующей SPI,
другой такой функции.
• Предотвращение использования потенциально невыравненных буферов страниц (Том Лейн)
Добавлены новые типы-объединения PGAlignedBlock и PGAlignedXLogBlock, которые должны
использоваться вместо простых массивов char, чтобы компилятор гарантированно выравни-
вал адрес начала буфера. В результате устраняется риск аварийного сбоя на платформах, чув-
ствительных к выравниванию, и может увеличиться быстродействие даже на тех платформах,
где выравнивание не требуется.
• Приведение в src/port/snprintf.c значения результата snprintf() в соответствие со стан-
дартом C99 (Том Лейн)
На платформах, где этот код используется (в основном в Windows), его несовременное поведе-
ние (не соответствующие C99) могло препятствовать выявлению переполнения буфера, если
вызывающий код рассчитывал на семантику C99.
• Требование обязательного использования -msse2 при сборке компилятором clang для i386
(Андрес Фройнд)
Тем самым решается проблема отсутствия проверок переполнения при операциях с плаваю-
щей точкой.
• Исправление в configure проверки, определяющей, результат какого типа возвращает
strerror_r() (Том Лейн)
Предыдущая реализация давала неправильный ответ при сборке с использованием компиля-
тора icc в Linux (возможно, и в других случаях), в результате чего libpq не выдавала полезные
сообщения при возникновении системных ошибок.
• Обновление данных часовых поясов до версии tzdata 2018g, включающее изменений правил
перехода на летнее время в России (Волгограде), Чили, Марокко и на Фиджи, а также коррек-
тировку исторических данных для Китая, Гавайев, Японии, Макао и Северной Кореи.
E.4. Выпуск 10.5
Дата выпуска:
2018-08-09
В этот выпуск вошли различные исправления, внесённые после версии 10.4. За информацией о
нововведениях версии обратитесь к Разделу E.9.
E.4.1. Миграция на версию 10.5
Если используется версия 10.X, выгрузка/восстановление базы не требуется.
Если вы обновляете сервер с более ранней версии, чем 10.4, см. также Раздел E.5.
E.4.2. Изменения
• Осуществление полного сброса состояния libpq между попытками соединения (Том Лейн)
Непривилегированный пользователь dblink или postgres_fdw мог обойти проверки, пред-
назначенные для предотвращения использования учётных данных на стороне сервера, на-
пример, файла ~/.pgpass, принадлежащего пользователю ОС, от имени которого работа-
2304Замечания к выпуску
ет сервер. В частности, уязвимость затрагивает серверы, принимающие локальные подклю-
чения с методом peer. Возможны были и другие атаки, например, SQL-инъекции в сеансе
postgres_fdw. Для атаки на postgres_fdw через эту уязвимость пользователь должен был
иметь возможность создавать объект стороннего сервера с нужными параметрами подключе-
ния, но атаку на dblink мог произвести любой пользователь, имеющий к нему доступ. Вообще
любой пользователь, имеющий возможность менять параметры подключения для приложения
на базе libpq, мог производить непредусмотренные действия, но другие эффективные сцена-
рии эксплуатации этого сложно придумать. Мы благодарим Андрея Красичкова за сообщение
о данном дефекте. (CVE-2018-10915)
• Исправление поведения INSERT … ON CONFLICT UPDATE с более сложным представлением,
чем просто SELECT * FROM … (Дин Рашид, Амит Ланготе)
Ошибочное развёртывание изменяемого представления могло приводить к сбоям или ошиб-
кам «attribute … has the wrong type» (атрибут … имеет неверный тип), если список SELECT
представления не соответствовал в точности списку столбцов нижележащей таблицы. Более
того, развив атаку через эту уязвимость, злоумышленник мог изменять столбцы, не имея для
них права UPDATE, но имея права INSERT и UPDATE для некоторых других столбцов в таблице.
Любой пользователь также мог эксплуатировать её для раскрытия содержимого памяти сер-
вера. (CVE-2018-10925)
• Обеспечение своевременного изменения полей relfrozenxid и relminmxid в «зафиксирован-
ных» системных каталогах (Андрес Фройнд)
Из-за чрезмерно оптимистичного кеширования эти изменения могли оказаться невидимыми
для других сеансов, что приводило к случайным ошибкам и/или разрушению данных. Для об-
щих каталогов, таких как pg_authid, проблема была ещё острее, так как устаревшие кеширо-
ванные данные могли попадать в новые сеансы и оставаться в существующих.
• Исправление поведения в ситуации, когда недавно повышенный сервер аварийно завершает-
ся до окончания обработки первой контрольной точки после восстановления (Микаэль Пакье,
Кётаро Хоригути, Паван Деоласи, Альваро Эррера)
В такой ситуации сервер не считал, что при последующем воспроизведении WAL было достиг-
нуто согласованное состояние базы данных, и это препятствовало его перезапуску.
• Исключение выдачи фантомной записи WAL при переработке полностью нулевой страницы
индекса btree (Амит Капила)
Эта ошибка проявлялась в сбоях проверочных утверждений и могла приводить к неоправдан-
ным отменам запросов на серверах горячего резерва.
• При воспроизведении WAL добавлена защита от некорректной длины записи, превышающей 1
ГБ (Микаэль Пакье)
Подобные данные должны считаться некорректными. Ранее код пытался выделить такой объ-
ём и получал критическую ошибку, что делало восстановление невозможным.
• При завершении восстановления запись в файл истории линии времени должна откладывать-
ся, насколько это возможно (Хейкки Линнакангас)
Это позволяет избежать ситуаций с несогласованностью состояния линии времени на диске,
возникавших при сбое в процессе очистки после восстановления (например, при проблеме с
файлом двухфазного состояния).
• Увеличение скорости воспроизведения WAL для транзакций, удаляющих множество отноше-
ний (Фудзии Масао)
В результате этого изменения уменьшается число сканирований общих буферов, поэтому эф-
фект от данного изменения тем больше, чем больше значение shared_buffers.
• Увеличение скорости освобождения блокировки при воспроизведении WAL ведомым сервером
(Томас Мунро)
2305Замечания к выпуску
• Обеспечение согласованной передачи состояния логической трансляции передатчиками WAL
(Саймон Риггс, Савада Масахико)
Ранее код не мог правильно определить, удалось ли нагнать вышестоящий сервер.
• Обеспечение наличия снимка при выполнении функций ввода типа данных в подписчиках ло-
гической репликации (Мин-Цюань Тран, Альваро Эррера)
Отсутствие снимка в некоторых случаях приводило к сбоям, например, при вводе доменов с
ограничениями, определяемыми функциями на языке SQL.
• Устранение дефектов в процедуре обработки снимков при логическом декодировании, приво-
дивших к ошибкам декодирования в редких случаях (Арсений Шер, Альваро Эррера)
• Добавление обработки подтранзакций в рабочих процессах синхронизации таблиц при логиче-
ской репликации (Амит Хандекар, Роберт Хаас)
Ранее синхронизация таблицы могла выполняться некорректно в случае отката подтранзак-
ций после модификации синхронизируемой таблицы.
• Обеспечение корректного сброса кешированного списка индексов таблицы после сбоя при со-
здания индекса (Питер Геохеган)
Ранее в этом списке могли оставаться OID нерабочих индексов, что могло приводить к про-
блемам в том же сеансе.
• Исправление некорректной обработки пустых несжатых страниц списка идентификаторов в
индексах GIN (Шивасубраманьян Рамасубраманьян, Александр Коротков)
Это могло привести к сбою проверочного утверждения после выполнения pg_upgrade для ин-
дексов GIN версии до 9.4 (в 9.4 и последующих версиях такие страницы не создаются).
• Выравнивание массивов безымянных семафоров POSIX для уменьшения разделения линий ке-
ша (Томас Мунро)
Это снижает конкуренцию в многопроцессорных системах и устраняет падение производи-
тельности (наблюдаемое в сравнении с предыдущими выпусками) в Linux и FreeBSD.
• Обеспечение реакции на сигналы в процессе, производящем параллельное сканирование ин-
декса (Амит Капила)
Ранее параллельные исполнители могли «зависать», ожидая блокировки страницы индекса, и
не замечать сигналы прерывания запроса.
• Обеспечение реакции на сигналы в процессе VACUUM в цикле удаления страниц B-дерева (Ан-
дрес Фройнд)
С испорченными индексами btree цикл мог оказаться бесконечным, и прервать его можно бы-
ло только аварийно отключив сервер.
• Исправление ошибки с оценкой стоимости соединения по хешу при оптимизации inner_unique
(Дэвид Роули)
Это могло приводить к выбору неудачного плана запроса, когда применялась эта оптимиза-
ция.
• Исправление некорректной оптимизации классов эквивалентности со столбцами составного
типа (Том Лейн)
Вследствие данной ошибки сервер не понимал, что индекс по составному столбцу может обес-
печить порядок сортировки, необходимый для соединения слиянием с данным столбцом.
• Исправление планировщика с целью устранения ошибок «ORDER/GROUP BY expression not
found in targetlist» (выражение ORDER/GROUP BY не найдено в целевом списке) при выполне-
нии некоторых запросов с функциями, возвращающими множества (Том Лейн)
2306Замечания к выпуску
• Исправление обработки ключей секционирования с типами данных, которые используют по-
лиморфный класс операторов btree; например, это касается массивов (Амит Ланготе, Альваро
Эррера)
• Исправление синтаксиса конструкции SQL-стандарта FETCH FIRST, чтобы она принимала ($n),
как того требует стандарт (Эндрю Гирт)
• Удаление недокументированного ограничения, не допускающего дублирования столбцов в
ключах разбиения (Юго Нагата)
• Недопущение использования временных таблиц в качестве секций не временных, а обычных
таблиц (Амит Ланготе, Микаэль Пакье)
Ранее такое использование разрешалось, но работало ненадёжно.
• Исправление в EXPLAIN учёта использования ресурсов, в частности, обращений к буферам
(Амит Капила, Томас Мунро)
• Исправление поведения SHOW ALL, чтобы эта команда показывала все параметры членам ро-
ли pg_read_all_settings и позволяла этим пользователям видеть имя файла и номер строки в
представлении pg_settings (Лоренц Альбе, Альваро Эррера)
• Корректное добавление схемы к именам ряда объектов в выводе getObjectDescription и
getObjectIdentity (Кётаро Хоригути, Том Лейн)
Имена правил сортировки, преобразований, объектов текстового поиска, отношений публика-
ций и объектов расширенной статистики не дополнялись схемой, тогда как должны были.
• Исправление проверки типа CREATE AGGREGATE с тем, чтобы к агрегатам с переменными аргу-
ментами можно было присоединять функции поддержки распараллеливания (Алексей Башта-
нов)
• Расширение счётчика строк в команде COPY FROM с 32 до 64 бит (Дэвид Роули)
Тем самым были решены две проблемы с входными данными, содержащими более 4G строк:
COPY FROM WITH HEADER терял одну строку на каждые 4G строк (не только первую), а в сообще-
ниях об ошибках выводилось неверное количество строк.
• Восстановление возможности удаления слотов репликации в однопользовательском режиме
(Альваро Эррера)
Она была непреднамеренно утрачена в выпуске 10.0.
• Исправление некорректных результатов функции variance(int4) и связанных агрегатов при
работе в параллельном режиме агрегирования (Дэвид Роули)
• Внесение корректив в обработку узлов TEXT и CDATA в выражениях столбцов xmltable() (Мар-
кус Винанд)
• Защита от возможной ошибки в функции OpenSSL RAND_bytes() (Дин Рашид, Микаэль Пакье)
При редких обстоятельствах это упущение могло приводить к отказам с сообщением «could
not generate random cancel key» (не удалось сгенерировать случайный ключ отмены), устра-
нить которые можно было, только перезапустив главный процесс.
• Исправление поведения libpq в некоторых случаях, когда задаётся hostaddr (Хари Бабу, Том
Лейн, Роберт Хаас)
Функция PQhost() в некоторых случаях выдавала некорректные или вводящие в заблуждение
результаты. Теперь она единообразно возвращает имя узла (если оно указано), или адрес узла
(если указан только он), или имя узла по умолчанию (обычно /tmp либо localhost, если опу-
щены оба параметра).
Также при проверке сертификата SSL с именем сервера могло сравниваться неправильное
значение.
2307Замечания к выпуску
Кроме того, поле с именем узла в ~/.pgpass могло сравниваться с неправильным значением.
Теперь это поле сравнивается с именем сервера (если оно указано), либо с его адресом (если
указан только он), либо с localhost (если опущены оба параметра).
Помимо этого, когда значение hostaddr нельзя было разобрать, выдавалось неправильное со-
общение об ошибке.
А когда параметры host, hostaddr или port содержат списки через запятую, libpq теперь ак-
куратнее обрабатывает пустые элементы списков (воспринимая их как значения по умолча-
нию).
• Добавление в библиотеку ecpg pgtypes функции освобождения строк для исключения про-
блем с управлением памятью в разных модулях (Такаюки Цунакава)
В Windows могут происходить сбои, если вызов free для некоторого блока памяти произво-
дится не из той DLL, которая выделила память (с помощью malloc). Библиотека pgtypes ино-
гда возвращает строки, которые должен освободить вызывающий код, и сделать это корректно
оказывается невозможно. Добавленная функция PGTYPESchar_free() является просто обёрт-
кой free, позволяющей приложениям произвести освобождение по правилам.
• Исправление поддержки в ecpg переменных long long в Windows, а также на других платфор-
мах, где strtoll/strtoull объявлены нестандартно или не объявлены вовсе (Хыонг Дангминь,
Том Лейн)
• Исправление ошибки с определением типа SQL-оператора в PL/pgSQL, когда изменение пра-
вила приводило к изменению семантики оператора в рамках сеанса (Том Лейн)
Эта ошибка приводила к сбоям проверочных утверждений или, в редких случаях, к тому, что
указание INTO STRICT не работало должным образом.
• Исправление запроса пароля в клиентских программах, чтобы отображение корректно отклю-
чалось в Windows, когда stdin — не терминал (Мэтью Стикни)
• Доработка исправления некорректного заключения в кавычки значений для переменных GUC
со списками при формировании дампа (Том Лейн)
Предыдущее исправление для заключения в кавычки значения search_path и других пере-
менных со списками в выводе pg_dump, как оказалось, привело к ошибкам со списками с пу-
стыми элементами и риску потери части длинных файловых путей.
• В pg_dump устранено упущение, когда свойства REPLICA IDENTITY для индексов ограничений
не выгружались (Том Лейн)
Уникальные индексы, созданные вручную, помечались корректно, а индексы, созданные огра-
ничениями UNIQUE или PRIMARY KEY — нет.
• В pg_upgrade теперь правильно проверяется, что старый сервер был выключен штатно (Брюс
Момджян)
Ранее проверка могла сработать некорректно при выключении сервера в незамедлительном
режиме.
• Исправление в contrib/hstore_plperl просмотра скалярных ссылок Perl и предотвращение
сбоя в случае, если не удаётся найти хеш-ссылку там, где она ожидается (Том Лейн)
• Устранение сбоя в функции модуля contrib/ltree при получении на вход пустого массива
(Пьер Дюкроке)
• Исправление обработки ошибок в ряде мест, где мог выдаваться некорректный код ошибки
(Микаэль Пакье, Том Лейн, Магнус Хагандер)
• Переоформление скриптов Makefile для обеспечения компоновки программ с собранными в
том же дереве библиотеками (например, libpq.so), а не с теми, что могут уже находиться в
системных каталогах библиотек (Том Лейн)
2308Замечания к выпуску
Это позволяет избежать проблем при сборке на платформах, где представлены старые версии
библиотек PostgreSQL.
• Обновление данных часовых поясов до версии tzdata 2018e, включающее изменение правил
перехода на летнее время в Северной Корее, а также корректировку исторических данных
для Чехословакии.
В это обновление вошло переопределение «летнего времени», которое действует в Ирландии,
а также действовало в прошлом в Намибии и в Чехословакии. В этих юрисдикциях стандарт-
ное время действует летом, а время для экономии света — зимой, поэтому при переходе на
это время сдвиг производится на час назад, а не на час вперёд. Это не влияет ни на фактиче-
ское смещение от UTC, ни на используемое сокращение часового пояса; эта особенность про-
является лишь в том, что в таких случаях столбец is_dst в представлении pg_timezone_names
будет содержать true для зимнего периода, и false для летнего.
E.5. Выпуск 10.4
Дата выпуска:
2018-05-10
В этот выпуск вошли различные исправления, внесённые после версии 10.3. За информацией о
нововведениях 10 версии обратитесь к Разделу E.9.
E.5.1. Миграция на версию 10.4
Если используется версия 10.X, выгрузка/восстановление базы не требуется.
Однако если вы используете расширение adminpack, его нужно обновить, следуя указаниям в пер-
вой записи в списке изменений.
Кроме того, если вас касаются ошибки с пометкой функций, описанные во второй и третьей записи
ниже, потребуются дополнительные действия для исправления каталогов баз данных.
Если вы обновляете сервер с более ранней версии, чем 10.3, см. также Раздел E.6.
E.5.2. Изменения
• Лишение роли public права на выполнение функции pg_logfile_rotate() из contrib/
adminpack (Стивен Фрост)
Функция pg_logfile_rotate() является устаревшей оболочкой функции ядра
pg_rotate_logfile(). Когда в последней была удалена жёсткая проверка суперпользователя,
чтобы доступ к этой функции ограничивался правами SQL, эти изменения следовало отразить
и в pg_logfile_rotate(), но это было упущено. Таким образом, с установленным расширени-
ем adminpack любой пользователь мог запросить прокрутку файла журнала, что можно счи-
тать некритичным нарушением безопасности.
После установки этого обновления администраторы должны обновить adminpack, выпол-
нив ALTER EXTENSION adminpack UPDATE в каждой базе данных, где установлен adminpack.
(CVE-2018-1115)
• Исправление некорректных пометок изменчивости для нескольких встроенных функций (То-
мас Мунро, Том Лейн)
Функции query_to_xml, cursor_to_xml, cursor_to_xmlschema, query_to_xmlschema и
query_to_xml_and_xmlschema должны были считаться изменчивыми, так как они выполняют
пользовательские запросы, в которых могут быть изменчивые операции. Однако они не бы-
ли помечены должным образом, что было чревато неправильной оптимизацией запросов. Это
было исправлено для новых инсталляций в результате корректировки исходных данных ката-
лога, но в существующих инсталляциях ошибочные пометки сохранятся. При практическом
2309Замечания к выпуску
использовании этих функций риск кажется небольшим, но в случае необходимости их мож-
но исправить, вручную изменив записи этих функций в pg_proc. Например: ALTER FUNCTION
pg_catalog.query_to_xml(text, boolean, boolean, text) VOLATILE. (Заметьте, что это нуж-
но будет проделать в каждой базе данных инсталляции.) Также вы можете обновить базу до
версии с корректными исходными данными, воспользовавшись pg_upgrade.
• Исправление некорректных пометок параллельно-безопасности для нескольких встроенных
функций (Thomas Munro, Tom Lane)
Функции brin_summarize_new_values, brin_summarize_range, brin_desummarize_range,
gin_clean_pending_list, cursor_to_xml, cursor_to_xmlschema, ts_rewrite, ts_stat,
binary_upgrade_create_empty_extension и pg_import_system_collations должны были счи-
таться параллельно-небезопасными, так как одни из них непосредственно модифицируют ба-
зу данных, а другие выполняют пользовательские запросы, которые могут это делать. Они
были некорректно помечены как параллельно-безопасные, что могло приводить к неожи-
данным ошибкам запросов. Это было исправлено для новых инсталляций в результате кор-
ректировки исходных данных каталога, но в существующих инсталляциях ошибочные помет-
ки сохранятся. При практическом использовании этих функций риск кажется небольшим,
если только не включён режим force_parallel_mode, но в случае необходимости их мож-
но исправить, вручную изменив записи этих функций в pg_proc. Например: ALTER FUNCTION
pg_catalog.brin_summarize_new_values(regclass) PARALLEL UNSAFE. (Заметьте, что это нуж-
но будет проделать в каждой базе данных инсталляции.) Также вы можете обновить базу до
версии с корректными исходными данными, воспользовавшись pg_upgrade.
• Предотвращение повторного использования для TOAST идентификаторов OID, соответствую-
щих уже неактуальным, но ещё не очищенным записям TOAST (Паван Деоласи)
После зацикливания счётчика OID имеется возможность использования для значения TOAST
идентификатора OID, соответствующего ранее удалённой записи в той же таблице TOAST.
Если запись не была очищена к тому времени, это приводило к ошибкам «unexpected chunk
number 0 (expected 1) for toast value nnnnn» (неожиданный номер порции 0 (ожидался 1) для
значения TOAST nnnnn), которые сохранялись до удаления неактуальной записи командой
VACUUM. В качестве решения выбор таких OID при создании новых записей TOAST теперь ис-
ключается.
• Корректная проверка всех ограничений CHECK для отдельных секций при выполнении COPY в
секционированную таблицу (Эцуро Фудзита)
Ранее проверялись только ограничения, заданные для секционированной таблицы в целом.
• Допущение значений TRUE и FALSE в качестве границ секции (Амит Ланготе)
Ранее для логического секционирующего столбца принимались только строковые литералы,
но pg_dump выводит эти значения как TRUE/FALSE, что приводило к ошибкам при выгрузке/за-
грузке данных.
• Исправление работы с памятью в функциях сравнения ключей секционирования (Альваро Эр-
рера, Амит Ланготе)
Эта ошибка могла приводить к сбоям при использовании для ключей секционирования клас-
сов операторов, определённых пользователем.
• Устранение возможности сбоя при добавлении запросом кортежей в несколько секций секци-
онированной таблицы, когда эти секции имеют разные типы строк (Эцуро Фудзита, Амит Лан-
готе)
• Изменение алгоритма ANALYZE в части модификации pg_class.reltuples (Дэвид Гулд)
Ранее плотность кортежей могла обновляться только для страниц, прошедших обработку
ANALYZE, для остальных плотность считалась прежней. В большой таблице, где ANALYZE выби-
рает лишь небольшой процент страниц, это означает, что возможно лишь незначительное из-
менение общей оценки плотности кортежей, и поэтому reltuples будет меняться практиче-
2310Замечания к выпуску
ски пропорционально изменениям физического размера таблицы (relpages) вне зависимо-
сти от того, что фактически происходит в таблице. В результате может наблюдаться настоль-
ко большое увеличение reltuples по сравнению с реальностью, что автоматическая очистка
практически отключается. Для исправления этой ошибки принимается, что выборка ANALYZE
является статистически несмещённой (какой она и должна быть), и наблюдаемая в ней плот-
ность просто экстраполируется на всю таблицу.
• Включение объектов расширенной статистики в набор свойств таблицы, копируемых кон-
струкцией CREATE TABLE … LIKE … INCLUDING ALL (Дэвид Роули)
Также добавлено указание INCLUDING STATISTICS для явного управления включением этой
информации.
• Исправление работы CREATE TABLE … LIKE со столбцами идентификации типа bigint (Пи-
тер Эйзентраут)
На платформах, где long имеет размер 32 бита (что включает 64-битные Windows, а также
большинство 32-битных систем), копируемые параметры последовательностей усекались до
32 бит.
• Предупреждение взаимоблокировок в параллельных командах CREATE INDEX CONCURRENTLY,
выполняемых на уровнях изоляции SERIALIZABLE и REPEATABLE READ (Том Лейн)
• Устранение возможности замедленного выполнения REFRESH MATERIALIZED VIEW
CONCURRENTLY (Томас Мунро)
• Устранение ошибки в UPDATE/DELETE … WHERE CURRENT OF в случае, когда задействованный
курсор использует план сканирования только индекса (Юго Нагата, Том Лейн)
• Исправление некорректного планирования, когда предложения соединения передавались в
параметризованные пути (Эндрю Гирт, Том Лейн)
Эта ошибка могла привести к неправильной классификации условия как «фильтра соедине-
ния» для внешнего соединения, тогда как оно должно быть простым «фильтром», и в итоге
мог получиться некорректный результат соединения.
• Устранение возможности некорректного построения плана сканирования только индекса в
случаях, когда один столбец таблицы фигурирует в нескольких индексах, но не во всех этих
индексах используются классы операторов, которые могут выдать значение столбца (Кётаро
Хоригути)
• Исправление некорректной оптимизации ограничений CHECK с гарантированными NULL-под-
выражениями в условиях верхнего уровня AND/OR (Том Лейн, Дин Рашид)
В результате, например, ограничение-исключение могло исключить из запроса дочернюю
таблицу, которая не должна быть исключена.
• Предотвращение сбоя планировщика в случаях, когда запрос содержит несколько наборов
GROUPING SETS, и ни один из них нельзя получить сортировкой (Эндрю Гирт)
• Устранение сбоя исполнителя в результате двойного освобождения памяти с некоторыми ва-
риантами использования GROUPING SET (Питер Геохеган)
• Исправление некорректного выполнения замкнутого соединения переходных таблиц (Томас
Мунро)
• Предотвращение сбоя в случае, когда триггер события перезаписи таблицы добавляется од-
новременно с выполнением команды, которая может вызвать такой триггер (Альваро Эррера,
Эндрю Гирт, Том Лейн)
• Предотвращение ошибки при прерывании запроса или прекращении сеанса в момент фикси-
рования подготовленной транзакции (Стас Кельвич)
• Ликвидация утечки памяти на время выполнения запроса в последовательно выполняемых со-
единениях по хешу (Том Лейн)
2311Замечания к выпуску
• Устранение возможных утечек или двойного освобождения закреплений буферов карты види-
мости (Амит Капила)
• Устранение неоправданной пометки страниц как полностью видимых (Дэн Вуд, Паван Деола-
си, Альваро Эррера)
Это могло происходить при блокировании (но не удалении) некоторых кортежей. Хотя за-
просы будут продолжать выполняться корректно, процедура очистки обычно игнорирует та-
кие страницы, вследствие чего кортежи на них никогда не будут замораживаться. В послед-
них выпусках это в конце концов приведёт к появлению ошибок вида «found multixact nnnnn
from before relminmxid nnnnn» (найдена мультитранзакция nnnnn, предшествующая relminmxid
nnnnn).
• Исправление излишне строгой проверки в heap_prepare_freeze_tuple (Альваро Эррера)
Это могло приводить к необоснованной ошибке «cannot freeze committed xmax» (не удаётся за-
морозить зафиксированный xmax) в базах данных, обновлённых с помощью pg_upgrade с вер-
сии 9.2 или старее.
• Устранение потери указателя в случаях, когда написанный на С триггер, выполняемый до из-
менения строки, возвращает старый кортеж («old») (Рушаб Латиа)
• Понижение уровня блокировки при планировании работы автоочистки (Джефф Джейнс)
Предыдущее поведение создавало значительные препятствия для параллельного выполнения
рабочих процессов в базах, содержащих множество таблиц.
• Обеспечение копирования имени клиентского компьютера при копировании данных
pg_stat_activity в локальную память (Эдмунд Хорнер)
Ранее предположительно локальный экземпляр содержал указатель на разделяемую память,
вследствие чего содержимое поля с именем клиентского компьютера могло неожиданно из-
мениться при отключении какого-либо сеанса.
• Корректная обработка информации pg_stat_activity для вспомогательных процессов (Эд-
мунд Хорнер)
Поля application_name, client_hostname и query для таких процессов могли содержать
неверные данные.
• Исправление некорректной обработки нескольких составных аффиксов в словарях ispell (Ар-
тур Закиров)
• Исправление поиска (то есть сканирования индекса с операторами неравенства), зависимого
от правила сортировки, в индексах SP-GiST, построенных по текстовым столбцам (Том Лейн)
Такой поиск мог возвращать неправильный набор строк для большинства правил сортировки,
отличных от C.
• Предотвращение утечки памяти на время выполнения запроса в классах операторов SP-GiST,
использующих переходящие значения (Антон Дигнос)
• Корректировка вычисления количества кортежей в индексе при изначальном построении ин-
декса SP-GiST (Томаш Вондра)
Ранее количество кортежей в индексе считалось равным количеству кортежей в нижележа-
щей таблице, что неверно в случае частичного индекса.
• Корректировка вычисления количества кортежей в индексе при очистке индекса GiST (Ан-
дрей Бородин)
Ранее оно считалось равным примерному количеству кортежей в куче, что провоцировало
неточность и определённо было ошибочным в случае частичного индекса.
• Исправление поведения в особом случае, когда ведомый реплицирующий сервер «застревал»
на записи продолжения WAL (Кётаро Хоригути)
2312Замечания к выпуску
• При логическом декодировании приняты меры во избежание двойной обработки данных WAL
при перезапуске передатчика WAL (Крейг Рингер)
• Исправление механизма логической репликации, чтобы он не полагался на совпадение OID
типов между локальным и удалённым серверами (Масахико Савада)
• Поддержка использования scalarltsel и scalargtsel с расширенными типами данных (То-
маш Вондра)
• Уменьшение потребления памяти libpq в случаях, когда сервер выдаёт ошибку после получе-
ния большого объёма результата запроса (Том Лейн)
Полученный ранее результат должен быть отброшен до, а не после обработки ошибки. На
некоторых платформах, в частности в Linux это может влиять на то, сколько памяти будет за-
нимать приложение.
• Устранение сбоев в ecpg, вызванных двойным освобождением памяти (Патрик Крекер, Джи-
ван Ладхе)
• Исправление обработки переменных long long int в ecpg, собранном с использованием
MSVC (Михаэль Мескес, Эндрю Гирт)
• Исправление некорректного заключения в кавычки значений для переменных GUC со списка-
ми при формировании дампа (Микаэль Пакье, Том Лейн)
Переменные local_preload_libraries, session_preload_libraries,
shared_preload_libraries и temp_tablespaces не заключались в кавычки корректно в выводе
pg_dump. Это могло приводить к проблемам, если эти переменным присваивались значения в
конструкциях CREATE FUNCTION … SET или ALTER DATABASE/ROLE … SET.
• Предотвращение отказа pg_recvlogical при подключении к серверам PostgreSQL до 10 версии
(Микаэль Пакье)
В результате предыдущего исправления программа pg_recvlogical, не проверяя версию серве-
ра, выдавала команду, которая должна предназначаться только серверам версии 10 и новее.
• Исправление поведения pg_rewind, чтобы на целевом сервере удалялись файлы, которые мог-
ли быть удалены в процессе выполнения на исходном сервере (Такаюки Цунакава)
В противном случае на целевом сервере могла нарушаться согласованность данных, особенно
если это был файл сегмента WAL.
• Исправление в pg_rewind обработки таблиц в дополнительных табличных пространствах (Та-
каюки Цунакава)
• Исправление обработки целочисленного переполнения в циклах FOR на языке PL/pgSQL (Том
Лейн)
Ранее с некоторыми компиляторами, отличными от gcc, переполнение переменной цикла не
проверялось, в результате чего цикл оказывался бесконечным.
• Исправление регрессионных тестов PL/Python для совместимости с Python 3.7 (Питер Эйзен-
траут)
• Поддержка тестирования PL/Python и связанных модулей при сборке с использованием Python
3 и MSVC (Эндрю Дунстан)
• Устранение ошибок при изначальном построении индексов contrib/bloom (Томаш Вондра,
Том Лейн)
Предотвращение возможного исчезновения последнего кортежа таблицы из индекса. Исправ-
ление подсчёта количества кортежей в частичных индексах.
• Переименование функций b64_encode и b64_decode во избежание конфликта со встроенными
функциями Solaris 11.4 (Райнер Орт)
2313Замечания к выпуску
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией 2018e (Том
Лейн)
В этой версии усовершенствован компилятор данных часовых поясов zic для работы с отрица-
тельными смещениями при переходе на летнее время. Хотя проект PostgreSQL в настоящее
время не поставляет такие данные часовых поясов, zic может применяться с данными, полу-
ченными непосредственно от IANA, поэтому кажется разумным обновить zic сейчас.
• Обновление данных часовых поясов до версии tzdata 2018d, включающее изменения правил
перехода на летнее время в Палестине и Антарктиде (станция Кейси), плюс корректировку
исторических данных для Португалии и её колоний, а также Уругвая и островов Эндербери,
Ямайка, Теркс и Кайкос.
E.6. Выпуск 10.3
Дата выпуска:
2018-03-01
В этот выпуск вошли различные исправления, внесённые после версии 10.2. За информацией о
нововведениях 10 версии обратитесь к Разделу E.9.
E.6.1. Миграция на версию 10.3
Если используется версия 10.X, выгрузка/восстановление базы не требуется.
Однако если в вашей СУБД не все пользователи взаимно доверяют друг другу либо если вы под-
держиваете приложение или расширение, предназначенное для использования в произвольных
ситуациях, настоятельно рекомендуется прочитать об изменениях в первой записи ниже и пред-
принять соответствующие действия для защиты вашей инсталляции или кода.
Также изменения, описанные во втором пункте списка ниже, могут приводить к сбоям функций,
используемых в индексных выражениях или материализованных представлениях, во время авто-
матического анализа или при восстановлении выгруженных данных. Поэтому после обновления
проверьте журнал сервера на предмет подобных проблем и исправьте затронутые функции.
Также, если вы обновляете сервер с более ранней версии, чем 10.2, см. Раздел E.7.
E.6.2. Изменения
• Добавление в документацию информации о настройке серверов и приложений для защиты от
атак с внедрением троянского кода через путь поиска (Ной Миш)
Когда используется значение search_path, включающее схемы, доступные для записи зло-
намеренному пользователю, он может перехватывать управление над выполнением запросов
и затем запускать произвольный SQL-код с правами атакуемого пользователя. Хотя есть воз-
можность составлять запросы, защищённые от подобного перехвата, это требует кропотли-
вой работы, и при этом очень легко что-то упустить. Поэтому мы рекомендуем использовать
конфигурации, в которых пути поиска не могут включать недоверенные схемы. Соответству-
ющая информация добавлена в Подраздел 5.8.6 (для пользователей и администраторов баз
данных), Раздел 34.1 (для разработчиков приложений), Подраздел 38.16.1 (для разработчиков
расширений) и CREATE FUNCTION (для разработчиков функций с характеристикой SECURITY
DEFINER). (CVE-2018-1058)
• Предотвращение использования небезопасных значений search_path в pg_dump и других кли-
ентских программах (Ной Миш, Том Лейн)
pg_dump, pg_upgrade, vacuumdb и другие приложения, предоставляемые PostgreSQL, были
уязвимы для перехвата выполнения, описанного в предыдущем пункте; так как эти прило-
жения обычно запускаются суперпользователями, они представляли собой привлекательные
средства для атаки. Чтобы защитить их вне зависимости от того, защищена ли вся инсталля-
ция в целом, они были изменены так, чтобы для них параметр search_path содержал только
pg_catalog. Теперь это так же касается и рабочих процессов автоочистки.
2314Замечания к выпуску
В случаях, когда этими программами неявно вызываются определённые пользователем функ-
ции — например, это могут быть пользовательские функции в выражениях индексов — бо-
лее строгое значение search_path может приводить к ошибкам, которые потребуется испра-
вить так, чтобы эти функции никак не зависели от пути поиска, с которым они выполняются.
Это всегда рекомендовалось делать, но сейчас это необходимо для корректного поведения.
(CVE-2018-1058)
• Предотвращение попыток логической репликации передавать изменения в непубликуемых от-
ношениях (Питер Эйзентраут)
Публикация всех таблиц (с пометкой FOR ALL TABLES) могла некорректно передавать измене-
ния в материализованных представлениях и таблицах information_schema, которые не долж-
ны попадать в поток изменений.
• Исправление некорректного поведения перепроверок одновременных изменений со ссылками
CTE, фигурирующими во внутренних планах (Том Лейн)
Если ссылка на CTE (содержимое предложения WITH) использовалась в InitPlan или SubPlan, и
запросу требовалось провести перепроверку из-за попытки изменения или блокировки одно-
временно изменяемой строки, могли быть получены неверные результаты.
• Устранение сбоев планировщика при перекрывающихся предложениях соединения слиянием
во внешнем соединении (Том Лейн)
Эти дефекты приводили в особых случаях к ошибкам планировщика «left and right pathkeys
do not match in mergejoin» (нарушено соответствие левых и правых ключей пути в соединении
слиянием) или «outer pathkeys do not match mergeclauses» (внешние ключи пути не соответ-
ствуют предложениям слияния).
• Исправление ошибки в pg_upgrade, когда не удавалось сохранить relfrozenxid для материа-
лизованных представлений (Том Лейн, Андрес Фройнд)
Данное упущение могло приводить к разрушению данных в материализованных пред-
ставлениях после обновления. Это могло проявляться в ошибках «could not access status
of transaction» (не удалось получить состояние транзакции) или «found xmin from before
relfrozenxid» (найден xmin перед relfrozenxid). Эта проблема была более вероятна в редко об-
новляемых материализованных представлениях или в представлениях, обновляемых только
командой REFRESH MATERIALIZED VIEW CONCURRENTLY.
Если такое разрушение имело место, его можно исправить, обновив материализованное пред-
ставление (без указания CONCURRENTLY).
• Исправление некорректного вывода pg_dump для некоторых граничных значений последова-
тельностей (Алексей Баштанов)
• Исправление неправильной обработки в pg_dump объектов STATISTICS (Том Лейн)
Схема объекта расширенной статистики неправильно помечалась в оглавлении таблицы вы-
гружаемых данных, что могло приводить к некорректным результатам при восстановлении от-
дельных схем. Также некорректно восстанавливалась информация о владельце. Кроме того,
логика работы изменена так, чтобы объекты статистики выгружались/восстанавливались или
нет как независимые объекты, без учёта того, производится ли выгрузка/восстановление таб-
лицы, к которой они привязаны. Исходное определение не должно распространяться на пла-
нируемое будущее расширение статистики нескольких таблиц.
• Исправление некорректной обработки имён функций PL/Python в стеках ошибки CONTEXT (Том
Лейн)
Ошибка, произошедшая во вложенном вызове функции PL/Python (то есть функции, вызван-
ной через SPI-запрос из другой функции PL/Python), могла привести к тому, что в трассировке
стека вместо ожидаемого результата имя внутренней функции фигурировало дважды. Также
2315Замечания к выпуску
ошибка во вложенном блоке PL/Python DO могла привести к обращению по нулевому указате-
лю на некоторых платформах.
• Максимальное значение log_min_duration для contrib/auto_explain доведено до INT_MAX,
что составляет около 24 суток вместо 35 минут (Том Лейн)
• Для разнообразных переменных GUC добавлена пометка PGDLLIMPORT в целях облегчения пе-
реноса модулей расширений в Windows (Метин Дослу)
E.7. Выпуск 10.2
Дата выпуска:
2018-02-08
В этот выпуск вошли различные исправления, внесённые после версии 10.1. За информацией о
нововведениях 10 версии обратитесь к Разделу E.9.
E.7.1. Миграция на версию 10.2
Если используется версия 10.X, выгрузка/восстановление базы не требуется.
Однако если вы используете оператор ~&gt; расширения contrib/cube, прочитайте ниже запись о
нём.
Также, если вы обновляете сервер с более ранней версии, чем 10.1, см. Раздел E.8.
E.7.2. Изменения
• Исправление обработки ключей секционирования, содержащих несколько выражений (Альва-
ро Эррера. Дэвид Роули)
Эта ошибка приводила к сбоям или, со специально сконструированными данными, к раскры-
тию произвольного содержимого памяти обслуживающего процесса. (CVE-2018-1052)
• Временные файлы, создаваемые программой pg_upgrade, должны быть недоступны для чте-
ния всеми пользователями (Том Лейн, Ной Миш)
Программа pg_upgrade обычно ограничивает доступ к своим временным файлам, чтобы их
мог читать и записывать только запускающий её пользователь. Но временные файлы, содер-
жащие вывод pg_dumpall -g могли быть доступны для чтения группе или всем пользовате-
лям, а возможно и для записи, если это допускало значение umask этого пользователя. При
типичном использовании в многопользовательских системах umask и/или разрешения в рабо-
чем каталоге достаточно жёсткие и эта проблема неактуальна; но pg_upgrade может исполь-
зоваться и в сценариях, где это упущение могло привести, например, к утечке паролей баз
данных. (CVE-2018-1053)
• Исправление очистки кортежей, которые были изменены при установленной блокировке раз-
деляемого ключа (Андрес Фройнд, Альваро Эррера)
В некоторых случаях операция VACUUM не удаляла такие кортежи, даже когда они теряли акту-
альность, что приводило к различным сценариям повреждения данных.
• Исправление упущения, когда метастраница хеш-индекса не помечалась как «грязная» по-
сле добавления новой страницы переполнения, что могло приводить к порче индекса (Лисянь
Цзоу, Амит Капила)
• Осуществление очистки очереди добавлений индекса GIN при выполнении VACUUM (Масахи-
ко Савада)
Это необходимо для гарантированного удаления неактуальных записей индекса. Прежний код
делал это в другом порядке, позволяя операции VACUUM пропускать очистку, если какие-то
другие процессы производили очистку параллельно. Однако при этом в индексе могли оста-
ваться некорректные записи.
2316Замечания к выпуску
• Исправление неправильной блокировки буфера при некоторых чтениях LSN (Якоб Чемпион,
Асим Правин, Ашвин Агравал)
Эти ошибки могли приводит к некорректному поведению при многопоточной нагрузке. По-
тенциальные последствия не были характеризованы полностью.
• Исправление некорректных результатов запросов в случаях, когда происходило упрощение
подзапросов, результаты которых использовались в GROUPING SETS (Хейкки Линнакангас)
• Исправление обработки ограничений секционирования по списку с ключами секционирова-
ния логического типа и массивами (Амит Ланготе)
• Исключение неоправданной ошибки в запросе с деревом наследования, который выполнял-
ся одновременно с тем, как некоторая дочерняя таблица удалялась из этого дерева командой
ALTER TABLE NO INHERIT (Том Лейн)
• Устранение разнообразных ошибок взаимоблокировки при выполнении в нескольких сеансах
команды CREATE INDEX CONCURRENTLY (Джефф Джейнс)
• Изменение полей размера таблицы в процессе VACUUM FULL на более раннем этапе (Амит Ка-
пила)
Это предупреждает неоптимальное поведение при перестраивании хеш-индексов таблицы,
так как для расчёта начального размера хеша используется статистика pg_class.
• Исправление работы UNION/INTERSECT/EXCEPT с нулём столбцов (Том Лейн)
• Запрет использования столбцов идентификации с типизированными таблицами и секциями
(Микаэль Пакье)
Такое использование теперь будет считаться неподдерживаемым.
• Исправление разнообразных ошибок, когда в столбец идентификации при добавлении записи
не вставлялось правильное значение по умолчанию (Микаэль Пакье, Питер Эйзентраут)
В некоторых контекстах, а именно в COPY и ALTER TABLE ADD COLUMN, ожидаемое значение по
умолчанию не применялось, а вместо него вставлялось значение NULL.
• Устранение ошибок в ситуациях, когда дерево наследования содержит дочерние сторонние
таблицы (Эцуро Фудзита)
Комбинация обычных и сторонних таблиц в дереве наследования провоцировала построение
некорректных планов в запросах UPDATE и DELETE. Это приводило к видимым ошибкам в неко-
торых случаях, особенно когда в дочерней сторонней таблице присутствовали триггеры уров-
ня строк.
• Исправление дефекта со связанным подзапросом SELECT внутри VALUES в подзапросе LATERAL
(Том Лейн)
• Устранение ошибки планировщика «could not devise a query plan for the given query» (не уда-
лось выработать план для данного запроса) в некоторых случаях, включая вложенные UNION
ALL в подзапросе LATERAL (Том Лейн)
• Реализована возможность использовать статистику функциональной зависимости для логиче-
ских столбцов (Том Лейн)
Ранее, хотя расширенную статистику можно было объявить и собирать по логическим столб-
цам, планировщик не мог её применить.
• Устранение недооценивания количества групп, выдаваемых подзапросами, в которых вызыва-
ются функции, возвращающие множества, в группируемых столбцах (Том Лейн)
В случаях, подобных SELECT DISTINCT unnest(foo), в версии 10.0 приблизительная оценка ко-
личества строк стала давать меньшее число по сравнению с предыдущими версиями, что мог-
2317Замечания к выпуску
ло приводить к выбору неоптимальных планов. Теперь восстановлен предыдущий алгоритм
оценивания.
• Исправление работы триггеров в процессах логической репликации (Петр Желинек)
• Исправление логического декодирования, чтобы файлы на диске корректно очищались от
данных сбойных транзакций (Атсуши Торикоши)
Процедура логического декодирования может выносить записи WAL на диск, если транзакции
генерируют много записей WAL. Обычно эти файлы очищаются после фиксирования транзак-
ции или поступления записи о её прерывании; но в отсутствие таких записей код очистки ра-
ботал неправильно.
• Исправление тайм-аута в процессе walsender и реакции на прерывания при обработке боль-
шой транзакции (Петр Желинек)
• Устранение условий гонки при удалении источника репликации, когда ожидание удаляющего
процесса могло быть бесконечным (Том Лейн)
• Предоставление членам роли pg_read_all_stats возможности видеть статистику walsender в
представлении pg_stat_replication (Фейке Стинберген)
• Отображение процессов walsender, передающих базовые резервные копии, как активные в
представлении pg_stat_activity (Магнус Хагандер)
• Исправление обозначения метода аутентификации scram-sha-256 в представлении
pg_hba_file_rules (Микаэль Пакье)
Ранее его название выводилось как scram-sha256, что могло смущать пользователей некор-
ректным написанием.
• Добавление в has_sequence_privilege() поддержки проверок WITH GRANT OPTION, как это сде-
лано в других функциях проверки прав (Джо Конвей)
• В базах данных с кодировкой UTF8 любые XML-объявления, выбирающие другую кодировку,
должны игнорироваться (Павел Стехуле, Ной Миш)
Мы всегда храним документы XML в кодировке базы данных, так что позволяя libxml обраба-
тывать объявления с другой кодировкой, мы получим ошибочные результаты. Если кодировка
базы — не UTF8, мы в любом случае не обещали поддерживать XML-данные с не ASCII-коди-
ровкой, так что предыдущее поведение сохранено для совместимости ошибок. Это изменение
затрагивает только xpath() и связанные функции; другой код и ранее работал так.
• Обеспечение прямой совместимости с будущими изменениями младших версий протокола
(Роберт Хаас, Бадрул Чоудхури)
Ранее серверы PostgreSQL просто отклоняли запросы на использование версий протокола но-
вее 3.0, так что никакого функционального отличия старших номеров от младших не было. Те-
перь клиенты могут запрашивать версии 3.x и получать в ответ не отказ, а сообщение, говоря-
щее, что сервер поддерживает только версию 3.0. В данный момент от этого ничего не меня-
ется, но перенос этого изменения в предыдущие версии должен ускорить внедрение неболь-
ших усовершенствований протокола в будущем.
• Предоставление возможности клиенту, поддерживающему привязку канала SCRAM, (в част-
ности libpq v11 или новее) подключаться к серверу v10 (Микаэль Пакье)
Версия 10 не реализует такую функциональность, и согласование её использования произво-
дилось некорректно.
• Предотвращение долгоживущих циклов в ConditionVariableBroadcast() (Том Лейн, Томас
Мунро)
При неудачно сложившихся временных интервалах процесс, пытающийся разбудить все спя-
щие процессы по условной переменной, мог зацикливаться на неопределённое время. Вслед-
2318Замечания к выпуску
ствие ограниченного использования условных переменных в v10, эта проблема затрагивала
только параллельные сканирования индексов и некоторые операции со слотами репликации.
• Корректный сброс ожиданий условных переменных при прерывании подтранзакции (Роберт
Хаас)
• Обеспечение своевременного завершения всех дочерних процессов, ожидающих условные пе-
ременные, в случае прекращения работы процесса postmaster (Том Лейн)
• Устранение сбоев параллельных процессов при использовании более чем одного узла Gather
(Томас Мунро)
• Ликвидация зависания в процессе параллельного сканирования индекса при обработке уда-
лённой или наполовину неактуальной страницы индекса (Амит Капила)
• Предотвращение краха в случае, когда при параллельном сканировании битовой карты не
удаётся выделить сегмент разделяемой памяти (Роберт Хаас)
• Исправление реакции на сбой при запуске параллельного рабочего процесса (Амит Капила,
Роберт Хаас)
Ранее параллельный запрос мог зависнуть на неопределённое время, если не удавалось запу-
стить рабочий процесс, вследствие ошибки в fork() или других редких проблем.
• Исключение неоправданной ошибки, которая выдавалась, когда не удавалось получить парал-
лельные исполнители при запуске параллельного запроса (Роберт Хаас)
• Исправление сбора статистики EXPLAIN, получаемой от параллельных исполнителей (Амит Ка-
пила, Томас Мунро)
• Строки запросов, передаваемые параллельным исполнителям, всегда должны завершаться ну-
лём (Томас Мунро)
Это предотвращает вывод мусора в журнал главного процесса от таких исполнителей.
• Устранение небезопасного предположения о выравнивании при работе с типом __int128 (Том
Лейн)
Обычно компиляторы полагают, что переменные __int128 выравниваются по 16-байтовым
границам, но наша инфраструктура выделения памяти не готова гарантировать это, а увели-
чение MAXALIGN кажется неподходящим по множеству причин. В качестве решения код был
изменён так, чтобы тип __int128 можно было использовать только когда мы можем сказать
компилятору, что предполагается не такое крупное выравнивание. Единственный замечен-
ный симптом этой проблемы — сбои в некоторых параллельных запросах с агрегированием.
• Предотвращение сбоев с переполнением стека при планировании операций со множествами с
крайне большой вложенностью (UNION/INTERSECT/EXCEPT) (Том Лейн)
• Предотвращение краха при перепроверке EvalPlanQual в узле сканирования индекса, являю-
щимся внутренним потомком соединения слиянием (Том Лейн)
Это могло происходить только при изменении или выборке SELECT FOR UPDATE данных соеди-
нения, когда одновременно изменялись некоторые выбранные строки.
• Устранение ошибки в процессе автоочистки, когда расширенная статистика для таблицы
определена, но не может быть вычислена (Альваро Эррера)
• Ликвидация обращений по нулевому указателю для некоторых типов адресов LDAP, задавае-
мых в файле pg_hba.conf (Томас Мунро)
• Предотвращение исчерпания памяти из-за разрастания простых хеш-таблиц (Томаш Вондра,
Андрес Фройнд)
• Исправление демонстрационных функций INSTR() в документации по PL/pgSQL (Юго Нагата,
Том Лейн)
2319Замечания к выпуску
В документации утверждалось, что эти функции совместимы с Oracle®, но это было не совсем
так. В частности, по-разному интерпретировалось отрицательное значение третьего парамет-
ра: Oracle воспринимает это значение как последнюю позицию, с которой может начинаться
целевая подстрока, а наши функции считали, что это последняя позиция, где строка может
заканчиваться. Также Oracle выдаёт ошибку в случае нулевого или отрицательного четвёрто-
го параметра, тогда как наши функции возвращали ноль.
Код этого примера был изменён для большего соответствия поведению Oracle. Пользовате-
лям, которые скопировали этот код в свои приложения, возможно, имеет смысл обновить свои
копии.
• Исправление поведения pg_dump, чтобы ACL (разрешения), комментарии и метки безопасно-
сти можно было надёжно идентифицировать в архивных выходных форматах (Том Лейн)
Компонент «метка» записи ACL в архиве обычно представлял собой просто имя целевого объ-
екта. В его начало теперь добавляется тип объекта, чтобы записи ACL соответствовали согла-
шениям, уже принятым для записей комментариев и меток безопасности. Кроме того, обо-
значения комментариев и меток безопасности, заданных для собственно базы данных, теперь
должны начинаться с DATABASE, чтобы они соответствовали тому же соглашению. Это преду-
преждает ложные срабатывания в коде, который пытается найти записи больших объектов по
строкам, начинающимся со слов LARGE OBJECT. Прежнее поведение могло приводить к непра-
вильной классификации записей как данные и нежелательным результатам при восстановле-
нии выгруженной только схемы или только данных.
Заметьте, что следствием этого стало изменение видимого пользователями вывода pg_restore
–list.
• Переименование функции copy_file_range в pg_rewind во избежание конфликта с новым си-
стемным вызовом Linux с таким же именем (Андрес Фройнд)
Это изменение предотвращает ошибки при сборке с новыми версиями glibc.
• В ecpg добавлено выявление массивов индикаторов с неправильной длиной и сообщение об
ошибке (Дэвид Рейдер)
• Изменение поведения оператора cube ~&gt; int в расширении contrib/cube для обеспечения его
совместимости с поиском kNN (Александр Коротков)
Смысл второго аргумента (выбирающего размерность) был изменён, чтобы можно было опре-
делённо сказать, какое именно значение выбирается в кубах переменных размерностей.
Это изменение нарушает совместимость, но так как этот оператор предназначался для по-
исков kNN, в прежнем виде он был бесполезен. После установки этого обновления все мате-
риализованные представления или индексы с выражениями, использующими этот оператор,
необходимо обновить/перестроить.
• Предотвращение срабатывания проверки истинности внутри libc в расширении contrib/
hstore из-за использования memcpy() с равными указателями источника и получателя (Томаш
Вондра)
• Исправление некорректного отображения битовых карт NULL для кортежей в contrib/
pageinspect (Максим Милютин)
• Исправление некорректного вывода функции hash_page_items() расширения contrib/
pageinspect (Масахико Савада)
• В расширении contrib/postgres_fdw ликвидирована ошибка планировщика «outer pathkeys
do not match mergeclauses» (внешние ключи пути не соответствуют предложениям слияния)
при построении плана, включающего удалённое соединение (Роберт Хаас)
• В contrib/postgres_fdw предотвращён сбой планировщика при дублировании элементов
GROUP BY (Дживан Чок)
2320Замечания к выпуску
• Добавление современных примеров настройки автозапуска Postgres в macOS (Том Лейн)
Скрипты в contrib/start-scripts/osx используют инфраструктуру, которая устарела десять
лет назад, и абсолютно неработоспособны во всех версиях macOS, выпущенных в последние
два года. Добавлен новый подкаталог contrib/start-scripts/macos со скриптами, использую-
щими новую инфраструктуру launchd.
• Исправление некорректного выбора зависящих от конфигурации библиотек OpenSSL в
Windows (Эндрю Дунстан)
• Поддержка компоновки с версиями libperl, собранными компилятором MinGW (Ной Миш)
Это позволяет собирать PL/Perl с некоторыми распространёнными дистрибутивами Perl для
Windows.
• Исправление в сборке MSVC проверки, требуется ли 32-битной libperl определение -
D_USE_32BIT_TIME_T (Ной Миш)
Имеющиеся дистрибутивы Perl ожидают разного, и при этом нет никакой возможности на-
дёжно проверить это, поэтому пришлось добавить проверку фактического поведения исполь-
зуемой библиотеки во время компиляции.
• В Windows обработчик аварийного завершения должен устанавливаться на более раннем эта-
пе запуска главного процесса (Такаюки Цунакава)
Это поможет получить дамп памяти при ошибках в те моменты в начале запуска, в которые
раньше дамп не записывался.
• В Windows устранены сбои, связанные с преобразованием кодировок при выводе сообщений
на самых ранних стадиях запуска процесса postmaster (Такаюки Цунакава)
• Использование нашего ранее написанного кода циклических блокировок для Motorola 68K во
OpenBSD, а также в NetBSD (Давид Карлье)
• Добавление поддержки циклических блокировок для Motorola 88K (Давид Карлье)
• Обновление данных часовых поясов до версии tzdata 2018c, включающее изменения правил
перехода на летнее время в Бразилии, в Сан-Томе и Принсипи, а также корректировки ис-
торических данных для Боливии, Японии и Южного Судана. Был удалён часовой пояс US/
Pacific-New (это был просто псевдоним для пояса America/Los_Angeles).
E.8. Выпуск 10.1
Дата выпуска:
2017-11-09
В этот выпуск вошли различные исправления, внесённые после версии 10.0. За информацией о
нововведениях 10 версии обратитесь к Разделу E.9.
E.8.1. Миграция на версию 10.1
Если используется версия 10.X, выгрузка/восстановление базы не требуется.
Однако если вы используете индексы BRIN, прочитайте четвёртую запись в списке изменений.
E.8.2. Изменения
• Обеспечение проверки разрешений на уровне таблиц и политик RLS при выполнении
INSERT … ON CONFLICT DO UPDATE во всех случаях (Дин Рашид)
Путь изменения данных в команде INSERT … ON CONFLICT DO UPDATE требовал наличия раз-
решения SELECT для всех столбцов в решающем индексе, но в случае указания решающего
ограничения по имени должная проверка отсутствовала. Кроме того, для таблиц с включён-
2321Замечания к выпуску
ной защитой на уровне строк не проверялось, соответствуют ли изменённые строки полити-
кам SELECT (вне зависимости от способа задания решающего индекса). (CVE-2017-15099)
• Устранение сбоя при несовпадении типа записи в json{b}_populate_recordset() (Микаэль
Пакье, Том Лейн)
Эти функции использовали тип результата, заданный в предложении FROM … AS, не прове-
ряя, соответствует ли он фактическому типу поступившего кортежа. В случае несоответствия
обычно происходил сбой, хотя также вероятным было раскрытие содержимого памяти серве-
ра. (CVE-2017-15098)
• Исправление скриптов запуска сервера — переключение на $PGUSER до открытия файла
$PGLOG (Ной Миш)
Ранее файл журнала postmaster открывался ещё под именем root. Таким образом, владелец
базы данных мог произвести атаку на другого пользователя системы, сделав $PGLOG символи-
ческой ссылкой на некоторый другой файл, который в результате можно было испортить до-
бавленными в него сообщениями журнала.
По умолчанию эти скрипты никуда не устанавливаются. Если вы использовали их, замените
свои экземпляры новыми копиями либо внесите те же коррективы в свои вручную изменён-
ные скрипты. Если владельцем существующего файла $PGLOG является root, его нужно уда-
лить или переименовать прежде чем перезапускать сервер с помощью исправленного скрип-
та. (CVE-2017-12172)
• Исправление вычисления сводных данных индекса BRIN для корректной работы при одновре-
менном расширении таблицы (Альваро Эррера)
Ранее в условиях гонки некоторые строки таблицы могли пропадать из индекса. Для устране-
ния последствий предыдущих проявлений этой проблемы может потребоваться перестроить
существующие индексы BRIN.
• Предупреждение возможных сбоев при параллельных изменениях индекса BRIN (Том Лейн)
В определённых условиях гонки могли возникать ошибки «invalid index offnum» (неверный но-
мер смещения в индексе) или «inconsistent range map» (несогласованность в карте диапазо-
нов).
• Предотвращение в ходе логической репликации присвоения NULL нереплицируемым столб-
цам при репликации UPDATE (Петр Желинек)
• Исправление механизма логической репликации, чтобы триггеры BEFORE ROW DELETE вызыва-
лись в должное время (Масахико Савада)
Ранее этого не происходило, если в таблице также имелся триггер BEFORE ROW UPDATE.
• Устранение сбоя при вызове логического декодирования из функции, использующей SPI, в
частности, из любой функции на одном из языков PL (Том Лейн)
• Игнорирование CTE (общих табличных выражений) при обращении к целевой таблице для вы-
полнения INSERT/UPDATE/DELETE и недопущение сопоставления имён целевых таблиц, задан-
ных с указанием схемы, с именами переходных таблиц в триггерах (Томас Мунро)
В результате для CTE, связанных с командами DML, восстановлено поведение, имевшее место
до версии 10.
• Уход от вычисления выражений в аргументах агрегатной функции для строк, не удовлетворя-
ющих условию FILTER (Том Лейн)
Тем самым восстанавливается поведение, наблюдавшееся до 10 версии (и описанное в стан-
дарте SQL).
• Исправление некорректных результатов запросов, содержащих в нескольких столбцах
GROUPING SETS одну и ту же простую переменную (Том Лейн)
2322Замечания к выпуску
• Устранение утечки памяти на время выполнения запроса при вычислении функции, возвра-
щающей множество, в целевом списке SELECT (Том Лейн)
• Реализована возможность параллельного выполнения подготовленных операторов с общими
планами (Амит Капила, Кунтал Гхош)
• Корректировка неправильных решений по распараллеливанию для вложенных запросов (Амит
Капила, Кунтал Гхош)
• Устранение сбоев в обработке параллельных запросов, возможных при удалении недавно ис-
пользованной роли (Амит Капила)
• Устранение сбоя при параллельном сканировании битовой карты с узлом плана BitmapAnd,
расположенным под узлом BitmapOr (Дилип Кумар)
• Исправление в функциях json_build_array(), json_build_object() и их аналогах для jsonb
обработки явно заданных аргументов VARIADIC (Микаэль Пакье)
• Исправление логики «частей работы» автоочистки для предупреждения возможных сбоев и
незаметной потери частей (Альваро Эррера)
• Устранение сбоев в особых случаях при добавлении столбцов в конец представления (Том
Лейн)
• Фиксирование правильных зависимостей когда представление или правило содержит узлы вы-
ражения FieldSelect или FieldStore (Том Лейн)
В отсутствие этих зависимостей команда DROP со столбцом или типом данных может выпол-
ниться, когда не должна, что вызовет ошибки при последующем использовании представле-
ния или правила. Данное исправление не защищает существующие представления/правила, а
повлияет только на создаваемые в будущем.
• Правильное определение хешируемости диапазонных типов данных (Том Лейн)
Планировщик ошибочно полагал, что любой диапазонный тип может хешироваться для ис-
пользования в соединениях или агрегировании по хешу, но на самом деле он должен прове-
рять, поддерживает ли хеширование подтип диапазона. Это не касается встроенных диапазон-
ных типов, так как все они всё равно хешируемые.
• Игнорирование узлов выражений RelabelType должным образом при рассмотрении статисти-
ки по функциональным зависимостям (Дэвид Роули)
Это позволяет, например, правильно использовать расширенную статистику по столбцам
varchar.
• Предотвращение разделения информации переходного состояния между сортирующими агре-
гатными функциями (Дэвид Роули)
Вследствие этого разделения возникали сбои во встроенных сортирующих агрегатах и могли
также возникать в подобных пользовательских функциях. Начиная с версии 11, предусмотре-
ны средства для надёжной защиты от таких случаев, а в ветвях стабильных выпусков просто
отключена оптимизация.
• Недопущение игнорирования значения idle_in_transaction_session_timeout, если до этого
произошёл таймаут оператора (statement_timeout) (Лукас Фиттл)
• Устранение маловероятной потери сообщений NOTIFY вследствие зацикливания идентифика-
торов транзакций (Марко Тииккая, Том Лейн)
Если в сеансе не выполнялись никакие запросы, то есть он просто ждал уведомлений и за это
время прошло более 2 миллиардов транзакций, он начинал пропускать уведомления от парал-
лельно фиксируемых транзакций.
• Уменьшение частоты запросов на сброс данных в процессе копирования файлов во избежание
проблем с производительностью в macOS, в частности с новой файловой системой APFS (Том
Лейн)
2323Замечания к выпуску
• Реализована возможность использовать режим FREEZE команды COPY на уровне изоляции
транзакций REPEATABLE READ или выше (Ной Миш)
Этот сценарий использования был непреднамеренно потерян вследствие предыдущего ис-
правления ошибки.
• Исправление функции AggGetAggref(), чтобы возвращались корректные узлы Aggref для
функций завершения агрегатов с объединёнными промежуточными вычислениями (Том Лейн)
• Исправление нечётких указаний схемы в некоторых новых запросах в pg_dump и psql (Вита-
лий Буровой, Том Лейн, Ной Миш)
• Уход от использования оператора @&gt; в запросах psql для команды \d (Том Лейн)
Это предотвращает проблемы, возникающие при установке расширения parray_gin, так как в
нём определён конфликтующий оператор.
• Исправление в pg_basebackup сравнения путей табличных пространств посредством приведе-
ния путей к канонической форме (Микаэль Пакье)
Это особенно полезно в Windows.
• Исправление libpq, чтобы для её работы не требовалось существование домашнего каталога
пользователя (Том Лейн)
В версии 10 невозможность найти домашний каталог при попытке прочитать ~/.pgpass счита-
лась критической ошибкой, но эта ситуация должна обрабатываться так же, как и отсутствие
данного файла. И в версии 10, и в ветвях предыдущих выпусков была допущена та же ошибка
при чтении ~/.pg_service.conf, хотя это было менее очевидно, так как данный файл исполь-
зовался только при указании имени службы.
• В ecpglib исправлена обработка обратной косой черты в строковых константах в зависимости
от значения standard_conforming_strings (Такаюки Цунакава)
• Игнорирование в ecpglib дробной части при вводе целочисленных значений в режиме совме-
стимости с Informix (Гао Цзэнци, Михаэль Мескес)
• Добавление отсутствующего предварительного требования temp-install для целей типа check в
Make (Ной Миш)
Некоторые невыполняемые по умолчанию тестовые процедуры, подобные make check, не про-
веряли актуальность временной инсталляции.
• Обновление данных часовых поясов до версии tzdata 2017c, включающее изменения правил
перехода на летнее время на Фиджи, в Намибии, Серверном Кипре, Судане, Тонга и на ост-
ровах Теркс и Кайкос, плюс корректировку исторических данных для Аляски, Апии, Бирмы,
Калькутты, Детройта, Ирландии, Намибии и Паго-Паго.
• В документации для HTML-якорей восстановлен верхний регистр (Питер Эйзентраут)
Вследствие изменений инструментария в документации 10.0 для внутренних HTML-якорей
был изменён регистр строк, что привело к повреждению некоторых внешних ссылок на доку-
ментацию на нашем сайте. Поэтому было решено вернуться к предыдущему стилю со строка-
ми в верхнем регистре.
E.9. Выпуск 10
Дата выпуска:
2017-10-05
E.9.1. Обзор
В число ключевых усовершенствований PostgreSQL 10 входят:
• Логическая репликация по схеме публикации/подписки
2324Замечания к выпуску
• Декларативное секционирование таблиц
• Улучшение распараллеливания запросов
• Значительное увеличение общей производительности
• Более сильная защита паролей с использованием SCRAM-SHA-256
• Улучшенные средства мониторинга и управления
Предыдущие пункты более подробно описаны в следующих разделах.
E.9.2. Миграция на версию 10
Тем, кто хочет мигрировать данные из любой предыдущей версии, необходимо выполнить выгруз-
ку/загрузку данных с помощью pg_dumpall или воспользоваться pg_upgrade.
В версии 10 реализован ряд изменений, которые могут повлиять на совместимость с предыдущими
выпусками. Примите к сведению следующие несовместимости:
• После обновления с помощью pg_upgrade с любой предыдущей основной версии PostgreSQL
необходимо перестроить хеш-индексы (Митхун Сай, Роберт Хаас, Амит Капила)
Необходимость данного требования продиктована значительным усовершенствованием меха-
низма хеш-индексов. Для облегчения задачи переиндексации pg_upgrade создаст вспомога-
тельный скрипт.
• Переименование каталога с журналом предзаписи из pg_xlog в pg_wal, а также переименова-
ние каталога с информацией о состоянии транзакций из pg_clog в pg_xact (Микаэль Пакье)
Старые имена неоднократно вводили пользователей в заблуждение — пользователи думали,
что эти каталоги содержат только несущественные файлы журналов, и вручную удаляли фай-
лы журналов предзаписи или состояния транзакций, что приводило к необратимой потере
данных. Эти переименования призваны предотвратить такие ошибки в будущем.
• Замена в именах функций SQL, утилит и параметров всех упоминаний «xlog» на «wal» (Роберт
Хаас)
Например, имя pg_switch_xlog() поменялось на pg_switch_wal(), pg_receivexlog — на
pg_receivewal, а –xlogdir — на –waldir. Это было сделано вместе с переименованием ката-
лога pg_xlog для согласованности; и вообще термин «xlog» теперь нигде не может встретить-
ся пользователю.
• Замена в связанных с WAL функциях и представлениях location на lsn (Дэвид Роули)
Ранее имело место несогласованное употребление обоих терминов.
• Изменение реализации функций, возвращающих множества, в списке SELECT (Андрес Фройнд)
Функции, возвращающие множества, теперь вычисляются до вычисления скалярных выра-
жений в списке SELECT, практически так же, как если бы они были помещены в предложение
LATERAL FROM. Это даёт более понятное поведение в случаях, когда присутствуют несколько
таких функций. Если они возвращают разное количество строк, все результаты дополняют-
ся до наибольшего количества строк значениями NULL. Ранее результаты обрабатывались в
цикле, пока все функции не завершались, и в результате получалось количество строк, рав-
ное наименьшему общему кратному периодов функций. Кроме того, функции, возвращающие
множества, теперь нельзя использовать в конструкциях CASE и COALESCE. За дополнительными
сведениями обратитесь к Подразделу 38.5.8.
• Использование стандартного синтаксиса конструктора строки в UPDATE … SET (списо-
к_столбцов) = конструктор_строки (Том Лейн)
Теперь конструктор_строки может начинаться со слова ROW; ранее его надо было опускать. Ес-
ли в списке_столбцов фигурирует имя только одного столбца, конструктор_строки должен ис-
2325Замечания к выпуску
пользовать ключевое слово ROW, так как иначе он не будет корректным конструктором строки,
а будет восприниматься как выражение в скобках. Также запись имя_таблицы.</em> в конструк-
торе_строки теперь разворачивается в набор столбцов, как и в других случаях использования
конструктора_строки.
• Когда ALTER TABLE … ADD PRIMARY KEY помечает столбцы как NOT NULL, это изменение те-
перь распространяется также на дочерние таблицы в иерархии наследования (Микаэль Па-
кье)
• Предотвращение срабатывания триггеров уровня оператора более одного раза для одного
оператора (Том Лейн)
В случаях, когда пишущие CTE изменяли одну таблицу, изменяемую внешним оператором ли-
бо другими пишущими CTE, триггеры BEFORE STATEMENT и AFTER STATEMENT вызывались неод-
нократно. Также, если в таблице были определены триггеры уровня оператора, в результате
действий для обеспечения целостности внешнего ключа (например, ON DELETE CASCADE), они
могли вызываться несколько раз для одного внешнего SQL-оператора. Это поведение противо-
речит стандарту SQL и было исправлено.
• Перемещение полей метаданных последовательностей в новый системный каталог
pg_sequence (Питер Эйзентраут)
Отношение последовательности содержит теперь только поля, которые могут быть измене-
ны функцией nextval(), то есть last_value, log_cnt и is_called. Другие свойства последова-
тельности, такие как начальное значение и шаг увеличения, сохраняются в соответствующей
строке в каталоге pg_sequence. Действие ALTER SEQUENCE теперь полностью транзакционное
и, как следствие, блокирует последовательность до фиксации транзакции. Функции nextval()
и setval() остаются нетранзакционными.
Основная несовместимость, привнесённая этим изменением, состоит в том, что из отно-
шения последовательности теперь можно прочитать только три поля, перечисленные вы-
ше. Чтобы получить другие свойства последовательности, приложения должны обратить-
ся к pg_sequence. Также для этого можно использовать новое системное представление
pg_sequences; оно выдаёт столбцы с именами, более подходящими для существующего кода.
Кроме того, последовательности, созданные для столбцов SERIAL, теперь генерируют 32-бит-
ные значения, тогда как предыдущие версии генерировали 64-битные. Это отличие никак не
проявляется, если значения просто сохраняются в столбце.
Переработан и вывод команды psql \d для последовательностей.
• Передача по умолчанию программой pg_basebackup данных WAL, необходимых для восстанов-
ления резервной копии (Магнус Хагандер)
При этом в pg_basebackup подразумеваемое значение -X/–wal-method меняется на stream.
Для воспроизведения старого поведения был добавлен вариант значения none. Параметр
pg_basebackup -x был удалён (используйте вместо него -X fetch).
• Изменение записей логической репликации в pg_hba.conf (Питер Эйзентраут)
В предыдущих версиях для подключения логической репликации требовалось указать
replication в столбце базы данных. С этого выпуска логической репликации соответствует
обычная запись с именем базы данных или ключевым словом, например, all. Для физической
репликации по-прежнему используется ключевое слово replication. Так как встроенная ло-
гическая репликация появилась только в этом выпуске, это изменение может затронуть толь-
ко пользователей сторонних средств логической репликации.
• Все действия в pg_ctl по умолчанию должны ожидать завершения операции (Питер Эйзентра-
ут)
Ранее некоторые действия pg_ctl не ждали завершения и для ожидания требовалось использо-
вать ключ -w.
2326Замечания к выпуску
• Изменение значения по умолчанию серверного параметра log_directory с pg_log на log (Ан-
дреас Карлссон)
• Добавление параметра конфигурации ssl_dh_params_file для указания имени файла с нестан-
дартными параметрами OpenSSL DH (Хейкки Линнакангас)
Тем самым заменяется жёстко заданное и недокументированное имя файла dh1024.pem. За-
метьте, что файл dh1024.pem по умолчанию больше не обрабатывается; вы должны задать этот
параметр, если хотите использовать свои параметры DH.
• Увеличение размера стандартных параметров DH, используемых для эфемерных DH-шифров
OpenSSL, до 2048 бит (Хейкки Линнакангас)
Размер предопределённых в коде параметров DH был увеличен с 1024 до 2048 бит, так что об-
мен ключами DH стал более устойчивым к подбору шифра. Однако некоторые старые реали-
зации SSL, в частности некоторые ревизии Java Runtime Environment версии 6, не принимают
параметры DH длиннее 1024 бит и, таким образом, не смогут подключиться через SSL. Если
вам необходимо поддерживать такие старые клиенты, вы можете использовать нестандартные
параметры DH размером 1024 бита вместо предопределённых параметров по умолчанию. См.
ssl_dh_params_file.
• Ликвидация возможности хранения незашифрованных паролей на сервере (Хейкки Линнакан-
гас)
Серверный параметр password_encryption больше не поддерживает значения off и plain.
Вариант UNENCRYPTED также теперь не поддерживается в командах CREATE/ALTER USER …
PASSWORD. Аналогично был удалён ключ –unencrypted команды createuser. Незашифрованные
пароли, перенесённые из старых версий, в этой версии будут храниться в зашифрованном ви-
де. Значением по умолчанию параметра password_encryption остаётся md5.
• Добавление серверных параметров min_parallel_table_scan_size и min_parallel_index_scan_size
для управления параллельными запросами (Амит Капила, Роберт Хаас)
Они заменяют переменную min_parallel_relation_size, которая была слишком общей.
• Не заключённый в кавычки текст в shared_preload_libraries и связанных серверных парамет-
рах не должен переводиться в нижний регистр (Куэль Чжо)
Эти параметры на самом деле представляют собой списки имён файлов, но ранее они воспри-
нимались как списки SQL-идентификаторов и обрабатывались по другим правилам.
• Удаление серверного параметра sql_inheritance (Роберт Хаас)
При выключенном значении этого параметра запросы, обращающиеся к родительским табли-
цам, перестают учитывать дочерние. Однако стандарт SQL требует, чтобы они учитывались, и
это поведение было принято по умолчанию в PostgreSQL 7.1.
• Реализация возможности передавать многомерные массивы в функции на PL/Python и возвра-
щать вложенные списки Python (Алексей Грищенко, Дэйв Крамер, Хейкки Линнакангас)
Это изменение потребовало нарушить обратную совместимость в части обработки масси-
вов составных типов в PL/Python. Раньше можно было вернуть массив составных типов как
[[col1, col2], [col1, col2]]; но теперь это будет интерпретироваться как двухмерный мас-
сив. Составные типы в массивах для однозначности должны возвращаться теперь в виде кор-
тежей Python, а не в виде списков. То есть предыдущую запись нужно заменить на [(col1,
col2), (col1, col2)].
• Удаление механизма автозагрузки «модулей» PL/Tcl (Том Лейн)
На замену этой функциональности пришли новые серверные параметры pltcl.start_proc и
pltclu.start_proc, которые проще в использовании и дают возможности, подобные имеющимся
в других языках программирования.
2327Замечания к выпуску
• Ликвидация поддержки выгрузки данных с серверов до 8.0 утилитами pg_dump/pg_dumpall
(Том Лейн)
Пользователям, которым нужно выгрузить данные с серверов до 8.0, остаётся использовать
dump из PostgreSQL версии 9.6 или старее. Выгруженные этими версиями данные должны
успешно загружаться на новых серверах.
• Ликвидация поддержки хранения даты/времени и интервалов в виде чисел с плавающей точ-
кой (Том Лейн)
Параметр configure –disable-integer-datetimes был удалён. Использование для таких зна-
чений чисел с плавающей точкой не давало значимых преимуществ и не было вариантом по
умолчанию, начиная с PostgreSQL 8.3.
• Ликвидация поддержки сервером клиент-серверного протокола версии 1.0 (Том Лейн)
Этот протокол не поддерживался клиентами со времён PostgreSQL 6.3.
• Удаление модуля contrib/tsearch2 (Роберт Хаас)
Этот модуль обеспечивал совместимость с версией полнотекстового поиска, которая постав-
лялась с серверами PostgreSQL до версии 8.3.
• Ликвидация приложений командной строки createlang и droplang (Питер Эйзентраут)
Они перешли в разряд устаревших в PostgreSQL 9.1. Вместо них можно непосредственно ис-
пользовать команды CREATE EXTENSION и DROP EXTENSION.
• Ликвидация поддержки вызовов функций версии 0 (Андрес Фройнд)
Расширения, предоставляющие функции, реализованные на C, теперь должны использовать
соглашение о вызовах версии 1. Версия 0 считалась устаревшей с 2001 года.
E.9.3. Изменения
Ниже вы найдёте подробный список изменений, произошедших между предыдущим основным вы-
пуском и PostgreSQL 10.
E.9.3.1. Сервер
E.9.3.1.1. Параллельное выполнение запросов
• Поддержка параллельного сканирования индексов типа B-дерево (Рахила Сьед, Амит Капила,
Роберт Хаас, Рафия Сабих)
Благодаря этому поиск в страницах индекса-B-дерева могут производить параллельно
несколько рабочих процессов.
• Поддержка параллельного сканирования кучи по битовой карте (Дилип Кумар)
Это позволяет распределить одно сканирование индекса между параллельными исполнителя-
ми, обрабатывающими разные области кучи.
• Реализована возможность выполнения соединения слиянием в параллельном режиме (Дилип
Кумар)
• Реализована возможность выполнения несвязанных запросов в параллельном режиме (Амит
Капила)
• Улучшение возможности параллельных процессов возвращать ранее отсортированные данные
(Рушаб Латиа)
• Расширение использования параллельных запросов в функциях процедурных языков (Роберт
Хаас, Рафия Сабих)
2328Замечания к выпуску
• Добавление серверного параметра max_parallel_workers для ограничения числа рабочих про-
цессов, которые могут использоваться для распараллеливания запросов (Жульен Рухо)
Значение этого параметра можно сделать меньше max_worker_processes, чтобы зарезервиро-
вать рабочие процессы для других целей, кроме параллельных запросов.
• Включение распараллеливания по умолчанию (значение по умолчанию параметра
max_parallel_workers_per_gather стало равно 2).
E.9.3.1.2. Индексы
• Добавление регистрации в журнале предзаписи операций с хеш-индексами (Амит Капила)
В результате хеш-индексы становятся отказоустойчивыми и пригодными к репликации. Преж-
нее предостережение относительно их использование удалено.
• Улучшение производительности хеш-индекса (Амит Капила, Митхун Сай, Ашутош Шарма)
• Добавление поддержки индексов SP-GiST для типов данных INET и CIDR (Эмре Хасегели)
• Добавление параметра для включения более активного вычисления сводных данных индекса
BRIN (Альваро Эррера)
Новый параметр CREATE INDEX позволяет автоматически обновлять сводную запись для
предыдущей зоны страниц BRIN при создании новой зоны.
• Добавление функций для удаления и повторного добавления сводных записей BRIN для зон
индекса BRIN (Альваро Эррера)
Новая SQL-функция brin_summarize_range() обновляет сводные записи индекса BRIN для
определённой зоны, а brin_desummarize_range() удаляет их. Это полезно для обновления
данных зоны, которая стала меньше в результате действия команд UPDATE и DELETE.
• Более точный расчёт выгоды от применения сканирования по индексу BRIN (Дэвид Роули, Эм-
ре Хасегели)
• Ускорение операций добавления и изменения записей в GiST благодаря более эффективному
использованию пространства индекса (Андрей Бородин)
• Минимизация блокировок страниц при очистке индексов GIN (Андрей Бородин)
E.9.3.1.3. Блокировки
• Сокращение блокировок, необходимых для изменения параметров таблиц (Саймон Риггс, Фаб-
рицио де Ройес Мелло)
Например, изменить параметр effective_io_concurrency для таблицы теперь можно с более лёг-
кой блокировкой.
• Реализация регулировки пределов для повышения уровня предикатных блокировок (Дагфинн
Ильмари Маннсакер)
Повышением уровня блокировок теперь можно управлять с помощью двух новых параметров
сервера, max_pred_locks_per_relation и max_pred_locks_per_page.
E.9.3.1.4. Оптимизатор
• Добавление статистики по нескольким столбцам, позволяющей вычислять коэффициент кор-
реляции и число различных значений (Томаш Вондра, Дэвид Роули, Альваро Эррера)
Появились новые команды: CREATE STATISTICS, ALTER STATISTICS и DROP STATISTICS. Это по-
лезно для оценки использования памяти запросом и для консолидации статистики по отдель-
ным столбцам.
• Увеличение производительности запросов, сталкивающихся с ограничениями безопасности
на уровне строк (Том Лейн)
2329Замечания к выпуску
Теперь оптимизатор лучше понимает, куда можно поместить условия фильтра RLS, благодаря
чему он может строить лучшие планы, при этом гарантируя выполнение условий RLS.
E.9.3.1.5. Общая производительность
• Ускорение агрегатных функций, которые вычисляют сумму с накоплением, используя ариф-
метику типа numeric, включая некоторые вариации SUM(), AVG() и STDDEV() (Хейкки Линна-
кангас)
• Увеличение скорости преобразований кодировок символов с использованием цифровых дере-
вьев (Кётаро Хоригути, Хейкки Линнакангас)
• Уменьшение издержек вычисления выражений при выполнении запросов, а также издержек
обращения к узлу плана (Андрес Фройнд)
Это особенно полезно для запросов, обрабатывающих множество строк.
• Возможность использования агрегирования по хешу при обработке наборов группирования
(Эндрю Гирт)
• Использование гарантий уникальности для оптимизации определённых типов соединений
(Дэвид Роули)
• Ускорение сортировки типа данных macaddr (Брандур Лич)
• Сокращение издержек на отслеживание статистики в сеансах, когда задействуются тысячи
отношений (Александр Алексеев)
E.9.3.1.6. Мониторинг
• Возможность явного управления отображением командой EXPLAIN времени планирования и
выполнения (Ашутош Бапат)
По умолчанию время планирования и выполнения выводится командой EXPLAIN ANALYZE и не
выводится в других случаях. Явно управлять этим позволяет новый параметр SUMMARY коман-
ды EXPLAIN.
• Добавлены новые стандартные роли для мониторинга (Дейв Пейдж)
Новые роли pg_monitor, pg_read_all_settings, pg_read_all_stats и pg_stat_scan_tables
позволяют упростить конфигурацию разрешений.
• Исправление передачи информации сборщику статистики во время REFRESH MATERIALIZED
VIEW (Джим Млодженски)
E.9.3.1.6.1. Ведение журнала
• Изменение префикса log_line_prefix, чтобы по умолчанию все строки журнала postmaster со-
держали текущее время (с миллисекундами) и идентификатор процесса (Кристоф Берг)
Ранее префикс по умолчанию был пустым.
• Добавление функций для получения содержимого каталогов журнала сообщений и WAL (Дейв
Пейдж)
Новые функции называются соответственно pg_ls_logdir() и pg_ls_waldir() и могут выпол-
няться не только суперпользователями (при наличии достаточных разрешений).
• Добавление функции pg_current_logfile() для чтения имён текущих файлов, в которые сбор-
щик сообщений выводит потоки stderr и csvlog (Жиль Даролд)
• Вывод в журнал сервера адреса и номера порта для каждого принимающего соединения соке-
та при запуске postmaster (Том Лейн)
2330Замечания к выпуску
Также добавление в сообщение об ошибке привязки к определённому сокету адреса этого со-
кета.
• Устранение лишних сообщений о запуске и остановке подпроцессов запускающего процесса
(Том Лейн)
Теперь уровень этих сообщений понижен до DEBUG1.
• Уменьшение уровня важности сообщений для уровней отладки, контролируемых параметром
log_min_messages (Роберт Хаас)
Это затрагивает также сообщения отладочных уровней client_min_messages.
E.9.3.1.6.2. Представление pg_stat_activity
• Добавление в pg_stat_activity информации о состоянии низкоуровневых ожиданий (Мика-
эль Пакье, Роберт Хаас)
Это позволяет отслеживать множество событий ожидания на низком уровне, включая ожида-
ния защёлок, записи/чтения/сброса файлов, чтения/записи со стороны клиента и синхронной
репликации.
• Отображение в pg_stat_activity вспомогательных и фоновых рабочих процессов, а также
процессов-передатчиков WAL (Кунтал Гхош, Микаэль Пакье)
Это упрощает мониторинг. Тип процесса обозначается в новом столбце backend_type.
• В pg_stat_activity реализовано отображение SQL-запросов, выполняемых параллельными
исполнителями (Рафия Сабих)
• Переименование в pg_stat_activity.wait_event_type значений LWLockTranche и LWLockNamed
в LWLock (Роберт Хаас)
Это делает вывод более согласованным.
E.9.3.1.7. Аутентификация
• Добавление поддержки SCRAM-SHA-256 для проверки и хранения паролей (Микаэль Пакье,
Хейкки Линнакангас)
Это обеспечивает лучшую безопасность по сравнению с существующим методом md5.
• Изменение типа серверного параметра password_encryption с boolean на enum (Микаэль Па-
кье)
Это потребовалось для поддержки различных вариантов хеширования паролей.
• Добавление представления pg_hba_file_rules для просмотра содержимого pg_hba.conf (Ха-
рибабу Комми)
Это представление показывает содержимое файла, а не действующие в данный момент пара-
метры.
• Поддержка нескольких серверов RADIUS (Магнус Хагандер)
Все связанные с RADIUS параметры теперь стали множественными и принимают список сер-
веров через запятую.
E.9.3.1.8. Конфигурация сервера
• Возможность обновления конфигурации SSL при перезагрузке конфигурации (Андреас
Карлссон, Том Лейн)
Это позволяет переконфигурировать SSL без перезапуска сервера, используя pg_ctl reload,
SELECT pg_reload_conf() или отправив сигнал SIGHUP. Однако, перезагрузка конфигурации
2331Замечания к выпуску
SSL не сработает, если для использования SSL-ключа сервера требуется пароль, так как ника-
кой возможности запросить его нет. В этом случае главный процесс (postmaster) продолжит
использовать изначальную конфигурацию, пока не будет перезапущен.
• Устранение практического предела для максимального значения bgwriter_lru_maxpages
(Джим Нэсби)
E.9.3.1.9. Надёжность
• После создания или удаления файлов следует выполнять fsync для каталога их содержащего
(Микаэль Пакье)
Это сокращает риск потери данных при отключении питания.
E.9.3.1.9.1. Журнал предзаписи (WAL)
• Предотвращение ненужных контрольных точек и архивации WAL в простаивающих системах
(Микаэль Пакье)
• Добавление серверного параметра wal_consistency_checking для внесения в WAL информации,
позволяющей проверять целостность на ведомом сервере (Кунтал Гхош, Роберт Хаас)
В случае выявления любого нарушения при проверке целостности на ведомом сервере выда-
ётся критическая ошибка.
• Увеличение максимально допустимого размера сегмента WAL до одного гигабайта (Бина
Эмерсон)
Увеличивая размер сегментов WAL, можно сократить частоту вызова archive_command и
уменьшить число файлов WAL.
E.9.3.2. Репликация и восстановление
• Реализация возможности логически реплицировать таблицы на подчинённые серверы (Петр
Желинек)
Логическая репликация даёт большую гибкость, чем физическая; в том числе позволяет ор-
ганизовывать репликацию между разными основными версиями PostgreSQL, а также избира-
тельную репликацию.
• Возможность ожидания подтверждения фиксации от ведомых серверов вне зависимости от их
порядка в списке synchronous_standby_names (Масахико Савада)
Ранее сервер всегда ожидал ответа от активных ведомых серверов, стоящих первыми в списке
synchronous_standby_names. Новое ключевое слово ANY в synchronous_standby_names позволя-
ет выбрать ожидание любого числа серверов, вне зависимости от их порядка. Это называется
фиксацией на основе кворума.
• Упрощение изменений конфигурации, которые необходимо внести для организации потоково-
го копирования и репликации (Магнус Хагандер, Дан Мин Хыонг)
В частности, были изменены значения по умолчанию для параметров wal_level,
max_wal_senders, max_replication_slots и hot_standby, чтобы они были пригодны для такого ис-
пользования в исходном состоянии.
• По умолчанию репликация разрешается для локальных подключений в pg_hba.conf (Микаэль
Пакье)
Ранее строки для подключений репликации в pg_hba.conf по умолчанию были закомментиро-
ваны. Это особенно полезно для pg_basebackup.
• Добавление в pg_stat_replication столбцов с информацией о задержках репликации (Томас
Мунро)
Новые столбцы называются write_lag, flush_lag и replay_lag.
2332Замечания к выпуску
• Возможность указания точки остановки восстановления по LSN (последовательному номеру в
журнале) в recovery.conf (Микаэль Пакье)
Ранее точку остановки можно было задать только по времени или идентификатору транзак-
ции.
• Предоставление пользователям возможности отключить в функции pg_stop_backup() ожида-
ние архивации всех файлов WAL (Дэвид Стил)
Этим поведением управляет необязательный второй аргумент функции pg_stop_backup().
• Возможность создания временных слотов репликации (Петр Желинек)
Временные слоты автоматически удаляются при завершении сеанса или при ошибке.
• Увеличение производительности воспроизведения в режиме горячего резерва благодаря оп-
тимизации обработки исключительных блокировок (Саймон Риггс, Дэвид Роули)
• Ускорение восстановления при двухфазной фиксации (Стас Кельвич, Никхил Сонтакке, Мика-
эль Пакье)
E.9.3.3. Запросы
• Добавление функции XMLTABLE, преобразующей данные в формате XML в набор табличных
строк (Павел Стехуле, Альваро Эррера)
• Исправление обработки в регулярных выражениях классов символов для символов с больши-
ми кодами, в частности, для символов Unicode больше U+7FF (Том Лейн)
Ранее такие символы никогда не воспринимались как принадлежащие классам, зависящим от
локали, например [[:alpha:]].
E.9.3.4. Служебные команды
• Добавление синтаксиса секционирования для автоматического создания ограничений секций
и распределения операций добавления и изменения кортежей (Амит Ланготе)
Этот синтаксис поддерживает секционирование по спискам и по диапазонам.
• Добавление для триггеров AFTER переходных таблиц, содержащих изменённые строки (Кевин
Гриттнер, Томас Мунро)
Содержимое переходных таблиц доступно в триггерах, написанных на языках программирова-
ния на стороне сервера.
• Реализация ограничительных политик защиты на уровне строк (Стивен Фрост)
Ранее все политики были разрешительными, то есть при выполнении условия любой политики
доступ разрешался. Но теперь при невыполнении ограничительной политики доступ будет за-
прещён. Эти типы политик можно комбинировать вместе.
• При создании ограничения внешнего ключа разрешение REFERENCES должно требоваться
только для целевой таблицы (Том Лейн)
Ранее также требовалось разрешение REFERENCES в таблице внешнего ключа. Это требование
было реализовано из-за недопонимания SQL-стандарта. Так как для создания в таблице огра-
ничения внешнего ключа (или подобного) требуются иметь права владельца этой таблицы, до-
полнительное требование разрешения REFERENCES кажется довольно бессмысленным.
• Реализация прав по умолчанию для схем (Матеус Оливейра)
Эти права задаются командой ALTER DEFAULT PRIVILEGES.
• Добавление команды CREATE SEQUENCE AS для создания последовательностей определённого
целочисленного типа данных (Питер Эйзентраут)
2333Замечания к выпуску
Это упрощает создание последовательностей с интервалом значений, соответствующим типу
базовых столбцов.
• Поддержка команды COPY представление FROM источник для представлений с триггерами
INSTEAD INSERT (Харибабу Комми)
Триггеры получают строки данных, которые читает команда COPY.
• Допущение указания имени функции без аргументов в командах DDL, если это имя уникально
(Питер Эйзентраут)
Например, теперь допускается указание DROP FUNCTION с именем функции без аргументов, ес-
ли существует только одна функция с таким именем. Такое поведение требуется стандартом
SQL.
• Реализация возможности удалять несколько функций, операторов и агрегатов одной коман-
дой DROP (Питер Эйзентраут)
• Поддержка предложения IF NOT EXISTS в командах CREATE SERVER, CREATE USER MAPPING и
CREATE COLLATION (Анастасия Лубенникова, Питер Эйзентраут)
• Добавление в вывод VACUUM VERBOSE количества пропущенных замороженных страниц и ста-
рейшего xmin (Масахико Савада, Саймон Риггс)
Эта информация также включается в вывод с log_autovacuum_min_duration.
• Ускорение удаления конечных пустых страниц кучи в процессе операции VACUUM (Клаудио
Фрейре, Альваро Эррера)
E.9.3.5. Типы данных
• Добавление поддержки полнотекстового поиска для типов JSON и JSONB (Дмитрий Долгов)
С этими типами данных теперь могут использоваться функции ts_headline() и
to_tsvector().
• Добавление поддержки MAC-адресов EUI-64 в виде нового типа данных macaddr8 (Харибабу
Комми)
Этот тип дополняет ранее реализованную поддержку MAC-адресов EUI-48 (тип macaddr).
• Добавление столбцов идентификации для назначения числовых значений столбцам при добав-
лении данных (Питер Эйзентраут)
Этот механизм подобен столбцам SERIAL, но соответствует стандарту SQL.
• Реализация возможности переименовывать значения ENUM (Дагфинн Ильмари Маннсакер)
Для этого используется синтаксис ALTER TYPE … RENAME VALUE.
• Исправление обращения с псевдотипами массивов (anyarray) как с массивами в функциях
to_json() и to_jsonb() (Эндрю Дунстан)
Ранее столбцы, объявленные как anyarray, (в частности, столбцы в представлении pg_stats)
преобразовывались не в массивы, а в строки JSON.
• Добавление операторов для умножения и деления значений money на значения int8 (Питер
Эйзентраут)
Ранее в таких случаях значения int8 приводились к типу float8, а затем использовались опе-
раторы money-и-float8. Новое поведение предупреждает возможную потерю точности. Но за-
метьте, что при делении money на int8 теперь дробная часть отбрасывается, как и в других
случаях целочисленного деления, тогда как ранее происходило округление.
2334Замечания к выпуску
• Проверка переполнения в функции ввода типа money (Питер Эйзентраут)
E.9.3.6. Функции
• Добавление упрощённой функции regexp_match() (Эмре Хасегели)
Эта функция подобна regexp_matches(), но возвращает только результаты первого вхожде-
ния, поэтому для её результата не требуется множество, так что её удобнее использовать в
простых случаях.
• Новая версия оператора удаления для jsonb, принимающая массив ключей для удаления
(Магнус Хагандер)
• Реализация рекурсивной обработки объектов и массивов JSON в функции
json_populate_record() и родственных ей (Никита Глухов)
Благодаря этому изменению массивы JSON корректно преобразуются в поля-массивы в целе-
вом типе SQL, а объекты JSON — в поля, представляющие собой составные типы. Ранее в та-
ких случаях происходила ошибка при попытке передать строковое представление JSON-зна-
чения функциям array_in() и record_in(), так как синтаксис полученной строки не соответ-
ствовал ожидаемому этими функциями.
• Добавление функции txid_current_if_assigned(), возвращающей идентификатор текущей
транзакции или NULL, если транзакции не присвоен идентификатор (Крейг Рингер)
Этим данная функция отличается от txid_current(), которая всегда возвращает идентифика-
тор транзакции (назначая его, если он отсутствует). Данную функцию, в отличие от неё, мож-
но выполнять на ведомых серверах.
• Добавление функции txid_status(), проверяющей, была ли зафиксирована транзакция
(Крейг Рингер)
Это позволяет проверить после неожиданного обрыва соединения, была ли зафиксирована
предыдущая транзакция, если вы просто не успели получить уведомление об этом.
• Добавление функции make_date(), интерпретирующей отрицательные числа, как годы до на-
шей эры (Альваро Эррера)
• Функции to_timestamp() и to_date() не должны принимать поля вне допустимых пределов
(Артур Закиров)
Например, ранее вызов to_date(‘2009-06-40’,’YYYY-MM-DD’) выполнялся успешно и возвра-
щалась дата 2009-07-10. Теперь с такими аргументами будет выдаваться ошибка.
E.9.3.7. Языки программирования на стороне сервера
• Возможность вызывать функции cursor() и execute() в PL/Python как методы их аргумента —
объекта plan (Питер Эйзентраут)
Это позволяет придерживаться более объектно-ориентированного стиля программирования.
• Реализована возможность получать значения оператора GET DIAGNOSTICS в PL/pgSQL в эле-
ментах массива (Том Лейн)
Ранее синтаксическое ограничение не допускало использования в качестве целевой перемен-
ной элемента массива.
E.9.3.7.1. PL/Tcl
• Возможность возвращать составные типы и наборы данных из функций PL/Tcl (Карл Лехенбау-
эр)
• Добавление команды subtransaction в PL/Tcl (Виктор Вагнер)
2335Замечания к выпуску
Это позволяет обработать ошибку в запросах PL/Tcl, не прерывая всю функцию.
• Добавление серверных параметров pltcl.start_proc и pltclu.start_proc для указания функций
инициализации, которые будут вызываться при запуске PL/Tcl (Том Лейн)
E.9.3.8. Клиентские интерфейсы
• Реализована возможность указания нескольких адресов или имён серверов в строках подклю-
чения libpq и в строках URI (Роберт Хаас, Хейкки Линнакангас)
Функции libpq будут подключаться к первому работоспособному узлу из этого списка.
• В строках подключения libpq и URI добавлена возможность затребовать сервер для чтения/за-
писи, то есть ведущий, а не ведомый сервер (Виктор Вагнер, Митхун Сай)
Это полезно при указании нескольких имён узлов. Соответствующий параметр подключения
libpq — target_session_attrs.
• Реализована возможность задавать в параметрах подключения libpq имя файла паролей (Джу-
лиан Маркворт)
Ранее его можно было задать только в переменной окружения.
• Добавлена функция PQencryptPasswordConn(), позволяющая создавать больше видов зашиф-
рованных паролей на стороне клиента (Микаэль Пакье, Хейкки Линнакангас)
Ранее функцией PQencryptPassword() можно было создавать только пароли, зашифрован-
ные MD5. Новая функция может также создавать и пароли, зашифрованные методом SCRAM-
SHA-256.
• Изменение версии препроцессора ecpg с 4.12 на 10 (Том Лейн)
Впредь версия ecpg будет соответствовать номеру версии дистрибутива PostgreSQL.
E.9.3.9. Клиентские приложения
• Добавлена поддержка условных ветвлений в psql (Кори Хинкер)
В psql появились метакоманды \if, \elif, \else и \endif. Это полезно в первую очередь для
скриптов.
• Добавление в psql метакоманды \gx для выполнения запроса (запуска команды \g) в расши-
ренном режиме (\x) (Кристоф Берг)
• Расширение переменных psql внутри строк, заключённых в обратные апострофы (Том Лейн)
Это особенно полезно в новых командах условного ветвления psql.
• Недопущение установки некорректных значений для специальных переменных psql (Даниэль
Верите, Том Лейн)
Ранее, если какой-либо специальной переменной psql присваивалось некорректное значение,
оно просто игнорировалось и применялось поведение по умолчанию. Теперь \set со специаль-
ной переменной выдаст ошибку при недопустимом новом значении. В виде особого исключе-
ния \set с пустым или без нового значения по-прежнему действует как присвоение перемен-
ной значения on; но теперь в переменной действительно оказывается это значение, а не пу-
стая строка. Команда \unset со специальной переменной теперь действительно сбрасывает
переменную так, что она получает значение по умолчанию, то есть то значение, которая она
имела при запуске. В итоге управляющая переменная теперь всегда имеет отображаемое зна-
чение, отражающее, что фактически делает psql.
• Добавление переменных, показывающих версию сервера и psql (Фабьен Коэльо)
2336Замечания к выпуску
• Добавление в команды \d (показать отношение) и \dD (показать домен) вывода правила сорти-
ровки, допустимости NULL и свойств по умолчанию в отдельных столбцах (Питер Эйзентраут)
Ранее вся эта информация выводилась в одном столбце «Модификаторы».
• Унификация поведения команд \d в случаях, когда запрошенный объект не найден (Даниэль
Густафссон)
Теперь все они выводят сообщения об этом в stderr, а не в stdout, и текст сообщения стал бо-
лее единообразным.
• Усовершенствование дополнения табуляцией в psql (Джефф Джейнс, Иэн Барвик, Андреас
Карлссон, Сероп Саркуни, Томас Мунро, Кевин Гриттнер. Дагфинн Ильмари Маннсакер)
• Добавление в pgbench параметра –log-prefix для установки префикса файла журнала (Ма-
сахико Савада)
• Возможность разбивать метакоманды pgbench на несколько строк (Фабьен Коэльо)
Теперь метакоманду можно продолжить на следующей строке, введя обратную косую черту
перед переводом строки.
• Устранение ограничения на положение параметра -M по отношению к другим параметрам ко-
мандной строки (Том Лейн)
E.9.3.10. Серверные приложения
• Добавление в pg_receivewal параметра -Z/–compress для включения сжатия (Микаэль Пакье)
• Добавление в pg_recvlogical параметра –endpos для указания конечной позиции (Крейг Рин-
гер)
Этот параметр дополняет существовавший ранее параметр –startpos.
• Переименование параметров initdb –noclean и –nosync в –no-clean и –no-sync (Вик Фи-
ринг, Питер Эйзентраут)
Старое написание по-прежнему поддерживается.
E.9.3.10.1. pg_dump, pg_dumpall, pg_restore
• В pg_restore реализована возможность исключать схемы (Михаэль Банк)
Для этого добавлен новый ключ -N/–exclude-schema.
• В pg_dump добавлен параметр –no-blobs (Гийом Леларж)
Этот ключ отключает выгрузку больших объектов.
• В pg_dumpall добавлен ключ –no-role-passwords для отказа от чтения паролей ролей (Ро-
бинс Таракан, Саймон Риггс)
Это позволяет использовать pg_dumpall не только суперпользователям; без этого ключа
pg_dumpall пытается прочитать пароли, а обычным пользователям это не разрешается.
• Поддержка использования синхронных снимков при выгрузке данных с ведомого сервера
(Петр Желинек)
• Выполнение fsync() (синхронизации с ФС) для файлов, записываемых утилитами pg_dump и
pg_dumpall (Микаэль Пакье)
Это позволяет более уверенно гарантировать, что выгруженные файлы безопасно сохранены
на диске, до завершения работы программы. Это поведение можно отключить новым ключом
–no-sync.
2337Замечания к выпуску
• В pg_basebackup реализована возможность передавать журнал предзаписи в режиме tar (Маг-
нус Хагандер)
Содержимое WAL будет храниться в отдельном от основной копии файле tar.
• Использование в pg_basebackup временных слотов репликации (Магнус Хагандер)
Временные слоты репликации будут задействоваться по умолчанию, когда pg_basebackup ис-
пользует передачу WAL с параметрами по умолчанию.
• Более аккуратное выполнение синхронизации с ФС везде, где это требуется в pg_basebackup и
pg_receivewal (Микаэль Пакье)
• Добавление в pg_basebackup ключа –no-sync для отключения синхронизации с ФС (Микаэль
Пакье)
• Улучшение обработки в pg_basebackup пропускаемых каталогов (Дэвид Стил)
• Добавление параметра ожидания для операции повышения роли в pg_ctl (Питер Эйзентраут)
• Добавление длинных ключей для работы pg_ctl с ожиданием (–wait) и без ожидания (–no-
wait) (Вик Фиринг)
• Добавление длинного ключа для параметров, которые pg_ctl передаёт серверу (–options)
(Питер Эйзентраут)
• В ожидании готовности сервера команда pg_ctl start –wait должна наблюдать за
postmaster.pid, а не пытаться установить подключение (Том Лейн)
Процесс postmaster теперь может сигнализировать о своей готовности принимать подключе-
ния в файле postmaster.pid, и pg_ctl теперь проверяет этот файл, чтобы определить, что сер-
вер запущен. Этот метод эффективнее и надёжнее старого, а кроме того он избавляет от сооб-
щений о неудавшихся попытках подключения при запуске.
• Уменьшение времени реакции pg_ctl в ожидании запуска/остановки процесса postmaster (Том
Лейн)
Теперь pg_ctl проверяет изменения состояния postmaster не один (как раньше), а десять раз в
секунду.
• Возврат ненулевого кода состояния при выходе pg_ctl, если ожидаемая операция не заверши-
лась за отведённое время (Питер Эйзентраут)
Теперь операции start и promote возвращают в таких случаях код состояния 1, а не 0. Опера-
ция stop делала это всегда.
E.9.3.11. Исходный код
• Переход на нумерацию версий с двумя компонентами (Питер Эйзентраут, Том Лейн)
Номера выпусков теперь состоят из двух частей (например, 10.1), а не из трёх (например,
9.6.3). Основные версии теперь будут увеличивать только первое число, а корректирующие
выпуски — только второе. В названии ветвей выпусков будет включаться только одно число
(например, 10 вместо 9.6). Это изменение произведено для того, чтобы пользователям было
понятнее, что есть основная, а что — дополнительная версия PostgreSQL.
• Улучшение поведения pgindent (Пётр Стефаняк, Том Лейн)
Мы перешли на новую версию pg_bsd_indent, включающую последние усовершенствования из
проекта FreeBSD. В результате устранено множество мелких ошибок, которые приводили к
странным решениям относительно форматирования кода C. Одно из самых заметных измене-
ний — строки в скобках (например, вызов функции, записанный в нескольких строках) теперь
2338Замечания к выпуску
единообразно выравниваются по открывающей скобке, даже если в результате код будет вы-
ходить за правую границу.
• Возможность использования библиотеки ICU для поддержки правил сортировки (Питер Эй-
зентраут)
Библиотека ICU реализует версионирование, что позволяет выявлять изменения правил сор-
тировки от версии к версии. Она подключается параметром configure –with-icu. По умолча-
нию для сортировки по-прежнему используется встроенная библиотека операционной систе-
мы.
• Автоматическое добавление для всех функций PG_FUNCTION_INFO_V1 пометки DLLEXPORT в
Windows (Лауренц Альбе)
Если сторонний код использует объявления функций с характеристикой extern, они также
должны иметь пометки DLLEXPORT в этих объявлениях.
• Ликвидация ставших ненужными SPI-функций SPI_push(), SPI_pop(),
SPI_push_conditional(), SPI_pop_conditional() и SPI_restore_connection() (Том Лейн)
Теперь их функциональность реализуется автоматически. Сейчас остались пустые макросы с
такими именами (чтобы не требовалось немедленно обновлять внешние модули), но в конце
концов их вызовы должны быть удалены.
Побочным эффектом этого изменения стало то, что SPI_palloc() и родственные функции те-
перь требуют активного SPI-подключения; их действие не сводится к простому palloc(), ес-
ли его нет. Предыдущее такое поведение оказалось не очень полезным и было чревато неожи-
данными утечками памяти.
• Возможность динамического выделения разделяемой памяти (Томас Мунро, Роберт Хаас)
• Добавление механизма выделения памяти, подобного slab, для эффективного выделения па-
мяти фиксированного размера (Томаш Вондра)
• Использование семафоров POSIX вместо SysV в Linux и FreeBSD (Том Лейн)
Это снимает некоторые присущие платформе лимиты на использование семафоров SysV.
• Улучшение поддержки 64-битных атомарных операций (Андрес Фройнд)
• Использование 64-битных атомарных операций на платформе ARM64 (Роман Шапошник)
• Переход к использованию функции clock_gettime(), если она доступна, для замеров длитель-
ности (Том Лейн)
Если clock_gettime() недоступна, по-прежнему будет использоваться gettimeofday().
• Добавление более надёжных генераторов случайных чисел для криптографического использо-
вания (Магнус Хагандер, Микаэль Пакье, Хейкки Линнакангас)
Если надёжный генератор случайных чисел не обнаруживается, процедура configure прервёт-
ся, если только дополнительно не передать ключ –disable-strong-random. Однако с этим
ключом функции pgcrypto, которым требуется надёжный генератор случайных чисел, будут
отключены.
• В функции WaitLatchOrSocket() налажено ожидание подключения сокета в Windows (Андрес
Фройнд)
• Функции tupconvert.c более не преобразуют кортежи только для того, чтобы включить в них
другой OID составного типа (Ашутош Бапат, Том Лейн)
В большинстве точек вызова этот OID составного типа не нужен; но если результирующий
кортеж будет использоваться как составное значение Datum, требуются дополнительные дей-
ствия, чтобы в нём оказался корректный OID.
2339Замечания к выпуску
• Ликвидация портов SCO и Unixware (Том Лейн)
• Переработка процесса сборки документации (Александр Лахин)
• Использование XSLT для сборки документации PostgreSQL (Питер Эйзентраут)
Ранее использовались программы Jade, DSSSL и JadeTex.
• Сборка HTML-документации по умолчанию со стилями XSLT (Питер Эйзентраут)
E.9.3.12. Дополнительные модули
• Реализация в file_fdw возможности читать вывод программ, так же как и содержимое файлов
(Кори Хинкер, Адам Гомаа)
• В postgres_fdw реализована передача агрегатных функций на удалённый сервер, когда это
возможно (Дживан Чок, Ашутош Бапат)
Это сокращает объём данных, который должен передаваться со стороннего сервера и избавля-
ет запрашивающий сервер от вычисления агрегатной функции.
• postgres_fdw может передавать соединения отношений на сторонний сервер в большем числе
случаев (Дэвид Роули, Ашутош Бапат, Эцуро Фудзита)
• Исправление поддержки столбцов OID в таблицах postgres_fdw (Эцуро Фудзита)
Ранее в столбцах OID всегда возвращались нули.
• Реализация в btree_gist и btree_gin возможности индексировать типы-перечисления (Эндрю
Дунстан)
Это позволяет использовать перечисления в ограничениях-исключениях.
• Добавление в btree_gist поддержки индексации для типа данных UUID (Пол Юнгвирт)
• Добавлено расширение amcheck, которое может проверять корректность индексов-B-деревьев
(Питер Геохеган)
• Отображение в pg_stat_statements игнорируемых констант как $N, а не как ? (Лукас Фиттл)
• Улучшение в модуле cube обработки кубов с нулевой размерностью (Том Лейн)
При этом также улучшена работа со значениями infinite и NaN.
• Сокращение числа блокировок при обращении к представлению pg_buffercache (Иван Карты-
шов)
Как следствие, его можно более беспрепятственно использовать в производственных средах.
• Добавление в pgstattuple функции pgstathashindex() для просмотра статистики хеш-индексов
(Ашутош Шарма)
• Возможность использовать GRANT для управления доступом к функциям pgstattuple (Стивен
Фрост)
Это позволяет администраторам разрешать вызывать эти функции не только суперпользовате-
лям.
• Сокращение числа блокировок в pgstattuple при просмотре хеш-индексов (Амит Капила)
• Добавление в pageinspect функции page_checksum() для получения контрольной суммы стра-
ницы (Томаш Вондра)
• Добавление в pageinspect функции bt_page_items(), которая выводит элементы страницы для
переданного образа страницы (Томаш Вондра)
• Добавление поддержки хеш-индексов в pageinspect (Джеспер Педерсен, Ашутош Шарма)
2340Замечания к выпуску
E.9.4. Благодарственный список
Перечисленные ниже (в алфавитном порядке) лица сделали вклад в этот выпуск, разрабатывая,
совершенствуя и рецензируя код, принимая правки, проводя тестирование или сообщая о пробле-
мах.
Адам Брайтвелл (Adam Brightwell)
Адам Брюссельбек (Adam Brusselback)
Адам Гомаа (Adam Gomaa)
Адам Сах (Adam Sah)
Адриан Клавер (Adrian Klaver)
Аидан Ван Дик (Aidan Van Dyk)
Александр Алексеев (Aleksander Alekseev)
Александр Коротков (Alexander Korotkov)
Александр Лахин (Alexander Lakhin)
Александр Сосна (Alexander Sosna)
Алексей Баштанов (Alexey Bashtanov)
Алексей Грищенко (Alexey Grishchenko)
Алексей Исайко (Alexey Isayko)
Альваро Эрнандес Тортоза (Álvaro Hernández Tortosa)
Альваро Эррера (Álvaro Herrera)
Амит Капила (Amit Kapila)
Амит Ланготе (Amit Langote)
Амит Хандекар (Amit Khandekar)
Амул Сул (Amul Sul)
Анастасия Лубенникова (Anastasia Lubennikova)
Андреас Джозеф Крог (Andreas Joseph Krogh)
Андреас Зельтенрейх (Andreas Seltenreich)
Андреас Карлссон (Andreas Karlsson)
Андреас Шербаум (Andreas Scherbaum)
Андрей Бородин (Andrey Borodin)
Андрей Лизенко (Andrey Lizenko)
Андрес Фройнд (Andres Freund)
Антонин Хоуска (Antonin Houska)
Антс Аасма (Ants Aasma)
Арсений Шер (Arseny Sher)
Артур Закиров (Artur Zakirov)
Арьен Нинхаус (Arjen Nienhuis)
Атсуши Торикоши (Atsushi Torikoshi)
Ашвин Агравал (Ashwin Agrawal)
Ашутош Бапат (Ashutosh Bapat)
Ашутош Шарма (Ashutosh Sharma)
Аюми Исии (Ayumi Ishii)
Бейзил Бурк (Basil Bourque)
Бен де Грааф (Ben de Graaff)
Бенедикт Грундман (Benedikt Grundmann)
Бернд Хелмле (Bernd Helmle)
Бина Эмерсон (Beena Emerson)
Брандур Лич (Brandur Leach)
Брин Хаган (Breen Hagan)
Бруно Вольф III (Bruno Wolff III)
Брэд Дейонг (Brad DeJong)
Брюс Момджян (Bruce Momjian)
Вайшнави Прабакаран (Vaishnavi Prabakaran)
Венката Балажи Наготи (Venkata Balaji Nagothi)
Вик Фиринг (Vik Fearing)
Вики Вергара (Vicky Vergara)
Виктор Вагнер (Victor Wagner)
2341Замечания к выпуску
Винаяк Покале (Vinayak Pokale)
Вирен Неги (Viren Negi)
Виталий Буровой (Vitaly Burovoy)
Владимир Кунщиков (Vladimir Kunshchikov)
Владимир Русинов (Vladimir Rusinov)
Габриэль Бартолини (Gabriele Bartolini)
Габриэль Рот (Gabrielle Roth)
Гао Цзэнци (Gao Zengqi)
Генри Болерт (Henry Boehlert)
Гердан Сантос (Gerdan Santos)
Гийом Леларж (Guillaume Lelarge)
Грег Аткинс (Greg Atkins)
Грег Бурек (Greg Burek)
Григорий Смолкин (Grigory Smolkin)
Грэхем Даттон (Graham Dutton)
Давид Феттер (David Fetter)
Дагфинн Ильмари Маннсакер (Dagfinn Ilmari Mannsåker)
Дайсукэ Хигути (Daisuke Higuchi)
Дамиан Кирога (Damian Quiroga)
Дан Мин Хыонг (Dang Minh Huong)
Даниель Вестерман (Daniel Westermann)
Данило Глинский (Danylo Hlynskyi)
Даниэле Вараццо (Daniele Varrazzo)
Даниэль Верите (Daniel Vérité)
Даниэль Густафссон (Daniel Gustafsson)
Дарко Прелец (Darko Prelec)
Деврим Гюндюз (Devrim Gündüz)
Дейв Крамер (Dave Cramer)
Дейв Пейдж (Dave Page)
Денис Смирнов (Denis Smirnov)
Дениш Патель (Denish Patel)
Деннис Бьорклунд (Dennis Björklund)
Джанни Чиолли (Gianni Ciolli)
Джаред Уорд (Jarred Ward)
Джастин Муис (Justin Muise)
Джастин Призби (Justin Pryzby)
Джеймс Паркс (James Parks)
Джейсон Ли (Jason Li)
Джейсон О’Доннелл (Jason O’Donnell)
Джейсон Петерсен (Jason Petersen)
Джереми Финцель (Jeremy Finzel)
Джереми Шнайдер (Jeremy Schneider)
Джеспер Педерсен (Jesper Pedersen)
Джефф Девис (Jeff Davis)
Джефф Джейнс (Jeff Janes)
Джефф Дэфо (Jeff Dafoe)
Дживан Ладхе (Jeevan Ladhe)
Дживан Чок (Jeevan Chalke)
Джим Млодженски (Jim Mlodgenski)
Джим Нэсби (Jim Nasby)
Джинью Чжан (Jinyu Zhang)
Джо Конвей (Joe Conway)
Джон Беркус (Josh Berkus)
Джон Харви (John Harvey)
Джордан Гигов (Jordan Gigov)
Джош Сореф (Josh Soref)
Джоэл Джейкобсон (Joel Jacobson)
Джузеппе Брокколо (Giuseppe Broccolo)
2342Замечания к выпуску
Джулиан Маркворт (Julian Markwort)
Джун-сок Ян (Junseok Yang)
Дилип Кумар (Dilip Kumar)
Дилян Палаузов (Dilyan Palauzov)
Дин Рашид (Dean Rasheed)
Дмитрий Долгов (Dmitry Dolgov)
Дмитрий Иванов (Dimitry Ivanov)
Дмитрий Павлов (Dima Pavlov)
Дмитрий Сарафанников (Dmitriy Sarafannikov)
Дмитрий Федин (Dmitry Fedin)
Дон Моррисон (Don Morrison)
Дэвид Джонстон (David Johnston)
Дэвид Кристенсен (David Christensen)
Дэвид Роули (David Rowley)
Дэвид Рэйдер (David Rader)
Дэвид Стил (David Steele)
Дэн Вуд (Dan Wood)
Евгений Казаков (Eugene Kazakov)
Евгений Коньков (Eugen Konkov)
Егор Рогов (Egor Rogov)
Жиль Даролд (Gilles Darold)
Жульен Рухо (Julien Rouhaud)
И Вэнь Вон (Yi Wen Wong)
Иван Картышов (Ivan Kartyshov)
Игорь Корот (Igor Korot)
Ильдус Курбангалиев (Ildus Kurbangaliev)
Иэн Барвик (Ian Barwick)
Йелте Феннема (Jelte Fennema)
Йерун ван дер Хам (Jeroen van der Ham)
Йон Нельсон (Jon Nelson)
КайГай Кохэй (KaiGai Kohei)
Кайл Конрой (Kyle Conroy)
Карен Хаддлстон (Karen Huddleston)
Карл Лехенбауэр (Karl Lehenbauer)
Карл О. Пинц (Karl O. Pinc)
Каспер Жук (Kacper Zuk)
Каталин Якоб (Catalin Iacob)
Кевин Гриттнер (Kevin Grittner)
Кейт Фиске (Keith Fiske)
Ким Росе Карлсен (Kim Rose Carlsen)
Клаудио Фрейре (Claudio Freire)
Клинтон Адамс (Clinton Adams)
Конст Чжан (Const Zhang)
Константин Евтеев (Konstantin Evteev)
Константин Книжник (Konstantin Knizhnik)
Константин Пан (Constantin Pan)
Кори Хинкер (Corey Huinker)
Крейг Рингер (Craig Ringer)
Крис Бенди (Chris Bandy)
Крис Ричардс (Chris Richards)
Крис Рупрехт (Chris Ruprecht)
Кристиан Ульрих (Christian Ullrich)
Кристоф Берг (Christoph Berg)
Кунтал Гхош (Kuntal Ghosh)
Курт Карталтепе (Kurt Kartaltepe)
Куэль Чжо (QL Zhuo)
Кётаро Хоригути (Kyotaro Horiguchi)
Лауренц Альбе (Laurenz Albe)
2343Замечания к выпуску
Леонардо Чекки (Leonardo Cecchi)
Лукас Фиттл (Lukas Fittl)
Людовик Вожуа-Пепин (Ludovic Vaugeois-Pepin)
Магнус Хагандер (Magnus Hagander)
Майк Пальмиотто (Mike Palmiotto)
Майкл Дэй (Michael Day)
Максим Милютин (Maksim Milyutin)
Максим Соболев (Maksym Sobolyev)
Марек Чворен (Marek Cvoren)
Марк Дилгер (Mark Dilger)
Марк Кирквуд (Mark Kirkwood)
Марк Петер (Mark Pether)
Марк Расбах (Marc Rassbach)
Марк-Олаф Яшке (Marc-Olaf Jaschke)
Марко Тииккая (Marko Tiikkaja)
Маркос Кастедо (Marcos Castedo)
Маркус Винанд (Markus Winand)
Марллиус Рибейро (Marllius Ribeiro)
Марти Раудсепп (Marti Raudsepp)
Мартин Маркес (Martín Marqués)
Масахико Савада (Masahiko Sawada)
Матеус Оливейра (Matheus Oliveira)
Мерлин Монкьюр (Merlin Moncure)
Микаэль Пакье (Michael Paquier)
Милош Урбанек (Milos Urbanek)
Митхун Сай (Mithun Cy)
Михаэль Банк (Michael Banck)
Михаэль Мескес (Michael Meskes)
Михаэль Овермайер (Michael Overmeyer)
Мойше Джейкобсон (Moshe Jacobson)
Муртуза Забуавала (Murtuza Zabuawala)
Мэтью Феньяк (Mathieu Fenniak)
Наоки Окано (Naoki Okano)
Натан Боссарт (Nathan Bossart)
Натан Вагнер (Nathan Wagner)
Неха Хатри (Neha Khatri)
Неха Шарма (Neha Sharma)
Никита Глухов (Nikita Glukhov)
Николай Никитин (Nikolay Nikitin)
Николай Шаплов (Nikolay Shaplov)
Николас Бачелли (Nicolas Baccelli)
Николас Гини (Nicolas Guini)
Николас Товен (Nicolas Thauvin)
Николаус Тиль (Nikolaus Thiel)
Никхил Сонтакке (Nikhil Sontakke)
Нил Андерсон (Neil Anderson)
Ной Миш (Noah Misch)
Нориёси Синода (Noriyoshi Shinoda)
Олаф Гавенда (Olaf Gawenda)
Олег Бартунов (Oleg Bartunov)
Оскари Сааренмаа (Oskari Saarenmaa)
Отар Шавадзе (Otar Shavadze)
Паван Деоласи (Pavan Deolasee)
Павел Голубь (Pavel Golub)
Павел Райскуп (Pavel Raiskup)
Павел Стехуле (Pavel Stehule)
Павел Ханак (Pavel Hanák)
Пареш Мор (Paresh More)
2344Замечания к выпуску
Петр Желинек (Petr Jelínek)
Питер Геохеган (Peter Geoghegan)
Питер Эйзентраут (Peter Eisentraut)
Пол Рамсей (Paul Ramsey)
Пол Юнгвирт (Paul Jungwirth)
Прабхат Саху (Prabhat Sahu)
Пьер-Эммануэль Андре (Pierre-Emmanuel André)
Пэн Сунь (Peng Sun)
Пётр Стефаняк (Piotr Stefaniak)
Рагнар Оухтерлони (Ragnar Ouchterlony)
Радек Слупик (Radek Slupik)
Раджкумар Рагхуванши (Rajkumar Raghuwanshi)
Райан Мерфи (Ryan Murphy)
Рафа де ла Торре (Rafa de la Torre)
Рафия Сабих (Rafia Sabih)
Рахила Сьед (Rahila Syed)
Регина Обе (Regina Obe)
Ричард Пистоль (Richard Pistole)
Роберт Хаас (Robert Haas)
Робинс Таракан (Robins Tharakan)
Род Тейлор (Rod Taylor)
Роман Шапошник (Roman Shaposhnik)
Рушаб Латиа (Rushabh Lathia)
Саймон Риггс (Simon Riggs)
Сандип Таккар (Sandeep Thakkar)
Свейн Свейнссон (Sveinn Sveinsson)
Свен Р. Кунце (Sven R. Kunze)
Себастьян Луке (Sebastian Luque)
Сергей Бурладян (Sergey Burladyan)
Сергей Копосов (Sergey Koposov)
Сероп Саркуни (Sehrope Sarkuni)
Симоне Готти (Simone Gotti)
Синтия Шан (Cynthia Shang)
Синъити Мацуда (Shinichi Matsuda)
Скотт Милликен (Scott Milliken)
Спенсер Томасон (Spencer Thomason)
Стас Кельвич (Stas Kelvich)
Степан Пестерников (Stepan Pesternikov)
Стив Рэндалл (Steve Randall)
Стив Сингер (Steve Singer)
Стивен Винфилд (Steven Winfield)
Стивен Фрост (Stephen Frost)
Стивен Фэклер (Steven Fackler)
Сурадж Хараге (Suraj Kharage)
Тайки Кондо (Taiki Kondo)
Такаюки Цунакава (Takayuki Tsunakawa)
Такэси Идэриха (Takeshi Ideriha)
Тахир Фахрутдинов (Tahir Fakhroutdinov)
Тацуо Исии (Tatsuo Ishii)
Тацуро Ямада (Tatsuro Yamada)
Тим Гудэйр (Tim Goodaire)
Тобиас Бусман (Tobias Bussmann)
Том Браун (Thom Brown)
Том Дунстан (Tom Dunstan)
Том Лейн (Tom Lane)
Тома ван Тилбург (Tom van Tilburg)
Томас Келлерер (Thomas Kellerer)
Томас Мунро (Thomas Munro)
2345Замечания к выпуску
Томаш Вондра (Tomas Vondra)
Томонари Кацумата (Tomonari Katsumata)
Тушар Ахуджа (Tushar Ahuja)
Фабрицио де Ройес Мелло (Fabrízio de Royes Mello)
Фабьен Коэльо (Fabien Coelho)
Фейке Стинберген (Feike Steenbergen)
Феликс Герзаге (Felix Gerzaguet)
Филип Йирсак (Filip Jirsák)
Филипп Бодуэн (Philippe Beaudoin)
Фудзии Масао (Fujii Masao)
Фёдор Сигаев (Teodor Sigaev)
Хайме Казанова (Jaime Casanova)
Ханс Бушман (Hans Buschmann)
Харибабу Комми (Haribabu Kommi)
Хейкки Линнакангас (Heikki Linnakangas)
Хуань Жуань (Huan Ruan)
Чепмен Флэк (Chapman Flack)
Чжоу Дигоал (Zhou Digoal)
Чжэнь Мин Ян (Zhen Ming Yang)
Чуаньтин Ван (Chuanting Wang)
Чхве Ду-Вон (Choi Doo-Won)
Чэнь Хуацзюнь (Chen Huajun)
Шо Като (Sho Kato)
Шон Фаррел (Sean Farrell)
Шэй Роджански (Shay Rojansky)
Эйдзи Сэки (Eiji Seki)
Эйлер Тавейра (Euler Taveira)
Эмил Иггланд (Emil Iggland)
Эмре Хасегели (Emre Hasegeli)
Энди Абелисто (Andy Abelisto)
Эндрю Вилрайт (Andrew Wheelwright)
Эндрю Гирт (Andrew Gierth)
Эндрю Дунстан (Andrew Dunstan)
Энрике Менесес (Enrique Meneses)
Эрвин Брандштеттер (Erwin Brandstetter)
Эрик Нордстром (Erik Nordström)
Эрик Рижкерс (Erik Rijkers)
Эцуро Фудзита (Etsuro Fujita)
Юго Нагата (Yugo Nagata)
Якоб Еггер (Jakob Egger)
E.10. Release 9.6.11
Дата выпуска:
2018-11-08
В этот выпуск вошли различные исправления, внесённые после версии 9.6.10. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.10.1. Миграция на версию 9.6.11
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.6.9, см. Раздел E.12.
E.10.2. Изменения
• Устранение сбоев, которые могли возникать в особых случаях в семействе функций has_объ-
ект_privilege() (Том Лейн)
2346Замечания к выпуску
Эти функции должны возвращать NULL, а не выдавать ошибку при получении неверного
OID. Некоторые из этих функций делали это и прежде, но не все. Кроме того, в функции
has_column_privilege() на некоторых платформах могли иметь место и другие сбои.
• Недопущение замедления порядка O(N^2) в функциях match/split с регулярными выражения-
ми при обработке длинных строк (Эндрю Гирт)
• Исправление дефекта в обработке стандартных многосимвольных операторов, следующих
непосредственно за комментарием или символами + и - (Эндрю Гирт)
Следствием данного упущения могли быть ошибки при разборе или неправильное определе-
ние приоритета операторов.
• Недопущение замедления порядка O(N^3) при обработке лексическим анализатором длин-
ных строк из символов + или - (Эндрю Гирт)
• Исправление некорректного выполнения подчинённых планов при сканировании внешнего
запроса в обратном направлении (Эндрю Гирт)
• Исправление ошибочного поведения UPDATE/DELETE … WHERE CURRENT OF … после переме-
щения курсора (Том Лейн)
Курсор, сканирующий несколько отношений (в частности, дерево наследования), мог работать
неправильно, возвращаясь к предыдущему отношению.
• Исправление в функции EvalPlanQual обработки узлов InitPlan, которые выполняются по
условию (Эндрю Гирт, Том Лейн)
Вследствие ошибки реализации могли возникать сложновоспроизводимые сбои или выдавать-
ся неправильные результаты при одновременных запросах на изменение, содержащих изоли-
рованные вложенные SELECT в конструкции CASE.
• Исправление проверок классов символов для корректной поддержки в Windows символов
Unicode выше U+FFFF (Том Лейн, Кэндзи Уно)
Эта ошибка проявлялась в операциях полнотекстового поиска, а также в работе модулей
contrib/ltree и contrib/pg_trgm.
• Недопущение передачи вложенных SELECT с оконными функциями, а также с указаниями
LIMIT или OFFSET, параллельным исполнителям (Амит Капила)
В таких случаях поведение могло быть несогласованным из-за того, что разные исполнители
получали разные результаты вследствие вариативности в порядке строк.
• Смена владельца последовательности, принадлежащей сторонней таблице, при выполнении
ALTER OWNER для этой таблицы (Питер Эйзентраут)
Операция смены владельца должна распространяться и на такие последовательности, но
раньше сторонние таблицы она не затрагивала.
• Обеспечение обработки сервером уже полученных прерываний NOTIFY и SIGTERM до начала
ожидания данных от клиента (Джефф Джейнс, Том Лейн)
• Устранение ошибки, приводившей к выделению лишней памяти для строки результатов
array_out() (Кэйити Хиробэ)
• Ликвидация утечки памяти при сканировании индекса SP-GiST (Том Лейн)
Сколько-нибудь значительное проявление этой утечки наблюдалось, только когда для ограни-
чения-исключения, использующего SP-GiST, в индекс поступало много записей.
• Закрытие файла сопоставлений в ApplyLogicalMappingFile() после завершения его использо-
вания (Томаш Вондра)
2347Замечания к выпуску
Ранее дескриптор файла терялся, что могло в итоге приводить к сбоям при логическом деко-
дировании.
• Устранение ошибки логического декодирования в случаях, когда сопоставленная таблица ка-
талога постоянно перезаписывается, например, в результате действия VACUUM FULL (Андрес
Фройнд)
• Предотвращение запуска сервера со значением wal_level, недостаточно большим для под-
держки существующего слота репликации (Андрес Фройнд)
• Предотвращение сбоя в случаях, когда служебная команда создаёт бесконечную рекурсию
(Том Лейн)
• Устранение в процессе инициализации горячего резерва проблемы дублирующихся XID, ко-
торые образуются при выполнении двухфазных транзакций на ведущем сервере (Микаэль Па-
кье, Константин Книжник)
• Исправление поведения событийных триггеров при обработке вложенных команд ALTER TABLE
(Микаэль Пакье, Альваро Эррера)
• Передача параллельным исполнителям времени начала оператора и транзакции от родитель-
ского процесса (Константин Книжник)
Тем самым исправлено поведение таких функций, как transaction_timestamp(), выполняю-
щихся в параллельном исполнителе.
• Обеспечение корректного выравнивания при передаче расширенных значений данных парал-
лельным исполнителям, что позволяет избежать сбоев на платформах, требовательных к вы-
равниванию (Том Лейн, Амит Капила)
• Исправление логики переработки файла WAL для правильного выполнения этой операции на
ведомых серверах (Микаэль Пакье)
В зависимости от значения параметра archive_mode ведомый сервер мог не удалить некото-
рые файлы WAL, подлежащие удалению.
• Исправление обработки времени фиксации транзакций в процессе восстановления (Масахико
Савада, Микаэль Пакье)
Если отслеживание времени фиксации не было включено постоянно, в процессе восстановле-
ния мог произойти сбой при попытке получить время фиксации транзакции, для которой оно
не было записано.
• Использование случайной затравки для random() в initdb, а также в сервере, запускаемом в
режиме начальной загрузки и в монопольном режиме (Ной Миш)
Практическая польза этого изменения состоит прежде всего в разрешении проблемы, когда
программа initdb не могла использовать общую память POSIX, считая её недоступной, из-за
конфликтов имён, вызванных использованием одинаковой затравки.
• Возможность прерывания операции выделения памяти в DSM (Крис Трэверс)
• Предупреждение сбоя в параллельном исполнителе при загрузке расширения, пытающегося
обратиться к системным кешам в своей функции инициализации (Томас Мунро)
Мы не считаем это удачным приёмом программирования расширений, но до внедрения парал-
лельных запросов это работало, а значит должно поддерживаться и теперь.
• Исправление поведения при динамическом включении параметра full_page_writes (Кётаро
Хоригути)
• Недопущение возможного сбоя в результате двойного освобождения памяти при повторном
сканировании SP-GiST (Эндрю Гирт)
• Предупреждение возможного переполнения буфера при воспроизведении операции распаков-
ки страницы GIN из WAL (Александр Коротков, Шивасубраманьян Рамасубраманьян)
2348Замечания к выпуску
• Выполнение операции fsync, ранее упущенной, для каталога слотов репликации (Константин
Книжник, Микаэль Пакье)
• Устранение неожиданных тайм-аутов при использовании wal_sender_timeout на медленном
сервере (Ной Миш)
• Исправление вычисления подходящей точки согласованности WAL в процессах горячего ре-
зерва (Александр Кукушкин, Микаэль Пакье)
Выбор правильной точки позволяет предотвратить некорректное поведение сразу после того,
как ведомый сервер достигает согласованного состояния базы при воспроизведении WAL.
• Корректная остановка фоновых рабочих процессов при получении главным процессом запро-
са на быстрое отключение до завершения запуска базы (Александр Кукушкин)
• Обновление карты свободного пространства при воспроизведении из WAL изменений флагов
замороженных/полностью видимых страниц (Альваро Эррера)
Ранее мы не заботились об этом, считая, что в карте свободного пространства в любом слу-
чае нет важной информации. Однако если она сильно устаревает, это может привести к зна-
чительному снижению производительности после повышения ведомого сервера до основного.
Эта карта в конце концов будет исправлена в результате обновлений, но мы хотим иметь её в
хорошем состоянии раньше, поэтому стоит приложить дополнительные усилия и поддержи-
вать её актуальность при воспроизведении WAL.
• Предотвращение преждевременного освобождения ресурсов параллельных исполнителей по
окончании запроса или при достижении предельного числа кортежей (Амит Капила)
В этот момент завершение исполнителя допустимо, только если вызывающий процесс не мо-
жет запросить обратное сканирование.
• Отказ от вызова обработчиков atexit при обработке SIGQUIT (Хейкки Линнакангас)
• Исключение сопоставлений пользователей для сторонних серверов из состава расширений
(Том Лейн)
При выполнении CREATE USER MAPPING в скрипте расширения для создаваемого сопоставле-
ния добавлялась зависимость, чего не должно быть. Сопоставления пользователей, как и ро-
ли, не могут быть членами расширений.
• Исправление поведения syslogger в случае ошибок при попытке открыть файлы CSV (Том
Лейн)
• Исправление кода psql, а также примеров в документации, чтобы функция PQconsumeInput()
вызывалась перед PQnotifies() (Том Лейн)
Тем самым решена проблема, когда psql не выдавал полученное сообщение NOTIFY до следую-
щей команды.
• Устранение возможной несогласованности при сортировке различных имён объектов в
pg_dump (Джейкоб Чемпион)
• Исправление pg_restore, чтобы при выдаче команд DISABLE/ENABLE TRIGGER имя таблицы до-
полнялось схемой (Том Лейн)
Это предотвращает сбои, возможные при новой политике выполнения восстановления с огра-
ниченным путём поиска.
• В pg_upgrade исправлена обработка событийных триггеров в расширениях (Харибабу Комми)
Ранее pg_upgrade не сохранял связь событийных триггеров с расширениями.
• Исправление проверки состояния кластера в pg_upgrade, чтобы она корректно выполнялась
на ведомом сервере (Брюс Момджян)
• Ограничение числа размерностей в значениях cube во всех функциях contrib/cube (Андрей
Бородин)
2349Замечания к выпуску
Ранее в некоторых функциях, связанных с кубами, можно было создать такие значения, кото-
рые затем не принимала функция cube_in(), что вызывало ошибки при восстановлении вы-
груженных данных.
• Недопущение передачи расширением contrib/postgres_fdw предложений ORDER BY, не со-
держащих переменных, на удалённый сервер (Эндрю Гирт)
• Исправление функции unaccent() в расширении contrib/unaccent, чтобы она использовала
словарь текстового поиска unaccent, находящийся в той же схеме, где и сама функция (Том
Лейн)
Ранее она пыталась найти словарь по пути поиска, но могла не обнаружить его, если путь по-
иска был ограничен.
• Устранение проблем при сборке в macOS 10.14 (Mojave) (Том Лейн)
Усовершенствование скрипта configure, чтобы в CPPFLAGS добавлялся ключ -isysroot; без
этого PL/Perl и PL/Tcl нельзя сконфигурировать или собрать в macOS 10.14. Значение sysroot
можно переопределить во время конфигурирования или сборки, установив переменную
PG_SYSROOT в аргументах configure или make.
Теперь рекомендуется, чтобы для связанных с Perl расширений во флагах компилятора указы-
валось $(perl_includespec), а не -I$(perl_archlibexp)/CORE. Второй вариант по-прежнему
будет работать на большинстве платформ, но не в последних macOS.
Также теперь не требуется указывать вручную ключ –with-tclconfig, чтобы собрать PL/Tcl в
последних версиях macOS.
• Исправление скриптов сборки с MSVC и регрессионного тестирования для работы с последни-
ми версиями Perl (Эндрю Дунстан)
Это изменение вызвано тем, что Perl теперь по умолчанию не включает текущий каталог в
свой путь поиска.
• Реализована возможность запускать регрессионные тесты в Windows с учётной записью адми-
нистратора (Эндрю Дунстан)
Чтобы это было безопасно, pg_regress теперь лишает себя расширенных прав при запуске.
• Снятие запрета на возврат из функций сравнения btree значений INT_MIN (Том Лейн)
До настоящего времени мы не позволяли типозависимым функциям сравнения возвращать
INT_MIN, благодаря чему вызывающий код мог сменить порядок сортировки, просто изменив
знак результата сравнения. Однако это могло вызывать проблемы с функциями сравнения,
возвращающими непосредственно результат memcmp(), strcmp() и подобных функций, так как
POSIX не накладывает на него никаких ограничений. Как минимум некоторые последние вер-
сии memcmp() могут возвращать INT_MIN, что приводило к нарушению порядка сортировки. В
связи с этим мы убрали это ограничение. Там же, где требуется поменять порядок сортировки
на противоположный, теперь нужно использовать макрос INVERT_COMPARE_RESULT().
• Устранение риска рекурсии при обработке сообщений об аннулировании общего кеша (Том
Лейн)
Эта ошибка могла привести, например, к сбою при обращении к системному каталогу или ин-
дексу, который был только что обработан командой VACUUM FULL.
В результате этого изменения функция LockAcquire теперь может возвращать новый код ре-
зультата, что теоретически может вызвать проблемы при использовании этой функции, хо-
тя для этого схема её использования должна быть весьма необычной. Также был изменён API
функции LockAcquireExtended.
• Сохранение и восстановление глобальных переменных SPI в SPI_connect() и SPI_finish()
(Чепмен Флэк, Том Лейн)
2350Замечания к выпуску
Это предотвращает накладки, возможные при вызове из одной функции, использующей SPI,
другой такой функции.
• Предотвращение использования потенциально невыравненных буферов страниц (Том Лейн)
Добавлены новые типы-объединения PGAlignedBlock и PGAlignedXLogBlock, которые должны
использоваться вместо простых массивов char, чтобы компилятор гарантированно выравни-
вал адрес начала буфера. В результате устраняется риск аварийного сбоя на платформах, чув-
ствительных к выравниванию, и может увеличиться быстродействие даже на тех платформах,
где выравнивание не требуется.
• Приведение в src/port/snprintf.c значения результата snprintf() в соответствие со стан-
дартом C99 (Том Лейн)
На платформах, где этот код используется (в основном в Windows), его несовременное поведе-
ние (не соответствующие C99) могло препятствовать выявлению переполнения буфера, если
вызывающий код рассчитывал на семантику C99.
• Требование обязательного использования -msse2 при сборке компилятором clang для i386
(Андрес Фройнд)
Тем самым решается проблема отсутствия проверок переполнения при операциях с плаваю-
щей точкой.
• Исправление в configure проверки, определяющей, результат какого типа возвращает
strerror_r() (Том Лейн)
Предыдущая реализация давала неправильный ответ при сборке с использованием компиля-
тора icc в Linux (возможно, и в других случаях), в результате чего libpq не выдавала полезные
сообщения при возникновении системных ошибок.
• Обновление данных часовых поясов до версии tzdata 2018g, включающее изменений правил
перехода на летнее время в России (Волгограде), Чили, Марокко и на Фиджи, а также коррек-
тировку исторических данных для Китая, Гавайев, Японии, Макао и Северной Кореи.
E.11. Выпуск 9.6.10
Дата выпуска:
2018-08-09
В этот выпуск вошли различные исправления, внесённые после версии 9.6.9. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.11.1. Миграция на версию 9.6.10
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.6.9, см. Раздел E.12.
E.11.2. Изменения
• Осуществление полного сброса состояния libpq между попытками соединения (Том Лейн)
Непривилегированный пользователь dblink или postgres_fdw мог обойти проверки, пред-
назначенные для предотвращения использования учётных данных на стороне сервера, на-
пример, файла ~/.pgpass, принадлежащего пользователю ОС, от имени которого работа-
ет сервер. В частности, уязвимость затрагивает серверы, принимающие локальные подклю-
чения с методом peer. Возможны были и другие атаки, например, SQL-инъекции в сеансе
postgres_fdw. Для атаки на postgres_fdw через эту уязвимость пользователь должен был
иметь возможность создавать объект стороннего сервера с нужными параметрами подключе-
ния, но атаку на dblink мог произвести любой пользователь, имеющий к нему доступ. Вообще
любой пользователь, имеющий возможность менять параметры подключения для приложения
на базе libpq, мог производить непредусмотренные действия, но другие эффективные сцена-
2351Замечания к выпуску
рии эксплуатации этого сложно придумать. Мы благодарим Андрея Красичкова за сообщение
о данном дефекте. (CVE-2018-10915)
• Исправление поведения INSERT … ON CONFLICT UPDATE с более сложным представлением,
чем просто SELECT * FROM … (Дин Рашид, Амит Ланготе)
Ошибочное развёртывание изменяемого представления могло приводить к сбоям или ошиб-
кам «attribute … has the wrong type» (атрибут … имеет неверный тип), если список SELECT
представления не соответствовал в точности списку столбцов нижележащей таблицы. Более
того, развив атаку через эту уязвимость, злоумышленник мог изменять столбцы, не имея для
них права UPDATE, но имея права INSERT и UPDATE для некоторых других столбцов в таблице.
Любой пользователь также мог эксплуатировать её для раскрытия содержимого памяти сер-
вера. (CVE-2018-10925)
• Обеспечение своевременного изменения полей relfrozenxid и relminmxid в «зафиксирован-
ных» системных каталогах (Андрес Фройнд)
Из-за чрезмерно оптимистичного кеширования эти изменения могли оказаться невидимыми
для других сеансов, что приводило к случайным ошибкам и/или разрушению данных. Для об-
щих каталогов, таких как pg_authid, проблема была ещё острее, так как устаревшие кеширо-
ванные данные могли попадать в новые сеансы и оставаться в существующих.
• Исправление поведения в ситуации, когда недавно повышенный сервер аварийно завершает-
ся до окончания обработки первой контрольной точки после восстановления (Микаэль Пакье,
Кётаро Хоригути, Паван Деоласи, Альваро Эррера)
В такой ситуации сервер не считал, что при последующем воспроизведении WAL было достиг-
нуто согласованное состояние базы данных, и это препятствовало его перезапуску.
• Исключение выдачи фантомной записи WAL при переработке полностью нулевой страницы
индекса btree (Амит Капила)
Эта ошибка проявлялась в сбоях проверочных утверждений и могла приводить к неоправдан-
ным отменам запросов на серверах горячего резерва.
• При воспроизведении WAL добавлена защита от некорректной длины записи, превышающей 1
ГБ (Микаэль Пакье)
Подобные данные должны считаться некорректными. Ранее код пытался выделить такой объ-
ём и получал критическую ошибку, что делало восстановление невозможным.
• При завершении восстановления запись в файл истории линии времени должна откладывать-
ся, насколько это возможно (Хейкки Линнакангас)
Это позволяет избежать ситуаций с несогласованностью состояния линии времени на диске,
возникавших при сбое в процессе очистки после восстановления (например, при проблеме с
файлом двухфазного состояния).
• Увеличение скорости воспроизведения WAL для транзакций, удаляющих множество отноше-
ний (Фудзии Масао)
В результате этого изменения уменьшается число сканирований общих буферов, поэтому эф-
фект от данного изменения тем больше, чем больше значение shared_buffers.
• Увеличение скорости освобождения блокировки при воспроизведении WAL ведомым сервером
(Томас Мунро)
• Обеспечение согласованной передачи состояния логической трансляции передатчиками WAL
(Саймон Риггс, Савада Масахико)
Ранее код не мог правильно определить, удалось ли нагнать вышестоящий сервер.
• Устранение дефектов в процедуре обработки снимков при логическом декодировании, приво-
дивших к ошибкам декодирования в редких случаях (Арсений Шер, Альваро Эррера)
2352Замечания к выпуску
• Обеспечение корректного сброса кешированного списка индексов таблицы после сбоя при со-
здании индекса (Питер Геохеган)
Ранее в этом списке могли оставаться OID нерабочих индексов, что могло приводить к про-
блемам в том же сеансе.
• Исправление некорректной обработки пустых несжатых страниц списка идентификаторов в
индексах GIN (Шивасубраманьян Рамасубраманьян, Александр Коротков)
Это могло привести к сбою проверочного утверждения после выполнения pg_upgrade для ин-
дексов GIN версии до 9.4 (в 9.4 и последующих версиях такие страницы не создаются).
• Обеспечение реакции на сигналы в процессе VACUUM в цикле удаления страниц B-дерева (Ан-
дрес Фройнд)
С испорченными индексами btree цикл мог оказаться бесконечным, и прервать его можно бы-
ло только аварийно отключив сервер.
• Исправление некорректной оптимизации классов эквивалентности со столбцами составного
типа (Том Лейн)
Вследствие данной ошибки сервер не понимал, что индекс по составному столбцу может обес-
печить порядок сортировки, необходимый для соединения слиянием с данным столбцом.
• Исправление планировщика с целью устранения ошибок «ORDER/GROUP BY expression not
found in targetlist» (выражение ORDER/GROUP BY не найдено в целевом списке) при выполне-
нии некоторых запросов с функциями, возвращающими множества (Том Лейн)
• Исправление синтаксиса конструкции SQL-стандарта FETCH FIRST, чтобы она принимала ($n),
как того требует стандарт (Эндрю Гирт)
• Исправление в EXPLAIN учёта использования ресурсов, в частности, обращений к буферам
(Амит Капила, Томас Мунро)
• Корректное добавление схемы к именам ряда объектов в выводе getObjectDescription (Кёта-
ро Хоригути, Том Лейн)
Имена правил сортировки, преобразований и объектов текстового поиска не дополнялись схе-
мой, тогда как должны были.
• Исправление проверки типа CREATE AGGREGATE с тем, чтобы к агрегатам с переменными аргу-
ментами можно было присоединять функции поддержки распараллеливания (Алексей Башта-
нов)
• Расширение счётчика строк в команде COPY FROM с 32 до 64 бит (Дэвид Роули)
Тем самым были решены две проблемы с входными данными, содержащими более 4G строк:
COPY FROM WITH HEADER терял одну строку на каждые 4G строк (не только первую), а в сообще-
ниях об ошибках выводилось неверное количество строк.
• Добавление в библиотеку ecpg pgtypes функции освобождения строк для исключения про-
блем с управлением памятью в разных модулях (Такаюки Цунакава)
В Windows могут происходить сбои, если вызов free для некоторого блока памяти произво-
дится не из той DLL, которая выделила память (с помощью malloc). Библиотека pgtypes ино-
гда возвращает строки, которые должен освободить вызывающий код, и сделать это корректно
оказывается невозможно. Добавленная функция PGTYPESchar_free() является просто обёрт-
кой free, позволяющей приложениям произвести освобождение по правилам.
• Исправление поддержки в ecpg переменных long long в Windows, а также на других платфор-
мах, где strtoll/strtoull объявлены нестандартно или не объявлены вовсе (Хыонг Дангминь,
Том Лейн)
• Исправление ошибки с определением типа SQL-оператора в PL/pgSQL, когда изменение пра-
вила приводило к изменению семантики оператора в рамках сеанса (Том Лейн)
2353Замечания к выпуску
Эта ошибка приводила к сбоям проверочных утверждений или, в редких случаях, к тому, что
указание INTO STRICT не работало должным образом.
• Исправление запроса пароля в клиентских программах, чтобы отображение корректно отклю-
чалось в Windows, когда stdin — не терминал (Мэтью Стикни)
• Доработка исправления некорректного заключения в кавычки значений для переменных GUC
со списками при формировании дампа (Том Лейн)
Предыдущее исправление для заключения в кавычки значения search_path и других пере-
менных со списками в выводе pg_dump, как оказалось, привело к ошибкам со списками с пу-
стыми элементами и риску потери части длинных файловых путей.
• В pg_dump устранено упущение, когда свойства REPLICA IDENTITY для индексов ограничений
не выгружались (Том Лейн)
Уникальные индексы, созданные вручную, помечались корректно, а индексы, созданные огра-
ничениями UNIQUE или PRIMARY KEY — нет.
• В pg_upgrade теперь правильно проверяется, что старый сервер был выключен штатно (Брюс
Момджян)
Ранее проверка могла сработать некорректно при выключении сервера в незамедлительном
режиме.
• Исправление в contrib/hstore_plperl просмотра скалярных ссылок Perl и предотвращение
сбоя в случае, если не удаётся найти хеш-ссылку там, где она ожидается (Том Лейн)
• Устранение сбоя в функции модуля contrib/ltree при получении на вход пустого массива
(Пьер Дюкроке)
• Исправление обработки ошибок в ряде мест, где мог выдаваться некорректный код ошибки
(Микаэль Пакье, Том Лейн, Магнус Хагандер)
• Переоформление скриптов Makefile для обеспечения компоновки программ с собранными в
том же дереве библиотеками (например, libpq.so), а не с теми, что могут уже находиться в
системных каталогах библиотек (Том Лейн)
Это позволяет избежать проблем при сборке на платформах, где представлены старые версии
библиотек PostgreSQL.
• Обновление данных часовых поясов до версии tzdata 2018e, включающее изменение правил
перехода на летнее время в Северной Корее, а также корректировку исторических данных
для Чехословакии.
В это обновление вошло переопределение «летнего времени», которое действует в Ирландии,
а также действовало в прошлом в Намибии и в Чехословакии. В этих юрисдикциях стандарт-
ное время действует летом, а время для экономии света — зимой, поэтому при переходе на
это время сдвиг производится на час назад, а не на час вперёд. Это не влияет ни на фактиче-
ское смещение от UTC, ни на используемое сокращение часового пояса; эта особенность про-
является лишь в том, что в таких случаях столбец is_dst в представлении pg_timezone_names
будет содержать true для зимнего периода, и false для летнего.
E.12. Выпуск 9.6.9
Дата выпуска:
2018-05-10
В этот выпуск вошли различные исправления, внесённые после версии 9.6.8. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.12.1. Миграция на версию 9.6.9
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
2354Замечания к выпуску
Однако если вы используете расширение adminpack, его нужно обновить, следуя указаниям в пер-
вой записи в списке изменений.
Кроме того, если вас касаются ошибки с пометкой функций, описанные во второй и третьей записи
ниже, потребуются дополнительные действия для исправления каталогов баз данных.
Если вы обновляете сервер с более ранней версии, чем 9.6.8, см. также Раздел E.13.
E.12.2. Изменения
• Лишение роли public права на выполнение функции pg_logfile_rotate() из contrib/
adminpack (Стивен Фрост)
Функция pg_logfile_rotate() является устаревшей оболочкой функции ядра
pg_rotate_logfile(). Когда в последней была удалена жёсткая проверка суперпользователя,
чтобы доступ к этой функции ограничивался правами SQL, эти изменения следовало отразить
и в pg_logfile_rotate(), но это было упущено. Таким образом, с установленным расширени-
ем adminpack любой пользователь мог запросить прокрутку файла журнала, что можно счи-
тать некритичным нарушением безопасности.
После установки этого обновления администраторы должны обновить adminpack, выпол-
нив ALTER EXTENSION adminpack UPDATE в каждой базе данных, где установлен adminpack.
(CVE-2018-1115)
• Исправление некорректных пометок изменчивости для нескольких встроенных функций (То-
мас Мунро, Том Лейн)
Функции query_to_xml, cursor_to_xml, cursor_to_xmlschema, query_to_xmlschema и
query_to_xml_and_xmlschema должны были считаться изменчивыми, так как они выполняют
пользовательские запросы, в которых могут быть изменчивые операции. Однако они не бы-
ли помечены должным образом, что было чревато неправильной оптимизацией запросов. Это
было исправлено для новых инсталляций в результате корректировки исходных данных ката-
лога, но в существующих инсталляциях ошибочные пометки сохранятся. При практическом
использовании этих функций риск кажется небольшим, но в случае необходимости их мож-
но исправить, вручную изменив записи этих функций в pg_proc. Например: ALTER FUNCTION
pg_catalog.query_to_xml(text, boolean, boolean, text) VOLATILE. (Заметьте, что это нуж-
но будет проделать в каждой базе данных инсталляции.) Также вы можете обновить базу до
версии с корректными исходными данными, воспользовавшись pg_upgrade.
• Исправление некорректных пометок параллельно-безопасности для нескольких встроенных
функций (Thomas Munro, Tom Lane)
Функции brin_summarize_new_values, gin_clean_pending_list, cursor_to_xml,
cursor_to_xmlschema, ts_rewrite, ts_stat и binary_upgrade_create_empty_extension долж-
ны были считаться параллельно-небезопасными, так как одни из них непосредственно моди-
фицируют базу данных, а другие выполняют пользовательские запросы, которые могут это де-
лать. Они были некорректно помечены как параллельно-безопасные, что могло приводить к
неожиданным ошибкам запросов. Это было исправлено для новых инсталляций в результате
корректировки исходных данных каталога, но в существующих инсталляциях ошибочные по-
метки сохранятся. При практическом использовании этих функций риск кажется небольшим,
если только не включён режим force_parallel_mode, но в случае необходимости их мож-
но исправить, вручную изменив записи этих функций в pg_proc. Например: ALTER FUNCTION
pg_catalog.brin_summarize_new_values(regclass) PARALLEL UNSAFE. (Заметьте, что это нуж-
но будет проделать в каждой базе данных инсталляции.) Также вы можете обновить базу до
версии с корректными исходными данными, воспользовавшись pg_upgrade.
• Предотвращение повторного использования для TOAST идентификаторов OID, соответствую-
щих уже неактуальным, но ещё не очищенным записям TOAST (Паван Деоласи)
После зацикливания счётчика OID имеется возможность использования для значения TOAST
идентификатора OID, соответствующего ранее удалённой записи в той же таблице TOAST.
2355Замечания к выпуску
Если запись не была очищена к тому времени, это приводило к ошибкам «unexpected chunk
number 0 (expected 1) for toast value nnnnn» (неожиданный номер порции 0 (ожидался 1) для
значения TOAST nnnnn), которые сохранялись до удаления неактуальной записи командой
VACUUM. В качестве решения выбор таких OID при создании новых записей TOAST теперь ис-
ключается.
• Изменение алгоритма ANALYZE в части модификации pg_class.reltuples (Дэвид Гулд)
Ранее плотность кортежей могла обновляться только для страниц, прошедших обработку
ANALYZE, для остальных плотность считалась прежней. В большой таблице, где ANALYZE выби-
рает лишь небольшой процент страниц, это означает, что возможно лишь незначительное из-
менение общей оценки плотности кортежей, и поэтому reltuples будет меняться практиче-
ски пропорционально изменениям физического размера таблицы (relpages) вне зависимо-
сти от того, что фактически происходит в таблице. В результате может наблюдаться настоль-
ко большое увеличение reltuples по сравнению с реальностью, что автоматическая очистка
практически отключается. Для исправления этой ошибки принимается, что выборка ANALYZE
является статистически несмещённой (какой она и должна быть), и наблюдаемая в ней плот-
ность просто экстраполируется на всю таблицу.
• Предупреждение взаимоблокировок в параллельных командах CREATE INDEX CONCURRENTLY,
выполняемых на уровнях изоляции SERIALIZABLE и REPEATABLE READ (Том Лейн)
• Устранение возможности замедленного выполнения REFRESH MATERIALIZED VIEW
CONCURRENTLY (Томас Мунро)
• Устранение ошибки в UPDATE/DELETE … WHERE CURRENT OF в случае, когда задействованный
курсор использует план сканирования только индекса (Юго Нагата, Том Лейн)
• Исправление некорректного планирования, когда предложения соединения передавались в
параметризованные пути (Эндрю Гирт, Том Лейн)
Эта ошибка могла привести к неправильной классификации условия как «фильтра соедине-
ния» для внешнего соединения, тогда как оно должно быть простым «фильтром», и в итоге
мог получиться некорректный результат соединения.
• Устранение возможности некорректного построения плана сканирования только индекса в
случаях, когда один столбец таблицы фигурирует в нескольких индексах, но не во всех этих
индексах используются классы операторов, которые могут выдать значение столбца (Кётаро
Хоригути)
• Исправление некорректной оптимизации ограничений CHECK с гарантированными NULL-под-
выражениями в условиях верхнего уровня AND/OR (Том Лейн, Дин Рашид)
В результате, например, ограничение-исключение могло исключить из запроса дочернюю
таблицу, которая не должна быть исключена.
• Устранение сбоя исполнителя в результате двойного освобождения памяти с некоторыми ва-
риантами использования GROUPING SETS (Питер Геохеган)
• Предотвращение сбоя в случае, когда триггер события перезаписи таблицы добавляется од-
новременно с выполнением команды, которая может вызвать такой триггер (Альваро Эррера,
Эндрю Гирт, Том Лейн)
• Предотвращение ошибки при прерывании запроса или прекращении сеанса в момент фикси-
рования подготовленной транзакции (Стас Кельвич)
• Ликвидация утечки памяти на время выполнения запроса в последовательно выполняемых со-
единениях по хешу (Том Лейн)
• Устранение возможных утечек или двойного освобождения закреплений буферов карты види-
мости (Амит Капила)
• Устранение неоправданной пометки страниц как полностью видимых (Дэн Вуд, Паван Деола-
си, Альваро Эррера)
2356Замечания к выпуску
Это могло происходить при блокировании (но не удалении) некоторых кортежей. Хотя за-
просы будут продолжать выполняться корректно, процедура очистки обычно игнорирует та-
кие страницы, вследствие чего кортежи на них никогда не будут замораживаться. В послед-
них выпусках это в конце концов приведёт к появлению ошибок вида «found multixact nnnnn
from before relminmxid nnnnn» (найдена мультитранзакция nnnnn, предшествующая relminmxid
nnnnn).
• Исправление излишне строгой проверки в heap_prepare_freeze_tuple (Альваро Эррера)
Это могло приводить к необоснованной ошибке «cannot freeze committed xmax» (не удаётся за-
морозить зафиксированный xmax) в базах данных, обновлённых с помощью pg_upgrade с вер-
сии 9.2 или старее.
• Устранение потери указателя в случаях, когда написанный на С триггер, выполняемый до из-
менения строки, возвращает старый кортеж («old») (Рушаб Латиа)
• Понижение уровня блокировки при планировании работы автоочистки (Джефф Джейнс)
Предыдущее поведение создавало значительные препятствия для параллельного выполнения
рабочих процессов в базах, содержащих множество таблиц.
• Обеспечение копирования имени клиентского компьютера при копировании данных
pg_stat_activity в локальную память (Эдмунд Хорнер)
Ранее предположительно локальный экземпляр содержал указатель на разделяемую память,
вследствие чего содержимое поля с именем клиентского компьютера могло неожиданно из-
мениться при отключении какого-либо сеанса.
• Исправление некорректной обработки нескольких составных аффиксов в словарях ispell (Ар-
тур Закиров)
• Исправление поиска (то есть сканирования индекса с операторами неравенства), зависимого
от правила сортировки, в индексах SP-GiST, построенных по текстовым столбцам (Том Лейн)
Такой поиск мог возвращать неправильный набор строк для большинства правил сортировки,
отличных от C.
• Предотвращение утечки памяти на время выполнения запроса в классах операторов SP-GiST,
использующих переходящие значения (Антон Дигнос)
• Корректировка вычисления количества кортежей в индексе при изначальном построении ин-
декса SP-GiST (Томаш Вондра)
Ранее количество кортежей в индексе считалось равным количеству кортежей в нижележа-
щей таблице, что неверно в случае частичного индекса.
• Корректировка вычисления количества кортежей в индексе при очистке индекса GiST (Ан-
дрей Бородин)
Ранее оно считалось равным примерному количеству кортежей в куче, что провоцировало
неточность и определённо было ошибочным в случае частичного индекса.
• Исправление поведения в особом случае, когда ведомый реплицирующий сервер «застревал»
на записи продолжения WAL (Кётаро Хоригути)
• При логическом декодировании приняты меры во избежание двойной обработки данных WAL
при перезапуске передатчика WAL (Крейг Рингер)
• Поддержка использования scalarltsel и scalargtsel с расширенными типами данных (То-
маш Вондра)
• Уменьшение потребления памяти libpq в случаях, когда сервер выдаёт ошибку после получе-
ния большого объёма результата запроса (Том Лейн)
2357Замечания к выпуску
Полученный ранее результат должен быть отброшен до, а не после обработки ошибки. На
некоторых платформах, в частности в Linux это может влиять на то, сколько памяти будет за-
нимать приложение.
• Устранение сбоев в ecpg, вызванных двойным освобождением памяти (Патрик Крекер, Джи-
ван Ладхе)
• Исправление обработки переменных long long int в ecpg, собранном с использованием
MSVC (Михаэль Мескес, Эндрю Гирт)
• Исправление некорректного заключения в кавычки значений для переменных GUC со списка-
ми при формировании дампа (Микаэль Пакье, Том Лейн)
Переменные local_preload_libraries, session_preload_libraries,
shared_preload_libraries и temp_tablespaces не заключались в кавычки корректно в выводе
pg_dump. Это могло приводить к проблемам, если эти переменным присваивались значения в
конструкциях CREATE FUNCTION … SET или ALTER DATABASE/ROLE … SET.
• Предотвращение отказа pg_recvlogical при подключении к серверам PostgreSQL до 10 версии
(Микаэль Пакье)
В результате предыдущего исправления программа pg_recvlogical, не проверяя версию серве-
ра, выдавала команду, которая должна предназначаться только серверам версии 10 и новее.
• Исправление поведения pg_rewind, чтобы на целевом сервере удалялись файлы, которые мог-
ли быть удалены в процессе выполнения на исходном сервере (Такаюки Цунакава)
В противном случае на целевом сервере могла нарушаться согласованность данных, особенно
если это был файл сегмента WAL.
• Исправление в pg_rewind обработки таблиц в дополнительных табличных пространствах (Та-
каюки Цунакава)
• Исправление обработки целочисленного переполнения в циклах FOR на языке PL/pgSQL (Том
Лейн)
Исправление обработки целочисленного переполнения в циклах FOR на языке PL/pgSQL (Том
Лейн)
• Исправление регрессионных тестов PL/Python для совместимости с Python 3.7 (Питер Эйзен-
траут)
• Исправление регрессионных тестов PL/Python для совместимости с Python 3.7 (Питер Эйзен-
траут)
• Устранение ошибок при изначальном построении индексов contrib/bloom (Томаш Вондра,
Том Лейн)
Предотвращение возможного исчезновения последнего кортежа таблицы из индекса. Исправ-
ление подсчёта количества кортежей в частичных индексах.
• Переименование функций b64_encode и b64_decode во избежание конфликта со встроенными
функциями Solaris 11.4 (Райнер Орт)
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией 2018e (Том
Лейн)
В этой версии усовершенствован компилятор данных часовых поясов zic для работы с отрица-
тельными смещениями при переходе на летнее время. Хотя проект PostgreSQL в настоящее
время не поставляет такие данные часовых поясов, zic может применяться с данными, полу-
ченными непосредственно от IANA, поэтому кажется разумным обновить zic сейчас.
• Обновление данных часовых поясов до версии tzdata 2018d, включающее изменения правил
перехода на летнее время в Палестине и Антарктиде (станция Кейси), плюс корректировку
2358Замечания к выпуску
исторических данных для Португалии и её колоний, а также Уругвая и островов Эндербери,
Ямайка, Теркс и Кайкос.
E.13. Выпуск 9.6.8
Дата выпуска:
2018-03-01
В этот выпуск вошли различные исправления, внесённые после версии 9.6.7. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.13.1. Миграция на версию 9.6.8
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если в вашей СУБД не все пользователи взаимно доверяют друг другу либо если вы под-
держиваете приложение или расширение, предназначенное для использования в произвольных
ситуациях, настоятельно рекомендуется прочитать об изменениях в первой записи ниже и пред-
принять соответствующие действия для защиты вашей инсталляции или кода.
Также изменения, описанные во втором пункте списка ниже, могут приводить к сбоям функций,
используемых в индексных выражениях или материализованных представлениях, во время авто-
матического анализа или при восстановлении выгруженных данных. Поэтому после обновления
проверьте журнал сервера на предмет подобных проблем и исправьте затронутые функции.
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.7, см. Раздел E.14.
E.13.2. Изменения
• Добавление в документацию информации о настройке серверов и приложений для защиты от
атак с внедрением троянского кода через путь поиска (Ной Миш)
Когда используется значение search_path, включающее схемы, доступные для записи зло-
намеренному пользователю, он может перехватывать управление над выполнением запросов
и затем запускать произвольный SQL-код с правами атакуемого пользователя. Хотя есть воз-
можность составлять запросы, защищённые от подобного перехвата, это требует кропотли-
вой работы, и при этом очень легко что-то упустить. Поэтому мы рекомендуем использовать
конфигурации, в которых пути поиска не могут включать недоверенные схемы. Соответству-
ющая информация добавлена в Подраздел 5.8.6 (для пользователей и администраторов баз
данных), Раздел 34.1 (для разработчиков приложений), Подраздел 38.16.1 (для разработчиков
расширений) и CREATE FUNCTION (для разработчиков функций с характеристикой SECURITY
DEFINER). (CVE-2018-1058)
• Предотвращение использования небезопасных значений search_path в pg_dump и других кли-
ентских программах (Ной Миш, Том Лейн)
pg_dump, pg_upgrade, vacuumdb и другие приложения, предоставляемые PostgreSQL, были
уязвимы для перехвата выполнения, описанного в предыдущем пункте; так как эти прило-
жения обычно запускаются суперпользователями, они представляли собой привлекательные
средства для атаки. Чтобы защитить их вне зависимости от того, защищена ли вся инсталля-
ция в целом, они были изменены так, чтобы для них параметр search_path содержал только
pg_catalog. Теперь это так же касается и рабочих процессов автоочистки.
В случаях, когда этими программами неявно вызываются определённые пользователем функ-
ции — например, это могут быть пользовательские функции в выражениях индексов — бо-
лее строгое значение search_path может приводить к ошибкам, которые потребуется испра-
вить так, чтобы эти функции никак не зависели от пути поиска, с которым они выполняются.
Это всегда рекомендовалось делать, но сейчас это необходимо для корректного поведения.
(CVE-2018-1058)
• Исправление некорректного поведения перепроверок одновременных изменений со ссылками
CTE, фигурирующими во внутренних планах (Том Лейн)
2359Замечания к выпуску
Если ссылка на CTE (содержимое предложения WITH) использовалась в InitPlan или SubPlan, и
запросу требовалось провести перепроверку из-за попытки изменения или блокировки одно-
временно изменяемой строки, могли быть получены неверные результаты.
• Устранение сбоев планировщика при перекрывающихся предложениях соединения слиянием
во внешнем соединении (Том Лейн)
Эти дефекты приводили в особых случаях к ошибкам планировщика «left and right pathkeys
do not match in mergejoin» (нарушено соответствие левых и правых ключей пути в соединении
слиянием) или «outer pathkeys do not match mergeclauses» (внешние ключи пути не соответ-
ствуют предложениям слияния).
• Исправление ошибки в pg_upgrade, когда не удавалось сохранить relfrozenxid для материа-
лизованных представлений (Том Лейн, Андрес Фройнд)
Данное упущение могло приводить к разрушению данных в материализованных пред-
ставлениях после обновления. Это могло проявляться в ошибках «could not access status
of transaction» (не удалось получить состояние транзакции) или «found xmin from before
relfrozenxid» (найден xmin перед relfrozenxid). Эта проблема была более вероятна в редко об-
новляемых материализованных представлениях или в представлениях, обновляемых только
командой REFRESH MATERIALIZED VIEW CONCURRENTLY.
Если такое разрушение имело место, его можно исправить, обновив материализованное пред-
ставление (без указания CONCURRENTLY).
• Исправление некорректной обработки имён функций PL/Python в стеках ошибки CONTEXT (Том
Лейн)
Ошибка, произошедшая во вложенном вызове функции PL/Python (то есть функции, вызван-
ной через SPI-запрос из другой функции PL/Python), могла привести к тому, что в трассировке
стека вместо ожидаемого результата имя внутренней функции фигурировало дважды. Также
ошибка во вложенном блоке PL/Python DO могла привести к обращению по нулевому указате-
лю на некоторых платформах.
• Максимальное значение log_min_duration для contrib/auto_explain доведено до INT_MAX,
что составляет около 24 суток вместо 35 минут (Том Лейн)
• Для разнообразных переменных GUC добавлена пометка PGDLLIMPORT в целях облегчения пе-
реноса модулей расширений в Windows (Метин Дослу)
E.14. Выпуск 9.6.7
Дата выпуска:
2018-02-08
В этот выпуск вошли различные исправления, внесённые после версии 9.6.6. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.14.1. Миграция на версию 9.6.7
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если вы используете оператор ~&gt; расширения contrib/cube, прочитайте ниже запись о
нём.
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.6, см. Раздел E.15.
E.14.2. Изменения
• Временные файлы, создаваемые программой pg_upgrade, должны быть недоступны для чте-
ния всеми пользователями (Том Лейн, Ной Миш)
Программа pg_upgrade обычно ограничивает доступ к своим временным файлам, чтобы их
мог читать и записывать только запускающий её пользователь. Но временные файлы, содер-
2360Замечания к выпуску
жащие вывод pg_dumpall -g могли быть доступны для чтения группе или всем пользовате-
лям, а возможно и для записи, если это допускало значение umask этого пользователя. При
типичном использовании в многопользовательских системах umask и/или разрешения в рабо-
чем каталоге достаточно жёсткие и эта проблема неактуальна; но pg_upgrade может исполь-
зоваться и в сценариях, где это упущение могло привести, например, к утечке паролей баз
данных. (CVE-2018-1053)
• Исправление очистки кортежей, которые были изменены при установленной блокировке раз-
деляемого ключа (Андрес Фройнд, Альваро Эррера)
В некоторых случаях операция VACUUM не удаляла такие кортежи, даже когда они теряли акту-
альность, что приводило к различным сценариям повреждения данных.
• Осуществление очистки очереди добавлений индекса GIN при выполнении VACUUM (Масахи-
ко Савада)
Это необходимо для гарантированного удаления неактуальных записей индекса. Прежний код
делал это в другом порядке, позволяя операции VACUUM пропускать очистку, если какие-то
другие процессы производили очистку параллельно. Однако при этом в индексе могли оста-
ваться некорректные записи.
• Исправление неправильной блокировки буфера при некоторых чтениях LSN (Якоб Чемпион,
Асим Правин, Ашвин Агравал)
Эти ошибки могли приводит к некорректному поведению при многопоточной нагрузке. По-
тенциальные последствия не были характеризованы полностью.
• Исправление некорректных результатов запросов в случаях, когда происходило упрощение
подзапросов, результаты которых использовались в GROUPING SETS (Хейкки Линнакангас)
• Исключение неоправданной ошибки в запросе с деревом наследования, который выполнял-
ся одновременно с тем, как некоторая дочерняя таблица удалялась из этого дерева командой
ALTER TABLE NO INHERIT (Том Лейн)
• Устранение разнообразных ошибок взаимоблокировки при выполнении в нескольких сеансах
команды CREATE INDEX CONCURRENTLY (Джефф Джейнс)
• Устранение ошибок в ситуациях, когда дерево наследования содержит дочерние сторонние
таблицы (Эцуро Фудзита)
Комбинация обычных и сторонних таблиц в дереве наследования провоцировала построение
некорректных планов в запросах UPDATE и DELETE. Это приводило к видимым ошибкам в неко-
торых случаях, особенно когда в дочерней сторонней таблице присутствовали триггеры уров-
ня строк.
• Исправление дефекта со связанным подзапросом SELECT внутри VALUES в подзапросе LATERAL
(Том Лейн)
• Устранение ошибки планировщика «could not devise a query plan for the given query» (не уда-
лось выработать план для данного запроса) в некоторых случаях, включая вложенные UNION
ALL в подзапросе LATERAL (Том Лейн)
• Исправление логического декодирования, чтобы файлы на диске корректно очищались от
данных сбойных транзакций (Атсуши Торикоши)
Процедура логического декодирования может выносить записи WAL на диск, если транзакции
генерируют много записей WAL. Обычно эти файлы очищаются после фиксирования транзак-
ции или поступления записи о её прерывании; но в отсутствие таких записей код очистки ра-
ботал неправильно.
• Исправление тайм-аута в процессе walsender и реакции на прерывания при обработке боль-
шой транзакции (Петр Желинек)
• Добавление в has_sequence_privilege() поддержки проверок WITH GRANT OPTION, как это сде-
лано в других функциях проверки прав (Джо Конвей)
2361Замечания к выпуску
• В базах данных с кодировкой UTF8 любые XML-объявления, выбирающие другую кодировку,
должны игнорироваться (Павел Стехуле, Ной Миш)
Мы всегда храним документы XML в кодировке базы данных, так что позволяя libxml обраба-
тывать объявления с другой кодировкой, мы получим ошибочные результаты. Если кодировка
базы — не UTF8, мы в любом случае не обещали поддерживать XML-данные с не ASCII-коди-
ровкой, так что предыдущее поведение сохранено для совместимости ошибок. Это изменение
затрагивает только xpath() и связанные функции; другой код и ранее работал так.
• Обеспечение прямой совместимости с будущими изменениями младших версий протокола
(Роберт Хаас, Бадрул Чоудхури)
Ранее серверы PostgreSQL просто отклоняли запросы на использование версий протокола но-
вее 3.0, так что никакого функционального отличия старших номеров от младших не было. Те-
перь клиенты могут запрашивать версии 3.x и получать в ответ не отказ, а сообщение, говоря-
щее, что сервер поддерживает только версию 3.0. В данный момент от этого ничего не меня-
ется, но перенос этого изменения в предыдущие версии должен ускорить внедрение неболь-
ших усовершенствований протокола в будущем.
• Исправление реакции на сбой при запуске параллельного рабочего процесса (Амит Капила,
Роберт Хаас)
Ранее параллельный запрос мог зависнуть на неопределённое время, если не удавалось запу-
стить рабочий процесс, вследствие ошибки в fork() или других редких проблем.
• Исправление сбора статистики EXPLAIN, получаемой от параллельных исполнителей (Амит Ка-
пила, Томас Мунро)
• Устранение небезопасного предположения о выравнивании при работе с типом __int128 (Том
Лейн)
Обычно компиляторы полагают, что переменные __int128 выравниваются по 16-байтовым
границам, но наша инфраструктура выделения памяти не готова гарантировать это, а увели-
чение MAXALIGN кажется неподходящим по множеству причин. В качестве решения код был
изменён так, чтобы тип __int128 можно было использовать только когда мы можем сказать
компилятору, что предполагается не такое крупное выравнивание. Единственный замечен-
ный симптом этой проблемы — сбои в некоторых параллельных запросах с агрегированием.
• Предотвращение сбоев с переполнением стека при планировании операций со множествами с
крайне большой вложенностью (UNION/INTERSECT/EXCEPT) (Том Лейн)
• Ликвидация обращений по нулевому указателю для некоторых типов адресов LDAP, задавае-
мых в файле pg_hba.conf (Томас Мунро)
• Исправление демонстрационных функций INSTR() в документации по PL/pgSQL (Юго Нагата,
Том Лейн)
В документации утверждалось, что эти функции совместимы с Oracle®, но это было не совсем
так. В частности, по-разному интерпретировалось отрицательное значение третьего парамет-
ра: Oracle воспринимает это значение как последнюю позицию, с которой может начинаться
целевая подстрока, а наши функции считали, что это последняя позиция, где строка может
заканчиваться. Также Oracle выдаёт ошибку в случае нулевого или отрицательного четвёрто-
го параметра, тогда как наши функции возвращали ноль.
Код этого примера был изменён для большего соответствия поведению Oracle. Пользовате-
лям, которые скопировали этот код в свои приложения, возможно, имеет смысл обновить свои
копии.
• Исправление поведения pg_dump, чтобы ACL (разрешения), комментарии и метки безопасно-
сти можно было надёжно идентифицировать в архивных выходных форматах (Том Лейн)
Компонент «метка» записи ACL в архиве обычно представлял собой просто имя целевого объ-
екта. В его начало теперь добавляется тип объекта, чтобы записи ACL соответствовали согла-
2362Замечания к выпуску
шениям, уже принятым для записей комментариев и меток безопасности. Кроме того, обо-
значения комментариев и меток безопасности, заданных для собственно базы данных, теперь
должны начинаться с DATABASE, чтобы они соответствовали тому же соглашению. Это преду-
преждает ложные срабатывания в коде, который пытается найти записи больших объектов по
строкам, начинающимся со слов LARGE OBJECT. Прежнее поведение могло приводить к непра-
вильной классификации записей как данные и нежелательным результатам при восстановле-
нии выгруженной только схемы или только данных.
Заметьте, что следствием этого стало изменение видимого пользователями вывода pg_restore
–list.
• Переименование функции copy_file_range в pg_rewind во избежание конфликта с новым си-
стемным вызовом Linux с таким же именем (Андрес Фройнд)
Это изменение предотвращает ошибки при сборке с новыми версиями glibc.
• В ecpg добавлено выявление массивов индикаторов с неправильной длиной и сообщение об
ошибке (Дэвид Рейдер)
• Изменение поведения оператора cube ~&gt; int в расширении contrib/cube для обеспечения его
совместимости с поиском kNN (Александр Коротков)
Смысл второго аргумента (выбирающего размерность) был изменён, чтобы можно было опре-
делённо сказать, какое именно значение выбирается в кубах переменных размерностей.
Это изменение нарушает совместимость, но так как этот оператор предназначался для по-
исков kNN, в прежнем виде он был бесполезен. После установки этого обновления все мате-
риализованные представления или индексы с выражениями, использующими этот оператор,
необходимо обновить/перестроить.
• Предотвращение срабатывания проверки истинности внутри libc в расширении contrib/
hstore из-за использования memcpy() с равными указателями источника и получателя (Томаш
Вондра)
• Исправление некорректного отображения битовых карт NULL для кортежей в contrib/
pageinspect (Максим Милютин)
• В расширении contrib/postgres_fdw ликвидирована ошибка планировщика «outer pathkeys
do not match mergeclauses» (внешние ключи пути не соответствуют предложениям слияния)
при построении плана, включающего удалённое соединение (Роберт Хаас)
• Добавление современных примеров настройки автозапуска Postgres в macOS (Том Лейн)
Скрипты в contrib/start-scripts/osx используют инфраструктуру, которая устарела десять
лет назад, и абсолютно неработоспособны во всех версиях macOS, выпущенных в последние
два года. Добавлен новый подкаталог contrib/start-scripts/macos со скриптами, использую-
щими новую инфраструктуру launchd.
• Исправление некорректного выбора зависящих от конфигурации библиотек OpenSSL в
Windows (Эндрю Дунстан)
• Поддержка компоновки с версиями libperl, собранными компилятором MinGW (Ной Миш)
Это позволяет собирать PL/Perl с некоторыми распространёнными дистрибутивами Perl для
Windows.
• Исправление в сборке MSVC проверки, требуется ли 32-битной libperl определение -
D_USE_32BIT_TIME_T (Ной Миш)
Имеющиеся дистрибутивы Perl ожидают разного, и при этом нет никакой возможности на-
дёжно проверить это, поэтому пришлось добавить проверку фактического поведения исполь-
зуемой библиотеки во время компиляции.
• В Windows обработчик аварийного завершения должен устанавливаться на более раннем эта-
пе запуска главного процесса (Такаюки Цунакава)
2363Замечания к выпуску
Это поможет получить дамп памяти при ошибках в те моменты в начале запуска, в которые
раньше дамп не записывался.
• В Windows устранены сбои, связанные с преобразованием кодировок при выводе сообщений
на самых ранних стадиях запуска процесса postmaster (Такаюки Цунакава)
• Использование нашего ранее написанного кода циклических блокировок для Motorola 68K во
OpenBSD, а также в NetBSD (Давид Карлье)
• Добавление поддержки циклических блокировок для Motorola 88K (Давид Карлье)
• Обновление данных часовых поясов до версии tzdata 2018c, включающее изменения правил
перехода на летнее время в Бразилии, в Сан-Томе и Принсипи, а также корректировки ис-
торических данных для Боливии, Японии и Южного Судана. Был удалён часовой пояс US/
Pacific-New (это был просто псевдоним для пояса America/Los_Angeles).
E.15. Выпуск 9.6.6
Дата выпуска:
2017-11-09
В этот выпуск вошли различные исправления, внесённые после версии 9.6.5. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.15.1. Миграция на версию 9.6.6
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если вы используете индексы BRIN, прочитайте четвёртую запись в списке изменений.
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.4, см. Раздел E.17.
E.15.2. Изменения
• Обеспечение проверки разрешений на уровне таблиц и политик RLS при выполнении
INSERT … ON CONFLICT DO UPDATE во всех случаях (Дин Рашид)
Путь изменения данных в команде INSERT … ON CONFLICT DO UPDATE требовал наличия раз-
решения SELECT для всех столбцов в решающем индексе, но в случае указания решающего
ограничения по имени должная проверка отсутствовала. Кроме того, для таблиц с включён-
ной защитой на уровне строк не проверялось, соответствуют ли изменённые строки полити-
кам SELECT (вне зависимости от способа задания решающего индекса). (CVE-2017-15099)
• Устранение сбоя при несовпадении типа записи в json{b}_populate_recordset() (Микаэль
Пакье, Том Лейн)
Эти функции использовали тип результата, заданный в предложении FROM … AS, не прове-
ряя, соответствует ли он фактическому типу поступившего кортежа. В случае несоответствия
обычно происходил сбой, хотя также вероятным было раскрытие содержимого памяти серве-
ра. (CVE-2017-15098)
• Исправление скриптов запуска сервера — переключение на $PGUSER до открытия файла
$PGLOG (Ной Миш)
Ранее файл журнала postmaster открывался ещё под именем root. Таким образом, владелец
базы данных мог произвести атаку на другого пользователя системы, сделав $PGLOG символи-
ческой ссылкой на некоторый другой файл, который в результате можно было испортить до-
бавленными в него сообщениями журнала.
По умолчанию эти скрипты никуда не устанавливаются. Если вы использовали их, замените
свои экземпляры новыми копиями либо внесите те же коррективы в свои вручную изменён-
ные скрипты. Если владельцем существующего файла $PGLOG является root, его нужно уда-
лить или переименовать прежде чем перезапускать сервер с помощью исправленного скрип-
та. (CVE-2017-12172)
2364Замечания к выпуску
• Исправление вычисления сводных данных индекса BRIN для корректной работы при одновре-
менном расширении таблицы (Альваро Эррера)
Ранее в условиях гонки некоторые строки таблицы могли пропадать из индекса. Для устране-
ния последствий предыдущих проявлений этой проблемы может потребоваться перестроить
существующие индексы BRIN.
• Предупреждение возможных сбоев при параллельных изменениях индекса BRIN (Том Лейн)
В определённых условиях гонки могли возникать ошибки «invalid index offnum» (неверный но-
мер смещения в индексе) или «inconsistent range map» (несогласованность в карте диапазо-
нов).
• Устранение сбоя при вызове логического декодирования из функции, использующей SPI, в
частности, из любой функции на одном из языков PL (Том Лейн)
• Исправление некорректных результатов запросов, содержащих в нескольких столбцах
GROUPING SETS одну и ту же простую переменную (Том Лейн)
• Корректировка неправильных решений по распараллеливанию для вложенных запросов (Амит
Капила, Кунтал Гхош)
• Устранение сбоев в обработке параллельных запросов, возможных при удалении недавно ис-
пользованной роли (Амит Капила)
• Исправление в функциях json_build_array(), json_build_object() и их аналогах для jsonb
обработки явно заданных аргументов VARIADIC (Микаэль Пакье)
• Корректное недопущение попыток приведения бесконечных значений с плавающей точкой к
типу numeric (Том Лейн, КайГай Кохэй)
Ранее поведение зависело от платформы.
• Устранение сбоев в особых случаях при добавлении столбцов в конец представления (Том
Лейн)
• Фиксирование правильных зависимостей когда представление или правило содержит узлы вы-
ражения FieldSelect или FieldStore (Том Лейн)
В отсутствие этих зависимостей команда DROP со столбцом или типом данных может выпол-
ниться, когда не должна, что вызовет ошибки при последующем использовании представле-
ния или правила. Данное исправление не защищает существующие представления/правила, а
повлияет только на создаваемые в будущем.
• Правильное определение хешируемости диапазонных типов данных (Том Лейн)
Планировщик ошибочно полагал, что любой диапазонный тип может хешироваться для ис-
пользования в соединениях или агрегировании по хешу, но на самом деле он должен прове-
рять, поддерживает ли хеширование подтип диапазона. Это не касается встроенных диапазон-
ных типов, так как все они всё равно хешируемые.
• Игнорирование узлов выражений RelabelType при определении уникальности содержимого
отношения (Дэвид Роули)
Это позволяет применить оптимизацию, когда результирующий столбец имеет тип varchar.
• Предотвращение разделения информации переходного состояния между сортирующими агре-
гатными функциями (Дэвид Роули)
Вследствие этого разделения возникали сбои во встроенных сортирующих агрегатах и могли
также возникать в подобных пользовательских функциях. Начиная с версии 11, предусмотре-
ны средства для надёжной защиты от таких случаев, а в ветвях стабильных выпусков просто
отключена оптимизация.
• Недопущение игнорирования значения idle_in_transaction_session_timeout, если до этого
произошёл таймаут оператора (statement_timeout) (Лукас Фиттл)
2365Замечания к выпуску
• Устранение маловероятной потери сообщений NOTIFY вследствие зацикливания идентифика-
торов транзакций (Марко Тииккая, Том Лейн)
Если в сеансе не выполнялись никакие запросы, то есть он просто ждал уведомлений и за это
время прошло более 2 миллиардов транзакций, он начинал пропускать уведомления от парал-
лельно фиксируемых транзакций.
• Предупреждение сбоя SIGBUS в Linux, когда в памяти DSM запрашивается область объёма,
превышающего свободный объём в tmpfs (Томас Мунро)
• Уменьшение частоты запросов на сброс данных в процессе копирования файлов во избежание
проблем с производительностью в macOS, в частности с новой файловой системой APFS (Том
Лейн)
• Предотвращение маловероятного сбоя при рекурсивном срабатывании триггеров (Том Лейн)
• Реализована возможность использовать режим FREEZE команды COPY на уровне изоляции
транзакций REPEATABLE READ или выше (Ной Миш)
Этот сценарий использования был непреднамеренно потерян вследствие предыдущего ис-
правления ошибки.
• Корректное восстановление значения umask при ошибке создания файла в COPY или
lo_export() (Питер Эйзентраут)
• Улучшение сообщения об ошибке в случае дублирующихся имён столбцов в ANALYZE (Натан
Боссарт)
• Добавление пропущенных случаев в GetCommandLogLevel() для устранения ошибок при ис-
пользовании определённых SQL-команд, когда log_statement имеет значение ddl (Микаэль
Пакье)
• Исправление разбора последней строки в файле pg_hba.conf, завершающемся не символом
перевода строки (Том Лейн)
• Исправление функции AggGetAggref(), чтобы возвращались корректные узлы Aggref для
функций завершения агрегатов с объединёнными промежуточными вычислениями (Том Лейн)
• Исправление pg_dump, чтобы команды GRANT выдавались в корректном порядке (Стивен
Фрост)
• Исправление в pg_basebackup сравнения путей табличных пространств посредством приведе-
ния путей к канонической форме (Микаэль Пакье)
Это особенно полезно в Windows.
• Исправление libpq, чтобы для её работы не требовалось существование домашнего каталога
пользователя (Том Лейн)
В версии 10 невозможность найти домашний каталог при попытке прочитать ~/.pgpass счита-
лась критической ошибкой, но эта ситуация должна обрабатываться так же, как и отсутствие
данного файла. И в версии 10, и в ветвях предыдущих выпусков была допущена та же ошибка
при чтении ~/.pg_service.conf, хотя это было менее очевидно, так как данный файл исполь-
зовался только при указании имени службы.
• Исправление в libpq защиты от целочисленного переполнения в счётчике строк в PGresult
(Микаэль Пакье)
• Исправление в ecpg обработки объявлений курсора вне текущей области с переменными типа
указатель или массив (Михаэль Мескес)
• В ecpglib исправлена обработка обратной косой черты в строковых константах в зависимости
от значения standard_conforming_strings (Такаюки Цунакава)
• Игнорирование в ecpglib дробной части при вводе целочисленных значений в режиме совме-
стимости с Informix (Гао Цзэнци, Михаэль Мескес)
2366Замечания к выпуску
• Исправление регрессионных тестов ecpg для более стабильного выполнения в Windows (Кри-
стиан Ульрих, Михаэль Мескес)
• Добавление отсутствующего предварительного требования temp-install для целей типа check в
Make (Ной Миш)
Некоторые невыполняемые по умолчанию тестовые процедуры, подобные make check, не про-
веряли актуальность временной инсталляции.
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией tzcode2017c
(Том Лейн)
Тем самым исправлены различные дефекты; единственное, что могут заметить пользователи
— правила перевода на летнее время для часового пояса с именем в стиле POSIX в отсутствие
файла posixrules в каталоге данных часового пояса теперь соответствуют текущему закону
США, а не действовавшему десять лет назад.
• Обновление данных часовых поясов до версии tzdata 2017c, включающее изменения правил
перехода на летнее время на Фиджи, в Намибии, Серверном Кипре, Судане, Тонга и на ост-
ровах Теркс и Кайкос, плюс корректировку исторических данных для Аляски, Апии, Бирмы,
Калькутты, Детройта, Ирландии, Намибии и Паго-Паго.
E.16. Выпуск 9.6.5
Дата выпуска:
2017-08-31
В этот выпуск вошло несколько исправлений, внесённых после версии 9.6.4. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.16.1. Миграция на версию 9.6.5
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.4, см. Раздел E.17.
E.16.2. Изменения
• Отображение сторонних таблиц в представлении information_schema.table_privileges (Пи-
тер Эйзентраут)
Раньше сторонние таблицы отображались в остальных связанных представлениях
information_schema, но отсутствовали в этом.
Так как определение этого представления устанавливается программой initdb, для решения
проблемы будет недостаточно обычного обновления. Если вы хотите исправить существую-
щую инсталляцию, вы можете от имени суперпользователя выполнить в psql:
SET search_path TO information_schema;
CREATE OR REPLACE VIEW table_privileges AS
SELECT CAST(u_grantor.rolname AS sql_identifier) AS grantor,
CAST(grantee.rolname AS sql_identifier) AS grantee,
CAST(current_database() AS sql_identifier) AS table_catalog,
CAST(nc.nspname AS sql_identifier) AS table_schema,
CAST(c.relname AS sql_identifier) AS table_name,
CAST(c.prtype AS character_data) AS privilege_type,
CAST(
CASE WHEN
– object owner always has grant options
pg_has_role(grantee.oid, c.relowner, ‘USAGE’)
OR c.grantable
THEN ‘YES’ ELSE ‘NO’ END AS yes_or_no) AS is_grantable,
2367Замечания к выпуску
CAST(CASE WHEN c.prtype = ‘SELECT’ THEN ‘YES’ ELSE ‘NO’ END AS yes_or_no)
AS with_hierarchy
FROM (
SELECT oid, relname, relnamespace, relkind, relowner,
(aclexplode(coalesce(relacl, acldefault(‘r’, relowner)))).* FROM pg_class
) AS c (oid, relname, relnamespace, relkind, relowner, grantor, grantee,
prtype, grantable),
pg_namespace nc,
pg_authid u_grantor,
(
SELECT oid, rolname FROM pg_authid
UNION ALL
SELECT 0::oid, ‘PUBLIC’
) AS grantee (oid, rolname)
WHERE c.relnamespace = nc.oid
AND c.relkind IN (‘r’, ‘v’, ‘f’)
AND c.grantee = grantee.oid
AND c.grantor = u_grantor.oid
AND c.prtype IN (‘INSERT’, ‘SELECT’, ‘UPDATE’, ‘DELETE’, ‘TRUNCATE’,
‘REFERENCES’, ‘TRIGGER’)
AND (pg_has_role(u_grantor.oid, ‘USAGE’)
OR pg_has_role(grantee.oid, ‘USAGE’)
OR grantee.rolname = ‘PUBLIC’);
Это потребуется повторить для каждой базы данных, требующей исправления (включая
template0).
• Исправление обработки аварийного выхода (например, при получении SIGTERM) при попытке
выполнить ROLLBACK для прерванной транзакции (Том Лейн)
В таких ситуациях мог происходить сбой проверочного утверждения. В выпускаемых сборках
выход всё равно производился, но в журнал выводилось неуместное сообщение «cannot drop
active portal» (удалить активный портал нельзя).
• Удаление проверочного утверждения, которое могло нарушаться при аварийном выходе (Том
Лейн)
• Правильное обнаружение столбцов, имеющих тип диапазона или домена, который определён
поверх искомого составного или доменного типа (Том Лейн)
Определённые команды ALTER, меняющие определение составного или доменного типа, долж-
ны проверять, нет ли в базе данных значений этого типа, и прерываться, если они есть, так
как для изменения или обновления таких значений нет необходимой инфраструктуры. Ранее
эти проверки могли пропустить значения, обёрнутые в типы диапазонов или вложенные доме-
ны, что могло нарушить целостность в базе данных.
• Предотвращение сбоя при передаче по ссылке типов данных фиксированной длины парал-
лельным рабочим процессам (Том Лейн)
• Устранение сбоя в pg_restore при работе в параллельном режиме и использовании фай-
ла-списка объектов, подлежащих восстановлению (Фабрицио де Ройес Мелло)
• Исправление лексического анализатора ecpg, чтобы он принимал предложения RETURNING без
связанных переменных C (Михаэль Мескес)
Благодаря этому программы ecpg могут содержать SQL-конструкции, использующие
RETURNING внутри (например, внутри CTE), не определяя значения, которые будут возвращены
клиенту.
• Доработка лексического анализатора ecpg, чтобы он распознавал продолжения строк команд
C-препроцессора с обратной косой чертой (Михаэль Мескес)
2368Замечания к выпуску
• Улучшение выбора флагов компилятора для PL/Perl в Windows (Том Лейн)
В результате этого исправления предотвращаются сбои PL/Perl, возможные из-за некор-
ректных предположений о ширине значений time_t. Побочным эффектом, который мо-
гут заметить разработчики расширений, стала ликвидация глобального определения
_USE_32BIT_TIME_T в сборках PostgreSQL для Windows. Это не должно приводить к проблемам,
так как тип time_t не используется ни в каких определениях API PostgreSQL.
• Исправление поведения make check при использовании альтернативной (не GNU) программы
make (Томас Мунро)
E.17. Выпуск 9.6.4
Дата выпуска:
2017-08-10
В этот выпуск вошли различные исправления, внесённые после версии 9.6.3. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.17.1. Миграция на версию 9.6.4
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если вы используете сторонние серверы данных, на которых для проверки подлинности
применяются пароли, прочитайте ниже первую запись в списке изменений.
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.3, см. Раздел E.18.
E.17.2. Изменения
• Дальнейшее ограничение видимости pg_user_mappings.umoptions для защиты паролей, сохра-
нённых в свойствах сопоставлений пользователей (Ной Миш)
Исправление дефекта CVE-2017-7486 оказалось некорректным: в результате пользова-
тель мог видеть свойства своего собственного сопоставления, даже когда он не имел пра-
ва USAGE для соответствующего стороннего сервера. В таких свойствах мог содержаться па-
роль, который должен задавать владелец сервера, а не сам пользователь. Так как представ-
ление information_schema.user_mapping_options не показывает свойства в таких случаях, и
pg_user_mappings не должно. (CVE-2017-7547)
Само по себе это исправление корректирует поведение только в новых базах данных, созда-
ваемых initdb. Если вы хотите применить это исправление к существующей базе данных, вам
нужно будет проделать следующие действия:</p>
<ol>
  <li>Добавьте allow_system_table_mods = true в postgresql.conf и перезапустите сервер. (В
версиях, поддерживающих ALTER SYSTEM, вы можете воспользоваться этой командой для
изменения конфигурации, но перезапустить сервер потребуется всё равно.)</li>
  <li>В каждой базе данных кластера выполните от имени суперпользователя следующие ко-
манды:
SET search_path = pg_catalog;
CREATE OR REPLACE VIEW pg_user_mappings AS
SELECT
U.oid
AS umid,
S.oid
AS srvid,
S.srvname
AS srvname,
U.umuser
AS umuser,
CASE WHEN U.umuser = 0 THEN
‘public’
ELSE
A.rolname
END AS usename,
2369Замечания к выпуску
CASE WHEN (U.umuser &lt;&gt; 0 AND A.rolname = current_user
AND (pg_has_role(S.srvowner, ‘USAGE’)
OR has_server_privilege(S.oid, ‘USAGE’)))
OR (U.umuser = 0 AND pg_has_role(S.srvowner, ‘USAGE’))
OR (SELECT rolsuper FROM pg_authid WHERE rolname =
current_user)
THEN U.umoptions
ELSE NULL END AS umoptions
FROM pg_user_mapping U
LEFT JOIN pg_authid A ON (A.oid = U.umuser) JOIN
pg_foreign_server S ON (U.umserver = S.oid);
3.
Не забудьте внести коррективы в базах данных template0 и template1, в противном случае
уязвимость сохранится в базах, которые будут создаваться впоследствии. Чтобы поправить
template0, вам потребуется временно разрешить подключения к ней. В PostgreSQL 9.5 и
новее вы можете выполнить
ALTER DATABASE template0 WITH ALLOW_CONNECTIONS true;
, а внеся поправку в template0, восстановить прежнее состояние командой
ALTER DATABASE template0 WITH ALLOW_CONNECTIONS false;
В более ранних версиях вместо этого используйте пару команд
UPDATE pg_database SET datallowconn = true WHERE datname = ‘template0’;
UPDATE pg_database SET datallowconn = false WHERE datname = ‘template0’;
4.
В заключение удалите параметр конфигурации allow_system_table_mods и ещё раз пере-
запустите postmaster.
• Запрет пустых паролей для всех методов аутентификации по паролю (Хейкки Линнакангас)
Библиотека libpq игнорирует пустое указание пароля и не передаёт его на сервер. Поэтому,
если пароль пользователя пустой, psql и другие клиенты на базе libpq не позволяют подклю-
читься с таким паролем. Как следствие, администратор может решить, что установка пустого
пароля равнозначна запрету входа по паролю. Однако с изменённым клиентом или клиентом
не на базе libpq подключение оказывается возможным, в зависимости от настроенного метода
аутентификации. В частности, самый распространённый метод, md5, принимает пустые паро-
ли. В результате этого изменения сервер не будет принимать пустые пароли во всех случаях.
(CVE-2017-7546)
• Добавление в lo_put() проверки права UPDATE для целевых больших объектов (Том Лейн, Ми-
каэль Пакье)
Функция lo_put(), несомненно, должна требовать наличия тех же прав, что и lowrite(), но
такая проверка отсутствовала, что позволяло пользователю менять данные в большом объек-
те. (CVE-2017-7548)
• Исправление в документации описания процесса обновления резервных серверов с использо-
ванием pg_upgrade (Брюс Момджян)
Ранее в документации говорилось, что нужно запустить/остановить ведущий сервер после за-
пуска pg_upgrade, но до синхронизации резервных серверов. Однако эта последовательность
небезопасна.
• Исправление одновременной блокировки цепочки изменённых кортежей (Альваро Эррера)
Когда цепочка изменённых кортежей блокируется одновременно несколькими сеансами в
неконфликтующем режиме с использованием старого снимка, и все операции завершаются
успешно, существовала возможность, что некоторые из них, несмотря на это, нарушатся (и
заключат, что актуальной версии кортежа нет) из-за условий гонки. В частности, вследствие
этого проверка внешнего ключа могла не увидеть кортеж, который определённо существует,
но изменяется параллельной операцией.
2370Замечания к выпуску
• Устранение риска повреждения данных при замораживании кортежа, в котором XMAX равен
идентификатору мультитранзакции с ровно одним ещё востребованным членом (Фёдор Сига-
ев)
• Предупреждение целочисленного переполнения и краха при сортировке в памяти более чем
одного миллиарда кортежей (Сергей Копосов)
• В Windows необходимо повторять попытки создания процесса в случае ошибки при резервиро-
вании диапазона адресов разделяемой памяти в новом процессе (Том Лейн, Амит Капила)
Это должно устранить периодические сбои при запуске дочерних процессов, возможно, вы-
званные вмешательством антивирусных программ.
• Устранение маловероятной возможности повреждения разделяемой хеш-таблицы предикат-
ных блокировок в сборках для Windows (Томас Мунро, Том Лейн)
• Предотвращение вывода в журнал сообщения о штатном закрытии SSL-соединения (поведе-
ние должно быть таким же, как и при сбросе соединения) (Микаэль Пакье)
• Запрещение передачи сеансовых билетов SSL клиентам (Том Лейн)
Это исправление устраняет сбои при переподключении клиентов с реализациями SSL, в кото-
рых эти билеты используются.
• Исправление кода, устанавливающего tcp_keepalives_idle в Solaris (Том Лейн)
• Исправление дефекта в сборщике статистики, приводящего к потере запросных сообщений,
выдаваемых сразу после перезапуска главного процесса (Том Лейн)
Запросы статистики, выдаваемые в течение полсекунды после предыдущего отключения глав-
ного процесса, по сути терялись.
• Размер приёмного буфера в сборщике статистики должен быть не меньше 100 Кбайт (Том
Лейн)
Это снижает риск потери данных статистики на старых платформах, где размер приёмного бу-
фера по умолчанию меньше.
• Устранение возможности создания некорректного сегмента WAL при повышении резервного
сервера сразу после того, как он обрабатывает запись XLOG_SWITCH (Андрес Фройнд)
• Процесс walsender должен завершаться своевременно, когда клиент инициирует выключение
(Том Лейн)
• Исправление обработки сигналов SIGHUP и SIGUSR1 в процессах walsender (Петр Желинек,
Андрес Фройнд)
• Предотвращение панического состояния, которое могут вызвать процессы walsender во время
контрольной точки при выключении (Андрес Фройнд, Микаэль Пакье)
• Устранение неоправданной паузы при перезапуске процессов walreceiver, возникающей
вследствие условий гонки в главном процессе (Том Лейн)
• Устранение утечки маленьких подтранзакций, оказывающихся на диске при логическом деко-
дировании (Андрес Фройнд)
В результате образовывались временные файлы, занимающие лишнее место на диске.
• Оптимизация операций, необходимых для получения снимков при создании слотов логическо-
го декодирования (Андрес Фройнд, Петр Желинек)
Предыдущий алгоритм оказывался очень неэффективным на сервере со множеством откры-
тых транзакций.
• Устранение условий гонки, при которых создание слотов логического декодирования могло
откладываться на неопределённое время (Андрес Фройнд, Петр Желинек)
2371Замечания к выпуску
• Уменьшение издержек при обработке событий сброса системного кеша (Том Лейн)
Это особенно полезно для логического декодирования, когда сброс кеша происходит часто.
• Ликвидация некорректной эвристики, применяемой в некоторых случаях для оценки избира-
тельности соединения при наличии ограничений внешнего ключа (Дэвид Роули)
В некоторых случаях, когда существовал внешний ключ по нескольким столбцам, но он не
точно соответствовал структуре условия соединения, планировщик использовал эвристиче-
скую оценку, которая оказывалась неподходящей. Теперь в таких случаях будет применяться
та же логика, что была до версии 9.6.
• Исправление поведения в ситуациях, когда INSERT или UPDATE присваивает более одного эле-
мента столбцу с типом домена на базе массива (Том Лейн)
• Разрешение использования оконных функций во вложенных SELECT в аргументах агрегатной
функции (Том Лейн)
• Обеспечение корректного применения предложения CHECK OPTIONS для представления, когда
нижележащая таблица является сторонней (Эцуро Фудзита)
Ранее операция изменения полностью передавалась на сторонний сервер, и если для пред-
ставления задавалось ограничение, оно не проверялось.
• Предупреждение конфликта имён с автоматически генерируемыми типами массивов при вы-
полнении ALTER … RENAME (Вик Фиринг)
Ранее автоматически сгенерированный тип массива во избежание конфликта переименовы-
вался при выполнении CREATE; данное исправление распространяет это поведение и на опера-
ции переименования.
• Устранение потери указателя в ALTER TABLE когда для ограничения, принадлежащего табли-
це, добавлен комментарий (Дэвид Роули)
При повторном применении комментария к воссозданному ограничению мог произойти сбой
со странным сообщением или даже с аварийным завершением.
• Добавление для команды ALTER USER … SET всех вариантов синтаксиса, что принимает
ALTER ROLE … SET (Питер Эйзентраут)
• Допущение для сторонней таблицы создания ограничений CHECK в изначально непроверенном
состоянии (NOT VALID) (Амит Ланготе)
CREATE TABLE просто игнорирует указания NOT VALID для ограничений CHECK, исходя из того,
что таблица должна быть пустой, и поэтому ограничение может сразу считаться проверен-
ным. Но это неверно для команды CREATE FOREIGN TABLE — нет причин полагать, что нижеле-
жащая таблица пуста, и даже если это так, не мы должны решать, что ограничение проверен-
ное. Поэтому такую «оптимизацию» для сторонних таблиц нужно исключить.
• Обновление информации о зависимости при смене типа аргумента или возврата для функции
ввода/вывода с opaque на целевой тип (Хейкки Линнакангас)
CREATE TYPE изменяет функции ввода/вывода, объявленные в давно устаревшем стиле, но ин-
формация о зависимости от этого типа не записывалась, в результате чего после команд DROP
TYPE могли оставаться дефектные определения функций.
• Допущение распараллеливания в плане запроса, когда COPY копирует данные из его результа-
та (Андрес Фройнд)
• Сокращение использования памяти при обработке командой ANALYZE столбцов tsvector
(Хейкки Линнакангас)
• Устранение ненужной потери точности и небрежного округления при умножении и делении
значений money на целые числа или числа с плавающей точкой (Том Лейн)
2372Замечания к выпуску
• Уточнение проверок пробельных символов в функциях, разбирающих идентификаторы, напри-
мер regprocedurein() (Том Лейн)
В зависимости от используемой локали эти функции могли неправильно воспринимать фраг-
менты многобайтных символов как пробелы.
• Использование уместных символов #define из Perl при сборке PL/Perl (Ашутош Шарма, Том
Лейн)
Это предупреждает проблемы переносимости, обычно проявляющиеся в виде ошибок «про-
верки совместимости» в момент загрузки библиотеки при использовании последних версий
Perl.
• Обеспечение в libpq корректного сброса состояния аутентификации GSS/SASL и SSPI после
неудачной попытки подключения (Микаэль Пакье)
Ранее этот сброс не выполнялся и при переходе с SSL-соединения на не SSL ошибка GSS/SASL
при попытке SSL-подключения мешала затем установить обычное подключение, без SSL. С
SSPI этого не происходило, но имела место утечка памяти.
• В psql устранён сбой, возникающий, когда команда COPY FROM STDIN завершалась вводом сиг-
нала EOF с клавиатуры, а затем следовала ещё одна попытка выполнить COPY FROM STDIN (То-
мас Мунро)
Это некорректное поведение наблюдалось в системах, основанных на BSD, (включая macOS),
но не в других.
• Исправление программ pg_dump и pg_restore, чтобы команды REFRESH MATERIALIZED VIEW вы-
давались в конце (Том Лейн)
Это предотвращает ошибки при выгрузке/восстановлении данных, когда материализованное
представление ссылается на таблицы, принадлежащие другому пользователю.
• Улучшение вывода в pg_dump/pg_restore сообщений об ошибках, возникающих в zlib (Влади-
мир Кунщиков, Альваро Эррера)
• Исправление поведения pg_dump с ключом –clean, чтобы событийные триггеры удалялись
должным образом (Том Лейн)
Теперь также правильно назначаются владельцы событийных триггеров; ранее после запуска
скрипта восстановления такие триггеры оказывались принадлежащими суперпользователю.
• Исправление поведения pg_dump с ключом –clean, чтобы существование схемы public не
требовалось (Стивен Фрост)
• Исправление дефекта в pg_dump, когда для пустого класса операторов выдавался некоррект-
ный SQL (Даниэль Густафссон)
• Исправление вывода pg_dump в stdout на платформе Windows (Кунтал Гхош)
Сжатые данные выгрузки в текстовом виде при выводе в stdout оказывались испорченными
из-за того, что дескриптор файла не переводился в двоичный режим.
• Исправление вывода pg_get_ruledef() для правила ON SELECT, связанного с представлением,
в котором переименовывались столбцы (Том Лейн)
В некоторых особых случаях pg_dump использует pg_get_ruledef() для выгрузки представле-
ний, так что эта ошибка могла приводить к сбоям при выгрузке/загрузке.
• Исправление выгрузки внешних соединений с пустыми ограничениями, получающихся, на-
пример, в результате NATURAL LEFT JOIN без общих столбцов (Том Лейн)
• Исправление выгрузки выражений с функциями в предложении FROM в случаях, когда эти вы-
ражения не преобразуются в нечто, напоминающее вызов функции (Том Лейн)
• Исправление вывода pg_basebackup в stdout на платформе Windows (Харибабу Комми)
2373Замечания к выпуску
Архивируемые данные при выводе в stdout оказывались испорченными из-за того, что де-
скриптор файла не переводился в двоичный режим.
• Исправление pg_rewind для корректной работы с файлами больше 2 ГБ (Кунтал Гхош, Мика-
эль Пакье)
Обычно такие файлы в каталогах данных PostgreSQL не образуются, но в некоторых случаях
они могут появиться.
• Исправление pg_upgrade, чтобы в конечной записи в WAL не оказалось wal_level = minimum
(Брюс Момджян)
Это могло препятствовать переподключению обновлённых резервных серверов.
• Исправление в pg_xlogdump вычисления длины записи WAL (Андрес Фройнд)
• В postgres_fdw соединения к удалённым серверам должны устанавливаться заново после ко-
манд ALTER SERVER и ALTER USER MAPPING (Кётаро Хоригути)
Благодаря этому изменения параметров, затрагивающие свойства соединения, вступят в силу
своевременно.
• В postgres_fdw реализована отмена команд управления удалёнными транзакциями (Роберт
Хаас, Рафия Сабих)
Это изменение позволяет быстрее прервать ожидание неотвечающего удалённого сервера в
большем количестве случаев, чем раньше.
• Увеличение MAX_SYSCACHE_CALLBACKS для выделения дополнительного места расширениям
(Том Лейн)
• При сборке разделяемых библиотек с gcc всегда должен передаваться ключ -fPIC, а не -fpic
(Том Лейн)
Это позволяет поддерживать библиотеки расширений большего размера на тех платформах,
где эти ключи не равнозначны.
• Для сборок MSVC реализована обработка ситуации, когда библиотека OpenSSL находится не в
подкаталоге VC (Эндрю Дунстан)
• Для сборок MSVC добавлен нужный путь для заголовочных файлов libxml2 (Эндрю Дунстан)
Это устраняет прежнюю необходимость перемещения файлов в стандартной инсталляции
libxml2 в Windows.
• Сборки MSVC должны распознавать библиотеку Tcl с именем tcl86.lib (Ной Миш)
• В сборках MSVC должны учитываться флаги в параметре PROVE_FLAGS, заданном в командной
строке vcregress.pl (Эндрю Дунстан)
E.18. Выпуск 9.6.3
Дата выпуска:
2017-05-11
В этот выпуск вошли различные исправления, внесённые после версии 9.6.2. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.18.1. Миграция на версию 9.6.3
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если вы используете сторонние серверы данных, на которых для проверки подлинности
применяются пароли, прочитайте ниже первую запись в списке изменений.
А если вы используете сторонние средства репликации, основанные на «логическом декодирова-
нии», обратите внимание на четвёртую запись в списке изменений.
2374Замечания к выпуску
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.2, см. Раздел E.19.
E.18.2. Изменения
• Ограничение видимости pg_user_mappings.umoptions для защиты паролей, сохранённых в
свойствах сопоставлений пользователей (Микаэль Пакье, Фейке Стинберген)
Предыдущая реализация позволяла владельцу объекта стороннего сервера или любому, кто
получил право USAGE, видеть свойства всех сопоставлений, связанных с этим сервером. В том
числе это могли быть и пароли других пользователей. Теперь определение данного представ-
ления изменено для соответствия поведению information_schema.user_mapping_options, так
что эти свойства может прочитать только собственно пользователь сопоставления либо, если
это сопоставление роли PUBLIC, владелец сервера, либо суперпользователь. (CVE-2017-7486)
Само по себе это исправление корректирует поведение только в новых базах данных, созда-
ваемых initdb. Если вы хотите применить это исправление к существующей базе данных, сле-
дуйте исправленной процедуре в списке изменений, относящейся к CVE-2017-7547, в Разде-
ле E.17.
• Предотвращение утечки статистической информации через негерметичные операторы (Питер
Эйзентраут)
Некоторые функции оценки избирательности в планировщике применяют пользовательские
операторы к значениям, получаемым из pg_statistic, например, к наиболее частым значе-
ниям и элементам гистограммы. Это происходит до проверки прав доступа к таблице, так что
злонамеренный пользователь может воспользоваться этим и получить подобные значения из
столбцов таблицы, чтение которых ему запрещено. Для устранения этой уязвимости следует
переходить к общим оценкам, если функция, реализующая оператор, не считается герметич-
ной и вызывающий её пользователь не имеет права на чтение столбца, статистика по которо-
му требуется планировщику. На практике в большинстве случаев одно из этих условий выпол-
няется. (CVE-2017-7484)
• Восстановление восприятия библиотекой libpq переменной окружения PGREQUIRESSL (Даниэль
Густафссон)
Поддержка этой переменной окружения была непреднамеренно ликвидирована в PostgreSQL
9.3, но в документации она осталась. Это создало угрозу безопасности, так как пользовате-
ли могли рассчитывать на то, что она будет требовать SSL-шифрования подключений, но на
самом деле этого не происходило. Теперь эта переменная воспринимается как и раньше, но
имеет меньший приоритет, чем PGSSLMODE, во избежание нарушения конфигураций, работаю-
щих корректно с версиями после 9.3. (CVE-2017-7485)
• Исправление потенциально некорректного начального снимка при логическом декодирова-
нии (Петр Желинек, Андрес Фройнд)
Изначальный снимок, создаваемый для слота репликации с логическим декодированием, мог
быть некорректным. В результате сторонние средства, использующие логическое декодирова-
ние, могли получать неполные/несогласованные начальные данные. Вероятность такого сбоя
увеличивалась, если при создании слота исходный сервер был загружен либо уже существо-
вал другой логический слот.
Если вы используете средство репликации, основанное на логическом декодировании, и копи-
ровали непустой набор данных в начале репликации, имеет смысл пересоздать реплику после
установления этого обновления либо сверить содержимое базы с исходным сервером.
• Исправление потенциального повреждения «слоёв инициализации» нежурналируемых индек-
сов (Роберт Хаас, Микаэль Пакье)
Это повреждение могло приводить к переходу нежурналируемого индекса в ошибочное состо-
яние после сбоя и перезапуска сервера. Устранить возникшую проблему можно было, только
удалив и перестроив индекс.
2375Замечания к выпуску
• Исправление ошибочного восстановления записей pg_subtrans при воспроизведении резерв-
ным сервером подготовленных, но не зафиксированных двухфазных транзакций (Том Лейн)
В большинстве случаев это не имело никаких болезненных последствий, но в особых ситуаци-
ях могло приводить к зацикливанию ссылок в pg_subtrans, что, в свою очередь, провоцирова-
ло бесконечные циклы в запросах, обращающимся к строкам, изменённым двухфазной тран-
закцией.
• Предотвращение возможного сбоя в walsender при ошибке инициализации буфера строки
(Стас Кельвич, Фудзии Масао)
• Предупреждение возможного сбоя при повторном сканировании индекса GiST с использова-
нием только индекса и поиском ближайших соседей (Том Лейн)
• Предотвращение задержек при запуске процессом postmaster нескольких параллельных рабо-
чих процессов (Том Лейн)
Ранее была возможна значительная задержка (до нескольких десятков секунд), когда запросу
требовалось более одного рабочего процесса, либо когда несколько запросов обращались за
рабочими процессами одновременно. На большинстве платформ это происходило при редком
стечении обстоятельств, но на некоторых наблюдалось регулярно.
• Исправление поведения postmaster при обработке сбоя fork() для фонового рабочего процес-
са (Том Лейн)
Ранее postmaster модифицировал элементы своего состояния так, как будто процесс был запу-
щен успешно, что впоследствии приводило к замешательству.
• Исправление потенциальной ошибки «no relation entry for relid 0» (нет записи отношения для
relid 0) при планировании вложенных операций с множествами (Том Лейн)
• Устранение разнообразных мелких дефектов в планировании параллельных запросов (Роберт
Хаас)
• Исключение применения оптимизации «физического целевого списка» к нестандартным ска-
нированиям (Дмитрий Иванов, Том Лейн)
Эта оптимизация предполагала, что получить все столбцы кортежа можно недорого, что дей-
ствительно верно для обычных кортежей Postgres, но с нестандартными провайдерами скани-
рования это может быть не так.
• Использование правильного подвыражения при применении политики защиты на уровне
строк FOR ALL (Стивен Фрост)
В некоторых случаях применялось ограничение WITH CHECK, хотя более уместным было бы
ограничение USING.
• Обеспечение видимости результатов непосредственно предшествующих DDL при разборе за-
просов в скриптах расширений (Жульен Рухо, Том Лейн)
Из-за того, что кеш между командами в скрипте расширения не сбрасывался, запрос к дан-
ным мог не наблюдать эффектов непосредственно предшествующего ему изменения каталога,
например результатов ALTER TABLE … RENAME.
• Ликвидация проверки прав доступа к табличному пространству при перестроении существую-
щего индекса командой ALTER TABLE … ALTER COLUMN TYPE (Ной Миш)
Это команда выдавала ошибку, если вызывающий пользователь не имел права CREATE для таб-
личного пространства, содержащего индекс. Такое поведение малополезно, так что стоит ис-
ключить эту проверку и разрешить перестраивать индекс там, где он находился.
• Предотвращение рекурсивного обращения команды ALTER TABLE … VALIDATE CONSTRAINT к
дочерним таблицам когда ограничение помечено как NO INHERIT (Амит Ланготе)
2376Замечания к выпуску
Это предупреждает нежелательные сбои типа «constraint does not exist» (ограничение не су-
ществует) в случаях, когда в дочерних таблицах нет соответствующего ограничения.
• Устранение потери указателя в COPY … TO когда для исходной таблицы активна защита на
уровне строк (Том Лейн)
Обычно это не имело болезненных последствий, но иногда всё же приводило к неожиданным
ошибкам и сбоям.
• Предупреждение обращения к уже закрытому элементу relcache в CLUSTER и VACUUM FULL (Том
Лейн)
При особом стечении обстоятельств это могло приводить к тому, что индексы в целевом отно-
шении перестраивались с неправильным режимом сохранения.
• Исправление ошибки команды VACUUM, когда она неправильно учитывала страницы, которые
не могла прочитать из-за конфликтующих закреплений страниц (Эндрю Гирт)
Это провоцировало недооценивание количества кортежей в таблице. В худшем случае с чрез-
вычайно востребованной таблицей команда VACUUM могла ошибочно сообщить, что таблица во-
все не содержит кортежей, что приводило к очень плохим решениям при планировании.
• Обеспечение возможности прерывания циклов массовой передачи кортежей в соединении по
хешу при попытке отмены запроса (Том Лейн, Томас Мунро)
• Исправление ошибок в поддержке определённых операторов box в SP-GiST (Никита Глухов)
Сканирование по индексу SP-GiST с использованием операторов &amp;&lt; &amp;&gt; &amp;&lt;| и |&amp;&gt; выдавало
некорректные ответы.
• Исправление проблем с переполнением целочисленных значений при сравнении типов
interval (Кётаро Хоригути, Том Лейн)
Операторы сравнения для типа interval могли выдавать неверные ответы для интервалов,
превышающих 296000 лет. Индексы по столбцам с такими большими значениями следует пе-
рестроить, так как они могут быть испорчены.
• Исправление функции cursor_to_xml(), чтобы она выдавала правильный результат с
tableforest = false (Томас Мунро, Питер Эйзентраут)
Ранее она не добавляла внешний элемент &lt;table&gt;.
• Устранение проблем с округлением в функциях float8_timestamptz() и make_interval()
(Том Лейн)
Эти функции отбрасывали дробную часть, а не округляли числа при преобразовании значения
с плавающей точкой к целому числу микросекунд; это могло приводить к неожиданным сдви-
гам результатов на единицу.
• Исправление функции pg_get_object_address() для членов семейств операторов (Альваро
Эррера)
• Исправление отмены pg_stop_backup() при попытке остановить немонопольное резервное ко-
пирование (Микаэль Пакье, Дэвид Стил)
Когда функция pg_stop_backup() отменялась, ожидая завершения немонопольного резерв-
ного копирования, информация о состоянии оставалась неактуальной; запустить новое моно-
польное копирование было невозможно, возникали и другие небольшие проблемы.
• Улучшение производительности представления pg_timezone_names (Том Лейн, Дэвид Роули)
• Уменьшение издержек при управлении памятью для контекстов, содержащих множество
больших блоков (Том Лейн)
• Исправление неаккуратной обработки редких ошибок в lseek() и close() (Том Лейн)
2377Замечания к выпуску
В типичных ситуациях эти системные вызовы отрабатывают без ошибок, но в случае ошибки
код fd.c мог повести себя некорректно.
• Исправление некорректной проверки факта работы postmaster в виде службы Windows (Мика-
эль Пакье)
Вследствие ошибки для вывода сообщений мог выбираться системный журнал событий (там
где его на самом деле не было), так что запись сообщений фактически не производилась.
• Исправление в ecpg поддержки COMMIT PREPARED и ROLLBACK PREPARED (Масахико Савада)
• Исправление ошибки двойного освобождения при обработке строковых констант, заключён-
ных в доллары, в ecpg (Михаэль Мескес)
• Исправление поведения pgbench с сочетанием параметров –connect и –rate (Фабьен Коэ-
льо)
• Исправление в pgbench обработки развёрнутого написания параметра –builtin согласно до-
кументации (Том Лейн)
• Исправление поведения pg_dump/pg_restore для корректной обработки прав, назначенных для
схемы public, при использовании параметра –clean (Стивен Фрост)
Другие схемы создаются без назначенных для них прав, но схема public представляет собой
исключение; когда она удаляется и восстанавливается вследствие указания –clean, её нуж-
но обработать особым образом.
• В pg_dump исправлена пометка схемы и владельца для комментариев и меток безопасности
некоторых типов объектов БД (Джузеппе Брокколо, Том Лейн)
В простых случаях это не проявлялось никак, но например, при восстановлении с выбором
схемы, могли потеряться комментарии, которые в ней должны быть, из-за того, что они не бы-
ли помечены как принадлежащие схеме своего объекта.
• Исправление ошибки в запросе pg_dump, предназначенном для получения начальных прав,
назначенных для процедурного языка (Питер Эйзентраут)
Вследствие этой ошибки pg_dump всегда полагал, что для языка не определены начальные
права. Так как это справедливо для большинства процедурных языков, последствия ошибки
могли проявляться довольно редко.
• Предотвращение вывода командой pg_restore -l некорректного файла со списком объектов,
когда имена объектов SQL содержат символы перевода строки (Том Лейн)
Символы перевода строки заменяются пробелами, что достаточно для того, чтобы этот список
корректно обработала команда pg_restore -L.
• Исправление поведения pg_upgrade для корректного переноса комментариев и меток без-
опасности, связанных с «большими объектами» (BLOB) (Стивен Фрост)
Ранее такие объекты корректно переносились в новую базу данных, но связанные с ними ком-
ментарии и метки безопасности терялись.
• Улучшение обработки ошибок в функции pg_file_write() из contrib/adminpack (Ной Миш)
В частности, она не реагировала на ошибки в вызове fclose().
• Предупреждение утечки предыдущего безымянного соединения при установлении нового
безымянного соединения в contrib/dblink (Джо Конвей)
• Исправление извлечения триграмм из регулярных выражений в contrib/pg_trgm (Том Лейн)
В некоторых случаях это могло приводить к формированию испорченной структуры данных,
для которой отсутствуют какие-либо соответствия. Вследствие этого при сканировании по ин-
2378Замечания к выпуску
дексам GIN и GiST с использованием триграмм для регулярного выражения могли не нахо-
диться никакие результаты.
• В contrib/postgres_fdw добавлена возможность вынесения на удалённый сервер условий со-
единения, содержащих функции из поставляемых расширений (Дэвид Роули, Ашутош Бапат)
• Поддержка Tcl 8.6 в сборках с MSVC (Альваро Эррера)
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией tzcode2017b
(Том Лейн)
Это устраняет ошибку с некоторыми вариантами перехода на летнее время в январе 2038.
• Обновление данных часовых поясов до версии tzdata 2017b, включающее изменение правил
перехода на летнее время в Чили, Монголии и на Гаити, а также исторические изменения для
Эквадора, Казахстана, Либерии и Испании. Переход к числовым аббревиатурам для ряда ча-
совых поясов в Южной Америке, в Тихом и Индийском океанах, а также в некоторых азиат-
ских и ближневосточных странах.
Ранее в базе данных часовых поясов IANA предоставлялись текстовые аббревиатуры для
всех часовых поясов и иногда при этом указывались аббревиатуры, которые практически не
употреблялись местным населением. Сейчас происходит процесс ухода от этой практики в
пользу использования числовых смещений UTC в тех часовых поясах, где нет никаких свиде-
тельств реального использования английской аббревиатуры. Как минимум на данном этапе,
PostgreSQL продолжит принимать подобные удалённые аббревиатуры при вводе дат/времени.
Но они не будут видны при просмотре представления pg_timezone_names и не будут выводить-
ся с датами/временем.
• Использование корректных правил перехода на летнее время для названий часовых поясов в
стиле POSIX при сборке с MSVC (Дэвид Роули)
Сборочные скрипты для MSVC не устанавливали корректно файл posixrules в дерево катало-
гов timezone. Это приводило к тому, что код timezone переходил к использованию встроенных
представлений о том, какой вариант перехода на летнее время применим для названия поя-
са в стиле POSIX. По историческим причинам это соответствует правилам, которые действо-
вали в США до 2007 г. (то есть переход на летнее время происходил в первое воскресенье ап-
реля, а на зимнее — в последнее воскресенье октября). С этим исправлением для часового по-
яса с названием в стиле POSIX будут использоваться текущие и исторические даты перехода
для пояса US/Eastern. Если для вас это нежелательно, удалите файл posixrules или замени-
те его файлом другого часового пояса (см. Подраздел 8.5.3). Учтите, что вследствие кеширо-
вания вам потребуется перезапустить сервер, чтобы подобные изменения вступили в силу.
E.19. Выпуск 9.6.2
Дата выпуска:
2017-02-09
В этот выпуск вошли различные исправления, внесённые после версии 9.6.1. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.19.1. Миграция на версию 9.6.2
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если в вашей инсталляции проявилась ошибка, описанная в первой записи следующего
списка изменений, после обновления вам может потребоваться предпринять дополнительные дей-
ствия для исправления испорченных индексов.
Также, если вы обновляете сервер с версии, более ранней, чем 9.6.1, см. Раздел E.20.
E.19.2. Изменения
• Исправление поведения в особых условиях, которое приводило к повреждению индексов, со-
здаваемых командой CREATE INDEX CONCURRENTLY (Паван Деоласи, Том Лейн)
2379Замечания к выпуску
Если команда CREATE INDEX CONCURRENTLY применялась для построения индекса, зависящего
от столбца, ранее не индексированного, то у строк, изменяемых транзакциями, выполняемы-
ми одновременно с командой CREATE INDEX, могли оказываться некорректные записи в индек-
се. В случае подозрений, что вас это коснулось, самое надёжное решение — перестроить та-
кие индексы после установки этого обновления.
• Предотвращение утери специального снимка, используемого при сканированиях каталога,
при преждевременной очистке данных (Tom Lane)
Рабочие процессы не учитывали этот снимок, сообщая о своём самом старом xmin, что остав-
ляло возможность для удаления по-прежнему нужных данных параллельными операциями
очистки. Это приводило к появлению плавающих ошибок с сообщениями «ошибка поиска в
кеше для отношения 1255».
• Исправление некорректной записи в WAL, формируемой для индексов BRIN (Кунтал Гхош)
Запись WAL, выдаваемая для страницы BRIN «revmap» при перемещении кортежа индекса в
другую страницу, была некорректной. При воспроизведении журнала соответствующая часть
индекса становилась непригодной, и её требовалось вычислять заново.
• Безусловное фиксирование в WAL создания «слоя инициализации» для нежурналируемых таб-
лиц (Микаэль Пакье)
Ранее это действие пропускалось при wal_level = minimal, но на самом деле это необходимо
даже в этом случае, чтобы нежурналируемая таблица корректно создавалась пустой после
сбоя.
• Если процесс сборщика статистики потерян, перезапускать его и в режиме горячего резерва
(Такаюки Цунакава)
• Обеспечение корректной работы механизма уведомлений горячего резерва, когда он включа-
ется при запуске резервного сервера (Антс Аасма, Крейг Рингер)
• Проверка прерываний в момент ожидания конфликтующего запроса сервером горячего ре-
зерва (Саймон Риггс)
• Предупреждение постоянного перезапуска процесса запуска автоочистки в особых случаях
(Амит Хандекар)
Это исправление решает проблему, возникавшую, когда автоочистка номинально отключена
и есть несколько таблиц, требующих «заморозки», но эти таблицы уже обработаны рабочими
процессами автоочистки.
• Недопущение установки нулевого значения для поля num_sync в synchronous_standby_names
(Фудзии Масао)
Правильный вариант отключения синхронных резервных серверов — задать пустую строку в
качестве всего значения.
• Не учитывать фоновые рабочие процессы при проверке ограничения на число подключений
пользователя (Дэвид Роули)
• Исправление проверки на возможность удаления объекта, принадлежащего расширению (Том
Лейн)
Скрипты обновления расширений должны иметь возможность удалять объекты расширений,
но это запрещалось для последовательностей со столбцами serial, а также, возможно, в других
случаях.
• Исправление отслеживания начальных прав доступа для объектов, принадлежащих расшире-
нию, чтобы это корректно работало с ALTER EXTENSION … ADD/DROP (Стивен Фрост)
Текущие права доступа к объекту в момент добавления его в расширение теперь будут счи-
таться правами по умолчанию; только в случае изменений они будут выгружаться при после-
дующем выполнении pg_dump.
2380Замечания к выпуску
• Команда ALTER TABLE должна сохранять назначения табличных пространств индексам при пе-
рестраивании индексов (Том Лейн, Микаэль Пакье)
Ранее с нестандартными значениями default_tablespace были возможны разрушения индек-
сов.
• Исправление некорректного изменения свойств триггерной функции при изменении свой-
ства «откладываемости» ограничения внешнего ключа с помощью команды ALTER TABLE …
ALTER CONSTRAINT (Том Лейн)
Это приводило к странным сбоям при последующем обращении к внешнему ключу, так как
триггеры срабатывали не в положенное время.
• Недопущение удаления ограничения внешнего ключа при наличии событий, ожидающих об-
работки триггерами, для целевого отношения (Том Лейн)
Это предотвращает ошибки «не удалось найти триггер NNN» и «в отношении NNN нет тригге-
ров».
• Исправление поведения ALTER TABLE … SET DATA TYPE … USING в случаях, когда порядок
столбцов в дочерней таблице отличается от родительской (Альваро Эррера)
Вследствие того, что столбцы в выражении USING не перенумеровывались, возникала ошибка,
обычно такая: «атрибут N имеет неправильный тип».
• Исправление обращения к столбцу OID в случаях, когда таблица с таким столбцом связывает-
ся с родительской, тоже с OID, посредством ALTER TABLE … INHERIT (Амит Ланготе)
В таких случаях столбец OID должен обрабатываться как обычный пользовательский столбец,
но этого не происходило, что приводило к странному поведению при последующих изменени-
ях наследования.
• Команда CREATE TABLE … LIKE … WITH OIDS должна создавать таблицу с OID вне зависи-
мости от того, есть ли OID в таблице, указанной в LIKE (Том Лейн)
• Исправление поведения CREATE OR REPLACE VIEW — запрос представления должен изменяться
до применения новых параметров представления (Дин Рашид)
Ранее в команде происходил сбой, если новые параметры оказывались несогласованными со
старым определением представления.
• Получение правильного идентификатора объекта в ALTER TEXT SEARCH CONFIGURATION (Артур
Закиров)
Ранее расширениям, таким как модули логического декодирования, выдавался неправильный
OID каталога.
• Предупреждение сбоев механизма учёта времени транзакций при запросе особых XID
(FrozenTransactionId и BootstrapTransactionId) (Крейг Рингер)
• Исправление некорректного использования reloptions представлений как reloptions обычных
таблиц (Том Лейн)
Симптомами ошибки были неуместные сообщения «ON CONFLICT не поддерживается
для таблицы …, служащей таблицей каталога» когда целевым отношением INSERT … ON
CONFLICT было представление с каскадной проверкой.
• Исправление некорректного сообщения «допустимое число элементов в целевом списке огра-
ничено N» при использовании ON CONFLICT с широкими таблицами (Том Лейн)
• Устранение ошибок с ложными сообщениями «в запросе обнаружены данные для удалённого
столбца» при выполнении INSERT или UPDATE в таблице с удалённым столбцом (Том Лейн)
• Предотвращение разворачивания foo.* в набор столбцов в исходном выражении UPDATE (Том
Лейн)
2381Замечания к выпуску
Это приводило к ошибкам с сообщением «несоответствие целевого количества в UPDATE —
внутренняя ошибка». Теперь эта запись воспринимается как обозначение переменной «вся-
строка», как и в других контекстах.
• Обеспечение точного определения модификаторов типа столбцов в конструкциях VALUES с
несколькими строками (Том Лейн)
Это устраняет проблемы, возникавшие, когда первое значение в столбце имеет воспринима-
емый модификатор типа (например, длину значения varchar), но последующие значения не
разделяют его ограничение.
• При нахождении незаконченной суррогатной пары Unicode в конце строки символов Unicode
должна выдаваться ошибка (Том Лейн)
Обычно за начальным суррогатным символом Unicode должно следовать продолжение, но
это не проверялось когда такой начальный символ оказывался последним в строке символов
Unicode (U&amp;’…’) или в Unicode-идентификаторе (U&amp;”…”).
• Корректировка выполнения агрегатов с DISTINCT и упорядочиванием, когда несколько таких
агрегатов могут разделять одно состояние перехода (Хейкки Линнакангас)
• Исправление реализации операторов поиска фраз в tsquery (Том Лейн)
Ликвидация некорректных и применяемых несогласованно правил перезаписи, которые пыта-
лись оптимизировать операторы И/ИЛИ/НЕ внутри оператора поиска фразы; вместо этого об-
работка таких выражений была добавлена в сам исполнитель. В результате устранены разно-
образные странности в поведении и возможные сбои в запросах полнотекстового поиска, со-
держащих такие выражения. Также реализовано разумное поведение вложенных операторов
поиска фраз не только с простыми деревьями, растущими влево; исправлено поведение при
удалении стоп-слов из предложения поиска фразы; обеспечена согласованность поиска по ин-
дексу и простого выполнения этих запросов с последовательным сканированием.
• Определённо отрицательному поисковому запросу, например, !foo, должны удовлетворять пу-
стые значения tsvector (Том Дунстан)
Такие соответствия находились при поиске по индексу GIN, но не при последовательном ска-
нировании или поиске по индексу GiST.
• Предотвращение сбоя в ситуации, когда ts_rewrite() заменяет поддерево не верхнего уровня
пустым запросом (Артур Закиров)
• Устранение проблем с производительностью в ts_rewrite() (Том Лейн)
• Исправление обработки в ts_rewrite() вложенных операторов NOT (Том Лейн)
• Увеличение скорости пользовательских агрегатов, использующих в качестве перехода функ-
цию array_append() (Том Лейн)
• Исправление array_fill() для корректной обработки пустых массивов (Том Лейн)
• Предупреждение возможных сбоев в функциях array_position() и array_positions() при об-
работке массивов записей (Джун-сок Янг)
• Устранение выхода на один байт за границу буфера в функции quote_literal_cstr() (Хейкки
Линнакангас)
Этот выход имел место только если входная строка содержала исключительно апострофы и/
или обратные косые черты.
• Предотвращение одновременного выполнения вызовов pg_start_backup() и
pg_stop_backup() (Микаэль Пакье)
Это предупреждает сбой проверки истинности и, вероятно, худшие последствия, в случае, ес-
ли кто-то попытается запустить эти функции параллельно.
2382Замечания к выпуску
• Отключение трансформации, которая пыталась оптимизировать бесполезные преобразования
AT TIME ZONE (Том Лейн)
Вследствие этого выдавались неверные результаты, когда упрощённое выражение использова-
лось в условии индекса.
• Сохранение приведений interval-в-interval, которые на самом деле несут смысловую на-
грузку (Том Лейн)
В некоторых случаях приведения, которые должны были обнулять младшие поля значений
interval, ошибочно считались бессмысленными и просто убирались. В результате, например,
при приведении значения типа INTERVAL MONTH к INTERVAL YEAR поле месяцев не обнулялось.
• Устранения сбоя в ситуациях, когда число рабочих процессов, доступных для параллельных
запросов, уменьшалось при повторном сканировании (Андреас Зельтенрейх)
• Исправление ошибок при передаче значений параметров GUC параллельным исполнителям
(Микаэль Пакье, Том Лейн)
• Допущение возможности для операторов, подготовленных командой PREPARE, иметь парал-
лельные планы (Амит Капила, Тобиас Бусман)
• Исправление некорректного построения параллельных планов для полусоединений (Том
Лейн)
• Исправление оценок количества строк для параллельных соединений (Роберт Хаас)
Эти оценки должны отражать количество строк, которое будет видеть отдельный рабочий
процесс, а не общее их число.
• Исправление планировщика, чтобы он не пытался распараллеливать узлы плана, содержащие
вложенные и инициализирующие планы (Том Лейн, Амит Капила)
• Аннулирование кешированных планов при изменениях в параметрах сторонних таблиц (Амит
Ланготе, Эцуро Фудзита, Ашутош Бапат)
• Исправление плана, формируемого для частичного агрегирования с выражением GROUP BY с
константой (Том Лейн)
• Исправление ошибки планировщика «не удалось найти план для CTE» при обработке кон-
струкции UNION ALL, включающей CTE (Том Лейн)
• Исправление некорректной обработки инициализирующих планов при принудительном добав-
лении узла Material во вложенный план (Том Лейн)
Типичным проявлением этого дефекта были ошибки «в плане не должно быть обращения к
переменной вложенного плана».
• Исправление оценки избирательности соединения по внешнему ключу для полусоединений и
антисоединений, а также в ситуациях с наследованием (Том Лейн)
Новый код, принимающий в рассмотрение связь по внешнему ключу, работал неправильно в
этих случаях, и оценки оказывались хуже, а не лучше, чем в коде до 9.6.
• Исправление pg_dump, чтобы в выгрузку попадали данные последовательности, помеченной
как конфигурационная таблица расширения (Микаэль Пакье)
• Корректировка неправильной обработки ALTER DEFAULT PRIVILEGES … REVOKE в pg_dump
(Стивен Фрост)
Программа pg_dump не выдавала требуемые команды REVOKE в случаях, когда с помощью
ALTER DEFAULT PRIVILEGES некоторые права доступа исключались из начального набора.
• Исправление pg_dump для корректной выгрузки пользовательских приведений и преобразова-
ний, использующих встроенные функции (Стивен Фрост)
• Реализация более разумного поведения pg_restore с –create –if-exists в случаях, когда
архив содержит нераспознанные команды DROP (Том Лейн)
2383Замечания к выпуску
Это не устраняет никакую наблюдаемую ошибку, но может улучшить поведение в будущем,
при использовании pg_restore с архивом, созданным предыдущей версией pg_dump.
• Исправление ограничения нагрузки pg_basebackup при низкой скорости ввода/вывода (Анто-
нин Хоуска)
Если скорость диска на время оказывалась ниже заданного ограничения, в вычислении про-
исходило переполнение, и в результате ограничение отключалось до конца операции.
• Обеспечение корректной работы pg_basebackup с подкаталогами pg_stat_tmp и pg_replslot,
являющимися символическими ссылками (Магнус Хагандер, Микаэль Пакье)
• Предотвращение возможного сбоя pg_basebackup на резервном сервере при задействовании
файлов WAL (Амит Капила, Роберт Хаас)
• Усовершенствование initdb, чтобы в postgresql.conf вставлялись корректные для текущей
платформы значения по умолчанию параметров xxx_flush_after (Фабьен Коэльо, Том Лейн)
Это позволило описать значения по умолчанию в документации более понятно, чем раньше.
• Исправление возможного дефекта при обработке развёрнутых массивов в ограничениях-про-
верках доменов и в конструкциях CASE (Том Лейн)
Существовала вероятность, что функция PL/pgSQL, вызванная в этих контекстах, изменит или
даже удалит значение массива, которое должно сохраняться для дополнительных операций.
• Исправление рекурсивного вызова функций PL/pgSQL в таких контекстах, как проверки огра-
ничений домена, выполняемые при присвоении значения переменной PL/pgSQL (Том Лейн)
• Обеспечение правильного учёта объектов исключений Python, создаваемых нами для PL/
Python, счётчиками использования (Рафа де ла Торре, Том Лейн)
Это предотвращает ошибки, возникавшие при использовании объектов после цикла уборки
мусора в Python.
• Исправление в PL/Tcl поддержки триггеров для таблиц, в которых имеется столбец .tupno
(Том Лейн)
Это соответствует (ранее недокументированному) поведению команд PL/Tcl spi_exec и
spi_execp, в том, что особый столбец .tupno добавляется, только если отсутствует настоящий
с таким именем.
• В файлах ~/.pgpass должны допускаться завершения строк в стиле DOS, даже на Unix-плат-
формах (Вик Фиринг)
Это изменение упрощает использование одних и тех же файлов паролей на машинах с Unix и
Windows.
• Устранение выхода на один байт за границу буфера, когда ecpg передаётся имя файла, кото-
рое заканчивается точкой (Такаюки Цунакава)
• Исправление некорректных сообщений об ошибках при дублировании данных в psql
\crosstabview (Том Лейн)
psql иногда цитировал некорректное содержимое строки/столбца, выдавая сообщение о мно-
жественных значениях в одной ячейке перекрёстной таблицы.
• Исправление в psql дополнения табуляцией для команды ALTER DEFAULT PRIVILEGES (Жиль
Даролд, Стивен Фрост)
• Исправление в psql дополнения табуляцией для ALTER TABLE t ALTER c DROP … (Кётаро Хо-
ригути)
• В psql пустое или содержащее только пробелы значение переменной окружения PAGER долж-
но означать «без постраничника» (Том Лейн)
2384Замечания к выпуску
Ранее с таким значением вывод, предназначенный для постраничника, просто исчезал.
• Улучшение в contrib/dblink передачи сообщений о низкоуровневых ошибках libpq, напри-
мер, о нехватке памяти (Джо Конвей)
• Реализация contrib/dblink должна игнорировать невоспринимаемые ей параметры серве-
ра, когда в качестве источника параметров подключения используется сторонний сервер
contrib/postgres_fdw (Кори Хинкер)
Ранее, если объект стороннего сервера имел параметры, которые не относились к параметрам
подключения libpq, происходила ошибка.
• Исправление проблем с переносимостью в функциях contrib/pageinspect, связанных с ин-
дексами GIN (Питер Эйзентраут, Том Лейн)
• Устранение возможной потери событий чтения сокета при ожидании в Windows (Амит Капи-
ла)
Эта ошибка была безвредной при обычном использовании, но, как оказалось, она приводила к
повисаниям при попытке воспользоваться расширением pldebugger.
• В Windows изменённые переменные окружения должны передаваться и отладочным DLL
(Кристина Ульрих)
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией tzcode2016j
(Том Лейн)
Это решило ряд проблем; в частности, проблему при установке данных о часовых поясах в ка-
талог, в котором не поддерживаются жёсткие ссылки.
• Обновление данных часовых поясов до версии tzdata 2016j, включающее изменения правил
перехода на летнее время на Северном Кипре (добавление нового пояса Asia/Famagusta), в
России (добавление нового пояса Europe/Saratov), в Тонга и в Антарктике/Кейси, плюс коррек-
тировку исторических данных для Италии, Казахстана, Мальты и Палестины. Переход к пред-
почитаемому числовому обозначению пояса для Тонга.
E.20. Выпуск 9.6.1
Дата выпуска:
2016-10-27
В этот выпуск вошли различные исправления, внесённые после версии 9.6.1. За информацией о
нововведениях версии 9.6 обратитесь к Разделу E.21.
E.20.1. Миграция на версию 9.6.1
Если используется версия 9.6.X, выгрузка/восстановление базы не требуется.
Однако если в вашей инсталляции проявились ошибки, описанные в двух первых записях следу-
ющего списка изменений, после обновления вам может потребоваться предпринять дополнитель-
ные действия для исправления испорченных карт свободного места и/или видимости.
E.20.2. Изменения
• Корректировка записи в WAL отметки об очистке карт свободного пространства и видимости
(Паван Деоласи, Хейкки Линнакангас)
Ранее могло получаться так, что эти файлы не восстанавливались корректно при восстановле-
нии после сбоя или оказывались неправильными на резервном сервере. Обращение к недей-
ствительному содержимому карты свободного пространства могло повлечь попытки использо-
вать страницы, которые были стёрты из самого отношения, что обычно приводило к ошибкам
типа «не удалось прочитать блок XXX: прочитано только 0 из 8192 байт». Также были возмож-
ны нарушения контрольных сумм в карте видимости, при включённом механизме контроль-
ных сумм.
2385Замечания к выпуску
Процедуры для определения наличия проблемы и её исправления рассматриваются в https://
wiki.postgresql.org/wiki/Free_Space_Map_Problems.
• Предупреждение возможного повреждения данных в процессе преобразования программой
pg_upgrade карты видимости отношения в формат 9.6 (Том Лейн)
На машинах с порядком байт от старшего, байты новой карты видимости записывались в
неправильном порядке, в результате чего карта оказывалась абсолютно некорректной. В
Windows старая карта считывалась в текстовом режиме, что приводило к некорректным ре-
зультатам, если в карте рядом оказывались байты, представляющие последовательность сим-
волов возврат каретки/перевод строки. Последняя ошибка практически всегда должна была
приводить к сбою pg_upgrade из-за того, что длина файла с картой оказывалась неверной.
Если вы используете компьютер с порядок байт от старшего (таковы многие архитектуры не
Intel) и применяли pg_upgrade для обновления баз с версии до 9.6, вы должны принять, что
все карты видимости некорректны и должны быть перестроены. Для этого достаточно аннули-
ровать карты видимости всех отношений с помощью функции pg_truncate_visibility_map()
расширения contrib/pg_visibility. Более подробную информацию вы можете найти в
https://wiki.postgresql.org/wiki/Visibility_Map_Problems.
• Предотвращение ошибок сериализации при операции добавлении данных, конфликтующей с
собой же, в INSERT … ON CONFLICT (Томас Мунро, Питер Геохеган)
• Ликвидация риска использования после освобождения при выполнении агрегатных функций с
DISTINCT (Питер Геохеган)
Это могло приводить к отказам или некорректным результатам запросов.
• Исправление обработки полиморфных агрегатных функций, используемых в качестве оконных
(Том Лейн)
Функции перехода агрегата сообщалось, что её первый аргумент и результат имеют выходной
тип агрегата, а не тип состояния. Это приводило к ошибкам или сбоям в функциях перехода,
связанных с полиморфными агрегатами.
• Исправление COPY со списком имён столбцов из таблицы, в которой включена защита на уров-
не строк (Адам Брайтвелл)
• Исправление EXPLAIN, чтобы она выдавала корректный XML, когда параметр track_io_timing
включён (Маркус Винанд)
Ранее вывод в формате XML содержал синтаксически некорректные теги, как например &lt;I/O-
Read-Time&gt;. Сейчас выдаётся такой тег: <I-O-Read-Time>.
• Исправление обновления статистики при TRUNCATE в подготовленной транзакции (Стас Кель-
вич)
• Исправление ошибок при объединении наследуемых ограничений CHECK в процессе создания
или изменения структуры таблицы (Том Лейн, Амит Ланготе)
Теперь одинаковые ограничения CHECK могут добавляться в родительскую и дочернюю таб-
лицу в любом порядке. С другой стороны, слияние проверенного ограничения из родитель-
ской таблицы с непроверенным (NOT VALID) ограничением в дочерней не должно допускаться.
Подобным образом, не должно допускаться слияние дочернего ненаследуемого (NO INHERIT)
ограничения с наследуемым.
• Вывод разумного значения в pg_settings.unit для параметров min_wal_size и max_wal_size
(Том Лейн)
• Исправление замены элементов массива в jsonb_set() (Том Лейн)
Если целью замены был существующий элемент массива JSON, он удалялся, а не заменялся
новым.
2386Замечания к выпуску
• Предотвращение очень маловероятного повреждения данных в результате проверки видимо-
сти кортежа без удержания блокировки буфера (Томас Мунро, Питер Геохеган, Том Лейн)
• Сохранение времени фиксирования транзакций после перезагрузки сервера (Жульен Рухо,
Крейг Рингер)
При включённом параметре track_commit_timestamp старые метки времени фиксации стано-
вились недоступными после полной перезагрузки сервера.
• Исправление логического декодирования WAL в случаях, когда вывод WAL из подтранзакции
оказывался слишком большим и вымещался на диск (Андрес Фройнд)
• Ликвидация проблемы с недействительным указателем в механизме логического декодирова-
ния WAL (Стас Кельвич)
• Округление размера запроса разделяемой памяти до числа, кратного размеру огромной стра-
ницы, когда огромные страницы используются в Linux (Том Лейн)
Это позволяет избежать возможных сбоев в munmap() в системах с нетипичными размерами
огромных страниц. За исключением случаев краха, эти сбои проявлялись только в сообщениях
в журнале.
• Не пытаться разделять контекст SSL между несколькими подключениями в libpq (Хейкки
Линнакангас)
Такое разделение приводило к разнообразным ошибкам, особенно при попытке использова-
ния различных параметров SSL для разных соединений.
• Предотвращение утечек памяти в особых случаях в libpq (Том Лейн)
Поступило сообщение об утечке в процессе PQreset(), но были возможны проявления и в свя-
занных случаях.
• В pg_upgrade проверка загружаемости библиотек должна производиться по порядку имён
(Том Лейн)
Это обходное решение проблемы зависимостей между расширениями, образуемых связями
модулей трансформации языков с базовыми модулями самих языков и типов данных.
• Исправление pg_upgrade для корректной работы с расширениями, содержащими методы до-
ступа индексов (Том Лейн)
Чтобы это было возможно, для сервера была добавлена поддержка команды ALTER EXTENSION
ADD/DROP ACCESS METHOD. Эта функциональность должна была добавляться в изначальной до-
работке, реализующей динамическое создание методов доступа, но этого не произошло по
упущению.
• Улучшение вывода ошибок в pg_upgrade при копировании/создании ссылок/перезаписи (Том
Лейн, Альваро Эррера)
• Исправление pg_dump для поддержки серверов версий до 7.4 (Амит Ланготе, Том Лейн)
• Недопущение одновременного указания аргументов --source-server и --source-target для
pg_rewind (Михаэль Банк)
• Программа pg_rewind должна отключать synchronous_commit в своём сеансе на исходном сер-
вере (Михаэль Банк, Микаэль Пакье)
При этом pg_rewind сможет работать, даже когда на исходном сервере настроена синхронная
репликация, но она по какой-то причине не функционирует.
• В pg_xlogdump нужно повторять попытку открыть новый сегмент WAL, когда используется па-
раметр --follow (Магнус Хагандер)
Это позволяет справиться с возможной задержкой при создании сервером следующего сег-
мента.
2387Замечания к выпуску
• Исправление в contrib/pg_visibility, чтобы выдавался корректный TID испорченного кор-
тежа (ранее TID мог выдаваться некорректно вследствие изменения, впоследствии отменённо-
го) (Том Лейн)
• Исправление зависимостей в makefile, чтобы параллельная сборка PL/Python сама по себе вы-
полнялась надёжно (Павел Райскуп)
• Обновление данных часовых поясов до версии tzdata 2016h, включающее изменение правил
перехода на летнее время в Палестине и Турции, а также исторические изменения для Тур-
ции и некоторых регионов России. Переход к числовым аббревиатурам для некоторых часовых
поясов в Антарктике, бывшем Советском Союзе и на Шри-Ланке.
Ранее в базе данных часовых поясов IANA предоставлялись текстовые аббревиатуры для
всех часовых поясов и иногда при этом указывались аббревиатуры, которые практически не
употреблялись местным населением. Сейчас происходит процесс ухода от этой практики в
пользу использования числовых смещений UTC в тех часовых поясах, где нет никаких свиде-
тельств реального использования английской аббревиатуры. Как минимум на данном этапе,
PostgreSQL продолжит принимать подобные удалённые аббревиатуры при вводе дат/времени.
Но они не будут видны при просмотре представления pg_timezone_names и не будут выводить-
ся с датами/временем.
Начиная с этого выпуска, аббревиатура AMT более не считается занятой часовым поясом Ар-
мении. Поэтому мы изменили значение этой аббревиатуры по умолчанию, чтобы она обозна-
чала Амазонское время (Amazon Time), так что теперь она означает UTC-4, а не UTC+4.
E.21. Выпуск 9.6
Дата выпуска:
2016-09-29
E.21.1. Обзор
В число ключевых усовершенствований PostgreSQL 9.6 входят:
• Параллельное выполнение последовательного сканирования, соединений и агрегатных вычис-
лений
• Предупреждение излишнего сканирования страниц при операциях очистки с заморозкой
• При синхронной репликации стало возможным использовать несколько резервных серверов
для увеличения надёжности
• Полнотекстовый поиск теперь позволяет находить фразы (несколько соседних слов)
• postgres_fdw теперь может выполнять на удалённой стороне соединение, сортировку, UPDATE
и DELETE
• Существенное увеличение производительности, особенно в части масштабируемости на мно-
гопроцессорных серверах
Предыдущие пункты более подробно описаны в следующих разделах.
E.21.2. Миграция на версию 9.6
Тем, кто хочет мигрировать данные из любой предыдущей версии, необходимо выполнить выгруз-
ку/загрузку данных с помощью pg_dumpall или воспользоваться pg_upgrade.
В версии 9.6 реализован ряд изменений, которые могут повлиять на совместимость с предыдущими
выпусками. Рассмотрите следующие несовместимые аспекты:
• Добавление в pg_stat_activity информации о том, чего ждёт процесс (Амит Капила, Ильдус
Курбангалиев)
Исторически процесс показывался как ожидающий, только если он ожидал тяжёлой блоки-
ровки. Теперь в pg_stat_activity также показываются ожидания лёгких блокировок и за-
2388Замечания к выпуску
креплений буферов. Также теперь виден тип ожидаемой блокировки. В результате этих изме-
нений столбец waiting был заменён столбцами wait_event_type и wait_event.
• В функции to_char() знак минус не должен считаться частью поля с заданной шириной для
компонентов времени (Брюс Момджян)
Например, to_char('-4 years'::interval, 'YY') теперь возвращает -04, а не -4.
• Более разумное поведение функции extract() с бесконечными значениями в аргументах (Ви-
талий Буровой)
Ранее функция extract() просто возвращала ноль для аргумента «бесконечность», вне зави-
симости от выбранного поля. Теперь она будет возвращать infinity или -infinity соответ-
ственно, когда это поле является монотонно возрастающим (например, year, epoch), и NULL
в противном случае (например, day, hour). Также теперь выдаётся ожидаемая ошибка при
некорректном указании поля.
• Ликвидация «особенности» PL/pgSQL, подавляющей строку КОНТЕКСТ в сообщениях, выдавае-
мых командами RAISE (Павел Стехуле)
Этот древний трюк для обратной совместимости по общему мнению пережил то время, когда
он был полезен.
• Исправление стандартного анализатора текстового поиска, чтобы он принимал начальные
цифры во фрагментах текста типа email и host (Артур Закиров)
В большинстве случаев это не должно отразиться на разборе текста, но если вы часто имее-
те дело с такими адресами, может иметь смысл перестроить зависимые столбцы и индексы
tsvector, чтобы адреса этих видов корректно находились при поиске.
• Расширение стандартного файла unaccent.rules в модуле contrib/unaccent для обработки
всех существующих в Unicode диакритик и корректного разворачивания лигатур (Томас Мун-
ро, Леонард Бенедетти)
Предыдущая версия не считала нужным преобразовывать некоторые редкие буквы с диакри-
тическими знаками. Кроме того, лигатуры теперь разворачиваются в отдельные буквы. В ин-
сталляциях, где используется этот файл правил, может иметь смысл перестроить столбцы
tsvector и зависимые индексы.
• Ликвидация давно считавшихся устаревшими указаний CREATEUSER/NOCREATEUSER команды
CREATE ROLE и родственных ей (Том Лейн)
Указание CREATEUSER на самом деле означало SUPERUSER из давних соображений относительно
обратной совместимости. Это постоянно вводило в заблуждение людей, которые полагали (и
имели на это право), что оно означало CREATEROLE. Это указание считается устаревшим уже
десять лет, так что пора решить эту проблему, убрав его.
• Считать имена ролей, начинающиеся с pg_, зарезервированными (Стивен Фрост)
Теперь пользователям будет запрещено создавать роли с такими именами. Это предотвращает
конфликты со встроенными ролями, создаваемыми программой initdb.
• Смена имени столбца в представлении information_schema.routines с
result_cast_character_set_name на result_cast_char_set_name (Клеман Прево)
Стандарт SQL:2011 устанавливает более длинное имя, но это, скорее всего, ошибка, так как у
соседних столбцов имена более краткие, как и в других представлениях information_schema.
• Параметр psql -c теперь не подразумевает поведение параметра --no-psqlrc (Павел Стехуле,
Каталин Якоб)
Для получения старого поведения нужно явно написать --no-psqlrc (или сокращение -X).
Модифицированные таким образом скрипты будут продолжать работать и со старыми версия-
ми psql.
2389Замечания к выпуску
• Усовершенствование функции параметра pg_restore -t, чтобы он отбирал все типы отноше-
ний, а не только простые таблицы (Крейг Рингер)
• Изменение формата отображения NextXID в pg_controldata и связанных местах (Джо Конвей,
Брюс Момджян)
Отображение значений эпоха-и-ID-транзакции в формате число:число. Предыдущий формат
число/число был похож на формат LSN, что могло вводить в заблуждение.
• Функции расширений, для которых это уместно, помечены как безопасные для распараллели-
вания (Андреас Карлссон)
Во многие стандартные расширения внесены изменения, чтобы их функции могли выполнять-
ся параллельными исполнителями запросов. Эти изменения не вступят в силу в базах данных,
обновлённых с предыдущих версий (с помощью pg_upgrade), пока вы не примените для каждо-
го такого расширения команду ALTER EXTENSION UPDATE (в каждой базе данных кластера).
E.21.3. Изменения
Ниже вы найдёте подробный список изменений, произошедших между предыдущим основным вы-
пуском и выпуском PostgreSQL 9.6.
E.21.3.1. Сервер
E.21.3.1.1. Параллельное выполнение запросов
• Параллельные запросы (Роберт Хаас, Амит Капила, Дэвид Роули и многие другие)
С версией 9.6 в PostgreSQL появляется начальная поддержка параллельного выполнения
больших запросов. Параллельному выполнению подлежат строго запросы только на чтение, в
которых производится последовательное сканирование целевой таблицы. В параллельном ре-
жиме могут выполняться и соединения по хешу с вложенными циклами, а также агрегирова-
ние (с поддерживаемыми агрегатными функциями). Ещё многое предстоит сделать, но и этот
набор возможностей уже весьма полезен.
Параллельное выполнение запросов по умолчанию отключено (пока). Чтобы выключить
его, установите для нового конфигурационного параметра max_parallel_workers_per_gather
значение, большее нуля. Для дополнительной настройки распараллеливания запросов
также введены новые параметры force_parallel_mode, parallel_setup_cost, parallel_tuple_cost и
min_parallel_relation_size.
• Инфраструктура для обозначения параллельно-безопасности функций (Роберт Хаас, Амит Ка-
пила)
E.21.3.1.2. Индексы
• Индексы GIN строятся более эффективно при значениях maintenance_work_mem, превышаю-
щих 1 ГБ (Роберт Абрахам, Фёдор Сигаев)
• Включение страниц, удаляемых из очереди обработки индекса GIN, сразу в карту свободного
пространства (Джефф Джейнс, Фёдор Сигаев)
Это предотвращает замусоривание базы, если таблица очищается нечасто.
• Добавление функции gin_clean_pending_list(), позволяющей вручную вызвать очистку оче-
реди обработки индекса GIN (Джефф Джейнс)
Ранее такая очистка производилась только в результате очистки или анализа родительской
таблицы.
• Оптимизация обработки «мёртвых» кортежей в индексах GiST (Анастасия Лубенникова)
Кортежи в индексе теперь помечаются как «мёртвые», если при сканировании индекса обна-
руживается, что соответствующий кортеж в куче — «мёртвый». Впоследствии, при добавле-
2390Замечания к выпуску
нии новых кортежей, кортежи, помеченные как «мёртвые», могут быть замещены, если потре-
буется место на этой странице.
• Добавлен класс операторов SP-GiST для типа box (Александр Лебедев)
E.21.3.1.3. Сортировка
• Увеличение производительности сортировки за счёт использования quicksort вместо выбора с
замещением при выполнении этапов внешней сортировки (Питер Геохеган)
Новый подход позволяет эффективнее использовать кеш процессора при типичных размерах
кеша и объёмах данных. Где необходимо, новое поведение можно скорректировать, воспользо-
вавшись новым конфигурационным параметром replacement_sort_tuples.
• Ускорение сортировки текста, когда одна и та же строка встречается многократно (Питер
Геохеган)
• Ускорение сортировки типов uuid, bytea и char(n) за счёт использования «сокращённых»
ключей (Питер Геохеган)
Поддержка сокращённых ключей была также добавлена в дополнительные классы операторов
text_pattern_ops, varchar_pattern_ops и bpchar_pattern_ops. Сокращённые ключи теперь
могут задействоваться и при вычислении сортирующих агрегатных функций.
• Ускорение команды CREATE INDEX CONCURRENTLY за счёт обработки идентификаторов TID как
64-битных целых в процессе сортировки (Питер Геохеган)
E.21.3.1.4. Блокировки
• Уменьшение конкуренции за ProcArrayLock (Амит Капила, Роберт Хаас)
• Улучшение производительности за счёт переноса блокировок содержимого буфера в дескрип-
торы буферов (Андрес Фройнд, Саймон Риггс)
• Замена циклических блокировок заголовков в общем буфере атомарными операциями для
улучшения масштабируемости (Александр Коротков, Андрес Фройнд)
• Использование атомарных операций вместо циклических блокировок для защиты очереди
ожидания LWLock (Андрес Фройнд)
• Разбиение на части списка свободных элементов для разделяемых по хешу таблиц, для умень-
шения конкуренции на многопроцессорных серверах (Александр Алексеев)
• Сокращение взаимоблокировок на резервных серверах при воспроизведении операций очист-
ки индекса-B-дерева (Саймон Риггс)
Это изменение исключает существенные задержки при репликации, которые иногда имели
место при воспроизведении таких операций.
E.21.3.1.5. Статистика оптимизатора
• Улучшение оценок ANALYZE для столбцов с большим количеством NULL (Томаш Вондра, Алек-
сандр Шульгин)
Ранее процедура ANALYZE была склонна недооценивать число различных и отличных от NULL
значений в столбце со множеством NULL, и также неточно вычисляла наиболее распростра-
нённые значения.
• Улучшение оценки планировщиком количества различных значений в результате запроса (То-
маш Вондра)
• Использование связей по внешним ключам для оценки избирательности предикатов соедине-
ния (Томаш Вондра, Дэвид Роули)
Если в таблице t имеется ограничение внешнего ключа, например (a,b) REFERENCES r
(x,y), то условие WHERE вида t.a = r.x AND t.b = r.y не может выбрать больше одной стро-
ки из r для строки t. Ранее планировщик считал объединённые AND условия независимыми и
2391Замечания к выпуску
поэтому часто неправильно оценивал избирательность запроса. Теперь он сравнивает условия
WHERE с применимыми ограничениями внешнего ключа и получает более точные оценки.
E.21.3.1.6. VACUUM
• Предупреждение повторной очистки страниц, содержащих только замороженные кортежи
(Масахико Савада, Роберт Хаас, Андрес Фройнд)
Ранее очистка для предотвращения зацикливания должна была просматривать все страницы
таблицы, даже страницы, с которыми ничего не нужно делать. Теперь страницы, содержащие
только замороженные кортежи, обозначаются в карте видимости таблицы, и могут быть про-
пущены при очистке, даже когда она производится в целях предотвращения зацикливания
транзакций. Это должно значительно снизить стоимость обслуживания больших таблиц, со-
держащих в основном постоянные данные.
Если необходимо, при очистке можно принудительно включить обработку полностью заморо-
женных страниц, передав нововведённый параметр DISABLE_PAGE_SKIPPING. Это никогда не
нужно делать в обычных условиях, но при повреждении карты видимости это может быть по-
лезно.
• Предупреждение бесполезных попыток усечения кучи в процессе VACUUM (Джефф Джейнс,
Том Лейн)
Это изменение предотвращает исключительную блокировку таблицы в некоторых случаях, ко-
гда усечение таблицы невозможно. Прежде всего это полезно тем, что позволяет лишний раз
не отменять запросы на резервных серверах.
E.21.3.1.7. Общая производительность
• Возможность аннулирования старых снимков MVCC после настраиваемого промежутка вре-
мени (Кевин Гриттнер)
Обычно удалённые кортежи не могут быть ликвидированы физически при очистке, пока не
будет отработана последняя транзакция, в которой они могут быть видны. Транзакция, оста-
ющаяся открытой в течение долгого времени, таким образом может стать причиной значи-
тельного замусоривания таблицы, препятствуя освобождению места. Это средство позволяет
задать с помощью нового конфигурационного параметра old_snapshot_threshold ограничение
времени, в течение которого снимок MVCC будет гарантированно актуальным. По истечении
этого времени мёртвые кортежи могут быть удалены. Транзакция, использующая просрочен-
ный снимок, получит ошибку, если она попытается прочитать страницу, которая могла бы со-
держать такие данные.
• Игнорирование в GROUP BY столбцов, функционально зависящих от других (Дэвид Роули)
Если в предложение GROUP BY включаются все столбцы неотложенного первичного ключа, а
также другие столбцы той же таблицы, последние столбцы являются избыточными и могут
быть исключены из группировки. Во многих распространённых случаях это упрощает вычис-
ления.
• Возможность использования сканирования только индекса с частичным индексом, когда
предложение WHERE индекса обращается к не индексированным столбцам (Томаш Вондра, Кё-
таро Хоригути)
Например, индекс, определённый командой CREATE INDEX tidx_partial ON t(b) WHERE a &gt;
0, теперь может использоваться для сканирования только по индексу в запросе, в котором за-
даётся условие WHERE a &gt; 0 и никак больше не задействуется a. Ранее это использование не
допускалось, на основании того, что a не входит в число столбцов индекса.
• Выполнение записи в контрольных точках упорядоченным образом (Фабьен Коэльо, Андрес
Фройнд)
Ранее, в контрольных точках грязные страницы записывались в том порядке, в каком они рас-
полагались в общих буферах, то есть практически в случайном. Это влекло снижение произ-
2392Замечания к выпуску
водительности, особенно на вращающихся носителях. В результате данного изменения запись
в контрольных точках будет производиться по порядку файлов и номеров блоков, и будет сба-
лансирована по табличным пространствам.
• Там, где возможно, вызывать функцию отложенной записи в ядре после некоторого количе-
ства операций записи, во избежание накопления «грязных» данных в дисковых буферах ядра
(Фабьен Коэльо, Андрес Фройнд)
PostgreSQL записывает данные в дисковый кеш ядра, откуда они будут сброшены в физиче-
ское хранилище в нужное время. Многие операционные системы не очень эффективно управ-
ляют этим, позволяя накапливаться в памяти большим объёмам данным, которые затем при-
ходится сбрасывать на диск одномоментно, что приводит к большим задержкам при очеред-
ных операциях ввода/вывода до завершения сброса. Это изменение внесено, чтобы снять эту
проблему, явно запрашивая сброс данных через определённый настраиваемый интервал.
В Linux для этой цели применяется функция sync_file_range(), и так как она практически
безвредна, этот механизм задействуется в Linux по умолчанию. Возможность сброса буфера
доступна и на других платформах, где имеется функция msync() или posix_fadvise(), но эти
функции дают некоторые нежелательные побочные эффекты, поэтому на всех платформах
кроме Linux данный механизм по умолчанию отключён.
Этим поведением управляют новые конфигурационные параметры backend_flush_after,
bgwriter_flush_after, checkpoint_flush_after и wal_writer_flush_after.
• Увеличение производительности агрегатных функций в результате разделения вычислений
между несколькими агрегатами, если они имеют одинаковые аргументы и функции перехода
(Дэвид Роули)
Например, в запросе SELECT AVG(x), VARIANCE(x) FROM tab для строки может быть достаточ-
но одной операции для вычисления обоих агрегатов.
• Ускорение проверок видимости для недавно созданных кортежей путём проверки снимка те-
кущей транзакции, вместо pg_clog, для определения, должна ли исходная транзакция счи-
таться зафиксированной (Джефф Джейнс, Том Лейн)
• Допущение установки вспомогательных битов кортежей на более раннем этапе (Андрес
Фройнд)
• Увеличение производительности подготовленных транзакций с коротким временем жизни
(Стас Кельвич, Саймон Риггс, Паван Деоласи)
Информация о двухфазной фиксации теперь записывается только в WAL во время PREPARE
TRANSACTION и считывается назад из WAL во время COMMIT PREPARED, если это имеет место
вскоре. Отдельный файл состояния создаётся, только если ожидающая транзакция не фикси-
руется и не прерывается к моменту следующей контрольной точки.
• Увеличение скорости уничтожения контекста памяти (Ян Вик)
• Увеличение производительности владельцев ресурсов с большим количеством отслеживаемых
объектов (Александр Алексеев)
• Увеличение скорости функций вывода типов timestamp, time и date (Дэвид Роули, Андрес
Фройнд)
• Недопущение некоторых излишних отмен запросов на серверах горячего резерва при воспро-
изведении действий, требующих блокировок AccessExclusive (Джефф Джейнс)
• Расширение отношений на несколько блоков сразу при конкуренции за блокировку расшире-
ния отношения (Дилип Кумар)
Это улучшает масштабируемость и снижает уровень конфликтов.
• Увеличение числа буферов clog для лучшей масштабируемости (Амит Капила, Андрес
Фройнд)
2393Замечания к выпуску
• Ускорение вычисления выражений в PL/pgSQL за счёт постоянного хранения в памяти запи-
сей ParamListInfo для простых переменных (Том Лейн)
• Недопущение уменьшения значения SO_SNDBUF ниже значения по умолчанию в последних
версиях Windows (Чен Хуацзюнь)
• Отключение механизма update_process_title по умолчанию в Windows (Такаюки Цунакава)
В Windows издержки изменения заголовка процесса гораздо выше, чем на многих других
платформах, и само это изменение менее полезно, так как большинство пользователей
Windows не имеют утилит для наблюдения за заголовками процессов.
E.21.3.1.8. Наблюдение
• Добавление системного представления pg_stat_progress_vacuum для наблюдения за процес-
сом выполнения операций VACUUM (Амит Ланготе, Роберт Хаас, Винаяк Покале, Рахила Сьед)
• Добавление функций pg_control_system(), pg_control_checkpoint(), pg_control_recovery()
и pg_control_init(), выдающих поля pg_control в SQL (Джо Конвей, Микаэль Пакье)
• Добавление системного представления pg_config (Джо Конвей)
В этом представлении выводится та же информация, что выдаётся утилитой командной стро-
ки pg_config, а именно разнообразные конфигурационные параметры времени компиляции
PostgreSQL.
• Добавление столбца confirmed_flush_lsn в системное представление pg_replication_slots
(Марко Тииккая)
• Добавление системного представления pg_stat_wal_receiver с информацией о состоянии
процесса приёмника WAL на сервере горячего резерва (Микаэль Пакье)
• Добавление функции pg_blocking_pids() для надёжного определения, какие сеансы блокиру-
ют какие (Том Лейн)
Эта функция возвращает массив идентификаторов процессов всех сеансов, которые блокиру-
ют сеанс с заданным идентификатором. Ранее пользователи получали такую информацию,
образуя замкнутое соединение с представлением pg_locks. Однако сделать это сколь-нибудь
корректно слишком сложно, а с внедрением параллельных запросов старый подход стал пол-
ностью непрактичным, так как блокировки могут удерживаться или запрашиваться дочерни-
ми рабочими процессами, а не главным обслуживающим процессом сеанса.
• Добавление функции pg_current_xlog_flush_location() для вывода текущей позиции сбро-
шенной записи в журнале транзакции (Томаш Вондра)
• Добавление функции pg_notification_queue_usage(), показывающей, насколько заполнена
очередь NOTIFY (Брендан Юрд)
• Ограничение подробностей при выводе статистики использования контекстов памяти (Том
Лейн)
Информация об использовании памяти, выводимая в протокол главного сервера при нехватке
памяти, теперь включает итоговую статистику при большом числе контекстов памяти, вместо
одного объёмного отчёта. Также в неё теперь входит итоговая строка «Всего».
E.21.3.1.9. Аутентификация
• Добавление метода аутентификации BSD, позволяющего использовать для проверки подлин-
ности клиентов PostgreSQL системную службу аутентификации BSD (Мариса Эмерсон)
Аутентификация BSD в настоящее время поддерживается только в OpenBSD.
• Когда используется аутентификация PAM, через поле PAM_RHOST модулям PAM может выда-
ваться IP-адрес или имя компьютера клиента (Гжегож Сампольски)
• Добавление вывода в протокол сервера сообщений о дополнительных типах ошибок при про-
верке пароля (Том Лейн)
2394Замечания к выпуску
Теперь в случае любых ошибок, которые обычно могут возникать, в протокол должны выда-
ваться сообщения уровня ПОДРОБНО.
• Поддержка паролей RADIUS длиной до 128 символов (Марко Тииккая)
• Добавление новых параметров аутентификации SSPI compat_realm и upn_username, позволяю-
щих выбрать, как при проверке подлинности SSPI будут использоваться имена области и поль-
зователя (NetBIOS или Kerberos) (Кристиан Ульрих)
E.21.3.1.10. Настройка сервера
• Возможность автоматического завершения сеансов, которые находятся в состоянии простоя в
транзакции слишком долго (Вик Фиринг)
Данное поведение настраивается новым конфигурационным параметром
idle_in_transaction_session_timeout. Это помогает бороться с забытыми транзакциями, которые
могут удерживать блокировки или мешать производить очистку в течение длительного време-
ни.
• Увеличение максимально допустимого значения checkpoint_timeout до 24 часов (Саймон
Риггс)
• Возможность устанавливать effective_io_concurrency для табличного пространства; это по-
лезно в случаях, когда различные табличные пространства имеют разные характеристики
ввода/вывода (Жульен Рухо)
• Добавление в log_line_prefix спецкода %n для вывода текущего времени в формате Unix, с мил-
лисекундами (Томаш Вондра, Джефф Дэвис)
• Добавление конфигурационных параметров syslog_sequence_numbers и syslog_split_messages
для дополнительной манипуляции форматом сообщений при выводе их в syslog (Питер Эйзен-
траут)
• Объединение значений archive и hot_standby конфигурационного параметра wal_level в од-
ном новом значении replica (Питер Эйзентраут)
Различать эти варианты больше не имеет смысла, и их слияние является шагом вперёд к за-
планированному упрощению организации репликации. Старые варианты по-прежнему прини-
маются, но внутри преобразуются к replica.
• Добавление в configure параметра --with-systemd, позволяющего вызывать sd_notify() при
запуске и остановке сервера (Питер Эйзентраут)
Это позволяет использовать единицы служб systemd типа notify, что значительно упрощает
управление PostgreSQL в окружении systemd.
• Теперь к файлу SSL-ключа сервера может быть разрешён доступ группы на чтение, если он
принадлежит пользователю root (Кристоф Берг)
Ранее мы настаивали на том, чтобы файл ключа принадлежал пользователю, запускающему
сервер PostgreSQL, но это оказалось неудобным в некоторых системах (например, в Debian),
в которых организовано централизованное управление сертификатами. Поэтому стоит допу-
стить случай, когда файл принадлежит root, а группа имеет доступ на чтение. И в этом слу-
чае администратор отвечает за то, чтобы в эту группу не входили недоверенные пользовате-
ли.
E.21.3.1.11. Надёжность
• Принудительное завершение обслуживающих процессов в случае отключения главного про-
цесса (Раджив Растоги, Роберт Хаас)
При нормальных обстоятельствах главный процесс всегда должен жить дольше своих дочер-
них процессов. Если же он по какой-то причине умирает, процессы, обслуживающие клиен-
тов, принудительно завершаются с ошибкой. Ранее работающие процессы продолжали выпол-
няться до отключения клиента; но это было небезопасно и неэффективно. Это также не дава-
2395Замечания к выпуску
ло запустить новый управляющий процесс до завершения последнего из старых обслуживаю-
щих процессов. Теперь обслуживающие процессы будут проверять, жив ли главный процесс,
ожидая ввода/вывода от клиента, так что они завершатся не мгновенно, но это должно про-
изойти не позже завершения текущего запроса.
• Проверка конфликтов сериализуемости перед тем, как будет выдана ошибка нарушения огра-
ничений (Томас Мунро)
В транзакциях сериализуемого уровня изоляции желательно, чтобы ошибка, вызванная па-
раллельными транзакциями, заявлялась как ошибка сериализации, что скажет приложению,
что попытка повторить то же действие может быть успешной. К сожалению, это не будет на-
дёжно работать при дублировании ключа при параллельном его добавлении. В результате это-
го изменения такая ошибка будет выдаваться как ошибка сериализации, если приложение яв-
но проверяет присутствие конфликтующего ключа (и не находит его) до этого в транзакции.
• Сообщения аннулирования должны записываться в WAL, даже если они выдаются транзакци-
ей, которой не назначен XID (Андрес Фройнд)
Это решает проблемы в особых случаях, когда транзакции на резервных серверах не замечали
некоторые изменения, например, создание индексов.
• Предупреждение одновременной отработки несколькими процессами очереди изменений в
индексе GIN (Фёдор Сигаев, Джефф Джейнс)
Это допускалось намеренно, но вызывало условия гонки, при которых процедура очистки про-
пускала записи в индексе, которые нужно было удалить.
E.21.3.2. Репликация и восстановление
• Возможность при синхронной репликации задействовать одновременно несколько синхрон-
ных резервных серверов (раньше поддерживался только один) (Масахико Савада, Бина Эмер-
сон, Микаэль Пакье, Фудзии Масао, Кётаро Хоригути)
Число резервных серверов, которые должны подтвердить фиксацию, прежде чем
она будет считаться завершённой, теперь устанавливается в значении параметра
synchronous_standby_names.
• Добавление нового значения remote_apply для конфигурационного параметра
synchronous_commit (Томас Мунро)
В этом режиме главный сервер ждёт, пока транзакция не будет применена на резервном, а не
просто сохранена на диске. Это значит, что можно рассчитывать, что транзакция, запущен-
ная на резервном сервере, будет видеть все изменения, подтверждённые на главном.
• Усовершенствование протокола репликации и добавление параметра в функцию
pg_create_physical_replication_slot() для немедленного резервирования WAL при созда-
нии слота репликации (Гуржит Сингх, Микаэль Пакье)
Это позволяет при создании слота репликации гарантировать, что будут доступны все файлы
WAL, нужные для базовой копии.
• Добавление ключа --slot для pg_basebackup (Питер Эйзентраут)
Это позволяет pg_basebackup использовать слот репликации, созданный для трансляции WAL.
Выбрав тот же слот для обычной потоковой репликации после создания базовой резервной ко-
пии, можно запустить новый резервный сервер, не прерывая приём потока.
• Доработка функций pg_start_backup() и pg_stop_backup() для поддержки немонопольного
резервного копирования (Магнус Хагандер)
E.21.3.3. Запросы
• Функции, возвращающие наборы кортежей, теперь могут возвращать просто NULL (Эндрю
Гирт, Том Лейн)
2396Замечания к выпуску
В контексте SELECT FROM function(...) функция, возвращающая набор составных значений,
не могла вернуть обычное значение NULL в составе набора. Теперь это допускается и такой ре-
зультат воспринимается как строка с полями NULL. Это позволяет избежать ошибок в особых
случаях, например, при разворачивании массива составных значений.
• Полная поддержка указаний индексов массивов и выбора полей в списке целевых столбцов
команды INSERT с несколькими строками VALUES (Том Лейн)
Ранее в таких ситуациях возникала ошибка, если один и тот же целевой столбец упоминался
более одного раза, например так: INSERT INTO tab (x[1], x[2]) VALUES (...).
• Когда уместно, вычисление выходных выражений SELECT откладывается и производится после
сортировки ORDER BY (Константин Книжник)
В результате этого изменения изменчивые или дорогостоящие функции в выходном спис-
ке выполняются в порядке, установленном предложением ORDER BY, и не будут вычисляться
лишний раз, когда присутствует предложение LIMIT. Ранее эта оптимизация имела место, ко-
гда сортировка выполнялась при сканировании индекса или перед соединением слиянием, но
не когда она производилась на верхнем уровне запроса.
• Расширение счётчиков, хранящих число обработанных кортежей, до 64 бит (Андреас Шерба-
ум)
В результате этого изменения в метках команд, например SELECT, теперь будут корректно вы-
даваться количества кортежей, превышающие 4 миллиарда. Это также распространяется на
команду GET DIAGNOSTICS ... ROW_COUNT в PL/pgSQL.
• Уход от преобразования некоторых кодировок через кодировку MULE_INTERNAL (Том Лейн)
Ранее преобразования кириллических и центральноевропейских однобайтовых кодировок за-
частую выполнялись путём перевода в связанную схему MULE_INTERNAL, и только затем в целе-
вую кодировку. Помимо того, что это неэффективно, это означает, что при обнаружении непе-
реводимого символа будет выдано некорректное сообщение об ошибке преобразования в/из
кодировки MULE_INTERNAL, а не кодировки, видимой пользователю.
• Допускать удалённое соединение сторонних таблиц, только если к ним обращается одна и та
же роль (Шигеру Ханада, Ашутош Бапат, Эцуро Фудзита)
Ранее инфраструктура вынесения соединений наружу доверяла заботу о безопасности цели-
ком обёрткам сторонних данных, но при этом в обёртке слишком легко могли непреднамерен-
но образовываться неочевидные уязвимости. Поэтому решено было в коде ядра определять,
какая роль обращается к каждой таблице, и пытаться выносить соединение наружу, только
если это одна роль для всех задействованных отношений.
E.21.3.4. Служебные команды
• Поддержка в COPY копирования вывода запроса INSERT/UPDATE/DELETE ... RETURNING (Марко Ти-
иккая)
Ранее для этого приходилось создавать промежуточные CTE (общие табличные выражения).
• Введение команды ALTER объект DEPENDS ON EXTENSION (Абхиджит Менон-Сен)
Эта команда позволяет пометить объект базы данных как зависимый от расширения, чтобы он
автоматически ликвидировался при удалении расширения (без явного указания CASCADE). Но
при этом такой объект не будет частью расширения и поэтому pg_dump будет выгружать его
отдельно.
• Команда ALTER объект SET SCHEMA теперь не будет делать ничего, если объект уже относится
к заданной схеме, вместо того, чтобы выдавать ошибку, что имело место раньше для большин-
ства типов объектов (Марти Раудсепп)
2397Замечания к выпуску
• Добавление в ALTER OPERATOR параметров, позволяющих изменять функции оценки избира-
тельности, связанные с существующим оператором (Юрий Журавлёв)
• Добавление указания IF NOT EXISTS в команду ALTER TABLE ADD COLUMN (Фабрицио де Ройес
Мелло)
• Снижение уровня блокировок, запрашиваемых командой ALTER TABLE при установке фактора
заполнения и параметров отношения, связанных с автоочисткой (Фабрицио де Ройес Мелло,
Саймон Риггс)
• Введение команды CREATE ACCESS METHOD, позволяющей расширениям создавать методы до-
ступа индексов (Александр Коротков, Петр Желинек)
• Добавление указания CASCADE для команды CREATE EXTENSION, позволяющего автоматически
устанавливать расширения, от которых зависит создаваемое (Петр Желинек)
• Команда CREATE TABLE ... LIKE должна включать столбец OID, если он есть в какой-либо из
исходных таблиц (Брюс Момджян)
• Если ограничение CHECK объявлено как NOT VALID (непроверенное) в команде создания табли-
цы, оно должно автоматически помечаться как проверенное (Амит Ланготе, Амул Сул)
Это безопасно, так как в таблице ещё нет строк, и соответствует давно принятому поведению
ограничений FOREIGN KEY.
• Исправлена команда DROP OPERATOR; она должна очищать ссылки на удаляемый оператор
pg_operator.oprcom и pg_operator.oprnegate (Рома Соколов)
Ранее эти ссылки оставлялись как есть, что было чревато проблемами в довольно маловероят-
ных случаях повторного использования OID удалённого оператора другим оператором.
• Один и тот же подплан не должен выдаваться дважды в выводе EXPLAIN (Том Лейн)
В некоторых случаях, обычно с узлами SubPlan в условиях индексов, команда EXPLAIN выводи-
ла данные одного и того же подплана дважды.
• Запрет создания индексов по системным столбцам, за исключением OID (Дэвид Роули)
Такие индексы никогда не считались поддерживаемыми и провоцировали некорректное пове-
дение, так как система могла менять значения системных столбцов, не обновляя индексы. Од-
нако ранее отсутствовали проверки, которые бы мешали их создавать.
E.21.3.5. Управление разрешениями
• Использование системы прав для управления доступом к важным функциям (Стивен Фрост)
Ранее многие требующие ограниченного доступа функции содержали жёстко зашитые про-
верки, которые выдавали ошибки, если эти функции пытался выполнять не суперпользова-
тель. Это вынуждало применять роли суперпользователей для выполнения и некоторых за-
урядных задач. Теперь эти проверки ушли, вместо этого initdb отзывает у роли public право на
выполнение (EXECUTE) этих функций. Это позволяет на местах дать право использовать их до-
веренным ролям, которым не нужны все полномочия суперпользователей.
• Создание нескольких встроенных ролей, используя которые можно давать доступ к операци-
ям, ранее доступным только суперпользователям (Стивен Фрост)
В настоящее время есть только одна такая роль, pg_signal_backend, но в дальнейшем ожида-
ется добавление других ролей.
E.21.3.6. Типы данных
• Усовершенствование полнотекстового поиска; поддержка поиска фраз, то есть лексем, встре-
чающихся рядом в определённом порядке, либо с заданным расстоянием между ними (Фёдор
Сигаев, Олег Бартунов, Дмитрий Иванов)
2398Замечания к выпуску
Запрос поиска фразы может быть записан в значении tsquery с использованием новых опе-
раторов &lt;-&gt; и <N>. Первая запись означает, что лексемы до и после неё должны находиться
рядом и в заданном порядке. Вторая запись означает, что они могут быть разделены ровно N
лексемами.
• Возможность записать указание среза массива без одной или двух границ, например,
array_col[3:] (Юрий Журавлёв)
Опущенные границы воспринимаются как значения верхнего или нижнего предела соответ-
ствующей позиции в массиве. Это позволяет упростить запись срезов во многих распростра-
нённых ситуациях.
• Более аккуратное обращение с датами и временем за пределами допустимого диапазона (Ви-
талий Буровой)
Это изменение предотвращает неожиданные ошибки выхода за пределы диапазона для значе-
ний дата/время с часовым поясом, очень близких к предельным значениям реализации. Ранее
«одно и то же» значение могло быть принято или нет, в зависимости от значения параметра
timezone (часового пояса), и как следствие, ранее выгруженные данные могли не загружаться
из-за значений, который до этого считались приемлемыми. Теперь границы проверяются по
UTC, а не по местному часовому поясу, так что эта проверка не зависит от значения timezone.
Также PostgreSQL теперь более аккуратно выявляет переполнение при вычислениях новых
значений даты или даты/времени, таких как date + integer.
• Обеспечена согласованная обработка значений infinity (бесконечность) и NaN (не число) в
компонентах геометрических типов данных при вводе и выводе (Том Лейн)
Такие значения теперь всегда будут выводиться как они выводились бы в обычном столбце
float8, и таким же образом будут вводиться. Предыдущее поведение зависело от платформы.
• Добавление в словарь ispell поддержки дополнительных языков и современного формата
файлов Hunspell (Артур Закиров)
• Реализация условий с просмотром назад в регулярных выражениях (Том Лейн)
Условие с просмотром назад похоже на условие с просмотром вперёд тем, что оно не вбира-
ет текст; оно проверяет наличие (или отсутствие) соответствия, заканчивающегося в текущей
позиции в строке, а не начинающегося с текущей позиции. Это поддерживают и многие дру-
гие исполнители регулярных выражений.
• Если в регулярных выражениях предположительно трёхсимвольное восьмеричное значение
\nnn превосходит 377 (255 в десятичном виде), должно считываться только двухсимвольное
восьмеричное значение (Том Лейн)
Это поведение соответствует тому, что наблюдается в текущих версиях Tcl.
• Добавление операторов для идентификаторов транзакций xid &lt;&gt; xid и xid &lt;&gt; int4, для согла-
сованности с соответствующими операторами равенства (Микаэль Пакье)
E.21.3.7. Функции
• Добавление функции jsonb_insert() для вставки нового элемента в массив jsonb или ранее
не существовавшего ключа в объект jsonb (Дмитрий Долгов)
• Увеличение точности функций ln(), log(), exp() и pow() для типа numeric (Дин Рашид)
• Добавление функции scale(numeric), выдающей масштаб значения numeric (Марко Тииккая)
• Добавление тригонометрических функций, работающих с градусами (Дин Рашид)
Например, sind() воспринимает свой аргумент в градусах, тогда как sin() — в радианах. Эти
функции до некоторой степени выдают точный результат для аргументов, для которых его
можно ожидать, например, sind(30) = 0.5.
2399Замечания к выпуску
• Обработка аргументов infinity и NaN в тригонометрических функциях по стандарту POSIX
(Дин Рашид)
Стандарт POSIX говорит, что эти функции должны возвращать NaN для аргумента NaN и выда-
вать ошибку для любых значений вне допустимого диапазона (включая infinity). Ранее они
вели себя по-разному на разных платформах.
• Функция to_timestamp(float8) теперь преобразует infinity (бесконечность) в числе с плава-
ющей точкой в infinity в дате (Виталий Буровой)
Ранее она просто выдавала ошибку для аргумента бесконечность.
• Добавление новых функций для значений tsvector (Стас Кельвич)
Это функции ts_delete(), ts_filter(), unnest(), tsvector_to_array(), array_to_tsvector()
и вариация setweight(), устанавливающая вес только для заданных лексем.
• Функции ts_stat() и tsvector_update_trigger() теперь принимают значения, имеющие не
только конкретный ожидаемый тип аргумента, но и тип, двоично совместимый с ним; напри-
мер, они могут принимать citext там, где ожидается text (Фёдор Сигаев)
• Добавление функций num_nulls() и num_nonnulls() с переменным числом аргументов, воз-
вращающих число переданных им значений NULL и значений, отличных от NULL (Марко Ти-
иккая)
Например, их можно использовать в ограничении CHECK(num_nonnulls(a,b,c) = 1), которое
требует, чтобы ровно одно из значений a,b,c было отлично от NULL. Эти функции также могут
применяться для подсчёта элементов NULL и элементов, отличных от NULL, в массиве.
• Добавление функции parse_ident() для разбиения полного (и возможно заключённого в ка-
вычки) идентификатора SQL на компоненты (Павел Стехуле)
• Функция to_number() воспринимает код формата V как признак деления числа на 10 в степе-
ни, заданной цифрами после V (Брюс Момджян)
Таким образом поведение этой функции оказывается обратным к to_char().
• Функции to_reg*() теперь принимают тип text, а не cstring (Пётр Коробейников)
Это избавляет от необходимости записывать явное приведение в большинстве случаев, когда
аргумент не является простой строковой константой.
• Добавление функции pg_size_bytes() для преобразования понятных человеку объёмов в чис-
ла (Павел Стехуле, Виталий Буровой, Дин Рашид)
Эта функция преобразует строки, в частности, те, что выдаёт pg_size_pretty(), в количество
байтов. Использовать её можно, например, так: SELECT oid::regclass FROM pg_class WHERE
pg_total_relation_size(oid) &gt; pg_size_bytes('10 GB').
• Формат вывода отрицательных чисел в pg_size_pretty() не должен отличаться от положи-
тельных (Адриан фон ден Дриш)
Ранее отрицательные числа никогда не сокращались и всегда выводились в байтах.
• Добавление необязательного аргумента missing_ok в функцию current_setting() (Дэвид
Кристенсен)
Это позволяет избежать ошибки при передаче неизвестного имени параметра; вместо ошибки
будет выдан NULL.
• Модификация ряда функций просмотра каталога, чтобы они возвращали NULL при недопусти-
мых входных данных (Микаэль Пакье)
Функция pg_get_viewdef() теперь возвращает NULL, получая неправильный OID представле-
ния; также и другие функции будут возвращать NULL при некорректных параметрах. Ранее в
2400Замечания к выпуску
таких случаях обычно возникали ошибки типа «cache lookup failed» (ошибка поиска в кеше), с
которыми не должны сталкиваться пользователи.
• Избавление функции pg_replication_origin_xact_reset() от аргументов (Фудзии Масао)
В документации говорится, что у неё нет аргументов, и коду функции на C никакие аргументы
не нужны, но в записи в pg_proc по ошибке указаны два аргумента.
E.21.3.8. Языки программирования на стороне сервера
• Выявление некорректных операторов CONTINUE и EXIT в PL/pgSQL при компиляции функции, а
не во время выполнения (Джим Нэсби)
• Расширение функций, выдающих ошибки и сообщения в PL/Python, чтобы они могли переда-
вать помимо основного сообщения и дополнительные поля (Павел Стехуле)
• Исправление механизма вызова функций PL/Python, позволяющее производить рекурсив-
ные вызовы этих функций через SPI, и корректировка поведения в ситуации, когда несколько
функций на PL/Python, возвращающих множества, вызываются в одном запросе (Алексей Гри-
щенко, Том Лейн)
• Ликвидация утечек памяти в пределах длительности сеанса в PL/Python (Хейкки Линнакангас,
Харибабу Комми, Том Лейн)
• Модернизация PL/Tcl, переход от передачи простых строк к «объектному» API Tcl (Джим Нэс-
би, Карл Лехенбауэр)
Это может значительно увеличить производительность в некоторых случаях. Заметьте, что
для PL/Tcl теперь требуется версия Tcl 8.4 или новее.
• В PL/Tcl при возникновении ошибок базы данных теперь возвращается дополнительная инфор-
мация в глобальной переменной Tcl errorCode (Джим Нэсби, Том Лейн)
Это реализовано в соответствии с принятым Tcl соглашением о выдаче дополнительных сведе-
ний об ошибке.
• Исправление логики преобразования кодировки в PL/Tcl; строки в кодировке базы данных
должны преобразовываться в UTF-8 (кодировку, ожидаемую в Tcl) и обратно (Том Лейн)
Ранее строки передавались без преобразования, что приводило к проблемам с символами вне
ASCII, когда кодировка базы была не UTF-8.
E.21.3.9. Клиентские интерфейсы
• Добавление нелокализуемой версии поля серьёзности в сообщения об ошибках и уведомления
(Том Лейн)
Благодаря этому изменению клиентский код может определить уровень серьёзности ошибки
или замечания, не имея дела с локализованными вариантами строки важности.
• Введение в libpq средства подавления поля КОНТЕКСТ в сообщениях об ошибках, либо для всех,
либо только для информационных сообщений (Павел Стехуле)
По умолчанию PQerrorMessage() теперь выводит КОНТЕКСТ только для ошибок. Для корректи-
ровки её поведения предназначена новая функция PQsetErrorContextVisibility().
• Добавление в libpq возможности переформировать сообщение об ошибке с другим уровнем
важности (Алексей Шульгин)
Данную возможность реализует новая функция PQresultVerboseErrorMessage(). Это поддер-
живается новой командой psql \errverbose и может быть также полезно для других клиентов.
• Усовершенствование функции PQhost() в libpq, чтобы она возвращала полезную информацию
при подключении к сокету Unix по умолчанию (Том Лейн)
2401Замечания к выпуску
Ранее она возвращала NULL в отсутствие явного указания адреса узла; теперь она возвращает
путь каталога сокетов по умолчанию.
• Исправление лексического анализатора ecpg, чтобы он корректно обрабатывал разрывы
строк в комментариях, начинающихся в строках с директивами препроцессора (Михаэль Мес-
кес)
E.21.3.10. Клиентские приложения
• Добавление флага --strict-names в pg_dump и pg_restore (Павел Стехуле)
С этим флагом программа выдаст ошибку, не найдя объектов, заданных параметрами -t или -
n, а не просто не будет ничего делать.
• В pg_dump реализована выгрузка локально изменённых назначений прав на системные объек-
ты (Стивен Фрост)
Хотя суперпользователь всегда мог изменить назначения прав для встроенных или создан-
ных расширениями объектов, после выгрузки/загрузки базы эти изменения терялись. Теперь
pg_dump распознаёт такие назначения и выгружает их. (Однако это работает только при вы-
грузке данных с сервера 9.6 или новее.)
• Теперь pg_dump может выгружать объекты, не принадлежащие расширениям, но находящие-
ся в принадлежащих им схемах (Мартин Маркиз)
Ранее такие объекты игнорировались, так как ошибочно считались принадлежащими расши-
рению, которому принадлежала их схема.
• В выводе pg_dump добавлено имя таблицы в метки тех объектов, которые являются уникаль-
ными только в рамках таблицы (как, например, триггеры) (Питер Эйзентраут)
• Поддержка нескольких параметров командной строки -c и -f (Павел Стехуле, Каталин Якоб)
Эти операции выполняются в том порядке, в каком передаются параметры, а затем psql завер-
шается.
• Добавление команды \crosstabview, выводящей результаты запроса в виде перекрёстной таб-
лицы (Даниэль Верите)
В этом виде значения из одного столбца результата запроса располагаются в клетках табли-
цы, заголовки строк и столбцов которой поступают из других столбцов результата.
• Добавление команды \errverbose, выводящей последнюю ошибку сервера с максимальной де-
тализацией (Александр Шульгин)
Этим удобно пользоваться при возникновении неожиданной ошибки — больше не нужно кор-
ректировать переменную VERBOSITY и повторно воспроизводить проблему, чтобы увидеть поля
ошибки, которые не показываются по умолчанию.
• Добавление команд \ev и \sv для редактирования и просмотра определений представлений
(Пётр Коробейников)
Эти команды соответствуют существующим командам \ef и \sf для функций.
• Добавление команды \gexec, выполняющей запрос и передающей полученный результат на
выполнение как тело нового запроса (Кори Хинкер)
• Команда \pset C строка должна устанавливать заголовок таблицы, как это делает \C строка
(Брюс Момджян)
• В режиме автоматического расширения (\pset expanded auto) не нужно применять широкий
формат для запросов результата с всего одним столбцом (Андреас Карлссон, Роберт Хаас)
• Улучшение заголовков, выводимых командой \watch (Микаэль Пакье, Том Лейн)
2402Замечания к выпуску
Добавление названия, если оно было задано командой \pset title, и сокращение предуста-
новленной части заголовка до время (каждые N с). При этом формат времени теперь опреде-
ляется локалью из окружения psql.
• Усовершенствование логики дополнения табуляцией, чтобы в рассмотрение принимался весь
введённый запрос, а не только текущая строка (Том Лейн)
Ранее разбиение команды на несколько строк ломало все правила дополнения табуляцией, ко-
торым нужно было видеть слова в предыдущих строках.
• Многочисленные улучшения механизма завершения табуляцией (Питер Эйзентраут, Вик Фи-
ринг, Кевин Гриттнер, Кётаро Хоригути, Джефф Джейнс, Андреас Карлссон, Фудзии Масао,
Томас Мунро, Масахико Савада, Павел Стехуле)
• Добавление в формат приглашения PROMPT спецкода %p для отображения ID текущего обслу-
живающего процесса (Жульен Рухо)
• Введение средства подавления поля КОНТЕКСТ в сообщения об ошибках, либо для всех, либо
только для информационных сообщений (Павел Стехуле)
Теперь по умолчанию КОНТЕКСТ выводится только для ошибок. И это можно изменить с помо-
щью специальной переменной SHOW_CONTEXT.
• Добавление в вывод \df+ прав доступа к функции и характеристик распараллеливания (Мика-
эль Пакье)
• Команды SQL в pgbench теперь завершаются точкой с запятой, а не переводом строки (Кётаро
Хоригути, Том Лейн)
Благодаря этому изменению, команды SQL в скриптах могут располагаться на нескольких
строках. Существующие нестандартные скрипты придётся подредактировать и добавить точку
с запятой в конце каждой строки, если это не было сделано ранее. (Это не помешает исполь-
зовать тот же скрипт со старыми версиями pgbench.)
• Поддержка арифметики с плавающей точкой, а также некоторых встроенных функций, в вы-
ражениях команд с обратной косой чертой (Фабьен Коэльо)
• Замена \setrandom встроенными функциями (Фабьен Коэльо)
Новые встроенные функции random(), random_exponential() и random_gaussian() делают
то же, что и \setrandom, но проще в использовании, так как их можно задействовать в бо-
лее сложных выражениях. Так как в результате этого добавления команда \setrandom стала
ненужной, она была ликвидирована.
• Возможность многократно запускать и встроенные, а не только нестандартные скрипты (Фаб-
ьен Коэльо)
Для этого введён ключ -b, работающий подобно ключу -f для нестандартных скриптов.
• Возможность изменения вероятностей выбора (весов) скриптов (Фабьен Коэльо)
Когда указывается несколько скриптов, какой из них будет выполняться, для каждой транзак-
ции pgbench выбирается случайным образом. Ранее выбор каждого было равновероятен, но
теперь для разных скриптов можно задать разные вероятности выбора.
• Сбор статистики по каждому скрипту при запуске нескольких скриптов (Фабьен Коэльо)
Это добавляет промежуточный уровень детализации к существующим двум — глобальной ста-
тистике и статистике в разрезе команд.
• Добавление параметра --progress-timestamp для вывода текущего времени эпохи Unix вме-
сто времени с момента запуска теста (Фабьен Коэльо)
• Возможность устанавливать число клиентских соединений (-c), не кратное количеству пото-
ков (-j) (Фабьен Коэльо)
2403Замечания к выпуску
• Когда задаётся параметр -T, завершать работу именно по истечении заданного времени (Фаб-
ьен Коэльо)
Ранее, если выбиралась низкая частота транзакций, программа pgbench могла ждать значи-
тельно дольше заданного времени.
E.21.3.11. Серверные приложения
• Улучшение вывода ошибок в initdb на стадии после начальной инициализации (Том Лейн)
Ранее при возникновении ошибок в качестве «ошибочного запроса» выдавался весь входной
файл; теперь выдаётся только текущий запрос. Чтобы получить желаемое поведение, теперь
запросы во входных файлах initdb нужно разделять пустыми строками.
• Ускорение initdb благодаря использованию только одного серверного сеанса для всех опера-
ций после инициализации (Том Лейн)
• Усовершенствование программы pg_rewind, чтобы она могла работать при изменении целевой
линии времени (Александр Коротков)
Это позволяет, например, перемотать повышенный резервный сервер к какому-то предыдуще-
му состоянию на линии времени прежнего главного сервера.
E.21.3.12. Исходный код
• Удаление устаревших функций heap_formtuple/heap_modifytuple/heap_deformtuple (Питер
Геохеган)
• Добавление макросов, призванных сделать вызовы AllocSetContextCreate() проще и безопас-
нее (Том Лейн)
Теперь указание индивидуальных параметров размера для контекста памяти считается
устаревшим в пользу использования одного из новых макросов ALLOCSET_DEFAULT_SIZES,
ALLOCSET_SMALL_SIZES или ALLOCSET_START_SMALL_SIZES. Однако существующий код будет ра-
ботать по-прежнему.
• Безусловное использование функций static inline в заголовочных файлах (Андрес Фройнд)
Это может привести к предупреждениям или генерации лишнего кода с очень старыми ком-
пиляторами, но упрощение записи стоит того.
• Усовершенствование инфраструктуры тестирования TAP (Микаэль Пакье, Крейг Рингер, Аль-
варо Эррера, Стивен Фрост)
А именно, теперь эта инфраструктура позволяет тестировать сценарии восстановления.
• Когда используется trace_lwlocks, идентифицировать отдельные блокировки по имени (Ро-
берт Хаас)
• Улучшение инфраструктуры psql, обеспечивающей дополнение кода табуляцией (Томас Мун-
ро, Микаэль Пакье)
Правила дополнения табуляцией стали компактнее и писать их стало легче.
• Закрепление системного каталога pg_shseclabel в кеше, чтобы он был доступен при проверке
подлинности в момент подключения (Адам Брайтвелл)
Код ядра не использует этот каталог для аутентификации, но к нему могут обращаться расши-
рения.
• Реструктуризация API методов доступа индексов с целью в большей степени скрыть его на
уровне C (Александр Коротков, Эндрю Гирт)
В результате этого изменения API индексных методов становится больше похожим на API,
принятый для обёрток сторонних данных и генераторов выборки из таблицы. Это упрощает
код C и должно сделать более приемлемой реализацию методов доступа индексов в устанав-
2404Замечания к выпуску
ливаемых расширениях. Данное изменение позволило удалить из системного каталога pg_am
многие столбцы. Чтобы SQL-запросы могли анализировать свойства МД индексов, которые
раньше были доступны в pg_am, были добавлены новые функции проверки свойств.
• Добавление системного каталога pg_init_privs для записи изначальных прав, назначаемых
для объектов, которые создаёт initdb и расширения (Стивен Фрост)
Благодаря этой инфраструктуре pg_dump может выгружать изменённые в данной инсталля-
ции назначения прав на системные объекты. Ранее такие назначения терялись после выгруз-
ки/загрузки, но теперь они сохраняются.
• Изменение способа запрашивания дополнительных лёгких блокировок расширениями (Амит
Капила, Роберт Хаас)
Функция RequestAddinLWLocks() была удалена, а ей на смену пришла
RequestNamedLWLockTranche(). С новым подходом будет проще идентифицировать лёгкие бло-
кировки и сложнее допустить ошибку.
• Усовершенствование тестировщика изоляции, чтобы в состоянии ожидания могли находиться
сразу несколько сеансов; это позволяет тестировать сценарии взаимоблокировок (Роберт Ха-
ас)
• Введение расширяемых типов узлов (КайГай Кохэй)
В результате этого изменения обёртки сторонних данных или провайдеры нестандартного
сканирования могут сохранить данные в дереве плана в более удобном формате, чем было воз-
можно ранее.
• Планировщик должен рассматривать дальнейшие шаги после сканирования/объединения, ге-
нерируя и сравнивая структуры Path; это позволяет упростить большой объём несистематиче-
ской логики (Том Лейн)
Сегодня это изменение практически никак не проявляется для конечных пользователей, но в
будущем оно позволит реализовать множество усовершенствований планировщика, которые
не вписывались в старую структуру кода.
• Поддержка частичного агрегирования (Дэвид Роули, Саймон Риггс)
Это изменение позволяет разделить вычисление агрегатной функции на части, например,
чтобы параллельные рабочие процессы могли вычислять её совместно. В будущем это может
позволить производить агрегатное вычисление по локальным и удалённым данным частично
на удалённой стороне.
• Внедрение универсального механизма для отслеживания процесса выполнения команд (Вина-
як Покале, Рахила Сьед, Амит Ланготе, Роберт Хаас)
• Выделение из psql лексического анализатора flex, чтобы его можно было использовать в дру-
гих клиентских программах (Том Лейн, Кётаро Хоригути)
Это избавляет от необходимости дублировать код для программ, которым нужно достаточно
хорошо понимать команды SQL, чтобы распознавать границы команд. Полноценно реализо-
вать это оказывается гораздо сложнее, чем хотелось бы, и на данный момент только psql из
всех поддерживаемых клиентских программ делает это на самом деле правильно.
Для размещения этого и другого кода, который будут совместно использовать наши клиент-
ские программы, был создан новый подкаталог src/fe_utils/. Раньше для такого совмест-
ного использования приходилось создавать символические ссылки или копировать исходные
файлы во время сборки, что было некрасиво и требовало двойной компиляции.
• Внедрение нового API WaitEventSet для эффективного ожидания набора событий, которые
обычно не меняются от одного цикла ожидания к другому (Андрес Фройнд, Амит Капила)
• Добавление унифицированного интерфейса для добавления записей в WAL (Александр Корот-
ков, Петр Желинек, Маркус Нуллмейер)
2405Замечания к выпуску
Благодаря этому изменению, расширения могут записывать в WAL изменения страниц со
стандартной структурой. При этом проблема воспроизведения WAL без доступа к этому рас-
ширению решается универсальным кодом воспроизведения. Это позволяет расширениям ре-
ализовывать, например, свои методы доступа индексов и рассчитывать на то, что WAL будет
поддерживать их.
• Поддержка произвольных сообщений WAL при логическом декодировании (Петр Желинек,
Андрес Фройнд)
Этот механизм позволяет расширениям вставлять в поток WAL произвольные данные, кото-
рые могут быть прочитаны модулями логического декодирования, но не связаны с физиче-
ским восстановлением данных.
• Реализация возможности для классов операторов SP-GiST сохранять произвольное «переходя-
щее значение» при проходе по индексу (Александр Лебедев, Фёдор Сигаев)
Это может быть нечто вроде «восстановленного значения», но могут быть и произвольные
данные, не обязательно того же типа, что индексируемый столбец.
• Введение уровня сообщений LOG_SERVER_ONLY для ereport() (Дэвид Стил)
Этот уровень обрабатывается как LOG, за исключением того, что такое сообщение никогда не
передаётся клиенту. Он предназначен для организации аудита и подобных приложений.
• Реализация в Makefile цели для сборки всех генерируемых заголовочных файлов (Микаэль
Пакье, Том Лейн)
Теперь, чтобы убедиться, что все генерируемые серверные заголовочные файлы актуальны,
можно выполнить сборку цели submake-generated-headers. Это полезно в подкаталогах, кото-
рые могут собираться «отдельно».
• Поддержка OpenSSL 1.1.0 (Андреас Карлссон, Хейкки Линнакангас)
E.21.3.13. Дополнительные модули
• Добавление параметра конфигурации auto_explain.sample_rate, устанавливающего для
contrib/auto_explain процент запросов, подлежащих анализу (Крейг Рингер, Жульен Рухо)
Это позволяет снизить издержки при большой нагрузке и при этом всё же получать полезную
общую информацию.
• Добавление модуля contrib/bloom, реализующего метод доступа индекса на основе фильтра
Блума (Фёдор Сигаев, Александр Коротков)
Это в первую очередь пилотная реализация метода доступа вне ядра, но этот модуль может
иметь и практическую пользу для запросов, производящих поиск по множеству столбцов.
• В модуле contrib/cube введены операторы расстояния для кубов и поддержка поиска в стиле
kNN в индексах GiST по столбцам типа cube (Стас Кельвич)
• Согласование представления о числах в функциях hstore_to_jsonb_loose() и
hstore_to_json_loose() расширения contrib/hstore (Том Лейн)
Ранее функция hstore_to_jsonb_loose() преобразовывала похожие на числа строки в числа
JSON, а не в строки, даже когда они в точности не соответствовали правилам записи чисел в
JSON. Это не согласовывалось с поведением hstore_to_json_loose(), так что проверки были
усилены для соблюдения синтаксиса JSON.
• Добавление функций оценки избирательности для операторов модуля contrib/intarray с це-
лью улучшения планов запросов, использующих эти операторы (Юрий Журавлёв, Александр
Коротков)
• Доработка функции heap_page_items() в модуле contrib/pageinspect, чтобы она вы-
водила неструктурированные данные в каждом кортеже, а также добавление функций
2406Замечания к выпуску
tuple_data_split() и heap_page_item_attrs() для исследования отдельных полей кортежей
(Николай Шаплов)
• Добавление необязательного параметра, задающего число итераций S2K, в функцию contrib/
pgcrypto в модуле pgp_sym_encrypt() (Джефф Джейнс)
• Добавление возможности оценивать «схожесть слов» в contrib/pg_trgm (Александр Коротков,
Артур Закиров)
Добавленные функции и операторы оценивают схожесть между одной строкой и наиболее по-
хожим отдельным словом в другой строке.
• Добавление параметра конфигурации pg_trgm.similarity_threshold, устанавливающего по-
рог схожести для contrib/pg_trgm (Артур Закиров)
Этот порог настраивался и раньше, но до этого им управляли специальные функции
set_limit() и show_limit(). Теперь они считаются устаревшими.
• Усовершенствование класса операторов GIN в contrib/pg_trgm для ускорения запросов с при-
менением индекса, в которых ищутся и редкие, и частые ключи (Джефф Джейнс)
• Увеличение производительности поиска по схожести в индексах GIN (модуль contrib/
pg_trgm) (Кристоф Форнароли)
• Добавление модуля contrib/pg_visibility, позволяющего изучать карты видимости таблиц
(Роберт Хаас)
• Добавление в contrib/sslinfo функции ssl_extension_info() для вывода информации о рас-
ширениях SSL, представленных в сертификате X509, который используется для текущего со-
единения (Дмитрий Воронин)
E.21.3.13.1. postgres_fdw
• Возможность передавать предоставляемые расширением операторы и функции на удалённый
сервер, если это расширение указано в белом списке в параметрах стороннего сервера (Пол
Рамси)
Пользователи могут использовать это, когда точно известно, что в удалённой базе установле-
на совместимая версия заданного расширения. Это позволяет более эффективно выполнять
запросы с операторами, поддерживаемыми расширениями.
• Возможность выполнения сортировки на удалённом сервере (Ашутош Бапат)
• Возможность выполнения соединений на удалённом сервере (Шигеру Ханада, Ашутош Бапат)
• Если возможно, выполнять UPDATE или DELETE полностью на удалённом сервере (Эцуро Фудзи-
та)
Ранее для удалённой модификации данных требовалось передавать команду SELECT FOR
UPDATE, а затем изменять или удалять отобранные строки по одной. Хотя это по-прежнему
необходимо, если эта операция требует локальных действий, теперь она может выполняться и
удалённо, если все элементы запроса можно безопасно передать на удалённый сервер.
• Возможность задавать число извлекаемых строк в параметрах сервера или таблицы (Кори
Хинкер)
Ранее postgres_fdw всегда читала результаты удалённых запросов по 100 строк; теперь это
количество стало настраиваемым.
• Для всех локальных пользователей, сопоставленных с одним удалённым пользователем, долж-
но использоваться одно соединение со сторонним сервером (Ашутош Бапат)
• Передача требования отмены запроса на удалённый сервер (Микаэль Пакье, Эцуро Фудзита)
Ранее требование на отмену локального запроса не влекло за собой досрочную отмену уда-
лённого запроса, уже переданного на выполнение.
2407Замечания к выпуску
E.22. Выпуск 9.5.15
Дата выпуска:
2018-11-08
В этот выпуск вошли различные исправления, внесённые после версии 9.5.14. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.22.1. Миграция на версию 9.5.15
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.5.13, см. Раздел E.27.
E.22.2. Изменения
• Устранение сбоев, которые могли возникать в особых случаях в семействе функций has_объ-
ект_privilege() (Том Лейн)
Эти функции должны возвращать NULL, а не выдавать ошибку при получении неверного
OID. Некоторые из этих функций делали это и прежде, но не все. Кроме того, в функции
has_column_privilege() на некоторых платформах могли иметь место и другие сбои.
• Недопущение замедления порядка O(N^2) в функциях match/split с регулярными выражения-
ми при обработке длинных строк (Эндрю Гирт)
• Исправление дефекта в обработке стандартных многосимвольных операторов, следующих
непосредственно за комментарием или символами + и - (Эндрю Гирт)
Следствием данного упущения могли быть ошибки при разборе или неправильное определе-
ние приоритета операторов.
• Недопущение замедления порядка O(N^3) при обработке лексическим анализатором длин-
ных строк из символов + или - (Эндрю Гирт)
• Исправление некорректного выполнения подчинённых планов при сканировании внешнего
запроса в обратном направлении (Эндрю Гирт)
• Исправление ошибочного поведения UPDATE/DELETE ... WHERE CURRENT OF ... после переме-
щения курсора (Том Лейн)
Курсор, сканирующий несколько отношений (в частности, дерево наследования), мог работать
неправильно, возвращаясь к предыдущему отношению.
• Исправление в функции EvalPlanQual обработки узлов InitPlan, которые выполняются по
условию (Эндрю Гирт, Том Лейн)
Вследствие ошибки реализации могли возникать сложновоспроизводимые сбои или выдавать-
ся неправильные результаты при одновременных запросах на изменение, содержащих изоли-
рованные вложенные SELECT в конструкции CASE.
• Исправление проверок классов символов для корректной поддержки в Windows символов
Unicode выше U+FFFF (Том Лейн, Кэндзи Уно)
Эта ошибка проявлялась в операциях полнотекстового поиска, а также в работе модулей
contrib/ltree и contrib/pg_trgm.
• Смена владельца последовательности, принадлежащей сторонней таблице, при выполнении
ALTER OWNER для этой таблицы (Питер Эйзентраут)
Операция смены владельца должна распространяться и на такие последовательности, но
раньше сторонние таблицы она не затрагивала.
• Обеспечение обработки сервером уже полученных прерываний NOTIFY и SIGTERM до начала
ожидания данных от клиента (Джефф Джейнс, Том Лейн)
2408Замечания к выпуску
• Устранение ошибки, приводившей к выделению лишней памяти для строки результатов
array_out() (Кэйити Хиробэ)
• Ликвидация утечки памяти при сканировании индекса SP-GiST (Том Лейн)
Сколько-нибудь значительное проявление этой утечки наблюдалось, только когда для ограни-
чения-исключения, использующего SP-GiST, в индекс поступало много записей.
• Закрытие файла сопоставлений в ApplyLogicalMappingFile() после завершения его использо-
вания (Томаш Вондра)
Ранее дескриптор файла терялся, что могло в итоге приводить к сбоям при логическом деко-
дировании.
• Устранение ошибки логического декодирования в случаях, когда сопоставленная таблица ка-
талога постоянно перезаписывается, например, в результате действия VACUUM FULL (Андрес
Фройнд)
• Предотвращение запуска сервера со значением wal_level, недостаточно большим для под-
держки существующего слота репликации (Андрес Фройнд)
• Предотвращение сбоя в случаях, когда служебная команда создаёт бесконечную рекурсию
(Том Лейн)
• Устранение в процессе инициализации горячего резерва проблемы дублирующихся XID, ко-
торые образуются при выполнении двухфазных транзакций на ведущем сервере (Микаэль Па-
кье, Константин Книжник)
• Исправление поведения событийных триггеров при обработке вложенных команд ALTER TABLE
(Микаэль Пакье, Альваро Эррера)
• Передача параллельным исполнителям времени начала оператора и транзакции от родитель-
ского процесса (Константин Книжник)
Тем самым исправлено поведение таких функций, как transaction_timestamp(), выполняю-
щихся в параллельном исполнителе.
• Исправление логики переработки файла WAL для правильного выполнения этой операции на
ведомых серверах (Микаэль Пакье)
В зависимости от значения параметра archive_mode ведомый сервер мог не удалить некото-
рые файлы WAL, подлежащие удалению.
• Исправление обработки времени фиксации транзакций в процессе восстановления (Масахико
Савада, Микаэль Пакье)
Если отслеживание времени фиксации не было включено постоянно, в процессе восстановле-
ния мог произойти сбой при попытке получить время фиксации транзакции, для которой оно
не было записано.
• Использование случайной затравки для random() в initdb, а также в сервере, запускаемом в
режиме начальной загрузки и в монопольном режиме (Ной Миш)
Практическая польза этого изменения состоит прежде всего в разрешении проблемы, когда
программа initdb не могла использовать общую память POSIX, считая её недоступной, из-за
конфликтов имён, вызванных использованием одинаковой затравки.
• Возможность прерывания операции выделения памяти в DSM (Крис Трэверс)
• Исправление поведения при динамическом включении параметра full_page_writes (Кётаро
Хоригути)
• Предупреждение возможного переполнения буфера при воспроизведении операции распаков-
ки страницы GIN из WAL (Александр Коротков, Шивасубраманьян Рамасубраманьян)
• Выполнение операции fsync, ранее упущенной, для каталога слотов репликации (Константин
Книжник, Микаэль Пакье)
2409Замечания к выпуску
• Устранение неожиданных тайм-аутов при использовании wal_sender_timeout на медленном
сервере (Ной Миш)
• Исправление вычисления подходящей точки согласованности WAL в процессах горячего ре-
зерва (Александр Кукушкин, Микаэль Пакье)
Выбор правильной точки позволяет предотвратить некорректное поведение сразу после того,
как ведомый сервер достигает согласованного состояния базы при воспроизведении WAL.
• Корректная остановка фоновых рабочих процессов при получении главным процессом запро-
са на быстрое отключение до завершения запуска базы (Александр Кукушкин)
• Отказ от вызова обработчиков atexit при обработке SIGQUIT (Хейкки Линнакангас)
• Исключение сопоставлений пользователей для сторонних серверов из состава расширений
(Том Лейн)
При выполнении CREATE USER MAPPING в скрипте расширения для создаваемого сопоставле-
ния добавлялась зависимость, чего не должно быть. Сопоставления пользователей, как и ро-
ли, не могут быть членами расширений.
• Исправление поведения syslogger в случае ошибок при попытке открыть файлы CSV (Том
Лейн)
• Исправление кода psql, а также примеров в документации, чтобы функция PQconsumeInput()
вызывалась перед PQnotifies() (Том Лейн)
Тем самым решена проблема, когда psql не выдавал полученное сообщение NOTIFY до следую-
щей команды.
• Устранение возможной несогласованности при сортировке различных имён объектов в
pg_dump (Джейкоб Чемпион)
• Исправление pg_restore, чтобы при выдаче команд DISABLE/ENABLE TRIGGER имя таблицы до-
полнялось схемой (Том Лейн)
Это предотвращает сбои, возможные при новой политике выполнения восстановления с огра-
ниченным путём поиска.
• В pg_upgrade исправлена обработка событийных триггеров в расширениях (Харибабу Комми)
Ранее pg_upgrade не сохранял связь событийных триггеров с расширениями.
• Исправление проверки состояния кластера в pg_upgrade, чтобы она корректно выполнялась
на ведомом сервере (Брюс Момджян)
• Ограничение числа размерностей в значениях cube во всех функциях contrib/cube (Андрей
Бородин)
Ранее в некоторых функциях, связанных с кубами, можно было создать такие значения, кото-
рые затем не принимала функция cube_in(), что вызывало ошибки при восстановлении вы-
груженных данных.
• Исправление функции unaccent() в расширении contrib/unaccent, чтобы она использовала
словарь текстового поиска unaccent, находящийся в той же схеме, где и сама функция (Том
Лейн)
Ранее она пыталась найти словарь по пути поиска, но могла не обнаружить его, если путь по-
иска был ограничен.
• Устранение проблем при сборке в macOS 10.14 (Mojave) (Том Лейн)
Усовершенствование скрипта configure, чтобы в CPPFLAGS добавлялся ключ -isysroot; без
этого PL/Perl и PL/Tcl нельзя сконфигурировать или собрать в macOS 10.14. Значение sysroot
2410Замечания к выпуску
можно переопределить во время конфигурирования или сборки, установив переменную
PG_SYSROOT в аргументах configure или make.
Теперь рекомендуется, чтобы для связанных с Perl расширений во флагах компилятора указы-
валось $(perl_includespec), а не -I$(perl_archlibexp)/CORE. Второй вариант по-прежнему
будет работать на большинстве платформ, но не в последних macOS.
Также теперь не требуется указывать вручную ключ --with-tclconfig, чтобы собрать PL/Tcl в
последних версиях macOS.
• Исправление скриптов сборки с MSVC и регрессионного тестирования для работы с последни-
ми версиями Perl (Эндрю Дунстан)
Это изменение вызвано тем, что Perl теперь по умолчанию не включает текущий каталог в
свой путь поиска.
• Реализована возможность запускать регрессионные тесты в Windows с учётной записью адми-
нистратора (Эндрю Дунстан)
Чтобы это было безопасно, pg_regress теперь лишает себя расширенных прав при запуске.
• Поддержка сборки в Windows с Visual Studio 2015 и Visual Studio 2017 (Микаэль Пакье, Хари-
бабу Комми)
• Снятие запрета на возврат из функций сравнения btree значений INT_MIN (Том Лейн)
До настоящего времени мы не позволяли типозависимым функциям сравнения возвращать
INT_MIN, благодаря чему вызывающий код мог сменить порядок сортировки, просто изменив
знак результата сравнения. Однако это могло вызывать проблемы с функциями сравнения,
возвращающими непосредственно результат memcmp(), strcmp() и подобных функций, так как
POSIX не накладывает на него никаких ограничений. Как минимум некоторые последние вер-
сии memcmp() могут возвращать INT_MIN, что приводило к нарушению порядка сортировки. В
связи с этим мы убрали это ограничение. Там же, где требуется поменять порядок сортировки
на противоположный, теперь нужно использовать макрос INVERT_COMPARE_RESULT().
• Устранение риска рекурсии при обработке сообщений об аннулировании общего кеша (Том
Лейн)
Эта ошибка могла привести, например, к сбою при обращении к системному каталогу или ин-
дексу, который был только что обработан командой VACUUM FULL.
В результате этого изменения функция LockAcquire теперь может возвращать новый код ре-
зультата, что теоретически может вызвать проблемы при использовании этой функции, хо-
тя для этого схема её использования должна быть весьма необычной. Также был изменён API
функции LockAcquireExtended.
• Сохранение и восстановление глобальных переменных SPI в SPI_connect() и SPI_finish()
(Чепмен Флэк, Том Лейн)
Это предотвращает накладки, возможные при вызове из одной функции, использующей SPI,
другой такой функции.
• Добавление определения ALLOCSET_DEFAULT_SIZES и связанных с ним макросов в ветви старых
версий (Том Лейн)
Эти макросы появились в версии 9.6, но поступали запросы добавить их и в старые версии,
чтобы ими можно было пользоваться в расширениях, обходясь без лишних условий.
• Предотвращение использования потенциально невыравненных буферов страниц (Том Лейн)
Добавлены новые типы-объединения PGAlignedBlock и PGAlignedXLogBlock, которые должны
использоваться вместо простых массивов char, чтобы компилятор гарантированно выравни-
вал адрес начала буфера. В результате устраняется риск аварийного сбоя на платформах, чув-
2411Замечания к выпуску
ствительных к выравниванию, и может увеличиться быстродействие даже на тех платформах,
где выравнивание не требуется.
• Приведение в src/port/snprintf.c значения результата snprintf() в соответствие со стан-
дартом C99 (Том Лейн)
На платформах, где этот код используется (в основном в Windows), его несовременное поведе-
ние (не соответствующие C99) могло препятствовать выявлению переполнения буфера, если
вызывающий код рассчитывал на семантику C99.
• Требование обязательного использования -msse2 при сборке компилятором clang для i386
(Андрес Фройнд)
Тем самым решается проблема отсутствия проверок переполнения при операциях с плаваю-
щей точкой.
• Исправление в configure проверки, определяющей, результат какого типа возвращает
strerror_r() (Том Лейн)
Предыдущая реализация давала неправильный ответ при сборке с использованием компиля-
тора icc в Linux (возможно, и в других случаях), в результате чего libpq не выдавала полезные
сообщения при возникновении системных ошибок.
• Обновление данных часовых поясов до версии tzdata 2018g, включающее изменений правил
перехода на летнее время в России (Волгограде), Чили, Марокко и на Фиджи, а также коррек-
тировку исторических данных для Китая, Гавайев, Японии, Макао и Северной Кореи.
E.23. Выпуск 9.5.14
Дата выпуска:
2018-08-09
В этот выпуск вошли различные исправления, внесённые после версии 9.5.13. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.23.1. Миграция на версию 9.5.14
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.5.13, см. Раздел E.27.
E.23.2. Изменения
• Осуществление полного сброса состояния libpq между попытками соединения (Том Лейн)
Непривилегированный пользователь dblink или postgres_fdw мог обойти проверки, пред-
назначенные для предотвращения использования учётных данных на стороне сервера, на-
пример, файла ~/.pgpass, принадлежащего пользователю ОС, от имени которого работа-
ет сервер. В частности, уязвимость затрагивает серверы, принимающие локальные подклю-
чения с методом peer. Возможны были и другие атаки, например, SQL-инъекции в сеансе
postgres_fdw. Для атаки на postgres_fdw через эту уязвимость пользователь должен был
иметь возможность создавать объект стороннего сервера с нужными параметрами подключе-
ния, но атаку на dblink мог произвести любой пользователь, имеющий к нему доступ. Вообще
любой пользователь, имеющий возможность менять параметры подключения для приложения
на базе libpq, мог производить непредусмотренные действия, но другие эффективные сцена-
рии эксплуатации этого сложно придумать. Мы благодарим Андрея Красичкова за сообщение
о данном дефекте. (CVE-2018-10915)
• Исправление поведения INSERT ... ON CONFLICT UPDATE с более сложным представлением,
чем просто SELECT * FROM ... (Дин Рашид, Амит Ланготе)
Ошибочное развёртывание изменяемого представления могло приводить к сбоям или ошиб-
кам «attribute ... has the wrong type» (атрибут ... имеет неверный тип), если список SELECT
2412Замечания к выпуску
представления не соответствовал в точности списку столбцов нижележащей таблицы. Более
того, развив атаку через эту уязвимость, злоумышленник мог изменять столбцы, не имея для
них права UPDATE, но имея права INSERT и UPDATE для некоторых других столбцов в таблице.
Любой пользователь также мог эксплуатировать её для раскрытия содержимого памяти сер-
вера. (CVE-2018-10925)
• Обеспечение своевременного изменения полей relfrozenxid и relminmxid в «зафиксирован-
ных» системных каталогах (Андрес Фройнд)
Из-за чрезмерно оптимистичного кеширования эти изменения могли оказаться невидимыми
для других сеансов, что приводило к случайным ошибкам и/или разрушению данных. Для об-
щих каталогов, таких как pg_authid, проблема была ещё острее, так как устаревшие кеширо-
ванные данные могли попадать в новые сеансы и оставаться в существующих.
• Исправление поведения в ситуации, когда недавно повышенный сервер аварийно завершает-
ся до окончания обработки первой контрольной точки после восстановления (Микаэль Пакье,
Кётаро Хоригути, Паван Деоласи, Альваро Эррера)
В такой ситуации сервер не считал, что при последующем воспроизведении WAL было достиг-
нуто согласованное состояние базы данных, и это препятствовало его перезапуску.
• Исключение выдачи фантомной записи WAL при переработке полностью нулевой страницы
индекса btree (Амит Капила)
Эта ошибка проявлялась в сбоях проверочных утверждений и могла приводить к неоправдан-
ным отменам запросов на серверах горячего резерва.
• При воспроизведении WAL добавлена защита от некорректной длины записи, превышающей 1
ГБ (Микаэль Пакье)
Подобные данные должны считаться некорректными. Ранее код пытался выделить такой объ-
ём и получал критическую ошибку, что делало восстановление невозможным.
• При завершении восстановления запись в файл истории линии времени должна откладывать-
ся, насколько это возможно (Хейкки Линнакангас)
Это позволяет избежать ситуаций с несогласованностью состояния линии времени на диске,
возникавших при сбое в процессе очистки после восстановления (например, при проблеме с
файлом двухфазного состояния).
• Увеличение скорости воспроизведения WAL для транзакций, удаляющих множество отноше-
ний (Фудзии Масао)
В результате этого изменения уменьшается число сканирований общих буферов, поэтому эф-
фект от данного изменения тем больше, чем больше значение shared_buffers.
• Увеличение скорости освобождения блокировки при воспроизведении WAL ведомым сервером
(Томас Мунро)
• Обеспечение согласованной передачи состояния логической трансляции передатчиками WAL
(Саймон Риггс, Савада Масахико)
Ранее код не мог правильно определить, удалось ли нагнать вышестоящий сервер.
• Устранение дефектов в процедуре обработки снимков при логическом декодировании, приво-
дивших к ошибкам декодирования в редких случаях (Арсений Шер, Альваро Эррера)
• Обеспечение корректного сброса кешированного списка индексов таблицы после сбоя при со-
здании индекса (Питер Геохеган)
Ранее в этом списке могли оставаться OID нерабочих индексов, что могло приводить к про-
блемам в том же сеансе.
• Исправление некорректной обработки пустых несжатых страниц списка идентификаторов в
индексах GIN (Шивасубраманьян Рамасубраманьян, Александр Коротков)
2413Замечания к выпуску
Это могло привести к сбою проверочного утверждения после выполнения pg_upgrade для ин-
дексов GIN версии до 9.4 (в 9.4 и последующих версиях такие страницы не создаются).
• Обеспечение реакции на сигналы в процессе VACUUM в цикле удаления страниц B-дерева (Ан-
дрес Фройнд)
С испорченными индексами btree цикл мог оказаться бесконечным, и прервать его можно бы-
ло только аварийно отключив сервер.
• Исправление некорректной оптимизации классов эквивалентности со столбцами составного
типа (Том Лейн)
Вследствие данной ошибки сервер не понимал, что индекс по составному столбцу может обес-
печить порядок сортировки, необходимый для соединения слиянием с данным столбцом.
• Исправление синтаксиса конструкции SQL-стандарта FETCH FIRST, чтобы она принимала ($n),
как того требует стандарт (Эндрю Гирт)
• Корректное добавление схемы к именам ряда объектов в выводе getObjectDescription (Кёта-
ро Хоригути, Том Лейн)
Имена правил сортировки, преобразований и объектов текстового поиска не дополнялись схе-
мой, тогда как должны были.
• Расширение счётчика строк в команде COPY FROM с 32 до 64 бит (Дэвид Роули)
Тем самым были решены две проблемы с входными данными, содержащими более 4G строк:
COPY FROM WITH HEADER терял одну строку на каждые 4G строк (не только первую), а в сообще-
ниях об ошибках выводилось неверное количество строк.
• Добавление в библиотеку ecpg pgtypes функции освобождения строк для исключения про-
блем с управлением памятью в разных модулях (Такаюки Цунакава)
В Windows могут происходить сбои, если вызов free для некоторого блока памяти произво-
дится не из той DLL, которая выделила память (с помощью malloc). Библиотека pgtypes ино-
гда возвращает строки, которые должен освободить вызывающий код, и сделать это корректно
оказывается невозможно. Добавленная функция PGTYPESchar_free() является просто обёрт-
кой free, позволяющей приложениям произвести освобождение по правилам.
• Исправление поддержки в ecpg переменных long long в Windows, а также на других платфор-
мах, где strtoll/strtoull объявлены нестандартно или не объявлены вовсе (Хыонг Дангминь,
Том Лейн)
• Исправление ошибки с определением типа SQL-оператора в PL/pgSQL, когда изменение пра-
вила приводило к изменению семантики оператора в рамках сеанса (Том Лейн)
Эта ошибка приводила к сбоям проверочных утверждений или, в редких случаях, к тому, что
указание INTO STRICT не работало должным образом.
• Исправление запроса пароля в клиентских программах, чтобы отображение корректно отклю-
чалось в Windows, когда stdin — не терминал (Мэтью Стикни)
• Продолжение исправления некорректного заключения в кавычки значений для переменных
GUC со списками при формировании дампа (Том Лейн)
Предыдущее исправление для заключения в кавычки значения search_path и других пере-
менных со списками в выводе pg_dump, как оказалось, привело к ошибкам со списками с пу-
стыми элементами и риску потери части длинных файловых путей.
• В pg_dump устранено упущение, когда свойства REPLICA IDENTITY для индексов ограничений
не выгружались (Том Лейн)
Уникальные индексы, созданные вручную, помечались корректно, а индексы, созданные огра-
ничениями UNIQUE или PRIMARY KEY — нет.
2414Замечания к выпуску
• В pg_upgrade теперь правильно проверяется, что старый сервер был выключен штатно (Брюс
Момджян)
Ранее проверка могла сработать некорректно при выключении сервера в незамедлительном
режиме.
• Исправление в contrib/hstore_plperl просмотра скалярных ссылок Perl и предотвращение
сбоя в случае, если не удаётся найти хеш-ссылку там, где она ожидается (Том Лейн)
• Устранение сбоя в функции модуля contrib/ltree при получении на вход пустого массива
(Пьер Дюкроке)
• Исправление обработки ошибок в ряде мест, где мог выдаваться некорректный код ошибки
(Микаэль Пакье, Том Лейн, Магнус Хагандер)
• Переоформление скриптов Makefile для обеспечения компоновки программ с собранными в
том же дереве библиотеками (например, libpq.so), а не с теми, что могут уже находиться в
системных каталогах библиотек (Том Лейн)
Это позволяет избежать проблем при сборке на платформах, где представлены старые версии
библиотек PostgreSQL.
• Обновление данных часовых поясов до версии tzdata 2018e, включающее изменение правил
перехода на летнее время в Северной Корее, а также корректировку исторических данных
для Чехословакии.
В это обновление вошло переопределение «летнего времени», которое действует в Ирландии,
а также действовало в прошлом в Намибии и в Чехословакии. В этих юрисдикциях стандарт-
ное время действует летом, а время для экономии света — зимой, поэтому при переходе на
это время сдвиг производится на час назад, а не на час вперёд. Это не влияет ни на фактиче-
ское смещение от UTC, ни на используемое сокращение часового пояса; эта особенность про-
является лишь в том, что в таких случаях столбец is_dst в представлении pg_timezone_names
будет содержать true для зимнего периода, и false для летнего.
E.24. Выпуск 9.5.13
Дата выпуска:
2018-05-10
В этот выпуск вошли различные исправления, внесённые после версии 9.5.12. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.24.1. Миграция на версию 9.5.13
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вас касаются ошибки с пометкой функций, описанные в первой записи в списке из-
менений, потребуются дополнительные действия для исправления каталогов баз данных.
Если вы обновляете сервер с более ранней версии, чем 9.5.12, см. также Раздел E.25.
E.24.2. Изменения
• Исправление некорректных пометок изменчивости для нескольких встроенных функций (То-
мас Мунро, Том Лейн)
Функции query_to_xml, cursor_to_xml, cursor_to_xmlschema, query_to_xmlschema и
query_to_xml_and_xmlschema должны были считаться изменчивыми, так как они выполняют
пользовательские запросы, в которых могут быть изменчивые операции. Однако они не бы-
ли помечены должным образом, что было чревато неправильной оптимизацией запросов. Это
было исправлено для новых инсталляций в результате корректировки исходных данных ката-
лога, но в существующих инсталляциях ошибочные пометки сохранятся. При практическом
2415Замечания к выпуску
использовании этих функций риск кажется небольшим, но в случае необходимости их мож-
но исправить, вручную изменив записи этих функций в pg_proc. Например: ALTER FUNCTION
pg_catalog.query_to_xml(text, boolean, boolean, text) VOLATILE. (Заметьте, что это нуж-
но будет проделать в каждой базе данных инсталляции.) Также вы можете обновить базу до
версии с корректными исходными данными, воспользовавшись pg_upgrade.
• Предотвращение повторного использования для TOAST идентификаторов OID, соответствую-
щих уже неактуальным, но ещё не очищенным записям TOAST (Паван Деоласи)
После зацикливания счётчика OID имеется возможность использования для значения TOAST
идентификатора OID, соответствующего ранее удалённой записи в той же таблице TOAST.
Если запись не была очищена к тому времени, это приводило к ошибкам «unexpected chunk
number 0 (expected 1) for toast value nnnnn» (неожиданный номер порции 0 (ожидался 1) для
значения TOAST nnnnn), которые сохранялись до удаления неактуальной записи командой
VACUUM. В качестве решения выбор таких OID при создании новых записей TOAST теперь ис-
ключается.
• Изменение алгоритма ANALYZE в части модификации pg_class.reltuples (Дэвид Гулд)
Ранее плотность кортежей могла обновляться только для страниц, прошедших обработку
ANALYZE, для остальных плотность считалась прежней. В большой таблице, где ANALYZE выби-
рает лишь небольшой процент страниц, это означает, что возможно лишь незначительное из-
менение общей оценки плотности кортежей, и поэтому reltuples будет меняться практиче-
ски пропорционально изменениям физического размера таблицы (relpages) вне зависимо-
сти от того, что фактически происходит в таблице. В результате может наблюдаться настоль-
ко большое увеличение reltuples по сравнению с реальностью, что автоматическая очистка
практически отключается. Для исправления этой ошибки принимается, что выборка ANALYZE
является статистически несмещённой (какой она и должна быть), и наблюдаемая в ней плот-
ность просто экстраполируется на всю таблицу.
• Предупреждение взаимоблокировок в параллельных командах CREATE INDEX CONCURRENTLY,
выполняемых на уровнях изоляции SERIALIZABLE и REPEATABLE READ (Том Лейн)
• Устранение возможности замедленного выполнения REFRESH MATERIALIZED VIEW
CONCURRENTLY (Томас Мунро)
• Устранение ошибки в UPDATE/DELETE ... WHERE CURRENT OF в случае, когда задействованный
курсор использует план сканирования только индекса (Юго Нагата, Том Лейн)
• Исправление некорректного планирования, когда предложения соединения передавались в
параметризованные пути (Эндрю Гирт, Том Лейн)
Эта ошибка могла привести к неправильной классификации условия как «фильтра соедине-
ния» для внешнего соединения, тогда как оно должно быть простым «фильтром», и в итоге
мог получиться некорректный результат соединения.
• Устранение возможности некорректного построения плана сканирования только индекса в
случаях, когда один столбец таблицы фигурирует в нескольких индексах, но не во всех этих
индексах используются классы операторов, которые могут выдать значение столбца (Кётаро
Хоригути)
• Исправление некорректной оптимизации ограничений CHECK с гарантированными NULL-под-
выражениями в условиях верхнего уровня AND/OR (Том Лейн, Дин Рашид)
В результате, например, ограничение-исключение могло исключить из запроса дочернюю
таблицу, которая не должна быть исключена.
• Устранение сбоя исполнителя в результате двойного освобождения памяти с некоторыми ва-
риантами использования GROUPING SETS (Питер Геохеган)
• Предотвращение сбоя в случае, когда триггер события перезаписи таблицы добавляется од-
новременно с выполнением команды, которая может вызвать такой триггер (Альваро Эррера,
Эндрю Гирт, Том Лейн)
2416Замечания к выпуску
• Предотвращение ошибки при прерывании запроса или прекращении сеанса в момент фикси-
рования подготовленной транзакции (Стас Кельвич)
• Ликвидация утечки памяти на время выполнения запроса в последовательно выполняемых со-
единениях по хешу (Том Лейн)
• Исправление излишне строгой проверки в heap_prepare_freeze_tuple (Альваро Эррера)
Это могло приводить к необоснованной ошибке «cannot freeze committed xmax» (не удаётся за-
морозить зафиксированный xmax) в базах данных, обновлённых с помощью pg_upgrade с вер-
сии 9.2 или старее.
• Устранение потери указателя в случаях, когда написанный на С триггер, выполняемый до из-
менения строки, возвращает старый кортеж («old») (Рушаб Латиа)
• Понижение уровня блокировки при планировании работы автоочистки (Джефф Джейнс)
Предыдущее поведение создавало значительные препятствия для параллельного выполнения
рабочих процессов в базах, содержащих множество таблиц.
• Обеспечение копирования имени клиентского компьютера при копировании данных
pg_stat_activity в локальную память (Эдмунд Хорнер)
Ранее предположительно локальный экземпляр содержал указатель на разделяемую память,
вследствие чего содержимое поля с именем клиентского компьютера могло неожиданно из-
мениться при отключении какого-либо сеанса.
• Исправление некорректной обработки нескольких составных аффиксов в словарях ispell (Ар-
тур Закиров)
• Исправление поиска (то есть сканирования индекса с операторами неравенства), зависимого
от правила сортировки, в индексах SP-GiST, построенных по текстовым столбцам (Том Лейн)
Такой поиск мог возвращать неправильный набор строк для большинства правил сортировки,
отличных от C.
• Корректировка вычисления количества кортежей в индексе при изначальном построении ин-
декса SP-GiST (Томаш Вондра)
Ранее количество кортежей в индексе считалось равным количеству кортежей в нижележа-
щей таблице, что неверно в случае частичного индекса.
• Корректировка вычисления количества кортежей в индексе при очистке индекса GiST (Ан-
дрей Бородин)
Ранее оно считалось равным примерному количеству кортежей в куче, что провоцировало
неточность и определённо было ошибочным в случае частичного индекса.
• Исправление поведения в особом случае, когда ведомый реплицирующий сервер «застревал»
на записи продолжения WAL (Кётаро Хоригути)
• При логическом декодировании приняты меры во избежание двойной обработки данных WAL
при перезапуске передатчика WAL (Крейг Рингер)
• Поддержка использования scalarltsel и scalargtsel с расширенными типами данных (То-
маш Вондра)
• Уменьшение потребления памяти libpq в случаях, когда сервер выдаёт ошибку после получе-
ния большого объёма результата запроса (Том Лейн)
Полученный ранее результат должен быть отброшен до, а не после обработки ошибки. На
некоторых платформах, в частности в Linux это может влиять на то, сколько памяти будет за-
нимать приложение.
• Устранение сбоев в ecpg, вызванных двойным освобождением памяти (Патрик Крекер, Джи-
ван Ладхе)
2417Замечания к выпуску
• Исправление обработки переменных long long int в ecpg, собранном с использованием
MSVC (Михаэль Мескес, Эндрю Гирт)
• Доработка некорректного заключения в кавычки значений для переменных GUC со списками
при формировании дампа (Микаэль Пакье, Том Лейн)
Переменные local_preload_libraries, session_preload_libraries,
shared_preload_libraries и temp_tablespaces не заключались в кавычки корректно в выводе
pg_dump. Это могло приводить к проблемам, если эти переменным присваивались значения в
конструкциях CREATE FUNCTION ... SET или ALTER DATABASE/ROLE ... SET.
• Предотвращение отказа pg_recvlogical при подключении к серверам PostgreSQL до 10 версии
(Микаэль Пакье)
В результате предыдущего исправления программа pg_recvlogical, не проверяя версию серве-
ра, выдавала команду, которая должна предназначаться только серверам версии 10 и новее.
• Исправление поведения pg_rewind, чтобы на целевом сервере удалялись файлы, которые мог-
ли быть удалены в процессе выполнения на исходном сервере (Такаюки Цунакава)
В противном случае на целевом сервере могла нарушаться согласованность данных, особенно
если это был файл сегмента WAL.
• Исправление в pg_rewind обработки таблиц в дополнительных табличных пространствах (Та-
каюки Цунакава)
• Исправление обработки целочисленного переполнения в циклах FOR на языке PL/pgSQL (Том
Лейн)
Исправление обработки целочисленного переполнения в циклах FOR на языке PL/pgSQL (Том
Лейн)
• Исправление регрессионных тестов PL/Python для совместимости с Python 3.7 (Питер Эйзен-
траут)
• Исправление регрессионных тестов PL/Python для совместимости с Python 3.7 (Питер Эйзен-
траут)
• Поддержка сборки с Microsoft Visual Studio 2015 (Микаэль Пакье)
Различные исправления, необходимые для совместимости с VS2015, были перенесены в ветвь
9.5 ранее, но это исправление было пропущено.
• Переименование функций b64_encode и b64_decode во избежание конфликта со встроенными
функциями Solaris 11.4 (Райнер Орт)
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией 2018e (Том
Лейн)
В этой версии усовершенствован компилятор данных часовых поясов zic для работы с отрица-
тельными смещениями при переходе на летнее время. Хотя проект PostgreSQL в настоящее
время не поставляет такие данные часовых поясов, zic может применяться с данными, полу-
ченными непосредственно от IANA, поэтому кажется разумным обновить zic сейчас.
• Обновление данных часовых поясов до версии tzdata 2018d, включающее изменения правил
перехода на летнее время в Палестине и Антарктиде (станция Кейси), плюс корректировку
исторических данных для Португалии и её колоний, а также Уругвая и островов Эндербери,
Ямайка, Теркс и Кайкос.
E.25. Выпуск 9.5.12
Дата выпуска:
2018-03-01
В этот выпуск вошли различные исправления, внесённые после версии 9.5.11. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
2418Замечания к выпуску
E.25.1. Миграция на версию 9.5.12
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если в вашей СУБД не все пользователи взаимно доверяют друг другу либо если вы под-
держиваете приложение или расширение, предназначенное для использования в произвольных
ситуациях, настоятельно рекомендуется прочитать об изменениях в первой записи ниже и пред-
принять соответствующие действия для защиты вашей инсталляции или кода.
Также изменения, описанные во втором пункте списка ниже, могут приводить к сбоям функций,
используемых в индексных выражениях или материализованных представлениях, во время авто-
матического анализа или при восстановлении выгруженных данных. Поэтому после обновления
проверьте журнал сервера на предмет подобных проблем и исправьте затронутые функции.
Также, если вы обновляете сервер с более ранней версии, чем 9.5.10, см. Раздел E.27.
E.25.2. Изменения
• Добавление в документацию информации о настройке серверов и приложений для защиты от
атак с внедрением троянского кода через путь поиска (Ной Миш)
Когда используется значение search_path, включающее схемы, доступные для записи зло-
намеренному пользователю, он может перехватывать управление над выполнением запросов
и затем запускать произвольный SQL-код с правами атакуемого пользователя. Хотя есть воз-
можность составлять запросы, защищённые от подобного перехвата, это требует кропотли-
вой работы, и при этом очень легко что-то упустить. Поэтому мы рекомендуем использовать
конфигурации, в которых пути поиска не могут включать недоверенные схемы. Соответству-
ющая информация добавлена в Подраздел 5.8.6 (для пользователей и администраторов баз
данных), Раздел 34.1 (для разработчиков приложений), Подраздел 38.16.1 (для разработчиков
расширений) и CREATE FUNCTION (для разработчиков функций с характеристикой SECURITY
DEFINER). (CVE-2018-1058)
• Предотвращение использования небезопасных значений search_path в pg_dump и других кли-
ентских программах (Ной Миш, Том Лейн)
pg_dump, pg_upgrade, vacuumdb и другие приложения, предоставляемые PostgreSQL, были
уязвимы для перехвата выполнения, описанного в предыдущем пункте; так как эти прило-
жения обычно запускаются суперпользователями, они представляли собой привлекательные
средства для атаки. Чтобы защитить их вне зависимости от того, защищена ли вся инсталля-
ция в целом, они были изменены так, чтобы для них параметр search_path содержал только
pg_catalog. Теперь это так же касается и рабочих процессов автоочистки.
В случаях, когда этими программами неявно вызываются определённые пользователем функ-
ции — например, это могут быть пользовательские функции в выражениях индексов — бо-
лее строгое значение search_path может приводить к ошибкам, которые потребуется испра-
вить так, чтобы эти функции никак не зависели от пути поиска, с которым они выполняются.
Это всегда рекомендовалось делать, но сейчас это необходимо для корректного поведения.
(CVE-2018-1058)
• Исправление некорректного поведения перепроверок одновременных изменений со ссылками
CTE, фигурирующими во внутренних планах (Том Лейн)
Если ссылка на CTE (содержимое предложения WITH) использовалась в InitPlan или SubPlan, и
запросу требовалось провести перепроверку из-за попытки изменения или блокировки одно-
временно изменяемой строки, могли быть получены неверные результаты.
• Устранение сбоев планировщика при перекрывающихся предложениях соединения слиянием
во внешнем соединении (Том Лейн)
Эти дефекты приводили в особых случаях к ошибкам планировщика «left and right pathkeys
do not match in mergejoin» (нарушено соответствие левых и правых ключей пути в соединении
2419Замечания к выпуску
слиянием) или «outer pathkeys do not match mergeclauses» (внешние ключи пути не соответ-
ствуют предложениям слияния).
• Исправление ошибки в pg_upgrade, когда не удавалось сохранить relfrozenxid для материа-
лизованных представлений (Том Лейн, Андрес Фройнд)
Данное упущение могло приводить к разрушению данных в материализованных пред-
ставлениях после обновления. Это могло проявляться в ошибках «could not access status
of transaction» (не удалось получить состояние транзакции) или «found xmin from before
relfrozenxid» (найден xmin перед relfrozenxid). Эта проблема была более вероятна в редко об-
новляемых материализованных представлениях или в представлениях, обновляемых только
командой REFRESH MATERIALIZED VIEW CONCURRENTLY.
Если такое разрушение имело место, его можно исправить, обновив материализованное пред-
ставление (без указания CONCURRENTLY).
• Исправление некорректной обработки имён функций PL/Python в стеках ошибки CONTEXT (Том
Лейн)
Ошибка, произошедшая во вложенном вызове функции PL/Python (то есть функции, вызван-
ной через SPI-запрос из другой функции PL/Python), могла привести к тому, что в трассировке
стека вместо ожидаемого результата имя внутренней функции фигурировало дважды. Также
ошибка во вложенном блоке PL/Python DO могла привести к обращению по нулевому указате-
лю на некоторых платформах.
• Максимальное значение log_min_duration для contrib/auto_explain доведено до INT_MAX,
что составляет около 24 суток вместо 35 минут (Том Лейн)
E.26. Выпуск 9.5.11
Дата выпуска:
2018-02-08
В этот выпуск вошли различные исправления, внесённые после версии 9.5.10. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.26.1. Миграция на версию 9.5.11
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.5.10, см. Раздел E.27.
E.26.2. Изменения
• Временные файлы, создаваемые программой pg_upgrade, должны быть недоступны для чте-
ния всеми пользователями (Том Лейн, Ной Миш)
Программа pg_upgrade обычно ограничивает доступ к своим временным файлам, чтобы их
мог читать и записывать только запускающий её пользователь. Но временные файлы, содер-
жащие вывод pg_dumpall -g могли быть доступны для чтения группе или всем пользовате-
лям, а возможно и для записи, если это допускало значение umask этого пользователя. При
типичном использовании в многопользовательских системах umask и/или разрешения в рабо-
чем каталоге достаточно жёсткие и эта проблема неактуальна; но pg_upgrade может исполь-
зоваться и в сценариях, где это упущение могло привести, например, к утечке паролей баз
данных. (CVE-2018-1053)
• Исправление очистки кортежей, которые были изменены при установленной блокировке раз-
деляемого ключа (Андрес Фройнд, Альваро Эррера)
В некоторых случаях операция VACUUM не удаляла такие кортежи, даже когда они теряли акту-
альность, что приводило к различным сценариям повреждения данных.
• Исправление неправильной блокировки буфера при некоторых чтениях LSN (Якоб Чемпион,
Асим Правин, Ашвин Агравал)
2420Замечания к выпуску
Эти ошибки могли приводит к некорректному поведению при многопоточной нагрузке. По-
тенциальные последствия не были характеризованы полностью.
• Исправление некорректных результатов запросов в случаях, когда происходило упрощение
подзапросов, результаты которых использовались в GROUPING SETS (Хейкки Линнакангас)
• Исключение неоправданной ошибки в запросе с деревом наследования, который выполнял-
ся одновременно с тем, как некоторая дочерняя таблица удалялась из этого дерева командой
ALTER TABLE NO INHERIT (Том Лейн)
• Устранение разнообразных ошибок взаимоблокировки при выполнении в нескольких сеансах
команды CREATE INDEX CONCURRENTLY (Джефф Джейнс)
• Устранение ошибок в ситуациях, когда дерево наследования содержит дочерние сторонние
таблицы (Эцуро Фудзита)
Комбинация обычных и сторонних таблиц в дереве наследования провоцировала построение
некорректных планов в запросах UPDATE и DELETE. Это приводило к видимым ошибкам в неко-
торых случаях, особенно когда в дочерней сторонней таблице присутствовали триггеры уров-
ня строк.
• Исправление дефекта со связанным подзапросом SELECT внутри VALUES в подзапросе LATERAL
(Том Лейн)
• Устранение ошибки планировщика «could not devise a query plan for the given query» (не уда-
лось выработать план для данного запроса) в некоторых случаях, включая вложенные UNION
ALL в подзапросе LATERAL (Том Лейн)
• Исправление логического декодирования, чтобы файлы на диске корректно очищались от
данных сбойных транзакций (Атсуши Торикоши)
Процедура логического декодирования может выносить записи WAL на диск, если транзакции
генерируют много записей WAL. Обычно эти файлы очищаются после фиксирования транзак-
ции или поступления записи о её прерывании; но в отсутствие таких записей код очистки ра-
ботал неправильно.
• Исправление тайм-аута в процессе walsender и реакции на прерывания при обработке боль-
шой транзакции (Петр Желинек)
• Добавление в has_sequence_privilege() поддержки проверок WITH GRANT OPTION, как это сде-
лано в других функциях проверки прав (Джо Конвей)
• В базах данных с кодировкой UTF8 любые XML-объявления, выбирающие другую кодировку,
должны игнорироваться (Павел Стехуле, Ной Миш)
Мы всегда храним документы XML в кодировке базы данных, так что позволяя libxml обраба-
тывать объявления с другой кодировкой, мы получим ошибочные результаты. Если кодировка
базы — не UTF8, мы в любом случае не обещали поддерживать XML-данные с не ASCII-коди-
ровкой, так что предыдущее поведение сохранено для совместимости ошибок. Это изменение
затрагивает только xpath() и связанные функции; другой код и ранее работал так.
• Обеспечение прямой совместимости с будущими изменениями младших версий протокола
(Роберт Хаас, Бадрул Чоудхури)
Ранее серверы PostgreSQL просто отклоняли запросы на использование версий протокола но-
вее 3.0, так что никакого функционального отличия старших номеров от младших не было. Те-
перь клиенты могут запрашивать версии 3.x и получать в ответ не отказ, а сообщение, говоря-
щее, что сервер поддерживает только версию 3.0. В данный момент от этого ничего не меня-
ется, но перенос этого изменения в предыдущие версии должен ускорить внедрение неболь-
ших усовершенствований протокола в будущем.
• Исправление реакции на сбой при запуске параллельного рабочего процесса (Амит Капила,
Роберт Хаас)
2421Замечания к выпуску
Ранее параллельный запрос мог зависнуть на неопределённое время, если не удавалось запу-
стить рабочий процесс, вследствие ошибки в fork() или других редких проблем.
• Устранение небезопасного предположения о выравнивании при работе с типом __int128 (Том
Лейн)
Обычно компиляторы полагают, что переменные __int128 выравниваются по 16-байтовым
границам, но наша инфраструктура выделения памяти не готова гарантировать это, а увели-
чение MAXALIGN кажется неподходящим по множеству причин. В качестве решения код был
изменён так, чтобы тип __int128 можно было использовать только когда мы можем сказать
компилятору, что предполагается не такое крупное выравнивание. Единственный замечен-
ный симптом этой проблемы — сбои в некоторых параллельных запросах с агрегированием.
• Предотвращение сбоев с переполнением стека при планировании операций со множествами с
крайне большой вложенностью (UNION/INTERSECT/EXCEPT) (Том Лейн)
• Ликвидация обращений по нулевому указателю для некоторых типов адресов LDAP, задавае-
мых в файле pg_hba.conf (Томас Мунро)
• Исправление демонстрационных функций INSTR() в документации по PL/pgSQL (Юго Нагата,
Том Лейн)
В документации утверждалось, что эти функции совместимы с Oracle®, но это было не совсем
так. В частности, по-разному интерпретировалось отрицательное значение третьего парамет-
ра: Oracle воспринимает это значение как последнюю позицию, с которой может начинаться
целевая подстрока, а наши функции считали, что это последняя позиция, где строка может
заканчиваться. Также Oracle выдаёт ошибку в случае нулевого или отрицательного четвёрто-
го параметра, тогда как наши функции возвращали ноль.
Код этого примера был изменён для большего соответствия поведению Oracle. Пользовате-
лям, которые скопировали этот код в свои приложения, возможно, имеет смысл обновить свои
копии.
• Исправление поведения pg_dump, чтобы ACL (разрешения), комментарии и метки безопасно-
сти можно было надёжно идентифицировать в архивных выходных форматах (Том Лейн)
Компонент «метка» записи ACL в архиве обычно представлял собой просто имя целевого объ-
екта. В его начало теперь добавляется тип объекта, чтобы записи ACL соответствовали согла-
шениям, уже принятым для записей комментариев и меток безопасности. Кроме того, обо-
значения комментариев и меток безопасности, заданных для собственно базы данных, теперь
должны начинаться с DATABASE, чтобы они соответствовали тому же соглашению. Это преду-
преждает ложные срабатывания в коде, который пытается найти записи больших объектов по
строкам, начинающимся со слов LARGE OBJECT. Прежнее поведение могло приводить к непра-
вильной классификации записей как данные и нежелательным результатам при восстановле-
нии выгруженной только схемы или только данных.
Заметьте, что следствием этого стало изменение видимого пользователями вывода pg_restore
--list.
• Переименование функции copy_file_range в pg_rewind во избежание конфликта с новым си-
стемным вызовом Linux с таким же именем (Андрес Фройнд)
Это изменение предотвращает ошибки при сборке с новыми версиями glibc.
• В ecpg добавлено выявление массивов индикаторов с неправильной длиной и сообщение об
ошибке (Дэвид Рейдер)
• Предотвращение срабатывания проверки истинности внутри libc в расширении contrib/
hstore из-за использования memcpy() с равными указателями источника и получателя (Томаш
Вондра)
• Добавление современных примеров настройки автозапуска Postgres в macOS (Том Лейн)
2422Замечания к выпуску
Скрипты в contrib/start-scripts/osx используют инфраструктуру, которая устарела десять
лет назад, и абсолютно неработоспособны во всех версиях macOS, выпущенных в последние
два года. Добавлен новый подкаталог contrib/start-scripts/macos со скриптами, использую-
щими новую инфраструктуру launchd.
• Исправление некорректного выбора зависящих от конфигурации библиотек OpenSSL в
Windows (Эндрю Дунстан)
• Поддержка компоновки с версиями libperl, собранными компилятором MinGW (Ной Миш)
Это позволяет собирать PL/Perl с некоторыми распространёнными дистрибутивами Perl для
Windows.
• Исправление в сборке MSVC проверки, требуется ли 32-битной libperl определение -
D_USE_32BIT_TIME_T (Ной Миш)
Имеющиеся дистрибутивы Perl ожидают разного, и при этом нет никакой возможности на-
дёжно проверить это, поэтому пришлось добавить проверку фактического поведения исполь-
зуемой библиотеки во время компиляции.
• В Windows обработчик аварийного завершения должен устанавливаться на более раннем эта-
пе запуска главного процесса (Такаюки Цунакава)
Это поможет получить дамп памяти при ошибках в те моменты в начале запуска, в которые
раньше дамп не записывался.
• В Windows устранены сбои, связанные с преобразованием кодировок при выводе сообщений
на самых ранних стадиях запуска процесса postmaster (Такаюки Цунакава)
• Использование нашего ранее написанного кода циклических блокировок для Motorola 68K во
OpenBSD, а также в NetBSD (Давид Карлье)
• Добавление поддержки циклических блокировок для Motorola 88K (Давид Карлье)
• Обновление данных часовых поясов до версии tzdata 2018c, включающее изменения правил
перехода на летнее время в Бразилии, в Сан-Томе и Принсипи, а также корректировки ис-
торических данных для Боливии, Японии и Южного Судана. Был удалён часовой пояс US/
Pacific-New (это был просто псевдоним для пояса America/Los_Angeles).
E.27. Выпуск 9.5.10
Дата выпуска:
2017-11-09
В этот выпуск вошли различные исправления, внесённые после версии 9.5.9. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.27.1. Миграция на версию 9.5.10
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы используете индексы BRIN, прочитайте четвёртую запись в списке изменений.
Также, если вы обновляете сервер с более ранней версии, чем 9.5.8, см. Раздел E.29.
E.27.2. Изменения
• Обеспечение проверки разрешений на уровне таблиц и политик RLS при выполнении
INSERT ... ON CONFLICT DO UPDATE во всех случаях (Дин Рашид)
Путь изменения данных в команде INSERT ... ON CONFLICT DO UPDATE требовал наличия раз-
решения SELECT для всех столбцов в решающем индексе, но в случае указания решающего
ограничения по имени должная проверка отсутствовала. Кроме того, для таблиц с включён-
2423Замечания к выпуску
ной защитой на уровне строк не проверялось, соответствуют ли изменённые строки полити-
кам SELECT (вне зависимости от способа задания решающего индекса). (CVE-2017-15099)
• Устранение сбоя при несовпадении типа записи в json{b}_populate_recordset() (Микаэль
Пакье, Том Лейн)
Эти функции использовали тип результата, заданный в предложении FROM ... AS, не прове-
ряя, соответствует ли он фактическому типу поступившего кортежа. В случае несоответствия
обычно происходил сбой, хотя также вероятным было раскрытие содержимого памяти серве-
ра. (CVE-2017-15098)
• Исправление скриптов запуска сервера — переключение на $PGUSER до открытия файла
$PGLOG (Ной Миш)
Ранее файл журнала postmaster открывался ещё под именем root. Таким образом, владелец
базы данных мог произвести атаку на другого пользователя системы, сделав $PGLOG символи-
ческой ссылкой на некоторый другой файл, который в результате можно было испортить до-
бавленными в него сообщениями журнала.
По умолчанию эти скрипты никуда не устанавливаются. Если вы использовали их, замените
свои экземпляры новыми копиями либо внесите те же коррективы в свои вручную изменён-
ные скрипты. Если владельцем существующего файла $PGLOG является root, его нужно уда-
лить или переименовать прежде чем перезапускать сервер с помощью исправленного скрип-
та. (CVE-2017-12172)
• Исправление вычисления сводных данных индекса BRIN для корректной работы при одновре-
менном расширении таблицы (Альваро Эррера)
Ранее в условиях гонки некоторые строки таблицы могли пропадать из индекса. Для устране-
ния последствий предыдущих проявлений этой проблемы может потребоваться перестроить
существующие индексы BRIN.
• Предупреждение возможных сбоев при параллельных изменениях индекса BRIN (Том Лейн)
В определённых условиях гонки могли возникать ошибки «invalid index offnum» (неверный но-
мер смещения в индексе) или «inconsistent range map» (несогласованность в карте диапазо-
нов).
• Устранение сбоя при вызове логического декодирования из функции, использующей SPI, в
частности, из любой функции на одном из языков PL (Том Лейн)
• Исправление в функциях json_build_array(), json_build_object() и их аналогах для jsonb
обработки явно заданных аргументов VARIADIC (Микаэль Пакье)
• Корректное недопущение попыток приведения бесконечных значений с плавающей точкой к
типу numeric (Том Лейн, КайГай Кохэй)
Ранее поведение зависело от платформы.
• Устранение сбоев в особых случаях при добавлении столбцов в конец представления (Том
Лейн)
• Фиксирование правильных зависимостей когда представление или правило содержит узлы вы-
ражения FieldSelect или FieldStore (Том Лейн)
В отсутствие этих зависимостей команда DROP со столбцом или типом данных может выпол-
ниться, когда не должна, что вызовет ошибки при последующем использовании представле-
ния или правила. Данное исправление не защищает существующие представления/правила, а
повлияет только на создаваемые в будущем.
• Правильное определение хешируемости диапазонных типов данных (Том Лейн)
Планировщик ошибочно полагал, что любой диапазонный тип может хешироваться для ис-
пользования в соединениях или агрегировании по хешу, но на самом деле он должен прове-
2424Замечания к выпуску
рять, поддерживает ли хеширование подтип диапазона. Это не касается встроенных диапазон-
ных типов, так как все они всё равно хешируемые.
• Игнорирование узлов выражений RelabelType при определении уникальности содержимого
отношения (Дэвид Роули)
Это позволяет применить оптимизацию, когда результирующий столбец имеет тип varchar.
• Устранение маловероятной потери сообщений NOTIFY вследствие зацикливания идентифика-
торов транзакций (Марко Тииккая, Том Лейн)
Если в сеансе не выполнялись никакие запросы, то есть он просто ждал уведомлений и за это
время прошло более 2 миллиардов транзакций, он начинал пропускать уведомления от парал-
лельно фиксируемых транзакций.
• Предупреждение сбоя SIGBUS в Linux, когда в памяти DSM запрашивается область объёма,
превышающего свободный объём в tmpfs (Томас Мунро)
• Предотвращение маловероятного сбоя при рекурсивном срабатывании триггеров (Том Лейн)
• Реализована возможность использовать режим FREEZE команды COPY на уровне изоляции
транзакций REPEATABLE READ или выше (Ной Миш)
Этот сценарий использования был непреднамеренно потерян вследствие предыдущего ис-
правления ошибки.
• Корректное восстановление значения umask при ошибке создания файла в COPY или
lo_export() (Питер Эйзентраут)
• Улучшение сообщения об ошибке в случае дублирующихся имён столбцов в ANALYZE (Натан
Боссарт)
• Исправление разбора последней строки в файле pg_hba.conf, завершающемся не символом
перевода строки (Том Лейн)
• Исправление в pg_basebackup сравнения путей табличных пространств посредством приведе-
ния путей к канонической форме (Микаэль Пакье)
Это особенно полезно в Windows.
• Исправление libpq, чтобы для её работы не требовалось существование домашнего каталога
пользователя (Том Лейн)
В версии 10 невозможность найти домашний каталог при попытке прочитать ~/.pgpass счита-
лась критической ошибкой, но эта ситуация должна обрабатываться так же, как и отсутствие
данного файла. И в версии 10, и в ветвях предыдущих выпусков была допущена та же ошибка
при чтении ~/.pg_service.conf, хотя это было менее очевидно, так как данный файл исполь-
зовался только при указании имени службы.
• Исправление в libpq защиты от целочисленного переполнения в счётчике строк в PGresult
(Микаэль Пакье)
• Исправление в ecpg обработки объявлений курсора вне текущей области с переменными типа
указатель или массив (Михаэль Мескес)
• В ecpglib исправлена обработка обратной косой черты в строковых константах в зависимости
от значения standard_conforming_strings (Такаюки Цунакава)
• Игнорирование в ecpglib дробной части при вводе целочисленных значений в режиме совме-
стимости с Informix (Гао Цзэнци, Михаэль Мескес)
• Добавление отсутствующего предварительного требования temp-install для целей типа check в
Make (Ной Миш)
Некоторые невыполняемые по умолчанию тестовые процедуры, подобные make check, не про-
веряли актуальность временной инсталляции.
2425Замечания к выпуску
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией tzcode2017c
(Том Лейн)
Тем самым исправлены различные дефекты; единственное, что могут заметить пользователи
— правила перевода на летнее время для часового пояса с именем в стиле POSIX в отсутствие
файла posixrules в каталоге данных часового пояса теперь соответствуют текущему закону
США, а не действовавшему десять лет назад.
• Обновление данных часовых поясов до версии tzdata 2017c, включающее изменения правил
перехода на летнее время на Фиджи, в Намибии, Серверном Кипре, Судане, Тонга и на ост-
ровах Теркс и Кайкос, плюс корректировку исторических данных для Аляски, Апии, Бирмы,
Калькутты, Детройта, Ирландии, Намибии и Паго-Паго.
E.28. Выпуск 9.5.9
Дата выпуска:
2017-08-31
В этот выпуск вошло несколько исправлений, внесённых после версии 9.5.8. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.28.1. Миграция на версию 9.5.9
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.5.8, см. Раздел E.29.
E.28.2. Изменения
• Отображение сторонних таблиц в представлении information_schema.table_privileges (Пи-
тер Эйзентраут)
Раньше сторонние таблицы отображались в остальных связанных представлениях
information_schema, но отсутствовали в этом.
Так как определение этого представления устанавливается программой initdb, для решения
проблемы будет недостаточно обычного обновления. Если вы хотите исправить существую-
щую инсталляцию, вы можете от имени суперпользователя выполнить в psql:
SET search_path TO information_schema;
CREATE OR REPLACE VIEW table_privileges AS
SELECT CAST(u_grantor.rolname AS sql_identifier) AS grantor,
CAST(grantee.rolname AS sql_identifier) AS grantee,
CAST(current_database() AS sql_identifier) AS table_catalog,
CAST(nc.nspname AS sql_identifier) AS table_schema,
CAST(c.relname AS sql_identifier) AS table_name,
CAST(c.prtype AS character_data) AS privilege_type,
CAST(
CASE WHEN
-- object owner always has grant options
pg_has_role(grantee.oid, c.relowner, 'USAGE')
OR c.grantable
THEN 'YES' ELSE 'NO' END AS yes_or_no) AS is_grantable,
CAST(CASE WHEN c.prtype = 'SELECT' THEN 'YES' ELSE 'NO' END AS yes_or_no)
AS with_hierarchy
FROM (
SELECT oid, relname, relnamespace, relkind, relowner,
(aclexplode(coalesce(relacl, acldefault('r', relowner)))).* FROM pg_class
) AS c (oid, relname, relnamespace, relkind, relowner, grantor, grantee,
prtype, grantable),
pg_namespace nc,
2426Замечания к выпуску
pg_authid u_grantor,
(
SELECT oid, rolname FROM pg_authid
UNION ALL
SELECT 0::oid, 'PUBLIC'
) AS grantee (oid, rolname)
WHERE c.relnamespace = nc.oid
AND c.relkind IN ('r', 'v', 'f')
AND c.grantee = grantee.oid
AND c.grantor = u_grantor.oid
AND c.prtype IN ('INSERT', 'SELECT', 'UPDATE', 'DELETE', 'TRUNCATE',
'REFERENCES', 'TRIGGER')
AND (pg_has_role(u_grantor.oid, 'USAGE')
OR pg_has_role(grantee.oid, 'USAGE')
OR grantee.rolname = 'PUBLIC');
Это потребуется повторить для каждой базы данных, требующей исправления (включая
template0).
• Исправление обработки аварийного выхода (например, при получении SIGTERM) при попытке
выполнить ROLLBACK для прерванной транзакции (Том Лейн)
В таких ситуациях мог происходить сбой проверочного утверждения. В выпускаемых сборках
выход всё равно производился, но в журнал выводилось неуместное сообщение «cannot drop
active portal» (удалить активный портал нельзя).
• Удаление проверочного утверждения, которое могло нарушаться при аварийном выходе (Том
Лейн)
• Правильное обнаружение столбцов, имеющих тип диапазона или домена, который определён
поверх искомого составного или доменного типа (Том Лейн)
Определённые команды ALTER, меняющие определение составного или доменного типа, долж-
ны проверять, нет ли в базе данных значений этого типа, и прерываться, если они есть, так
как для изменения или обновления таких значений нет необходимой инфраструктуры. Ранее
эти проверки могли пропустить значения, обёрнутые в типы диапазонов или вложенные доме-
ны, что могло нарушить целостность в базе данных.
• Устранение сбоя в pg_restore при работе в параллельном режиме и использовании фай-
ла-списка объектов, подлежащих восстановлению (Фабрицио де Ройес Мелло)
• Исправление лексического анализатора ecpg, чтобы он принимал предложения RETURNING без
связанных переменных C (Михаэль Мескес)
Благодаря этому программы ecpg могут содержать SQL-конструкции, использующие
RETURNING внутри (например, внутри CTE), не определяя значения, которые будут возвращены
клиенту.
• Улучшение выбора флагов компилятора для PL/Perl в Windows (Том Лейн)
В результате этого исправления предотвращаются сбои PL/Perl, возможные из-за некор-
ректных предположений о ширине значений time_t. Побочным эффектом, который мо-
гут заметить разработчики расширений, стала ликвидация глобального определения
_USE_32BIT_TIME_T в сборках PostgreSQL для Windows. Это не должно приводить к проблемам,
так как тип time_t не используется ни в каких определениях API PostgreSQL.
• Исправление поведения make check при использовании альтернативной (не GNU) программы
make (Томас Мунро)
E.29. Выпуск 9.5.8
Дата выпуска:
2017-08-10
2427Замечания к выпуску
В этот выпуск вошли различные исправления, внесённые после версии 9.5.7. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.29.1. Миграция на версию 9.5.8
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы используете сторонние серверы данных, на которых для проверки подлинности
применяются пароли, прочитайте ниже первую запись в списке изменений.
Также, если вы обновляете сервер с более ранней версии, чем 9.5.7, см. Раздел E.30.
E.29.2. Изменения
• Дальнейшее ограничение видимости pg_user_mappings.umoptions для защиты паролей, сохра-
нённых в свойствах сопоставлений пользователей (Ной Миш)
Исправление дефекта CVE-2017-7486 оказалось некорректным: в результате пользова-
тель мог видеть свойства своего собственного сопоставления, даже когда он не имел пра-
ва USAGE для соответствующего стороннего сервера. В таких свойствах мог содержаться па-
роль, который должен задавать владелец сервера, а не сам пользователь. Так как представ-
ление information_schema.user_mapping_options не показывает свойства в таких случаях, и
pg_user_mappings не должно. (CVE-2017-7547)
Само по себе это исправление корректирует поведение только в новых базах данных, созда-
ваемых initdb. Если вы хотите применить это исправление к существующей базе данных, вам
нужно будет проделать следующие действия:</N></I-O-Read-Time></li>
  <li>Добавьте allow_system_table_mods = true в postgresql.conf и перезапустите сервер. (В
версиях, поддерживающих ALTER SYSTEM, вы можете воспользоваться этой командой для
изменения конфигурации, но перезапустить сервер потребуется всё равно.)</li>
  <li>В каждой базе данных кластера выполните от имени суперпользователя следующие ко-
манды:
SET search_path = pg_catalog;
CREATE OR REPLACE VIEW pg_user_mappings AS
SELECT
U.oid
AS umid,
S.oid
AS srvid,
S.srvname
AS srvname,
U.umuser
AS umuser,
CASE WHEN U.umuser = 0 THEN
‘public’
ELSE
A.rolname
END AS usename,
CASE WHEN (U.umuser &lt;&gt; 0 AND A.rolname = current_user
AND (pg_has_role(S.srvowner, ‘USAGE’)
OR has_server_privilege(S.oid, ‘USAGE’)))
OR (U.umuser = 0 AND pg_has_role(S.srvowner, ‘USAGE’))
OR (SELECT rolsuper FROM pg_authid WHERE rolname =
current_user)
THEN U.umoptions
ELSE NULL END AS umoptions
FROM pg_user_mapping U
LEFT JOIN pg_authid A ON (A.oid = U.umuser) JOIN
pg_foreign_server S ON (U.umserver = S.oid);
3.
Не забудьте внести коррективы в базах данных template0 и template1, в противном случае
уязвимость сохранится в базах, которые будут создаваться впоследствии. Чтобы поправить
2428Замечания к выпуску
template0, вам потребуется временно разрешить подключения к ней. В PostgreSQL 9.5 и
новее вы можете выполнить
ALTER DATABASE template0 WITH ALLOW_CONNECTIONS true;
, а внеся поправку в template0, восстановить прежнее состояние командой
ALTER DATABASE template0 WITH ALLOW_CONNECTIONS false;
В более ранних версиях вместо этого используйте пару команд
UPDATE pg_database SET datallowconn = true WHERE datname = ‘template0’;
UPDATE pg_database SET datallowconn = false WHERE datname = ‘template0’;
4.
В заключение удалите параметр конфигурации allow_system_table_mods и ещё раз пере-
запустите postmaster.
• Запрет пустых паролей для всех методов аутентификации по паролю (Хейкки Линнакангас)
Библиотека libpq игнорирует пустое указание пароля и не передаёт его на сервер. Поэтому,
если пароль пользователя пустой, psql и другие клиенты на базе libpq не позволяют подклю-
читься с таким паролем. Как следствие, администратор может решить, что установка пустого
пароля равнозначна запрету входа по паролю. Однако с изменённым клиентом или клиентом
не на базе libpq подключение оказывается возможным, в зависимости от настроенного метода
аутентификации. В частности, самый распространённый метод, md5, принимает пустые паро-
ли. В результате этого изменения сервер не будет принимать пустые пароли во всех случаях.
(CVE-2017-7546)
• Добавление в lo_put() проверки права UPDATE для целевых больших объектов (Том Лейн, Ми-
каэль Пакье)
Функция lo_put(), несомненно, должна требовать наличия тех же прав, что и lowrite(), но
такая проверка отсутствовала, что позволяло пользователю менять данные в большом объек-
те. (CVE-2017-7548)
• Исправление в документации описания процесса обновления резервных серверов с использо-
ванием pg_upgrade (Брюс Момджян)
Ранее в документации говорилось, что нужно запустить/остановить ведущий сервер после за-
пуска pg_upgrade, но до синхронизации резервных серверов. Однако эта последовательность
небезопасна.
• Исправление одновременной блокировки цепочки изменённых кортежей (Альваро Эррера)
Когда цепочка изменённых кортежей блокируется одновременно несколькими сеансами в
неконфликтующем режиме с использованием старого снимка, и все операции завершаются
успешно, существовала возможность, что некоторые из них, несмотря на это, нарушатся (и
заключат, что актуальной версии кортежа нет) из-за условий гонки. В частности, вследствие
этого проверка внешнего ключа могла не увидеть кортеж, который определённо существует,
но изменяется параллельной операцией.
• Устранение риска повреждения данных при замораживании кортежа, в котором XMAX равен
идентификатору мультитранзакции с ровно одним ещё востребованным членом (Фёдор Сига-
ев)
• Предупреждение целочисленного переполнения и краха при сортировке в памяти более чем
одного миллиарда кортежей (Сергей Копосов)
• В Windows необходимо повторять попытки создания процесса в случае ошибки при резервиро-
вании диапазона адресов разделяемой памяти в новом процессе (Том Лейн, Амит Капила)
Это должно устранить периодические сбои при запуске дочерних процессов, возможно, вы-
званные вмешательством антивирусных программ.
• Устранение маловероятной возможности повреждения разделяемой хеш-таблицы предикат-
ных блокировок в сборках для Windows (Томас Мунро, Том Лейн)
2429Замечания к выпуску
• Предотвращение вывода в журнал сообщения о штатном закрытии SSL-соединения (поведе-
ние должно быть таким же, как и при сбросе соединения) (Микаэль Пакье)
• Запрещение передачи сеансовых билетов SSL клиентам (Том Лейн)
Это исправление устраняет сбои при переподключении клиентов с реализациями SSL, в кото-
рых эти билеты используются.
• Исправление кода, устанавливающего tcp_keepalives_idle в Solaris (Том Лейн)
• Исправление дефекта в сборщике статистики, приводящего к потере запросных сообщений,
выдаваемых сразу после перезапуска главного процесса (Том Лейн)
Запросы статистики, выдаваемые в течение полсекунды после предыдущего отключения глав-
ного процесса, по сути терялись.
• Размер приёмного буфера в сборщике статистики должен быть не меньше 100 Кбайт (Том
Лейн)
Это снижает риск потери данных статистики на старых платформах, где размер приёмного бу-
фера по умолчанию меньше.
• Устранение возможности создания некорректного сегмента WAL при повышении резервного
сервера сразу после того, как он обрабатывает запись XLOG_SWITCH (Андрес Фройнд)
• Процесс walsender должен завершаться своевременно, когда клиент инициирует выключение
(Том Лейн)
• Исправление обработки сигналов SIGHUP и SIGUSR1 в процессах walsender (Петр Желинек,
Андрес Фройнд)
• Предотвращение панического состояния, которое могут вызвать процессы walsender во время
контрольной точки при выключении (Андрес Фройнд, Микаэль Пакье)
• Устранение неоправданной паузы при перезапуске процессов walreceiver, возникающей
вследствие условий гонки в главном процессе (Том Лейн)
• Устранение утечки маленьких подтранзакций, оказывающихся на диске при логическом деко-
дировании (Андрес Фройнд)
В результате образовывались временные файлы, занимающие лишнее место на диске.
• Оптимизация операций, необходимых для получения снимков при создании слотов логическо-
го декодирования (Андрес Фройнд, Петр Желинек)
Предыдущий алгоритм оказывался очень неэффективным на сервере со множеством откры-
тых транзакций.
• Устранение условий гонки, при которых создание слотов логического декодирования могло
откладываться на неопределённое время (Андрес Фройнд, Петр Желинек)
• Уменьшение издержек при обработке событий сброса системного кеша (Том Лейн)
Это особенно полезно для логического декодирования, когда сброс кеша происходит часто.
• Исправление поведения в ситуациях, когда INSERT или UPDATE присваивает более одного эле-
мента столбцу с типом домена на базе массива (Том Лейн)
• Разрешение использования оконных функций во вложенных SELECT в аргументах агрегатной
функции (Том Лейн)
• Предупреждение конфликта имён с автоматически генерируемыми типами массивов при вы-
полнении ALTER … RENAME (Вик Фиринг)
Ранее автоматически сгенерированный тип массива во избежание конфликта переименовы-
вался при выполнении CREATE; данное исправление распространяет это поведение и на опера-
ции переименования.
2430Замечания к выпуску
• Устранение потери указателя в ALTER TABLE когда для ограничения, принадлежащего табли-
це, добавлен комментарий (Дэвид Роули)
При повторном применении комментария к воссозданному ограничению мог произойти сбой
со странным сообщением или даже с аварийным завершением.
• Добавление для команды ALTER USER … SET всех вариантов синтаксиса, что принимает
ALTER ROLE … SET (Питер Эйзентраут)
• Обновление информации о зависимости при смене типа аргумента или возврата для функции
ввода/вывода с opaque на целевой тип (Хейкки Линнакангас)
CREATE TYPE изменяет функции ввода/вывода, объявленные в давно устаревшем стиле, но ин-
формация о зависимости от этого типа не записывалась, в результате чего после команд DROP
TYPE могли оставаться дефектные определения функций.
• Сокращение использования памяти при обработке командой ANALYZE столбцов tsvector
(Хейкки Линнакангас)
• Устранение ненужной потери точности и небрежного округления при умножении и делении
значений money на целые числа или числа с плавающей точкой (Том Лейн)
• Уточнение проверок пробельных символов в функциях, разбирающих идентификаторы, напри-
мер regprocedurein() (Том Лейн)
В зависимости от используемой локали эти функции могли неправильно воспринимать фраг-
менты многобайтных символов как пробелы.
• Использование уместных символов #define из Perl при сборке PL/Perl (Ашутош Шарма, Том
Лейн)
Это предупреждает проблемы переносимости, обычно проявляющиеся в виде ошибок «про-
верки совместимости» в момент загрузки библиотеки при использовании последних версий
Perl.
• Обеспечение в libpq корректного сброса состояния аутентификации GSS/SASL и SSPI после
неудачной попытки подключения (Микаэль Пакье)
Ранее этот сброс не выполнялся и при переходе с SSL-соединения на не SSL ошибка GSS/SASL
при попытке SSL-подключения мешала затем установить обычное подключение, без SSL. С
SSPI этого не происходило, но имела место утечка памяти.
• В psql устранён сбой, возникающий, когда команда COPY FROM STDIN завершалась вводом сиг-
нала EOF с клавиатуры, а затем следовала ещё одна попытка выполнить COPY FROM STDIN (То-
мас Мунро)
Это некорректное поведение наблюдалось в системах, основанных на BSD, (включая macOS),
но не в других.
• Исправление программ pg_dump и pg_restore, чтобы команды REFRESH MATERIALIZED VIEW вы-
давались в конце (Том Лейн)
Это предотвращает ошибки при выгрузке/восстановлении данных, когда материализованное
представление ссылается на таблицы, принадлежащие другому пользователю.
• Улучшение вывода в pg_dump/pg_restore сообщений об ошибках, возникающих в zlib (Влади-
мир Кунщиков, Альваро Эррера)
• Исправление поведения pg_dump с ключом –clean, чтобы событийные триггеры удалялись
должным образом (Том Лейн)
Теперь также правильно назначаются владельцы событийных триггеров; ранее после запуска
скрипта восстановления такие триггеры оказывались принадлежащими суперпользователю.
• Исправление дефекта в pg_dump, когда для пустого класса операторов выдавался некоррект-
ный SQL (Даниэль Густафссон)
2431Замечания к выпуску
• Исправление вывода pg_dump в stdout на платформе Windows (Кунтал Гхош)
Сжатые данные выгрузки в текстовом виде при выводе в stdout оказывались испорченными
из-за того, что дескриптор файла не переводился в двоичный режим.
• Исправление вывода pg_get_ruledef() для правила ON SELECT, связанного с представлением,
в котором переименовывались столбцы (Том Лейн)
В некоторых особых случаях pg_dump использует pg_get_ruledef() для выгрузки представле-
ний, так что эта ошибка могла приводить к сбоям при выгрузке/загрузке.
• Исправление выгрузки внешних соединений с пустыми ограничениями, получающихся, на-
пример, в результате NATURAL LEFT JOIN без общих столбцов (Том Лейн)
• Исправление выгрузки выражений с функциями в предложении FROM в случаях, когда эти вы-
ражения не преобразуются в нечто, напоминающее вызов функции (Том Лейн)
• Исправление вывода pg_basebackup в stdout на платформе Windows (Харибабу Комми)
Архивируемые данные при выводе в stdout оказывались испорченными из-за того, что де-
скриптор файла не переводился в двоичный режим.
• Исправление pg_rewind для корректной работы с файлами больше 2 ГБ (Кунтал Гхош, Мика-
эль Пакье)
Обычно такие файлы в каталогах данных PostgreSQL не образуются, но в некоторых случаях
они могут появиться.
• Исправление pg_upgrade, чтобы в конечной записи в WAL не оказалось wal_level = minimum
(Брюс Момджян)
Это могло препятствовать переподключению обновлённых резервных серверов.
• Исправление в pg_xlogdump вычисления длины записи WAL (Андрес Фройнд)
• В postgres_fdw соединения к удалённым серверам должны устанавливаться заново после ко-
манд ALTER SERVER и ALTER USER MAPPING (Кётаро Хоригути)
Благодаря этому изменения параметров, затрагивающие свойства соединения, вступят в силу
своевременно.
• В postgres_fdw реализована отмена команд управления удалёнными транзакциями (Роберт
Хаас, Рафия Сабих)
Это изменение позволяет быстрее прервать ожидание неотвечающего удалённого сервера в
большем количестве случаев, чем раньше.
• Увеличение MAX_SYSCACHE_CALLBACKS для выделения дополнительного места расширениям
(Том Лейн)
• При сборке разделяемых библиотек с gcc всегда должен передаваться ключ -fPIC, а не -fpic
(Том Лейн)
Это позволяет поддерживать библиотеки расширений большего размера на тех платформах,
где эти ключи не равнозначны.
• Экранирование фигурных скобок в наших сборочных скриптах для Microsoft MSVC во избежа-
ние предупреждений или ошибок с новыми версиями Perl (Эндрю Дунстан)
• Для сборок MSVC реализована обработка ситуации, когда библиотека OpenSSL находится не в
подкаталоге VC (Эндрю Дунстан)
• Для сборок MSVC добавлен нужный путь для заголовочных файлов libxml2 (Эндрю Дунстан)
Это устраняет прежнюю необходимость перемещения файлов в стандартной инсталляции
libxml2 в Windows.
• Сборки MSVC должны распознавать библиотеку Tcl с именем tcl86.lib (Ной Миш)
2432Замечания к выпуску
• В сборках MSVC должны учитываться флаги в параметре PROVE_FLAGS, заданном в командной
строке vcregress.pl (Эндрю Дунстан)
E.30. Выпуск 9.5.7
Дата выпуска:
2017-05-11
В этот выпуск вошли различные исправления, внесённые после версии 9.5.6. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.30.1. Миграция на версию 9.5.7
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы используете сторонние серверы данных, на которых для проверки подлинности
применяются пароли, прочитайте ниже первую запись в списке изменений.
А если вы используете сторонние средства репликации, основанные на «логическом декодирова-
нии», обратите внимание на четвёртую запись в списке изменений.
Также, если вы обновляете сервер с более ранней версии, чем 9.5.6, см. Раздел E.31.
E.30.2. Изменения
• Ограничение видимости pg_user_mappings.umoptions для защиты паролей, сохранённых в
свойствах сопоставлений пользователей (Микаэль Пакье, Фейке Стинберген)
Предыдущая реализация позволяла владельцу объекта стороннего сервера или любому, кто
получил право USAGE, видеть свойства всех сопоставлений, связанных с этим сервером. В том
числе это могли быть и пароли других пользователей. Теперь определение данного представ-
ления изменено для соответствия поведению information_schema.user_mapping_options, так
что эти свойства может прочитать только собственно пользователь сопоставления либо, если
это сопоставление роли PUBLIC, владелец сервера, либо суперпользователь. (CVE-2017-7486)
Само по себе это исправление корректирует поведение только в новых базах данных, созда-
ваемых initdb. Если вы хотите применить это исправление к существующей базе данных, сле-
дуйте исправленной процедуре в списке изменений, относящейся к CVE-2017-7547, в Разде-
ле E.29.
• Предотвращение утечки статистической информации через негерметичные операторы (Питер
Эйзентраут)
Некоторые функции оценки избирательности в планировщике применяют пользовательские
операторы к значениям, получаемым из pg_statistic, например, к наиболее частым значе-
ниям и элементам гистограммы. Это происходит до проверки прав доступа к таблице, так что
злонамеренный пользователь может воспользоваться этим и получить подобные значения из
столбцов таблицы, чтение которых ему запрещено. Для устранения этой уязвимости следует
переходить к общим оценкам, если функция, реализующая оператор, не считается герметич-
ной и вызывающий её пользователь не имеет права на чтение столбца, статистика по которо-
му требуется планировщику. На практике в большинстве случаев одно из этих условий выпол-
няется. (CVE-2017-7484)
• Восстановление восприятия библиотекой libpq переменной окружения PGREQUIRESSL (Даниэль
Густафссон)
Поддержка этой переменной окружения была непреднамеренно ликвидирована в PostgreSQL
9.3, но в документации она осталась. Это создало угрозу безопасности, так как пользовате-
ли могли рассчитывать на то, что она будет требовать SSL-шифрования подключений, но на
самом деле этого не происходило. Теперь эта переменная воспринимается как и раньше, но
имеет меньший приоритет, чем PGSSLMODE, во избежание нарушения конфигураций, работаю-
щих корректно с версиями после 9.3. (CVE-2017-7485)
2433Замечания к выпуску
• Исправление потенциально некорректного начального снимка при логическом декодирова-
нии (Петр Желинек, Андрес Фройнд)
Изначальный снимок, создаваемый для слота репликации с логическим декодированием, мог
быть некорректным. В результате сторонние средства, использующие логическое декодирова-
ние, могли получать неполные/несогласованные начальные данные. Вероятность такого сбоя
увеличивалась, если при создании слота исходный сервер был загружен либо уже существо-
вал другой логический слот.
Если вы используете средство репликации, основанное на логическом декодировании, и копи-
ровали непустой набор данных в начале репликации, имеет смысл пересоздать реплику после
установления этого обновления либо сверить содержимое базы с исходным сервером.
• Исправление потенциального повреждения «слоёв инициализации» нежурналируемых индек-
сов (Роберт Хаас, Микаэль Пакье)
Это повреждение могло приводить к переходу нежурналируемого индекса в ошибочное состо-
яние после сбоя и перезапуска сервера. Устранить возникшую проблему можно было, только
удалив и перестроив индекс.
• Исправление ошибочного восстановления записей pg_subtrans при воспроизведении резерв-
ным сервером подготовленных, но не зафиксированных двухфазных транзакций (Том Лейн)
В большинстве случаев это не имело никаких болезненных последствий, но в особых ситуаци-
ях могло приводить к зацикливанию ссылок в pg_subtrans, что, в свою очередь, провоцирова-
ло бесконечные циклы в запросах, обращающимся к строкам, изменённым двухфазной тран-
закцией.
• Предотвращение возможного сбоя в walsender при ошибке инициализации буфера строки
(Стас Кельвич, Фудзии Масао)
• Предупреждение возможного сбоя при повторном сканировании индекса GiST с использова-
нием только индекса и поиском ближайших соседей (Том Лейн)
• Исправление поведения postmaster при обработке сбоя fork() для фонового рабочего процес-
са (Том Лейн)
Ранее postmaster модифицировал элементы своего состояния так, как будто процесс был запу-
щен успешно, что впоследствии приводило к замешательству.
• Устранение сбоев или неверных ответов в случаях, когда тип данных столбца в GROUPING SETS
является хешируемым, но не сортируемым (Паван Деоласи)
• Исключение применения оптимизации «физического целевого списка» к нестандартным ска-
нированиям (Дмитрий Иванов, Том Лейн)
Эта оптимизация предполагала, что получить все столбцы кортежа можно недорого, что дей-
ствительно верно для обычных кортежей Postgres, но с нестандартными провайдерами скани-
рования это может быть не так.
• Использование правильного подвыражения при применении политики защиты на уровне
строк FOR ALL (Стивен Фрост)
В некоторых случаях применялось ограничение WITH CHECK, хотя более уместным было бы
ограничение USING.
• Обеспечение видимости результатов непосредственно предшествующих DDL при разборе за-
просов в скриптах расширений (Жульен Рухо, Том Лейн)
Из-за того, что кеш между командами в скрипте расширения не сбрасывался, запрос к дан-
ным мог не наблюдать эффектов непосредственно предшествующего ему изменения каталога,
например результатов ALTER TABLE … RENAME.
• Ликвидация проверки прав доступа к табличному пространству при перестроении существую-
щего индекса командой ALTER TABLE … ALTER COLUMN TYPE (Ной Миш)
2434Замечания к выпуску
Это команда выдавала ошибку, если вызывающий пользователь не имел права CREATE для таб-
личного пространства, содержащего индекс. Такое поведение малополезно, так что стоит ис-
ключить эту проверку и разрешить перестраивать индекс там, где он находился.
• Предотвращение рекурсивного обращения команды ALTER TABLE … VALIDATE CONSTRAINT к
дочерним таблицам когда ограничение помечено как NO INHERIT (Амит Ланготе)
Это предупреждает нежелательные сбои типа «constraint does not exist» (ограничение не су-
ществует) в случаях, когда в дочерних таблицах нет соответствующего ограничения.
• Устранение потери указателя в COPY … TO когда для исходной таблицы активна защита на
уровне строк (Том Лейн)
Обычно это не имело болезненных последствий, но иногда всё же приводило к неожиданным
ошибкам и сбоям.
• Предупреждение обращения к уже закрытому элементу relcache в CLUSTER и VACUUM FULL (Том
Лейн)
При особом стечении обстоятельств это могло приводить к тому, что индексы в целевом отно-
шении перестраивались с неправильным режимом сохранения.
• Исправление ошибки команды VACUUM, когда она неправильно учитывала страницы, которые
не могла прочитать из-за конфликтующих закреплений страниц (Эндрю Гирт)
Это провоцировало недооценивание количества кортежей в таблице. В худшем случае с чрез-
вычайно востребованной таблицей команда VACUUM могла ошибочно сообщить, что таблица во-
все не содержит кортежей, что приводило к очень плохим решениям при планировании.
• Обеспечение возможности прерывания циклов массовой передачи кортежей в соединении по
хешу при попытке отмены запроса (Том Лейн, Томас Мунро)
• Исправление проблем с переполнением целочисленных значений при сравнении типов
interval (Кётаро Хоригути, Том Лейн)
Операторы сравнения для типа interval могли выдавать неверные ответы для интервалов,
превышающих 296000 лет. Индексы по столбцам с такими большими значениями следует пе-
рестроить, так как они могут быть испорчены.
• Исправление функции cursor_to_xml(), чтобы она выдавала правильный результат с
tableforest = false (Томас Мунро, Питер Эйзентраут)
Ранее она не добавляла внешний элемент &lt;table&gt;.
• Устранение проблем с округлением в функциях float8_timestamptz() и make_interval()
(Том Лейн)
Эти функции отбрасывали дробную часть, а не округляли числа при преобразовании значения
с плавающей точкой к целому числу микросекунд; это могло приводить к неожиданным сдви-
гам результатов на единицу.
• Исправление функции pg_get_object_address() для членов семейств операторов (Альваро
Эррера)
• Улучшение производительности представления pg_timezone_names (Том Лейн, Дэвид Роули)
• Уменьшение издержек при управлении памятью для контекстов, содержащих множество
больших блоков (Том Лейн)
• Исправление неаккуратной обработки редких ошибок в lseek() и close() (Том Лейн)
В типичных ситуациях эти системные вызовы отрабатывают без ошибок, но в случае ошибки
код fd.c мог повести себя некорректно.
• Исправление некорректной проверки факта работы postmaster в виде службы Windows (Мика-
эль Пакье)
2435Замечания к выпуску
Вследствие ошибки для вывода сообщений мог выбираться системный журнал событий (там
где его на самом деле не было), так что запись сообщений фактически не производилась.
• Исправление в ecpg поддержки COMMIT PREPARED и ROLLBACK PREPARED (Масахико Савада)
• Исправление ошибки двойного освобождения при обработке строковых констант, заключён-
ных в доллары, в ecpg (Михаэль Мескес)
• В pg_dump исправлена пометка схемы и владельца для комментариев и меток безопасности
некоторых типов объектов БД (Джузеппе Брокколо, Том Лейн)
В простых случаях это не проявлялось никак, но например, при восстановлении с выбором
схемы, могли потеряться комментарии, которые в ней должны быть, из-за того, что они не бы-
ли помечены как принадлежащие схеме своего объекта.
• Предотвращение вывода командой pg_restore -l некорректного файла со списком объектов,
когда имена объектов SQL содержат символы перевода строки (Том Лейн)
Символы перевода строки заменяются пробелами, что достаточно для того, чтобы этот список
корректно обработала команда pg_restore -L.
• Исправление поведения pg_upgrade для корректного переноса комментариев и меток без-
опасности, связанных с «большими объектами» (BLOB) (Стивен Фрост)
Ранее такие объекты корректно переносились в новую базу данных, но связанные с ними ком-
ментарии и метки безопасности терялись.
• Улучшение обработки ошибок в функции pg_file_write() из contrib/adminpack (Ной Миш)
В частности, она не реагировала на ошибки в вызове fclose().
• Предупреждение утечки предыдущего безымянного соединения при установлении нового
безымянного соединения в contrib/dblink (Джо Конвей)
• Исправление извлечения триграмм из регулярных выражений в contrib/pg_trgm (Том Лейн)
В некоторых случаях это могло приводить к формированию испорченной структуры данных,
для которой отсутствуют какие-либо соответствия. Вследствие этого при сканировании по ин-
дексам GIN и GiST с использованием триграмм для регулярного выражения могли не нахо-
диться никакие результаты.
• В contrib/postgres_fdw реализована передача требования отмены запроса удалённому серве-
ру (Микаэль Пакье, Эцуро Фудзита)
Ранее требование на отмену локального запроса не влекло за собой досрочную отмену уда-
лённого запроса, уже переданного на выполнение. Это доработка ранее была реализована в
9.6 и теперь перенесена в 9.5.
• Поддержка Tcl 8.6 в сборках с MSVC (Альваро Эррера)
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией tzcode2017b
(Том Лейн)
Это устраняет ошибку с некоторыми вариантами перехода на летнее время в январе 2038.
• Обновление данных часовых поясов до версии tzdata 2017b, включающее изменение правил
перехода на летнее время в Чили, Монголии и на Гаити, а также исторические изменения для
Эквадора, Казахстана, Либерии и Испании. Переход к числовым аббревиатурам для ряда ча-
совых поясов в Южной Америке, в Тихом и Индийском океанах, а также в некоторых азиат-
ских и ближневосточных странах.
Ранее в базе данных часовых поясов IANA предоставлялись текстовые аббревиатуры для
всех часовых поясов и иногда при этом указывались аббревиатуры, которые практически не
употреблялись местным населением. Сейчас происходит процесс ухода от этой практики в
пользу использования числовых смещений UTC в тех часовых поясах, где нет никаких свиде-
2436Замечания к выпуску
тельств реального использования английской аббревиатуры. Как минимум на данном этапе,
PostgreSQL продолжит принимать подобные удалённые аббревиатуры при вводе дат/времени.
Но они не будут видны при просмотре представления pg_timezone_names и не будут выводить-
ся с датами/временем.
• Использование корректных правил перехода на летнее время для названий часовых поясов в
стиле POSIX при сборке с MSVC (Дэвид Роули)
Сборочные скрипты для MSVC не устанавливали корректно файл posixrules в дерево катало-
гов timezone. Это приводило к тому, что код timezone переходил к использованию встроенных
представлений о том, какой вариант перехода на летнее время применим для названия поя-
са в стиле POSIX. По историческим причинам это соответствует правилам, которые действо-
вали в США до 2007 г. (то есть переход на летнее время происходил в первое воскресенье ап-
реля, а на зимнее — в последнее воскресенье октября). С этим исправлением для часового по-
яса с названием в стиле POSIX будут использоваться текущие и исторические даты перехода
для пояса US/Eastern. Если для вас это нежелательно, удалите файл posixrules или замени-
те его файлом другого часового пояса (см. Подраздел 8.5.3). Учтите, что вследствие кеширо-
вания вам потребуется перезапустить сервер, чтобы подобные изменения вступили в силу.
E.31. Выпуск 9.5.6
Дата выпуска:
2017-02-09
В этот выпуск вошли различные исправления, внесённые после версии 9.5.5. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.31.1. Миграция на версию 9.5.6
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если в вашей инсталляции проявилась ошибка, описанная в первой записи следующего
списка изменений, после обновления вам может потребоваться предпринять дополнительные дей-
ствия для исправления испорченных индексов.
Также, если вы обновляете сервер с более ранней версии, чем 9.5.5, см. Раздел E.32.
E.31.2. Изменения
• Исправление поведения в особых условиях, которое приводило к повреждению индексов, со-
здаваемых командой CREATE INDEX CONCURRENTLY (Паван Деоласи, Том Лейн)
Если команда CREATE INDEX CONCURRENTLY применялась для построения индекса, зависящего
от столбца, ранее не индексированного, то у строк, изменяемых транзакциями, выполняемы-
ми одновременно с командой CREATE INDEX, могли оказываться некорректные записи в индек-
се. В случае подозрений, что вас это коснулось, самое надёжное решение — перестроить та-
кие индексы после установки этого обновления.
• Предотвращение утери специального снимка, используемого при сканированиях каталога,
при преждевременной очистке данных (Tom Lane)
Рабочие процессы не учитывали этот снимок, сообщая о своём самом старом xmin, что остав-
ляло возможность для удаления по-прежнему нужных данных параллельными операциями
очистки. Это приводило к появлению плавающих ошибок с сообщениями «ошибка поиска в
кеше для отношения 1255».
• Исправление некорректной записи в WAL, формируемой для индексов BRIN (Кунтал Гхош)
Запись WAL, выдаваемая для страницы BRIN «revmap» при перемещении кортежа индекса в
другую страницу, была некорректной. При воспроизведении журнала соответствующая часть
индекса становилась непригодной, и её требовалось вычислять заново.
• Безусловное фиксирование в WAL создания «слоя инициализации» для нежурналируемых таб-
лиц (Микаэль Пакье)
2437Замечания к выпуску
Ранее это действие пропускалось при wal_level = minimal, но на самом деле это необходимо
даже в этом случае, чтобы нежурналируемая таблица корректно создавалась пустой после
сбоя.
• Сокращение взаимоблокировок на резервных серверах при воспроизведении операций очист-
ки индекса-B-дерева (Саймон Риггс)
Это изменение исключает существенные задержки при репликации, которые иногда имели
место при воспроизведении таких операций.
• Если процесс сборщика статистики потерян, перезапускать его и в режиме горячего резерва
(Такаюки Цунакава)
• Обеспечение корректной работы механизма уведомлений горячего резерва, когда он включа-
ется при запуске резервного сервера (Антс Аасма, Крейг Рингер)
• Проверка прерываний в момент ожидания конфликтующего запроса сервером горячего ре-
зерва (Саймон Риггс)
• Предупреждение постоянного перезапуска процесса запуска автоочистки в особых случаях
(Амит Хандекар)
Это исправление решает проблему, возникавшую, когда автоочистка номинально отключена
и есть несколько таблиц, требующих «заморозки», но эти таблицы уже обработаны рабочими
процессами автоочистки.
• Исправление проверки на возможность удаления объекта, принадлежащего расширению (Том
Лейн)
Скрипты обновления расширений должны иметь возможность удалять объекты расширений,
но это запрещалось для последовательностей со столбцами serial, а также, возможно, в других
случаях.
• Команда ALTER TABLE должна сохранять назначения табличных пространств индексам при пе-
рестраивании индексов (Том Лейн, Микаэль Пакье)
Ранее с нестандартными значениями default_tablespace были возможны разрушения индек-
сов.
• Исправление некорректного изменения свойств триггерной функции при изменении свой-
ства «откладываемости» ограничения внешнего ключа с помощью команды ALTER TABLE …
ALTER CONSTRAINT (Том Лейн)
Это приводило к странным сбоям при последующем обращении к внешнему ключу, так как
триггеры срабатывали не в положенное время.
• Недопущение удаления ограничения внешнего ключа при наличии событий, ожидающих об-
работки триггерами, для целевого отношения (Том Лейн)
Это предотвращает ошибки «не удалось найти триггер NNN» и «в отношении NNN нет тригге-
ров».
• Исправление поведения ALTER TABLE … SET DATA TYPE … USING в случаях, когда порядок
столбцов в дочерней таблице отличается от родительской (Альваро Эррера)
Вследствие того, что столбцы в выражении USING не перенумеровывались, возникала ошибка,
обычно такая: «атрибут N имеет неправильный тип».
• Исправление обращения к столбцу OID в случаях, когда таблица с таким столбцом связывает-
ся с родительской, тоже с OID, посредством ALTER TABLE … INHERIT (Амит Ланготе)
В таких случаях столбец OID должен обрабатываться как обычный пользовательский столбец,
но этого не происходило, что приводило к странному поведению при последующих изменени-
ях наследования.
2438Замечания к выпуску
• Исправление поведения CREATE OR REPLACE VIEW — запрос представления должен изменяться
до применения новых параметров представления (Дин Рашид)
Ранее в команде происходил сбой, если новые параметры оказывались несогласованными со
старым определением представления.
• Получение правильного идентификатора объекта в ALTER TEXT SEARCH CONFIGURATION (Артур
Закиров)
Ранее расширениям, таким как модули логического декодирования, выдавался неправильный
OID каталога.
• Предупреждение сбоев механизма учёта времени транзакций при запросе особых XID
(FrozenTransactionId и BootstrapTransactionId) (Крейг Рингер)
• Проверка конфликтов сериализуемости перед тем, как будет выдана ошибка нарушения огра-
ничений (Томас Мунро)
В транзакциях сериализуемого уровня изоляции желательно, чтобы ошибка, вызванная па-
раллельными транзакциями, заявлялась как ошибка сериализации, что скажет приложению,
что попытка повторить то же действие может быть успешной. К сожалению, это не будет на-
дёжно работать при дублировании ключа при параллельном его добавлении. В результате это-
го изменения такая ошибка будет выдаваться как ошибка сериализации, если приложение яв-
но проверяет присутствие конфликтующего ключа (и не находит его) до этого в транзакции.
• Исправление некорректного использования reloptions представлений как reloptions обычных
таблиц (Том Лейн)
Симптомами ошибки были неуместные сообщения «ON CONFLICT не поддерживается
для таблицы …, служащей таблицей каталога» когда целевым отношением INSERT … ON
CONFLICT было представление с каскадной проверкой.
• Исправление некорректного сообщения «допустимое число элементов в целевом списке огра-
ничено N» при использовании ON CONFLICT с широкими таблицами (Том Лейн)
• Предотвращение разворачивания foo.* в набор столбцов в исходном выражении UPDATE (Том
Лейн)
Это приводило к ошибкам с сообщением «несоответствие целевого количества в UPDATE —
внутренняя ошибка». Теперь эта запись воспринимается как обозначение переменной «вся-
строка», как и в других контекстах.
• Обеспечение точного определения модификаторов типа столбцов в конструкциях VALUES с
несколькими строками (Том Лейн)
Это устраняет проблемы, возникавшие, когда первое значение в столбце имеет воспринима-
емый модификатор типа (например, длину значения varchar), но последующие значения не
разделяют его ограничение.
• При нахождении незаконченной суррогатной пары Unicode в конце строки символов Unicode
должна выдаваться ошибка (Том Лейн)
Обычно за начальным суррогатным символом Unicode должно следовать продолжение, но
это не проверялось когда такой начальный символ оказывался последним в строке символов
Unicode (U&amp;’…’) или в Unicode-идентификаторе (U&amp;”…”).
• Определённо отрицательному поисковому запросу, например, !foo, должны удовлетворять пу-
стые значения tsvector (Том Дунстан)
Такие соответствия находились при поиске по индексу GIN, но не при последовательном ска-
нировании или поиске по индексу GiST.
• Предотвращение сбоя в ситуации, когда ts_rewrite() заменяет поддерево не верхнего уровня
пустым запросом (Артур Закиров)
2439Замечания к выпуску
• Устранение проблем с производительностью в ts_rewrite() (Том Лейн)
• Исправление обработки в ts_rewrite() вложенных операторов NOT (Том Лейн)
• Увеличение скорости пользовательских агрегатов, использующих в качестве перехода функ-
цию array_append() (Том Лейн)
• Исправление array_fill() для корректной обработки пустых массивов (Том Лейн)
• Предупреждение возможных сбоев в функциях array_position() и array_positions() при об-
работке массивов записей (Джун-сок Янг)
• Устранение выхода на один байт за границу буфера в функции quote_literal_cstr() (Хейкки
Линнакангас)
Этот выход имел место только если входная строка содержала исключительно апострофы и/
или обратные косые черты.
• Предотвращение одновременного выполнения вызовов pg_start_backup() и
pg_stop_backup() (Микаэль Пакье)
Это предупреждает сбой проверки истинности и, вероятно, худшие последствия, в случае, ес-
ли кто-то попытается запустить эти функции параллельно.
• Отключение трансформации, которая пыталась оптимизировать бесполезные преобразования
AT TIME ZONE (Том Лейн)
Вследствие этого выдавались неверные результаты, когда упрощённое выражение использова-
лось в условии индекса.
• Сохранение приведений interval-в-interval, которые на самом деле несут смысловую на-
грузку (Том Лейн)
В некоторых случаях приведения, которые должны были обнулять младшие поля значений
interval, ошибочно считались бессмысленными и просто убирались. В результате, например,
при приведении значения типа INTERVAL MONTH к INTERVAL YEAR поле месяцев не обнулялось.
• Исправление ошибок при передаче значений параметров GUC параллельным исполнителям
(Микаэль Пакье, Том Лейн)
• Аннулирование кешированных планов при изменениях в параметрах сторонних таблиц (Амит
Ланготе, Эцуро Фудзита, Ашутош Бапат)
• Исправление pg_dump для корректной выгрузки пользовательских приведений и преобразова-
ний, использующих встроенные функции (Стивен Фрост)
• Реализация более разумного поведения pg_restore с –create –if-exists в случаях, когда
архив содержит нераспознанные команды DROP (Том Лейн)
Это не устраняет никакую наблюдаемую ошибку, но может улучшить поведение в будущем,
при использовании pg_restore с архивом, созданным предыдущей версией pg_dump.
• Исправление ограничения нагрузки pg_basebackup при низкой скорости ввода/вывода (Анто-
нин Хоуска)
Если скорость диска на время оказывалась ниже заданного ограничения, в вычислении про-
исходило переполнение, и в результате ограничение отключалось до конца операции.
• Обеспечение корректной работы pg_basebackup с подкаталогами pg_stat_tmp и pg_replslot,
являющимися символическими ссылками (Магнус Хагандер, Микаэль Пакье)
• Предотвращение возможного сбоя pg_basebackup на резервном сервере при задействовании
файлов WAL (Амит Капила, Роберт Хаас)
• Исправление возможного дефекта при обработке развёрнутых массивов в ограничениях-про-
верках доменов и в конструкциях CASE (Том Лейн)
2440Замечания к выпуску
Существовала вероятность, что функция PL/pgSQL, вызванная в этих контекстах, изменит или
даже удалит значение массива, которое должно сохраняться для дополнительных операций.
• Исправление рекурсивного вызова функций PL/pgSQL в таких контекстах, как проверки огра-
ничений домена, выполняемые при присвоении значения переменной PL/pgSQL (Том Лейн)
• Обеспечение правильного учёта объектов исключений Python, создаваемых нами для PL/
Python, счётчиками использования (Рафа де ла Торре, Том Лейн)
Это предотвращает ошибки, возникавшие при использовании объектов после цикла уборки
мусора в Python.
• Исправление в PL/Tcl поддержки триггеров для таблиц, в которых имеется столбец .tupno
(Том Лейн)
Это соответствует (ранее недокументированному) поведению команд PL/Tcl spi_exec и
spi_execp, в том, что особый столбец .tupno добавляется, только если отсутствует настоящий
с таким именем.
• В файлах ~/.pgpass должны допускаться завершения строк в стиле DOS, даже на Unix-плат-
формах (Вик Фиринг)
Это изменение упрощает использование одних и тех же файлов паролей на машинах с Unix и
Windows.
• Устранение выхода на один байт за границу буфера, когда ecpg передаётся имя файла, кото-
рое заканчивается точкой (Такаюки Цунакава)
• Исправление в psql дополнения табуляцией для команды ALTER DEFAULT PRIVILEGES (Жиль
Даролд, Стивен Фрост)
• В psql пустое или содержащее только пробелы значение переменной окружения PAGER долж-
но означать «без постраничника» (Том Лейн)
Ранее с таким значением вывод, предназначенный для постраничника, просто исчезал.
• Улучшение в contrib/dblink передачи сообщений о низкоуровневых ошибках libpq, напри-
мер, о нехватке памяти (Джо Конвей)
• Реализация contrib/dblink должна игнорировать невоспринимаемые ей параметры серве-
ра, когда в качестве источника параметров подключения используется сторонний сервер
contrib/postgres_fdw (Кори Хинкер)
Ранее, если объект стороннего сервера имел параметры, которые не относились к параметрам
подключения libpq, происходила ошибка.
• Исправление проблем с переносимостью в функциях contrib/pageinspect, связанных с ин-
дексами GIN (Питер Эйзентраут, Том Лейн)
• В Windows изменённые переменные окружения должны передаваться и отладочным DLL
(Кристина Ульрих)
• Синхронизация нашей копии библиотеки timezone с выпущенной IANA версией tzcode2016j
(Том Лейн)
Это решило ряд проблем; в частности, проблему при установке данных о часовых поясах в ка-
талог, в котором не поддерживаются жёсткие ссылки.
• Обновление данных часовых поясов до версии tzdata 2016j, включающее изменения правил
перехода на летнее время на Северном Кипре (добавление нового пояса Asia/Famagusta), в
России (добавление нового пояса Europe/Saratov), в Тонга и в Антарктике/Кейси, плюс коррек-
тировку исторических данных для Италии, Казахстана, Мальты и Палестины. Переход к пред-
почитаемому числовому обозначению пояса для Тонга.
2441Замечания к выпуску
E.32. Выпуск 9.5.5
Дата выпуска:
2016-10-27
В этот выпуск вошли различные исправления, внесённые после версии 9.5.4. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.32.1. Миграция на версию 9.5.5
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если в вашей инсталляции проявилась ошибка, описанная в первой записи следующего
списка изменений, после обновления вам может потребоваться предпринять дополнительные дей-
ствия для исправления испорченных карт свободного места.
Также, если вы обновляете сервер с более ранней версии, чем 9.5.2, см. Раздел E.35.
E.32.2. Изменения
• Корректировка записи в WAL отметки об очистке карт свободного пространства и видимости
(Паван Деоласи, Хейкки Линнакангас)
Ранее могло получаться так, что эти файлы не восстанавливались корректно при восстановле-
нии после сбоя или оказывались неправильными на резервном сервере. Обращение к недей-
ствительному содержимому карты свободного пространства могло повлечь попытки использо-
вать страницы, которые были стёрты из самого отношения, что обычно приводило к ошибкам
типа «не удалось прочитать блок XXX: прочитано только 0 из 8192 байт». Также были возмож-
ны нарушения контрольных сумм в карте видимости, при включённом механизме контроль-
ных сумм.
Процедуры для определения наличия проблемы и её исправления рассматриваются в https://
wiki.postgresql.org/wiki/Free_Space_Map_Problems.
• Исправление некорректного создания в WAL записей, относящихся к индексам GIN, на маши-
нах с порядком байт от старшего (Том Лейн)
Типичным симптомом данной проблемы были ошибки «unexpected GIN leaf action» (неожидан-
ное действие на уровне листьев GIN) при воспроизведении WAL.
• Исправление команды SELECT FOR UPDATE/SHARE, чтобы кортежи, изменённые впоследствии
прерванной транзакцией, блокировались корректно (Альваро Эррера)
Начиная с версии 9.5, команда SELECT иногда могла вообще не выдавать такие кортежи. Под-
тверждений того, что это могло иметь место в предыдущих версиях, не было, но теоретически
при одновременных изменениях это возможно.
• Исправление перепроверок EvalPlanQual в ситуациях со сканированием CTE (Том Лейн)
Перепроверка всегда воспринимала такие CTE, как не возвращающие строки, в результате че-
го обычно не удавалось изменить строки, которые были изменены недавно.
• Исправлено удаление спекулятивно добавленных кортежей TOAST при выходе из INSERT …
ON CONFLICT (Оскари Сааренмаа)
В условиях гонки, когда две транзакции пытаются вставить конфликтующие кортежи, в проиг-
равшей транзакции происходила ошибка «попытка удаления невидимого кортежа», если при
добавлении вставлялись поля TOAST.
• Предотвращение ошибок сериализации при операции добавлении данных, конфликтующей с
собой же, в INSERT … ON CONFLICT (Томас Мунро, Питер Геохеган)
• Исправление некорректного повторения предыдущих результатов агрегирования по хешу в
подзапросе (Эндрю Гирт)
2442Замечания к выпуску
Проверка возможности повторного использования ранее вычисленной хеш-таблицы со значе-
ниями состояния агрегата не учитывала то, что в выражении агрегируемого аргумента мог-
ла фигурировать ссылка на внешний запрос. В этом случае изменение в значении этой ссылки
должно было приводить к пересчёту хеш-таблицы, но этого не происходило.
• Ликвидирована утечка памяти на протяжении запроса в массовой команде UPDATE для табли-
цы с индексом PRIMARY KEY или REPLICA IDENTITY (Том Лейн)
• Исправление COPY со списком имён столбцов из таблицы, в которой включена защита на уров-
не строк (Адам Брайтвелл)
• Исправление EXPLAIN, чтобы она выдавала корректный XML, когда параметр track_io_timing
включён (Маркус Винанд)
Ранее вывод в формате XML содержал синтаксически некорректные теги, как например &lt;I/O-
Read-Time&gt;. Сейчас выдаётся такой тег: <I-O-Read-Time>.
• Подавление вывода нулей для неизмеренного времени в EXPLAIN (Максим Милютин)
При определённом сочетании параметров команда EXPLAIN выдавала нулевые значения для
того времени, которое на самом деле даже не замеряется при этих параметрах. Мы придер-
живаемся политики не выдавать такие поля в выводе EXPLAIN, так что нужно обеспечить со-
гласованность во всех случаях.
• Исправление обновления статистики при TRUNCATE в подготовленной транзакции (Стас Кель-
вич)
• Исправление длительности таймаута, установленного для ожидания командой VACUUM исклю-
чительной блокировки, чтобы она могла опустошить таблицу (Саймон Риггс)
Длительность таймаута должна была составлять 50 миллисекунд, но на самом деле это было
лишь 50 микросекунд, в результате чего команда VACUUM оставляла попытку опустошить таб-
лицу гораздо раньше, чем планировалось. Теперь устанавливается запланированное значе-
ние.
• Исправление ошибок при объединении наследуемых ограничений CHECK в процессе создания
или изменения структуры таблицы (Том Лейн, Амит Ланготе)
Теперь одинаковые ограничения CHECK могут добавляться в родительскую и дочернюю таб-
лицу в любом порядке. С другой стороны, слияние проверенного ограничения из родитель-
ской таблицы с непроверенным (NOT VALID) ограничением в дочерней не должно допускаться.
Подобным образом, не должно допускаться слияние дочернего ненаследуемого (NO INHERIT)
ограничения с наследуемым.
• Вывод разумного значения в pg_settings.unit для параметров min_wal_size и max_wal_size
(Том Лейн)
• Ликвидация искусственных ограничений на значения, принимаемые функциями
numeric_in() и numeric_recv() (Том Лейн)
Мы принимаем числовые значения, не превышающие предела хранения (больше 1e100000),
поэтому кажется довольно неразумным, что numeric_in() не принимала в научной записи
экспоненты больше 1000. Также нет смысла не принимать в numeric_recv() более 1000 цифр
во вводимом значении.
• Предотвращение очень маловероятного повреждения данных в результате проверки видимо-
сти кортежа без удержания блокировки буфера (Томас Мунро, Питер Геохеган, Том Лейн)
• Сохранение времени фиксирования транзакций после перезагрузки сервера (Жульен Рухо,
Крейг Рингер)
При включённом параметре track_commit_timestamp старые метки времени фиксации стано-
вились недоступными после полной перезагрузки сервера.
2443Замечания к выпуску
• Исправление логического декодирования WAL в случаях, когда вывод WAL из подтранзакции
оказывался слишком большим и вымещался на диск (Андрес Фройнд)
• Исправление возможной ошибки сортировки при прекращении использования сокращённых
ключей (Питер Геохеган)
В худшем случае это могло приводить к повреждению индекса-B-дерева, что потребует пере-
строить его с помощью команды REINDEX. Но, как нам представляется, такие ситуации очень
редки.
• Ликвидация утечки дескриптора файла, имевшей место при опустошении временного отноше-
ния размером более 1 Гбайта (Андрес Фройнд)
• Запрещение запуска самостоятельного обслуживающего процесса при включённом режиме
standby_mode (Микаэль Пакье)
Такой режим не будет ничем полезен, так как никакой процесс-приёмник WAL не сможет по-
лучать данные WAL; и это может привести к некорректному поведению кода, который не рас-
считан на такую ситуацию.
• Исправление инициализации состояния слота репликации при повторном использовании сло-
та (Микаэль Пакье)
В результате того, что не все поля слота сбрасывались, команда VACUUM могла не удалять
«мёртвые» кортежи.
• Округление размера запроса разделяемой памяти до числа, кратного размеру огромной стра-
ницы, когда огромные страницы используются в Linux (Том Лейн)
Это позволяет избежать возможных сбоев в munmap() в системах с нетипичными размерами
огромных страниц. За исключением случаев краха, эти сбои проявлялись только в сообщениях
в журнале.
• Выбор более случайного значения для идентификатора управляющего сегмента динамиче-
ской разделяемой памяти (Роберт Хаас, Том Лейн)
Ранее каждый раз выбиралось одно и то же значение, потому что оно получалось из random(),
но srandom() к этому моменту ещё не вызывалась. Это относительно безвредно, однако плани-
ровалось другое поведение.
• В Windows нужно повторять попытку создания управляющего сегмента динамической разде-
ляемой памяти после ошибки «нет доступа» (Кётаро Хоригути, Амит Капила)
Иногда Windows выдаёт ошибку ERROR_ACCESS_DENIED вместо ERROR_ALREADY_EXISTS, когда та-
кой сегмент уже существует. Получая такую ошибку, главный процесс не мог запуститься,
считая, что столкнулся с неисправимой ошибкой.
• Исправление в PL/pgSQL поведения с параметрами и локальными переменными типов
int2vector и oidvector (Том Лейн)
• Не пытаться разделять контекст SSL между несколькими подключениями в libpq (Хейкки
Линнакангас)
Такое разделение приводило к разнообразным ошибкам, особенно при попытке использова-
ния различных параметров SSL для разных соединений.
• Предотвращение утечек памяти в особых случаях в libpq (Том Лейн)
Поступило сообщение об утечке в процессе PQreset(), но были возможны проявления и в свя-
занных случаях.
• Согласование поведения параметров --help и --version программы ecpg со всеми остальны-
ми нашими программами (Харибабу Комми)
• Исправление расчёта средней задержки в pgbench (Фабьен Коэльо)
2444Замечания к выпуску
Этот расчёт был неверным при наличии в скрипте команд \sleep или когда длительность те-
ста ограничивалась числом транзакций, а не общим временем.
• В pg_upgrade проверка загружаемости библиотек должна производиться по порядку имён
(Том Лейн)
Это обходное решение проблемы зависимостей между расширениями, образуемых связями
модулей трансформации языков с базовыми модулями самих языков и типов данных.
• Программа pg_dump никогда не должна выгружать функции-конструкторы диапазонов (Том
Лейн)
В результате такой выгрузки программа pg_upgrade не могла справиться с расширениями,
включающими диапазонные типы, пытаясь дважды создать их функции-конструкторы.
• При запуске pg_dump с ключом -C должно подавляться предложение TABLESPACE команды
CREATE DATABASE, если указан ключ --no-tablespaces (Том Лейн)
• Исправление работы pg_receivexlog с ключом --synchronous без слотов (Габриэль Бартолини)
• Недопущение одновременного указания аргументов --source-server и --source-target для
pg_rewind (Михаэль Банк)
• Программа pg_rewind должна отключать synchronous_commit в своём сеансе на исходном сер-
вере (Михаэль Банк, Микаэль Пакье)
При этом pg_rewind сможет работать, даже когда на исходном сервере настроена синхронная
репликация, но она по какой-то причине не функционирует.
• В pg_xlogdump нужно повторять попытку открыть новый сегмент WAL, когда используется па-
раметр --follow (Магнус Хагандер)
Это позволяет справиться с возможной задержкой при создании сервером следующего сег-
мента.
• Исправление программы pg_xlogdump, чтобы она корректно работала с файлом WAL, начина-
ющимся с записи продолжения, располагающейся на нескольких страницах (Паван Деоласи)
• Исправление contrib/pg_buffercache для работы со значением shared_buffers, превышаю-
щим 256 Гбайт (КайГай Кохэй)
• Исправление скрипта contrib/intarray/bench/bench.pl, чтобы он выводил результаты ко-
манды EXPLAIN, которую он выполняет при запуске с ключом -e (Даниэль Густафссон)
• Поддержка OpenSSL 1.1.0 (Хейкки Линнакангас)
• Внедрение инфраструктуры тестирования TAP, чтобы её можно было применять для тестиро-
вания расширений (Крейг Рингер)
Когда PostgreSQL конфигурируется с параметром --enable-tap-tests, теперь команда «make
install» будет устанавливать файлы поддержки Perl для тестирования TAP туда, где PGXS смо-
жет найти их. Благодаря этому внешние расширения смогут использовать $(prove_check) без
дополнительных проверок.
• В сборках MSVC программа pg_recvlogical включена в клиентский набор (МауМау)
• Корректировка сопоставления часовых поясов в Windows, чтобы сервер корректно распозна-
вал имена часовых поясов, появившиеся в последних версиях Windows (Микаэль Пакье)
• Предупреждение ошибок при использовании устаревших аббревиатур динамических часовых
поясов (Том Лейн)
Если аббревиатуре динамического часового пояса не соответствует запись в данных часово-
го пояса, считать её равнозначной имени часового пояса. Это предупреждает неожиданные
ошибки, когда IANA удаляет аббревиатуры из своей базы данных часовых поясов, что произо-
шло в выпуске tzdata 2016f и, вполне вероятно, повторится в будущем. Вследствие этого не
2445Замечания к выпуску
только не распознавались отдельные аббревиатуры; при любом расхождении происходил сбой
в представлении pg_timezone_abbrevs.
• Обновление данных часовых поясов до версии tzdata 2016h, включающее изменение правил
перехода на летнее время в Палестине и Турции, а также исторические изменения для Тур-
ции и некоторых регионов России. Переход к числовым аббревиатурам для некоторых часовых
поясов в Антарктике, бывшем Советском Союзе и на Шри-Ланке.
Ранее в базе данных часовых поясов IANA предоставлялись текстовые аббревиатуры для
всех часовых поясов и иногда при этом указывались аббревиатуры, которые практически не
употреблялись местным населением. Сейчас происходит процесс ухода от этой практики в
пользу использования числовых смещений UTC в тех часовых поясах, где нет никаких свиде-
тельств реального использования английской аббревиатуры. Как минимум на данном этапе,
PostgreSQL продолжит принимать подобные удалённые аббревиатуры при вводе дат/времени.
Но они не будут видны при просмотре представления pg_timezone_names и не будут выводить-
ся с датами/временем.
Начиная с этого выпуска, аббревиатура AMT более не считается занятой часовым поясом Ар-
мении. Поэтому мы изменили значение этой аббревиатуры по умолчанию, чтобы она обозна-
чала Амазонское время (Amazon Time), так что теперь она означает UTC-4, а не UTC+4.
E.33. Выпуск 9.5.4
Дата выпуска:
2016-08-11
В этот выпуск вошли различные исправления, внесённые после версии 9.5.3. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.33.1. Миграция на версию 9.5.4
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.5.2, см. Раздел E.35.
E.33.2. Изменения
• Исправление некорректного вычисления вложенных выражений CASE-WHEN (Хейкки Линнакан-
гас, Микаэль Пакье, Том Лейн)
Выражение CASE, фигурирующее в подвыражении проверки другого выражения CASE, мог-
ло некорректно оценивать, отличается ли его собственное проверяемое значение от NULL.
Кроме того, встраивание SQL-функции, реализующей оператор равенства, который использу-
ется выражением CASE, может привести к передаче неправильного проверяемого значения
функциям, вызываемым в выражении CASE в теле функции SQL. Если же проверяемые значе-
ния оказываются разных типов, возможен сбой; более того, это может эксплуатироваться для
несанкционированного чтения областей памяти сервера. (CVE-2016-5423)
• Корректировка в клиентских программах обработки специальных символов в именах ролей и
баз данных (Ной Миш, Натан Боссарт, Микаэль Пакье)
Программа vacuumdb и другие клиентские утилиты во многих местах могли некорректно вос-
принимать имена ролей и баз данных, включающие кавычки или обратную косую черту. Те-
перь проверки ужесточены во избежание рисков. Также, когда этим программам вместо име-
ни базы передаётся строка подключения, она обрабатывается должным образом.
Приведение в соответствие с документацией правил обработки пар двойных кавычек в коман-
дах psql \connect и \password.
Введение нового параметра -reuse-previous для команды psql \connect, позволяющего явно
указывать, должны ли повторно использоваться параметры предыдущего подключения. (Без
данного параметра это, как и раньше, зависит от того, похоже ли имя базы данных на стро-
2446Замечания к выпуску
ку подключения.) Это позволяет безопасно оперировать с именами баз данных, содержащими
специальные символы, в скриптах pg_dumpall.
pg_dumpall теперь не будет принимать имена ролей или баз данных, содержащие символы пе-
ревода строки или возврата каретки, так как безопасно экранировать эти символы в Windows
не представляется практичным. В будущем мы можем запретить такие имена и на стороне
сервера, но пока это не сделано.
Эти коррективы считаются исправлениями уязвимостей, так как, сконструировав имена объ-
ектов специальным образом (используя спецсимволы), можно было сформировать произволь-
ные команды, которые выполнятся с правами суперпользователя, когда суперпользователь бу-
дет выполнять pg_dumpall или другие операции обслуживания базы. (CVE-2016-5424)
• Исправление некорректного в особых случаях поведения проверок IS NULL/IS NOT NULL, при-
меняемых к вложенным составным значениям (Эндрю Гирт, Том Лейн)
В стандарте SQL говорится, что проверка IS NULL должна возвращать TRUE для строки со все-
ми значениями NULL (то есть ROW(NULL,NULL) IS NULL выдаёт TRUE), но это не должно дей-
ствовать рекурсивно (то есть, ROW(NULL, ROW(NULL,NULL)) IS NULL выдаёт FALSE). В основном
исполнителе это реализовано правильно, но при некоторых оптимизациях планировщика эта
проверка рассматривалась как рекурсивная (и TRUE выдавалось в обоих случаях), кроме того,
обёртка contrib/postgres_fdw тоже могла выдавать удалённые запросы с подобным некор-
ректным поведением.
• Исправление ошибки «unrecognized node type» (нераспознанный тип узла) при INSERT ... ON
CONFLICT в рекурсивном CTE (элементе WITH) (Питер Геохеган)
• Исправление в INSERT ... ON CONFLICT сопоставления предикатов или выражений индексов,
которые были упрощены планировщиком на стадии предобработки выражений (Том Лейн)
• Правильная обработка нарушений ограничений-исключений, которые применяются к целе-
вой таблице команды INSERT ... ON CONFLICT, но не являются решающими индексами (Том
Лейн)
В таких случаях должна выдаваться обычная ошибка нарушения ограничения, но вместо это-
го код попадал в бесконечный цикл.
• Исправление INSERT ... ON CONFLICT, чтобы при наличии в целевой таблице уникального ин-
декса по OID не происходила ошибка (Том Лейн)
• Недопущение для типов данных inet и cidr входных адресов IPv6 со слишком большим коли-
чеством разделённых двоеточиями полей (Том Лейн)
• Предотвращение сбоя в close_ps() (операторе point ## lseg) для входных координат NaN
(Том Лейн)
В таких случаях должен просто возвращаться NULL.
• Предотвращение сбоя в функции pg_get_expr(), когда ей передаются несогласованные значе-
ния (Микаэль Пакье, Томас Мунро)
• Исправление в нескольких местах выхода на один байт за границу буфера в to_number() (Пи-
тер Эйзентраут)
В некоторых случаях функция to_number() могла читать из входной строки на один символ
больше, чем нужно. Это создавало небольшой риск сбоя в случае расположения входной стро-
ки у края блока памяти.
• Планировщик не должен запускаться для запроса, заданного в операторе CREATE
MATERIALIZED VIEW или CREATE TABLE AS с указанием WITH NO DATA (Микаэль Пакье, Том
Лейн)
Это предотвращает некоторые лишние условия ошибки, например, когда стабильная функция,
вызываемая материализованным представлением, зависит от ещё не существующей таблицы.
2447Замечания к выпуску
• Ликвидация небезопасного промежуточного состояния при выполнении heap_update() по
сложному пути (Масахико Савада, Андрес Фройнд)
Ранее в особых случаях целевой кортеж блокировался (путём изменения его XMAX), но это
действие не отражалось в журнале, что могло угрожать целостности данных, если страница
вымещалась на диск, а затем, до завершения изменения кортежа, происходил сбой базы.
• Исправление обновления вспомогательных битов при воспроизведении из WAL операций бло-
кирования строк (Андрес Фройнд)
Единственным известным последствием этой проблемы было то, что блокировки строк, удер-
живаемые подготовленной, но не зафиксированной транзакцией, могли теряться после сбоя и
перезапуска сервера.
• Предотвращение неоправданных ошибок «could not serialize access» (не удалось сериализо-
вать доступ) при получении блокировок строк FOR KEY SHARE в сериализуемом режиме (Альва-
ро Эррера)
• «Развёрнутые» данные, возвращаемые узлом плана, должны быть доступны только для чтения
(Том Лейн)
Это предотвращает сбои в некоторых случаях, когда результат нижнего узла плана неодно-
кратно задействуется в верхних узлах. Если говорить о ядре PostgreSQL, риску подвержены
только значения массивов, возвращаемые функциями PL/pgSQL; но расширения могут исполь-
зовать развёрнутые данные и для других целей.
• Предупреждение сбоя в postgres -C, когда указанная переменная имеет пустое строковое
значение (Микаэль Пакье)
• Предотвращение незапланированного ожидания приёмника в процессах, передающих WAL
(Кётаро Хоригути)
• Исправление возможной потери больших подтранзакций при логическом декодировании
(Петру-Флорин Миханча)
• Исправление сбоя логического декодирования, когда подтранзакция не содержит фактиче-
ских изменений (Марко Тииккая, Эндрю Гирт)
• Предоставление обслуживающим процессам актуальной статистики по общим каталогам (Том
Лейн)
Ранее сборщик статистики не мог обновлять файл статистики для общих каталогов по запросу
от обычного обслуживающего процесса. Эта проблема была частично скрыта, так как процесс
запуска автоочистки регулярно выдавал запросы, в результате которых такие обновления про-
изводились: однако она проявлялась при отключении автоочистки.
• Исключение ненужной записи в файлы статистики, когда несколько обслуживающих процес-
сов запрашивают обновление один за другим (Том Лейн, Томаш Вондра)
• Исключение потребления лишнего ID транзакции во время VACUUM (Александр Коротков)
В некоторых случаях в процессе VACUUM текущей транзакции без необходимости присваивался
XID. В обычных условиях это некритично, но если очистка выполняется для предотвращения
зацикливания идентификаторов транзакций, потребление дополнительных идентификаторов
может привести к очень плохим последствиям.
• Предотвращение риска сбоя при очистке идентификаторов мультитранзакций в инсталляции,
обновлённой (с помощью pg_upgrade) с версии старее 9.3 (Эндрю Гирт, Альваро Эррера)
Обычно этот дефект проявлялся в ошибках типа «MultiXactId NNN has not been created yet --
apparent wraparound» (MultiXactId %u ещё не был создан: видимо, произошло зацикливание).
• Когда в запускаемой вручную команде ANALYZE задаётся список столбцов, не нужно сбрасы-
вать счётчик changes_since_analyze целевой таблицы (Том Лейн)
2448Замечания к выпуску
Если мы анализируем только избранные столбцы, мы не должны предотвращать запуск проце-
дуры автоанализа для других столбцов.
• Исправление ошибки в ANALYZE с завышением показателя n_distinct для столбца, содержа-
щего уникальные или почти уникальные значениями и вместе с тем множество NULL (Том
Лейн)
Значения NULL могли учитываться как будто они сами являются уникальными, что приводи-
ло к серьёзным просчётам планировщика с запросами некоторых типов.
• Недопущение запуска при автоочистке нескольких рабочих процессов для одного общего ка-
талога (Альваро Эррера)
Обычно это не представляет большой проблемы, так как очистка выполняется быстро; но ес-
ли каталог очень сильно замусорен, это может привести к тому, что все рабочие процессы,
кроме одного, будут бессмысленно ждать, вместо того, чтобы делать что-то полезное с други-
ми таблицами.
• Исправление ошибки при обработке пометки/восстановления позиции в B-дереве (Кевин
Гриттнер)
Вследствие этой ошибки могли выдаваться некорректные результаты соединения или ошибоч-
ные утверждения при соединении слиянием, в котором внутренним узлом оказывалось скани-
рование индекса-B-дерева.
• Предупреждение двойного освобождения блокировки буфера при отказе от попытки удаления
страницы индекса-B-дерева (Том Лейн)
В результате этой ошибки процедура VACUUM не могла завершиться в некоторых случаях при
наличии проблем с индексами-B-деревьями.
• Исправление ошибки при построении больших (больше shared_buffers) хеш-индексов (Том
Лейн)
В коде, работающем с большими индексами, обнаружилась ошибка, приводящая к добавле-
нию в индекс некорректных хеш-значений, так что последующий поиск по индексу всегда был
безуспешным, кроме случаев, когда кортежи вставлялись в индекс уже после его создания.
• Предотвращение бесконечного цикла при построении индексов GiST для геометрических
столбцов с составными значениями, содержащими NaN (Том Лейн)
• Предупреждение сбоя при сканировании с поиском ближайших соседей (упорядоченно-
го (ORDER BY) по расстоянию) по индексу contrib/btree_gist, построенному по столбцу
interval (Питер Геохеган)
• Исправление ошибки «PANIC: failed to add BRIN tuple» (ПАНИКА: не удалось добавить кортеж
BRIN), возникавшей при попытке изменить элемент индекса BRIN (Альваро Эррера)
• Предупреждение возможных сбоев при остановке фонового рабочего процесса (Дмитрий Ива-
нов)
• Исправление поведения в PL/pgSQL предложения INTO внутри команд IMPORT FOREIGN SCHEMA
(Том Лейн)
• Исправление кода contrib/btree_gin, чтобы он корректно выдавал наименьшее возможное
значение bigint (Питер Эйзентраут)
• Наделение libpq способностью корректно декодировать версию сервера по схеме нумерации,
которая вскоре будет принята (Питер Эйзентраут)
Для выпусков после 9.6 планируется перейти на нумерацию версий по схеме с двумя, а не
тремя компонентами. Поэтому нужно, чтобы PQserverVersion() возвращала правильное зна-
чение с такой нумерацией.
2449Замечания к выпуску
• Исправление в ecpg кода обработки элементов массива unsigned long long (Михаэль Мескес)
• В pg_dump с одновременно заданными ключами -c и -C не должна выдаваться команда CREATE
SCHEMA public (Дэвид Джонсон, Том Лейн)
• Улучшение обработки SIGTERM/control-C в параллельном режиме pg_dump и pg_restore (Том
Лейн)
Обеспечение своевременного завершения рабочих процессов и передачи команд отмены за-
просов в подключённые рабочие процессы, в случае, если они выполняют какие-либо длитель-
ные операции, например CREATE INDEX.
• Корректировка выдачи ошибок в параллельном режиме pg_dump и pg_restore (Том Лейн)
Ранее ошибки, выдаваемые рабочими процессами pg_dump или pg_restore, могли никогда не
достигать консоли пользователя, так как они проходили через главный процесс, и были воз-
можны различные сценарии взаимоблокировки, когда главный процесс не мог передавать со-
общения. Теперь вместо этого всё будет просто выводиться в stderr. В некоторых случаях при
этом возможны повторы сообщений (например, когда все рабочие процессы сообщают об от-
ключении главного), но это представляется лучшим вариантом, чем терять сообщения.
• Обеспечение корректного отключения параллельных процессов pg_dump и pg_restore в
Windows в случае ошибки (Кётаро Хоригути)
Ранее процесс выдавал ошибку, но затем просто оставался в памяти, пока пользователь не
останавливал его вручную.
• Параллельный pg_dump должен завершаться штатно при попытке подключения к резервному
серверу (Магнус Хагандер)
Такое использование не поддерживается (если только не применяется --no-synchronized-
snapshots), но эта ошибка не обрабатывалась должным образом.
• Улучшение поведения pg_dump при сборке без поддержки zlib (Кётаро Хоригути)
С такой сборкой не работала корректно параллельная выгрузка, а в других случаях выдава-
лись довольно бессмысленные предупреждения.
• Добавление для pg_basebackup параметра -Z 0, позволяющего отключить сжатие (Фудзии Ма-
сао)
• Корректировка в makefile правила для безопасной сборки разделяемых библиотек AIX в па-
раллельном режиме (Ной Миш)
• Исправление тестов TAP и скриптов MSVC для работы с каталогом сборки, путь к которому со-
держит пробелы (Микаэль Пакье, Кётаро Хоригути)
• Более предсказуемое поведение в выборе ошибки «statement timeout» (тайм-аут оператора)
или «lock timeout» (тайм-аут блокировки) (Том Лейн)
В сильно загруженных системах регрессионные тесты иногда выдавали ошибку «lock timeout»
(тайм-аут блокировки), хотя прежде этого должен был случиться тайм-аут оператора.
• Адаптация регрессионных тестов к датской и валлийской локалям (Джефф Джейнс, Том
Лейн)
Изменены некоторые тестовые данные, с которыми в этих локалях действовали необычные
правила сортировки.
• Приведение нашей копии кодов часовых поясов в соответствие с выпущенной IANA версией
tzcode 2016c (Том Лейн)
Это необходимо для принятия ожидаемых в будущем изменений в файлах данных часовых по-
ясов. Также это решает некоторые редкие проблемы при работе с необычными часовыми поя-
сами.
2450Замечания к выпуску
• Обновление данных часовых поясов до версии tzdata 2016f, включающее новые правила пере-
хода на летнее время в Кемерове и Новосибирске, а также корректировку исторических дан-
ных для Азербайджана, Белоруссии и Марокко.
E.34. Выпуск 9.5.3
Дата выпуска:
2016-05-12
В этот выпуск вошли различные исправления, внесённые после версии 9.5.2. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.34.1. Миграция на версию 9.5.3
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако если вы обновляете сервер с более ранней версии, чем 9.5.2, см. Раздел E.35.
E.34.2. Изменения
• Очередь ошибок OpenSSL должна очищаться перед вызовом функций OpenSSL (не следует по-
лагать, что она уже очищена); мы также должны обязательно очищать её после вызова (Пи-
тер Геохеган, Дэйв Витек, Питер Эйзентраут)
Это изменение предотвращает проблемы, возникающие, когда несколько подключений ис-
пользуют OpenSSL в одном процессе и не весь участвующий в этом код очищает очередь оши-
бок по одним правилам. В частности, возникали ошибки, когда клиентское приложение ис-
пользовало SSL-подключения через libpq одновременно с SSL-подключениями, устанавливае-
мыми обёртками PHP, Python или Ruby для OpenSSL. Подобные проблемы могли иметь место и
на сервере, если модуль расширения устанавливал исходящее SSL-подключение.
• Исправление ошибки планировщика «не удалось построить N-стороннее соединение» с пол-
ным соединением, заключённым в правой части левого соединения (Том Лейн)
• Исправление некорректной обработки проверок класса эквивалентности в планах с много-
уровневыми вложенными циклами (Том Лейн)
С классом эквивалентности переменных с тремя или более элементами, например X.X = Y.Y
= Z.Z, планировщик мог опустить некоторые проверки, необходимые, чтобы удостовериться,
что все переменные действительно равны, в результате чего выдавались строки соединения,
не удовлетворяющие предложениям WHERE. По ряду причин некорректные планы редко выби-
рались на практике, поэтому эта ошибка оставалась необнаруженной долгое время.
• Исправление ошибок анализатора запроса в особых случаях при включённом параметре
operator_precedence_warning (Том Лейн)
Например, запрос SELECT (ARRAY[])::text[] давал ошибку, хотя без скобок он работал.
• Ликвидирована утечка памяти на протяжении запроса при сканировании индекса GIN (Жу-
льен Рухо)
• Ликвидирована утечка памяти на протяжении запроса и угроза повреждения индекса при до-
бавлении в индекс GIN (Том Лейн)
Эта утечка памяти обычно ни на что не влияла в простых запросах, но могла быть очень суще-
ственной при построении большого индекса GIN с большим значением maintenance_work_mem.
• Исправление возможного некорректного поведения кодов формата TH, th и Y,YYY в
to_timestamp() (Том Лейн)
С этими кодами был возможен выход за конец строки, в результате чего последующие коды
формата читали мусор.
• Исправление вывода правил и представлений, в которых аргумент массив в конструкции зна-
чение оператор ANY (массив) представляет собой вложенный SELECT (Том Лейн)
2451Замечания к выпуску
• Запрет на использование символов новой строки в значениях параметров ALTER SYSTEM (Том
Лейн)
При разборе файла конфигурации строки, содержащие символы новой строки, не принимают-
ся, поэтому мы не должны допускать их в значениях, вставляемых командой ALTER SYSTEM.
• Исправление поведения ALTER TABLE ... REPLICA IDENTITY USING INDEX в случае, когда вы-
бирается индекс по OID (Дэвид Роули)
• Исключение возможного некорректного поведения в случае неудачи при удалении символи-
ческой ссылки табличного пространства (Том Лейн)
• Исправление сбоя при логическом декодировании на платформах, чувствительных к выравни-
ванию (Том Лейн, Андрес Фройнд)
Этот сбой происходил, когда транзакция была достаточно большой, чтобы оказаться на диске,
и в ней происходило изменение первичного ключа.
• Исключение повторных обращений за ответом к приёмнику журнала при завершении процес-
са walsender (Ник Клитон)
• Использование в pg_regress тайм-аута запуска из переменной окружения PGCTLTIMEOUT, если
она задана (Том Лейн)
Это поведение согласуется с тем, что было недавно введено в pg_ctl; возможность задать
тайм-аут облегчает автоматизированное тестирование на медленных машинах.
• Исправление ошибки в pg_upgrade, из-за которой не восстанавливалось членство семейства
операторов, содержащего всего один класс операторов, в расширении (Том Лейн)
В таких случаях семейство операторов восстанавливалось в новую базу, но переставало быть
частью расширения. Это не приводило немедленно к негативным эффектам, но с выводом, вы-
даваемым впоследствии утилитой pg_dump, при восстановлении возникали ошибки (безвред-
ные).
• Исправление ошибки в pg_upgrade, приводившей к сбою, когда правила TOAST в новом кла-
стере отличались от старых (Том Лейн)
В pg_upgrade был специальный код для обработки ситуации, когда новая версия PostgreSQL
считала, что у таблицы должна быть дополнительная таблица TOAST, а старая версия считала
по-другому. Этот код был нерабочим, поэтому его следует удалить и ничего не делать в таких
случаях; похоже, что нет никаких причин полагать, что мы не сможем обойтись без таблицы
TOAST, если это было возможно по правилам старой версии.
• Исправление атомарных операций в коде для PPC, генерируемом компилятором IBM XLC
(Ной Миш)
• Уменьшение числа семафоров SysV, задействуемых сборкой, полученной с ключом --disable-
spinlocks (Том Лейн)
• Переименование внутренней функции strtoi() в strtoint() во избежание конфликта с биб-
лиотечной функцией NetBSD (Томас Мунро)
• Исправление кодов ошибок, получаемых из системных вызовов bind() и listen() в Windows
(Том Лейн)
• Уменьшение детализации вывода компилятора при сборке с Microsoft Visual Studio (Кристиан
Ульрих)
• Поддержка сборки с Visual Studio 2015 (Микаэль Пакье, Петр Желинек)
Учтите, что сборки, произведённые с VS2015, не будут работать в версиях Windows, более ран-
них чем Windows Vista.
• Исправление putenv() для корректной работы с Visual Studio 2013 (Микаэль Пакье)
2452Замечания к выпуску
• Исключение потенциально небезопасного использования функции FormatMessage() в
Windows (Кристиан Ульрих)
Использование флага FORMAT_MESSAGE_IGNORE_INSERTS, где это уместно. Сообщений о кон-
кретных связанных с этим ошибками не было, но проявить осторожность представляется хо-
рошей идеей.
• Обновление данных часовых поясов до версии tzdata 2016d, включающее изменения правил
перехода на летнее время в России и Венесуэле. Появились новые названия часовых поясов
Europe/Kirov и Asia/Tomsk, отражающие тот факт, что в этих регионах история изменения ча-
совых поясов отличается от соседних.
E.35. Выпуск 9.5.2
Дата выпуска:
2016-03-31
В этот выпуск вошли различные исправления, внесённые после версии 9.5.1. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.35.1. Миграция на версию 9.5.2
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
Однако вследствие изменения, идущего первым в следующем списке, для некоторых индексов мо-
жет потребоваться выполнить REINDEX.
E.35.2. Изменения
• Отключены сокращённые ключи при сортировке строк в локалях, отличных от C (Роберт Хаас)
В PostgreSQL 9.5 появилась логика ускорения сравнения строковых типов данных с примене-
нием стандартной функции библиотеки C strxfrm() вместо strcoll(). Сейчас обнаружилось,
что в большинстве версий glibc (реализации библиотеки С для Linux) функция strxfrm() реа-
лизована с ошибками, то есть для некоторых локалей с ней получаются результаты сравнения
строк, отличающиеся от strcoll(). Пока эта проблема не будет изучена глубже, такая опти-
мизация для всех локалей, отличных от C, отключается. (Локаль C от этого не зависит, так как
она не использует ни strcoll(), ни strxfrm().)
К сожалению, данная проблема затрагивает не только сортировку, но и упорядочивание запи-
сей в B-деревьях, а значит, индексы-B-деревья по столбцам типов text, varchar или char мо-
гут оказаться испорченными, если они сортировались с проблемной локалью и были построе-
ны или модифицированы версией PostgreSQL 9.5.0 или 9.5.1. Индексы, которые могли постра-
дать вследствие этой проблемы, следует перестроить (выполнив REINDEX) .
В данный момент невозможно определить исчерпывающий список проблемных локалей. Из-
вестно, что с локалью C всё в порядке, и с локалями английского языка, например, en_US, то-
же не замечено никаких проблем, но с некоторыми другими популярными локалями, напри-
мер de_DE, поведение некорректно в большинстве версий glibc.
• Корректное сохранение статуса защиты на уровне строк в кешируемых планах (Стивен Фрост)
В сеансе, выполняющем запросы с разными ролями, из кеша планов может быть некорректно
взят план, построенный для другой роли, что может привести к применению ошибочного на-
бора политик, когда активна защита на уровне строк (RLS). (CVE-2016-2193)
• В некоторые новые функции contrib/pageinspect добавлены проверки суперпользователя
(Андреас Зельтенрейх)
Большинство функций в расширении pageinspect, исследующие значения bytea, не допуска-
ют вызова обычными пользователями, но в brin_page_type() и brin_metapage_info() такие
ограничения отсутствуют. Однако, передав им изощрённо сформированные значения bytea,
2453Замечания к выпуску
можно вызвать крах сервера или прочитать несколько байт памяти сервера. Поэтому были до-
бавлены недостающие проверки во избежание подобных злоупотреблений. (CVE-2016-3065)
• Исправлено некорректное сравнение ROW() с применением индексов (Саймон Риггс)
Ошибки в небольшой оптимизации, введённой в 9.5, приводили к некорректным результатам,
если при сравнении ROW() имело место частичное соответствие индексу, но не точное (напри-
мер, когда порядок столбцов другой или в индексе есть столбцы с сортировкой и ASC, и DESC).
Пока лучшее решение не найдено, эта оптимизация отключена.
• Исправлена некорректная обработка NULL в сравнениях ROW() с применением индексов (Том
Лейн)
Поиск по индексу со сравнением строк вида ROW(a, b) &gt; ROW('x', 'y') останавливался, до-
ходя до элемента NULL в столбце b, игнорируя тот факт, что с последующими значениями a
могут быть связаны значения b, отличные от NULL.
• Предотвращение маловероятных сценариев потери данных в случае переименования фай-
лов без соответствующих вызовов fsync() до и после (Микаэль Пакье, Томаш Вондра, Андрес
Фройнд)
• Исправлено некорректное поведение при перепроверке только что изменённой строки в за-
просе, выполняющем SELECT FOR UPDATE/SHARE и обращающемся к отношениям, которые не
нужно блокировать (Том Лейн)
Строки из незаблокированных отношений некорректно воспринимались во время перепровер-
ки как полностью содержащие NULL, что могло привести к неправильному выводу о том, что
изменённая строка больше не удовлетворяет условию WHERE, или к выдаче NULL в результате.
• Исправлена ошибка в json_to_record(), возникавшая, когда поле входного объекта содержа-
ло вложенный объект с полем, имя которого совпадало с именем одного из запрошенных вы-
ходных столбцов (Том Лейн)
• Исправлен бессмысленный результат функции jsonb_object() в форме с двумя аргументами
при вызове с пустыми массивами (Микаэль Пакье, Эндрю Дунстан)
• Исправлено некорректное поведение в jsonb_set() при преобразовании элемента массива пу-
тей в целое значение для использования в качестве индекса массива (Микаэль Пакье)
• Исправлено некорректное форматирование отрицательных смещений часовых поясов в функ-
ции to_char() с применением кода формата OF (Томас Мунро, Том Лейн)
• Исправлена некорректное протоколирование событий ожидания, имеющих место в
INSERT ... ON CONFLICT (Питер Геохеган)
В выводимых сообщениях иногда отмечалось, что ожидание было вызвано ограничением-ис-
ключением, хотя такое ограничение было не при чём.
• Параметр recovery_min_apply_delay игнорируется, пока восстановление не достигло согласо-
ванного состояния (Микаэль Пакье)
Ранее, резервные серверы откладывали применение записей WAL, учитывая
recovery_min_apply_delay, даже при воспроизведении начальной порции WAL, необходимой
для приведения базы данных в рабочее состояние. Так как резервный сервер бесполезен, пока
он не достиг согласованного состояния базы данных, это кажется напрасным.
• Корректная обработка ситуаций, когда pg_subtrans на грани зацикливания XID при запуске
сервера (Джефф Джейнс)
• Исправление разнообразных ошибок в логическом декодировании (Андрес Фройнд)
Проблемы возникали с кортежами больше одной страницы с вариантом идентификации ре-
плики FULL, при выполнении команд UPDATE, изменяющих первичный ключ в транзакции, до-
статочно большой для выгрузки на диск, а также с некорректными ошибками «subxact logged
2454Замечания к выпуску
without previous toplevel record» (транзакция внесена в журнал без предыдущей записи верх-
него уровня) и с некорректным выводом времени фиксирования транзакций.
• Исправлена ошибка планировщика, возникавшая с вложенными представлениями с барьера-
ми безопасности, когда внешнее представление содержит предложение WHERE с коррелирую-
щим подзапросом (Дин Рашид)
• Ликвидирована утечка памяти при поиске по индексу GIN (Том Лейн)
• Предотвращён крах в исключительной ситуации при попытке повторно освободить строки, вы-
водимые localeconv() (Том Лейн)
• Исправлен разбор файлов аффиксов для словарей ispell (Том Лейн)
Код разбора мог работать неправильно, если файл аффиксов содержит символы, которые мо-
гут менять размер в байтах при преобразовании регистра, как например, символ I в турецких
локалях UTF8.
• Исключено использование sscanf() при разборе файлов словарей ispell (Артур Закиров)
Это устраняет проблему переносимости на платформы на базе FreeBSD (включая macOS).
• Исправление кода атомарных операций, генерируемого на PPC компилятором IBM xlc (Ной
Миш)
Эта ошибка приводила к редким сбоям при параллельных операциях на этой платформе.
• Предотвращение сбоя на старых версиях Windows (до 7SP1/2008R2SP1) с процессором с под-
держкой AVX2 и с Postgres, собранным компилятором Visual Studio 2013 (Кристиан Ульрих)
Это обходное решение проблемы в библиотеки выполнения Visual Studio 2013, которая, как
заявили в Microsoft, не будет исправляться в этой версии.
• В psql исправлена логика завершения команд табуляцией с учётом особенностей многобайт-
ных символов (Кётаро Хоригути, Роберт Хаас)
• В psql исправлено завершение табуляцией команды SECURITY LABEL (Том Лейн)
При нажатии TAB после ввода SECURITY LABEL мог произойти сбой или выдавались посторон-
ние ключевые слова.
• Команда pg_ctl теперь принимает тайм-аут ожидания из переменной среды PGCTLTIMEOUT, ес-
ли этот тайм-аут не задан в командной строке (Ной Миш)
Это упрощает тестирование более медленных узлов на ферме сборки, позволяя индивиду-
ально задавать время, превышающее обычное, для запуска и завершения главного процесса
(postmaster).
• Исправление ошибочной проверки состояния службы Windows в pg_ctl (Мануэль Матар)
В предыдущих корректирующих выпусках были попытки исправить pg_ctl, чтобы он правиль-
но определял, нужно ли отправлять сообщения в журнал событий Window, но в итоге провер-
ка оказалась противоположной.
• Исправлено поведение pgbench, чтобы сочетание параметров -C и -M prepared обрабатыва-
лось корректно (Том Лейн)
• В pg_upgrade теперь пропускается создание скрипта удаления, когда новый каталог данных
находится внутри старого (Брюс Момджян)
Выполнение этого скрипта «вслепую» в таких случаях приводило к потере нового каталога
данных.
• В PL/Perl пустые массивы Postgres стали корректно переводиться в пустые массивы Perl
(Алекс Хансакер)
• Код PL/Python адаптирован для работы с именами функций, не подходящими для идентифика-
торов Python (Джим Нэсби)
2455Замечания к выпуску
• Исправление ряда ошибок в статистике, возвращаемой функцией pgstatindex() из contrib/
pgstattuple (Том Лейн)
• Ликвидация зависимости от psed в сборках с MSVC, так как ядро Perl больше не предоставля-
ет её (Микаэль Пакье, Эндрю Дунстан)
• Обновление данных часовых поясов до версии tzdata 2016c, включающее изменения правил
перехода на летнее время в Азербайджане, Чили, на Гаити, в Палестине и России (в Алтай-
ском крае, Астраханской, Кировской и Ульяновской областях, а также на Сахалине), плюс
корректировку исторических данных для Литвы, Молдавии и России (для Калининграда, Са-
мары и Волгограда).
E.36. Выпуск 9.5.1
Дата выпуска:
2016-02-11
В этот выпуск вошли различные исправления, внесённые после версии 9.5.0. За информацией о
нововведениях версии 9.5 обратитесь к Разделу E.37.
E.36.1. Миграция на версию 9.5.1
Если используется версия 9.5.X, выгрузка/восстановление базы не требуется.
E.36.2. Изменения
• Исправлены проблемы с бесконечными циклами и переполнениями буфера в регулярных вы-
ражениях (Том Лейн)
С очень большими диапазонами символов в некоторых случаях можно было добиться беско-
нечного цикла, а в других — переполнения памяти. (CVE-2016-0773)
• Исправлено упущение, из-за которого в редких случаях при соединениях по хешу пропуска-
лось соединение некоторых кортежей внутреннего отношения (Томаш Вондра, Том Лейн)
• Предотвращено проталкивание предложений HAVING в подзапросы, когда применяются набо-
ры группирования (Эндрю Гирт)
• Исправление пересборки арбитра ON CONFLICT в предложении WHERE (Питер Геохеган)
• Спецкоды %h и %r в log_line_prefix стали работать в сообщениях, выдаваемых в режиме
log_connections (Том Лейн)
Ранее %h/%r начинали работать только после того, как новый сеанс выдавал сообщение
«connection received» (соединение получено); теперь они работают и для этого сообщения.
• Ликвидация утечки маркера в процессе аутентификации SSPI (Кристиан Ульрих)
• Исправлена команда \det в psql, чтобы она воспринимала шаблон, передаваемый ей в аргу-
менте, так же, как другие команды \d с шаблонами, которые могут дополняться схемами (Рис
Харт)
• Программа pg_ctl в Windows должна выбирать, куда направлять вывод, проверяя состояние
службы, а не то, что устройство стандартного вывода является терминалом (Микаэль Пакье)
• Исправление разнообразных ошибок в исключительных случаях при обработке объектов-чле-
нов расширений в pg_dump (Том Лейн)
• Исправлено некорректное заключение в кавычки имён ограничений доменов в pg_dump (Эл-
вис Пранскевичус)
• Теперь pg_dump помечает триггеры представления, чтобы они обрабатывались после правил,
во избежание ошибок при параллельном pg_restore (Том Лейн)
• Внедрение в pgbench защиты от переполнения в исключительных случаях при вычислении за-
данных в скрипте операторов деления или взятия остатка (Фабьен Коэльо, Микаэль Пакье)
2456Замечания к выпуску
• Подавление бесполезного предупреждения при подключении pg_receivexlog к серверу версии
до 9.4 (Марко Ненчарини)
• Решение проблем с выгрузкой/перезагрузкой данных при одновременном использовании
plpython2 и plpython3 (Том Лейн)
В принципе можно использовать обе версии PL/Python в одной базе данных, но не в одном се-
ансе (так как две версии libpython нельзя безопасно использовать одновременно). Однако и
pg_restore, и pg_upgrade в своей работе нарушают это ограничение одного сеанса. В качестве
обходного решения изменено время проверки версий.
• Исправление регрессионных тестов PL/Python для совместимости с Python 3.5 (Питер Эйзен-
траут)
• Недопущение установки определённых параметров PL/Java непривилегированными пользова-
телями (Ной Миш)
Это изменение ликвидирует угрозу, связанную с уязвимостью в PL/Java (CVE-2016-0766), ис-
правленной в PL/Java (эти параметры теперь доступны только суперпользователю). Чтобы лик-
видировать угрозу безопасности для тех серверов PostgreSQL, которые обновляются чаще,
чем PL/Java, это изменение внесено также в код ядра сервера.
• Исправление заголовочных файлов, поставляемых с ecpg: в директиву препроцессора не дол-
жен включаться комментарий, продолжающийся в следующей строке (Михаэль Мескес)
Такой комментарий не принимается препроцессором ecpg. Пока не вполне ясно, следует ли
скорректировать сам ecpg.
• Исправление в hstore_to_json_loose() проверки, можно ли преобразовать значение hstore в
число JSON (Том Лейн)
Ранее эту функцию можно было ввести в заблуждение не алфавитно-цифровыми замыкающи-
ми символами, что приводило к формированию синтаксически некорректного JSON.
• В contrib/postgres_fdw исправлены ошибки, вызванные использованием tableoid в коман-
дах, модифицирующих данные (Эцуро Фудзита, Роберт Хаас)
• Исправлено некорректно введённое ограничение NAMEDATALEN 256 байтами (Роберт Хаас, Том
Лейн)
• Улучшение воспроизводимости сборки путём обеспечения фиксированного порядка имён
файлов, передаваемых компоновщику (Кристоф Берг)
Это устраняет возможные двоичные различия создаваемых исполняемых файлов от сборки к
сборке.
• Включение dynloader.h в список устанавливаемых заголовочных файлов при сборке с MSVC
(Брюс Момджян, Микаэль Пакье)
• Обновление данных часовых поясов до версии tzdata 2016a, включающее изменения правил
перехода на летнее время на Каймановых островах, в Метлакалте и Забайкальском крае, плюс
корректировку исторических данных для Пакистана.
E.37. Выпуск 9.5
Дата выпуска:
2016-01-07
E.37.1. Обзор
В число ключевых усовершенствований PostgreSQL 9.5 входят:
• Возможность превращать команды INSERT, вызывающие конфликты ограничений, в команды
UPDATE, либо игнорировать их
• Добавление в GROUP BY аналитической функциональности: GROUPING SETS, CUBE и ROLLUP
2457Замечания к выпуску
• Добавление механизма защиты на уровне строк
• Создание механизмов для отслеживания прогресса репликации, включая средства идентифи-
кации источника отдельных изменений при логической репликации
• Добавление блочно-зональных индексов (BRIN)
• Существенное увеличение скорости сортировки
• Существенное увеличение производительности на многопроцессорных машинах
Предыдущие пункты более подробно описаны в следующих разделах.
E.37.2. Миграция на версию 9.5
Тем, кто хочет мигрировать данные из любой предыдущей версии, необходимо выполнить выгруз-
ку/загрузку данных с помощью pg_dumpall или воспользоваться pg_upgrade.
В версии 9.5 реализован ряд изменений, которые могут повлиять на совместимость с предыдущими
выпусками. Рассмотрите следующие несовместимые аспекты:
• Изменение приоритета операторов в соответствии со стандартом SQL (Том Лейн)
Приоритет операторов &lt;=, &gt;= и &lt;&gt; был понижен до приоритета операторов &lt;, &gt; и =. Приори-
тет проверок IS (например, x IS NULL) был понижен и стал непосредственно ниже приорите-
та этих шести операторов сравнения. Также операторы из нескольких слов, начинающиеся с
NOT, теперь имеют приоритет своего базового оператора (например, NOT BETWEEN теперь имеет
тот же приоритет, что и BETWEEN), тогда как раньше их приоритет был несогласованным; они
воспринимались как NOT по отношению к левому операнду, но при этом как базовый оператор
по отношению к правому. Новый параметр конфигурации operator_precedence_warning даёт
возможность получать предупреждения о запросах, в которых эти изменения приоритета при-
водят к другому результату разбора запроса.
• Смена в pg_ctl выбираемого по умолчанию режима отключения с smart на fast (Брюс Момд-
жян)
Это означает, что теперь по умолчанию сервер будет принудительно прерывать существую-
щие сеансы, а не просто ждать их завершения.
• Использование приведения присваивания для преобразований типов данных в присваиваниях
PL/pgSQL, вместо перевода в текстовый вид и обратно (Том Лейн)
Вследствие этого изменения при преобразовании булевых значений в строковые получаются
значения true и false, а не t и f. Другие преобразования типов могут быть успешны в боль-
шем числе случаев, чем раньше; например, при присвоении числового значения 3.9 цело-
численной переменной, ей будет присвоено 4, а не произойдёт ошибка, как раньше. Если для
некоторых исходного и целевого типов приведение присваивания не определено, PL/pgSQL
вернётся к старому поведению с преобразованием через вывод/ввод.
• Возможность использования экранирования обратной косой чертой символов в параметрах
командной строки сервера (Андрес Фройнд)
Ранее, пробелы в строке параметров всегда служили разделителями параметров, так что не
было никакой возможности включить пробел в значение параметра. Чтобы указать обратную
косую черту в значении параметра, теперь нужно написать \\.
• Изменение значения по умолчанию параметра GSSAPI include_realm на 1, чтобы по умолча-
нию имя области клиента не удалялось из имени принципала GSS или SSPI (Стивен Фрост)
• Замена параметра конфигурации checkpoint_segments параметрами min_wal_size и
max_wal_size (Хейкки Линнакангас)
Если вы ранее настраивали checkpoint_segments, следующая формула даст вам приблизи-
тельно эквивалентное значение:
2458Замечания к выпуску
max_wal_size = (3 * checkpoint_segments) * 16MB
Заметьте, что значение по умолчанию параметра max_wal_size стало гораздо больше, чем
раньше имел параметр checkpoint_segments, так что возможно, что корректировать этот па-
раметр больше не потребуется.
• Регулирование снятия процессов при нехватке памяти в Linux через новые переменные окру-
жения PG_OOM_ADJUST_FILE и PG_OOM_ADJUST_VALUE, вместо параметров времени компиляции
LINUX_OOM_SCORE_ADJ и LINUX_OOM_ADJ (Гуржит Сингх)
• Списание параметра конфигурации сервера ssl_renegotiation_limit, который стал устарев-
шим в предыдущих выпусках (Андрес Фройнд)
Хотя возможность повторного согласования SSL — хорошая вещь в теории, с ней связано до-
статочно ошибок, чтобы считать её скорее отрицательной на практике, и поэтому она будет
исключена в будущих версиях соответствующих стандартов. Учитывая это, мы убрали под-
держку этой возможности из PostgreSQL. Параметр ssl_renegotiation_limit сохранился, но
ему нельзя присвоить ничего, кроме нуля (то есть он всегда отключён). Также он больше не
описывается в документации.
• Удаление параметра конфигурации сервера autocommit, который уже был устаревшим и не
работал (Том Лейн)
• Удаление из каталога pg_authid поля rolcatupdate, так как оно было бесполезным (Адам
Брайтвелл)
• В системном представлении pg_stat_replication в поле sent теперь NULL, а не 0, представ-
ляет недействительное значение (Магнус Хагандер)
• Операторы извлечения элементов массивов json и jsonb теперь могут принимать отрицатель-
ные позиции, которые отсчитываются от конца массивов JSON (Питер Геохеган, Эндрю Дун-
стан)
Ранее эти операторы возвращали NULL для отрицательных позиций.
E.37.3. Изменения
Ниже вы найдёте подробный список изменений, произошедших между предыдущим основным вы-
пуском и выпуском PostgreSQL 9.5.
E.37.3.1. Сервер
E.37.3.1.1. Индексы
• Добавление блочно-зональных индексов (BRIN) (Альваро Эррера)
Индексы BRIN хранят только сводные данные (например, минимальные и максимальные зна-
чения) по зонам блоков в куче. Поэтому они очень компактны и легко обновляются; при этом,
если данные кластеризованы натуральным образом, такие индексы позволяют очень суще-
ственно ускорить операции поиска.
• Реализация возможности выполнять в запросах точную фильтрацию по дистанции для объек-
тов (многоугольников, кругов), индексируемых по описанным прямоугольникам с использова-
нием GiST (Александр Коротков, Хейкки Линнакангас)
Ранее, для использования такого индекса требовалось применять подзапрос, выбирающий
большое количество строк, упорядоченных по дистанции до окружающего прямоугольника, а
затем дополнительно отфильтровывать результат, рассчитывая расстояние точнее.
• Возможность использования индексов GiST в сканировании только по индексу (Анастасия Лу-
бенникова, Хейкки Линнакангас, Андреас Карлссон)
• Добавление параметра конфигурации gin_pending_list_limit, управляющего размером очере-
дей GIN (Фудзии Масао)
2459Замечания к выпуску
Это значение можно также задать на уровне индекса как параметр хранения индекса. Ранее
размер очереди зависел от параметра work_mem, что было неудобно, так как подходящие зна-
чения work_mem обычно оказывались слишком большими для данной цели.
• Выдача при создании хеш-индексов предупреждения о том, что они не защищены от сбоев
(Брюс Момджян)
E.37.3.1.2. Общая производительность
• Ускорение сортировки полей varchar, text и numeric за счёт использования «сокращённых»
ключей (Питер Геохеган, Эндрю Гирт, Роберт Хаас)
• Расширение инфраструктуры, позволяющее производить сортировку, вызывая встроенные,
не вызываемые из SQL функции сравнения, для выполнения команд CREATE INDEX, REINDEX и
CLUSTER (Питер Геохеган)
• Улучшение производительности соединений по хешу (Томаш Вондра, Роберт Хаас)
• Улучшение параллелизма операции замены разделяемого буфера (Роберт Хаас, Амит Капила,
Андрес Фройнд)
• Уменьшение количества блокировок и закреплений страниц при сканировании индексов (Ке-
вин Гриттнер)
Прежде всего это полезно тем, что позволяет реже блокировать процедуру очистки индексов.
• Оптимизация использования памяти при отслеживании закреплений буферов в серверных
процессах (Андрес Фройнд)
• Улучшение масштабируемости блокировок (Андрес Фройнд)
В особенности это снимает проблемы масштабируемости в системах с несколькими раздель-
ными процессорами.
• Оптимизатор теперь может удалить ненужные ссылки на соединяемые слева подзапросы (Дэ-
вид Роули)
• Возможность вынесения ограничений запроса в подзапросы с оконными функциями, где это
уместно (Дэвид Роули)
• Возможность вынесения вызова негерметичной функции за представление с барьером без-
опасности, если функция не получает никакие выходные столбцы представления (Дин Рашид)
• Доработка планировщика, чтобы он использовал статистику, полученную из индекса по вы-
ражению с булевской функцией, когда соответствующий вызов функции присутствует в WHERE
(Том Лейн)
• ANALYZE теперь вычисляет основную статистику (процент значений NULL и среднюю шири-
ну столбцов) даже для столбцов, тип данных которых лишён функции равенства (Олександр
Шульгин)
• Ускорение расчёта CRC (циклического избыточного кода) и переход к CRC-32C (Абхиджит
Менон-Сен, Хейкки Линнакангас)
• Улучшение производительности сканирования индексов по битовой карте (Фёдор Сигаев, Том
Лейн)
• Ускорение команды CREATE INDEX за счёт исключения лишнего копирования в памяти (Роберт
Хаас)
• Увеличение числа разделов отображений буферов (Амит Капила, Андрес Фройнд, Роберт Ха-
ас)
Это увеличивает производительность при многопоточной нагрузке.
E.37.3.1.3. Наблюдение
• Добавление параметра хранения log_autovacuum_min_duration для управления протоколиро-
ванием автоочистки на уровне таблиц (Микаэль Пакье)
2460Замечания к выпуску
• Добавление нового параметра конфигурации cluster_name (Томас Мунро)
Эта строка, обычно задаваемая в postgresql.conf, позволяет клиентам идентифицировать
кластер. Это имя также выводится в заголовке всех серверных процессов, что упрощает выде-
ление всех процессов, принадлежащих одному кластеру.
• Недопущение изменения log_disconnections простыми пользователями при установлении со-
единения (Фудзии Масао)
E.37.3.1.4. SSL
• Проверка «Альтернативных имён субъекта» (Subject Alternative Names) (при наличии) в SSL-
сертификатах серверов (Алексей Клюкин)
Когда такое поле присутствует, оно проверяется вместо поля «Общее имя» (Common Name) в
сертификате.
• Добавление системного представления pg_stat_ssl, выдающего информацию о SSL-подклю-
чениях (Магнус Хагандер)
• Добавление в libpq функций, возвращающих информацию об SSL независящим от реализации
способом (Хейкки Линнакангас)
Хотя PQgetssl() по-прежнему можно применять для обращений к функциям OpenSSL, те-
перь это считается устаревшим вариантом, так как будущие версии libpq могут поддерживать
и другие реализации SSL. По возможности используйте новые функции PQsslAttribute(),
PQsslAttributeNames() и PQsslInUse(), чтобы получать информацию об SSL независящим от
реализации SSL способом.
• В libpq должны сохраняться установленные многопоточные обработчики вызовов OpenSSL
(Ян Урбански)
Ранее они перезаписывались.
E.37.3.1.5. Параметры сервера
• Замена параметра конфигурации checkpoint_segments параметрами min_wal_size и
max_wal_size (Хейкки Линнакангас)
Это изменение позволяет разместить большое количество файлов WAL, но при этом не со-
хранять их, когда они будут уже не нужны. Как следствие, значение max_wal_size по умол-
чанию увеличено до 1GB, что намного больше старой величины по умолчанию, устанавливае-
мой параметром checkpoint_segments. Также заметьте, что резервные серверы теперь произ-
водят точки перезапуска, стараясь ограничить использование пространства WAL значением
max_wal_size; ранее они не учитывали параметр checkpoint_segments.
• Регулирование снятия процессов при нехватке памяти в Linux через новые переменные окру-
жения PG_OOM_ADJUST_FILE и PG_OOM_ADJUST_VALUE (Гуржит Сингх)
Предыдущая инфраструктура управления механизмом OOM зависела от параметров времени
компиляции LINUX_OOM_SCORE_ADJ и LINUX_OOM_ADJ, которые теперь не поддерживаются. Но-
вое поведение распространяется на все сборки.
• Осуществление записи времени фиксации транзакции, когда включён параметр
track_commit_timestamp (Альваро Эррера, Петр Желинек)
Прочитать записанное время можно, воспользовавшись функциями
pg_xact_commit_timestamp() и pg_last_committed_xact().
• Возможность устанавливать local_preload_libraries в команде ALTER ROLE SET (Питер Эйзен-
траут, Кётаро Хоригути)
• Рабочие процессы автоочистки теперь реагируют на изменения параметров конфигурации в
процессе работы (Микаэль Пакье)
2461Замечания к выпуску
• Параметр конфигурации debug_assertions стал доступен только для чтения (Андрес Фройнд)
Это значит, что утверждения теперь нельзя выключить, если они были включены на этапе
компиляции, что позволяет дополнительно оптимизировать код. При этом изменении также
был удалён ключ postgres -A.
• Возможность установления параметра effective_io_concurrency в системах, где он не играет
роли (Питер Эйзентраут)
• Добавление системного представления pg_file_settings, показывающего содержимое фай-
лов конфигурации сервера (Савада Масахико)
• Добавление поля pending_restart в системное представление pg_settings, показывающего,
что изменение было внесено, но не вступит в силу до перезапуска базы данных (Питер Эйзен-
траут)
• Возможность сбросить значения ALTER SYSTEM командой ALTER SYSTEM RESET (Вик Фиринг)
Эта команда удаляет заданный параметр из postgresql.auto.conf.
E.37.3.2. Репликация и восстановление
• Создание механизмов для отслеживания прогресса репликации, включая средства идентифи-
кации источника отдельных изменений при логической репликации (Андрес Фройнд)
Эти механизмы полезны при создании решений репликации.
• Переработка операции усечения мультитранзакций, чтобы она корректно фиксировалась в
журнале (Андрес Фройнд)
В результате этот механизм становится проще и надёжнее.
• Добавление в recovery.conf параметра recovery_target_action, управляющего действиями
после восстановления (Петр Желинек)
Этот параметр пришёл на замену pause_at_recovery_target.
• Добавление для archive_mode нового значения always, позволяющего архивировать получае-
мые файлы WAL (Фудзии Масао)
• Добавление параметра конфигурации wal_retrieve_retry_interval для управления повторными
попытками чтения WAL после сбоя (Алексей Васильев, Микаэль Пакье)
Это особенно полезно для тёплого резерва.
• Возможность сжатия образов полных страниц в WAL (Рахила Сьед, Микаэль Пакье)
Это позволяет сократить объём WAL, за счёт дополнительной нагрузки на процессор при за-
писи и воспроизведении WAL. Эта возможность управляется новым параметром конфигура-
ции wal_compression (по умолчанию он отключён).
• Архивация файлов WAL с расширением .partial при повышении резервного сервера (Хейкки
Линнакангас)
• Добавление параметра конфигурации log_replication_commands для протоколирования команд
репликации (Фудзии Масао)
По умолчанию команды репликации, в частности IDENTIFY_SYSTEM, не записываются в прото-
кол, даже когда log_statement имеет значение all.
• Добавление в pg_replication_slots отображения процессов, занимающих слоты репликации
(Крейг Рингер)
Эта информация выводится в новом столбце active_pid.
• Возможность использовать в задаваемом в recovery.conf параметре primary_conninfo иден-
тификаторы соединений в формате URI, например, postgres:// (Александр Шульгин)
2462Замечания к выпуску
E.37.3.3. Запросы
• Возможность превращать команды INSERT, вызывающие конфликты ограничений, в команды
UPDATE, либо игнорировать их (Питер Геохеган, Хейкки Линнакангас, Андрес Фройнд)
Для этого введён синтаксис INSERT ... ON CONFLICT DO NOTHING/UPDATE. Таким образом в
Postgres реализована популярная команда UPSERT.
• Добавление в GROUP BY аналитической функциональности: GROUPING SETS, CUBE и ROLLUP (Энд-
рю Гирт, Атри Шарма)
• Возможность присвоения результатов одного вложенного SELECT нескольким целевым столб-
цам в UPDATE (Том Лейн)
Для этого применяется синтаксис UPDATE tab SET (col1, col2, ...) = (SELECT ...).
• Добавление в SELECT указания SKIP LOCKED для пропуска заблокированных строк (Томас Мун-
ро)
При этом не выдаётся ошибка, как в случае с NOWAIT.
• Добавление в SELECT указания TABLESAMPLE, что позволяет получать подмножество строк таб-
лицы (Петр Желинек)
Благодаря этому теперь поддерживаются описанные в стандарте SQL методы извлечения вы-
борки. Кроме того, представлены средства для создания пользовательских методов извлече-
ния выборки.
• Предложение возможных исправлений при опечатках в именах столбцов (Питер Геохеган, Ро-
берт Хаас)
E.37.3.4. Служебные команды
• Добавление более подробной информации о порядке сортировки в вывод EXPLAIN (Мариус
Тиммер, Лукас Крефт, Арне Шеффер)
Эта информация включает свойства COLLATE, DESC, USING и NULLS FIRST/LAST.
• Добавление в вывод VACUUM количества страниц, пропущенных из-за закреплений (Джим Нэс-
би)
• Команда TRUNCATE теперь корректно обновляет счётчики кортежей в pg_stat (Александр
Шульгин)
• Добавление в REINDEX возможности переиндексировать всю схему с новым указанием SCHEMA
(Савада Масахико)
• Добавление в REINDEX указания VERBOSE (Савада Масахико)
• Исключение из вывода REINDEX DATABASE и SCHEMA имён столбцов в случае отсутствия указа-
ния VERBOSE (Саймон Риггс)
• Удаление устаревшего указания FORCE команды REINDEX (Фудзии Масао)
E.37.3.5. Манипуляции с объектами
• Добавление механизма защиты на уровне строк (Крейг Рингер, КайГай Кохэй, Адам Брайт-
велл, Дин Рашид, Стивен Фрост)
Этот механизм позволяет на уровне строк определять, какие строки пользователи смогут
добавлять, изменять и даже видеть в таблице. Для управления им введены новые команды
CREATE/ALTER/DROP POLICY и ALTER TABLE ... ENABLE/DISABLE ROW SECURITY.
• Возможность изменения режима журналирования таблицы в WAL с применением команды
ALTER TABLE ... SET LOGGED / UNLOGGED (Фабрицио де Ройес Мелло)
2463Замечания к выпуску
• Добавление предложения IF NOT EXISTS в CREATE TABLE AS, CREATE INDEX, CREATE SEQUENCE и
CREATE MATERIALIZED VIEW (Фабрицио де Ройес Мелло)
• Добавление поддержки IF EXISTS в ALTER TABLE ... RENAME CONSTRAINT (Брюс Момджян)
• Возможность передать некоторым командам DDL вместо имени конкретного пользователя
идентификаторы CURRENT_USER и SESSION_USER, обозначающие текущего пользователя и поль-
зователя сеанса (Кётаро Хоригути, Альваро Эррера)
Это поддерживают команды ALTER USER, ALTER GROUP, ALTER ROLE, GRANT и ALTER объект
OWNER TO.
• Поддержка комментариев в ограничениях домена (Альваро Эррера)
• Снижение уровней блокировки для некоторых команд, управляющих триггерами и сторонни-
ми ключами (Саймон Риггс, Андреас Карлссон)
• Разрешение использовать LOCK TABLE ... ROW EXCLUSIVE MODE тем, кто имеет право INSERT в
целевой таблице (Стивен Фрост)
Ранее для этой команды требовалось право UPDATE, DELETE или TRUNCATE.
• Применение ограничений CHECK для таблицы и домена в алфавитном порядке имён (Том
Лейн)
Ранее порядок был недетерминированным.
• Добавление в CREATE/ALTER DATABASE возможности управлять свойствами datistemplate и
datallowconn (Вик Фиринг)
Это позволяет задавать/изменять эти параметры, не модифицируя вручную системный ката-
лог pg_database.
E.37.3.5.1. Сторонние таблицы
• Добавление поддержки IMPORT FOREIGN SCHEMA (Ронан Данклау, Микаэль Пакье, Том
Лейн)
Эта команда позволяет автоматически создать локальные сторонние таблицы с той же струк-
турой, что имеют таблицы на удалённом сервере.
• Возможность определения ограничений CHECK для сторонних таблиц (Шигеру Ханада, Эцуро
Фудзита)
Такие ограничения считаются контролируемыми на удалённом сервере, а не локально. Одна-
ко для оптимизации запросов предполагается, что они удовлетворяются, как например при
исключении по ограничению.
• Возможность включать сторонние таблицы в иерархии наследования (Шигеру Ханада, Эцуро
Фудзита)
Чтобы это работало естественным образом, в сторонних таблицах теперь допускаются ограни-
чения-проверки, помечаемые как недействительные, и могут задаваться характеристики хра-
нения и OID, хотя по сути это никак не влияет на стороннюю таблицу.
• Обёртки сторонних данных и методы нестандартного сканирования обрели возможность вы-
носить соединения наружу (КайГай Кохэй)
E.37.3.5.2. Событийные триггеры
• Для устанавливаемого событийного триггера ddl_command_end собираются сведения об актив-
ности DDL, которые могут быть ему полезны (Альваро Эррера)
Эти сведения можно получить через возвращающую множество функцию
pg_event_trigger_ddl_commands() или через структуры данных C, если результат этой функ-
ции недостаточно детализирован.
2464Замечания к выпуску
• Возможность реагирования в событийных триггерах на перезапись таблицы, вызываемую опе-
рацией ALTER TABLE (Димитри Фонтейн)
• Добавление поддержки событийных триггеров для команд COMMENT, SECURITY LABEL и
GRANT/REVOKE уровня базы данных (Альваро Эррера)
• Добавление столбцов в вывод pg_event_trigger_dropped_objects (Альваро Эррера)
Это позволяет упростить обработку операций удаления.
E.37.3.6. Типы данных
• Возможность записать в тип xml пустое или состоящее только из пробельных символов значе-
ние (Питер Эйзентраут)
Это требуется стандартом SQL/XML.
• Возможность ввода в macaddr значений в формате xxxx-xxxx-xxxx (Хервин Вестстрате)
• Запрещение несоответствующего стандарту SQL синтаксиса interval с указанием одновре-
менно полей и точности (Брюс Момджян)
Пр стандарту такие значения этого типа должны записываться, например, как INTERVAL
MINUTE TO SECOND(2). В PostgreSQL ранее допускалась запись INTERVAL(2) MINUTE TO SECOND,
но теперь принимается только стандартный способ.
• Добавление оценки избирательности для операторов inet/cidr и улучшение оценки для функ-
ций текстового поиска (Эмре Хасегели, Том Лейн)
• Добавление типов данных regrole и regnamespace для упрощения ввода и улучшенного выво-
да OID ролей и пространств имён (Кётаро Хоригути)
E.37.3.6.1. JSON
• Добавление для типа jsonb функций jsonb_set() и jsonb_pretty() (Дмитрий Долгов, Эндрю
Дунстан, Петр Желинек)
• Добавление функций, формирующих jsonb: to_jsonb(), jsonb_object(),
jsonb_build_object(), jsonb_build_array(), jsonb_agg() и jsonb_object_agg() (Эндрю Дун-
стан)
Аналогичные функции уже имелись для типа json.
• Снижение требований для преобразований в/из json и jsonb (Том Лейн)
• Возможность вычитать из документов jsonb значения типов integer, text и массивы text
(Дмитрий Долгов, Эндрю Дунстан)
• Добавление для типа jsonb оператора || (Дмитрий Долгов, Эндрю Дунстан)
• Добавление функций json_strip_nulls() и jsonb_strip_nulls() для удаления значений null
из документов JSON (Эндрю Дунстан)
E.37.3.7. Функции
• Добавление generate_series() для значений numeric (Плато Малугин)
• Возможность передавать массив на вход array_agg() и ARRAY() (Али Акбар, Том Лейн)
• Добавление функций array_position() и array_positions(), возвращающих позиции значе-
ний в массиве (Павел Стехуле)
• Добавление оператора дистанции от точки до многоугольника (point-polygon) &lt;-&gt; (Александр
Коротков)
• Возможность использовать в качестве спецсимволов в SIMILAR TO и SUBSTRING многобайтовых
символов (Джефф Девис)
2465Замечания к выпуску
Ранее в качестве спецсимвола можно было выбрать только однобайтовый символ.
• Добавление вариации width_bucket(), поддерживающей любой упорядочиваемый тип данных
и группы неодинаковой ширины (Петр Желинек)
• Добавление необязательного аргумента missing_ok в pg_read_file() и связанные функции
(Микаэль Пакье, Хейкки Линнакангас)
• Введение конструкции =&gt;, позволяющей задать значения именованных параметров в вызовах
функций (Павел Стехуле)
Ранее присвоение значения записывалось только с конструкцией :=. Это потребовало запре-
тить создание пользовательского оператора =&gt;. При создании пользовательских операторов =&gt;
до этого выдавались предупреждения (начиная с PostgreSQL 9.0).
• Добавление POSIX-совместимого округления для платформ, где используются функции округ-
ления, предоставляемые PostgreSQL (Педро Химено Фортеа)
E.37.3.7.1. Системные информационные функции и представления
• Добавление функции pg_get_object_address(), возвращающей набор OID, однозначно иден-
тифицирующих объект, и функции pg_identify_object_as_address(), возвращающей инфор-
мацию об объекте по этим OID (Альваро Эррера)
• Ослабление ограничений безопасности при просмотре запросов в pg_stat_activity и вызове
функций pg_cancel_backend() и pg_terminate_backend() (Стивен Фрост)
Ранее эти операции могли выполнять только роли, которым непосредственно принадлежит
целевой сеанс; теперь достаточно быть членом такой роли.
• Добавление функции pg_stat_get_snapshot_timestamp(), выдающей время снимка статисти-
ки (Мэтт Келли)
Это время показывает, когда в последний раз файл снимка записывался в файловую систему.
• Добавление функции mxid_age(), вычисляющей возраст мультитранзакций (Брюс Момджян)
E.37.3.7.2. Агрегатные функции
• Добавление агрегатных функций min()/max() для типов данных inet/cidr (Харибабу Комми)
• Использование 128-битных целых, где они поддерживаются, для накопления значений в неко-
торых агрегатных функциях (Андреас Карлссон)
E.37.3.8. Языки программирования на стороне сервера
• Улучшение поддержки составных типов в PL/Python (Эд Бен, Ронан Данклау)
Это позволяет возвращать из функций на PL/Python массивы составных типов.
• Уменьшение неточности при преобразовании значений с плавающей точкой в PL/Python (Мар-
ко Крин)
• Возможность определения функций преобразования между типами данных SQL и типами дан-
ных процедурных языков (Питер Эйзентраут)
Это изменение привносит команды CREATE/DROP TRANSFORM. Также с ним добавлены дополни-
тельные трансформации типов hstore и ltree из/в типы языков PL/Perl и PL/Python.
E.37.3.8.1. Серверный язык PL/pgSQL
• Улучшение производительности массивов PL/pgSQL (Том Лейн)
• Добавление оператора ASSERT в PL/pgSQL (Павел Стехуле)
• Допущение использования в качестве идентификаторов большего количества ключевых слов
PL/pgSQL (Том Лейн)
2466Замечания к выпуску
E.37.3.9. Клиентские приложения
• Перемещение pg_archivecleanup, pg_test_fsync, pg_test_timing и pg_xlogdump из contrib в src/
bin (Питер Эйзентраут)
В результате эти программы должны по умолчанию устанавливаться в большем числе инстал-
ляций.
• Добавление программы pg_rewind, позволяющей восстановить синхронизированное состояние
главного сервера после отработки отказа (Хейкки Линнакангас)
• Возможность управления слотами физической репликации с помощью pg_receivexlog (Мика-
эль Пакье)
Для этого введены новые параметры --create-slot и --drop-slot.
• В pg_receivewal появилась возможность синхронно сбрасывать WAL на диск с нововведённым
параметром --synchronous (Фуруя Осаму, Фудзии Масао)
Без него файлы WAL сохраняются на диске только при закрытии.
• В vacuumdb появилась возможность очистки в параллельном режиме с нововведённым пара-
метром --jobs (Дилип Кумар)
• Программа vacuumdb теперь не запрашивает один и тот же пароль многократно, когда уста-
навливает несколько подключений (Харибабу Комми, Микаэль Пакье)
• Добавление ключа --verbose для reindexdb (Савада Масахико)
• Использование в pg_basebackup файла отображений табличных пространств при выборе фор-
мата tar, что позволяет поддерживать символические ссылки и пути длиннее 100 символов в
MS Windows (Амит Капила)
• Добавление в pg_xlogdump ключа --stats для получения сводной статистики (Абхиджит Ме-
нон-Сен)
• Возможность получить вывод psql в формате AsciiDoc (Шимон Гуз)
• Добавление режима errors в переменной ECHO, в котором psql выводит только команды с
ошибками (Павел Стехуле)
Этот режим также можно включить, передав psql ключ -b.
• Разделение в psql параметров, управляющих стилем линий в Юникоде, на параметры для ко-
лонок, заголовка и границ (Павел Стехуле)
Поддерживаются одинарные и двойные линии; вариант по умолчанию — single (одинарные).
• Поддержка нового параметра %l в переменных окружения PROMPT в psql, позволяющего уви-
деть текущий номер строки в многострочном операторе (Савада Масахико)
• Добавление в \pset параметра pager_min_lines, управляющего вызовом постраничника (Энд-
рю Дунстан)
• Улучшение подсчёта строк в psql, по результатам которого принимается решения о вызове
постраничника (Эндрю Дунстан)
• Теперь psql не запускается, если не может записать в файл, заданный ключом --output или
--log-file (Том Лейн, Даниэль Верите)
Ранее psql по сути игнорировал этот ключ в таких случаях.
• Добавление в psql дополнения табуляцией, когда устанавливается переменная search_path
(Джефф Джейнс)
В настоящее время дополнение табуляцией возможно только для первой схемы.
2467Замечания к выпуску
• Улучшение в psql дополнения табуляцией для триггеров и правил (Андреас Карлссон)</I-O-Read-Time></li>
  <li>Команды с обратной косой чертой
• Добавление для команды psql \? разделов справки variables и options (Павел Стехуле)
Команда \? variables показывает справку по специальным переменным psql, а \? options —
по параметрам командной строки. Команда \? commands выводит метакоманды, которые выво-
дились раньше, и это остаётся вариантом по умолчанию. Эти разделы справки также можно
получить, передав в командной строке аргумент –help=раздел.
• В команде psql \db+ добавлен вывод размера табличного пространства (Фабрицио де Ройес
Мелло)
• В psql \dT+ добавлено отображение владельцев типов данных (Магнус Хагандер)
• В psql \watch добавлен вывод информации \timing (Фудзии Масао)
Отключение вывода запросов \watch при запуске с ключом –echo-hidden, так как обычно
они не нужны.
• Команды psql \sf и \ef должны учитывать переменную ECHO_HIDDEN (Эндрю Дунстан)
• Улучшение в psql дополнения табуляцией для \set, \unset и имён :variable (Павел Стехуле)
• Возможность дополнения табуляцией имён ролей в командах psql \c (Иэн Барвик)
• Возможность использовать в pg_dump снимок данных, полученный в другом сеансе, с пара-
метром –snapshot (Саймон Риггс, Микаэль Пакье)
Этот снимок должен быть экспортирован функцией pg_export_snapshot() или при создании
слота логической репликации. Это может применяться для совместного использования согла-
сованного снимка несколькими процессами pg_dump.
• Поддержка в архивном формате tar таблиц размером больше 8 ГБ (Том Лейн)
Стандарт POSIX формата tar не позволяет включать в архив элементы размером больше 8
ГБ, но большинство современных реализаций tar поддерживают расширение, допускающие
это. Поэтому нужно использовать расширенный формат, когда это необходимо, а не выдавать
ошибку.
• Включение в pg_dump вывода версий сервера и pg_dump во всех режимах (Цзин Ван)
До этого информация о версии выводилась только в режиме –verbose.
• Исключение давно забытого параметра -i/–ignore-version из pg_dump, pg_dumpall и
pg_restore (Фудзии Масао)
• Поддержка нескольких параметров pg_ctl -o, так что их значения соединяются вместе (Брюс
Момджян)
• Возможность определения для pg_ctl источника событий, записываемых в журнал событий
MS Windows (МауМау)
Это влияет только на события pg_ctl, а не сервера — для него источник событий задаётся от-
дельно, в postgresql.conf.
• Если в качестве принимающего адреса сервера задаётся всёохватывающее значение (0.0.0.0
в IPv4 или :: в IPv6), нужно подключаться через адрес локального замыкания, а не использо-
вать заданный адрес буквально (Кондо Юта)
Это исправление в первую очередь затрагивает Windows, так как на других платформах pg_ctl
предпочитает использовать Unix-сокет.
• Перемещение pg_upgrade из contrib в src/bin (Питер Эйзентраут)
2468Замечания к выпуску
В связи с этим изменением, функциональность, ранее предоставляемая модулем
pg_upgrade_support, была включена в ядро сервера.
• Поддержка нескольких параметров pg_upgrade -o/-O, так что их значения соединяются вме-
сте (Брюс Момджян)
• Улучшение сравнений правил сортировки для баз данных в pg_upgrade (Хейкки Линнакангас)
• Ликвидация поддержки обновления с версии 8.3 (Брюс Момджян)
• Перемещение pgbench из contrib в src/bin (Питер Эйзентраут)
• Исправлено вычисление TPS «за исключением установленных соединений» (Тацуо Исии, Фаб-
ьен Коэльо)
Накладные расходы на установление соединения подсчитывались неправильно, когда число
потоков pgbench было меньше числа клиентских подключений. Хотя это определённо ошибка,
мы не будем переносить её исправление в версии до 9.5, так как при этом значения TPS ока-
жутся несравнимыми с предыдущими результатами.
• Подсчёт транзакций, выполнявшихся дольше заданного времени (Фабьен Коэльо)
Этим подсчётом управляет нововведённый параметр –latency-limit.
• Возможность получить в pgbench случайное распределение Гаусса или экспоненциальное
распределение \setrandom (Мицумаса Кондо, Фабьен Коэльо)
• Реализация в команде pgbench \set обработки арифметических выражений с несколькими
операторами и включение % (деления по модулю) в список поддерживаемых операторов (Ро-
берт Хаас, Фабьен Коэльо)
E.37.3.10. Исходный код
• Упрощение формата записи WAL (Хейкки Линнакангас)
Благодаря этому изменению, внешним средствам будет легче отслеживать, какие блоки изме-
няются.
• Улучшение представления записей фиксации и прерывания транзакций в WAL (Андрес
Фройнд)
• Добавление API атомарных операций с памятью (Андрес Фройнд)
• Возможность реализации нестандартных методов сканирования и путей (КайГай Кохэй, Том
Лейн)
Это даёт расширениям дополнительные рычаги управления оптимизатором и исполнителем.
• Возможность устанавливать блокировки после фильтрации в обёртках сторонних данных (Эцу-
ро Фудзита)
• Сторонние таблицы теперь могут участвовать в запросах INSERT … ON CONFLICT DO NOTHING
(Питер Геохеган, Хейкки Линнакангас, Андрес Фройнд)
Обёртки сторонних данных не нужно модифицировать, чтобы это поддерживалось. Однако ко-
манда INSERT … ON CONFLICT DO UPDATE со сторонними таблицами не поддерживается.
• Улучшение интерфейса hash_create(), позволяющее выбирать хеш-функции с простым двоич-
ным ключом (Фёдор Сигаев, Том Лейн)
• Улучшение инфраструктуры параллельного выполнения (Роберт Хаас, Амит Капила, Ной
Миш, Рушаб Латиа, Дживан Чок)
• Ликвидация портов для Alpha (CPU) и Tru64 (ОС) (Андрес Фройнд)
• Ликвидация реализации циклических блокировок (spinlock) на основе перестановки байт для
ARMv5 и предыдущих процессоров (Роберт Хаас)
2469Замечания к выпуску
Особенность слабого упорядочивания доступа к памяти в ARM v5 делает такую реализацию
блокировки ненадёжной. Однако использование циклических блокировок всё же возможно с
новыми версиями gcc, поддерживающими атомарные операции.
• Выдача ошибки при попытке записать в файлы tar чрезмерно длинный (больше 100 символов)
путь (Питер Эйзентраут)
Tar не поддерживает такие длинные пути.
• Смена индексируемого класса операторов для столбцов pg_seclabel.provider и
pg_shseclabel.provider на text_pattern_ops (Том Лейн)
Это позволяет избежать возможных проблем с этими индексами, когда в разных базах данных
кластера используются разные правила сортировки.
• Изменение примитивов spinlock, чтобы они действовали как барьеры для оптимизаций компи-
лятора (Роберт Хаас)
E.37.3.10.1. MS Windows
• Получение системного времени с большей точностью в Windows 8, Windows Server 2012 и бо-
лее новых системах Windows (Крейг Рингер)
• Установка разделяемых библиотек в bin в MS Windows (Питер Эйзентраут, Микаэль Пакье)
• Установка src/test/modules вместе с contrib в сборках с MSVC (Микаэль Пакье)
• В сборке с MSVC теперь может учитываться задаваемый для configure параметр –with-
extra-version (Микаэль Пакье)
• Передача PGFILEDESC в сборки contrib с MSVC (Микаэль Пакье)
• Добавление значков во все собираемые с MSVC двоичные файлы и информации о версии во
все двоичные файлы, собираемые для MS Windows (Ной Миш)
При сборке с MinGW такие значки уже добавлялись ранее.
• Добавление поддержки необязательных аргументов во внутреннюю реализацию
getopt_long() (Микаэль Пакье, Андрес Фройнд)
Это используется при сборке с MSVC.
E.37.3.11. Дополнительные модули
• Добавление статистики для получения минимального, максимального, среднего времени и
стандартного отклонения в pg_stat_statements (Мицумаса Кондо, Эндрю Дунстан)
• Добавление в pgcrypto функции pgp_armor_headers() для извлечения заголовков PGP Armor
(Марко Тииккая, Хейкки Линнакангас)
• Возможность задавать пустые строки замены в unaccent (Мохаммед Альхашаш)
Это полезно для языков, в которых диакритические знаки представляются как отдельные сим-
волы.
• Возможность задавать многосимвольные исходные строки в unaccent (Том Лейн)
Это может быть полезно для языков, в которых диакритические знаки представляются как от-
дельные символы. Это также позволяет создавать более сложные словари удаления диакрити-
ки.
• Добавление в contrib модулей tsm_system_rows и tsm_system_time, реализующих дополни-
тельные методы извлечения выборки (Петр Желинек)
• Добавление функций исследования индекса GIN в pageinspect (Хейкки Линнакангас, Питер
Геохеган, Микаэль Пакье)
2470Замечания к выпуску
• Добавление информации о закреплении буфера в вывод pg_buffercache (Андрес Фройнд)
• Возможность получать от pgstattuple приблизительных ответов с меньшими издержками, ис-
пользуя pgstattuple_approx() (Абхиджит Менон-Сен)
• Перемещение dummy_seclabel, test_shm_mq, test_parser и worker_spi из contrib в src/test/
modules (Альваро Эррера)
Этим модули предназначаются только для тестирования сервера, поэтому их нет смысла соби-
рать или устанавливать в составе пакета PostgreSQL.
2471</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-074/" title="Приложение D. Соответствие стандарту SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Приложение D. Соответствие стандарту SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-074/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~25 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-074/" rel="bookmark" title="Приложение D. Соответствие стандарту SQL" itemprop="url">Приложение D. Соответствие стандарту SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Приложение D. Соответствие стандарту SQL</p>

<p>В этом разделе в общих чертах отмечается, в какой степени PostgreSQL соответствует текущему
стандарту SQL. Следующая информация не является официальным утверждением о соответствии,
а представляет только основные аспекты на уровне детализации, достаточно полезном и целесо-
образном для пользователей.
Формально стандарт SQL называется ISO/IEC 9075 «Язык баз данных SQL». Время от времени вы-
пускается обновлённая версия стандарта; последняя версия стандарта вышла в 2011 г. Эта версия
получила обозначение ISO/IEC 9075:2011, или просто SQL:2011. До этого были выпущены версии
SQL:2008, SQL:2003, SQL:1999 и SQL-92. Каждая следующая версия заменяет предыдущую, так
что утверждение о совместимости с предыдущими версиями не имеет большой ценности. Разработ-
чики PostgreSQL стремятся обеспечить совместимость с последней официальной версией стандар-
та, оставаясь при этом в рамках традиционной функциональности и здравого смысла. PostgreSQL
реализует большую часть требуемой стандартом функциональности, хотя иногда с немного други-
ми функциями или синтаксисом. Можно ожидать, что со временем степень совместимости будет
увеличиваться.
SQL-92 определяет три уровня функциональной совместимости: начальный (Entry), промежуточ-
ный (Intermediate) и полный (Full). Большинство СУБД заявляют о совместимости со стандартом
SQL только на начальном уровне, так как полный набор возможностей на промежуточном и пол-
ном уровнях либо слишком велик, либо конфликтует с ранее принятым поведением.
Начиная с SQL:1999, вместо трёх чрезмерно пространных уровней SQL-92 в стандарте SQL опре-
делено множество отдельных функциональных возможностей. Большое его подмножество пред-
ставляет «Основную» функциональность, которую должны обеспечивать все совместимые с SQL
реализации. Поддержка остальных возможностей не является обязательной. Некоторые необяза-
тельные возможности группируются вместе, образуя «пакеты», о поддержке которых могут заяв-
лять реализации SQL, таким образом, декларируя совместимость с определённой группой возмож-
ностей.
Описание стандарта, начиная с версии SQL:2003, также разделяется на несколько частей. Каждая
такая часть имеет короткое имя и номер. Заметьте, что нумерация этих частей непоследователь-
ная.
• ISO/IEC 9075-1 Структура (SQL/Framework)
• ISO/IEC 9075-2 Основа (SQL/Foundation)
• ISO/IEC 9075-3 Интерфейс уровня вызовов (SQL/CLI)
• ISO/IEC 9075-4 Модули постоянного хранения (SQL/PSM)
• ISO/IEC 9075-9 Управление внешними данными (SQL/MED)
• ISO/IEC 9075-10 Привязки объектных языков (SQL/OLB)
• ISO/IEC 9075-11 Схемы информации и определений (SQL/Schemata)
• ISO/IEC 9075-13 Программы и типы, использующие язык Java (SQL/JRT)
• ISO/IEC 9075-14 Спецификации, связанные с XML (SQL/XML)
2244Соответствие стандарту SQL
Ядро PostgreSQL реализует части 1, 2, 9, 11 и 14. Часть 3 реализуется драйвером ODBC, а часть
13 — подключаемым расширением PL/Java, но точное соответствие этих компонентов стандарту
на данный момент не проверено. Части 4 и 10 в PostgreSQL в настоящее время не реализованы.
PostgreSQL поддерживает почти все основные возможности стандарта SQL:2011. Из 179 обяза-
тельных возможностей, которые требуются для полного соответствия «Основной» функциональ-
ности, PostgreSQL обеспечивает совместимость как минимум для 160. Кроме того, он реализует
длинный список необязательных возможностей. Следует отметить, что на время написания этой
документации ни одна существующая СУБД не заявила о полном соответствии «Основной» функ-
циональности SQL:2011.
В следующих двух разделах мы представляем список возможностей, которые поддерживает
PostgreSQL, и список возможностей, определённых в SQL:2011, которые ещё не поддерживаются в
PostgreSQL. Оба эти списка носят приблизительный характер: какая-то возможность, отмеченная
как поддерживаемая, может отличаться от стандарта в деталях, и напротив, для какой-то непод-
держиваемой возможности могут быть реализованы ключевые компоненты. Наиболее точная ин-
формация о том, что работает, а что нет, содержится в основной документации.
Примечание
Коды возможностей, содержащие знак минус, обозначают подчинённые возможности.
При этом, если какая-либо одна подчинённая возможность не поддерживается, основ-
ная возможность так же не будет поддерживаться, даже если реализованы все осталь-
ные на подуровне.
D.1. Поддерживаемые возможности
Идентификатор
Пакет
Описание
Комментарий
B012 Встроенный C
B021 Непосредственный SQL
E011 Ядро Числовые типы данных
E011-01 Ядро Типы данных INTEGER
и SMALLINT
E011-02 Ядро Типы данных REAL,
DOUBLE PRECISION и
FLOAT
E011-03 Ядро Типы данных DECIMAL
и NUMERIC
E011-04 Ядро Арифметические
раторы
E011-05 Ядро Числовые сравнения
E011-06 Ядро Неявные преобразова-
ния между числовыми
типами данных
E021 Ядро Символьные типы дан-
ных
E021-01 Ядро Тип
CHARACTER
E021-02 Ядро Тип
данных
CHARACTER VARYING
E021-03 Ядро Символьные строки
2245
опе-
данныхСоответствие стандарту SQL
Идентификатор Пакет Описание
E021-04 Ядро Функция CHARACTER_ убирает завершающие
LENGTH
пробелы из значений
CHARACTER перед под-
счётом символов
E021-05 Ядро Функция
LENGTH
E021-06 Ядро Функция SUBSTRING
E021-07 Ядро Конкатенация символь-
ных строк
E021-08 Ядро Функции
LOWER
E021-09 Ядро Функция TRIM
E021-10 Ядро Неявные преобразова-
ния между типами сим-
вольных строк
E021-11 Ядро Функция POSITION
E021-12 Ядро Сравнения символов
E031 Ядро Идентификаторы
E031-01 Ядро Идентификаторы с раз-
делителями
E031-02 Ядро Идентификаторы
нижнем регистре
E031-03 Ядро Завершающее
кивание
E051 Ядро Базовое
запросов
E051-01 Ядро SELECT DISTINCT
E051-02 Ядро Предложение
BY
E051-04 Ядро GROUP BY может со-
держать столбцы не из</p>
<списка выборки="">
E051-05 Ядро Элементы списка вы-
борки могут переиме-
новываться
E051-06 Ядро Предложение HAVING
E051-07 Ядро Дополнение * в списке
выборки
E051-08 Ядро Корреляционные име-
на
в
предложении
FROM
E051-09 Ядро Переименование столб-
цов
в
предложении
FROM
E061 Ядро Базовые предикаты и
условия поиска
E061-01 Ядро Предикат сравнения
2246
Комментарий
OCTET_
UPPER
и
в
подчёр-
определение
GROUPСоответствие стандарту SQL
Идентификатор Пакет Описание
E061-02 Ядро Предикат BETWEEN
E061-03 Ядро Предикат IN со спис-
ком значений
E061-04 Ядро Предикат LIKE
E061-05 Ядро Предложение ESCAPE
в предикате LIKE
E061-06 Ядро Предикат NULL
E061-07 Ядро Предикаты
количе-
ственного сравнения
E061-08 Ядро Предикат EXISTS
E061-09 Ядро Подзапросы в предика-
те сравнения
E061-11 Ядро Подзапросы в предика-
те IN
E061-12 Ядро Подзапросы в преди-
кате количественного
сравнения
E061-13 Ядро Коррелирующие подза-
просы
E061-14 Ядро Условие поиска
E071 Ядро Простые выражения с
запросами
E071-01 Ядро Табличный
оператор
UNION DISTINCT
E071-02 Ядро Табличный
UNION ALL
E071-03 Ядро Табличный
оператор
EXCEPT DISTINCT
E071-05 Ядро Столбцы,
объединяе-
мые табличными опе-
раторами, могут иметь
разные типы данных
E071-06 Ядро Табличные операторы в
подзапросах
E081 Ядро Основные права досту-
па
E081-01 Ядро Право на SELECT
E081-02 Ядро Право на DELETE
E081-03 Ядро Право на INSERT на
уровне таблицы
E081-04 Ядро Право на UPDATE на
уровне таблицы
E081-05 Ядро Право на UPDATE на
уровне столбцов
E081-06 Ядро Право REFERENCES на
уровне таблицы
2247
Комментарий
операторСоответствие стандарту SQL
Идентификатор Пакет Описание E081-07 Ядро Право REFERENCES на
уровне столбцов
E081-08 Ядро Предложение
GRANT OPTION E081-09 Ядро Право USAGE E081-10 Ядро Право на EXECUTE E091 Ядро Функции множеств E091-01 Ядро AVG E091-02 Ядро COUNT E091-03 Ядро MAX E091-04 Ядро MIN E091-05 Ядро SUM E091-06 Ядро Дополнение ALL E091-07 Ядро Дополнение DISTINCT E101 Ядро Базовая обработка дан-
ных
E101-01 Ядро Оператор INSERT E101-03 Ядро Оператор UPDATE
критерием отбора с
E101-04 Ядро Оператор DELETE
критерием отбора с
E111 Ядро Оператор SELECT, воз-
вращающий одну стро-
ку
E121 Ядро Базовая
курсоров E121-01 Ядро DECLARE CURSOR E121-02 Ядро Столбцы ORDER BY, от-
сутствующие в списке
выборки
E121-03 Ядро Выражения значений
в предложении ORDER
BY
E121-04 Ядро Оператор OPEN E121-06 Ядро Оператор UPDATE с по-
зиционированием
E121-07 Ядро Оператор DELETE с по-
зиционированием
E121-08 Ядро Оператор CLOSE E121-10 Ядро Оператор
FETCH
неявным NEXT E121-17 Ядро Курсоры WITH HOLD E131 Ядро Поддержка
NULL
(
NULL вместо значений)
2248
Комментарий
WITH
поддержка
сСоответствие стандарту SQL
Идентификатор Пакет Описание
E141 Ядро Основные ограничения
целостности
E141-01 Ядро Ограничения
NULL
E141-02 Ядро Ограничения UNIQUE
столбцов NOT NULL
E141-03 Ядро Ограничения PRIMARY
KEY
E141-04 Ядро Базовое
ограничение
FOREIGN KEY без дей-
ствия (NO ACTION)
по умолчанию и для
операций удаления со
ссылками, и для опера-
ций изменения со ссыл-
ками
E141-06 Ядро Ограничения CHECK
E141-07 Ядро Значения столбцов по
умолчанию
E141-08 Ядро NOT NULL распростра-
няется на PRIMARY KEY
E141-10 Ядро Имена во внешнем клю-
че могут указываться в
любом порядке
E151 Ядро Поддержка транзакций
E151-01 Ядро Оператор COMMIT
E151-02 Ядро Оператор ROLLBACK
E152 Ядро Базовый оператор SET
TRANSACTION
E152-01 Ядро Оператор
SET
TRANSACTION:
пред-
ложение
ISOLATION
LEVEL SERIALIZABLE
E152-02 Ядро Оператор
SET
TRANSACTION: предло-
жения READ ONLY и
READ WRITE
E153 Ядро Запросы, изменяющие
данные, с подзапроса-
ми
E161 Ядро Комментарии SQL, на-
чинающиеся с двух ми-
нусов
E171 Ядро Поддержка SQLSTATE
F021 Ядро Основная информаци-
онная схема
F021-01 Ядро Представление
COLUMNS
2249
Комментарий
NOTСоответствие стандарту SQL
Идентификатор Пакет Описание
Комментарий
F021-02 Ядро Представление TABLES
F021-03 Ядро Представление VIEWS
F021-04 Ядро Представление TABLE_
CONSTRAINTS
F021-05 Ядро Представление
REFERENTIAL_
CONSTRAINTS
F021-06 Ядро Представление
CHECK_CONSTRAINTS
F031 Ядро Базовые манипуляции
со схемой
F031-01 Ядро Оператор
CREATE
TABLE создаёт храни-
мые основные таблицы
F031-02 Ядро Представление
CREATE VIEW
F031-03 Ядро Оператор GRANT
F031-04 Ядро Оператор
ALTER
TABLE:
предложение
ADD COLUMN
F031-13 Ядро Оператор DROP TABLE:
предложение
RESTRICT
F031-16 Ядро Оператор DROP VIEW:
предложение
RESTRICT
F031-19 Ядро Оператор
REVOKE:
предложение
RESTRICT
F032 Каскадное удаление (
CASCADE)
F033 Оператор
ALTER
TABLE:
предложение
DROP COLUMN
F034 Расширенный оператор
REVOKE
F034-01 Оператор REVOKE мо-
жет выполняться не
только владельцем объ-
екта схемы
F034-02 Оператор
REVOKE:
предложение
GRANT
OPTION FOR
F034-03 Оператор REVOKE от-
зывает право, данное
субъекту с указанием
WITH GRANT OPTION
F041
Ядро
Базовое
таблиц
2250
соединениеСоответствие стандарту SQL
Идентификатор Пакет Описание
F041-01 Ядро Внутреннее
соедине-
ние (но не обязатель-
но с ключевым словом
INNER)
F041-02 Ядро Ключевое слово INNER
F041-03 Ядро LEFT OUTER JOIN
F041-04 Ядро RIGHT OUTER JOIN
F041-05 Ядро Внешние
соединения
могут быть вложенны-
ми
F041-07 Ядро Внутренняя таблица с
левой или правой сто-
роны внешнего соеди-
нения может также
участвовать во внутрен-
нем соединении
F041-08 Ядро Поддерживаются
все
операторы сравнения (
а не только =)
F051 Ядро Базовая поддержка да-
ты и времени
F051-01 Ядро Тип
данных
DATE
(включая
поддержку
строк DATE)
F051-02 Ядро Тип
данных
TIME
(включая
поддержку
строк TIME) с точно-
стью до секунд как ми-
нимум с 0 знаков после
запятой
F051-03 Ядро Тип
данных
TIMESTAMP
(вклю-
чая поддержку строк
TIMESTAMP) с точно-
стью до секунд как ми-
нимум с 0 и 6 знаками
после запятой
F051-04 Ядро Предикаты сравнения с
типами данных DATE,
TIME и TIMESTAMP
F051-05 Ядро Явное приведение (
CAST) между типами
даты/времени и типами
символьных строк
F051-06 Ядро CURRENT_DATE
F051-07 Ядро LOCALTIME
F051-08 Ядро LOCALTIMESTAMP
F052 Расширенные средства Арифметика с интерва-
работы с датами/време- лами и датами/време-
нем
нем
2251
КомментарийСоответствие стандарту SQL
Идентификатор
Пакет
Описание
F053
F081
Комментарий
Предикат OVERLAPS
Ядро
UNION и EXCEPT
представлениях
в
F111 Уровни изоляции, от-
личные
от
SERIALIZABLE
F111-01 Уровень
изоляции
READ UNCOMMITTED
F111-02 Уровень
изоляции
READ COMMITTED
F111-03 Уровень
изоляции
REPEATABLE READ
F131 Ядро Операции группировки
F131-01 Ядро Предложения WHERE,
GROUP BY и HAVING,
поддерживаемые в за-
просах со сгруппиро-
ванными представлени-
ями
F131-02 Ядро Поддержка нескольких
таблиц
в
запросах
со сгруппированными
представлениями
F131-03 Ядро Поддержка
функций
множеств в запросах
со сгруппированными
представлениями
F131-04 Ядро Подзапросы с предло-
жениями GROUP BY и
HAVING и сгруппиро-
ванные представления
F131-05 Ядро SELECT,
возвращаю-
щий
одну
стро-
ку, с предложениями
GROUP BY и HAVING
и
сгруппированными
представлениями
F171 Несколько схем для од-
ного пользователя
F191 Расширенное управле- Действия при удалении
ние целостностью
со ссылками
F200
F201
Оператор
TABLE
Ядро
Функция CAST
F202
F221
TRUNCATE
TRUNCATE TABLE: воз-
можность
перезапус-
ка идентифицирующе-
го столбца
Ядро
Явные значения
умолчанию
2252
поСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
F222 Оператор
INSERT:
предложение DEFAULT
VALUES
F231 Таблицы прав
F231-01 Представление TABLE_
PRIVILEGES
F231-02 Представление
COLUMN_PRIVILEGES
F231-03 Представление USAGE_
PRIVILEGES
F251 Поддержка доменов
F261 Ядро Выражение CASE
F261-01 Ядро Простой
CASE
F261-02 Ядро Оператор CASE с усло-
виями
F261-03 Ядро NULLIF
F261-04 Ядро COALESCE
оператор
F262 Расширенные выраже-
ния CASE
F271 Составные строки сим-
волов
F281 Улучшенный оператор
LIKE
F302 Табличный
INTERSECT
F302-01 Табличный
оператор
INTERSECT DISTINCT
F302-02 Табличный
оператор
INTERSECT ALL
F304 Табличный
EXCEPT ALL
оператор
оператор
F311-01 Ядро CREATE SCHEMA
F311-02 Ядро CREATE TABLE для хра-
нимых основных таблиц
F311-03 Ядро CREATE VIEW
F311-04 Ядро CREATE VIEW:
CHECK OPTION
F311-05 Ядро Оператор GRANT
WITH
F321 Авторизация пользова-
телей
F361 Поддержка
грамм
F381 Расширенные манипу-
ляции со схемой
2253
подпро-Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
F381-01 Оператор
ALTER
TABLE:
предложение
ALTER COLUMN
F381-02 Оператор
ALTER
TABLE:
предложение
ADD CONSTRAINT
F381-03 Оператор
ALTER
TABLE:
предложение
DROP CONSTRAINT
F382 Изменение типа дан-
ных столбцов
F383 Предложение, устанав-
ливающее NOT NULL
для столбца
F384 Предложение удаления
свойства идентифици-
рующего столбца
F386 Предложение установ-
ления генерирования
значений идентифици-
рующего столбца
F391 Длинные
торы
F392 Спецсимволы Unicode в
идентификаторах
F393 Спецсимволы Unicode в
текстовых строках
F401 Расширенное соедине-
ние таблиц
F401-01 NATURAL JOIN
F401-02 FULL OUTER JOIN
F401-04 CROSS JOIN
F402 Соединения по именам
столбцов для больших
объектов, массивов и
мультимножеств
F411 Расширенные средства Указание часового поя- отличия в интерпрета-
работы с датами/време- са
ции строкового пред-
нем
ставления
идентифика-
F421 Национальные
лы
F431 Прокручиваемые кур-
соры только для чтения
F431-01 FETCH с явным NEXT
F431-02 FETCH FIRST
F431-03 FETCH LAST
F431-04 FETCH PRIOR
F431-05 FETCH ABSOLUTE
2254
симво-Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
F431-06 FETCH RELATIVE
F441 Расширенная поддерж-
ка функций множеств
F442 Смешанные ссылки на
столбцы в функциях
множеств
F471 Ядро Скалярные
значения
подзапросов
F481 Ядро Расширенный предикат
NULL
F491 Расширенное управле- Управление
ние целостностью
ниями
F501 Ядро Представления
воз-
можностей и совмести-
мости
F501-01 Ядро Представление
FEATURES
SQL_
F501-02 Ядро Представление
SIZING
SQL_
F501-03 Ядро Представление
LANGUAGES
SQL_
ограниче-
F502 Таблицы расширенной
документации
F502-01 Представление
SQL_
SIZING_PROFILES
F502-02 Представление
SQL_
IMPLEMENTATION_
INFO
F502-03 Представление
PACKAGES
F531 Временные таблицы
F555
Расширенные средства Дополнительная
работы с датами/време- ность в секундах
нем
SQL_
точ-
F561 Полные
значений
F571 Проверки значений ис-
тинности
F591 Производные таблицы
F611 Типы данных для инди-
каторов
F641 Конструкторы строк и
таблиц
F651 Дополнения имён ката-
логов
F661 Простые таблицы
2255
выраженияСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
F672 Ограничения-проверки
с текущим временем
F690 Поддержка правил сор- но без поддержки набо-
тировки
ров символов
F692 Расширенная поддерж-
ка правил сортировки
F701 Расширенное управле- Действия при обновле-
ние целостностью
нии со ссылками
F711 ALTER для домена
F731 Права на INSERT для
столбцов
F751 Усовершенствования
CHECK для представле-
ний
F761 Управление сеансом
F762 CURRENT_CATALOG
F763 CURRENT_SCHEMA
F771 Управление соединени-
ем
F781 Самоссылающиеся опе-
рации
F791 Нечувствительные кур-
соры
F801 Полные функции мно-
жеств
F850 <Предложение order="" by=""> на верхнем уровне в
<выражении запроса="">
F851 <Предложение order="" by=""> в подзапросах
F852 <Предложение order="" by=""> на верхнем уровне
в представлениях
F855 Вложенное
<предло- жение="" order="" by=""> в <вы- ражении="" запроса="">
F856 Вложенное
<предло- жение="" fetch="" first=""> в
<предложении запро-="" са="">
F857 <Предложение fetch="" first=""> на верхнем уров-
не в <выражении за-="" проса="">
F858 <Предложение fetch="" first=""> в подзапросах
2256Соответствие стандарту SQL
Идентификатор
Пакет
Описание
F859 <Предложение fetch="" first=""> на верхнем уров-
не в представлениях
F860 <Указание числа="" строк=""> в <предложе- нии="" fetch="" first="">
F861 <Предложение offset="" для="" результата=""> на
верхнем уровне в <вы- ражении="" запроса="">
F862 <Предложение offset="" для="" результата=""> в под-
запросах
F863 Вложенное
<предло- жение="" offset="" для="" ре-="" зультата=""> в <выраже- нии="" запроса="">
F864 <Предложение offset="" для="" результата=""> на
верхнем уровне в пред-
ставлениях
F865 <Указание числа="" строк=""> с <предложени- ем="" offset="" для="" результа-="" та="">
S071 Расширенная поддерж- SQL-пути при разреше-
ка объектов
нии имён функций и ти-
пов
S092 Массивы пользователь-
ских типов
S095 Конструкторы массива
из запроса
S096 Необязательное указа-
ние границ массива
S098 ARRAY_AGG
S111 Расширенная поддерж- ONLY в выражениях за-
ка объектов
просов
S201 Вызываемые из SQL
подпрограммы, работа-
ющие с массивами
S201-01 Массивы в параметрах
S201-02 Массивы в качестве ти-
па результата функций
S211
Расширенная поддерж- Пользовательские
ка объектов
функции приведений
S301 Расширенный UNNEST
T031 Тип данных BOOLEAN
T071 Тип данных BIGINT
2257
КомментарийСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
T121 WITH (без RECURSIVE)
в выражении запроса
T122 WITH (с RECURSIVE) в
подзапросе
T131 Рекурсивный запрос
T132 Рекурсивный запрос в
подзапросе
T141 Предикат SIMILAR
T151 Предикат DISTINCT
T152 Предикат DISTINCT с
отрицанием
T171 Предложение LIKE в
определении таблицы
T172 Предложение
подза-
проса AS в определении
таблицы
T173 Расширенное предло-
жение LIKE в определе-
нии таблицы
T174 Идентифицирующие
столбцы
T177 Поддержка генерато-
ров последовательно-
стей: возможность про-
стого перезапуска
T178 Идентифицирующие
столбцы: возможность
простого перезапуска
T191 Расширенное управле- Действие
RESTRICT
ние целостностью
при нарушении ссылок
T201 Расширенное управле- Сравнимые типы дан-
ние целостностью
ных для ссылочных
ограничений
T211-01 Активная база данных, Триггеры, активируе-
улучшенное
управле- мые
при
UPDATE,
ние целостностью
INSERT или DELETE в
одной базовой таблице
T211-02 Активная база данных, Триггеры BEFORE
улучшенное
управле-
ние целостностью
T211-03 Активная база данных, Триггеры AFTER
улучшенное
управле-
ние целостностью
T211-04 Активная база данных, Триггеры
улучшенное
управле- ROW
ние целостностью
T211-05 Активная база данных, Возможность
задать
улучшенное
управле- условие поиска, кото-
ние целостностью
рое должно быть ис-
2258
FOR
EACHСоответствие стандарту SQL
Идентификатор Пакет
Описание
Комментарий
тинным перед вызовом
триггера
T211-07 Активная база данных, Право TRIGGER
улучшенное
управле-
ние целостностью
T212 Расширенное управле- Расширенные возмож-
ние целостностью
ности триггеров
T213 Триггеры INSTEAD OF
T231 Чувствительные курсо-
ры
T241 Оператор
TRANSACTION
T271 Точки сохранения
T281 Право SELECT на уров-
не столбцов
T285 Улучшения имён про-
изводных столбцов
T312 Функция OVERLAY
START
T321-01 Ядро Пользовательские
функции без перегруз-
ки
T321-02 Ядро Пользовательские хра-
нимые процедуры без
перегрузки
T321-03 Ядро Вызов функций
T321-04 Ядро Оператор CALL
T321-06 Ядро Представление
ROUTINES
T321-07 Ядро Представление
PARAMETERS
T323 Явное управление без-
опасностью
внешних
подпрограмм
T325 Дополненные указания
параметров SQL
T331 Базовые роли
T341 Перегрузка
вызывае-
мых из SQL функций и
процедур
T351 Блочные комментарии
SQL (комментарии /
*...*/)
T431
OLAP
Расширенные возмож-
ности группирования
T432
Вложения и конкатена-
ция GROUPING SETS
2259Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
T433 Функция GROUPING с
несколькими аргумен-
тами
T441 Функции ABS и MOD
T461 Симметричный преди-
кат BETWEEN
T491 Производная
LATERAL
T501 Улучшенный предикат
EXISTS
T521 Именованные аргумен-
ты в операторе CALL
T551 Необязательные клю-
чевые слова, подразу-
меваемые синтаксисом
по умолчанию
T581 Функция подстроки по
регулярному выраже-
нию
T591 Ограничения UNIQUE
для столбцов, принима-
ющих NULL
T611
OLAP
таблица
Элементарные
ции OLAP
опера-
T613 Получение выборки
T614 Функция NTILE
T615 Функции LEAD и LAG
T617 Функции FIRST_VALUE
и LAST_VALUE
T620 Предложение
WINDOW:
параметр
GROUPS
T621 Дополнительные
ленные функции
T631
Ядро
чис-
Предикат IN с одним
элементом списка
T651 Операторы модифика-
ции схемы SQL в SQL-
подпрограммах
T655 Циклически зависимые
подпрограммы
X010 Тип XML
X011 Массивы типа XML
X014 Атрибуты типа XML
X016 Хранимые
XML
X020 XMLConcat
2260
значенияСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
X031 XMLElement
X032 XMLForest
X034 XMLAgg
X035 XMLAgg:
ORDER BY
X036 XMLComment
X037 XMLPI
X040 Базовое
таблиц
X041 Базовое отображение
таблиц: значения NULL
отсутствуют
X042 Базовое отображение
таблиц: NULL в виде nil
X043 Базовое отображение
таблиц: таблица в виде
леса элементов
X044 Базовое отображение
таблиц: таблица в виде
элемента
X045 Базовое отображение
таблиц: с целевым про-
странством имён
X046 Базовое
таблиц:
данных
X047 Базовое отображение
таблиц:
отображение
метаданных
X048 Базовое отображение
таблиц:
кодирование
двоичных
строк
в
base64
X049 Базовое отображение
таблиц:
кодирование
двоичных строк в шест-
надцатеричном виде
X050 Расширенное
жение таблиц
X051 Расширенное
отобра-
жение таблиц: значе-
ния NULL отсутствуют
X052 Расширенное
отобра-
жение таблиц: NULL в
виде nil
X053 Расширенное
отобра-
жение таблиц: таблица
в виде леса элементов
2261
параметр
отображение
отображение
отображение
отобра-Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
X054 Расширенное
отобра-
жение таблиц: таблица
в виде элемента
X055 Расширенное
отобра-
жение таблиц: с це-
левым пространством
имён
X056 Расширенное
отобра-
жение таблиц: отобра-
жение данных
X057 Расширенное
отобра-
жение таблиц: отобра-
жение метаданных
X058 Расширенное
отобра-
жение таблиц: кодиро-
вание двоичных строк в
base64
X059 Расширенное
отобра-
жение таблиц: кодиро-
вание двоичных строк
в шестнадцатеричном
виде
X060 XMLParse: ввод сим-
вольных строк и вари-
ант CONTENT
X061 XMLParse: ввод сим-
вольных строк и вари-
ант DOCUMENT
X070 XMLSerialize:
сериа-
лизация
символьных
строк
и
вариант
CONTENT
X071 XMLSerialize:
сериа-
лизация
символьных
строк
и
вариант
DOCUMENT
X072 XMLSerialize:
сериа-
лизация
символьных
строк
X090 Предикат
мента
X120 XML в параметрах SQL-
подпрограмм
X121 XML
в
параметрах
внешних подпрограмм
X222 Механизм
XML BY REF
X301 XMLTable:
указание
списка
производных
столбцов
2262
XML-доку-
передачиСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
X302 XMLTable:
указание
столбца нумерации
X303 XMLTable:
указание
значения столбца по
умолчанию
X304 XMLTable:
контекста
X400 Сопоставление имён и
идентификаторов
X410 Изменение типа дан-
ных столбца: поддерж-
ка типа XML
передача
D.2. Неподдерживаемые возможности
Следующие возможности, описанные в SQL:2011, не реализованы в этом выпуске PostgreSQL. В
некоторых случая они заменяются равнозначной функциональностью
Идентификатор
Пакет
Описание
Комментарий
B011 Встроенный язык Ada
B013 Встроенный
COBOL язык
B014 Встроенный
Fortran язык
B015 Встроенный
MUMPS язык
B016 Встроенный
Pascal язык
B017 Встроенный язык PL/I
B031 Базовый динамический
SQL
B032 Расширенный динами-
ческий SQL
B032-01 <Оператор input=""> B033 Нетипизированные ар-
гументы функции, вы-
зываемой из SQL
B034 Динамическое
указа-
ние атрибутов курсора
B035 Нерасширенные имена
дескрипторов
B041 Расширения
встроен-
ных объявлений исклю-
чений SQL
B051 Расширенные
права
для выполнения
B111 Язык модулей — Ada
B112 Язык модулей — C
2263
describeСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
B113 Язык
COBOL модулей —
B114 Язык
Fortran модулей —
B115 Язык
модулей
MUMPS —
B116 Язык модулей — Pascal
B117 Язык модулей — PL/I B121 Язык подпрограмм —
Ada
B122 Язык подпрограмм — C
B123 Язык подпрограмм —
COBOL
B124 Язык подпрограмм —
Fortran
B125 Язык подпрограмм —
MUMPS
B126 Язык подпрограмм —
Pascal
B127 Язык подпрограмм —
PL/I
B128 Язык подпрограмм —
SQL
B211 Язык модулей — Ada:
поддержка VARCHAR и
NUMERIC
B221 Язык
подпрограмм
—
Ada:
поддержка
VARCHAR и NUMERIC
E182
Ядро
Язык модулей
F054 TIMESTAMP в списке
приоритетов типа DATE
F121 Базовое управление ди-
агностикой
F121-01 Оператор
DIAGNOSTICS
F121-02 Оператор
SET
TRANSACTION:
пред-
ложение DIAGNOSTICS
SIZE
F122 Расширенное управле-
ние диагностикой
F123 Вся диагностика
F181
Ядро
GET
Поддержка множества
модулей
2264Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
F263 Разделённые запятыми
предикаты в простом
выражении CASE
F291 Предикат UNIQUE
F301 CORRESPONDING в вы-
ражениях запросов
F311
Ядро
Оператор определения
схемы
F312 Оператор MERGE
возможная альтернати-
ва — INSERT ... ON
CONFLICT DO UPDATE
F313 Расширенный оператор
MERGE
F314 Оператор MERGE с вет-
вью DELETE
F341 Таблицы
ния
F385 Предложение удаления
выражения, генериру-
ющего значения столб-
ца
F394 Необязательное указа-
ние нормальной формы
F403 Секционированные со-
единённые таблицы
F451 Определение
символов
набора
F461 Именованные
символов
наборы
F492 Необязательное указа-
ние соблюдения огра-
ничения таблицы
использова- без таблиц ROUTINE_*_
USAGE
F521 Расширенное управле- Утверждения
ние целостностью
F671 Расширенное управле- Подзапросы в CHECK
ние целостностью
F693 Правила
сортировки
символов для SQL-сеан-
сов и клиентских моду-
лей
F695 Поддержка
ровки
F696 Дополнительная доку-
ментация по перекоди-
ровке
F721 Откладываемые
ничения
2265
намеренно опущено
перекоди-
огра- только сторонние
уникальные ключи
иСоответствие стандарту SQL
Идентификатор
Пакет
Описание
F741
F812
Комментарий
Типы ссылочных совпа- пока без частичного
дений MATCH
совпадения
Ядро
Базовое флагирование
F813 Расширенное флагиро-
вание
F821 Ссылки на локальные
таблицы
F831 Полное изменение кур-
сора
F831-01 Изменяемые прокручи-
ваемые курсоры
F831-02 Изменяемые упорядо-
ченные курсоры
F841 Предикат LIKE_REGEX
F842 Функция
OCCURRENCES_
REGEX
F843 Функция
REGEX
POSITION_
F844 Функция
REGEX
SUBSTRING_
F845 Функция
REGEX
TRANSLATE_
F846 Поддержка октетов в
операторах регулярных
выражений
F847 Неконстантные
регу-
лярные выражения
F866 Предложение
FETCH
FIRST:
параметр
PERCENT
F867 Предложение
FETCH
FIRST: параметр WITH
TIES
S011 Ядро Отдельные типы дан-
ных
S011-01 Ядро Представление USER_
DEFINED_TYPES
S023 Базовая
объектов S024 Расширенная поддерж- Расширенные структу-
ка объектов
рированные типы
S025 Окончательные струк-
турированные типы
S026 Самоссылающиеся
структурированные ти-
пы
поддержка Базовые структуриро-
ванные типы
2266Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
S027 Создание метода по за-
данному имени метода
S028 Произвольный порядок
параметров UDT
S041 Базовая
объектов
поддержка Базовые ссылочные ти-
пы
S043 Расширенная поддерж- Расширенные
ка объектов
ные типы
S051 Базовая
объектов
S081 Расширенная поддерж- Подтаблицы
ка объектов
ссылоч-
поддержка Создание таблицы из частично поддержива-
типа
ется
S091 Базовая
массивов
поддержка частично поддержива-
ется
S091-01 Массивы
встроенных
типов данных
S091-02 Массивы отдельных ти-
пов
S091-03 Выражения с массива-
ми
S094 Массивы ссылочных ти-
пов
S097 Присвоение значения
элементу массива
S151 Базовая
объектов
поддержка Предикат типа
S161 Расширенная поддерж- Приведение подтипов
ка объектов
S162 Приведение подтипов
для ссылочных типов
S202 Вызываемые из SQL
подпрограммы, работа-
ющие с мультимноже-
ствами
S231 Расширенная поддерж- Указатели на структур-
ка объектов
ные типы
S232 Указатели на массивы
S233 Указатели на мульти-
множества
S241 Функции преобразова-
ний
S242 Оператор
изменения
преобразования
S251 Определяемые пользо-
вателем упорядочива-
ния
S261 Метод SPECIFICTYPE
2267Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
S271 Базовая
поддержка
мультимножеств
S272 Мультимножества
пользовательских
пов
S274 Мультимножества ссы-
лочных типов
S275 Расширенная поддерж-
ка мультимножеств
S281 Типы вложенных кол-
лекций
S291 Ограничение уникаль-
ности для всей строки
S401 Отдельные типы на ба-
зе типов массивов
S402 Отдельные типы на ба-
зе отдельных типов
S403 ARRAY_MAX_
CARDINALITY
S404 TRIM_ARRAY
T011 Тип TIMESTAMP в ин-
формационной схеме
T021 Типы данных BINARY и
VARBINARY
T022 Расширенная поддерж-
ка
типов
данных
BINARY и VARBINARY
T023 Составные
строки
T024 Пробелы
строках
ти-
двоичные
в
двоичных
T041 Базовая
объектов поддержка Базовая поддержка ти-
па данных LOB
T041-01 Базовая
объектов поддержка Тип данных BLOB
T041-02 Базовая
объектов поддержка Тип данных CLOB
T041-03 Базовая
объектов поддержка Функции
POSITION,
LENGTH,
LOWER,
TRIM,
UPPER
и
SUBSTRING для типов
данных LOB
T041-04 Базовая
объектов поддержка Конкатенация
данных LOB
T041-05 Базовая
объектов поддержка Указатель
на
LOB:
неудерживаемый
T042
типов
Расширенная поддерж-
ка типа данных LOB
2268Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
T043 Множитель T
T044 Множитель P
T051 Типы кортежей
T052 MAX и MIN для типов
кортежей
T053 Явные
псевдонимы
ссылки на все поля
T061 Поддержка UCS
T101 Улучшенное определе-
ние возможности NULL
T111 Изменяемые соедине-
ния, объединения и
столбцы
T175 Генерируемые столбцы
T176 Поддержка генерато-
ров последовательно-
стей
T180 Системное версиониро-
вание таблиц
T181 Таблицы
времени
уровня
с периодом
прикладного
T211 Активная база данных, Базовые возможности
улучшенное
управле- триггеров
ние целостностью
T211-06 Активная база данных, Поддержка правил вре-
улучшенное
управле- мени выполнения для
ние целостностью
взаимодействия тригге-
ров и ограничений
T211-08 Активная база данных, Несколько
триггеров намеренно опущено
улучшенное
управле- для одного события вы-
ние целостностью
зываются в том поряд-
ке, в каком они были со-
зданы в каталоге
T251 Оператор
TRANSACTION:
метр LOCAL
SET
пара-
T261 Сцеплённые
ции
T272 Улучшенное управле-
ние точками сохране-
ния
T301 Функциональные зави- частично поддержива-
симости
ется
транзак-
T321 Ядро Базовые
вызываемые
из SQL подпрограммы
T321-05 Ядро Оператор RETURN
2269Соответствие стандарту SQL
Идентификатор Пакет Описание
Комментарий
T322 PSM Объявляемые атрибуты
типа данных
T324 Явное управление без-
опасностью
подпро-
грамм SQL
T326 Табличные функции
T332 Расширенные роли
T434 GROUP BY DISTINCT
T471 Наборы результатов в
качестве возвращаемо-
го значения
T472 DESCRIBE CURSOR
T495 Совместное изменение другой синтаксис
и извлечение данных
T502 Предикаты периодов
T511 Счётчики транзакций
T522 Значения по умолча-
нию для входных пара-
метров процедур, вызы-
ваемых из SQL
T561 Удерживаемые
тели
T571 Внешние вызываемые
из SQL функции, воз-
вращающие массивы
T572 Внешние вызываемые
из
SQL
функции,
возвращающие мульти-
множества
T601 Ссылки на локальные
курсоры
T612 Расширенные
ции OLAP
T616 Варианты
обработки
NULL
для
функций
LEAD и LAG
T618 Функция NTH_VALUE
T619 Вложенные
функции
T641 Присвоение
несколь- поддерживаются толь-
ким столбцам
ко некоторые варианты
синтаксиса
T652 Операторы динамиче-
ского SQL в SQL-под-
программах
2270
в основном поддержи-
ваются
поддерживаются, за ис-
ключением ключевого
слова DEFAULT при вы-
зове
указа-
опера- поддерживаются неко-
торые формы
функция
существует,
но некоторые возмож-
ности отсутствуют
оконныеСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
T653 Операторы модифика-
ции схемы SQL во внеш-
них подпрограммах
T654 Операторы динамиче-
ского SQL во внешних
подпрограммах
M001 Связи
данных
DATALINK)
M002 Связи данных
SQL/CLI
M003 Связи данных через
встроенный SQL
M004 Поддержка
данных сторонних частично поддержива-
ется
M005 Поддержка
схем сторонних
M006 Подпрограмма
GetSQLString
M007 TransmitRequest
M009 Подпрограммы GetOpts
и GetStatistics
M010 Поддержка
обёрток другой API
сторонних данных
M011 Связи
Ada M012 Связи данных через C
M013 Связи данных
COBOL
через
M014 Связи данных
Fortran
через
M015 Связи данных
MUMPS
через
M016 Связи
Pascal через
M017 Связи данных через PL/
I
M018 Подпрограммы интер-
фейса обёртки сторон-
них данных на языке
Ada
M019 Подпрограммы интер- другой API
фейса обёртки сторон-
них данных на языке C
M020 Подпрограммы интер-
фейса обёртки сторон-
них данных на языке
COBOL
2271
данных
данных
(
через
черезСоответствие стандарту SQL
Идентификатор
Пакет
Описание
M021 Подпрограммы интер-
фейса обёртки сторон-
них данных на языке
Fortran
M022 Подпрограммы интер-
фейса обёртки сторон-
них данных на языке
MUMPS
M023 Подпрограммы интер-
фейса обёртки сторон-
них данных на языке
Pascal
M024 Подпрограммы интер-
фейса обёртки сторон-
них данных на языке
PL/I
M030 Поддержка сторонних
данных SQL-сервера
M031 Общие подпрограммы
обёртки сторонних дан-
ных
X012 Мультимножества типа
XML
X013 Отдельные типы, про-
изводные от XML
X015 Поля типа XML
X025 XMLCast
X030 XMLDocument
X038 XMLText
X065 XMLParse: ввод BLOB и
вариант CONTENT
X066 XMLParse: ввод BLOB и
вариант DOCUMENT
X068 XMLSerialize: BOM
X069 XMLSerialize: INDENT
X073 XMLSerialize: сериали-
зация BLOB и вариант
CONTENT
X074 XMLSerialize: сериали-
зация BLOB и вариант
DOCUMENT
X075 XMLSerialize: сериали-
зация BLOB
X076 XMLSerialize: VERSION
X077 XMLSerialize:
явное
указание ENCODING
X078 XMLSerialize:
явное
объявление XML
2272
КомментарийСоответствие стандарту SQL
Идентификатор
Пакет
Описание
X080 Пространства имён при
публикации XML
X081 Объявления
про-
странств имён XML на
уровне запроса
X082 Объявления
про-
странств имён XML в
DML
X083 Объявления
про-
странств имён XML в
DDL
X084 Объявления
про-
странств имён XML в
составных операторах
X085 Предопределённые
префиксы пространств
имён
X086 Объявления
про-
странств имён XML в
XMLTable
X091 Предикат содержимого
XML
X096 XMLExists
X100 Поддержка
ведущего
языка для XML: вари-
ант CONTENT
X101 Поддержка
ведущего
языка для XML: вари-
ант DOCUMENT
X110 Поддержка
ведущего
языка для XML: отобра-
жение VARCHAR
X111 Поддержка
ведущего
языка для XML: отобра-
жение CLOB
X112 Поддержка
ведущего
языка для XML: отобра-
жение BLOB
X113 Поддержка
ведуще-
го
языка
для
XML: указание STRIP
WHITESPACE
X114 Поддержка
ведуще-
го языка для XML:
указание
PRESERVE
WHITESPACE
X131 Предложение
XMLBINARY на уровне
запроса
2273
Комментарий
Только XPathСоответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
X132 Предложение
XMLBINARY в DML
X133 Предложение
XMLBINARY в DDL
X134 Предложение
XMLBINARY в состав-
ных операторах
X135 Предложение
XMLBINARY в
просах
X141 Предикат IS VALID: в
зависимости от данных
X142 Предикат IS VALID:
предложение
ACCORDING TO
X143 Предикат IS
предложение
ELEMENT
X144 Предикат IS VALID: рас-
положение схемы
X145 Предикат IS VALID вне
ограничений-проверок
X151 Предикат IS VALID с ва-
риантом DOCUMENT
X152 Предикат IS VALID с ва-
риантом CONTENT
X153 Предикат IS VALID с ва-
риантом SEQUENCE
X155 Предикат IS VALID:
NAMESPACE без пред-
ложения ELEMENT
X157 Предикат IS VALID: NO
NAMESPACE с предло-
жением ELEMENT
X160 Базовая информацион-
ная схема для заре-
гистрированных XML-
схем
X161 Расширенная информа-
ционная схема для за-
регистрированных
XML-схем
X170 Варианты
обработки
NULL с XML
X171 Вариант NIL ON NO
CONTENT
X181 Тип XML(DOCUMENT(
UNTYPED))
2274
подза-
VALID:Соответствие стандарту SQL
Идентификатор
Пакет
Описание
Комментарий
X182 Тип XML(DOCUMENT(
ANY))
X190 Тип XML(SEQUENCE)
X191 Тип XML(DOCUMENT(
XMLSCHEMA))
X192 Тип
XML(CONTENT(
XMLSCHEMA))
X200 XMLQuery
X201 XMLQuery:
RETURNING CONTENT
X202 XMLQuery:
RETURNING
SEQUENCE
X203 XMLQuery:
контекста
X204 XMLQuery:
инициа-
лизация
переменной
XQuery
X205 XMLQuery:
указание
EMPTY ON EMPTY
X206 XMLQuery:
указание
NULL ON EMPTY
X211 Поддержка XML 1.1
X221 Механизм
передачи
XML BY VALUE
X231 Тип
XML(CONTENT(
UNTYPED))
X232 Тип
ANY))
X241 RETURNING CONTENT
при публикации XML
X242 RETURNING
SEQUENCE при публи-
кации XML
X251 Хранимые
значения
XML
типа
XML(
DOCUMENT(
UNTYPED))
X252 Хранимые
значения
XML
типа
XML(
DOCUMENT(ANY))
X253 Хранимые
значения
XML
типа
XML(
CONTENT(UNTYPED))
X254 Хранимые
значения
XML
типа
XML(
CONTENT(ANY))
2275
передача
XML(CONTENT(Соответствие стандарту SQL
Идентификатор
Пакет
Описание
X255 Хранимые
значения
XML
типа
XML(
SEQUENCE)
X256 Хранимые
значения
XML
типа
XML(
DOCUMENT(
XMLSCHEMA))
X257 Хранимые
значения
XML
типа
XML(
CONTENT(
XMLSCHEMA))
X260 Тип XML: предложение
ELEMENT
X261 Тип XML: NAMESPACE
без
предложения
ELEMENT
X263 Тип
XML:
NO
NAMESPACE с предло-
жением ELEMENT
X264 Тип XML: расположе-
ние схемы
X271 XMLValidate: в зависи-
мости от данных
X272 XMLValidate: предложе-
ние ACCORDING TO
X273 XMLValidate: предложе-
ние ELEMENT
X274 XMLValidate: располо-
жение схемы
X281 XMLValidate с вариан-
том DOCUMENT
X282 XMLValidate с вариан-
том CONTENT
X283 XMLValidate с вариан-
том SEQUENCE
X284 XMLValidate:
NAMESPACE без пред-
ложения ELEMENT
X286 XMLValidate:
NO
NAMESPACE с предло-
жением ELEMENT
X300 XMLTable
X305 XMLTable: инициализа-
ция переменной XQuery
2276
</Оператор></предложени-></Указание></Предложение></выраже-></предло-></Предложение></вы-></Предложение></предложе-></Указание></Предложение></Предложение></выражении></Предложение></предложении></предло-></вы-></предло-></Предложение></Предложение></выражении></Предложение></списка>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    

    
    
    

    
      
        <li><strong class="current-page">2</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page3/">3</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page4/">4</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page3/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>