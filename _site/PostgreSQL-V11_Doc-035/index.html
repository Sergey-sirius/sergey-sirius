<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 35. Большие объекты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 35. Большие объекты">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 35. Большие объекты">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-035/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-035/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 35. Большие объекты">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-035/" rel="bookmark" title="Глава 35. Большие объекты">Глава 35. Большие объекты</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~15 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 35. Большие объекты</p>

<p>В PostgreSQL имеется механизм для работы с большими объектами, предоставляющий доступ в
потоковом режиме к пользовательским данным, сохранённым в специальной структуре больших
объектов. Потоковый доступ удобен, когда нужно обрабатывать данные, объём которых слишком
велик, чтобы оперировать ими как единым целым.
В этой главе описывается реализация, а также программный интерфейс и функции языка запро-
сов для работы с данными больших объектов PostgreSQL. В примерах в этой главе будет исполь-
зоваться библиотека libpq для языка C, но та же функциональность поддерживается и другими
программными интерфейсами PostgreSQL. Другие интерфейсы могут использовать внутри себя
интерфейс больших объектов для реализации общего подхода к работе с большими значениями.
Здесь это не описывается.
35.1. Введение
Все большие объекты хранятся в одной системной таблице с именем pg_largeobject. Для каждого
большого объекта также имеется запись в системной таблице pg_largeobject_metadata. Большие
объекты можно создавать, изменять и удалять, используя API чтения/записи, подобный стандарт-
ному API для работы с файлами.
PostgreSQL также поддерживает систему хранения, названную «TOAST», которая автоматически
переносит значения, не умещающиеся в одну страницу таблицы, в дополнительную область хра-
нилища. Вследствие этого подсистема больших объектов отчасти оказывается устаревшей. Однако
её преимуществом остаётся то, что она позволяет сохранять значения размером до 4 Тбайт, тогда
как поля в TOAST ограничиваются 1 Гбайтом. Кроме того, чтение и изменение больших объектов
можно выполнять эффективнее по сравнению с полями TOAST, которые при большинстве опера-
ций считываются и записываются как единое целое.
35.2. Особенности реализации
Механизм больших объектов разбивает большие объекты на «фрагменты» и сохраняет эти фраг-
менты в строках таблицы. При произвольном доступе на запись и чтение быстрый поиск нужного
фрагмента обеспечивается индексом-B-деревом в этой таблице.
Фрагменты больших объектов не должны быть последовательными. Например, если приложение
откроет новый большой объект, переместится к смещению 1000000 байт и запишет несколько
байт, это не приведёт к выделению лишнего 1000000 байт в хранилище; записаны будут только
фрагменты, покрывающие диапазон собственно записанных байт. Операция чтения, однако, про-
читает нули для всех неразмещённых в хранилище байт, предшествующих последнему записан-
ному фрагменту. Это соответствует принятому поведению «разреженных» файлов в файловых си-
стемах Unix.
Начиная с PostgreSQL 9.0, для больших объектов назначается владелец и набор прав доступа, ко-
торыми можно управлять командами GRANT и REVOKE. Для чтения большого объекта требуются
права SELECT, а для записи или усечения его — права UPDATE. Удалять большой объект, задавать
комментарий для него, либо сменять его владельца разрешается только его владельцу (или супер-
пользователю базы данных). Для совместимости с предыдущими версиями можно скорректировать
это поведение, изменив параметр времени выполнения lo_compat_privileges.
35.3. Клиентские интерфейсы
В этом разделе описываются средства, которые предоставляет клиентская библиотека PostgreSQL
libpq для обращения к большим объектам. Интерфейс работы с большими объектами PostgreSQL
создан по подобию интерфейса файловых систем Unix, так что он включает аналоги функций open,
read, write, lseek и т. д.
Все операции с большими объектами с применением этих функций должны иметь место в блоке
транзакции SQL, так как дескрипторы больших объектов актуальны только во время транзакции.
832Большие объекты
Если при выполнении одной из этих функций происходит ошибка, эта функция возвращает значе-
ние, иначе невозможное, обычно 0 или -1. Сообщение, описывающее ошибку, сохраняется в объ-
екте соединения; получить его можно с помощью PQerrorMessage.
Клиентские приложения, которые используют эти функции, должны включать заголовочный файл
libpq/libpq-fs.h и компоноваться с библиотекой libpq.
35.3.1. Создание большого объекта
Функция
Oid lo_creat(PGconn <em>conn, int mode);
создаёт новый большой объект. Возвращаемым значением будет OID, назначенный новому объек-
ту, либо InvalidOid (ноль) в случае ошибки. Параметр mode не используется и игнорируется, на-
чиная с PostgreSQL 8.1; однако для обратной совместимости с более ранними выпусками в нём
лучше задать значение INV_READ, INV_WRITE или INV_READ | INV_WRITE. (Эти константы определе-
ны в заголовочном файле libpq/libpq-fs.h.)
Пример:
inv_oid = lo_creat(conn, INV_READ|INV_WRITE);
Функция
Oid lo_create(PGconn *conn, Oid lobjId);
также создаёт новый большой объект. В lobjId можно задать назначаемый ему OID; при этом
произойдёт ошибка, если этот OID уже присвоен какому-либо большому объекту. Если в lobjId
передаётся InvalidOid (ноль), lo_create присваивает большому объекту свободный OID (так же,
как и lo_creat). Возвращаемым значением будет OID, назначенный новому большому объекту,
либо InvalidOid (ноль) в случае ошибки.
Функция lo_create появилась в PostgreSQL 8.1; если попытаться выполнить её с сервером более
старой версии, произойдёт ошибка и будет возвращено InvalidOid.
Пример:
inv_oid = lo_create(conn, desired_oid);
35.3.2. Импорт большого объекта
Чтобы импортировать в качестве большого объекта файл операционной системы, вызовите
Oid lo_import(PGconn *conn, const char *filename);
В filename задаётся имя файла в операционной системе, который будет импортирован как боль-
шой объект. Возвращаемым значением будет OID, назначенный новому большому объекту, либо
InvalidOid (ноль) в случае ошибки. Заметьте, что этот файл читает библиотека клиентского ин-
терфейса, а не сервер; таким образом, он должен существовать в файловой системе на стороне
клиента и быть доступным для чтения клиентскому приложению.
Функция
Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);
также импортирует новый большой объект. В lobjId можно задать назначаемый ему OID; при этом
произойдёт ошибка, если этот OID уже присвоен какому-либо большому объекту. Если в lobjId
передаётся InvalidOid (ноль), lo_import_with_oid присваивает большому объекту свободный OID
(так же, как и lo_import). Возвращаемым значением будет OID, назначенный новому большому
объекту, либо InvalidOid (ноль) в случае ошибки.
Функция lo_import_with_oid появилась в PostgreSQL 8.4 и вызывает внутри lo_create, появив-
шуюся в 8.1; если попытаться выполнить её с сервером версии 8.0 или ранней, она завершится
ошибкой и возвратит InvalidOid.
833Большие объекты
35.3.3. Экспорт большого объекта
Чтобы экспортировать большой объект в файл операционной системы, вызовите
int lo_export(PGconn *conn, Oid lobjId, const char *filename);
В аргументе lobjId задаётся OID экспортируемого большого объекта, а в аргументе filename за-
даётся имя файла в операционной системе. Заметьте, что файл записывается библиотекой клиент-
ского интерфейса, а не сервером. Возвращает 1 при успешном выполнении, -1 при ошибке.
35.3.4. Открытие существующего большого объекта
Чтобы открыть существующий большой объект для чтения или записи, вызовите
int lo_open(PGconn *conn, Oid lobjId, int mode);
В аргументе lobjId задаётся OID открываемого большого объекта. Биты в аргументе mode опреде-
ляют, открывается ли файл для чтения (INV_READ), для записи (INV_WRITE), либо для чтения/записи.
(Эти константы определяются в заголовочном файле libpq/libpq-fs.h.) Функция lo_open возвра-
щает дескриптор большого объекта (неотрицательный) для последующего использования в функ-
циях lo_read, lo_write, lo_lseek, lo_lseek64, lo_tell, lo_tell64, lo_truncate, lo_truncate64 и
lo_close. Этот дескриптор актуален только до завершения текущей транзакции. В случае ошибки
возвращается -1.
В настоящее время сервер не различает режимы INV_WRITE и INV_READ | INV_WRITE: с таким де-
скриптором можно читать данные в любом случае. Однако есть значительное отличие этих режи-
мов от одиночного INV_READ: с дескриптором INV_READ записывать данные нельзя, а данные, счи-
тываемые через него, будут отражать содержимое большого объекта в снимке транзакции, кото-
рый был активен при выполнении lo_open, то есть не будут включать изменения, произведённые
позже этой или другими транзакциями. При чтении с дескриптором INV_WRITE возвращаются дан-
ные, отражающие все изменения, произведённые другими зафиксированными транзакциями, а
также текущей транзакцией. Это подобно различиям режимов REPEATABLE READ и READ COMMITTED
для обычных команд SQL SELECT.
Функция lo_open завершится ошибкой, если пользователь не имеет права SELECT для данного
большого объекта или если указан флаг INV_WRITE и отсутствует право UPDATE. (До PostgreSQL
11 права проверялись при первом фактическом вызове функции чтения или записи с этим де-
скриптором.) Отключить новые проверки можно с помощью параметра времени выполнения
lo_compat_privileges.
Пример:
inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);
35.3.5. Запись данных в большой объект
Функция
int lo_write(PGconn *conn, int fd, const char *buf, size_t len);
записывает len байт из буфера buf (который должен иметь размер len) в дескриптор большого
объекта fd. В fd должно передаваться значение, возвращённое предыдущим вызовом lo_open. Воз-
вращает эта функция число фактически записанных байт (в текущей реализации это всегда len,
если только не произошла ошибка). В случае ошибки возвращается значение -1.
Хотя параметр len объявлен как size_t, эта функция не принимает значение длины, превышаю-
щее INT_MAX. На практике всё равно лучше передавать данные фрагментами не больше несколь-
ких мегабайт.
35.3.6. Чтение данных из большого объекта
Функция
834Большие объекты
int lo_read(PGconn *conn, int fd, char *buf, size_t len);
читает до len байт из дескриптора большого объекта fd в буфер buf (который должен иметь раз-
мер len). В fd должно передаваться значение, возвращённое предыдущим вызовом lo_open. Воз-
вращает эта функция число фактически прочитанных байт; это число должно быть меньше len,
если при чтении был достигнут конец объекта. В случае ошибки возвращается -1.
Хотя параметр len объявлен как size_t, эта функция не принимает значение длины, превышаю-
щее INT_MAX. На практике всё равно лучше передавать данные фрагментами не больше несколь-
ких мегабайт.
35.3.7. Перемещение в большом объекте
Чтобы изменить текущее положение чтения или записи, связанное с дескриптором большого объ-
екта, вызовите
int lo_lseek(PGconn *conn, int fd, int offset, int whence);
Эта функция перемещает указатель текущего положения для дескриптора большого объекта
fd в новое положение, заданное аргументом offset. Для аргумента whence задаются значения
SEEK_SET (перемещение от начала объекта), SEEK_CUR (перемещение от текущего положения) и
SEEK_END (перемещение от конца объекта). Возвращает эта функция новое положение указателя,
либо -1 в случае ошибки.
Оперируя с большими объектами, размер которых превышает 2 ГБ, используйте
pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);
Эта функция действует так же, как и lo_lseek, но может принять значение offset, превышающее
2 ГБ, и/или вернуть результат, превышающий 2 ГБ. Заметьте, что если новое положение указателя
оказывается за границей в 2ГБ, функция lo_lseek выдаёт ошибку.
Функция lo_lseek64 появилась в PostgreSQL 9.3. Если попытаться выполнить её с сервером более
старой версии, произойдёт ошибка и будет возвращено -1.
35.3.8. Получение текущего положения в большом объекте
Чтобы получить текущее положение чтения или записи для дескриптора большого объекта, вызо-
вите
int lo_tell(PGconn *conn, int fd);
Если возникает ошибка, возвращается -1.
Оперируя с большими объектами, размер которых может превышать 2 ГБ, используйте
pg_int64 lo_tell64(PGconn *conn, int fd);
Эта функция действует так же, как lo_tell, но может выдавать результат, превышающий 2 ГБ.
Заметьте, что lo_tell выдаёт ошибку, если текущее положение чтения/записи оказывается за
границей в 2 ГБ.
Функция lo_tell64 появилась в PostgreSQL 9.3. Если попытаться выполнить её с сервером более
старой версии, произойдёт ошибка и будет возвращено -1.
35.3.9. Усечение большого объекта
Чтобы усечь большой объект до требуемой длины, вызовите
int lo_truncate(PGcon *conn, int fd, size_t len);
Эта функция усекает большой объект с дескриптором fd до длины len. В fd должно передаваться
значение, возвращённое предыдущим вызовом lo_open. Если len превышает текущую длину боль-
шого объекта, большой объект расширяется до заданной длины нулевыми байтами (‘\0’). В случае
успеха lo_truncate возвращает ноль, а при ошибке возвращается -1.
835Большие объекты
Положение чтения/записи, связанное с дескриптором fd, при этом не меняется.
Хотя параметр len объявлен как size_t, lo_truncate не принимает значение длины, превышаю-
щее INT_MAX.
Оперируя с большими объектами, размер которых может превышать 2 ГБ, используйте
int lo_truncate64(PGcon *conn, int fd, pg_int64 len);
Эта функция действует так же, как lo_truncate, но может принимать значения len, превышающие
2 ГБ.
Функция lo_truncate появилась в PostgreSQL 8.3; если попытаться выполнить её с сервером более
старой версии, произойдёт ошибка и будет возвращено -1.
Функция lo_truncate64 появилась в PostgreSQL 9.3; если попытаться выполнить её с сервером
более старой версии, произойдёт ошибка и будет возвращено -1.
35.3.10. Закрытие дескриптора большого объекта
Дескриптор большого объекта можно закрыть, вызвав
int lo_close(PGconn *conn, int fd);
Здесь fd — дескриптор большого объекта, возвращённый функцией lo_open. В случае успеха
lo_close возвращает ноль. При ошибке возвращается -1.
Все дескрипторы больших объектов, остающиеся открытыми в конце транзакции, закрываются
автоматически.
35.3.11. Удаление большого объекта
Чтобы удалить большой объект из базы данных, вызовите
int lo_unlink(PGconn *conn, Oid lobjId);
В аргументе lobjId задаётся OID большого объекта, который нужно удалить. В случае успеха воз-
вращается 1, а в случае ошибки -1.
35.4. Серверные функции
Функции, предназначенные для работы с большими объектами на стороне сервера из SQL, пере-
числены в Таблице 35.1.
Таблица 35.1. SQL-ориентированные функции для работы с большими объектами
Функция
Тип результата
Описание
Пример
lo_from_bytea(
oid
loid
oid,
string bytea) Создаёт большой lo_from_bytea(
объект,
сохраня- 0,
ет в нём данные ‘\xffffff00’)
и возвращает его
OID. С 0 система
выбирает OID са-
ма.
lo_put(
oid,
bigint,
bytea) Записывает
дан- lo_put(24528,
ные по заданному 1, ‘\xaa’)
смещению.
loid
void
offset
str
lo_get( loid oid bytea
[, from bigint,
for int])
Извлекает содер- lo_get(24528,
жимое подстроки. 0, 3)
836
Результат
24528
\xffaaffБольшие объекты
Каждой из клиентских функций, описанных ранее, соответствуют дополнительные функции на сто-
роне сервера; на самом деле, по большей части клиентские функции представляют собой просто
интерфейсы к равнозначным серверным функциям. К функциям, которые так же удобно вызывать
командами SQL, относятся: lo_creat, lo_create, lo_unlink, lo_importи lo_export. Ниже приве-
дены примеры их использования:
CREATE TABLE image (
name
text,
raster
oid
);
SELECT lo_creat(-1); – возвращает OID нового пустого большого объекта
SELECT lo_create(43213); – пытается создать большой объект с OID 43213
SELECT lo_unlink(173454); – удаляет большой объект с OID 173454
INSERT INTO image (name, raster)
VALUES (‘beautiful image’, lo_import(‘/etc/motd’));
INSERT INTO image (name, raster) – то же, что выше, но с предопределённым OID
VALUES (‘beautiful image’, lo_import(‘/etc/motd’, 68583));
SELECT lo_export(image.raster, ‘/tmp/motd’) FROM image
WHERE name = ‘beautiful image’;
Серверные функции lo_import и lo_export значительно отличаются от их аналогов, выполняемых
на стороне клиента. Эти две функции читают и пишут файлы в файловой системе сервера с права-
ми пользователя-владельца базы данных. Поэтому по умолчанию использовать их разрешено толь-
ко суперпользователям. Клиентские функции импорта и экспорта, напротив, используют права
клиентской программы для чтения и записи файлов в файловой системе клиента. Для выполнения
клиентских функций никакие права в базе данных не требуется, кроме права на чтение или запись
требуемого большого объекта.
Внимание
Использование серверных функций lo_import и lo_export можно разрешить (восполь-
зовавшись GRANT) не только суперпользователям, но при этом следует серьёзно оце-
нить возможные угрозы безопасности. Злонамеренный пользователь, имея такие пра-
ва, легко может стать суперпользователем (например, перезаписав файлы конфигура-
ции сервера) или атаковать другие области файловой системы сервера, не стремясь по-
лучить полномочия суперпользователя в базе данных. Поэтому доступ к ролям с та-
кими правами должен ограничиваться так же строго, как и доступ к ролям супер-
пользователей. Тем не менее, если серверные функции lo_import и lo_export необ-
ходимо применять для каких-либо регулярных операций, безопаснее будет использо-
вать роль с такими правами, чем с правами суперпользователя, так как это помогает
предохраниться от случайных ошибок.
Функциональность lo_read и lo_write также представляется через вызовы на стороне сервера, но
имена серверных функций, в отличие от клиентских, не содержат символы подчёркивания. Эти
функции нужно вызывать по именам loread и lowrite.
35.5. Пример программы
В Примере 35.1 представлена пробная программа, демонстрирующая использование интерфейса
больших объектов в libpq. Части этой программы закомментированы, но оставлены в тексте для
читателя. Эту программу также можно найти в src/test/examples/testlo.c в дистрибутиве ис-
ходного кода.
837Большие объекты
Пример 35.1. Пример использования больших объектов с применением libpq
/</em>————————————————————————-
*</p>
<ul>
  <li>testlo.c
*
test using large objects with libpq
*</li>
  <li>Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group</li>
  <li>Portions Copyright (c) 1994, Regents of the University of California
*
*</li>
  <li>IDENTIFICATION
*
src/test/examples/testlo.c
*
*————————————————————————-
*/
#include <stdio.h>
#include <stdlib.h>
#include
#include
#include
#include</stdlib.h></stdio.h></li>
</ul>
<p>&lt;sys/types.h&gt;
&lt;sys/stat.h&gt;</p>
<fcntl.h>
<unistd.h>
#include "libpq-fe.h"
#include "libpq/libpq-fs.h"
#define BUFSIZE
1024
/*
* importFile -
*
import file "in_filename" into database as large object "lobjOid"
*
*/
static Oid
importFile(PGconn *conn, char *filename)
{
Oid
lobjId;
int
lobj_fd;
char
buf[BUFSIZE];
int
nbytes,
tmp;
int
fd;
/*
* open the file to be read in
*/
fd = open(filename, O_RDONLY, 0666);
if (fd &lt; 0)
{
/* error */
fprintf(stderr, "cannot open unix file\"%s\"\n", filename);
}
/*
* create the large object
*/
lobjId = lo_creat(conn, INV_READ | INV_WRITE);
if (lobjId == 0)
838Большие объекты
fprintf(stderr, "cannot create large object");
lobj_fd = lo_open(conn, lobjId, INV_WRITE);
/*
* read in from the Unix file and write to the inversion file
*/
while ((nbytes = read(fd, buf, BUFSIZE)) &gt; 0)
{
tmp = lo_write(conn, lobj_fd, buf, nbytes);
if (tmp &lt; nbytes)
fprintf(stderr, "error while reading \"%s\"", filename);
}
close(fd);
lo_close(conn, lobj_fd);
return lobjId;
}
static void
pickout(PGconn *conn, Oid lobjId, int start, int len)
{
int
lobj_fd;
char
*buf;
int
nbytes;
int
nread;
lobj_fd = lo_open(conn, lobjId, INV_READ);
if (lobj_fd &lt; 0)
fprintf(stderr, "cannot open large object %u", lobjId);
lo_lseek(conn, lobj_fd, start, SEEK_SET);
buf = malloc(len + 1);
nread = 0;
while (len - nread &gt; 0)
{
nbytes = lo_read(conn, lobj_fd, buf, len - nread);
buf[nbytes] = '\0';
fprintf(stderr, "&gt;&gt;&gt; %s", buf);
nread += nbytes;
if (nbytes &lt;= 0)
break;
/* no more data? */
}
free(buf);
fprintf(stderr, "\n");
lo_close(conn, lobj_fd);
}
static void
overwrite(PGconn *conn, Oid lobjId, int start, int len)
{
int
lobj_fd;
char
*buf;
int
nbytes;
int
nwritten;
int
i;
839Большие объекты
lobj_fd = lo_open(conn, lobjId, INV_WRITE);
if (lobj_fd &lt; 0)
fprintf(stderr, "cannot open large object %u", lobjId);
lo_lseek(conn, lobj_fd, start, SEEK_SET);
buf = malloc(len + 1);
for (i = 0; i &lt; len; i++)
buf[i] = 'X';
buf[i] = '\0';
nwritten = 0;
while (len - nwritten &gt; 0)
{
nbytes = lo_write(conn, lobj_fd, buf + nwritten, len - nwritten);
nwritten += nbytes;
if (nbytes &lt;= 0)
{
fprintf(stderr, "\nWRITE FAILED!\n");
break;
}
}
free(buf);
fprintf(stderr, "\n");
lo_close(conn, lobj_fd);
}
/*
* exportFile -
*
export large object "lobjOid" to file "out_filename"
*
*/
static void
exportFile(PGconn *conn, Oid lobjId, char *filename)
{
int
lobj_fd;
char
buf[BUFSIZE];
int
nbytes,
tmp;
int
fd;
/*
* open the large object
*/
lobj_fd = lo_open(conn, lobjId, INV_READ);
if (lobj_fd &lt; 0)
fprintf(stderr, "cannot open large object %u", lobjId);
/*
* open the file to be written to
*/
fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0666);
if (fd &lt; 0)
{
/* error */
fprintf(stderr, "cannot open unix file\"%s\"",
filename);
840Большие объекты
}
/*
* read in from the inversion file and write to the Unix file
*/
while ((nbytes = lo_read(conn, lobj_fd, buf, BUFSIZE)) &gt; 0)
{
tmp = write(fd, buf, nbytes);
if (tmp &lt; nbytes)
{
fprintf(stderr, "error while writing \"%s\"",
filename);
}
}
lo_close(conn, lobj_fd);
close(fd);
return;
}
static void
exit_nicely(PGconn *conn)
{
PQfinish(conn);
exit(1);
}
int
main(int argc, char **argv)
{
char
*in_filename,
*out_filename;
char
*database;
Oid
lobjOid;
PGconn
*conn;
PGresult
*res;
if (argc != 4)
{
fprintf(stderr, "Usage: %s database_name in_filename out_filename\n",
argv[0]);
exit(1);
}
database = argv[1];
in_filename = argv[2];
out_filename = argv[3];
/*
* set up the connection
*/
conn = PQsetdb(NULL, NULL, NULL, NULL, database);
/* check to see that the backend connection was successfully made */
if (PQstatus(conn) != CONNECTION_OK)
{
fprintf(stderr, "Connection to database failed: %s",
841Большие объекты
PQerrorMessage(conn));
exit_nicely(conn);
}
/* Set always-secure search path, so malicious users can't take control. */
res = PQexec(conn,
"SELECT pg_catalog.set_config('search_path', '', false)");
if (PQresultStatus(res) != PGRES_TUPLES_OK)
{
fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
PQclear(res);
/*
res = PQexec(conn, "begin");
PQclear(res);
printf("importing file \"%s\" ...\n", in_filename);
lobjOid = importFile(conn, in_filename); */
lobjOid = lo_import(conn, in_filename);
if (lobjOid == 0)
fprintf(stderr, "%s\n", PQerrorMessage(conn));
else
{
printf("\tas large object %u.\n", lobjOid);
printf("picking out bytes 1000-2000 of the large object\n");
pickout(conn, lobjOid, 1000, 1000);
printf("overwriting bytes 1000-2000 of the large object with X's\n");
overwrite(conn, lobjOid, 1000, 1000);
printf("exporting large object to file \"%s\" ...\n", out_filename);
exportFile(conn, lobjOid, out_filename); */
if (lo_export(conn, lobjOid, out_filename) &lt; 0)
fprintf(stderr, "%s\n", PQerrorMessage(conn));
/*
}
res = PQexec(conn, "end");
PQclear(res);
PQfinish(conn);
return 0;
}
842
</unistd.h></fcntl.h>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-035/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-035/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-035/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-034/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Script_Mount_FTP_Folder/" title="Монтируем папку FTP в файловую систему Bash  SCRIPT">Монтируем папку FTP в файловую систему Bash  SCRIPT</a></h3>
      <p>Bash Монтируем папку FTP в файловую систему Bash  SCRIPT: <a href="http://localhost:4000/Script_Mount_FTP_Folder/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Script_bash-copy-ftp/" title="Копируем на FTP скриптом bash">Копируем на FTP скриптом bash</a></h4>
        <span>Published on January 17, 2019</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Work-Project-Manager/" title="Коротко - работа менеджера проектов">Коротко - работа менеджера проектов</a></h4>
        <span>Published on December 04, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
