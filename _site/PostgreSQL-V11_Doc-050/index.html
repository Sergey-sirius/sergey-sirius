<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 50. Отслеживание прогресса репликации &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 50. Отслеживание прогресса репликации">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 50. Отслеживание прогресса репликации">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-050/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-050/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 50. Отслеживание прогресса репликации">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-050/" rel="bookmark" title="Глава 50. Отслеживание прогресса репликации">Глава 50. Отслеживание прогресса репликации</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~864 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 50. Отслеживание прогресса репликации</p>

<p>Инфраструктура источников репликации введена для упрощения реализации решений логической
репликации на основе логического декодирования. Она помогает решить две распространённых
проблемы:
• Как надёжно отслеживать прогресс репликации
• Как менять поведение репликации в зависимости от источника строки; например, для предот-
вращения циклов при двунаправленной репликации
Источники репликации имеют только два свойства: имя и OID. Имя, по которому к источнику сле-
дует обращаться из разных систем, задаётся значением типа text в произвольной форме. Его сле-
дует выбирать так, чтобы конфликты между источниками репликации, созданными различными
средствами репликации были маловероятны; например, добавлять в начало обозначение средства
репликации. OID используется только для того, чтобы не приходилось хранить длинное имя там,
где требуется минимизировать объём. Он не может разделяться между разными системами.
Источник репликации можно создать функцией pg_replication_origin_create(); удалить функ-
цией pg_replication_origin_drop(); и увидеть в системном каталоге pg_replication_origin.
Одной из нетривиальных задач при организации репликации является надёжное отслеживание
прогресса воспроизведения. Например, когда применяющий изменения процесс (или весь кла-
стер) умирает, нужно иметь возможность понять, какие данные были переданы успешно. Наивные
решения этой проблемы, такие как изменение строки в некоторой таблице для каждой воспроиз-
ведённой транзакции, чреваты дополнительной нагрузкой во время выполнения и замусоривани-
ем базы данных.
С использованием инфраструктуры источников репликации сеанс может быть по-
мечен как воспроизводящий изменения с удалённого узла (с помощью функции
pg_replication_origin_session_setup()). В дополнение к этому для каждой транзакции из ис-
точника можно задать LSN и время фиксации, вызвав pg_replication_origin_xact_setup().
Если сделать всё это, прогресс репликации можно будет отслеживать надёжным образом.
Прогресс воспроизведения для всех источников репликации можно увидеть в представле-
нии pg_replication_origin_status. Прогресс отдельного источника, например, при возоб-
новлении репликации, можно получить для любого источника, воспользовавшись функцией
pg_replication_origin_progress(), или для источника, настроенного в текущем сеансе, с помо-
щью pg_replication_origin_session_progress().
В топологиях репликации более сложных, чем простая репликация с одной системы в другую, воз-
можна ещё одна проблема — повторная репликация уже воспроизведённых строк, что может при-
водить к зацикливанию и снижению эффективности. В качестве механизма выявления и предот-
вращения повторной репликации так же могут оказаться полезны источники репликации. Если
воспользоваться функциями, упомянутыми в предыдущем абзаце, во все поступающие в сеансе
транзакции и изменения, передаваемые обработчикам модулей вывода (см. Раздел 49.6), добавля-
ется пометка источника репликации для текущего сеанса. Это позволяет обрабатывать их в модуле
вывода по-разному, например, игнорировать все строки, кроме имеющих локальное происхожде-
ние. Кроме того, обработчик вызова filter_by_origin_cb позволяет отфильтровать поток измене-
ний логического декодирования в зависимости от источника. Фильтрация через этот обработчик
не так гибка, как проверка записей внутри модуля вывода, но зато гораздо эффективнее.
1298Часть VI. Справочное руководство
Статьи этого справочного руководства составлены так, чтобы дать в разумном объёме авторитетную,
полную и формальную сводку по соответствующим темам. Дополнительные сведения об использо-
вании PostgreSQL в повествовательной, ознакомительной или показательной форме можно найти в
других частях этой книги. Ссылки на них можно найти на страницах этого руководства.
Все эти справочные статьи также публикуются в виде традиционных страниц «man».Команды SQL
Эта часть документации содержит справочную информацию по командам SQL, поддерживаемым
PostgreSQL. Под «SQL» здесь понимается язык вообще; сведения о соответствии стандартам и сов-
местимости всех команд приведены на соответствующих страниц справочника.
1300ABORT
ABORT — прервать текущую транзакцию
Синтаксис
ABORT [ WORK | TRANSACTION ]
Описание
ABORT откатывает текущую транзакцию и приводит к отмене всех изменений, внесённых транзак-
цией. Эта команда ведёт себя так же, как и стандартная SQL-команда ROLLBACK, и существует
только по историческим причинам.
Параметры
WORK
TRANSACTION
Необязательные ключевые слова, не оказывают никакого влияния.
Замечания
Чтобы завершить и зафиксировать транзакцию, используйте COMMIT.
При выполнении команды ABORT вне блока транзакции выдаётся предупреждение и больше ничего
не происходит.
Примеры
Чтобы прервать все операции:
ABORT;
Совместимость
Эта команда является расширением PostgreSQL и существует по историческим причинам. Ей рав-
нозначна стандартная SQL-команда ROLLBACK.
См. также
BEGIN, COMMIT, ROLLBACK
1301ALTER AGGREGATE
ALTER AGGREGATE — изменить определение агрегатной функции
Синтаксис
ALTER AGGREGATE имя (
ALTER AGGREGATE имя (
OWNER
ALTER AGGREGATE имя (
сигнатура_агр_функции
сигнатура_агр_функции
TO ( новый_владелец |
сигнатура_агр_функции
) RENAME TO новое_имя
)
CURRENT_USER | SESSION_USER )
) SET SCHEMA новая_схема
Здесь сигнатура_агр_функции:</p>
<ul>
  <li>|
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] |
[ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] ] ORDER BY
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ]
Описание
ALTER AGGREGATE изменяет определение агрегатной функции.
Выполнить ALTER AGGREGATE может только владелец соответствующей агрегатной функции. Чтобы
сменить схему агрегатной функции, необходимо также иметь право CREATE в новой схеме. Чтобы
сменить владельца, требуется также быть непосредственным или опосредованным членом новой
роли, а эта роль должна иметь право CREATE в схеме агрегатной функции. (С такими ограничени-
ями при смене владельца не происходит ничего такого, что нельзя было бы сделать, имея право
удалить и вновь создать агрегатную функцию. Однако суперпользователь может сменить владель-
ца агрегатной функции в любом случае.)
Параметры
имя
Имя существующей агрегатной функции (возможно, дополненное схемой).
режим_аргумента
Режим аргумента: IN или VARIADIC. По умолчанию подразумевается IN.
имя_аргумента
Имя аргумента. Заметьте, что на самом деле ALTER AGGREGATE не обращает внимание на имена
аргументов, так как для однозначной идентификации агрегатной функции достаточно только
типов аргументов.
тип_аргумента
Тип входных данных, с которыми работает агрегатная функция. Чтобы сослаться на агрегатную
функцию без аргументов, укажите вместо списка аргументов *, а чтобы сослаться на сортиру-
ющую агрегатную функцию, добавьте ORDER BY между указаниями непосредственных и агре-
гируемых аргументов.
новое_имя
Новое имя агрегатной функции.
новый_владелец
Новый владелец агрегатной функции.
1302ALTER AGGREGATE
новая_схема
Новая схема агрегатной функции.
Замечания
Если вы хотите сослаться на сортирующую агрегатную функцию, рекомендуется добавить ORDER
BY между непосредственными и агрегируемыми аргументами так же, как и в CREATE AGGREGATE.
Однако, команда сработает и без ORDER BY, если непосредственные и агрегирующие аргументы пе-
речислены подряд в одном списке. В такой сокращённой форме, если и в списке непосредственных,
и в списке агрегирующих аргументов содержится VARIADIC “any”, достаточно написать VARIADIC
“any” только один раз.
Примеры
Переименование агрегатной функции myavg для типа integer в my_average:
ALTER AGGREGATE myavg(integer) RENAME TO my_average;
Смена владельца агрегатной функции myavg для типа integer на joe:
ALTER AGGREGATE myavg(integer) OWNER TO joe;
Перемещение сортирующей агрегатной функции mypercentile с непосредственным аргументом
типа float8 и агрегируемым аргументом типа integer в схему myschema:
ALTER AGGREGATE mypercentile(float8 ORDER BY integer) SET SCHEMA myschema;
Это тоже будет работать:
ALTER AGGREGATE mypercentile(float8, integer) SET SCHEMA myschema;
Совместимость
Оператор ALTER AGGREGATE отсутствует в стандарте SQL.
См. также
CREATE AGGREGATE, DROP AGGREGATE
1303ALTER COLLATION
ALTER COLLATION — изменить определение правила сортировки
Синтаксис
ALTER COLLATION имя REFRESH VERSION
ALTER COLLATION имя RENAME TO новое_имя
ALTER COLLATION имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER COLLATION имя SET SCHEMA новая_схема
Описание
ALTER COLLATION изменяет определение правила сортировки.
Выполнить ALTER COLLATION может только владелец соответствующего правила сортировки. Что-
бы сменить владельца, необходимо быть непосредственным или опосредованным членом новой
роли-владельца, а эта роль должна иметь право CREATE в схеме правила сортировки. (С такими
ограничениями при смене владельца не происходит ничего такого, что нельзя было бы сделать,
имея право удалить и вновь создать правило сортировки. Однако суперпользователь может сме-
нить владельца правила сортировки в любом случае.)
Параметры
имя
Имя существующего правила сортировки (возможно, дополненное схемой).
новое_имя
Новое имя правила сортировки.
новый_владелец
Новый владелец правила сортировки.
новая_схема
Новая схема правила сортировки.
REFRESH VERSION
Обновить версию правила сортировки. За подробностями обратитесь к Разделу «Замечания».
Замечания
Когда применяются правила сортировки, предоставляемые библиотекой ICU, внутренняя версия
сортировщика ICU записывается в системный каталог при создании объекта для данного правила.
Когда такое правило используется, текущая версия сверяется с записанной и в случае несовпаде-
ния выдаётся предупреждение, например такое:
WARNING: collation “xx-x-icu” has version mismatch
DETAIL: The collation in the database was created using version 1.2.3.4, but the
operating system provides version 2.3.4.5.
HINT: Rebuild all objects affected by this collation and run ALTER COLLATION
pg_catalog.”xx-x-icu” REFRESH VERSION, or build PostgreSQL with the right library
version.
Изменения в определениях правил сортировки могут приводить к разрушению индексов и дру-
гим проблемам, так как СУБД рассчитывает на то, что хранимые объекты отсортированы в опре-
1304ALTER COLLATION
делённом порядке. Вообще этого следует избегать, но это может иметь место в совершенно ле-
гальных обстоятельствах, например при обновлении с помощью pg_upgrade исполняемых файлов
сервера, скомпонованных с более новой версией ICU. Когда возникает такая ситуация, все объек-
ты, зависящие от данного правила сортировки, должны быть перестроены, например, командой
REINDEX. После этой операции можно обновить версию правила сортировки, выполнив команду
ALTER COLLATION … REFRESH VERSION. При этом системный каталог будет обновлён, в него будет
записана текущая версия сортировщика, и предупреждение уйдёт. Заметьте, что эта команда соб-
ственно не проверяет, были ли все зависимые объекты перестроены корректно.
Следующий запрос позволяет выбрать все правила сортировки в текущей базе данных, которые
требуют обновления, и зависящие от них объекты:
SELECT pg_describe_object(refclassid, refobjid, refobjsubid) AS “Collation”,
pg_describe_object(classid, objid, objsubid) AS “Object”
FROM pg_depend d JOIN pg_collation c
ON refclassid = ‘pg_collation’::regclass AND refobjid = c.oid
WHERE c.collversion &lt;&gt; pg_collation_actual_version(c.oid)
ORDER BY 1, 2;
Примеры
Переименование правила сортировки de_DE в german:
ALTER COLLATION “de_DE” RENAME TO german;
Изменение владельца правила сортировки en_US на joe:
ALTER COLLATION “en_US” OWNER TO joe;
Совместимость
Оператор ALTER COLLATION отсутствует в стандарте SQL.
См. также
CREATE COLLATION, DROP COLLATION
1305ALTER CONVERSION
ALTER CONVERSION — изменить определение перекодировки
Синтаксис
ALTER CONVERSION имя RENAME TO новое_имя
ALTER CONVERSION имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER CONVERSION имя SET SCHEMA новая_схема
Описание
ALTER CONVERSION изменяет определение перекодировки.
Выполнить ALTER CONVERSION может только владелец соответствующей перекодировки. Чтобы сме-
нить владельца, необходимо быть непосредственным или опосредованным членом новой роли-вла-
дельца, а эта роль должна иметь право CREATE в схеме перекодировки. (С такими ограничениями
при смене владельца не происходит ничего такого, что нельзя было бы сделать, имея право уда-
лить и вновь создать перекодировку. Однако суперпользователь может сменить владельца переко-
дировки в любом случае.)
Параметры
имя
Имя существующей перекодировки (возможно, дополненное схемой).
новое_имя
Новое имя перекодировки.
новый_владелец
Новый владелец перекодировки.
новая_схема
Новая схема перекодировки.
Примеры
Переименование перекодировки iso_8859_1_to_utf8 в latin1_to_unicode:
ALTER CONVERSION iso_8859_1_to_utf8 RENAME TO latin1_to_unicode;
Смена владельца перекодировки iso_8859_1_to_utf8 на joe:
ALTER CONVERSION iso_8859_1_to_utf8 OWNER TO joe;
Совместимость
Оператор ALTER CONVERSION отсутствует в стандарте SQL.
См. также
CREATE CONVERSION, DROP CONVERSION
1306ALTER DATABASE
ALTER DATABASE — изменить атрибуты базы данных
Синтаксис
ALTER DATABASE имя [ [ WITH ] параметр [ … ] ]
Здесь параметр:
ALLOW_CONNECTIONS разр_подключения
CONNECTION LIMIT предел_подключений
IS_TEMPLATE это_шаблон
ALTER DATABASE имя RENAME TO новое_имя
ALTER DATABASE имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER DATABASE имя SET TABLESPACE новое_табл_пространство
ALTER
ALTER
ALTER
ALTER
DATABASE
DATABASE
DATABASE
DATABASE
имя
имя
имя
имя
SET параметр_конфигурации ( TO | = ) ( значение | DEFAULT )
SET параметр_конфигурации FROM CURRENT
RESET параметр_конфигурации
RESET ALL
Описание
ALTER DATABASE изменяет атрибуты базы данных.
Первая форма оператора меняет параметры на уровне базы данных. (Подробнее описано ниже.)
Изменять эти параметры может только владелец базы данных или суперпользователь.
Вторая форма меняет имя базы данных. Переименовать базу данных может только владелец БД
или суперпользователь (не суперпользователю требуется также право CREATEDB). Переименовать
текущую базу данных нельзя. (Если вам нужно сделать это, сначала подключитесь к другой базе.)
Третья форма меняет владельца базы данных. Чтобы сменить владельца базы, необходимо быть её
владельцем и также непосредственным или опосредованным членом новой роли-владельца, и кро-
ме того, иметь право CREATEDB. (Заметьте, что суперпользователи наделяются всеми этими права-
ми автоматически.)
Четвёртая форма меняет табличное пространство по умолчанию для базы данных. Произвести это
изменение может только её владелец или суперпользователь; кроме того, необходимо иметь право
для создания нового табличного пространства. Эта команда физически переносит все таблицы или
индексы из прежнего основного табличного пространства БД в новое. Новое табличное простран-
ство должно быть пустым для этой базы данных и к ней никто не должен быть подключён. Таблицы
и индексы, находящиеся не в основном табличном пространстве, при этом не затрагиваются.
Остальные формы меняют значение по умолчанию конфигурационных переменных времени вы-
полнения для базы данных PostgreSQL. Когда устанавливается следующий сеанс работы с ука-
занной базой данных, заданное этой командой значение становится значением по умолчанию.
Значения переменных, заданные для базы данных, переопределяют значения, определённые в
postgresql.conf или полученные через командную строку postgres. Менять сеансовые значения
переменных для базы данных может только её владелец или суперпользователь. Некоторые пара-
метры изменить таким образом нельзя, а некоторые может изменить только суперпользователь.
1307ALTER DATABASE
Параметры
имя
Имя базы данных, атрибуты которой изменяются.
разр_подключения
Если false, никто не сможет подключаться к этой базе данных.
предел_подключений
Число разрешённых одновременно подключений к этой базе данных (-1 снимает ограничение).
это_шаблон
Если true, базу данных сможет клонировать любой пользователь с правами CREATEDB; в против-
ном случае, клонировать эту базу смогут только суперпользователи и её владелец.
новое_имя
Новое имя базы данных.
новый_владелец
Новый владелец базы данных.
новое_табл_пространство
Новое основное табличное пространство базы данных.
Эту форму команды нельзя выполнять внутри блока транзакции.
параметр_конфигурации
значение
Устанавливает сеансовое значение по умолчанию для указанного параметра конфигурации.
Если указывается значение DEFAULT или равнозначный вариант, RESET, определение парамет-
ра на уровне базы данных удаляется, так что в новых сеансах будет действовать значение по
умолчанию, определённое на уровне системы. Для очистки всех значений параметров на уров-
не базы данных выполните RESET ALL. SET FROM CURRENT устанавливает значение параметра на
уровне базы данных из текущего значения в активном сеансе.
За подробными сведениями об именах и значениях параметров обратитесь к SET и Главе 19.
Замечания
Также возможно связать параметры сеанса не с базой данных, а с определённой ролью; см. ALTER
ROLE. В случае конфликта параметры на уровне роли переопределяют параметры на уровне базы
данных.
Примеры
Отключение сканирования индекса по умолчанию в базе данных test:
ALTER DATABASE test SET enable_indexscan TO off;
Совместимость
Оператор ALTER DATABASE является расширением PostgreSQL.
См. также
CREATE DATABASE, DROP DATABASE, SET, CREATE TABLESPACE
1308ALTER DEFAULT PRIVILEGES
ALTER DEFAULT PRIVILEGES — определить права доступа по умолчанию
Синтаксис
ALTER DEFAULT PRIVILEGES
[ FOR ( ROLE | USER ) целевая_роль [, …] ]
[ IN SCHEMA имя_схемы [, …] ]
предложение_GRANT_или_REVOKE
Где предложение_GRANT_или_REVOKE может быть следующим:
GRANT ( ( SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER )
[, …] | ALL [ PRIVILEGES ] )
ON TABLES
TO ( [ GROUP ] имя_роли | PUBLIC ) [, …] [ WITH GRANT OPTION ]
GRANT ( ( USAGE | SELECT | UPDATE )
[, …] | ALL [ PRIVILEGES ] )
ON SEQUENCES
TO ( [ GROUP ] имя_роли | PUBLIC ) [, …] [ WITH GRANT OPTION ]
GRANT ( EXECUTE | ALL [ PRIVILEGES ] )
ON ( FUNCTIONS | ROUTINES )
TO ( [ GROUP ] имя_роли | PUBLIC ) [, …] [ WITH GRANT OPTION ]
GRANT ( USAGE | ALL [ PRIVILEGES ] )
ON TYPES
TO ( [ GROUP ] имя_роли | PUBLIC ) [, …] [ WITH GRANT OPTION ]
GRANT ( USAGE | CREATE | ALL [ PRIVILEGES ] )
ON SCHEMAS
TO ( [ GROUP ] имя_роли | PUBLIC ) [, …] [ WITH GRANT OPTION ]
REVOKE [ GRANT OPTION FOR ]
( ( SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER )
[, …] | ALL [ PRIVILEGES ] )
ON TABLES
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( ( USAGE | SELECT | UPDATE )
[, …] | ALL [ PRIVILEGES ] )
ON SEQUENCES
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( EXECUTE | ALL [ PRIVILEGES ] )
ON ( FUNCTIONS | ROUTINES )
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | ALL [ PRIVILEGES ] )
1309ALTER DEFAULT PRIVILEGES
ON TYPES
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | CREATE | ALL [ PRIVILEGES ] )
ON SCHEMAS
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
Описание
ALTER DEFAULT PRIVILEGES позволяет задавать права, применяемые к объектам, которые будут
создаваться в будущем. (Эта команда не затрагивает права, назначенные уже существующим объ-
ектам.) В настоящее время можно задавать права только для схем, таблиц (включая представле-
ния и сторонние таблицы), последовательностей, функций и типов (включая домены). Примени-
тельно к данной команде функциями считаются также агрегатные функции и процедуры. Слова
FUNCTIONS и ROUTINES для неё считаются равнозначными. (ROUTINES предпочтительнее в перспек-
тиве как стандартный термин, охватывающий и функции, и процедуры. В более ранних выпусках
PostgreSQL допускалось только слово FUNCTIONS. Задать права по умолчанию для функций и про-
цедур по отдельности нельзя.)
Вы можете изменить права по умолчанию только для объектов, которые будут созданы вами или
ролями, членами которых вы являетесь. Права можно задать глобально (т. е. для всех объектов,
создаваемых в текущей базе данных) или для определённых схем. Заданные на уровне схемы права
по умолчанию добавляются к тем, что определены глобально для конкретного типа объекта.
Как объясняется в GRANT, права по умолчанию для объектов любого типа обычно дают все назна-
чаемые разрешения владельцу объекта, а также могут давать некоторые разрешения роли PUBLIC.
Однако это поведение можно поменять, изменив права по умолчанию командой ALTER DEFAULT
PRIVILEGES.
Параметры
целевая_роль
Имя существующей роли, членом которой является текущая. Если FOR ROLE опущено, подра-
зумевается текущая роль.
имя_схемы
Имя существующей схемы. Если указано, права по умолчанию меняются для объектов, которые
будут созданы в этой схеме. Если IN SCHEMA опущено, меняются глобальные права по умолча-
нию. Указание IN SCHEMA не допускается вместе с ON SCHEMAS, так как схемы не могут быть
вложенными.
имя_роли
Имя существующей роли, для которой даются или отзываются права. Этот и все другие пара-
метры в предложении_grant_или_revoke действуют как описано в GRANT или REVOKE, за ис-
ключением того, что они распространяются не на один конкретный объект, а на целый класс
объектов.
Замечания
Чтобы узнать текущие назначенные права по умолчанию, воспользуйтесь командой \ddp в psql.
Интерпретация значений прав приведена в описании команды \dp в GRANT.
Если вы желаете удалить роль, права по умолчанию для которой были изменены, необходимо явно
отменить изменения прав по умолчанию или воспользоваться командой DROP OWNED BY для избав-
ления от назначенных для этой роли прав по умолчанию.
1310ALTER DEFAULT PRIVILEGES
Примеры
Наделение всех правом SELECT для всех таблиц (и представлений), которые будут созданы в даль-
нейшем в схеме myschema, и наделение роли webuser правом INSERT для этих же таблиц:
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT INSERT ON TABLES TO webuser;
Отмена предыдущих изменений с тем, чтобы для таблиц, создаваемых в будущем, были определе-
ны только обычные права, без дополнительных:
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE SELECT ON TABLES FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE INSERT ON TABLES FROM webuser;
Лишение роли public права на выполнение (EXECUTE), которое обычно даётся для функций (для
всех функций, которые будут созданы ролью admin):
ALTER DEFAULT PRIVILEGES FOR ROLE admin REVOKE EXECUTE ON FUNCTIONS FROM PUBLIC;
Совместимость
Оператор ALTER DEFAULT PRIVILEGES отсутствует в стандарте SQL.
См. также
GRANT, REVOKE
1311ALTER DOMAIN
ALTER DOMAIN — изменить определение домена
Синтаксис
ALTER DOMAIN имя
( SET DEFAULT выражение | DROP DEFAULT )
ALTER DOMAIN имя
( SET | DROP ) NOT NULL
ALTER DOMAIN имя
ADD ограничение_домена [ NOT VALID ]
ALTER DOMAIN имя
DROP CONSTRAINT [ IF EXISTS ] имя_ограничения [ RESTRICT | CASCADE ]
ALTER DOMAIN имя
RENAME CONSTRAINT имя_ограничения TO имя_нового_ограничения
ALTER DOMAIN имя
VALIDATE CONSTRAINT имя_ограничения
ALTER DOMAIN имя
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER DOMAIN имя
RENAME TO новое_имя
ALTER DOMAIN имя
SET SCHEMA новая_схема
Описание
ALTER DOMAIN изменяет определение существующего домена. Эта команда имеет несколько раз-
новидностей:
SET/DROP DEFAULT
Эти формы задают/убирают значение по умолчанию для домена. Заметьте, что эти значения
по умолчанию применяются только при последующих командах INSERT; они не меняются в
строках с данным доменом, уже добавленных в таблицу.
SET/DROP NOT NULL
Эти формы определяют, будет ли домен принимать значения NULL или нет. SET NOT NULL
можно выполнить, только если столбцы с этим доменом ещё не содержат значений NULL.
ADD ограничение_домена [ NOT VALID ]
Эта форма добавляет новое ограничение для домена с тем же синтаксисом, что описан в
CREATE DOMAIN. Когда добавляется новое ограничение домена, все столбцы с этим доменом
будут проверены на соответствие этому ограничению. Эти проверки можно подавить, добавив
указание NOT VALID, а затем активировать позднее с помощью команды ALTER DOMAIN …
VALIDATE CONSTRAINT. Вновь вставленные или изменённые строки всегда проверяются по всем
ограничениям, даже тем, что отмечены как NOT VALID. Указание NOT VALID допускается только
для ограничений CHECK.
DROP CONSTRAINT [ IF EXISTS ]
Эта форма убирает ограничения домена. Если указано IF EXISTS и заданное ограничение не
существует, это не считается ошибкой. В этом случае выдаётся только замечание.
RENAME CONSTRAINT
Эта форма меняет название ограничения домена.
1312ALTER DOMAIN
VALIDATE CONSTRAINT
Эта форма включает проверку ограничения, ранее добавленного как NOT VALID, то есть, про-
веряет все данные в столбцах с этим доменом на соответствие этому ограничению.
OWNER
Эта форма меняет владельца домена на заданного пользователя.
RENAME
Эта форма меняет название домена.
SET SCHEMA
Эта форма меняет схему домена. Все ограничения, связанные с данным доменом, так же пере-
носятся в новую схему.
Выполнить ALTER DOMAIN может только владелец соответствующего домена. Чтобы сменить схему
домена, необходимо также иметь право CREATE в новой схеме. Чтобы сменить владельца, необходи-
мо быть непосредственным или опосредованным членом новой роли-владельца, а эта роль должна
иметь право CREATE в схеме домена. (С такими ограничениями при смене владельца не происходит
ничего такого, что нельзя было бы сделать, имея право удалить и вновь создать домен. Однако
суперпользователь может сменить владельца домена в любом случае.)
Параметры
имя
Имя существующего домена (возможно, дополненное схемой), подлежащего изменению.
ограничение_домена
Новое ограничение домена.
имя_ограничения
Имя существующего ограничения, подлежащего удалению или переименованию.
NOT VALID
Не проверять существующие данные в столбцах на соответствие ограничению.
CASCADE
Автоматически удалять объекты, зависящие от данного ограничения, и, в свою очередь, все
зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении ограничения, если существуют зависящие от него объекты. Это поведение
по умолчанию.
новое_имя
Новое имя домена.
имя_нового_ограничения
Новое имя ограничения.
новый_владелец
Имя пользователя, назначаемого новым владельцем домена.
новая_схема
Новая схема домена.
1313ALTER DOMAIN
Замечания
В настоящее время команды ALTER DOMAIN ADD CONSTRAINT, ALTER DOMAIN VALIDATE CONSTRAINT
и ALTER DOMAIN SET NOT NULL выдают ошибку, если указанный домен или любой производный от
него используется в столбце с типом-контейнером (это может быть составной, диапазонный тип
или массив) в какой-либо таблице базы данных. В дальнейшем они будут доработаны, с тем чтобы
новое ограничение проверялось и при такой вложенности.
Примеры
Добавление ограничения NOT NULL к домену:
ALTER DOMAIN zipcode SET NOT NULL;
Удаление ограничения NOT NULL из домена:
ALTER DOMAIN zipcode DROP NOT NULL;
Добавление ограничения-проверки к домену:
ALTER DOMAIN zipcode ADD CONSTRAINT zipchk CHECK (char_length(VALUE) = 5);
Удаление ограничения-проверки из домена:
ALTER DOMAIN zipcode DROP CONSTRAINT zipchk;
Переименование ограничения-проверки в домене:
ALTER DOMAIN zipcode RENAME CONSTRAINT zipchk TO zip_check;
Перемещение домена в другую схему:
ALTER DOMAIN zipcode SET SCHEMA customers;
Совместимость
ALTER DOMAIN соответствует стандарту SQL, за исключением подвидов OWNER, RENAME, SET SCHEMA
и VALIDATE CONSTRAINT, которые являются расширениями PostgreSQL. Предложение NOT VALID
вариации ADD CONSTRAINT также является расширением PostgreSQL.
См. также
CREATE DOMAIN, DROP DOMAIN
1314ALTER EVENT TRIGGER
ALTER EVENT TRIGGER — изменить определение событийного триггера
Синтаксис
ALTER
ALTER
ALTER
ALTER
EVENT
EVENT
EVENT
EVENT
TRIGGER
TRIGGER
TRIGGER
TRIGGER
имя
имя
имя
имя
DISABLE
ENABLE [ REPLICA | ALWAYS ]
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
RENAME TO новое_имя
Описание
ALTER EVENT TRIGGER изменяет свойства существующего событийного триггера.
Для изменения событийного триггера нужно быть суперпользователем.
Параметры
имя
Имя существующего триггера, подлежащего изменению.
новый_владелец
Имя пользователя, назначаемого новым владельцем событийного триггера.
новое_имя
Новое имя событийного триггера.
DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER
Эти формы настраивают срабатывание событийных триггеров. Отключённый триггер сохраня-
ется в системе, но не выполняется, когда происходит его событие срабатывания. См. также
session_replication_role.
Совместимость
Оператор ALTER EVENT TRIGGER отсутствует в стандарте SQL.
См. также
CREATE EVENT TRIGGER, DROP EVENT TRIGGER
1315ALTER EXTENSION
ALTER EXTENSION — изменить определение расширения
Синтаксис
ALTER
ALTER
ALTER
ALTER
EXTENSION
EXTENSION
EXTENSION
EXTENSION
имя
имя
имя
имя
UPDATE [ TO новая_версия ]
SET SCHEMA новая_схема
ADD элемент_объект
DROP элемент_объект
Здесь элемент_объект:
ACCESS METHOD имя_объекта |
AGGREGATE имя_агрегатной_функции ( сигнатура_агр_функции ) |
CAST (исходный_тип AS целевой_тип) |
COLLATION имя_объекта |
CONVERSION имя_объекта |
DOMAIN имя_объекта |
EVENT TRIGGER имя_объекта |
FOREIGN DATA WRAPPER имя_объекта |
FOREIGN TABLE имя_объекта |
FUNCTION имя_функции [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
MATERIALIZED VIEW имя_объекта |
OPERATOR имя_оператора (тип_слева, тип_справа) |
OPERATOR CLASS имя_объекта USING метод_индекса |
OPERATOR FAMILY имя_объекта USING метод_индекса |
[ PROCEDURAL ] LANGUAGE имя_объекта |
PROCEDURE имя_процедуры [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
ROUTINE имя_подпрограммы [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
SCHEMA имя_объекта |
SEQUENCE имя_объекта |
SERVER имя_объекта |
TABLE имя_объекта |
TEXT SEARCH CONFIGURATION имя_объекта |
TEXT SEARCH DICTIONARY имя_объекта |
TEXT SEARCH PARSER имя_объекта |
TEXT SEARCH TEMPLATE имя_объекта |
TRANSFORM FOR имя_типа LANGUAGE имя_языка |
TYPE имя_объекта |
VIEW имя_объекта
и сигнатура_агр_функции:</li>
  <li>|
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] |
[ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] ] ORDER BY
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ]
Описание
ALTER EXTENSION изменяет определение установленного расширения. Эта команда имеет несколь-
ко подвидов:
1316ALTER EXTENSION
UPDATE
Эта форма обновляет версию расширения. Расширение должно предоставлять подходящий
скрипт обновления (или набор скриптов), который может сменить текущую установленную вер-
сию на требуемую.
SET SCHEMA
Эта форма переносит объекты расширения в другую схему. Чтобы эта команда выполнилась
успешно, расширение должно быть перемещаемым.
ADD элемент_объект
Эта форма добавляет существующий объект в расширение. В основном это применяется в
скриптах обновления расширений. Добавленный объект затем будет считаться частью расши-
рения, и удалить его можно будет, только удалив расширение.
DROP элемент_объект
Эта форма удаляет из расширения включённый в него объект. В основном это применяется в
скриптах обновления расширений. Сам объект при этом не уничтожается, а только отделяется
от расширения.
Подробнее эти операции описаны в Разделе 38.16.
Чтобы выполнить команду ALTER EXTENSION, необходимо быть владельцем данного расширения.
Для форм ADD/DROP требуется также быть владельцем добавляемого/удаляемого объекта.
Параметры
имя
Имя установленного расширения.
новая_версия
Запрашиваемая новая версия расширения. Её можно записать в виде идентификатора или стро-
кового значения. Если она не указана, ALTER EXTENSION UPDATE пытается выполнить обновле-
ние до версии, указанной в качестве версии по умолчанию в управляющем файле расширения.
новая_схема
Новая схема расширения.
имя_объекта
имя_агрегатной_функции
имя_функции
имя_оператора
имя_процедуры
имя_подпрограммы
Имя объекта, добавляемого или удаляемого из расширения. Имена таблиц, агрегатных функ-
ций, доменов, сторонних таблиц, функций, операторов, классов операторов, семейств операто-
ров, процедур, подпрограмм, последовательностей, объектов текстового поиска, типов и пред-
ставлений можно дополнить именем схемы.
исходный_тип
Имя исходного типа данных для приведения.
целевой_тип
Имя целевого типа данных для приведения.
1317ALTER EXTENSION
режим_аргумента
Режим аргумента функции, процедуры или агрегата: IN, OUT, INOUT или VARIADIC. По умолча-
нию подразумевается IN. Заметьте, что ALTER EXTENSION не учитывает аргументы OUT, так как
для идентификации функции нужны только типы входных аргументов. Поэтому достаточно пе-
речислить только аргументы IN, INOUT и VARIADIC.
имя_аргумента
Имя аргумента функции, процедуры или агрегата. Заметьте, что на самом деле ALTER EXTENSION
не обращает внимание на имена аргументов, так как для однозначной идентификации функции
достаточно только типов аргументов.
тип_аргумента
Тип данных аргумента функции, процедуры или агрегата.
тип_слева
тип_справа
Тип данных аргументов оператора (возможно, дополненный именем схемы). В случае отсут-
ствия аргумента префиксного или постфиксного оператора укажите вместо типа NONE.
PROCEDURAL
Это слово не несёт смысловой нагрузки.
имя_типа
Имя типа данных, для которого предназначена трансформация.
имя_языка
Имя языка, для которого предназначена трансформация.
Примеры
Обновление расширения hstore до версии 2.0:
ALTER EXTENSION hstore UPDATE TO ‘2.0’;
Смена схемы расширения hstore на utils:
ALTER EXTENSION hstore SET SCHEMA utils;
Добавление существующей функции в расширение hstore:
ALTER EXTENSION hstore ADD FUNCTION populate_record(anyelement, hstore);
Совместимость
Оператор ALTER EXTENSION является расширением PostgreSQL.
См. также
CREATE EXTENSION, DROP EXTENSION
1318ALTER FOREIGN DATA WRAPPER
ALTER FOREIGN DATA WRAPPER — изменить определение обёртки сторонних данных
Синтаксис
ALTER FOREIGN DATA WRAPPER имя
[ HANDLER функция_обработчик | NO HANDLER ]
[ VALIDATOR функция_проверки | NO VALIDATOR ]
[ OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ]) ]
ALTER FOREIGN DATA WRAPPER имя OWNER TO ( новый_владелец | CURRENT_USER |
SESSION_USER )
ALTER FOREIGN DATA WRAPPER имя RENAME TO новое_имя
Описание
ALTER FOREIGN DATA WRAPPER изменяет определение обёртки сторонних данных. Первая форма
команды меняет вспомогательные функции или общие параметры обёртки (требуется минимум
одно предложение), а вторая — владельца обёртки.
Настраивать обёртки сторонних данных могут только суперпользователи и только суперпользова-
тели могут быть их владельцами.
Параметры
имя
Имя существующей обёртки сторонних данных.
HANDLER функция_обработчик
Задаёт новое имя функции-обработчика для обёртки сторонних данных.
NO HANDLER
Эти ключевые слова указывают, что обёртка сторонних данных теперь не имеет функции-об-
работчика.
Заметьте, что обращаться к сторонним таблицам, если их обёртка сторонних данных не имеет
обработчика, нельзя.
VALIDATOR функция_проверки
Задаёт новое имя функции проверки для обёртки сторонних данных.
Заметьте, что возможна ситуация, что предыдущие параметры обёртки данных, зависимых сер-
веров, сопоставлений пользователей или сторонних таблиц окажутся неприемлемыми для но-
вой функции проверки. PostgreSQL не проверяет их, поэтому пользователь сам должен убедить-
ся в правильности этих параметров, прежде чем использовать изменённую обёртку данных.
Однако параметры, изменяемые в данной команде ALTER FOREIGN DATA WRAPPER, будут прове-
рены новой функцией проверки.
NO VALIDATOR
Эти ключевые слова указывают, что обёртка сторонних данных теперь не имеет функции про-
верки.
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ] )
Эта форма настраивает параметры обёртки сторонних данных. ADD, SET и DROP определяют, ка-
кое действие будет выполнено (добавление, установка и удаление, соответственно). Если дей-
1319ALTER FOREIGN DATA WRAPPER
ствие не задано явно, подразумевается ADD. Имена параметров должны быть уникальными, они
вместе со значениями проверяются функцией проверки, если она установлена.
новый_владелец
Имя пользователя, назначаемого новым владельцем обёртки сторонних данных.
новое_имя
Новое имя обёртки сторонних данных.
Примеры
Изменение параметров обёртки сторонних данных dbi: добавление параметра foo, удаление bar:
ALTER FOREIGN DATA WRAPPER dbi OPTIONS (ADD foo ‘1’, DROP ‘bar’);
Установление для обёртки сторонних данных dbi новой функции проверки bob.myvalidator:
ALTER FOREIGN DATA WRAPPER dbi VALIDATOR bob.myvalidator;
Совместимость
ALTER FOREIGN DATA WRAPPER соответствует стандарту ISO/IEC 9075-9 (SQL/MED), за исключением
предложений HANDLER, VALIDATOR, OWNER TO и RENAME, являющихся расширениями.
См. также
CREATE FOREIGN DATA WRAPPER, DROP FOREIGN DATA WRAPPER
1320ALTER FOREIGN TABLE
ALTER FOREIGN TABLE — изменить определение сторонней таблицы
Синтаксис
ALTER FOREIGN TABLE [ IF EXISTS ]
действие [, … ]
ALTER FOREIGN TABLE [ IF EXISTS ]
RENAME [ COLUMN ] имя_столбца
ALTER FOREIGN TABLE [ IF EXISTS ]
RENAME TO новое_имя
ALTER FOREIGN TABLE [ IF EXISTS ]
SET SCHEMA новая_схема
[ ONLY ] имя [ * ]
[ ONLY ] имя [ * ]
TO новое_имя_столбца
имя
имя
Где действие может быть следующим:
ADD [ COLUMN ] имя_столбца тип_данных [ COLLATE правило_сортировки ]
[ ограничение_столбца [ … ] ]
DROP [ COLUMN ] [ IF EXISTS ] имя_столбца [ RESTRICT | CASCADE ]
ALTER [ COLUMN ] имя_столбца [ SET DATA ] TYPE тип_данных
[ COLLATE правило_сортировки ]
ALTER [ COLUMN ] имя_столбца SET DEFAULT выражение
ALTER [ COLUMN ] имя_столбца DROP DEFAULT
ALTER [ COLUMN ] имя_столбца ( SET | DROP ) NOT NULL
ALTER [ COLUMN ] имя_столбца SET STATISTICS integer
ALTER [ COLUMN ] имя_столбца SET ( атрибут = значение [, … ] )
ALTER [ COLUMN ] имя_столбца RESET ( атрибут [, … ] )
ALTER [ COLUMN ] имя_столбца SET STORAGE ( PLAIN | EXTERNAL | EXTENDED | MAIN )
ALTER [ COLUMN ] имя_столбца OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’]
[, … ])
ADD ограничение_таблицы [ NOT VALID ]
VALIDATE CONSTRAINT имя_ограничения
DROP CONSTRAINT [ IF EXISTS ] имя_ограничения [ RESTRICT | CASCADE ]
DISABLE TRIGGER [ имя_триггера | ALL | USER ]
ENABLE TRIGGER [ имя_триггера | ALL | USER ]
ENABLE REPLICA TRIGGER имя_триггера
ENABLE ALWAYS TRIGGER имя_триггера
SET WITH OIDS
SET WITHOUT OIDS
INHERIT таблица_родитель
NO INHERIT таблица_родитель
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ])
Описание
ALTER FOREIGN TABLE меняет определение существующей сторонней таблицы. Эта команда имеет
несколько разновидностей:
ADD COLUMN
Эта форма добавляет в стороннюю таблицу новый столбец, следуя тому же синтаксису, что и
CREATE FOREIGN TABLE. В отличие от добавления столбца в обычную таблицу, при данной
операции в базовом хранилище ничего не меняется; эта команда просто объявляет о доступно-
сти нового столбца через данную стороннюю таблицу.
1321ALTER FOREIGN TABLE
DROP COLUMN [ IF EXISTS ]
Эта форма удаляет столбец из сторонней таблицы. Если что-либо зависит от этого столбца,
например, представление, для успешного результата потребуется добавить CASCADE. Если ука-
зано IF EXISTS и этот столбец не существует, ошибка не происходит, вместо этого выдаётся
замечание.
SET DATA TYPE
Эта форма меняет тип столбца сторонней таблицы. И это не влияет на нижележащее храни-
лище: данная операция просто меняет тип, который по мнению PostgreSQL будет иметь этот
столбец.
SET/DROP DEFAULT
Эти формы задают или удаляют значение по умолчанию для столбцов. Значения по умолчанию
применяются только при последующих командах INSERT или UPDATE; их изменения не отража-
ются в строках, уже существующих в таблице.
SET/DROP NOT NULL
Устанавливает, будет ли столбец принимать значения NULL или нет.
SET STATISTICS
Эта форма задаёт цель сбора статистики по столбцам для последующих операций ANALYZE. За
подробностями обратитесь к описанию подобной формы ALTER TABLE.
SET ( атрибут = значение [, … ] )
RESET ( атрибут [, … ] )
Эта форма задаёт или сбрасывает значения атрибутов. За подробностями обратитесь к описа-
нию подобной формы ALTER TABLE.
SET STORAGE
Эта форма задаёт режим хранения для столбца. За подробностями обратитесь к описанию по-
добной формы ALTER TABLE. Заметьте, что режим хранения не имеет значения, если обёртка
сторонних данных для этой таблицы будет игнорировать его.
ADD ограничение_таблицы [ NOT VALID ]
Эта форма добавляет новое ограничение в стороннюю таблицу с применением того же синтак-
сиса, что и CREATE FOREIGN TABLE. В настоящее время поддерживаются только ограничения
CHECK.
В отличие от ограничения, добавляемого для обычной таблицы, ограничение сторонней таб-
лицы фактически никак не проверяется; эта команда сводится просто к заявлению о том, что
все строки в сторонней таблице предположительно удовлетворяют новому условию. (Подроб-
нее это рассматривается в описании CREATE FOREIGN TABLE.) Если ограничение помечено
как NOT VALID (непроверенное), сервер не будет полагать, что оно выполняется; такая запись
делается только на случай использования в будущем.
VALIDATE CONSTRAINT
Эта форма отмечает ограничение, которая ранее было помечено NOT VALID, как проверенное.
Собственно для проверки этого ограничения ничего не делается, но последующие запросы бу-
дут полагать, что оно действует.
DROP CONSTRAINT [ IF EXISTS ]
Эта форма удаляет указанное ограничение сторонней таблицы. Если указано IF EXISTS и за-
данное ограничение не существует, это не считается ошибкой. В этом случае выдаётся только
замечание.
1322ALTER FOREIGN TABLE
DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER
Эти формы управляют триггерами, принадлежащими сторонней таблице. За подробностями
обратитесь к описанию подобной формы ALTER TABLE.
SET WITH OIDS
Эта форма добавляет в таблицу системный столбец oid (см. Раздел 5.4). Если в таблице уже
есть такой столбец, она не делает ничего. Обёртка сторонних данных должна поддерживать
OID, иначе из этого столбца будут читаться просто нулевые значения.
Заметьте, что это не равнозначно команде ADD COLUMN oid oid (эта команда добавит не систем-
ный, а обычный столбец с подходящим именем oid).
SET WITHOUT OIDS
Эта форма удаляет из таблицы системный столбец oid. Это в точности равнозначно DROP COLUMN
oid RESTRICT, за исключением того, что в случае отсутствия столбца oid ошибки не будет.
INHERIT таблица_родитель
Эта форма делает целевую стороннюю таблицу потомком указанной родительской таблицы. За
подробностями обратитесь к описанию подобной формы ALTER TABLE.
NO INHERIT таблица_родитель
Эта форма удаляет целевую стороннюю таблицу из списка потомков указанной родительской
таблицы.
OWNER
Эта форма меняет владельца сторонней таблицы на заданного пользователя.
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ] )
Эта форма настраивает параметры сторонней таблицы или одного из её столбцов. ADD, SET и
DROP определяют, какое действие будет выполнено (добавление, установка и удаление, соответ-
ственно). Если действие не задано явно, подразумевается ADD. Имена параметров не должны
повторяться (хотя параметр таблицы и параметр столбца вполне могут иметь одно имя). Имена
и значения параметров также проверяются библиотекой обёртки сторонних данных.
RENAME
Формы RENAME меняют имя сторонней таблицы или имя столбца в сторонней таблице.
SET SCHEMA
Эта форма переносит стороннюю таблицу в другую схему.
Все действия, кроме RENAME и SET SCHEMA, можно объединить в один список изменений и выполнить
одновременно. Например, можно добавить несколько столбцов и/или изменить тип столбцов одной
командой.
Если команда записана в виде ALTER FOREIGN TABLE IF EXISTS … и сторонняя таблица не суще-
ствует, это не считается ошибкой. В этом случае выдаётся только замечание.
Выполнить ALTER FOREIGN TABLE может только владелец соответствующей таблицы. Чтобы сменить
схему сторонней таблицы, необходимо также иметь право CREATE в новой схеме. Чтобы сменить
владельца, необходимо быть непосредственным или опосредованным членом новой роли-владель-
ца, а эта роль должна иметь право CREATE в схеме таблицы. (С такими ограничениями при смене
владельца не происходит ничего такого, что нельзя было бы сделать, имея право удалить и вновь
создать таблицу. Однако суперпользователь может сменить владельца таблицы в любом случае.)
Чтобы добавить столбец или изменить тип столбец, ещё требуется иметь право USAGE для его типа
данных.
1323ALTER FOREIGN TABLE
Параметры
имя
Имя (возможно, дополненное схемой) существующей сторонней таблицы, подлежащей изме-
нению. Если перед именем таблицы указано ONLY, изменяется только заданная таблица. Без
ONLY изменяется и заданная таблица, и все её потомки (если таковые есть). После имени табли-
цы можно также добавить необязательное указание *, чтобы явно обозначить, что изменению
подлежат все дочерние таблицы.
имя_столбца
Имя нового или существующего столбца.
новое_имя_столбца
Новое имя существующего столбца.
новое_имя
Новое имя таблицы.
тип_данных
Тип данных нового столбца или новый тип данных существующего столбца.
ограничение_таблицы
Новое ограничение уровня таблицы для сторонней таблицы.
имя_ограничения
Имя существующего ограничения, подлежащего удалению.
CASCADE
Автоматически удалять объекты, зависящие от удаляемого столбца или ограничения (напри-
мер, представления, содержащие этот столбец), и, в свою очередь, все зависящие от них объ-
екты (см. Раздел 5.13).
RESTRICT
Отказать в удалении столбца или ограничения, если существуют зависящие от них объекты.
Это поведение по умолчанию.
имя_триггера
Имя включаемого или отключаемого триггера.
ALL
Отключает или включает все триггеры, принадлежащие сторонней таблице. (Если какие-либо
из триггеров являются внутрисистемными, для этого требуются права суперпользователя. Са-
ма система не добавляет такие триггеры в сторонние таблицы, но дополнительный код может
сделать это.)
USER
Отключает или включает все триггеры, принадлежащие сторонней таблице, кроме сгенериро-
ванных внутрисистемных.
таблица_родитель
Родительская таблица, с которой будет установлена или разорвана связь данной сторонней
таблицы.
1324ALTER FOREIGN TABLE
новый_владелец
Имя пользователя, назначаемого новым владельцем таблицы.
новая_схема
Имя схемы, в которую будет перемещена таблица.
Замечания
Ключевое слово COLUMN не несёт смысловой нагрузки и может быть опущено.
При добавлении или удалении столбцов (ADD COLUMN/DROP COLUMN), добавлении ограничений NOT
NULL или CHECK или изменении типа данных (SET DATA TYPE) согласованность этих определений
с внешним сервером не гарантируется. Ответственность за соответствие определений таблицы
удалённой стороне лежит на пользователе.
За более полным описанием параметров обратитесь к CREATE FOREIGN TABLE.
Примеры
Установление ограничения NOT NULL для столбца:
ALTER FOREIGN TABLE distributors ALTER COLUMN street SET NOT NULL;
Изменение параметров сторонней таблицы:
ALTER FOREIGN TABLE myschema.distributors OPTIONS (ADD opt1 ‘value’, SET opt2 ‘value2’,
DROP opt3 ‘value3’);
Совместимость
Формы ADD, DROP и SET DATA TYPE соответствуют стандарту SQL. Другие формы являются собствен-
ными расширениями PostgreSQL. Кроме того, возможность указать в одной команде ALTER FOREIGN
TABLE несколько операций так же является расширением.
ALTER FOREIGN TABLE DROP COLUMN позволяет удалить единственный столбец сторонней таблицы и
оставить таблицу без столбцов. Это является расширением стандарта SQL, который не допускает
существование сторонних таблиц с нулём столбцов.
См. также
CREATE FOREIGN TABLE, DROP FOREIGN TABLE
1325ALTER FUNCTION
ALTER FUNCTION — изменить определение функции
Синтаксис
ALTER FUNCTION имя [ ( [ [ режим_аргумента ]
[, …] ] ) ]
действие [ … ] [ RESTRICT ]
ALTER FUNCTION имя [ ( [ [ режим_аргумента ]
[, …] ] ) ]
RENAME TO новое_имя
ALTER FUNCTION имя [ ( [ [ режим_аргумента ]
[, …] ] ) ]
OWNER TO ( новый_владелец | CURRENT_USER
ALTER FUNCTION имя [ ( [ [ режим_аргумента ]
[, …] ] ) ]
SET SCHEMA новая_схема
ALTER FUNCTION имя [ ( [ [ режим_аргумента ]
[, …] ] ) ]
DEPENDS ON EXTENSION имя_расширения
[ имя_аргумента ] тип_аргумента
[ имя_аргумента ] тип_аргумента
[ имя_аргумента ] тип_аргумента
| SESSION_USER )
[ имя_аргумента ] тип_аргумента
[ имя_аргумента ] тип_аргумента
Где действие может быть следующим:
CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
PARALLEL ( UNSAFE | RESTRICTED | SAFE )
COST стоимость_выполнения
ROWS строк_в_результате
SET параметр_конфигурации ( TO | = ) ( значение | DEFAULT )
SET параметр_конфигурации FROM CURRENT
RESET параметр_конфигурации
RESET ALL
Описание
ALTER FUNCTION изменяет определение функции.
Выполнить ALTER FUNCTION может только владелец соответствующей функции. Чтобы сменить схе-
му функции, необходимо также иметь право CREATE в новой схеме. Чтобы сменить владельца, тре-
буется также быть непосредственным или опосредованным членом новой роли, а эта роль должна
иметь право CREATE в схеме функции. (С такими ограничениями при смене владельца не проис-
ходит ничего такого, что нельзя было бы сделать, имея право удалить и вновь создать функцию.
Однако суперпользователь может сменить владельца функции в любом случае.)
Параметры
имя
Имя существующей функции (возможно, дополненное схемой). Если список аргументов не ука-
зан, это имя должно быть уникальным в схеме.
режим_аргумента
Режим аргумента: IN, OUT, INOUT или VARIADIC. По умолчанию подразумевается IN. Заметьте,
что ALTER FUNCTION не учитывает аргументы OUT, так как для идентификации функции нужны
только типы входных аргументов. Поэтому достаточно перечислить только аргументы IN, INOUT
и VARIADIC.
1326ALTER FUNCTION
имя_аргумента
Имя аргумента. Заметьте, что на самом деле ALTER FUNCTION не обращает внимание на имена
аргументов, так как для однозначной идентификации функции достаточно только типов аргу-
ментов.
тип_аргумента
Тип данных аргументов функции (возможно, дополненный именем схемы), если таковые име-
ются.
новое_имя
Новое имя функции.
новый_владелец
Новый владелец функции. Заметьте, что если функция помечена как SECURITY DEFINER, в даль-
нейшем она будет выполняться от имени нового владельца.
новая_схема
Новая схема функции.
имя_расширения
Имя расширения, от которого будет зависеть функция.
CALLED ON NULL INPUT
RETURNS NULL ON NULL INPUT
STRICT
CALLED ON NULL INPUT меняет функцию так, чтобы она вызывалась, когда некоторые или все
её аргументы равны NULL. RETURNS NULL ON NULL INPUT или STRICT меняет функцию так,
чтобы она не вызывалась, когда некоторые или все её аргументы равны NULL, а вместо вызова
автоматически выдавался результат NULL. За подробностями обратитесь к CREATE FUNCTION.
IMMUTABLE
STABLE
VOLATILE
Устанавливает заданный вариант изменчивости функции. Подробнее это описано в CREATE
FUNCTION.
[EXTERNAL] SECURITY INVOKER
[EXTERNAL] SECURITY DEFINER
Устанавливает, является ли функция определяющей контекст безопасности. Ключевое слово
EXTERNAL игнорируется для соответствия стандарту SQL. Подробнее это свойство описано в
CREATE FUNCTION.
PARALLEL
Устанавливает, будет ли функция считаться безопасной для распараллеливания. Подробнее
это описано в CREATE FUNCTION.
LEAKPROOF
Устанавливает, является ли функция герметичной. Подробнее это свойство описано в CREATE
FUNCTION.
COST стоимость_выполнения
Изменяет ориентировочную стоимость выполнения функции. Подробнее это описывается в
CREATE FUNCTION.
1327ALTER FUNCTION
ROWS строк_в_результате
Изменяет ориентировочное число строк в результате функции, возвращающей множество. По-
дробнее это описывается в CREATE FUNCTION.
параметр_конфигурации
значение
Добавляет или изменяет установку параметра конфигурации, выполняемую при вызове функ-
ции. Если задано значение DEFAULT или, что равнозначно, выполняется действие RESET, локаль-
ное переопределение для функции удаляется и функция выполняется со значением, установ-
ленным в окружении. Для удаления всех установок параметров для данной функции укажите
RESET ALL. SET FROM CURRENT устанавливает для последующих вызовов функции значение па-
раметра, действующее в момент выполнения ALTER PROCEDURE.
За подробными сведениями об именах и значениях параметров обратитесь к SET и Главе 19.
RESTRICT
Игнорируется для соответствия стандарту SQL.
Примеры
Переименование функции sqrt для типа integer в square_root:
ALTER FUNCTION sqrt(integer) RENAME TO square_root;
Смена владельца функции sqrt для типа integer на joe:
ALTER FUNCTION sqrt(integer) OWNER TO joe;
Смена схемы функции sqrt для типа integer на maths:
ALTER FUNCTION sqrt(integer) SET SCHEMA maths;
Обозначение функции sqrt для типа integer как зависимой от расширения mathlib:
ALTER FUNCTION sqrt(integer) DEPENDS ON EXTENSION mathlib;
Изменение пути поиска, который устанавливается автоматически для функции:
ALTER FUNCTION check_password(text) SET search_path = admin, pg_temp;
Отмена автоматического определения search_path для функции:
ALTER FUNCTION check_password(text) RESET search_path;
Теперь функция будет выполняться с тем путём, который задан в момент вызова.
Совместимость
Этот оператор частично совместим с оператором ALTER FUNCTION в стандарте SQL. Стандарт поз-
воляет менять больше свойств функции, но не позволяет переименовывать функции, переключать
контекст безопасности, связывать с функциями значения параметров конфигурации, а также ме-
нять владельца, схему и тип изменчивости функции. Также в стандарте слово RESTRICT считается
обязательным, тогда как в PostgreSQL оно не требуется.
См. также
CREATE FUNCTION, DROP FUNCTION, ALTER PROCEDURE, ALTER ROUTINE
1328ALTER GROUP
ALTER GROUP — изменить имя роли или членство
Синтаксис
ALTER GROUP указание_роли ADD USER имя_пользователя [, … ]
ALTER GROUP указание_роли DROP USER имя_пользователя [, … ]
Здесь указание_роли:
имя_роли
| CURRENT_USER
| SESSION_USER
ALTER GROUP имя_группы RENAME TO новое_имя
Описание
ALTER GROUP изменяет атрибуты группы пользователей. Эта команда считается устаревшей, хотя
и поддерживается для обратной совместимости, так как группы (и пользователи) были заменены
более общей концепцией ролей.
Первые две формы добавляют пользователей в группу или удаляют их из группы. (В данном слу-
чае в качестве «пользователя» или «группы» может фигурировать любая роль.) По сути они рав-
нозначны командам разрешающим/запрещающим членство в роли «группа»; поэтому вместо них
рекомендуется использовать GRANT и REVOKE.
Третья форма меняет имя группы. Она в точности равнозначна команде ALTER ROLE, выполняю-
щей переименование роли.
Параметры
имя_группы
Имя изменяемой группы (роли).
имя_пользователя
Пользователи (роли), добавляемые или исключаемые из группы. Эти пользователи должны уже
существовать; ALTER GROUP не создаёт и не удаляет пользователей.
новое_имя
Новое имя группы.
Примеры
Добавление пользователей в группу:
ALTER GROUP staff ADD USER karl, john;
Удаление пользователей из группы:
ALTER GROUP workers DROP USER beth;
Совместимость
Оператор ALTER GROUP отсутствует в стандарте SQL.
См. также
GRANT, REVOKE, ALTER ROLE
1329ALTER INDEX
ALTER INDEX — изменить определение индекса
Синтаксис
ALTER INDEX [ IF EXISTS ] имя RENAME TO новое_имя
ALTER INDEX [ IF EXISTS ] имя SET TABLESPACE табл_пространство
ALTER INDEX имя ATTACH PARTITION имя_индекса
ALTER INDEX имя DEPENDS ON EXTENSION имя_расширения
ALTER INDEX [ IF EXISTS ] имя SET ( параметр_хранения = значение [, … ] )
ALTER INDEX [ IF EXISTS ] имя RESET ( параметр_хранения [, … ] )
ALTER INDEX [ IF EXISTS ] имя ALTER [ COLUMN ] номер_столбца
SET STATISTICS целое
ALTER INDEX ALL IN TABLESPACE имя [ OWNED BY имя_роли [, … ] ]
SET TABLESPACE новое_табл_пространство [ NOWAIT ]
Описание
ALTER INDEX меняет определение существующего индекса. Эта команда имеет несколько разно-
видностей:
RENAME
Форма RENAME меняет имя индекса. Если этот индекс связан с ограничением таблицы (UNIQUE,
PRIMARY KEY или EXCLUDE), это ограничение тоже переименовывается. На сохранённые данные
это не влияет.
SET TABLESPACE
Эта форма меняет табличное пространство индекса на заданное и переносит в него файл(ы)
данных, связанные с индексом. Для изменения табличного пространства индекса нужно быть
владельцем индекса и иметь право CREATE в новом табличном пространстве. Форма ALL IN
TABLESPACE позволяет перенести из заданного пространства все индексы в текущей базе дан-
ных, блокируя их для перемещения и затем перемещая каждый индекс. Эта форма также под-
держивает указание OWNED BY, с которым будут перемещены только индексы, принадлежащие
заданным ролям. Если указан параметр NOWAIT, команда завершится ошибкой, если не сможет
немедленно получить все требуемые блокировки. Заметьте, что эта команда не переместит си-
стемные каталоги; вместо неё следует использовать ALTER DATABASE или явные вызовы ALTER
INDEX. См. также CREATE TABLESPACE.
ATTACH PARTITION
Эта форма присоединяет указанный индекс к изменяемому. Указанный индекс должен отно-
ситься к секции таблицы, содержащей изменяемый индекс, и иметь такое же определение.
Присоединённый индекс не может быть удалён независимо, но будет удалён автоматически
при удалении родительского индекса.
DEPENDS ON EXTENSION
Эта форма помечает индекс как зависимый от расширения, так что при удалении расширения
будет автоматически удалён и индекс.
SET ( параметр_хранения = значение [, … ] )
Эта форма настраивает один или несколько специфичных для индекса параметров хранения.
Список доступных параметров приведён в CREATE INDEX. Заметьте, что эта команда не меняет
содержимое индекса немедленно; для получения желаемого эффекта в зависимости от пара-
метров может потребоваться перестроить индекс командой REINDEX.
1330ALTER INDEX
RESET ( параметр_хранения [, … ] )
Эта форма сбрасывает один или несколько специфичных для индекса параметров хранения к
значениям по умолчанию. Как и с SET, для полного обновления индекса может потребоваться
выполнить REINDEX.
ALTER [ COLUMN ] номер_столбца SET STATISTICS целое
Эта форма задаёт ориентир сбора статистики по столбцу для последующих операций ANALYZE,
хотя её можно использовать только для индексируемых столбцов, заданных в виде выражений.
Так как у выражений нет уникальных имён, мы обращаемся к ним по порядковым номерам
столбцов в индексе. Диапазон допустимых значений ориентира: 0..10000; при -1 применяется
системное значение по умолчанию (default_statistics_target). За дополнительными сведениями
об использовании статистики планировщиком запросов PostgreSQL обратитесь к Разделу 14.2.
Параметры
IF EXISTS
Не считать ошибкой, если индекс не существует. В этом случае будет выдано замечание.
номер_столбца
Число, указывающее на номер столбца в индексе по порядку (слева направо).
имя
Имя (возможно, дополненное схемой) существующего индекса, подлежащего изменению.
новое_имя
Новое имя индекса.
табл_пространство
Табличное пространство, в которое будет перемещён индекс.
имя_расширения
Имя расширения, от которого будет зависеть индекс.
параметр_хранения
Имя специфичного для индекса параметра хранения.
значение
Новое значение специфичного для индекса параметра хранения. Это может быть число или
строка, в зависимости от параметра.
Замечания
Эти операции также возможно выполнить с помощью ALTER TABLE. На самом деле ALTER INDEX -
— это просто синоним нескольких форм ALTER TABLE, работающих с индексами.
Ранее существовала форма ALTER INDEX OWNER, но сейчас она игнорируется (с предупреждением).
Владельцем индекса может быть только владелец соответствующей таблицы. При смене владельца
таблицы владелец индекса меняется автоматически.
Какие-либо изменения индексов системного каталога не допускаются.
Примеры
Переименование существующего индекса:
ALTER INDEX distributors RENAME TO suppliers;
1331ALTER INDEX
Перемещение индекса в другое табличное пространство:
ALTER INDEX distributors SET TABLESPACE fasttablespace;
Изменение фактора заполнения индекса (предполагается, что это поддерживает метод индекса):
ALTER INDEX distributors SET (fillfactor = 75);
REINDEX INDEX distributors;
Устанавливает ориентир сбора статистики для индекса по выражению:
CREATE INDEX coord_idx ON measured (x, y, (z + t));
ALTER INDEX coord_idx ALTER COLUMN 3 SET STATISTICS 1000;
Совместимость
ALTER INDEX является расширением PostgreSQL.
См. также
CREATE INDEX, REINDEX
1332ALTER LANGUAGE
ALTER LANGUAGE — изменить определение процедурного языка
Синтаксис
ALTER [ PROCEDURAL ] LANGUAGE имя RENAME TO новое_имя
ALTER [ PROCEDURAL ] LANGUAGE имя OWNER TO ( новый_владелец | CURRENT_USER |
SESSION_USER )
Описание
ALTER LANGUAGE изменяет определение процедурного языка. Единственное, что может это команда
— переименовать язык или назначить нового владельца. Выполнить ALTER LANGUAGE может только
суперпользователь или владелец языка.
Параметры
имя
Имя языка
новое_имя
Новое имя языка
новый_владелец
Новый владелец языка
Совместимость
Оператор ALTER LANGUAGE отсутствует в стандарте SQL.
См. также
CREATE LANGUAGE, DROP LANGUAGE
1333ALTER LARGE OBJECT
ALTER LARGE OBJECT — изменить определение большого объекта
Синтаксис
ALTER LARGE OBJECT oid_большого_объекта OWNER TO ( новый_владелец | CURRENT_USER |
SESSION_USER )
Описание
ALTER LARGE OBJECT изменяет определение большого объекта. Единственное, что может сделать
эта команда — назначить нового владельца. Выполнить ALTER LARGE OBJECT может только супер-
пользователь или владелец большого объекта.
Параметры
oid_большого_объекта
OID изменяемого большого объекта
новый_владелец
Новый владелец большого объекта
Совместимость
Оператор ALTER LARGE OBJECT отсутствует в стандарте SQL.
См. также
Глава 35
1334ALTER MATERIALIZED VIEW
ALTER MATERIALIZED VIEW — изменить определение материализованного представления
Синтаксис
ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
действие [, … ]
ALTER MATERIALIZED VIEW имя
DEPENDS ON EXTENSION имя_расширения
ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
RENAME [ COLUMN ] имя_столбца TO новое_имя_столбца
ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
RENAME TO новое_имя
ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
SET SCHEMA новая_схема
ALTER MATERIALIZED VIEW ALL IN TABLESPACE имя [ OWNED BY имя_роли [, … ] ]
SET TABLESPACE новое_табл_пространство [ NOWAIT ]
Где действие может быть следующим:
ALTER [ COLUMN ] имя_столбца SET STATISTICS integer
ALTER [ COLUMN ] имя_столбца SET ( атрибут = значение [, … ] )
ALTER [ COLUMN ] имя_столбца RESET ( атрибут [, … ] )
ALTER [ COLUMN ] имя_столбца SET STORAGE ( PLAIN | EXTERNAL | EXTENDED | MAIN )
CLUSTER ON имя_индекса
SET WITHOUT CLUSTER
SET ( параметр_хранения = значение [, … ] )
RESET ( параметр_хранения [, … ] )
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
Описание
ALTER MATERIALIZED VIEW изменяет различные расширенные свойства существующего материа-
лизованного представления.
Выполнить ALTER MATERIALIZED VIEW может только владелец материализованного представления.
Чтобы сменить схему материализованного представления, необходимо также иметь право CREATE
в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредо-
ванным членом новой роли, а эта роль должна иметь право CREATE в схеме материализованного
представления. (С такими ограничениями при смене владельца не происходит ничего такого, что
нельзя было бы сделать, имея право удалить и вновь создать материализованное представление.
Однако суперпользователь может сменить владельца материализованного представления в любом
случае.)
Форма DEPENDS ON EXTENSION помечает материализованное представление как зависимое от рас-
ширения, так что матпредставление будет автоматически удаляться при удалении расширения.
Подвиды и действия оператора ALTER MATERIALIZED VIEW являются подмножеством тех, что от-
носятся к команде ALTER TABLE, и имеют то же значение применительно к материализованным
представлениям. За подробностями обратитесь к описанию ALTER TABLE.
Параметры
имя
Имя существующего материализованного представления (возможно, дополненное схемой).
1335ALTER MATERIALIZED VIEW
имя_столбца
Имя нового или существующего столбца.
имя_расширения
Имя расширения, от которого будет зависеть материализованное представление.
новое_имя_столбца
Новое имя существующего столбца.
новый_владелец
Имя пользователя, назначаемого новым владельцем материализованного представления.
новое_имя
Новое имя материализованного представления.
новая_схема
Новая схема материализованного представления.
Примеры
Переименование материализованного представления foo в bar:
ALTER MATERIALIZED VIEW foo RENAME TO bar;
Совместимость
ALTER MATERIALIZED VIEW является расширением PostgreSQL.
См. также
CREATE MATERIALIZED VIEW, DROP MATERIALIZED VIEW, REFRESH MATERIALIZED VIEW
1336ALTER OPERATOR
ALTER OPERATOR — изменить определение оператора
Синтаксис
ALTER OPERATOR имя ( ( тип_слева | NONE ) , ( тип_справа | NONE ) )
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER OPERATOR имя ( ( тип_слева | NONE ) , ( тип_справа | NONE ) )
SET SCHEMA новая_схема
ALTER OPERATOR имя ( ( тип_слева | NONE ) , ( тип_справа | NONE ) )
SET ( ( RESTRICT = ( процедура_ограничения | NONE )
| JOIN = ( процедура_соединения | NONE )
) [, … ] )
Описание
ALTER OPERATOR изменяет определение оператора.
Выполнить ALTER OPERATOR может только владелец соответствующего оператора. Чтобы сменить
владельца, необходимо быть непосредственным или опосредованным членом новой роли-владель-
ца, а эта роль должна иметь право CREATE в схеме оператора. (С такими ограничениями при сме-
не владельца не происходит ничего такого, что нельзя было бы сделать, имея право удалить и
вновь создать оператор. Однако суперпользователь может сменить владельца оператора в любом
случае.)
Параметры
имя
Имя существующего оператора (возможно, дополненное схемой).
тип_слева
Тип данных левого операнда оператора; если у оператора нет левого операнда, укажите NONE.
тип_справа
Тип данных правого операнда оператора; если у оператора нет правого операнда, укажите NONE.
новый_владелец
Новый владелец оператора.
новая_схема
Новая схема оператора.
процедура_ограничения
Функция оценки избирательности ограничения для данного оператора; значение NONE удаля-
ет существующую функцию оценки.
процедура_соединения
Функция оценки избирательности соединения для этого оператора; значение NONE удаляет
существующую функцию оценки.
Примеры
Смена владельца нестандартного оператора a @@ b для типа text:
1337ALTER OPERATOR
ALTER OPERATOR @@ (text, text) OWNER TO joe;
Смена функций оценки избирательности ограничения и соединения для нестандартного операто-
ра a &amp;&amp; b для типа int[]:
ALTER OPERATOR &amp;&amp; (<em>int4, _int4) SET (RESTRICT = _int_contsel, JOIN =
_int_contjoinsel);
Совместимость
Команда ALTER OPERATOR отсутствует в стандарте SQL.
См. также
CREATE OPERATOR, DROP OPERATOR
1338ALTER OPERATOR CLASS
ALTER OPERATOR CLASS — изменить определение класса операторов
Синтаксис
ALTER OPERATOR CLASS имя USING метод_индекса
RENAME TO новое_имя
ALTER OPERATOR CLASS имя USING метод_индекса
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER OPERATOR CLASS имя USING метод_индекса
SET SCHEMA новая_схема
Описание
ALTER OPERATOR CLASS изменяет определение класса операторов.
Выполнить ALTER OPERATOR CLASS может только владелец соответствующего класса операторов.
Чтобы сменить владельца, необходимо быть непосредственным или опосредованным членом но-
вой роли-владельца, а эта роль должна иметь право CREATE в схеме класса операторов. (С такими
ограничениями при смене владельца не происходит ничего такого, что нельзя было бы сделать,
имея право удалить и вновь создать класс операторов. Однако суперпользователь может сменить
владельца классов операторов в любом случае.)
Параметры
имя
Имя существующего класса операторов (возможно, дополненное схемой).
метод_индекса
Имя индексного метода, для которого предназначен этот класс операторов.
новое_имя
Новое имя класса операторов.
новый_владелец
Новый владелец класса операторов.
новая_схема
Новая схема класса операторов.
Совместимость
Команда ALTER OPERATOR CLASS отсутствует в стандарте SQL.
См. также
CREATE OPERATOR CLASS, DROP OPERATOR CLASS, ALTER OPERATOR FAMILY
1339ALTER OPERATOR FAMILY
ALTER OPERATOR FAMILY — изменить определение семейства операторов
Синтаксис
ALTER OPERATOR FAMILY имя USING метод_индекса ADD
( OPERATOR номер_стратегии имя_оператора ( тип_операнда, тип_операнда )
[ FOR SEARCH | FOR ORDER BY семейство_сортировки ]
| FUNCTION номер_опорной_функции [ ( тип_операнда [ , тип_операнда ] ) ]
имя_функции [ ( тип_аргумента [, …] ) ]
) [, … ]
ALTER OPERATOR FAMILY имя USING метод_индекса DROP
( OPERATOR номер_стратегии ( тип_операнда [ , тип_операнда ] )
| FUNCTION номер_опорной_функции ( тип_операнда [ , тип_операнда ] )
) [, … ]
ALTER OPERATOR FAMILY имя USING метод_индекса
RENAME TO новое_имя
ALTER OPERATOR FAMILY имя USING метод_индекса
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER OPERATOR FAMILY имя USING метод_индекса
SET SCHEMA новая_схема
Описание
ALTER OPERATOR FAMILY меняет определение семейства операторов. Она позволяет добавлять в
семейство операторы и опорные функции, удалять их из семейства или менять имя и владельца
семейства операторов.
Когда операторы и опорные функции добавляются в семейство с помощью ALTER OPERATOR FAMILY,
они не становятся частью какого-либо определённого класса операторов в семействе, а просто
считаются «слабосвязанными» с семейством. Это показывает, что эти операторы и функции се-
мантически совместимы с семейством, но не требуются для корректной работы какого-либо ин-
декса. (Операторы и функции, которые действительно требуются для этого, должны быть включе-
ны не в семейство, а в класс операторов; см. CREATE OPERATOR CLASS.) PostgreSQL позволяет
удалять слабосвязанные члены из семейства в любое время, но члены класса операторов не могут
быть удалены, пока не будет удалён весь класс и все зависимые от него индексы. Обычно в классы
операторов включаются операторы и функции, работающие с одним типом данным (так как они
нужны для поддержки индексов данных такого типа), а функции и операторы, работающие с раз-
ными типами, становятся слабосвязанными членами семейства.
Выполнить ALTER OPERATOR FAMILY может только суперпользователь. (Это ограничение введено
потому, что ошибочное определение семейства операторов может вызвать нарушения или даже
сбой в работе сервера.)
ALTER OPERATOR FAMILY в настоящее время не проверяет, включает ли определение семейства
операторов все операторы и функции, требуемые для индексного метода, и образуют ли они це-
лостный набор. Ответственность за правильность определения семейства лежит на пользователе.
За дополнительными сведениями обратитесь к Разделу 38.15.
Параметры
имя
Имя существующего семейства операторов (возможно, дополненное схемой).
1340ALTER OPERATOR FAMILY
метод_индекса
Имя индексного метода, для которого предназначено это семейство операторов.
номер_стратегии
Номер стратегии индексного метода для оператора, связанного с данным семейством опера-
торов.
имя_оператора
Имя (возможно, дополненное схемой) оператора, связанного с данным семейством операторов.
тип_операнда
В предложении OPERATOR указывается тип(ы) данных оператора или NONE, если это левый или
правый унарный оператор. В отличие от похожего синтаксиса в CREATE OPERATOR CLASS, здесь
типы операндов должны указываться всегда.
В предложении ADD FUNCTION это тип данных, который должна поддерживать эта функция,
если он отличается от входного типа данных функции. Для функций сравнения B-деревьев и
хеш-функций указывать тип_операнда необязательно, так как их входные типы данных всегда
будут верными. Однако для функций поддержки сортировки B-деревьев и всех функций в клас-
сах операторов GiST, SP-GiST и GIN необходимо указать тип(ы) операндов, с которыми будут
использоваться эти функции.
В предложении DROP FUNCTION тип операнда, который должна поддерживать эта функция.
семейство_сортировки
Имя (возможно, дополненное схемой) существующего семейства операторов btree, описываю-
щего порядок сортировки, связанный с оператором сортировки.
Если не указано ни FOR SEARCH (для поиска), ни FOR ORDER BY (для сортировки), подразумевается
FOR SEARCH.
номер_опорной_функции
Номер опорной функции индексного метода для функции, связанной с данным семейством опе-
раторов.
имя_функции
Имя (возможно, дополненное схемой) функции, которая является опорной функцией индексно-
го метода для данного семейства операторов. Если список аргументов отсутствует, имя функ-
ции должно быть уникальным в её схеме.
тип_аргумента
Тип данных параметра функции.
новое_имя
Новое имя семейства операторов.
новый_владелец
Новый владелец семейства операторов.
новая_схема
Новая схема семейства операторов.
Предложения OPERATOR и FUNCTION могут указываться в любом порядке.
1341ALTER OPERATOR FAMILY
Замечания
Заметьте, что в синтаксисе DROP указывается только «слот» в семействе операторов, по номеру
стратегии или опорной функции, и входные типы данных. Имя оператора или функции, занимаю-
щих этот слот, не упоминается. Также учтите, что в DROP FUNCTION указываются типы входных
данных, которые должна поддерживать функция, но для индексов GiST, SP-GiST и GIN они могут
не иметь ничего общего с типами фактических аргументов функции.
Так как механизмы индексов не проверяют права доступа к функциям прежде чем вызывать их,
включение функций или операторов в семейство операторов по сути даёт всем право на выполне-
ние их. Обычно это не проблема для таких функций, какие бывают полезны в семействе операто-
ров.
Операторы не должны реализовываться в функциях на языке SQL. SQL-функция вероятнее всего
будет встроена в вызывающий запрос, что помешает оптимизатору понять, что этот запрос соот-
ветствует индексу.
До PostgreSQL 8.4 предложение OPERATOR могло включать указание RECHECK. Теперь это не поддер-
живается, так как оператор индекса может быть «неточным» и это определяется на ходу в момент
выполнения. Это позволяет эффективно справляться с ситуациями, когда оператор может быть
или не быть неточным.
Примеры
Следующий пример добавляет опорные функции и операторы смешанных типов в семейство опе-
раторов, уже содержащее классы операторов B-дерева для типов данных int4 и int2.
ALTER OPERATOR FAMILY integer_ops USING btree ADD
– int4 и int2
OPERATOR 1 &lt; (int4, int2) ,
OPERATOR 2 &lt;= (int4, int2) ,
OPERATOR 3 = (int4, int2) ,
OPERATOR 4 &gt;= (int4, int2) ,
OPERATOR 5 &gt; (int4, int2) ,
FUNCTION 1 btint42cmp(int4, int2) ,
– int2 и int4
OPERATOR 1 &lt; (int2, int4) ,
OPERATOR 2 &lt;= (int2, int4) ,
OPERATOR 3 = (int2, int4) ,
OPERATOR 4 &gt;= (int2, int4) ,
OPERATOR 5 &gt; (int2, int4) ,
FUNCTION 1 btint24cmp(int2, int4) ;
Удаление этих же элементов:
ALTER OPERATOR FAMILY integer_ops USING btree DROP
– int4 vs
OPERATOR 1
OPERATOR 2
OPERATOR 3
OPERATOR 4
OPERATOR 5
FUNCTION 1
int2
(int4,
(int4,
(int4,
(int4,
(int4,
(int4,
int2)
int2)
int2)
int2)
int2)
int2)
,
,
,
,
,
,
– int2 vs int4
OPERATOR 1 (int2, int4) ,
OPERATOR 2 (int2, int4) ,
1342ALTER OPERATOR FAMILY
OPERATOR
OPERATOR
OPERATOR
FUNCTION
3
4
5
1
(int2,
(int2,
(int2,
(int2,
int4)
int4)
int4)
int4)
,
,
,
;
Совместимость
Команда ALTER OPERATOR FAMILY отсутствует в стандарте SQL.
См. также
CREATE OPERATOR FAMILY, DROP OPERATOR FAMILY, CREATE OPERATOR CLASS, ALTER
OPERATOR CLASS, DROP OPERATOR CLASS
1343ALTER POLICY
ALTER POLICY — изменить определение политики защиты на уровне строк
Синтаксис
ALTER POLICY имя ON имя_таблицы RENAME TO новое_имя
ALTER
[
[
[
POLICY имя ON имя_таблицы
TO ( имя_роли | PUBLIC | CURRENT_USER | SESSION_USER ) [, …] ]
USING ( выражение_использования ) ]
WITH CHECK ( выражение_проверки ) ]
Описание
ALTER POLICY изменяет определение существующей политики на уровне строк. Заметьте, что ALTER
POLICY позволяет изменить только набор ролей, для которых применяется политика, и выражения
USING и WITH CHECK. Чтобы изменить другие свойства политики, например команду, к которой она
применяется, а также характеристику разрешительная/ограничительная, политику надо удалить
и создать заново.
Использовать ALTER POLICY может только владелец таблицы (или представления), к которой при-
меняется эта политика.
Во второй форме ALTER POLICY список ролей, выражение_использования и выражение_проверки за-
меняются независимо, если они указаны. Когда одно из этих предложений опущено, соответству-
ющая часть политики остаётся неизменной.
Параметры
имя
Имя существующей политики, подлежащей изменению.
имя_таблицы
Имя таблицы (возможно, дополненное схемой), к которой применяется эта политика.
новое_имя
Новое имя политики.
имя_роли
Роль (роли), на которую действует политика. В одной команде можно указать несколько ролей.
Чтобы применить политику ко всем ролям, укажите PUBLIC.
выражение_использования
Выражение USING для политики. За подробностями обратитесь к CREATE POLICY.
выражение_проверки
Выражение WITH CHECK для политики. За подробностями обратитесь к CREATE POLICY.
Совместимость
ALTER POLICY является расширением PostgreSQL.
См. также
CREATE POLICY, DROP POLICY
1344ALTER PROCEDURE
ALTER PROCEDURE — изменить определение процедуры
Синтаксис
ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
действие [ … ] [ RESTRICT ]
ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
RENAME TO новое_имя
ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
SET SCHEMA новая_схема
ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
DEPENDS ON EXTENSION имя_расширения
] тип_аргумента
] тип_аргумента
] тип_аргумента
] тип_аргумента
] тип_аргумента
Где действие может быть следующим:
[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
SET параметр_конфигурации ( TO | = ) ( значение | DEFAULT )
SET параметр_конфигурации FROM CURRENT
RESET параметр_конфигурации
RESET ALL
Описание
ALTER PROCEDURE изменяет определение процедуры.
Выполнить ALTER PROCEDURE может только владелец процедуры. Чтобы сменить схему процедуры,
необходимо также иметь право CREATE в новой схеме. Чтобы сменить владельца, требуется также
быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право
CREATE в схеме представления. (С таким ограничениями при смене владельца не происходит ни-
чего такого, что нельзя было бы сделать, имея право удалить и вновь создать процедуру. Однако
суперпользователь может сменить владельца процедуры в любом случае.)
Параметры
имя
Имя существующей процедуры (возможно, дополненное схемой). Если список аргументов не
указан, имя процедуры должно быть уникальным в её схеме.
режим_аргумента
Режим аргумента: IN или VARIADIC. По умолчанию подразумевается IN.
имя_аргумента
Имя аргумента. Заметьте, что на самом деле ALTER PROCEDURE не обращает внимание на име-
на аргументов, так как для однозначной идентификации процедуры достаточно только типов
аргументов.
1345ALTER PROCEDURE
тип_аргумента
Тип данных аргументов процедуры (возможно, дополненный именем схемы), если таковые име-
ются.
новое_имя
Новое имя процедуры.
новый_владелец
Новый владелец процедуры. Заметьте, что если процедура помечена как SECURITY DEFINER, в
дальнейшем она будет выполняться от имени нового владельца.
новая_схема
Новая схема процедуры.
имя_расширения
Имя расширения, от которого будет зависеть процедура.
[EXTERNAL] SECURITY INVOKER
[EXTERNAL] SECURITY DEFINER
Устанавливает, является ли процедура определяющей контекст безопасности. Ключевое слово
EXTERNAL игнорируется для соответствия стандарту SQL. Подробнее это свойство описано в
CREATE PROCEDURE.
параметр_конфигурации
значение
Добавляет или изменяет установку параметра конфигурации, выполняемую при вызове про-
цедуры. Если задано значение DEFAULT или, что равнозначно, выполняется действие RESET, ло-
кальное переопределение для процедуры удаляется и процедура выполняется со значением,
установленным в окружении. Для удаления всех установок параметров для данной процедуры
укажите RESET ALL. SET FROM CURRENT устанавливает для последующих вызовов процедуры
значение параметра, действующее в момент выполнения ALTER PROCEDURE.
За подробными сведениями об именах и значениях параметров обратитесь к SET и Главе 19.
RESTRICT
Игнорируется для соответствия стандарту SQL.
Примеры
Переименование процедуры insert_data с двумя аргументами типа integer в insert_record:
ALTER PROCEDURE insert_data(integer, integer) RENAME TO insert_record;
Смена владельца процедуры insert_data с двумя аргументами типа integer на joe:
ALTER PROCEDURE insert_data(integer, integer) OWNER TO joe;
Смена схемы процедуры insert_data с двумя аргументами типа integer на accounting:
ALTER PROCEDURE insert_data(integer, integer) SET SCHEMA accounting;
Обозначение процедуры insert_data(integer, integer) как зависимой от расширения myext:
ALTER PROCEDURE insert_data(integer, integer) DEPENDS ON EXTENSION myext;
Изменение пути поиска, который устанавливается автоматически для процедуры:
ALTER PROCEDURE check_password(text) SET search_path = admin, pg_temp;
1346ALTER PROCEDURE
Отмена автоматического определения search_path для процедуры:
ALTER PROCEDURE check_password(text) RESET search_path;
Теперь процедура будет выполняться с тем путём, который задан в момент вызова.
Совместимость
Этот оператор частично совместим с оператором ALTER PROCEDURE в стандарте SQL. Стандарт поз-
воляет изменить больше свойств процедуры, но не даёт возможности переименовать процедуру,
сделать процедуру определяющей контекст безопасности, связать с процедурой значения пара-
метров конфигурации или изменить владельца, схему или характеристику изменчивости процеду-
ры. Также стандарт требует наличия ключевого слова RESTRICT, но в PostgreSQL оно необязатель-
ное.
См. также
CREATE PROCEDURE, DROP PROCEDURE, ALTER FUNCTION, ALTER ROUTINE
1347ALTER PUBLICATION
ALTER PUBLICATION — изменить определение публикации
Синтаксис
ALTER
ALTER
ALTER
ALTER
ALTER
ALTER
PUBLICATION
PUBLICATION
PUBLICATION
PUBLICATION
PUBLICATION
PUBLICATION
имя
имя
имя
имя
имя
имя
ADD TABLE [ ONLY ] имя_таблицы [ * ] [, …]
SET TABLE [ ONLY ] имя_таблицы [ * ] [, …]
DROP TABLE [ ONLY ] имя_таблицы [ * ] [, …]
SET ( параметр_публикации [= значение] [, … ] )
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
RENAME TO новое_имя
Описание
Команда ALTER PUBLICATION может изменять атрибуты публикации.
Первые три формы управляют вхождением таблиц в публикации. Предложение SET TABLE заменя-
ет список таблиц в публикации заданным. Предложения ADD TABLE и DROP TABLE добавляют и уда-
ляют таблицы в публикации, соответственно. Заметьте, что при добавлении таблиц в публикацию,
на которую уже оформлена подписка, необходимо выполнить ALTER SUBSCRIPTION … REFRESH
PUBLICATION на стороне подписчика, чтобы это изменение вступило в силу.
Четвёртая форма этой команды, показанная в сводке синтаксиса, может изменять все свойства
публикации, заданные в CREATE PUBLICATION. Свойства, которые не упоминаются в этой коман-
де, сохраняют предыдущие значения.
Остальные формы команды меняют владельца и имя публикации.
Для выполнения ALTER PUBLICATION необходимо владеть данной публикацией. Чтобы сменить вла-
дельца, необходимо быть непосредственным или опосредованным членом новой роли-владельца, а
эта роль должна иметь право CREATE в базе данных. Кроме того, новым владельцем публикации FOR
ALL TABLES должен быть суперпользователь. Однако суперпользователь может менять владение
публикацией, обходя эти ограничения.
Параметры
имя
Имя существующей публикации, определение которой изменяется.
имя_таблицы
Имя существующей таблицы. Если перед именем таблицы указано ONLY, затрагивается только
заданная таблица. Без ONLY затрагивается и заданная таблица, и все её потомки (если таковые
есть). После имени таблицы можно добавить необязательное указание *, чтобы явно обозна-
чить, что должны затрагиваться и все дочерние таблицы.
SET ( параметр_публикации [= значение] [, … ] )
Это предложение изменяет параметры публикации, изначально установленные командой
CREATE PUBLICATION. За дополнительными сведениями обратитесь к её описанию.
новый_владелец
Имя пользователя, назначаемого новым владельцем публикации.
новое_имя
Новое имя публикации.
1348ALTER PUBLICATION
Примеры
Изменение публикации, чтобы публиковались только удаления и изменения:
ALTER PUBLICATION noinsert SET (publish = ‘update, delete’);
Добавление таблиц в публикацию:
ALTER PUBLICATION mypublication ADD TABLE users, departments;
Совместимость
ALTER PUBLICATION является расширением PostgreSQL.
См. также
CREATE PUBLICATION, DROP PUBLICATION, CREATE SUBSCRIPTION, ALTER SUBSCRIPTION
1349ALTER ROLE
ALTER ROLE — изменить роль в базе данных
Синтаксис
ALTER ROLE указание_роли [ WITH ] параметр [ … ]
Здесь параметр:
|
|
|
|
|
|
|
|
|
SUPERUSER | NOSUPERUSER
CREATEDB | NOCREATEDB
CREATEROLE | NOCREATEROLE
INHERIT | NOINHERIT
LOGIN | NOLOGIN
REPLICATION | NOREPLICATION
BYPASSRLS | NOBYPASSRLS
CONNECTION LIMIT предел_подключений
[ ENCRYPTED ] PASSWORD ‘пароль’
VALID UNTIL ‘дата_время’
ALTER ROLE имя RENAME TO новое_имя
ALTER
( TO
ALTER
FROM
ALTER
ALTER
ROLE ( указание_роли | ALL
| = ) ( значение | DEFAULT
ROLE ( указание_роли | ALL
CURRENT
ROLE ( указание_роли | ALL
ROLE ( указание_роли | ALL
) [ IN DATABASE имя_бд ] SET параметр_конфигурации
)
) [ IN DATABASE имя_бд ] SET параметр_конфигурации
) [ IN DATABASE имя_бд ] RESET параметр_конфигурации
) [ IN DATABASE имя_бд ] RESET ALL
Здесь указание_роли:
имя_роли
| CURRENT_USER
| SESSION_USER
Описание
ALTER ROLE изменяет атрибуты роли PostgreSQL.
Первая форма команды в этой справке может изменить многие атрибуты роли, которые можно
указать в CREATE ROLE. (Покрываются все возможные атрибуты, отсутствуют только возможности
добавления/удаления членов роли; для этого нужно использовать GRANT и REVOKE.) Атрибуты, не
упомянутые в команде, сохраняют свои предыдущие значения. Суперпользователи базы данных
могут изменить любые параметры любой роли, а пользователи с правом CREATEROLE могут также
менять любые параметры, но только не ролей суперпользователей и репликации. Обычные поль-
зователи (роли) могут менять только свой пароль.
Вторя форма меняет имя роли. Суперпользователи базы данных могут переименовать любую роль,
а пользователи с правом CREATEROLE могут переименовывать роли не суперпользователей. Также
нельзя переименовать роль текущего пользователя в активном сеансе. (Если вам нужно сделать
это, подключитесь другим пользователем.) Так как в паролях с MD5-шифрованием имя роли ис-
пользуется в качестве криптосоли, при переименовании роли её пароль очищается, если он был
зашифрован MD5.
Оставшиеся формы меняют значение по умолчанию конфигурационной переменной, которое бу-
дет распространяться на сеансы роли во всех базах данных, либо, если добавлено предложение
IN DATABASE, только на сеансы роли в заданной базе. Если вместо имени роли указано ALL, это
1350ALTER ROLE
значение переменной распространяется на все роли. Использование ALL с IN DATABASE по сути
равносильно использованию команды ALTER DATABASE … SET ….
Когда эта роль впоследствии установит новое подключение, указанное значение станет значением
по умолчанию в сеансе, переопределяя значение, заданное в postgresql.conf или полученное из
командной строки postgres. Это происходит только в момент входа; при выполнении SET ROLE
или SET SESSION AUTHORIZATION новые значения не применятся. Набор параметров для всех
баз данных переопределяется параметрами уровня БД, установленными для роли. Параметры для
конкретной базы данных или конкретной роли переопределяют параметры для всех ролей.
Суперпользователи могут менять значения переменных по умолчанию для любых ролей, а поль-
зователи с правом CREATEROLE могут менять их только для ролей не суперпользователей. Обычные
пользователи могут определять переменные только для себя. Некоторые переменные конфигура-
ции нельзя задать таким способом, а некоторые может настроить только суперпользователь. Па-
раметры всех ролей во всех базах данных могут настраивать только суперпользователи.
Параметры
имя
Имя роли, атрибуты которой изменяются.
CURRENT_USER
Выбирает для изменения текущего пользователя, а не явно задаваемую роль.
SESSION_USER
Выбирает для изменения текущего пользователя сеанса, а не явно задаваемую роль.
SUPERUSER
NOSUPERUSER
CREATEDB
NOCREATEDB
CREATEROLE
NOCREATEROLE
INHERIT
NOINHERIT
LOGIN
NOLOGIN
REPLICATION
NOREPLICATION
BYPASSRLS
NOBYPASSRLS
CONNECTION LIMIT предел_подключений
[ ENCRYPTED ] PASSWORD пароль
VALID UNTIL ‘дата_время’
Эти предложения меняют атрибуты, изначально установленные командой CREATE ROLE. За
дополнительными сведениями обратитесь к странице справки CREATE ROLE.
новое_имя
Новое имя роли.
имя_бд
Имя базы данных, в которой устанавливается конфигурационная переменная.
параметр_конфигурации
значение
Указанный параметр конфигурации принимает заданное значение по умолчанию в сеансах ро-
ли. Если значение задано как DEFAULT или, что то же самое, применяется операция RESET, пе-
1351ALTER ROLE
реопределение этого параметра для роли удаляется и роль будет получать в новых сеансах
системное значение параметра. Для очистки значений всех параметров, связанных с ролью,
применяется RESET ALL. SET FROM CURRENT сохраняет текущее значение параметра в активном
сеансе в качестве значения для данной роли. Если указано IN DATABASE, параметр конфигура-
ции настраивается или удаляется только для данной роли и указанной базы данных.
Определения переменных для роли применяются только в начале сеанса; команды SET ROLE
и SET SESSION AUTHORIZATION эти определения не обрабатывают.
За подробными сведениями об именах и значениях параметров обратитесь к SET и Главе 19.
Замечания
Для добавления новых ролей используйте команду CREATE ROLE, а для удаления роли — DROP
ROLE.
ALTER ROLE не может управлять членством роли, для этого применяется GRANT и REVOKE.
Указывая в этой команде незашифрованный пароль, следует проявлять осторожность. Пароль бу-
дет передаваться на сервер открытым текстом и может также записаться в историю команд кли-
ента или в протокол работы сервера. В psql есть команда \password, с помощью которой можно
сменить пароль роли, не рискуя рассекретить пароль.
Также возможно связать сеансовые значения по умолчанию с определённой базой данных, а не с
ролью (см. ALTER DATABASE). В случае конфликта параметры для базы данных и роли переопре-
деляют параметры только для роли, которые, в свою очередь, переопределяют параметры для ба-
зы данных.
Примеры
Изменение пароля роли:
ALTER ROLE davide WITH PASSWORD ‘hu8jmn3’;
Удаление пароля роли:
ALTER ROLE davide WITH PASSWORD NULL;
Изменение срока действия пароля (в частности, определяется, что пароль должен перестать дей-
ствовать в полдень 4 мая 2015 г. в часовом поясе UTC+1):
ALTER ROLE chris VALID UNTIL ‘May 4 12:00:00 2015 +1’;
Установка бесконечного срока действия пароля:
ALTER ROLE fred VALID UNTIL ‘infinity’;
Наделение роли правами на создание других ролей и новых баз данных:
ALTER ROLE miriam CREATEROLE CREATEDB;
Определение нестандартного значения параметра maintenance_work_mem для роли:
ALTER ROLE worker_bee SET maintenance_work_mem = 100000;
Определение нестандартного значения параметра client_min_messages для роли и заданной базы:
ALTER ROLE fred IN DATABASE devel SET client_min_messages = DEBUG;
Совместимость
Оператор ALTER ROLE является расширением PostgreSQL.
См. также
CREATE ROLE, DROP ROLE, ALTER DATABASE, SET
1352ALTER ROUTINE
ALTER ROUTINE — изменить определение подпрограммы
Синтаксис
ALTER ROUTINE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
действие [ … ] [ RESTRICT ]
ALTER ROUTINE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
RENAME TO новое_имя
ALTER ROUTINE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER
ALTER ROUTINE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
SET SCHEMA новая_схема
ALTER ROUTINE имя [ ( [ [ режим_аргумента ] [ имя_аргумента
[, …] ] ) ]
DEPENDS ON EXTENSION имя_расширения
] тип_аргумента
] тип_аргумента
] тип_аргумента
)
] тип_аргумента
] тип_аргумента
Где действие может быть следующим:
IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
PARALLEL ( UNSAFE | RESTRICTED | SAFE )
COST стоимость_выполнения
ROWS строк_в_результате
SET параметр_конфигурации ( TO | = ) ( значение | DEFAULT )
SET параметр_конфигурации FROM CURRENT
RESET параметр_конфигурации
RESET ALL
Описание
ALTER ROUTINE изменяет определение подпрограммы, то есть агрегата, функции или процедуры.
Описание параметров, дополнительные примеры и подробности представлены в описаниях ALTER
AGGREGATE, ALTER FUNCTION и ALTER PROCEDURE.
Примеры
Переименование подпрограммы foo для типа integer в foobar:
ALTER ROUTINE foo(integer) RENAME TO foobar;
Эта команда будет работать независимо от того, является ли foo процедурой, агрегатной или обыч-
ной функцией.
Совместимость
Этот оператор частично совместим с оператором ALTER ROUTINE в стандарте SQL. За подробностя-
ми обратитесь к описаниям ALTER FUNCTION и ALTER PROCEDURE. Возможность сослаться по
имени подпрограммы на агрегатную функцию является расширением PostgreSQL.
См. также
ALTER AGGREGATE, ALTER FUNCTION, ALTER PROCEDURE, DROP ROUTINE
Заметьте, что команды CREATE ROUTINE нет.
1353ALTER RULE
ALTER RULE — изменить определение правила
Синтаксис
ALTER RULE имя ON имя_таблицы RENAME TO новое_имя
Описание
ALTER RULE изменяет свойства существующего правила. В настоящее время эта команда может
только изменить имя правила.
Использовать ALTER RULE может только владелец таблицы (или представления), к которой приме-
няется это правило.
Параметры
имя
Имя существующего правила, подлежащего изменению.
имя_таблицы
Имя (возможно, дополненное схемой) существующей таблицы (или представления), к которой
применяется это правило.
новое_имя
Новое имя правила.
Примеры
Переименование существующего правила:
ALTER RULE notify_all ON emp RENAME TO notify_me;
Совместимость
Оператор ALTER RULE является языковым расширением PostgreSQL, как и вся система перезаписи
запросов.
См. также
CREATE RULE, DROP RULE
1354ALTER SCHEMA
ALTER SCHEMA — изменить определение схемы
Синтаксис
ALTER SCHEMA имя RENAME TO новое_имя
ALTER SCHEMA имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
Описание
ALTER SCHEMA изменяет определение схемы.
Выполнить ALTER SCHEMA может только владелец соответствующей схемы. Чтобы переименовать
схему, необходимо также иметь право CREATE в базе данных схемы. Чтобы сменить владельца необ-
ходимо быть непосредственным или опосредованным членом новой роли-владельца и иметь право
CREATE в базе данных. (Суперпользователи наделяются этими правами автоматически.)
Параметры
имя
Имя существующей схемы.
новое_имя
Новое имя схемы. Новое имя не может начинаться с pg</em>, так как такие имена зарезервированы
для системных схем.
новый_владелец
Новый владелец схемы.
Совместимость
Оператор ALTER SCHEMA отсутствует в стандарте SQL.
См. также
CREATE SCHEMA, DROP SCHEMA
1355ALTER SEQUENCE
ALTER SEQUENCE — изменить определение генератора последовательности
Синтаксис
ALTER SEQUENCE [ IF EXISTS ] имя
[ AS тип_данных ]
[ INCREMENT [ BY ] шаг ]
[ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
[ START [ WITH ] начало ]
[ RESTART [ [ WITH ] перезапуск ] ]
[ CACHE кеш ] [ [ NO ] CYCLE ]
[ OWNED BY ( имя_таблицы.имя_столбца | NONE ) ]
ALTER SEQUENCE [ IF EXISTS ] имя OWNER TO ( новый_владелец | CURRENT_USER |
SESSION_USER )
ALTER SEQUENCE [ IF EXISTS ] имя RENAME TO новое_имя
ALTER SEQUENCE [ IF EXISTS ] имя SET SCHEMA новая_схема
Описание
ALTER SEQUENCE меняет параметры существующего генератора последовательности. Параметры,
не определяемые явно в команде ALTER SEQUENCE, сохраняют свои предыдущие значения.
Выполнить ALTER SEQUENCE может только владелец соответствующей последовательности. Чтобы
сменить схему последовательности, необходимо также иметь право CREATE в новой схеме. Чтобы
сменить владельца, необходимо быть непосредственным или опосредованным членом новой ро-
ли-владельца, а эта роль должна иметь право CREATE в схеме последовательности. (С такими огра-
ничениями при смене владельца не происходит ничего такого, что нельзя было бы сделать, имея
право удалить и вновь создать последовательность. Однако суперпользователь может сменить вла-
дельца последовательности в любом случае.)
Параметры
имя
Имя (возможно, дополненное схемой) последовательности, подлежащей изменению.
IF EXISTS
Не считать ошибкой, если последовательность не существует. В этом случае будет выдано за-
мечание.
тип_данных
Необязательное предложение AS тип_данных меняет тип данных для последовательности. До-
пустимые типы: smallint, integer и bigint.
При изменении типа данных автоматически меняются минимальное и максимальное значения
последовательности, в том и только в том случае, если это были минимальные и максимальные
значения старого типа данных (другими словами, если последовательность была создана со
свойствами NO MINVALUE или NO MAXVALUE, неявно или явно). В противном случае минимальные
и максимальные значения сохраняются, если только в этой же команде не указаны новые зна-
чения. Если минимальное/максимальное значение не умещается в новом типе данных, выда-
ётся ошибка.
шаг
Предложение INCREMENT BY шаг является необязательным. При положительном значении шага
генерируется возрастающая последовательность, при отрицательном — убывающая; если шаг
не указан, сохраняется предыдущее значение.
1356ALTER SEQUENCE
мин_значение
NO MINVALUE
Необязательное предложение MINVALUE мин_значение определяет минимальное значение, ко-
торое будет генерировать данная последовательность. Если указано NO MINVALUE, для возраста-
ющей последовательности этим значением будет 1, а для убывающей — минимальное число для
её типа данных. В отсутствие этих указаний будет сохранено текущее минимальное значение.
макс_значение
NO MAXVALUE
Необязательное предложение MAXVALUE макс_значение определяет максимальное значение,
которое будет генерировать данная последовательность. Если указано NO MAXVALUE, для возрас-
тающей последовательности этим значением будет максимальное число для её типа данных,
а для убывающей — -1. В отсутствие этих указаний будет сохранено текущее максимальное
значение.
начало
Необязательное предложение START WITH начало меняет записанное начальное значение по-
следовательности. При этом текущее значение последовательности не меняется, а только
устанавливается значение, которое будет применено будущими командами ALTER SEQUENCE
RESTART.
перезапуск
Необязательное предложение RESTART [ WITH перезапуск ] меняет текущее значение после-
довательности. Оно подобно вызову функции setval с параметром is_called = false: указан-
ное значение перезапуска будет возвращено при следующем вызове функции nextval. Отсут-
ствие в RESTART значения перезапуск равносильно передаче стартового значения, записанного
командой CREATE SEQUENCE или последнего установленного командой ALTER SEQUENCE START
WITH.
В отличие от вызова setval, операция RESTART с последовательностью является транзакцион-
ной и не даёт параллельным транзакциям получать числа из той же последовательности. Если
это поведение не устраивает, следует воспользоваться функцией setval.
кеш
Предложение CACHE кеш разрешает предварительно выделять и сохранять в памяти числа по-
следовательности для ускорения доступа к ним. Минимальное значение равно 1 (т. е. за один
раз генерируется только одно значение, кеширования нет). Если это предложение отсутствует,
сохраняется старое значение размера кеша.
CYCLE
Необязательное ключевое слово CYCLE позволяет зациклить последовательность при достиже-
нии макс_значения или мин_значения для возрастающей и убывающей последовательности, со-
ответственно. Когда этот предел достигается, следующим числом этих последовательностей
будет соответственно мин_значение или макс_значение.
NO CYCLE
Если добавляется необязательное указание NO CYCLE, при каждом вызове nextval после дости-
жения предельного значения будет возникать ошибка. Если же указания CYCLE и NO CYCLE от-
сутствуют, сохраняется предыдущее поведение зацикливания.
OWNED BY имя_таблицы.имя_столбца
OWNED BY NONE
Указание OWNED BY связывает последовательность с определённым столбцом таблицы, с тем
чтобы при удалении этого столбца (или всей таблицы) автоматически удалилась и последова-
1357ALTER SEQUENCE
тельность. Это указание заменяет любую ранее установленную связь данной последователь-
ности. Целевая таблица должна иметь того же владельца и находиться в той же схеме, что и
последовательность. Указание OWNED BY NONE убирает все существующие связи, обозначая по-
следовательность «независимой».
новый_владелец
Имя пользователя, назначаемого новым владельцем последовательности.
новое_имя
Новое имя последовательности.
новая_схема
Новая схема последовательности.
Замечания
ALTER SEQUENCE не оказывает немедленного влияния на результаты nextval в серверных процес-
сах, кроме текущего, которые могли предварительно сгенерировать (кешировать) значения после-
довательности. Эти процессы заметят изменения только после того, как будут израсходованы все
кешированные значения. Текущий серверный процесс реагирует на изменения сразу.
ALTER SEQUENCE не влияет на значение currval последовательности. (В PostgreSQL до версии 8.3
это могло происходить.)
ALTER SEQUENCE блокирует параллельные вызовы nextval, currval, lastval и setval.
По историческим причинам ALTER TABLE тоже может работать с последовательностями, но все
разновидности ALTER TABLE, допустимые для управления последовательностями, равнозначны вы-
шеперечисленным формам.
Примеры
Перезапуск последовательности serial с числа 105:
ALTER SEQUENCE serial RESTART WITH 105;
Совместимость
Оператор ALTER SEQUENCE соответствует стандарту SQL, за исключением предложений AS, START
WITH, OWNED BY, OWNER TO, RENAME TO и SET SCHEMA, являющихся расширениями PostgreSQL.
См. также
CREATE SEQUENCE, DROP SEQUENCE
1358ALTER SERVER
ALTER SERVER — изменить определение стороннего сервера
Синтаксис
ALTER
[
ALTER
ALTER
SERVER имя [ VERSION ‘новая_версия’ ]
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ] ) ]
SERVER имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
SERVER имя RENAME TO новое_имя
Описание
ALTER SERVER изменяет определение стороннего сервера. Первая форма меняет строку версии
сервера или общие параметры сервера (требуется минимум одно предложение). Вторая форма
меняет владельца сервера.
Изменить свойства сервера может только его владелец. Чтобы изменить владельца, необходимо
быть его владельцем, а также непосредственным или опосредованным членом новой роли-владель-
ца, и кроме того, иметь право USAGE для обёртки сторонних данных сервера. (Суперпользователи
удовлетворяют всем этим условиям автоматически.)
Параметры
имя
Имя существующего сервера.
новая_версия
Новая версия сервера.
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ] )
Эти формы изменяют параметры сервера. Указания ADD, SET и DROP определяют выполняемое
действие (добавление, установка и удаление, соответственно). Если действие не задано явно,
подразумевается ADD. Имена параметров должны быть уникальными, они вместе со значениями
также проверяются библиотекой обёртки сторонних данных.
новый_владелец
Имя пользователя, назначаемого новым владельцем стороннего сервера.
новое_имя
Новое имя стороннего сервера.
Примеры
Изменение свойств сервера foo, добавление параметров подключения:
ALTER SERVER foo OPTIONS (host ‘foo’, dbname ‘foodb’);
Изменение свойств сервера foo: смена версии, изменение параметра host:
ALTER SERVER foo VERSION ‘8.4’ OPTIONS (SET host ‘baz’);
Совместимость
ALTER SERVER соответствует стандарту ISO/IEC 9075-9 (SQL/MED). Формы OWNER TO и RENAME явля-
ются расширениями PostgreSQL.
1359ALTER SERVER
См. также
CREATE SERVER, DROP SERVER
1360ALTER STATISTICS
ALTER STATISTICS — изменить определение объекта расширенной статистики
Синтаксис
ALTER STATISTICS имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER STATISTICS имя RENAME TO новое_имя
ALTER STATISTICS имя SET SCHEMA новая_схема
Описание
ALTER STATISTICS меняет параметры существующего объекта расширенной статистики. Парамет-
ры, не определённые явно в команде ALTER STATISTICS, сохраняют свои предыдущие значения.
Выполнить ALTER STATISTICS может только владелец объекта статистики. Чтобы сменить схему
объекта статистики, необходимо также иметь право CREATE в новой схеме. Чтобы сменить владель-
ца, также нужно быть непосредственным или опосредованным членом новой роли-владельца, и
эта роль должна иметь право CREATE в схеме объекта статистики. (С такими ограничениями при
смене владельца не происходит ничего такого, что нельзя было бы сделать, имея право удалить
и вновь создать объект статистики. Однако суперпользователь может сменить владельца объекта
статистики в любом случае.)
Параметры
имя
Имя (возможно, дополненное схемой) объекта статистики, подлежащего изменению.
новый_владелец
Имя пользователя, назначаемого новым владельцем объекта статистики.
новое_имя
Новое имя объекта статистики.
новая_схема
Новая схема объекта статистики.
Совместимость
Оператор ALTER STATISTICS отсутствует в стандарте SQL.
См. также
CREATE STATISTICS, DROP STATISTICS
1361ALTER SUBSCRIPTION
ALTER SUBSCRIPTION — изменить определение подписки
Синтаксис
ALTER SUBSCRIPTION имя CONNECTION ‘строка_подключения’
ALTER SUBSCRIPTION имя SET PUBLICATION имя_публикации [, …] [ WITH
( параметр_set_publication [= значение] [, … ] ) ]
ALTER SUBSCRIPTION имя REFRESH PUBLICATION [ WITH ( параметр_обновления [= значение]
[, … ] ) ]
ALTER SUBSCRIPTION имя ENABLE
ALTER SUBSCRIPTION имя DISABLE
ALTER SUBSCRIPTION имя SET ( параметр_подписки [= значение] [, … ] )
ALTER SUBSCRIPTION имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER SUBSCRIPTION имя RENAME TO новое_имя
Описание
ALTER SUBSCRIPTION может менять многие свойства подписки, которые могут задаваться в CREATE
SUBSCRIPTION.
Чтобы выполнить ALTER SUBSCRIPTION для подписки, нужно быть её владельцем. Чтобы сменить
владельца, нужно быть непосредственным или опосредованным членом новой роли-владельца.
Новый владелец должен быть суперпользователем. (В настоящее время все владельцы подписок
должны быть суперпользователями, так что на практике проверка владельца будет пропущена. Но
в будущем это может быть изменено.)
Параметры
имя
Имя подписки, свойства которой изменяются.
CONNECTION ‘строка_подключения’
Это предложение изменяет строку соединения, изначально установленную командой CREATE
SUBSCRIPTION. За дополнительными сведениями обратитесь к описанию этой команды.
SET PUBLICATION имя_публикации
Изменяет список публикаций, на которые оформлена подписка. За подробностями обратитесь
к описанию CREATE SUBSCRIPTION. По умолчанию эта команда также выполняет действие
REFRESH PUBLICATION.
В указании параметр_set_publication задаются дополнительные свойства операции. Поддер-
живаются следующие параметры:
refresh (boolean)
Со значением false данная команда не будет обновлять информацию о таблицах. В этом
случае следует выполнить REFRESH PUBLICATION отдельно. Значение по умолчанию — true.
Кроме того, здесь могут задаваться параметры обновления, упомянутые в описании REFRESH
PUBLICATION.
REFRESH PUBLICATION
Считывает недостающую информацию о таблицах с публикующего сервера. В результате про-
изводится репликация таблиц, добавленных в публикации, на которые оформлена подписка,
после последнего вызова REFRESH PUBLICATION или CREATE SUBSCRIPTION.
1362ALTER SUBSCRIPTION
В указании параметр_обновления задаются дополнительные свойства операции обновления.
Поддерживаются следующие параметры:
copy_data (boolean)
Определяет, должны ли копироваться существующие данные в публикациях, на которые
оформляется подписка, сразу после начала репликации. Значение по умолчанию — true.
ENABLE
Включает ранее отключённую подписку, запуская процесс логической репликации в конце
транзакции.
DISABLE
Отключает активную подписку, останавливая процесс логической репликации в конце тран-
закции.
SET ( параметр_подписки [= значение] [, … ] )
Это предложение изменяет параметры, изначально установленные командой CREATE
SUBSCRIPTION. За подробностями обратитесь к её описанию. Оно принимает параметры
slot_name и synchronous_commit
новый_владелец
Имя пользователя, назначаемого новым владельцем подписки.
новое_имя
Новое имя подписки.
Примеры
Изменение подписки, заключающееся в подписывании на публикацию insert_only:
ALTER SUBSCRIPTION mysub SET PUBLICATION insert_only;
Отключение (остановка) подписки:
ALTER SUBSCRIPTION mysub DISABLE;
Совместимость
ALTER SUBSCRIPTION является расширением PostgreSQL.
См. также
CREATE SUBSCRIPTION, DROP SUBSCRIPTION, CREATE PUBLICATION, ALTER PUBLICATION
1363ALTER SYSTEM
ALTER SYSTEM — изменить параметр конфигурации сервера
Синтаксис
ALTER SYSTEM SET параметр_конфигурации ( TO | = ) ( значение | ‘значение’ | DEFAULT )
ALTER SYSTEM RESET параметр_конфигурации
ALTER SYSTEM RESET ALL
Описание
Оператор ALTER SYSTEM применяется для изменения параметров конфигурации сервера, распро-
страняющихся на весь кластер баз данных. Пользоваться им может быть удобнее, чем вручную
редактировать файл postgresql.conf. ALTER SYSTEM записывает заданное значение параметра в
файл postgresql.auto.conf, который считывается сервером в дополнение к postgresql.conf. При
указании в качестве значения параметра DEFAULT или применении формы RESET соответствующий
элемент конфигурации удаляется из postgresql.auto.conf. Удалить все настроенные таким спо-
собом параметры позволяет предложение RESET ALL.
Значения, установленные командой ALTER SYSTEM, вступают в силу после следующей переза-
грузки конфигурации сервера либо после перезапуска сервера (если это параметры, восприни-
маемые только при запуске). Перезагрузить конфигурацию сервера можно, вызвав SQL-функцию
pg_reload_conf(), выполнив pg_ctl reload или отправив сигнал SIGHUP главному серверному
процессу.
Выполнить ALTER SYSTEM могут только суперпользователи. А так как эта команда работает непо-
средственно с файловой системой и не может быть отменена, её нельзя поместить в блок транзак-
ции или функцию.
Параметры
параметр_конфигурации
Имя устанавливаемого параметра конфигурации. Список доступных параметров приведён в
Главе 19.
значение
Новое значение параметра. Значениями могут быть строковые константы, идентификато-
ры, числа или списки таких элементов через запятую, в зависимости от конкретного пара-
метра. Если в качестве значения указать DEFAULT, параметр и его значение удаляется из
postgresql.auto.conf.
Замечания
С помощью этой команды нельзя задать data_directory, равно как и другие параметры, недопусти-
мые в postgresql.conf (например, предустановленные параметры).
Другие способы настройки параметров описаны в Разделе 19.1.
Примеры
Установка уровня ведения журнала транзакций (wal_level):
ALTER SYSTEM SET wal_level = replica;
Отмена изменения, восстановление значения, заданного в postgresql.conf:
1364ALTER SYSTEM
ALTER SYSTEM RESET wal_level;
Совместимость
Оператор ALTER SYSTEM является расширением PostgreSQL.
См. также
SET, SHOW
1365ALTER TABLE
ALTER TABLE — изменить определение таблицы
Синтаксис
ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
действие [, … ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
RENAME [ COLUMN ] имя_столбца TO новое_имя_столбца
ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
RENAME CONSTRAINT имя_ограничения TO имя_нового_ограничения
ALTER TABLE [ IF EXISTS ] имя
RENAME TO новое_имя
ALTER TABLE [ IF EXISTS ] имя
SET SCHEMA новая_схема
ALTER TABLE ALL IN TABLESPACE имя [ OWNED BY имя_роли [, … ] ]
SET TABLESPACE новое_табл_пространство [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] имя
ATTACH PARTITION имя_секции ( FOR VALUES указание_границ_секции | DEFAULT )
ALTER TABLE [ IF EXISTS ] имя
DETACH PARTITION имя_секции
Где действие может быть следующим:
ADD [ COLUMN ] [ IF NOT EXISTS ] имя_столбца тип_данных
[ COLLATE правило_сортировки ] [ ограничение_столбца [ … ] ]
DROP [ COLUMN ] [ IF EXISTS ] имя_столбца [ RESTRICT | CASCADE ]
ALTER [ COLUMN ] имя_столбца [ SET DATA ] TYPE тип_данных
[ COLLATE правило_сортировки ] [ USING выражение ]
ALTER [ COLUMN ] имя_столбца SET DEFAULT выражение
ALTER [ COLUMN ] имя_столбца DROP DEFAULT
ALTER [ COLUMN ] имя_столбца ( SET | DROP ) NOT NULL
ALTER [ COLUMN ] имя_столбца ADD GENERATED ( ALWAYS | BY DEFAULT ) AS IDENTITY
[ ( параметры_последовательности ) ]
ALTER [ COLUMN ] имя_столбца ( SET GENERATED ( ALWAYS | BY DEFAULT ) |
SET параметр_последовательности | RESTART [ [ WITH ] перезапуск ] ) […]
ALTER [ COLUMN ] имя_столбца DROP IDENTITY [ IF EXISTS ]
ALTER [ COLUMN ] имя_столбца SET STATISTICS integer
ALTER [ COLUMN ] имя_столбца SET ( атрибут = значение [, … ] )
ALTER [ COLUMN ] имя_столбца RESET ( атрибут [, … ] )
ALTER [ COLUMN ] имя_столбца SET STORAGE ( PLAIN | EXTERNAL | EXTENDED | MAIN )
ADD ограничение_таблицы [ NOT VALID ]
ADD ограничение_таблицы_по_индексу
ALTER CONSTRAINT имя_ограничения [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY
DEFERRED | INITIALLY IMMEDIATE ]
VALIDATE CONSTRAINT имя_ограничения
DROP CONSTRAINT [ IF EXISTS ] имя_ограничения [ RESTRICT | CASCADE ]
DISABLE TRIGGER [ имя_триггера | ALL | USER ]
ENABLE TRIGGER [ имя_триггера | ALL | USER ]
ENABLE REPLICA TRIGGER имя_триггера
ENABLE ALWAYS TRIGGER имя_триггера
DISABLE RULE имя_правила_перезаписи
ENABLE RULE имя_правила_перезаписи
ENABLE REPLICA RULE имя_правила_перезаписи
ENABLE ALWAYS RULE имя_правила_перезаписи
DISABLE ROW LEVEL SECURITY
1366ALTER TABLE
ENABLE ROW LEVEL SECURITY
FORCE ROW LEVEL SECURITY
NO FORCE ROW LEVEL SECURITY
CLUSTER ON имя_индекса
SET WITHOUT CLUSTER
SET WITH OIDS
SET WITHOUT OIDS
SET TABLESPACE новое_табл_пространство
SET ( LOGGED | UNLOGGED )
SET ( параметр_хранения = значение [, … ] )
RESET ( параметр_хранения [, … ] )
INHERIT таблица_родитель
NO INHERIT таблица_родитель
OF имя_типа
NOT OF
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
REPLICA IDENTITY ( DEFAULT | USING INDEX имя_индекса | FULL | NOTHING )
и указание_границ_секции:
IN ( ( числовая_константа | строковая_константа | TRUE | FALSE | NULL ) [, …] ) |
FROM ( ( числовая_константа | строковая_константа | TRUE | FALSE | MINVALUE |
MAXVALUE ) [, …] )
TO ( ( числовая_константа | строковая_константа | TRUE | FALSE | MINVALUE |
MAXVALUE ) [, …] ) |
WITH ( MODULUS числовая_константа, REMAINDER числовая_константа )
и ограничение_столбца:
[ CONSTRAINT имя_ограничения ]
( NOT NULL |
NULL |
CHECK ( выражение ) [ NO INHERIT ] |
DEFAULT выражение_по_умолчанию |
GENERATED ( ALWAYS | BY DEFAULT ) AS IDENTITY [ ( параметры_последовательности ) ] |
UNIQUE параметры_индекса |
PRIMARY KEY параметры_индекса |
REFERENCES целевая_таблица [ ( целевой_столбец ) ] [ MATCH FULL | MATCH PARTIAL |
MATCH SIMPLE ]
[ ON DELETE действие ] [ ON UPDATE действие ] )
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
и ограничение_таблицы:
[ CONSTRAINT имя_ограничения ]
( CHECK ( выражение ) [ NO INHERIT ] |
UNIQUE ( имя_столбца [, … ] ) параметры_индекса |
PRIMARY KEY ( имя_столбца [, … ] ) параметры_индекса |
EXCLUDE [ USING метод_индекса ] ( элемент_исключения WITH оператор
[, … ] ) параметры_индекса [ WHERE ( предикат ) ] |
FOREIGN KEY ( имя_столбца [, … ] ) REFERENCES целевая_таблица [ ( целевой_столбец
[, … ] ) ]
[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE действие ] [ ON
UPDATE действие ] )
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
и ограничение_таблицы_по_индексу:
1367ALTER TABLE
[ CONSTRAINT имя_ограничения ]
( UNIQUE | PRIMARY KEY ) USING INDEX имя_индекса
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
параметры_индекса в ограничениях UNIQUE, PRIMARY KEY и EXCLUDE:
[ INCLUDE ( имя_столбца [, … ] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) ]
[ USING INDEX TABLESPACE табл_пространство ]
элемент_исключения в ограничении EXCLUDE:
( имя_столбца | ( выражение ) ) [ класс_операторов ] [ ASC | DESC ] [ NULLS ( FIRST |
LAST ) ]
Описание
ALTER TABLE меняет определение существующей таблицы. Несколько её разновидностей описаны
ниже. Заметьте, что для разных разновидностей могут требоваться разные уровни блокировок. Ес-
ли явно не отмечено другое, требуется блокировка ACCESS EXCLUSIVE. При перечислении несколь-
ких подкоманд будет запрашиваться самая сильная блокировка из требуемых ими.
ADD COLUMN [ IF NOT EXISTS ]
Эта форма добавляет в таблицу новый столбец, с тем же синтаксисом, что и CREATE TABLE.
Если указано IF NOT EXISTS и столбец с таким именем уже существует, это не будет ошибкой.
DROP COLUMN [ IF EXISTS ]
Эта форма удаляет столбец из таблицы. При этом автоматически будут удалены индексы и
ограничения таблицы, связанные с этим столбцом. Также будет удалена многовариантная ста-
тистика, охватывающая удаляемый столбец, если после его удаления в статистике останутся
данные только одного столбца. Если от этого столбца зависят какие либо объекты вне этой таб-
лицы, например, внешние ключи или представления, чтобы удалить их, необходимо добавить
указание CASCADE. Если в команде указано IF EXISTS и этот столбец не существует, это не счи-
тается ошибкой, вместо этого просто выдаётся замечание.
SET DATA TYPE
Эта форма меняет тип столбца таблицы. Индексы и простые табличные ограничения, включаю-
щие этот столбец, будут автоматически преобразованы для использования нового типа столбца,
для чего будет заново разобрано определяющее их выражение. Необязательное предложение
COLLATE задаёт правило сортировки для нового столбца; если оно опущено, выбирается прави-
ло сортировки по умолчанию для нового типа. Необязательное предложение USING определя-
ет, как новое значение столбца будет получено из старого; если оно отсутствует, выполняет-
ся приведение типа по умолчанию, как обычное присваивание значения старого типа новому.
Предложение USING становится обязательным, если неявное приведение или присваивание с
приведением старого типа к новому не определено.
SET/DROP DEFAULT
Эти формы задают или удаляют значение по умолчанию для столбцов. Значения по умолчанию
применяются только при последующих командах INSERT или UPDATE; их изменения не отража-
ются в строках, уже существующих в таблице.
SET/DROP NOT NULL
Эти формы определяют, будет ли столбец принимать значения NULL или нет. Задать SET NOT
NULL можно, только если столбец не содержит значений NULL.
Если данная таблица является секцией, операцию DROP NOT NULL нельзя выполнить для столбца,
если он определён с характеристикой NOT NULL в родительской таблице. Чтобы удалить огра-
1368ALTER TABLE
ничение NOT NULL из всех секций, выполните DROP NOT NULL для родительской таблицы. Даже
если ограничение NOT NULL в родительской таблице отсутствует, при желании такое ограниче-
ние может быть добавлено в отдельные секции. Другими словами, потомки могут запрещать
значения NULL, даже если родитель их допускает, но не наоборот.
ADD GENERATED ( ALWAYS | BY DEFAULT ) AS IDENTITY
SET GENERATED ( ALWAYS | BY DEFAULT )
DROP IDENTITY [ IF EXISTS ]
Эти формы определяют, является ли столбец столбцом идентификации, и меняют свойства ге-
нерирования значений уже существующего столбца идентификации. За подробностями обра-
титесь к CREATE TABLE.
Если указано DROP IDENTITY IF EXISTS и заданный столбец не является столбцом идентифи-
кации, это не считается ошибкой. В этом случае выдаётся только замечание.
SET параметр_последовательности
RESTART
Эти формы меняют нижележащую последовательность ранее созданного столбца идентифика-
ции. Здесь параметр_последовательности — это параметр, поддерживаемый командой ALTER
SEQUENCE, например INCREMENT BY.
SET STATISTICS
Эта форма задаёт ориентир сбора статистики по столбцу для последующих операций ANALYZE.
Диапазон допустимых значений ориентира: 0..10000; при -1 применяется системное значение
по умолчанию (default_statistics_target). За дополнительными сведениями об использовании
статистики планировщиком запросов PostgreSQL обратитесь к Разделу 14.2.
SET STATISTICS запрашивает блокировку SHARE UPDATE EXCLUSIVE.
SET ( атрибут = значение [, … ] )
RESET ( атрибут [, … ] )
Эта форма устанавливает или сбрасывает параметры атрибутов. В настоящее время един-
ственными параметрами атрибутов являются n_distinct и n_distinct_inherited, которые
переопределяют оценку кол-ва_различных_значений, производимую последующими опера-
циями ANALYZE. Атрибут n_distinct влияет на расчёт статистики по самой таблице, а
n_distinct_inherited — на статистику по таблице и её потомкам. Если заданное значение по-
ложительно, ANALYZE будет считать, что столбец содержит именно это количество различных
значений не NULL. Если заданное значение отрицательно (оно должно быть больше или равно
-1), ANALYZE будет считать, что количество различных значений не NULL в столбце линейно
зависит от размера таблицы; точное число будет получено умножением примерного размера
таблицы на абсолютное значение параметра. Например, при -1 будет предполагаться, что раз-
личны все значения в столбце, а при -0,5 — что в среднем каждое значение повторяется два-
жды. Это может быть полезно, когда размер таблицы меняется со временем, так как умноже-
ние на число строк в таблице производится только во время планирования запроса. С 0 коли-
чество различных значений оценивается как обычно. За дополнительными сведениями об ис-
пользовании статистики планировщиком запросов PostgreSQL обратитесь к Разделу 14.2.
Для изменения параметров атрибутов запрашивается блокировка SHARE UPDATE EXCLUSIVE.
SET STORAGE
Эта форма устанавливает режим хранения столбца. Она определяет, хранятся ли данные внут-
ри таблицы или в отдельной таблице TOAST, а также, сжимаются ли они. Режим PLAIN дол-
жен применяться для значений фиксированной длины, таких как integer; это вариант хране-
ния внутри, без сжатия. Режим MAIN применяется для хранения внутри, но сжатых данных,
EXTERNAL — для внешнего хранения несжатых данных, а EXTENDED — для внешнего хранения
1369ALTER TABLE
сжатых данных. EXTENDED используется по умолчанию для большинства типов данных, поддер-
живающих хранилище не PLAIN. Применение EXTERNAL позволяет ускорить операции с подстро-
ками на очень больших значениях text и bytea, за счёт проигрыша в объёме хранилища. За-
метьте, что предложение SET STORAGE само по себе не меняет ничего в таблице, оно только
задаёт стратегию, которая будет реализована при будущих изменениях в таблице. За дополни-
тельными сведениями обратитесь к Разделу 68.2.
ADD ограничение_таблицы [ NOT VALID ]
Эта форма добавляет в таблицу новое ограничение, с тем же синтаксисом, что и CREATE TABLE,
и дополнительным указанием NOT VALID, которое в настоящее время разрешено только для
ограничений внешнего ключа и ограничений-проверок. Если ограничение помечено как NOT
VALID, потенциально длительная начальная проверка того, что ему удовлетворяют все строки,
пропускается. Тем не менее это ограничение будет действовать при последующих добавлениях
или изменениях (то есть, эти операции не будут выполнены, если, в случае с внешним ключом,
в главной таблице не найдётся соответствующая строка, либо, в случае с ограничением-про-
веркой, новая строка нарушит проверочное условие). Но база данных не будет считать, что
ограничение выполняется для всех строк таблицы, пока оно не будет проверено с применением
указания VALIDATE CONSTRAINT. Ограничения внешнего ключа для секционированных таблиц
в настоящее время не могут помечаться как NOT VALID.
Для добавления ограничения внешнего ключа требуется блокировка SHARE ROW EXCLUSIVE в
целевой таблице.
С ограничениями уникальности и первичного ключа, добавляемыми в секционированные таб-
лицы, связаны дополнительные требования; см. CREATE TABLE.
ADD ограничение_таблицы_по_индексу
Эта форма добавляет в таблицу новое ограничение PRIMARY KEY или UNIQUE на базе существу-
ющего уникального индекса. В это ограничение будут включены все столбцы данного индекса.
Индекс не может быть частичным и включать столбцы-выражения. Кроме того, это должен
быть индекс-B-дерево с порядком сортировки по умолчанию. С такими ограничениями добав-
ляемые индексы не будут ничем отличаться от индексов, создаваемых обычными командами
ADD PRIMARY KEY и ADD UNIQUE.
В случае с указанием PRIMARY KEY, если столбцы индекса ещё не помечены NOT NULL, данная
команда попытается выполнить ALTER COLUMN SET NOT NULL для каждого столбца. При этом
потребуется произвести полное сканирование таблицы, чтобы убедиться, что столбец(ы) не
содержит NULL. Во всех остальных случаях это быстрая операция.
Если задано имя ограничения, индекс будет переименован и получит заданное имя. В против-
ном случае, именем ограничения станет имя индекса.
После выполнения этой команды индекс становится «принадлежащим» ограничению, так же,
как если бы он был создан обычной командой ADD PRIMARY KEY или ADD UNIQUE. Это значит, в
частности, что при удалении ограничения индекс будет удалён вместе с ним.
Эта форма с секционированными таблицами в настоящее время не поддерживается.
Примечание
Добавление ограничения на базе существующего индекса бывает полезно в ситуа-
циях, когда новое ограничение требуется добавить, не блокируя изменения в таб-
лице на долгое время. Для этого можно создать индекс командой CREATE INDEX
CONCURRENTLY, а затем задействовать его как полноценное ограничение, используя
эту запись. См. следующий пример.
1370ALTER TABLE
ALTER CONSTRAINT
Эта форма меняет атрибуты созданного ранее ограничения. В настоящее время изменять мож-
но только ограничения внешнего ключа.
VALIDATE CONSTRAINT
Эта форма проверяет ограничение внешнего ключа или ограничение-проверку, созданное ра-
нее с указанием NOT VALID, сканируя всю таблицу с целью убедиться, что ограничению удовле-
творяют все строки. Если ограничение уже помечено как верное, ничего не происходит.
Проверка больших таблиц может быть довольно длительной. Смысл отделения проверки от
собственно создания ограничения состоит в том, что это позволяет отложить проверку на время
меньшей активности или провести дополнительную работу с существующими ошибками и при
этом не допустить новых. Заметьте также, что во время осуществления проверки сама по себе
она не препятствует выполнению обычных команд записи в таблицу.
При проверке запрашивается только блокировка SHARE UPDATE EXCLUSIVE целевой таблицы.
Для ограничений внешнего ключа требуется также блокировка ROW SHARE в таблице, на кото-
рую ссылается ограничение.
DROP CONSTRAINT [ IF EXISTS ]
Эта форма удаляет указанное ограничение таблицы, вместе с нижележащим индексом, если
таковой имеется. Если указано IF EXISTS и заданное ограничение не существует, это не счи-
тается ошибкой. В этом случае выдаётся только замечание.
DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER
Эти формы настраивают срабатывание триггера(ов), принадлежащего таблице. Отключённый
триггер сохраняется в системе, но не выполняется, когда происходит вызывающее его собы-
тие. Для отложенных триггеров состояние включения проверяется при возникновении собы-
тия, а не когда фактически вызывается функция триггера. Эта команда может отключить или
включить один триггер по имени, либо все триггеры таблицы, либо только пользовательские
триггеры (кроме сгенерированных внутрисистемных триггеров ограничений, например, триг-
геров, реализующих ограничения внешнего ключа или отложенные ограничения уникально-
сти и ограничения-исключения). Для отключения или включения сгенерированных внутриси-
стемных триггеров ограничений требуются права суперпользователя; отключать их следует с
осторожностью, так как очевидно, что невозможно гарантировать целостность ограничений,
если триггеры не работают.
На механизм срабатывания триггеров также влияет конфигурационная переменная
session_replication_role. Включённые без дополнительных указаний (по умолчанию) триггеры
будут срабатывать, когда роль репликации — «origin» (по умолчанию) или «local». Триггеры,
включённые указанием ENABLE REPLICA, будут срабатывать, только если текущий режим сеанса
— «replica», а триггеры, включённые указанием ENABLE ALWAYS, будут срабатывать независимо
от текущего режима репликации.
Эффект этого механизма состоит в том, что в конфигурации по умолчанию триггеры не сраба-
тывают в репликах. Это полезно, потому что если триггер используется в исходной базе для
распределения данных по таблицам, система репликации будет реплицировать и распределён-
ные таким образом данные, поэтому триггер не должен срабатывать в реплике второй раз, так
как иначе будет иметь место дублирование. Однако, если триггер используется для других це-
лей, например, выдаёт уведомления, может иметь смысл установить для него свойство ENABLE
ALWAYS, чтобы он также срабатывал в репликах.
Эта команда запрашивает блокировку SHARE ROW EXCLUSIVE.
DISABLE/ENABLE [ REPLICA | ALWAYS ] RULE
Эти формы настраивают срабатывание правил перезаписи, относящихся к таблице. Отключён-
ное правило сохраняется в системе, но не применяется во время переписывания запроса. По
1371ALTER TABLE
сути эти операции подобны операциям включения/отключения триггеров. Однако это не рас-
пространяется на правила ON SELECT — они применяются всегда, чтобы представления продол-
жали работать, даже в сеансах, исполняющих не основную роль репликации.
На механизм срабатывания правил также оказывает влияние конфигурационная переменная
session_replication_role, подобное тому, что описано выше применительно к триггерам.
DISABLE/ENABLE ROW LEVEL SECURITY
Эти формы управляют применением относящихся к таблице политик защиты строк. Если за-
щита включается, но политики для таблицы не определены, применяется политика запрета
доступа по умолчанию. Заметьте, что политики могут быть определены для таблицы, даже если
защита на уровне строк отключена — в этом случае политики НЕ применяются и их ограниче-
ния игнорируются. См. также CREATE POLICY.
NO FORCE/FORCE ROW LEVEL SECURITY
Эти формы управляют применением относящихся к таблице политик защиты строк, когда поль-
зователь является её владельцем. Если это поведение включается, политики защиты на уровне
строк будут действовать и на владельца таблицы. Если оно отключено (по умолчанию), защита
на уровне строк не будет действовать на пользователя, являющегося владельцем таблицы. См.
также CREATE POLICY.
CLUSTER ON
Эта форма выбирает индекс по умолчанию для последующих операций CLUSTER. Собственно
кластеризация таблицы при этом не выполняется.
Для изменения параметров кластеризации запрашивается блокировка SHARE
EXCLUSIVE.
UPDATE
SET WITHOUT CLUSTER
Эта форма удаляет последнее заданное указание индекса для CLUSTER. Её действие отразится
на будущих операциях кластеризации, для которых не будет задан индекс.
Для изменения параметров кластеризации запрашивается блокировка SHARE
EXCLUSIVE.
UPDATE
SET WITH OIDS
Эта форма добавляет в таблицу системный столбец oid (см. Раздел 5.4). Если в таблице уже
есть такой столбец, она не делает ничего.
Заметьте, что это не равнозначно команде ADD COLUMN oid oid (эта команда добавит не систем-
ный, а обычный столбец с подходящим именем oid).
SET WITHOUT OIDS
Эта форма удаляет из таблицы системный столбец oid. Это в точности равнозначно DROP COLUMN
oid RESTRICT, за исключением того, что в случае отсутствия столбца oid ошибки не будет.
SET TABLESPACE
Эта форма меняет табличное пространство таблицы на заданное и перемещает файлы данных,
связанные с таблицей, в новое пространство. Индексы таблицы, если они имеются, не переме-
щаются; однако их можно переместить отдельно дополнительными командами SET TABLESPACE.
Форма ALL IN TABLESPACE позволяет перенести в другое табличное пространство все таблицы
текущей базы данных, при этом она сначала блокирует все таблицы, а затем переносит каждую
из них. Эта форма также поддерживает указание OWNED BY, с которым перемещаются только
таблицы указанного владельца. Если указан параметр NOWAIT, команда завершится ошибкой,
если не сможет получить все требуемые блокировки немедленно. Заметьте, что системные ка-
1372ALTER TABLE
талоги эта форма не перемещает; если требуется переместить их, следует использовать ALTER
DATABASE или явные вызовы ALTER TABLE. Отношения information_schema не считаются частью
системных каталогов и подлежат перемещению. См. также CREATE TABLESPACE.
SET ( LOGGED | UNLOGGED )
Эта форма меняет характеристику журналирования таблицы, делает таблицу журналируе-
мой/нежурналируемой, соответственно (см. UNLOGGED). К временной таблице она неприменима.
SET ( параметр_хранения = значение [, … ] )
Эта форма меняет один или несколько параметров хранения таблицы. Подробнее допустимые
параметры описаны в Подразделе «Параметры хранения». Заметьте, что эта команда не меня-
ет содержимое таблицы немедленно; в зависимости от параметра может потребоваться пере-
записать таблицы, чтобы получить желаемый эффект. Это можно сделать с помощью команд
VACUUM FULL, CLUSTER или одной из форм ALTER TABLE, принудительно перезаписывающих
таблицу. Изменения параметров, связанных с планировщиком, вступают в силу при следующей
блокировке таблицы, так что в текущих запросах они не проявляются.
Данная форма затребует блокировку SHARE UPDATE EXCLUSIVE для изменения парамет-
ров хранения, связанных с фактором заполнения, TOAST и автоочисткой, а также следую-
щих параметров, связанных с планировщиком: effective_io_concurrency, parallel_workers,
seq_page_cost, random_page_cost, n_distinct и n_distinct_inherited.
Примечание
Хотя CREATE TABLE позволяет указать OIDS в синтаксисе WITH (параметр_хранения),
ALTER TABLE не воспринимает OIDS как параметр хранения. Поэтому для изменения
характеристики OID следует применять формы SET WITH OIDS и SET WITHOUT OIDS.
RESET ( параметр_хранения [, … ] )
Эта форма сбрасывает один или несколько параметров хранения к значениям по умолчанию.
Как и с SET, для полного обновления таблицы может потребоваться перезаписать таблицу.
INHERIT таблица_родитель
Эта форма назначает целевую таблицу потомком заданной родительской таблицы. Впослед-
ствии запросы к родительской таблице будут включать записи и целевой таблицы. Чтобы таб-
лица могла стать потомком, она должна содержать те же столбцы, что и родительская (хотя она
может включать и дополнительные столбцы). Столбцы должны иметь одинаковые типы данных
и, если в родительской таблице какие-то из них имеют ограничение NOT NULL, они должны
иметь ограничение NOT NULL и в таблице-потомке.
Также в таблице-потомке должны присутствовать все ограничения CHECK родительской таб-
лицы, за исключением ненаследуемых (то есть созданных командой ALTER TABLE … ADD
CONSTRAINT … NO INHERIT), которые игнорируются; при этом все соответствующие ограни-
чения в таблице-потомке не должны быть ненаследуемыми. В настоящее время ограничения
UNIQUE, PRIMARY KEY и FOREIGN KEY не учитываются, но в будущем это может измениться.
NO INHERIT таблица_родитель
Эта форма удаляет целевую таблицу из списка потомков указанной родительской таблицы. Ре-
зультаты запросов к родительской таблице после этого не будут включать записи, взятые из
целевой таблицы.
OF имя_типа
Эта форма связывает таблицу с составным типом, как если бы она была сформирована коман-
дой CREATE TABLE OF. При этом список имён и типов столбцов должен точно соответствовать
1373ALTER TABLE
тому, что образует составной тип; отличие возможно в системном столбце oid. Кроме того,
таблица не должна быть потомком какой-либо другой таблицы. Эти ограничения — залог того,
что команда CREATE TABLE OF позволит создать таблицу с таким же определением.
NOT OF
Эта форма разрывает связь типизированной таблицы с её типом.
OWNER TO
Эта форма меняет владельца таблицы, последовательности, представления, материализован-
ного представления или сторонней таблицы на заданного пользователя.
REPLICA IDENTITY
Эта форма меняет информацию, записываемую в журнал предзаписи для идентификации из-
меняемых или удаляемых строк. Данный параметр действует только при использовании логи-
ческой репликации. В режиме DEFAULT (по умолчанию для не системных таблиц) записывается
старые значения столбцов первичного ключа, если он есть. В режиме USING INDEX записыва-
ются старые значения столбцов, составляющих заданный индекс, который должен быть уни-
кальным, не частичным, не отложенным и включать только столбцы, помеченные NOT NULL.
В режиме FULL записываются старые значения всех столбцов в строке, а в режиме NOTHING
(по умолчанию для системных таблиц) никакая информация о старой строке не записывается.
Во всех случаях старые значения записываются в журнал, только если как минимум в одном
столбце из тех, что должны быть записаны, произошли изменения в новой строке.
RENAME
Формы RENAME меняют имя таблицы (или индекса, последовательности, представления, мате-
риализованного представления или сторонней таблицы), имя отдельного столбца таблицы или
имя ограничения таблицы. При переименовании ограничения, у которого имеется нижележа-
щий индекс, этот индекс также переименовывается. На хранимые данные это не влияет.
SET SCHEMA
Эта форма перемещает таблицу в другую схему. Вместе с таблицей перемещаются связанные с
ней индексы и ограничения, а также последовательности, принадлежащие столбцам таблицы.
ATTACH PARTITION имя_секции ( FOR VALUES указание_границ_секции | DEFAULT )
Эта форма присоединяет существующую таблицу (которая тоже может быть секционирован-
ной) в качестве секции к целевой таблице. С указанием FOR VALUES таблица станет секцией для
определённых значений, а с указанием DEFAULT — секцией по умолчанию. Для каждого индек-
са в целевой таблице будет создан соответствующий индекс в присоединяемой таблице; или,
если равнозначный индекс уже существует, он будет присоединён к индексу целевой таблицы,
как при выполнении команды ALTER INDEX ATTACH PARTITION.
Для секции, добавляемой с FOR VALUES, используется то же указание_границ_секции, что и в
CREATE TABLE. Это указание должно соответствовать стратегии секционирования и ключу раз-
биения целевой таблицы. Присоединяемая таблица должна иметь те же столбцы, что и целевая,
и никаких других; более того, должны совпадать и типы столбцов. Кроме того, в ней должны
быть те же ограничения NOT NULL и CHECK, что и в целевой таблице. Ограничения FOREIGN KEY
в настоящее время не учитываются. Если какое-либо из ограничений CHECK присоединяемой
таблицы помечено как NO INHERIT, команда выдаст ошибку; такое ограничение нужно будет
пересоздать без предложения NO INHERIT.
Если новая секция является обычной таблицей, для проверки, не нарушает ли какая-либо стро-
ка в таблице ограничение секции, производится полное сканирование таблицы. Такого скани-
рования можно избежать, добавив перед выполнением этой команды в таблицу действующее
ограничение CHECK, допускающее только такие строки, которые удовлетворяют задаваемому
ограничению секции. Однако это не будет работать, если какие-либо ключи разбиения являют-
ся выражениями и секция не принимает значения NULL. При присоединении секции по списку,
1374ALTER TABLE
не принимающей значения NULL, также добавьте ограничение NOT NULL в столбец ключа раз-
биения, если это не выражение.
Если новая секция является сторонней таблицей, никакая проверка, удовлетворяют ли все
строки сторонней таблицы ограничению секции, не выполняется. (Обсуждение ограничений
сторонней таблицы вы можете найти в CREATE FOREIGN TABLE.)
Когда у таблицы есть секция по умолчанию, у данной секции при добавлении новой меняется
ограничение секции. Секция по умолчанию не может содержать строки, которые должны быть
перенесены в новую секцию, поэтому она будет просканирована и проверена на предмет их от-
сутствия. Этого сканирования, как и сканирования новой секции, можно избежать, если опре-
делить подходящее ограничение CHECK. Кроме того, сканирование этой секции, как и новой,
всегда пропускается, когда данная секция является сторонней таблицей.
DETACH PARTITION имя_секции
Эта форма отсоединяет заданную секцию от целевой таблицы. Отсоединяемая секция продол-
жит существовать как отдельная таблица, но более не будет иметь никаких связей с таблицей,
от которой была отсоединена. Все индексы, которые были присоединены к индексам целевой
таблицы, отсоединяются.
Все виды ALTER TABLE, действующие на одну таблицу, кроме RENAME, SET SCHEMA, ATTACH PARTITION
и DETACH PARTITION можно объединить в список множественных изменений и применить вместе.
Например, можно добавить несколько столбцов и/или изменить тип столбцов в одной команде. Это
особенно полезно для больших таблиц, так как вся таблица обрабатывается за один проход.
Выполнить ALTER TABLE может только владелец соответствующей таблицы. Чтобы сменить схе-
му или табличное пространство таблицы, необходимо также иметь право CREATE в новой схеме
или табличном пространстве. Чтобы сделать таблицу потомком другой таблицы, нужно быть вла-
дельцем и родительской таблицы. Также, чтобы подсоединить таблицу к другой в качестве сек-
ции, необходимо быть владельцем подсоединяемой таблицы. Чтобы сменить владельца, необходи-
мо быть непосредственным или опосредованным членом новой роли-владельца, а эта роль должна
иметь право CREATE в схеме таблицы. (С такими ограничениями при смене владельца не происходит
ничего такого, что нельзя было бы сделать, имея право удалить и вновь создать таблицу. Однако
суперпользователь может сменить владельца таблицы в любом случае.) Чтобы добавить столбец,
сменить тип столбца или применить предложение OF, необходимо также иметь право USAGE для
соответствующего типа данных.
Параметры
IF EXISTS
Не считать ошибкой, если таблица не существует. В этом случае будет выдано замечание.
имя
Имя (возможно, дополненное схемой) существующей таблицы, подлежащей изменению. Если
перед именем таблицы указано ONLY, изменяется только заданная таблица. Без ONLY изменя-
ется и заданная таблица, и все её потомки (если таковые есть). После имени таблицы можно
также добавить необязательное указание *, чтобы явно обозначить, что изменению подлежат
все дочерние таблицы.
имя_столбца
Имя нового или существующего столбца.
новое_имя_столбца
Новое имя существующего столбца.
новое_имя
Новое имя таблицы.
1375ALTER TABLE
тип_данных
Тип данных нового столбца или новый тип данных существующего столбца.
ограничение_таблицы
Новое ограничение таблицы.
имя_ограничения
Имя нового или существующего ограничения.
CASCADE
Автоматически удалять объекты, зависящие от удаляемого столбца или ограничения (напри-
мер, представления, содержащие этот столбец), и, в свою очередь, все зависящие от них объ-
екты (см. Раздел 5.13).
RESTRICT
Отказать в удалении столбца или ограничения, если существуют зависящие от них объекты.
Это поведение по умолчанию.
имя_триггера
Имя включаемого или отключаемого триггера.
ALL
Отключить или включить все триггеры, принадлежащие таблице. (Для этого требуются права
суперпользователя, если в числе этих триггеров оказываются сгенерированные внутрисистем-
ные триггеры исключений, например те, что реализуют ограничения внешнего ключа или от-
ложенные ограничения уникальности и исключений.)
USER
Отключить или включить все триггеры, принадлежащие таблице, за исключением сгенериро-
ванных внутрисистемных триггеров исключений, например, тех, что реализуют ограничения
внешнего ключа или отложенные ограничения уникальности и исключений.
имя_индекса
Имя существующего индекса.
параметр_хранения
Имя параметра хранения таблицы
значение
Новое значение параметра хранения таблицы. Это может быть число или строка, в зависимости
от параметра.
таблица_родитель
Родительская таблица, с которой будет установлена или разорвана связь данной таблицы.
новый_владелец
Имя пользователя, назначаемого новым владельцем таблицы.
новое_табл_пространство
Имя табличного пространства, в которое будет перемещена таблица.
новая_схема
Имя схемы, в которую будет перемещена таблица.
1376ALTER TABLE
имя_секции
Имя таблицы, подсоединяемой в качестве новой секции, или наоборот, отсоединяемой от дан-
ной таблицы.
указание_границ_секции
Указание границ для новой секции. Подробнее синтаксис этого указания рассматривается в
описании CREATE TABLE.
Замечания
Ключевое слово COLUMN не несёт смысловой нагрузки и может быть опущено.
Когда конструкция ADD COLUMN добавляет столбец и для него задано неизменчивое выражение
DEFAULT, значение по умолчанию вычисляется во время выполнения оператора и сохраняется в
метаданных таблицы. Это значение затем будет использовано в качестве содержимого столбца для
всех существующих строк. Если указание DEFAULT отсутствует, столбец будет содержать NULL. В
обоих случаях перезапись таблицы не требуется.
Добавление столбца с изменчивым выражением DEFAULT или изменение типа существующего
столбца влечёт за собой перезапись всей таблицы и её индексов. Но возможно исключение при
смене типа существующего столбца: если предложение USING не меняет содержимое столбца и
старый тип двоично приводится к новому или является неограниченным доменом поверх нового
типа, то перезапись таблицы не требуется, хотя все индексы с затронутыми столбцами всё же
требуется перестроить. При добавлении или удалении системного столбца oid также необходима
перезапись всей таблицы. Перестроение больших таблиц и/или их индексов может быть весьма
длительной процедурой, которая при этом временно требует вдвое больше места на диске.
Добавление ограничений CHECK или NOT NULL влечёт за собой необходимость просканировать таб-
лицу, чтобы проверить, что все существующие строки удовлетворяют ограничению, но перезапи-
сывать таблицу при этом не требуется.
Подобным образом, при присоединении новой секции может производиться её сканирование для
проверки, соответствуют ли существующие строки ограничению секции.
Возможность объединения множества изменений в одну команду ALTER TABLE полезна в основном
тем, что позволяет совместить сканирования и перезаписи таблицы, требуемые этим операциям,
и выполнить их за один проход.
Форма DROP COLUMN не удаляет столбец физически, а просто делает его невидимым для операций
SQL. При последующих операциях добавления или изменения в этот столбец будет записываться
значение NULL. Таким образом, удаление столбца выполняется быстро, но при этом размер таб-
лицы на диске не уменьшается, так как пространство, занимаемое удалённым столбцом, не высво-
бождается. Это пространство будет освобождено со временем, по мере изменения существующих
строк. (При удалении системного столбца oid это поведение не наблюдается, так как немедленно
выполняется перезапись таблицы.)
Чтобы принудительно высвободить пространство, занимаемое столбцом, который был удалён, мож-
но выполнить одну из форм ALTER TABLE, производящих перезапись всей таблицы. В результате
все строки будут воссозданы так, что в удалённом столбце будет содержаться NULL.
Перезаписывающие формы ALTER TABLE небезопасны с точки зрения MVCC. После перезаписи
таблица будет выглядеть пустой для параллельных транзакций, если они работают со снимком,
полученным до момента перезаписи. За подробностями обратитесь к Разделу 13.5.
В указании USING предложения SET DATA TYPE на самом деле можно записать выражение со ста-
рыми значениями строки; то есть, оно может ссылаться как на преобразуемые столбцы, так и на
другие. Это позволяет записывать в SET DATA TYPE очень общие преобразования данных. Ввиду та-
кой гибкости, выражение USING не применяется к значению по умолчанию данного столбца (если
таковое есть); результат может быть не константным выражением, что требуется для значения по
1377ALTER TABLE
умолчанию. Это означает, что в случае отсутствия явного приведения или присваивания старого
типа новому, SET DATA TYPE может не справиться с преобразованием значения по умолчанию,
несмотря на то, что применяется предложение USING. В этих случаях нужно удалить значение по
умолчанию с помощью DROP DEFAULT, выполнить ALTER TYPE, а затем с помощью SET DEFAULT за-
дать новое подходящее значение по умолчанию. Подобные соображения применимы и в отноше-
нии индексов и ограничений с этим столбцом.
Если у таблицы имеются дочерние таблицы, то добавлять, переименовывать столбцы или менять их
тип в родительской таблице, не повторяя ту же операцию в дочерних таблицах, нельзя. Это прави-
ло гарантирует, что столбцы в дочерних таблицах всегда соответствуют родительской. Подобным
образом, нельзя переименовать ограничение CHECK в родительской таблице, не переименовывая
его во всех дочерних таблицах, что тоже гарантирует соответствие всех ограничений CHECK. (Од-
нако это не касается ограничений, построенных на индексах.) И так как выборка из родительской
таблицы влечёт за собой выборку из всех потомков, ограничение родителя не может быть помече-
но как действующее, если оно также не является действующим в потомках. Во всех этих случаях
команда ALTER TABLE ONLY не будет выполнена.
Рекурсивная операция DROP COLUMN удалит столбец из дочерней таблицы, только если этот стол-
бец не наследуется от каких-то других родителей и никогда не был определён в дочерней таблице
независимо. Нерекурсивная операция DROP COLUMN (т. е., ALTER TABLE ONLY … DROP COLUMN) нико-
гда не удаляет унаследованные столбцы; вместо этого она помечает их как независимо определён-
ные, а не наследуемые. С секционированной таблицей нерекурсивная команда DROP COLUMN выдаст
ошибку, так как все секции таблицы должны содержать те же столбцы, что и главная таблица.
Действия для столбцов идентификации (ADD GENERATED, SET и т. д., DROP IDENTITY), а также дей-
ствия TRIGGER, CLUSTER, OWNER и TABLESPACE никогда не распространяются рекурсивно на дочерние
таблицы; то есть они всегда выполняются так, как будто указано ONLY. Операция добавления огра-
ничения выполняется рекурсивно только для ограничений CHECK, не помеченных как NO INHERIT.
Какие-либо изменения таблиц системного каталога не допускаются.
За более подробным описанием допустимых параметров обратитесь к CREATE TABLE. Дополни-
тельно о наследовании можно узнать в Главе 5.
Примеры
Добавление в таблицу столбца типа varchar:
ALTER TABLE distributors ADD COLUMN address varchar(30);
Удаление столбца из таблицы:
ALTER TABLE distributors DROP COLUMN address RESTRICT;
Изменение типов двух существующих столбцов в одной операции:
ALTER TABLE distributors
ALTER COLUMN address TYPE varchar(80),
ALTER COLUMN name TYPE varchar(100);
Смена типа целочисленного столбца, содержащего время в стиле Unix, на тип timestamp with
time zone с применением предложения USING:
ALTER TABLE foo
ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
USING
timestamp with time zone ‘epoch’ + foo_timestamp * interval ‘1 second’;
То же самое, но в случае, когда у столбца есть значение по умолчанию, не приводимое автомати-
чески к новому типу данных:
ALTER TABLE foo
1378ALTER TABLE
ALTER COLUMN foo_timestamp DROP DEFAULT,
ALTER COLUMN foo_timestamp TYPE timestamp with time zone
USING
timestamp with time zone ‘epoch’ + foo_timestamp * interval ‘1 second’,
ALTER COLUMN foo_timestamp SET DEFAULT now();
Переименование существующего столбца:
ALTER TABLE distributors RENAME COLUMN address TO city;
Переименование существующей таблицы:
ALTER TABLE distributors RENAME TO suppliers;
Переименование существующего ограничения:
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
Добавление в столбец ограничения NOT NULL:
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
Удаление ограничения NOT NULL из столбца:
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
Добавление ограничения-проверки в таблицу и все её потомки:
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
Добавление ограничения-проверки только в таблицу, но не в её потомки:
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO
INHERIT;
(Данное ограничение-проверка не будет наследоваться и будущими потомками тоже.)
Удаление ограничения-проверки из таблицы и из всех её потомков:
ALTER TABLE distributors DROP CONSTRAINT zipchk;
Удаление ограничения-проверки только из самой таблицы:
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
(Ограничение-проверка остаётся во всех дочерних таблицах.)
Добавление в таблицу ограничения внешнего ключа:
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES
addresses (address);
Добавление в таблицу ограничения внешнего ключа с наименьшим влиянием на работу других:
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES
addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
Добавление в таблицу ограничения уникальности (по нескольким столбцам):
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
Добавление в таблицу первичного ключа с автоматическим именем (учтите, что в таблице может
быть только один первичный ключ):
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
Перемещение таблицы в другое табличное пространство:
1379ALTER TABLE
ALTER TABLE distributors SET TABLESPACE fasttablespace;
Перемещение таблицы в другую схему:
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
Пересоздание ограничения первичного ключа без блокировки изменений в процессе перестрое-
ния индекса:
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
Присоединение секции к таблице, разбиваемой по диапазонам:
ALTER TABLE measurement
ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM (‘2016-07-01’) TO
(‘2016-08-01’);
Присоединение секции к таблице, разбиваемой по списку:
ALTER TABLE cities
ATTACH PARTITION cities_ab FOR VALUES IN (‘a’, ‘b’);
Присоединение секции к таблице, разбиваемой по хешу:
ALTER TABLE orders
ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
Присоединение секции по умолчанию к секционированной таблице:
ALTER TABLE cities
ATTACH PARTITION cities_partdef DEFAULT;
Удаление секции из секционированной таблицы:
ALTER TABLE measurement
DETACH PARTITION measurement_y2015m12;
Совместимость
Формы ADD (без USING INDEX), DROP [COLUMN], DROP IDENTITY, RESTART, SET DEFAULT, SET DATA
TYPE (без USING), SET GENERATED и SET параметр_последовательности соответствуют стандарту SQL.
Другие формы являются расширениями стандарта SQL, реализованными в PostgreSQL. Кроме того,
расширением является возможность указать в одной команде ALTER TABLE несколько операций
изменения.
ALTER TABLE DROP COLUMN позволяет удалить единственный столбец таблицы и оставить таблицу
без столбцов. Это является расширением стандарта SQL, который не допускает существование
таблиц с нулём столбцов.
См. также
CREATE TABLE
1380ALTER TABLESPACE
ALTER TABLESPACE — изменить определение табличного пространства
Синтаксис
ALTER
ALTER
ALTER
ALTER
TABLESPACE
TABLESPACE
TABLESPACE
TABLESPACE
имя
имя
имя
имя
RENAME TO новое_имя
OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
SET ( параметр_табличного_пространства = значение [, … ] )
RESET ( параметр_табличного_пространства [, … ] )
Описание
ALTER TABLESPACE может применяться для изменения определения табличного пространства.
Чтобы изменить определение табличного пространства, нужно быть его владельцем. Чтобы сме-
нить владельца, нужно быть непосредственным или опосредованным членом новой роли-владель-
ца. (Заметьте, что суперпользователи наделяются этими правами автоматически.)
Параметры
имя
Имя существующего табличного пространства.
новое_имя
Новое имя табличного пространства. Новое имя не может начинаться с pg_, так как такие име-
на зарезервированы для системных табличных пространств.
новый_владелец
Новый владелец табличного пространства.
параметр_табличного_пространства
Устанавливаемый или сбрасываемый параметр табличного пространства. В настоя-
щее время поддерживаются только параметры seq_page_cost, random_page_cost и
effective_io_concurrency. При установке этих значений для заданного табличного простран-
ства будет переопределена обычная оценка стоимости чтения страниц из таблиц в этом
пространстве, настраиваемая одноимённым параметром конфигурации (см. seq_page_cost,
random_page_cost, effective_io_concurrency). Это может быть полезно, если одно из табличных
пространств размещено на диске, который быстрее или медленнее остальной дисковой систе-
мы.
Примеры
Переименование табличного пространства index_space в fast_raid:
ALTER TABLESPACE index_space RENAME TO fast_raid;
Смена владельца табличного пространства index_space:
ALTER TABLESPACE index_space OWNER TO mary;
Совместимость
Оператор ALTER TABLESPACE отсутствует в стандарте SQL.
См. также
CREATE TABLESPACE, DROP TABLESPACE
1381ALTER TEXT SEARCH CONFIGURATION
ALTER TEXT SEARCH CONFIGURATION — изменить определение конфигурации текстового поиска
Синтаксис
ALTER TEXT SEARCH CONFIGURATION имя
ADD MAPPING FOR тип_фрагмента [, … ] WITH имя_словаря [, … ]
ALTER TEXT SEARCH CONFIGURATION имя
ALTER MAPPING FOR тип_фрагмента [, … ] WITH имя_словаря [, … ]
ALTER TEXT SEARCH CONFIGURATION имя
ALTER MAPPING REPLACE старый_словарь WITH новый_словарь
ALTER TEXT SEARCH CONFIGURATION имя
ALTER MAPPING FOR тип_фрагмента [, … ] REPLACE старый_словарь WITH новый_словарь
ALTER TEXT SEARCH CONFIGURATION имя
DROP MAPPING [ IF EXISTS ] FOR тип_фрагмента [, … ]
ALTER TEXT SEARCH CONFIGURATION имя RENAME TO новое_имя
ALTER TEXT SEARCH CONFIGURATION имя OWNER TO ( новый_владелец | CURRENT_USER |
SESSION_USER )
ALTER TEXT SEARCH CONFIGURATION имя SET SCHEMA новая_схема
Описание
ALTER TEXT SEARCH CONFIGURATION изменяет определение конфигурации текстового поиска. Эта
команда позволяет настроить сопоставления типов фрагментов со словарями или сменить владель-
ца или имя конфигурации.
Выполнить ALTER TEXT SEARCH CONFIGURATION может только владелец соответствующей конфигу-
рации.
Параметры
имя
Имя (возможно, дополненное схемой) существующей конфигурации текстового поиска.
тип_фрагмента
Имя типа фрагмента, выдаваемое при разборе конфигурации.
имя_словаря
Имя словаря текстового поиска, в котором будет искаться указанный тип фрагмента. Если ука-
заны несколько словарей, они просматриваются в порядке перечисления.
старый_словарь
Имя словаря текстового поиска, которое будет заменено в сопоставлении.
новый_словарь
Имя словаря текстового поиска, которое будет подставлено там, где был старый_словарь.
новое_имя
Новое имя конфигурации текстового поиска.
новый_владелец
Новый владелец конфигурации текстового поиска.
1382ALTER TEXT SEARCH
CONFIGURATION
новая_схема
Новая схема конфигурации текстового поиска.
Форма ADD MAPPING FOR настраивает список словарей, которые будут просматриваться в поиске
указанных типов фрагментов; если сопоставление для каких-либо типов уже задано, возникнет
ошибка. Форма ALTER MAPPING FOR делает то же самое, но она сначала удаляет существующее со-
поставление для этих типов фрагментов. Формы ALTER MAPPING REPLACE подставляют новый_сло-
варь вместо старый_словарь везде, где упоминается последний. Это выполняется только для ука-
занных типов фрагментов, когда присутствует FOR, либо для всех сопоставлений в конфигурации
в противном случае. Форма DROP MAPPING удаляет все словари для заданных типов фрагментов,
в результате чего фрагменты этих типов будут игнорироваться конфигурацией. Если сопоставле-
ний для заданных типов фрагментов нет, возникает ошибка, если только не добавлено указание
IF EXISTS.
Примеры
В следующем примере словарь english заменяется на swedish везде, где использовался english
в конфигурации my_config.
ALTER TEXT SEARCH CONFIGURATION my_config
ALTER MAPPING REPLACE english WITH swedish;
Совместимость
Оператор ALTER TEXT SEARCH CONFIGURATION отсутствует в стандарте SQL.
См. также
CREATE TEXT SEARCH CONFIGURATION, DROP TEXT SEARCH CONFIGURATION
1383ALTER TEXT SEARCH DICTIONARY
ALTER TEXT SEARCH DICTIONARY — изменить определение словаря текстового поиска
Синтаксис
ALTER TEXT SEARCH DICTIONARY имя (
параметр [ = значение ] [, … ]
)
ALTER TEXT SEARCH DICTIONARY имя RENAME TO новое_имя
ALTER TEXT SEARCH DICTIONARY имя OWNER TO ( новый_владелец | CURRENT_USER |
SESSION_USER )
ALTER TEXT SEARCH DICTIONARY имя SET SCHEMA новая_схема
Описание
ALTER TEXT SEARCH DICTIONARY изменяет определение словаря текстового поиска. Эта команда
позволяет изменить параметры словаря, связанные с шаблонами, или сменить владельца или имя
словаря.
Выполнить ALTER TEXT SEARCH DICTIONARY может только владелец словаря.
Параметры
имя
Имя (возможно, дополненное схемой) существующего словаря текстового поиска.
параметр
Имя параметра шаблона, устанавливаемого для данного словаря.
значение
Новое значение для параметра настройки шаблонов. Если знак равно и значение опущено,
предыдущее значение параметра удаляется из словаря, что позволяет вернутся к значению по
умолчанию.
новое_имя
Новое имя словаря текстового поиска.
новый_владелец
Новый владелец словаря текстового поиска.
новая_схема
Новая схема словаря текстового поиска.
Параметры настройки шаблонов могут перечисляться в любом порядке.
Примеры
Команда в следующем примере меняет список стоп-слов словаря на базе Snowball. Другие пара-
метры остаются неизменными.
ALTER TEXT SEARCH DICTIONARY my_dict ( StopWords = newrussian );
Команда в следующем примере меняет параметр, определяющий язык, на dutch, и удаляет пара-
метр, задающий список стоп-слов.
ALTER TEXT SEARCH DICTIONARY my_dict ( language = dutch, StopWords );
1384ALTER TEXT SEARCH DICTIONARY
Следующая команда «изменяет» определение словаря, на самом деле не меняя ничего.
ALTER TEXT SEARCH DICTIONARY my_dict ( dummy );
(Это работает потому, что код удаления параметра не считает ошибкой отсутствие такого пара-
метра.) Этот трюк может быть полезен при изменении файлов конфигурации словаря; ALTER при-
нудит все существующие сеансы перечитать файлы конфигурации, что в противном случае они не
сделают никогда, если прочитали конфигурацию ранее.
Совместимость
Оператор ALTER TEXT SEARCH DICTIONARY отсутствует в стандарте SQL.
См. также
CREATE TEXT SEARCH DICTIONARY, DROP TEXT SEARCH DICTIONARY
1385ALTER TEXT SEARCH PARSER
ALTER TEXT SEARCH PARSER — изменить определение анализатора текстового поиска
Синтаксис
ALTER TEXT SEARCH PARSER имя RENAME TO новое_имя
ALTER TEXT SEARCH PARSER имя SET SCHEMA новая_схема
Описание
ALTER TEXT SEARCH PARSER изменяет определение анализатора текстового поиска. В настоящее
время эта команда позволяет только сменить его имя.
Выполнить ALTER TEXT SEARCH PARSER может только суперпользователь.
Параметры
имя
Имя (возможно, дополненное схемой) существующего анализатора текстового поиска.
новое_имя
Новое имя анализатора текстового поиска.
новая_схема
Новая схема анализатора текстового поиска.
Совместимость
Оператор ALTER TEXT SEARCH PARSER отсутствует в стандарте SQL.
См. также
CREATE TEXT SEARCH PARSER, DROP TEXT SEARCH PARSER
1386ALTER TEXT SEARCH TEMPLATE
ALTER TEXT SEARCH TEMPLATE — изменить определение шаблона текстового поиска
Синтаксис
ALTER TEXT SEARCH TEMPLATE имя RENAME TO новое_имя
ALTER TEXT SEARCH TEMPLATE имя SET SCHEMA новая_схема
Описание
ALTER TEXT SEARCH TEMPLATE изменяет определение шаблона текстового поиска. В настоящее
время эта команда позволяет только сменить его имя.
Выполнить команду ALTER TEXT SEARCH TEMPLATE может только суперпользователь.
Параметры
имя
Имя (возможно, дополненное схемой) существующего шаблона текстового поиска.
новое_имя
Новое имя шаблона текстового поиска.
новая_схема
Новая схема шаблона текстового поиска.
Совместимость
Оператор ALTER TEXT SEARCH TEMPLATE отсутствует в стандарте SQL.
См. также
CREATE TEXT SEARCH TEMPLATE, DROP TEXT SEARCH TEMPLATE
1387ALTER TRIGGER
ALTER TRIGGER — изменить определение триггера
Синтаксис
ALTER TRIGGER имя ON имя_таблицы RENAME TO новое_имя
ALTER TRIGGER имя ON имя_таблицы DEPENDS ON EXTENSION имя_расширения
Описание
ALTER TRIGGER меняет свойства существующего триггера. Предложение RENAME переименовывает
данный триггер, не затрагивая его определение. Предложение DEPENDS ON EXTENSION помечает
триггер как зависимый от расширения, так что при удалении расширения будет автоматически
удаляться и триггер.
Изменять свойства триггера может только владелец таблицы, с которой работает триггер.
Параметры
имя
Имя существующего триггера, подлежащего изменению.
имя_таблицы
Имя таблицы, с которой работает триггер.
новое_имя
Новое имя триггера.
имя_расширения
Имя расширения, от которого будет зависеть триггер.
Замечания
Возможность временно включать или отключать триггер предоставляется командой ALTER TABLE,
а не ALTER TRIGGER, так как ALTER TRIGGER не позволяет удобным образом выразить указание
включить или отключить все триггеры таблицы сразу.
Примеры
Переименование существующего триггера:
ALTER TRIGGER emp_stamp ON emp RENAME TO emp_track_chgs;
Обозначение триггера как зависимого от расширения:
ALTER TRIGGER emp_stamp ON emp DEPENDS ON EXTENSION emplib;
Совместимость
ALTER TRIGGER — реализованное в PostgreSQL расширение стандарта SQL.
См. также
ALTER TABLE
1388ALTER TYPE
ALTER TYPE — изменить определение типа
Синтаксис
ALTER TYPE имя действие [, … ]
ALTER TYPE имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER TYPE имя RENAME ATTRIBUTE имя_атрибута TO новое_имя_атрибута [ CASCADE |
RESTRICT ]
ALTER TYPE имя RENAME TO новое_имя
ALTER TYPE имя SET SCHEMA новая_схема
ALTER TYPE имя ADD VALUE [ IF NOT EXISTS ] новое_значение_перечисления [ ( BEFORE |
AFTER ) соседнее_значение_перечисления ]
ALTER TYPE имя RENAME VALUE существующее_значение_перечисления
TO новое_значение_перечисления
Где действие может быть следующим:
ADD ATTRIBUTE имя_атрибута тип_данных [ COLLATE правило_сортировки ] [ CASCADE |
RESTRICT ]
DROP ATTRIBUTE [ IF EXISTS ] имя_атрибута [ CASCADE | RESTRICT ]
ALTER ATTRIBUTE имя_атрибута [ SET DATA ] TYPE тип_данных
[ COLLATE правило_сортировки ] [ CASCADE | RESTRICT ]
Описание
ALTER TYPE изменяет определение существующего типа. Эта команда имеет несколько разновид-
ностей:
ADD ATTRIBUTE
Эта форма добавляет в составной тип новый атрибут с тем же синтаксисом, что и CREATE TYPE.
DROP ATTRIBUTE [ IF EXISTS ]
Эта форма удаляет атрибут из составного типа. Если указано IF EXISTS и атрибут не существу-
ет, это не считается ошибкой. В этом случае выдаётся только замечание.
SET DATA TYPE
Эта форма меняет тип атрибута составного типа.
OWNER
Эта форма меняет владельца типа.
RENAME
Эта форма меняет имя типа или имя отдельного атрибута составного типа.
SET SCHEMA
Эта форма переносит тип в другую схему.
ADD VALUE [ IF NOT EXISTS ] [ BEFORE | AFTER ]
Эта форма добавляет новое значение в тип-перечисление. Порядок нового значения в перечис-
лении можно указать, добавив BEFORE (перед) или AFTER (после) с одним из существующих зна-
чений. Если такое указание отсутствует, новый элемент добавляется в конец списка значений.
1389ALTER TYPE
С указанием IF NOT EXISTS, если тип уже содержит новое значение, ошибки не произойдёт:
будет выдано замечание и ничего больше. Без этого указания, если такое значение уже пред-
ставлено, возникнет ошибка.
RENAME VALUE
Эта форма переименовывает значение в типе-перечислении. Позиция значения в порядке пе-
речисления при этом не меняется. Если это значение отсутствует или в перечислении уже есть
новое имя, выдаётся ошибка.
Операции ADD ATTRIBUTE, DROP ATTRIBUTE и ALTER ATTRIBUTE можно объединить в один список
множественных изменений для параллельного выполнения. Например, в одной команде можно
добавить сразу несколько атрибутов и/или изменить тип нескольких атрибутов.
Выполнить ALTER TYPE может только владелец соответствующего типа. Чтобы сменить схему типа,
необходимо также иметь право CREATE в новой схеме. Чтобы сменить владельца, необходимо быть
непосредственным или опосредованным членом новой роли-владельца, а эта роль должна иметь
право CREATE в схеме типа. (С такими ограничениями при смене владельца не происходит ничего
такого, что нельзя было бы сделать, имея право удалить и вновь создать тип. Однако суперпользо-
ватель может сменить владельца типа в любом случае.) Чтобы добавить атрибут или изменить тип
атрибута, также требуется иметь право USAGE для соответствующего типа данных.
Параметры
имя
Имя (возможно, дополненное схемой) существующего типа, подлежащего изменению.
новое_имя
Новое имя типа.
новый_владелец
Имя пользователя, назначаемого новым владельцем типа.
новая_схема
Новая схема типа.
имя_атрибута
Имя атрибута, подлежащего добавлению, изменению или удалению.
новое_имя_атрибута
Новое имя атрибута
тип_данных
Тип данных добавляемого атрибута, либо новый тип данных изменяемого атрибута.
новое_значение_перечисления
Новое значение добавляется в список значений перечисления или для существующего значе-
ния задаётся новое имя. Как и все элементы перечисления, оно должно заключаться в кавычки.
соседнее_значение_перечисления
Существующие значение в перечислении, непосредственно перед или после которого по по-
рядку перечисления будет добавлено новое значение. Как и все элементы перечисления, оно
должно заключаться в кавычки.
существующее_значение_перечисления
Существующее значение в перечислении, которое будет переименовано. Как и все элементы
перечисления, оно должно заключаться в кавычки.
1390ALTER TYPE
CASCADE
Автоматически распространять действие операции на типизированные таблицы, имеющий дан-
ный тип, и их потомки.
RESTRICT
Отказать в выполнении операции, если изменяемый тип является типом типизированной таб-
лицы. Это поведение по умолчанию.
Замечания
ALTER TYPE … ADD VALUE (форму, добавляющую в тип-перечисление новое значение) нельзя
выполнять внутри блока транзакции.
Сравнения с добавленными значениями перечисления иногда бывают медленнее сравнений, в ко-
торых задействуются только начальные члены типа-перечисления. Обычно это происходит, только
если BEFORE или AFTER устанавливает порядок нового элемента не в конце списка. Однако, иногда
это наблюдается даже тогда, когда новое значение добавляется в конец списка (это происходит,
если счётчик OID «прокручивается» с момента изначального создания типа-перечисления). Это
замедление обычно несущественное, но если это важно, вернуть максимальную производитель-
ность можно, удалив и создав заново это перечисление, либо выгрузив копию базы данных и за-
грузив её вновь.
Примеры
Переименование типа данных:
ALTER TYPE electronic_mail RENAME TO email;
Смена владельца типа email на joe:
ALTER TYPE email OWNER TO joe;
Смена схемы типа email на customers:
ALTER TYPE email SET SCHEMA customers;
Добавление в тип нового атрибута:
ALTER TYPE compfoo ADD ATTRIBUTE f3 int;
Добавление нового значения в тип-перечисление, в определённое положение по порядку:
ALTER TYPE colors ADD VALUE ‘orange’ AFTER ‘red’;
Переименование значения в перечислении:
ALTER TYPE colors RENAME VALUE ‘purple’ TO ‘mauve’;
Совместимость
Формы команды, предназначенные для добавления и удаления атрибутов, являются частью стан-
дарта SQL; другие формы относятся к расширениям PostgreSQL.
См. также
CREATE TYPE, DROP TYPE
1391ALTER USER
ALTER USER — изменить роль в базе данных
Синтаксис
ALTER USER указание_роли [ WITH ] параметр [ … ]
Здесь параметр:
|
|
|
|
|
|
|
|
|
SUPERUSER | NOSUPERUSER
CREATEDB | NOCREATEDB
CREATEROLE | NOCREATEROLE
INHERIT | NOINHERIT
LOGIN | NOLOGIN
REPLICATION | NOREPLICATION
BYPASSRLS | NOBYPASSRLS
CONNECTION LIMIT предел_подключений
[ ENCRYPTED ] PASSWORD ‘пароль’
VALID UNTIL ‘дата_время’
ALTER USER имя RENAME TO новое_имя
ALTER
( TO
ALTER
FROM
ALTER
ALTER
USER ( указание_роли | ALL
| = ) ( значение | DEFAULT
USER ( указание_роли | ALL
CURRENT
USER ( указание_роли | ALL
USER ( указание_роли | ALL
) [ IN DATABASE имя_бд ] SET параметр_конфигурации
)
) [ IN DATABASE имя_бд ] SET параметр_конфигурации
) [ IN DATABASE имя_бд ] RESET параметр_конфигурации
) [ IN DATABASE имя_бд ] RESET ALL
Здесь указание_роли:
имя_роли
| CURRENT_USER
| SESSION_USER
Описание
Оператор ALTER USER теперь стал синонимом оператора ALTER ROLE.
Совместимость
Оператор ALTER USER является расширением PostgreSQL. В стандарте SQL определение пользова-
телей считается зависимым от реализации.
См. также
ALTER ROLE
1392ALTER USER MAPPING
ALTER USER MAPPING — изменить определение сопоставления пользователей
Синтаксис
ALTER USER MAPPING FOR ( имя_пользователя | USER | CURRENT_USER | SESSION_USER |
PUBLIC )
SERVER имя_сервера
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ] )
Описание
ALTER USER MAPPING изменяет определение сопоставления пользователей.
Владелец стороннего сервера может изменить сопоставление любых пользователей на этом сер-
вере. Кроме того, пользователь может изменить сопоставление для своего собственного имени
пользователя, если он наделён правом USAGE на данном сервере.
Параметры
имя_пользователя
Имя пользователя для сопоставления. Значения CURRENT_USER и USER соответствуют имени те-
кущего пользователя. Значение PUBLIC соответствует именам всех текущих и будущих пользо-
вателей системы.
имя_сервера
Имя сервера, для которого меняется сопоставление пользователей.
OPTIONS ( [ ADD | SET | DROP ] параметр [‘значение’] [, … ] )
Эти формы меняют параметры сопоставления пользователей. Новые параметры переопределя-
ют любые определённые ранее. Возможные операции с параметрами: ADD (добавить), SET (уста-
новить) и DROP (удалить). По умолчанию подразумевается ADD. Имена параметров должны быть
уникальными; кроме того, они проверяются обёрткой сторонних данных.
Примеры
Изменение пароля в сопоставлении пользователя bob на сервере foo:
ALTER USER MAPPING FOR bob SERVER foo OPTIONS (SET password ‘public’);
Совместимость
ALTER USER MAPPING соответствует стандарту ISO/IEC 9075-9 (SQL/MED). Однако есть небольшое
синтаксическое различие: в стандарте ключевое слово FOR опускается. Но так как и в CREATE USER
MAPPING, и в DROP USER MAPPING слово FOR находится в аналогичных позициях, а IBM DB2 (ещё
одна популярная реализация SQL/MED) требует его и для ALTER USER MAPPING, PostgreSQL в этом
аспекте отклоняется от стандарта ради согласованности и совместимости.
См. также
CREATE USER MAPPING, DROP USER MAPPING
1393ALTER VIEW
ALTER VIEW — изменить определение представления
Синтаксис
ALTER VIEW [ IF EXISTS ] имя ALTER [ COLUMN ] имя_столбца SET DEFAULT выражение
ALTER VIEW [ IF EXISTS ] имя ALTER [ COLUMN ] имя_столбца DROP DEFAULT
ALTER VIEW [ IF EXISTS ] имя OWNER TO ( новый_владелец | CURRENT_USER | SESSION_USER )
ALTER VIEW [ IF EXISTS ] имя RENAME TO новое_имя
ALTER VIEW [ IF EXISTS ] имя SET SCHEMA новая_схема
ALTER VIEW [ IF EXISTS ] имя SET ( имя_параметра_представления
[= значение_параметра_представления] [, … ] )
ALTER VIEW [ IF EXISTS ] имя RESET ( имя_параметра_представления [, … ] )
Описание
ALTER VIEW изменяет различные дополнительные свойства представления. (Для изменения запро-
са, определяющего представление, используйте команду CREATE OR REPLACE VIEW.)
Выполнить ALTER VIEW может только владелец представления. Чтобы сменить схему представле-
ния, необходимо также иметь право CREATE в новой схеме. Чтобы сменить владельца, требуется
также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь
право CREATE в схеме представления. (С такими ограничениями при смене владельца не происхо-
дит ничего такого, что нельзя было бы сделать, имея право удалить и вновь создать представление.
Однако суперпользователь может сменить владельца представления в любом случае.)
Параметры
имя
Имя существующего представления (возможно, дополненное схемой).
IF EXISTS
Не считать ошибкой, если представление не существует. В этом случае будет выдано замеча-
ние.
SET/DROP DEFAULT
Эти формы устанавливают или удаляют значение по умолчанию в заданном столбце. Значение
по умолчанию подставляется в команды INSERT и UPDATE, вносящие данные в представление, до
применения каких-либо правил или триггеров в этом представлении. Таким образом, значения
по умолчанию в представлении имеют приоритет перед значениями по умолчанию в нижеле-
жащих отношениях.
новый_владелец
Имя пользователя, назначаемого новым владельцем представления.
новое_имя
Новое имя представления.
новая_схема
Новая схема представления.
SET ( имя_параметра_представления [= значение_параметра_представления] [, … ] )
RESET ( имя_параметра_представления [, … ] )
Устанавливает или сбрасывает параметры представления. В настоящее время поддерживаются
параметры:
1394ALTER VIEW
check_option (string)
Изменяет параметр проверки представления. Допустимые значения: local (локальная) или
cascaded (каскадная).
security_barrier (boolean)
Изменяет свойство представления, включающее барьер безопасности. Значение должно
быть логическим: true или false.
Замечания
По историческим причинам команду ALTER TABLE можно использовать и с представлениями; но
единственно допустимые для работы с представлениями вариации ALTER TABLE равносильны вы-
шеперечисленным командам.
Примеры
Переименование представления foo в bar:
ALTER VIEW foo RENAME TO bar;
Добавление значения столбца по умолчанию в изменяемое представление:
CREATE TABLE base_table (id int, ts timestamptz);
CREATE VIEW a_view AS SELECT * FROM base_table;
ALTER VIEW a_view ALTER COLUMN ts SET DEFAULT now();
INSERT INTO base_table(id) VALUES(1); – в ts окажется значение NULL
INSERT INTO a_view(id) VALUES(2); – в ts окажется текущее время
Совместимость
ALTER VIEW — реализованное в PostgreSQL расширение стандарта SQL.
См. также
CREATE VIEW, DROP VIEW
1395ANALYZE
ANALYZE — собрать статистику по базе данных
Синтаксис
ANALYZE [ ( параметр [, …] ) ] [ таблица_и_столбцы [, …] ]
ANALYZE [ VERBOSE ] [ таблица_и_столбцы [, …] ]
Здесь допускается параметр:
VERBOSE
и таблица_и_столбцы:
имя_таблицы [ ( имя_столбца [, …] ) ]
Описание
ANALYZE собирает статистическую информацию о содержимом таблиц в базе данных и сохраняет
результаты в системном каталоге pg_statistic. Впоследствии планировщик запросов будет ис-
пользовать эту статистику для выбора наиболее эффективных планов выполнения запросов.
Без списка таблица_и_столбцы команда ANALYZE обрабатывает все таблицы и материализованные
представления в текущей базе данных, на анализ которых текущий пользователь имеет право. Со
списком ANALYZE обрабатывает только указанные в нём таблицы. Дополнительно можно задать
для таблицы список имён столбцов, в этом случае статистика будет собираться только по этим
столбцам.
Когда список параметров заключается в скобки, параметры могут быть записаны в любом поряд-
ке. Синтаксис со скобками появился в PostgreSQL 11; вариант записи без скобок считается уста-
ревшим.
Параметры
VERBOSE
Включает вывод сообщений о процессе выполнения.
имя_таблицы
Имя (возможно, дополненное схемой) определённой таблицы, подлежащей анализу. Если опу-
щено, анализироваться будут все обычные и секционированные таблицы, а также материали-
зованные представления в текущей базе данных (но не сторонние таблицы). Если задано имя
секционированной таблицы, обновлена будет как статистика наследования для этой таблицы,
так и статистика отдельных её секций.
имя_столбца
Имя столбца, подлежащего анализу. По умолчанию анализируются все столбцы.
Выводимая информация
С указанием VERBOSE команда ANALYZE выдаёт сообщения о процессе анализа, отмечая текущую
обрабатываемую таблицу. Также она выводит различные статистические сведения о таблицах.
Замечания
Сторонние таблицы анализируются только при явном указании и только если соответствующая
обёртка сторонних данных поддерживает команду ANALYZE. Если эта команда не поддерживается,
при выполнении ANALYZE выводится предупреждение и больше ничего не происходит.
1396ANALYZE
В стандартной конфигурации PostgreSQL работающий демон автоочистки (см. Подраздел 24.1.6)
запускает анализ таблиц автоматически, когда они изначально заполняются данными, и периоди-
чески, по мере того, как они меняются. Если автоочистка отключена, рекомендуется запускать
ANALYZE время от времени, либо после кардинальных изменений в таблице. Точная статистика по-
могает планировщику выбрать наиболее эффективный план запроса и тем самым увеличивает ско-
рость выполнения запроса. Обычно для баз, где данные в основном читаются, выполняют VACUUM
и ANALYZE раз в день, во время наименьшей активности. (Этого будет недостаточно, если данные
меняются очень активно.)
ANALYZE запрашивает для целевой таблицы блокировку только на чтение, так что эта команда мо-
жет выполняться параллельно с другими операциями с таблицей.
Статистика, собираемая командой ANALYZE, обычно включает список из нескольких самых частых
значений в каждом столбце и гистограмму, отражающую примерное распределение данных во
всех столбцах. Один или оба этих элемента статистики могут быть опущены, если ANALYZE сочтёт их
неинтересными (например, в столбце уникального ключа нет повторяющихся значений), либо если
тип данных столбца не поддерживает соответствующие операторы. Более подробно статистика
описывается в Главе 24.
В больших таблицах ANALYZE не просматривает все строки, а обрабатывает только небольшую слу-
чайную выборку. Это позволяет проанализировать за короткое время даже очень большие табли-
цы. Однако учтите, что такая статистика будет лишь приблизительной и может немного меняться
при каждом выполнении ANALYZE, даже если фактическое содержимое таблицы остаётся неизмен-
ным. Это может приводить к небольшим изменениям в оценках стоимости запросов, выводимых
командой EXPLAIN. В редких случаях вследствие этой недетерменированности планировщик ме-
няет свой выбор после выполнения ANALYZE. Чтобы избежать этого, увеличьте объём статистики,
собираемой командой ANALYZE, как описано ниже.
Количеством статистики можно управлять, настраивая конфигурационную переменную
default_statistics_target или устанавливая ориентир статистики на уровне столбцов командой ALTER
TABLE … ALTER COLUMN … SET STATISTICS (см. ALTER TABLE). Ориентир задаёт максимальное
число записей в списке наиболее распространённых значений и максимальное число интервалов
в гистограмме. По умолчанию значение ориентира равно 100, но его можно увеличить или умень-
шить в поисках баланса между точностью оценок планировщика и временем, требующимся для
выполнения ANALYZE, а также объёмом статистики в таблице pg_statistic. Если установить ори-
ентир статистики равным нулю, статистика по таким столбцам собираться не будет. Это может
быть полезно для столбцов, которые никогда не фигурируют в предложениях WHERE, GROUP BY и
ORDER BY, так как планировщик никогда не будет использовать их статистику.
Число строк таблицы, выбираемых для подготовки статистики, определяется наибольшим ориен-
тиром статистики по всем анализируемым столбцам этой таблицы. Увеличение ориентира при-
водит к пропорциональному увеличению времени и пространства, требуемого для выполнения
ANALYZE.
Одним из показателей, оцениваемых командой ANALYZE, является число различных значений,
встречающихся в каждом столбце. Так как рассматривается только подмножество всех строк, эта
оценка иногда может быть весьма неточной, даже при самых больших ориентирах статистики. Ес-
ли эта неточность приводит к плохому выбору плана запроса, более точное значение можно опре-
делить вручную и затем задать его командой ALTER TABLE … ALTER COLUMN … SET (n_distinct
= …) (см. ALTER TABLE).
Если у анализируемой таблицы есть один или несколько потомков, ANALYZE соберёт статистику
дважды: сначала по строкам только родительской таблицы, а затем по строкам родительской и всех
дочерних таблиц. Второй набор статистики необходим для планирования запросов, обращающихся
ко всему дереву наследования. Демон автоочистки, однако, принимая решение об автоматическом
запуске анализа, будет учитывать операции добавления или изменения данных только в самой
родительской таблице. Если именно в этой таблице изменение и добавление происходит редко,
наследуемая статистика может терять актуальность, если не запускать ANALYZE вручную.
1397ANALYZE
Если какие-либо из дочерних таблиц являются сторонними таблицами и их обёртки сторонних
данных не поддерживают ANALYZE, эти дочерние таблицы игнорируются при сборе статистики на-
следования.
Если анализируемая таблица оказалась пустой, ANALYZE не будет обновлять статистику по этой
таблице; в базе сохранится статистика, собранная ранее.
Совместимость
Оператор ANALYZE отсутствует в стандарте SQL.
См. также
VACUUM, vacuumdb, Подраздел 19.4.4, Подраздел 24.1.6
1398BEGIN
BEGIN — начать блок транзакции
Синтаксис
BEGIN [ WORK | TRANSACTION ] [ режим_транзакции [, …] ]
Где режим_транзакции может быть следующим:
ISOLATION LEVEL ( SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ
UNCOMMITTED )
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
Описание
BEGIN начинает блок транзакции, то есть обозначает, что все операторы после команды BEGIN и
до явной команды COMMIT или ROLLBACK будут выполняться в одной транзакции. По умолчанию
(без BEGIN) PostgreSQL выполняет транзакции в режиме «autocommit» (автофиксация), то есть каж-
дый оператор выполняется в своей отдельной транзакции, которая неявно фиксируется в конце
оператора (если оператор был выполнен успешно; в противном случае, транзакция откатывается).
В блоке транзакции операторы выполняются быстрее, так как для запуска/фиксации транзакции
производится масса операций, нагружающих процессор и диск. Кроме того, выполнение несколь-
ких операторов в одной транзакции позволяет обеспечить целостность при внесении серии свя-
занных изменений; другие сеансы не видят промежуточное состояние, когда произошли ещё не
все связанные изменения.
Если указан уровень изоляции, режим чтения/записи или устанавливается отложенный режим,
новая транзакция получает те же характеристики, что и после выполнения SET TRANSACTION.
Параметры
WORK
TRANSACTION
Необязательные ключевые слова, не оказывают никакого влияния.
За описанием других параметров обратитесь к SET TRANSACTION.
Замечания
START TRANSACTION делает то же, что и BEGIN.
Для завершения блока транзакции используйте COMMIT или ROLLBACK.
При попытке выполнить BEGIN внутри уже начатого блока транзакции будет выдано предупрежде-
ние, а состояние транзакции не изменится. Для вложения подтранзакций внутри блока транзак-
ций используйте точки сохранения (см. SAVEPOINT).
Для сохранения обратной совместимости допускается перечисление режимов_транзакции без за-
пятых.
Примеры
Начало блока транзакции:
BEGIN;
1399BEGIN
Совместимость
BEGIN — это языковое расширение PostgreSQL. Эта команда равнозначна соответствующей стан-
дарту SQL команде START TRANSACTION, на справочной странице которой можно найти допол-
нительные сведения о совместимости.
Значение DEFERRABLE параметра режим_транзакции является языковым расширением PostgreSQL.
По стечению обстоятельств ключевое слово BEGIN имеет другое значение во встраиваемом SQL,
поэтому при портировании приложений баз данных рекомендуется внимательно сверить семанти-
ку транзакций.
См. также
COMMIT, ROLLBACK, START TRANSACTION, SAVEPOINT
1400CALL
CALL — вызвать процедуру
Синтаксис
CALL имя ( [ аргумент ] [, …] )
Описание
CALL вызывает процедуру.
Если у процедуры есть выходные параметры, возвращается строка результата, содержащая зна-
чения этих параметров.
Параметры
имя
Имя процедуры (возможно, дополненное схемой).
аргумент
Входной аргумент вызова процедуры. Подробнее синтаксис вызова процедур и функций, а
также использование именованных параметров описывается в Разделе 4.3.
Замечания
Чтобы вызывать процедуру, пользователь должен иметь право EXECUTE для неё.
Для вызова функции (не процедуры) следует использовать SELECT.
Если CALL выполняется в блоке транзакции, вызываемая процедура не может выполнять опера-
торы управления транзакциями. Такие операторы допускаются, только если CALL выполняется в
собственной транзакции.
Выходные параметры команд CALL в PL/pgSQL обрабатываются по-другому; см. Подраздел 43.6.3.
Примеры
CALL do_db_maintenance();
Совместимость
Команда CALL соответствует стандарту SQL.
См. также
CREATE PROCEDURE
1401CHECKPOINT
CHECKPOINT — произвести контрольную точку в журнале предзаписи
Синтаксис
CHECKPOINT
Описание
Контрольная точка — это момент в последовательности событий в журнале предзаписи, когда все
файлы данных приводятся в актуальное состояние, соответствующее информации в журнале. При
этом все файлы данных сохраняются на диск. Более подробно о том, что происходит во время
контрольной точки, можно узнать в Разделе 30.4.
Команда CHECKPOINT приводит к принудительному выполнению контрольной точки в момент вы-
зова, не дожидаясь периодической контрольной точки, производимой системой по графику (это
настраивается параметрами в Подраздел 19.5.2). Команда CHECKPOINT не предназначена для при-
менения при обычном использовании базы данных.
Если CHECKPOINT выполняется в процессе восстановления, вместо записи новой контрольной точки
производится точка перезапуска (см. Раздел 30.4).
Выполнять CHECKPOINT могут только суперпользователи.
Совместимость
Команда CHECKPOINT является языковым расширением PostgreSQL.
1402CLOSE
CLOSE — закрыть курсор
Синтаксис
CLOSE ( имя | ALL )
Описание
CLOSE освобождает ресурсы, связанные с открытым курсором. Когда курсор закрыт, никакие опе-
рации с ним невозможны. Закрывать курсор следует, когда он становится ненужным.
Все не удерживаемые открытые курсоры закрываются неявно при завершении транзакции коман-
дами COMMIT или ROLLBACK. Удерживаемый курсор закрывается неявно, если транзакция, его со-
здавшая, прерывается командой ROLLBACK. Если создавшая его транзакция завершается успешной
фиксацией, удерживаемый курсор остаётся открытым до явного вызова команды CLOSE или отклю-
чения клиента.
Параметры
имя
Имя открытого курсора, который будет закрыт.
ALL
Закрывает все открытые курсоры.
Замечания
В PostgreSQL нет явной команды OPEN для курсора; курсор считается открытым при объявлении.
Чтобы объявить курсор, используйте оператор DECLARE.
Получить список всех доступных курсоров можно, обратившись к системному представлению
pg_cursors.
Если курсор был закрыт после точки сохранения, а затем произошёл откат к этой точке, действие
команды CLOSE не отменяется; то есть курсор остаётся закрытым.
Примеры
Следующая команда закрывает курсор liahona:
CLOSE liahona;
Совместимость
Оператор CLOSE полностью соответствует стандарту SQL. CLOSE
PostgreSQL.
См. также
DECLARE, FETCH, MOVE
1403
ALL является расширениемCLUSTER
CLUSTER — кластеризовать таблицу согласно индексу
Синтаксис
CLUSTER [VERBOSE] имя_таблицы [ USING имя_индекса ]
CLUSTER [VERBOSE]
Описание
Оператор CLUSTER указывает PostgreSQL кластеризовать таблицу, заданную параметром имя_таб-
лицы, согласно индексу, заданному параметром имя_индекса. Указанный индекс уже должен быть
определён в таблице имя_таблицы.
В результате кластеризации таблицы её содержимое физически переупорядочивается в зависимо-
сти от индекса. Кластеризация является одноразовой операцией: последующие изменения в таб-
лице нарушают порядок кластеризации. Другими словами, система не пытается автоматически
сохранять порядок новых или изменённых строк в соответствии с индексом. (Если такое желание
возникает, можно периодически повторять кластеризацию, выполняя команду снова. Кроме того,
если для заданной таблицы установить параметр FILLFACTOR меньше 100%, это может помочь со-
хранить порядок кластеризации при изменениях, так как изменяемые строки будут помещаться в
ту же страницу, если в ней достаточно места.)
Когда таблица кластеризована, PostgreSQL запоминает, по какому именно индексу. Форма CLUSTER
имя_таблицы повторно кластеризует таблицу по тому же индексу. Для установки индекса, который
будет использоваться для будущих операций кластеризации, или очистки предыдущего значения
можно также применить команду CLUSTER или формы SET WITHOUT CLUSTER команды ALTER TABLE.
CLUSTER без параметров повторно кластеризует все ранее кластеризованные таблицы в текущей
базе данных, принадлежащие пользователю, вызывающему команду, или все такие таблицы, если
её вызывает суперпользователь. Эту форму CLUSTER нельзя выполнять внутри блока транзакции.
В процессе кластеризации таблицы для неё запрашивается блокировка ACCESS EXCLUSIVE. Это пре-
пятствует выполнению всех других операций (чтению и записи) с таблицей до завершения CLUSTER.
Параметры
имя_таблицы
Имя таблицы (возможно, дополненное схемой).
имя_индекса
Имя индекса.
VERBOSE
Выводит отчёт о процессе кластеризации по мере обработки таблиц.
Замечания
В случаях, когда происходит обращение к случайным единичным строкам таблицы, фактический
порядок данных в этой таблице не важен. Но если обращения к одним данным происходят чаще,
чем к другим, и есть индекс, который собирает их вместе, применение команды CLUSTER может
быть полезным. Например, когда из таблицы запрашивается диапазон индексированных значе-
ний, либо одно индексированное значение, которому соответствуют несколько строк, CLUSTER мо-
жет помочь, так как страница таблицы, найденная по индексу для первой искомой строки, скорее
всего, будет содержать и все остальные искомые строки. Таким образом, кластеризация помогает
соптимизировать обращения к диску и ускорить запросы.
1404CLUSTER
CLUSTER может переупорядочить таблицу, выполнив либо сканирование указанного индекса, либо
(для индексов-B-деревьев) последовательное сканирование, а затем сортировку. Наилучший по
скорости вариант будет выбран, исходя из имеющейся статистической информации и параметров
планировщика.
Когда выбирается сканирование индекса, создаётся временная таблица, содержащая данные це-
левой таблицы по порядку индекса. Также создаются копии всех индексов таблицы. Таким обра-
зом, для этой операции требуется объём дискового пространства не меньше, чем размер таблицы
и индексов в сумме.
В случае выбора последовательного сканирования и сортировки создаётся ещё и временный файл
для сортировки, так что пиковым требованием будет удвоенный размер таблицы плюс размер ин-
дексов. Этот метод часто быстрее, чем сканирование по индексу, но если требование к дисковому
пространству неприемлемо, можно отключить его выбор, временно установив enable_sort в off.
Перед кластеризацией рекомендуется установить в maintenance_work_mem достаточно большое
значение (но не больше, чем объём ОЗУ, который вы хотите выделить для операции CLUSTER).
Так как планировщик записывает статистику, связанную с порядком таблиц, для вновь кластери-
зуемых таблиц рекомендуется запускать ANALYZE. В противном случае планировщик может оши-
биться с выбором плана запроса.
Так как CLUSTER запоминает, по каким индексам кластеризованы таблицы, достаточно лишь один
раз вручную кластеризовать нужные таблицы, а затем настроить периодический скрипт обслужи-
вания, который будет выполнять CLUSTER без параметров, с тем чтобы эти таблицы регулярно кла-
стеризовались.
Примеры
Кластеризация таблицы employees согласно её индексу employees_ind:
CLUSTER employees USING employees_ind;
Кластеризация таблицы employees согласно тому же индексу, что был использован ранее:
CLUSTER employees;
Кластеризация всех таблиц в базе данных, что были кластеризованы ранее:
CLUSTER;
Совместимость
Оператор CLUSTER отсутствует в стандарте SQL.
Синтаксис
CLUSTER имя_индекса ON имя_таблицы
так же является допустимым для совместимости с PostgreSQL до версии 8.3.
См. также
clusterdb
1405COMMENT
COMMENT — задать или изменить комментарий объекта
Синтаксис
COMMENT ON
(
ACCESS METHOD имя_объекта |
AGGREGATE имя_агрегатной_функции ( сигнатура_агр_функции ) |
CAST (исходный_тип AS целевой_тип) |
COLLATION имя_объекта |
COLUMN имя_отношения.имя_столбца |
CONSTRAINT имя_ограничения ON имя_таблицы |
CONSTRAINT имя_ограничения ON DOMAIN имя_домена |
CONVERSION имя_объекта |
DATABASE имя_объекта |
DOMAIN имя_объекта |
EXTENSION имя_объекта |
EVENT TRIGGER имя_объекта |
FOREIGN DATA WRAPPER имя_объекта |
FOREIGN TABLE имя_объекта |
FUNCTION имя_функции [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
INDEX имя_объекта |
LARGE OBJECT oid_большого_объекта |
MATERIALIZED VIEW имя_объекта |
OPERATOR имя_оператора (тип_слева, тип_справа) |
OPERATOR CLASS имя_объекта USING метод_индекса |
OPERATOR FAMILY имя_объекта USING метод_индекса |
POLICY имя_политики ON имя_таблицы |
[ PROCEDURAL ] LANGUAGE имя_объекта |
PROCEDURE имя_процедуры [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
PUBLICATION имя_объекта |
ROLE имя_объекта |
ROUTINE имя_подпрограммы [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
RULE имя_правила ON имя_таблицы |
SCHEMA имя_объекта |
SEQUENCE имя_объекта |
SERVER имя_объекта |
STATISTICS имя_объекта |
SUBSCRIPTION имя_объекта |
TABLE имя_объекта |
TABLESPACE имя_объекта |
TEXT SEARCH CONFIGURATION имя_объекта |
TEXT SEARCH DICTIONARY имя_объекта |
TEXT SEARCH PARSER имя_объекта |
TEXT SEARCH TEMPLATE имя_объекта |
TRANSFORM FOR имя_типа LANGUAGE имя_языка |
TRIGGER имя_триггера ON имя_таблицы |
TYPE имя_объекта |
VIEW имя_объекта
) IS ‘текст’
Здесь сигнатура_агр_функции:
1406COMMENT</li>
  <li>|
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] |
[ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] ] ORDER BY
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ]
Описание
COMMENT сохраняет комментарий об объекте базы данных.
Для каждого объекта сохраняется только одна строка, так что для изменения комментария нужно
просто выполнить COMMENT ещё раз для того же объекта. Чтобы удалить комментарий, вместо тек-
стовой строки укажите NULL. При удалении объектов комментарии удаляются автоматически.
Для большинства типов объектов комментарий может установить только владелец объекта. Но
так как роли не имеют владельцев, COMMENT ON ROLE для ролей суперпользователей разрешено
выполнять только суперпользователям, а для обычных ролей — тем, кто имеет право CREATEROLE.
Так же не имеют владельцев и методы доступа; чтобы добавить комментарий для метода доступа,
нужно быть суперпользователем. Разумеется, суперпользователи могут задавать комментарии для
любых объектов.
Просмотреть комментарии можно в psql, используя семейство команд \d. Имеется возможность
получать комментарии и в других пользовательских интерфейсах, используя те же встроенные
функции, что использует psql, а именно obj_description, col_description и shobj_description
(см. Таблицу 9.68).
Параметры
имя_объекта
имя_отношения.имя_столбца
имя_агрегатной_функции
имя_ограничения
имя_функции
имя_оператора
имя_политики
имя_процедуры
имя_подпрограммы
имя_правила
имя_триггера
Имя объекта, для которого задаётся комментарий. Имена таблиц, агрегатных функций, правил
сортировки, перекодировок, доменов, сторонних таблиц, функций, индексов, операторов, клас-
сов и семейств операторов, процедур, последовательностей, подпрограмм, объектов текстового
поиска и статистики, типов и представлений могут быть дополнены именем схемы. При опре-
делении комментария для столбца, имя_отношения должно ссылаться на таблицу, представле-
ние, составной тип или стороннюю таблицу.
имя_таблицы
имя_домена
При создании комментария для ограничения, триггера, правила или политики эти параметры
задают имя таблицы или домена, к которым относится этот объект.
исходный_тип
Имя исходного типа данных для приведения.
целевой_тип
Имя целевого типа данных для приведения.
1407COMMENT
режим_аргумента
Режим аргумента функции, процедуры или агрегата: IN, OUT, INOUT или VARIADIC. По умолча-
нию подразумевается IN. Заметьте, что COMMENT не учитывает аргументы OUT, так как для иден-
тификации функции нужны только типы входных аргументов. Поэтому достаточно перечислить
только аргументы IN, INOUT и VARIADIC.
имя_аргумента
Имя аргумента функции, процедуры или агрегата. Заметьте, что на самом деле COMMENT не об-
ращает внимание на имена аргументов, так как для однозначной идентификации функции до-
статочно только типов аргументов.
тип_аргумента
Тип данных аргумента функции, процедуры или агрегата.
oid_большого_объекта
OID большого объекта.
тип_слева
тип_справа
Тип данных аргументов оператора (возможно, дополненный именем схемы). В случае отсут-
ствия аргумента префиксного или постфиксного оператора укажите вместо типа NONE.
PROCEDURAL
Это слово не несёт смысловой нагрузки.
имя_типа
Имя типа данных, для которого предназначена трансформация.
имя_языка
Имя языка, для которого предназначена трансформация.
текст
Новый комментарий, записанный в виде строковой константы (или NULL для удаления коммен-
тария).
Замечания
В настоящее время механизм безопасности в части просмотра комментариев отсутствует: любой
пользователь, подключённый к базе данных, может видеть все комментарии всех объектов базы.
Для общих объектов, таких как базы данных, роли и табличные пространства, комментарии хра-
нятся глобально, так что их может видеть любой пользователь, подключённый к любой базе дан-
ных в кластере. Поэтому ничего секретного писать в комментариях не следует.
Примеры
Добавление комментария для таблицы mytable:
COMMENT ON TABLE mytable IS ‘Это моя таблица.’;
Удаление его:
COMMENT ON TABLE mytable IS NULL;
Ещё несколько примеров:
COMMENT ON ACCESS METHOD rtree IS ‘Метод доступа R-Tree’;
COMMENT ON AGGREGATE my_aggregate (double precision) IS ‘Вычисляет дисперсию выборки’;
1408COMMENT
COMMENT ON CAST (text AS int4) IS ‘Выполняет приведение строк к int4’;
COMMENT ON COLLATION “fr_CA” IS ‘Канадский французский’;
COMMENT ON COLUMN my_table.my_column IS ‘Порядковый номер сотрудника’;
COMMENT ON CONVERSION my_conv IS ‘Перекодировка в UTF8’;
COMMENT ON CONSTRAINT bar_col_cons ON bar IS ‘Ограничение столбца col’;
COMMENT ON CONSTRAINT dom_col_constr ON DOMAIN dom IS ‘Ограничение col для домена’;
COMMENT ON DATABASE my_database IS ‘База данных разработчиков’;
COMMENT ON DOMAIN my_domain IS ‘Домен почтового адреса’;
COMMENT ON EXTENSION hstore IS ‘Реализует тип данных hstore’;
COMMENT ON FOREIGN DATA WRAPPER mywrapper IS ‘Моя обёртка сторонних данных’;
COMMENT ON FOREIGN TABLE my_foreign_table IS ‘Информация о сотрудниках в другой БД’;
COMMENT ON FUNCTION my_function (timestamp) IS ‘Возвращает число римскими цифрами’;
COMMENT ON INDEX my_index IS ‘Обеспечивает уникальность по коду сотрудника’;
COMMENT ON LANGUAGE plpython IS ‘Поддержка Python для хранимых процедур’;
COMMENT ON LARGE OBJECT 346344 IS ‘Документ планирования’;
COMMENT ON MATERIALIZED VIEW my_matview IS ‘Сводка истории заказов’;
COMMENT ON OPERATOR ^ (text, text) IS ‘Вычисляет пересечение двух текстов’;
COMMENT ON OPERATOR - (NONE, integer) IS ‘Унарный минус’;
COMMENT ON OPERATOR CLASS int4ops USING btree IS ‘Операторы для четырёхбайтовых целых
(для B-деревьев)’;
COMMENT ON OPERATOR FAMILY integer_ops USING btree IS ‘Все целочисленные операторы (для
B-деревьев)’;
COMMENT ON POLICY my_policy ON mytable IS ‘Фильтр строк по пользователям’;
COMMENT ON PROCEDURE my_proc (integer, integer) IS ‘Строит отчёт’;
COMMENT ON ROLE my_role IS ‘Административная группа для таблиц бухгалтерии’;
COMMENT ON RULE my_rule ON my_table IS ‘Протоколирует изменения в записях сотрудников’;
COMMENT ON SCHEMA my_schema IS ‘Данные отдела’;
COMMENT ON SEQUENCE my_sequence IS ‘Предназначена для генерации первичных ключей’;
COMMENT ON SERVER myserver IS ‘Мой сторонний сервер’;
COMMENT ON STATISTICS my_statistics IS ‘Улучшает оценку числа строк для планировщика’;
COMMENT ON TABLE my_schema.my_table IS ‘Данные сотрудников’;
COMMENT ON TABLESPACE my_tablespace IS ‘Табличное пространство для индексов’;
COMMENT ON TEXT SEARCH CONFIGURATION my_config IS ‘Фильтрация специальных слов’;
COMMENT ON TEXT SEARCH DICTIONARY swedish IS ‘Стеммер Snowball для шведского языка’;
COMMENT ON TEXT SEARCH PARSER my_parser IS ‘Разделяет текст на слова’;
COMMENT ON TEXT SEARCH TEMPLATE snowball IS ‘Стеммер Snowball’;
COMMENT ON TRANSFORM FOR hstore LANGUAGE plpythonu IS ‘Трансформирует данные из hstore
в словарь языка Python’;
COMMENT ON TRIGGER my_trigger ON my_table IS ‘Обеспечивает ссылочную целостность’;
COMMENT ON TYPE complex IS ‘Тип данных комплексных чисел’;
COMMENT ON VIEW my_view IS ‘Представление расходов по отделам’;
Совместимость
Оператор COMMENT отсутствует в стандарте SQL.
1409COMMIT
COMMIT — зафиксировать текущую транзакцию
Синтаксис
COMMIT [ WORK | TRANSACTION ]
Описание
COMMIT фиксирует текущую транзакцию. Все изменения, произведённые транзакцией, становятся
видимыми для других и гарантированно сохранятся в случае сбоя.
Параметры
WORK
TRANSACTION
Необязательные ключевые слова, не оказывают никакого влияния.
Замечания
Для прерывания транзакции используйте ROLLBACK.
При попытке выполнить COMMIT вне транзакции ничего не произойдёт, но будет выдано предупре-
ждение.
Примеры
Следующая команда фиксирует текущую транзакцию и сохраняет все изменения:
COMMIT;
Совместимость
В стандарте SQL описаны только две формы: COMMIT и COMMIT WORK. В остальном эта команда пол-
ностью соответствует стандарту.
См. также
BEGIN, ROLLBACK
1410COMMIT PREPARED
COMMIT PREPARED — зафиксировать транзакцию, которая ранее была подготовлена для двухфаз-
ной фиксации
Синтаксис
COMMIT PREPARED id_транзакции
Описание
COMMIT PREPARED фиксирует транзакцию, находящуюся в подготовленном состоянии.
Параметры
id_транзакции
Идентификатор транзакции, которая будет зафиксирована.
Замечания
Зафиксировать подготовленную транзакцию может либо пользователь, выполнявший её изначаль-
но, либо суперпользователь. При этом не обязательно работать в том же сеансе, где выполнялась
транзакция.
Эту команду нельзя выполнить внутри блока транзакции. Подготовленная транзакция фиксирует-
ся немедленно.
Все существующие в текущий момент подготовленные транзакции показываются в системном
представлении pg_prepared_xacts.
Примеры
Фиксация транзакции, имеющей идентификатор foobar:
COMMIT PREPARED ‘foobar’;
Совместимость
Оператор COMMIT PREPARED является расширением PostgreSQL. Он предназначен для использова-
ния внешними системами управления транзакциями, некоторые из которых работают по стандар-
там (например, X/Open XA), но сторона SQL в этих системах не стандартизирована.
См. также
PREPARE TRANSACTION, ROLLBACK PREPARED
1411COPY
COPY — копировать данные между файлом и таблицей
Синтаксис
COPY имя_таблицы [ ( имя_столбца [, …] ) ]
FROM ( ‘имя_файла’ | PROGRAM ‘команда’ | STDIN )
[ [ WITH ] ( параметр [, …] ) ]
COPY ( имя_таблицы [ ( имя_столбца [, …] ) ] | ( запрос ) )
TO ( ‘имя_файла’ | PROGRAM ‘команда’ | STDOUT )
[ [ WITH ] ( параметр [, …] ) ]
Здесь допускается параметр:
FORMAT имя_формата
OIDS [ boolean ]
FREEZE [ boolean ]
DELIMITER ‘символ_разделитель’
NULL ‘маркер_NULL’
HEADER [ boolean ]
QUOTE ‘символ_кавычек’
ESCAPE ‘символ_экранирования’
FORCE_QUOTE ( ( имя_столбца [, …] ) | * )
FORCE_NOT_NULL ( имя_столбца [, …] )
FORCE_NULL ( имя_столбца [, …] )
ENCODING ‘имя_кодировки’
Описание
COPY перемещает данные между таблицами PostgreSQL и обычными файлами в файловой системе.
COPY TO копирует содержимое таблицы в файл, а COPY FROM — из файла в таблицу (добавляет
данные к тем, что уже содержались в таблице). COPY TO может также скопировать результаты
запроса SELECT.
Если указывается список столбцов, COPY скопирует только данные указанных столбцов. Если в
таблице есть столбцы, отсутствующие в этом списке, COPY FROM заполнит эти столбцы значениями
по умолчанию.
COPY с именем файла указывает серверу PostgreSQL читать или записывать непосредственно этот
файл. Заданный файл должен быть доступен пользователю PostgreSQL (тому пользователю, от име-
ни которого работает сервер), и путь к файлу должен задаваться с точки зрения сервера. Когда
указывается параметр PROGRAM, сервер выполняет заданную команду и читает данные из стандарт-
ного вывода программы, либо записывает их в стандартный ввод. Команда должна определяться
с точки зрения сервера и быть доступной для исполнения пользователю PostgreSQL. Когда указы-
вается STDIN или STDOUT, данные передаются через соединение клиента с сервером.
Параметры
имя_таблицы
Имя существующей таблицы (возможно, дополненное схемой).
имя_столбца
Необязательный список столбцов, данные которых будут копироваться. Если этот список от-
сутствует, копируются все столбцы таблицы.
1412COPY
запрос
Команда SELECT, VALUES, INSERT, UPDATE или DELETE, результаты которой будут скопиро-
ваны. Заметьте, что запрос должен заключаться в скобки.
Для запросов INSERT, UPDATE и DELETE должно задаваться предложение RETURNING и в целе-
вом отношении не должно быть условного правила, правила ALSO или правила INSTEAD, разво-
рачивающегося в несколько операторов.
имя_файла
Путь входного или выходного файла. Путь входного файла может быть абсолютным или относи-
тельным, но путь выходного должен быть только абсолютным. Пользователям Windows следует
использовать формат E’’ и продублировать каждую обратную черту в пути файла.
PROGRAM
Выполняемая команда. COPY FROM читает стандартный вывод команды, а COPY TO записывает
в её стандартный ввод.
Заметьте, что команда запускается через командную оболочку, так что если требуется пере-
дать этой команде какие-либо аргументы, поступающие из недоверенного источника, необхо-
димо аккуратно избавиться от всех спецсимволов, имеющих особое значение в оболочке, либо
экранировать их. По соображениям безопасности лучше ограничиться фиксированной строкой
команды или как минимум не позволять пользователям вводить в неё произвольное содержи-
мое.
STDIN
Указывает, что данные будут поступать из клиентского приложения.
STDOUT
Указывает, что данные будут выдаваться клиентскому приложению.
boolean
Включает или отключает заданный параметр. Для включения параметра можно написать TRUE,
ON или 1, а для отключения — FALSE, OFF или 0. Значение boolean можно опустить, в этом случае
подразумевается TRUE.
FORMAT
Выбирает формат чтения или записи данных: text (текстовый), csv (значения, разделённые
запятыми, Comma Separated Values) или binary (двоичный). По умолчанию выбирается формат
text.
OIDS
Копирует OID каждой строки. (Если присутствует указание OIDS, но таблица не содержит стол-
бец oid, либо копируется запрос, возникнет ошибка.)
FREEZE
Запросы копируют данные с уже замороженными строками, как после выполнения команды
VACUUM FREEZE. Это позволяет увеличить производительность при начальном добавлении дан-
ных. Строки будут замораживаться, только если загружаемая таблица была создана или опу-
стошена в текущей подтранзакции, с ней не связаны открытые курсоры и в данной транзакции
нет других снимков.
Заметьте, что все другие сеансы будут немедленно видеть данные, как только они будут успеш-
но загружены. Это нарушает принятые правила видимости MVCC, так что пользователи, вклю-
чающие этот режим, должны понимать, какие проблемы это может вызвать.
1413COPY
DELIMITER
Задаёт символ, разделяющий столбцы в строках файла. По умолчанию это символ табуляции в
текстовом формате и запятая в формате CSV. Задаваемый символ должен быть однобайтовым.
Для формата binary этот параметр не допускается.
NULL
Определяет строку, задающую значение NULL. По умолчанию в текстовом формате это \N (об-
ратная косая черта и N), а в формате CSV — пустая строка без кавычек. Пустую строку можно
использовать и в текстовом формате, если не требуется различать пустые строки и NULL. Для
формата binary этот параметр не допускается.
Примечание
При выполнении COPY FROM любые значения, совпадающие с этой строкой, сохра-
няются как значение NULL, так что при переносе данных важно убедиться в том,
что это та же строка, что применялась в COPY TO.
HEADER
Указывает, что файл содержит строку заголовка с именами столбцов. При выводе первая стро-
ка файла будет содержать имена столбцов таблицы, а при вводе первая строка просто игнори-
руется. Этот параметр допускается только для формата CSV.
QUOTE
Указывает символ кавычек, используемый для заключения данных в кавычки. По умолчанию
это символ двойных кавычек. Задаваемый символ должен быть однобайтовым. Этот параметр
поддерживается только для формата CSV.
ESCAPE
Задаёт символ, который будет выводиться перед символом данных, совпавшим со значением
QUOTE. По умолчанию это тот же символ, что и QUOTE (то есть, при появлении в данных кавычек,
они дублируются). Задаваемый символ должен быть однобайтовым. Этот параметр допускается
только для режима CSV.
FORCE_QUOTE
Принудительно заключает в кавычки все значения не NULL в указанных столбцах. Выводимое
значение NULL никогда не заключается в кавычки. Если указано *, в кавычки будут заключаться
значения не NULL во всех столбцах. Этот параметр принимает только команда COPY TO и только
для формата CSV.
FORCE_NOT_NULL
Не сопоставлять значения в указанных столбцах с маркером NULL. По умолчанию, когда мар-
кер пуст, это означает, что пустые значения будут считаны как строки нулевой длины, а не
NULL, даже когда они не заключены в кавычки. Этот параметр допускается только в команде
COPY FROM и только для формата CSV.
FORCE_NULL
Сопоставлять значения в указанных столбцах с маркером NULL, даже если они заключены в
кавычки, и в случае совпадения устанавливать значение NULL. По умолчанию, когда этот мар-
кер пуст, пустая строка в кавычках будет преобразовываться в NULL. Этот параметр допуска-
ется только в команде COPY FROM и только для формата CSV.
ENCODING
Указывает, что файл имеет кодировку имя_кодировки. Если этот параметр опущен, выбирается
текущая кодировка клиента. Подробнее об этом говорится ниже, в примечаниях.
1414COPY
Выводимая информация
В случае успешного завершения, COPY возвращает метку команды в виде
COPY число
Здесь число — количество скопированных записей.
Примечание
psql выводит эту метку, только если выполнялась не команда COPY … TO STDOUT или
её аналог в psql, метакоманда \copy … to stdout. Это сделано для того, чтобы метка
команды не смешалась с данными, выведенными перед ней.
Замечания
COPY TO может использоваться только с обычными таблицами, но не с представлениями. Одна-
ко вы можете скопировать текущее содержимое представления, записав COPY (SELECT * FROM
имя_представления) TO ….
COPY FROM можно применять с обычными, сторонними и секционированными таблицами или пред-
ставлениями, в которых установлены триггеры INSTEAD OF INSERT.
COPY обрабатывает только явно заданную таблицу, дочерние таблицы при копировании данных не
затрагиваются. Поэтому, например COPY таблица TO выводит те же данные, что и запрос SELECT</li>
  <li>FROM ONLY table. Для выгрузки всех данных в иерархии наследования можно применить COPY
(SELECT * FROM table) TO ….
В таблице, данные которой читает команда COPY TO, требуется иметь право на выборку данных, а
в таблице, куда вставляет значения COPY FROM, требуется право на добавление. При этом, если в
команде перечисляются избранные столбцы, достаточно иметь права только для них.
Если для таблицы включена защита на уровне строк, соответствующие политики SELECT будут
применяться и к операторам COPY таблица TO. Операторы COPY FROM для таблиц с защитой строк в
настоящее время не поддерживаются. Вместо них следует использовать равнозначные операторы
INSERT.
Файлы, указанные в команде COPY, читаются или записываются непосредственно сервером, не кли-
ентским приложением. Поэтому они должны располагаться на сервере или быть доступными сер-
веру, а не клиенту. Они должны быть доступны на чтение или запись пользователю PostgreSQL
(пользователю, от имени которого работает сервер), не клиенту. Аналогично, команда, указанная
параметром PROGRAM, выполняется непосредственно сервером, а не клиентским приложением, и
должна быть доступна на выполнение пользователю PostgreSQL. Выполнять COPY с указанием фай-
ла или внешней команды разрешено только суперпользователям базы данных или членам встро-
енных ролей pg_read_server_files, pg_write_server_files или pg_execute_server_program, так
как это позволяет читать/записывать любые файлы и запускать любые программы, к которым име-
ет доступ сервер.
Не путайте команду COPY с реализованной в psql метакомандой \copy. Метакоманда \copy вызы-
вает COPY FROM STDIN или COPY TO STDOUT, а затем работает с данными в файле, доступном кли-
енту psql. Таким образом, когда применяется команда \copy, доступность файла и права доступа
зависят от клиента, а не от сервера.
Путь файла, указываемый в COPY, рекомендуется всегда задавать как абсолютный, а не относи-
тельный. Это обязательное условие для команды COPY TO, но COPY FROM позволяет прочитать файл,
заданный и относительным путём. Такой путь будет интерпретироваться относительно рабочего
каталога серверного процесса (обычно это каталог данных кластера), а не рабочего каталога кли-
ента.
1415COPY
Выполнение команды в PROGRAM может быть ограничено и другими работающими в ОС механизма-
ми контроля доступа, например SELinux.
COPY FROM вызывает все триггеры и обрабатывает все ограничения-проверки в целевой таблице.
Однако правила при загрузке данных не вызываются.
Для столбцов идентификации команда COPY FROM всегда переносит значения, содержащиеся во
входных данных, как команда INSERT с указанием OVERRIDING SYSTEM VALUE.
При вводе и выводе данных COPY учитывается DateStyle. Для обеспечения переносимости на дру-
гие инсталляции PostgreSQL, в которых могут использоваться нестандартные значения DateStyle,
значение DateStyle следует установить равным ISO до вызова COPY TO. Также рекомендуется
не выгружать данные с IntervalStyle равным sql_standard, так как сервер с другим значением
IntervalStyle может неправильно воспринимать отрицательные интервалы в таких данных.
Входные данные интерпретируются согласно кодировке, заданной параметром ENCODING, или те-
кущей кодировке клиента, а выходные кодируются в кодировке ENCODING или текущей кодировке
клиента, даже если данные не проходят через клиента, а считываются или записываются в файл
непосредственно сервером.
COPY прекращает операцию при первой ошибке. Это не должно приводить к проблемам в случае
с COPY TO, но после COPY FROM в целевой таблице остаются ранее полученные строки. Эти строки
не будут видимыми и доступными, но будут занимать место на диске. Если сбой происходит при
копировании большого объёма данных, это может приводить к значительным потерям дискового
пространства. При желании вернуть потерянный объём, это можно сделать с помощью команды
VACUUM.
FORCE_NULL и FORCE_NOT_NULL можно применить одновременно к одному столбцу. В результате
NULL-значения в кавычках будут преобразованы в NULL, а NULL-значения без кавычек — в пу-
стые строки.
Форматы файлов
Текстовый формат
Когда применяется формат text, читаемые или записываемые данные представляют собой тек-
стовый файл, строка в котором соответствует строке таблицы. Столбцы в строке разделяются сим-
волом-разделителем. Значения самих столбцов — строки, выдаваемые функцией вывода, либо вос-
принимаемые функцией ввода, соответствующей типу данных столбца. Заданный маркер NULL
выводится и считывается вместо столбцов со значением NULL. COPY FROM выдаёт ошибку, если в
любой из строк во входном файле оказывается больше или меньше столбцов, чем ожидается. С
указанием OIDS значение OID считывается или записывается в первом столбце, предшествующем
столбцам с основными данными.
Конец данных может обозначаться одной строкой, содержащей только обратную косую и точку
(.). Маркер конца данных не требуется при чтении из файла, так как его роль вполне выполняет
конец файла; он необходим только при передаче данных в/из клиентского приложения по прото-
колу обмена до версии 3.0.
Символы обратной косой черты () в данных COPY позволяют экранировать символы данных, кото-
рые без них считались бы разделителями строк или столбцов. В частности, предваряться обратной
косой должны следующие символы, когда они оказываются в значении столбца: сама обратная
косая черта, перевод строки, возврат каретки и текущий разделитель.
Маркер NULL передаётся команде COPY TO как есть, без добавления обратной косой; COPY FROM,
со своей стороны, ищет во вводимых данных маркеры NULL до удаления обратных косых. Таким
образом, маркер NULL, например такой как \N, отличается от значения \N в данных (оно должно
представляться в виде \N).
Команда COPY FROM распознаёт следующие спецпоследовательности:
1416COPY
Последовательность Представляет
\b Забой (ASCII 8)
\f Подача формы (ASCII 12)
\n Новая строка (ASCII 10)
\r Возврат каретки (ASCII 13)
\t Табуляция (ASCII 9)
\v Вертикальная табуляция (ASCII 11)
\цифры Обратная косая с последующими 1-3 восьмерич-
ными цифрами представляет символ с заданным
числовым кодом
\xцифры Обратная косая с последующим x и 1-2 шестна-
дцатеричными цифрами представляет символ с
заданным числовым кодом
В настоящее время COPY TO никогда не выводит спецпоследовательности с восьмеричными или
шестнадцатеричными кодами, однако выводит другие вышеперечисленные спецпоследовательно-
сти вместо управляющих символов.
Любой другой символ после обратной косой, отсутствующий в приведённой выше таблице, будет
представлять себя. Однако опасайтесь излишнего добавления обратных косых, так как это может
привести к случайному образованию строки, обозначающей маркер конца данных (.) или маркер
NULL (\N по умолчанию). Эти строки будут восприняты прежде, чем обработаются спецпоследо-
вательности с обратной косой.
В приложениях, генерирующих данные для COPY, настоятельно рекомендуется преобразовать сим-
волы новой строки и возврата каретки в последовательности \n и \r, соответственно. В настоящее
время можно представить возврат каретки в данных как обратная косая и возврат каретки, а пере-
вод строки как обратная косая и перевод строки, однако это может не поддерживаться в будущих
версиях. Такие символы также подвержены искажениям, если файл с выводом COPY переносится
между разными системами (например, с Unix в Windows и наоборот).
COPY TO завершает каждую строку символом новой строки в стиле Unix («\n»). Серверы, работаю-
щие в Microsoft Windows, вместо этого выводят символы возврат каретки/новая строка («\r\n»),
но только при выводе COPY в файл на сервере; для согласованности на разных платформах, COPY
TO STDOUT всегда передаёт «\n», вне зависимости от платформы сервера. COPY FROM может воспри-
нимать строки, завершающиеся символами новая строка, перевод каретки, либо возврат карет-
ки+новая строка. Чтобы уменьшить риск ошибки из-за неэкранированных символов новой строки
и возврата каретки, которые должны были быть данными, COPY FROM сигнализирует о проблеме,
если концы строк во входных данных различаются.
Формат CSV
Этот формат применяется для импорта и экспорта данных в виде списка значений, разделённых
запятыми (CSV), с которым могут работать многие другие программы, например электронные таб-
лицы. Вместо правил экранирования значений, введённых в PostgreSQL для текстового формата,
этот формат использует стандартный механизм экранирования CSV.
Значения в каждой записи разделяются символами DELIMITER. Если значение содержит символ
разделителя, символ QUOTE, маркер NULL, символ возврата каретки или перевода строки, то всё
значение дополнятся спереди и сзади символами QUOTE, а любое вхождение символа QUOTE или
спецсимвола (ESCAPE) в данных предваряется спецсимволом. С указанием FORCE_QUOTE в кавычки
будут принудительно заключаться любые значения не NULL в указанных столбцах.
В формате CSV отсутствует стандартный способ отличить значение NULL от пустой строки. В
PostgreSQL команда COPY решает это с помощью кавычек. Значение NULL выводится в виде строки,
задаваемой параметром NULL, и не заключается в кавычки, тогда как значение не NULL, со строкой,
1417COPY
задаваемой параметром NULL, заключается. Например, с параметрами по умолчанию NULL записы-
вается в виде пустой строки без кавычек, тогда как пустая строка записывается в двойных кавыч-
ках (“”). При чтении значений действуют похожие правила. Указание FORCE_NOT_NULL позволяет
избежать сравнений на NULL во входных данных в заданных столбцах, а FORCE_NULL — преобразо-
вывать в NULL маркеры NULL, даже заключённые в кавычки.
Так как обратная косая черта не является спецсимволом в формате CSV, маркер конца данных .
может быть и значением данных. Во избежание ошибок интерпретации данные ., выводимые в
виде единственного элемента строки, автоматически заключаются в кавычки при выводе, а при
вводе этот маркер, заключённый в кавычки, не воспринимается как маркер конца данных. При
загрузке файла, созданного другой программой, в котором в единственном столбце без кавычек
оказалось значение ., потребуется дополнительно заключить это значение в кавычки.
Примечание
В формате CSV все символы являются значимыми. Заключённое в кавычки значе-
ние, дополненное пробелами или любыми другими символами, кроме DELIMITER, будет
включать и эти символы. Это может приводить к ошибкам при импорте данных из си-
стемы, дополняющей строки CSV пробельными символами до некоторой фиксирован-
ной ширины. В случае возникновения такой проблемы необходимо обработать файл
CSV и удалить из него замыкающие пробельные символы, прежде чем загружать дан-
ные из него в PostgreSQL.
Примечание
Обработчик формата CSV воспринимает и генерирует файлы CSV со значениями в ка-
вычках, которые могут содержать символы возврата каретки и перевода строки. Таким
образом, число строк в этих файлах не строго равно числу строк в таблице, как в фай-
лах текстового формата.
Примечание
Многие программы генерируют странные и иногда неприемлемые файлы CSV, так что
этот формат используется скорее по соглашению, чем по стандарту. Поэтому вам могут
встретиться файлы, которые невозможно импортировать, используя этот механизм, а
COPY может сформировать такие файлы, что их не смогут обработать другие програм-
мы.
Двоичный формат
При выборе формата binary все данные сохраняются/считываются в двоичном, а не текстовом
виде. Иногда этот формат обрабатывается быстрее, чем текстовый и CSV, но он может оказаться
непереносимым между разными машинными архитектурами и версиями PostgreSQL. Кроме того,
двоичный формат сильно зависит от типов данных; например, он не позволяет вывести данные из
столбца smallint, а затем прочитать их в столбец integer, хотя с текстовым форматом это вполне
возможно.
Формат binary включает заголовок файла, ноль или более записей, содержащих данные строк, и
окончание файла. Для заголовков и данных принят сетевой порядок байт.
Примечание
В PostgreSQL до версии 7.4 использовался другой двоичный формат.
1418COPY
Заголовок файла
Заголовок файла содержит 15 байт фиксированных полей, за которыми следует область расшире-
ния заголовка переменной длины. Фиксированные поля:
Сигнатура
Последовательность из 11 байт PGCOPY\n\377\r\n\0 — заметьте, что нулевой байт является
обязательной частью сигнатуры. (Эта сигнатура позволяет легко выявить файлы, испорченные
при передаче, не сохраняющей все 8 бит данных. Она изменится при прохождении через филь-
тры, меняющие концы строк, отбрасывающие нулевые байты или старшие биты, либо добавля-
ющие чётность.)
Поле флагов
Маска из 32 бит, обозначающая важные аспекты формата файла. Биты нумеруются от 0 (LSB)
до 31 (MSB). Учтите, что это поле хранится в сетевом порядке байт (наиболее значащий байт
первый), как и все целочисленные поля в этом формате. Биты 16-31 зарезервированы для обо-
значения критичных особенностей формата; обработчик должен прервать чтение, встретив лю-
бой неожиданный бит в этом диапазоне. Биты 0-15 зарезервированы для обозначения особен-
ностей, связанных с обратной совместимостью; обработчик может просто игнорировать любые
неожиданные биты в этом диапазоне. В настоящее время определён только один битовый флаг,
остальные должны быть равны 0:
Бит 16
При 1 в данные включается OID; при 0 — нет
Длина области расширения заголовка
Целое 32-битное число, определяющее длину в байтах остального заголовка, не включая само
это значение. В настоящее время содержит 0, и сразу за ним следует первая запись. При бу-
дущих изменениях формата в заголовок могут быть добавлены дополнительные данные. Обра-
ботчик должен просто пропускать все расширенные данные заголовка, о которых ему ничего
не известно.
Область расширения заголовка предусмотрена для размещения последовательности самоопреде-
ляемых блоков. Поле флагов не должно содержать указаний о том, что содержится в области рас-
ширения. Точное содержимое области расширения может быть определено в будущих версиях.
При таком подходе возможно как обратно-совместимое дополнение заголовка (добавить блоки рас-
ширения заголовка или установить младшие биты флагов), так и не обратно-совместимое (устано-
вить старшие биты флагов, сигнализирующие о подобном изменении, и добавить вспомогательные
данные в область расширения, если это потребуется).
Записи
Каждая запись начинается с 16-битного целого числа, определяющего количество полей в записи.
(В настоящее время во всех записях должно быть одинаковое число полей, но так может быть не
всегда.) Затем, для каждого поля в записи указывается 32-битная длина поля, за которой следует
это количество байт с данными поля. (Значение длины не включает свой размер, и может быть
равно нулю.) В качестве особого варианта, -1 обозначает, что в поле содержится NULL. В случае
с NULL за длиной не следуют байты данных.
Выравнивание или какие-либо дополнительные данные между полями не вставляются.
В настоящее время предполагается, что все значения данных в файле двоичного формата содер-
жатся в двоичном формате (формате под кодом 1). Возможно, в будущем расширении в заголовок
будет добавлено поле, позволяющее задавать другие коды форматов для разных столбцов.
Чтобы определить подходящий двоичный формат для фактических данных, обратитесь к исходно-
му коду PostgreSQL, в частности, к функциям <em>send и *recv для типов данных каждого столбца
(обычно эти функции находятся в каталоге src/backend/utils/adt/ в дереве исходного кода).
1419COPY
Если в файл включается OID, поле OID следует немедленно за числом, определяющим количество
полей. Это поле не отличается от других ничем, кроме того, что оно не учитывается в количестве
полей. В частности, для него также задаётся длина — это позволяет обрабатывать и четырёх- и
восьмибайтовые OID без особых сложностей, и даже вывести OID, равный NULL, если возникнет
потребность в этом.
Окончание файла
Окончание файла состоит из 16-битного целого, содержащего -1. Это позволяет легко отличить
его от счётчика полей в записи.
Обработчик, читающий файл, должен выдать ошибку, если число полей в записи не равно -1 или
ожидаемому числу столбцов. Это обеспечивает дополнительную проверку синхронизации данных.
Примеры
В следующем примере таблица передаётся клиенту с разделителем полей «вертикальная чер-
та» (|):
COPY country TO STDOUT (DELIMITER ‘|’);
Копирование данных из файла в таблицу country:
COPY country FROM ‘/usr1/proj/bray/sql/country_data’;
Копирование в файл только данных стран, название которых начинается с ‘A’:
COPY (SELECT * FROM country WHERE country_name LIKE ‘A%’) TO ‘/usr1/proj/bray/sql/
a_list_countries.copy’;
Для копирования данных в сжатый файл можно направить вывод через внешнюю программу сжа-
тия:
COPY country TO PROGRAM ‘gzip &gt; /usr1/proj/bray/sql/country_data.gz’;
Пример данных, подходящих для копирования в таблицу из STDIN:
AF
AL
DZ
ZM
ZW
AFGHANISTAN
ALBANIA
ALGERIA
ZAMBIA
ZIMBABWE
Примечание: пробелы в каждой строке на самом деле обозначают символы табуляции.
Ниже приведены те же данные, но выведенные в двоичном формате. Данные показаны после об-
работки Unix-утилитой od -c. Таблица содержит три столбца; первый имеет тип char(2), второй
— text, а третий — integer. Последний столбец во всех строках содержит NULL.
0000000
P
G
C
O
P
0000020 \0 \0 \0 \0 003
0000040
F
G
H
A
N
0000060 \0 \0 \0 002
A
0000100
A 377 377 377 377
0000120 007
A
L
G
E
0000140 \0 002
Z
M \0
0000160 377 377 \0 003 \0
0000200
M
B
A
B
W
Y \n 377 \r \n \0 \0 \0 \0 \0 \0
\0 \0 \0 002
A
F \0 \0 \0 013
A
I
S
T
A
N 377 377 377 377 \0 003
L \0 \0 \0 007
A
L
B
A
N
I
\0 003 \0 \0 \0 002
D
Z \0 \0 \0
R
I
A 377 377 377 377 \0 003 \0 \0
\0 \0 006
Z
A
M
B
I
A 377 377
\0 \0 002
Z
W \0 \0 \0 \b
Z
I
E 377 377 377 377 377 377
Совместимость
Оператор COPY отсутствует в стандарте SQL.
До версии PostgreSQL 9.0 использовался и по-прежнему поддерживается следующий синтаксис:
1420COPY
COPY имя_таблицы [ ( имя_столбца [, …] ) ]
FROM ( ‘имя_файла’ | STDIN )
[ [ WITH ]
[ BINARY ]
[ OIDS ]
[ DELIMITER [ AS ] ‘разделитель’ ]
[ NULL [ AS ] ‘маркер_null’ ]
[ CSV [ HEADER ]
[ QUOTE [ AS ] ‘кавычки’ ]
[ ESCAPE [ AS ] ‘спецсимвол’ ]
[ FORCE NOT NULL имя_столбца [, …] ] ] ]
COPY ( имя_таблицы [ ( имя_столбца [, …] ) ] | ( запрос ) )
TO ( ‘имя_файла’ | STDOUT )
[ [ WITH ]
[ BINARY ]
[ OIDS ]
[ DELIMITER [ AS ] ‘разделитель’ ]
[ NULL [ AS ] ‘маркер_null’ ]
[ CSV [ HEADER ]
[ QUOTE [ AS ] ‘кавычки’ ]
[ ESCAPE [ AS ] ‘спецсимвол’ ]
[ FORCE QUOTE ( имя_столбца [, …] | * ) ] ] ]
Заметьте, что в этом синтаксисе ключевые слова BINARY и CSV обрабатываются как независимые,
а не как аргументы параметра FORMAT.
До версии PostgreSQL 7.3 использовался и по-прежнему поддерживается следующий синтаксис:
COPY [ BINARY ] table_name [ WITH OIDS ]
FROM ( ‘имя_файла’ | STDIN )
[ [USING] DELIMITERS ‘разделитель’ ]
[ WITH NULL AS ‘маркер_null’ ]
COPY [ BINARY ] имя_таблицы [ WITH OIDS ]
TO ( ‘имя_файла’ | STDOUT )
[ [USING] DELIMITERS ‘разделитель’ ]
[ WITH NULL AS ‘маркер_null’ ]
1421CREATE ACCESS METHOD
CREATE ACCESS METHOD — создать новый метод доступа
Синтаксис
CREATE ACCESS METHOD имя
TYPE тип_метода_доступа
HANDLER функция_обработчик
Описание
Команда CREATE ACCESS METHOD создаёт новый метод доступа.
Имя метода доступа должно быть уникальным в базе данных.
Определять новые методы доступа могут только суперпользователи.
Параметры
имя
Имя создаваемого метода доступа.
тип_метода_доступа
Это предложение задаёт тип создаваемого метода доступа. В настоящее время поддерживается
только INDEX.
функция_обработчик
В аргументе функция_обработчик указывается имя (возможно дополненное схемой) ранее заре-
гистрированной функции, представляющей метод доступа. Функция-обработчик должна при-
нимать один аргумент типа internal, а её тип возврата зависит от типа метода доступа; для
методов доступа типа INDEX это должен быть index_am_handler. Также от типа метода доступа
зависит API уровня C, который должна реализовывать эта функция-обработчик. API методов
доступа индексов описан в Главе 61.
Примеры
Создание метода доступа индекса heptree с функцией-обработчиком heptree_handler:
CREATE ACCESS METHOD heptree TYPE INDEX HANDLER heptree_handler;
Совместимость
CREATE ACCESS METHOD является расширением PostgreSQL.
См. также
DROP ACCESS METHOD, CREATE OPERATOR CLASS, CREATE OPERATOR FAMILY
1422CREATE AGGREGATE
CREATE AGGREGATE — создать агрегатную функцию
Синтаксис
CREATE AGGREGATE имя ( [ режим_аргумента ] [ имя_аргумента ] тип_данных_аргумента
[ , … ] ) (
SFUNC = функция_состояния,
STYPE = тип_данных_состояния
[ , SSPACE = размер_данных_состояния ]
[ , FINALFUNC = функция_завершения ]
[ , FINALFUNC_EXTRA ]
[ , FINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE ) ]
[ , COMBINEFUNC = комбинирующая_функция ]
[ , SERIALFUNC = функция_сериализации ]
[ , DESERIALFUNC = функция_десериализации ]
[ , INITCOND = начальное_условие ]
[ , MSFUNC = функция_состояния_движ ]
[ , MINVFUNC = обратная_функция_движ ]
[ , MSTYPE = тип_данных_состояния_движ ]
[ , MSSPACE = размер_данных_состояния_движ ]
[ , MFINALFUNC = функция_завершения_движ ]
[ , MFINALFUNC_EXTRA ]
[ , MFINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE ) ]
[ , MINITCOND = начальное_условие_движ ]
[ , SORTOP = оператор_сортировки ]
[ , PARALLEL = ( SAFE | RESTRICTED | UNSAFE ) ]
)
CREATE AGGREGATE имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_данных_аргумента
[ , … ] ]
ORDER BY [ режим_аргумента ] [ имя_аргумента
] тип_данных_аргумента [ , … ] ) (
SFUNC = функция_состояния,
STYPE = тип_данных_состояния
[ , SSPACE = размер_данных_состояния ]
[ , FINALFUNC = функция_завершения ]
[ , FINALFUNC_EXTRA ]
[ , FINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE ) ]
[ , INITCOND = начальное_условие ]
[ , PARALLEL = ( SAFE | RESTRICTED | UNSAFE ) ]
[ , HYPOTHETICAL ]
)
или старый синтаксис
CREATE AGGREGATE имя (
BASETYPE = базовый_тип,
SFUNC = функция_состояния,
STYPE = тип_данных_состояния
[ , SSPACE = размер_данных_состояния ]
[ , FINALFUNC = функция_завершения ]
[ , FINALFUNC_EXTRA ]
[ , FINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE ) ]
[ , COMBINEFUNC = комбинирующая_функция ]
[ , SERIALFUNC = функция_сериализации ]
1423CREATE AGGREGATE
[
[
[
[
[
[
[
[
[
[
[
,
,
,
,
,
,
,
,
,
,
,
DESERIALFUNC = функция_десериализации ]
INITCOND = начальное_условие ]
MSFUNC = функция_состояния_движ ]
MINVFUNC = обратная_функция_движ ]
MSTYPE = тип_данных_состояния_движ ]
MSSPACE = размер_данных_состояния_движ ]
MFINALFUNC = функция_завершения_движ ]
MFINALFUNC_EXTRA ]
MFINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE ) ]
MINITCOND = начальное_условие_движ ]
SORTOP = оператор_сортировки ]
)
Описание
CREATE AGGREGATE создаёт новую агрегатную функцию. Некоторое количество базовых и часто
используемых агрегатных функций включено в дистрибутив, они описаны в Разделе 9.20. Но если
нужно адаптировать их к новым типам или создать недостающие агрегатные функции, это можно
сделать с помощью команды CREATE AGGREGATE.
Если указывается имя схемы (например, CREATE AGGREGATE myschema.myagg …), агрегатная функ-
ция создаётся в указанной схеме. В противном случае она создаётся в текущей схеме.
Агрегатная функция идентифицируется по имени и типам входных данных. Две агрегатных функ-
ции в одной схеме могут иметь одно имя, только если они работают с разными типами данных.
Имя и тип(ы) входных данных агрегата не могут совпадать с именем и типами данных любой дру-
гой обычной функции в той же схеме. Это же правило действует при перегрузке имён обычных
функций (см. CREATE FUNCTION).
Простую агрегатную функцию образуют одна или две обычные функции: функция перехода состо-
яния функция_состояния и необязательная функция окончательного вычисления функция_завер-
шения. Они используются следующим образом:
функция_состояния( внутреннее-состояние, следующие-значения-данных ) —&gt; следующее-
внутреннее-состояние
функция_завершения( внутреннее-состояние ) —&gt; агрегатное_значение
PostgreSQL создаёт временную переменную типа тип_данных_состояния для хранения текущего
внутреннего состояния агрегата. Затем для каждой поступающей строки вычисляются значения
аргументов агрегата и вызывается функция перехода состояния с текущим значением состояния
и полученными аргументами; эта функция вычисляет следующее внутреннее состояние. Когда та-
ким образом будут обработаны все строки, вызывается завершающая функция, которая должна
вычислить возвращаемое значение агрегата. Если функция завершения отсутствует, просто воз-
вращается конечное значение состояния.
Агрегатная функция может определить начальное условие, то есть начальное значение для внут-
ренней переменной состояния. Это значение задаётся и сохраняется в базе данных в виде строки
типа text, но оно должно быть допустимым внешним представлением константы типа данных пе-
ременной состояния. По умолчанию начальным значением состояния считается NULL.
Если функция перехода состояния объявлена как «strict» (строгая), её нельзя вызывать с входными
значениями NULL. В этом случае агрегатная функция выполняется следующим образом. Строки
со значениями NULL игнорируются (функция перехода не вызывается и предыдущее значение со-
стояния не меняется) и если начальное состояние равно NULL, то в первой же строке, в которой
все входные значения не NULL, первый аргумент заменяет значение состояния, а функция пере-
хода вызывается для каждой последующей строки, в которой все входные значения не NULL. Это
поведение удобно для реализации таких агрегатных функций, как max. Заметьте, что такое пове-
дение возможно, только если тип_данных_состояния совпадает с первым типом_данных_аргумента.
Если же эти типы различаются, необходимо задать начальное условие не NULL или использовать
нестрогую функцию перехода состояния.
1424CREATE AGGREGATE
Если функция перехода состояния не является строгой, она вызывается безусловно для каждой
поступающей строки и должна сама обрабатывать вводимые значения и переменную состояния,
равные NULL. Это позволяет разработчику агрегатной функции полностью управлять тем, как она
воспринимает значения NULL.
Если функция завершения объявлена как «strict» (строгая), она не будет вызвана при конечном
значении состояния, равном NULL; вместо этого автоматически возвращается результат NULL.
(Разумеется, это вполне нормальное поведение для строгих функций.) Когда функция завершения
вызывается, она в любом случае может возвратить значение NULL. Например, функция заверше-
ния для avg возвращает NULL, если определяет, что было обработано ноль строк.
Иногда бывает полезно объявить функцию завершения как принимающую не только состояние, но
и дополнительные параметры, соответствующие входным данным агрегата. В основном это имеет
смысл для полиморфных функций завершения, которым может быть недостаточно знать тип дан-
ных только переменной состояния, чтобы вывести тип результата. Эти дополнительные парамет-
ры всегда передаются как NULL (так что функция завершения не должна быть строгой, когда при-
меняется FINALFUNC_EXTRA), но в остальном это обычные параметры. Функция завершения может
выяснить фактические типы аргументов в текущем вызове, воспользовавшись системным вызовом
get_fn_expr_argtype.
Агрегатная функция может дополнительно поддерживать режим движущегося агрегата, как опи-
сано в Подразделе 38.11.1. Для этого режима требуются параметры MSFUNC, MINVFUNC и MSTYPE, а
также могут задаваться MSPACE, MFINALFUNC, MFINALFUNC_EXTRA, MFINALFUNC_MODIFY и MINITCOND. За
исключением MINVFUNC, эти параметры работают как соответствующие параметры простого агре-
гата без начальной буквы M; они определяют отдельную реализацию агрегата, включающую функ-
цию обратного перехода.
Если в список параметров добавлено указание ORDER BY, создаётся особый типа агрегата, называ-
емый сортирующим агрегатом; с указанием HYPOTHETICAL создаётся гипотезирующий агрегат.
Эти агрегаты работают с группами отсортированных значений и зависят от порядка сортировки,
поэтому определение порядка сортировки входных данных является неотъемлемой частью их вы-
зова. Кроме того, они могут иметь непосредственные аргументы, которые вычисляются едино-
жды для всей процедуры агрегирования, а не для каждой поступающей строки. Гипотезирующие
агрегаты представляют собой подкласс сортирующих агрегатов, в которых непосредственные ар-
гументы должны совпадать, по количеству и типам данных, с агрегируемыми аргументами. Это
позволяет добавить значения этих непосредственных аргументов в набор агрегируемых строк в
качестве дополнительной «гипотетической» строки.
Агрегатная функция может дополнительно поддерживать частичное агрегирование, как описа-
но в Подразделе 38.11.4. Для этого требуется задать параметр COMBINEFUNC. Если в качестве ти-
па_данных_состояния выбран internal, обычно уместно также задать SERIALFUNC и DESERIALFUNC,
чтобы было возможно параллельное агрегирование. Заметьте, что для параллельного агрегирова-
ния агрегатная функция также должна быть помечена как PARALLEL SAFE (безопасная для распа-
раллеливания).
Агрегаты, работающие подобно MIN и MAX, иногда можно соптимизировать, заменив сканирование
всех строк таблицы обращением к индексу. Если агрегат подлежит такой оптимизации, это мож-
но указать, определив оператор сортировки. Основное требование при этом: агрегат должен вы-
давать в результате первый элемент по порядку сортировки, задаваемому оператором; другими
словами:
SELECT agg(col) FROM tab;
должно быть равнозначно:
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
Дополнительно предполагается, что агрегат игнорирует значения NULL и возвращает NULL, толь-
ко если строк со значениями не NULL не нашлось. Обычно оператор &lt; является подходящим опе-
ратором сортировки для MIN, а &gt; — для MAX. Заметьте, что обращение к индексу может дать эффект,
1425CREATE AGGREGATE
только если заданный оператор реализует стратегию «меньше» или «больше» в классе операторов
индекса-B-дерева.
Чтобы создать агрегатную функцию, необходимо иметь право USAGE для типов аргументов, типа(ов)
состояния и типа результата, а также право EXECUTE для опорных функций.
Параметры
имя
Имя создаваемой агрегатной функции (возможно, дополненное схемой).
режим_аргумента
Режим аргумента: IN или VARIADIC. (Агрегатные функции не поддерживают выходные аргумен-
ты (OUT).) По умолчанию подразумевается IN. Режим VARIADIC может быть указан только по-
следним.
имя_аргумента
Имя аргумента. В настоящее время используется только в целях документирования. Если опу-
щено, соответствующий аргумент будет безымянным.
тип_данных_аргумента
Тип входных данных, с которым работает эта агрегатная функция. Для создания агрегатной
функции без аргументов вставьте * вместо списка с определениями аргументов. (Пример такой
агрегатной функции: count(</em>).)
базовый_тип
В прежнем синтаксисе CREATE AGGREGATE тип входных данных задавался параметром basetype,
а не записывался после имени агрегата. Это позволяло указать только один входной параметр.
Чтобы определить функцию без аргументов, используя этот синтаксис, в качестве значения
basetype нужно указать “ANY” (не *). Создать сортирующий агрегат старый синтаксис не поз-
волял.
функция_состояния
Имя функции перехода состояния, вызываемой для каждой входной строки. Для обычных аг-
регатных функций с N аргументами, функция_состояния должна принимать N+1 аргумент, пер-
вый должен иметь тип тип_данных_состояния, а остальные — типы соответствующих входных
данных. Возвращать она должна значение типа тип_данных_состояния. Эта функция принима-
ет текущее значение состояния и текущие значения входных данных, и возвращает следующее
значение состояния.
В сортирующих (и в том числе, гипотезирующих) агрегатах функция перехода состояния полу-
чает только текущее значение состояния и агрегируемые аргументы, без непосредственных
аргументов. Других отличий у неё нет.
тип_данных_состояния
Тип данных значения состояния для агрегатной функции.
размер_данных_состояния
Средний размер значения состояния агрегата (в байтах). Если этот параметр опущен или равен
нулю, применяемая оценка по умолчанию определяется по типу тип_данных_состояния. Пла-
нировщик использует это значение для оценивания объёма памяти, требуемому для агрегатно-
го запроса с группировкой. Планировщик может применить агрегирование по хешу для такого
запроса, только если хеш-таблица, судя по оценке, поместится в work_mem; таким образом, при
больших значениях этого параметра агрегирование по хешу будет менее желательным.
1426CREATE AGGREGATE
функция_завершения
Имя функции завершения, вызываемой для вычисления результата агрегатной функции после
обработки всех входных строк. Для обычного агрегата эта функция должна принимать един-
ственный аргумент типа тип_данных_состояния. Возвращаемым типом агрегата будет тип, ко-
торый возвращает эта функция. Если функция_завершения не указана, результатом агрегата бу-
дет конечное значение состояния, а типом результата — тип_данных_состояния.
В сортирующих (и в том числе, гипотезирующих) агрегатах функция завершения получает не
только конечное значение состояния, но и значения всех непосредственных аргументов.
Если команда содержит указание FINALFUNC_EXTRA, то в дополнение к конечному значению со-
стояния и всем непосредственным аргументам функция завершения получает добавочные зна-
чения NULL, соответствующие обычным (агрегируемым) аргументам агрегата. Это в основном
полезно для правильного определения типа результата при создании полиморфной агрегатной
функции.
FINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE )
Этот параметр указывает, является ли функция завершения чистой функцией, которая не из-
меняет свои аргументы. Это свойство функции передаёт значение READ_ONLY; два других значе-
ния показывают, что она может менять значение переходного состояния. Подробнее это рас-
сматривается в Разделе «Замечания». По умолчанию подразумевается значение READ_ONLY, за
исключением сортирующих агрегатов (для них значение по умолчанию — READ_WRITE).
комбинирующая_функция
Дополнительно может быть указана комбинирующая_функция, чтобы агрегатная функция под-
держивала частичное агрегирование. Если задаётся, комбинирующая_функция должна комбини-
ровать два значения типа_данных_состояния, содержащих результат агрегирования по некото-
рому подмножеству входных значений, и вычислять новое значение типа_данных_состояния,
представляющее результат агрегирования по обоим множествам данных. Эту функцию можно
считать своего рода функцией_состояния, которая вместо обработки отдельной входной строки
и включения её данных в текущее агрегируемое состояние включает некоторое агрегирован-
ное состояние в текущее.
Указанная комбинирующая_функция должна быть объявлена как принимающая два аргумента
типа_данных_состояния и возвращающая значение типа_данных_состояния. Эта функция до-
полнительно может быть объявлена «строгой». В этом случае данная функция не будет вызы-
ваться, когда одно из входных состояний — NULL; в качестве корректного результата будет
выдано другое состояние.
Для агрегатных функций, у которых тип_данных_состояния — internal, комбинирующая_функ-
ция не должна быть «строгой». При этом комбинирующая_функция должна позаботиться о том,
чтобы состояния NULL обрабатывались корректно и возвращаемое состояние располагалось в
контексте памяти агрегирования.
функция_сериализации
Агрегатная функция, у которой тип_данных_состояния — internal, может участвовать в парал-
лельном агрегировании, только если для неё задана функция_сериализации, которая должна
сериализовать агрегатное состояние в значение bytea для передачи другому процессу. Эта
функция должна принимать один аргумент типа internal и возвращать тип bytea. Также при
этом нужно задать соответствующую функцию_десериализации.
функция_десериализации
Десериализует ранее сериализованное агрегатное состояние обратно в тип_данных_состояния.
Эта функция должна принимать два аргумента типов bytea и internal и выдавать результат
типа internal. (Замечание: второй аргумент типа internal не используется, но требуется из
соображений типобезопасности.)
1427CREATE AGGREGATE
начальное_условие
Начальное значение переменной состояния. Оно должно задаваться строковой константой в
форме, пригодной для ввода в тип_данных_состояния. Если не указано, начальным значением
состояния будет NULL.
функция_состояния_движ
Имя функции прямого перехода состояния, вызываемой для каждой входной строки в режи-
ме движущегося агрегата. Это точно такая же функция, как и обычная функция перехода, но
её первый аргумент и результат имеют тип тип_данных_состояния_движ, который может отли-
чаться от типа тип_данных_состояния.
обратная_функция_движ
Имя функции обратного перехода состояния, применяемой в режиме движущегося агрегата.
У этой функции те же типы аргумента и результатов, что и у функции_состояния_движ, но она
предназначена не для добавления, а для удаления значения из текущего состояния агрегата.
Функция обратного перехода должна иметь ту же характеристику строгости, что и функция
прямого перехода.
тип_данных_состояния_движ
Тип данных значения состояния для агрегатной функции в режиме движущегося агрегата.
размер_данных_состояния_движ
Примерный размер значения состояния в режиме движущегося агрегата. Он имеет то же зна-
чение, что и размер_данных_состояния.
функция_завершения_движ
Имя функции завершения, вызываемой в режиме движущегося агрегата для вычисления ре-
зультата агрегатной функции после обработки всех входных строк. Она работает так же, как
функция_завершения, но её первый аргумент имеет тип тип_данных_состояния_движ, а дополни-
тельными пустыми аргументами управляет параметр MFINALFUNC_EXTRA. Тип результата, кото-
рый определяет функция_завершения_движ, или тип_данных_состояния_движ, должен совпадать
с типом результата обычной реализации агрегата.
MFINALFUNC_MODIFY = ( READ_ONLY | SHAREABLE | READ_WRITE )
Этот параметр подобен FINALFUNC_MODIFY, но описывает поведение функции завершения для
движущегося агрегата.
начальное_условие_движ
Начальное значение переменной состояния в режиме движущегося агрегата. Оно применяется
так же, как начальное_условие.
оператор_сортировки
Связанный оператор сортировки для реализации агрегатов, подобных MIN или MAX. Здесь ука-
зывается просто имя оператора (возможно, дополненное схемой). Предполагается, что опера-
тор поддерживает те же типы входных данных, что и агрегат (который должен быть обычным
и иметь один аргумент).
PARALLEL = ( SAFE | RESTRICTED | UNSAFE )
Указания PARALLEL SAFE, PARALLEL RESTRICTED и PARALLEL UNSAFE имеют те же значения, что и
в CREATE FUNCTION. Агрегатная функция не будет считаться распараллеливаемой, если она
имеет характеристику PARALLEL UNSAFE (она подразумевается по умолчанию!) или PARALLEL
RESTRICTED. Заметьте, что планировщик не обращает внимание на допустимость распараллели-
вания опорных функций агрегата, а учитывает только характеристику самой агрегатной функ-
ции.
1428CREATE AGGREGATE
HYPOTHETICAL
Этот признак, допустимый только для сортирующих агрегатов, указывает, что агрегатные ар-
гументы должны обрабатываться согласно требованиям гипотезирующих агрегатов: то есть по-
следние несколько непосредственных аргументов должны соответствовать по типам агрегат-
ным аргументам (WITHIN GROUP). Признак HYPOTHETICAL не влияет на поведение во время выпол-
нения, он учитывается только при разрешении типов данных и правил сортировки аргументов.
Параметры CREATE AGGREGATE могут записываться в любом порядке, не обязательно так, как по-
казано выше.
Замечания
В параметрах, определяющих имена вспомогательных функций, при необходимости можно напи-
сать имя схемы, например: SFUNC = public.sum. Однако типы аргументов там не указываются —
типы аргументов вспомогательных функций определяются другими параметрами.
Обычно функции PostgreSQL должны быть действительно функциями, не меняющими свои вход-
ные значения. Однако функциям агрегатного перехода, используемым в контексте агрегатной
функции, разрешено действовать хитрее и изменять аргумент с переходным состоянием на месте.
Это может дать значительный выигрыш в скорости по сравнению с созданием новой копии пере-
ходного состояния при каждом вызове.
Подобным образом, хотя функция завершения агрегата обычно не должна изменять свои входные
значения, иногда может быть полезно допустить изменение аргумента с переходным состоянием.
Соответствующее поведение должно обозначаться параметром FINALFUNC_MODIFY. Его значение
READ_WRITE показывает, что функция завершения модифицирует переходное состояние неопреде-
лённым образом. При этом значении предотвращается использование агрегата в качестве оконной
функции, а также не допускается объединение переходных состояний при вызове агрегатов с оди-
наковыми входными данными и функциями перехода. Значение SHAREABLE указывает, что функ-
цию перехода нельзя применять после функции завершения, но с конечным значением состояния
могут быть выполнены несколько вызовов функции завершения. При этом значении предотвраща-
ется использование агрегата в качестве оконной функции, но переходные состояния могут объ-
единяться. (То есть оптимизация в данном случае состоит не в многократном применении одной
функции завершения, а в применении различных функций завершения к одному и тому же конеч-
ному переходному состоянию. Это допускается, только если ни одна из функций завершения не
помечена как READ_WRITE.)
Если агрегатная функция поддерживает режим движущегося агрегата, это увеличивает эффек-
тивность вычислений, когда она применяется в качестве оконной функции для окна с движущимся
началом рамки (то есть, когда начало определяется не как UNBOUNDED PRECEDING). По сути, функ-
ция прямого перехода добавляет входные значения к состоянию агрегата, когда они поступают в
рамку окна снизу, а функция обратного перехода снова вычитает их, когда они покидают рамку
сверху. Поэтому вычитаются значения в том же порядке, в каком добавлялись. Когда бы ни вызы-
валась функция обратного перехода, она таким образом получит первое из добавленных, но ещё
не удалённых значений аргумента. Функция обратного перехода может рассчитывать на то, что
после того, как она удалит самые старые данные, в текущем состоянии останется ещё как мини-
мум одна строка. (Когда это правило могло бы нарушиться, механизм оконных функций просто
начинает агрегировать данные заново, а не вызывает функцию обратного перехода.)
Функция прямого перехода для режима движущегося агрегата не может возвращать NULL в ка-
честве нового значения состояния. Если NULL возвращает функция обратного перехода, это по-
казывает, что она не может произвести обратное вычисление для этих конкретных данных, и что
вычисление агрегата следует выполнить заново от начальной позиции текущей рамки. Благодаря
этому соглашению, режим движущегося агрегата можно использовать, даже если иногда возни-
кают ситуации, в которых обратный расчёт состояния производить непрактично.
Агрегатную функцию можно использовать с движущимися рамками и без реализации движущего-
ся агрегата, но при этом PostgreSQL будет заново агрегировать все данные при каждом перемеще-
нии начала рамки. Заметьте, что вне зависимости от того, поддерживает ли агрегатная функция
1429CREATE AGGREGATE
режим движущегося агрегата, PostgreSQL может обойтись без повторных вычислений при сдвиге
конца рамки; новые значения просто продолжают добавляться в состояние агрегата. Именно по-
этому для использования агрегата в качестве оконной функции требуется, чтобы функция завер-
шения была только читающей: она не должна изменять значение состояния агрегата, чтобы агре-
гирование могло продолжаться и после получения результата для набора строк в определённой
рамке.
Синтаксис сортирующих агрегатных функций позволяет указать VARIADIC и в последнем непосред-
ственном параметре, и в последнем агрегатном (WITHIN GROUP). Однако в текущей реализации
на применение VARIADIC накладываются два ограничения. Во-первых, в сортирующих агрегатах
можно использовать только VARIADIC “any”, но не другие типы переменных массивов. Во-вторых,
если последним непосредственным аргументом является VARIADIC “any”, то допускается только
один агрегатный аргумент и это тоже должен быть VARIADIC “any”. (В представлении, использу-
емом в системных каталогах, эти два параметра объединяются в один элемент VARIADIC “any”,
так как в pg_proc нельзя представить функцию с несколькими параметрами VARIADIC.) Если агре-
гатная функция является гипотезирующей, непосредственные аргументы, соответствующие пара-
метру VARIADIC “any”, будут гипотетическими; любые предшествующие параметры представляют
дополнительные непосредственные аргументы, которые могут не соответствовать агрегатным.
В настоящее время сортирующие агрегатные функции не поддерживают режим движущегося аг-
регата, так как их нельзя применять в качестве оконных функций.
Частичное (в том числе, параллельное) агрегирование в настоящее время не поддерживается для
сортирующих агрегатных функций. Также оно никогда не будет применяться для агрегатных вы-
зовов с предложениями DISTINCT или ORDER BY, так как они по природе своей не могут быть реа-
лизованы с частичным агрегированием.
Примеры
См. Раздел 38.11.
Совместимость
Оператор CREATE AGGREGATE является языковым расширением PostgreSQL. В стандарте SQL не
предусмотрено создание пользовательских агрегатных функций.
См. также
ALTER AGGREGATE, DROP AGGREGATE
1430CREATE CAST
CREATE CAST — создать приведение
Синтаксис
CREATE CAST (исходный_тип AS целевой_тип)
WITH FUNCTION имя_функции [ (тип_аргумента [, …]) ]
[ AS ASSIGNMENT | AS IMPLICIT ]
CREATE CAST (исходный_тип AS целевой_тип)
WITHOUT FUNCTION
[ AS ASSIGNMENT | AS IMPLICIT ]
CREATE CAST (исходный_тип AS целевой_тип)
WITH INOUT
[ AS ASSIGNMENT | AS IMPLICIT ]
Описание
CREATE CAST создаёт новое приведение. Приведение определяет, как выполнить преобразование
из одного типа в другой. Например,
SELECT CAST(42 AS float8);
преобразует целочисленную константу 42 к типу float8, вызывая ранее определённую функцию,
в данном случае float8(int4). (Если подходящее приведение не определено, возникнет ошибка
преобразования.)
Два типа могут быть двоично-сводимыми; это означает, что преобразование может быть выполне-
но «бесплатно», без вызова какой-либо функции. Для этого требуется, чтобы соответствующие зна-
чения имели одинаковое внутреннее представление. Например, типы text и varchar двоично-сво-
димые в обе стороны. Отношение двоичной сводимости не обязательно симметрично. Например,
приведение типа xml к типу text в текущей реализации можно выполнить бесплатно, но для пре-
образования в обратном направлении требуется функция, выполняющая как минимум синтакси-
ческую проверку. (Два типа, двоично-сводимые в обе стороны, также называются двоично-совме-
стимыми.)
Приведение можно определить как преобразование ввода/вывода, используя указание WITH INOUT.
В этом случае для приведения одного типа к другому вызывается функция вывода исходного ти-
па данных, а выданная ей строка передаётся функции ввода целевого типа. Во многих случаях
эта возможность избавляет от необходимости писать для преобразования всех типов отдельные
функции приведения. Преобразование ввода/вывода работает так же, как и обычное приведение
с функцией; отличается только реализация.
По умолчанию, приведение можно вызвать, только записав его явно, то есть применив конструк-
цию CAST(x AS имя_типа) или x::имя_типа.
Если приведение помечено AS ASSIGNMENT, его можно вызывать неявно, присваивая значение
столбцу с целевым типом данных. Например, если foo.f1 — столбец типа text, то команда:
INSERT INTO foo (f1) VALUES (42);
будет допустимой, если приведение типа integer к text помечено AS ASSIGNMENT, и не будет в
противном случае. (Для описания такого типа приведений мы обычно используем термин приве-
дение присваивания.)
Если приведение помечено AS IMPLICIT, оно будет вызываться неявно в любом контексте, будь
то присваивание или внутреннее преобразование в выражении. (Обычно мы называет приведение
такого типа неявным приведением.) Например, рассмотрите этот запрос:
1431CREATE CAST
SELECT 2 + 4.0;
При разборе запроса константам сначала назначаются типы integer и numeric. Однако в систем-
ных каталогах нет оператора integer + numeric, хотя есть оператор numeric + numeric. Таким об-
разом, запрос выполнится успешно, если существует преобразование типа integer к numeric с по-
меткой AS IMPLICIT — и на самом деле это так. Анализатор запроса применит неявное приведение
и запрос будет обработан, как если бы он был записан в виде
SELECT CAST ( 2 AS numeric ) + 4.0;
Системные каталоги также содержат приведение типа numeric к integer. Если бы это приведение
тоже было бы помечено AS IMPLICIT (на самом деле это не так), анализатору запроса пришлось
бы выбирать между предыдущим вариантом и приведением константы numeric к типу integer с
последующим применением оператора integer + integer. Не имея возможности выбрать лучший
вариант, анализатор бы не смог разрешить запрос и объявил бы его неоднозначным. Именно бла-
годаря тому, что только одно из двух приведений сделано неявным, анализатор приходит к пони-
манию, что предпочитаемым является преобразование выражения numeric-и-integer в numeric;
отдельного встроенного знания об этом нет.
Определяя, объявлять ли приведения неявными, разумно проявлять консерватизм. При чрезмер-
ном количестве способов неявного приведения PostgreSQL может выбирать неожиданные интер-
претации команд, или вовсе не сможет выполнить команды из-за наличия множества возможных
интерпретаций. Как правило, следует делать приведение неявно вызываемым только для преоб-
разований, сохраняющих информацию, между типами в одной общей категории типов. Например,
приведение int2 к int4 разумно сделать неявным, но приведение float8 к int4, возможно, лучше
сделать только приведением присваивания. Приведения типов разных категорий, например, text
к int4, лучше делать только явными.
Примечание
Иногда ради удобства или соответствия стандартам требуется ввести множество неяв-
ных преобразований для нескольких типов, что приводит к неизбежной неоднозначно-
сти. Чтобы анализатор запроса мог обеспечить желаемое поведение в таких случаях,
он дополнительно принимает во внимание категории типов и предпочитаемые типы.
Подробнее это описано в CREATE TYPE.
Чтобы создать приведение, необходимо быть владельцем одного (исходного или целевого) типа и
иметь право USAGE для другого типа. Создать двоично-сводимое приведение могут только супер-
пользователи. (Это ограничение введено потому, что преобразование данных с ошибочным двоич-
ным сведением может легко вызывать сбой сервера.)
Параметры
исходный_тип
Имя исходного типа данных для приведения.
целевой_тип
Имя целевого типа данных для приведения.
имя_функции[(тип_аргумента [, …])]
Функция, вызываемая для выполнения приведения. Имя функции может быть дополнено схе-
мой; в противном случае для поиска функции просматривается путь поиска. Тип данных ре-
зультата должен соответствовать целевому типу приведения. Аргументы функции рассматри-
ваются ниже. Если список аргументов отсутствует, имя функции должно быть уникальным в
её схеме.
1432CREATE CAST
WITHOUT FUNCTION
Обозначает, что исходный тип сводится к целевому на двоичном уровне, так что функция для
приведения не требуется.
WITH INOUT
Обозначает, что приведение выполняется как преобразование ввода/вывода, то есть вызывает-
ся функция вывода исходного типа данных, а её результат-строка передаётся функции ввода
целевого типа.
AS ASSIGNMENT
Обозначает, что приведение может вызываться неявно в контексте присваивания.
AS IMPLICIT
Обозначает, что приведение может вызываться неявно в любом контексте.
Функции, реализующие приведение, могут иметь от одного до трёх аргументов. Тип первого аргу-
мента должен быть идентичен или двоично-сводимым к исходному типу приведения. Второй аргу-
мент, если он есть, должен иметь тип integer; в нём передаётся модификатор типа, связанный
с целевым типом, или -1, если он отсутствует. Третий аргумент, если он есть, должен иметь тип
boolean; в нём передаётся true, если приведение выполняется явно, либо false в противном слу-
чае. (Это довольно экстравагантно, но стандарт SQL предусматривает разное поведение для явно-
го и неявного приведения в некоторых случаях. Этот аргумент предназначен для функций, кото-
рые должны реализовывать такие приведения. Однако создавать собственные типы данных, для
которых это имело бы значение, не рекомендуется.)
Возвращаемый тип функции приведения должен быть идентичным или двоично-сводимым к целе-
вому типу приведения.
Обычно исходный и целевой типы в приведении различаются, однако можно объявить приведение
одного типа к такому же, если функция, реализующая преобразование, имеет более одного аргу-
мента. Это используется для представления в системных каталогах функций, сводящих разные
длины типов. Реализующая такое приведение функция будет сводить значение типа к значению с
определённым модификатором, заданному вторым аргументом.
Когда исходный и целевой типы приведения различаются и функция принимает более одного ар-
гумента, преобразование типа из одного в другой и сведение к нужной длине может выполняться
за один шаг. Если же соответствующей записи не находится, приведение к типу с определённым
модификатором выполняется в два этапа: сначала выполняется преобразование типа, а затем при-
меняется модификатор типа.
Приведение типа домена или к типу домена в настоящее время не осуществляется. При попытке
выполнить такое приведение вместо него выполняется приведение, связанное с базовым типом
домена.
Замечания
Для удаления приведений, созданных пользователем, применяется DROP CAST.
Помните, что когда требуется преобразовывать типы в обе стороны, необходимо явно описать два
приведения.
Обычно не требуется создавать приведения между пользовательскими типами и стандартными
строковыми типами (text, varchar и char(n), а также пользовательскими типами, относящимися
к категории строковых). Для них PostgreSQL предоставляет автоматическое преобразование вво-
да/вывода. Автоматические приведения к строковым типам считаются приведениями присваива-
ния, а автоматические приведения строковых типов к другим могут быть только явными. Это по-
ведение можно переопределить, создав собственное приведение, заменяющее автоматическое, но
1433CREATE CAST
обычно это нужно, только чтобы сделать вызов более удобным, чем стандартное только присва-
ивание или явное указание. Возможен и другой повод для такого переопределения — желание
создать приведение, работающее не так, как функция ввода/вывода типа; но это настолько удиви-
тельно, что следует дважды подумать, хороша ли эта идея. (На самом деле у небольшого количе-
ства встроенных типов имеются подобные специфические приведения, в основном из-за требова-
ний стандарта SQL.)
Хотя это и не обязательно, но рекомендуется следовать старому соглашению называть функции,
реализующие приведение, по целевому типу данных. Многие привыкли выполнять преобразова-
ние типов данных, записывая его в стиле функций, т. е. имя_типа(x). Эта запись на самом деле ни
больше ни меньше как просто вызов функции, реализующей приведение; такой вызов не воспри-
нимается как именно приведение. Если называть функции, не следуя этому соглашению, это мо-
жет оказаться неожиданным для пользователей. Так как PostgreSQL позволяет перегружать одно
и то же имя функции с разными типами аргументов, ничто не мешает создать множество функций
приведения разных типов к одному, названных по имени этого целевого типа.
Примечание
Вообще говоря, в предыдущем абзаце допущено некоторое упрощение: есть два случая,
когда конструкция с вызовом функции исполняется как приведение, без сопоставле-
ния с фактической функцией. Если вызову функции имя(x) в точности не соответству-
ет существующая функция, но имеется тип данных имя и в pg_cast есть двоично-сво-
димое приведение типа x к этому типу, такой вызов будет воспринят как приведение.
Это исключение введено, чтобы двоично-сводимое приведение можно было вызывать,
используя синтаксис функций, несмотря на то, что никакой функции преобразования
у него нет. Аналогично, если запись приведения в pg_cast отсутствует, но в случае
приведения это было бы преобразование в/из строкового типа, такой вызов будет вы-
полнен как преобразование ввода/вывода. Это исключение позволяет вызывать преоб-
разование ввода/вывода, используя синтаксис вызова функции.
Примечание
Но есть исключение и из этого исключения: преобразование ввода/вывода из состав-
ных типов в строковые нельзя вызвать в виде функции, его необходимо записать как
явное приведение (используя CAST или запись ::). Это исключение было добавлено,
потому что после введения автоматически предоставляемых преобразований ввода/вы-
вода, оказалось слишком легко случайно вызвать такое приведение, тогда как имелась
в виду ссылка на столбец или функцию.
Примеры
Создание приведения присваивания типа bigint к типу int4 с помощью функции int4(bigint):
CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;
(Это приведение уже предопределено в системе.)
Совместимость
Команда CREATE CAST соответствует стандарту SQL, за исключением того, что в стандарте ниче-
го не говорится о двоично-сводимых типах и дополнительных аргументах реализующих функций.
Указание AS IMPLICIT тоже является расширением PostgreSQL.
См. также
CREATE FUNCTION, CREATE TYPE, DROP CAST
1434CREATE COLLATION
CREATE COLLATION — создать правило сортировки
Синтаксис
CREATE COLLATION [ IF NOT EXISTS ] имя (
[ LOCALE = локаль, ]
[ LC_COLLATE = категория_сортировки, ]
[ LC_CTYPE = категория_типов_символов, ]
[ PROVIDER = провайдер, ]
[ VERSION = версия ]
)
CREATE COLLATION [ IF NOT EXISTS ] имя FROM существующее_правило
Описание
CREATE COLLATION определяет новое правило сортировки, используя параметры локали операци-
онной системы, либо копируя существующее правило.
Чтобы создать правило сортировки, необходимо иметь право CREATE в целевой схеме.
Параметры
IF NOT EXISTS
Не считать ошибкой, если правило сортировки с таким именем уже существует. В этом случае
будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее правило сор-
тировки как-то соотносится с тем, которое могло бы быть создано.
имя
Имя правила сортировки, возможно, дополненное схемой. Если схема не указана, правило сор-
тировки создаётся в текущей схеме. Заданное имя правила должно быть уникальным в этой
схеме. (Системные каталоги могут содержать правила сортировки с одним именем, но пред-
назначенные для разных кодировок, однако они будут игнорироваться, если их кодировка не
совпадает с кодировкой базы данных.)
локаль
Это краткая запись для одновременной установки LC_COLLATE и LC_CTYPE. Если указан этот
вариант, задать любой из этих параметров отдельно нельзя.
категория_сортировки
Указанная локаль операционной системы устанавливается в качестве категории локали
LC_COLLATE.
категория_типов_символов
Указанная локаль операционной системы устанавливается в качестве категории локали
LC_CTYPE.
провайдер
Задаёт провайдер, который будет использоваться для функций локализации, связанных с дан-
ным правилом сортировки. Возможные значения: icu,libc. По умолчанию выбирается libc.
Набор доступных значений зависит от операционной системы и параметров сборки.
версия
Задаёт строку версии, сохраняемую с правилом сортировки. Обычно её не следует задавать —
тогда эта версия будет получена из фактической версии правила сортировки, сообщённой опе-
1435CREATE COLLATION
рационной системой. Это указание предназначено для того, чтобы команда pg_upgrade смогла
скопировать версию из существующей инсталляции.
Что делать при несовпадении версий правил сортировки, описано в ALTER COLLATION.
существующее_правило
Имя копируемого существующего правила сортировки. Новое правило сортировки получит те
же свойства, что и существующее, но будет независимым объектом.
Замечания
Для удаления созданных пользователем правил сортировки применяется команда DROP COLLATION.
Подробнее узнать о создании правил сортировки можно в Подразделе 23.2.2.3.
Когда используется провайдер libc, локаль должна быть применимой к кодировке текущей базы
данных. Точные правила описаны в CREATE DATABASE.
Примеры
Создание правила сортировки из локали операционной системы fr_FR.utf8 (предполагается, что
кодировка текущей базы данных — UTF8):
CREATE COLLATION french (locale = ‘fr_FR.utf8’);
Создание правила сортировки с порядком, принятым в Германии для телефонных книг, с исполь-
зование провайдера ICU:
CREATE COLLATION german_phonebook (provider = icu, locale = ‘de-u-co-phonebk’);
Создание правила сортировки из уже существующего:
CREATE COLLATION german FROM “de_DE”;
Иногда удобно использовать в приложениях имена правил сортировки, не зависящие от операци-
онной системы.
Совместимость
Оператор CREATE COLLATION определён в стандарте SQL, но его действие ограничено копирова-
нием существующего правила сортировки. Синтаксис создания нового правила сортировки пред-
ставляет собой расширение PostgreSQL.
См. также
ALTER COLLATION, DROP COLLATION
1436CREATE CONVERSION
CREATE CONVERSION — создать перекодировку
Синтаксис
CREATE [ DEFAULT ] CONVERSION имя
FOR исходная_кодировка TO целевая_кодировка FROM имя_функции
Описание
CREATE CONVERSION определяет новую перекодировку наборов символов. Кроме того, перекодиров-
ки, помеченные как DEFAULT, могут применяться для автоматического преобразования кодировки
между клиентом и сервером. Для такого применения должны быть определены две перекодиров-
ки: из кодировки A в B и из кодировки B в A.
Чтобы создать перекодировку, необходимо иметь право EXECUTE для реализующей функции и право
CREATE в целевой схеме.
Параметры
DEFAULT
Предложение DEFAULT показывает, что эта перекодировка должна использоваться по умолча-
нию для преобразования заданной исходной кодировки в целевую. Для каждой пары кодировок
может быть только одна перекодировка по умолчанию.
имя
Имя перекодировки, возможно, дополненное схемой. Если схема не указана, перекодировка
создаётся в текущей схеме. Имя перекодировки должно быть уникально в этой схеме.
исходная_кодировка
Имя исходной кодировки.
целевая_кодировка
Имя целевой кодировки.
имя_функции
Функция, выполняющая перекодирование. Имя функции может быть дополнено схемой, в про-
тивном случае для поиска функции просматривается путь поиска.
Функция должна иметь следующую сигнатуру:
conv_proc(
integer, –
integer, –
cstring, –
internal, –
integer
–
) RETURNS void;
идентификатор исходной кодировки
идентификатор целевой кодировки
исходная строка (строка, завершающаяся 0, как в C)
целевая строка (заполняется строкой, завершающейся 0, как в C)
длина исходной строки
Замечания
Для удаления перекодировок, созданных пользователем, применяется DROP CONVERSION.
Набор прав, требуемых для создания перекодировки, может измениться в будущих версиях.
1437CREATE CONVERSION
Примеры
Создание перекодировки из кодировки UTF8 в LATIN1 с использованием функции myfunc:
CREATE CONVERSION myconv FOR ‘UTF8’ TO ‘LATIN1’ FROM myfunc;
Совместимость
Оператор CREATE CONVERSION является расширением PostgreSQL. В стандарте SQL отсутствует
оператор CREATE CONVERSION, но есть очень похожий по предназначению и синтаксису оператор
CREATE TRANSLATION.
См. также
ALTER CONVERSION, CREATE FUNCTION, DROP CONVERSION
1438CREATE DATABASE
CREATE DATABASE — создать базу данных
Синтаксис
CREATE DATABASE имя
[ [ WITH ] [ OWNER [=] имя_пользователя ]
[ TEMPLATE [=] шаблон ]
[ ENCODING [=] кодировка ]
[ LC_COLLATE [=] категория_сортировки ]
[ LC_CTYPE [=] категория_типов_символов ]
[ TABLESPACE [=] табл_пространство ]
[ ALLOW_CONNECTIONS [=] разр_подключения ]
[ CONNECTION LIMIT [=] предел_подключений ]
[ IS_TEMPLATE [=] это_шаблон ] ]
Описание
Команда CREATE DATABASE создаёт базу данных PostgreSQL.
Чтобы создать базу данных, необходимо быть суперпользователем или иметь специальное право
CREATEDB. См. CREATE ROLE.
По умолчанию новая база данных создаётся копированием стандартной системной базы данных
template1. Задать другой шаблон можно, добавив указание TEMPLATE имя. В частности, написав
TEMPLATE template0, можно создать девственно чистую базу данных, содержащую только стан-
дартные объекты, предопределённые установленной версией PostgreSQL. Это бывает полезно, ко-
гда копировать в новую базу любые дополнительные объекты, добавленные локально в template1,
нежелательно.
Параметры
имя
Имя создаваемой базы данных.
имя_пользователя
Имя пользователя (роли), назначаемого владельцем новой базы данных, либо DEFAULT, чтобы
владельцем стал пользователь по умолчанию (а именно, пользователь, выполняющий команду).
Чтобы создать базу данных и сделать её владельцем другую роль, необходимо быть непосред-
ственным или опосредованным членом этой роли, либо суперпользователем.
шаблон
Имя шаблона, из которого будет создаваться новая база данных, либо DEFAULT, чтобы выбрать
шаблон по умолчанию (template1).
кодировка
Кодировка символов в новой базе данных. Укажите строковую константу (например,
‘SQL_ASCII’) или целочисленный номер кодировки, либо DEFAULT, чтобы выбрать кодиров-
ку по умолчанию (а именно, кодировку шаблона). Наборы символов, которые поддерживает
PostgreSQL, перечислены в Подразделе 23.3.1. Дополнительные ограничения описаны ниже.
категория_сортировки
Порядок сортировки (LC_COLLATE), который будет использоваться в новой базе данных. Этот
параметр определяет порядок сортировки строк, например, в запросах с ORDER BY, а также
1439CREATE DATABASE
порядок индексов по текстовым столбцам. По умолчанию используется порядок сортировки,
установленный в шаблоне. Дополнительные ограничения описаны ниже.
категория_типов_символов
Классификация символов (LC_CTYPE), которая будет применяться в новой базе данных. Этот
параметр определяет принадлежность символов категориям, например: строчные, заглавные,
цифры и т. п. По умолчанию используется классификация символов, установленная в шаблоне.
Дополнительные ограничения описаны ниже.
табл_пространство
Имя табличного пространства, связываемого с новой базой данных, или DEFAULT для использо-
вания табличного пространства шаблона. Это табличное пространство будет использоваться
по умолчанию для объектов, создаваемых в этой базе. За подробностями обратитесь к CREATE
TABLESPACE.
разр_подключения
Если false, никто не сможет подключаться к этой базе данных. По умолчанию имеет значение
true, то есть подключения принимаются (если не ограничиваются другими механизмами, на-
пример, GRANT/REVOKE CONNECT).
предел_подключений
Максимальное количество одновременных подключений к этой базе данных. Значение -1 (по
умолчанию) снимает ограничение.
это_шаблон
Если true, базу данных сможет клонировать любой пользователь с правами CREATEDB; в против-
ном случае (по умолчанию), клонировать эту базу смогут только суперпользователи и её вла-
делец.
Дополнительные параметры могут записываться в любом порядке, не обязательно так, как пока-
зано выше.
Замечания
CREATE DATABASE нельзя выполнять внутри блока транзакции.
Ошибки, содержащие сообщение «не удалось инициализировать каталог базы данных», чаще все-
го связаны с нехваткой прав в каталоге данных, заполнением диска или другими проблемами в
файловой системе.
Для удаления базы данных применяется DROP DATABASE.
Программа createdb представляет собой оболочку этой команды, созданную ради удобства.
Конфигурационные параметры уровня базы данных (устанавливаемые
DATABASE) из шаблона в новую базу данных не копируются.
командой
ALTER
Хотя с помощью этой команды можно скопировать любую базу данных, а не только template1,
указав её имя в качестве имени шаблона, она не предназначена (пока) для использования в каче-
стве универсального средства вроде «COPY DATABASE». Принципиальным ограничением является
невозможность копирования базы данных шаблона, если установлены другие подключения к ней.
CREATE DATABASE выдаёт ошибку, если при запуске команды есть другие подключения к этой ба-
зе; в противном случае новые подключения к базе блокируются до завершения команды CREATE
DATABASE. За дополнительными сведениями обратитесь к Разделу 22.3.
Кодировка символов, указанная для новой базы данных, должна быть совместима с выбранными
параметрами локали (LC_COLLATE и LC_CTYPE). Если выбрана локаль C (или равнозначная ей POSIX),
1440CREATE DATABASE
допускаются все кодировки, но для других локалей правильно будет работать только одна кодиров-
ка. (В Windows, однако, кодировку UTF-8 можно использовать с любой локалью.) CREATE DATABASE
позволяет суперпользователям указать кодировку SQL_ASCII вне зависимости от локали, но этот
вариант считается устаревшим и может привести к ошибочному поведению строковых функций,
если в базе хранятся данные в кодировке, несовместимой с заданной локалью.
Параметры локали и кодировка должны соответствовать тем, что установлены в шаблоне, если
только это не template0. Это ограничение объясняется тем, что другие базы данных могут содер-
жать данные в кодировке, отличной от заданной, или индексы, порядок сортировки которых опре-
деляются параметрами LC_COLLATE и LC_CTYPE. При копировании таких данных получится база,
которая будет испорченной согласно новым параметрам локали. Однако template0 определённо
не содержит какие-либо данные или индексы, зависящие от кодировки или локали.
Ограничение CONNECTION LIMIT действует только приблизительно; если одновременно запускают-
ся два сеанса, тогда как в базе остаётся только одно «свободное место», может так случиться, что
будут отклонены оба подключения. Кроме того, это ограничение не распространяется на супер-
пользователей и фоновые рабочие процессы.
Примеры
Создание базы данных:
CREATE DATABASE lusiadas;
Создание базы данных sales, принадлежащей пользователю salesapp, с табличным простран-
ством по умолчанию salesspace:
CREATE DATABASE sales OWNER salesapp TABLESPACE salesspace;
Создание базы данных music с другой локалью:
CREATE DATABASE music
LC_COLLATE ‘sv_SE.utf8’ LC_CTYPE ‘sv_SE.utf8’
TEMPLATE template0;
В этом примере предложение TEMPLATE template0 необходимо, только если указанная локаль от-
личается от локали в template1. (В противном случае явное указание локали является избыточ-
ным.)
Создание базы данных music2 с другой локалью и другой кодировкой символов:
CREATE DATABASE music2
LC_COLLATE ‘sv_SE.iso885915’ LC_CTYPE ‘sv_SE.iso885915’
ENCODING LATIN9
TEMPLATE template0;
Свойства кодировки должны соответствовать локали, иначе возникнет ошибка.
Заметьте, что имена локалей зависят от операционной системы, так что показанные выше команды
могут не везде работать одинаково.
Совместимость
Оператор CREATE DATABASE отсутствует в стандарте SQL. Базы данных равнозначны каталогам, а
их создание в стандарте определяется реализацией.
См. также
ALTER DATABASE, DROP DATABASE
1441CREATE DOMAIN
CREATE DOMAIN — создать домен
Синтаксис
CREATE DOMAIN имя [ AS ] тип_данных
[ COLLATE правило_сортировки ]
[ DEFAULT выражение ]
[ ограничение [ … ] ]
Здесь ограничение:
[ CONSTRAINT имя_ограничения ]
( NOT NULL | NULL | CHECK (выражение) )
Описание
CREATE DOMAIN создаёт новый домен. Домен по сути представляет собой тип данных с дополнитель-
ными условиями (ограничивающими допустимый набор значений). Владельцем домена становит-
ся пользователь его создавший.
Если задаётся имя схемы (например, CREATE DOMAIN myschema.mydomain …), домен создаётся в
указанной схеме, в противном случае — в текущей. Имя домена должно быть уникальным среди
имён типов и доменов, существующих в этой схеме.
Домены полезны для абстрагирования и вынесения общих характеристик разных полей в единое
место для упрощения сопровождения. Например, в нескольких таблицах может присутствовать
столбец, содержащий электронный адрес, и для всех требуются одинаковые ограничения CHECK,
проверяющие синтаксис адреса. В этом случае лучше определить домен, а не задавать для каждой
таблицы отдельные ограничения.
Чтобы создать домен, необходимо иметь право USAGE для нижележащего типа.
Параметры
имя
Имя создаваемого домена (возможно, дополненное схемой).
тип_данных
Нижележащий тип данных домена (может включать определение массива с этим типом).
правило_сортировки
Необязательное указание правила сортировки для домена. Если это указание отсутствует, ис-
пользуется правило сортировки по умолчанию нижележащего типа данных. Указать COLLATE
можно, только если нижележащий тип данных является сортируемым.
DEFAULT выражение
Предложение DEFAULT определяет значение по умолчанию для столбцов, типом данных кото-
рых является этот домен. Значением может быть любое выражение без переменных (подзапро-
сы также не допускаются). Тип данных этого выражения должен соответствовать типу данных
домена. Если значение по умолчанию не указано, им будет значение NULL.
Значение по умолчанию будет использоваться в любой операции добавления строк, в которой
не задано значение для этого столбца. Если значение по умолчанию установлено для конкрет-
ного столбца, оно будет переопределять значение по умолчанию, связанное с доменом. В свою
1442CREATE DOMAIN
очередь, значение по умолчанию для домена переопределяет любое значение по умолчанию,
связанное с нижележащим типом данных.
CONSTRAINT имя_ограничения
Имя ограничения. Если не указано явно, имя будет сгенерировано системой.
NOT NULL
Значения этого домена будут отличны от NULL (но см. замечания ниже).
NULL
Этот домен может содержать значение NULL. Это свойство домена по умолчанию.
Это предложение предназначено только для совместимости с нестандартными базами данных
SQL. Использовать его в новых приложениях не рекомендуется.
CHECK (выражение)
Предложения CHECK задают ограничения целостности или проверки, которым должны удовле-
творять значения домена. Каждое ограничение должно представлять собой выражение, выда-
ющее результат типа Boolean. Проверяемое значение в этом выражении обозначается ключе-
вым словом VALUE. Если выражение выдаёт FALSE, сообщается об ошибке и приведение значе-
ния к типу домена запрещается.
В настоящее время выражения CHECK не могут содержать переменные, кроме VALUE, и подза-
просы.
Когда для домена задано несколько ограничений CHECK, они будут проверяться в алфавитном
порядке имён. (До версии 9.5 в PostgreSQL не было установлено никакого определённого по-
рядка обработки ограничений CHECK.)
Замечания
Ограничения домена, в частности NOT NULL, проверяются при преобразовании значения к типу до-
мена. Однако из столбца, который номинально имеет тип домена, всё же можно прочитать NULL,
несмотря на такое ограничение. Например, это может происходить в запросе внешнего соедине-
ния, если столбец домена окажется в обнуляемой стороне внешнего соединения. Более тонкий
пример:
INSERT INTO tab (domcol) VALUES ((SELECT domcol FROM tab WHERE false));
Пустой скалярный вложенный SELECT выдаст значение NULL, типом которого будет считаться
домен, так что к этому значению не будут применены дополнительные проверки ограничений и
строка будет успешно добавлена.
Избежать таких проблем очень сложно, так как в SQL вообще предполагается, что значение NULL
является подходящим для любого типа данных. Таким образом, лучше всего разрабатывать огра-
ничения так, чтобы значения NULL допускались, а затем при необходимости применять ограни-
чения NOT NULL к столбцам доменного типа, а не непосредственно к самому этому типу.
Примеры
В этом примере создаётся тип данных us_postal_code (почтовый индекс США), который затем
используется в определении таблицы. Для проверки значения на соответствие формату почтовых
индексов США применяется проверка с регулярными выражениями:
CREATE DOMAIN us_postal_code AS TEXT
CHECK(
VALUE ~ ‘^\d(5)$’
OR VALUE ~ ‘^\d(5)-\d(4)$’
);
1443CREATE DOMAIN
CREATE TABLE us_snail_addy (
address_id SERIAL PRIMARY KEY,
street1 TEXT NOT NULL,
street2 TEXT,
street3 TEXT,
city TEXT NOT NULL,
postal us_postal_code NOT NULL
);
Совместимость
Команда CREATE DOMAIN соответствует стандарту SQL.
См. также
ALTER DOMAIN, DROP DOMAIN
1444CREATE EVENT TRIGGER
CREATE EVENT TRIGGER — создать событийный триггер
Синтаксис
CREATE EVENT TRIGGER имя
ON событие
[ WHEN переменная_фильтра IN (filter_value [, … ]) [ AND … ] ]
EXECUTE ( FUNCTION | PROCEDURE ) имя_функции()
Описание
CREATE EVENT TRIGGER создаёт новый событийный триггер. Функция триггера выполняется, когда
происходит указанное событие и удовлетворяется связанное с триггером условие WHEN (если такое
имеется). За вводной информацией по триггерам обратитесь к Главе 40. Владельцем триггера ста-
новится пользователь его создавший.
Параметры
имя
Имя, назначаемое новому триггеру. Это имя должно быть уникальным в базе данных.
событие
Имя события, при котором срабатывает триггер и вызывается заданная функция. Подробнее
об именах событий можно узнать в Разделе 40.1.
переменная_фильтра
Имя переменной, применяемой для фильтрования событий. Это указание позволяет ограни-
чить срабатывание триггера подмножеством случаев, в которых он поддерживается. В настоя-
щее время единственно возможное значение параметра переменная_фильтра — TAG.
значение_фильтра
Список значений связанного параметра переменная_фильтра, для которых должен срабатывать
триггер. Для переменной TAG это список меток команд (например, ‘DROP FUNCTION’).
имя_функции
Заданная пользователем функция, объявленная как функция без аргументов и возвращающая
тип event_trigger.
В синтаксисе CREATE EVENT TRIGGER ключевые слова FUNCTION и PROCEDURE равнозначны, но
указываемая функция должна в любом случае быть функцией, а не процедурой. Ключевое слово
PROCEDURE здесь поддерживается по историческим причинам и считается устаревшим.
Замечания
Создавать событийные триггеры могут только суперпользователи.
Событийные триггеры не вызываются в однопользовательском режиме (см. postgres). Если оши-
бочный событийный триггер заблокировал работу с базой данных так, что даже удалить его нель-
зя, перезапустите сервер в однопользовательском режиме и это можно будет сделать.
Примеры
Триггер, запрещающий выполнение любой команды DDL:
1445CREATE EVENT TRIGGER
CREATE OR REPLACE FUNCTION abort_any_command()
RETURNS event_trigger
LANGUAGE plpgsql
AS <script type="math/tex">BEGIN
RAISE EXCEPTION 'command % is disabled', tg_tag;
END;</script>;
CREATE EVENT TRIGGER abort_ddl ON ddl_command_start
EXECUTE FUNCTION abort_any_command();
Совместимость
Оператор CREATE EVENT TRIGGER отсутствует в стандарте SQL.
См. также
ALTER EVENT TRIGGER, DROP EVENT TRIGGER, CREATE FUNCTION
1446CREATE EXTENSION
CREATE EXTENSION — установить расширение
Синтаксис
CREATE EXTENSION [ IF NOT EXISTS ] имя_расширения
[ WITH ] [ SCHEMA имя_схемы ]
[ VERSION версия ]
[ FROM старая_версия ]
[ CASCADE ]
Описание
CREATE EXTENSION загружает в текущую базу данных новое расширение. Расширение с таким име-
нем не должно быть уже загружено.
Загрузка расширения по сути сводится к запуску скрипта расширения. Этот скрипт обычно созда-
ёт новые SQL-объекты, такие как функции, типы данных, операторы и методы поддержки индек-
сов. CREATE EXTENSION дополнительно записывает идентификаторы всех добавляемых объектов,
так что впоследствии их можно удалить, выполнив команду DROP EXTENSION.
Для загрузки расширения требуются те же права, что необходимы для создания составляющих его
объектов. Для большинства расширений это означает, что необходимы права владельца базы дан-
ных или суперпользователя. Пользователь, запускающий CREATE EXTENSION, становится владель-
цем самого расширения (это требуется для последующих проверок доступа), а также владельцем
всех объектов, созданных скриптом расширения.
Параметры
IF NOT EXISTS
Не считать ошибкой, если расширение с таким именем уже существует. В этом случае будет
выдано замечание. Заметьте, что нет никакой гарантии, что существующее расширение как-
то соотносится с тем, которое могло бы быть создано из указанного скрипта.
имя_расширения
Имя устанавливаемого расширения. PostgreSQL создаст расширение, используя инструкции из
файла SHAREDIR/extension/имя_расширения.control.
имя_схемы
Имя схемы, в которую будут установлены объекты расширения (подразумевается, что расши-
рение позволяет управлять размещением своих объектов). Указанная схема должна уже суще-
ствовать. Если имя не указано и в управляющем файле расширения оно так же не задано, для
создания объектов используется текущая схема.
Если в управляющем файле расширения задаётся параметр schema, заданную схему нельзя
переопределить предложением SCHEMA. Обычно при указании предложения SCHEMA возникает
ошибка, если эта схема конфликтует с параметром schema данного расширения. Однако, если
также задаётся предложение CASCADE, в случае конфликта имя_схемы игнорируется. Заданное
имя_схемы будет использоваться для установки всех необходимых расширений, в управляющих
файлах которых не задаётся schema.
Помните, что само расширение не считается принадлежащим какой-либо схеме; имена расши-
рений не дополняются схемой и потому должны быть уникальными во всей базе данных. Одна-
ко объекты, принадлежащие расширениям, могут относиться к схемам.
1447CREATE EXTENSION
версия
Версия устанавливаемого расширения. Её можно записать в виде идентификатора или строко-
вого значения. По умолчанию версия считывается из управляющего файла расширения.
старая_версия
Указание FROM старая_версия может быть добавлено тогда и только тогда, когда устанавлива-
емое расширение заменяет модуль «старого стиля», представляющий собой просто набор объ-
ектов, не упакованный в расширение. С этим указанием CREATE EXTENSION запускает альтер-
нативный установочный скрипт, собирающий все существующие объекты в расширение, а не
создающий новые. Учтите, что SCHEMA при этом определяет схему, содержащую эти существу-
ющие объекты.
Значение, задаваемое в качестве старой_версии, определяется автором расширения и может
меняться, если в расширение нужно преобразовать не одну версию модуля в старом стиле. Для
стандартных дополнительных модулей, поставляемых в PostgreSQL до версии 9.1, при преоб-
разовании модуля в расширение старая_версия должна содержать значение unpackaged.
CASCADE
Автоматически устанавливать все расширения, от которого зависит данное, если они ещё не
установлены. Их зависимости подобным образом рекурсивно устанавливаются автоматически.
Предложение SCHEMA, если задано, применяется ко всем расширениям, устанавливаемым та-
ким способом. Другие параметры оператора к автоматически устанавливаемым расширениям
не применяются; в частности, всегда выбираются их версии по умолчанию.
Замечания
Прежде чем вы сможете выполнить CREATE EXTENSION и загрузить расширение в базу данных,
необходимо правильно установить сопутствующие файлы расширения. Информацию об установ-
ке расширений, поставляемых в составе PostgreSQL, можно найти по ссылке Дополнительные по-
ставляемые модули.
Расширения, доступные для установки в данный момент, можно найти в системном представлении
pg_available_extensions или pg_available_extension_versions.
За информацией для разработчиков расширений обратитесь к Разделу 38.16.
Примеры
Установка расширения hstore в текущую базу данных:
CREATE EXTENSION hstore;
Преобразование установленного до версии 9.1 модуля hstore в расширение:
CREATE EXTENSION hstore SCHEMA public FROM unpackaged;
Будьте внимательны — здесь нужно указать схему, в которую ранее были установлены существу-
ющие объекты hstore.
Совместимость
CREATE EXTENSION является расширением PostgreSQL.
См. также
ALTER EXTENSION, DROP EXTENSION
1448CREATE FOREIGN DATA WRAPPER
CREATE FOREIGN DATA WRAPPER — создать новую обёртку сторонних данных
Синтаксис
CREATE FOREIGN DATA WRAPPER имя
[ HANDLER функция_обработчик | NO HANDLER ]
[ VALIDATOR функция_проверки | NO VALIDATOR ]
[ OPTIONS ( параметр ‘значение’ [, … ] ) ]
Описание
CREATE FOREIGN DATA WRAPPER создаёт обёртку сторонних данных. Владельцем обёртки становится
создавший её пользователь.
Имя обёртки сторонних данных должно быть уникальным в базе данных.
Создавать обёртки сторонних данных могут только суперпользователи.
Параметры
имя
Имя создаваемой обёртки сторонних данных.
HANDLER функция_обработчик
В аргументе функция_обработчик указывается имя ранее зарегистрированной функции, кото-
рая будет вызываться для получения функций, реализующих обращения к сторонним табли-
цам. Функция-обработчик не принимает аргументы и возвращает результат типа fdw_handler.
Обёртку сторонних таблиц можно создать и без функции-обработчика, но через такую обёртку
нельзя будет использовать сторонние таблицы, хотя объявить их вполне возможно.
VALIDATOR функция_проверки
В аргументе функция_проверки указывается имя ранее зарегистрированной функции, которая
будет вызываться для проверки общих параметров, передаваемых обёртке сторонних данных,
а также параметров сторонних серверов, сопоставлений пользователей и сторонних таблиц,
доступных через эту обёртку. Если функция проверки не задана или указано NO VALIDATOR,
параметры не будут проверяться во время создания объектов. (Обёртка сторонних данных мо-
жет игнорировать или не принимать неверные указания параметров во время выполнения, в
зависимости от реализации.) Функция проверки должна принимать два аргумента: первый ти-
па text[] (в нём содержится массив параметров, хранящихся в системном каталоге), а второй
типа oid (в нём указывается OID системного каталога с этими параметрами). Возвращаемое
значение игнорируется; функция проверки должна сообщать о неверных параметрах, вызывая
системную функцию ereport(ERROR).
OPTIONS ( параметр ‘значение’ [, … ] )
Это предложение определяет параметры для создаваемой обёртки сторонних данных. Набор
допустимых параметров и значений для каждой обёртки свой, контроль их правильности осу-
ществляет функция проверки сторонних данных. Имена параметров должны быть уникальны-
ми.
Замечания
Функциональность PostgreSQL по работе со сторонними данными продолжает активно развивать-
ся. На данный момент выполняется только примитивная оптимизация запросов (и по большей ча-
1449CREATE FOREIGN DATA WRAPPER
сти это тоже делает обёртка), так что в этом направлении есть поле для улучшения производи-
тельности.
Примеры
Создание бесполезной обёртки сторонних данных dummy:
CREATE FOREIGN DATA WRAPPER dummy;
Создание обёртки сторонних данных file с функцией-обработчиком file_fdw_handler:
CREATE FOREIGN DATA WRAPPER file HANDLER file_fdw_handler;
Создание обёртки сторонних данных mywrapper с параметрами:
CREATE FOREIGN DATA WRAPPER mywrapper
OPTIONS (debug ‘true’);
Совместимость
CREATE FOREIGN DATA WRAPPER соответствует стандарту ISO/IEC 9075-9 (SQL/MED), за исключением
того, что предложения HANDLER и VALIDATOR стандартом не предусмотрены, а предложения LIBRARY
и LANGUAGE, напротив, не реализованы в PostgreSQL.
Учтите, однако, что функциональность SQL/MED в целом ещё не обеспечивается.
См. также
ALTER FOREIGN DATA WRAPPER, DROP FOREIGN DATA WRAPPER, CREATE SERVER, CREATE USER
MAPPING, CREATE FOREIGN TABLE
1450CREATE FOREIGN TABLE
CREATE FOREIGN TABLE — создать стороннюю таблицу
Синтаксис
CREATE FOREIGN TABLE [ IF NOT EXISTS ] имя_таблицы ( [
( имя_столбца тип_данных [ OPTIONS ( параметр ‘значение’ [, … ] ) ]
[ COLLATE правило_сортировки ] [ ограничение_столбца [ … ] ]
| ограничение_таблицы )
[, … ]
] )
[ INHERITS ( таблица_родитель [, … ] ) ]
SERVER имя_сервера
[ OPTIONS ( параметр ‘значение’ [, … ] ) ]
CREATE FOREIGN TABLE [ IF NOT EXISTS ] имя_таблицы
PARTITION OF таблица_родитель [ (
( имя_столбца [ WITH OPTIONS ] [ ограничение_столбца [ … ] ]
| ограничение_таблицы )
[, … ]
) ] указание_границ_секции
SERVER имя_сервера
[ OPTIONS ( параметр ‘значение’ [, … ] ) ]
Здесь ограничение_столбца:
[ CONSTRAINT имя_ограничения ]
( NOT NULL |
NULL |
CHECK ( выражение ) [ NO INHERIT ] |
DEFAULT выражение_по_умолчанию )
и ограничение_таблицы:
[ CONSTRAINT имя_ограничения ]
CHECK ( выражение ) [ NO INHERIT ]
Описание
CREATE FOREIGN TABLE создаёт новую стороннюю таблицу в текущей базе данных. Владельцем
таблицы будет пользователь, выполнивший эту команду.
Если указано имя схемы (например, CREATE FOREIGN TABLE myschema.mytable …), таблица будет
создана в этой схеме. В противном случае она создаётся в текущей схеме. Имя сторонней таблицы
должно отличаться от имён других сторонних и обычных таблиц, последовательностей, индексов,
представлений и материализованных представлений, существующих в этой схеме.
CREATE FOREIGN TABLE также автоматически создаёт составной тип данных, соответствующий од-
ной строке сторонней таблицы. Таким образом, имя сторонней таблицы не может совпадать с име-
нем существующего типа в этой же схеме.
Если указано предложение PARTITION OF, таблица создаётся в виде секции parent_table с указан-
ными границами.
Чтобы создать стороннюю таблицу, необходимо иметь право USAGE для стороннего сервера, а также
право USAGE для всех типов столбцов, содержащихся в таблице.
1451CREATE FOREIGN TABLE
Параметры
IF NOT EXISTS
Не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет
выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то
соотносится с тем, которое могло бы быть создано.
имя_таблицы
Имя создаваемой таблицы (возможно, дополненное схемой).
имя_столбца
Имя столбца, создаваемого в новой таблице.
тип_данных
Тип данных столбца (может включать определение массива с этим типом). За дополнительными
сведениями о типах данных, которые поддерживает PostgreSQL, обратитесь к Главе 8.
COLLATE правило_сортировки
Предложение COLLATE назначает правило сортировки для столбца (который должен иметь тип,
поддерживающий сортировку). Если оно отсутствует, используется правило сортировки по
умолчанию, установленное для типа данных столбца.
INHERITS ( таблица_родитель [, … ] )
Необязательное предложение INHERITS определяет список таблиц, от которых новая сторонняя
таблица будет автоматически наследовать все столбцы. Родительскими таблицами могут быть
обычные или сторонние таблицы. За подробностями обратитесь к описанию подобной формы
CREATE TABLE.
CONSTRAINT имя_ограничения
Необязательное имя столбца или ограничения таблицы. При нарушении ограничения его имя
будет выводиться в сообщении об ошибках, так что имена ограничений вида столбец должен
быть положительным могут сообщить полезную информацию об ограничении клиентскому при-
ложению. (Имена ограничений, включающие пробелы, необходимо заключать в двойные ка-
вычки.) Если имя ограничения не указано, система генерирует имя автоматически.
NOT NULL
Данный столбец не принимает значения NULL.
NULL
Данный столбец может содержать значения NULL (по умолчанию).
Это предложение предназначено только для совместимости с нестандартными базами данных
SQL. Использовать его в новых приложениях не рекомендуется.
CHECK ( выражение ) [ NO INHERIT ]
В ограничении CHECK задаётся выражение, возвращающее булевский результат, которому
должны удовлетворять все строки в сторонней таблице; то есть это выражение должно выда-
вать TRUE или UNKNOWN, но никогда FALSE, для всех строк в сторонней таблице. Ограниче-
ние-проверка, заданное как ограничение столбца, должно ссылаться только на значение само-
го столбца, тогда как ограничение на уровне таблицы может ссылаться и на несколько столб-
цов.
В настоящее время выражения CHECK не могут содержать подзапросы или ссылаться на пере-
менные, кроме как на столбцы текущей строки. Также допустима ссылка на системный столбец
tableoid, но не на другие системные столбцы.
1452CREATE FOREIGN TABLE
Ограничение с пометкой NO INHERIT не будет наследоваться дочерними таблицами.
DEFAULT выражение_по_умолчанию
Предложение DEFAULT задаёт значение по умолчанию для столбца, в определении которого оно
присутствует. Значение задаётся выражением без переменных (подзапросы и перекрёстные
ссылки на другие столбцы текущей таблицы в нём не допускаются). Тип данных выражения,
задающего значение по умолчанию, должен соответствовать типу данных столбца.
Это выражение будет использоваться во всех операциях добавления данных, в которых не за-
даётся значение данного столбца. Если значение по умолчанию не определено, таким значе-
нием будет NULL.
имя_сервера
Имя существующего стороннего сервера, предоставляющего данную стороннюю таблицу. О
создании сервера можно узнать в CREATE SERVER.
OPTIONS ( параметр ‘значение’ [, …] )
Параметры, связываемые с новой сторонней таблицей или одним из её столбцов. Допустимые
имена и значения параметров у каждой обёртки сторонних данных свои; они контролируются
функцией проверки, связанной с этой обёрткой. Имена параметров не должны повторяться
(хотя параметр таблицы и параметр столбца вполне могут иметь одно имя).
Замечания
Ограничения сторонних таблиц (например, CHECK и NOT NULL) не контролируются ядром системы
PostgreSQL, как не пытаются их контролировать и большинство обёрток сторонних данных; то есть,
система просто предполагает, что ограничение выполняется. Контролировать такое ограничение
не имело бы большого смысла, так как оно применялось бы только к строкам, добавляемым или из-
меняемым через стороннюю таблицу, но не к строкам, модифицируемым другим путём, например,
непосредственно на удалённом сервере. Вместо этого, ограничение, связанное со сторонней таб-
лицей, должно представлять ограничение, выполнение которого обеспечивает удалённый сервер.
Некоторые специализированные обёртки сторонних данных могут быть единственным вариантом
обращения к доступным через них данным, и в этом случае может быть уместно реализовать кон-
троль ограничений в самой такой обёртке. Но не следует полагать, что какая-либо обёртка ведёт
себя так, если об этом не сказано явно в её документации.
Хотя PostgreSQL не пытается контролировать ограничения для сторонних таблиц, он полагает, что
они выполняются для целей оптимизации запросов. Если в сторонней таблице будут видны строки,
не удовлетворяющие объявленному ограничению, запросы к этой таблицы могут выдавать некор-
ректные результаты. Ответственность за фактическое выполнение условия ограничения лежит на
пользователе.
Примеры
Создание сторонней таблицы films, которая будет доступна через сервер film_server:
CREATE FOREIGN TABLE films (
code
char(5) NOT NULL,
title
varchar(40) NOT NULL,
did
integer NOT NULL,
date_prod
date,
kind
varchar(10),
len
interval hour to minute
)
SERVER film_server;
Создание сторонней таблицы measurement_y2016m07, которая будет доступна через сервер
server_07, в виде секции таблицы measurement, секционированной по диапазонам:
1453CREATE FOREIGN TABLE
CREATE FOREIGN TABLE measurement_y2016m07
PARTITION OF measurement FOR VALUES FROM (‘2016-07-01’) TO (‘2016-08-01’)
SERVER server_07;
Совместимость
Команда CREATE FOREIGN TABLE в основном соответствует стандарту SQL; однако, как и CREATE
TABLE, она допускает ограничения NULL и сторонние таблицы с нулём столбцов. Возможность за-
давать значения по умолчанию для столбцов также является расширением PostgreSQL. Наследо-
вание таблиц, в форме, определённой в PostgreSQL, стандарту не соответствует.
См. также
ALTER FOREIGN TABLE, DROP FOREIGN TABLE, CREATE TABLE, CREATE SERVER, IMPORT
FOREIGN SCHEMA
1454CREATE FUNCTION
CREATE FUNCTION — создать функцию
Синтаксис
CREATE [ OR REPLACE ] FUNCTION
имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ ( DEFAULT |
= ) выражение_по_умолчанию ] [, …] ] )
[ RETURNS тип_результата
| RETURNS TABLE ( имя_столбца тип_столбца [, …] ) ]
( LANGUAGE имя_языка
| TRANSFORM ( FOR TYPE имя_типа ) [, … ]
| WINDOW
| IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
| CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
| [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
| PARALLEL ( UNSAFE | RESTRICTED | SAFE )
| COST стоимость_выполнения
| ROWS строк_в_результате
| SET параметр_конфигурации ( TO значение | = значение | FROM CURRENT )
| AS ‘определение’
| AS ‘объектный_файл’, ‘объектный_символ’
) …
Описание
Команда CREATE FUNCTION определяет новую функцию. CREATE OR REPLACE FUNCTION создаёт новую
функцию, либо заменяет определение уже существующей. Чтобы определить функцию, необходи-
мо иметь право USAGE для соответствующего языка.
Если указано имя схемы, функция создаётся в заданной схеме, в противном случае — в текущей.
Имя новой функции должно отличаться от имён существующих функций или процедур с такими
же типами аргументов в этой схеме. Однако функции и процедуры с аргументами разных типов
могут иметь одно имя (это называется перегрузкой).
Чтобы заменить текущее определение существующей функции, используйте команду CREATE OR
REPLACE FUNCTION. Но учтите, что она не позволяет изменить имя или аргументы функции (если
попытаться сделать это, на самом деле будет создана новая, независимая функция). Кроме того,
CREATE OR REPLACE FUNCTION не позволит изменить тип результата существующей функции. Чтобы
сделать это, придётся удалить функцию и создать её заново. (Это означает, что если функция имеет
выходные параметры (OUT), то изменить типы параметров OUT можно, только удалив функцию.)
Когда команда CREATE OR REPLACE FUNCTION заменяет существующую функцию, владелец и права
доступа к этой функции не меняются. Все другие свойства функции получают значения, задавае-
мые командой явно или по умолчанию. Чтобы заменить функцию, необходимо быть её владельцем
(или быть членом роли-владельца).
Если вы удалите и затем вновь создадите функцию, новая функция станет другой сущностью, от-
личной от старой; вам потребуется так же удалить существующие правила, представления, триг-
геры и т. п., ссылающиеся на старую функцию. Поэтому, чтобы изменить определение функции,
сохраняя ссылающиеся на неё объекты, следует использовать CREATE OR REPLACE FUNCTION. Кроме
того, многие дополнительные свойства существующей функции можно изменить с помощью ALTER
FUNCTION.
Владельцем функции становится создавший её пользователь.
1455CREATE FUNCTION
Чтобы создать функцию, необходимо иметь право USAGE для типов её аргументов и возвращаемого
типа.
Параметры
имя
Имя создаваемой функции (возможно, дополненное схемой).
режим_аргумента
Режим аргумента: IN (входной), OUT (выходной), INOUT (входной и выходной) или VARIADIC (пе-
ременный). По умолчанию подразумевается IN. За единственным аргументом VARIADIC могут
следовать только аргументы OUT. Кроме того, аргументы OUT и INOUT нельзя использовать с
предложением RETURNS TABLE.
имя_аргумента
Имя аргумента. Некоторые языки (включая SQL и PL/pgSQL) позволяют использовать это имя
в теле функции. Для других языков это имя служит просто дополнительным описанием, если
говорить о самой функции; однако вы можете указывать имена аргументов при вызове функции
для улучшения читаемости (см. Раздел 4.3). Имя выходного аргумента в любом случае имеет
значение, так как оно определяет имя столбца в типе результата. (Если вы опустите имя вы-
ходного аргумента, система выберет для него имя по умолчанию.)
тип_аргумента
Тип данных аргумента функции (возможно, дополненный схемой), при наличии аргументов.
Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка
на столбец таблицы.
В зависимости от языка реализации также может допускаться указание «псевдотипов», напри-
мер, cstring. Псевдотипы показывают, что фактический тип аргумента либо определён не пол-
ностью, либо существует вне множества обычных типов SQL.
Ссылка на тип столбца записывается в виде имя_таблицы.имя_столбца%TYPE. Иногда такое ука-
зание бывает полезно, так как позволяет создать функцию, независящую от изменений в опре-
делении таблицы.
выражение_по_умолчанию
Выражение, используемое для вычисления значения по умолчанию, если параметр не задан
явно. Результат выражения должен сводиться к типу соответствующего параметра. Значения
по умолчанию могут иметь только входные параметры (включая INOUT). Для всех входных па-
раметров, следующих за параметром с определённым значением по умолчанию, также должны
быть определены значения по умолчанию.
тип_результата
Тип возвращаемых данных (возможно, дополненный схемой). Это может быть базовый, состав-
ной или доменный тип, либо ссылка на тип столбца таблицы. В зависимости от языка реализа-
ции здесь также могут допускаться «псевдотипы», например cstring. Если функция не должна
возвращать значение, в качестве типа результата указывается void.
В случае наличия параметров OUT или INOUT, предложение RETURNS можно опустить. Если
оно присутствует, оно должно согласовываться с типом результата, выводимым из выходных
параметров: в качестве возвращаемого типа указывается RECORD, если выходных параметров
несколько, либо тип единственного выходного параметра.
Указание SETOF показывает, что функция возвращает множество, а не единственный элемент.
Ссылка на тип столбца записывается в виде имя_таблицы.имя_столбца%TYPE.
1456CREATE FUNCTION
имя_столбца
Имя выходного столбца в записи RETURNS TABLE. По сути это ещё один способ объявить имено-
ванный выходной параметр (OUT), но RETURNS TABLE также подразумевает и RETURNS SETOF.
тип_столбца
Тип данных выходного столбца в записи RETURNS TABLE.
имя_языка
Имя языка, на котором реализована функция. Это может быть sql, c, internal, либо имя про-
цедурного языка, определённого пользователем, например, plpgsql. Стиль написания этого
имени в апострофах считается устаревшим и требует точного совпадения регистра.
TRANSFORM ( FOR TYPE имя_типа ) [, … ] )
Устанавливает список трансформаций, которые должны применяться при вызове функции.
Трансформации выполняют преобразования между типами SQL и типами данных, специфич-
ными для языков; см. CREATE TRANSFORM. Преобразования встроенных типов обычно жёстко
предопределены в реализациях процедурных языков, так что их здесь указывать не нужно. Ес-
ли реализация процедурного языка не может обработать тип и трансформация для него отсут-
ствует, будет выполнено преобразование типов по умолчанию, но это зависит от реализации.
WINDOW
Указание WINDOW показывает, что создаётся не простая, а оконная функция. В настоящее вре-
мя это имеет смысл только для функций, написанных на C. Атрибут WINDOW нельзя изменить,
модифицируя впоследствии определение функции.
IMMUTABLE
STABLE
VOLATILE
Эти атрибуты информируют оптимизатор запросов о поведении функции. Одновременно мож-
но указать не более одного атрибута. Если никакой атрибут не задан, по умолчанию подразу-
мевается VOLATILE.
Характеристика IMMUTABLE (постоянная) показывает, что функция не может модифицировать
базу данных и всегда возвращает один и тот же результат при определённых значениях аргу-
ментов; то есть, она не обращается к базе данных и не использует информацию, не переданную
ей явно в списке аргументов. Если функция имеет такую характеристику, любой её вызов с
аргументами-константами можно немедленно заменить значением функции.
Характеристика STABLE (стабильная) показывает, что функция не может модифицировать базу
данных и в рамках одного сканирования таблицы она всегда возвращает один и тот же резуль-
тат для определённых значений аргументов, но этот результат может быть разным в разных
операторах SQL. Это подходящий выбор для функций, результаты которых зависят от содержи-
мого базы данных и настраиваемых параметров (например, текущего часового пояса). (Но этот
вариант не подходит для триггеров AFTER, желающих прочитать строки, изменённые текущей
командой.) Также заметьте, что функции семейства current_timestamp также считаются ста-
бильными, так как их результаты не меняются внутри транзакции.
Характеристика VOLATILE (изменчивая) показывает, что результат функции может меняться
даже в рамках одного сканирования таблицы, так что её вызовы нельзя оптимизировать. Из-
менчивы в этом смысле относительно немногие функции баз данных, например: random(),
currval() и timeofday(). Но заметьте, что любая функция с побочными эффектами должна
быть классифицирована как изменчивая, даже если её результат вполне предсказуем, чтобы
её вызовы не были соптимизированы; пример такой функции: setval().
За дополнительными подробностями обратитесь к Разделу 38.7.
1457CREATE FUNCTION
LEAKPROOF
Характеристика LEAKPROOF (герметичная) показывает, что функция не имеет побочных эффек-
тов. Она не раскрывает информацию о своих аргументах, кроме как возвращая результат. На-
пример, функция, которая выдаёт сообщение об ошибке с некоторыми, но не всеми значени-
ями аргументов, либо выводит значения аргументов в сообщении об ошибке, не является гер-
метичной. Это влияет на то, как система выполняет запросы к представлениям, созданным с
барьером безопасности (с указанием security_barrier), или к таблицам с включённой защи-
той строк. Во избежание неконтролируемой утечки данных система будет проверять условия
из политик защиты и определений представлений с барьерами безопасности перед любыми
условиями, которые задаёт пользователь в самом запросе и в которых задействуются негерме-
тичные функции. Функции и операторы, помеченные как герметичные, считаются доверенны-
ми и могут выполняться перед условиями из политик защиты и представлений с барьерами
безопасности. При этом функции, которые не имеют аргументов или которым не передаются
никакие аргументы из представления с барьером безопасности или таблицы, не требуется по-
мечать как герметичные, чтобы они выполнялись до условий, связанных с безопасностью. См.
CREATE VIEW и Раздел 41.5. Это свойство может установить только суперпользователь.
CALLED ON NULL INPUT
RETURNS NULL ON NULL INPUT
STRICT
CALLED ON NULL INPUT (по умолчанию) показывает, что функция будет вызвана как обычно, если
среди её аргументов оказываются значения NULL. В этом случае ответственность за проверку
значений NULL и соответствующую их обработку ложится на разработчика функции.
Указание RETURNS NULL ON NULL INPUT или STRICT показывает, что функция всегда возвращает
NULL, получив NULL в одном из аргументов. Такая функция не будет вызываться с аргументами
NULL, вместо этого автоматически будет полагаться результат NULL.
[EXTERNAL] SECURITY INVOKER
[EXTERNAL] SECURITY DEFINER
Характеристика SECURITY INVOKER (безопасность вызывающего) показывает, что функция бу-
дет выполняться с правами пользователя, вызвавшего её. Этот вариант подразумевается по
умолчанию. Вариант SECURITY DEFINER (безопасность определившего) определяет, что функ-
ция выполняется с правами пользователя, владеющего ей.
Ключевое слово EXTERNAL (внешняя) допускается для соответствия стандарту SQL, но являет-
ся необязательным, так как, в отличие от SQL, эта характеристика распространяется на все
функции, а не только внешние.
PARALLEL
Указание PARALLEL UNSAFE означает, что эту функцию нельзя выполнять в параллельном режи-
ме и присутствие такой функции в операторе SQL приводит к выбору последовательного плана
выполнения. Это характеристика функции по умолчанию. Указание PARALLEL RESTRICTED озна-
чает, что функцию можно выполнять в параллельном режиме, но только в ведущем процессе
группы. PARALLEL SAFE показывает, что функция безопасна для выполнения в параллельном
режиме без ограничений.
Функции должны помечаться как небезопасные для параллельного выполнения, если они из-
меняют состояние базы данных, вносят изменения в транзакции, например, используя под-
транзакции, обращаются к последовательностям или пытаются сохранять параметры (напри-
мер, используя setval). Ограниченно параллельными должны помечаться функции, которые
обращаются к временным таблицам, состоянию клиентского подключения, курсорам, подго-
товленным операторам или разнообразному состоянию обслуживающего процесса, которое си-
стема не может синхронизировать в параллельном режиме (например, setseed может выпол-
нять только ведущий процесс группы, так как изменения, внесённые другим процессом, не пе-
редаются ведущему). Вообще, если функция помечена как безопасная, тогда как она является
1458CREATE FUNCTION
ограниченной или небезопасной, либо если она помечена как ограниченно безопасная, не яв-
ляясь безопасной, при попытке вызвать её в параллельном запросе она может выдавать ошибки
или неверные результаты. Функции на языке C при неправильной пометке теоретически могут
проявлять полностью неопределённое поведение, так как система никак не может защититься
от произвольного кода на C, но чаще все они будут вести себя не хуже, чем любая другая функ-
ция. В случае сомнений функцию следует помечать как небезопасную (UNSAFE), что и имеет
место по умолчанию.
COST стоимость_выполнения
Положительное число, задающее примерную стоимость выполнения функции, в единицах
cpu_operator_cost. Если функция возвращает множество, это число задаёт стоимость для одной
строки. Если стоимость не указана, для функций на C и внутренних функций она считается
равной 1 единице, а для функций на всех других языках — 100 единицам. При больших значе-
ниях планировщик будет стараться не вызывать эту функцию чаще, чем это необходимо.
ROWS строк_в_результате
Положительное число, задающее примерное число строк, которое будет ожидать планировщик
на выходе этой функции. Это указание допустимо, только если функция объявлена как возвра-
щающая множество. Предполагаемое по умолчанию значение — 1000 строк.
параметр_конфигурации
значение
Предложение SET определяет, что при вызове функции указанный параметр конфигурации
должен принять заданное значение, а затем восстановить своё предыдущее значение при за-
вершении функции. Предложение SET FROM CURRENT сохраняет в качестве значения, которое
будет применено при входе в функцию, значение, действующее в момент выполнения CREATE
FUNCTION.
Если в определение функции добавлено SET, то действие команды SET LOCAL, выполняемой
внутри функции для того же параметра, ограничивается телом функции: предыдущее значение
параметра так же будет восстановлено при завершении функции. Однако обычная команда SET
(без LOCAL) переопределяет предложение SET, как и предыдущую команду SET LOCAL: действие
такой команды будет сохранено и после завершения функции, если только не произойдёт откат
транзакции.
За подробными сведениями об именах и значениях параметров обратитесь к SET и Главе 19.
определение
Строковая константа, определяющая реализацию функции; её значение зависит от языка. Это
может быть имя внутренней функции, путь к объектному файлу, команда SQL или код функции
на процедурном языке.
Часто бывает полезно заключать определение функции в доллары (см. Подраздел 4.1.2.4), а не
в традиционные апострофы. Если не использовать доллары, все апострофы и обратные косые
черты в определении функции придётся экранировать, дублируя их.
объектный_файл, объектный_символ
Эта форма предложения AS применяется для динамически загружаемых функций на языке C,
когда имя функции в коде C не совпадает с именем функции в SQL. Строка объектный_файл
задаёт имя файла разделяемой библиотеки, содержащей скомпилированную функцию на C, и
воспринимается как параметр команды LOAD. Строка объектный_символ задаёт символ ском-
понованной функции, то есть имя функции в исходном коде на языке C. Если объектный символ
опущен, предполагается, что он совпадает с именем определяемой SQL-функции. В C имена
всех функций должны быть различными, поэтому перегружаемым функциям, реализованным
на C, нужно давать разные имена (например, включать в имена C обозначения типов аргумен-
тов).
1459CREATE FUNCTION
Если повторные вызовы CREATE FUNCTION ссылаются на один и тот же объектный файл, он
загружается в рамках сеанса только один раз. Чтобы выгрузить и загрузить этот файл снова
(например, в процессе разработки), начните новый сеанс.
За дополнительной информацией о разработке функций обратитесь к Разделу 38.3.
Перегрузка
PostgreSQL допускает перегрузку функций; то есть, позволяет использовать одно имя для несколь-
ких различных функций, если у них различаются типы входных аргументов. Независимо от того,
используете вы эту возможность или нет, она требует предосторожности при вызове функций в
базах данных, где одни пользователи не доверяют другим; см. Раздел 10.3.
Две функции считаются совпадающими, если они имеют одинаковые имена и типы входных ар-
гументов, параметры OUT игнорируются. Таким образом, например, эти объявления вызовут кон-
фликт:
CREATE FUNCTION foo(int) …
CREATE FUNCTION foo(int, out text) …
Функции, имеющие разные типы аргументов, не будут считаться конфликтующими в момент со-
здания, но предоставленные для них значения по умолчанию могут вызвать конфликт в момент
использования. Например, рассмотрите следующие определения:
CREATE FUNCTION foo(int) …
CREATE FUNCTION foo(int, int default 42) …
Вызов foo(10) завершится ошибкой из-за неоднозначности в выборе вызываемой функции.
Замечания
В объявлении аргументов функции и возвращаемого значения допускается полный синтаксис
описания типа SQL. Однако модификаторы типа в скобках (например, поле точности для ти-
па numeric) команда CREATE FUNCTION не учитывает. Так что, например, CREATE FUNCTION foo
(varchar(10)) … создаст такую же функцию, что и CREATE FUNCTION foo (varchar) ….
При замене существующей функции с помощью CREATE OR REPLACE FUNCTION есть ограничения на
изменения имён параметров. В частности, нельзя изменить имя, уже назначенное любому входно-
му параметру (хотя можно добавить имена ранее безымянным параметрам). Также, если у функ-
ции более одного выходного параметра, нельзя изменять имена выходных параметров, так как
это приведёт к изменению имён столбцов анонимного составного типа, описывающего результат
функции. Эти ограничения позволяют гарантировать, что существующие вызовы функции не пе-
рестанут работать после её замены.
Если функция объявлена как STRICT с аргументом VARIADIC, при оценивании строгости проверя-
ется, что весь переменный массив в целом не NULL. Если же в этом массиве содержатся элементы
NULL, функция будет вызываться.
Примеры
Ниже приведено несколько простых вводных примеров. За дополнительными сведениями и при-
мерами обратитесь к Разделу 38.3.
CREATE FUNCTION add(integer, integer) RETURNS integer
AS ‘select $1 + $2;’
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;
Функция увеличения целого числа на 1, использующая именованный аргумент, на языке PL/
pgSQL:
1460CREATE FUNCTION
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS <script type="math/tex">BEGIN
RETURN i + 1;
END;</script> LANGUAGE plpgsql;
Функция, возвращающая запись с несколькими выходными параметрами:
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
AS <script type="math/tex">SELECT $1, CAST($1 AS text) || ' is text'</script>
LANGUAGE SQL;
SELECT * FROM dup(42);
То же самое можно сделать более развёрнуто, явно объявив составной тип:
CREATE TYPE dup_result AS (f1 int, f2 text);
CREATE FUNCTION dup(int) RETURNS dup_result
AS <script type="math/tex">SELECT $1, CAST($1 AS text) || ' is text'</script>
LANGUAGE SQL;
SELECT * FROM dup(42);
Ещё один способ вернуть несколько столбцов — применить функцию TABLE:
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
AS <script type="math/tex">SELECT $1, CAST($1 AS text) || ' is text'</script>
LANGUAGE SQL;
SELECT * FROM dup(42);
Однако пример с TABLE отличается от предыдущих, так как в нём функция на самом деле возвра-
щает не одну, а набор записей.
Разработка защищённых функций SECURITY DEFINER
Так как функция SECURITY DEFINER выполняется с правами пользователя, владеющего ей, необхо-
димо позаботиться о том, чтобы её нельзя было использовать не по назначению. В целях безопас-
ности, в пути search_path следует исключить любые схемы, доступные на запись недоверенным
пользователям. Это не позволит злонамеренным пользователям создать свои объекты (например,
таблицы, функции и операторы), которые замаскируют объекты, используемые функцией. Особен-
но важно в этом отношении исключить схему временных таблиц, которая по умолчанию просмат-
ривается первой, а право записи в неё по умолчанию имеют все. Соответствующую защиту мож-
но организовать, поместив временную схему в конец списка поиска. Для этого следует сделать
pg_tempпоследней записью в search_path. Безопасное использование демонстрирует следующая
функция:
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS <script type="math/tex">DECLARE passed BOOLEAN;
BEGIN
SELECT (pwd = $2) INTO passed
FROM
pwds
WHERE
username = $1;
RETURN passed;
END;</script> LANGUAGE plpgsql
SECURITY DEFINER
– Установить безопасный путь поиска: сначала доверенная схема(ы), затем ‘pg_temp’.
SET search_path = admin, pg_temp;
1461CREATE FUNCTION
Эта функция должна обращаться к таблице admin.pwds, но без предложения SET или с предложе-
нием SET, включающим только admin, её можно «обмануть», создав временную таблицу pwds.
До PostgreSQL 8.3 предложение SET отсутствовало, так что старые функции могут содержать до-
вольно сложную логику для сохранения, изменения и восстановления переменной search_path.
Существующее теперь предложение SET позволяет сделать это намного проще.
Также следует помнить о том, что по умолчанию право выполнения для создаваемых функций
имеет роль PUBLIC (за подробностями обратитесь к GRANT). Однако часто требуется разрешить
доступ к функциям, работающим в контексте определившего, только некоторым пользователям.
Для этого необходимо отозвать стандартные права PUBLIC и затем дать права на выполнение ин-
дивидуально. Чтобы не образовалось окно, в котором новая функция будет недоступна совсем, со-
здайте её и назначьте права в одной транзакции. Например, так:
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) … SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
Совместимость
Команда CREATE FUNCTION определена в стандарте SQL. Её реализация в PostgreSQL близка к стан-
дартизированной, но совместима с ней не полностью. К отличиям относятся непереносимые атри-
буты, а также поддержка различных языков.
Для совместимости с другими СУБД режим_аргумента можно записать после имя_аргумента или
перед ним, но стандарту соответствует только первый вариант.
Для определения значений по умолчанию для параметров стандарт SQL поддерживает только син-
таксис с ключевым словом DEFAULT. Синтаксис со знаком = используется в T-SQL и Firebird.
См. также
ALTER FUNCTION, DROP FUNCTION, GRANT, LOAD, REVOKE
1462CREATE GROUP
CREATE GROUP — создать роль в базе данных
Синтаксис
CREATE GROUP имя [ [ WITH ] параметр [ … ] ]
Здесь параметр:
|
|
|
|
|
|
|
|
|
|
|
|
SUPERUSER | NOSUPERUSER
CREATEDB | NOCREATEDB
CREATEROLE | NOCREATEROLE
INHERIT | NOINHERIT
LOGIN | NOLOGIN
[ ENCRYPTED ] PASSWORD ‘пароль’
VALID UNTIL ‘дата_время’
IN ROLE имя_роли [, …]
IN GROUP имя_роли [, …]
ROLE имя_роли [, …]
ADMIN имя_роли [, …]
USER имя_роли [, …]
SYSID uid
Описание
Оператор CREATE GROUP теперь является синонимом оператора CREATE ROLE.
Совместимость
Оператор CREATE GROUP отсутствует в стандарте SQL.
См. также
CREATE ROLE
1463CREATE INDEX
CREATE INDEX — создать индекс
Синтаксис
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] имя ] ON
[ ONLY ] имя_таблицы [ USING метод ]
( ( имя_столбца | ( выражение ) ) [ COLLATE правило_сортировки ] [ класс_операторов
] [ ASC | DESC ] [ NULLS ( FIRST | LAST ) ] [, …] )
[ INCLUDE ( имя_столбца [, …] ) ]
[ WITH ( параметр_хранения = значение [, … ] ) ]
[ TABLESPACE табл_пространство ]
[ WHERE предикат ]
Описание
CREATE INDEX создаёт индексы по указанному столбцу(ам) заданного отношения, которым может
быть таблица или материализованное представление. Индексы применяются в первую очередь для
оптимизации производительности базы данных (хотя при неправильном использовании возможен
и противоположный эффект).
Ключевое поле для индекса задаётся как имя столбца или выражение, заключённое в скобки. Если
метод индекса поддерживает составные индексы, допускается указание нескольких полей.
Поле индекса может быть выражением, вычисляемым из значений одного или нескольких столб-
цов в строке таблицы. Это может быть полезно для получения быстрого доступа к данным по
некоторому преобразованию исходных значений. Например, индекс, построенный по выражению
upper(col), позволит использовать поиск по индексу в предложении WHERE upper(col) = ‘JIM’.
PostgreSQL предоставляет следующие методы индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN.
Пользователи могут определить и собственные методы индексов, но это довольно сложная задача.
Если в команде присутствует предложение WHERE, она создаёт частичный индекс. Такой индекс
содержит записи только для части таблицы, обычно более полезной для индексации, чем осталь-
ная таблица. Например, если таблица содержит информацию об оплаченных и неоплаченных сче-
тах, при этом последних сравнительно немного, но именно эта часть таблицы наиболее востребо-
вана, то увеличить быстродействие можно, создав индекс только по этой части. Ещё одно возмож-
ное применение WHERE — добавив UNIQUE, обеспечить уникальность в подмножестве таблицы. По-
дробнее это рассматривается в Разделе 11.8.
Выражение в предложении WHERE может ссылаться только на столбцы нижележащей таблицы, но
не обязательно ограничиваться теми, по которым строится индекс. В настоящее время в WHERE
также нельзя использовать подзапросы и агрегатные выражения. Это же ограничение распростра-
няется и на выражения в полях индексов.
Все функции и операторы, используемые в определении индекса, должны быть «постоянными»,
то есть, их результаты должны зависеть только от аргументов, но не от внешних факторов (напри-
мер, содержимого другой таблицы или текущего времени). Это ограничение обеспечивает опреде-
лённость поведения индекса. Чтобы использовать в выражении индекса или в предложении WHERE
собственную функцию, не забудьте пометить её при создании как постоянную (IMMUTABLE).
Параметры
UNIQUE
Указывает, что система должна контролировать повторяющиеся значения в таблице при со-
здании индекса (если в таблице уже есть данные) и при каждом добавлении данных. Попытки
1464CREATE INDEX
вставить или изменить данные, при которых будет нарушена уникальность индекса, будут за-
вершаться ошибкой.
Когда уникальные индексы применяются к секционированным таблицам, действуют дополни-
тельные ограничения; см. CREATE TABLE.
CONCURRENTLY
С этим указанием PostgreSQL построит индекс, не устанавливая никаких блокировок, которые
бы предотвращали добавление, изменение или удаление записей в таблице; тогда как по умол-
чанию операция построения индекса блокирует запись (но не чтение) в таблице до своего за-
вершения. При создании индекса в этом режиме есть ряд особенностей, о которых следует
знать — см. Подраздел «Неблокирующее построение индексов».
IF NOT EXISTS
Не считать ошибкой, если индекс с таким именем уже существует. В этом случае будет выдано
замечание. Заметьте, что нет никакой гарантии, что существующий индекс как-то соотносится
с тем, который мог бы быть создан. Имя индекса является обязательным, когда указывается
IF NOT EXISTS.
INCLUDE
Необязательное предложение INCLUDE позволяет указать список столбцов, которые будут вклю-
чены в индекс как неключевые столбцы. Неключевой столбец не может использоваться в усло-
вии поиска для сканирования по индексу, и он не учитывается при анализе ограничения уни-
кальности или исключения, устанавливаемого индексом. Однако при сканировании только ин-
декса содержимое неключевых столбцов может быть получено без обращения к целевой таб-
лице, так как оно находится непосредственно в элементе индекса. Таким образом, в результате
добавления неключевых столбцов сканирование только индекса может использоваться в тех
запросах, где иначе оно было бы неприменимо.
Добавляя в индекс неключевые столбцы, особенно большого размера, есть смысл проявлять
консерватизм. Если кортеж в индексе превышает максимально допустимый размер для данно-
го типа индексов, вставить данные в таблицу не удастся. В неключевых столбцах дублируются
данные из основной таблицы, что приводит к разрастанию индекса и может повлечь замедле-
ние запросов.
Для столбцов, перечисленных в INCLUDE, не нужны соответствующие классы операторов; это
предложение может содержать столбцы, для типов данных которых не определены классы опе-
раторов для заданного метода доступа.
Выражения во включаемых столбцах не поддерживаются, так как их нельзя будет использовать
при сканировании только индекса.
В настоящее время эту возможность поддерживает только метод доступа индекса-B-дерева. В
таких индексах значения столбцов, указанных в предложении INCLUDE, включаются в кортежи
на уровне листьев, которые соответствуют кортежам кучи, но не включаются в элементы верх-
них уровней, используемые для навигации в дереве.
имя
Имя создаваемого индекса. Указание схемы при этом не допускается; индекс всегда относится
к той же схеме, что и родительская таблица. Если имя опущено, PostgreSQL формирует подхо-
дящее имя по имени родительской таблицы и именам индексируемых столбцов.
ONLY
Указывает, что индексы не должны рекурсивно создаваться в секциях секционированной таб-
лицы. По умолчанию создание выполняется рекурсивно.
имя_таблицы
Имя индексируемой таблицы (возможно, дополненное схемой).
1465CREATE INDEX
метод
Имя применяемого метода индекса. Возможные варианты: btree, hash, gist, spgist, gin и brin.
По умолчанию подразумевается метод btree.
имя_столбца
Имя столбца таблицы.
выражение
Выражение с одним или несколькими столбцами таблицы. Обычно выражение должно записы-
ваться в скобках, как показано в синтаксисе команды. Однако скобки можно опустить, если
выражение записано в виде вызова функции.
правило_сортировки
Имя правила сортировки, применяемого для индекса. По умолчанию используется правило
сортировки, заданное для индексируемого столбца, либо полученное для результата выраже-
ния индекса. Индексы с нестандартными правилами сортировки могут быть полезны для за-
просов, включающих выражения с такими правилами.
класс_операторов
Имя класса операторов. Подробнее об этом ниже.
ASC
Указывает порядок сортировки по возрастанию (подразумевается по умолчанию).
DESC
Указывает порядок сортировки по убыванию.
NULLS FIRST
Указывает, что значения NULL после сортировки оказываются перед остальными. Это поведе-
ние по умолчанию с порядком сортировки DESC.
NULLS LAST
Указывает, что значения NULL после сортировки оказываются после остальных. Это поведение
по умолчанию с порядком сортировки ASC.
параметр_хранения
Имя специфичного для индекса параметра хранения. За подробностями обратитесь к Подраз-
делу «Параметры хранения индекса».
табл_пространство
Табличное пространство, в котором будет создан индекс. Если не определено, выбирается
default_tablespace, либо temp_tablespaces, при создании индекса временной таблицы.
предикат
Выражение ограничения для частичного индекса.
Параметры хранения индекса
Необязательное предложение WITH определяет параметры хранения для индекса. У каждого ме-
тода индекса есть свой набор допустимых параметров хранения. Следующий параметр принимают
методы B-дерево, хеш, GiST и SP-GiST:
fillfactor
Фактор заполнения для индекса определяет в процентном отношении, насколько плотно метод
индекса будет заполнять страницы индекса. Для B-деревьев концевые страницы заполняются
1466CREATE INDEX
до этого процента при начальном построении индекса и позже, при расширении индекса впра-
во (добавлении новых наибольших значений ключа). Если страницы впоследствии оказывают-
ся заполненными полностью, они будут разделены, что приводит к постепенному снижению
эффективности индекса. Для B-деревьев по умолчанию используется фактор заполнения 90,
но его можно поменять на любое целое значение от 10 до 100. Фактор заполнения, равный
100, полезен для статических таблиц и помогает уменьшить физический размер таблицы, но
для интенсивно изменяемых таблиц лучше использовать меньшее значение, чтобы разделять
страницы приходилось реже. С другими методами индекса фактор заполнения действует по-
другому, но примерно в том же ключе; значение фактора заполнения по умолчанию для раз-
ных методов разное.
Индексы B-дерево дополнительно принимают этот параметр:
vacuum_cleanup_index_scale_factor
Значение vacuum_cleanup_index_scale_factor для индекса.
Индексы GiST дополнительно принимают этот параметр:
buffering
Определяет, будет ли при построении индекса использоваться буферизация, описанная в Под-
разделе  64.4.1. Со значением OFF она отключена, с ON — включена, а с AUTO — отключена
вначале, но может затем включиться на ходу, как только размер индекса достигнет значения
effective_cache_size. По умолчанию подразумевается AUTO.
Индексы GIN принимают другие параметры:
fastupdate
Этот параметр управляет механизмом быстрого обновления, описанным в Подразделе 66.4.1.
Он имеет логическое значение: ON включает быстрое обновление, OFF отключает его. (Другие
возможные написания ON и OFF перечислены в Разделе 19.1.) Значение по умолчанию — ON.
Примечание
Выключение fastupdate в ALTER INDEX предотвращает помещение добавляемых
в дальнейшем строк в список записей, ожидающих индексации, но записи, до-
бавленные в этот список ранее, в нём остаются. Чтобы очистить очередь опе-
раций, надо затем выполнить VACUUM для этой таблицы или вызвать функцию
gin_clean_pending_list.
gin_pending_list_limit
Пользовательский параметр gin_pending_list_limit. Его значение задаётся в килобайтах.
Индексы BRIN принимают другие параметры:
pages_per_range
Определяет, сколько блоков таблицы образуют зону блоков для каждой записи в индексе BRIN
(за подробностями обратитесь к Разделу 67.1). Значение по умолчанию — 128.
autosummarize
Определяет, нужно ли вычислять сводное значение для зоны предыдущей страницы, когда про-
исходит добавление на следующей странице.
Неблокирующее построение индексов
Создание индекса может мешать обычной работе с базой данных. Обычно PostgreSQL блокирует
индексируемую таблицу от записи и выполняет всю операцию построения индекса за одно ска-
1467CREATE INDEX
нирование таблицы. Другие транзакции могут продолжать читать таблицу, но при попытке вста-
вить, изменить или удалить строки в таблице они будут заблокированы до завершения построения
индекса. Это может оказать нежелательное влияние на работу производственной базы данных.
Индексация очень больших таблиц может занимать много часов, и даже для маленьких таблиц
построение индекса может заблокировать записывающие процессы на время, неприемлемое для
производственной системы.
PostgreSQL поддерживает построение индексов без блокировки записи. Этот метод выбирается
указанием CONCURRENTLY команды CREATE INDEX. Когда он используется, PostgreSQL должен вы-
полнить два сканирования таблицы, а кроме того, должен дождаться завершения всех существую-
щих транзакций, которые потенциально могут модифицировать и использовать этот индекс. Таким
образом, эта процедура требует проделать в сумме больше действий и выполняется значительно
дольше, чем обычное построение индекса. Однако благодаря тому, что этот метод позволяет про-
должать обычную работу с базой во время построения индекса, он оказывается полезным в про-
изводственной среде. Хотя разумеется, дополнительная нагрузка на процессор и подсистему вво-
да/вывода, создаваемая при построении индекса, может привести к замедлению других операций.
При неблокирующем построении индекса он попадает в системный каталог в одной транзакции,
затем ещё два сканирования таблицы выполняются в двух других транзакциях. Перед каждым ска-
нированием таблицы процедура построения индекса должна ждать завершения текущих транзак-
ций, модифицировавших эту таблицу. После второго сканирования также необходимо дожидаться
завершения всех транзакций, получивших снимок (см. Главу  13) перед вторым сканированием.
Наконец индекс может быть помечен как готовый к использованию, после чего команда CREATE
INDEX завершается. Однако даже тогда индекс может быть не готов немедленно к применению в
запросах: в худшем случае он не будет использоваться, пока существуют транзакции, начатые до
начала построения индекса.
Если при сканировании таблицы возникает проблема, например взаимоблокировка или нарушение
уникальности в уникальном индексе, команда CREATE INDEX завершится ошибкой, но оставит после
себя «нерабочий» индекс. Этот индекс будет игнорироваться при чтении данных, так как он может
быть неполным; однако с ним могут быть связаны дополнительные операции при изменениях. В
psql встроенная команда \d помечает такой индекс как INVALID:
postgres=# \d tab
Table “public.tab”
Column | Type
| Collation | Nullable | Default
——–+———+———–+———-+———
col
| integer |
|
|
Indexes:
“idx” btree (col) INVALID
Рекомендуемый в таких случаях способ исправления ситуации — удалить индекс и затем попы-
таться снова выполнить CREATE INDEX CONCURRENTLY. (Кроме того, можно перестроить его с помо-
щью команды REINDEX. Но так как REINDEX не поддерживает неблокирующий режим, вряд ли этот
вариант будет желательным.)
Ещё одна сложность, с которой можно столкнуться при неблокирующем построении уникального
индекса, заключается в том, что ограничение уникальности уже влияет на другие транзакции,
когда второе сканирование таблицы только начинается. Это значит, что нарушения ограничения
могут проявляться в других запросах до того, как индекс становится доступным для использова-
ния и даже тогда, когда создать индекс в итоге не удаётся. Кроме того, если при втором сканиро-
вании происходит ошибка, «нерабочий» индекс оставляет в силе своё ограничение уникальности
и дальше.
Метод неблокирующего построения поддерживает также индексы выражений и частичные индек-
сы. Ошибки, произошедшие при вычислении этих выражений, могут привести к такому же пове-
дению, как в вышеописанных случаях с нарушением ограничений уникальности.
Обычное построение индекса допускает одновременное построение других индексов обычным ме-
тодом, но неблокирующее построение в один момент времени допускается только одно. В любом
1468CREATE INDEX
случае, никакие другие изменения схемы для данной таблицы в это время не разрешаются. Другое
отличие состоит в том, что в блоке транзакции может быть выполнена обычная команда CREATE
INDEX, но не CREATE INDEX CONCURRENTLY.
Замечания
Информацию о том, когда могут применяться, и когда не применяются индексы, и в каких кон-
кретных ситуациях они могут быть полезны, можно найти в Главе 11.
В настоящее время составные индексы поддерживаются только методами B-дерево, GiST, GIN и
BRIN. По умолчанию такой индекс может включать до 32 полей. (Этот предел можно изменить,
пересобрав PostgreSQL.) Уникальные индексы поддерживает только B-дерево.
Для каждого столбца индекса можно задать класс операторов. Этот класс определяет, какие опе-
раторы будут использоваться индексом для этого столбца. Например, индекс-B-дерево по четы-
рёхбайтовым целым будет использовать класс int4_ops; этот класс операторов включает функции
сравнения для таких значений. На практике обычно достаточно использовать класс операторов по
умолчанию для типа данных столбца. Существование классов операторов объясняется в первую
очередь тем, что для некоторых типов данных можно предложить более одного осмысленного по-
рядка сортировки. Например, может возникнуть желание отсортировать комплексные числа как
по абсолютному значению, так и по вещественной части. Это можно сделать, определив два класса
операторов для типа данных и выбрав подходящий класс при создании индекса. За дополнитель-
ными сведениями о классах операторов обратитесь к Разделу 11.9 и Разделу 38.15.
Когда команда CREATE INDEX вызывается для секционированной таблицы, по умолчанию её дей-
ствие распространятся рекурсивно на все секции, с тем чтобы в них оказались соответствующие
индексы. Сначала каждая секция проверяется на наличие равнозначного индекса, и, если таковой
находится, он присоединяется как индекс секции к создаваемому, который таким образом стано-
вится родительским индексом. Если нужного индекса не оказывается, новый индекс автоматиче-
ски создаётся и присоединяется к основному; имя индекса для каждой секции выбирается так же,
как и при выполнении этой команды без имени индекса. С указанием ONLY рекурсия не произво-
дится и индекс помечается как нерабочий. (Команда ALTER INDEX … ATTACH PARTITION пометит
его как рабочий, когда он будет представлен во всех секциях). Однако заметьте, что в любой сек-
ции, создаваемой в будущем командой CREATE TABLE … PARTITION OF, соответствующий индекс
появится автоматически, вне зависимости от данного указания.
Для методов индекса, поддерживающих сканирование по порядку (в настоящее время это поддер-
живает только B-дерево), можно изменить порядок сортировки индекса, добавив необязательные
предложения ASC, DESC, NULLS FIRST или NULLS LAST. Так как упорядоченный индекс можно ска-
нировать вперёд или назад, обычно не имеет смысла создавать индекс по убыванию (DESC) для од-
ного столбца — этот порядок сортировки можно получить и с обычным индексом. Эти параметры
имеют смысл при создании составных индексов так, что они будут соответствовать порядку сор-
тировки, указанному в запросе со смешанным порядком, например SELECT … ORDER BY x ASC, y
DESC. Параметры NULLS полезны, когда требуется реализовать поведение «NULL внизу», изменив
стандартное «NULL вверху», в запросах, зависящих от индексов, чтобы избежать дополнительной
сортировки.
Для большинства методов индексов скорость создания индекса зависит от значения
maintenance_work_mem. Чем больше это значение, тем меньше времени требуется для создания
индекса (если только заданное значение не превышает объём действительно доступной памяти,
что влечёт за собой использование подкачки).
PostgreSQL может строить индексы, задействуя несколько процессоров для ускорения обработки
строк таблицы. Это называется параллельным построением индексов. Для методов индексов, под-
держивающих построение в параллельном режиме (в настоящее время это только B-дерево), па-
раметр maintenance_work_mem задаёт максимальный объём памяти, который может быть выделен
для одной операции построения индекса в целом, независимо от того, сколько рабочих процессов
будет запущено. Целесообразность использования параллельных процессов и их оптимальное ко-
личество обычно автоматически определяется моделью стоимости.
1469CREATE INDEX
Параллельное построение индексов может выиграть от увеличения maintenance_work_mem там, где
для аналогичного последовательного построения индекса выигрыша не будет или он будет мини-
мальным. Заметьте, что значение maintenance_work_mem может влиять на число запрашиваемых
рабочих процессов, так как параллельным исполнителям должно быть выделено не менее 32MB из
общего бюджета maintenance_work_mem. Кроме того, 32MB должно остаться для ведущего процесса.
Увеличение max_parallel_maintenance_workers позволит создать больше исполнителей, что приве-
дёт к уменьшению времени создания индекса, если только создание индекса уже не упирается
в скорость ввода/вывода. Разумеется, для этого должно быть достаточно процессорных ресурсов,
которые иначе бы простаивали.
Если в ALTER TABLE задаётся значение parallel_workers, именно оно определяет, сколько парал-
лельных исполнителей будет запрашивать команда CREATE INDEX для данной таблицы. При этом
полностью игнорируется модель стоимости, и maintenance_work_mem не влияет на определение ко-
личества параллельных исполнителей. Если параметру parallel_workers в ALTER TABLE присваи-
вается 0, параллельное построение индексов для этой таблицы полностью отключается.
Подсказка
После изменения параметра parallel_workers в ходе оптимизации построения индек-
сов имеет смысл сбросить его. Это предотвратит нежелательные изменения планов за-
просов, так как parallel_workers влияет на все параллельные сканирования таблицы.
Хотя CREATE INDEX с указанием CONCURRENTLY поддерживает параллельное построение без особых
ограничений, фактически в параллельном режиме выполняется только первое сканирование таб-
лицы.
Для удаления индекса применяется DROP INDEX.
В предыдущих выпусках PostgreSQL также поддерживался метод индекса R-дерево. Сейчас он от-
сутствует, так как он не даёт значительных преимуществ по сравнению с GiST. Указание USING
rtree команда CREATE INDEX будет интерпретировать как USING gist, для упрощения перевода
старых баз на GiST.
Примеры
Создание уникального индекса-B-дерева по столбцу title в таблице films:
CREATE UNIQUE INDEX title_idx ON films (title);
Создание уникального индекса-B-дерева по столбцу title, а также включённым столбцам
director и rating в таблице films:
CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);
Создание индекса по выражению lower(title), позволяющего эффективно выполнять регистро-
независимый поиск:
CREATE INDEX ON films ((lower(title)));
(В этом примере мы решили опустить имя индекса, чтобы имя выбрала система, например
films_lower_idx.)
Создание индекса с нестандартным правилом сортировки:
CREATE INDEX title_idx_german ON films (title COLLATE “de_DE”);
Создание индекса с нестандартным порядком значений NULL:
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
Создание индекса с нестандартным фактором заполнения:
1470CREATE INDEX
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
Создание индекса GIN с отключённым механизмом быстрого обновления:
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
Создание индекса по столбцу code в таблице films и размещение его в табличном пространстве
indexspace:
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
Создание индекса GiST по координатам точек, позволяющего эффективно использовать операторы
box с результатом функции преобразования:
CREATE INDEX pointloc
ON points USING gist (box(location,location));
SELECT * FROM points
WHERE box(location,location) &amp;&amp; ‘(0,0),(1,1)’::box;
Создание индекса без блокировки записи в таблицу:
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
Совместимость
CREATE INDEX является языковым расширением PostgreSQL. Средства обеспечения индексов в
стандарте SQL не описаны.
См. также
ALTER INDEX, DROP INDEX
1471CREATE LANGUAGE
CREATE LANGUAGE — создать процедурный язык
Синтаксис
CREATE [ OR REPLACE ] [ PROCEDURAL ] LANGUAGE имя
CREATE [ OR REPLACE ] [ TRUSTED ] [ PROCEDURAL ] LANGUAGE имя
HANDLER обработчик_вызова [ INLINE обработчик_внедрённого_кода ]
[ VALIDATOR функция_проверки ]
Описание
CREATE LANGUAGE регистрирует в базе данных PostgreSQL новый процедурный язык. Впоследствии
на этом языке можно будет определять новые функции и процедуры.
Примечание
Начиная с PostgreSQL 9.1, большинство процедурных языков были преобразованы в
«расширения», так что они теперь устанавливаются посредством CREATE EXTENSION,
а не CREATE LANGUAGE. Прямое использование CREATE LANGUAGE теперь следует ограни-
чить скриптами установки расширений. Если в вашей базе данных есть «чистое» опре-
деление языка, возможно, полученное в результате обновления, его можно преобразо-
вать в расширение, выполнив CREATE EXTENSION имя_языка FROM unpackaged.
CREATE LANGUAGE по сути связывает имя языка с функциями-обработчиками, исполняющими код,
написанный на этом языке. За дополнительными сведениями о языковых обработчиках обратитесь
к Главе 56.
Команда CREATE LANGUAGE имеет две формы. В первой форме пользователь задаёт только имя со-
здаваемого языка, и сервер PostgreSQL получает подходящие параметры, обращаясь к системному
каталогу pg_pltemplate. Во второй форме пользователь указывает параметры языка вместе с его
именем. Вторая форма позволяет создать язык, не определённый заранее в pg_pltemplate, но этот
подход считается устаревшим.
Когда сервер находит в каталоге pg_pltemplate запись для заданного имени языка, он будет ис-
пользовать данные из каталога, даже если параметры языка указаны в команде. Это поведение
упрощает загрузку экспортированных ранее файлов, которые, скорее всего, будут содержать уста-
ревшую информацию о функциях поддержки языка.
Обычно, для того чтобы зарегистрировать новый язык, необходимо иметь право суперпользова-
теля PostgreSQL. Однако владелец базы данных может зарегистрировать новый язык в этой базе
данных, если язык определён в каталоге pg_pltemplate и помечен как допускающий создание вла-
дельцами БД (tmpldbacreate содержит true). По умолчанию доверенные языки могут создаваться
владельцами базы данных, но это можно изменить, внеся коррективы в pg_pltemplate. Создатель
языка становится его владельцем и может впоследствии удалить или переименовать его, либо на-
значить другого владельца.
CREATE OR REPLACE LANGUAGE создаст новый язык, либо заменит существующее определение. Если
язык уже существует, его параметры изменяются в соответствии со значениями, указанными в
команде или полученными из pg_pltemplate, при этом владелец языка и права доступа к нему
не меняются, и все существующие функции, написанные на этом языке, по-прежнему считаются
рабочими. Помимо обладания обычными правами, требующимися для создания языка, пользова-
тель должен быть суперпользователем или владельцем существующего языка. Вариант с REPLACE
в основном предназначен для случаев, когда язык уже существует. Если для языка есть запись
1472CREATE LANGUAGE
в pg_pltemplate, то REPLACE фактически ничего не меняет в существующем определении, кроме
исключительного случая, когда запись в pg_pltemplate была изменена после создания языка.
Параметры
TRUSTED
Указание TRUSTED (доверенный) означает, что язык не даёт пользователю доступ к данным, к
которым он не имел бы доступа без него. Если при регистрации языка это ключевое слово опу-
щено, использовать этот язык для создания новых функций смогут только суперпользователи
PostgreSQL.
PROCEDURAL
Это слово не несёт смысловой нагрузки.
имя
Имя процедурного языка. Оно должно быть уникальным среди всех языков в базе данных.
В целях обратной совместимости имя можно заключить в апострофы.
HANDLER обработчик_вызова
Здесь обработчик_вызова — имя ранее зарегистрированной функции, которая будет вызываться
для исполнения процедур (функций) на этом языке. Обработчик вызова для процедурного язы-
ка должен быть написан на компилируемом языке, например, на C, с соглашениями о вызовах
версии 1 и зарегистрирован в PostgreSQL как функция без аргументов, возвращающая фиктив-
ный тип language_handler, который просто показывает, что эта функция — обработчик вызова.
INLINE обработчик_внедрённого_кода
Здесь обработчик_внедрённого_кода — имя ранее зарегистрированной функции, которая будет
вызываться для выполнения анонимного блока кода (команды DO) на этом языке. Если обра-
ботчик_внедрённого_кода не определён, данный язык не будет поддерживать анонимные блоки
кода. Этот обработчик должен принимать один аргумент типа internal, содержащий внутрен-
нее представление команды DO, и обычно возвращает тип void. Значение, возвращаемое этим
обработчиком, игнорируется.
VALIDATOR функция_проверки
Здесь функция_проверки — имя ранее зарегистрированной функции, которая будет вызываться
при создании новой функции на этом языке и проверять её. Если функция проверки не задана,
функции на этом языке при создании проверяться не будут. Функция проверки должна прини-
мать один аргумент типа oid с идентификатором создаваемой функции и обычно возвращает
void.
Функция проверки обычно проверяет тело создаваемой функции на синтаксические ошибки,
но может также проанализировать и другие характеристики функции, например, поддержку
определённых типов аргументов этим языком. Значение, возвращаемое этой функцией, игно-
рируется, об ошибках она должна сигнализировать, вызывая ereport().
Параметр TRUSTED и имена вспомогательных функций игнорируются, если на сервере для указан-
ного языка имеется запись в pg_pltemplate.
Замечания
Для удаления процедурных языков следует использовать DROP LANGUAGE.
В системном каталоге pg_language (см. Раздел 52.29) записывается информация о языках, уста-
новленных в данный момент. Список установленных языков также показывает команда \dL в psql.
1473CREATE LANGUAGE
Чтобы создавать функции на процедурном языке, пользователь должен иметь право USAGE для это-
го языка. По умолчанию для доверенных языков право USAGE даётся роли PUBLIC (т. е. всем), одна-
ко при желании его можно отозвать.
Процедурные языки являются локальными по отношению к базам данных. Тем не менее, язык
можно установить в базу данных template1, в результате чего он будет автоматически доступен
во всех базах данных, создаваемых из неё впоследствии.
Обработчик вызова, обработчик встроенного кода (при наличии) и функция проверки (при нали-
чии) должны уже существовать, если на сервере нет записи для этого языка в pg_pltemplate. Но
если такая запись уже есть, функции могут не существовать — в случае отсутствия в базе данных
они будут определены автоматически. (Это может привести к сбою в CREATE LANGUAGE, если в уста-
новленной системе не найдётся разделяемая библиотека, реализующая этот язык.)
В PostgreSQL до версии 7.3 обязательно требовалось объявить функции-обработчики, как возвра-
щающие фиктивный тип opaque, а не language_handler. Для поддержки загрузки старых файлов
экспорта БД, команда CREATE LANGUAGE принимает функции с объявленным типом результата
opaque, но при этом выдаётся предупреждение и тип результата меняется на language_handler.
Примеры
Предпочитаемый способ создания любых процедурных языков довольно прост:
CREATE LANGUAGE plperl;
Для языка, не представленного в каталоге pg_pltemplate, требуется выполнить следующие дей-
ствия:
CREATE FUNCTION plsample_call_handler() RETURNS language_handler
AS ‘$libdir/plsample’
LANGUAGE C;
CREATE LANGUAGE plsample
HANDLER plsample_call_handler;
Совместимость
CREATE LANGUAGE является расширением PostgreSQL.
См. также
ALTER LANGUAGE, CREATE FUNCTION, DROP LANGUAGE, GRANT, REVOKE
1474CREATE MATERIALIZED VIEW
CREATE MATERIALIZED VIEW — создать материализованное представление
Синтаксис
CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] имя_таблицы
[ (имя_столбца [, …] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) ]
[ TABLESPACE табл_пространство ]
AS запрос
[ WITH [ NO ] DATA ]
Описание
CREATE MATERIALIZED VIEW определяет материализованное представление запроса. Заданный за-
прос выполняется и наполняет представление в момент вызова команды (если только не указано
WITH NO DATA). Обновить представление позже можно, выполнив REFRESH MATERIALIZED VIEW.
Команда CREATE MATERIALIZED VIEW подобна CREATE TABLE AS, за исключением того, что она запо-
минает запрос, порождающий представление, так что это представление можно позже обновить
по требованию. Материализованные представления сходны с таблицами во многом, но не во всём;
например, не поддерживаются временные материализованные представления и автоматическая
генерация OID.
Параметры
IF NOT EXISTS
Не считать ошибкой, если материализованное представление с таким именем уже существует.
В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее
материализованное представление как-то соотносится с тем, которое могло бы быть создано.
имя_таблицы
Имя создаваемого материализованного представления (возможно, дополненное схемой).
имя_столбца
Имя столбца в создаваемом материализованном представлении. Если имена столбцов не зада-
ны явно, они определяются по именам столбцов результата запроса.
WITH ( параметр_хранения [= значение] [, … ] )
Это предложение задаёт дополнительные параметры хранения для создаваемого материали-
зованного представления; подробнее о них можно узнать в Подразделе «Параметры хране-
ния». Все параметры, которые поддерживает CREATE TABLE, поддерживает так же и CREATE
MATERIALIZED VIEW, за исключением OIDS. За дополнительной информацией обратитесь к
CREATE TABLE.
TABLESPACE табл_пространство
Здесь табл_пространство — имя табличного пространства, в котором будет создано материа-
лизованное представление. Если оно не задано, выбирается default_tablespace.
запрос
Команда SELECT, TABLE или VALUES. Эта команда будет выполняться в контексте с ограниче-
ниями по безопасности; в частности, будут запрещены вызовы функций, которые сами создают
временные таблицы.
1475CREATE MATERIALIZED VIEW
WITH [ NO ] DATA
Это предложение указывает, будет ли материализованное представление наполняться в мо-
мент создания. Если материализованное представление не наполняется, оно помечается как
нечитаемое, так что к нему нельзя будет обращаться до выполнения REFRESH MATERIALIZED
VIEW.
Совместимость
CREATE MATERIALIZED VIEW является расширением PostgreSQL.
См. также
ALTER MATERIALIZED VIEW, CREATE TABLE AS, CREATE VIEW, DROP MATERIALIZED VIEW,
REFRESH MATERIALIZED VIEW
1476CREATE OPERATOR
CREATE OPERATOR — создать оператор
Синтаксис
CREATE OPERATOR имя (
(FUNCTION|PROCEDURE) = имя_функции
[, LEFTARG = тип_слева ] [, RIGHTARG = тип_справа ]
[, COMMUTATOR = коммут_оператор ] [, NEGATOR = обратный_оператор ]
[, RESTRICT = процедура_ограничения ] [, JOIN = процедура_соединения ]
[, HASHES ] [, MERGES ]
)
Описание
CREATE OPERATOR определяет новый оператор, имя. Владельцем оператора становится пользова-
тель, его создавший. Если указано имя схемы, оператор создаётся в ней, в противном случае —
в текущей схеме.
Имя оператора образует последовательность из нескольких символов (не более чем NAMEDATALEN-1,
по умолчанию 63) из следующего списка:</li>
  <li>
    <ul>
      <li>
        <ul>
          <li>/ &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
Однако выбор имени ограничен ещё следующими условиями:
• Сочетания символов – и /* не могут присутствовать в имени оператора, так как они будут
обозначать начало комментария.
• Многосимвольное имя оператора не может заканчиваться знаком + или -, если только оно не
содержит также один из этих символов:
~ ! @ # % ^ &amp; | ` ?
Например, @- — допустимое имя оператора, а <em>- — нет. Благодаря этому ограничению,
PostgreSQL может разбирать корректные SQL-запросы без пробелов между компонентами.
• Использование =&gt; в качестве имени оператора считается устаревшим и может быть вовсе за-
прещено в будущих выпусках.
Оператор != отображается в &lt;&gt; при вводе, так что эти два имени всегда равнозначны.
Необходимо определить либо LEFTARG, либо RIGHTARG, а для бинарных операторов оба аргумента.
Для правых унарных операторов должен быть определён только LEFTARG, а для левых унарных —
только RIGHTARG.
Функция имя_функции должна быть уже определена с помощью CREATE FUNCTION и иметь соответ-
ствующее число аргументов (один или два) указанных типов.
В синтаксисе CREATE OPERATOR ключевые слова FUNCTION и PROCEDURE равнозначны, но указываемая
функция должна в любом случае быть функцией, а не процедурой. Ключевое слово PROCEDURE здесь
поддерживается по историческим причинам и считается устаревшим.
Другие предложения определяют дополнительные характеристики оптимизации. Их значение
описано в Разделе 38.14.
Чтобы создать оператор, необходимо иметь право USAGE для типов аргументов и результата, а
также право EXECUTE для нижележащей функции. Если указывается коммутативный или обратный
оператор, нужно быть его владельцем.
1477CREATE OPERATOR
Параметры
имя
Имя определяемого оператора. Допустимые в нём символы перечислены ниже. Указанное имя
может быть дополнено схемой, например так: CREATE OPERATOR myschema.+ (…). Если схема
не указана, оператор создаётся в текущей схеме. При этом два оператора в одной схеме могут
иметь одно имя, если они работают с разными типами данных. Такое определение операторов
называется перегрузкой.
имя_функции
Функция, реализующая этот оператор.
тип_слева
Тип данных левого операнда оператора, если он есть. Этот параметр опускается для левых
унарных операторов.
тип_справа
Тип данных правого операнда оператора, если он есть. Этот параметр опускается для правых
унарных операторов.
коммут_оператор
Оператор, коммутирующий для данного.
обратный_оператор
Оператор, обратный для данного.
процедура_ограничения
Функция оценки избирательности ограничения для данного оператора.
процедура_соединения
Функция оценки избирательности соединения для этого оператора.
HASHES
Показывает, что этот оператор поддерживает соединение по хешу.
MERGES
Показывает, что этот оператор поддерживает соединение слиянием.
Чтобы задать имя оператора с указанием схемы в коммут_оператор или другом дополнительном
аргументе, применяется синтаксис OPERATOR(), например:
COMMUTATOR = OPERATOR(myschema.===) ,
Замечания
За дополнительными сведениями обратитесь к Разделу 38.13.
Задать лексический приоритет оператора в команде CREATE OPERATOR невозможно, так как обработ-
ка приоритетов жёстко зашита в анализаторе. Подробнее приоритеты описаны в Подразделе 4.1.6.
Устаревшие параметры SORT1, SORT2, LTCMP и GTCMP ранее использовались для определения имён
операторов сортировки, связанных с оператором, применяемым при соединении слиянием. Теперь
это не требуется, так как информацию о связанных операторах теперь дают семейства операторов
B-дерева. Если в команде отсутствует явное указание MERGES, все эти параметры игнорируются.
Для удаления пользовательских операторов из базы данных применяется DROP OPERATOR, а для
изменения их свойств — ALTER OPERATOR.
1478CREATE OPERATOR
Примеры
Следующая команда определяет новый оператор, проверяющий равенство площадей, для типа box:
CREATE OPERATOR === (
LEFTARG = box,
RIGHTARG = box,
FUNCTION = area_equal_function,
COMMUTATOR = ===,
NEGATOR = !==,
RESTRICT = area_restriction_function,
JOIN = area_join_function,
HASHES, MERGES
);
Совместимость
CREATE OPERATOR является языковым расширением PostgreSQL. Средства определения пользова-
тельских операторов в стандарте SQL не описаны.
См. также
ALTER OPERATOR, CREATE OPERATOR CLASS, DROP OPERATOR
1479CREATE OPERATOR CLASS
CREATE OPERATOR CLASS — создать класс операторов
Синтаксис
CREATE OPERATOR CLASS имя [ DEFAULT ] FOR TYPE тип_данных
USING метод_индекса [ FAMILY имя_семейства ] AS
( OPERATOR номер_стратегии имя_оператора [ ( тип_операнда, тип_операнда ) ] [ FOR
SEARCH | FOR ORDER BY семейство_сортировки ]
| FUNCTION номер_опорной_функции [ ( тип_операнда [ , тип_операнда ] ) ] имя_функции
( тип_аргумента [, …] )
| STORAGE тип_хранения
) [, … ]
Описание
CREATE OPERATOR CLASS создаёт класс операторов. Класс операторов устанавливает, как данный
тип будет использоваться в индексе, определяя, какие операторы исполняют конкретные роли или
«стратегии» для этого типа данных и метода индекса. Также класс операторов определяет опорные
функции, которые будет задействовать метод индекса в случае выбора данного класса для столбца
индекса. Все операторы и функции, используемые классом операторов, должны существовать до
создания этого класса.
Если указывается имя схемы, класс операторов создаётся в указанной схеме, в противном случае
— в текущей. Два класса операторов в одной схеме могут иметь одинаковые имена, только если
они предназначены для разных методов индекса.
Владельцем класса операторов становится пользователь, создавший его. В настоящее время со-
здавать классы операторов могут только суперпользователи. (Это ограничение введено потому,
что ошибочное определение класса может вызвать нарушения или даже сбой в работе сервера.)
CREATE OPERATOR CLASS в настоящее время не проверяет, включает ли определение класса опе-
раторов все операторы и функции, требуемые для метода индекса, и образуют ли они целостный
набор. Ответственность за правильность определения класса операторов лежит на пользователе.
Связанные классы операторов могут быть сгруппированы в семейства операторов. Чтобы поме-
стить класс в существующее семейство, добавьте параметр FAMILY в CREATE OPERATOR CLASS. Без
этого параметра новый класс помещается в семейство, имеющее то же имя, что и класс (если та-
кое семейство не существует, оно создаётся).
За дополнительными сведениями обратитесь к Разделу 38.15.
Параметры
имя
Имя создаваемого класса операторов, возможно, дополненное схемой.
DEFAULT
Если присутствует это указание, класс операторов становится классом по умолчанию для сво-
его типа данных. Для определённого типа данных и метода индекса можно определить не боль-
ше одного класса операторов по умолчанию.
тип_данных
Тип данных столбца, для которого предназначен этот класс операторов.
1480CREATE OPERATOR CLASS
метод_индекса
Имя индексного метода, для которого предназначен этот класс операторов.
имя_семейства
Имя существующего семейства операторов, в которое будет добавлен этот класс. Если не ука-
зано, подразумевается семейство с тем же именем, что и класс (если такое семейство не суще-
ствует, оно создаётся).
номер_стратегии
Номер стратегии индексного метода для оператора, связанного с данным классом операторов.
имя_оператора
Имя (возможно, дополненное схемой) оператора, связанного с данным классом операторов.
тип_операнда
В предложении OPERATOR это тип данных операнда, либо ключевое слово NONE, характеризую-
щее левый унарный или правый унарный оператор. Типы операндов обычно можно опустить,
когда они совпадают с типом данных класса операторов.
В предложении FUNCTION это тип данных операнда, который должна поддерживать эта функ-
ция, если он отличается от входного типа данных функции (для функций сравнения в B-дере-
вьях и хеш-функций) или типа данных класса (для функций поддержки сортировки в B-деревьях
и всех функций в классах операторов GiST, SP-GiST, GIN и BRIN). Обычно предполагаемые по
умолчанию типы оказываются верными, так что тип_операнда указывать в FUNCTION не нужно,
кроме функций сортировки B-дерева, предназначенных для сравнений разных типов данных.
семейство_сортировки
Имя (возможно, дополненное схемой) существующего семейства операторов btree, описываю-
щего порядок сортировки, связанный с оператором сортировки.
Если не указано ни FOR SEARCH (для поиска), ни FOR ORDER BY (для сортировки), подразумевается
FOR SEARCH.
номер_опорной_функции
Номер опорной функции индексного метода для функции, связанной с данным классом опера-
торов.
имя_функции
Имя (возможно, дополненное схемой) функции, которая является опорной функцией индекс-
ного метода для данного класса операторов.
тип_аргумента
Тип данных параметра функции.
тип_хранения
Тип данных, фактически сохраняемых в индексе. Обычно это тип данных столбца, но некото-
рые методы индекса (в настоящее время, GiST, GIN и BRIN) могут работать с отличным от него
типом. Предложение STORAGE может присутствовать, только если метод индекса позволяет ис-
пользовать другой тип данных. Если тип_данных столбца задан как anyarray, тип_хранения мо-
жет быть объявлен как anyelement, чтобы показать, что записи в индексе являются членами
типа элемента, принадлежащего к фактическому типу массива, для которого создаётся кон-
кретный индекс.
Предложения OPERATOR, FUNCTION и STORAGE могут указываться в любом порядке.
1481CREATE OPERATOR CLASS
Замечания
Так как механизмы индексов не проверяют права доступа к функциям, прежде чем вызывать их,
включение функций или операторов в класс операторов по сути даёт всем право на выполнение
их. Обычно это не проблема для таких функций, какие бывают полезны в классе операторов.
Операторы не должны реализовываться в функциях на языке SQL. SQL-функция вероятнее всего
будет встроена в вызывающий запрос, что помешает оптимизатору понять, что этот запрос соот-
ветствует индексу.
До PostgreSQL 8.4 предложение OPERATOR могло включать указание RECHECK. Теперь это не поддер-
живается, так как оператор индекса может быть «неточным» и это определяется на ходу в момент
выполнения. Это позволяет эффективно справляться с ситуациями, когда оператор может быть
или не быть неточным.
Примеры
Команда в следующем примере определяет класс операторов индекса GiST для типа данных _int4
(массива из int4). Полный пример приведён в модуле intarray.
CREATE OPERATOR CLASS gist__int_ops
DEFAULT FOR TYPE _int4 USING gist AS
OPERATOR
3
&amp;&amp;,
OPERATOR
6
= (anyarray, anyarray),
OPERATOR
7
@&gt;,
OPERATOR
8
&lt;@,
OPERATOR
20
@@ (_int4, query_int),
FUNCTION
1
g_int_consistent (internal, _int4, smallint, oid,
internal),
FUNCTION
2
g_int_union (internal, internal),
FUNCTION
3
g_int_compress (internal),
FUNCTION
4
g_int_decompress (internal),
FUNCTION
5
g_int_penalty (internal, internal, internal),
FUNCTION
6
g_int_picksplit (internal, internal),
FUNCTION
7
g_int_same (_int4, _int4, internal);
Совместимость
CREATE OPERATOR CLASS является расширением PostgreSQL. Команда CREATE OPERATOR CLASS от-
сутствует в стандарте SQL.
См. также
ALTER OPERATOR CLASS, DROP OPERATOR CLASS, CREATE OPERATOR FAMILY, ALTER OPERATOR
FAMILY
1482CREATE OPERATOR FAMILY
CREATE OPERATOR FAMILY — создать семейство операторов
Синтаксис
CREATE OPERATOR FAMILY имя USING метод_индекса
Описание
CREATE OPERATOR FAMILY создаёт новое семейство операторов. Семейство операторов определяет
коллекцию связанных классов операторов и, возможно, некоторые дополнительные операторы и
вспомогательные функции, совместимые с этими классами, но не требующиеся для функциониро-
вания каких-либо индексов. (Операторы и функции, требующиеся для работы индексов, следует
группировать в соответствующем классе операторов, а не «слабо» связывать в семействе опера-
торов. Обычно операторы с операндами одного типа привязываются к классам операторов, тогда
как операторы для двух разных типов могут быть слабо связаны в семействе, содержащем классы
операторов для обоих типов.)
Создаваемое семейство операторов изначально не содержит ничего. Оно должно наполняться по-
следующими командами CREATE OPERATOR CLASS, добавляющими в него классы операторов, и, воз-
можно, командами ALTER OPERATOR FAMILY, добавляющими «слабосвязанные» операторы и соот-
ветствующие вспомогательные функции.
Если указывается имя схемы, семейство операторов создаётся в указанной схеме, в противном
случае — в текущей. Два семейства операторов в одной схеме могут иметь одинаковые имена,
только если они предназначены для разных методов индекса.
Владельцем семейства операторов становится пользователь, создавший его. В настоящее время
создавать семейства операторов могут только суперпользователи. (Это ограничение введено по-
тому, что ошибочное определение семейства может вызвать нарушения или даже сбой в работе
сервера.)
За дополнительными сведениями обратитесь к Разделу 38.15.
Параметры
имя
Имя создаваемого семейства операторов, возможно, дополненное схемой.
метод_индекса
Имя индексного метода, для которого предназначено это семейство операторов.
Совместимость
CREATE OPERATOR FAMILY является расширением PostgreSQL. Команда CREATE OPERATOR FAMILY
отсутствует в стандарте SQL.
См. также
ALTER OPERATOR FAMILY, DROP OPERATOR FAMILY, CREATE OPERATOR CLASS, ALTER OPERATOR
CLASS, DROP OPERATOR CLASS
1483CREATE POLICY
CREATE POLICY — создать новую политику защиты на уровне строк для таблицы
Синтаксис
CREATE POLICY имя ON имя_таблицы
[ AS ( PERMISSIVE | RESTRICTIVE ) ]
[ FOR ( ALL | SELECT | INSERT | UPDATE | DELETE ) ]
[ TO ( имя_роли | PUBLIC | CURRENT_USER | SESSION_USER ) [, …] ]
[ USING ( выражение_USING ) ]
[ WITH CHECK ( выражение_CHECK ) ]
Описание
Команда CREATE POLICY определяет для таблицы новую политику защиты на уровне строк. Заметь-
те, что для таблицы должна быть включена защита на уровне строк (using ALTER TABLE … ENABLE
ROW LEVEL SECURITY), чтобы созданные политики действовали.
Политика даёт разрешение на выборку, добавление, изменение или удаление строк, удовлетворя-
ющих соответствующему выражению политики. Существующие строки таблицы проверяются по
выражению, указанному в USING, тогда как строки, которые могут быть созданы командами INSERT
или UPDATE проверяются по выражению, указанному в WITH CHECK. Когда выражение USING истин-
но для заданной строки, эта строка видна пользователю, а если ложно или выдаёт NULL, строка
не видна. Когда выражение WITH CHECK истинно для заданной строки, эта строка добавляется или
изменяется, а если ложно или выдаёт NULL, происходит ошибка.
Для операторов INSERT и UPDATE выражения WITH CHECK применяются после срабатывания триг-
геров BEFORE, но до того, как будут собственно модифицированы данные. Таким образом, триггер
BEFORE ROW может изменить данные, подлежащие добавлению, и повлиять на результат условия
политики защиты. Выражения WITH CHECK обрабатываются до каких-либо других ограничений.
Имена политик задаются на уровне таблицы. Таким образом, одно имя политики можно исполь-
зовать в нескольких разных таблицах и в каждой дать отдельное, подходящее этой таблице опре-
деление политики.
Политики могут применяться для определённых команд или для определённых ролей. По умолча-
нию создаваемые политики применяются для всех команд и ролей, если явно не задано другое. К
одной команде могут применяться несколько политик; подробнее рассказывается ниже. В Табли-
це 240 показано, как к определённым командам применяются разные типы политик.
Для политик, которые могут иметь и выражения USING, и выражения WITH CHECK (ALL и UPDATE),
в случае отсутствия выражения WITH CHECK выражение USING будет использоваться и для опреде-
ления видимости строк (обычное назначение USING) и для определения, какие строки разрешено
добавить (назначение WITH CHECK).
Если для таблицы включена защита на уровне строк, но применимые политики отсутствуют, пред-
полагается политика «запрета по умолчанию», так что никакие строки нельзя будет увидеть или
изменить.
Параметры
имя
Имя создаваемой политики. Оно должно отличаться от имён других политик для этой таблицы.
имя_таблицы
Имя (возможно, дополненное схемой) существующей таблицы (или представления), к которой
применяется эта политика.
1484CREATE POLICY
PERMISSIVE
Указывает, что создаваемая политика должна быть разрешительной. Все разрешительные по-
литики, которые применяются к данному запросу, будут объединяться вместе логическим опе-
ратором «ИЛИ». Создавая разрешительные политики, администраторы могут расширять мно-
жество записей, к которым можно обращаться. Политики являются разрешительными по умол-
чанию.
RESTRICTIVE
Указывает, что создаваемая политика должна быть ограничительной. Все ограничительные
политики, которые применяются к данному запросу, будут объединяться вместе логическим
оператором «И». Создавая ограничительные политики, администраторы могут сократить мно-
жество записей, к которым можно обращаться, так как для каждой записи должны удовлетво-
ряться все ограничительные политики.
Заметьте, что для получения доступа к записям должна быть определена минимум одна раз-
решительная политика, и только в дополнение к ней могут быть определены имеющие смысл
ограничительные политики, ограничивающие доступ. Если разрешительные политики отсут-
ствуют, ни к каким записям обращаться нельзя. Когда определены и разрешительные, и огра-
ничительные политики, запись будет доступна, если удовлетворяется минимум одна из разре-
шительных политик и все ограничительные.
команда
Команда, к которой применяется политика. Допустимые варианты: ALL, SELECT, INSERT, UPDATE
и DELETE. ALL (все) подразумевается по умолчанию. Особенности их применения описаны ниже.
имя_роли
Роль (роли), к которой применяется политика. По умолчанию подразумевается PUBLIC, то есть
политика применяется ко всем ролям.
выражение_USING
Произвольное условное выражение SQL (возвращающее boolean). Это условное выражение не
может содержать агрегатные или оконные функции. Когда включена защита на уровне строк,
оно добавляется в запросы, обращающиеся к данной таблице, и в их результатах оказываются
видимыми только те строки, для которых оно выдаёт true. Все строки, для которых это выраже-
ние возвращает false или NULL, не будут видны пользователю (в запросе SELECT), и не будут
доступны для модификации (запросами UPDATE или DELETE). Такая строка просто пропускается,
ошибка при этом не выдаётся.
выражение_CHECK
Произвольное условное выражение SQL (возвращающее boolean). Это условное выражение не
может содержать агрегатные или оконные функции. Когда включена защита на уровне строк,
оно применяется в запросах INSERT и UPDATE к этой таблице, так что в них принимаются только
те строки, для которых оно выдаёт true. Если это выражение выдаёт false или NULL для любой
из добавляемых записей или записей, получаемых при изменении, выдаётся ошибка. Заметьте,
что ограничение_проверки вычисляется для предлагаемого нового содержимого строки, а не
для существующих данных.
Политики по командам
ALL
Указание ALL для политики означает, что она применяется ко всем командам, вне зависимости
от типа. Если существует политика ALL и другие более детализированные политики, тогда бу-
дет применяться и политика ALL, и более детализированная политика (или политики). Кроме
того, политики ALL с выражением USING будут применяться и к стороне выборки, и к стороне
изменения данных в запросе, если определено только выражение USING.
Например, когда выполняется UPDATE, политика ALL будет фильтровать и строки, которые смо-
жет прочитать UPDATE для изменения (применяя выражение USING), и окончательные изменён-
1485CREATE POLICY
ные строки, проверяя, можно ли записать их в таблицу (применяя выражение WITH CHECK, ес-
ли оно определено, или USING в противном случае). Если команда INSERT или UPDATE пытается
добавить в таблицу строки, не удовлетворяющие выражению WITH CHECK политики ALL, вся ко-
манда будет прервана.
SELECT
Указание SELECT для политики означает, что она применяется к запросам SELECT и тогда, когда
при обращении к отношению, для которого определена политика, задействуется право SELECT.
В результате запрос SELECT выдаст только те записи из отношения, которые удовлетворят по-
литике SELECT, и запрос, использующий право SELECT, например, запрос UPDATE, увидит только
записи, разрешённые политикой SELECT. Для политики SELECT не может задаваться выражение
WITH CHECK, так как оно действует только когда записи читаются из отношения.
INSERT
Указание INSERT для политики означает, что она применяется к командам INSERT. Если встав-
ляемые строки не проходят проверку политики, выдаётся ошибка нарушения политики и вся
команда INSERT прерывается. Для политики INSERT не может задаваться выражение USING, так
как она действует только когда в отношение добавляются записи.
Заметьте, что INSERT с указанием ON CONFLICT DO UPDATE проверяет выражения WITH CHECK
политик INSERT только для строк, добавляемых в отношение по пути INSERT.
UPDATE
Выбор типа UPDATE для политики означает, что она будет применяться к командам UPDATE,
SELECT FOR UPDATE и SELECT FOR SHARE, а также к дополнительным предложениям ON CONFLICT
DO UPDATE команд INSERT. Так как UPDATE подразумевает извлечение существующей записи и
замену её новой изменённой записью, политики UPDATE принимают как выражение USING, так
и WITH CHECK. Выражение USING определяет, какие записи команда UPDATE сможет увидеть для
последующего изменения, а выражение WITH CHECK — какие изменённые строки сохранить в
отношении.
Если в какой-либо строке изменённые значения не будут удовлетворять выражению WITH
CHECK, произойдёт ошибка и вся команда будет прервана. Если указывается только предложе-
ние USING, его выражение будет применяться и в качестве USING, и в качестве выражения WITH
CHECK.
Обычно команде UPDATE также нужно прочитать данные из столбцов подлежащего изменению
отношения (например, в предложении WHERE или RETURNING либо в выражении в правой части
предложения SET). В этом случае также требуется иметь права SELECT в изменяемом отноше-
нии и в дополнение к политикам UPDATE будут применяться соответствующие политики SELECT
или ALL. Таким образом, помимо того, что пользователю должны разрешать изменение строк
политики UPDATE или ALL, ему также должны разрешать доступ к изменяемым строкам поли-
тики SELECT или ALL.
Когда для команды INSERT задано вспомогательное предложение ON CONFLICT DO UPDATE, если
выбирается путь UPDATE, строка, подлежащая изменению, сначала проверяется по выражени-
ям USING всех политик UPDATE, а затем изменённая строка ещё раз проверяется по выражениям
WITH CHECK. Заметьте, однако, что в отличие от отдельной команды UPDATE, если существую-
щая строка не удовлетворяет выражениям USING, будет выдана ошибка (путь UPDATE никогда
не пропускается неявно).
DELETE
Указание DELETE для политики означает, что она применяется к командам DELETE. Команда
DELETE будет видеть только те строки, которые позволит эта политика. При этом строки могут
быть видны через SELECT, но удалить их будет нельзя, если они не удовлетворяют выражению
USING политики DELETE.
1486CREATE POLICY
В большинстве случаев команде DELETE также нужно прочитать данные из столбцов в отноше-
нии, из которого осуществляется удаление (например, в предложении WHERE или RETURNING). В
таких случаях необходимо также иметь право SELECT для этого отношения, и в дополнение к
политикам DELETE будут применятся соответствующие политики SELECT или ALL. Таким обра-
зом, пользователь должен получить доступ к удаляемым строкам через политики SELECT или
ALL, помимо того что удаление этих строк ему должны разрешить политики DELETE или ALL.
Для политики DELETE не может задаваться выражение WITH CHECK, так как она применяется
только тогда, когда записи удаляются из отношения, а в этом случае новые строки, подлежащие
проверке, отсутствуют.
Таблица 240. Политики, применяемые для разных команд
Команда
SELECT
Политика
SELECT/ALL Политика
INSERT/ALL
Выражение
USING Выражение WITH Выражение
CHECK
USING
Существующая —
строка
—
INSERT
RETURNING
UPDATE
—
… Новая строка
a
Выражение WITH Выражение
CHECK
USING
—
Существующая —
строка —
Новая строка — — —
Новая строка — — —
Существующие —
и новые строки Существующая Новая строка
строка —
Существующая —
a
строка — Существующая
строка
a
DELETE
Политика
DELETE/ALL
—
SELECT
FOR Существующая —
строка
UPDATE/SHARE
INSERT
Политика UPDATE/ALL
ON CONFLICT DO Существующие —
и новые строки
UPDATE
—
Существующая Новая строка
строка
—
a
Если для существующей или новой строки требуется доступ на чтение (например, предложение WHERE или RETURNING, обращающееся к столбцам отно-
шения).
Применение нескольких политик
Когда к одной команде применяются несколько политик для различных типов команд (как напри-
мер, политики SELECT и UPDATE применяются к команде UPDATE), пользователь должен иметь раз-
решения всех этих типов (например, разрешение для выборки строк из отношения, а также раз-
решение на их изменение). Таким образом, выражения для одного типа политики комбинируются
с выражениями для другого типа операцией И.
Когда к одной команде применяются несколько политик для одного типа команды, доступ к от-
ношению должна дать как минимум одна разрешительная (PERMISSIVE) политика, а также долж-
ны удовлетворяться все ограничительные (RESTRICTIVE) политики. Таким образом выражения
всех политик PERMISSIVE объединяются операцией ИЛИ, выражения всех политик RESTRICTIVE объ-
единяются операцией И, а полученные результаты объединяются операцией И. Если политики
PERMISSIVE отсутствуют, доступ запрещается.
Заметьте, что при объединении нескольких политик, политики ALL применяются как политики
каждого применимого в данном случае типа.
Например, в команде UPDATE, требующей разрешений и для SELECT, и для UPDATE, в случае суще-
ствования нескольких применимых политик каждого типа они будут объединяться следующим об-
разом:
выражение from RESTRICTIVE SELECT/ALL policy 1
1487CREATE POLICY
AND
выражение from RESTRICTIVE SELECT/ALL policy 2
AND
…
AND
(
выражение from PERMISSIVE SELECT/ALL policy 1
OR
выражение from PERMISSIVE SELECT/ALL policy 2
OR
…
)
AND
выражение from RESTRICTIVE UPDATE/ALL policy 1
AND
выражение from RESTRICTIVE UPDATE/ALL policy 2
AND
…
AND
(
выражение from PERMISSIVE UPDATE/ALL policy 1
OR
выражение from PERMISSIVE UPDATE/ALL policy 2
OR
…
)
Замечания
Чтобы создать или изменить политики для таблицы, нужно быть её владельцем.
Хотя политики применяются к явно выполняемым запросам к таблицам БД, они не применяются,
когда система выполняет внутренние проверки ссылочной целостности или проверяет ограниче-
ния. Это означает, что существуют косвенные пути проверить существование заданного значения.
Например, можно попытаться вставить повторяющееся значение в столбец, образующий первич-
ный ключ или имеющую ограничение уникальности. Если при этом произойдёт ошибка, пользо-
ватель может заключить, что это значение уже существует. (В данном случае предполагается,
что политика разрешает пользователю вставлять записи, которые он может не видеть.) Подобный
приём также возможен, если пользователь может вставлять записи в таблицу, которая ссылается
на другую, иным образом не видимую. Существование значения можно определить, вставив его
в подчинённую таблицу, при этом успешный результат операции будет признаком того, что это
значение есть в главной таблице. Эти изъяны можно устранить, либо тщательно разработав по-
литики, которые вовсе не позволят пользователям выполнять операции добавления, изменения и
удаления, по результатам которых можно узнать о значениях в таблицах, не видимых иным обра-
зом, либо используя генерируемые значения (например, суррогатные ключи).
Вообще система будет применять фильтры, устанавливаемые политиками безопасности, до усло-
вий в запросах пользователя, чтобы предотвратить нежелательную утечку защищаемых данных
через пользовательские функции, которые могут быть недоверенными. Однако функции и опера-
торы, помеченные системой (или системным администратором) как LEAKPROOF (герметичные) мо-
гут вычисляться до условий политики, так как они считаются доверенными.
Так как выражения политики добавляются непосредственно в запрос пользователя, они выполня-
ются с правами пользователя, запускающего исходный запрос. Таким образом, пользователи, на
которых распространяется заданная политика, должны иметь права для обращения ко всем таб-
лицам и функциям, задействованным в выражении, иначе им просто будет отказано в доступе при
попытке обращения к целевой таблице (если для неё включена защита на уровне строк). Однако
это не влияет на работу представлений — как и с обычными запросами и представлениями, про-
верки разрешений и политики для нижележащих таблиц представления будут выполняться с пра-
1488CREATE POLICY
вами владельца представления, и при этом будут действовать политики, распространяющиеся на
этого владельца.
Дополнительное описание и практические примеры можно найти в Разделе 5.7.
Совместимость
CREATE POLICY является расширением PostgreSQL.
См. также
ALTER POLICY, DROP POLICY, ALTER TABLE
1489CREATE PROCEDURE
CREATE PROCEDURE — создать процедуру
Синтаксис
CREATE [ OR REPLACE ] PROCEDURE
имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ ( DEFAULT |
= ) выражение_по_умолчанию ] [, …] ] )
( LANGUAGE имя_языка
| TRANSFORM ( FOR TYPE имя_типа ) [, … ]
| [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
| SET параметр_конфигурации ( TO значение | = значение | FROM CURRENT )
| AS ‘определение’
| AS ‘объектный_файл’, ‘объектный_символ’
) …
Описание
Команда CREATE PROCEDURE определяет новую процедуру. CREATE OR REPLACE PROCEDURE создаёт
новую процедуру либо заменяет определение уже существующей. Чтобы определить процедуру,
необходимо иметь право USAGE для соответствующего языка.
Если указано имя схемы, процедура создаётся в заданной схеме, в противном случае — в текущей.
Имя новой процедуры должно отличаться от имён существующих процедур и функций с такими
же типами аргументов в этой схеме. Однако процедуры и функции с аргументами разных типов
могут иметь одно имя (это называется перегрузкой).
Команда CREATE OR REPLACE PROCEDURE предназначена для изменения текущего определения су-
ществующей процедуры. С её помощью нельзя изменить имя или типы аргументов (если попытать-
ся сделать это, будет создана новая отдельная процедура).
Когда команда CREATE OR REPLACE PROCEDURE заменяет существующую процедуру, владелец и
права доступа к этой процедуре не меняются. Все другие свойства процедуры получают значения,
задаваемые командой явно или по умолчанию. Чтобы заменить процедуру, необходимо быть её
владельцем (или быть членом роли-владельца).
Владельцем процедуры становится создавший её пользователь.
Чтобы создать процедуру, необходимо иметь право USAGE для типов её аргументов.
Параметры
имя
Имя создаваемой процедуры (возможно, дополненное схемой).
режим_аргумента
Режим аргумента: IN, INOUT или VARIADIC. По умолчанию подразумевается IN. (Режим OUT для
процедур в настоящее время не поддерживается. Используйте вместо него INOUT.)
имя_аргумента
Имя аргумента.
тип_аргумента
Тип данных аргумента процедуры (возможно, дополненный схемой), при наличии аргументов.
Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка
на столбец таблицы.
1490CREATE PROCEDURE
В зависимости от языка реализации также может допускаться указание «псевдотипов», напри-
мер, cstring. Псевдотипы показывают, что фактический тип аргумента либо определён не пол-
ностью, либо существует вне множества обычных типов SQL.
Ссылка на тип столбца записывается в виде имя_таблицы.имя_столбца%TYPE. Иногда такое ука-
зание бывает полезно, так как позволяет создать процедуру, независящую от изменений в опре-
делении таблицы.
выражение_по_умолчанию
Выражение, используемое для вычисления значения по умолчанию, если параметр не задан яв-
но. Результат выражения должен сводиться к типу соответствующего параметра. Для всех вход-
ных параметров, следующих за параметром с определённым значением по умолчанию, также
должны быть определены значения по умолчанию.
имя_языка
Имя языка, на котором реализована функция. Это может быть sql, c, internal либо имя про-
цедурного языка, определённого пользователем, например, plpgsql. Стиль написания этого
имени в апострофах считается устаревшим и требует точного совпадения регистра.
TRANSFORM ( FOR TYPE имя_типа ) [, … ] )
Устанавливает список трансформаций, которые должны применяться при вызове процедуры.
Трансформации выполняют преобразования между типами SQL и типами данных, специфич-
ными для языков; см. CREATE TRANSFORM. Преобразования встроенных типов обычно жёстко
предопределены в реализациях процедурных языков, так что их здесь указывать не нужно. Ес-
ли реализация процедурного языка не может обработать тип и трансформация для него отсут-
ствует, будет выполнено преобразование типов по умолчанию, но это зависит от реализации.
[EXTERNAL] SECURITY INVOKER
[EXTERNAL] SECURITY DEFINER
Характеристика SECURITY INVOKER (безопасность вызывающего) показывает, что процедура бу-
дет выполняться с правами пользователя, вызвавшего её. Этот вариант подразумевается по
умолчанию. Вариант SECURITY DEFINER (безопасность определившего) обозначает, что проце-
дура выполняется с правами пользователя, владеющего ей.
Ключевое слово EXTERNAL (внешняя) допускается для соответствия стандарту SQL, но является
необязательным, так как, в отличие от SQL, эта характеристика распространяется на все про-
цедуры, а не только внешние.
В процедуре с характеристикой SECURITY DEFINER не могут выполняться операторы управления
транзакциями (например, COMMIT и ROLLBACK в некоторых языках).
параметр_конфигурации
значение
Предложение SET определяет, что при вызове процедуры указанный параметр конфигурации
должен принять заданное значение, а затем восстановить своё предыдущее значение при за-
вершении процедуры. Предложение SET FROM CURRENT сохраняет в качестве значения, которое
будет применено при входе в процедуру, значение, действующее в момент выполнения CREATE
PROCEDURE.
Если в определение процедуры добавлено SET, то действие команды SET LOCAL, выполняемой
внутри процедуры для того же параметра, ограничивается телом процедуры: предыдущее зна-
чение параметра так же будет восстановлено при завершении процедуры. Однако обычная ко-
манда SET (без LOCAL) переопределяет предложение SET, как и предыдущую команду SET LOCAL:
действие такой команды будет сохранено и после завершения процедуры, если только не про-
изойдёт откат транзакции.
Если к определению процедуры добавлено SET, то в этой процедуре не могут выполняться опе-
раторы управления транзакциями (например, COMMIT и ROLLBACK в некоторых языках).
1491CREATE PROCEDURE
За подробными сведениями об именах и значениях параметров обратитесь к SET и Главе 19.
определение
Строковая константа, определяющая реализацию процедуры; её значение зависит от языка.
Это может быть имя внутренней процедуры, путь к объектному файлу, команда SQL или код
на процедурном языке.
Часто бывает полезно заключать определение процедуры в доллары (см. Подраздел 4.1.2.4), а
не в традиционные апострофы. Если не использовать доллары, все апострофы и обратные косые
черты в определении процедуры придётся экранировать, дублируя их.
объектный_файл, объектный_символ
Эта форма предложения AS применяется для динамически загружаемых процедур на языке C,
когда имя процедуры в коде C не совпадает с именем процедуры в SQL. Строка объектный_файл
задаёт имя файла, содержащего скомпилированную процедуру на C (данная команда воспри-
нимает эту строку так же, как и LOAD). Строка объектный_символ задаёт символ скомпонован-
ной процедуры, то есть имя процедуры в исходном коде на языке C. Если объектный символ не
указан, предполагается, что он совпадает с именем определяемой SQL-процедуры.
Если повторные вызовы CREATE PROCEDURE ссылаются на один и тот же объектный файл, он
загружается в рамках сеанса только один раз. Чтобы выгрузить и загрузить этот файл снова
(например, в процессе разработки), начните новый сеанс.
Замечания
Дополнительные детали создания функций, которые применимы и к процедурам, описываются в
CREATE FUNCTION.
Чтобы выполнить процедуру, воспользуйтесь командой CALL.
Примеры
CREATE PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL
AS <script type="math/tex">INSERT INTO tbl VALUES (a);
INSERT INTO tbl VALUES (b);</script>;
CALL insert_data(1, 2);
Совместимость
Команда CREATE PROCEDURE определена в стандарте SQL. Её реализация в PostgreSQL близка к
стандартизированной, но совместима с ней не полностью. Дополнительные подробности можно
найти в описании CREATE FUNCTION.
См. также
ALTER PROCEDURE, DROP PROCEDURE, CALL, CREATE FUNCTION
1492CREATE PUBLICATION
CREATE PUBLICATION — создать публикацию
Синтаксис
CREATE PUBLICATION имя
[ FOR TABLE [ ONLY ] имя_таблицы [ * ] [, …]
| FOR ALL TABLES ]
[ WITH ( параметр_публикации [= значение] [, … ] ) ]
Описание
CREATE PUBLICATION создаёт новую публикацию в текущей базе данных. Имя публикации должно
отличаться от имён других существующих публикаций в текущей базе.
Публикация по сути является группой таблиц, изменения в данных которых должны реплициро-
ваться с использованием логической репликации. Подробнее о том, как публикации вписываются
в схему логической репликации, рассказывается в Разделе 31.1.
Параметры
имя
Имя новой публикации.
FOR TABLE
Задаёт список таблиц, добавляемых в публикацию. Если перед именем таблицы указано ONLY, в
публикацию добавляется только заданная таблица. Без ONLY добавляется и заданная таблица,
и все её потомки (если таковые есть). После имени таблицы можно добавить необязательное
указание *, чтобы явно обозначить, что должны включаться и все дочерние таблицы.
В публикацию могут включаться только постоянные базовые таблицы. Временные, нежурна-
лируемые, сторонние и секционированные таблицы, а также материализованные и обычные
представления не могут входить в публикацию. Для реплицирования секционированной табли-
цы в публикацию нужно добавить её отдельные секции.
FOR ALL TABLES
Устанавливает, что данная публикация охватывает изменения во всех таблиц в базе данных,
включая таблицы, которые будут созданы позже.
WITH ( параметр_публикации [= значение] [, … ] )
В этом предложении могут задаваться следующие необязательные параметры публикации:
publish (string)
Этот параметр определяет, какие операции DML будет передавать новая публикация её
подписчикам. В качестве его значения через запятую задаётся список операций из следу-
ющих: insert, update, delete и truncate. По умолчанию публикуются все действия, так что
этот параметр имеет значение по умолчанию ‘insert, update, delete, truncate’.
Замечания
Если не задано ни FOR TABLE, ни FOR ALL TABLES, публикация создаётся с пустым набором таблиц.
Это полезно, если таблицы будут добавляться позднее.
Создание публикации не влечёт немедленный запуск репликации. Эта операция только определя-
ет логику группирования и фильтрации для будущих подписчиков.
1493CREATE PUBLICATION
Чтобы создать публикацию, пользователь должен иметь право CREATE в текущей базе данных. (Ра-
зумеется, на суперпользователей это условие не распространяется.)
Чтобы добавить таблицу в публикацию, пользователь должен иметь права владельца этой таблицы.
Для использования предложения FOR ALL TABLES пользователь должен быть суперпользователем.
Таблицы, добавляемые в публикацию, которая охватывает операции UPDATE и/или DELETE, должны
иметь свойство REPLICA IDENTITY. В противном случае отслеживание этих операций для таблиц
будет запрещено.
Для команды INSERT … ON CONFLICT публикация будет выдавать операцию, к которой фактически
сводится команда. Поэтому в зависимости от исхода команды, она может быть опубликована либо
как INSERT, либо как UPDATE, либо не будет опубликована вовсе.
Команды COPY … FROM публикуются в виде операций INSERT.
Операции DDL не публикуются.
Примеры
Создание публикации, охватывающей изменения в двух таблицах:
CREATE PUBLICATION mypublication FOR TABLE users, departments;
Создание публикации, охватывающей все изменения во всех таблицах:
CREATE PUBLICATION alltables FOR ALL TABLES;
Создание публикации, охватывающей только операции INSERT в одной таблице:
CREATE PUBLICATION insert_only FOR TABLE mydata
WITH (publish = ‘insert’);
Совместимость
CREATE PUBLICATION является расширением PostgreSQL.
См. также
ALTER PUBLICATION, DROP PUBLICATION
1494CREATE ROLE
CREATE ROLE — создать роль в базе данных
Синтаксис
CREATE ROLE имя [ [ WITH ] параметр [ … ] ]
Здесь параметр:
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
SUPERUSER | NOSUPERUSER
CREATEDB | NOCREATEDB
CREATEROLE | NOCREATEROLE
INHERIT | NOINHERIT
LOGIN | NOLOGIN
REPLICATION | NOREPLICATION
BYPASSRLS | NOBYPASSRLS
CONNECTION LIMIT предел_подключений
[ ENCRYPTED ] PASSWORD ‘пароль’
VALID UNTIL ‘дата_время’
IN ROLE имя_роли [, …]
IN GROUP имя_роли [, …]
ROLE имя_роли [, …]
ADMIN имя_роли [, …]
USER имя_роли [, …]
SYSID uid
Описание
CREATE ROLE добавляет новую роль в кластер баз данных PostgreSQL. Роль — это сущность, которая
может владеть объектами и иметь определённые права в базе; роль может представлять «пользо-
вателя», «группу» или и то, и другое, в зависимости от варианта использования. За информацией
об управлении пользователями и проверке подлинности обратитесь к Главе 21 и Главе 20. Чтобы
выполнить эту команду, необходимо быть суперпользователем или иметь право CREATEROLE.
Учтите, что роли определяются на уровне кластера баз данных, так что они действуют во всех
базах в кластере.
Параметры
имя
Имя создаваемой роли.
SUPERUSER
NOSUPERUSER
Эти предложения определяют, будет ли эта роль «суперпользователем», который может пере-
определить все ограничения доступа в базе данных. Статус суперпользователя несёт опасность
и назначать его следует только в случае необходимости. Создать нового суперпользователя
может только суперпользователь. В отсутствие этих предложений по умолчанию подразумева-
ется NOSUPERUSER.
CREATEDB
NOCREATEDB
Эти предложения определяют, сможет ли роль создавать базы данных. Указание CREATEDB даёт
новой роли это право, а NOCREATEDB запрещает роли создавать базы данных. По умолчанию
подразумевается NOCREATEDB.
1495CREATE ROLE
CREATEROLE
NOCREATEROLE
Эти предложения определяют, сможет ли роль создавать новые роли (т. е. выполнять CREATE
ROLE). Роль с правом CREATEROLE может также изменять и удалять другие роли. По умолчанию
подразумевается NOCREATEROLE.
INHERIT
NOINHERIT
Эти предложения определяют, будет ли роль «наследовать» права ролей, членом которых она
является. Роль с атрибутом INHERIT может автоматически использовать в базе данных любые
права, назначенные всем ролям, в которые она включена, непосредственно или опосредованно.
Без INHERIT членство в другой роли позволяет только выполнить SET ROLE и переключиться на
эту роль; правами, назначенными другой роли, можно будет пользоваться только после этого.
По умолчанию подразумевается INHERIT.
LOGIN
NOLOGIN
Эти предложения определяют, разрешается ли новой роли вход на сервер; то есть, может ли
эта роль стать начальным авторизованным именем при подключении клиента. Можно считать,
что роль с атрибутом LOGIN соответствует пользователю. Роли без этого атрибута бывают по-
лезны для управления доступом в базе данных, но это не пользователи в обычном понимании.
По умолчанию подразумевается вариант NOLOGIN, за исключением вызова CREATE ROLE в виде
CREATE USER.
REPLICATION
NOREPLICATION
Эти предложения определяют, будет ли роль ролью репликации. Чтобы роль могла подклю-
чаться к серверу в режиме репликации (в режиме физической или логической репликации) и
создавать/удалять слоты репликации, у неё должен быть этот атрибут (либо это должна быть
роль суперпользователя). Роль, имеющая атрибут REPLICATION, обладает очень большими при-
вилегиями и поэтому этот атрибут должны иметь только роли, фактически используемые для
репликации. По умолчанию подразумевается вариант NOREPLICATION.
BYPASSRLS
NOBYPASSRLS
Эти предложения определяют, будут ли для роли игнорироваться все политики защиты на уров-
не строк (RLS). Значение по умолчанию — NOBYPASSRLS. Заметьте, что pg_dump по умолчанию
отключает row_security (устанавливает значение OFF) для уверенности, что выгружено всё со-
держимое таблицы. Если пользователь, запускающий pg_dump, не будет иметь необходимых
прав, он получит ошибку. Суперпользователь и владелец выгружаемой таблицы всегда обходят
защиту RLS.
CONNECTION LIMIT предел_подключений
Если роли разрешён вход, этот параметр определяет, сколько параллельных подключений мо-
жет установить роль. Значение -1 (по умолчанию) снимает ограничение. Заметьте, что под это
ограничение подпадают только обычные подключения. Ни подготовленные транзакции, ни со-
единения фоновых рабочих процессов в расчёт не берутся.
[ ENCRYPTED ] PASSWORD пароль
Задаёт пароль роли. (Пароль полезен только для ролей с атрибутом LOGIN, но задать его мож-
но и для ролей без такого атрибута.) Если проверка подлинности по паролю не будет исполь-
зоваться, этот параметр можно опустить. При указании пустого значения будет задан пароль
NULL, что не позволит данному пользователю пройти проверку подлинности по паролю. При
желании пароль NULL можно установить явно, указав PASSWORD NULL.
1496CREATE ROLE
Примечание
Если задана пустая строка, пароль также будет сброшен в NULL, но в PostgreSQL
до версии 10 было не так. В ранних версиях пустая строка могла приниматься или
нет, в зависимости от метода аутентификации и версии сервера, а libpq не давала
использовать такой пароль в любом случае. Во избежание неоднозначности указы-
вать пустую строку в качестве пароля не следует.
Пароль всегда хранится в системных каталогах в зашифрованном виде. Ключевое слово
ENCRYPTED не имеет эффекта, но принимается для обратной совместимости. Метод шифрова-
ния определяется параметром конфигурации password_encryption. Если представленная стро-
ка пароля уже зашифрована с применением MD5 или SCRAM, она сохраняется как есть вне
зависимости от значения password_encryption (так как система не может расшифровать пере-
данный зашифрованной пароль, чтобы зашифровать его по другому алгоритму). Это позволяет
пересохранять зашифрованные пароли при выгрузке/восстановлении.
VALID UNTIL ‘дата_время’
Предложение VALID UNTIL устанавливает дату и время, после которого пароль роли перестаёт
действовать. Если это предложение отсутствует, срок действия пароля будет неограниченным.
IN ROLE имя_роли
В предложении IN ROLE перечисляются одна или несколько существующих ролей, в которые
будет немедленно включена новая роль. (Заметьте, что добавить новую роль с правами адми-
нистратора таким образом нельзя; для этого надо отдельно выполнить команду GRANT.)
IN GROUP имя_роли
IN GROUP — устаревшее написание предложения IN ROLE.
ROLE имя_роли
В предложении ROLE перечисляются одна или несколько существующих ролей, которые авто-
матически становятся членами создаваемой роли. (По сути таким образом новая роль стано-
вится «группой».)
ADMIN имя_роли
Предложение ADMIN подобно ROLE, но перечисленные в нём роли включаются в новую роль с
атрибутом WITH ADMIN OPTION, что даёт им право включать в эту роль другие роли.
USER имя_роли
Предложение USER является устаревшим написанием предложения ROLE.
SYSID uid
Предложение SYSID игнорируется, но принимается для обратной совместимости.
Замечания
Для изменения атрибутов роли применяется ALTER ROLE, а для удаления роли — DROP ROLE. Все
атрибуты, заданные в CREATE ROLE, могут быть изменены позднее командами ALTER ROLE.
Для добавления и удаления членов ролей, используемых в качестве групп, рекомендуется исполь-
зовать GRANT и REVOKE.
Предложение VALID UNTIL определяет срок действия только пароля, но не роли как таковой. В
частности, ограничение срока пароля не действует при входе пользователя без проверки подлин-
ности по паролю.
1497CREATE ROLE
Атрибут INHERIT управляет наследованием назначаемых прав (то есть правами доступа к объек-
там баз данных и членством в ролях). Его действие не распространяется на специальные атрибу-
ты, устанавливаемые командами CREATE ROLE и ALTER ROLE. Например, членства в роли с правом
CREATEDB недостаточно для получения права создавать базы данных, даже если установлен атри-
бут INHERIT; чтобы воспользоваться правом создавать базы данных, необходимо переключиться на
эту роль, выполнив SET ROLE.
Атрибут INHERIT устанавливается по умолчанию в целях обратной совместимости: в предыдущих
выпусках PostgreSQL пользователи всегда обладали всеми правами групп, в которые они были
включены. Однако NOINHERIT по смыслу ближе к тому, что описано в стандарте SQL.
Будьте осторожны с правом CREATEROLE. На роли, создаваемые командой CREATEROLE, не распро-
страняется концепция наследования. Это значит, что даже если роль не имеет определённого пра-
ва, но может создавать другие роли, она вполне способна создать другую роль с отличным набором
прав (за исключением создания ролей с правами суперпользователя). Например, если роль «user»
имеет право CREATEROLE, но не CREATEDB, она, тем не менее, может создать новую роль с правом
CREATEDB. Поэтому роль с правом CREATEROLE следует воспринимать как роль почти суперпользо-
вателя.
PostgreSQL включает программу createuser, которая предоставляет ту же функциональность, что и
команда CREATE ROLE (на самом деле она вызывает эту команду), но может запускаться в командной
оболочке.
Ограничение CONNECTION LIMIT действует только приблизительно; если одновременно запускают-
ся два сеанса, тогда как для этой роли остаётся только одно «свободное место», может так слу-
читься, что будут отклонены оба подключения. Кроме того, это ограничение не распространяется
на суперпользователей.
Указывая в этой команде незашифрованный пароль, следует проявлять осторожность. Пароль бу-
дет передаваться на сервер открытым текстом и может также записываться в историю команд
клиента или в протокол работы сервера. Команда createuser, однако, передаёт пароль зашифро-
ванным. Кроме того, в psql есть команда \password, с помощью которой можно безопасно сменить
пароль позже.
Примеры
Создание роли, для которой разрешён вход, но не задан пароль:
CREATE ROLE jonathan LOGIN;
Создание роли с паролем:
CREATE USER davide WITH PASSWORD ‘jw8s0F4’;
(CREATE USER действует так же, как CREATE ROLE, но подразумевает ещё и атрибут LOGIN.)
Создание роли с паролем, действующим до конца 2004 г., то есть пароль перестаёт действовать
в первую же секунду 2005 г.
CREATE ROLE miriam WITH LOGIN PASSWORD ‘jw8s0F4’ VALID UNTIL ‘2005-01-01’;
Создание роли, которая может создавать базы данных и управлять ролями:
CREATE ROLE admin WITH CREATEDB CREATEROLE;
Совместимость
Оператор CREATE ROLE описан в стандарте SQL, но стандарт требует поддержки только следующего
синтаксиса:
CREATE ROLE имя [ WITH ADMIN имя_роли ]
Возможность создавать множество начальных администраторов и все другие параметры CREATE
ROLE относятся к расширениям PostgreSQL.
1498CREATE ROLE
В стандарте SQL определяются концепции пользователей и ролей, но в нём они рассматриваются
как отдельные сущности, а все команды создания пользователей считаются внутренней специфи-
кой СУБД. В PostgreSQL мы решили объединить пользователей и роли в единую сущность, так что
роли получили дополнительные атрибуты, не описанные в стандарте.
Поведение, наиболее близкое к описанному в стандарте SQL, можно получить, если создавать
пользователей с атрибутом NOINHERIT, а роли — с атрибутом INHERIT.
См. также
SET ROLE, ALTER ROLE, DROP ROLE, GRANT, REVOKE, createuser
1499CREATE RULE
CREATE RULE — создать правило перезаписи
Синтаксис
CREATE [ OR REPLACE ] RULE имя AS ON событие
TO имя_таблицы [ WHERE условие ]
DO [ ALSO | INSTEAD ] ( NOTHING | команда | ( команда ; команда … ) )
Здесь допускается событие:
SELECT | INSERT | UPDATE | DELETE
Описание
CREATE RULE создаёт правило, применяемое к указанной таблице или представлению. CREATE OR
REPLACE RULE либо создаёт новое правило, либо заменяет существующее с тем же именем для той
же таблицы.
Система правил PostgreSQL позволяет определить альтернативное действие, заменяющее опера-
ции добавления, изменения или удаления данных в таблицах базы данных. Грубо говоря, прави-
ло описывает дополнительные команды, которые будут выполняться при вызове определённой ко-
манды для определённой таблицы. Кроме того, правило INSTEAD может заменить заданную коман-
ду другой, либо сделать, чтобы она не выполнялась вовсе. Правила также применяются для реали-
зации SQL-запросов. Важно понимать, что правило это фактически механизм преобразования ко-
манд (макрос). Заданное преобразование имеет место до начала выполнения команды. Когда тре-
буется выполнить некоторую операцию независимо для каждой физической строки, скорее всего,
для этого нужно применять триггер, а не правило. Более подробно о системе правил можно узнать
в Главе 41.
В настоящее время правила ON SELECT должны быть безусловными, с характеристикой INSTEAD
(вместо исходного), и их действия должны состоять из единственной команды SELECT. Таким обра-
зом, правило ON SELECT по сути превращает таблицу в представление, чьим видимым содержимым
являются строки, возвращаемые командой SELECT, заданной в правиле, а не данные, хранящиеся в
таблице (если они есть). Вообще же для этой цели лучшим стилем считается пользоваться коман-
дой CREATE VIEW, а не создавать реальную таблицу и определять затем правило ON SELECT для неё.
С помощью правил можно создать иллюзию изменяемого представления, определив правила ON
INSERT, ON UPDATE и ON DELETE (либо только те, которых достаточно для решения поставленной
задачи) и заменив операции изменения данных в представлении соответствующими действиями с
другими таблицами. Если требуется поддерживать оператор INSERT RETURNING и подобные ему, в
каждое из этих правило обязательно нужно поместить подходящее предложение RETURNING.
Использование правил с условиями для сложных изменений представлений связано с одним огра-
ничением: для каждого действия, которое вы хотите разрешить для представления, необходимо
определить безусловное правило INSTEAD. Если определено только условное правило, или правило
не типа INSTEAD, система отвергнет попытки выполнить изменения, предполагая, что в некоторых
случаях изменения могут свестись к операциям с фиктивной нижележащей таблицей. При жела-
нии обработать все полезные случаи изменений в условных правилах, добавьте безусловное пра-
вило DO INSTEAD NOTHING, чтобы система понимала, что ей никогда не придётся изменять ниже-
лежащую таблицу. Затем создайте условные правила без свойства INSTEAD; в тех случаях, когда
они будут применяться, их действия будут добавлены к действию по умолчанию INSTEAD NOTHING.
(Однако, этот способ в настоящее время не подходит для реализации запросов RETURNING.)
1500CREATE RULE
Примечание
Представления, достаточно простые для реализации автоматического обновления (см.
CREATE VIEW), могут быть изменяемыми без пользовательских правил. Хотя вы, тем не
менее, можете создать явное правило, обычно автоматическое преобразование будет
работать лучше такого правила.
Другая, заслуживающая рассмотрения, альтернатива правилам — триггеры INSTEAD
OF (см. CREATE TRIGGER).
Параметры
имя
Имя создаваемого правила. Оно должно отличаться от имён любых других правил для той же
таблицы. При наличии нескольких правил для одной таблицы и одного типа события они при-
меняются в алфавитном порядке.
событие
Тип события: SELECT, INSERT, UPDATE или DELETE. Заметьте, что команду INSERT с предложением
ON CONFLICT нельзя использовать с таблицами, для которых определены правила INSERT или
UPDATE. В этом случае подумайте о применении изменяемых представлений.
имя_таблицы
Имя (возможно, дополненное схемой) существующей таблицы (или представления), к которой
применяется это правило.
условие
Любое выражение условия SQL (возвращающее boolean). Это выражение не может ссылаться
на какие-либо таблицы, кроме как на NEW и OLD, и не может содержать агрегатные функции.
INSTEAD
INSTEAD указывает, что заданные команды должны выполняться вместо исходной команды.
ALSO
ALSO указывает, что заданные команды должны выполняться в дополнение к исходной команде.
Если ни ALSO, ни INSTEAD не указано, по умолчанию подразумевается ALSO.
команда
Команда или команды, составляющие действие правила. Здесь допустимы команды: SELECT,
INSERT, UPDATE, DELETE и NOTIFY.
В параметрах условие и команда можно использовать имена специальных таблиц NEW и OLD для об-
ращения к значениям в соответствующей таблице. NEW (новая) принимается в правилах ON INSERT
и ON UPDATE и обозначает ссылку на новую строку, добавляемую или изменяемую. OLD (старая)
принимается в правилах ON UPDATE и ON DELETE и обозначает ссылку на существующую строку,
изменяемую или удаляемую.
Замечания
Чтобы создать или изменить правила для таблицы, нужно быть её владельцем.
В правило для INSERT, UPDATE или DELETE для представления можно добавить предложение
RETURNING, выдающее столбцы представления. Это предложение будет генерировать результат,
1501CREATE RULE
если правило сработает при выполнении команды INSERT RETURNING, UPDATE RETURNING или
DELETE RETURNING. Когда правило срабатывает при выполнении команды без RETURNING, предло-
жение RETURNING этого правила игнорируется. В текущей реализации только безусловные пра-
вила INSTEAD могут содержать RETURNING; более того, допускается максимум одно предложение
RETURNING среди всех правил для некоторого события. (Благодаря этому ограничению, только одно
предложение RETURNING может быть выбрано для вычисления результатов.) Запросы с RETURNING
к данному представлению не будут выполняться, если ни одно из определённых для него правил
не содержит предложение RETURNING.
Очень важно следить за тем, чтобы правила не зацикливались. Например, два следующих опреде-
ления правил будут приняты PostgreSQL, но при попытке выполнить команду SELECT PostgreSQL
сообщит об ошибке из-за рекурсивного расширения правила:
CREATE RULE “_RETURN” AS
ON SELECT TO t1
DO INSTEAD
SELECT * FROM t2;
CREATE RULE “_RETURN” AS
ON SELECT TO t2
DO INSTEAD
SELECT * FROM t1;
SELECT * FROM t1;
В настоящее время, если действие правила содержит команду NOTIFY, эта команда будет выпол-
няться безусловно, то есть, NOTIFY будет выдаваться, даже если не найдётся никаких строк, к ко-
торым бы применялось правило. Например, в следующем примере:
CREATE RULE notify_me AS ON UPDATE TO mytable DO ALSO NOTIFY mytable;
UPDATE mytable SET name = ‘foo’ WHERE id = 42;
одно событие NOTIFY будет отправлено при выполнении команды UPDATE, даже если никакие строки
не соответствуют условию id = 42. Это недостаток текущей реализации, который может быть
исправлен в будущих версиях.
Совместимость
Оператор CREATE RULE является языковым расширением PostgreSQL, как и вся система перезаписи
запросов.
См. также
ALTER RULE, DROP RULE
1502CREATE SCHEMA
CREATE SCHEMA — создать схему
Синтаксис
CREATE
CREATE
CREATE
CREATE
SCHEMA
SCHEMA
SCHEMA
SCHEMA
имя_схемы [ AUTHORIZATION указание_роли ] [ элемент_схемы [ … ] ]
AUTHORIZATION указание_роли [ элемент_схемы [ … ] ]
IF NOT EXISTS имя_схемы [ AUTHORIZATION указание_роли ]
IF NOT EXISTS AUTHORIZATION указание_роли
Здесь указание_роли:
имя_пользователя
| CURRENT_USER
| SESSION_USER
Описание
CREATE SCHEMA создаёт новую схему в текущей базе данных. Имя схемы должно отличаться от имён
других существующих схем в текущей базе данных.
Схема по сути представляет собой пространство имён: она содержит именованные объекты (таб-
лицы, типы данных, функции и операторы), имена которых могут совпадать с именами других объ-
ектов, существующих в других схемах. Для обращения к объекту нужно либо «дополнить» его имя
именем схемы в виде префикса, либо установить путь поиска, включающий требуемую схему. Ко-
манда CREATE, в которой указывается неполное имя объекта, создаёт объект в текущей схеме (схе-
ме, стоящей первой в пути поиска; узнать её позволяет функция current_schema).
Команда CREATE SCHEMA может дополнительно включать подкоманды, создающие объекты в новой
схеме. Эти подкоманды по сути воспринимаются как отдельные команды, выполняемые после со-
здания схемы, за исключением того, что с предложением AUTHORIZATION все создаваемые объекты
будут принадлежать указанному в нём пользователю.
Параметры
имя_схемы
Имя создаваемой схемы. Если оно опущено, именем схемы будет имя_пользователя. Это имя
не может начинаться с pg_, так как такие имена зарезервированы для системных схем.
имя_пользователя
Имя пользователя (роли), назначаемого владельцем новой схемы. Если опущено, по умолчанию
владельцем будет пользователь, выполняющий команды. Чтобы назначить владельцем созда-
ваемой схемы другую роль, необходимо быть непосредственным или опосредованным членом
этой роли, либо суперпользователем.
элемент_схемы
Оператор SQL, определяющий объект, создаваемый в новой схеме. В настоящее время CREATE
SCHEMA может содержать только подкоманды CREATE TABLE, CREATE VIEW, CREATE INDEX, CREATE
SEQUENCE, CREATE TRIGGER и GRANT. Создать объекты других типов можно отдельными команда-
ми после создания схемы.
IF NOT EXISTS
Не делать ничего (только выдать замечание), если схема с таким именем уже существует. Когда
используется это указание, эта команда не может содержать подкоманды элемент_схемы.
1503CREATE SCHEMA
Замечания
Чтобы создать схему, пользователь должен иметь право CREATE в текущей базе данных. (Разумеет-
ся, на суперпользователей это условие не распространяется.)
Примеры
Создание схемы:
CREATE SCHEMA myschema;
Создание схемы для пользователя joe; схема так же получит имя joe:
CREATE SCHEMA AUTHORIZATION joe;
Создание схемы с именем test, владельцем которой будет пользователь joe, если только схема
test ещё не существует. (Является ли владельцем существующей схемы пользователь joe, значе-
ния не имеет.)
CREATE SCHEMA IF NOT EXISTS test AUTHORIZATION joe;
Создание схемы, в которой сразу создаются таблица и представление:
CREATE SCHEMA hollywood
CREATE TABLE films (title text, release date, awards text[])
CREATE VIEW winners AS
SELECT title, release FROM films WHERE awards IS NOT NULL;
Заметьте, что отдельные подкоманды не завершаются точкой с запятой.
Следующие команды приводят к тому же результату другим способом:
CREATE SCHEMA hollywood;
CREATE TABLE hollywood.films (title text, release date, awards text[]);
CREATE VIEW hollywood.winners AS
SELECT title, release FROM hollywood.films WHERE awards IS NOT NULL;
Совместимость
Стандарт SQL также допускает в команде CREATE SCHEMA предложение DEFAULT CHARACTER SET и
дополнительные типы подкоманд, которые PostgreSQL в настоящее время не принимает.
В стандарте SQL говорится, что подкоманды в CREATE SCHEMA могут следовать в любом порядке.
Однако текущая реализация в PostgreSQL не воспринимает все возможные варианты ссылок впе-
рёд в подкомандах, поэтому иногда возникает необходимость переупорядочить подкоманды, что-
бы исключить такие ссылки.
Согласно стандарту SQL, владелец схемы всегда владеет всеми объектами в ней, но PostgreSQL
допускает размещение в схемах объектов, принадлежащих не владельцу схемы. Такая ситуация
возможна, только если владелец схемы даст право CREATE в этой схеме кому-либо другому, либо
объекты в ней будет создавать суперпользователь.
Указание IF NOT EXISTS является расширением PostgreSQL.
См. также
ALTER SCHEMA, DROP SCHEMA
1504CREATE SEQUENCE
CREATE SEQUENCE — создать генератор последовательности
Синтаксис
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] имя
[ AS тип_данных ]
[ INCREMENT [ BY ] шаг ]
[ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
[ START [ WITH ] начало ] [ CACHE кеш ] [ [ NO ] CYCLE ]
[ OWNED BY ( имя_таблицы.имя_столбца | NONE ) ]
Описание
CREATE SEQUENCE создаёт генератор последовательности. Эта операция включает создание и ини-
циализацию специальной таблицы имя, содержащей одну строку. Владельцем генератора будет
пользователь, выполняющий эту команду.
Если указано имя схемы, последовательность создаётся в заданной схеме, в противном случае — в
текущей. Временные последовательности существуют в специальной схеме, так что при создании
таких последовательностей имя схемы задать нельзя. Имя последовательности должно отличаться
от имён других последовательностей, таблиц, индексов, представлений или сторонних таблиц, уже
существующих в этой схеме.
После создания последовательности работать с ней можно, вызывая функции nextval, currval и
setval. Эти функции документированы в Разделе 9.16.
Хотя непосредственно изменить значение последовательности нельзя, получить её параметры и
текущее состояние можно таким запросом:
SELECT * FROM name;
В частности, поле last_value последовательности будет содержать последнее значение, выделен-
ное для какого-либо сеанса. (Конечно, ко времени вывода это значение может стать неактуальным,
если другие сеансы активно вызывают nextval.)
Параметры
TEMPORARY или TEMP
Если указано, объект последовательности создаётся только для данного сеанса и автоматиче-
ски удаляется при завершении сеанса. Существующая постоянная последовательность с тем
же именем не будут видна (в этом сеансе), пока существует временная, однако к ней можно
обратиться, дополнив имя указанием схемы.
IF NOT EXISTS
Не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет
выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то
соотносится с последовательностью, которая могла бы быть создана — это может быть даже
не последовательность.
имя
Имя создаваемой последовательности (возможно, дополненное схемой).
тип_данных
Необязательное предложение AS тип_данных задаёт тип данных для последовательности. До-
пустимые типы: smallint, integer и bigint. По умолчанию устанавливается тип bigint. От
1505CREATE SEQUENCE
типа данных зависят принимаемые по умолчанию минимальное и максимальное значения по-
следовательности.
шаг
Необязательное предложение INCREMENT BY шаг определяет, какое число будет добавляться
к текущему значению последовательности для получения нового значения. С положительным
шагом последовательность будет возрастающей, а с отрицательным — убывающей. Значение
по умолчанию: 1.
мин_значение
NO MINVALUE
Необязательное предложение MINVALUE мин_значение определяет наименьшее число, кото-
рое будет генерировать последовательность. Если это предложение опущено либо указано NO
MINVALUE, используется значение по умолчанию: 1 для возвращающей последовательности или
минимальное значение типа данных — для убывающей.
макс_значение
NO MAXVALUE
Необязательное предложение MAXVALUE макс_значение определяет наибольшее число, кото-
рое будет генерировать последовательность. Если это предложение опущено либо указано NO
MAXVALUE, используется значение по умолчанию: максимальное значение типа данных для воз-
растающей последовательности или -1 — для убывающей.
начало
Необязательное предложение START WITH начало позволяет запустить последовательность с
любого значения. По умолчанию началом считается мин_значение для возрастающих последо-
вательностей и макс_значение для убывающих.
кеш
Необязательное предложение CACHE кеш определяет, сколько чисел последовательности будет
выделяться и сохраняться в памяти для ускорения доступа к ним. Минимальное значение рав-
но 1 (за один раз генерируется только одно значение, т. е. кеширования нет), и оно же пред-
полагается по умолчанию.
CYCLE
NO CYCLE
Параметр CYCLE позволяет зациклить последовательность при достижении макс_значения или
мин_значения для возрастающей или убывающей последовательности, соответственно. Когда
этот предел достигается, следующим числом этих последовательностей будет соответственно
мин_значение или макс_значение.
Если указывается NO CYCLE, при каждом вызове nextval после достижения предельного зна-
чения будет возникать ошибка. Если указания CYCLE и NO CYCLE отсутствуют, по умолчанию
предполагается NO CYCLE.
OWNED BY имя_таблицы.имя_столбца
OWNED BY NONE
Предложение OWNED BY позволяет связать последовательность с определённым столбцом таб-
лицы так, чтобы при удалении этого столбца (или всей таблицы) последовательность удалялась
автоматически. Указанная таблица должна иметь того же владельца и находиться в той же
схеме, что и последовательность. Подразумеваемое по умолчанию предложение OWNED BY NONE
указывает, что такая связь не устанавливается.
Замечания
Для удаления последовательности применяется команда DROP SEQUENCE.
1506CREATE SEQUENCE
Последовательности основаны на арифметике bigint, так что их значения не могут выходить за
диапазон восьмибайтовых целых (-9223372036854775808 .. 9223372036854775807).
Так как вызовы nextval и setval никогда не откатываются, объекты последовательностей не под-
ходят, если требуется обеспечить непрерывное назначение номеров последовательностей. Непре-
рывное назначение можно организовать, используя исключительную блокировку таблицы со счёт-
чиком; однако это решение будет гораздо дороже, чем применение объектов последовательностей,
особенно когда последовательные номера будут затребоваться сразу многими транзакциями.
Если значение параметра кеш больше единицы, и объект последовательности используется парал-
лельно в нескольких сеансах, результат может оказаться не вполне ожидаемым. Каждый сеанс
будет выделять и кешировать несколько очередных значений последовательности при одном об-
ращении к объекту последовательности и соответственно увеличивать последнее_значение этого
объекта. Затем при следующих кеш-1 вызовах nextval в этом сеансе будет просто возвращать за-
готовленные значения, не касаясь объекта последовательности. В результате, все числа, выделен-
ные, но не использованные в сеансе, будут потеряны при завершении сеанса, что приведёт к об-
разовании «дырок» в последовательности.
Более того, хотя разным сеансам гарантированно выделяются различные значения последователь-
ности, если рассмотреть все сеансы в целом, порядок этих значений может быть нарушен. На-
пример, при значении кеш, равном 10, сеанс A может зарезервировать значения 1..10 и получить
nextval=1, затем сеанс B может зарезервировать значения 11..20 и получить nextval=11 до того,
как в сеансе A сгенерируется nextval=2. Таким образом, при значении кеш, равном одному, можно
быть уверенными в том, что nextval генерирует последовательные значения; но если кеш больше
одного, рассчитывать можно только на то, что все значения nextval различны; их порядок может
быть непоследовательным. Кроме того, last_value возвращает последнее зарезервированное зна-
чение для всех сеансов, вне зависимости от того, было ли оно уже возвращено функцией nextval.
Также следует учитывать, что действие функции setval, выполненной для такой последователь-
ности, проявится в других сеансах только после того, как в них будут использованы все предвари-
тельно закешированные значения.
Примеры
Создание возрастающей последовательности с именем serial, с начальным значением 101:
CREATE SEQUENCE serial START 101;
Получение следующего номера этой последовательности:
SELECT nextval(‘serial’);
nextval
———
101
Получение следующего номера этой последовательности:
SELECT nextval(‘serial’);
nextval
———
102
Использование этой последовательности в команде INSERT:
INSERT INTO distributors VALUES (nextval(‘serial’), ‘nothing’);
Изменение значения последовательности после COPY FROM:
BEGIN;
COPY distributors FROM ‘input_file’;
1507CREATE SEQUENCE
SELECT setval(‘serial’, max(id)) FROM distributors;
END;
Совместимость
Команда CREATE SEQUENCE соответствует стандарту SQL, со следующими исключениями:
• Для получения следующего значения применяется функция nextval(), а не выражение NEXT
VALUE FOR, как того требует стандарт.
• Предложение OWNED BY является расширением PostgreSQL.
См. также
ALTER SEQUENCE, DROP SEQUENCE
1508CREATE SERVER
CREATE SERVER — создать сторонний сервер
Синтаксис
CREATE SERVER [ IF NOT EXISTS ] имя_сервера [ TYPE ‘тип_сервера’ ] [ VERSION
‘версия_сервера’ ]
FOREIGN DATA WRAPPER имя_обёртки_сторонних_данных
[ OPTIONS ( параметр ‘значение’ [, … ] ) ]
Описание
CREATE SERVER создаёт сторонний сервер. Владельцем сервера становится создавший его пользо-
ватель.
Определение стороннего сервера обычно включает информацию о подключении, которую исполь-
зует обёртка сторонних данных для доступа к внешнему ресурсу. Определяя сопоставления поль-
зователей, можно установить и другие параметры подключения, связанные с пользователями.
Имя сервера должно быть уникальным в базе данных.
Для создания сервера требуется право USAGE для обёртки сторонних данных.
Параметры
IF NOT EXISTS
Не считать ошибкой, если сервер с таким именем уже существует. В этом случае будет выдано
замечание. Заметьте, что нет никакой гарантии, что существующий сервер как-то соотносится
с тем, который мог бы быть создан.
имя_сервера
Имя создаваемого стороннего сервера.
тип_сервера
Необязательный тип сервера, может быть полезен для обёрток сторонних данных.
версия_сервера
Необязательная версия сервера, может быть полезна для обёрток сторонних данных.
имя_обёртки_сторонних_данных
Имя обёртки сторонних данных, управляющей сервером.
OPTIONS ( параметр ‘значение’ [, … ] )
Это предложение определяет параметры сервера. Эти параметры обычно задают свойства под-
ключения к серверу; их конкретные имена и значения зависят от обёртки сторонних данных.
Замечания
При использовании модуля dblink имя стороннего сервера может служить аргументом функ-
ции dblink_connect, определяющим параметры подключения. Для такого варианта использования
необходимо иметь право USAGE для стороннего сервера.
Примеры
Создание сервера myserver, доступного через обёртку postgres_fdw:
1509CREATE SERVER
CREATE SERVER myserver FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host ‘foo’, dbname
‘foodb’, port ‘5432’);
За подробностями обратитесь к postgres_fdw.
Совместимость
CREATE SERVER соответствует стандарту ISO/IEC 9075-9 (SQL/MED).
См. также
ALTER SERVER, DROP SERVER, CREATE FOREIGN DATA WRAPPER, CREATE FOREIGN TABLE,
CREATE USER MAPPING
1510CREATE STATISTICS
CREATE STATISTICS — создать расширенную статистику
Синтаксис
CREATE STATISTICS [ IF NOT EXISTS ] имя_статистики
[ ( вид_статистики [, … ] ) ]
ON имя_столбца, имя_столбца [, …]
FROM имя_таблицы
Описание
Команда CREATE STATISTICS создаст новый объект расширенной статистики, отслеживающий дан-
ные определённой таблицы, сторонней таблицы или материализованного представления. Объект
статистики будет создан в текущей базе данных, и его владельцем станет пользователь, выполня-
ющий команду.
Если задано имя схемы (например, CREATE STATISTICS myschema.mystat …), объект статистики
создаётся в указанной схеме, в противном случае — в текущей. Имя объекта статистики должно
отличаться от имён других объектов статистики в этой схеме.
Параметры
IF NOT EXISTS
Не считать ошибкой, если объект статистики с таким именем уже существует. В этом случае
будет выдано замечание. Заметьте, что при этом проверяется только имя объекта, а не харак-
теристики его определения.
имя_статистики
Имя создаваемого объекта статистики (возможно, дополненное схемой).
вид_статистики
Вид статистики, которая будет вычисляться в этом объекте. В настоящее время поддержива-
ется статистика ndistinct, подсчёт числа различных значений, и dependencies, определение
функциональных зависимостей. Если это предложение опущено, в объект статистики вклю-
чаются все поддерживаемые виды статистики. За дополнительными сведениями обратитесь к
Подразделу 14.2.2 и Разделу 70.2.
имя_столбца
Имя столбца таблицы, который будет покрываться вычисляемой статистикой. Необходимо ука-
зать имена минимум двух столбцов.
имя_таблицы
Имя (возможно, дополненное схемой) таблицы, содержащей столбцы, по которым создаётся
статистика.
Замечания
Чтобы создать объект статистики, читающий таблицу, необходимо быть владельцем этой таблицы.
После создания объекта статистики его владелец может определяться независимо от нижележа-
щей таблицы.
Примеры
В данном примере создаётся таблица t1 с двумя функционально зависимыми столбцами; то есть
знания значения одного столбца достаточно, чтобы определить значение другого. Затем для этих
столбцов строится статистика функциональной зависимости:
1511CREATE STATISTICS
CREATE TABLE t1 (
a
int,
b
int
);
INSERT INTO t1 SELECT i/100, i/500
FROM generate_series(1,1000000) s(i);
ANALYZE t1;
– число совпадающих строк будет катастрофически недооценено:
EXPLAIN ANALYZE SELECT * FROM t1 WHERE (a = 1) AND (b = 0);
CREATE STATISTICS s1 (dependencies) ON a, b FROM t1;
ANALYZE t1;
– теперь оценка числа строк стала точнее:
EXPLAIN ANALYZE SELECT * FROM t1 WHERE (a = 1) AND (b = 0);
Без статистики функциональной зависимости планировщик предположил бы, что два условия
WHERE независимы друг от друга, и перемножил бы их оценки избирательности, что дало бы слиш-
ком заниженную оценку числа строк. Однако с созданной статистикой планировщик понимает,
что условия WHERE избыточны и не ошибается с этой оценкой.
Совместимость
Команда CREATE STATISTICS отсутствует в стандарте SQL.
См. также
ALTER STATISTICS, DROP STATISTICS
1512CREATE SUBSCRIPTION
CREATE SUBSCRIPTION — создать подписку
Синтаксис
CREATE SUBSCRIPTION имя_подписки
CONNECTION ‘строка_подключения’
PUBLICATION имя_публикации [, …]
[ WITH ( параметр_подписки [= значение] [, … ] ) ]
Описание
CREATE SUBSCRIPTION создаёт подписку для текущей базы данных. Имя подписки должно отли-
чаться от имён других существующих подписок в текущей базе.
Подписка представляет собой реплицирующее подключение к публикующему серверу. Поэтому
данная команда не только добавляет определения подписки в локальные каталоги, но также со-
здаёт слот репликации на удалённом сервере.
В момент фиксации транзакции, в рамках которой выполняется эта команда, будет запущен рабо-
чий процесс логической репликации.
Дополнительные сведения о подписках и логической репликации в целом можно найти в Разде-
ле 31.2 и Главе 31.
Параметры
имя_подписки
Имя новой подписки.
CONNECTION ‘строка_подключения’
Строка подключения к публикующему серверу. Подробности описаны в Подразделе 34.1.1.
PUBLICATION имя_публикации
Имена публикаций на публикующем сервере, на которые оформляется подписка.
WITH ( параметр_подписки [= значение] [, … ] )
В этом предложении могут задаваться следующие необязательные параметры подписки:
copy_data (boolean)
Определяет, должны ли копироваться существующие данные в публикациях, на которые
оформляется подписка, сразу после начала репликации. Значение по умолчанию — true.
create_slot (boolean)
Определяет, должна ли команда создавать слот репликации на публикующем сервере. Зна-
чение по умолчанию — true.
enabled (boolean)
Определяет, активировать ли репликацию в подписке, или её нужно только настроить, но
не запускать сразу. Значение по умолчанию — true.
slot_name (string)
Имя слота репликации, которое должно использоваться. По умолчанию в качестве имени
слота используется имя подписки.
1513CREATE SUBSCRIPTION
Когда в качестве slot_name задаётся NONE, с подпиской не будет связан слот репликации.
Это может быть полезно, если слот репликации позднее будет создаваться вручную. У таких
подписок также должны быть равны false свойства enabled и create_slot.
synchronous_commit (enum)
Значение этого параметра переопределяет свойство synchronous_commit. По умолчанию —
off.
Значение off безопасно для логической репликации: если подписчик потеряет транзакции
из-за нарушения синхронизации, данные будут повторно переданы с публикующего серве-
ра.
При выполнении синхронной логической репликации может быть уместно другое значение.
Рабочие процессы логической репликации передают позиции записанных и сохранённых на
диске данных публикующему серверу, так что при синхронной репликации он будет ждать
завершения сохранения. Это значит, что значение off параметра synchronous_commit на
подписчике может увеличить задержку при выполнении COMMIT на сервере публикации.
При таком сценарии может быть выгоднее задать для synchronous_commit значение local
или выше.
connect (boolean)
Определяет, нужно ли при выполнении CREATE SUBSCRIPTION подключаться к публику-
ющему серверу. Если равняется false, значениями по умолчанию параметров enabled,
create_slot и copy_data тоже будет false.
Значение false параметра connect несовместимо со значением true параметров enabled,
create_slot и copy_data.
Так как со значением false соединение не устанавливается, подписка на таблицы не оформ-
ляется, так что после включения подписки ничего не будет реплицироваться. Чтобы таб-
лицы вошли в подписку, потребуется позже выполнить ALTER SUBSCRIPTION … REFRESH
PUBLICATION.
Замечания
Подробнее о том, как организовать управление доступом подписчиков к публикующему серверу,
рассказывается в Разделе 31.7.
При создании слота репликации (поведение по умолчанию) CREATE SUBSCRIPTION нельзя выпол-
нять внутри блока транзакции.
Создание подписки с подключением к тому же кластеру баз данных (например, для организации
репликации между базами данных в одном кластере или в одной базе данных) будет успешным,
только если слот репликации не создаётся той же командой. В противном случае команда CREATE
SUBSCRIPTION зависнет. Чтобы оформить такую подписку, слот репликации нужно создать отдель-
но (воспользовавшись функцией pg_create_logical_replication_slot и передав ей имя модуля
pgoutput) и создать подписку с параметром create_slot = false. Это ограничение реализации,
которое может быть устранено в будущем выпуске.
Примеры
Создание подписки на репликации mypublication и insert_only на удалённом сервере с немед-
ленным запуском репликации при фиксировании транзакции:
CREATE SUBSCRIPTION mysub
CONNECTION ‘host=192.168.1.50 port=5432 user=foo dbname=foodb’
PUBLICATION mypublication, insert_only;
Создание подписки на публикацию insert_only на удалённом сервере с отключением репликации
для запуска в будущем.
1514CREATE SUBSCRIPTION
CREATE SUBSCRIPTION
CONNECTION
PUBLICATION
WITH
mysub
‘host=192.168.1.50 port=5432 user=foo dbname=foodb’
insert_only
(enabled = false);
Совместимость
CREATE SUBSCRIPTION является расширением PostgreSQL.
См. также
ALTER SUBSCRIPTION, DROP SUBSCRIPTION, CREATE PUBLICATION, ALTER PUBLICATION
1515CREATE TABLE
CREATE TABLE — создать таблицу
Синтаксис
CREATE [ [ GLOBAL | LOCAL ] ( TEMPORARY | TEMP ) | UNLOGGED ] TABLE [ IF NOT
EXISTS ] имя_таблицы ( [
( имя_столбца тип_данных [ COLLATE правило_сортировки ] [ ограничение_столбца
[ … ] ]
| ограничение_таблицы
| LIKE исходная_таблица [ вариант_копирования … ] )
[, … ]
] )
[ INHERITS ( таблица_родитель [, … ] ) ]
[ PARTITION BY ( RANGE | LIST | HASH ) ( ( имя_столбца | ( выражение ) )
[ COLLATE правило_сортировки ] [ класс_операторов ] [, … ] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT ( PRESERVE ROWS | DELETE ROWS | DROP ) ]
[ TABLESPACE табл_пространство ]
CREATE [ [ GLOBAL | LOCAL ] ( TEMPORARY | TEMP ) | UNLOGGED ] TABLE [ IF NOT
EXISTS ] имя_таблицы
OF имя_типа [ (
( имя_столбца [ WITH OPTIONS ] [ ограничение_столбца [ … ] ]
| ограничение_таблицы )
[, … ]
) ]
[ PARTITION BY ( RANGE | LIST | HASH ) ( ( имя_столбца | ( выражение ) )
[ COLLATE правило_сортировки ] [ класс_операторов ] [, … ] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT ( PRESERVE ROWS | DELETE ROWS | DROP ) ]
[ TABLESPACE табл_пространство ]
CREATE [ [ GLOBAL | LOCAL ] ( TEMPORARY | TEMP ) | UNLOGGED ] TABLE [ IF NOT
EXISTS ] имя_таблицы
PARTITION OF таблица_родитель [ (
( имя_столбца [ WITH OPTIONS ] [ ограничение_столбца [ … ] ]
| ограничение_таблицы )
[, … ]
) ] ( FOR VALUES указание_границ_секции | DEFAULT )
[ PARTITION BY ( RANGE | LIST | HASH ) ( ( имя_столбца | ( выражение ) )
[ COLLATE правило_сортировки ] [ класс_операторов ] [, … ] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT ( PRESERVE ROWS | DELETE ROWS | DROP ) ]
[ TABLESPACE табл_пространство ]
Здесь ограничение_столбца:
[ CONSTRAINT имя_ограничения ]
( NOT NULL |
NULL |
CHECK ( выражение ) [ NO INHERIT ] |
DEFAULT выражение_по_умолчанию |
GENERATED ( ALWAYS | BY DEFAULT ) AS IDENTITY [ ( параметры_последовательности ) ] |
UNIQUE параметры_индекса |
1516CREATE TABLE
PRIMARY KEY параметры_индекса |
REFERENCES целевая_таблица [ ( целевой_столбец ) ] [ MATCH FULL | MATCH PARTIAL |
MATCH SIMPLE ]
[ ON DELETE действие ] [ ON UPDATE действие ] )
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
и ограничение_таблицы:
[ CONSTRAINT имя_ограничения ]
( CHECK ( выражение ) [ NO INHERIT ] |
UNIQUE ( имя_столбца [, … ] ) параметры_индекса |
PRIMARY KEY ( имя_столбца [, … ] ) параметры_индекса |
EXCLUDE [ USING метод_индекса ] ( элемент_исключения WITH оператор
[, … ] ) параметры_индекса [ WHERE ( предикат ) ] |
FOREIGN KEY ( имя_столбца [, … ] ) REFERENCES целевая_таблица [ ( целевой_столбец
[, … ] ) ]
[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE действие ] [ ON
UPDATE действие ] )
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
и вариант_копирования:
( INCLUDING | EXCLUDING ) ( COMMENTS | CONSTRAINTS | DEFAULTS | IDENTITY | INDEXES |
STATISTICS | STORAGE | ALL )
и указание_границ_секции:
IN ( ( числовая_константа | строковая_константа | TRUE | FALSE | NULL ) [, …] ) |
FROM ( ( числовая_константа | строковая_константа | TRUE | FALSE | MINVALUE |
MAXVALUE ) [, …] )
TO ( ( числовая_константа | строковая_константа | TRUE | FALSE | MINVALUE |
MAXVALUE ) [, …] ) |
WITH ( MODULUS числовая_константа, REMAINDER числовая_константа )
параметры_индекса в ограничениях UNIQUE, PRIMARY KEY и EXCLUDE:
[ INCLUDE ( имя_столбца [, … ] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) ]
[ USING INDEX TABLESPACE табл_пространство ]
элемент_исключения в ограничении EXCLUDE:
( имя_столбца | ( выражение ) ) [ класс_операторов ] [ ASC | DESC ] [ NULLS ( FIRST |
LAST ) ]
Описание
CREATE TABLE создаёт новую, изначально пустую таблицу в текущей базе данных. Владельцем таб-
лицы будет пользователь, выполнивший эту команду.
Если задано имя схемы (например, CREATE TABLE myschema.mytable …), таблица создаётся в
указанной схеме, в противном случае — в текущей. Временные таблицы существуют в специаль-
ной схеме, так что при создании таких таблиц имя схемы задать нельзя. Имя таблицы должно от-
личаться от имён других таблиц, последовательностей, индексов, представлений или сторонних
таблиц в этой схеме.
CREATE TABLE также автоматически создаёт составной тип данных, соответствующий одной строке
таблицы. Таким образом, имя таблицы не может совпадать с именем существующего типа в этой
же схеме.
1517CREATE TABLE
Необязательные предложения ограничений задают ограничения (проверки), которым должны
удовлетворять добавляемые или изменяемые строки, чтобы операция добавления или изменения
была выполнена успешно. Ограничение представляет собой SQL-объект, помогающий некоторым
способом определить множество допустимых значений в таблице.
Определить ограничения можно двумя способами: в виде ограничений таблицы и в виде ограни-
чений столбца. Ограничение столбца определяется как часть определения столбца, а ограниче-
ние таблицы не привязывается к конкретному столбцу и может задействовать несколько столбцов.
Любые ограничения столбцов можно также записать в виде ограничения таблицы, они введены
просто для удобства записи в случаях, когда ограничение затрагивает только один столбец.
Чтобы создать таблицу, необходимо иметь право USAGE для типов всех столбцов или типа в пред-
ложении OF, соответственно.
Параметры
TEMPORARY или TEMP
С таким указанием таблица создаётся как временная. Временные таблицы автоматически уда-
ляются в конце сеанса или могут удаляться в конце текущей транзакции (см. описание ON
COMMIT ниже). Существующая постоянная таблица с тем же именем не будет видна в текущем
сеансе, пока существует временная, однако к ней можно обратиться, дополнив имя указанием
схемы. Все индексы, создаваемые для временной таблицы, так же автоматически становятся
временными.
Демон автоочистки не может прочитать и, как следствие, сжимать и анализировать временные
таблицы. По этой причине соответствующие операции очистки и анализа следует выполнять,
вызывая SQL-команды в рамках сеанса. Например, если временную таблицу планируется ис-
пользовать в сложных запросах, будет разумным выполнить для неё ANALYZE после того, как
она будет наполнена.
По желанию можно добавить указание GLOBAL или LOCAL перед TEMPORARY или TEMP. В настоящее
время это не имеет значения для PostgreSQL и считается устаревшей возможностью; см. Раздел
«Совместимость».
UNLOGGED
С этим указанием таблица создаётся как нежурналируемая. Данные, записываемые в нежур-
налируемые таблицы, не проходят через журнал предзаписи (см. Главу 30), в результате че-
го такие таблицы работают гораздо быстрее обычных. Однако, они не защищены от сбоя; при
сбое или аварийном отключении сервера нежурналируемая таблица автоматически усекает-
ся. Кроме того, содержимое нежурналируемой таблицы не реплицируется на ведомые серве-
ры. Любые индексы, создаваемые для нежурналируемой таблицы, автоматически становятся
нежурналируемыми.
IF NOT EXISTS
Не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет
выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то
соотносится с тем, которое могло бы быть создано.
имя_таблицы
Имя создаваемой таблицы (возможно, дополненное схемой).
OF имя_типа
Создаёт типизированную таблицу, структура которой определяется указанным составным ти-
пом (его имя может быть дополнено схемой). Типизированная таблица привязана к породив-
шему её типу; например, при удалении типа (командой DROP TYPE … CASCADE) будет удалена
и эта таблица.
1518CREATE TABLE
Когда создаётся типизированная таблица, типы данных её столбцов определяются нижележа-
щим составным типом, а не задаются командой CREATE TABLE. Но CREATE TABLE может добавить
в таблицу значения по умолчанию и ограничения, а также задать параметры её хранения.
имя_столбца
Имя столбца, создаваемого в новой таблице.
тип_данных
Тип данных столбца (может включать определение массива с этим типом). За дополнительными
сведениями о типах данных, которые поддерживает PostgreSQL, обратитесь к Главе 8.
COLLATE правило_сортировки
Предложение COLLATE назначает правило сортировки для столбца (который должен иметь тип,
поддерживающий сортировку). Если оно отсутствует, используется правило сортировки по
умолчанию, установленное для типа данных столбца.
INHERITS ( таблица_родитель [, … ] )
Необязательное предложение INHERITS определяет список таблиц, от которых новая таблица
будет автоматически наследовать все столбцы. Родительские таблицы могут быть обычными
или сторонними таблицами.
При использовании INHERITS создаётся постоянная связь дочерней таблицы с родительскими.
Изменения схемы в родительских таблицах обычно также отражаются в дочерних, и по умол-
чанию при чтении родительских таблиц в результат включаются данные дочерней таблицы.
Когда в нескольких родительских таблицах оказываются столбцы с одним именем, происходит
ошибка, за исключением случая, когда типы данных всех этих столбцов в таблицах совпадают.
В этом случае одноимённые столбцы объединяются и формируют один столбец в новой табли-
це. Если имя столбца новой таблицы совпадает с именем одного из унаследованных столбцов,
их типы так же должны совпадать, и в этом случае определения столбцов тоже сливаются в
одну. Если в новой таблице явно указывается значение по умолчанию для нового столбца, это
значение переопределяет любые значения по умолчанию, унаследованные этим столбцом. В
противном случае, если значения по умолчанию определяются в разных родительских табли-
цах, эти определения должны совпадать, иначе произойдёт ошибка.
Ограничения CHECK объединяются вместе по сути так же, как и столбцы: если несколько роди-
тельских таблиц и/или определение новой таблицы содержат одноимённые ограничения CHECK,
этим ограничениям должны соответствовать одинаковые выражения проверки, в противном
случае произойдёт ошибка. В случае совпадения выражения, эти ограничения с данным выра-
жением объединяются в одно. При этом ограничения со свойством NO INHERIT в родительской
таблице исключаются из рассмотрения. Заметьте, что безымянное ограничение CHECK в новой
таблице никогда не сливается с другими, так как для него всегда выбирается уникальное имя.
Параметры STORAGE для столбца так же копируются из родительских таблиц.
Если столбец в родительской таблице является столбцом идентификации, это свойство не на-
следуется. Если требуется, в дочерней таблице этот столбец можно объявить столбцом иден-
тификации.
PARTITION BY ( RANGE | LIST | HASH ) ( ( имя_столбца | ( выражение ) ) [ класс_операторов
] [, …] )
Необязательное предложение PARTITION BY задаёт стратегию секционирования таблицы. Таб-
лица, созданная с этим указанием, называется секционируемой таблицей. Задаваемый в скоб-
ках список столбцов или выражений формирует ключ разбиения таблицы. Для разбиения по
диапазонам или по хешу ключ разбиения может включать несколько столбцов или выражений
(до 32, но этот предел можно изменить при сборке PostgreSQL), но для разбиения по спискам
ключ должен состоять из одного столбца или выражения.
1519CREATE TABLE
Для секционирования по диапазонам и по спискам нужен класс операторов B-дерева, тогда как
для секционирования по хешу требуется класс операторов хеширования. Если класс операто-
ров не задан явно, будет применён класс операторов по умолчанию для соответствующего ти-
па; в случае отсутствия такого класса выдаётся ошибка. Для секционирования по хешу приме-
няемый класс операторов должен реализовывать опорную функцию 2 (см. Подраздел 38.15.3).
Секционируемая таблица разделяется на подтаблицы (называемые секциями), которые созда-
ются отдельными командами CREATE TABLE. Сама по себе секционируемая таблица не содержит
данных. Строка данных, вставляемая в эту таблицу, перенаправляется в секцию в зависимости
от значений столбцов или выражений в ключе разбиения. Если значениям в новой строке не
соответствует ни одна из существующих секций, возникает ошибка.
Секционируемые таблицы не поддерживают ограничения EXCLUDE; однако вы можете опреде-
лить такие ограничения в отдельных секциях. Кроме того, в настоящее время не поддержива-
ется создание внешних ключей, ссылающихся на секционированные таблицы, хотя в секцио-
нированных таблицах можно создать ограничения PRIMARY KEY.
Узнать больше о секционировании таблиц можно в Разделе 5.10.
PARTITION OF таблица_родитель ( FOR VALUES указание_границ_секции | DEFAULT )
Создаёт таблицу в виде секции указанной родительской таблицы. Таблицу можно создать либо
как секцию для определённых значений (используя FOR VALUES), либо как секцию по умолча-
нию (используя DEFAULT). Это указание неприемлемо для таблиц, секционируемых по хешу.
Здесь указание_границ_секции должно соответствовать методу и ключу секционирования ро-
дительской таблицы и не должно конфликтовать с другой существующей секцией того же ро-
дителя. Вариант указания с IN используется для секционирования по спискам, тогда как вари-
ант с FROM и TO для секционирования по диапазонам, а с WITH — для секционирования по хешу.
В качестве значений, задаваемых в указании_границ_секции, принимается буквальное значе-
ние, NULL и MINVALUE или MAXVALUE. Буквальным значением должна быть либо числовая кон-
станта, приводимая к типу соответствующего столбца ключа разбиения, либо строковая кон-
станта, представляющая допустимое входное значение для этого типа.
При создании секции с разбиением по спискам возможно указать, что столбец ключа разби-
ения может содержать NULL, включив в список секции NULL. Однако у отдельно взятой роди-
тельской таблицы может быть не больше одной такой секции. Для диапазонных секций NULL
задать нельзя.
При создании диапазонной секции нижняя граница, задаваемая во FROM, включается в диапа-
зон, а верхняя граница, задаваемая в TO — исключается. То есть, значения, задаваемые в спис-
ке FROM, являются допустимыми значениями соответствующих столбцов ключа разбиения для
этой секции, а значения в списке TO — нет. Заметьте, что это утверждение должно восприни-
маться с учётом правил сравнения строк таблицы (см. Подраздел 9.23.5). Например, с разбие-
нием PARTITION BY RANGE (x,y), секция с границами FROM (1, 2) TO (3, 4) примет x=1 с
любым значением y&gt;=2, x=2 с любым y, отличным от NULL, и x=3 с любым y&lt;4.
Специальные значения MINVALUE и MAXVALUE могут использоваться при создании диапазонной
секции для указания, что нижняя или верхняя граница для значений столбца отсутствует. На-
пример, секция, определённая с указанием FROM (MINVALUE) TO (10), будет принимать любые
значения меньше 10, а секция, определённая с указанием FROM (10) TO (MAXVALUE), — любые
значения, которые больше или равны 10.
При создании диапазонной секции с более чем одним столбцом может также иметь смысл ис-
пользовать MAXVALUE в определении нижней границы, а MINVALUE — верхней. Например, секция,
определённая с указанием FROM (0, MAXVALUE) TO (10, MAXVALUE), будет принимать любые
строки, в которых первый столбец ключа разбиения больше 0 и меньше или равен 10. Подоб-
ным образом, секция, определённая с указанием FROM (‘a’, MINVALUE) TO (‘b’, MINVALUE),
будет принимать строки, в которых первый столбец ключа разбиения начинается с “a”.
1520CREATE TABLE
Заметьте, что если для одного столбца в границе секции задаётся MINVALUE или MAXVALUE, то
же значение должно применяться и для всех последующих столбцов. Например, граница (10,
MINVALUE, 0) будет некорректной; допустимая граница: (10, MINVALUE, MINVALUE).
Также заметьте, что для некоторых типов элементов, таких как timestamp, наряду с други-
ми значениями допускается значение “infinity” (бесконечность). Оно отличается от вариан-
тов MINVALUE и MAXVALUE, которые на самом деле не обозначают значения, которые можно
сохранить, а просто говорят о том, это значение не ограничено. MAXVALUE можно восприни-
мать как значение, которое больше любого другого, включая “бесконечность”, а MINVALUE мень-
ше любого другого значения, включая “минус бесконечность”. Таким образом, диапазон FROM
(‘infinity’) TO (MAXVALUE) не будет пустым, а будет принимать ровно одно значение —
“infinity”.
С указанием DEFAULT таблица присоединяется к родительской таблице как секция по умолча-
нию. Родительской таблицей может быть таблица, разбиваемая по спискам или диапазонам.
Ключ разбиения, не попадающий ни в одну другую секцию данного родителя, будет отправлен
в секцию по умолчанию. У отдельно взятой родительской таблицы может быть только одна сек-
ция по умолчанию.
Когда у таблицы есть секция по умолчанию (DEFAULT) и к ней добавляется новая секция, тре-
буется просканировать существующую секцию по умолчанию и убедиться в том, что она не со-
держит строки, которые должны относиться к новой секции. Если она содержит большое коли-
чество строк, это сканирование может быть длительным. Сканирование не будет выполняться,
если секция по умолчанию является сторонней таблицей или в ней есть ограничение, гаранти-
рующее отсутствие в этой секции строк, подлежащих перемещению в новую секцию.
При создании секции с разбиением по хешу должен задаваться модуль и остаток. Модулем
должно быть положительное число, а остатком неотрицательное число, меньшее модуля. Обыч-
но при начальной настройке таблицы с секционированием по хешу нужно выбрать модуль, рав-
ный количеству секций, и назначить каждой секции этот модуль и разные остатки (см. при-
меры ниже). Однако секциям можно назначить и разные модули, с условием, что модули, на-
значенные секциям таблицы, разбиваемой по хешу, являются делителями следующих больших
модулей. Это позволяет постепенно увеличивать число секций, не производя полное переме-
щение всех данных. Например, предположим, что у вас есть таблица, разбиваемая по хешу на 8
секций, для каждой из которых назначен модуль 8, и возникла необходимость увеличить число
секций до 16. Вы можете отсоединить одну из секций по модулю 8, создать две новые секции по
модулю 16, покрывающих ту же часть пространства ключа (одну с остатком, равным остатку
отсоединённой секции, а вторую с остатком, равным тому же остатку плюс 8), и вновь напол-
нить их данными. Затем вы можете повторять эту операцию (возможно, позже) для следующих
секций по модулю 8, пока таковых не останется. Хотя и при таком подходе может потребовать-
ся перемещать большие объёмы данных на каждом этапе, это всё же лучше, чем создавать аб-
солютно новую таблицу и перемещать все данные сразу.
В секции должны содержаться столбцы с теми же именами и типами, что и в секционированной
таблице, к которой она относится. Если родитель имеет характеристику WITH OIDS, все секции
должны иметь OID; родительский столбец OID будет наследоваться всеми секциями, как и лю-
бой другой столбец. Изменение имён или типов столбцов в секционируемой таблице, или добав-
ление или удаление столбца OID будет автоматически распространяться во все секции. Огра-
ничения CHECK будут наследоваться автоматически всеми секциями, но для отдельных секций
могут быть заданы дополнительные ограничения CHECK; дополнительные ограничения с теми
же именами и условиями, как в родительской таблицы, будут объединены с родительским огра-
ничением. Также независимо для каждой секции могут быть заданы значения по умолчанию.
Строки, добавляемые в секционированную таблицу, будут автоматически перенаправляться в
соответствующую секцию. Если подходящей секции не найдётся, произойдёт ошибка.
Такие операции, как TRUNCATE, обычно затрагивают и саму таблицу, и каскадно распростра-
няются на все дочерние секции, но могут также выполняться в отдельных секциях. Заметь-
1521CREATE TABLE
те, что для удаления секции с помощью DROP TABLE требуется установить блокировку ACCESS
EXCLUSIVE в родительской таблице.
LIKE исходная_таблица [ вариант_копирования … ]
Предложение LIKE определяет таблицу, из которой в новую таблицу будут автоматически ско-
пированы все имена столбцов, их типы данных и их ограничения на NULL.
В отличие от INHERITS, новая и исходная таблица становятся полностью независимыми после
завершения создания. Изменения в исходной таблице не отражаются в новой, а данные новой
таблицы не включаются в результат чтения исходной.
Выражения значений по умолчанию в определениях копируемых столбцов переносятся в но-
вую таблицу, только если дополнительно указано INCLUDING DEFAULTS. Без этого указания вы-
ражения по умолчанию не копируются, вследствие чего в новой таблице скопированные столб-
цы получают значения по умолчанию NULL. Заметьте, что при копировании выражений по
умолчанию, которые вызывают функции, модифицирующие БД, как например nextval, может
образовываться функциональная связь исходной таблицы с новой.
Характеристика идентификации в определении скопированного столбца будет копироваться,
только если в команде есть указание INCLUDING IDENTITY. Для каждого столбца идентификации
в новой таблице создаётся новая последовательность, независящая от последовательностей,
связанных со старой таблицей.
Ограничения NULL копируются в новую таблицу всегда, а ограничения CHECK копируются толь-
ко при явном указании INCLUDING CONSTRAINTS. Это в равной мере касается ограничений как
таблиц, так и столбцов.
Расширенная статистика копируется в новую таблицу, если указано INCLUDING STATISTICS.
Индексы, свойство PRIMARY KEY, а также ограничения UNIQUE и EXCLUDE копируются из исходной
таблицы в новую, только если явно указано INCLUDING INDEXES. Имена для новых индексов и
ограничений выбираются согласно стандартным правилам, независимо от того, как назывались
исходные. (Это позволяет избежать ошибок с дублированием имён с новыми индексами.)
Параметры STORAGE будут перенесены в определение копируемых столбцов, только если явно
указывается INCLUDING STORAGE. По умолчанию параметры STORAGE исключаются, вследствие
чего скопированные столбцы в новой таблице получают параметры по умолчанию, определён-
ные соответствующим типом. Подробнее параметры STORAGE описаны в Разделе 68.2.
Комментарии для скопированных столбцов, ограничений и индексов будут копироваться, толь-
ко если явно указано INCLUDING COMMENTS. По умолчанию комментарии исключаются, вслед-
ствие чего скопированные столбцы и ограничения в новой таблице оказываются без коммен-
тариев.
INCLUDING
ALL представляет собой краткую форму предложения INCLUDING
COMMENTS
INCLUDING CONSTRAINTS INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING INDEXES
INCLUDING STATISTICS INCLUDING STORAGE.
Заметьте, что в отличие от INHERITS, столбцы и ограничения, копируемые командой LIKE, не
объединяются с одноимёнными столбцами и ограничениями. Если дублирующееся имя указы-
вается явно или возникает в другом предложении LIKE, происходит ошибка.
Предложение LIKE может также применяться для копирования определений столбцов из
представлений, сторонних таблиц и составных типов. Неприменимые параметры (например,
INCLUDING INDEXES для представления) при этом игнорируются.
CONSTRAINT имя_ограничения
Необязательное имя столбца или ограничения таблицы. При нарушении ограничения его имя
будет выводиться в сообщении об ошибках, так что имена ограничений вида столбец должен
1522CREATE TABLE
быть положительным могут сообщить полезную информацию об ограничении клиентскому при-
ложению. (Имена ограничений, включающие пробелы, необходимо заключать в двойные ка-
вычки.) Если имя ограничения не указано, система генерирует имя автоматически.
NOT NULL
Данный столбец не принимает значения NULL.
NULL
Данный столбец может содержать значения NULL (по умолчанию).
Это предложение предназначено только для совместимости с нестандартными базами данных
SQL. Использовать его в новых приложениях не рекомендуется.
CHECK ( выражение ) [ NO INHERIT ]
В ограничении CHECK задаётся выражение, возвращающее булевский результат, по которому
определяется, будет ли успешна операция добавления или изменения для конкретных строк.
Операция выполняется успешно, если результат выражения равен TRUE или UNKNOWN. Если
же для какой-нибудь строки, задействованной в операции добавления или изменения, будет
получен результат FALSE, возникает ошибка, и эта операция не меняет ничего в базе данных.
Ограничение-проверка, заданное как ограничение столбца, должно ссылаться только на значе-
ние самого столбца, тогда как ограничение на уровне таблицы может ссылаться и на несколько
столбцов.
В настоящее время выражения CHECK не могут содержать подзапросы или ссылаться на пере-
менные, кроме как на столбцы текущей строки. Также допустима ссылка на системный столбец
tableoid, но не на другие системные столбцы.
Ограничение с пометкой NO INHERIT не будет наследоваться дочерними таблицами.
Когда для таблицы задано несколько ограничений CHECK, они будут проверяться для каждой
строки в алфавитном порядке имён после проверки ограничений NOT NULL. (До версии 9.5
в PostgreSQL не было установлено никакого определённого порядка обработки ограничений
CHECK.)
DEFAULT выражение_по_умолчанию
Предложение DEFAULT задаёт значение по умолчанию для столбца, в определении которого оно
присутствует. Значение задаётся выражением без переменных (подзапросы и перекрёстные
ссылки на другие столбцы текущей таблицы в нём не допускаются). Тип данных выражения,
задающего значение по умолчанию, должен соответствовать типу данных столбца.
Это выражение будет использоваться во всех операциях добавления данных, в которых не за-
даётся значение данного столбца. Если значение по умолчанию не определено, таким значе-
нием будет NULL.
GENERATED ( ALWAYS | BY DEFAULT ) AS IDENTITY [ ( параметры_последовательности ) ]
С этим предложением столбец создаётся как столбец идентификации. С ним будет связана
неявная последовательность, из которой этот столбец будет автоматически получать значения
в новых строках.
Предложения ALWAYS и BY DEFAULT определяют, какой приоритет имеет заданное пользовате-
лем значение этого столбца в команде INSERT. С предложением ALWAYS пользовательское зна-
чение используется, только если в операторе INSERT указано OVERRIDING SYSTEM VALUE. С пред-
ложением BY DEFAULT пользовательскому значению отдаётся предпочтение. За подробностями
обратитесь к INSERT. (В команде COPY всегда используются пользовательские значения, вне
зависимости от значения этого параметра.)
Используя необязательное предложение параметры_последовательности, можно переопреде-
лить свойства последовательности. За подробностями обратитесь к CREATE SEQUENCE.
1523CREATE TABLE
UNIQUE (ограничение столбца)
UNIQUE ( имя_столбца [, … ] ) [ INCLUDE ( имя_столбца [, …]) ] (ограничение таблицы)
Ограничение UNIQUE определяет, что группа из одного или нескольких столбцов таблицы может
содержать только уникальные значения. Ограничение уникальности для таблицы ведёт себя
точно так же, как ограничение для столбца, но может охватывать несколько столбцов.
При проверке ограничения уникальности значения NULL не считаются равными.
В каждом ограничении уникальности для таблицы должен задаваться набор столбцов, отлич-
ный от набора любого другого ограничения уникальности или первичного ключа в данной таб-
лице. (Иначе это будет одно и то же ограничение, определённое многократно.)
При установлении ограничения уникальности в многоуровневой иерархии секционирования в
определение ограничения должны включаться все столбцы ключа разбиения целевой секцио-
нированной таблицы, а также столбцы всех подчинённых секционированных таблиц.
При добавлении ограничения уникальности автоматически будет создан уникальный индекс-B-
дерево по столбцу или группе столбцов, перечисленных в ограничении. Необязательное пред-
ложение INCLUDE добавляет к этому индексу один или несколько столбцов, для которых уни-
кальность не будет требоваться. Заметьте, что хотя ограничение по включаемым столбцам не
контролируется, оно всё же зависит от них. Как следствие, некоторые операции с этими столб-
цами (например, DROP COLUMN) могут повлечь каскадное удаление индекса и ограничения.
PRIMARY KEY (ограничение столбца)
PRIMARY KEY ( имя_столбца [, … ] ) [ INCLUDE ( имя_столбца [, …]) ] (ограничение таблицы)
Ограничение PRIMARY KEY определяет, что столбец или столбцы таблицы могут содержать толь-
ко уникальные (без повторений) значения, отличные от NULL. Для таблицы может быть задан
только один первичный ключ, будь то ограничение столбца или ограничение таблицы.
В определении первичного ключа должен задаваться набор столбцов, отличный от набора лю-
бого другого ограничения уникальности, установленного для данной таблицы. (В противном
случае уникальное ограничение оказывается избыточным и будет отброшено.)
PRIMARY KEY устанавливает для данных те же ограничения, что и сочетание UNIQUE и NOT NULL,
но образование первичного ключа из набора столбцов также добавляет метаданные о конструк-
ции схемы, так как первичный ключ подразумевает, что другие таблицы могут ссылаться на
этот набор столбцов, как на уникальный идентификатор строк.
Ограничения PRIMARY KEY для секционированных таблиц подчиняются тем же требованиям,
что и ограничения UNIQUE.
При добавлении ограничения первичного ключа (PRIMARY KEY) автоматически будет создан
уникальный индекс-B-дерево по столбцу или группе столбцов, перечисленных в ограничении.
Необязательное предложение INCLUDE позволяет задать список столбцов, которые будут вклю-
чены в неключевую часть индекса. Хотя уникальность по включаемым столбцам не контроли-
руется, ограничение всё же зависит от них. Как следствие, некоторые операции с этими столб-
цами (например, DROP COLUMN) могут повлечь каскадное удаление индекса и ограничения.
EXCLUDE [ USING метод_индекса ] ( элемент_исключения WITH оператор [, … ] ) парамет-
ры_индекса [ WHERE ( предикат ) ]
Предложение EXCLUDE определяет ограничение-исключение, которое гарантирует, что для лю-
бых двух строк, сравниваемых по указанным столбцам или выражениям с указанными операто-
рами, результат не будет равен TRUE для всех сравнений. Если все указанные операторы прове-
ряют равенство, это ограничение равносильно ограничению UNIQUE, хотя обычное ограничение
уникальности будет работать быстрее. С другой стороны, в ограничениях-исключениях можно
задавать более общие условия, чем простое условие на равенство. Например, можно задать
ограничение, требующее, чтобы никакие две строки в таблице не содержали пересекающихся
кругов (см. Раздел 8.8), применив оператор &amp;&amp;.
1524CREATE TABLE
Ограничения-исключения реализуются с помощью индексов, так что каждый указанный в них
оператор должен быть связан с соответствующим классом операторов (см. Раздел 11.9) для ме-
тода_индекса. Кроме того, операторы должны быть коммутативными. В каждом элементе_ис-
ключения можно дополнительно указать класс оператора и/или параметры сортировки, подроб-
но описанные в CREATE INDEX.
Метод индекса должен поддерживать amgettuple (см. Главу 61); в настоящее время это озна-
чает, что метод GIN здесь применять нельзя. Хотя в ограничении-исключении можно исполь-
зовать B-деревья и хеш-индексы, в этом мало смысла, так как такой подход ничем не лучше
обычного ограничения уникальности. Так что на практике методом индекса всегда будет GiST
или SP-GiST.
Параметр предикат позволяет указать ограничение-исключение для подмножества таблицы;
внутри при этом создаётся частичный индекс. Заметьте, что предикат необходимо заключить
в скобки.
REFERENCES внешняя_таблица [ ( внешний_столбец ) ] [ MATCH тип_совпадения ] [ ON DELETE
действие ] [ ON UPDATE действие ] (ограничение столбца)
FOREIGN KEY ( имя_столбца [, … ] ) REFERENCES внешняя_таблица [ ( внешний_столбец
[, … ] ) ] [ MATCH тип_совпадения ] [ ON DELETE действие ] [ ON UPDATE действие ]
(ограничение таблицы)
Эти предложения определяют ограничение внешнего ключа, требующее, чтобы группа из од-
ного или нескольких столбцов новой таблицы содержала только такие значения, которым со-
ответствуют значения в заданных столбцах некоторой строки во внешней таблице. Если спи-
сок целевых_столбцов опущен, в качестве него используется первичный ключ целевой_табли-
цы. В качестве целевых столбцов должны указываться столбцы неоткладываемого уникального
ограничения или первичного ключа во внешней таблице. При этом пользователь должен иметь
право REFERENCES во внешней таблице (либо для всей таблицы, либо только для целевых столб-
цов). Для добавления ограничения внешнего ключа требуется блокировка SHARE ROW EXCLUSIVE
в целевой таблице. Заметьте, что нельзя определить ограничения внешнего ключа, связываю-
щие временные и постоянные таблицы. Также заметьте, что нельзя определить внешний ключ,
который будет ссылаться на секционированную таблицу, хотя определить внешний ключ в сек-
ционированной таблице можно.
Значения, вставляемые в ссылающиеся столбцы, сверяются со значениями во внешних столб-
цах внешней таблицы с учётом заданного типа совпадения. Возможны три типа совпадения:
MATCH FULL (полное совпадение), MATCH PARTIAL (частичное совпадение) и тип по умолчанию,
MATCH SIMPLE (простое совпадение). С MATCH FULL ни один из столбцов составного внешнего
ключа не может содержать NULL, кроме случая, когда все внешние столбцы NULL; в этом слу-
чае, строка может не иметь соответствия во внешней таблице. С MATCH SIMPLE любой из столб-
цов внешнего ключа может содержать NULL; при этом строка с NULL в одном из таких столб-
цов может не иметь соответствия во внешней таблице. Тип MATCH PARTIAL ещё не реализован.
(Разумеется, чтобы вопросы со сравнением NULL не возникали, к столбцам, ссылающимся на
внешние, можно применить ограничения NOT NULL.)
Кроме того, при изменении значений во внешних столбцах с данными в столбцах этой таблицы
могут производиться определённые действия. Предложение ON DELETE задаёт действие, про-
изводимое при удалении некоторой строки во внешней таблице. Предложение ON UPDATE по-
добным образом задаёт действие, производимое при изменении значения в целевых столбцах
внешней таблицы. Если строка изменена, но это изменение не затронуло целевые столбцы, ни-
какое действие не производится. Ссылочные действия, кроме NO ACTION, нельзя сделать откла-
дываемыми, даже если ограничение объявлено как откладываемое. Для каждого предложения
возможные следующие варианты действий:
NO ACTION
Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нару-
шение ограничения внешнего ключа. Для отложенных ограничений ошибка произойдёт в
1525CREATE TABLE
момент проверки ограничения, если строки, ссылающиеся на эту запись, по-прежнему бу-
дут существовать. Этот вариант действия подразумевается по умолчанию.
RESTRICT
Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт на-
рушение ограничения внешнего ключа. Этот вариант подобен NO ACTION, но эта проверка
будет неоткладываемой.
CASCADE
Удалить все строки, ссылающиеся на удаляемую запись, либо поменять значения в ссыла-
ющихся столбцах на новые значения во внешних столбцах, в соответствии с операцией.
SET NULL
Установить ссылающиеся столбцы равными NULL.
SET DEFAULT
Установить в ссылающихся столбцах значения по умолчанию. (Если эти значения не рав-
ны NULL, во внешней таблице должна быть строка, соответствующая набору значений по
умолчанию; в противном случае операция завершится ошибкой.)
Если внешние столбцы меняются часто, будет разумным добавить индекс для ссылающихся
столбцов, чтобы действия по обеспечению ссылочной целостности, связанные с ограничением
внешнего ключа, выполнялись более эффективно.
DEFERRABLE
NOT DEFERRABLE
Это предложение определяет, может ли ограничение быть отложенным. Неоткладываемое
ограничение будет проверяться немедленно после каждой команды. Проверка откладывае-
мых ограничений может быть отложена до завершения транзакции (обычно с помощью коман-
ды SET CONSTRAINTS). По умолчанию подразумевается вариант NOT DEFERRABLE. В настоя-
щее время это предложение принимают только ограничения UNIQUE, PRIMARY KEY, EXCLUDE и
REFERENCES (внешний ключ). Ограничения NOT NULL и CHECK не могут быть отложенными. За-
метьте, что откладываемые ограничения не могут применяться в качестве решающих при кон-
фликте в операторе INSERT с предложением ON CONFLICT DO UPDATE.
INITIALLY IMMEDIATE
INITIALLY DEFERRED
Для откладываемых ограничений это предложение определяет, когда ограничение должно
проверяться по умолчанию. Ограничение с характеристикой INITIALLY IMMEDIATE (подра-
зумеваемой по умолчанию) проверяется после каждого оператора. Ограничение INITIALLY
DEFERRED, напротив, проверяется только в конце транзакции. Время проверки ограничения
можно изменить явно с помощью команды SET CONSTRAINTS.
WITH ( параметр_хранения [= значение] [, … ] )
Это предложение определяет необязательные параметры хранения для таблицы или индекса
(за подробными сведениями о них обратитесь к Подразделу «Параметры хранения»). Предло-
жение WITH для таблицы может также включать указание OIDS=TRUE (или просто OIDS), уста-
навливающее, что каждая строка таблицы должна иметь собственный OID (Object IDentifier,
идентификатор объекта), или указание OIDS=FALSE, устанавливающее, что строки не содержат
OID. Если указание OIDS отсутствует, значение этого свойства по умолчанию зависит от кон-
фигурационного параметра default_with_oids. (Если новая таблица унаследована от каких-либо
таблиц, имеющих OID, свойство OIDS=TRUE задаётся принудительно, даже если в команде явно
написано OIDS=FALSE.)
Если явно указано OIDS=FALSE или это подразумевается, в новой таблице не будут храниться
значения OID и новый OID не будет генерироваться для каждой добавляемой в неё строки. Для
1526CREATE TABLE
обычных таблиц такое поведение предпочтительнее, так как оно сокращает потребление OID и
тем самым откладывает зацикливание 32-битного счётчика OID. Как только происходит зацик-
ливание, значения OID больше нельзя считать уникальными, что делает их значительно менее
полезными. К тому же, исключение столбца OID из таблицы сокращает объём, необходимый
для хранения таблицы на диске, на 4 байта для каждой строки (на большинстве платформ), что
несколько улучшает производительность.
Для удаления данных OID из таблицы после её создания воспользуйтесь командой ALTER
TABLE.
WITH OIDS
WITHOUT OIDS
Это устаревшее написание указаний WITH (OIDS) и WITH (OIDS=FALSE), соответственно. Если
требуется определить одновременно свойство OIDS и параметры хранения, необходимо исполь-
зовать синтаксис WITH ( … ); см. ниже.
ON COMMIT
Поведением временных таблиц в конце блока транзакции позволяет управлять предложение
ON COMMIT, которое принимает три параметра:
PRESERVE ROWS
Никакое специальное действие в конце транзакции не выполняется. Это поведение по умол-
чанию.
DELETE ROWS
Все строки в этой временной таблице будут удаляться в конце каждого блока транзакции.
По сути, при каждой фиксации транзакции будет автоматически выполняться TRUNCATE.
DROP
Эта временная таблица будет удаляться в конце текущего блока транзакции.
TABLESPACE табл_пространство
Здесь табл_пространство — имя табличного пространства, в котором будет создаваться новая
таблица. Если оно не указано, выбирается default_tablespace или temp_tablespaces, если табли-
ца временная.
USING INDEX TABLESPACE табл_пространство
Это предложение позволяет выбрать табличное пространство, в котором будут создаваться ин-
дексы, связанные с ограничениями UNIQUE, PRIMARY KEY или EXCLUDE. Если оно не указано, вы-
бирается default_tablespace или temp_tablespaces, если таблица временная.
Параметры хранения
Предложение WITH позволяет установить параметры хранения для таблиц и индексов, связанных
с ограничениями UNIQUE, PRIMARY KEY и EXCLUDE. Параметры хранения для индексов документи-
рованы в CREATE INDEX. Поддерживаемые в настоящее время параметры хранения для таблиц
перечислены ниже. Как показано, для многих параметров существует дополнительный параметр
с тем же именем и префиксом toast., который управляет поведением вторичной таблицы TOAST,
если она есть (за дополнительными сведениями о TOAST обратитесь к Разделу 68.2). Если значе-
ние некоторого параметра задано для таблицы, а значение равнозначного параметра toast. не
определено, для таблицы TOAST будет применяться значение параметра основной таблицы. Воз-
можность задания этих параметров для секционированных таблиц не поддерживается, но вы мо-
жете задать их для отдельных конечных секций.
fillfactor (integer)
Фактор заполнения для таблицы, задаваемый в процентах, от 10 до 100. Значение по умолча-
нию — 100 (плотное заполнение). При меньшем факторе заполнения операции INSERT упако-
1527CREATE TABLE
вывают данные в страницы только до заданного процента; оставшееся место резервируется для
изменения строк на этой странице. В результате UPDATE получает шанс поместить изменённую
копию строки в ту же страницу, что и исходную, что гораздо эффективнее, чем размещать её
на другой странице. Для таблиц, записи в которых никогда не меняются, лучшим выбором бу-
дет плотное заполнение, но для активно изменяемых таблиц лучше выбрать меньший фактор
заполнения. Этот параметр нельзя задать для таблиц TOAST.
toast_tuple_target (integer)
Параметр toast_tuple_target задаёт минимальную длину кортежа, после превышения которой
мы будем пытаться переносить значения больших столбцов в таблицы TOAST и до которой мы
будем пытаться сократить размер кортежа после перехода к TOAST. Это затрагивает только
столбцы с пометкой External (внешние) или Extended (расширенные) и касается только новых
кортежей — на существующие это не влияет. По умолчанию этот параметр имеет значение,
позволяющее разместить минимум 4 кортежа в блоке, что при стандартном размере блока со-
ставляет 2040 байт. Допустимые значения лежат в интервале от 128 байт до (размер_блока -
заголовок), по умолчанию 8160 байт. Изменение этого значения может не отражаться на очень
коротких и очень длинных кортежах. Заметьте, что выбранное по умолчанию значение часто
близко к оптимальному, и весьма вероятно, что изменение этого параметра в некоторых слу-
чаях будет иметь отрицательный эффект. Для таблиц TOAST этот параметр задать нельзя.
parallel_workers (integer)
Данный параметр задаёт число рабочих процессов, которые должны задействоваться при па-
раллельном сканировании таблицы. Если это значение не задано, система будет определять
его, исходя из размера отношения. Фактическое число рабочих процессов, выбранное плани-
ровщиком или служебными операторами, выполняющими параллельное сканирование, может
быть меньше, например, вследствие ограничения max_worker_processes.
autovacuum_enabled, toast.autovacuum_enabled (boolean)
Включает или отключает демон автоочистки для определённой таблицы. Со значением true
демон автоочистки будет автоматически выполнять операции VACUUM и/или ANALYZE в этой таб-
лице, согласно правилам, описанным в Подразделе 24.1.6. Со значением false эта таблица не
будет подвергаться автоочистке, если только это не потребуется для предотвращения зацик-
ливания идентификаторов транзакций. Более подробно предотвращение зацикливания описы-
вается в Подразделе 24.1.5. Заметьте, что демон автоочистки не будет запускаться вовсе (ес-
ли только это не потребуется для предотвращения зацикливания), если параметр autovacuum
имеет значение false; это нельзя переопределить, установив параметры хранения для отдель-
ных таблиц. Таким образом, явно устанавливать для этого параметра значение true практиче-
ски не имеет смысла — полезно только значение false.
autovacuum_vacuum_threshold, toast.autovacuum_vacuum_threshold (integer)
Значение параметра autovacuum_vacuum_threshold для таблицы.
autovacuum_vacuum_scale_factor, toast.autovacuum_vacuum_scale_factor (float4)
Значение параметра autovacuum_vacuum_scale_factor для таблицы.
autovacuum_analyze_threshold (integer)
Значение параметра autovacuum_analyze_threshold для таблицы.
autovacuum_analyze_scale_factor (float4)
Значение параметра autovacuum_analyze_scale_factor для таблицы.
autovacuum_vacuum_cost_delay, toast.autovacuum_vacuum_cost_delay (integer)
Значение параметра autovacuum_vacuum_cost_delay для таблицы.
autovacuum_vacuum_cost_limit, toast.autovacuum_vacuum_cost_limit (integer)
Значение параметра autovacuum_vacuum_cost_limit для таблицы.
1528CREATE TABLE
autovacuum_freeze_min_age, toast.autovacuum_freeze_min_age (integer)
Значение параметра vacuum_freeze_min_age для таблицы. Учтите, что система будет игнориро-
вать установленные для таблиц значения autovacuum_freeze_min_age, превышающие полови-
ну системного autovacuum_freeze_max_age.
autovacuum_freeze_max_age, toast.autovacuum_freeze_max_age (integer)
Значение параметра autovacuum_freeze_max_age для таблицы. Учтите, что система будет игно-
рировать установленные для таблиц значения autovacuum_freeze_max_age, превышающие зна-
чение системного параметра (они могут быть только меньше).
autovacuum_freeze_table_age, toast.autovacuum_freeze_table_age (integer)
Значение параметра vacuum_freeze_table_age для таблицы.
autovacuum_multixact_freeze_min_age, toast.autovacuum_multixact_freeze_min_age (integer)
Значение
параметра
vacuum_multixact_freeze_min_age
для
таблицы.
Учтите,
что
демон
автоочистки
будет
игнорировать
установленные
для
таблиц
значения
autovacuum_multixact_freeze_min_age, превышающие половину значения системного пара-
метра autovacuum_multixact_freeze_max_age.
autovacuum_multixact_freeze_max_age, toast.autovacuum_multixact_freeze_max_age (integer)
Значение параметра autovacuum_multixact_freeze_max_age для таблицы. Учтите, что
система автоочистки будет игнорировать установленные для таблиц параметры
autovacuum_multixact_freeze_max_age, превышающие системный параметр (они могут быть
только меньше).
autovacuum_multixact_freeze_table_age,
(integer)
toast.autovacuum_multixact_freeze_table_age
Значения параметра vacuum_multixact_freeze_table_age для таблицы.
log_autovacuum_min_duration, toast.log_autovacuum_min_duration (integer)
Значения параметра log_autovacuum_min_duration для таблицы.
user_catalog_table (boolean)
Объявляет таблицу как дополнительную таблицу каталога, например для целей логической ре-
пликации. За подробностями обратитесь к Подразделу 49.6.2. Для таблиц TOAST этот параметр
задать нельзя.
Замечания
Применять OID в новых приложениях не рекомендуется: по возможности лучше использовать в ка-
честве первичного ключа таблицы столбец идентификации или другой генератор последователь-
ности. Однако, если в вашем приложении для идентификации строк применяется OID, рекоменду-
ется создать уникальное ограничение по столбцу oid в этой таблице, чтобы значения OID в этой
таблице на самом деле однозначно идентифицировали строки даже после зацикливания счётчи-
ка. Также не стоит полагать, что значения OID уникальны в разных таблицах; если вам требуется
идентификатор, уникальный в базе данных, воспользуйтесь для этого комбинацией tableoid и OID
строки.
Подсказка
Применять OIDS=FALSE не рекомендуется для таблиц без первичного ключа, так как без
OID или уникального ключа данных сложно идентифицировать определённые строки.
1529CREATE TABLE
PostgreSQL автоматически создаёт индекс, гарантирующий уникальность, для каждого ограниче-
ния уникальности и ограничения первичного ключа. Поэтому явно создавать индекс для столбцов
первичного ключа не требуется. (За дополнительными сведениями обратитесь к CREATE INDEX.)
Ограничения уникальности и первичные ключи в текущей реализации не наследуются. Вслед-
ствие этого ограничения уникальности довольно плохо сочетаются с наследованием.
В таблице не может быть больше 1600 столбцов. (На практике фактический предел обычно ниже
из-за ограничения на длину записи.)
Примеры
Создание таблицы films и таблицы distributors:
CREATE TABLE films (
code
char(5) CONSTRAINT firstkey PRIMARY KEY,
title
varchar(40) NOT NULL,
did
integer NOT NULL,
date_prod
date,
kind
varchar(10),
len
interval hour to minute
);
CREATE TABLE distributors (
did
integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
name
varchar(40) NOT NULL CHECK (name &lt;&gt; ‘’)
);
Создание таблицы с двумерным массивом:
CREATE TABLE array_int (
vector int[][]
);
Определение ограничения уникальности для таблицы films. Ограничения уникальности могут
быть определены для одного или нескольких столбцов таблицы:
CREATE TABLE films (
code
char(5),
title
varchar(40),
did
integer,
date_prod
date,
kind
varchar(10),
len
interval hour to minute,
CONSTRAINT production UNIQUE(date_prod)
);
Определение ограничения-проверки для столбца:
CREATE TABLE distributors (
did
integer CHECK (did &gt; 100),
name
varchar(40)
);
Определение ограничения-проверки для таблицы:
CREATE TABLE distributors (
did
integer,
name
varchar(40),
CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; ‘’)
);
1530CREATE TABLE
Определение ограничения первичного ключа для таблицы films:
CREATE TABLE films (
code
char(5),
title
varchar(40),
did
integer,
date_prod
date,
kind
varchar(10),
len
interval hour to minute,
CONSTRAINT code_title PRIMARY KEY(code,title)
);
Определение ограничения первичного ключа для таблицы distributors. Следующие два примера
равнозначны, но в первом используется синтаксис ограничений для таблицы, а во втором — для
столбца:
CREATE TABLE distributors (
did
integer,
name
varchar(40),
PRIMARY KEY(did)
);
CREATE TABLE distributors (
did
integer PRIMARY KEY,
name
varchar(40)
);
Определение значений по умолчанию: для столбца name значением по умолчанию будет строка,
для столбца did — следующее значение объекта последовательности, а для modtime — время, когда
была вставлена запись:
CREATE TABLE distributors (
name
varchar(40) DEFAULT ‘Luso Films’,
did
integer DEFAULT nextval(‘distributors_serial’),
modtime
timestamp DEFAULT current_timestamp
);
Определение двух ограничений NOT NULL для столбцов таблицы distributors, при этом одному
ограничению даётся явное имя:
CREATE TABLE distributors (
did
integer CONSTRAINT no_null NOT NULL,
name
varchar(40) NOT NULL
);
Определение ограничения уникальности для столбца name:
CREATE TABLE distributors (
did
integer,
name
varchar(40) UNIQUE
);
То же самое условие, но в виде ограничения таблицы:
CREATE TABLE distributors (
did
integer,
name
varchar(40),
UNIQUE(name)
);
Создание такой же таблицы с фактором заполнения 70% для таблицы и её уникального индекса:
CREATE TABLE distributors (
1531CREATE TABLE
did
integer,
name
varchar(40),
UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
Создание таблицы circles с ограничением-исключением, не допускающим пересечения двух кру-
гов:
CREATE TABLE circles (
c circle,
EXCLUDE USING gist (c WITH &amp;&amp;)
);
Создание таблицы cinemas в табличном пространстве diskvol1:
CREATE TABLE cinemas (
id serial,
name text,
location text
) TABLESPACE diskvol1;
Создание составного типа и типизированной таблицы:
CREATE TYPE employee_type AS (name text, salary numeric);
CREATE TABLE employees OF employee_type (
PRIMARY KEY (name),
salary WITH OPTIONS DEFAULT 1000
);
Создание таблицы, секционируемой по диапазонам:
CREATE TABLE measurement (
logdate
date not null,
peaktemp
int,
unitsales
int
) PARTITION BY RANGE (logdate);
Создание таблицы, секционируемой по диапазонам, с ключом разбиения, включающим несколько
столбцов:
CREATE TABLE measurement_year_month (
logdate
date not null,
peaktemp
int,
unitsales
int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
Создание таблицы, секционируемой по спискам:
CREATE TABLE cities (
city_id
bigserial not null,
name
text not null,
population
bigint
) PARTITION BY LIST (left(lower(name), 1));
Создание таблицы, секционируемой по хешу:
CREATE TABLE orders (
order_id
bigint not null,
cust_id
bigint not null,
status
text
) PARTITION BY HASH (order_id);
1532CREATE TABLE
Создание секции таблицы, секционируемой по диапазонам:
CREATE TABLE measurement_y2016m07
PARTITION OF measurement (
unitsales DEFAULT 0
) FOR VALUES FROM (‘2016-07-01’) TO (‘2016-08-01’);
Создание нескольких секций для таблицы, секционируемой по диапазонам, с ключом разбиения,
включающим несколько столбцов:
CREATE TABLE measurement_ym_older
PARTITION OF measurement_year_month
FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);
CREATE TABLE measurement_ym_y2016m11
PARTITION OF measurement_year_month
FOR VALUES FROM (2016, 11) TO (2016, 12);
CREATE TABLE measurement_ym_y2016m12
PARTITION OF measurement_year_month
FOR VALUES FROM (2016, 12) TO (2017, 01);
CREATE TABLE measurement_ym_y2017m01
PARTITION OF measurement_year_month
FOR VALUES FROM (2017, 01) TO (2017, 02);
Создание секции таблицы, секционируемой по спискам:
CREATE TABLE cities_ab
PARTITION OF cities (
CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN (‘a’, ‘b’);
Создание секции таблицы, секционируемой по спискам (при этом сама секция также создаётся
секционируемой), и добавление секции в неё:
CREATE TABLE cities_ab
PARTITION OF cities (
CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN (‘a’, ‘b’) PARTITION BY RANGE (population);
CREATE TABLE cities_ab_10000_to_100000
PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
Создание секций таблицы, секционируемой по хешу:
CREATE TABLE orders_p1 PARTITION OF orders
FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
FOR VALUES WITH (MODULUS 4, REMAINDER 3);
Создание секции по умолчанию:
CREATE TABLE cities_partdef
PARTITION OF cities DEFAULT;
Совместимость
Команда CREATE TABLE соответствует стандарту SQL, с описанными ниже исключениями.
1533CREATE TABLE
Временные таблицы
Хотя синтаксис CREATE TEMPORARY TABLE подобен аналогичному в стандарте SQL, результат по-
лучается другим. В стандарте временные таблицы определяются только один раз и существуют
(изначально пустые) в каждом сеансе, в котором они используются. PostgreSQL вместо этого тре-
бует, чтобы каждый сеанс выполнял собственную команду CREATE TEMPORARY TABLE для каждой
временной таблицы, которая будет использоваться. Это позволяет использовать в разных сеансах
таблицы с одинаковыми именами для разных целей, тогда как при подходе, регламентированном
стандартом, все экземпляры временной таблицы с одним именем должны иметь одинаковую таб-
личную структуру.
Поведение временных таблиц, описанное в стандарте, в большинстве своём игнорируют и другие
СУБД, так что в этом отношении PostgreSQL ведёт себя так же, как и ряд других СУБД.
В стандарте SQL также разделяются глобальные и локальные временные таблицы — в локальной
временной таблице содержится отдельный набор данных для каждого модуля SQL в отдельном
сеансе, хотя её определение так же разделяется между ними. Так как в PostgreSQL модули SQL
не поддерживаются, это различие в PostgreSQL не существует.
Совместимости ради, PostgreSQL принимает ключевые слова GLOBAL и LOCAL в объявлении времен-
ной таблицы, но в настоящее время они никак не действуют. Использовать их не рекомендуется,
так как в будущих версиях PostgreSQL может быть принята их интерпретация, более близкая к
стандарту.
Предложение ON COMMIT для временных таблиц тоже подобно описанному в стандарте SQL, но есть
некоторые отличия. Если предложение ON COMMIT опущено, в SQL подразумевается поведение ON
COMMIT DELETE ROWS. Однако в PostgreSQL по умолчанию действует ON COMMIT PRESERVE ROWS.
Параметр ON COMMIT DROP в стандарте SQL отсутствует.
Неотложенные ограничения уникальности
Когда ограничение UNIQUE или PRIMARY KEY не является отложенным, PostgreSQL проверяет уни-
кальность непосредственно в момент добавления или изменения строки. Стандарт SQL говорит,
что уникальность должна обеспечиваться только в конце оператора; это различие проявляется,
например когда одна команда изменяет множество ключевых значений. Чтобы получить поведе-
ние, оговоренное стандартом, объявите ограничение как откладываемое (DEFERRABLE), но не отло-
женное (т. е., INITIALLY IMMEDIATE). Учтите, что этот вариант может быть значительно медленнее,
чем немедленная проверка ограничений.
Ограничения-проверки для столбцов
Стандарт SQL говорит, что ограничение CHECK, определяемое для столбца, может ссылаться толь-
ко на столбец, с которым оно связано; только ограничения CHECK для таблиц могут ссылаться на
несколько столбцов. В PostgreSQL этого ограничения нет; он воспринимает ограничения-проверки
для столбцов и таблиц одинаково.
Ограничение EXCLUDE
Ограничения EXCLUDE являются расширением PostgreSQL.
NULL «Ограничение»
«Ограничение» NULL (на самом деле это не ограничение) является расширением PostgreSQL стан-
дарта SQL, которое реализовано для совместимости с некоторыми другими СУБД (и для симмет-
рии с ограничением NOT NULL). Так как это поведение по умолчанию для любого столбца, его при-
сутствие не несёт смысловой нагрузки.
Имена ограничений
В стандарте SQL говорится, что имена ограничений таблицы и ограничений домена должны быть
уникальными в схеме, содержащей эту таблицу или домен. Однако PostgreSQL менее строг: он
1534CREATE TABLE
требует только, чтобы имена были уникальны среди ограничений, присоединённых к данной кон-
кретной таблице или домену. Но такого послабления нет для ограничений, построенных на индек-
сах (ограничений UNIQUE, PRIMARY KEY и EXCLUDE), так как ограничение и связанный с ним индекс
имеют одно имя, а имена индексов должны быть уникальны среди всех отношений в их схеме.
В настоящее время в PostgreSQL ограничения NOT NULL вообще не имеют имён, так что на них тре-
бования уникальности не распространяются. Однако это может поменяться в будущих выпусках.
Наследование
Множественное наследование посредством INHERITS является языковым расширением
PostgreSQL. SQL:1999 и более поздние стандарты определяют единичное наследование с дру-
гим синтаксисом и смыслом. Наследование в стиле SQL:1999 пока ещё не поддерживается в
PostgreSQL.
Таблицы с нулём столбцов
PostgreSQL позволяет создать таблицу без столбцов (например, CREATE TABLE foo();). Это расши-
рение стандарта SQL, который не допускает таблицы с нулём столбцов. Таблицы с нулём столбцов
сами по себе не очень полезны, но если их запретить, возникают странные особые ситуации с ко-
мандой ALTER TABLE DROP COLUMN, так что лучшим вариантом кажется игнорировать это требова-
ние стандарта.
Множество столбцов идентификации
PostgreSQL позволяет иметь в таблице более одного столбца идентификации. В стандарте же гово-
рится, что в таблице может быть максимум один столбец идентификации. Это ограничение ослаб-
лено в основном для большей гибкости при выполнении изменений в схеме или миграции. Заметь-
те, что команда INSERT поддерживает только одно предложение переопределения значения, при-
меняемое ко всему оператору, так что с несколькими столбцами идентификации различное пове-
дение не поддерживается должным образом.
Предложение LIKE
Хотя предложение LIKE описано в стандарте SQL, многие варианты его использования, допусти-
мые в PostgreSQL, в стандарте не описаны, а некоторые предусмотренные в стандарте возможно-
сти не реализованы в PostgreSQL.
Предложение WITH
Предложение WITH является расширением PostgreSQL; в стандарте ни параметры хранения, ни
OID не оговариваются.
Табличные пространства
Концепция табличных пространств в PostgreSQL отсутствует в стандарте. Как следствие, предло-
жения TABLESPACE и USING INDEX TABLESPACE являются расширениями.
Типизированные таблицы
Типизированные таблицы реализуют подмножество стандарта SQL. Согласно стандарту, типизи-
рованная таблица содержит столбцы, соответствующие нижележащему составному типу, и ещё
один столбец, ссылающийся на себя. PostgreSQL не поддерживает ссылающиеся на себя столбцы
явно, но тот же эффект можно получить, воспользовавшись OID.
Предложение PARTITION BY
Предложение PARTITION BY является расширением PostgreSQL.
Предложение PARTITION OF
Предложение PARTITION OF является расширением PostgreSQL.
1535CREATE TABLE
См. также
ALTER TABLE, DROP TABLE, CREATE TABLE AS, CREATE TABLESPACE, CREATE TYPE
1536CREATE TABLE AS
CREATE TABLE AS — создать таблицу из результатов запроса
Синтаксис
CREATE [ [ GLOBAL | LOCAL ] ( TEMPORARY | TEMP ) | UNLOGGED ] TABLE [ IF NOT
EXISTS ] имя_таблицы
[ (имя_столбца [, …] ) ]
[ WITH ( параметр_хранения [= значение] [, … ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT ( PRESERVE ROWS | DELETE ROWS | DROP ) ]
[ TABLESPACE табл_пространство ]
AS запрос
[ WITH [ NO ] DATA ]
Описание
CREATE TABLE AS создаёт таблицу и наполняет её данными, полученными в результате выполне-
ния SELECT. Столбцы этой таблицы получают имена и типы данных в соответствии со столбцами
результата SELECT (хотя имена столбцов можно переопределить, добавив явно список новых имён
столбцов).
CREATE TABLE AS напоминает создание представления, но на самом деле есть значительная разни-
ца: эта команда создаёт новую таблицу и выполняет запрос только раз, чтобы наполнить таблицу
начальными данными. Последующие изменения в исходных таблицах запроса в новой таблице от-
ражаться не будут. С представлением, напротив, определяющая его команда SELECT выполняется
при каждой выборке из него.
Параметры
GLOBAL или LOCAL
Для совместимости игнорируются. Использование этих ключевых слов считается устаревшим;
за подробностями обратитесь к CREATE TABLE.
TEMPORARY или TEMP
Если указано, создаваемая таблица будет временной. За подробностями обратитесь к CREATE
TABLE.
UNLOGGED
Если указано, создаваемая таблица будет нежурналируемой. За подробностями обратитесь к
CREATE TABLE.
IF NOT EXISTS
Не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет
выдано замечание. За подробностями обратитесь к описанию CREATE TABLE.
имя_таблицы
Имя создаваемой таблицы (возможно, дополненное схемой).
имя_столбца
Имя столбца в создаваемой таблице. Если имена столбцов не заданы явно, они определяются
по именам столбцов результата запроса.
WITH ( параметр_хранения [= значение] [, … ] )
Это предложение определяет дополнительные параметры хранения для новой таблицы: за
подробностями обратитесь к Подразделу «Параметры хранения». Предложение WITH может
1537CREATE TABLE AS
также включать указание OIDS=TRUE (или просто OIDS), с которым строкам в новой таблице бу-
дут назначаться идентификаторы объектов (OID), либо указание OIDS=FALSE, с которым строки
не будут содержать OID. За дополнительными сведениями обратитесь к CREATE TABLE.
WITH OIDS
WITHOUT OIDS
Это устаревшее написание указаний WITH (OIDS) и WITH (OIDS=FALSE), соответственно. Если
требуется определить одновременно свойство OIDS и параметры хранения, необходимо исполь-
зовать синтаксис WITH ( … ); см. ниже.
ON COMMIT
Поведением временных таблиц в конце блока транзакции позволяет управлять предложение
ON COMMIT, которое принимает три параметра:
PRESERVE ROWS
Никакое специальное действие в конце транзакции не выполняется. Это поведение по умол-
чанию.
DELETE ROWS
Все строки в этой временной таблице будут удаляться в конце каждого блока транзакции.
По сути, при каждой фиксации транзакции будет автоматически выполняться TRUNCATE.
DROP
Эта временная таблица будет удаляться в конце текущего блока транзакции.
TABLESPACE табл_пространство
Здесь табл_пространство — имя табличного пространства, в котором будет создаваться новая
таблица. Если оно не указано, выбирается default_tablespace или temp_tablespaces, если табли-
ца временная.
запрос
Команда SELECT, TABLE или VALUES, либо команда EXECUTE, выполняющая подготовленный
запрос SELECT, TABLE или VALUES.
WITH [ NO ] DATA
Это предложение определяет, будут ли данные, выданные запросом, копироваться в новую таб-
лицу. Если нет, то копируется только структура. По умолчанию данные копируются.
Замечания
Функциональность этой команды подобна SELECT INTO, но предпочтительнее использовать её, во
избежание путаницы с другими применениями синтаксиса SELECT INTO. Кроме того, набор воз-
можностей CREATE TABLE AS шире, чем у SELECT INTO.
Команда CREATE TABLE AS позволяет пользователю явно определить, добавлять ли OID в табли-
цу. Если присутствие OID не определено явно, оно определяется конфигурационной переменной
default_with_oids.
Примеры
Создание таблицы films_recent, содержащей только последние записи из таблицы films:
CREATE TABLE films_recent AS
SELECT * FROM films WHERE date_prod &gt;= ‘2002-01-01’;
Чтобы скопировать таблицу полностью, можно также использовать короткую форму команды
TABLE:
1538CREATE TABLE AS
CREATE TABLE films2 AS
TABLE films;
Создание временной таблицы films_recent, содержащей только последние записи таблицы films,
с применением подготовленного оператора. Новая таблица будет содержать OID и прекратит су-
ществование при фиксации транзакции:
PREPARE recentfilms(date) AS
SELECT * FROM films WHERE date_prod &gt; $1;
CREATE TEMP TABLE films_recent WITH (OIDS) ON COMMIT DROP AS
EXECUTE recentfilms(‘2002-01-01’);
Совместимость
CREATE TABLE AS соответствует стандарту SQL. Нестандартные расширения перечислены ниже:
• Стандарт требует заключать предложение подзапроса в скобки, но в PostgreSQL эти скобки
необязательны.
• Стандарт требует наличия указания WITH [ NO ] DATA, в PostgreSQL оно необязательно.
• PostgreSQL работает с временными таблицами не так, как описано в стандарте; за подробно-
стями обратитесь к CREATE TABLE.
• Предложение WITH является расширением PostgreSQL; в стандарте ни параметры хранения,
ни OID не оговариваются.
• Концепция табличных пространств в PostgreSQL отсутствует в стандарте. Как следствие,
предложение TABLESPACE является расширением.
См. также
CREATE MATERIALIZED VIEW, CREATE TABLE, EXECUTE, SELECT, SELECT INTO, VALUES
1539CREATE TABLESPACE
CREATE TABLESPACE — создать табличное пространство
Синтаксис
CREATE TABLESPACE табл_пространство
[ OWNER ( новый_владелец | CURRENT_USER | SESSION_USER ) ]
LOCATION ‘каталог’
[ WITH ( параметр_табличного_пространства = значение [, … ] ) ]
Описание
CREATE TABLESPACE регистрирует новое табличное пространство на уровне кластера баз данных.
Имя табличного пространства должно отличаться от имён уже существующих табличных про-
странств в кластере.
Табличные пространства позволяют суперпользователям определять альтернативные расположе-
ния в файловой системе, где могут находиться файлы, содержащие объекты базы данных (напри-
мер, таблицы или индексы).
Пользователь, имеющий соответствующие права, может передать параметр табл_пространство ко-
манде CREATE DATABASE, CREATE TABLE, CREATE INDEX или ADD CONSTRAINT, чтобы файлы данных для
этих объектов хранились в указанном табличном пространстве.
Предупреждение
Табличное пространство нельзя использовать отдельно от кластера, в котором оно бы-
ло определено; см. Раздел 22.6.
Параметры
табл_пространство
Имя создаваемого табличного пространства. Это имя не может начинаться с pg_, так как такие
имена зарезервированы для системных табличных пространств.
имя_пользователя
Имя пользователя, который будет владельцем табличного пространства. Если опущено, вла-
дельцем по умолчанию станет пользователь, выполняющий команду. Создавать табличные про-
странства могут только суперпользователи, но их владельцами могут быть назначены и обыч-
ные пользователи.
каталог
Каталог, который будет использован для этого табличного пространства. Этот каталог должен
быть пустым и должен принадлежать системному пользователю PostgreSQL. Задаваться его
расположение должно абсолютным путём.
параметр_табличного_пространства
Устанавливаемый или сбрасываемый параметр табличного пространства. В настоя-
щее время поддерживаются только параметры seq_page_cost, random_page_cost и
effective_io_concurrency. При установке этих значений для заданного табличного простран-
ства будет переопределена обычная оценка стоимости чтения страниц из таблиц в этом
пространстве, настраиваемая одноимённым параметром конфигурации (см. seq_page_cost,
random_page_cost, effective_io_concurrency). Это может быть полезно, если одно из табличных
1540CREATE TABLESPACE
пространств размещено на диске, который быстрее или медленнее остальной дисковой систе-
мы.
Замечания
Табличные пространства поддерживаются только на платформах, поддерживающих символиче-
ские ссылки.
CREATE TABLESPACE не может быть выполнена внутри блока транзакции.
Примеры
Создание табличного пространства dbspace в /data/dbs:
CREATE TABLESPACE dbspace LOCATION ‘/data/dbs’;
Создание табличного пространства indexspace в /data/indexes и назначение его владельцем
genevieve:
CREATE TABLESPACE indexspace OWNER genevieve LOCATION ‘/data/indexes’;
Совместимость
CREATE TABLESPACE является расширением PostgreSQL.
См. также
CREATE DATABASE, CREATE TABLE, CREATE INDEX, DROP TABLESPACE, ALTER TABLESPACE
1541CREATE TEXT SEARCH CONFIGURATION
CREATE TEXT SEARCH CONFIGURATION — создать конфигурацию текстового поиска
Синтаксис
CREATE TEXT SEARCH CONFIGURATION имя (
PARSER = имя_анализатора |
COPY = исходная_конфигурация
)
Описание
CREATE TEXT SEARCH CONFIGURATION создаёт конфигурацию текстового поиска. Конфигурация тек-
стового поиска определяет анализатор текстового поиска, разделяющий строку на фрагменты, и
словари, позволяющие установить, какие именно фрагменты представляют интерес при поиске.
Если задаётся только анализатор, новая конфигурация текстового поиска не будет содержать со-
поставления типов фрагментов со словарями и, как следствие, будет игнорировать все слова. Для
создания сопоставлений, которые бы сделали конфигурацию полезной, затем нужно будет вос-
пользоваться командой ALTER TEXT SEARCH CONFIGURATION. Другой вариант команды позволяет
скопировать конфигурацию текстового поиска.
Если указывается имя схемы, конфигурация текстового поиска создаётся в указанной схеме. В
противном случае она создаётся в текущей схеме.
Владельцем конфигурации текстового поиска становится пользователь её создавший.
За дополнительными сведениями обратитесь к Главе 12.
Параметры
имя
Имя создаваемой конфигурации текстового поиска, возможно, дополненное схемой.
имя_анализатора
Имя анализатора текстового поиска, который будет использоваться этой конфигурацией.
исходная_конфигурация
Имя существующей конфигурации текстового поиска, которая будет скопирована.
Замечания
Параметры PARSER и COPY являются взаимоисключающими, так как при копировании существую-
щей конфигурации выбранный в ней анализатор копируется тоже.
Совместимость
Оператор CREATE TEXT SEARCH CONFIGURATION отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH CONFIGURATION, DROP TEXT SEARCH CONFIGURATION
1542CREATE TEXT SEARCH DICTIONARY
CREATE TEXT SEARCH DICTIONARY — создать словарь текстового поиска
Синтаксис
CREATE TEXT SEARCH DICTIONARY имя (
TEMPLATE = шаблон
[, параметр = значение [, … ]]
)
Описание
CREATE TEXT SEARCH DICTIONARY создаёт словарь текстового поиска. Словарь текстового поис-
ка определяет способ выделения слов, представляющих или не представляющих интерес для по-
иска. Работа словаря зависит от шаблона текстового поиска, в котором определяются функции,
собственно выполняющие действия. Обычно словарь задаёт некоторые параметры, управляющие
частным поведением функций шаблона.
Если указывается имя схемы, словарь текстового поиска создаётся в указанной схеме. В противном
случае он создаётся в текущей схеме.
Владельцем словаря текстового поиска становится пользователь его создавший.
За дополнительными сведениями обратитесь к Главе 12.
Параметры
имя
Имя создаваемого словаря текстового поиска, возможно, дополненное схемой.
шаблон
Имя шаблона текстового поиска, который будет определять общее поведение этого словаря.
параметр
Имя параметра шаблона, устанавливаемого для данного словаря.
значение
Значение для параметра, связанного с шаблоном. Если это не простой идентификатор или чис-
ло, его следует заключить в кавычки (при желании его можно заключать в кавычки всегда).
Параметры могут перечисляться в любом порядке.
Примеры
Команда в следующем примере создаёт словарь на базе Snowball с нестандартным списком стоп-
слов.
CREATE TEXT SEARCH DICTIONARY my_russian (
template = snowball,
language = russian,
stopwords = myrussian
);
Совместимость
Оператор CREATE TEXT SEARCH DICTIONARY отсутствует в стандарте SQL.
1543CREATE TEXT
SEARCH DICTIONARY
См. также
ALTER TEXT SEARCH DICTIONARY, DROP TEXT SEARCH DICTIONARY
1544CREATE TEXT SEARCH PARSER
CREATE TEXT SEARCH PARSER — создать анализатор текстового поиска
Синтаксис
CREATE TEXT SEARCH PARSER имя (
START = функция_начала ,
GETTOKEN = функция_выдачи_фрагмента ,
END = функция_окончания ,
LEXTYPES = функция_лекс_типов
[, HEADLINE = функция_выдержек ]
)
Описание
CREATE TEXT SEARCH PARSER создаёт анализатор текстового поиска. Анализатор текстового поиска
определяет способ разделения текстовой строки на фрагменты и назначения типов (категорий)
этим фрагментам. Анализатор не очень полезен сам по себе, для осуществления поиска он должен
быть подключён к конфигурации текстового поиска вместе с определёнными словарями.
Если указывается имя схемы, словарь текстового поиска создаётся в указанной схеме. В противном
случае он создаётся в текущей схеме.
Выполнить CREATE TEXT SEARCH PARSER может только суперпользователь. (Это ограничение введе-
но потому, что ошибочное определение анализатора текстового поиска может вызвать нарушения
или даже сбой в работе сервера.)
За дополнительными сведениями обратитесь к Главе 12.
Параметры
имя
Имя создаваемого анализатора текстового поиска, возможно, дополненное схемой.
функция_начала
Имя функции, вызываемой в начале обработки.
функция_выдачи_фрагмента
Имя функции, выдающей следующий фрагмент.
функция_окончания
Имя функции, вызываемой по окончании обработки.
функция_лекс_типов
Имя функции перечисления лексических типов (эта функция выдаёт информацию о множестве
типов фрагментов, выделяемых анализатором).
функция_выдержек
Имя функции извлечения выдержек (эта функция выделяет краткое содержание для набора
фрагментов).
Имена функций могут быть дополнены именем схемы, если требуется. Типы аргументов не указы-
ваются, так как список аргументов для всех типов функций предопределён. Обязательными явля-
ются все функции, кроме функции выдержек.
1545CREATE TEXT SEARCH PARSER
Аргументы могут перечисляться в любом порядке, не только в том, что показан выше.
Совместимость
Оператор CREATE TEXT SEARCH PARSER отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH PARSER, DROP TEXT SEARCH PARSER
1546CREATE TEXT SEARCH TEMPLATE
CREATE TEXT SEARCH TEMPLATE — создать шаблон текстового поиска
Синтаксис
CREATE TEXT SEARCH TEMPLATE имя (
[ INIT = функция_инициализации , ]
LEXIZE = функция_выделения_лексем
)
Описание
CREATE TEXT SEARCH TEMPLATE создаёт новый шаблон текстового поиска. Шаблоны текстового
поиска определяют функции для реализации словарей текстового поиска. Шаблон сам по себе
бесполезен, но его экземпляр нужно создать для словаря. Словарь обычно определяет параметры,
передаваемые функциям шаблона.
Если указывается имя схемы, шаблон текстового поиска создаётся в указанной схеме. В противном
случае он создаётся в текущей схеме.
Выполнить CREATE TEXT SEARCH TEMPLATE может только суперпользователь. Это ограничение вве-
дено потому, что ошибочное определение шаблона текстового поиска может вызвать нарушения
или даже сбой в работе сервера. Смысл отделения шаблонов от словарей в том, что шаблон по-
крывает «небезопасные» аспекты определения словаря. Параметры, которые можно задать при
определении словаря, не могут причинить вред, поэтому создавать словари разрешено и неприви-
легированным пользователям.
За дополнительными сведениями обратитесь к Главе 12.
Параметры
имя
Имя создаваемого шаблона текстового поиска, возможно, дополненное схемой.
функция_инициализации
Имя функции инициализации для шаблона.
функция_выделения_лексем
Имя функции выделения лексем.
Имена функций могут быть дополнены именем схемы, если требуется. Типы аргументов не указы-
ваются, так как список аргументов для всех типов функций предопределён. Функция выделения
лексем является обязательной, а функция инициализации может отсутствовать.
Аргументы могут перечисляться в любом порядке, не только в том, что показан выше.
Совместимость
Оператор CREATE TEXT SEARCH TEMPLATE отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH TEMPLATE, DROP TEXT SEARCH TEMPLATE
1547CREATE TRANSFORM
CREATE TRANSFORM — создать трансформацию
Синтаксис
CREATE [ OR REPLACE ] TRANSFORM FOR имя_типа LANGUAGE имя_языка (
FROM SQL WITH FUNCTION имя_функции_из_sql [ (тип_аргумента [, …]) ],
TO SQL WITH FUNCTION имя_функции_в_sql [ (тип_аргумента [, …]) ]
);
Описание
CREATE TRANSFORM определяет новую трансформацию. CREATE OR REPLACE TRANSFORM либо создаёт
трансформацию, либо заменяет существующую.
Трансформация определяет, как преобразовать тип данных для процедурного языка. Например,
если написать на языке PL/Python функцию, использующую тип hstore, PL/Python заведомо не
знает, как должны представляться значения hstore в среде Python. Обычно реализации языка
нисходят к текстовому представлению, но это может быть неудобно, когда более уместен был бы,
например, ассоциативный массив или список.
Трансформация определяет две функции:
• Функция «из SQL» преобразует тип из среды SQL в среду языка. Эта функция будет вызывать-
ся для аргументов функции, написанной на этом языке.
• Функция «в SQL» преобразует тип из среды языка в среду SQL. Эта функция будет вызываться
для значения, возвращаемого из функции на этом языке.
Предоставлять обе эти функции не требуется, можно ограничиться одной. Если одна из них не
указана, при необходимости выбирается поведение, принятое для языка по умолчанию. (Чтобы
полностью перекрыть путь трансформации в одну сторону, можно написать функцию, которая бу-
дет всегда выдавать ошибку.)
Чтобы создать трансформацию, необходимо быть владельцем и иметь право USAGE для типа, иметь
право USAGE для языка, а также быть владельцем и иметь право EXECUTE для функций из-SQL и в-
SQL, если они задаются.
Параметры
имя_типа
Имя типа данных, для которого предназначена трансформация.
имя_языка
Имя языка, для которого предназначена трансформация.
имя_функции_из_sql[(тип_аргумента [, …])]
Имя функции для преобразования типа из среды SQL в среду языка. Она должна принимать
один аргумент типа internal и возвращать тип internal. Фактический аргумент будет иметь
тип, заданный для трансформации, и сама функция должна рассчитывать на это. (Но на уровне
SQL нельзя объявить функцию, возвращающую тип internal, если она не принимает минимум
один аргумент типа internal.) Фактически возвращаемое значение будет определяться реали-
зацией языка. Если список аргументов отсутствует, имя функции должно быть уникальным в
её схеме.
имя_функции_в_sql[(тип_аргумента [, …])]
Имя функции для преобразования типа из среды языка в среду SQL. Она должна принимать
один аргумент типа internal и возвращать тип, для которого создаётся трансформация. Фак-
1548CREATE TRANSFORM
тическое значение аргумента будет определяться реализацией языка. Если список аргументов
отсутствует, имя функции должно быть уникальным в её схеме.
Замечания
Для удаления трансформаций применяется DROP TRANSFORM.
Примеры
Чтобы создать трансформацию для типа hstore и языка plpythonu, сначала нужно создать тип и
язык:
CREATE TYPE hstore …;
CREATE EXTENSION plpythonu;
Затем создайте необходимые функции:
CREATE FUNCTION hstore_to_plpython(val internal) RETURNS internal
LANGUAGE C STRICT IMMUTABLE
AS …;
CREATE FUNCTION plpython_to_hstore(val internal) RETURNS hstore
LANGUAGE C STRICT IMMUTABLE
AS …;
И наконец, создайте трансформацию, соединяющую всё это вместе:
CREATE TRANSFORM FOR hstore LANGUAGE plpythonu (
FROM SQL WITH FUNCTION hstore_to_plpython(internal),
TO SQL WITH FUNCTION plpython_to_hstore(internal)
);
На практике эти команды помещаются в расширение.
В разделе contrib представлено несколько расширений, в которых определены трансформации,
что может послужить практическим примером реализации.
Совместимость
Первая форма CREATE TRANSFORM является расширением PostgreSQL. В стандарте SQL есть команда
CREATE TRANSFORM, но её предназначение — преобразовывать типы для языков на стороне клиента.
Этот вариант использования не поддерживается PostgreSQL.
См. также
CREATE FUNCTION, CREATE LANGUAGE, CREATE TYPE, DROP TRANSFORM
1549CREATE TRIGGER
CREATE TRIGGER — создать триггер
Синтаксис
CREATE [ CONSTRAINT ] TRIGGER имя ( BEFORE | AFTER | INSTEAD OF ) ( событие
[ OR … ] )
ON имя_таблицы
[ FROM ссылающаяся_таблица ]
[ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
[ REFERENCING ( ( OLD | NEW ) TABLE [ AS ] имя_переходного_отношения ) [ … ] ]
[ FOR [ EACH ] ( ROW | STATEMENT ) ]
[ WHEN ( условие ) ]
EXECUTE ( FUNCTION | PROCEDURE ) имя_функции ( аргументы )
Здесь допускается событие:
INSERT
UPDATE [ OF имя_столбца [, … ] ]
DELETE
TRUNCATE
Описание
CREATE TRIGGER создаёт новый триггер. Триггер будет связан с указанной таблицей, представле-
нием или сторонней таблицей и будет выполнять заданную функцию имя_функции при определён-
ных операциях с этой таблицей.
Триггер можно настроить так, чтобы он срабатывал до операции со строкой (до проверки ограни-
чений и попытки выполнить INSERT, UPDATE или DELETE) или после её завершения (после проверки
ограничений и выполнения INSERT, UPDATE или DELETE), либо вместо операции (при добавлении,
изменении и удалении строк в представлении). Если триггер срабатывает до или вместо события,
он может пропустить операцию с текущей строкой, либо изменить добавляемую строку (только
для операций INSERT и UPDATE). Если триггер срабатывает после события, он «видит» все измене-
ния, включая результат действия других триггеров.
Триггер с пометкой FOR EACH ROW вызывается один раз для каждой строки, изменяемой в процессе
операции. Например, операция DELETE, удаляющая 10 строк, приведёт к срабатыванию всех триг-
геров ON DELETE в целевом отношении 10 раз подряд, по одному разу для каждой удаляемой строки.
Триггер с пометкой FOR EACH STATEMENT, напротив, вызывается только один раз для конкретной
операции, вне зависимости от того, как много строк она изменила (в частности, при выполнении
операции, изменяющей ноль строк, всё равно будут вызваны все триггеры FOR EACH STATEMENT).
Триггеры, срабатывающие в режиме INSTEAD OF, должны быть помечены FOR EACH ROW и могут
быть определены только для представлений. Триггеры BEFORE и AFTER для представлений должны
быть помечены FOR EACH STATEMENT.
Кроме того, триггеры можно определить и для команды TRUNCATE, но только типа FOR
STATEMENT.
EACH
В следующей таблице перечисляются типы триггеров, которые могут использоваться для таблиц,
представлений и сторонних таблиц:
Когда
Событие
BEFORE
На уровне строк
INSERT/UPDATE/DELETE
1550
Таблицы и сто-
ронние таблицы
На уровне оператора
Таблицы, пред-
ставления и сто-
ронние таблицыCREATE TRIGGER
Когда
Событие
AFTER
INSTEAD OF
На уровне строк
На уровне оператора
TRUNCATE — Таблицы
INSERT/UPDATE/DELETE Таблицы и сто-
ронние таблицы Таблицы, пред-
ставления и сто-
ронние таблицы
TRUNCATE — Таблицы
INSERT/UPDATE/DELETE Представления —
TRUNCATE — —
Кроме того, в определении триггера можно указать булевское условие WHEN, которое определит,
вызывать триггер или нет. В триггерах на уровне строк условия WHEN могут проверять старые и/или
новые значения столбцов в строке. Триггеры на уровне оператора так же могут содержать условие
WHEN, хотя для них это не столь полезно, так как в этом условии нельзя ссылаться на какие-либо
значения в таблице.
Если для одного события определено несколько триггеров одного типа, они будут срабатывать в
алфавитном порядке их имён.
Когда указывается параметр CONSTRAINT, эта команда создаёт триггер ограничения. Он подобен
обычным триггерам, но отличается тем, что время его срабатывания можно изменить командой
SET CONSTRAINTS. Триггеры ограничений должны быть триггерами типа AFTER ROW для обычных
(не сторонних) таблиц. Они могут срабатывать либо в конце оператора, вызвавшего целевое собы-
тие, либо в конце содержащей его транзакции; в последнем случае они называются отложенны-
ми. Срабатывание ожидающего отложенного триггера можно вызвать немедленно, воспользовав-
шись командой SET CONSTRAINTS. Предполагается, что триггеры ограничений будут генерировать
исключения при нарушении ограничений.
Когда указывается REFERENCING, для триггера собираются переходные отношения, представляю-
щие собой множества строк, включающие все строки, которые были добавлены, удалены или из-
менены текущим оператором SQL. Это позволяет триггеру наблюдать общую картину того, что
сделал оператор, а не только одну строку за другой. Это указание допускается только для триггера
AFTER, не являющегося триггером ограничения; кроме того, если это триггер для UPDATE, у него
должен отсутствовать список имён_столбцов. Указание OLD TABLE может быть задано только один
раз и только для триггера, который может срабатывать при UPDATE или DELETE; оно создаёт пере-
ходное отношение, содержащее образы-до-изменения всех строк, модифицированных или удалён-
ных оператором. Указание NEW TABLE, подобным образом, может быть задано только единожды
и только для триггера, который может срабатывать для UPDATE или INSERT; оно создаёт переход-
ное отношение, содержащее образы-после-изменения всех строк, модифицированных или добав-
ленных оператором.
SELECT не изменяет никакие строки, поэтому создавать триггеры для SELECT нельзя. Для решения
задач, в которых требуются подобные триггеры, могут подойти правила или представления.
За дополнительными сведениями о триггерах обратитесь к Главе 39.
Параметры
имя
Имя, назначаемое новому триггеру. Это имя должно отличаться от имени любого другого триг-
гера в этой же таблице. Имя не может быть дополнено схемой — триггер наследует схему от
своей таблицы. Для триггеров ограничений это имя также используется, когда требуется скор-
ректировать поведение триггера с помощью команды SET CONSTRAINTS.
1551CREATE TRIGGER
BEFORE
AFTER
INSTEAD OF
Определяет, будет ли заданная функция вызываться до, после или вместо события. Для триг-
гера ограничения можно указать только AFTER.
событие
Принимает одно из значений: INSERT, UPDATE, DELETE или TRUNCATE; этот параметр определяет
событие, при котором будет срабатывать триггер. Несколько событий можно указать, добавив
между ними слово OR, если только не запрашиваются переходные отношения.
Для событий UPDATE можно указать список столбцов, используя такую запись:
UPDATE OF имя_столбца1 [, имя_столбца2 … ]
Такой триггер сработает, только если в указанном в целевой команде UPDATE списке столбцов
найдётся минимум одна из перечисленных.
Для событий INSTEAD OF UPDATE указание списка столбцов не допускается. Список столбцов
также нельзя задать, когда запрашиваются переходные отношения.
имя_таблицы
Имя (возможно, дополненное схемой) таблицы, представления или сторонней таблицы, для ко-
торых предназначен триггер.
ссылающаяся_таблица
Имя (возможно, дополненное схемой) другой таблицы, на которую ссылается ограничение. Оно
используется для ограничений внешнего ключа и не рекомендуется для обычного применения.
Это указание допускается только для триггеров ограничений.
DEFERRABLE
NOT DEFERRABLE
INITIALLY IMMEDIATE
INITIALLY DEFERRED
Время срабатывания триггера по умолчанию. Подробнее возможные варианты описаны в до-
кументации CREATE TABLE. Это указание допускается только для триггеров ограничений.
REFERENCING
Это ключевое слово непосредственно предшествует объявлению одного или двух имён, по ко-
торым можно будет обращаться к переходным отношениями, образуемым при выполнении це-
левого оператора.
OLD TABLE
NEW TABLE
Это предложение указывает, будет ли следующее имя относиться к переходному отношению с
образом-до-изменения или к переходному отношению с образом-после-изменения.
имя_переходного_отношения
Имя (неполное, без схемы), которое будет использоваться в триггере для обращения к этому
переходному отношению.
FOR EACH ROW
FOR EACH STATEMENT
Определяет, будет ли функция триггера срабатывать один раз для каждой строки, либо для
SQL-оператора. Если не указано ничего, подразумевается FOR EACH STATEMENT (для оператора).
Для триггеров ограничений можно указать только FOR EACH ROW.
1552CREATE TRIGGER
условие
Булевское выражение, определяющее, будет ли выполняться функция триггера. Если для триг-
гера задано указание WHEN, функция будет вызываться, только когда условие возвращает true.
В триггерах FOR EACH ROW условие WHEN может ссылаться на значения столбца в старой и/или
новой строке, в виде OLD.имя_столбца и NEW.имя_столбца, соответственно. Разумеется, тригге-
ры INSERT не могут ссылаться на OLD, а триггеры DELETE не могут ссылаться на NEW.
Триггеры INSTEAD OF не поддерживают условия WHEN.
В настоящее время выражения WHEN не могут содержать подзапросы.
Учтите, что для триггеров ограничений вычисление условия WHEN не откладывается, а выпол-
няется немедленно после операции, изменяющей строки. Если результат условия — ложь, сам
триггер не откладывается для последующего выполнения.
имя_функции
Заданная пользователем функция, объявленная как функция без аргументов и возвращающая
тип trigger, которая будет вызываться при срабатывании триггера.
В синтаксисе CREATE TRIGGER ключевые слова FUNCTION и PROCEDURE равнозначны, но указыва-
емая триггерная функция должна в любом случае быть функцией, а не процедурой. Ключевое
слово PROCEDURE здесь поддерживается по историческим причинам и считается устаревшим.
аргументы
Необязательный список аргументов через запятую, которые будут переданы функции при сра-
батывании триггера. В качестве аргументов функции передаются строковые константы. И хо-
тя в этом списке можно записать и простые имена или числовые константы, они тоже будут
преобразованы в строки. Порядок обращения к таким аргументам в функции триггера может
отличаться от обычных аргументов, поэтому его следует уточнить в описании языка реализа-
ции этой функции.
Замечания
Чтобы создать триггер, пользователь должен иметь право TRIGGER для этой таблицы. Также поль-
зователь должен иметь право EXECUTE для триггерной функции.
Для удаления триггера применяется команда DROP TRIGGER.
Триггер для избранных столбцов (определённый с помощью UPDATE OF имя_столбца) будет сраба-
тывать, когда его столбцы перечислены в качестве целевых в списке SET команды UPDATE. Измене-
ния, вносимые в строки триггерами BEFORE UPDATE, при этом не учитываются, поэтому значения
столбцов можно изменить так, что триггер не сработает. И наоборот, при выполнении команды
UPDATE … SET x = x … триггер для столбца x сработает, хотя значение столбца не меняется.
В триггере BEFORE условие WHEN вычисляется непосредственно перед возможным вызовом функ-
ции, поэтому проверка WHEN существенно не отличается от проверки того же условия в начале
функции триггера. В частности, учтите, что строка NEW, которую видит ограничение, содержит те-
кущие значения, возможно, изменённые предыдущими триггерами. Кроме того, в триггере BEFORE
условие WHEN не может проверять системные столбцы в строке NEW (например, oid), так как они
ещё не установлены.
В триггере AFTER условие WHEN проверяется сразу после изменения строки, и если оно выполняет-
ся, событие запоминается, чтобы вызвать триггер в конце оператора. Если же для триггера AFTER
условие WHEN не выполняется, нет необходимости запоминать событие для последующей обработ-
ки или заново перечитывать строку в конце оператора. Это приводит к значительному ускорению
операторов, изменяющих множество строк, когда триггер должен срабатывать только для некото-
рых из них.
1553CREATE TRIGGER
В некоторых случаях одна команда SQL может вызывать сразу нескольких видов триггеров. На-
пример, INSERT с предложением ON CONFLICT DO UPDATE может выполнять операции как добав-
ления, так и изменения, так что она при необходимости будет вызывать триггеры обоих видов.
При этом переходные отношения, предоставляемые триггерам, будут разными в зависимости от
типа события; то есть триггер INSERT будет видеть только добавленные строки, а триггер UPDATE
— только изменённые.
Изменения или удаления строк, вызванные действиями по обеспечению целостности внешнего
ключа, например, ON UPDATE CASCADE или ON DELETE SET NULL, считаются частью SQL-команды,
вызвавшей эти действия (заметьте, что такие действия не могут быть отложенными). В затраги-
ваемой таблице будут вызваны соответствующие триггеры, и таким образом появляется возмож-
ность вызова триггеров для SQL-команды, не соответствующей непосредственно их типу. В про-
стых ситуациях триггеры, запрашивающие переходные отношения, будут видеть все изменения,
произведённые в их таблице одной исходной командой SQL, в виде одного переходного отношения.
Однако возможны случаи, в которых присутствие триггера AFTER ROW, запрашивающего переход-
ные отношения, приведёт к тому, что операции для обеспечения целостности внешнего ключа,
вызванные одной SQL-командой, будут разделены на несколько этапов, и на каждом будут свои
переходные отношения. В таких случаях все существующие триггеры уровня оператора будут сра-
батывать единожды при создании переходного отношения, что гарантирует, что эти триггеры бу-
дут видеть каждую обрабатываемую строку в переходном отношении один и только один раз.
Триггеры уровня операторов для представления срабатывают, только если операция с представ-
лением обрабатывается триггером уровня строк INSTEAD OF. Если операция обрабатывается пра-
вилом INSTEAD, то вместо исходного оператора, обращающегося к представлению, выполняются те
операторы, что генерирует правило, поэтому вызываться будут триггеры, связанные с таблицами,
к которым обращаются эти заменяющие операторы. Аналогично, для автоматически изменяемо-
го представления выполнение операции сводится к переписыванию оператора в виде операции
с базовой таблицей представления, так что срабатывать будут триггеры уровня операторов для
базовой таблицы.
При создании триггера уровня строки для секционированной таблицы такие же триггеры будут
созданы во всех существующих секциях этой таблицы; идентичные триггеры будут установлены и в
секциях, создаваемых и присоединяемых позже. Для секционированных таблиц могут создаваться
только триггеры AFTER.
При изменении данных в секционированной таблице или таблице с потомками срабатывают триг-
геры уровня оператора, связанные с явно задействованной таблицей, но не триггеры уровня опе-
ратора для её секций или дочерних таблиц. Триггеры уровня строк, напротив, срабатывают для
строк в затрагиваемых секциях или дочерних таблицах, даже если они явно не присутствуют в за-
просе. Если триггер уровня оператора был определён с переходными отношениями, названными
в указании REFERENCING, то в них будут видны образы строк из всех затронутых секций или дочер-
них таблиц. В случае с потомками в иерархии наследования образы строк будут содержать толь-
ко столбцы, присутствующие в таблице, с которой связан триггер. В настоящее время триггеры
уровня строк с переходными отношениями нельзя определить для секций или дочерних таблиц в
иерархии наследования.
В PostgreSQL до версии 7.3 обязательно требовалось объявлять триггерные функции, как возвра-
щающие фиктивный тип opaque, а не trigger. Для поддержки загрузки старых файлов экспорта
БД, команда CREATE TRIGGER принимает функции с объявленным типом результата opaque, но при
этом выдаётся предупреждение и тип результата меняется на trigger.
Примеры
Выполнение функции check_account_update перед любым изменением строк в таблице accounts:
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE FUNCTION check_account_update();
1554CREATE TRIGGER
То же самое, но функция триггера будет выполняться, только если столбец balance присутствует
в списке целевых столбцов команды UPDATE:
CREATE TRIGGER check_update
BEFORE UPDATE OF balance ON accounts
FOR EACH ROW
EXECUTE FUNCTION check_account_update();
В этом примере функция будет выполняться, если значение столбца balance в действительности
изменилось:
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
EXECUTE FUNCTION check_account_update();
Вызов функции, ведущей журнал изменений в accounts, но только если что-то изменилось:
CREATE TRIGGER log_update
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.</em> IS DISTINCT FROM NEW.<em>)
EXECUTE FUNCTION log_account_update();
Выполнение для каждой строки функции view_insert_row, которая будет вставлять строки в ни-
жележащие таблицы представления:
CREATE TRIGGER view_insert
INSTEAD OF INSERT ON my_view
FOR EACH ROW
EXECUTE FUNCTION view_insert_row();
Выполнение функции check_transfer_balances_to_zero для каждого оператора, проверяющей,
что строки transfer в совокупности дают нулевой баланс:
CREATE TRIGGER transfer_insert
AFTER INSERT ON transfer
REFERENCING NEW TABLE AS inserted
FOR EACH STATEMENT
EXECUTE FUNCTION check_transfer_balances_to_zero();
Выполнение функции check_matching_pairs для каждой строки, проверяющей, что соответствую-
щие пары пунктов изменены синхронно (одним оператором):
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab
FOR EACH ROW
EXECUTE FUNCTION check_matching_pairs();
В Разделе 39.4 приведён полный пример функции триггера, написанной на C.
Совместимость
Оператор CREATE TRIGGER в PostgreSQL реализует подмножество возможностей, описанных в стан-
дарте SQL. В настоящее время в нём отсутствует следующая функциональность:
• Тогда как имена переходных таблиц для триггеров AFTER задаются предложением
REFERENCING стандартным образом, переменные строк, применяемые в триггерах FOR EACH
ROW нельзя объявлять в предложении REFERENCING. Порядок обращения к таким строкам за-
висит от языка, на котором написана триггерная функция, но для каждого языка он вполне
определённый. Некоторые языки по сути действуют так, как будто в команде присутствует
предложение REFERENCING с указанием OLD ROW AS OLD NEW ROW AS NEW.
1555CREATE TRIGGER
• Стандарт позволяет использовать переходные таблицы с триггерами UPDATE, ограничивающи-
ми набор отслеживаемых столбцов, но тогда и набор строк, видимых в переходных таблицах,
должен зависеть от списка целевых столбцов триггера. В настоящее время такое поведение в
PostgreSQL не реализовано.
• PostgreSQL позволяет задать в качестве действия триггера только функцию, определённую
пользователем. Стандарт допускает также выполнение ряда других команд SQL, например,
CREATE TABLE. Однако это ограничение несложно преодолеть, создав пользовательскую функ-
цию, выполняющую требуемые команды.
В стандарте SQL определено, что несколько триггеров должны срабатывать по порядку создания.
PostgreSQL упорядочивает их по именам, так как это было признано более удобным.
В стандарте SQL определено, что триггеры BEFORE DELETE при каскадном удалении срабатывают
после завершения каскадного DELETE. В PostgreSQL триггеры BEFORE DELETE всегда срабатывают
перед операцией удаления, даже если она каскадная. Это поведение выбрано как более логичное.
Ещё одно отклонение от стандарта проявляется, когда триггеры BEFORE, срабатывающие в резуль-
тате ссылочной операции, изменяют строки или не дают выполнить изменение. Это может приве-
сти к нарушению ограничений или сохранению данных, не соблюдающих ссылочную целостность.
Возможность задать несколько действий для одного триггера с помощью ключевого слова OR —
реализованное в PostgreSQL расширение стандарта SQL.
Возможность вызывать триггеры для TRUNCATE — реализованное в PostgreSQL расширение стан-
дарта SQL, как и возможность определять триггеры на уровне оператора для представлений.
CREATE CONSTRAINT TRIGGER — реализованное в PostgreSQL расширение стандарта SQL.
См. также
ALTER TRIGGER, DROP TRIGGER, CREATE FUNCTION, SET CONSTRAINTS
1556CREATE TYPE
CREATE TYPE — создать новый тип данных
Синтаксис
CREATE TYPE имя AS
( [ имя_атрибута тип_данных [ COLLATE правило_сортировки ] [, … ] ] )
CREATE TYPE имя AS ENUM
( [ ‘метка’ [, … ] ] )
CREATE TYPE имя AS RANGE (
SUBTYPE = подтип
[ , SUBTYPE_OPCLASS = класс_оператора_подтипа ]
[ , COLLATION = правило_сортировки ]
[ , CANONICAL = каноническая_функция ]
[ , SUBTYPE_DIFF = функция_разницы_подтипа ]
)
CREATE TYPE имя (
INPUT = функция_ввода,
OUTPUT = функция_вывода
[ , RECEIVE = функция_получения ]
[ , SEND = функция_отправки ]
[ , TYPMOD_IN = функция_ввода_модификатора_типа ]
[ , TYPMOD_OUT = функция_вывода_модификатора_типа ]
[ , ANALYZE = функция_анализа ]
[ , INTERNALLENGTH = ( внутр_длина | VARIABLE ) ]
[ , PASSEDBYVALUE ]
[ , ALIGNMENT = выравнивание ]
[ , STORAGE = хранение ]
[ , LIKE = тип_образец ]
[ , CATEGORY = категория ]
[ , PREFERRED = предпочитаемый ]
[ , DEFAULT = по_умолчанию ]
[ , ELEMENT = элемент ]
[ , DELIMITER = разделитель ]
[ , COLLATABLE = сортируемый ]
)
CREATE TYPE имя
Описание
CREATE TYPE регистрирует новый тип данных для использования в текущей базе данных. Владель-
цем типа становится создавший его пользователь.
Если указано имя схемы, тип создаётся в указанной схеме. В противном случае, он создаётся в
текущей схеме. Имя типа должно отличаться от имён любых других существующих типов или до-
менов в той же схеме. (А так как с таблицами связываются типы данных, имя типа должно также
отличаться и от имён существующих таблиц в этой схеме.)
Команда CREATE TYPE имеет пять форм, показанных выше в сводке синтаксиса. Они создают со-
ответственно составной тип, перечисление, диапазон, базовый тип или тип-пустышку. Первые
четыре эти типа рассматриваются по порядку ниже. Тип-пустышка представляет собой просто за-
готовку для типа, который будет определён позже; он создаётся командой CREATE TYPE с одним
1557CREATE TYPE
именем, без параметров. Типы-пустышки необходимы для определения прямых ссылок при созда-
нии базовых типов и типов-диапазонов, как описывается в соответствующих разделах.
Составные типы
Первая форма CREATE TYPE создаёт составной тип. Составной тип задаётся списком имён и типами
данных атрибутов. Если тип данных является сортируемым, то для атрибута можно также задать
правило сортировки. Составной тип по сути не отличается от типа строки таблицы, но CREATE TYPE
избавляет от необходимости создавать таблицу, когда всё, что нужно, это создать тип. Отдельный
составной тип может быть полезен, например, для передачи аргументов или результатов функции.
Чтобы создать составной тип, необходимо иметь право USAGE для типов всех его атрибутов.
Типы перечислений
Вторая форма CREATE TYPE создаёт тип-перечисление (такие типы описываются в Разделе  8.7).
Перечисления принимают список из одной или нескольких меток в кавычках, каждая не длиннее
NAMEDATALEN байт (64 байта в стандартной сборке PostgreSQL).
Диапазонные типы
Третья форма CREATE TYPE создаёт тип-диапазон (такие типы описываются в Разделе 8.17).
Задаваемый для диапазона подтип может быть любым типом со связанным классом операторов
B-дерева (что позволяет определить порядок значений в диапазоне). Обычно порядок элементов
определяет класс операторов B-дерева по умолчанию, но его можно изменить, задав имя другого
класса в параметре класс_операторов_подтипа. Если подтип поддерживает сортировку и требует-
ся, чтобы значения упорядочивались с нестандартным правилом сортировки, его имя можно за-
дать в параметре правило_сортировки.
Необязательная каноническая_функция должна принимать один аргумент определяемого типа
диапазона и возвращать значение того же типа. Это используется для преобразования значений
диапазона в каноническую форму, когда это уместно. За дополнительными сведениями обратитесь
к Подразделу 8.17.8. Создаётся каноническая_функция несколько нетривиально, так как она долж-
на быть уже определена, прежде чем можно будет объявить тип-диапазон. Для этого нужно сна-
чала создать тип-пустышку, который будет заготовкой типа, не имеющей никаких свойств, кроме
имени и владельца. Это можно сделать, выполнив команду CREATE TYPE имя без дополнительных
параметров. Затем можно объявить функцию, для которой тип-пустышка будет типом аргумента и
результата, и, наконец, объявить тип-диапазон с тем же именем. При этом тип-пустышка автома-
тически заменится полноценным типом-диапазоном.
Необязательная функция_разницы_подтипа должна принимать в аргументах два значения типа
подтип и возвращать значение double precision, представляющее разницу между двумя данны-
ми значениями. Хотя эту функцию можно не использовать, она позволяет кардинально увеличить
эффективность индексов GiST для столбцов с типом-диапазоном. За дополнительными сведениями
обратитесь к Подразделу 8.17.8.
Базовые типы
Четвёртая форма CREATE TYPE создаёт новый базовый тип (скалярный тип). Чтобы создать новый
базовый тип, нужно быть суперпользователем. (Это ограничение введено потому, что ошибочное
определение типа может вызвать нарушения или даже сбой в работе сервера.)
Эти параметры могут перечисляться в любом порядке, не только в показанном выше, и большин-
ство из них необязательные. Прежде чем создавать тип, необходимо зарегистрировать две или
более функций (с помощью CREATE FUNCTION). Обязательными являются функции функция_ввода
и функция_вывода, тогда как функция_получения, функция_отправки, функция_модификатора_типа,
функция_вывода_модификатора_типа и функция_анализа могут отсутствовать. Обычно эти функции
разрабатываются на C или другом низкоуровневом языке.
1558CREATE TYPE
Функция_ввода преобразует внешнее текстовое представление типа во внутреннее, с которым ра-
ботают операторы и функции, определённые для этого типа. Функция_вывода выполняет обратное
преобразование. Функцию ввода можно объявить как принимающую один аргумент типа cstring,
либо как принимающую три аргумента типов cstring, oid и integer. В первом аргументе переда-
ётся вводимый текст в виде строки в стиле C, во втором аргументе — собственный OID типа (кро-
ме типов массивов, для которых передаётся OID типа элемента), а в третьем — модификатор_ти-
па для целевого столбца, если он определён (или -1 в противном случае). Функция ввода должна
возвращать значение нового типа данных. Обычно функция ввода должна быть строгой (STRICT);
если это не так, при получении на вход значения NULL она будет вызываться с первым парамет-
ром NULL. Функция может в этом случае сама вернуть NULL или вызвать ошибку. (Это полезно в
основном для поддержки функций ввода доменных типов, которые не должны принимать данные
NULL.) Функция вывода должна принимать один аргумент нового типа данных, а возвращать она
должна cstring. Для значений NULL функции вывода не вызываются.
Необязательная функция_получения преобразует двоичное внешнее представление типа во внут-
реннее представление. Если эта функция отсутствует, новый тип не сможет участвовать в двоич-
ном вводе. Двоичное представление следует выбирать таким, чтобы оно легко переводилось во
внутреннюю форму и при этом было переносимым до разумной степени. (Например, для стандарт-
ных целочисленных типов данных во внешнем двоичном представлении выбран сетевой порядок
байтов, тогда как внутреннее представление определяется порядком байтов в процессоре.) Функ-
ция получения должна выполнить проверку вводимого значения на допустимость. Функция полу-
чения может быть объявлена как принимающая один аргумент типа internal, либо как принима-
ющая три аргумента типов internal, oid и integer. В первом аргументе передаётся указатель на
буфер StringInfo, содержащий полученную байтовую строку, а дополнительные аргументы такие
же, как и для функции ввода текста. Функция получения должна возвращать значение нового типа
данных. Обычно функция получения должна быть строгой (STRICT); если это не так, при получе-
нии на вход значения NULL, она будет вызываться с первым параметром NULL. Функция может
в этом случае сама вернуть NULL или вызывать ошибку. (Это полезно в основном для поддержки
функций получения доменных типов, которые не должны принимать значения NULL.) Подобным
образом, необязательная функция_отправки преобразует данные из внутреннего во внешнее дво-
ичное представление. Если эта функция не определена, новый тип не может участвовать в двоич-
ном выводе. Функция отправки должна принимать один аргумент нового типа данных, а возвра-
щать она должна bytea. Для значений NULL функции отправки не вызываются.
Здесь у вас может возникнуть вопрос, как функции ввода и вывода могут быть объявлены прини-
мающими или возвращающими значения нового типа, если они должны быть созданы до объяв-
ления нового типа. Ответ довольно прост: сначала нужно создать тип-пустышку, который будет
заготовкой типа, не имеющей никаких свойств, кроме имени и владельца. Это можно сделать, вы-
полнив команду CREATE TYPE имя без дополнительных параметров. Затем можно будет определить
функции ввода/вывода на C, ссылающиеся на этот тип. И наконец, команда CREATE TYPE с полным
определением заменит тип-пустышку окончательным и полноценным определением, после чего
новый тип можно будет использовать как обычно.
Необязательные функция_ввода_модификатора_типа и функция_вывода_модификатора_типа требу-
ются, только если типы поддерживают модификаторы, или, другими словами, дополнитель-
ные ограничения, связываемые с объявлением типа, например char(5) или numeric(30,2). В
PostgreSQL типы могут принимать в качестве модификаторов одну или несколько простых кон-
стант или идентификаторов. Однако эти данные должны упаковываться в единственное неотрица-
тельное целочисленное значение, которое и будет храниться в системных каталогах. Функция_в-
вода_модификатора_типа получает объявленные модификаторы в виде строки cstring. Она должна
проверить значения на допустимость (и вызвать ошибку, если они неверны), а затем выдать неот-
рицательное значение integer, которое будет сохранено в столбце «typmod». Если для типа не
определена функция_ввода_модификатора_типа, модификаторы типа приниматься не будут. Функ-
ция_вывода_модификатора_типа преобразует внутреннее целочисленное значение typmod обратно,
в форму, понятную пользователю. Она должна вернуть значение cstring, которое именно в этом
виде будет добавлено к имени типа; например, функция для numeric должна вернуть (30,2). Функ-
ция_вывода_модификатора_типа может быть опущена, в этом случае сохранённое целочисленное
значение typmod по умолчанию будет выводиться просто в виде числа, заключённого в скобки.
1559CREATE TYPE
Необязательная функция_анализа выполняет сбор специфической для этого типа статистики в
столбцах с таким типом данных. По умолчанию ANALYZE пытается собрать статистику, используя
операторы «равно» и «меньше», если для этого типа определён класс операторов B-дерева по умол-
чанию. Для нескалярных типов это поведение скорее всего не подойдёт, поэтому его можно пере-
определить, задав собственную функцию анализа. Эта функция должна принимать единственный
аргумент типа internal и возвращать результат boolean. Более глубоко API функций анализа опи-
сан в src/include/commands/vacuum.h.
Если особенности внутреннего представления нового типа известны функциям ввода/вывода и дру-
гим функциям, созданным специально для работы с этим типом, необходимо определить ряд ха-
рактеристик внутреннего представления, о которых должен знать PostgreSQL. В первую очередь
это internallength (внутренняя длина). Если базовый тип данных имеет фиксированную длину, в
internallength указывается эта длина в виде положительного числа, а если длина переменная,
в internallength задаётся значение VARIABLE. (Внутри при этом typlen принимает значение -1.)
Внутреннее представление всех типов переменной длины должно начинаться с 4-байтового цело-
го, задающего общую длину значения этого типа. (Заметьте, что поле длины часто кодируется, как
описано в Разделе 68.2; обращаться к нему напрямую неразумно.)
Необязательный флаг PASSEDBYVALUE указывает, что значения этого типа данных передаются по
значению, а не по ссылке. Типы, передаваемые по значению, должны быть фиксированной длины
и их внутреннее представление не может быть больше размера типа Datum (4 байта на одних ма-
шинах, 8 — на других).
Параметр выравнивание определяет, как требуется выравнивать данные этого типа. Допускается
выравнивание по границам 1, 2, 4 или 8 байт. Заметьте, что типы переменной длины должны быть
выровнены как минимум по границе 4 байт, так как их первым компонентом обязательно должен
быть int4.
Параметр хранение позволяет выбрать стратегию хранения для типов данных переменной длины.
(Для типов с фиксированной длиной поддерживается только вариант plain.) Если выбрана страте-
гия plain, данные этого типа всегда хранятся внутри, без сжатия. Со стратегией extended система
сначала попытается сжать большое значение, а затем выносит его из строки основной таблицы,
если оно всё же окажется слишком большим. С external значение может быть вынесено из основ-
ной таблицы, но система не будет пытаться сжать его. Стратегия main позволяет сжать данные, но
не стремится вынести их из основной таблицы. (Элементы данных с этой стратегией хранения, тем
не менее, могут быть вынесены из основной таблицы, если другого способа уместить их в строке
нет, но всё же она отдаёт большее предпочтение основной таблице, по сравнению со стратегиями
extended и external.)
Значения storage, отличные от plain, подразумевают, что функции типа данных могут принимать
значения в формате toast, описанном в Разделе 68.2 и Подразделе 38.12.1. Эти значения просто
определяют стратегию хранения TOAST по умолчанию для столбцов отделяемого в TOAST типа
данных; пользователи могут выбирать другие стратегии для отдельных столбцов, применяя коман-
ду ALTER TABLE SET STORAGE.
Параметр тип_образец позволяет задать основные свойства представления типа другим способом:
скопировать их из существующего типа. В частности, из указанного типа будут скопированы свой-
ства internallength, passedbyvalue, alignment и storage. (Также возможно, хотя обычно это не
требуется, переопределить некоторые из этих значений, указав их вместе с предложением LIKE.)
Определять представление типа таким образом особенно удобно, когда низкоуровневая реализа-
ция нового типа некоторым образом опирается на существующий тип.
Параметры категория и предпочитаемый позволяют определять, какое неявное приведение будет
применяться в неоднозначных ситуациях. Каждый тип данных принадлежит к некоторой катего-
рии, обозначаемой одним символом ASCII, при этом он может быть, либо не быть «предпочитае-
мым» в этой категории. Анализатор запроса по возможности выберет приведение к предпочитае-
мому типу (но только среди других типов той же категории), когда это может помочь разрешить
имя перегруженной функции или оператора. За дополнительными подробностями обратитесь к
1560CREATE TYPE
Главе 10. Если для типа не определено неявное приведение к какому-либо другому типу или об-
ратное, для этих параметров достаточно оставить значения по умолчанию. Однако если есть груп-
па связанных типов, для которых определены неявные приведения, часто бывает полезно поме-
тить их все как принадлежащие некоторой категории и назначить один или два «наиболее общих»
предпочитаемыми в этой категории. Параметр категория особенно полезен при добавлении типа,
определённого пользователем, в существующую встроенную категорию, например, в категорию
числовых или строковых типов. Однако так же возможно создать категории типов, полностью опре-
делённые пользователем. В качестве имени такой категории можно выбрать любой ASCII-символ,
кроме латинской заглавной буквы.
Если пользователь хочет назначить столбцам с этим типом данных значение по умолчанию, от-
личное от NULL, он может задать его в этой команде, указав его после ключевого слова DEFAULT.
(Такое значение по умолчанию можно переопределить явным предложением DEFAULT, добавлен-
ным при создании столбца.)
Чтобы обозначить, что тип является массивом, укажите тип элементов массива, добавив ключевое
слово ELEMENT. Например, чтобы определить массив из четырёхбайтовых целых (int4), укажите
ELEMENT = int4. Дополнительные сведения о типах массивов приведены ниже.
Параметр delimiter позволяет задать разделитель, который будет вставляться между значениями
во внешнем представлении массива с элементами этого типа. По умолчанию разделителем явля-
ется запятая (,). Заметьте, что разделитель связывается с типом элементов массива, а не с типом
самого массива.
Если необязательный логический параметр сортируемый равен true, определения столбцов и вы-
ражения с этим типом могут включать указания о порядке сортировки, в предложении COLLATE.
Как именно будут использоваться эти указания, зависит от реализации функций, работающих с
этим типом; эти указания не действуют автоматически просто от того, что тип помечен как сор-
тируемый.
Типы массивов
При создании любого нового типа PostgreSQL автоматически создаёт соответствующий тип мас-
сива, имя которого он получает, добавляя подчёркивание перед именем типа элементов. Если по-
лученное имя оказывается не короче NAMEDATALEN байт, оно усекается. (Если полученное таким
образом имя конфликтует с именем уже существующего типа, процесс повторяется, пока не бу-
дет получено уникальное имя.) Этот неявно создаваемый тип массива имеет переменную длину
и использует встроенные функции ввода и вывода array_in и array_out. Тип массива отражает
любые изменения владельца или схемы связанного типа элемента и удаляется сам при удалении
типа элемента.
Вы можете вполне резонно спросить, зачем нужен параметр ELEMENT, если система создаёт пра-
вильный тип массива автоматически. Единственный случай, когда параметр ELEMENT может быть
полезен, это когда вы создаёте тип фиксированной длины, который внутри оказывается массивом
одинаковых элементов, и вы хотите, чтобы к этим элементам можно было обращаться по индексу,
помимо того, что вы можете реализовать какие угодно операции с типом в целом. Например, тип
point представлен просто как два числа с плавающей точкой, к которым можно обратиться так:
point[0] и point[1]. Заметьте, что это работает только с типами фиксированной длины, которые
представляют собой в точности последовательность одинаковых полей фиксированной длины. Тип
массива переменной длины должен иметь обобщённое внутреннее представление, с которым уме-
ют работать array_in и array_out. По историческим причинам (т. е. это определённо некорректно,
но менять уже слишком поздно), индексы в массивах фиксированной длины начинаются с нуля,
а не с 1, как в массивах переменной длины.
Параметры
имя
Имя создаваемого типа (возможно, дополненное схемой).
1561CREATE TYPE
имя_атрибута
Имя атрибута (столбца) составного типа.
тип_данных
Имя существующего типа данных, который станет типом столбца составного типа.
правило_сортировки
Имя существующего правила сортировки, связываемого со столбцом составного типа или с
типом-диапазоном.
метка
Строковая константа, представляющая текстовую метку, связанную с отдельным значением
типа-перечисления.
подтип
Имя типа элемента, множество значений которого будет представлять тип-диапазон.
класс_оператора_подтипа
Имя класса операторов B-дерева для подтипа.
каноническая_функция
Имя функции канонизации для типа-диапазона.
функция_разницы_подтипа
Имя функции разницы для значений подтипа.
функция_ввода
Имя функции, преобразующей данные из внешнего текстового представления типа во внутрен-
нюю форму.
функция_вывода
Имя функции, преобразующей данные из внутренней формы во внешнее текстовое представ-
ление типа.
функция_получения
Имя функции, преобразующей данные из внешнего двоичного представления типа во внутрен-
нюю форму.
функция_отправки
Имя функции, преобразующей данные из внутренней формы во внешнее двоичное представле-
ние типа.
функция_ввода_модификатора_типа
Имя функции, преобразующей массив модификаторов типа во внутреннюю форму.
функция_вывода_модификатора_типа
Имя функции, преобразующей внутреннюю форму модификаторов типа во внешнее текстовое
представление.
функция_анализа
Имя функции, производящей статистический анализ типа данных.
1562CREATE TYPE
внутр_длина
Числовая константа, задающая размер внутреннего представления нового типа в байтах. По
умолчанию предполагается, что тип имеет переменную длину.
выравнивание
Требуемое выравнивание для типа данных. Допустимые значения этого параметра, если он
указывается: char, int2, int4 или double; по умолчанию подразумевается int4.
хранение
Стратегия хранения для типа данных. Допустимые значения этого параметра, если он указы-
вается: plain, external, extended или main; по умолчанию подразумевается plain.
тип_образец
Имя существующего типа данных, от которого новый тип получит свойства представления. Из
этого типа будут скопированы значения параметров internallength, passedbyvalue, alignment
и storage, если их не переопределят явные указания, заданные дополнительно в этой команде
CREATE TYPE.
категория
Код категории (один символ ASCII) для этого типа. По умолчанию подразумевается ‘U’ (что
означает пользовательский тип, «User-defined»). Коды других стандартных категорий можно
найти в Таблице 52.63. Для нестандартных категорий можно выбрать другие ASCII-символы.
предпочитаемый
Если значение этого параметра равно true, создаваемый тип будет предпочитаемым в своей ка-
тегории. По умолчанию подразумевается false. Будьте очень осторожны, создавая новый пред-
почитаемый тип в существующей категории, так как это может поменять поведение выраже-
ний неожиданным образом.
по_умолчанию
Значение по умолчанию для создаваемого типа данных. Если не указано, значением по умол-
чанию будет NULL.
элемент
Создаваемый тип будет массивом; этот параметр определяет тип элементов массива.
разделитель
Символ, разделяющий значения в массивах, образованных из значений создаваемого типа.
сортируемый
Если значение этого параметра равно true, в операциях с создаваемым типом может учиты-
ваться информация о правилах сортировки. По умолчанию подразумевается false.
Замечания
Так как на использование типа данных после создания не накладываются ограничения, объявле-
ние базового типа или типа-диапазона по сути даёт всем право на выполнение функций, упомяну-
тых в определении типа. Обычно это не проблема для таких функций, какие бывают полезны в
определении типов. Но прежде чем создать тип, преобразование которого во внешнюю форму и
обратно будет использовать «секретную» информацию, стоит подумать дважды.
В PostgreSQL до версии 8.3 имя генерируемого типа-массива всегда образовалось из имени типа
элемента и добавленного спереди символа подчёркивания (_). (Таким образом, допустимая мак-
симальная длина имени типа была на символ меньше, чем длины других имён.) Хотя и сейчас имя
типа массива чаще всего образуется таким образом, оно может быть и другим в случае достиже-
1563CREATE TYPE
ния максимальной длины или конфликтов с именами пользовательских типов, начинающихся с
подчёркивания. Поэтому полагаться на это соглашение в коде не рекомендуется. Вместо этого,
имя типа массива, связанного с данным типом, следует определять по значению pg_type.typarray.
Вообще же можно посоветовать не использовать имена типов и таблиц, начинающиеся с подчёр-
кивания. Хотя сервер сможет сгенерировать другое имя, не конфликтующее с пользовательским,
некоторая путаница всё же возможна, особенно со старыми клиентскими приложениями, которые
могут полагать, что имя типа, начинающееся с подчёркивания, всегда относится к типу массива.
В PostgreSQL до версии 8.2 у CREATE TYPE name отсутствовала форма для создания типа-пустышки.
Поэтому для создания нового базового типа требовалось сначала создать функцию ввода. При та-
ком подходе PostgreSQL воспринимал тип возврата функции ввода как имя нового типа данных и
неявно создавал тип-пустышку, на который затем можно было ссылаться в определениях осталь-
ных функций ввода/вывода. Этот подход по-прежнему работает, но считается устаревшим и может
быть запрещён в будущих версиях. Кроме того, во избежание непреднамеренного заполнения ка-
талогов типами-пустышками, появляющимися в результате простых опечаток в определении функ-
ций, тип-пустышка будет создаваться таким образом, только если функция ввода написана на C.
В PostgreSQL до версии 7.3 было принято вовсе не создавать тип-пустышку, заменяя в определе-
нии функций ссылки на ещё не созданный тип именем псевдотипа opaque. Аргументы cstring и
результаты так же должны были объявляться как opaque до версии 7.3. Для поддержки загрузки
старых файлов экспорта БД, CREATE TYPE примет ссылки на функции ввода/вывода, объявленные
с типом opaque, но при этом выдаст замечание и изменит в объявлении функции псевдотип на
правильный.
Примеры
В этом примере создаётся составной тип, а затем он используется в определении функции:
CREATE TYPE compfoo AS (f1 int, f2 text);
CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS <script type="math/tex">SELECT fooid, fooname FROM foo</script> LANGUAGE SQL;
В этом примере создаётся тип-перечисление, а затем он используется в определении таблицы:
CREATE TYPE bug_status AS ENUM (‘new’, ‘open’, ‘closed’);
CREATE TABLE bug (
id serial,
description text,
status bug_status
);
В этом примере создаётся тип-диапазон:
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
В следующем примере создаётся базовый тип данных box, а затем он используется в определении
таблицы:
CREATE TYPE box;
CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS … ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS … ;
CREATE TYPE box (
INTERNALLENGTH = 16,
INPUT = my_box_in_function,
OUTPUT = my_box_out_function
1564CREATE TYPE
);
CREATE TABLE myboxes (
id integer,
description box
);
Если бы внутренней структурой box был массив из четырёх элементов float4, вместо этого можно
было бы использовать определение:
CREATE TYPE box (
INTERNALLENGTH = 16,
INPUT = my_box_in_function,
OUTPUT = my_box_out_function,
ELEMENT = float4
);
В таком случае к числам, составляющим значение этого типа, можно было бы обращаться по ин-
дексу. В остальном поведение этого типа будет таким же.
В этом примере создаётся тип большого объекта, а затем он используется в определении таблицы:
CREATE TYPE bigobj (
INPUT = lo_filein, OUTPUT = lo_fileout,
INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
id integer,
obj bigobj
);
Другие примеры, в том числе демонстрирующие подходящие функции ввода/вывода, можно найти
в Разделе 38.12.
Совместимость
Первая форма команды CREATE TYPE, создающая составной тип, соответствует стандарту SQL.
Другие формы являются расширениями PostgreSQL. Для оператора CREATE TYPE в стандарте SQL
также определены другие формы, не реализованные в PostgreSQL.
Возможность создавать составной тип без атрибутов — специфическое отклонение PostgreSQL от
стандарта (как и аналогичная особенность команды CREATE TABLE).
См. также
ALTER TYPE, CREATE DOMAIN, CREATE FUNCTION, DROP TYPE
1565CREATE USER
CREATE USER — создать роль в базе данных
Синтаксис
CREATE USER имя [ [ WITH ] параметр [ … ] ]
Здесь параметр:
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
SUPERUSER | NOSUPERUSER
CREATEDB | NOCREATEDB
CREATEROLE | NOCREATEROLE
INHERIT | NOINHERIT
LOGIN | NOLOGIN
REPLICATION | NOREPLICATION
BYPASSRLS | NOBYPASSRLS
CONNECTION LIMIT предел_подключений
[ ENCRYPTED ] PASSWORD ‘пароль’
VALID UNTIL ‘дата_время’
IN ROLE имя_роли [, …]
IN GROUP имя_роли [, …]
ROLE имя_роли [, …]
ADMIN имя_роли [, …]
USER имя_роли [, …]
SYSID uid
Описание
Команда CREATE USER теперь является просто синонимом CREATE ROLE. Единственное отличие в
том, что для команды, записанной в виде CREATE USER, по умолчанию подразумевается LOGIN, а в
виде CREATE ROLE подразумевается NOLOGIN.
Совместимость
Оператор CREATE USER является расширением PostgreSQL. В стандарте SQL определение пользо-
вателей считается зависимым от реализации.
См. также
CREATE ROLE
1566CREATE USER MAPPING
CREATE USER MAPPING — создать сопоставление пользователя для стороннего сервера
Синтаксис
CREATE USER MAPPING [ IF NOT EXISTS ] FOR ( имя_пользователя | USER | CURRENT_USER |
PUBLIC )
SERVER имя_сервера
[ OPTIONS ( параметр ‘значение’ [ , … ] ) ]
Описание
CREATE USER MAPPING создаёт сопоставление пользователя на внешнем сервере. Сопоставление
пользователя обычно содержит информацию о подключении, которую будет использовать обёртка
сторонних данных вместе с информацией о стороннем сервере для получения доступа к внешнему
ресурсу.
Владелец стороннего сервера может создать сопоставление для любых пользователей на этом сер-
вере. Кроме того, пользователь может создать сопоставление для своего собственного имени поль-
зователя, если он наделён правом USAGE на данном сервере.
Параметры
IF NOT EXISTS
Не считать ошибкой, если сопоставление данного пользователя для данного стороннего серве-
ра уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии,
что существующее сопоставление как-то соотносится с тем, которое могло бы быть создано.
имя_пользователя
Имя существующего пользователя, для которого создаётся сопоставление на стороннем серве-
ре. Ключевые слова CURRENT_USER и USER обозначают имя текущего пользователя. Если указы-
вается PUBLIC, создаётся так называемое общее сопоставление, которое будет использоваться
при отсутствии сопоставления для конкретного пользователя.
имя_сервера
Имя существующего сервера, для которого создаётся сопоставление пользователя.
OPTIONS ( параметр ‘значение’ [, … ] )
В этом предложении задаются параметры сопоставления. Эти параметры обычно определяют
фактическое имя и пароль пользователя на целевом сервере. Имена параметров должны быть
уникальными. Набор допустимых имён и значений параметров определяется обёрткой сторон-
них данных внешнего сервера.
Примеры
Создание сопоставления для пользователя bob на сервере foo:
CREATE USER MAPPING FOR bob SERVER foo OPTIONS (user ‘bob’, password ‘secret’);
Совместимость
CREATE USER MAPPING соответствует стандарту ISO/IEC 9075-9 (SQL/MED).
См. также
ALTER USER MAPPING, DROP USER MAPPING, CREATE FOREIGN DATA WRAPPER, CREATE SERVER
1567CREATE VIEW
CREATE VIEW — создать представление
Синтаксис
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW имя [ ( имя_столбца
[, …] ) ]
[ WITH ( имя_параметра_представления [= значение_параметра_представления]
[, … ] ) ]
AS запрос
[ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
Описание
CREATE VIEW создаёт представление запроса. Создаваемое представление лишено физической ма-
териализации, поэтому указанный запрос будет выполняться при каждом обращении к представ-
лению.
Команда CREATE OR REPLACE VIEW действует подобным образом, но если представление с этим
именем уже существует, оно заменяется. Новый запрос должен выдавать те же столбцы, что выда-
вал запрос, ранее определённый для этого представления (то есть, столбцы с такими же именами
должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько
новых столбцов в конце списка. Вычисления, в результате которых формируются столбцы пред-
ставления, могут быть совершенно другими.
Если задано имя схемы (например, CREATE VIEW myschema.myview …), представление создаётся
в указанной схеме, в противном случае — в текущей. Временные представления существуют в
специальной схеме, так что при создании таких представлений имя схемы задать нельзя. Имя
представления должно отличаться от имён других представлений, таблиц, последовательностей,
индексов или сторонних таблиц в этой схеме.
Параметры
TEMPORARY или TEMP
С таким указанием представление создаётся как временное. Временные представления авто-
матически удаляются в конце сеанса. Существующее постоянное представление с тем же име-
нем не будет видно в текущем сеансе, пока существует временное, однако к нему можно обра-
титься, дополнив имя указанием схемы.
Если в определении представления задействованы временные таблицы, представление так же
создаётся как временное (вне зависимости от присутствия явного указания TEMPORARY).
RECURSIVE
Создаёт рекурсивное представление. Синтаксис
CREATE RECURSIVE VIEW [ схема . ] имя (имена_столбцов) AS SELECT …;
равнозначен
CREATE VIEW [ схема . ] имя AS WITH RECURSIVE имя (имена_столбцов) AS (SELECT …)
SELECT имена_столбцов FROM имя;
Для рекурсивного представления обязательно должен задаваться список с именами столбцов.
имя
Имя создаваемого представления (возможно, дополненное схемой).
1568CREATE VIEW
имя_столбца
Необязательный список имён, назначаемых столбцам представления. Если отсутствует, имена
столбцов формируются из результатов запроса.
WITH ( имя_параметра_представления [= значение_параметра_представления] [, … ] )
В этом предложении могут задаваться следующие необязательные параметры представления:
check_option (string)
Этот параметр может принимать значение local (локально) или cascaded (каскадно) и рав-
нозначен указанию WITH [ CASCADED | LOCAL ] CHECK OPTION (см. ниже). Изменить этот
параметр у существующего представления с помощью ALTER VIEW нельзя.
security_barrier (boolean)
Этот параметр следует использовать, если представление должно обеспечивать безопас-
ность на уровне строк. За дополнительными подробностями обратитесь к Разделу 41.5.
запрос
Команда SELECT или VALUES, которая выдаёт столбцы и строки представления.
WITH [ CASCADED | LOCAL ] CHECK OPTION
Это указание управляет поведением автоматически изменяемых представлений. Если оно при-
сутствует, при выполнении операций INSERT и UPDATE с этим представлением будет проверять-
ся, удовлетворяют ли новые строки условию, определяющему представление (то есть, проверя-
ется, будут ли новые строки видны через это представление). Если они не удовлетворяют усло-
вию, операция не будет выполнена. Если указание CHECK OPTION отсутствует, команды INSERT
и UPDATE смогут создавать в этом представлении строки, которые не будут видны в нём. Под-
держиваются следующие варианты проверки:
LOCAL
Новые строки проверяются только по условиям, определённым непосредственно в самом
представлении. Любые условия, определённые в нижележащих базовых представлениях, не
проверяются (если только в них нет указания CHECK OPTION).
CASCADED
Новые строки проверяются по условиям данного представления и всех нижележащих базо-
вых. Если указано CHECK OPTION, а LOCAL и CASCADED опущено, подразумевается указание
CASCADED.
Указание CHECK OPTION нельзя использовать с рекурсивными представлениями.
Заметьте, что CHECK OPTION поддерживается только для автоматически изменяемых представ-
лений, не имеющих триггеров INSTEAD OF и правил INSTEAD. Если автоматически изменяемое
представление определено поверх базового представления с триггерами INSTEAD OF, то для
проверки ограничений автоматически изменяемого представления можно применить указание
LOCAL CHECK OPTION, хотя условия базового представления с триггерами INSTEAD OF при этом
проверяться не будут (каскадная проверка не будет спускаться к представлению, модифици-
руемому триггером, и любые параметры проверки, определённые для такого представления,
будут просто игнорироваться). Если для представления или любого из его базовых отношений
определено правило INSTEAD, приводящее к перезаписи команды INSERT или UPDATE, в переза-
писанном запросе все параметры проверки будут игнорироваться, в том числе проверки авто-
матически изменяемых представлений, определённых поверх отношений с правилом INSTEAD.
Замечания
Для удаления представлений применяется оператор DROP VIEW.
1569CREATE VIEW
Позаботьтесь о том, чтобы столбцы представления получили желаемые имена и типы. Например,
такая команда:
CREATE VIEW vista AS SELECT ‘Hello World’;
плоха тем, что именем столбца по умолчанию будет ?column?, а типом данных — text; и это может
быть не совсем то, чего вы хотите. Лучше записывать строковую константу в результате представ-
ления примерно так:
CREATE VIEW vista AS SELECT text ‘Hello World’ AS hello;
Доступ к таблицам, задействованным в представлении, определяется правами владельца представ-
ления. В некоторых случаях это позволяет организовать безопасный, но ограниченный доступ к
нижележащим таблицам. Однако учтите, что не все представления могут быть защищёнными; за
подробностями обратитесь к Разделу 41.5. Функции, вызываемые в представлении, выполняются
так, как будто они вызываются непосредственно из запроса, обращающегося к представлению.
Поэтому пользователь представления должен иметь все права, необходимые для вызова всех функ-
ций, задействованных в представлении.
При выполнении CREATE OR REPLACE VIEW для существующего представления меняется только пра-
вило SELECT, определяющее представление. Другие свойства представления, включая владельца,
права и правила, кроме SELECT, остаются неизменными. Чтобы изменить определение представ-
ления, необходимо быть его владельцем (или членом роли-владельца).
Изменяемые представления
Простые представления становятся изменяемыми автоматически: система позволит выполнять
команды INSERT, UPDATE и DELETE с таким представлением так же, как и с обычной таблицей. Пред-
ставление будет автоматически изменяемым, если оно удовлетворяют одновременно всем следу-
ющим условиям:
• Список FROM в запросе, определяющем представлении, должен содержать ровно один эле-
мент, и это должна быть таблица или другое изменяемое представление.
• Определение представления не должно содержать предложения WITH, DISTINCT, GROUP BY,
HAVING, LIMIT и OFFSET на верхнем уровне запроса.
• Определение представления не должно содержать операции с множествами (UNION, INTERSECT
и EXCEPT) на верхнем уровне запроса.
• Список выборки в запросе не должен содержать агрегатные и оконные функции, а также
функции, возвращающие множества.
Автоматически обновляемое представление может содержать как изменяемые, так и не изменяе-
мые столбцы. Столбец будет изменяемым, если это простая ссылка на изменяемый столбец ниже-
лежащего базового отношения; в противном случае, этот столбец будет доступен только для чте-
ния, и если команда INSERT или UPDATE попытается записать значение в него, возникнет ошибка.
Если представление автоматически изменяемое, система будет преобразовывать обращающиеся
к нему операторы INSERT, UPDATE и DELETE в соответствующие операторы, обращающиеся к ниже-
лежащему базовому отношению. При этом в полной мере поддерживаются операторы INSERT с
предложением ON CONFLICT UPDATE.
Если автоматически изменяемое представление содержит условие WHERE, это условие ограничива-
ет набор строк, которые могут быть изменены командой UPDATE и удалены командой DELETE в этом
представлении. Однако UPDATE может изменить строку так, что она больше не будет соответство-
вать условию WHERE и, как следствие, больше не будет видна через представление. Команда INSERT
подобным образом может вставить в базовое отношение строки, которые не удовлетворят условию
WHERE и поэтому не будут видны через представление (ON CONFLICT UPDATE может подобным обра-
зом воздействовать на существующую строку, не видимую через представление). Чтобы запретить
командам INSERT и UPDATE создавать такие строки, которые не видны через представление, можно
воспользоваться указанием CHECK OPTION.
1570CREATE VIEW
Если автоматически изменяемое представление имеет свойство security_barrier (барьер без-
опасности), то все условия WHERE этого представления (и все условия с герметичными операторами
(LEAKPROOF)) будут всегда вычисляться перед условиями, добавленными пользователем представ-
ления. За подробностями обратитесь к Разделу 41.5. Заметьте, что по этой причине строки, кото-
рые в конце концов не были выданы (потому что не прошли проверку в пользовательском условии
WHERE), могут всё же остаться заблокированными. Чтобы определить, какие условия применяются
на уровне отношения (и, как следствие, избавляют часть строк от блокировки), можно воспользо-
ваться командой EXPLAIN.
Более сложные представления, не удовлетворяющие этим условиям, по умолчанию доступны толь-
ко для чтения: система не позволит выполнить операции добавления, изменения или удаления
строк в таком представлении. Создать эффект изменяемого представления для них можно, опреде-
лив триггеры INSTEAD OF, которые будут преобразовывать запросы на изменение данных в соответ-
ствующие действия с другими таблицами. За дополнительными сведениями обратитесь к CREATE
TRIGGER. Так же есть возможность создавать правила (см. CREATE RULE), но на практике тригге-
ры проще для понимания и применения.
Учтите, что пользователь, выполняющий операции добавления, изменения или удаления данных в
представлении, должен иметь соответствующие права для этого представления. Кроме того, вла-
делец представления должен иметь сопутствующие права в нижележащих базовых отношениях,
хотя пользователь, собственно выполняющий эти операции, может этих прав не иметь (см. Раз-
дел 41.5).
Примеры
Создание представления, содержащего все комедийные фильмы:
CREATE VIEW comedies AS
SELECT *
FROM films
WHERE kind = ‘Comedy’;
Эта команда создаст представление со столбцами, которые содержались в таблице film в момент
выполнения команды. Хотя при создании представления было указано *, столбцы, добавляемые в
таблицу позже, частью представления не будут.
Создание представления с указанием LOCAL CHECK OPTION:
CREATE VIEW universal_comedies AS
SELECT *
FROM comedies
WHERE classification = ‘U’
WITH LOCAL CHECK OPTION;
Эта команда создаст представление на базе представления comedies, выдающее только коме-
дии (kind = ‘Comedy’) универсальной возрастной категории classification = ‘U’. Любая по-
пытка выполнить в представлении INSERT или UPDATE со строкой, не удовлетворяющей условию
classification = ‘U’, будет отвергнута, но ограничение по полю kind (тип фильма) проверяться
не будет.
Создание представления с указанием CASCADED CHECK OPTION:
CREATE VIEW pg_comedies AS
SELECT *
FROM comedies
WHERE classification = ‘PG’
WITH CASCADED CHECK OPTION;
Это представление будет проверять, удовлетворяют ли новые строки обоим условиям: по столбцу
kind и по столбцу classification.
Создание представления с изменяемыми и неизменяемыми столбцами:
1571CREATE VIEW
CREATE VIEW comedies AS
SELECT f.</em>,
country_code_to_name(f.country_code) AS country,
(SELECT avg(r.rating)
FROM user_ratings r
WHERE r.film_id = f.id) AS avg_rating
FROM films f
WHERE f.kind = ‘Comedy’;
Это представление будет поддерживать операции INSERT, UPDATE и DELETE. Изменяемыми будут все
столбцы из таблицы films, тогда как вычисляемые столбцы country и avg_rating будут доступны
только для чтения.
Создание рекурсивного представления, содержащего числа от 1 до 100:
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
VALUES (1)
UNION ALL
SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
Заметьте, что несмотря на то, что имя рекурсивного представления дополнено схемой в этой ко-
манде CREATE, внутренняя ссылка представления на себя же схемой не дополняется. Это связано
с тем, что имя неявно создаваемого CTE не может дополняться схемой.
Совместимость
Команда CREATE OR REPLACE VIEW — языковое расширение PostgreSQL. Так же расширением яв-
ляется предложение WITH ( … ) и концепция временного представления.
См. также
ALTER VIEW, DROP VIEW, CREATE MATERIALIZED VIEW
1572DEALLOCATE
DEALLOCATE — освободить подготовленный оператор
Синтаксис
DEALLOCATE [ PREPARE ] ( имя | ALL )
Описание
DEALLOCATE применяется для освобождения ранее подготовленного оператора SQL. Если не осво-
бодить подготовленный оператор явно, он будет освобождён при завершении сеанса.
За дополнительными сведениями о подготовленных операторах обратитесь к PREPARE.
Параметры
PREPARE
Это ключевое слово игнорируется.
имя
Имя подготовленного оператора, подлежащего освобождению.
ALL
Освобождает все подготовленные операторы.
Совместимость
В стандарте SQL есть оператор DEALLOCATE, но он предназначен только для применения во встра-
иваемом SQL.
См. также
EXECUTE, PREPARE
1573DECLARE
DECLARE — определить курсор
Синтаксис
DECLARE имя [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
CURSOR [ ( WITH | WITHOUT ) HOLD ] FOR запрос
Описание
Оператор DECLARE позволяет пользователю создавать курсоры, с помощью которых можно выби-
рать по очереди некоторое количество строк из результата большого запроса. Когда курсор со-
здан, через него можно получать строки, применяя команду FETCH.
Примечание
На этой странице описывается применение курсоров на уровне команд SQL. Если вы
попытаетесь использовать курсоры внутри функции PL/pgSQL, правила будут другими
— см. Раздел 43.7.
Параметры
имя
Имя создаваемого курсора.
BINARY
Курсор с таким свойством возвращает данные в двоичном, а не текстовом формате.
INSENSITIVE
Указывает, что данные, считываемые из курсора, не должны зависеть от изменений, которые
могут происходить в нижележащих таблицах после создания курсора. В PostgreSQL это пове-
дение подразумевается по умолчанию, так что это ключевое слово ни на что не влияет и при-
нимается только для совместимости со стандартом SQL.
SCROLL
NO SCROLL
Указание SCROLL определяет, что курсор может прокручивать набор данных и получать строки
непоследовательно (например, в обратном порядке). В зависимости от сложности плана запро-
са указание SCROLL может отрицательно отразиться на скорости выполнения запроса. Указа-
ние NO SCROLL, напротив, определяет, что через курсор нельзя будет получать строки в произ-
вольном порядке. По умолчанию прокрутка в некоторых случаях разрешается; но это не рав-
нозначно эффекту указания SCROLL. За подробностями обратитесь к Разделу «Замечания».
WITH HOLD
WITHOUT HOLD
Указание WITH HOLD определяет, что курсор можно продолжать использовать после успешной
фиксации создавшей его транзакции. WITHOUT HOLD определяет, что курсор нельзя будет ис-
пользовать за рамками транзакции, создавшей его. Если не указано ни WITHOUT HOLD, ни WITH
HOLD, по умолчанию подразумевается WITHOUT HOLD.
запрос
Команда SELECT или VALUES, выдающая строки, которые будут получены через курсор.
1574DECLARE
Ключевые слова BINARY, INSENSITIVE и SCROLL могут указываться в любом порядке.
Замечания
Обычный курсор выдаёт данные в текстовом виде, в каком их выдаёт SELECT. Однако с указанием
BINARY курсор может выдавать их и в двоичном формате. Это упрощает операции преобразования
данных для сервера и клиента, за счёт дополнительных усилий, требующихся от программиста для
работы с платформозависимыми двоичными форматами. Например, если запрос получает значе-
ние 1 из целочисленного столбца, обычный курсор выдаст строку, содержащую 1, тогда как через
двоичный курсор будет получено четырёхбайтовое поле, содержащее внутреннее представление
значения (с сетевым порядком байтов).
Двоичные курсоры должны применяться с осмотрительностью. Многие приложения, в том числе
psql, не приспособлены к работе с двоичными курсорами и ожидают, что данные будут поступать
в текстовом формате.
Примечание
Когда клиентское приложение выполняет команду FETCH, используя протокол «расши-
ренных запросов», в сообщении Bind этого протокола указывается, в каком формате,
текстовом или двоичном, должны быть получены данные. Это указание переопределя-
ет свойство курсора, заданное в его объявлении. Таким образом, концепция курсора,
объявляемого двоичным, становится устаревшей при использовании протокола расши-
ренных запросов — любой курсор может быть прочитан как текстовый или двоичный.
Если в команде объявления курсора не указано WITH HOLD, созданный ей курсор может использо-
ваться только в текущей транзакции. Таким образом, оператор DECLARE без WITH HOLD бесполезен
вне блока транзакции: курсор будет существовать только до завершения этого оператора. Поэтому
PostgreSQL сообщает об ошибке, если такая команда выполняется вне блока транзакции. Чтобы
определить блок транзакции, примените команды BEGIN и COMMIT (или ROLLBACK).
Если в объявлении курсора указано WITH HOLD и транзакция, создавшая курсор, успешно фиксиру-
ется, к этому курсору могут продолжать обращаться последующие транзакции в этом сеансе. (Но
если создавшая курсор транзакция прерывается, курсор уничтожается.) Курсор со свойством WITH
HOLD (удерживаемый) может быть закрыт явно, командой CLOSE, либо неявно, по завершении сеан-
са. В текущей реализации строки, представляемые удерживаемым курсором, копируются во вре-
менный файл или в область памяти, так что они остаются доступными для следующих транзакций.
Объявить курсор со свойством WITH HOLD можно, только если запрос не содержит указаний FOR
UPDATE и FOR SHARE.
Указание SCROLL добавляется при определении курсора, который будет выбирать данные в обрат-
ном порядке. Это поведение требуется стандартом SQL. Однако для совместимости с предыдущи-
ми версиями, PostgreSQL допускает выборку в обратном направлении и без указания SCROLL, если
план запроса курсора достаточно прост, чтобы реализовать прокрутку назад без дополнительных
операций. Тем не менее, разработчикам приложений не следует рассчитывать на то, что курсор,
созданный без указания SCROLL, можно будет прокручивать назад. С указанием NO SCROLL про-
крутка назад запрещается в любом случае.
Выборка в обратном направлении также запрещается, если запрос содержит указания FOR UPDATE
и FOR SHARE; в этом случае указание SCROLL не принимается.
Внимание
Прокручиваемые и удерживаемые (WITH HOLD) курсоры могут выдавать неожиданные
результаты, если они вызывают изменчивые функции (см. Раздел 38.7). Когда повторно
выбирается ранее прочитанная строка, функции могут вызываться снова и выдавать
1575DECLARE
результаты, отличные от полученных в первый раз. Один из способов обойти эту про-
блему — объявить курсор с указанием WITH HOLD и зафиксировать транзакцию, прежде
чем читать из него какие-либо строки. В этом случае весь набор данных курсора будет
материализован во временном хранилище, так что изменчивые функции будут выпол-
нены для каждой строки лишь единожды.
Если запрос в определении курсора включает указания FOR UPDATE или FOR SHARE, возвращаемые
курсором строки блокируются в момент первой выборки, так же, как это происходит при выпол-
нении SELECT с этими указаниями. Кроме того, при чтении строк будут возвращаться их наибо-
лее актуальные версии; таким образом, с этими указаниями курсор будет вести себя как «чувстви-
тельный курсор», определённый в стандарте SQL. (Указать INSENSITIVE для курсора с запросом
FOR UPDATE или FOR SHARE нельзя.)
Внимание
Обычно рекомендуется использовать FOR UPDATE, если курсор предназначается для
применения в командах UPDATE … WHERE CURRENT OF и DELETE … WHERE CURRENT OF.
Указание FOR UPDATE предотвращает изменение строк другими сеансами после того,
как они были считаны, и до того, как выполнится команда. Без FOR UPDATE последу-
ющая команда с WHERE CURRENT OF не сработает, если строка будет изменена после
создания курсора.
Ещё одна причина использовать указание FOR UPDATE в том, что без него последующие
команды с WHERE CURRENT OF могут выдать ошибку, если запрос курсора не удовлетво-
ряет оговоренному в стандарте SQL критерию «простой изменяемости» (в частности,
курсор должен ссылаться только на одну таблицу и не должен использовать группи-
ровку и сортировку (ORDER BY)). Курсоры, не удовлетворяющие этому критерию, могут
работать либо не работать, в зависимости от конкретного выбранного плана; так что в
худшем случае приложение может работать в тестовой, но сломается в производствен-
ной среде. С указанием FOR UPDATE курсор гарантированно будет изменяемым.
Не использовать же FOR UPDATE для команд с WHERE CURRENT OF в основном имеет смысл,
только если требуется получить прокручиваемый курсор или курсор, не отражающий
последующие изменения (то есть, продолжающий показывать прежние данные). Если
это действительно необходимо, обязательно учтите при реализации приведённые выше
замечания.
В стандарте SQL механизм курсоров предусмотрен только для встраиваемого SQL. Сервер
PostgreSQL не реализует для курсоров оператор OPEN; курсор считается открытым при объявлении.
Однако ECPG, встраиваемый препроцессор SQL для PostgreSQL, следует соглашениям стандарта,
в том числе поддерживая для курсоров операторы DECLARE и OPEN.
Получить список всех доступных курсоров можно, обратившись к системному представлению
pg_cursors.
Примеры
Объявление курсора:
DECLARE liahona CURSOR FOR SELECT * FROM films;
Другие примеры использования курсора можно найти в FETCH.
Совместимость
В стандарте SQL говорится, что чувствительность курсоров к параллельному обновлению ниже-
лежащих данных по умолчанию определяется реализацией. В PostgreSQL курсоры по умолчанию
1576DECLARE
нечувствительные, а чувствительными их можно сделать с помощью указания FOR UPDATE. Другие
СУБД могут работать иначе.
Стандарт SQL допускает курсоры только во встраиваемом SQL и в модулях. PostgreSQL позволяет
использовать курсоры интерактивно.
Двоичные курсоры являются расширением PostgreSQL.
См. также
CLOSE, FETCH, MOVE
1577DELETE
DELETE — удалить записи таблицы
Синтаксис
[ WITH [ RECURSIVE ] запрос_WITH [, …] ]
DELETE FROM [ ONLY ] имя_таблицы [ * ] [ [ AS ] псевдоним ]
[ USING список_USING ]
[ WHERE условие | WHERE CURRENT OF имя_курсора ]
[ RETURNING * | выражение_результата [ [ AS ] имя_результата ] [, …] ]
Описание
Команда DELETE удаляет из указанной таблицы строки, удовлетворяющие условию WHERE. Если
предложение WHERE отсутствует, она удаляет из таблицы все строки, в результате будет получена
рабочая, но пустая таблица.
Подсказка
TRUNCATE реализует более быстрый механизм удаления всех строк из таблицы.
Удалить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя
способами: применяя вложенные запросы или указав дополнительные таблицы в предложении
USING. Выбор предпочитаемого варианта зависит от конкретных обстоятельств.
Предложение RETURNING указывает, что команда DELETE должна вычислить и возвратить значения
для каждой фактически удалённой строки. Вычислить в нём можно любое выражение со столбца-
ми целевой таблицы и/или столбцами других таблиц, упомянутых в USING. Список RETURNING имеет
тот же синтаксис, что и список результатов SELECT.
Чтобы удалять данные из таблицы, необходимо иметь право DELETE для неё, а также право SELECT
для всех таблиц, перечисленных в предложении USING, и таблиц, данные которых считываются в
условии.
Параметры
запрос_WITH
Предложение WITH позволяет задать один или несколько подзапросов, на которые затем можно
ссылаться по имени в запросе DELETE. Подробнее об этом см. Раздел 7.8 и SELECT.
имя_таблицы
Имя (возможно, дополненное схемой) таблицы, из которой будут удалены строки. Если перед
именем таблицы добавлено ONLY, соответствующие строки удаляются только из указанной таб-
лицы. Без ONLY строки будут также удалены из всех таблиц, унаследованных от указанной. При
желании, после имени таблицы можно указать *, чтобы явно обозначить, что операция затра-
гивает все дочерние таблицы.
псевдоним
Альтернативное имя целевой таблицы. Когда указывается это имя, оно полностью скрывает
фактическое имя таблицы. Например, в запросе DELETE FROM foo AS f дополнительные ком-
поненты оператора DELETE должны обращаться к целевой таблице по имени f, а не foo.
список_USING
Список табличных выражений, позволяющий добавлять в условие WHERE столбцы из других таб-
лиц. Он подобен списку таблиц, который можно задать в предложении «Предложение FROM»
1578DELETE
оператора SELECT; например, в нём можно определить псевдоним для таблицы. Целевую табли-
цу повторять в списке_USING нужно, только если требуется определить замкнутое соединение.
условие
Выражение, возвращающее значение типа boolean. Удалены будут только те строки, для кото-
рых это выражение возвращает true.
имя_курсора
Имя курсора, который будет использоваться в условии WHERE CURRENT OF. С таким условием
будет удалена строка, выбранная из этого курсора последней. Курсор должен образовываться
запросом, не применяющим группировку, к целевой таблице команды DELETE. Заметьте, что
WHERE CURRENT OF нельзя задать вместе с булевским условием. За дополнительными сведениями
об использовании курсоров с WHERE CURRENT OF обратитесь к DECLARE.
выражение_результата
Выражение, которое будет вычисляться и возвращаться командой DELETE после удаления каж-
дой строки. В этом выражении можно использовать имена любых столбцов таблицы имя_таб-
лицы или таблиц, перечисленных в списке USING. Чтобы получить все столбцы, достаточно на-
писать *.
имя_результата
Имя, назначаемое возвращаемому столбцу.
Выводимая информация
В случае успешного завершения, DELETE возвращает метку команды в виде
DELETE число
Здесь число — количество удалённых строк. Заметьте, что это число может быть меньше числа
строк, соответствующих условию, если удаления были подавлены триггером BEFORE DELETE. Если
число равно 0, это означает, что запрос не удалил ни одной строки (это не считается ошибкой).
Если команда DELETE содержит предложение RETURNING, её результат будет похож на результат
оператора SELECT (с теми же столбцами и значениями, что содержатся в списке RETURNING), полу-
ченный для строк, удалённых этой командой.
Замечания
PostgreSQL позволяет ссылаться на столбцы других таблиц в условии WHERE, когда эти таблицы
перечисляются в предложении USING. Например, удалить все фильмы определённого продюсера
можно так:
DELETE FROM films USING producers
WHERE producer_id = producers.id AND producers.name = ‘foo’;
По сути в этом запросе выполняется соединение таблиц films и producers, и все успешно вклю-
чённые в соединение строки в films помечаются для удаления. Этот синтаксис не соответствует
стандарту. Следуя стандарту, эту задачу можно решить так:
DELETE FROM films
WHERE producer_id IN (SELECT id FROM producers WHERE name = ‘foo’);
В ряде случаев запрос в стиле соединения легче написать и он может работать быстрее, чем в
стиле вложенного запроса.
Примеры
Удаление всех фильмов, кроме мюзиклов:
DELETE FROM films WHERE kind &lt;&gt; ‘Musical’;
1579DELETE
Очистка таблицы films:
DELETE FROM films;
Удаление завершённых задач с получением всех данных удалённых строк:
DELETE FROM tasks WHERE status = ‘DONE’ RETURNING *;
Удаление из tasks строки, на которой в текущий момент располагается курсор c_tasks:
DELETE FROM tasks WHERE CURRENT OF c_tasks;
Совместимость
Эта команда соответствует стандарту SQL, но предложения USING и RETURNING являются расшире-
ниями PostgreSQL, как и возможность использовать WITH с DELETE.
См. также
TRUNCATE
1580DISCARD
DISCARD — очистить состояние сеанса
Синтаксис
DISCARD ( ALL | PLANS | SEQUENCES | TEMPORARY | TEMP )
Описание
DISCARD высвобождает внутренние ресурсы, связанные с сеансом использования базы данных. Эта
команда полезна для частичного или полного сброса состояния сеанса. Для освобождения различ-
ных типов ресурсов она поддерживает несколько разных подкоманд; вариант DISCARD ALL вклю-
чает в себя все остальные и также сбрасывает дополнительное состояние.
Параметры
PLANS
Высвобождает все кешированные планы запросов, вынуждая сервер провести планирование
заново при следующем использовании связанного подготовленного оператора.
SEQUENCES
Сбрасывает кешированное состояние, связанное с последовательностями, включая внутрен-
нюю информацию currval()/lastval() и любые предварительно выделенные значения после-
довательностей, которые ещё не выдала функция nextval(). (Кеширование значений последо-
вательности описано в CREATE SEQUENCE.)
TEMPORARY или TEMP
Удаляет все временные таблицы, созданные в текущем сеансе.
ALL
Высвобождает все временные ресурсы, связанные с текущим сеансом, и сбрасывает сеанс к
начальному состоянию. В настоящее время действует так же, как и следующая последователь-
ность операторов:
SET SESSION AUTHORIZATION DEFAULT;
RESET ALL;
DEALLOCATE ALL;
CLOSE ALL;
UNLISTEN *;
SELECT pg_advisory_unlock_all();
DISCARD PLANS;
DISCARD SEQUENCES;
DISCARD TEMP;
Замечания
DISCARD ALL нельзя выполнять внутри блока транзакции.
Совместимость
DISCARD является расширением PostgreSQL.
1581DO
DO — выполнить анонимный блок кода
Синтаксис
DO [ LANGUAGE имя_языка ] код
Описание
DO выполняет анонимный блок кода или, другими словами, разовую анонимную функцию на про-
цедурном языке.
Блок кода воспринимается, как если бы это было тело функции, которая не имеет параметров и
возвращает void. Этот код разбирается и выполняется один раз.
Необязательное предложение LANGUAGE можно записать до или после блока кода.
Параметры
код
Выполняемый код на процедурном языке. Он должен задаваться в виде текстовой строки (её
рекомендуется заключать в доллары), как и код в CREATE FUNCTION.
имя_языка
Имя процедурного языка, на котором написан код. По умолчанию подразумевается plpgsql.
Замечания
Применяемый процедурный язык должен быть уже зарегистрирован в текущей базе с помощью
команды CREATE EXTENSION. По умолчанию зарегистрирован только plpgsql, но не другие языки.
Пользователь должен иметь право USAGE для данного процедурного языка, либо быть суперпользо-
вателем, если этот язык недоверенный. Такие же требования действуют и при создании функции
на этом языке.
Если команда DO исполняется в блоке транзакции, код процедуры не может вызывать операторы
управления транзакциями. Такие операторы допускаются, только если DO выполняется в отдель-
ной транзакции.
Примеры
Следующий код даст все права для всех представлений в схеме public роли webuser:
DO <script type="math/tex">DECLARE r record;
BEGIN
FOR r IN SELECT table_schema, table_name FROM information_schema.tables
WHERE table_type = 'VIEW' AND table_schema = 'public'
LOOP
EXECUTE 'GRANT ALL ON ' || quote_ident(r.table_schema) || '.' ||
quote_ident(r.table_name) || ' TO webuser';
END LOOP;
END</script>;
Совместимость
Оператор DO отсутствует в стандарте SQL.
1582DO
См. также
CREATE LANGUAGE
1583DROP ACCESS METHOD
DROP ACCESS METHOD — удалить метод доступа
Синтаксис
DROP ACCESS METHOD [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP ACCESS METHOD удаляет существующий метод доступа. Удалять методы доступа разрешено
только суперпользователям.
Параметры
IF EXISTS
Не считать ошибкой, если метод доступа не существует. В этом случае будет выдано замечание.
имя
Имя существующего метода доступа.
CASCADE
Автоматически удалять объекты, зависящие от данного метода доступа (например, классы и
семейства операторов, а также индексы), и, в свою очередь, все зависящие от них объекты (см.
Раздел 5.13).
RESTRICT
Отказать в удалении метода доступа, если от него зависят какие-либо объекты. Это поведение
по умолчанию.
Примеры
Удаление метода доступа heptree:
DROP ACCESS METHOD heptree;
Совместимость
DROP ACCESS METHOD является расширением PostgreSQL.
См. также
CREATE ACCESS METHOD
1584DROP AGGREGATE
DROP AGGREGATE — удалить агрегатную функцию
Синтаксис
DROP AGGREGATE [ IF EXISTS ] имя ( сигнатура_агр_функции ) [, …] [ CASCADE |
RESTRICT ]
Здесь сигнатура_агр_функции:</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>|
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] |
[ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] ] ORDER BY
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ]
Описание
DROP AGGREGATE удаляет существующую агрегатную функцию. Пользователь, выполняющий эту
команду, должен быть владельцем агрегатной функции.
Параметры
IF EXISTS
Не считать ошибкой, если агрегатная функция не существует. В этом случае будет выдано за-
мечание.
имя
Имя существующей агрегатной функции (возможно, дополненное схемой).
режим_аргумента
Режим аргумента: IN или VARIADIC. По умолчанию подразумевается IN.
имя_аргумента
Имя аргумента. Заметьте, что на самом деле DROP AGGREGATE не обращает внимание на имена
аргументов, так как для однозначной идентификации агрегатной функции достаточно только
типов аргументов.
тип_аргумента
Тип входных данных, с которыми работает агрегатная функция. Чтобы сослаться на агрегатную
функцию без аргументов, укажите вместо списка аргументов *, а чтобы сослаться на сортиру-
ющую агрегатную функцию, добавьте ORDER BY между указаниями непосредственных и агре-
гируемых аргументов.
CASCADE
Автоматически удалять объекты, зависящие от данной агрегатной функции (например, исполь-
зующие её представления), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении агрегатной функции, если от неё зависят какие-либо объекты. Это пове-
дение по умолчанию.
Замечания
Альтернативные варианты указания сортирующих агрегатов описаны в ALTER AGGREGATE.
1585DROP AGGREGATE
Примеры
Удаление агрегатной функции myavg для типа integer:
DROP AGGREGATE myavg(integer);
Удаление гипотезирующей агрегатной функции myrank, которая принимает произвольный список
сортируемых столбцов и соответствующий список непосредственных аргументов:
DROP AGGREGATE myrank(VARIADIC “any” ORDER BY VARIADIC “any”);
Удаление нескольких агрегатных функций одной командой:
DROP AGGREGATE myavg(integer), myavg(bigint);
Совместимость
Оператор DROP AGGREGATE отсутствует в стандарте SQL.
См. также
ALTER AGGREGATE, CREATE AGGREGATE
1586DROP CAST
DROP CAST — удалить приведение типа
Синтаксис
DROP CAST [ IF EXISTS ] (исходный_тип AS целевой_тип) [ CASCADE | RESTRICT ]
Описание
DROP CAST удаляет ранее определённое приведение типа.
Чтобы удалить приведение, необходимо быть владельцем исходного или целевого типа данных.
Такие же требования действуют и при создании приведения.
Параметры
IF EXISTS
Не считать ошибкой, если приведение не существует. В этом случае будет выдано замечание.
исходный_тип
Имя исходного типа данных для приведения.
целевой_тип
Имя целевого типа данных для приведения.
CASCADE
RESTRICT
Эти ключевые слова игнорируются, так как от приведений не зависят никакие объекты.
Примеры
Удаление приведения типа text к типу int:
DROP CAST (text AS int);
Совместимость
Команда DROP CAST соответствует стандарту SQL.
См. также
CREATE CAST
1587DROP COLLATION
DROP COLLATION — удалить правило сортировки
Синтаксис
DROP COLLATION [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP COLLATION удаляет ранее определённое правило сортировки. Чтобы удалить правило сорти-
ровки, необходимо быть его владельцем.
Параметры
IF EXISTS
Не считать ошибкой, если правило сортировки не существует. В этом случае будет выдано за-
мечание.
имя
Имя правила сортировки, возможно, дополненное схемой.
CASCADE
Автоматически удалять объекты, зависящие от данного правила сортировки, и, в свою очередь,
все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении правила сортировки, если от него зависят какие-либо объекты. Это пове-
дение по умолчанию.
Примеры
Удаление правила сортировки с именем german:
DROP COLLATION german;
Совместимость
Команда DROP COLLATION соответствует стандарту SQL, за исключением параметра IF EXISTS,
являющегося расширением PostgreSQL.
См. также
ALTER COLLATION, CREATE COLLATION
1588DROP CONVERSION
DROP CONVERSION — удалить преобразование
Синтаксис
DROP CONVERSION [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP CONVERSION удаляет ранее определённое преобразование. Чтобы удалить преобразование,
необходимые быть его владельцем.
Параметры
IF EXISTS
Не считать ошибкой, если преобразование не существует. В этом случае будет выдано замеча-
ние.
имя
Имя преобразования, возможно, дополненное схемой.
CASCADE
RESTRICT
Эти ключевые слова игнорируются, так как от преобразований не зависят никакие объекты.
Примеры
Удаление преобразования с именем myname:
DROP CONVERSION myname;
Совместимость
Оператор DROP CONVERSION отсутствует в стандарте SQL, хотя в нём есть оператор DROP
TRANSLATION, сопутствующий оператору CREATE TRANSLATION, который, в свою очередь, подобен
CREATE CONVERSION в PostgreSQL.
См. также
ALTER CONVERSION, CREATE CONVERSION
1589DROP DATABASE
DROP DATABASE — удалить базу данных
Синтаксис
DROP DATABASE [ IF EXISTS ] имя
Описание
Оператор DROP DATABASE удаляет базу данных. Он удаляет из каталогов записи, относящиеся к
базе данных, а также удаляет каталог, содержащий данные. Выполнить эту команду может только
владелец базы данных. Кроме того, удалить базу нельзя, пока к ней подключены вы или кто-то
ещё. (Чтобы выполнить эту команду, подключитесь к postgres или любой другой базе данных.)
Действие команды DROP DATABASE нельзя отменить. Используйте её с осторожностью!
Параметры
IF EXISTS
Не считать ошибкой, если база данных не существует. В этом случае будет выдано замечание.
имя
Имя базы данных, подлежащей удалению.
Замечания
DROP DATABASE нельзя выполнять внутри блока транзакции.
Эту команду нельзя выполнить, если установлено подключение к удаляемой базе данных. Поэто-
му может быть удобнее вместо неё использовать программу dropdb, которая сама вызывает эту
команду внутри.
Совместимость
Оператор DROP DATABASE отсутствует в стандарте SQL.
См. также
CREATE DATABASE
1590DROP DOMAIN
DROP DOMAIN — удалить домен
Синтаксис
DROP DOMAIN [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP DOMAIN удаляет домен. Удалить домен может только его владелец.
Параметры
IF EXISTS
Не считать ошибкой, если домен не существует. В этом случае будет выдано замечание.
имя
Имя существующего домена (возможно, дополненное схемой).
CASCADE
Автоматически удалять объекты, зависящие от данного домена (например, столбцы таблиц), и,
в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении домена, если от него зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Удаление домена box:
DROP DOMAIN box;
Совместимость
Эта команда соответствует стандарту SQL, за исключением параметра IF EXISTS, являющегося
расширением PostgreSQL.
См. также
CREATE DOMAIN, ALTER DOMAIN
1591DROP EVENT TRIGGER
DROP EVENT TRIGGER — удалить событийный триггер
Синтаксис
DROP EVENT TRIGGER [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP EVENT TRIGGER удаляет существующий событийный триггер. Пользователь, выполняющий
эту команду, должен быть владельцем событийного триггера.
Параметры
IF EXISTS
Не считать ошибкой, если событийный триггер не существует. В этом случае будет выдано
замечание.
имя
Имя событийного триггера, подлежащего удалению.
CASCADE
Автоматически удалять объекты, зависящие от данного триггера, и, в свою очередь, все зави-
сящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении триггера, если от него зависят какие-либо объекты. Это поведение по
умолчанию.
Примеры
Удаление триггера snitch:
DROP EVENT TRIGGER snitch;
Совместимость
Оператор DROP EVENT TRIGGER отсутствует в стандарте SQL.
См. также
CREATE EVENT TRIGGER, ALTER EVENT TRIGGER
1592DROP EXTENSION
DROP EXTENSION — удалить расширение
Синтаксис
DROP EXTENSION [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP EXTENSION удаляет расширения из базы данных. При удалении расширения также удаляются
все составляющие его объекты.
Чтобы выполнить DROP EXTENSION, необходимо быть владельцем расширения.
Параметры
IF EXISTS
Не считать ошибкой, если расширение не существует. В этом случае будет выдано замечание.
имя
Имя установленного расширения.
CASCADE
Автоматически удалять объекты, зависящие от данного расширения, и, в свою очередь, все
зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении расширения, если от него зависят какие-либо объекты (кроме объектов,
составляющих его, и других расширений, перечисленных в той же команде DROP). Это поведе-
ние по умолчанию.
Примеры
Удаление расширения hstore из текущей базы данных.
DROP EXTENSION hstore;
Эта команда не будет выполнена, если какие-либо объекты из hstore будут задействованы, напри-
мер, если в какой-либо таблице окажется столбец типа hstore. Чтобы принудительно удалить и
эти зависимые объекты, необходимо добавить параметр CASCADE.
Совместимость
DROP EXTENSION является расширением PostgreSQL.
См. также
CREATE EXTENSION, ALTER EXTENSION
1593DROP FOREIGN DATA WRAPPER
DROP FOREIGN DATA WRAPPER — удалить обёртку сторонних данных
Синтаксис
DROP FOREIGN DATA WRAPPER [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP FOREIGN DATA WRAPPER удаляет существующую обёртку сторонних данных. Пользователь,
выполняющий эту команду, должен быть владельцем обёртки.
Параметры
IF EXISTS
Не считать ошибкой, если обёртка сторонних данных не существует. В этом случае будет вы-
дано замечание.
имя
Имя существующей обёртки сторонних данных.
CASCADE
Автоматически удалять объекты, зависящие от данной обёртки сторонних данных (например,
сторонние таблицы и серверы), и, в свою очередь, все зависящие от них объекты (см. Раз-
дел 5.13).
RESTRICT
Отказать в удалении обёртки сторонних данных, если от неё зависят какие-либо объекты. Это
поведение по умолчанию.
Примеры
Удаление обёртки сторонних данных dbi:
DROP FOREIGN DATA WRAPPER dbi;
Совместимость
DROP FOREIGN DATA WRAPPER соответствует стандарту ISO/IEC 9075-9 (SQL/MED). Предложение IF
EXISTS является расширением PostgreSQL.
См. также
CREATE FOREIGN DATA WRAPPER, ALTER FOREIGN DATA WRAPPER
1594DROP FOREIGN TABLE
DROP FOREIGN TABLE — удалить стороннюю таблицу
Синтаксис
DROP FOREIGN TABLE [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP FOREIGN TABLE удаляет стороннюю таблицу. Удалить стороннюю таблицу может только её
владелец.
Параметры
IF EXISTS
Не считать ошибкой, если сторонняя таблица не существует. В этом случае будет выдано за-
мечание.
имя
Имя (возможно, дополненное схемой) сторонней таблицы, подлежащей удалению.
CASCADE
Автоматически удалять объекты, зависящие от данной сторонней таблицы (например, пред-
ставления), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении сторонней таблицы, если от неё зависят какие-либо объекты. Это поведе-
ние по умолчанию.
Примеры
Удаление двух сторонних таблиц, films и distributors:
DROP FOREIGN TABLE films, distributors;
Совместимость
Эта команда соответствует ISO/IEC 9075-9 (SQL/MED), но возможность удалять в одной команде
несколько таблиц и указание IF EXISTS являются расширениями PostgreSQL.
См. также
ALTER FOREIGN TABLE, CREATE FOREIGN TABLE
1595DROP FUNCTION
DROP FUNCTION — удалить функцию
Синтаксис
DROP FUNCTION [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
] тип_аргумента [, …] ] ) ] [, …]
[ CASCADE | RESTRICT ]
Описание
DROP FUNCTION удаляет определение существующей функции. Пользователь, выполняющий эту
команду, должен быть владельцем функции. Помимо имени функции требуется указать типы её
аргументов, так как в базе данных могут существовать несколько функций с одним именем, но с
разными списками аргументов.
Параметры
IF EXISTS
Не считать ошибкой, если функция не существует. В этом случае будет выдано замечание.
имя
Имя существующей функции (возможно, дополненное схемой). Если список аргументов не ука-
зан, имя функции должно быть уникальным в её схеме.
режим_аргумента
Режим аргумента: IN, OUT, INOUT или VARIADIC. По умолчанию подразумевается IN. Заметьте,
что DROP FUNCTION не учитывает аргументы OUT, так как для идентификации функции нужны
только типы входных аргументов. Поэтому достаточно перечислить только аргументы IN, INOUT
и VARIADIC.
имя_аргумента
Имя аргумента. Заметьте, что на самом деле DROP FUNCTION не обращает внимание на имена
аргументов, так как для однозначной идентификации функции достаточно только типов аргу-
ментов.
тип_аргумента
Тип данных аргументов функции (возможно, дополненный именем схемы), если таковые име-
ются.
CASCADE
Автоматически удалять объекты, зависящие от данной функции (например, операторы или
триггеры), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении функции, если от неё зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Эта команда удаляет функцию, вычисляющую квадратный корень:
DROP FUNCTION sqrt(integer);
Удаление нескольких функций одной командой:
1596DROP FUNCTION
DROP FUNCTION sqrt(integer), sqrt(bigint);
Если имя функции уникально в её схеме, на неё можно сослаться без списка аргументов:
DROP FUNCTION update_employee_salaries;
Заметьте, что это отличается от
DROP FUNCTION update_employee_salaries();
Данная форма ссылается на функцию с нулём аргументов, тогда как первый вариант подходит для
функции с любым числом аргументов, в том числе и с нулём, если имя функции уникально.
Совместимость
Эта команда соответствует стандарту SQL, но дополнена следующими расширениями PostgreSQL:
• Стандарт допускает удаление в одной команде только одной функции.
• Указание IF EXISTS
• Возможность указывать режимы и имена аргументов
См. также
CREATE FUNCTION, ALTER FUNCTION, DROP PROCEDURE, DROP ROUTINE
1597DROP GROUP
DROP GROUP — удалить роль в базе данных
Синтаксис
DROP GROUP [ IF EXISTS ] имя [, …]
Описание
DROP GROUP теперь является синонимом оператора DROP ROLE.
Совместимость
Оператор DROP GROUP отсутствует в стандарте SQL.
См. также
DROP ROLE
1598DROP INDEX
DROP INDEX — удалить индекс
Синтаксис
DROP INDEX [ CONCURRENTLY ] [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP INDEX удаляет существующий индекс из базы данных. Выполнить эту команду может только
владелец индекса.
Параметры
CONCURRENTLY
С этим указанием индекс удаляется, не блокируя параллельные операции выборки, добавле-
ния, изменения и удаления данных в таблице индекса. Обычный оператор DROP INDEX запра-
шивает исключительную блокировку для таблицы, запрещая другим обращаться к ней до за-
вершения удаления. Если же добавлено это указание, команда, напротив, будет ждать завер-
шения конфликтующих транзакций.
Применяя это указание, надо учитывать несколько особенностей. В частности, при этом можно
задать имя только одного индекса, а параметр CASCADE не поддерживается. (Таким образом, ин-
декс, поддерживающий ограничение UNIQUE или PRIMARY KEY, так удалить нельзя.) Кроме того,
обычную команду DROP INDEX можно выполнить в блоке транзакции, а DROP INDEX CONCURRENTLY
— нет.
IF EXISTS
Не считать ошибкой, если индекс не существует. В этом случае будет выдано замечание.
имя
Имя (возможно, дополненное схемой) индекса, подлежащего удалению.
CASCADE
Автоматически удалять объекты, зависящие от данного индекса, и, в свою очередь, все завися-
щие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении индекса, если от него зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Эта команда удалит индекс title_idx:
DROP INDEX title_idx;
Совместимость
DROP INDEX является языковым расширением PostgreSQL. Средства обеспечения индексов в стан-
дарте SQL не описаны.
См. также
CREATE INDEX
1599DROP LANGUAGE
DROP LANGUAGE — удалить процедурный язык
Синтаксис
DROP [ PROCEDURAL ] LANGUAGE [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP LANGUAGE удаляет определение ранее зарегистрированного процедурного языка. Выполнить
DROP LANGUAGE может только владелец языка или суперпользователь.
Примечание
Начиная с PostgreSQL 9.1, большинство процедурных языков были преобразованы в
«расширения», так что теперь их следует удалять командами DROP EXTENSION, а не
DROP LANGUAGE.
Параметры
IF EXISTS
Не считать ошибкой, если язык не существует. В этом случае будет выдано замечание.
имя
Имя существующего процедурного языка. В целях обратной совместимости имя можно заклю-
чить в апострофы.
CASCADE
Автоматически удалять объекты, зависящие от данного языка (например, функции на этом язы-
ке), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении языка, если от него зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Эта команда удаляет процедурный язык plsample:
DROP LANGUAGE plsample;
Совместимость
Оператор DROP LANGUAGE отсутствует в стандарте SQL.
См. также
ALTER LANGUAGE, CREATE LANGUAGE
1600DROP MATERIALIZED VIEW
DROP MATERIALIZED VIEW — удалить материализованное представление
Синтаксис
DROP MATERIALIZED VIEW [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP MATERIALIZED VIEW удаляет существующее материализованное представление. Выполнить
эту команду может только владелец материализованного представления.
Параметры
IF EXISTS
Не считать ошибкой, если материализованное представление не существует. В этом случае
будет выдано замечание.
имя
Имя (возможно, дополненное схемой) материализованного представления, подлежащего уда-
лению.
CASCADE
Автоматически удалять объекты, зависящие от данного материализованного представления
(например, другие материализованные или обычные представления), и, в свою очередь, все
зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении материализованного представления, если от него зависят какие-либо объ-
екты. Это поведение по умолчанию.
Примеры
Эта команда удаляет материализованное представление с именем order_summary:
DROP MATERIALIZED VIEW order_summary;
Совместимость
DROP MATERIALIZED VIEW — расширение PostgreSQL.
См. также
CREATE MATERIALIZED VIEW, ALTER MATERIALIZED VIEW, REFRESH MATERIALIZED VIEW
1601DROP OPERATOR
DROP OPERATOR — удалить оператор
Синтаксис
DROP OPERATOR [ IF EXISTS ] имя ( ( тип_слева | NONE ) , ( тип_справа | NONE ) )
[, …] [ CASCADE | RESTRICT ]
Описание
DROP OPERATOR удаляет существующий оператор из базы данных. Выполнить эту команду может
только владелец оператора.
Параметры
IF EXISTS
Не считать ошибкой, если оператор не существует. В этом случае будет выдано замечание.
имя
Имя существующего оператора (возможно, дополненное схемой).
тип_слева
Тип данных левого операнда оператора; если у оператора нет левого операнда, укажите NONE.
тип_справа
Тип данных правого операнда оператора; если у оператора нет правого операнда, укажите NONE.
CASCADE
Автоматически удалять объекты, зависящие от данного оператора (например, использующие
его представления), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении оператора, если от него зависят какие-либо объекты. Это поведение по
умолчанию.
Примеры
Удаление оператора возведения в степень a^b для типа integer:
DROP OPERATOR ^ (integer, integer);
Удаление левого унарного оператора двоичного дополнения ~b для типа bit:
DROP OPERATOR ~ (none, bit);
Удаление правого унарного оператора вычисления факториала x! для типа bigint:
DROP OPERATOR ! (bigint, none);
Удаление нескольких операторов одной командой:
DROP OPERATOR ~ (none, bit), ! (bigint, none);
Совместимость
Команда DROP OPERATOR отсутствует в стандарте SQL.
1602DROP OPERATOR
См. также
CREATE OPERATOR, ALTER OPERATOR
1603DROP OPERATOR CLASS
DROP OPERATOR CLASS — удалить класс операторов
Синтаксис
DROP OPERATOR CLASS [ IF EXISTS ] имя USING метод_индекса [ CASCADE | RESTRICT ]
Описание
DROP OPERATOR CLASS удаляет существующий класс операторов. Выполнить эту команду может
только владелец класса операторов.
DROP OPERATOR CLASS не удаляет операторы или функции, связанные с этим классом. Если же су-
ществуют индексы, зависящие от этого класса, класс будет удалён успешно (вместе с индексами),
только если добавить указание CASCADE.
Параметры
IF EXISTS
Не считать ошибкой, если класс операторов не существует. В этом случае будет выдано заме-
чание.
имя
Имя существующего класса операторов (возможно, дополненное схемой).
метод_индекса
Имя индексного метода, для которого предназначен этот класс операторов.
CASCADE
Автоматически удалять объекты, зависящие от данного класса операторов (например, исполь-
зующие его индексы), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении класса операторов, если от него зависят какие-либо объекты. Это поведе-
ние по умолчанию.
Замечания
DROP OPERATOR CLASS не удалит семейство операторов, содержавшее этот класс, даже если в этом
семействе больше ничего не останется (в том числе, если семейство было неявно создано командой
CREATE OPERATOR CLASS). Пустое семейство операторов безвредно, но порядка ради затем следует
удалить и его, командой DROP OPERATOR FAMILY; или, возможно, выполнить DROP OPERATOR FAMILY
в первую очередь.
Примеры
Удаление класса операторов B-дерева с именем widget_ops:
DROP OPERATOR CLASS widget_ops USING btree;
Эта команда не будет выполнена, если в базе существуют индексы, использующие этот класс. Что-
бы удалить такие индексы вместе с классом операторов, нужно добавить указание CASCADE.
Совместимость
Команда DROP OPERATOR CLASS отсутствует в стандарте SQL.
1604DROP OPERATOR CLASS
См. также
ALTER OPERATOR CLASS, CREATE OPERATOR CLASS, DROP OPERATOR FAMILY
1605DROP OPERATOR FAMILY
DROP OPERATOR FAMILY — удалить семейство операторов
Синтаксис
DROP OPERATOR FAMILY [ IF EXISTS ] имя USING метод_индекса [ CASCADE | RESTRICT ]
Описание
DROP OPERATOR FAMILY удаляет существующее семейство операторов. Выполнить эту команду мо-
жет только владелец семейства операторов.
DROP OPERATOR FAMILY удаляет также все классы операторов, содержащиеся в семействе, но не
удаляет связанные с ним операторы или функции. Если от классов операторов, содержащихся в
семействе, зависят какие-либо индексы, семейство будет удалено успешно (вместе с классами и
индексами), только если добавить указание CASCADE.
Параметры
IF EXISTS
Не считать ошибкой, если семейство операторов не существует. В этом случае будет выдано
замечание.
имя
Имя (возможно, дополненное схемой) существующего семейства операторов.
метод_индекса
Имя индексного метода, для которого предназначено это семейство операторов.
CASCADE
Автоматически удалять объекты, зависящие от данного семейства операторов, и, в свою оче-
редь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении семейства операторов, если от него зависят какие-либо объекты. Это по-
ведение по умолчанию.
Примеры
Удаление семейства операторов B-дерева с именем float_ops:
DROP OPERATOR FAMILY float_ops USING btree;
Эта команда не будет выполнена, если в базе существуют индексы, использующие классы опера-
торов из этого семейства. Чтобы удалить такие индексы вместе с семейством операторов, нужно
добавить указание CASCADE.
Совместимость
Команда DROP OPERATOR FAMILY отсутствует в стандарте SQL.
См. также
ALTER OPERATOR FAMILY, CREATE OPERATOR FAMILY, ALTER OPERATOR CLASS, CREATE
OPERATOR CLASS, DROP OPERATOR CLASS
1606DROP OWNED
DROP OWNED — удалить объекты базы данных, принадлежащие роли
Синтаксис
DROP OWNED BY ( имя | CURRENT_USER | SESSION_USER ) [, …] [ CASCADE | RESTRICT ]
Описание
DROP OWNED удаляет в текущей базе данных все объекты, принадлежащие любой из указанных
ролей. Кроме того, эти роли лишаются всех прав, которые они имели для объектов текущей базы
данных и общих объектов (баз данных, табличных пространств).
Параметры
имя
Имя роли, все объекты которой будут уничтожены, а права отозваны.
CASCADE
Автоматически удалять объекты, зависящие от каждого затрагиваемого объекта, и, в свою оче-
редь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении объектов, принадлежащих роли, если от каких-либо из них зависят другие
объекты в базе данных. Это поведение по умолчанию.
Замечания
DROP OWNED часто применяется при подготовке к удалению одной или нескольких ролей. Так как
команда DROP OWNED затрагивает объекты только в текущей базе данных, обычно её нужно выпол-
нять в каждой базе данных, которая содержит объекты, принадлежащие удаляемой роли.
С указанием CASCADE эта команда может рекурсивно удалить объекты, принадлежащие и другим
пользователям.
Команда DROP OWNED даёт альтернативную возможность — удалить все объекты базы данных,
принадлежащие одной или нескольким ролям. Однако DROP OWNED не затрагивает права, назна-
ченные для других объектов.
Базы данных и табличные пространства, принадлежащие указанным ролям, эта команда не уда-
ляет.
За подробностями обратитесь к Разделу 21.4.
Совместимость
Команда DROP OWNED — расширение PostgreSQL.
См. также
REASSIGN OWNED, DROP ROLE
1607DROP POLICY
DROP POLICY — удалить политику защиты на уровне строк для таблицы
Синтаксис
DROP POLICY [ IF EXISTS ] имя ON имя_таблицы [ CASCADE | RESTRICT ]
Описание
DROP POLICY удаляет указанную политику из таблицы. Заметьте, что если из таблицы удаляется
последняя политика, а в таблице продолжает действовать защита на уровне строк (включённая
командой ALTER TABLE), будет применена политика запрета по умолчанию. Отключить защиту
на уровне строк для таблицы можно с помощью команды ALTER TABLE … DISABLE ROW LEVEL
SECURITY, независимо от того, определены ли политики для этой таблицы или нет.
Параметры
IF EXISTS
Не считать ошибкой, если политика не существует. В этом случае будет выдано замечание.
имя
Имя политики, подлежащей удалению.
имя_таблицы
Имя (возможно, дополненное схемой) таблицы, к которой применяется эта политика.
CASCADE
RESTRICT
Эти ключевые слова игнорируются, так как от политик не зависят никакие объекты.
Примеры
Удаление политики p1 из таблицы my_table:
DROP POLICY p1 ON my_table;
Совместимость
DROP POLICY является расширением PostgreSQL.
См. также
CREATE POLICY, ALTER POLICY
1608DROP PROCEDURE
DROP PROCEDURE — удалить процедуру
Синтаксис
DROP PROCEDURE [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
] тип_аргумента [, …] ] ) ] [, …]
[ CASCADE | RESTRICT ]
Описание
DROP PROCEDURE удаляет определение существующей процедуры. Пользователь, выполняющий эту
команду, должен быть владельцем процедуры. Помимо имени процедуры требуется указать типы
её аргументов, так как в базе данных могут существовать несколько процедур с одним именем, но
с разными списками аргументов.
Параметры
IF EXISTS
Не считать ошибкой, если процедура не существует. В этом случае будет выдано замечание.
имя
Имя существующей процедуры (возможно, дополненное схемой). Если список аргументов не
указан, имя процедуры должно быть уникальным в её схеме.
режим_аргумента
Режим аргумента: IN или VARIADIC. По умолчанию подразумевается IN.
имя_аргумента
Имя аргумента. Заметьте, что на самом деле DROP PROCEDURE не обращает внимание на имена
аргументов, так как для однозначной идентификации процедуры достаточно только типов ар-
гументов.
тип_аргумента
Тип данных аргументов процедуры (возможно, дополненный именем схемы), если таковые име-
ются.
CASCADE
Автоматически удалять объекты, зависящие от данной процедуры, и, в свою очередь, все зави-
сящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении процедуры, если от неё зависят какие-либо объекты. Это поведение по
умолчанию.
Примеры
DROP PROCEDURE do_db_maintenance();
Совместимость
Эта команда соответствует стандарту SQL, но дополнена расширениями PostgreSQL:
• Стандарт позволяет удалять с помощью этой команды только одну процедуру.
1609DROP PROCEDURE
• Указание IF EXISTS
• Возможность указывать режимы и имена аргументов
См. также
CREATE PROCEDURE, ALTER PROCEDURE, DROP FUNCTION, DROP ROUTINE
1610DROP PUBLICATION
DROP PUBLICATION — удалить публикацию
Синтаксис
DROP PUBLICATION [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP PUBLICATION удаляет существующую публикацию из базы данных.
Удалить публикацию может только её владелец или суперпользователь.
Параметры
IF EXISTS
Не считать ошибкой, если публикация не существует. В этом случае будет выдано замечание.
имя
Имя существующей публикации.
CASCADE
RESTRICT
Эти ключевые слова игнорируются, так как от публикаций не зависят никакие объекты.
Примеры
Удаление публикации:
DROP PUBLICATION mypublication;
Совместимость
DROP PUBLICATION является расширением PostgreSQL.
См. также
CREATE PUBLICATION, ALTER PUBLICATION
1611DROP ROLE
DROP ROLE — удалить роль в базе данных
Синтаксис
DROP ROLE [ IF EXISTS ] имя [, …]
Описание
DROP ROLE удаляет указанные роли. Удалить роль суперпользователя может только суперпользо-
ватель, а чтобы удалить роль обычного пользователя, достаточно иметь право CREATEROLE.
Если на эту роль есть ссылки в какой-либо базе данных в кластере, возникнет ошибка и роль не
будет удалена. Прежде чем удалять роль, необходимо удалить все принадлежащие ей объекты
(или сменить их владельца), а также лишить её данных ей прав для других объектов. Для этой цели
можно применить команды REASSIGN OWNED и DROP OWNED; за подробностями обратитесь к
Разделу 21.4.
Однако ликвидировать членство в ролях, связанное с этой ролью, не требуется; DROP ROLE автома-
тически исключит данную роль из других ролей, и третьи роли из данной. Сами роли при этом не
удаляются и другим образом никак не затрагиваются.
Параметры
IF EXISTS
Не считать ошибкой, если роль не существует. В этом случае будет выдано замечание.
имя
Имя роли, подлежащей удалению.
Замечания
PostgreSQL включает программу dropuser, которая предоставляет ту же функциональность (на
самом деле она вызывает эту команду), но может запускаться в командной оболочке.
Примеры
Удаление роли:
DROP ROLE jonathan;
Совместимость
В стандарте SQL определена команда DROP ROLE, но она может удалять только по одной роли, а
для её выполнения требуются другие права, не такие как в PostgreSQL.
См. также
CREATE ROLE, ALTER ROLE, SET ROLE
1612DROP ROUTINE
DROP ROUTINE — удалить подпрограмму
Синтаксис
DROP ROUTINE [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
] тип_аргумента [, …] ] ) ] [, …]
[ CASCADE | RESTRICT ]
Описание
DROP ROUTINE удаляет определение существующей подпрограммы, которой может быть обычная
функция, агрегат или процедура. Описание параметров, дополнительные примеры и подробности
приведены в описаниях DROP AGGREGATE, DROP FUNCTION и DROP PROCEDURE.
Примеры
Удаление подпрограммы foo для типа integer:
DROP ROUTINE foo(integer);
Эта команда будет работать независимо от того, является ли foo агрегатом, функцией или проце-
дурой.
Совместимость
Эта команда соответствует стандарту SQL, но дополнена следующими расширениями PostgreSQL:
• Стандарт позволяет удалять с помощью этой команды только одну подпрограмму.
• Указание IF EXISTS
• Возможность указывать режимы и имена аргументов
• Поддержка агрегатных функций.
См. также
DROP AGGREGATE, DROP FUNCTION, DROP PROCEDURE, ALTER ROUTINE
Заметьте, что также отсутствует команда CREATE ROUTINE.
1613DROP RULE
DROP RULE — удалить правило перезаписи
Синтаксис
DROP RULE [ IF EXISTS ] имя ON имя_таблицы [ CASCADE | RESTRICT ]
Описание
DROP RULE удаляет правило перезаписи.
Параметры
IF EXISTS
Не считать ошибкой, если правило не существует. В этом случае будет выдано замечание.
имя
Имя правила, подлежащего удалению.
имя_таблицы
Имя (возможно, дополненное схемой) существующей таблицы (или представления), к которой
применяется это правило.
CASCADE
Автоматически удалять объекты, зависящие от данного правила, и, в свою очередь, все завися-
щие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении правила, если от него зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Удаление правила перезаписи newrule:
DROP RULE newrule ON mytable;
Совместимость
DROP RULE является языковым расширением PostgreSQL, как и вся система перезаписи запросов.
См. также
CREATE RULE, ALTER RULE
1614DROP SCHEMA
DROP SCHEMA — удалить схему
Синтаксис
DROP SCHEMA [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP SCHEMA удаляет схемы из базы данных.
Схему может удалить только её владелец или суперпользователь. Заметьте, что владелец может
удалить схему (вместе со всеми содержащимися в ней объектами), даже если он не владеет неко-
торыми объектами в своей схеме.
Параметры
IF EXISTS
Не считать ошибкой, если схема не существует. В этом случае будет выдано замечание.
имя
Имя схемы.
CASCADE
Автоматически удалять объекты, содержащиеся в этой схеме (таблицы, функции и т. д.), и, в
свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении схемы, если она содержит какие-либо объекты. Это поведение по умолча-
нию.
Замечания
С указанием CASCADE эта команда может удалить объекты не только в данной схеме, но и в других.
Примеры
Удаление схемы mystuff из базы данных вместе со всем, что в ней содержится:
DROP SCHEMA mystuff CASCADE;
Совместимость
Команда DROP SCHEMA полностью соответствует стандарту SQL, но возможность удалять в одной
команде несколько схем и указание IF EXISTS являются расширениями PostgreSQL.
См. также
ALTER SCHEMA, CREATE SCHEMA
1615DROP SEQUENCE
DROP SEQUENCE — удалить последовательность
Синтаксис
DROP SEQUENCE [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP SEQUENCE удаляет генераторы числовых последовательностей. Удалить последовательность
может только её владелец или суперпользователь.
Параметры
IF EXISTS
Не считать ошибкой, если последовательность не существует. В этом случае будет выдано за-
мечание.
имя
Имя последовательности (возможно, дополненное схемой).
CASCADE
Автоматически удалять объекты, зависящие от данной последовательности, и, в свою очередь,
все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении последовательности, если от неё зависят какие-либо объекты. Это пове-
дение по умолчанию.
Примеры
Удаление последовательности serial:
DROP SEQUENCE serial;
Совместимость
DROP SEQUENCE соответствует стандарту SQL, но возможность удалять в одной команде несколько
последовательностей и указание IF EXISTS являются расширениями PostgreSQL.
См. также
CREATE SEQUENCE, ALTER SEQUENCE
1616DROP SERVER
DROP SERVER — удалить описание стороннего сервера
Синтаксис
DROP SERVER [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP SERVER удаляет существующее описание стороннего сервера. Пользователь, выполняющий
эту команду, должен быть владельцем сервера.
Параметры
IF EXISTS
Не считать ошибкой, если сервер не существует. В этом случае будет выдано замечание.
имя
Имя существующего сервера.
CASCADE
Автоматически удалять объекты, зависящие от данного триггера, и, в свою очередь, все зави-
сящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении сервера, если от него зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Удаление определения сервера foo, если оно существует:
DROP SERVER IF EXISTS foo;
Совместимость
DROP SERVER соответствует стандарту ISO/IEC 9075-9 (SQL/MED). Предложение IF EXISTS является
расширением PostgreSQL.
См. также
CREATE SERVER, ALTER SERVER
1617DROP STATISTICS
DROP STATISTICS — удалить расширенную статистику
Синтаксис
DROP STATISTICS [ IF EXISTS ] имя [, …]
Описание
DROP STATISTICS удаляет объект(ы) статистики из базы данных. Удалить объект статистики может
только владелец объекта, владелец схемы или суперпользователь.
Параметры
IF EXISTS
Не считать ошибкой, если объект статистики не существует. В этом случае будет выдано заме-
чание.
имя
Имя (возможно, дополненное схемой) объекта статистики, подлежащего удалению.
Примеры
Удаление двух объектов статистики в разных схемах (если эти объекты отсутствуют, ошибки не
будет):
DROP STATISTICS IF EXISTS
accounting.users_uid_creation,
public.grants_user_role;
Совместимость
Оператор DROP STATISTICS отсутствует в стандарте SQL.
См. также
ALTER STATISTICS, CREATE STATISTICS
1618DROP SUBSCRIPTION
DROP SUBSCRIPTION — удалить подписку
Синтаксис
DROP SUBSCRIPTION [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP SUBSCRIPTION удаляет подписку из кластера баз данных.
Удалить подписку может только суперпользователь.
Команду DROP SUBSCRIPTION нельзя выполнять в блоке транзакции, если подписка связана со сло-
том репликации. (Для освобождения слота можно использовать ALTER SUBSCRIPTION.)
Параметры
имя
Имя подписки, подлежащей удалению.
CASCADE
RESTRICT
Эти ключевые слова игнорируются, так как от подписок не зависят никакие объекты.
Замечания
При удалении подписки, связанной со слотом репликации на удалённом узле (это типичная ситу-
ация), команда DROP SUBSCRIPTION подключится к удалённому узлу и попытается удалить слот ре-
пликации в ходе этой операции. Это необходимо для освобождения ресурсов, выделенных для под-
писки на удалённом узле. Если при этом происходит сбой, либо из-за недоступности удалённого уз-
ла, либо из-за ошибки при удалении слота репликации, либо вообще из-за его отсутствия, команда
DROP SUBSCRIPTION прерывается. Для разрешения этой ситуации разорвите связь подписки с этим
слотом репликации, выполнив команду ALTER SUBSCRIPTION … SET (slot_name = NONE). После
этого команда DROP SUBSCRIPTION не будет пытаться выполнять какие-либо действия на удалённом
узле. Заметьте, что если удалённый слот репликации фактически продолжает существовать, его
нужно будет удалить вручную; в противном случае для него будет по-прежнему сохраняться WAL,
что в конце концов может привести к переполнению диска. См. также Подраздел 31.2.1.
Если подписка связана со слотом репликации, команду DROP SUBSCRIPTION нельзя выполнять внут-
ри блока транзакции.
Примеры
Удаление подписки:
DROP SUBSCRIPTION mysub;
Совместимость
DROP SUBSCRIPTION является расширением PostgreSQL.
См. также
CREATE SUBSCRIPTION, ALTER SUBSCRIPTION
1619DROP TABLE
DROP TABLE — удалить таблицу
Синтаксис
DROP TABLE [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP TABLE удаляет таблицы из базы данных. Удалить таблицу может только её владелец, владелец
схемы или суперпользователь. Чтобы опустошить таблицу, не удаляя её саму, вместо этой команды
следует использовать DELETE или TRUNCATE.
DROP TABLE всегда удаляет все индексы, правила, триггеры и ограничения, существующие в це-
левой таблице. Однако, чтобы удалить таблицу, на которую ссылается представление или ограни-
чение внешнего ключа в другой таблице, необходимо дополнительно указать CASCADE. (С указани-
ем CASCADE зависимое представление будет удалено полностью, но в случае с первичным ключом
удалено будет только само ограничение, а не таблица, к которой оно относится.)
Параметры
IF EXISTS
Не считать ошибкой, если таблица не существует. В этом случае будет выдано замечание.
имя
Имя (возможно, дополненное схемой) таблицы, подлежащей удалению.
CASCADE
Автоматически удалять объекты, зависящие от данной таблицы (например, представления), и,
в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении таблицы, если от неё зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Удаление таблиц films и distributors:
DROP TABLE films, distributors;
Совместимость
Эта команда соответствует стандарту SQL, но возможность удалять в одной команде несколько
таблиц и указание IF EXISTS являются расширениями PostgreSQL.
См. также
ALTER TABLE, CREATE TABLE
1620DROP TABLESPACE
DROP TABLESPACE — удалить табличное пространство
Синтаксис
DROP TABLESPACE [ IF EXISTS ] имя
Описание
DROP TABLESPACE удаляет табличное пространство из системы.
Удалить табличное пространство может только его владелец или суперпользователь. Перед удале-
нием его необходимо очистить от всех объектов базы данных. Даже если в текущей базе данных не
будет ни одного объекта, находящегося в этом пространстве, в нём вполне могут оставаться объек-
ты других баз данных. Кроме того, если табличное пространство указано в списке temp_tablespaces
любого активного сеанса, команда DROP может завершиться ошибкой, если в этом пространстве
окажутся временные файлы.
Параметры
IF EXISTS
Не считать ошибкой, если табличное пространство не существует. В этом случае будет выдано
замечание.
имя
Имя табличного пространства.
Замечания
DROP TABLESPACE не может быть выполнена в блоке транзакции.
Примеры
Удаление табличного пространства mystuff из системы:
DROP TABLESPACE mystuff;
Совместимость
DROP TABLESPACE является расширением PostgreSQL.
См. также
CREATE TABLESPACE, ALTER TABLESPACE
1621DROP TEXT SEARCH CONFIGURATION
DROP TEXT SEARCH CONFIGURATION — удалить конфигурацию текстового поиска
Синтаксис
DROP TEXT SEARCH CONFIGURATION [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP TEXT SEARCH CONFIGURATION удаляет существующую конфигурацию текстового поиска. Вы-
полнить эту команду может только владелец конфигурации.
Параметры
IF EXISTS
Не считать ошибкой, если конфигурация текстового поиска не существует. В этом случае будет
выдано замечание.
имя
Имя (возможно, дополненное схемой) существующей конфигурации текстового поиска.
CASCADE
Автоматически удалять объекты, зависящие от данной конфигурации текстового поиска, и, в
свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении конфигурации текстового поиска, если от неё зависят какие-либо объекты.
Это поведение по умолчанию.
Примеры
Удаление конфигурации текстового поиска my_english:
DROP TEXT SEARCH CONFIGURATION my_english;
Эта команда не будет выполнена, если какие-либо индексы ссылаются на эту конфигурацию в
вызовах to_tsvector. Чтобы удалить такие индексы вместе с конфигурацией, следует добавить
указание CASCADE.
Совместимость
Оператор DROP TEXT SEARCH CONFIGURATION отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH CONFIGURATION, CREATE TEXT SEARCH CONFIGURATION
1622DROP TEXT SEARCH DICTIONARY
DROP TEXT SEARCH DICTIONARY — удалить словарь текстового поиска
Синтаксис
DROP TEXT SEARCH DICTIONARY [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP TEXT SEARCH DICTIONARY удаляет существующий словарь текстового поиска. Выполнить эту
команду может только владелец словаря.
Параметры
IF EXISTS
Не считать ошибкой, если словарь текстового поиска не существует. В этом случае будет вы-
дано замечание.
имя
Имя (возможно, дополненное схемой) существующего словаря текстового поиска.
CASCADE
Автоматически удалять объекты, зависящие от данного словаря текстового поиска, и, в свою
очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении словаря текстового поиска, если от него зависят какие-либо объекты. Это
поведение по умолчанию.
Примеры
Удалить словарь текстового поиска english:
DROP TEXT SEARCH DICTIONARY english;
Эта команда не будет выполнена, если существуют конфигурации текстового поиска, использую-
щие этот словарь. Чтобы удалить такие конфигурации вместе со словарём, следует добавить ука-
зание CASCADE.
Совместимость
Оператор DROP TEXT SEARCH DICTIONARY отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH DICTIONARY, CREATE TEXT SEARCH DICTIONARY
1623DROP TEXT SEARCH PARSER
DROP TEXT SEARCH PARSER — удалить анализатор текстового поиска
Синтаксис
DROP TEXT SEARCH PARSER [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP TEXT SEARCH PARSER удаляет существующий анализатор текстового поиска. Выполнить эту
команду может только суперпользователь.
Параметры
IF EXISTS
Не считать ошибкой, если анализатор текстового поиска не существует. В этом случае будет
выдано замечание.
имя
Имя (возможно, дополненное схемой) существующего анализатора текстового поиска.
CASCADE
Автоматически удалять объекты, зависящие от данного анализатора текстового поиска, и, в
свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении анализатора текстового поиска, если от него зависят какие-либо объекты.
Это поведение по умолчанию.
Примеры
Удаление анализатора текстового поиска my_parser:
DROP TEXT SEARCH PARSER my_parser;
Эта команда не будет выполнена, если существуют конфигурации текстового поиска, использую-
щие это анализатор. Чтобы удалить такие конфигурации вместе с анализатором, следует добавить
указание CASCADE.
Совместимость
Оператор DROP TEXT SEARCH PARSER отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH PARSER, CREATE TEXT SEARCH PARSER
1624DROP TEXT SEARCH TEMPLATE
DROP TEXT SEARCH TEMPLATE — удалить шаблон текстового поиска
Синтаксис
DROP TEXT SEARCH TEMPLATE [ IF EXISTS ] имя [ CASCADE | RESTRICT ]
Описание
DROP TEXT SEARCH TEMPLATE удаляет существующий шаблон текстового поиска. Выполнить эту
команду может только суперпользователь.
Параметры
IF EXISTS
Не считать ошибкой, если шаблон текстового поиска не существует. В этом случае будет вы-
дано замечание.
имя
Имя (возможно, дополненное схемой) существующего шаблона текстового поиска.
CASCADE
Автоматически удалять объекты, зависящие от данного шаблона текстового поиска, и, в свою
очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении шаблона текстового поиска, если от него зависят какие-либо объекты. Это
поведение по умолчанию.
Примеры
Удаление шаблона текстового поиска thesaurus:
DROP TEXT SEARCH TEMPLATE thesaurus;
Эта команда не будет выполнена, если существуют словари текстового поиска, использующие этот
шаблон. Чтобы удалить такие словари вместе с шаблоном, следует добавить указание CASCADE.
Совместимость
Оператор DROP TEXT SEARCH TEMPLATE отсутствует в стандарте SQL.
См. также
ALTER TEXT SEARCH TEMPLATE, CREATE TEXT SEARCH TEMPLATE
1625DROP TRANSFORM
DROP TRANSFORM — удалить трансформацию
Синтаксис
DROP TRANSFORM [ IF EXISTS ] FOR имя_типа LANGUAGE имя_языка [ CASCADE | RESTRICT ]
Описание
DROP TRANSFORM удаляет ранее определённую трансформацию.
Чтобы удалить трансформацию, необходимо быть владельцем типа и языка. Такие же требования
действуют и при создании трансформации.
Параметры
IF EXISTS
Не считать ошибкой, если трансформация не существует. В этом случае будет выдано замеча-
ние.
имя_типа
Имя типа данных, для которого предназначена трансформация.
имя_языка
Имя языка, для которого предназначена трансформация.
CASCADE
Автоматически удалять объекты, зависящие от данной трансформации, и, в свою очередь, все
зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении трансформации, если от неё зависят какие-либо объекты. Это поведение
по умолчанию.
Примеры
Удаление трансформации для типа hstore и языка plpythonu:
DROP TRANSFORM FOR hstore LANGUAGE plpythonu;
Совместимость
Эта форма DROP TRANSFORM является расширением PostgreSQL. За подробностями обратитесь к
описанию CREATE TRANSFORM.
См. также
CREATE TRANSFORM
1626DROP TRIGGER
DROP TRIGGER — удалить триггер
Синтаксис
DROP TRIGGER [ IF EXISTS ] имя ON имя_таблицы [ CASCADE | RESTRICT ]
Описание
DROP TRIGGER удаляет существующее определение триггера. Пользователь, выполняющий эту ко-
манду, должен быть владельцем таблицы, для которой определён данный триггер.
Параметры
IF EXISTS
Не считать ошибкой, если триггер не существует. В этом случае будет выдано замечание.
имя
Имя триггера, подлежащего удалению.
имя_таблицы
Имя (возможно, дополненное схемой) таблицы, для которой определён триггер.
CASCADE
Автоматически удалять объекты, зависящие от данного триггера, и, в свою очередь, все зави-
сящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении триггера, если от него зависят какие-либо объекты. Это поведение по
умолчанию.
Примеры
Удаление триггера if_dist_exists в таблице films:
DROP TRIGGER if_dist_exists ON films;
Совместимость
Оператор DROP TRIGGER в PostgreSQL несовместим со стандартом SQL. В стандарте имена тригге-
ров не считаются локальными по отношению к таблицам, так что синтаксис команды проще: DROP
TRIGGER имя.
См. также
CREATE TRIGGER
1627DROP TYPE
DROP TYPE — удалить тип данных
Синтаксис
DROP TYPE [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP TYPE удаляет определённый пользователем тип данных. Удалить тип может только его вла-
делец.
Параметры
IF EXISTS
Не считать ошибкой, если тип не существует. В этом случае будет выдано замечание.
имя
Имя (возможно, дополненное схемой) типа данных, подлежащего удалению.
CASCADE
Автоматически удалять объекты, зависящие от данного типа (например, столбцы таблиц, функ-
ции и операторы), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении типа, если от него зависят какие-либо объекты. Это поведение по умол-
чанию.
Примеры
Удаление типа данных box:
DROP TYPE box;
Совместимость
Эта команда подобна соответствующей команде в стандарте SQL, но указание IF EXISTS является
расширением PostgreSQL. Однако учтите, что команда CREATE TYPE и механизм расширения типов
в PostgreSQL значительно отличаются от стандарта SQL.
См. также
ALTER TYPE, CREATE TYPE
1628DROP USER
DROP USER — удалить роль в базе данных
Синтаксис
DROP USER [ IF EXISTS ] имя [, …]
Описание
DROP USER — просто альтернативное написание команды DROP ROLE.
Совместимость
DROP USER является расширением PostgreSQL. В стандарте SQL определение пользователей счи-
тается зависимым от реализации.
См. также
DROP ROLE
1629DROP USER MAPPING
DROP USER MAPPING — удалить сопоставление пользователя для стороннего сервера
Синтаксис
DROP USER MAPPING [ IF EXISTS ] FOR ( имя_пользователя | USER | CURRENT_USER | PUBLIC )
SERVER имя_сервера
Описание
DROP USER MAPPING удаляет существующее сопоставление пользователя для стороннего сервера.
Владелец стороннего сервера может удалить заданные для этого сервера сопоставления любых
пользователей. Кроме того, обычный пользователь может удалить сопоставление для собственного
имени, если он имеет право USAGE для сервера.
Параметры
IF EXISTS
Не считать ошибкой, если сопоставление не существует. В этом случае будет выдано замеча-
ние.
имя_пользователя
Имя пользователя для сопоставления. Значения CURRENT_USER и USER соответствуют имени те-
кущего пользователя. Значение PUBLIC соответствует именам всех текущих и будущих пользо-
вателей системы.
имя_сервера
Имя сервера, для которого меняется сопоставление пользователей.
Примеры
Удаление сопоставления пользователя bob для сервера foo, если оно существует:
DROP USER MAPPING IF EXISTS FOR bob SERVER foo;
Совместимость
DROP USER MAPPING соответствует стандарту ISO/IEC 9075-9 (SQL/MED). Предложение IF EXISTS
является расширением PostgreSQL.
См. также
CREATE USER MAPPING, ALTER USER MAPPING
1630DROP VIEW
DROP VIEW — удалить представление
Синтаксис
DROP VIEW [ IF EXISTS ] имя [, …] [ CASCADE | RESTRICT ]
Описание
DROP VIEW удаляет существующее представление. Выполнить эту команду может только владелец
представления.
Параметры
IF EXISTS
Не считать ошибкой, если представление не существует. В этом случае будет выдано замеча-
ние.
имя
Имя (возможно, дополненное схемой) представления, подлежащего удалению.
CASCADE
Автоматически удалять объекты, зависящие от данного представления (например, другие пред-
ставления), и, в свою очередь, все зависящие от них объекты (см. Раздел 5.13).
RESTRICT
Отказать в удалении представления, если от него зависят какие-либо объекты. Это поведение
по умолчанию.
Примеры
Эта команда удаляет представление с именем kinds:
DROP VIEW kinds;
Совместимость
Эта команда соответствует стандарту SQL, но возможность удалять в одной команде несколько
представлений и указание IF EXISTS являются расширениями PostgreSQL.
См. также
ALTER VIEW, CREATE VIEW
1631END
END — зафиксировать текущую транзакцию
Синтаксис
END [ WORK | TRANSACTION ]
Описание
END фиксирует текущую транзакцию. Все изменения, произведённые этой транзакцией, становят-
ся видимыми для других и гарантированно сохранятся в случае сбоя. Эта команда является рас-
ширением PostgreSQL и равнозначна команде COMMIT.
Параметры
WORK
TRANSACTION
Необязательные ключевые слова, не оказывают никакого влияния.
Замечания
Для прерывания транзакции используйте ROLLBACK.
При попытке выполнить END вне транзакции ничего не произойдёт, но будет выдано предупрежде-
ние.
Примеры
Следующая команда фиксирует текущую транзакцию и сохраняет все изменения:
END;
Совместимость
END является расширением PostgreSQL и выполняет ту же функцию, что и оператор COMMIT, опи-
санный в стандарте SQL.
См. также
BEGIN, COMMIT, ROLLBACK
1632EXECUTE
EXECUTE — выполнить подготовленный оператор
Синтаксис
EXECUTE имя [ ( параметр [, …] ) ]
Описание
EXECUTE выполняет подготовленный ранее оператор. Так как подготовленные операторы существу-
ют только в рамках сеанса, они должны создаваться командой PREPARE, выполненной в текущем
сеансе ранее.
Если команда PREPARE, создающая оператор, определяет некоторый набор параметров, команде
EXECUTE должны быть переданы подходящие значения этих параметров; в противном случае воз-
никнет ошибка. Заметьте, что подготовленные операторы (в отличие от функций) не перегружа-
ются в зависимости от типа или числа параметров; имя подготовленного оператора должно быть
уникальным в рамках текущего сеанса.
Чтобы узнать больше о создании и использовании подготовленных операторов, обратитесь к
PREPARE.
Параметры
имя
Имя подготовленного оператора, который будет выполнен.
параметр
Фактическое значение параметра подготовленного оператора. Это может быть выражение, вы-
дающее значение, совместимое с типом данных этого параметра, который был определён при
создании подготовленного оператора.
Выводимая информация
Метка команды, возвращаемая EXECUTE, соответствует подготовленному оператору, а не оператору
EXECUTE.
Примеры
Примеры приведены в разделе «Примеры» документации по оператору PREPARE.
Совместимость
В стандарте SQL есть оператор EXECUTE, но он предназначен только для применения во встраива-
емом SQL. Эта версия оператора EXECUTE имеет также несколько другой синтаксис.
См. также
DEALLOCATE, PREPARE
1633EXPLAIN
EXPLAIN — показать план выполнения оператора
Синтаксис
EXPLAIN [ ( параметр [, …] ) ] оператор
EXPLAIN [ ANALYZE ] [ VERBOSE ] оператор
Здесь допускается параметр:
ANALYZE [ boolean ]
VERBOSE [ boolean ]
COSTS [ boolean ]
BUFFERS [ boolean ]
TIMING [ boolean ]
SUMMARY [ boolean ]
FORMAT ( TEXT | XML | JSON | YAML )
Описание
Эта команда выводит план выполнения, генерируемый планировщиком PostgreSQL для заданного
оператора. План выполнения показывает, как будут сканироваться таблицы, затрагиваемые опе-
ратором — просто последовательно, по индексу и т. д. — а если запрос связывает несколько таб-
лиц, какой алгоритм соединения будет выбран для объединения считанных из них строк.
Наибольший интерес в выводимой информации представляет ожидаемая стоимость выполнения
оператора, которая показывает, сколько, по мнению планировщика, будет выполняться этот опе-
ратор (это значение измеряется в единицах стоимости, которые не имеют точного определения,
но обычно это обращение к странице на диске). Фактически выводятся два числа: стоимость за-
пуска до выдачи первой строки и общая стоимость выдачи всех строк. Для большинства запросов
важна общая стоимость, но в таких контекстах, как подзапрос в EXISTS, планировщик будет мини-
мизировать стоимость запуска, а не общую стоимость (так как исполнение запроса всё равно за-
вершится сразу после получения одной строки). Кроме того, если количество возвращаемых строк
ограничивается предложением LIMIT, планировщик интерполирует стоимость между двумя этими
числами, выбирая наиболее выгодный план.
С параметром ANALYZE оператор будет выполнен на самом деле, а не только запланирован. При
этом в вывод добавляются фактические сведения о времени выполнения, включая общее время,
затраченное на каждый узел плана (в миллисекундах) и общее число строк, выданных в результате.
Это помогает понять, насколько близки к реальности предварительные оценки планировщика.
Важно
Имейте в виду, что с указанием ANALYZE оператор действительно выполняется. Хотя
EXPLAIN отбрасывает результат, который вернул бы SELECT, в остальном все действия
выполняются как обычно. Если вы хотите выполнить EXPLAIN ANALYZE с командой
INSERT, UPDATE, DELETE, CREATE TABLE AS или EXECUTE, не допуская изменения данных
этой командой, воспользуйтесь таким приёмом:
BEGIN;
EXPLAIN ANALYZE …;
ROLLBACK;
Без скобок для этого оператора можно указать только параметры ANALYZE и VERBOSE и только в
таком порядке. В PostgreSQL до версии 9.0 поддерживался только синтаксис без скобок, однако в
дальнейшем ожидается, что все новые параметры будут восприниматься только в скобках.
1634EXPLAIN
Параметры
ANALYZE
Выполнить команду и вывести фактическое время выполнения и другую статистику. По умол-
чанию этот параметр равен FALSE.
VERBOSE
Вывести дополнительную информацию о плане запроса. В частности, включить список столб-
цов результата для каждого узла в дереве плана, дополнить схемой имена таблиц и функций,
всегда указывать для переменных в выражениях псевдоним их таблицы, а также выводить име-
на всех триггеров, для которых выдаётся статистика. По умолчанию этот параметр равен FALSE.
COSTS
Вывести рассчитанную стоимость запуска и общую стоимость каждого узла плана, а также
рассчитанное число строк и ширину каждой строки. Этот параметр по умолчанию равен TRUE.
BUFFERS
Включить информацию об использовании буфера. В частности, вывести число попаданий, бло-
ков прочитанных, загрязненных и записанных в разделяемом и локальном буфере, а также
число прочитанных и записанных временных блоков. Попаданием считается ситуация, когда
требуемый блок уже находится в кеше и чтения с диска удаётся избежать. Блоки в общем бу-
фере содержат данные обычных таблиц и индексов, в локальном — данные временных таблиц и
индексов, а временные блоки предназначены для краткосрочного использования при выполне-
нии сортировки, хеширования, материализации и подобных узлов плана. Число загрязнённых
блоков показывает, сколько ранее не модифицированных блоков изменила данная операция;
тогда как число записанных блоков показывает, сколько ранее загрязнённых блоков данный
серверный процесс вынес из кеша при обработке запроса. Значения, указываемые для узла
верхнего уровня, включают значения всех его дочерних узлов. В текстовом формате выводятся
только ненулевые значения. Этот параметр действует только в режиме ANALYZE. По умолчанию
его значение равно FALSE.
TIMING
Включить в вывод фактическое время запуска и время, затраченное на каждый узел. Постоян-
ное чтение системных часов может значительно замедлить запрос, так что если достаточно
знать фактическое число строк, имеет смысл сделать этот параметр равным FALSE. Время вы-
полнения всего оператора замеряется всегда, даже когда этот параметр выключен и на уровне
узлов время не подсчитывается. Этот параметр действует только в режиме ANALYZE. По умол-
чанию его значение равно TRUE.
SUMMARY
Включить сводку (например, суммарное время) после плана запроса. Сводка включается по
умолчанию, когда используется ANALYZE, но этот параметр позволяет получить её и с други-
ми вариантами команды. Время планирования в EXPLAIN EXECUTE включает время извлечения
плана из кеша и время перепланирования, если оно потребовалось.
FORMAT
Установить один из следующих форматов вывода: TEXT, XML, JSON или YAML. Последние три
формата содержат ту же информацию, что и текстовый, но больше подходят для программного
разбора. По умолчанию выбирается формат TEXT.
boolean
Включает или отключает заданный параметр. Для включения параметра можно написать TRUE,
ON или 1, а для отключения — FALSE, OFF или 0. Значение boolean можно опустить, в этом случае
подразумевается TRUE.
1635EXPLAIN
оператор
Любой оператор SELECT, INSERT, UPDATE, DELETE, VALUES, EXECUTE, DECLARE, CREATE TABLE AS и
CREATE MATERIALIZED VIEW AS, план выполнения которого вас интересует.
Выводимая информация
Результатом команды будет текстовое описание плана, выбранного для оператора, возможно, до-
полненное статистикой выполнения. Представленная информация описана в Разделе 14.1.
Замечания
Чтобы планировщик запросов PostgreSQL был достаточно информирован для эффективной опти-
мизации запросов, данные в pg_statistic должны быть актуальными для всех таблиц, задейство-
ванных в запросе. Обычно об этом автоматически заботится демон автоочистки. Но если в таблице
недавно произошли значительные изменения, может потребоваться вручную выполнить ANALYZE,
не дожидаясь, пока автоочистка обработает эти изменения.
Измеряя фактическую стоимость выполнения каждого узла в плане, текущая реализация EXPLAIN
ANALYZE привносит накладные расходы профилирования в выполнение запроса. В результате это-
го, при запуске запроса командой EXPLAIN ANALYZE он может выполняться значительно дольше,
чем при обычном выполнении. Объём накладных расходов зависит от природы запроса, а также от
используемой платформы. Худшая ситуация наблюдается для узлов плана, которые сами по себе
выполняются очень быстро, и в операционных системах, где получение текущего времени относи-
тельно длительная операция.
Примеры
Получение плана простого запроса для таблицы, содержащей единственный столбец типа integer,
с 10000 строк:
EXPLAIN SELECT * FROM foo;
QUERY PLAN
———————————————————
Seq Scan on foo (cost=0.00..155.00 rows=10000 width=4)
(1 row)
План того же запроса, но выведенный в формате JSON:
EXPLAIN (FORMAT JSON) SELECT * FROM foo;
QUERY PLAN
——————————–
[
+
(
+
“Plan”: (
+
“Node Type”: “Seq Scan”,+
“Relation Name”: “foo”, +
“Alias”: “foo”,
+
“Startup Cost”: 0.00,
+
“Total Cost”: 155.00,
+
“Plan Rows”: 10000,
+
“Plan Width”: 4
+
)
+
)
+
]
(1 row)
Если в таблице есть индекс, а в запросе присутствует условие WHERE, для которого полезен этот
индекс, EXPLAIN может показать другой план:
1636EXPLAIN
EXPLAIN SELECT * FROM foo WHERE i = 4;
QUERY PLAN
————————————————————–
Index Scan using fi on foo (cost=0.00..5.98 rows=1 width=4)
Index Cond: (i = 4)
(2 rows)
План того же запроса, но в формате YAML:
EXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i=’4’;
QUERY PLAN
——————————-</li>
  <li>
    <dl>
      <dt>Plan:</dt>
      <dt>+</dt>
      <dt>Node Type: “Index Scan” +</dt>
      <dt>Scan Direction: “Forward”+</dt>
      <dt>Index Name: “fi”</dt>
      <dt>+</dt>
      <dt>Relation Name: “foo”</dt>
      <dt>+</dt>
      <dt>Alias: “foo”</dt>
      <dt>+</dt>
      <dt>Startup Cost: 0.00</dt>
      <dt>+</dt>
      <dt>Total Cost: 5.98</dt>
      <dt>+</dt>
      <dt>Plan Rows: 1</dt>
      <dt>+</dt>
      <dt>Plan Width: 4</dt>
      <dt>+</dt>
      <dt>Index Cond: “(i = 4)”</dt>
      <dt>(1 row)</dt>
      <dt>Рассмотрение формата XML оставлено в качестве упражнения для читателя.</dt>
      <dt>План того же запроса без вывода оценок стоимости:</dt>
      <dt>EXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;</dt>
      <dt>QUERY PLAN</dt>
      <dt>—————————-</dt>
      <dt>Index Scan using fi on foo</dt>
      <dt>Index Cond: (i = 4)</dt>
      <dt>(2 rows)</dt>
      <dt>Пример плана для запроса с агрегатной функцией:</dt>
      <dt>EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;</dt>
      <dt>QUERY PLAN</dt>
      <dt>———————————————————————</dt>
      <dt>Aggregate (cost=23.93..23.93 rows=1 width=4)</dt>
      <dt>-&gt; Index Scan using fi on foo (cost=0.00..23.92 rows=6 width=4)</dt>
      <dt>Index Cond: (i &lt; 10)</dt>
      <dt>(3 rows)</dt>
      <dt>Пример использования EXPLAIN EXECUTE для отображения плана выполнения подготовленного за-</dt>
      <dt>проса:</dt>
      <dt>PREPARE query(int, int) AS SELECT sum(bar) FROM test</dt>
      <dt>WHERE id &gt; $1 AND id &lt; $2</dt>
      <dt>GROUP BY foo;</dt>
      <dt>EXPLAIN ANALYZE EXECUTE query(100, 200);</dt>
      <dt>QUERY PLAN</dt>
      <dt>——————————————————————————————–</dt>
      <dt>1637EXPLAIN</dt>
      <dt>HashAggregate (cost=9.54..9.54 rows=1 width=8) (actual time=0.156..0.161 rows=11</dt>
      <dt>loops=1)</dt>
      <dt>Group Key: foo</dt>
      <dt>-&gt; Index Scan using test_pkey on test (cost=0.29..9.29 rows=50 width=8) (actual</dt>
      <dt>time=0.039..0.091 rows=99 loops=1)</dt>
      <dt>Index Cond: ((id &gt; $1) AND (id &lt; $2))</dt>
      <dt>Planning time: 0.197 ms</dt>
      <dt>Execution time: 0.225 ms</dt>
      <dt>(6 rows)</dt>
      <dt>Разумеется, конкретные числа, показанные здесь, зависят от фактического содержимого задей-</dt>
      <dt>ствованных таблиц. Также учтите, что эти числа и даже выбранная стратегия выполнения запро-</dt>
      <dt>са могут меняться от версии к версии PostgreSQL вследствие усовершенствования планировщика.</dt>
      <dt>Кроме того, команда ANALYZE при обработке статистических данных производит случайные выбор-</dt>
      <dt>ки, так что оценки стоимости могут меняться при каждом чистом запуске ANALYZE, даже когда</dt>
      <dt>фактическое распределение данных в таблице не меняется.</dt>
      <dt>Совместимость</dt>
      <dt>Оператор EXPLAIN отсутствует в стандарте SQL.</dt>
      <dt>См. также</dt>
      <dt>ANALYZE</dt>
      <dt>1638FETCH</dt>
      <dt>FETCH — получить результат запроса через курсор</dt>
      <dt>Синтаксис</dt>
      <dt>FETCH [ direction [ FROM | IN ] ] имя_курсора</dt>
      <dt>Здесь direction может быть пустым или принимать следующее значение:</dt>
      <dt>NEXT</dt>
      <dt>PRIOR</dt>
      <dt>FIRST</dt>
      <dt>LAST</dt>
      <dt>ABSOLUTE число</dt>
      <dt>RELATIVE число</dt>
      <dt>число</dt>
      <dt>ALL</dt>
      <dt>FORWARD</dt>
      <dt>FORWARD число</dt>
      <dt>FORWARD ALL</dt>
      <dt>BACKWARD</dt>
      <dt>BACKWARD число</dt>
      <dt>BACKWARD ALL</dt>
      <dt>Описание</dt>
      <dt>FETCH получает строки через ранее созданный курсор.</dt>
      <dt>Курсор связан с определённым положением, что и использует команда FETCH. Курсор может рас-</dt>
      <dt>полагаться перед первой строкой результата запроса, на любой строке этого результата, либо по-</dt>
      <dt>сле последней строки. При создании курсор оказывается перед первой строкой. Когда FETCH до-</dt>
      <dt>ходит до конца набора строк, курсор остаётся в положении после последней строки, либо перед</dt>
      <dt>первой, при движении назад. После команд FETCH ALL и FETCH BACKWARD ALL курсор всегда оказы-</dt>
      <dt>вается после последней строки или перед первой, соответственно.</dt>
      <dt>Формы NEXT, PRIOR, FIRST, LAST, ABSOLUTE и RELATIVE выбирают одну строку после соответствущего</dt>
      <dt>перемещения курсора. Если в этом положении строки не оказывается, возвращается пустой ре-</dt>
      <dt>зультат, а курсор остаётся в достигнутом положении перед первой строкой или после последней.</dt>
      <dt>Формы FORWARD и BACKWARD получают указанное число строк, сдвигаясь соответственно вперёд</dt>
      <dt>или назад; в результате курсор оказывается на последней выданной строке (или перед/после всех</dt>
      <dt>строк, если число превышает количество доступных строк).</dt>
      <dt>Формы RELATIVE 0, FORWARD 0 и BACKWARD 0 действуют одинаково — они считывают текущую стро-</dt>
      <dt>ку, не перемещая курсор, то есть, повторно выбирая строку, выбранную последней. Эта операция</dt>
      <dt>будет успешна, только если курсор не расположен до первой или после последней строки; в этом</dt>
      <dt>случае строка возвращена не будет.</dt>
      <dt>Примечание</dt>
      <dt>На этой странице описывается применение курсоров на уровне команд SQL. Если вы</dt>
      <dt>попытаетесь использовать курсоры внутри функции PL/pgSQL, правила будут другими</dt>
      <dt>— см. Подраздел 43.7.3.</dt>
      <dt>1639FETCH</dt>
      <dt>Параметры</dt>
      <dt>direction</dt>
      <dt>Параметр направление задаёт направление движения и число выбираемых строк. Он может</dt>
      <dt>принимать одно из следующих значений:</dt>
      <dt>NEXT</dt>
      <dt>Выбрать следующую строку. Это действие подразумевается по умолчанию, если направле-</dt>
      <dt>ние опущено.</dt>
      <dt>PRIOR</dt>
      <dt>Выбрать предыдущую строку.</dt>
      <dt>FIRST</dt>
      <dt>Выбрать первую строку запроса (аналогично указанию ABSOLUTE 1).</dt>
      <dt>LAST</dt>
      <dt>Выбрать последнюю строку запроса (аналогично ABSOLUTE -1).</dt>
      <dt>ABSOLUTE число</dt>
      <dt>Выбрать строку под номером число с начала, либо под номером abs(число) с конца, если</dt>
      <dt>число отрицательно. Если число выходит за границы набора строк, курсор размещается пе-</dt>
      <dt>ред первой или после последней строки; в частности, с ABSOLUTE 0 курсор оказывается пе-</dt>
      <dt>ред первой строкой.</dt>
      <dt>RELATIVE число</dt>
      <dt>Выбрать строку под номером число, считая со следующей вперёд, либо под номером</dt>
      <dt>abs(число), считая с предыдущей назад, если число отрицательно. RELATIVE 0 повторно</dt>
      <dt>считывает текущую строку, если таковая имеется.</dt>
      <dt>число</dt>
      <dt>Выбрать следующее число строк (аналогично FORWARD число).</dt>
      <dt>ALL</dt>
      <dt>Выбрать все оставшиеся строки (аналогично FORWARD ALL).</dt>
      <dt>FORWARD</dt>
      <dt>Выбрать следующую строку (аналогично NEXT).</dt>
      <dt>FORWARD число</dt>
      <dt>Выбрать следующее число строк. FORWARD 0 повторно выбирает текущую строку.</dt>
      <dt>FORWARD ALL</dt>
      <dt>Выбрать все оставшиеся строки.</dt>
      <dt>BACKWARD</dt>
      <dt>Выбрать предыдущую строку (аналогично PRIOR).</dt>
      <dt>BACKWARD число</dt>
      <dt>Выбрать предыдущее число строк (с перемещением назад). BACKWARD 0 повторно выбирает</dt>
      <dt>текущую строку.</dt>
      <dt>BACKWARD ALL</dt>
      <dt>Выбрать все предыдущие строки (с перемещением назад).</dt>
      <dt>1640FETCH</dt>
      <dt>число</dt>
      <dt>Здесь число — целочисленная константа, возможно со знаком, определяющая смещение или</dt>
      <dt>количество выбираемых строк. Для вариантов FORWARD и BACKWARD указание отрицательного</dt>
      <dt>числа равнозначно смене направления FORWARD на BACKWARD и наоборот.</dt>
      <dt>имя_курсора</dt>
      <dt>Имя открытого курсора.</dt>
      <dt>Выводимая информация</dt>
      <dt>При успешном выполнении FETCH возвращает метку команды вида</dt>
      <dt>FETCH число</dt>
      <dt>Здесь count — количество выбранных строк (может быть и нулевым). Заметьте, что в psql метка</dt>
      <dt>команды не выдаётся, так как вместо неё psql выводит выбранные строки.</dt>
      <dt>Замечания</dt>
      <dt>Если перемещение курсора в FETCH не ограничивается вариантами FETCH NEXT или FETCH FORWARD с</dt>
      <dt>положительным числом, курсор должен быть объявлен с указанием SCROLL. Для простых запросов</dt>
      <dt>PostgreSQL допускает обратное перемещение курсора, объявленного без SCROLL, но на это пове-</dt>
      <dt>дение лучше не рассчитывать. Если курсор объявлен с указанием NO SCROLL, перемещение назад</dt>
      <dt>запрещается.</dt>
      <dt>Вариант ABSOLUTE нисколько не быстрее, чем перемещение к требуемой строке с относительным</dt>
      <dt>сдвигом: нижележащий механизм всё равно должен прочитать все промежуточные строки. Вы-</dt>
      <dt>борки по абсолютному отрицательному положению ещё хуже: сначала запрос необходимо прочи-</dt>
      <dt>тать до конца и найти последнюю строку, а затем вернуться назад к указанной строке. Однако</dt>
      <dt>перемотка к началу запроса (FETCH ABSOLUTE 0) выполняется быстро.</dt>
      <dt>Определить курсор позволяет команда DECLARE, а переместить его, не читая данные, — команда</dt>
      <dt>MOVE.</dt>
      <dt>Примеры</dt>
      <dt>Следующий пример демонстрирует перемещение курсора в таблице:</dt>
      <dt>BEGIN WORK;</dt>
      <dt>– Создание курсора:</dt>
      <dt>DECLARE liahona SCROLL CURSOR FOR SELECT * FROM films;</dt>
      <dt>– Получение первых 5 строк через курсор liahona:</dt>
      <dt>FETCH FORWARD 5 FROM liahona;</dt>
      <dt>code |</dt>
      <dt>title</dt>
      <dt>| did | date_prod |</dt>
      <dt>kind</dt>
      <dt>| len</dt>
      <dt>——-+————————-+—–+————+———-+——-</dt>
      <dt>BL101 | The Third Man</dt>
      <dt>| 101 | 1949-12-23 | Drama</dt>
      <dt>| 01:44</dt>
      <dt>BL102 | The African Queen</dt>
      <dt>| 101 | 1951-08-11 | Romantic | 01:43</dt>
      <dt>JL201 | Une Femme est une Femme | 102 | 1961-03-12 | Romantic | 01:25</dt>
      <dt>P_301 | Vertigo</dt>
      <dt>| 103 | 1958-11-14 | Action</dt>
      <dt>| 02:08</dt>
      <dt>P_302 | Becket</dt>
      <dt>| 103 | 1964-02-03 | Drama</dt>
      <dt>| 02:28</dt>
      <dt>– Получение предыдущей строки:</dt>
      <dt>FETCH PRIOR FROM liahona;</dt>
      <dt>code | title | did | date_prod | kind | len</dt>
      <dt>——-+———+—–+————+——–+——-</dt>
      <dt>P_301 | Vertigo | 103 | 1958-11-14 | Action | 02:08</dt>
      <dt>1641FETCH</dt>
      <dt>– Закрытие курсора и завершение транзакции:</dt>
      <dt>CLOSE liahona;</dt>
      <dt>COMMIT WORK;</dt>
      <dt>Совместимость</dt>
      <dt>В стандарте SQL команда FETCH определена только для встраиваемого SQL. Описанная здесь ре-</dt>
      <dt>ализация FETCH возвращает данные подобно оператору SELECT, а не помещает их в переменные</dt>
      <dt>исполняющей среды. В остальном, FETCH полностью прямо-совместима со стандартом SQL.</dt>
      <dt>Формы FETCH с FORWARD и BACKWARD, а также формы FETCH число и FETCH ALL (в которых FORWARD</dt>
      <dt>подразумевается) являются расширениями PostgreSQL.</dt>
      <dt>В стандарте SQL перед именем курсора допускается только указание FROM; возможность указать</dt>
      <dt>IN или опустить оба указания относится к расширениям.</dt>
      <dt>См. также</dt>
      <dt>CLOSE, DECLARE, MOVE</dt>
      <dt>1642GRANT</dt>
      <dt>GRANT — определить права доступа</dt>
      <dt>Синтаксис</dt>
      <dt>GRANT ( ( SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER )</dt>
      <dt>[, …] | ALL [ PRIVILEGES ] )</dt>
      <dt>ON ( [ TABLE ] имя_таблицы [, …]</dt>
      <dt>| ALL TABLES IN SCHEMA имя_схемы [, …] )</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( ( SELECT | INSERT | UPDATE | REFERENCES ) ( имя_столбца [, …] )</dt>
      <dt>[, …] | ALL [ PRIVILEGES ] ( имя_столбца [, …] ) )</dt>
      <dt>ON [ TABLE ] имя_таблицы [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( ( USAGE | SELECT | UPDATE )</dt>
      <dt>[, …] | ALL [ PRIVILEGES ] )</dt>
      <dt>ON ( SEQUENCE имя_последовательности [, …]</dt>
      <dt>| ALL SEQUENCES IN SCHEMA имя_схемы [, …] )</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( ( CREATE | CONNECT | TEMPORARY | TEMP ) [, …] | ALL [ PRIVILEGES ] )</dt>
      <dt>ON DATABASE имя_бд [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( USAGE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON DOMAIN имя_домена [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( USAGE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON FOREIGN DATA WRAPPER имя_обёртки_сторонних_данных [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( USAGE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON FOREIGN SERVER имя_сервера [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( EXECUTE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON ( ( FUNCTION | PROCEDURE | ROUTINE ) имя_подпрограммы [ ( [ [ режим_аргумента ]</dt>
      <dt>[ имя_аргумента ] тип_аргумента [, …] ] ) ] [, …]</dt>
      <dt>| ALL ( FUNCTIONS | PROCEDURES | ROUTINES ) IN SCHEMA имя_схемы [, …] )</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( USAGE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON LANGUAGE имя_языка [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( ( SELECT | UPDATE ) [, …] | ALL [ PRIVILEGES ] )</dt>
      <dt>ON LARGE OBJECT oid_БО [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( ( CREATE | USAGE ) [, …] | ALL [ PRIVILEGES ] )</dt>
      <dt>ON SCHEMA имя_схемы [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>1643GRANT</dt>
      <dt>GRANT ( CREATE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON TABLESPACE табл_пространство [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>GRANT ( USAGE | ALL [ PRIVILEGES ] )</dt>
      <dt>ON TYPE имя_типа [, …]</dt>
      <dt>TO указание_роли [, …] [ WITH GRANT OPTION ]</dt>
      <dt>Здесь указание_роли:</dt>
      <dt>[ GROUP ] имя_роли</dt>
      <dt>| PUBLIC</dt>
      <dt>| CURRENT_USER</dt>
      <dt>| SESSION_USER</dt>
      <dt>GRANT имя_роли [, …] TO имя_роли [, …] [ WITH ADMIN OPTION ]</dt>
      <dt>Описание</dt>
      <dt>Команда GRANT имеет две основные разновидности: первая назначает права для доступа к объектам</dt>
      <dt>баз данных (таблицам, столбцам, представлениям, сторонним таблицам, последовательностям, ба-</dt>
      <dt>зам данных, обёрткам сторонних данных, сторонним серверам, функциям, процедурам, процедур-</dt>
      <dt>ным языкам, схемам или табличным пространствам), а вторая назначает одни роли членами дру-</dt>
      <dt>гих. Эти разновидности во многом похожи, но имеют достаточно отличий, чтобы рассматривать</dt>
      <dt>их отдельно.</dt>
      <dt>GRANT для объектов баз данных</dt>
      <dt>Эта разновидность команды GRANT даёт одной или нескольким ролям определённые права для до-</dt>
      <dt>ступа к объекту базы данных. Эти права добавляются к списку имеющихся, если роль уже наделе-</dt>
      <dt>на какими-то правами.</dt>
      <dt>Также можно дать роли некоторое право для всех объектов одного типа в одной или нескольких</dt>
      <dt>схемах. Эта функциональность в настоящее время поддерживается только для таблиц, последова-</dt>
      <dt>тельностей, функций и процедур. ALL TABLES распространяется и на представления со сторонними</dt>
      <dt>таблицами так же, как и вариант GRANT для конкретного объекта. ALL FUNCTIONS распространяет-</dt>
      <dt>ся и на агрегатные функции, но не на процедуры, тоже подобно варианту GRANT для конкретного</dt>
      <dt>объекта.</dt>
      <dt>Ключевое слово PUBLIC означает, что права даются всем ролям, включая те, что могут быть созда-</dt>
      <dt>ны позже. PUBLIC можно воспринимать как неявно определённую группу, в которую входят все</dt>
      <dt>роли. Любая конкретная роль получит в сумме все права, данные непосредственно ей и ролям,</dt>
      <dt>членом которых она является, а также права, данные роли PUBLIC.</dt>
      <dt>Если указано WITH GRANT OPTION, получатель права, в свою очередь, может давать его другим. Без</dt>
      <dt>этого указания распоряжаться своим правом он не сможет. Группе PUBLIC право передачи права</dt>
      <dt>дать нельзя.</dt>
      <dt>Нет необходимости явно давать права для доступа к объекту его владельцу (обычно это пользова-</dt>
      <dt>тель, создавший объект), так как по умолчанию он имеет все права. (Однако владелец может ли-</dt>
      <dt>шить себя прав в целях безопасности.)</dt>
      <dt>Право удалять объект или изменять его определение произвольным образом не считается назна-</dt>
      <dt>чаемым; оно неотъемлемо связано с владельцем, так что отозвать это право или дать его кому-то</dt>
      <dt>другому нельзя. (Однако похожий эффект можно получить, управляя членством в роли, владею-</dt>
      <dt>щей объектом; см. ниже.) Владелец также неявно получает право распоряжения всеми правами</dt>
      <dt>для своего объекта.</dt>
      <dt>PostgreSQL по умолчанию назначает группе PUBLIC определённые права для некоторых типов объ-</dt>
      <dt>ектов. Для таблиц, столбцов, последовательностей, обёрток сторонних данных, сторонних серве-</dt>
      <dt>1644GRANT</dt>
      <dt>ров, больших объектов, схем и табличных пространств PUBLIC по умолчанию никаких прав не име-</dt>
      <dt>ет. Для других типов объектов PUBLIC имеет следующие права по умолчанию: CONNECT и TEMPORARY</dt>
      <dt>(создание временных таблиц) для баз данных; EXECUTE — для функций и процедур; USAGE — для</dt>
      <dt>языков и типов данных (включая домены). Владелец объекта, конечно же, может отозвать (посред-</dt>
      <dt>ством REVOKE) как явно назначенные права, так и права по умолчанию. (Для максимальной без-</dt>
      <dt>опасности команду REVOKE нужно выполнить в транзакции, создающей объект; тогда не образуется</dt>
      <dt>окно, в котором другой пользователь сможет обратиться к объекту.) Кроме того, эти изначально</dt>
      <dt>назначаемые права по умолчанию можно изменить, воспользовавшись командой ALTER DEFAULT</dt>
      <dt>PRIVILEGES.</dt>
      <dt>Все возможные права перечислены ниже:</dt>
      <dt>SELECT</dt>
      <dt>Позволяет выполнять SELECT для любого столбца или перечисленных столбцов в заданной таб-</dt>
      <dt>лице, представлении или последовательности. Также позволяет выполнять COPY TO. Помимо</dt>
      <dt>того, это право требуется для обращения к существующим значениям столбцов в UPDATE или</dt>
      <dt>DELETE. Для последовательностей это право позволяет пользоваться функцией currval. Для</dt>
      <dt>больших объектов это право позволяет читать содержимое объекта.</dt>
      <dt>INSERT</dt>
      <dt>Позволяет вставлять строки в заданную таблицу с помощью INSERT. Если право ограничива-</dt>
      <dt>ется несколькими столбцами, только их значение можно будет задать в команде INSERT (другие</dt>
      <dt>столбцы получат значения по умолчанию). Также позволяет выполнять COPY FROM.</dt>
      <dt>UPDATE</dt>
      <dt>Позволяет изменять (с помощью UPDATE) данные во всех, либо только перечисленных, столб-</dt>
      <dt>цах в заданной таблице. (На практике для любой нетривиальной команды UPDATE потребуется</dt>
      <dt>и право SELECT, так как она должна обратиться к столбцам таблицы, чтобы определить, какие</dt>
      <dt>строки подлежат изменению, и/или вычислить новые значения столбцов.) Для SELECT … FOR</dt>
      <dt>UPDATE и SELECT … FOR SHARE также необходимо это право как минимум для одного столбца,</dt>
      <dt>помимо права SELECT. Для последовательностей это право позволяет пользоваться функциями</dt>
      <dt>nextval и setval. Для больших объектов это право позволяет записывать данные в объект или</dt>
      <dt>обрезать его.</dt>
      <dt>DELETE</dt>
      <dt>Позволяет удалять строки из заданной таблицы с помощью DELETE. (На практике для любой</dt>
      <dt>нетривиальной команды DELETE потребуется также право SELECT, так как она должна обратить-</dt>
      <dt>ся к столбцам таблицы, чтобы определить, какие строки подлежат удалению.)</dt>
      <dt>TRUNCATE</dt>
      <dt>Позволяет опустошить заданную таблицу с помощью TRUNCATE.</dt>
      <dt>REFERENCES</dt>
      <dt>Позволяет создавать ограничение внешнего ключа, ссылающееся на определённую таблицу</dt>
      <dt>либо на определённые столбцы таблицы. (См. описание CREATE TABLE.)</dt>
      <dt>TRIGGER</dt>
      <dt>Позволяет создавать триггеры в заданной таблице. (См. описание оператора CREATE TRIGGER.)</dt>
      <dt>CREATE</dt>
      <dt>Для баз данных это право позволяет создавать схемы и публикации в заданной базе.</dt>
      <dt>Для схем это право позволяет создавать новые объекты в заданной схеме. Чтобы переименовать</dt>
      <dt>существующий объект, необходимо быть владельцем этого объекта и иметь это право для схемы,</dt>
      <dt>содержащей его.</dt>
      <dt>1645GRANT</dt>
      <dt>Для табличных пространств это право позволяет создавать таблицы, индексы и временные фай-</dt>
      <dt>лы в заданном табличном пространстве, а также создавать базы данных, для которых это про-</dt>
      <dt>странство будет основным. (Учтите, что когда это право отзывается, существующие объекты</dt>
      <dt>остаются в прежнем расположении.)</dt>
      <dt>CONNECT</dt>
      <dt>Позволяет пользователю подключаться к указанной базе данных. Это право проверяется</dt>
      <dt>при установлении соединения (в дополнение к условиям, определённым в конфигурации</dt>
      <dt>pg_hba.conf).</dt>
      <dt>TEMPORARY</dt>
      <dt>TEMP</dt>
      <dt>Позволяет создавать временные таблицы в заданной базе данных.</dt>
      <dt>EXECUTE</dt>
      <dt>Позволяет выполнять заданную функцию или процедуру и применять любые определённые по-</dt>
      <dt>верх неё операторы. Это единственный тип прав, применимый к функциям и процедурам. Этот</dt>
      <dt>синтаксис FUNCTION распространяется и на агрегатные функции. Также можно использовать</dt>
      <dt>вариант с ROUTINE, охватывающий функции, агрегатные функции или процедуры вне зависимо-</dt>
      <dt>сти от фактического рода объекта.</dt>
      <dt>USAGE</dt>
      <dt>Для процедурных языков это право позволяет создавать функции на заданном языке. Это един-</dt>
      <dt>ственный тип прав, применимый к процедурным языкам.</dt>
      <dt>Для схем это право даёт доступ к объектам, содержащимся в заданной схеме (предполагается,</dt>
      <dt>что при этом имеются права, необходимые для доступа к самим объектам). По сути это пра-</dt>
      <dt>во позволяет субъекту «просматривать» объекты внутри схемы. Без этого разрешения имена</dt>
      <dt>объектов всё же можно будет узнать, например, обратившись к системным таблицам. Кроме</dt>
      <dt>того, если отозвать это право, в существующих сеансах могут оказаться операторы, для кото-</dt>
      <dt>рых просмотр имён объектов был выполнен ранее, так что это право не позволяет абсолютно</dt>
      <dt>надёжно перекрыть доступ к объектам.</dt>
      <dt>Для последовательностей это право позволяет использовать функции currval и nextval.</dt>
      <dt>Для типов и доменов это право позволяет использовать заданный тип или домен при создании</dt>
      <dt>таблиц, функций или других объектов схемы. (Заметьте, что это право не ограничивает общее</dt>
      <dt>«использование» типа, например, обращение к значениям типа в запросах. Не имея этого пра-</dt>
      <dt>ва, субъект лишается только возможности создавать объекты, зависящие от заданного типа.</dt>
      <dt>Основное предназначение этого права в том, чтобы ограничить круг пользователей, способных</dt>
      <dt>создавать зависимости от типа, которые могут впоследствии помешать владельцу типа изме-</dt>
      <dt>нить его.)</dt>
      <dt>Для обёрток сторонних данных это право позволяет создавать новые серверы, используя задан-</dt>
      <dt>ную обёртку.</dt>
      <dt>Для серверов это право позволяет создавать определения сторонних таблиц, связанные с этим</dt>
      <dt>сервером. Субъекты могут также создавать, изменять или удалять сопоставление для собствен-</dt>
      <dt>ного имени пользователя, связанное с этим сервером.</dt>
      <dt>ALL PRIVILEGES</dt>
      <dt>Даёт целевой роли все права сразу. Ключевое слово PRIVILEGES является необязательным в</dt>
      <dt>PostgreSQL, хотя в строгом SQL оно требуется.</dt>
      <dt>Права, требующиеся для других команд, указаны на страницах справки этих команд.</dt>
      <dt>1646GRANT</dt>
      <dt>GRANT для ролей</dt>
      <dt>Эта разновидность команды GRANT включает роль в члены одной или нескольких других ролей.</dt>
      <dt>Членство в ролях играет важную роль, так как права, данные роли, распространяются и на всех</dt>
      <dt>её членов.</dt>
      <dt>С указанием WITH ADMIN OPTION новоиспечённый член роли сможет, в свою очередь, включать в</dt>
      <dt>члены этой роли, а также исключать из неё другие роли. Без этого указания обычные пользовате-</dt>
      <dt>ли не могут это делать. Считается, что роль не имеет права WITH ADMIN OPTION для самой себя, но</dt>
      <dt>ей позволено управлять своими членами из сеанса, в котором пользователь сеанса соответствует</dt>
      <dt>данной роли. Суперпользователи баз данных могут включать или исключать любые роли из любых</dt>
      <dt>ролей. Роли с правом CREATEROLE могут управлять членством в любых ролях, кроме ролей супер-</dt>
      <dt>пользователей.</dt>
      <dt>В отличие от прав, членство в ролях нельзя назначить группе PUBLIC. Заметьте также, что эта</dt>
      <dt>форма команды не принимает избыточное слово GROUP.</dt>
      <dt>Замечания</dt>
      <dt>Для лишения субъектов прав доступа применяется команда REVOKE.</dt>
      <dt>Начиная с PostgreSQL версии 8.1, концепции пользователей и групп объединены в единую сущ-</dt>
      <dt>ность, названную ролью. Таким образом, теперь нет необходимости добавлять ключевое слово</dt>
      <dt>GROUP, чтобы показать, что субъект является группой, а не пользователем. Слово GROUP всё ещё</dt>
      <dt>принимается этой командой, но оно лишено смысловой нагрузки.</dt>
      <dt>Пользователь может выполнять SELECT, INSERT и подобные команды со столбцом таблицы, если</dt>
      <dt>он имеет такое право для данного столбца или для всей таблицы. Если назначить пользователю</dt>
      <dt>требуемое право на уровне таблицы, а затем отозвать его для одного из столбцов, это не даст</dt>
      <dt>эффекта, которого можно было бы ожидать: операция с правами на уровне столбцов не затронет</dt>
      <dt>право на уровне таблицы.</dt>
      <dt>Если назначить право доступа к объекту (с помощью GRANT) попытается не владелец объекта, ко-</dt>
      <dt>манда завершится ошибкой, если пользователь не имеет никаких прав для этого объекта. Если же</dt>
      <dt>пользователь имеет какие-то права, команда будет выполняться, но пользователь сможет давать</dt>
      <dt>другим только те права, которые даны ему с правом передачи. Формы GRANT ALL PRIVILEGES будут</dt>
      <dt>выдавать предупреждение, если у него вовсе нет таких прав, тогда как другие формы будут выда-</dt>
      <dt>вать предупреждения, если пользователь не имеет прав распоряжаться именно правами, указан-</dt>
      <dt>ными в команде. (В принципе, эти утверждения применимы и к владельцу объекта, но ему разре-</dt>
      <dt>шено распоряжаться всеми правами, поэтому такие ситуации невозможны.)</dt>
      <dt>Следует отметить, что суперпользователи баз данных могут обращаться к любым объектам, вне</dt>
      <dt>зависимости от наличия каких-либо прав. Это сравнимо с привилегиями пользователя root в си-</dt>
      <dt>стеме Unix. И так же, как root, роль суперпользователя следует использовать только когда это</dt>
      <dt>абсолютно необходимо.</dt>
      <dt>Если суперпользователь решит выполнить команду GRANT или REVOKE, она будет выполнена, как</dt>
      <dt>если бы её выполнял владелец заданного объекта. В частности, права, назначенные такой коман-</dt>
      <dt>дой, будут представлены как права, назначенные владельцем объекта. (Если так же установить</dt>
      <dt>членство в роли, оно будет представлено как назначенное самой ролью.)</dt>
      <dt>GRANT и REVOKE также могут быть выполнены ролью, которая не является владельцем заданно-</dt>
      <dt>го объекта, но является членом роли-владельца, либо членом роли, имеющей права WITH GRANT</dt>
      <dt>OPTION для этого объекта. В этом случае, права будут записаны как назначенные ролью, которая</dt>
      <dt>действительно владеет объектом, либо имеет право WITH GRANT OPTION. Например, если таблица</dt>
      <dt>t1 принадлежит роли g1, членом которой является u1, то u1 может дать права на использование t1</dt>
      <dt>роли u2, но эти права будут представлены, как назначенные непосредственно ролью g1. Отозвать</dt>
      <dt>эти права позже сможет любой член роли g1.</dt>
      <dt>Если роль, выполняющая команду GRANT, получает требуемое право по нескольким путям член-</dt>
      <dt>ства, какая именно роль будет выбрана в качестве назначающей право, не определено. Если это</dt>
      <dt>1647GRANT</dt>
      <dt>важно, в таких случаях рекомендуется воспользоваться командой SET ROLE и переключиться на</dt>
      <dt>роль, которую хочется видеть в качестве выполняющей GRANT.</dt>
      <dt>При назначении прав для доступа к таблице они автоматически не распространяются на после-</dt>
      <dt>довательности, используемые этой таблицей, в том числе, на последовательности, связанные со</dt>
      <dt>столбцами SERIAL. Права доступа к последовательностям нужно назначать отдельно.</dt>
      <dt>Чтобы получить информацию о существующих правах, назначенных для таблиц и столбцов, вос-</dt>
      <dt>пользуйтесь командой \dp в psql. Например:</dt>
      <dt>=&gt; \dp mytable</dt>
      <dt>Access privileges</dt>
      <dt>Schema | Name</dt>
      <dt>| Type |</dt>
      <dt>Access privileges</dt>
      <dt>| Column access privileges</dt>
      <dt>——–+———+——-+———————–+————————–</dt>
      <dt>public | mytable | table | miriam=arwdDxt/miriam | col1:</dt>
      <dd>=r/miriam
:
miriam_rw=rw/miriam</dd>
      <dd>admin=arw/miriam
(1 row)
Записи, выводимые командой \dp, интерпретируются так:
имя_роли=xxxx – права, назначенные роли
=xxxx – права, назначенные PUBLIC
r
w
a
d
D
x
t
X
U
C
c
T
arwdDxt
*
–
–
–
–
–
–
–
–
–
–
–
–
–
–
SELECT (“read”, чтение)
UPDATE (“write”, запись)
INSERT (“append”, добавление)
DELETE
TRUNCATE
REFERENCES
TRIGGER
EXECUTE
USAGE
CREATE
CONNECT
TEMPORARY
ALL PRIVILEGES (все права для таблиц; для других объектов другие)
право передачи заданного права
/yyyy – роль, назначившая это право
В примере выше показано, что увидит пользователь miriam, если создаст таблицу mytable и вы-
полнит:
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
Для других объектов есть другие команды \d, которые также позволяют просмотреть назначенные
права.
Если столбец «Права доступа» для данного объекта пуст, это значит, что для объекта действуют
стандартные права (то есть столбец прав содержит NULL). Права по умолчанию всегда включают
все права для владельца и могут также включать некоторые права для PUBLIC в зависимости от
типа объекта, как разъяснялось выше. Первая команда GRANT или REVOKE для объекта приводит к
проявлению записи прав по умолчанию (например, (miriam=arwdDxt/miriam)), а затем изменяет
эту запись в соответствии с заданным запросом. Подобным образом, строки, показанные в столбце
«Права доступа к столбцам», выводятся только для столбцов с нестандартными правами доступа.
(Заметьте, что в данном контексте под «стандартными правами» всегда подразумевается встро-
енный набор прав, предопределённый для типа объекта. Если с объектом связан набор прав по
1648GRANT
умолчанию, полученный после изменения в результате ALTER DEFAULT PRIVILEGES, изменённые
права будут всегда выводиться явно, показывая эффект команды ALTER.)
Заметьте, что право распоряжения правами, которое имеет владелец, не отмечается в выводимой
сводке. Знаком * отмечаются только те права с правом передачи, которые были явно назначены
кому-либо.
Примеры
Следующая команда разрешает всем добавлять записи в таблицу films:
GRANT INSERT ON films TO PUBLIC;
Эта команда даёт пользователю manuel все права для представления kinds:
GRANT ALL PRIVILEGES ON kinds TO manuel;
Учтите, что если её выполнит суперпользователь или владелец представления kinds, эта команда
действительно даст субъекту все права, но если её выполнит обычный пользователь, субъект по-
лучит только те права, которые даны этому пользователю с правом передачи.
Включение в роль admins пользователя joe:
GRANT admins TO joe;
Совместимость
Согласно стандарту SQL, слово PRIVILEGES в указании ALL PRIVILEGES является обязательным.
Стандарт SQL не позволяет назначать права сразу для нескольких объектов одной командой.
PostgreSQL позволяет владельцу объекта лишить себя своих обычных прав: например, владелец
таблицы может разрешить себе только чтение таблицы, отозвав собственные права INSERT, UPDATE,
DELETE и TRUNCATE. В стандарте SQL это невозможно. Это объясняется тем, что PostgreSQL воспри-
нимает права владельца как назначенные им же себе; поэтому их можно и отозвать. В стандарте
SQL права владельца даются ему предполагаемой сущностью «<em>SYSTEM». Так как владелец объ-
екта отличается от «_SYSTEM», лишить себя этих прав он не может.
Согласно стандарту SQL, право с правом передачи можно дать субъекту PUBLIC; однако PostgreSQL
может давать право с правом передачи только ролям.
В стандарте SQL право USAGE распространяется и на другие типы объектов: наборы символов, пра-
вила сортировки и преобразования.
В стандарте SQL право USAGE для последовательностей управляет использованием выражения NEXT
VALUE FOR, которое равнозначно функции nextval в PostgreSQL. Права SELECT и UPDATE для по-
следовательностей являются расширениями PostgreSQL. То, что право USAGE для последователь-
ностей управляет использованием функции currval, так же относится к расширениям PostgreSQL
(как и сама функция).
Права для баз данных, табличных пространств, схем и языков относятся к расширениям
PostgreSQL.
См. также
REVOKE, ALTER DEFAULT PRIVILEGES
1649IMPORT FOREIGN SCHEMA
IMPORT FOREIGN SCHEMA — импортировать определения таблиц со стороннего сервера
Синтаксис
IMPORT FOREIGN SCHEMA удалённая_схема
[ ( LIMIT TO | EXCEPT ) ( имя_таблицы [, …] ) ]
FROM SERVER имя_сервера
INTO локальная_схема
[ OPTIONS ( параметр ‘значение’ [, … ] ) ]
Описание
IMPORT FOREIGN SCHEMA создаёт сторонние таблицы, которые представляют таблицы, существую-
щие на стороннем сервере. Новые сторонние таблицы будут принадлежать пользователю, выпол-
няющему команду, и будут содержать корректные определения столбцов и параметры, соответ-
ствующие удалённым таблицам.
По умолчанию импортируются все таблицы и представления, существующие в определённой схеме
на стороннем сервере. По желанию список таблиц можно ограничить некоторым подмножеством,
или исключить из него конкретные таблицы. Новые сторонние таблицы создаются в целевой схеме,
которая должна уже существовать.
Чтобы использовать IMPORT FOREIGN SCHEMA, необходимо иметь право USAGE для стороннего серве-
ра, а также право CREATE в целевой схеме.
Параметры
удалённая_схема
Удалённая схема, из которой будут импортированы объекты. Что именно представляет собой
удалённая схема, зависит от применяемой обёртки сторонних данных.
LIMIT TO ( имя_таблицы [, …] )
Импортировать только сторонние таблицы с заданными именами. Другие таблицы, существу-
ющие в сторонней схеме, будут проигнорированы.
EXCEPT ( имя_таблицы [, …] )
Исключить из импорта указанные сторонние таблицы. Данная команда импортирует все таб-
лицы, существующие в сторонней схеме, за исключением перечисленных в этом предложении.
имя_сервера
Сторонний сервер, с которого импортируется схема.
локальная_схема
Схема, в которой будут созданы импортируемые сторонние таблицы.
OPTIONS ( параметр ‘значение’ [, …] )
Параметры, которые должны применяться при импорте. Допустимые имена параметров и их
значения зависят от обёртки сторонних данных.
Примеры
Импорт определений таблиц из удалённой схемы foreign_films на сервере film_server с созда-
нием сторонних таблиц в локальной схеме films:
1650IMPORT FOREIGN SCHEMA
IMPORT FOREIGN SCHEMA foreign_films
FROM SERVER film_server INTO films;
Та же операция, но импортируются только таблицы actors и directors (если они существуют):
IMPORT FOREIGN SCHEMA foreign_films LIMIT TO (actors, directors)
FROM SERVER film_server INTO films;
Совместимость
Команда IMPORT FOREIGN SCHEMA соответствует стандарту SQL, за исключением параметра
OPTIONS, являющегося расширением PostgreSQL.
См. также
CREATE FOREIGN TABLE, CREATE SERVER
1651INSERT
INSERT — добавить строки в таблицу
Синтаксис
[ WITH [ RECURSIVE ] запрос_WITH [, …] ]
INSERT INTO имя_таблицы [ AS псевдоним ] [ ( имя_столбца [, …] ) ]
[ OVERRIDING ( SYSTEM | USER) VALUE ]
( DEFAULT VALUES | VALUES ( ( выражение | DEFAULT ) [, …] ) [, …] | запрос )
[ ON CONFLICT [ объект_конфликта ] действие_при_конфликте ]
[ RETURNING * | выражение_результата [ [ AS ] имя_результата ] [, …] ]
Здесь допускается объект_конфликта:
( ( имя_столбца_индекса | ( выражение_индекса ) ) [ COLLATE правило_сортировки ]
[ класс_операторов ] [, …] ) [ WHERE предикат_индекса ]
ON CONSTRAINT имя_ограничения
и действие_при_конфликте может быть следующим:
DO NOTHING
DO UPDATE SET ( имя_столбца = ( выражение | DEFAULT ) |
( имя_столбца [, …] ) = [ ROW ] ( ( выражение | DEFAULT )
[, …] ) |
( имя_столбца [, …] ) = ( вложенный_SELECT )
) [, …]
[ WHERE условие ]
Описание
INSERT добавляет строки в таблицу. Эта команда может добавить одну или несколько строк, сфор-
мированных выражениями значений, либо ноль или более строк, выданных дополнительным за-
просом.
Имена целевых столбцов могут перечисляться в любом порядке. Если список с именами столбцов
отсутствует, по умолчанию целевыми столбцами становятся все столбцы заданной таблицы; либо
первые N из них, если только N столбцов поступает от предложения VALUES или запроса. Значения,
получаемые от предложения VALUES или запроса, связываются с явно или неявно определённым
списком столбцов слева направо.
Все столбцы, не представленные в явном или неявном списке столбцов, получат значения по умол-
чанию, если для них заданы эти значения, либо NULL в противном случае.
Если выражение для любого столбца выдаёт другой тип данных, система попытается автоматиче-
ски привести его к нужному.
Предложение ON CONFLICT позволяет задать действие, заменяющее возникновение ошибки при
нарушении ограничения уникальности или ограничения-исключения. (См. описание «Предложе-
ние ON CONFLICT» ниже.)
С необязательным предложением RETURNING команда INSERT вычислит и возвратит значения для
каждой фактически добавленной строки (или изменённой, если применялось предложение ON
CONFLICT DO UPDATE). В основном это полезно для получения значений, присвоенных по умолча-
нию, например, последовательного номера записи. Однако в этом предложении можно задать лю-
бое выражение со столбцами таблицы. Список RETURNING имеет тот же синтаксис, что и список ре-
зультатов SELECT. В результате будут возвращены те строки, которые были успешно вставлены или
1652INSERT
изменены. Например, если строка была заблокирована, но не изменена, из-за того, что условие в
предложении ON CONFLICT DO UPDATE … WHERE не удовлетворено, эта строка возвращена не будет.
Чтобы добавлять строки в таблицу, необходимо иметь право INSERT для неё. Если присутствует
предложение ON CONFLICT DO UPDATE, также требуется иметь право UPDATE для этой таблицы.
Если указывается список столбцов, достаточно иметь право INSERT только для перечисленных
столбцов. Аналогично, с предложением ON CONFLICT DO UPDATE достаточно иметь право UPDATE
только для столбцов, которые будут изменены. Однако предложение ON CONFLICT DO UPDATE также
требует наличия права SELECT для всех столбцов, значения которых считываются в выражениях
ON CONFLICT DO UPDATE или в условии.
Для применения предложения RETURNING требуется право SELECT для всех столбцов, перечислен-
ных в RETURNING. Если для добавления строк применяется запрос, для всех таблиц или столбцов,
задействованных в этом запросе, разумеется, необходимо иметь право SELECT.
Параметры
Добавление
В этом разделе рассматриваются параметры, применяемые только при добавлении новых строк.
Параметры, применяемые исключительно с предложением ON CONFLICT, описываются отдельно.
запрос_WITH
Предложение WITH позволяет задать один или несколько подзапросов, на которые затем можно
ссылаться по имени в запросе INSERT. Подробнее об этом см. Раздел 7.8 и SELECT.
Заданный запрос (оператор SELECT) также может содержать предложение WITH. В этом случае
в запросе можно обращаться к обоим запросам_WITH, но второй будет иметь приоритет, так как
он вложен ближе.
имя_таблицы
Имя существующей таблицы (возможно, дополненное схемой).
псевдоним
Альтернативное имя, заменяющее имя_таблицы. Когда указывается этот псевдоним, он полно-
стью скрывает реальное имя таблицы. Это особенно полезно, когда в предложении ON CONFLICT
DO UPDATE фигурирует таблица с именем excluded, так как без определения псевдонима это
имя будет отдано специальной таблице, представляющей строки, предназначенные для добав-
ления.
имя_столбца
Имя столбца в таблице имя_таблицы. Это имя столбца при необходимости может быть допол-
нено именем вложенного поля или индексом в массиве. (Когда данные вставляются только
в некоторые поля столбца составного типа, в другие поля записывается NULL.) Обращаясь к
столбцу в предложении ON CONFLICT DO UPDATE, включать имя таблицы в ссылку на целевой
столбец не нужно. Например, запись INSERT INTO table_name … ON CONFLICT DO UPDATE SET
table_name.col = 1 некорректна (это согласуется с общим поведением команды UPDATE).
OVERRIDING SYSTEM VALUE
Без этого предложения не допускается задание явного значения (отличного от DEFAULT) для
столбца идентификации, определённого с характеристикой GENERATED ALWAYS. Данное предло-
жение перекрывает это ограничение.
OVERRIDING USER VALUE
Если указывается это предложение, то значения, представляемые для столбцов идентифика-
ции, определённых с характеристикой GENERATED BY DEFAULT, игнорируются и вместо них при-
меняются значения, выдаваемые последовательностью по умолчанию.
1653INSERT
Это предложение полезно, например, при копировании значений между таблицами. Команда
INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1 скопирует из tbl1 все столб-
цы, кроме столбцов идентификации в tbl2, а значения столбцов идентификации в tbl2 будут
сгенерированы последовательностями в tbl2.
DEFAULT VALUES
Все столбцы получат значения по умолчанию. (Предложение OVERRIDING в этой форме не до-
пускается.)
выражение
Выражение или значение, которое будет присвоено соответствующему столбцу.
DEFAULT
Соответствующий столбец получит значение по умолчанию.
запрос
Запрос (оператор SELECT), который выдаст строки для добавления в таблицу. Его синтаксис
описан в справке оператора SELECT.
выражение_результата
Выражение, которое будет вычисляться и возвращаться командой INSERT после добавления
или изменения каждой строки. В этом выражении можно использовать имена любых столбцов
таблицы имя_таблицы. Чтобы получить все столбцы, достаточно написать *.
имя_результата
Имя, назначаемое возвращаемому столбцу.
Предложение ON CONFLICT
Необязательное предложение ON CONFLICT задаёт действие, заменяющее возникновение ошибки
при нарушении ограничения уникальности или ограничения-исключения. Для каждой отдельной
строки, предложенной для добавления, добавление либо выполняется успешно, либо, если нару-
шается решающее ограничение или индекс, задаваемые как объект_конфликта, выполняется аль-
тернативное действие_конфликта. Вариант ON CONFLICT DO NOTHING в качестве альтернативного
действия просто отменяет добавление строки. Вариант ON CONFLICT DO UPDATE изменяет суще-
ствующую строку, вызвавшую конфликт со строкой, предложенной для добавления.
Задаваемый объект_конфликта может выбирать уникальный индекс. Определение объекта, позво-
ляющее выбрать индекс, включает один или несколько столбцов (их определяет имя_столбца_ин-
декса) и/или выражение_индекса и необязательный предикат_индекса. Все уникальные индексы в
таблице имя_таблицы, которые, без учёта порядка столбцов, содержат в точности столбцы/выра-
жения, определяющие объект_конфликта, выбираются как решающие индексы. Если указывается
предикат_индекса, он должен, в качестве дополнительного требования выбора, удовлетворять ин-
дексам. Заметьте, что это означает, что не частичный уникальный индекс (уникальный индекс без
предиката) будет выбран (и будет использоваться в ON CONFLICT), если такой индекс удовлетворя-
ет всем остальным критериям. Если попытка выбрать индекс оказывается неудачной, выдаётся
ошибка.
ON CONFLICT DO UPDATE гарантирует атомарный результат команды INSERT или UPDATE; при отсут-
ствии внешних ошибок гарантируется один из двух этих исходов, даже при большой параллельной
активности. Эта операция также известна как UPSERT — «UPDATE или INSERT».
объект_конфликта
Определяет, для какого именно конфликта в ON CONFLICT будет предпринято альтернативное
действие, устанавливая решающие индексы. Это указание позволяет осуществить выбор уни-
кального индекса или явно задаёт имя ограничения. Для ON CONFLICT DO NOTHING объект_кон-
1654INSERT
фликта может не указываться; в этом случае игнорироваться будут все конфликты с любыми
ограничениями (и уникальными индексами). Для ON CONFLICT DO UPDATE объект_конфликта
должен указываться.
действие_при_конфликте
Параметр действие_при_конфликте задаёт альтернативное действие в случае конфликта. Это
может быть либо DO NOTHING (не делать ничего), либо предложение DO UPDATE (произвести из-
менение), в котором указываются точные детали операции UPDATE, выполняемой в случае кон-
фликта. Предложения SET и WHERE в ON CONFLICT DO UPDATE могут обращаться к существую-
щей строке по имени таблицы (или псевдониму) или к строкам, предлагаемым для добавления,
используя специальную таблицу excluded. Для чтения столбцов excluded необходимо иметь
право SELECT для соответствующих столбцов в целевой таблице.
Заметьте, что эффект действий всех триггеров уровня строк BEFORE INSERT отражается в зна-
чениях excluded, так как в результате этих действий строка может быть исключена из множе-
ства добавляемых.
имя_столбца_индекса
Имя столбца в таблице имя_таблицы. Используется для выбора решающих индексов. Задаётся в
формате CREATE INDEX. Чтобы запрос выполнился, для столбца имя_столбца_индекса требуется
право SELECT.
выражение_индекса
Подобно указанию имя_столбца_индекса, но применяется для выбора индекса по выражениям
со столбцами таблицы имя_таблицы, фигурирующим в определениях индексов (не по простым
столбцам). Задаётся в формате CREATE INDEX. Для всех столбцов, к которым обращается выра-
жение_индекса, необходимо иметь право SELECT.
правило_сортировки
Когда задаётся, устанавливает, что соответствующие имя_столбца_индекса или выражение_ин-
декса должны использовать определённый порядок сортировки, чтобы этот индекс мог быть
выбран. Обычно это указание опускается, так как от правил сортировки чаще всего не зависит,
произойдёт ли нарушение ограничений или нет. Задаётся в формате CREATE INDEX.
класс_операторов
Когда задаётся, устанавливает, что соответствующие имя_столбца_индекса или выражение_ин-
декса должны использовать определённый класс, чтобы индекс мог быть выбран. Обычно это
указание опускается, потому что семантика равенства часто всё равно одна и та же в разных
классах операторов типа, или потому что достаточно рассчитывать на то, что заданные уни-
кальные индексы имеют адекватное определение равенства. Задаётся в формате CREATE INDEX.
предикат_индекса
Используется для выбора частичных уникальных индексов. Выбраны могут быть любые индек-
сы, удовлетворяющие предикату (при этом они могут не быть собственно частичными индек-
сами). Задаётся в формате CREATE INDEX. Для всех столбцов, задействованных в предикате_ин-
декса, требуется право SELECT.
имя_ограничения
Явно задаёт решающее ограничение по имени, что заменяет неявный выбор ограничения или
индекса.
условие
Выражение, выдающее значение типа boolean. Изменены будут только те строки, для которых
это выражение выдаст true, хотя при выборе действия ON CONFLICT DO UPDATE заблокируются
1655INSERT
все строки. Заметьте, что условие вычисляется в конце, после того как конфликт был признан
претендующим на выполнение изменения.
Заметьте, что ограничения-исключения не могут быть решающими в ON CONFLICT DO UPDATE. Во
всех случаях в качестве решающих поддерживаются только неоткладываемые (NOT DEFERRABLE)
ограничения и уникальные индексы.
Команда INSERT с предложением ON CONFLICT DO UPDATE является «детерминированной». Это
означает, что этой команде не разрешено воздействовать на любую существующую строку больше
одного раза; в случае такой ситуации возникнет ошибка нарушения мощности множества. Строки,
предлагаемые для добавления, не должны дублироваться с точки зрения атрибутов, ограничива-
емых решающим индексом или ограничением.
Заметьте, что в настоящий момент не поддерживается ситуация, когда конструкция ON CONFLICT
DO UPDATE команды INSERT, применяемой к секционированной таблице, изменяет ключ разбиения
в конфликтующей строке так, что эта строка должна быть перенесена в новую секцию.
Подсказка
Часто предпочтительнее использовать неявный выбор уникального индекса вместо
непосредственного указания ограничения в виде ON CONFLICT ON CONSTRAINT имя_о-
граничения. Выбор продолжит корректно работать, когда нижележащий индекс будет
заменён другим более или менее равнозначным индексом методом наложения, напри-
мер, с использованием CREATE UNIQUE INDEX … CONCURRENTLY и последующим удале-
нием заменяемого индекса.
Выводимая информация
В случае успешного завершения, INSERT возвращает метку команды в виде
INSERT oid число
Здесь число представляет количество добавленных или изменённых строк. Если число равняется
одному, а целевая таблица содержит oid, то в качестве oid выводится OID, назначенный добавлен-
ной строке. Эта одна строка должна быть добавлена, но не изменена. В противном случае в каче-
стве oid выводится ноль.
Если команда INSERT содержит предложение RETURNING, её результат будет похож на результат
оператора SELECT (с теми же столбцами и значениями, что содержатся в списке RETURNING), полу-
ченный для строк, добавленных или изменённых этой командой.
Замечания
Если целевая таблица является секционированной, каждая строка перенаправляется в соответ-
ствующую секцию и вставляется в неё. Если целевая таблица является секцией и какая-либо из
входных строк нарушает ограничение этой секции, происходит ошибка.
Примеры
Добавление одной строки в таблицу films:
INSERT INTO films VALUES
(‘UA502’, ‘Bananas’, 105, ‘1971-07-13’, ‘Comedy’, ‘82 minutes’);
В этом примере столбец len опускается и, таким образом, получает значение по умолчанию:
INSERT INTO films (code, title, did, date_prod, kind)
VALUES (‘T_601’, ‘Yojimbo’, 106, ‘1961-06-16’, ‘Drama’);
В этом примере для столбца с датой задаётся указание DEFAULT, а не явное значение:
1656INSERT
INSERT INTO films VALUES
(‘UA502’, ‘Bananas’, 105, DEFAULT, ‘Comedy’, ‘82 minutes’);
INSERT INTO films (code, title, did, date_prod, kind)
VALUES (‘T_601’, ‘Yojimbo’, 106, DEFAULT, ‘Drama’);
Добавление строки, полностью состоящей из значений по умолчанию:
INSERT INTO films DEFAULT VALUES;
Добавление нескольких строк с использованием многострочного синтаксиса VALUES:
INSERT INTO films (code, title, did, date_prod, kind) VALUES
(‘B6717’, ‘Tampopo’, 110, ‘1985-02-10’, ‘Comedy’),
(‘HG120’, ‘The Dinner Game’, 140, DEFAULT, ‘Comedy’);
В этом примере в таблицу films вставляются некоторые строки из таблицы tmp_films, имеющей
ту же структуру столбцов, что и films:
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; ‘2004-05-07’;
Этот пример демонстрирует добавление данных в столбцы с типом массива:
– Создание пустого поля 3x3 для игры в крестики-нолики
INSERT INTO tictactoe (game, board[1:3][1:3])
VALUES (1, ‘((“ “,” “,” “),(“ “,” “,” “),(“ “,” “,” “))’);
– Указания индексов в предыдущей команда могут быть опущены
INSERT INTO tictactoe (game, board)
VALUES (2, ‘((X,” “,” “),(“ “,O,” “),(“ “,X,” “))’);
Добавление одной строки в таблицу distributors и получение последовательного номера, сгене-
рированного благодаря указанию DEFAULT:
INSERT INTO distributors (did, dname) VALUES (DEFAULT, ‘XYZ Widgets’)
RETURNING did;
Увеличение счётчика продаж для продавца, занимающегося компанией Acme Corporation, и со-
хранение всей изменённой строки вместе с текущим временем в таблице журнала:
WITH upd AS (
UPDATE employees SET sales_count = sales_count + 1 WHERE id =
(SELECT sales_person FROM accounts WHERE name = ‘Acme Corporation’)
RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
Добавить дистрибьюторов или изменить существующие данные должным образом. Предполага-
ется, что в таблице определён уникальный индекс, ограничивающий значения в столбце did. За-
метьте, что для обращения к значениям, изначально предлагаемым для добавления, используется
специальная таблица excluded:
INSERT INTO distributors (did, dname)
VALUES (5, ‘Gizmo Transglobal’), (6, ‘Associated Computing, Inc’)
ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
Добавить дистрибьютора или не делать ничего для строк, предложенных для добавления, если
уже есть существующая исключающая строка (строка, содержащая конфликтующие значения в
столбце или столбцах после срабатывания триггеров перед добавлением строки). В данном приме-
ре предполагается, что определён уникальный индекс, ограничивающий значения в столбце did:
INSERT INTO distributors (did, dname) VALUES (7, ‘Redline GmbH’)
ON CONFLICT (did) DO NOTHING;
Добавить дистрибьюторов или изменить существующие данные должным образом. В данном при-
мере предполагается, что в таблице определён уникальный индекс, ограничивающий значения в
1657INSERT
столбце did. Предложение WHERE позволяет ограничить набор фактически изменяемых строк (од-
нако любая существующая строка, не подлежащая изменению, всё же будет заблокирована):
– Не менять данные существующих дистрибьюторов в зависимости от почтового индекса
INSERT INTO distributors AS d (did, dname) VALUES (8, ‘Anvil Distribution’)
ON CONFLICT (did) DO UPDATE
SET dname = EXCLUDED.dname || ‘ (formerly ‘ || d.dname || ‘)’
WHERE d.zipcode &lt;&gt; ‘21201’;
– Указать имя ограничения непосредственно в операторе (связанный индекс
– применяется для принятия решения о выполнении действия DO NOTHING)
INSERT INTO distributors (did, dname) VALUES (9, ‘Antwerp Design’)
ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
Добавить дистрибьютора, если возможно; в противном случае не делать ничего (DO NOTHING). В
данном примере предполагается, что в таблице определён уникальный индекс, ограничивающий
значения в столбце did по подмножеству строк, в котором булевский столбец is_active содержит
true:
– Этот оператор может выбрать частичный уникальный индекс по “did”
– с предикатом “WHERE is_active”, а может и просто использовать
– обычное ограничение уникальности по столбцу “did”
INSERT INTO distributors (did, dname) VALUES (10, ‘Conrad International’)
ON CONFLICT (did) WHERE is_active DO NOTHING;
Совместимость
INSERT соответствует стандарту SQL, но предложение RETURNING относится к расширениям
PostgreSQL, как и возможность применять WITH с INSERT и возможность задавать альтернативное
действие с ON CONFLICT. Кроме того, ситуация, когда список столбцов опущен, но не все столбцы
получают значения из предложения VALUES или запроса, стандартом не допускается.
В стандарте SQL говорится, что предложение OVERRIDING SYSTEM VALUE может присутствовать,
только если существует столбец идентификации, для которого всегда генерируется значение.
PostgreSQL допускает это предложение в любом случае и игнорирует его в случае неприменимо-
сти.
Возможные ограничения предложения запрос описаны в справке SELECT.
1658LISTEN
LISTEN — ожидать уведомления
Синтаксис
LISTEN канал
Описание
LISTEN регистрирует текущий сеанс для получения уведомления через канал с заданным именем
(канал). Если текущий сеанс уже зарегистрирован и ожидает уведомления через этот канал, ни-
чего не происходит.
Когда вызывается команда NOTIFY канал (в текущем или другом сеансе, подключённом к той же
базе данных), все сеансы, ожидающие уведомления через заданный канал, получают уведомление
и каждый, в свою очередь, передаёт его подключённому клиентскому приложению.
Сеанс может отказаться от получения уведомлений через определённый канал с помощью коман-
ды UNLISTEN. Кроме того, подписка на любые уведомления автоматически отменяется при завер-
шении сеанса.
Способ получения уведомлений клиентским приложением определяется программным интерфей-
сом PostgreSQL, который оно использует. Приложение, использующее библиотеку libpq, выполня-
ет команду LISTEN как обычную команду SQL, а затем оно должно периодически вызывать функ-
цию PQnotifies, чтобы проверить, не поступили ли новые уведомления. Другие интерфейсы, на-
пример libpgtcl, предоставляют более высокоуровневые методы для обработки событий уведомле-
ний; на самом деле с libpgtcl разработчик приложения даже не должен непосредственно выпол-
нять команды LISTEN и UNLISTEN. За дополнительными подробностями обратитесь к документации
интерфейса, который вы используете.
В описании NOTIFY использование LISTEN и NOTIFY рассматривается более подробно.
Параметры
канал
Имя канала уведомлений (любой идентификатор).
Замечания
LISTEN начинает действовать при фиксировании транзакции. Если LISTEN или UNLISTEN выполня-
ется в транзакции, которая затем откатывается, состояние подписки этого сеанса на уведомления
не меняется.
Транзакция, в которой выполняется LISTEN, не может быть подготовлена для двухфазной фикса-
ции.
Примеры
Демонстрация процедуры ожидания/получения уведомления в psql:
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification “virtual” received from server process with PID 8448.
Совместимость
Оператор LISTEN отсутствует в стандарте SQL.
1659LISTEN
См. также
NOTIFY, UNLISTEN
1660LOAD
LOAD — загрузить файл разделяемой библиотеки
Синтаксис
LOAD ‘имя_файла’
Описание
Эта команда загружает файл разделяемой библиотеки в адресное пространство сервера
PostgreSQL. Если указанный файл был загружен ранее, эта команда не делает ничего. Файлы биб-
лиотек, содержащие функции на C, загружаются автоматически при первом вызове любой из этих
функций. Поэтому явно выполнять LOAD обычно требуется только для загрузки библиотек, которые
изменяют поведение сервера, внедряя свои обработчики, а не предоставляют некоторый набор
функций.
Имя файла библиотеки обычно задаётся собственно именем файла, а полный путь определяется
при просмотре пути поиска библиотек сервера (задаваемого в dynamic_library_path). Также в каче-
стве имени может быть передан непосредственно полный путь. В любом случае расширение имени
файла, стандартное для файлов разделяемых библиотек на данной платформе, можно опустить.
Дополнительную информацию по этой теме можно найти в Подразделе 38.10.1.
Обычные пользователи (не суперпользователи) могут использовать LOAD только для загрузки фай-
лов библиотек, расположенных в $libdir/plugins/ — заданное имя_файла должно начинаться
именно с этой строки. (Ответственность за то, чтобы в этом каталоге находились только «безопас-
ные» библиотеки, лежит на администраторе баз данных.)
Совместимость
LOAD является расширением PostgreSQL.
См. также
CREATE FUNCTION
1661LOCK
LOCK — заблокировать таблицу
Синтаксис
LOCK [ TABLE ] [ ONLY ] имя [ * ] [, …] [ IN режим_блокировки MODE ] [ NOWAIT ]
Где режим_блокировки может быть следующим:
ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
| SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE
Описание
LOCK TABLE получает блокировку на уровне таблицы, при необходимости ожидая освобождения
таблицы от других конфликтующих блокировок. Если указано NOWAIT, LOCK TABLE не ждёт, пока
таблица освободится: если блокировку нельзя получить немедленно, команда прерывается и вы-
даётся ошибка. Как только блокировка получена, она удерживается до завершения текущей тран-
закции. (Команды UNLOCK TABLE не существует; блокировки всегда освобождаются в конце тран-
закции.)
Когда блокируется представление, блокировка с тем же режимом рекурсивно распределяется на
все отношения, фигурирующие в определяющем представление запросе.
Запрашивая автоматические блокировки для команд, работающих с таблицами, PostgreSQL все-
гда выбирает наименее ограничивающий режим блокировки из возможных. Оператор LOCK TABLE
предназначен для случаев, когда требуется более сильная блокировка. Например, предположим,
что приложение выполняет транзакцию на уровне изоляции READ COMMITTED и оно должно полу-
чать неизменные данные на протяжении всей транзакции. Для достижения этой цели можно по-
лучить для таблицы блокировку в режиме SHARE, прежде чем обращаться к ней. В результате па-
раллельные изменения данных будут исключены и при последующих чтениях будет получено ста-
бильное представление зафиксированных данных, так как режим блокировки SHARE конфликтует
с блокировкой ROW EXCLUSIVE, запрашиваемой при записи, а LOCK TABLE имя IN SHARE MODE будет
ждать, пока параллельные транзакции с блокировкой ROW EXCLUSIVE не будут зафиксированы или
отменены. Таким образом, в момент получения такой блокировки не останется ни одной открытой
незафиксированной операции записи; кроме того, никто не сможет записывать в таблицу, пока
блокировка не будет снята.
Чтобы получить похожий эффект в транзакции на уровне изоляции REPEATABLE READ или
SERIALIZABLE, необходимо выполнить оператор LOCK TABLE перед первым SELECT или операто-
ром, изменяющим данные. Представление данных для транзакции уровня REPEATABLE READ или
SERIALIZABLE будет заморожено в момент, когда начнёт выполняться этот запрос. Если команда
LOCK TABLE выполняется в транзакции позже, она так же исключает параллельную запись, но не
даёт гарантии, что транзакция будет читать последние зафиксированные данные.
Если в транзакции такого рода требуется изменять данные в таблице, для неё следует использовать
режим блокировки SHARE ROW EXCLUSIVE вместо SHARE. Этот режим гарантирует, что в один мо-
мент времени будет выполняться только одна транзакция такого типа. Без этого ограничения воз-
можна взаимоблокировка: две транзакции могут одновременно получить блокировки SHARE, после
чего они не смогут получить блокировку ROW EXCLUSIVE, чтобы собственно выполнить изменения.
(Заметьте, что собственные блокировки транзакции никогда не конфликтуют, так что транзакция
может получить блокировку ROW EXCLUSIVE, когда она владеет блокировкой SHARE — но не тогда,
когда блокировку SHARE удерживает другая транзакция.) Чтобы не допустить взаимоблокировок,
убедитесь, что все транзакции запрашивают блокировки одних объектов в одинаковом порядке, и
если для одного объекта запрашиваются блокировки в разных режимах, транзакции всегда долж-
ны запрашивать самую строгую блокировку.
1662LOCK
Дополнительно о режимах и стратегиях блокировки можно узнать в Разделе 13.3.
Параметры
имя
Имя (возможно, дополненное схемой) существующей таблицы, для которой запрашивается бло-
кировка. Если перед именем таблицы указано ONLY, блокируется только заданная таблица. Без
ONLY блокируется и заданная таблица, и все её потомки (если таковые есть). После имени таб-
лицы можно также добавить необязательное указание *, чтобы явно обозначить, что блокиров-
ка затрагивает и все дочерние таблицы.
Команда LOCK TABLE a, b; равнозначна последовательности LOCK TABLE a; LOCK TABLE b;.
Таблицы блокируются по одной в порядке, заданном в команде LOCK TABLE.
режим_блокировки
Режим блокировки определяет, с какой блокировкой будет конфликтовать данная. Режимы бло-
кировок описаны в Разделе 13.3.
Если режим блокировки не указан, применяется самый строгий режим, ACCESS EXCLUSIVE.
NOWAIT
Указывает, что LOCK TABLE не должна ожидать освобождения конфликтующих блокировок: если
запрошенная блокировка не может быть получена немедленно, транзакция прерывается.
Замечания
LOCK TABLE … IN ACCESS SHARE MODE требует наличия права SELECT в целевой таблице. LOCK
TABLE … IN ROW EXCLUSIVE MODE требует наличия прав INSERT, UPDATE, DELETE или TRUNCATE для
целевой таблицы. Все другие формы LOCK требуют наличия права UPDATE, DELETE или TRUNCATE на
уровне таблицы.
Пользователь, выполняющий операцию блокировки представления, должен иметь соответствую-
щее право для этого представления. Кроме того, владелец представления должен иметь сопут-
ствующие права в нижележащих базовых отношениях, хотя пользователь, устанавливающую бло-
кировку, может этих прав не иметь.
Вне блока транзакции команда LOCK TABLE бесполезна: блокировка сохранится только до заверше-
ния операции. Поэтому PostgreSQL выдаёт ошибку при попытке применить LOCK не в блоке тран-
закции. Чтобы определить блок транзакции, используйте BEGIN и COMMIT (или ROLLBACK).
LOCK TABLE может устанавливать только блокировки на уровне таблицы, так что все имена режи-
мов, включающие слово ROW (строка), не совсем корректны. Следует воспринимать их так, что в
этих режимах пользователь намеревается получать в заблокированной таблице блокировки уров-
ня строк. Также учтите, что в режиме ROW EXCLUSIVE устанавливается разделяемая блокировка
таблицы. Заметьте, что применительно к LOCK TABLE все режимы блокировки действуют одинако-
во, отличаются только правила, определяющие, какой режим с каким конфликтует. Чтобы узнать,
как получить блокировку именно на уровне строк, обратитесь к Подразделу 13.3.2 и Подразделу
«Предложение блокировки» в справочной документации SELECT.
Примеры
Получение блокировки SHARE для первичного ключа таблицы при добавлении записи в подчинён-
ную таблицу:
BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films
WHERE name = ‘Star Wars: Episode I - The Phantom Menace’;
1663LOCK
– Если запись не будет возвращена, произойдёт откат транзакции
INSERT INTO films_user_comments VALUES
(_id</em>, ‘GREAT! I was waiting for it for so long!’);
COMMIT WORK;
Установление блокировки SHARE ROW EXCLUSIVE в таблице первичного ключа перед выполнением
операции удаления:
BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM films_user_comments WHERE id IN
(SELECT id FROM films WHERE rating &lt; 5);
DELETE FROM films WHERE rating &lt; 5;
COMMIT WORK;
Совместимость
Команда LOCK TABLE отсутствует в стандарте SQL, в нём уровни изоляции транзакции определя-
ются командой SET TRANSACTION. PostgreSQL поддерживает и этот вариант; подробнее это описано
в SET TRANSACTION.
За исключением ACCESS SHARE, ACCESS EXCLUSIVE и SHARE UPDATE EXCLUSIVE, режимы блокировки
в PostgreSQL и синтаксис LOCK TABLE совместимы с теми, что представлены в СУБД Oracle.
1664MOVE
MOVE — переместить курсор
Синтаксис
MOVE [ direction [ FROM | IN ] ] имя_курсора
Здесь direction может быть пустым или принимать следующее значение:
NEXT
PRIOR
FIRST
LAST
ABSOLUTE число
RELATIVE число
число
ALL
FORWARD
FORWARD число
FORWARD ALL
BACKWARD
BACKWARD число
BACKWARD ALL
Описание
MOVE перемещает курсор, не получая данные. Команда MOVE работает точно так же, как FETCH, но
она не возвращает данные строк, а только перемещает курсор.
Команда MOVE поддерживает те же параметры, что и FETCH; за подробным описанием её синтаксиса
и использования обратитесь к FETCH.
Выводимая информация
В случае успешного завершения, MOVE возвращает метку команды в виде
MOVE число
Здесь число показывает количество строк, которое бы выдала команда FETCH с такими же парамет-
рами (оно может быть нулевым).
Примеры
BEGIN WORK;
DECLARE liahona CURSOR FOR SELECT * FROM films;
– Пропустить первые 5 строк:
MOVE FORWARD 5 IN liahona;
MOVE 5
– Выбрать 6-ую строку из курсора liahona:
FETCH 1 FROM liahona;
code | title | did | date_prod | kind | len
——-+——–+—–+————+——–+——-
P_303 | 48 Hrs | 103 | 1982-10-22 | Action | 01:37
(1 row)
1665MOVE
– Закрыть курсор liahona и завершить транзакцию:
CLOSE liahona;
COMMIT WORK;
Совместимость
Оператор MOVE отсутствует в стандарте SQL.
См. также
CLOSE, DECLARE, FETCH
1666NOTIFY
NOTIFY — сгенерировать уведомление
Синтаксис
NOTIFY канал [ , сообщение ]
Описание
Команда NOTIFY отправляет событие уведомления вместе с дополнительной строкой «сообщения»
всем клиентским приложениям, которые до этого выполнили в текущей базе данных LISTEN канал
с указанным именем канала. Уведомления видны всем пользователям.
NOTIFY предоставляет простой механизм межпроцессного взаимодействия для множества процес-
сов, работающих с одной базой данных PostgreSQL. Вместе с уведомлением может быть передана
строка сообщения, а передавая дополнительные данные через таблицы базы данных, можно со-
здать более высокоуровневые механизмы обмена структурированными данными.
Информация, передаваемая клиенту с уведомлением, включает имя канала уведомлений, PID сер-
верного процесса, управляющего сеансом, который выдал уведомление, и строку сообщения (она
будет пустой, если сообщение не задано).
Выбор подходящих имён каналов и их назначения — дело проектировщика базы данных. Обычно
имя канала совпадает с именем какой-либо таблицы в базе, а событие уведомления по сути озна-
чает «я изменила эту таблицу, посмотрите, что она содержит теперь». Однако команды NOTIFY
и LISTEN не навязывают именно такой подход. Например, проектировщик базы данных может вы-
брать разные имена каналов, чтобы сигнализировать о разных типах изменений в одной таблице.
Кроме того, строку сообщения тоже можно использовать для выделения различных событий.
Если требуется сигнализировать о факте изменений в определённой таблице, используя NOTIFY,
можно применить полезный программный приём — поместить NOTIFY в триггер уровня оператора,
который будет срабатывать при изменениях в таблице. При таком подходе уведомление будет вы-
даваться автоматически, так что прикладной программист не рискует случайно оставить какое-ли-
бо изменение без уведомления.
Транзакции оказывают значительное влияние на работу NOTIFY. Во-первых, если NOTIFY выполня-
ется внутри транзакции, уведомления доставляются получателям после фиксирования транзак-
ции и только в этом случае. Это разумно, так как в случае прерывания транзакции действие всех
команд в ней аннулируется, включая NOTIFY. Однако это может обескуражить тех, кто ожидает,
что уведомления будут приходить немедленно. Во-вторых, если ожидающий сеанс получает уве-
домление внутри транзакции, это событие не будет доставлено подключённому клиенту до завер-
шения (фиксации или отката) транзакции. Это опять же объясняется тем, что если уведомление
будет доставлено в рамках транзакции, которая затем будет прервана, может возникнуть желание
как-то отменить его — но сервер не может «забрать назад» уведомление после того, как оно бы-
ло отправлено клиенту. Поэтому уведомления доставляются только между транзакциями. Учиты-
вая вышесказанное, в приложениях, применяющих NOTIFY для сигнализации в реальном времени,
следует минимизировать размер транзакций.
Если в рамках одной транзакции в один канал поступило несколько уведомлений с одинаковым
сообщением, сервер может решить доставить только одно уведомление. Если же сообщения раз-
личаются, уведомления будут всегда доставлены по отдельности. Так же уведомления, поступаю-
щие от разных транзакций, никогда не будут объединены в одно. Не считая фильтрации последу-
ющих экземпляров дублирующихся уведомлений, NOTIFY гарантирует, что уведомления от одной
транзакции всегда поступают в том же порядке, в каком были отправлены. Также гарантируется,
что сообщения от разных транзакций поступают в порядке фиксации этих транзакций.
Часто бывает, что клиент, выполнивший NOTIFY, ожидает уведомления на этом же канале. В этом
случае он получит своё же уведомление, как и любой другой сеанс, ожидающий уведомления. В
1667NOTIFY
зависимости от логики приложения, это может привести к бессмысленным операциям, например,
поиску изменений в таблице, которые и были внесены этим же сеансом. Этой дополнительной ра-
боты можно избежать, если проверить, не совпадает ли PID сигнализирующего процесса (указан-
ный в данных события) с собственным PID сеанса (его можно узнать, обратившись к libpq). Если
они совпадают, значит сеанс получил уведомление о собственных действиях, так что его можно
игнорировать.
Параметры
канал
Имя канала для передачи уведомления (любой идентификатор).
сообщение
Строка «сообщения», которая будет передана вместе с уведомлением. Она должна задаваться
простой текстовой константой. В стандартной конфигурации её длина должна быть меньше
8000 байт. (Если требуется передать двоичные данные или большой объём информации, лучше
поместить их в таблицу базы данных и передать ключ этой записи.)
Замечания
Уведомления, которые были отправлены, но ещё не обработаны всеми ожидающими сеансами, со-
держатся в очереди. Если эта очередь переполняется, транзакции, в которых вызывается NOTIFY,
будут завершены ошибкой при попытке фиксации. Очередь довольно велика (8 ГБ в стандартной
конфигурации), так что её размера должно хватать практически во всех случаях, но если в сеансе
выполняется LISTEN, а затем продолжается очень длительная транзакция, очередь не очищается.
Как только эта очередь заполняется наполовину, в журнал записываются предупреждения, в ко-
торых указывается, какой сеанс препятствует очистке очереди. В этом случае следует добиться
завершения текущей транзакции в указанном сеансе, чтобы очередь была очищена.
Функция pg_notification_queue_usage показывает, какой процент очереди в данный момент за-
нят ожидающими уведомлениями. За дополнительными сведениями обратитесь к Разделу 9.25.
Транзакция, в которой выполняется NOTIFY, не может быть подготовлена для двухфазной фикса-
ции.
pg_notify
Также отправить уведомление можно, используя функцию pg_notify(text, text). Эта функция
принимает в первом аргументе имя канала, а во втором текст сообщения. Гораздо удобнее исполь-
зовать её, когда требуется работать с динамическими именами каналов и сообщениями.
Примеры
Демонстрация процедуры ожидания/получения уведомления в psql:
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification “virtual” received from server process with PID 8448.
NOTIFY virtual, ‘This is the payload’;
Asynchronous notification “virtual” with payload “This is the payload” received from
server process with PID 8448.
LISTEN foo;
SELECT pg_notify(‘fo’ || ‘o’, ‘pay’ || ‘load’);
Asynchronous notification “foo” with payload “payload” received from server process
with PID 14728.
Совместимость
Оператор NOTIFY отсутствует в стандарте SQL.
1668NOTIFY
См. также
LISTEN, UNLISTEN
1669PREPARE
PREPARE — подготовить оператор к выполнению
Синтаксис
PREPARE имя [ ( тип_данных [, …] ) ] AS оператор
Описание
PREPARE создаёт подготовленный оператор. Подготовленный оператор представляет собой объект
на стороне сервера, позволяющий оптимизировать производительность приложений. Когда выпол-
няется PREPARE, указанный оператор разбирается, анализируется и переписывается. При последу-
ющем выполнении команды EXECUTE подготовленный оператор планируется и исполняется. Такое
разделение труда исключает повторный разбор запроса, при этом позволяет выбрать наилучший
план выполнения в зависимости от определённых значений параметров.
Подготовленные операторы могут принимать параметры — значения, которые подставляются в
оператор, когда он собственно выполняется. При создании подготовленного оператора к этим па-
раметрам можно обращаться по порядковому номеру, используя запись $1, $2 и т. д. Дополнитель-
но можно указать список соответствующих типов данных параметров. Если тип данных параметра
не указан или объявлен как unknown (неизвестный), тип выводится из контекста при первом обра-
щении к этому параметру (если это возможно). При выполнении оператора фактические значения
параметров передаются команде EXECUTE. За подробностями обратитесь к EXECUTE.
Подготовленные операторы существуют только в рамках текущего сеанса работы с БД. Когда се-
анс завершается, система забывает подготовленный оператор, так что его надо будет создать сно-
ва, чтобы использовать дальше. Это также означает, что один подготовленный оператор не может
использоваться одновременно несколькими клиентами базы данных; но каждый клиент может со-
здать собственный подготовленный оператор и использовать его. Освободить подготовленный опе-
ратор можно вручную, выполнив команду DEALLOCATE.
Подготовленные операторы потенциально дают наибольший выигрыш в производительности, ко-
гда в одном сеансе выполняется большое число однотипных операторов. Отличие в производи-
тельности особенно значительно, если операторы достаточно сложны для планирования или пе-
резаписи, например, когда в запросе объединяется множество таблиц или необходимо применить
несколько правил. Если оператор относительно прост в этом плане, но сложен для выполнения,
выигрыш от использования подготовленных операторов будет менее заметным.
Параметры
имя
Произвольное имя, назначаемое данному подготовленному оператору. Оно должно быть уни-
кальным в рамках одного сеанса; это имя затем используется для выполнения или освобожде-
ния ранее подготовленного оператора.
тип_данных
Тип данных параметра подготовленного оператора. Если тип данных конкретного параметра
не задан или задан как unknown, он будет выводиться из контекста при первом обращении к
этому параметру. Для обращения к параметрам в самом подготовленном операторе использу-
ется запись $1, $2 и т. д.
оператор
Любой оператор SELECT, INSERT, UPDATE, DELETE или VALUES.
1670PREPARE
Замечания
Подготовленные операторы могут использовать общие планы, а не перестраивать план для каж-
дого набора переданных значений EXECUTE. Для подготовленных операторов без параметров это
происходит сразу; иначе общий план выбирается после пяти и более выполнений, при которых
получаются планы с ожидаемой средней стоимостью (включая издержки планирования), превы-
шающей оценку стоимости общего плана. Когда общий план выбран, он будет использоваться до
конца жизни подготовленного оператора. При использовании значений EXECUTE, которые редко
встречаются в столбцах со множеством дублирующихся значений, могут быть построены специ-
ализированные планы настолько выгоднее общего плана, что даже с издержками планирования
общий план может не использоваться никогда.
Для общего плана предполагается, что значения, передаваемые в EXECUTE, являются уникальны-
ми значениями в столбце и что эти значения распределены равномерно. Например, если в стати-
стике записаны три различных значения столбца, с общим планом предполагается, что проверке
на равенство для столбца будут соответствовать 33% обработанных строк. Статистика по столб-
цам также позволяет общим планам точно вычислять избирательность для уникальных столбцов.
Сравнения по столбцам с неоднородным распределением и указания несуществующих значений
влияют на среднюю стоимость плана и следовательно, на то, будет ли выбран общий план и когда.
Чтобы узнать, какой план выполнения выбирает PostgreSQL для подготовленного оператора, вос-
пользуйтесь EXPLAIN (например, напишите EXPLAIN EXECUTE). Если применяется общий план, он
будет содержать символы параметров $n, тогда как в специализированном плане будут подставле-
ны фактические значения параметров. Оценки строк в общем плане отражают избирательность,
вычисленную для конкретных параметров.
Более подробно о планировании запросов и статистике, которую собирает PostgreSQL для этих
целей, можно узнать в документации ANALYZE.
Хотя основной смысл подготовленных операторов в том, чтобы избежать многократного разбора
и планирования оператора, PostgreSQL будет принудительно заново анализировать и планировать
выполнение оператора всякий раз, когда объекты базы данных, задействованные в операторе, под-
вергаются изменениям определения (DDL) со времени предыдущего использования подготовлен-
ного оператора. Кроме того, если от одного использования оператора к другому меняется значе-
ние search_path, оператор будет так же разобран заново с новым search_path. (Последнее поведе-
ние появилось в PostgreSQL 9.3.) С этими правилами использование подготовленного оператора
по сути почти не отличается от выполнения одного и того же запроса снова и снова, но даёт выиг-
рыш по скорости (если определения объектов не меняются), особенно если оптимальный план от
раза к разу не меняется. Однако различия всё же могут проявиться — например, когда оператор
обращается к таблице по неполному имени, а затем в схеме, стоящей в пути search_path раньше,
создаётся другая таблица с таким же именем, автоматический пересмотр запроса не происходит,
так как никакой объект в определении оператора не изменился. Однако, если автоматический пе-
ресмотр произойдёт в результате других изменений, при последующем выполнении запроса будет
задействована новая таблица.
Получить список всех доступных в сеансе подготовленных операторов можно, обратившись к си-
стемному представлению pg_prepared_statements.
Примеры
Создание подготовленного оператора для команды INSERT, который затем выполняется:
PREPARE fooplan (int, text, bool, numeric) AS
INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, ‘Hunter Valley’, ‘t’, 200.00);
Создание подготовленного оператора для команды SELECT, который затем выполняется:
PREPARE usrrptplan (int) AS
SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid
1671PREPARE
AND l.date = $2;
EXECUTE usrrptplan(1, current_date);
Заметьте, что тип данных второго параметра не указывается, так что он выводится из контекста,
в котором используется $2.
Совместимость
В стандарте SQL есть оператор PREPARE, но он предназначен только для применения во встраива-
емом SQL. Эта версия оператора PREPARE имеет также несколько другой синтаксис.
См. также
DEALLOCATE, EXECUTE
1672PREPARE TRANSACTION
PREPARE TRANSACTION — подготовить текущую транзакцию для двухфазной фиксации
Синтаксис
PREPARE TRANSACTION id_транзакции
Описание
PREPARE TRANSACTION подготавливает текущую транзакцию для двухфазной фиксации. После этой
команды транзакция перестаёт быть связанной с текущим сеансом; её состояние полностью со-
храняется на диске, и есть очень большая вероятность, что она будет успешно зафиксирована, да-
же если до этого времени работа базы данных будет прервана аварийно.
Подготовленную транзакцию затем можно зафиксировать или отменить командами COMMIT
PREPARED и ROLLBACK PREPARED, соответственно. Эти команды можно вызывать из любого се-
анса, не только из того, в котором эта транзакция создавалась.
С точки зрения сеанса, выполняющего команду, PREPARE TRANSACTION не отличается от ROLLBACK:
после её выполнения не активна никакая транзакция, а результат действия подготовленной тран-
закции становится невидимым (Он окажется видимым снова, если транзакция будет зафиксиро-
вана.)
Если при выполнении команды PREPARE TRANSACTION по какой-то причине происходит сбой, ко-
манда действует как ROLLBACK: текущая транзакция откатывается.
Параметры
id_транзакции
Произвольный идентификатор, по которому затем на эту транзакцию будут ссылаться команды
COMMIT PREPARED или ROLLBACK PREPARED. Идентификатор должен задаваться строковой кон-
стантой не длиннее 200 байтов и должен отличаться от идентификаторов любых других подго-
товленных на данный момент транзакций.
Замечания
PREPARE TRANSACTION не предназначена для использования в приложениях или интерактивных се-
ансах. Её задача — дать возможность внешнему менеджеру транзакций выполнять атомарные гло-
бальные транзакции, охватывающие несколько баз данных или другие транзакционные ресурсы.
Обычно применять PREPARE TRANSACTION следует только при разработке собственного менеджера
транзакций.
Эта команда должна выполняться внутри блока транзакции. Начинает блок транзакции команда
BEGIN.
В настоящее время команда PREPARE неспособна подготавливать транзакции, в которых выполня-
лись какие-либо действия с временными таблицами, создавались курсоры WITH HOLD либо выпол-
нялись команды LISTEN, UNLISTEN или NOTIFY. Эти функции слишком тесно связаны с текущим се-
ансом, так что в подготовленной транзакции они не были бы полезны.
Если транзакция меняет какие-либо параметры времени выполнения командой SET (без указания
LOCAL), их значения сохраняются после PREPARE TRANSACTION и не зависят от последующих команд
COMMIT PREPARED и ROLLBACK PREPARED. Так что в этом отношении PREPARE TRANSACTION больше
похожа на COMMIT, чем на ROLLBACK.
Все существующие в текущий момент подготовленные транзакции показываются в системном
представлении pg_prepared_xacts.
1673PREPARE TRANSACTION
Внимание
Оставлять транзакции в подготовленном состоянии на долгое время не рекомендуется.
Это повлияет на способность команды VACUUM высвобождать пространство, а в крайнем
случае может привести к отключению базы данных для предотвращения зацикливания
ID транзакций (см. Подраздел 24.1.5). Также учтите, что транзакция продолжит удер-
живать все свои блокировки. Это сделано с расчётом на то, что подготовленная тран-
закция будет зафиксирована или отменена как только внешний менеджер транзакций
убедится, что все другие базы данных так же готовы к фиксации.
В отсутствие настроенного внешнего менеджера транзакций, который бы отслеживал
подготовленные транзакции и своевременно закрывал их, лучше вовсе отключить под-
держку подготовленных транзакций, установив max_prepared_transactions равным ну-
лю. Это не позволит случайно создать подготовленные транзакции, которые могут быть
забыты и в конце концов станут причиной проблем.
Примеры
Текущая транзакция подготавливается для двухфазной фиксации, при этом ей назначается иден-
тификатор foobar:
PREPARE TRANSACTION ‘foobar’;
Совместимость
Оператор PREPARE TRANSACTION является расширением PostgreSQL. Он предназначен для исполь-
зования внешними системами управления транзакциями, некоторые из которых работают по стан-
дартам (например, X/Open XA), но сторона SQL в этих системах не стандартизирована.
См. также
COMMIT PREPARED, ROLLBACK PREPARED
1674REASSIGN OWNED
REASSIGN OWNED — сменить владельца объектов базы данных, принадлежащих заданной роли
Синтаксис
REASSIGN OWNED BY ( старая_роль | CURRENT_USER | SESSION_USER ) [, …]
TO ( новая_роль | CURRENT_USER | SESSION_USER )
Описание
REASSIGN OWNED указывает системе сменить владельца объектов баз данных, принадлежащих одной
из старых_ролей, на новую_роль.
Параметры
старая_роль
Имя роли. Все объекты в текущей базе данных и все общие объекты (базы данных, табличные
пространства), принадлежащие этой роли, станут принадлежать новой_роли.
новая_роль
Имя роли, которая станет новым владельцем затронутых объектов.
Замечания
REASSIGN OWNED часто применяется при подготовке к удалению одной или нескольких ролей. Так
как команда REASSIGN OWNED затрагивает объекты только в текущей базе данных, обычно её нужно
выполнять в каждой базе данных, которая содержит объекты, принадлежащие удаляемой роли.
Для выполнения REASSIGN OWNED необходимо быть членом и исходной, и целевой роли.
Команда DROP OWNED предлагает альтернативное решение, просто удаляя все объекты в базе
данных, принадлежащие одной или нескольким заданным ролям.
Команда REASSIGN OWNED не затрагивает никакие права, которые даны старым_ролям для объектов,
им не принадлежащим. Отозвать эти права можно, воспользовавшись командой DROP OWNED.
За подробностями обратитесь к Разделу 21.4.
Совместимость
Оператор REASSIGN OWNED является расширением PostgreSQL.
См. также
DROP OWNED, DROP ROLE, ALTER DATABASE
1675REFRESH MATERIALIZED VIEW
REFRESH MATERIALIZED VIEW — заменить содержимое материализованного представления
Синтаксис
REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] имя
[ WITH [ NO ] DATA ]
Описание
REFRESH MATERIALIZED VIEW полностью заменяет содержимое материализованного представления.
Эту команду разрешено выполнять только владельцам мат. представления. Старое его содержимое
при этом аннулируется. Если добавлено указание WITH DATA (или нет никакого), нижележащий
запрос выполняется и выдаёт новые данные, так что материализованное представление остаётся в
сканируемом состоянии. Если указано WITH NO DATA, новые данные не выдаются, и оно оказывается
в несканируемом состоянии.
Указать CONCURRENTLY вместе с WITH NO DATA нельзя.
Параметры
CONCURRENTLY
Обновить материализованное представление, не блокируя параллельные выборки из него. Без
данного параметра обновление, затрагивающее много строк, обычно задействует меньше ре-
сурсов и выполнится быстрее, но может препятствовать чтению этого материализованного
представления другими сеансами. При этом данный режим может быть быстрее при неболь-
шом количестве строк.
Данный параметр допускается, только если в материализованном представлении есть хотя бы
один индекс UNIQUE, построенный только по именам столбцов и включающий все строки; то
есть, в нём не должно быть выражений и предложения WHERE.
Этот параметр нельзя использовать, когда материализованное представление ещё не наполне-
но.
Даже с этим параметром в один момент времени допускается только одно обновление (REFRESH)
материализованного представления.
имя
Имя (возможно, дополненное схемой) материализованного представления, подлежащего об-
новлению.
Замечания
Тогда как индекс по умолчанию для операций CLUSTER команда REFRESH MATERIALIZED VIEW со-
храняет, она не упорядочивает генерируемые строки по нему. Если генерируемые данные необхо-
димо упорядочить, в определяющем запросе нужно явно указать ORDER BY.
Примеры
Эта команда заменяет содержимое материализованного представления order_summary, используя
запрос из определения материализованного представления, и оставляет его в сканируемом состо-
янии:
REFRESH MATERIALIZED VIEW order_summary;
Эта команда освобождает пространство, связанное с материализованным представлением
annual_statistics_basis, и оставляет это представление в несканируемом состоянии:
1676REFRESH MATERIALIZED VIEW
REFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;
Совместимость
REFRESH MATERIALIZED VIEW — расширение PostgreSQL.
См. также
CREATE MATERIALIZED VIEW, ALTER MATERIALIZED VIEW, DROP MATERIALIZED VIEW
1677REINDEX
REINDEX — перестроить индексы
Синтаксис
REINDEX [ ( VERBOSE ) ] ( INDEX | TABLE | SCHEMA | DATABASE | SYSTEM ) имя
Описание
REINDEX перестраивает индекс, обрабатывая данные таблицы, к которой относится индекс, и в ре-
зультате заменяет старую копию индекса. Команда REINDEX применяется в следующих ситуациях:
• Индекс был повреждён, его содержимое стало некорректным. Хотя в теории этого не должно
случаться, на практике индексы могут испортиться из-за программных ошибок или аппарат-
ных сбоев. В таких случаях REINDEX служит методом восстановления индекса.
• Индекс стал «раздутым», то есть в нём оказалось много пустых или почти пустых страниц.
Это может происходить с B-деревьями в PostgreSQL при определённых, достаточно редких
сценариях использования. REINDEX даёт возможность сократить объём, занимаемый индексом,
записывая новую версию индекса без «мёртвых» страниц. За подробностями обратитесь к Раз-
делу 24.2.
• Параметр хранения индекса (например, фактор заполнения) был изменён, и теперь требует-
ся, чтобы это изменение вступило в силу в полной мере.
• Построение индекса с параметром CONCURRENTLY завершилось ошибкой, в результате чего
индекс оказался «нерабочим». Такие индексы бесполезны, но команда REINDEX предостав-
ляет удобный способ перестроить их. Однако заметьте, что REINDEX перестраивает индекс
не в параллельном режиме. Чтобы перестроить такой индекс, минимизируя влияние на про-
изводственную среду, его следует удалить, а затем снова выполнить команду CREATE INDEX
CONCURRENTLY.
Параметры
INDEX
Перестраивает указанный индекс.
TABLE
Перестраивает все индексы в указанной таблице. Если у таблицы имеется дополнительная таб-
лица «TOAST», она так же переиндексируется.
SCHEMA
Перестраивает все индексы в указанной схеме. Если таблица в этой схеме имеет вторичную
таблицу «TOAST», она также будет переиндексирована. При этом обрабатываются и индексы
в общих системных каталогах. Эту форму REINDEX нельзя выполнить в блоке транзакции.
DATABASE
Перестраивает все индексы в текущей базе данных. При этом обрабатываются также индексы
в общих системных каталогах. Эту форму REINDEX нельзя выполнить в блоке транзакции.
SYSTEM
Перестраивает все индексы в системных каталогах текущей базы данных. При этом обрабаты-
ваются также индексы в общих системных каталогах, но индексы в таблицах пользователя не
затрагиваются. Эту форму REINDEX нельзя выполнить в блоке транзакции.
1678REINDEX
имя
Имя определённого индекса, таблицы или базы данных, подлежащих переиндексации. В насто-
ящее время REINDEX DATABASE и REINDEX SYSTEM могут переиндексировать только текущую базу
данных, так что их параметр должен соответствовать имени текущей базы данных.
VERBOSE
Выводит отчёт о прогрессе после переиндексации каждого индекса.
Замечания
В случае подозрений в повреждении индекса таблицы пользователя, этот индекс или все индексы
таблицы можно перестроить, используя команду REINDEX INDEX или REINDEX TABLE.
Всё усложняется, если возникает необходимость восстановить повреждённый индекс системной
таблицы. В этом случае важно, чтобы система сама не использовала этот индекс. (На самом деле
в таких случаях вы, скорее всего, столкнётесь с падением процессов сервера в момент запуска,
как раз вследствие испорченных индексов.) Чтобы надёжно восстановить рабочее состояние, сер-
вер следует запускать с параметром -P, который отключает использование индексов при поиске
в системных каталогах.
Один из вариантов сделать это — выключить сервер PostgreSQL и запустить его снова в одно-
пользовательском режиме, с параметром -P в командной строке. Затем можно выполнить REINDEX
DATABASE, REINDEX SYSTEM, REINDEX TABLE или REINDEX INDEX, в зависимости от того, что вы хотите
восстановить. В случае сомнений выполните REINDEX SYSTEM, чтобы перестроить все системные
индексы в базе данных. Затем завершите однопользовательский сеанс сервера и перезапустите
сервер в обычном режиме. Чтобы подробнее узнать, как работать с сервером в однопользователь-
ском интерфейсе, обратитесь к справочной странице postgres.
Можно так же запустить обычный экземпляр сервера, но добавить в параметры командной строки
-P. В разных клиентах это может делаться по-разному, но во всех клиентах на базе libpq можно
установить для переменной окружения PGOPTIONS значение -P до запуска клиента. Учтите, что
хотя этот метод не препятствует работе других клиентов, всё же имеет смысл не позволять им
подключаться к повреждённой базе данных до завершения восстановления.
Действие REINDEX подобно удалению и пересозданию индекса в том смысле, что содержимое ин-
декса пересоздаётся с нуля, но блокировки при этом устанавливаются другие. REINDEX блокирует
запись, но не чтение родительской таблицы индекса. Эта команда также устанавливает исключи-
тельную блокировку для обрабатываемого индекса, что блокирует чтение таблицы, при котором
задействуется этот индекс. DROP INDEX, напротив, моментально устанавливает исключительную
блокировку на родительскую таблицу, блокируя и запись, и чтение. Последующая команда CREATE
INDEX блокирует запись, но не чтение; так как индекс отсутствует, обращений к нему ни при каком
чтении не будет, что означает, что блокироваться чтение не будет, но выполняться оно будет как
дорогостоящее последовательное сканирование.
Для перестраивания одного индекса или индексов таблицы необходимо быть владельцем этого ин-
декса или таблицы. Для переиндексирования схемы или базы данных необходимо быть владельцем
этой схемы или базы. Заметьте, что вследствие этого в некоторых случаях не только суперпользо-
ватели могут перестраивать индексы таблиц, принадлежащих другим пользователям. Однако из
этих правил есть исключение — когда команду REINDEX DATABASE, REINDEX SCHEMA или REINDEX
SYSTEM выполняет не суперпользователь, индексы общих каталогов будут пропускаться, если толь-
ко данный каталог не принадлежит этому пользователю (как правило, это так). Разумеется, супер-
пользователи могут переиндексировать всё без ограничений.
Переиндексирование секционированных таблиц или секционированных индексов не поддержива-
ется. Переиндексировать можно каждую секцию по отдельности.
Примеры
Перестроение одного индекса:
1679REINDEX
REINDEX INDEX my_index;
Перестроение всех индексов таблицы my_table:
REINDEX TABLE my_table;
Перестроение всех индексов в определённой базе данных, в предположении, что целостность си-
стемных индексов под сомнением:
$ export PGOPTIONS=”-P”
$ psql broken_db
…
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
Совместимость
Команда REINDEX отсутствует в стандарте SQL.
1680RELEASE SAVEPOINT
RELEASE SAVEPOINT — высвободить ранее определённую точку сохранения
Синтаксис
RELEASE [ SAVEPOINT ] имя_точки_сохранения
Описание
RELEASE SAVEPOINT уничтожает точку сохранения, определённую ранее в текущей транзакции.
После уничтожения точка сохранения становится неприменимой в качестве точки возврата, но
никаких других проявлений, видимых для пользователя, эта команда не имеет. Она не отменяет
эффекта команд, выполненных после установки точки сохранения. (Для этого предназначена ко-
манда ROLLBACK TO SAVEPOINT.) Уничтожение точки сохранения, когда она становится не нуж-
на, позволяет системе освобождать некоторые ресурсы раньше, чем завершается транзакция.
RELEASE SAVEPOINT также уничтожает все точки сохранения, установленные после заданной точ-
ки.
Параметры
имя_точки_сохранения
Имя точки сохранения, подлежащей уничтожению.
Замечания
Указание имени точки сохранения, не определённой ранее, считается ошибкой.
Освободить точку сохранения в транзакции, находящейся в прерванном состоянии, нельзя.
Если одно имя дано нескольким точкам сохранения, освобождена будет только последняя из них.
Примеры
Этот пример показывает, как установить и затем уничтожить точку сохранения:
BEGIN;
INSERT INTO table1 VALUES (3);
SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (4);
RELEASE SAVEPOINT my_savepoint;
COMMIT;
Данная транзакция вставит значения 3 и 4.
Совместимость
Эта команда соответствует стандарту SQL. В стандарте говорится, что ключевое слово SAVEPOINT
является обязательным, но PostgreSQL позволяет опускать его.
См. также
BEGIN, COMMIT, ROLLBACK, ROLLBACK TO SAVEPOINT, SAVEPOINT
1681RESET
RESET — восстановить значение по умолчанию заданного параметра времени выполнения
Синтаксис
RESET параметр_конфигурации
RESET ALL
Описание
RESET сбрасывает параметры времени выполнения к значениям по умолчанию. RESET — альтерна-
тивное написание команды
SET параметр_конфигурации TO DEFAULT
За подробностями обратитесь к SET.
Значение по умолчанию определяется как значение, которое имел бы этот параметр, если бы для
него не выполнялась команда SET в текущем сеансе. Фактическое значение может быть задано в
компилируемом коде, файле конфигурации, параметрах командной строки или в параметрах по
умолчанию для базы данных или пользователя. Если определить его как «значение, которое имеет
параметр в начале сеанса», это будет не вполне корректно, так как оно будет сброшено к тому,
что задано в файле конфигурации в данный момент. За подробностями обратитесь к Главе 19.
Транзакционное поведение команды RESET не отличается от SET: её действие будет отменено при
откате транзакции.
Параметры
параметр_конфигурации
Имя устанавливаемого параметра конфигурации времени выполнения. Доступные параметры
описаны в Главе 19 и на справочной странице SET.
ALL
Сбрасывает к значениям по умолчанию все устанавливаемые параметры времени выполнения.
Примеры
Сброс конфигурационной переменной timezone к значению по умолчанию:
RESET timezone;
Совместимость
RESET является расширением PostgreSQL.
См. также
SET, SHOW
1682REVOKE
REVOKE — отозвать права доступа
Синтаксис
REVOKE [ GRANT OPTION FOR ]
( ( SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER )
[, …] | ALL [ PRIVILEGES ] )
ON ( [ TABLE ] имя_таблицы [, …]
| ALL TABLES IN SCHEMA имя_схемы [, …] )
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( ( SELECT | INSERT | UPDATE | REFERENCES ) ( имя_столбца [, …] )
[, …] | ALL [ PRIVILEGES ] ( имя_столбца [, …] ) )
ON [ TABLE ] имя_таблицы [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( ( USAGE | SELECT | UPDATE )
[, …] | ALL [ PRIVILEGES ] )
ON ( SEQUENCE имя_последовательности [, …]
| ALL SEQUENCES IN SCHEMA имя_схемы [, …] )
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( ( CREATE | CONNECT | TEMPORARY | TEMP ) [, …] | ALL [ PRIVILEGES ] )
ON DATABASE имя_бд [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | ALL [ PRIVILEGES ] )
ON DOMAIN имя_домена [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | ALL [ PRIVILEGES ] )
ON FOREIGN DATA WRAPPER имя_обёртки_сторонних_данных [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | ALL [ PRIVILEGES ] )
ON FOREIGN SERVER имя_сервера [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( EXECUTE | ALL [ PRIVILEGES ] )
ON ( ( FUNCTION | PROCEDURE | ROUTINE ) имя_функции [ ( [ [ режим_аргумента ]
[ имя_аргумента ] тип_аргумента [, …] ] ) ] [, …]
1683REVOKE
| ALL ( FUNCTIONS | PROCEDURES | ROUTINES ) IN SCHEMA имя_схемы [, …] )
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | ALL [ PRIVILEGES ] )
ON LANGUAGE имя_языка [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( ( SELECT | UPDATE ) [, …] | ALL [ PRIVILEGES ] )
ON LARGE OBJECT oid_БО [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( ( CREATE | USAGE ) [, …] | ALL [ PRIVILEGES ] )
ON SCHEMA имя_схемы [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( CREATE | ALL [ PRIVILEGES ] )
ON TABLESPACE табл_пространство [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ GRANT OPTION FOR ]
( USAGE | ALL [ PRIVILEGES ] )
ON TYPE имя_типа [, …]
FROM ( [ GROUP ] имя_роли | PUBLIC ) [, …]
[ CASCADE | RESTRICT ]
REVOKE [ ADMIN OPTION FOR ]
имя_роли [, …] FROM имя_роли [, …]
[ CASCADE | RESTRICT ]
Описание
Команда REVOKE лишает одну или несколько ролей прав, назначенных ранее. Ключевое слово
PUBLIC обозначает неявно определённую группу всех ролей.
Различные типы прав подробно рассматриваются в описании команды GRANT.
Заметьте, что любая конкретная роль получает в сумме права, данные непосредственно ей, права,
данные любой роли, в которую она включена, а также права, данные группе PUBLIC. Поэтому, на-
пример, лишение PUBLIC права SELECT не обязательно будет означать, что все роли лишатся права
SELECT для данного объекта: оно сохранится у тех ролей, которым оно дано непосредственно или
косвенно, через другую роль. Подобным образом, лишение права SELECT какого-либо пользователя
может не повлиять на его возможность пользоваться правом SELECT, если это право дано группе
PUBLIC или другой роли, в которую он включён.
Если указано GRANT OPTION FOR, отзывается только право передачи права, но не само право. Без
этого указания отзывается и право, и право распоряжаться им.
Если пользователь обладает правом с правом передачи и он дал его другим пользователям, по-
следнее право считается зависимым. Когда первый пользователь лишается самого права или пра-
ва передачи и существуют зависимые права, эти зависимые права также отзываются, если допол-
1684REVOKE
нительно указано CASCADE; в противном случае операция завершается ошибкой. Это рекурсивное
лишение прав затрагивает только права, полученные через цепочку пользователей, которую мож-
но проследить до пользователя, являющегося субъектом команды REVOKE. Таким образом, пользо-
ватели могут в итоге сохранить это право, если оно было также получено через других пользова-
телей.
Когда отзывается право доступа к таблице, с ним вместе автоматически отзываются соответству-
ющие права для каждого столбца таблицы (если такие права заданы). С другой стороны, если роли
были даны права для таблицы, лишение роли таких же прав на уровне отдельных столбцов ни на
что не влияет.
При лишении пользователя членства в роли GRANT OPTION меняется на ADMIN OPTION, в остальном
поведение команды похожее. Заметьте также, что эта форма команды не принимает избыточное
слово GROUP.
Замечания
Для просмотра прав, назначенных для существующих таблиц и столбцов, можно воспользоваться
командой \dp в psql. Формат её вывода рассматривается в описании GRANT. Для других, не таб-
личных объектов предусмотрены другие команды \d, которые могут показывать в том числе и на-
значенные для них права.
Пользователь может отзывать только те права, которые он дал другому непосредственно. Если,
например, пользователь A дал право с правом передачи пользователю B, а пользователь B, в свою
очередь, дал это право пользователю C, то пользователь A не сможет лишить этого права непо-
средственно C. Вместо этого, пользователь A может лишить права передачи права пользователя
B и использовать параметр CASCADE, чтобы этого права по цепочке лишился пользователь C. Или
же, например, если и A, и B дали одно и то же право C, то A сможет отозвать право, которое дал
он, но не пользователь B, так что в результате C всё равно будет иметь это право.
Если отозвать право доступа к объекту (с помощью REVOKE) попытается не владелец объекта, ко-
манда завершится ошибкой, если пользователь не имеет никаких прав для этого объекта. Если же
пользователь имеет какие-то права, команда будет выполняться, но пользователь сможет отозвать
только те права, которые даны ему с правом распоряжения ими. Формы REVOKE ALL PRIVILEGES
будут выдавать предупреждение, если у него вовсе нет таких прав, тогда как другие формы бу-
дут выдавать предупреждения, если пользователь не имеет права распоряжаться именно правами,
указанными в команде. (В принципе, эти утверждения применимы и к владельцу объекта, но ему
разрешено распоряжаться всем правами, поэтому такие ситуации невозможны.)
Если команду GRANT или REVOKE выполняет суперпользователь, эта команда выполняется так, как
будто её выполняет владелец затрагиваемого объекта. Так как все права в конце концов исхо-
дят от владельца объекта (возможно, косвенно по цепочке или через право распоряжением пра-
вом), суперпользователь может отозвать все права, но это может потребовать применения режима
CASCADE, как описывалось выше.
REVOKE также может быть выполнена ролью, которая не является владельцем заданного объекта,
но является членом роли-владельца, либо членом роли, имеющей права WITH GRANT OPTION для
этого объекта. В этом случае команда будет выполнена, как если бы её выполняла содержащая
роль, действительно владеющая объектом или имеющая права WITH GRANT OPTION. Например, если
таблица t1 принадлежит роли g1, членом которой является роль u1, то u1 может отзывать права
на использование t1, которые записаны как данные ролью g1. В том числе это могут быть права,
данные ролью u1, а также другими членами роли g1.
Если роль, выполняющая команду REVOKE, получила указанные права косвенно по нескольким пу-
тям членства ролей, какая именно роль будет выбрана для выполнения команды, не определено. В
таких случаях рекомендуется воспользоваться командой SET ROLE и переключиться на роль, кото-
рую хочется видеть в качестве выполняющей REVOKE. Если этого не сделать, могут быть отозваны
не те права, что планировалось, либо отозвать права вообще не удастся.
1685REVOKE
Примеры
Лишение группы public права добавлять данные в таблицу films:
REVOKE INSERT ON films FROM PUBLIC;
Лишение пользователя manuel всех прав для представления kinds:
REVOKE ALL PRIVILEGES ON kinds FROM manuel;
Заметьте, что на самом деле это означает «лишить всех прав, которые дал я».
Исключение из членов роли admins пользователя joe:
REVOKE admins FROM joe;
Совместимость
Замечания по совместимости, приведённые для команды GRANT, справедливы и для REVOKE. Стан-
дарт требует обязательного указания ключевого слова RESTRICT или CASCADE, но PostgreSQL под-
разумевает RESTRICT по умолчанию.
См. также
GRANT
1686ROLLBACK
ROLLBACK — прервать текущую транзакцию
Синтаксис
ROLLBACK [ WORK | TRANSACTION ]
Описание
ROLLBACK откатывает текущую транзакцию и приводит к аннулированию всех изменений, произ-
ведённых транзакцией.
Параметры
WORK
TRANSACTION
Необязательные ключевые слова, не оказывают никакого влияния.
Замечания
Чтобы завершить и зафиксировать транзакцию, используйте COMMIT.
При выполнении команды ROLLBACK вне блока транзакции выдаётся предупреждение и больше
ничего не происходит.
Примеры
Чтобы прервать все операции:
ROLLBACK;
Совместимость
В стандарте SQL описаны только две формы: ROLLBACK и ROLLBACK WORK. В остальном эта команда
полностью соответствует стандарту.
См. также
BEGIN, COMMIT, ROLLBACK TO SAVEPOINT
1687ROLLBACK PREPARED
ROLLBACK PREPARED — отменить транзакцию, которая ранее была подготовлена для двухфазной
фиксации
Синтаксис
ROLLBACK PREPARED id_транзакции
Описание
ROLLBACK PREPARED откатывает транзакцию в подготовленном состоянии.
Параметры
id_транзакции
Идентификатор транзакции, которую нужно откатить.
Замечания
Откатить подготовленную транзакцию может либо пользователь, выполнявший её изначально, ли-
бо суперпользователь. При этом не обязательно работать в том же сеансе, где выполнялась тран-
закция.
Эту команду нельзя выполнить внутри блока транзакции. Подготовленная транзакция откатыва-
ется немедленно.
Все существующие в текущий момент подготовленные транзакции показываются в системном
представлении pg_prepared_xacts.
Примеры
Откат транзакции, имеющей идентификатор foobar:
ROLLBACK PREPARED ‘foobar’;
Совместимость
Оператор ROLLBACK PREPARED является расширением PostgreSQL. Он предназначен для использо-
вания внешними системами управления транзакциями, некоторые из которых работают по стан-
дартам (например, X/Open XA), но сторона SQL в этих системах не стандартизирована.
См. также
PREPARE TRANSACTION, COMMIT PREPARED
1688ROLLBACK TO SAVEPOINT
ROLLBACK TO SAVEPOINT — откатиться к точке сохранения
Синтаксис
ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] имя_точки_сохранения
Описание
Откатывает все команды, выполненные после установления точки сохранения. Точка сохранения
остаётся действующей и при необходимости можно снова откатиться к ней позже.
ROLLBACK TO SAVEPOINT неявно уничтожает все точки сохранения, установленные после заданной
точки.
Параметры
имя_точки_сохранения
Точка сохранения, к которой нужно откатиться.
Замечания
Чтобы уничтожить точку сохранения, не отменяя действия команд, выполненных после неё, при-
меняется команда RELEASE SAVEPOINT.
Указание имени точки сохранения, не установленной ранее, считается ошибкой.
Курсоры проявляют не совсем транзакционное поведение применительно к точкам сохранения.
Любой курсор, открытый внутри точки сохранения, будет закрыт при откате к этой точке. Если
ранее открытый курсор был перемещён командой FETCH или MOVE внутри точки сохранения, к ко-
торой затем произошёл откат, курсор остаётся в той позиции, в которой он остался после FETCH (то
есть, перемещение курсора, производимое командой FETCH, не откатывается). Также при откате
не отменяется и закрытие курсора. Однако другие побочные эффекты, вызываемые запросом кур-
сора (например, побочные действия изменчивых функций, вызываемых в запросе) отменяются,
если они производятся после точки сохранения, к которой затем происходит откат. Курсор, вы-
полнение которого приводит к прерыванию транзакции, переводится в нерабочее состояние, так
что даже если восстановить транзакцию, выполнив ROLLBACK TO SAVEPOINT, этот курсор нельзя
будет использовать.
Примеры
Отмена действия команд, выполненных после установки точки сохранения my_savepoint:
ROLLBACK TO SAVEPOINT my_savepoint;
Откат к точке сохранения не отражается на положении курсора:
BEGIN;
DECLARE foo CURSOR FOR SELECT 1 UNION SELECT 2;
SAVEPOINT foo;
FETCH 1 FROM foo;
?column?
———-
1
1689ROLLBACK TO SAVEPOINT
ROLLBACK TO SAVEPOINT foo;
FETCH 1 FROM foo;
?column?
———-
2
COMMIT;
Совместимость
В стандарте SQL говорится, что ключевое слово SAVEPOINT является обязательным, но PostgreSQL
и Oracle позволяют опускать его. SQL допускает WORK, но не TRANSACTION, в качестве избыточного
слова после ROLLBACK. Кроме того, в SQL есть дополнительное предложение AND [ NO ] CHAIN, ко-
торое в настоящее время не поддерживается в PostgreSQL. В остальном эта команда соответствует
стандарту SQL.
См. также
BEGIN, COMMIT, RELEASE SAVEPOINT, ROLLBACK, SAVEPOINT
1690SAVEPOINT
SAVEPOINT — определить новую точку сохранения в текущей транзакции
Синтаксис
SAVEPOINT имя_точки_сохранения
Описание
SAVEPOINT устанавливает новую точку сохранения в текущей транзакции.
Точка сохранения — это специальная отметка внутри транзакции, которая позволяет откатить все
команды, выполненные после неё, и восстановить таким образом состояние на момент установки
этой точки.
Параметры
имя_точки_сохранения
Имя, назначаемое новой точке сохранения.
Замечания
Для отката к установленной точке сохранения предназначена команда ROLLBACK TO SAVEPOINT.
Чтобы уничтожить точку сохранения, сохраняя изменения, произведённые после того, как она
была установлена, применяется команда RELEASE SAVEPOINT.
Точки сохранения могут быть установлены только внутри блока транзакции. В одной транзакции
можно определить несколько точек сохранения.
Примеры
Установление точки сохранения и затем отмена действия всех команд, выполненных после уста-
новленной точки:
BEGIN;
INSERT INTO table1 VALUES (1);
SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (2);
ROLLBACK TO SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (3);
COMMIT;
Показанная транзакция вставит в таблицу значения 1 и 3, но не 2.
Этот пример показывает, как установить и затем уничтожить точку сохранения:
BEGIN;
INSERT INTO table1 VALUES (3);
SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (4);
RELEASE SAVEPOINT my_savepoint;
COMMIT;
Данная транзакция вставит значения 3 и 4.
Совместимость
Стандарт SQL требует, чтобы точка сохранения уничтожалась автоматически, когда устанавлива-
ется другая точка сохранения с тем же именем. В PostgreSQL старая точка сохранения остаётся,
1691SAVEPOINT
хотя при откате или уничтожении будет выбираться только самая последняя. (После уничтожения
последней точки командой RELEASE SAVEPOINT доступной для команд ROLLBACK TO SAVEPOINT и
RELEASE SAVEPOINT становится следующая.) В остальном оператор SAVEPOINT полностью соответ-
ствует стандарту.
См. также
BEGIN, COMMIT, RELEASE SAVEPOINT, ROLLBACK, ROLLBACK TO SAVEPOINT
1692SECURITY LABEL
SECURITY LABEL — определить или изменить метку безопасности, применённую к объекту
Синтаксис
SECURITY LABEL [ FOR провайдер ] ON
(
TABLE имя_объекта |
COLUMN имя_таблицы.имя_столбца |
AGGREGATE имя_агрегатной_функции ( сигнатура_агр_функции ) |
DATABASE имя_объекта |
DOMAIN имя_объекта |
EVENT TRIGGER имя_объекта |
FOREIGN TABLE имя_объекта
FUNCTION имя_функции [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
LARGE OBJECT oid_большого_объекта |
MATERIALIZED VIEW имя_объекта |
[ PROCEDURAL ] LANGUAGE имя_объекта |
PROCEDURE имя_процедуры [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
PUBLICATION имя_объекта |
ROLE имя_объекта |
ROUTINE имя_подпрограммы [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, …] ] ) ] |
SCHEMA имя_объекта |
SEQUENCE имя_объекта |
SUBSCRIPTION имя_объекта |
TABLESPACE имя_объекта |
TYPE имя_объекта |
VIEW имя_объекта
) IS ‘метка’
Здесь сигнатура_агр_функции:</dd>
    </dl>
  </li>
  <li>|
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] |
[ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ] ] ORDER BY
[ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ , … ]
Описание
SECURITY LABEL применяет метку безопасности к объекту базы данных. С определённым объектом
может быть связано произвольное количество меток безопасности, по одной для каждого провай-
дера. Провайдеры меток представляют собой загружаемые модули, которые регистрируют себя,
вызывая функцию register_label_provider.
Примечание
register_label_provider — это не SQL-функция; её можно вызывать только из ском-
пилированного кода C, загруженного сервером.
Провайдер меток определяет, допустима ли заданная метка и разрешено ли применять эту метку
к указанному объекту. Какой смысл вкладывается в данную метку, так же определяет провайдер
меток. PostgreSQL не накладывает никаких ограничений на то, как провайдер должен интерпре-
1693SECURITY LABEL
тировать метки безопасности; он просто обеспечивает механизм их хранения. На практике, этот
механизм реализован для того, чтобы в базы данных можно было интегрировать системы мандат-
ного управления доступом (MAC) на базе меток, такие как SE-Linux. Такие системы принимают
все решения по ограничению доступа, учитывая метки объектов, а не традиционные сущности из-
бирательного управления доступом (DAC), такие как пользователи и группы.
Параметры
имя_объекта
имя_таблицы.имя_столбца
имя_агрегатной_функции
имя_функции
имя_процедуры
имя_подпрограммы
Имя помечаемого объекта. Имена таблиц, агрегатных и обычных функций, процедур, подпро-
грамм, доменов, сторонних таблиц, последовательностей и представлений можно дополнить
именем схемы.
провайдер
Имя провайдера, с которым будет связана эта метка. Указанный провайдер должен быть загру-
жен и готов выполнять операцию размечивания. Если загружен всего один провайдер, его имя
можно опустить для краткости.
режим_аргумента
Режим аргумента функции, процедуры или агрегата: IN, OUT, INOUT или VARIADIC. По умолча-
нию подразумевается IN. Заметьте, что SECURITY LABEL не учитывает аргументы OUT, так как
для идентификации функции нужны только типы входных аргументов. Поэтому достаточно пе-
речислить только аргументы IN, INOUT и VARIADIC.
имя_аргумента
Имя аргумента функции, процедуры или агрегата. Заметьте, что на самом деле SECURITY LABEL
не обращает внимание на имена аргументов, так как для однозначной идентификации функции
достаточно только типов аргументов.
тип_аргумента
Тип данных аргумента функции, процедуры или агрегата.
oid_большого_объекта
OID большого объекта.
PROCEDURAL
Это слово не несёт смысловой нагрузки.
метка
Новая метка безопасности, записанная в виде строковой константы, либо NULL, если метку без-
опасности нужно удалить.
Примеры
Следующий пример показывает, как можно изменить метку безопасности для таблицы.
SECURITY LABEL FOR selinux ON TABLE mytable IS ‘system_u:object_r:sepgsql_table_t:s0’;
Совместимость
Команда SECURITY LABEL отсутствует в стандарте SQL.
1694SECURITY LABEL
См. также
sepgsql, src/test/modules/dummy_seclabel
1695SELECT
SELECT, TABLE, WITH — получить строки из таблицы или представления
Синтаксис
[ WITH [ RECURSIVE ] запрос_WITH [, …] ]
SELECT [ ALL | DISTINCT [ ON ( выражение [, …] ) ] ]
[ * | выражение [ [ AS ] имя_результата ] [, …] ]
[ FROM элемент_FROM [, …] ]
[ WHERE условие ]
[ GROUP BY элемент_группирования [, …] ]
[ HAVING условие [, …] ]
[ WINDOW имя_окна AS ( определение_окна ) [, …] ]
[ ( UNION | INTERSECT | EXCEPT ) [ ALL | DISTINCT ] выборка ]
[ ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS ( FIRST | LAST ) ]
[, …] ]
[ LIMIT ( число | ALL ) ]
[ OFFSET начало [ ROW | ROWS ] ]
[ FETCH ( FIRST | NEXT ) [ число ] ( ROW | ROWS ) ONLY ]
[ FOR ( UPDATE | NO KEY UPDATE | SHARE | KEY SHARE ) [ OF имя_таблицы [, …] ]
[ NOWAIT | SKIP LOCKED ] […] ]
Здесь допускается элемент_FROM:
[ ONLY ] имя_таблицы [ * ] [ [ AS ] псевдоним [ ( псевдоним_столбца [, …] ) ] ]
[ TABLESAMPLE метод_выборки ( аргумент [, …] ) [ REPEATABLE
( затравка ) ] ]
[ LATERAL ] ( выборка ) [ AS ] псевдоним [ ( псевдоним_столбца [, …] ) ]
имя_запроса_WITH [ [ AS ] псевдоним [ ( псевдоним_столбца [, …] ) ] ]
[ LATERAL ] имя_функции ( [ аргумент [, …] ] )
[ WITH ORDINALITY ] [ [ AS ] псевдоним [ ( псевдоним_столбца
[, …] ) ] ]
[ LATERAL ] имя_функции ( [ аргумент [, …] ] ) [ AS ] псевдоним
( определение_столбца [, …] )
[ LATERAL ] имя_функции ( [ аргумент [, …] ] ) AS ( определение_столбца [, …] )
[ LATERAL ] ROWS FROM( имя_функции ( [ аргумент [, …] ] ) [ AS
( определение_столбца [, …] ) ] [, …] )
[ WITH ORDINALITY ] [ [ AS ] псевдоним [ ( псевдоним_столбца
[, …] ) ] ]
элемент_FROM [ NATURAL ] тип_соединения элемент_FROM [ ON условие_соединения |
USING ( столбец_соединения [, …] ) ]
и элемент_группирования может быть следующим:
( )
выражение
( выражение [, …] )
ROLLUP ( ( выражение | ( выражение [, …] ) ) [, …] )
CUBE ( ( выражение | ( выражение [, …] ) ) [, …] )
GROUPING SETS ( элемент_группирования [, …] )
и запрос_WITH:
имя_запроса_WITH [ ( имя_столбца [, …] ) ] AS ( выборка | values | insert
| update | delete )
1696SELECT
TABLE [ ONLY ] имя_таблицы [ * ]
Описание
SELECT получает строки из множества таблиц (возможно, пустого). Общая процедура выполнения
SELECT следующая:
    <ol>
      <li>Выполняются все запросы в списке WITH. По сути они формируют временные таблицы, к которым
затем можно обращаться в списке FROM. Запрос в WITH выполняется только один раз, даже если
он фигурирует в списке FROM неоднократно. (См. Подраздел «Предложение WITH» ниже.)</li>
      <li>Вычисляются все элементы в списке FROM. (Каждый элемент в списке FROM представляет собой
реальную или виртуальную таблицу.) Если список FROM содержит несколько элементов, они объ-
единяются перекрёстным соединением. (См. Подраздел «Предложение FROM» ниже.)</li>
      <li>Если указано предложение WHERE, все строки, не удовлетворяющие условию, исключаются из
результата. (См. Подраздел «Предложение WHERE» ниже.)</li>
      <li>Если присутствует указание GROUP BY, либо в запросе вызываются агрегатные функции, вывод
разделяется по группам строк, соответствующим одному или нескольким значениям, а затем
вычисляются результаты агрегатных функций. Если добавлено предложение HAVING, оно исклю-
чает группы, не удовлетворяющие заданному условию. (См. Подраздел «Предложение GROUP BY»
и Подраздел «Предложение HAVING» ниже.)</li>
      <li>Вычисляются фактические выходные строки по заданным в SELECT выражениям для каждой
выбранной строки или группы строк. (См. Подраздел «Список SELECT» ниже.)</li>
      <li>SELECT DISTINCT исключает из результата повторяющиеся строки. SELECT DISTINCT ON исключа-
ет строки, совпадающие по всем указанным выражениям. SELECT ALL (по умолчанию) возвраща-
ет все строки результата, включая дубликаты. (См. Подраздел «Предложение DISTINCT» ниже.)</li>
      <li>Операторы UNION, INTERSECT и EXCEPT объединяют вывод нескольких команд SELECT в один ре-
зультирующий набор. Оператор UNION возвращает все строки, представленные в одном, либо
обоих наборах результатов. Оператор INTERSECT возвращает все строки, представленные строго
в обоих наборах. Оператор EXCEPT возвращает все строки, представленные в первом наборе, но
не во втором. Во всех трёх случаях повторяющиеся строки исключаются из результата, если
явно не указано ALL. Чтобы явно обозначить, что выдаваться должны только неповторяющиеся
строки, можно добавить избыточное слово DISTINCT. Заметьте, что в данном контексте по умол-
чанию подразумевается DISTINCT, хотя в самом SELECT по умолчанию подразумевается ALL. (См.
Подраздел «Предложение UNION+», Подраздел «Предложение INTERSECT» и Подраздел «Пред-
ложение EXCEPT» ниже.)</li>
      <li>Если присутствует предложение ORDER BY, возвращаемые строки сортируются в указанном по-
рядке. В отсутствие ORDER BY строки возвращаются в том порядке, в каком системе будет проще
их выдать. (См. Подраздел «Предложение ORDER BY» ниже.)</li>
      <li>Если указано предложение LIMIT (или FETCH FIRST) либо OFFSET, оператор SELECT возвращает
только подмножество строк результата. (См. Подраздел «Предложение LIMIT» ниже.)
10.Если указано FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE или FOR KEY SHARE, оператор SELECT
блокирует выбранные строки, защищая их от одновременных изменений. (См. Подраздел «Пред-
ложение блокировки» ниже.)
Для всех столбцов, задействованных в команде SELECT, необходимо иметь право SELECT. Примене-
ние блокировок FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE или FOR KEY SHARE требует также права
UPDATE (как минимум для одного столбца в каждой выбранной для блокировки таблице).
Параметры
Предложение WITH
Предложение WITH позволяет задать один или несколько подзапросов, к которым затем можно об-
ратиться по имени в основном запросе. Эти подзапросы по сути действуют как временные таблицы
или представления в процессе выполнения главного запроса. Каждый подзапрос может представ-
1697SELECT
лять собой оператор SELECT, TABLE, VALUES, INSERT, UPDATE или DELETE. При использовании в WITH
оператора, изменяющего данные, (INSERT, UPDATE или DELETE) обычно добавляется предложение
RETURNING. Заметьте, что именно результат RETURNING, а не нижележащая таблица, изменяемая
запросом, формирует временную таблицу, которую затем читает основной запрос. Если RETURNING
опущено, оператор, тем не менее, выполняется, но не выдаёт никакого результата, так что на него
нельзя сослаться как на таблицу в основном запросе.
Имя (без схемы) должно быть указано для каждого запроса WITH. Также можно задать необяза-
тельный список с именами столбцов; если он опущен, имена столбцов формируются из результата
подзапроса.
Если указано RECURSIVE, подзапрос SELECT может ссылаться сам на себя по имени. Такой подза-
прос должен иметь форму
нерекурсивная_часть UNION [ ALL | DISTINCT ] рекурсивная_часть
, где рекурсивная ссылка на сам запрос может находиться только справа от UNION. Для одного за-
проса допускается только одна рекурсивная ссылка на него же. Операторы, изменяющие данные,
не могут быть рекурсивными, но результат рекурсивного запроса SELECT в таких операторах мож-
но использовать. За примером обратитесь к Разделу 7.8.
Ещё одна особенность RECURSIVE в том, что запросы WITH могут быть неупорядоченными: запрос
может ссылаться на другой, идущий в списке после него. (Однако циклические ссылки или взаим-
ная рекурсия не поддерживаются.) Без RECURSIVE запрос в WITH может ссылаться только на запро-
сы того же уровня в WITH, предшествующие ему в списке WITH.
Ключевое свойство запросов WITH состоит в том, что они вычисляются один раз для всего основ-
ного запроса, даже если в основном запросе содержатся несколько ссылок на них. В частности,
гарантируется, что операторы, изменяющие данные, будут выполняться ровно один раз, вне зави-
симости от того, будет ли их результат прочитан основным запросом и в каком объёме.
Основной запрос и все запросы WITH, условно говоря, выполняются одновременно. Это значит, что
действие оператора, изменяющего данные в WITH, не будут видеть другие части запроса, кроме
как прочитав его вывод RETURNING. Если два таких оператора попытаются изменить одну строку,
результат будет неопределённым.
За дополнительными сведениями обратитесь к Разделу 7.8.
Предложение FROM
В предложении FROM перечисляются одна или несколько таблиц, служащих источниками данных
для SELECT. Если указано несколько источников, результатом будет декартово произведение (пе-
рекрёстное соединение) всех их строк. Но обычно в запрос добавляются уточняющие условия (в
предложении WHERE), которые ограничивают набор строк небольшим подмножеством этого произ-
ведения.
Предложение FROM может содержать следующие элементы:
имя_таблицы
Имя (возможно, дополненное схемой) существующей таблицы или представления. Если перед
именем таблицы указано ONLY, считывается только заданная таблица. Без ONLY считывается и
заданная таблица, и все её потомки (если таковые есть). После имени таблицы можно также
добавить необязательное указание <em>, чтобы явно обозначить, что блокировка затрагивает и все
дочерние таблицы.
псевдоним
Альтернативное имя для элемента списка FROM. Этот псевдоним используется для краткости
или для исключения неоднозначности с замкнутыми соединениями (когда одна таблица чита-
ется неоднократно). Когда задаётся псевдоним, он полностью скрывает настоящее имя табли-
цы или функции; например, при записи FROM foo AS f, в продолжении запроса SELECT к это-
1698SELECT
му элементу FROM нужно обращаться по имени f, а не foo. Если задан псевдоним таблицы, за
ним можно также написать список псевдонимов столбцов, который определит альтернативные
имена для столбцов таблицы.
TABLESAMPLE метод_выборки ( аргумент [, …] ) [ REPEATABLE ( затравка ) ]
Предложение TABLESAMPLE, сопровождающее имя_таблицы, показывает, что для получения под-
множества строк в этой таблице должен применяться указанный метод_выборки. Эта выборка
предшествует применению любых других фильтров, например, в предложении WHERE. В стан-
дартный дистрибутив PostgreSQL включены два метода выборки, BERNOULLI и SYSTEM; другие
методы выборки можно установить в базу данных через расширения.
Методы выборки BERNOULLI и SYSTEM принимают единственный аргумент, определяющий, ка-
кой процент таблицы должен попасть в выборку, от 0 до 100. Этот аргумент может задавать-
ся любым выражением со значением типа real. (Другие методы выборки могут принимать до-
полнительные или другие параметры.) Оба этих метода возвращают случайную выборку таб-
лицы, содержащую примерно указанный процент строк таблицы. Метод BERNOULLI сканирует
всю таблицу и выбирает или игнорирует отдельные строки независимо, с заданной вероятно-
стью. Метод SYSTEM строит выборку на уровне блоков, определяя для каждого блока шанс его
задействовать, и возвращает все строки из каждого задействуемого блока. Метод SYSTEM рабо-
тает значительно быстрее BERNOULLI, когда выбирается небольшой процент строк, но он может
выдавать менее случайную выборку таблицу из-за эффектов кучности.
В необязательном предложении REPEATABLE задаётся затравка — число или выражение, зада-
ющее отправное значение для генератора случайных чисел в методе выборки. Значением за-
травки может быть любое отличное от NULL число с плавающей точкой. Два запроса, в кото-
рых указаны одинаковые значения затравки и аргумента, выдадут одну и ту же выборку таб-
лицы при условии неизменности содержимого таблицы. Но с разными значениями затравки
выборки обычно получаются разными. В отсутствие предложения REPEATABLE для каждого за-
проса выдаётся новая случайная выборка, в зависимости от затравки, сгенерированной систе-
мой. Заметьте, что некоторые дополнительные методы выборки не принимают предложение
REPEATABLE и выдают разные выборки при каждом использовании.
выборка
Предложение FROM может содержать вложенный запрос SELECT. Можно считать, что из его
результата создаётся временная таблица на время выполнения основной команды SELECT. За-
метьте, что вложенный запрос SELECT должен заключаться в скобки и для него должен зада-
ваться псевдоним. Здесь также можно использовать команду VALUES.
имя_запроса_WITH
На запрос WITH можно ссылаться по имени, как если бы имя запроса представляло имя таблицы.
(На самом деле запрос WITH скрывает любую реальную таблицу с тем же именем для основного
запроса. Если необходимо обратиться к одноимённой реальной таблице, можно дополнить имя
этой таблицы именем схемы.) Для этого имени можно задать псевдоним, так же, как и для
имени таблицы.
имя_функции
В предложении FROM могут содержаться вызовы функций. (Это особенно полезно для функций,
возвращающих множества, но в принципе можно использовать любые функции.) Можно счи-
тать, что из результата функции создаётся временная таблица на время выполнения основ-
ной команды SELECT. Если вызов функции сопровождается необязательным предложением WITH
ORDINALITY, после всех выдаваемых функцией столбцов в вывод добавляется ещё один столбец
с номерами строк.
Псевдоним для функции можно задать так же, как и для таблицы. Если этот псевдоним задан,
за ним можно также написать список псевдонимов столбцов, который определит альтернатив-
ные имена для атрибутов составного типа результата функции, включая имя столбца, который
может быть добавлен предложением ORDINALITY.
1699SELECT
Несколько вызовов функций можно объединить в одном элементе предложения FROM, заключив
их в конструкцию ROWS FROM( … ). Выводом такого элемента будет соединение первых строк
всех функций, затем вторых строк и т. д. Если одни функции выдают меньше строк, чем другие,
недостающие данные заменяются значениями NULL, так что общее число возвращаемых строк
всегда будет равняться максимальному числу строк из возвращённых всеми функциями.
Если функция определена как возвращающая тип данных record, для неё нужно указать псев-
доним или ключевое слово AS, за которым должен идти список определений столбцов в форме
( имя_столбца тип_данных [, … ]). Список определений столбцов должен соответствовать
фактическому количеству и типу столбцов, возвращаемых функцией.
Если при использовании синтаксиса ROWS FROM( … ) одна из функций требует наличия
списка определений столбцов, этот список лучше разместить после вызова функции внутри
ROWS FROM( … ). Список определений столбцов можно поместить после конструкции ROWS
FROM( … ), только если вызывается всего одна функция, а предложение WITH ORDINALITY
отсутствует.
Чтобы использовать ORDINALITY со списком определений столбцов, необходимо применить за-
пись ROWS FROM( … ) и поместить список с определениями столбцов внутрь ROWS FROM( … ).
тип_соединения
Один из следующих вариантов:
• [ INNER ] JOIN
• LEFT [ OUTER ] JOIN
• RIGHT [ OUTER ] JOIN
• FULL [ OUTER ] JOIN
• CROSS JOIN
Для типов соединений INNER и OUTER необходимо указать условие соединения, а именно одно из
предложений NATURAL, ON условие_соединения или USING (столбец_соединения [, …]). Эти
предложения описываются ниже. Для CROSS JOIN ни одно из этих предложений не допускается.
Предложение JOIN объединяет два элемента списка FROM, которые мы для простоты дальше
будем называть «таблицами», хотя на самом деле это может быть любой объект, допустимый
в качестве элемента FROM. Для определения порядка вложенности при необходимости следует
использовать скобки. В отсутствие скобок предложения JOIN обрабатывается слева направо.
В любом случае, JOIN связывает элементы сильнее, чем запятые, разделяющие элементы в
списке FROM.
CROSS JOIN и INNER JOIN формируют простое декартово произведение, то же, что можно полу-
чить, указав две таблицы на верхнем уровне FROM, но ограниченное возможным условием со-
единения. Предложение CROSS JOIN равнозначно INNER JOIN ON (TRUE), то есть, никакие стро-
ки по условию не удаляются. Эти типы соединений введены исключительно для удобства запи-
си, они не дают ничего такого, что нельзя было бы получить, используя просто FROM и WHERE.
LEFT OUTER JOIN возвращает все строки ограниченного декартова произведения (т. е. все объ-
единённые строки, удовлетворяющие условию соединения) плюс все строки в таблице слева,
для которых не находится строк в таблице справа, удовлетворяющих условию. Строка, взятая
из таблицы слева, дополняется до полной ширины объединённой таблицы значениями NULL
в столбцах таблицы справа. Заметьте, что для определения, какие строки двух таблиц соответ-
ствуют друг другу, проверяется только условие самого предложения JOIN. Внешние условия
проверяются позже.
RIGHT OUTER JOIN, напротив, возвращает все соединённые строки плюс одну строку для каж-
дой строки справа, не имеющей соответствия слева (эта строка дополняется значениями NULL
влево). Это предложение введено исключительно для удобства записи, так как его можно легко
свести к LEFT OUTER JOIN, поменяв левую и правую таблицы местами.
1700SELECT
FULL OUTER JOIN возвращает все соединённые строки плюс все строки слева, не имеющие со-
ответствия справа, (дополненные значениями NULL вправо) плюс все строки справа, не имею-
щие соответствия слева (дополненные значениями NULL влево).
ON условие_соединения
Задаваемое условие_соединения представляет собой выражение, выдающее значение типа
boolean (как в предложении WHERE), которое определяет, какие строки считаются соответству-
ющими при соединении.
USING ( столбец_соединения [, …] )
Предложение вида USING ( a, b, … ) представляет собой сокращённую форму записи ON
таблица_слева.a = таблица_справа.a AND таблица_слева.b = таблица_справа.b …. Кроме
того, USING подразумевает, что в результат соединения будет включён только один из пары
равных столбцов, но не оба.
NATURAL
NATURAL представляет собой краткую запись USING со списком, в котором перечисляются
все столбцы двух таблиц, имеющие одинаковые имена. Если одинаковых имён нет, указание
NATURAL равнозначно ON TRUE.
LATERAL
Ключевое слово LATERAL может предварять вложенный запрос SELECT в списке FROM. Оно поз-
воляет обращаться в этом вложенном SELECT к столбцам элементов FROM, предшествующим ему
в списке FROM. (Без LATERAL все вложенные подзапросы SELECT обрабатываются независимо и
не могут ссылаться на другие элементы списка FROM.)
Слово LATERAL можно также добавить перед вызовом функции в списке FROM, но в этом случае
оно будет избыточным, так как выражения с функциями могут ссылаться на предыдущие эле-
менты списка FROM в любом случае.
Элемент LATERAL может находиться на верхнем уровне списка FROM или в дереве JOIN. В по-
следнем случае он может также ссылаться на любые элементы в левой части JOIN, справа от
которого он находится.
Когда элемент FROM содержит ссылки LATERAL, запрос выполняется следующим образом: сна-
чала для строки элемента FROM с целевыми столбцами, или набора строк из нескольких эле-
ментов FROM, содержащих целевые столбцы, вычисляется элемент LATERAL со значениями этих
столбцов. Затем результирующие строки обычным образом соединяются со строками, из кото-
рых они были вычислены. Эта процедура повторяется для всех строк исходных таблиц.
Таблица, служащая источником столбцов, должна быть связана с элементом LATERAL соедине-
нием INNER или LEFT, в противном случае не образуется однозначно определяемый набор строк,
из которого можно будет получать наборы строк для элемента LATERAL. Таким образом, хотя
конструкция X RIGHT JOIN LATERAL Y синтаксически правильная, Y в ней не может обращаться
к X.
Предложение WHERE
Необязательное предложение WHERE имеет общую форму
WHERE условие
, где условие — любое выражение, выдающее результат типа boolean. Любая строка, не удовле-
творяющая этому условию, исключается из результата. Строка удовлетворяет условию, если оно
возвращает true при подстановке вместо ссылок на переменные фактических значений из этой
строки.
Предложение GROUP BY
Необязательное предложение GROUP BY имеет общую форму
1701SELECT
GROUP BY элемент_группирования [, …]
GROUP BY собирает в одну строку все выбранные строки, выдающие одинаковые значения для вы-
ражений группировки. В качестве выражения внутри элемента_группирования может выступать
имя входного столбца, либо имя или порядковый номер выходного столбца (из списка элемен-
тов SELECT), либо произвольное значение, вычисляемое по значениям входных столбцов. В случае
неоднозначности имя в GROUP BY будет восприниматься как имя входного, а не выходного столбца.
Если в элементе группирования задаётся GROUPING SETS, ROLLUP или CUBE, предложение GROUP BY в
целом определяет некоторое число независимых наборов группирования. Это даёт тот же эффект,
что и объединение подзапросов (с UNION ALL) с отдельными наборами группирования в их пред-
ложениях GROUP BY. Подробнее использование наборов группирования описывается в Подразде-
ле 7.2.4.
Агрегатные функции, если они используются, вычисляются по всем строкам, составляющим каж-
дую группу, и в итоге выдают отдельное значение для каждой группы. (Если агрегатные функции
используются без предложения GROUP BY, запрос выполняется как с одной группой, включающей
все выбранные строки.) Набор строк, поступающих в каждую агрегатную функцию, можно допол-
нительно отфильтровать, добавив предложение FILTER к вызову агрегатной функции; за дополни-
тельными сведениями обратитесь к Подразделу 4.2.7. С предложением FILTER на вход агрегатной
функции поступают только те строки, которые соответствуют заданному фильтру.
Когда в запросе присутствует предложение GROUP BY или какая-либо агрегатная функция, выра-
жения в списке SELECT не могут обращаться к негруппируемым столбцам, кроме как в агрегатных
функциях или в случае функциональной зависимости, так как иначе в негруппируемом столбце
нужно было бы вернуть более одного возможного значения. Функциональная зависимость образу-
ется, если группируемые столбцы (или их подмножество) составляют первичный ключ таблицы,
содержащей негруппируемый столбец.
Имейте в виду, что все агрегатные функции вычисляются перед «скалярными» выражениями в
предложении HAVING или списке SELECT. Это значит, что например, с помощью выражения CASE
нельзя обойти вычисление агрегатной функции; см. Подраздел 4.2.14.
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать вместе с GROUP BY.
Предложение HAVING
Необязательное предложение HAVING имеет общую форму
HAVING условие
Здесь условие задаётся так же, как и для предложения WHERE.
HAVING исключает из результата строки групп, не удовлетворяющих условию. HAVING отличается
от WHERE: WHERE фильтрует отдельные строки до применения GROUP BY, а HAVING фильтрует строки
групп, созданных предложением GROUP BY. Каждый столбец, фигурирующий в условии, должен
однозначно ссылаться на группируемый столбец, за исключением случаев, когда эта ссылка нахо-
дится внутри агрегатной функции или негруппируемый столбец функционально зависит от груп-
пируемых.
В присутствие HAVING запрос превращается в группируемый, даже если GROUP BY отсутствует. То
же самое происходит, когда запрос содержит агрегатные функции, но не предложение GROUP BY.
Все выбранные строки считаются формирующими одну группу, а в списке SELECT и предложении
HAVING можно обращаться к столбцам таблицы только из агрегатных функций. Такой запрос будет
выдавать единственную строку, если результат условия HAVING — true, и ноль строк в противном
случае.
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать вместе с HAVING.
1702SELECT
Предложение WINDOW
Необязательное предложение WINDOW имеет общую форму
WINDOW имя_окна AS ( определение_окна ) [, …]
Здесь имя_окна — это имя, на которое можно ссылаться из предложений OVER или последующих
определений окон, а определение_окна имеет следующий вид:
[ имя_существующего_окна ]
[ PARTITION BY выражение [, …] ]
[ ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS ( FIRST | LAST ) ]
[, …] ]
[ предложение_рамки ]
Если указано имя_существующего_окна, оно должно ссылаться на предшествующую запись в спис-
ке WINDOW; новое окно копирует предложение разбиения из этой записи, а также предложение сор-
тировки, если оно присутствует. В этом случае для нового окна нельзя задать собственное пред-
ложение PARTITION BY, а ORDER BY можно указать, только если его не было у копируемого окна.
Новое окно всегда использует собственное предложение рамки; в копируемом окне оно задаваться
не должно.
Элементы списка PARTITION BY интерпретируется во многом так же, как и элементы Подраздела
«Предложение GROUP BY», за исключением того, что это всегда простые выражения, но не имя или
номер выходного столбца. Другое различие состоит в том, что эти выражения могут содержать
вызовы агрегатных функций, которые не допускаются в обычном предложении GROUP BY. Здесь они
допускаются потому, что формирование окна происходит после группировки и агрегирования.
Подобным образом, элементы списка ORDER BY интерпретируются во многом так же, как и эле-
менты Подраздела «Предложение ORDER BY», за исключением того, что выражения в нём всегда
принимаются как простые выражения, но не как имя или номер выходного столбца.
Необязательное предложение_рамки определяет рамку окна для оконных функций, которые зави-
сят от рамки (не все функции таковы). Рамка окна — это набор связанных строк для каждой строки
запроса (называемой текущей строкой). В качестве предложения_рамки может задаваться
( RANGE | ROWS | GROUPS ) начало_рамки [ исключение_рамки ]
( RANGE | ROWS | GROUPS ) BETWEEN начало_рамки AND конец_рамки [ исключение_рамки ]
Здесь начало_рамки и конец_рамки может задаваться как
UNBOUNDED PRECEDING
смещение PRECEDING
CURRENT ROW
смещение FOLLOWING
UNBOUNDED FOLLOWING
и исключение_рамки может быть таким:
EXCLUDE
EXCLUDE
EXCLUDE
EXCLUDE
CURRENT ROW
GROUP
TIES
NO OTHERS
Если конец_рамки опущен, по умолчанию подразумевается CURRENT ROW. В качестве начала_рамки
нельзя задать UNBOUNDED FOLLOWING, в качестве конца_рамки не допускается UNBOUNDED PRECEDING,
и конец_рамки не может идти в показанном выше списке указаний начало_рамки AND конец_рамки
перед началом_рамки — например, синтаксис RANGE BETWEEN CURRENT ROW AND смещение PRECEDING
не допускается.
По умолчанию рамка образуется предложением RANGE UNBOUNDED PRECEDING, что по сути то же,
что RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW; оно устанавливает рамку так, что
она включает все строки от начала раздела до последней строки, родственной текущей (строки,
которые согласно указанному для окна предложению ORDER BY считаются равными текущей; если
1703SELECT
ORDER BY отсутствует, все строки считаются родственными). Вообще UNBOUNDED PRECEDING озна-
чает, что рамка начинается с первой строки раздела, а UNBOUNDED FOLLOWING означает, что рам-
ка заканчивается на последней строке раздела, независимо от режима RANGE, ROWS или GROUPS. В
режиме ROWS указание CURRENT ROW означает, что рамка начинается или заканчивается текущей
строкой; но в режиме RANGE или GROUPS оно означает, что рамка начинается или заканчивается
первой или последней строкой, родственной текущей, согласно порядку ORDER BY. Варианты сме-
щение PRECEDING и смещение FOLLOWING означают разное в зависимости от режима рамки. В режиме
ROWS целочисленное смещение определяет сдвиг, с которым начало рамки позиционируется перед
текущей строкой, а конец рамки — после текущей строки. В режиме GROUPS целочисленное сме-
щение аналогичным образом определяет сдвиг относительно группы строк, родственных текущей,
где группа родственных строк — группа строк, считающихся равными согласно предложению
ORDER BY для данного окна. В режиме RANGE для указания смещения необходимо присутствие в
определении окна ровно одного столбца ORDER BY. Тогда рамка будет содержать те строки, в кото-
рых значение упорядочивающего столбца не более чем на смещение меньше (для PRECEDING) или
больше (для FOLLOWING) значения упорядочивающего столбца в текущей строке. В этом случае тип
данных выражения смещение зависит от типа данных упорядочивающего столбца. Для числовых
столбцов это обычно тот же числовой тип, а для столбцов с типом дата/время — тип interval. Во
всех этих случаях значение смещения должно быть отличным от NULL и неотрицательным. Кроме
того, хотя смещение не обязательно должно быть простой константой, оно не может содержать пе-
ременные, агрегатные или оконные функции.
Дополнение исключение_рамки позволяет исключить из рамки строки, которые окружают текущую
строку, даже если они должны быть включены согласно указаниям, определяющим начало и конец
рамки. EXCLUDE CURRENT ROW исключает из рамки текущую строку. EXCLUDE GROUP исключает из
рамки текущую строку и родственные ей согласно порядку сортировки. EXCLUDE TIES исключает
из рамки все родственные строки для текущей, но не собственно текущую строку. EXCLUDE NO
OTHERS просто явно выражает поведение по умолчанию — не исключает ни текущую строку, ни
родственные ей.
Учтите, что в режиме ROWS могут выдаваться непредсказуемые результаты, если согласно порядку,
заданному в ORDER BY, строки сортируются неоднозначно. Режимы RANGE и GROUPS предусмотрены
для того, чтобы строки, являющиеся родственными в порядке ORDER BY, обрабатывались одинако-
во: все строки определённой группы попадут в одну рамку или будут исключены из неё.
Предложение WINDOW применяется для управления поведением оконных функций, фигурирующих
в запросе, в Подразделе «Список SELECT» или Подразделе «Предложение ORDER BY». Эти функции
могут обращаться к элементам WINDOW по именам в своих предложениях OVER. При этом элементы
WINDOW не обязательно задействовать в запросе; если они не используются, они просто игнориру-
ются. Оконные функции можно использовать вовсе без элементов WINDOW, так как в вызове оконной
функции можно задать определение окна непосредственно в предложении OVER. Однако предло-
жение WINDOW позволяет сократить текст запроса, когда одно и то же определение окна применя-
ется при вызове нескольких оконных функций.
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать вместе с WINDOW.
Оконные функции подробно описываются в Разделе 3.5, Подразделе 4.2.8 и Подразделе 7.2.5.
Список SELECT
Список SELECT (между ключевыми словами SELECT и FROM) содержит выражения, которые форми-
руют выходные строки оператора SELECT. Эти выражения могут обращаться (и обычно обращают-
ся) к столбцам, вычисленным в предложении FROM.
Так же, как в таблице, каждый выходной столбец SELECT имеет имя. В простом предложении SELECT
это имя просто помечает столбец при выводе, но когда SELECT представляет собой подзапрос боль-
шого запроса, это имя большой запрос видит как имя столбца виртуальной таблицы, созданной
подзапросом. Чтобы задать имя для выходного столбца, нужно написать AS выходное_имя после вы-
1704SELECT
ражения столбца. (Слово AS можно опустить, но только если желаемое выходное имя не совпадает
с каким-либо ключевым словом PostgreSQL (см. Приложение C). Чтобы не зависеть от появления
новых ключевых слов в будущем, рекомендуется всегда писать AS, либо заключать имя в двойные
кавычки.) Если имя столбца не задать, PostgreSQL выберет его автоматически. Если выражение
столбца представляет собой просто ссылку на столбец, то выбранное таким образом имя будет
совпадать с именем столбца. В более сложных случаях может использоваться имя функции или
типа, либо в отсутствие других вариантов система может сгенерировать имя вроде ?column?.
По имени выходного столбца можно обратиться к его значению в предложениях ORDER BY и GROUP
BY, но не в WHERE или HAVING; в них вместо имени надо записывать всё выражение.
Вместо выражения в выходном списке можно указать *, что будет обозначать все столбцы выбран-
ных строк. Кроме того, можно записать имя_таблицы.</em> как краткое обозначение всех столбцов,
получаемых из данной таблицы. В этих случаях нельзя задать новые имена столбцов с помощью
AS; именами выходных столбцов будут имена столбцов в таблице.
Согласно стандарту SQL, выражения в выходном списке должны вычисляться до применения
DISTINCT, ORDER BY или LIMIT. Это, очевидно, необходимо для DISTINCT, так как иначе не будет
ясно, какие значения должны выдаваться как уникальные. Однако во многих случаях выходные
выражения удобнее вычислять после ORDER BY и LIMIT; в частности, если в выходном списке со-
держатся изменчивые или дорогостоящие функции. В этом случае порядок вычисления функций
оказывается более интуитивным, а для строк, которые не попадут в результат, не будут произво-
диться вычисления. PostgreSQL фактически будет вычислять выходные выражения после сорти-
ровки и ограничения их количества, если эти выражения не фигурируют в DISTINCT, ORDER BY или
GROUP BY. (Например, в запросе SELECT f(x) FROM tab ORDER BY 1 функция f(x), несомненно,
должна вычисляться перед сортировкой.) Выходные выражения, содержащие функции, возвраща-
ющие множества, фактически вычисляются после сортировки и до ограничения количества строк,
так что LIMIT будет отбрасывать строки, выдаваемые функцией, возвращающей множество.
Примечание
В PostgreSQL до версии 9.6 никакой порядок вычисления выходных выражений по от-
ношению к сортировке или ограничениям количества не гарантировался; он зависел
от формы выбранного плана запроса.
Предложение DISTINCT
Если указано SELECT DISTINCT, все повторяющиеся строки исключаются из результирующего на-
бора (из каждой группы дубликатов остаётся одна строка). SELECT ALL делает противоположное:
сохраняет все строки; это поведение по умолчанию.
SELECT DISTINCT ON ( выражение [, …] ) сохраняет только первую строку из каждого набо-
ра строк, для которого данное выражение даёт одинаковые значения. Выражения DISTINCT ON
обрабатываются по тем же правилам, что и выражения ORDER BY (см. выше). Заметьте, что «пер-
вая строка» каждого набора непредсказуема, если только не применяется предложение ORDER BY,
определяющее, какие строки должны быть первыми. Например:
SELECT DISTINCT ON (location) location, time, report
FROM weather_reports
ORDER BY location, time DESC;
возвращает самую последнюю сводку погоды для каждого местоположения. Но если бы мы не до-
бавили ORDER BY, чтобы значения времени убывали, мы бы получили сводки по местоположениям
от непредсказуемого времени.
Выражения DISTINCT ON должны соответствовать самым левым выражениям в ORDER BY. Предло-
жение ORDER BY обычно содержит и другие выражения, которые определяют желаемый порядок
строк в каждой группе DISTINCT ON.
1705SELECT
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать вместе с DISTINCT.
Предложение UNION+
Предложение UNION имеет следующую общую форму:
оператор_SELECT UNION [ ALL | DISTINCT ] оператор_SELECT
Здесь оператор_SELECT — это любой подзапрос SELECT без предложений ORDER BY, LIMIT, FOR NO KEY
UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE. (ORDER BY и LIMIT можно добавить к вложенному
выражению, если оно заключено в скобки. Без скобок эти предложения будут восприняты как
применяемые к результату UNION, а не к выражению в его правой части.)
Оператор UNION вычисляет объединение множеств всех строк, возвращённых заданными запроса-
ми SELECT. Строка оказывается в объединении двух наборов результатов, если она присутствует
минимум в одном наборе. Два оператора SELECT, представляющие прямые операнды UNION, долж-
ны выдавать одинаковое число столбцов, а типы соответствующих столбцов должны быть совме-
стимыми.
Результат UNION не будет содержать повторяющихся строк, если не указан параметр ALL. ALL
предотвращает исключение дубликатов. (Таким образом, UNION ALL обычно работает значитель-
но быстрее, чем UNION; поэтому, везде, где возможно, следует указывать ALL.) DISTINCT можно за-
писать явно, чтобы обозначить, что дублирующиеся строки должны удаляться (это поведение по
умолчанию).
При использовании в одном запросе SELECT нескольких операторов UNION они вычисляются слева
направо, если иной порядок не определяется скобками.
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать ни для результата UNION, ни для любого из подзапросов UNION.
Предложение INTERSECT
Предложение INTERSECT имеет следующую общую форму:
оператор_SELECT INTERSECT [ ALL | DISTINCT ] оператор_SELECT
Здесь оператор_SELECT — это любой подзапрос SELECT без предложений ORDER BY, LIMIT, FOR NO
KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE.
Оператор INTERSECT вычисляет пересечение множеств всех строк, возвращённых заданными за-
просами SELECT. Строка оказывается в пересечении двух наборов результатов, если она присут-
ствует в обоих наборах.
Результат INTERSECT не будет содержать повторяющихся строк, если не указан параметр ALL. С
параметром ALL строка, повторяющаяся m раз в левой таблице и n раз в правой, будет выдана в
результирующем наборе min(m,n) раз. DISTINCT можно записать явно, чтобы обозначить, что дуб-
лирующиеся строки должны удаляться (это поведение по умолчанию).
При использовании в одном запросе SELECT нескольких операторов INTERSECT они вычисляются
слева направо, если иной порядок не диктуется скобками. INTERSECT связывает свои подзапросы
сильнее, чем UNION. Другими словами, A UNION B INTERSECT C будет восприниматься как A UNION
(B INTERSECT C).
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать ни для результата INTERSECT, ни для любого из подзапросов INTERSECT.
Предложение EXCEPT
Предложение EXCEPT имеет следующую общую форму:
1706SELECT
оператор_SELECT EXCEPT [ ALL | DISTINCT ] оператор_SELECT
Здесь оператор_SELECT — это любой подзапрос SELECT без предложений ORDER BY, LIMIT, FOR NO
KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE.
Оператор EXCEPT вычисляет набор строк, которые присутствуют в результате левого запроса
SELECT, но отсутствуют в результате правого.
Результат EXCEPT не будет содержать повторяющихся строк, если не указан параметр ALL. С пара-
метром ALL строка, повторяющаяся m раз в левой таблице и n раз в правой, будет выдана в резуль-
тирующем наборе max(m-n,0) раз. DISTINCT можно записать явно, чтобы обозначить, что дублиру-
ющиеся строки должны удаляться (это поведение по умолчанию).
При использовании в одном запросе SELECT нескольких операторов EXCEPT они вычисляются слева
направо, если иной порядок не диктуется скобками. EXCEPT связывает свои подзапросы так же
сильно, как UNION.
В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя
задать ни для результата EXCEPT, ни для любого из подзапросов EXCEPT.
Предложение ORDER BY
Необязательное предложение ORDER BY имеет следующую общую форму:
ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS ( FIRST | LAST ) ] [, …]
Предложение ORDER BY указывает, что строки результата должны сортироваться согласно задан-
ным выражениям. Если две строки дают равные значения для самого левого выражения, прове-
ряется следующее выражение и т. д. Если их значения оказываются равными для всех заданных
выражений, строки возвращаются в порядке, определяемом реализацией.
В качестве выражения может задаваться имя или порядковый номер выходного столбца (элемента
списка SELECT), либо произвольное выражение со значениями входных столбцов.
Порядковым номером в данном случае считается последовательный номер (при нумерации сле-
ва направо) позиции выходного столбца. Возможность указать порядковый номер позволяет вы-
полнить сортировку по столбцу, не имеющему уникального имени. В принципе это не абсолютно
необходимо, так как выходному столбцу всегда можно присвоить имя, воспользовавшись предло-
жением AS.
В предложении ORDER BY также можно использовать произвольные выражения, в том числе, и со
столбцами, отсутствующими в списке результатов SELECT. Таким образом, следующий оператор
вполне корректен:
SELECT name FROM distributors ORDER BY code;
Однако, если ORDER BY применяется к результату UNION, INTERSECT или EXCEPT, в нём можно задать
только имя или номер выходного столбца, но не выражение.
Если в качестве выражения ORDER BY задано простое имя, которому соответствует и выходной, и
входной столбец, то ORDER BY будет воспринимать его как имя выходного столбца. Этот выбор про-
тивоположен тому, что делает GROUP BY в такой же ситуации. Такая несогласованность допущена
для соответствия стандарту SQL.
Дополнительно после любого выражения в предложении ORDER BY можно добавить ключевое сло-
во ASC (по возрастанию) или DESC (по убыванию). По умолчанию подразумевается ASC. Кроме того,
можно задать имя специфического оператора сортировки в предложении USING. Оператор сорти-
ровки должен быть членом «меньше» или «больше» некоторого семейства операторов B-дерева.
ASC обычно равнозначно USING &lt; и DESC обычно равнозначно USING &gt;. (Хотя создатель нестандарт-
ного типа данных может определить по-другому порядок сортировки по умолчанию и поставить
ему в соответствие операторы с другими именами.)
1707SELECT
Если указано NULLS LAST, значения NULL при сортировке оказываются после значений не NULL; с
указанием NULLS FIRST значения NULL оказываются перед значениями не NULL. Если не указано
ни то, ни другое, по умолчанию подразумевается NULLS LAST при явно или неявно выбранном
порядке ASC, либо NULLS FIRST при порядке DESC (то есть по умолчанию считается, что значения
NULL больше значений не NULL). С предложением USING порядок NULL по умолчанию зависит от
того, является ли указанный оператор оператором «меньше» или «больше».
Заметьте, что параметры сортировки применяются только к тому выражению, за которым они
следуют; в частности, ORDER BY x, y DESC означает не то же самое, что ORDER BY x DESC, y DESC.
Данные символьных строк сортируются согласно правилу сортировки, установленному для сорти-
руемого столбца. При необходимости это правило можно переопределить, добавив предложение
COLLATE в выражение, например так: ORDER BY mycolumn COLLATE “en_US”. За дополнительными
сведениями обратитесь к Подразделу 4.2.10 и Разделу 23.2.
Предложение LIMIT
Предложение LIMIT состоит из двух независимых вложенных предложений:
LIMIT ( число | ALL )
OFFSET начало
Здесь число определяет максимальное количество строк, которое должно быть выдано, тогда как
начало определяет, сколько строк нужно пропустить, прежде чем начать выдавать строки. Когда
указаны оба значения, сначала строки пропускаются в количестве, заданном значением начало,
а затем следующие строки выдаются в количестве, не превышающем значения число.
Если результатом выражения число оказывается NULL, предложение воспринимается как LIMIT
ALL, т. е. число строк не ограничивается. Если начало принимает значение NULL, предложение
воспринимается как OFFSET 0.
SQL:2008 вводит другой синтаксис для получения того же результата, и его так же поддерживает
PostgreSQL. Он выглядит так:
OFFSET начало ( ROW | ROWS )
FETCH ( FIRST | NEXT ) [ число ] ( ROW | ROWS ) ONLY
В этом синтаксисе значение начало или число в соответствии со стандартом должно быть букваль-
ной константой, параметром или именем переменной; PostgreSQL позволяет использовать и дру-
гие выражения, но их обычно нужно заключать в скобки во избежание неоднозначности. Если
число опускается в предложении FETCH, оно принимает значение 1. Слова ROW и ROWS, а также FIRST
и NEXT являются незначащими и не влияют на поведение этих предложений. Согласно стандарту
предложение OFFSET должно идти перед FETCH, если они присутствуют вместе; но PostgreSQL ме-
нее строг и допускает любой порядок.
Применяя LIMIT, имеет смысл использовать также предложение ORDER BY, чтобы строки результа-
та выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмноже-
ства строк запроса — вы можете запросить строки с десятой по двадцатую, но какой порядок вы
имеете в виду? Порядок будет неизвестен, если не добавить ORDER BY.
Планировщик запроса учитывает ограничение LIMIT, строя план выполнения запроса, поэтому,
вероятнее всего, планы (а значит и порядок строк) будут меняться при разных LIMIT и OFFSET. Та-
ким образом, различные значения LIMIT/OFFSET, выбирающие разные подмножества результатов
запроса, приведут к несогласованности результатов, если не установить предсказуемую сорти-
ровку с помощью ORDER BY. Это не ошибка, а неизбежное следствие того, что SQL не гарантирует
вывод результатов запроса в некотором порядке, если порядок не определён явно предложением
ORDER BY.
Возможно даже, что при повторном выполнении одного и того же запроса с LIMIT будут получены
разные подмножества строк таблицы, если предложение ORDER BY не диктует выбор определённого
1708SELECT
подмножества. Опять же, это не ошибка; в данном случае детерминированность результата просто
не гарантируется.
Предложение блокировки
Предложения блокировки включают в себя FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE и FOR KEY
SHARE; они влияют на то, как SELECT блокирует строки, получаемые из таблицы.
Предложение блокировки имеет следующую общую форму:
FOR вариант_блокировки [ OF имя_таблицы [, …] ] [ NOWAIT | SKIP LOCKED ]
Здесь вариант_блокировки может быть следующим:
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
Подробнее о каждом режиме блокировки на уровне строк можно узнать в Подразделе 13.3.2.
Чтобы операция не ждала завершения других транзакций, к блокировке можно добавить указание
NOWAIT или SKIP LOCKED. С NOWAIT оператор выдаёт ошибку, а не ждёт, если выбранную строку
нельзя заблокировать немедленно. С указанием SKIP LOCKED выбранные строки, которые нельзя
заблокировать немедленно, пропускаются. При этом формируется несогласованное представле-
ние данных, так что этот вариант не подходит для общего применения, но может использоваться
для исключения блокировок при обращении множества потребителей к таблице типа очереди. За-
метьте, что указания NOWAIT и SKIP LOCKED применяются только к блокировкам на уровне строк —
необходимая блокировка ROW SHARE уровня таблицы запрашивается обычным способом (см. Гла-
ву 13). Если требуется запросить блокировку уровня таблицы без ожидания, можно сначала вы-
полнить LOCK с указанием NOWAIT.
Если в предложении блокировки указаны определённые таблицы, блокироваться будут только
строки, получаемые из этих таблиц; другие таблицы, задействованные в SELECT, будут прочитаны
как обычно. Предложение блокировки без списка таблиц затрагивает все таблицы, задействован-
ные в этом операторе. Если предложение блокировки применяется к представлению или подза-
просу, оно затрагивает все таблицы, которые используются в представлении или подзапросе. Од-
нако эти предложения не применяются к запросам WITH, к которым обращается основной запрос.
Если требуется установить блокировку строк в запросе WITH, предложение блокировки нужно ука-
зать непосредственно в этом запросе WITH.
В случае необходимости задать для разных таблиц разное поведение блокировки, в запрос можно
добавить несколько предложений. Если при этом одна и та же таблица упоминается (или неявно
затрагивается) в нескольких предложениях блокировки, блокировка устанавливается так, как ес-
ли бы было указано только одно, самое сильное из них. Подобным образом, если в одном из пред-
ложений указано NOWAIT, для этой таблицы блокировка будет запрашиваться без ожидания. В про-
тивном случае она будет обработана в режиме SKIP LOCKED, если он выбран в любом из затраги-
вающих её предложений.
Предложения блокировки не могут применяться в контекстах, где возвращаемые строки нельзя
чётко связать с отдельными строками таблицы; например, блокировка неприменима при агреги-
ровании.
Когда предложение блокировки находится на верхнем уровне запроса SELECT, блокируются имен-
но те строки, которые возвращаются запросом; в случае с запросом объединения, блокировке под-
лежат строки, из которых составляются возвращаемые строки объединения. В дополнение к этому,
заблокированы будут строки, удовлетворяющие условиям запроса на момент создания снимка за-
проса, хотя они не будут возвращены, если с момента снимка они изменятся и перестанут удовле-
творять условиям. Если применяется LIMIT, блокировка прекращается, как только будет получено
достаточное количество строк для удовлетворения лимита (но заметьте, что строки, пропускае-
мые указанием OFFSET, будут блокироваться). Подобным образом, если предложение блокировки
1709SELECT
применяется в запросе курсора, блокироваться будут только строки, фактически полученные или
пройденные курсором.
Когда предложение блокировки находится в подзапросе SELECT, блокировке подлежат те строки,
которые будет получены внешним запросом от подзапроса. Таких строк может оказаться меньше,
чем можно было бы предположить, проанализировав только сам подзапрос, так как условия из
внешнего запроса могут способствовать оптимизации выполнения подзапроса. Например, запрос
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
заблокирует только строки, в которых col1 = 5, при том, что в такой записи условие не относится
к подзапросу.
Предыдущие версии не могли сохранить блокировку, которая была повышена последующей точкой
сохранения. Например, этот код:
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET … WHERE key = 1;
ROLLBACK TO s;
не мог сохранить блокировку FOR UPDATE после ROLLBACK TO. Это было исправлено в версии 9.3.
Внимание
Возможно, что команда SELECT, работающая на уровне изоляции READ COMMITTED и при-
меняющая предложение ORDER BY вместе с блокировкой, будет возвращать строки не
по порядку. Это связано с тем, что ORDER BY выполняется в первую очередь. Эта ко-
манда отсортирует результат, но затем может быть заблокирована, пытаясь получить
блокировку одной или нескольких строк. К моменту, когда блокировка SELECT будет
снята, некоторые из сортируемых столбцов могут уже измениться, в результате чего
их порядок может быть нарушен (хотя они были упорядочены для исходных значений).
При необходимости обойти эту проблему, можно поместить FOR UPDATE/SHARE в подза-
прос, например так:
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
Заметьте, что в результате это приведёт к блокированию всех строк в mytable, тогда
как указание FOR UPDATE на верхнем уровне могло бы заблокировать только фактиче-
ски возвращаемые строки. Это может значительно повлиять на производительность,
особенно в сочетании ORDER BY с LIMIT или другими ограничениями. Таким образом,
этот приём рекомендуется, только если ожидается параллельное изменение сортиру-
емых столбцов, а результат должен быть строго отсортирован.
На уровнях изоляции REPEATABLE READ и SERIALIZABLE это приведёт к ошибке сериа-
лизации (с SQLSTATE равным ‘40001’), так что на этих уровнях получить строки не по
порядку невозможно.
Команда TABLE
Команда
TABLE имя
равнозначна
SELECT * FROM имя
Её можно применять в качестве команды верхнего уровня или как более краткую запись внут-
ри сложных запросов. С командой TABLE могут использоваться только предложения WITH, UNION,
INTERSECT, EXCEPT, ORDER BY, LIMIT, OFFSET, FETCH и предложения блокировки FOR; предложение
WHERE и какие-либо формы агрегирования не поддерживаются.
1710SELECT
Примеры
Соединение таблицы films с таблицей distributors:
SELECT f.title, f.did, d.name, f.date_prod, f.kind
FROM distributors d, films f
WHERE f.did = d.did
title
| did |
name
| date_prod |
kind
——————-+—–+————–+————+———-
The Third Man
| 101 | British Lion | 1949-12-23 | Drama
The African Queen | 101 | British Lion | 1951-08-11 | Romantic
…
Суммирование значений столбца len (продолжительность) для всех фильмов и группирование ре-
зультатов по столбцу kind (типу фильма):
SELECT kind, sum(len) AS total FROM films GROUP BY kind;
kind
| total
———-+——-
Action
| 07:34
Comedy
| 02:58
Drama
| 14:28
Musical | 06:42
Romantic | 04:38
Суммирование значений столбца len для всех фильмов, группирование результатов по столбцу
kind и вывод только тех групп, общая продолжительность которых меньше 5 часов:
SELECT kind, sum(len) AS total
FROM films
GROUP BY kind
HAVING sum(len) &lt; interval ‘5 hours’;
kind
| total
———-+——-
Comedy
| 02:58
Romantic | 04:38
Следующие два запроса демонстрируют равнозначные способы сортировки результатов по содер-
жимому второго столбца (name):
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;
did |
name
—–+——————
109 | 20th Century Fox
110 | Bavaria Atelier
101 | British Lion
107 | Columbia
102 | Jean Luc Godard
113 | Luso films
104 | Mosfilm
103 | Paramount
106 | Toho
105 | United Artists
111 | Walt Disney
112 | Warner Bros.
1711SELECT
108 | Westward
Следующий пример показывает объединение таблиц distributors и actors, ограниченное имена-
ми, начинающимися с буквы W в каждой таблице. Интерес представляют только неповторяющие-
ся строки, поэтому ключевое слово ALL опущено.
distributors:
did |
name
—–+————–
108 | Westward
111 | Walt Disney
112 | Warner Bros.
…
actors:
id |
name
—-+—————-
1 | Woody Allen
2 | Warren Beatty
3 | Walter Matthau
…
SELECT distributors.name
FROM distributors
WHERE distributors.name LIKE ‘W%’
UNION
SELECT actors.name
FROM actors
WHERE actors.name LIKE ‘W%’;
name
—————-
Walt Disney
Walter Matthau
Warner Bros.
Warren Beatty
Westward
Woody Allen
Этот пример показывает, как использовать функцию в предложении FROM, со списком определений
столбцов и без него:
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS <script type="math/tex">SELECT * FROM distributors WHERE did = $1;</script> LANGUAGE SQL;
SELECT * FROM distributors(111);
did |
name
—–+————-
111 | Walt Disney
CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS <script type="math/tex">SELECT * FROM distributors WHERE did = $1;</script> LANGUAGE SQL;
SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
f1 |
f2
—–+————-
111 | Walt Disney
Пример функции с добавленным столбцом нумерации:
SELECT * FROM unnest(ARRAY[‘a’,’b’,’c’,’d’,’e’,’f’]) WITH ORDINALITY;
unnest | ordinality
——–+———-
a
|
1
b
|
2
c
|
3
1712SELECT
d
|
e
|
f
|
(6 rows)
4
5
6
Этот пример показывает, как использовать простое предложение WITH:
WITH t AS (
SELECT random() as x FROM generate_series(1, 3)
)
SELECT * FROM t
UNION ALL
SELECT * FROM t
x
——————–
0.534150459803641
0.520092216785997
0.0735620250925422
0.534150459803641
0.520092216785997
0.0735620250925422
Заметьте, что запрос WITH выполняется всего один раз, поэтому мы получаем два одинаковых на-
бора по три случайных значения.
В этом примере WITH RECURSIVE применяется для поиска всех подчинённых Мери (непосредствен-
ных или косвенных) и вывода их уровня косвенности в таблице с информацией только о непосред-
ственных подчинённых:
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
SELECT 1, employee_name, manager_name
FROM employee
WHERE manager_name = ‘Mary’
UNION ALL
SELECT er.distance + 1, e.employee_name, e.manager_name
FROM employee_recursive er, employee e
WHERE er.employee_name = e.manager_name
)
SELECT distance, employee_name FROM employee_recursive;
Заметьте, что это типичная форма рекурсивных запросов: начальное условие, последующий UNION,
а затем рекурсивная часть запроса. Убедитесь в том, что рекурсивная часть запроса в конце кон-
цов перестанет возвращать строки, иначе запрос окажется в бесконечном цикле. (За другими при-
мерами обратитесь к Разделу 7.8.)
В этом примере используется LATERAL для применения функции get_product_names(), возвраща-
ющей множество, для каждой строки таблицы manufacturers:
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
Производители, с которыми в данный момент не связаны никакие продукты, не попадут в резуль-
тат, так как это внутреннее соединение. Если бы мы захотели включить названия и этих произво-
дителей, мы могли бы сделать так:
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
Совместимость
Разумеется, оператор SELECT совместим со стандартом SQL. Однако не все описанные в стандарте
возможности реализованы, а некоторые, наоборот, являются расширениями.
1713SELECT
Необязательное предложение FROM
PostgreSQL разрешает опустить предложение FROM. Это позволяет очень легко вычислять резуль-
таты простых выражений:
SELECT 2+2;
?column?
———-
4
Некоторые другие базы данных SQL не допускают этого, требуя задействовать в SELECT фиктивную
таблицу с одной строкой.
Заметьте, что если предложение FROM не указано, запрос не может обращаться ни к каким табли-
цам базы данных. Например, следующий запрос недопустим:
SELECT distributors.* WHERE distributors.name = ‘Westward’;
До версии 8.1 PostgreSQL мог принимать запросы такого вида, неявно добавляя каждую таблицу,
задействованную в запросе, в предложение FROM этого запроса. Теперь это не допускается.
Пустые списки SELECT
Список выходных выражений после SELECT может быть пустым, что в результате даст таблицу без
столбцов. Стандарт SQL не считает такой синтаксис допустимым, но PostgreSQL допускает его, так
как это согласуется с возможностью иметь таблицы с нулём столбцов. Однако, когда используется
DISTINCT, пустой список не допускается.
Необязательное ключевое слово AS
В стандарте SQL необязательное ключевое слово AS можно опустить перед именем выходного
столбца, если это имя является допустимым именем столбца (то есть не совпадает с каким-либо
зарезервированным ключевым словом). PostgreSQL несколько более строг: AS требуется, если имя
столбца совпадает с любым ключевым словом, зарезервированным или нет. Тем не менее, реко-
мендуется использовать AS или заключать имена выходных столбцов в кавычки, во избежание кон-
фликтов, возможных при появлении в будущем новых ключевых слов.
В списке FROM и стандарт, и PostgreSQL позволяют опускать AS перед псевдонимом, который явля-
ется незарезервированным ключевым словом. Но для имён выходных столбцов это не подходит из-
за синтаксической неоднозначности.
ONLY и наследование
Стандарт SQL требует заключать в скобки имя таблицы после ONLY, например SELECT * FROM ONLY
(tab1), ONLY (tab2) WHERE …. PostgreSQL считает эти скобки необязательными.
PostgreSQL позволяет добавлять в конце *, чтобы явно обозначить, что дочерние таблицы включа-
ются в рассмотрение, в отличие от поведения с ONLY. Стандарт не позволяет этого.
(Эти соображения в равной степени касаются всех SQL-команд, поддерживающих параметр ONLY.)
Ограничения предложения TABLESAMPLE
Предложение TABLESAMPLE в настоящий момент принимается только для обычных таблиц и мате-
риализованных представлений. Однако согласно стандарту SQL оно должно применяться к любым
элементам списка FROM.
Вызовы функций в предложении FROM
PostgreSQL позволяет записать вызов функции непосредственно в виде элемента списка FROM. В
стандарте SQL такой вызов функции требуется помещать во вложенный SELECT; то есть, запись
FROM функция(…) псевдоним примерно равнозначна записи FROM LATERAL (SELECT функция(…))
1714SELECT
псевдоним. Заметьте, что указание LATERAL считается неявным; это связано с тем, что стандарт
требует поведения LATERAL для элемента UNNEST() в предложении FROM. PostgreSQL обрабатывает
UNNEST() так же, как и другие функции, возвращающие множества.
Пространства имён в GROUP BY и ORDER BY
В стандарте SQL-92 предложение ORDER BY может содержать ссылки только на выходные столб-
цы по именам или номерам, тогда как GROUP BY может содержать выражения с именами только
входных столбцов. PostgreSQL расширяет оба эти предложения, позволяя также применять другие
варианты (но если возникает неоднозначность, он разрешает её согласно стандарту). PostgreSQL
также позволяет задавать произвольные выражения в обоих предложениях. Заметьте, что имена,
фигурирующие в выражениях, всегда будут восприниматься как имена входных, а не выходных
столбцов.
В SQL:1999 и более поздних стандартах введено несколько другое определение, которое не пол-
ностью совместимо с SQL-92. Однако в большинстве случаев PostgreSQL будет интерпретировать
выражение ORDER BY или GROUP BY так, как требует SQL:1999.
Функциональные зависимости
PostgreSQL распознаёт функциональную зависимость (что позволяет опускать столбцы в GROUP BY),
только когда первичный ключ таблицы присутствует в списке GROUP BY. В стандарте SQL оговари-
ваются дополнительные условия, которые следует учитывать.
LIMIT и OFFSET
Предложения LIMIT и OFFSET относятся к специфическим особенностям PostgreSQL и поддержи-
ваются также в MySQL. В стандарте SQL:2008 для той же цели вводятся предложения OFFSET …
FETCH (FIRST|NEXT) …, рассмотренные ранее в Подразделе «Предложение LIMIT». Этот синтак-
сис также используется в IBM DB2. (Приложения, написанные для Oracle, часто применяют об-
ходной способ и получают эффект этих предложений, задействуя автоматически генерируемый
столбец rownum, который отсутствует в PostgreSQL.)
FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, FOR KEY SHARE
Хотя указание FOR UPDATE есть в стандарте SQL, стандарт позволяет использовать его только в
предложении DECLARE CURSOR. PostgreSQL допускает его использование в любом запросе SELECT,
а также в подзапросах SELECT, но это является расширением. Варианты FOR NO KEY UPDATE, FOR
SHARE и FOR KEY SHARE, а также указания NOWAIT и SKIP LOCKED в стандарте отсутствуют.
Изменение данных в WITH
PostgreSQL разрешает использовать INSERT, UPDATE и DELETE в качестве запросов WITH. Стандарт
SQL этого не предусматривает.
Нестандартные предложения
DISTINCT ON ( … ) — расширение стандарта SQL.
ROWS FROM( … ) — расширение стандарта SQL.
1715SELECT INTO
SELECT INTO — создать таблицу из результатов запроса
Синтаксис
[ WITH [ RECURSIVE ] запрос_WITH [, …] ]
SELECT [ ALL | DISTINCT [ ON ( выражение [, …] ) ] ]</li>
    </ol>
  </li>
  <li>| выражение [ [ AS ] имя_результата ] [, …]
INTO [ TEMPORARY | TEMP | UNLOGGED ] [ TABLE ] новая_таблица
[ FROM элемент_FROM [, …] ]
[ WHERE условие ]
[ GROUP BY выражение [, …] ]
[ HAVING условие [, …] ]
[ WINDOW имя_окна AS ( определение_окна ) [, …] ]
[ ( UNION | INTERSECT | EXCEPT ) [ ALL | DISTINCT ] выборка ]
[ ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS ( FIRST | LAST ) ]
[, …] ]
[ LIMIT ( число | ALL ) ]
[ OFFSET начало [ ROW | ROWS ] ]
[ FETCH ( FIRST | NEXT ) [ число ] ( ROW | ROWS ) ONLY ]
[ FOR ( UPDATE | SHARE ) [ OF имя_таблицы [, …] ] [ NOWAIT ] […] ]
Описание
SELECT INTO создаёт новую таблицу и заполняет её данными, полученными из запроса. Данные не
передаются клиенту, как с обычной командой SELECT. Столбцы новой таблицы получают имена и
типы данных, связанные с выходными столбцами SELECT.
Параметры
TEMPORARY или TEMP
Если указано, создаваемая таблица будет временной. За подробностями обратитесь к CREATE
TABLE.
UNLOGGED
Если указано, создаваемая таблица будет нежурналируемой. За подробностями обратитесь к
CREATE TABLE.
новая_таблица
Имя создаваемой таблицы (возможно, дополненное схемой).
Все другие параметры подробно описываются в SELECT.
Замечания
Команда SELECT INTO действует подобно CREATE TABLE AS, но рекомендуется использовать CREATE
TABLE AS, так как SELECT INTO не поддерживается в ECPG и PL/pgSQL, вследствие того, что они
воспринимают предложение INTO по-своему. К тому же, CREATE TABLE AS предоставляет больший
набор возможностей, чем SELECT INTO.
Чтобы добавить столбец OID в таблицу, создаваемую командой SELECT INTO, необходимо уста-
новить конфигурационную переменную default_with_oids. С другой стороны, можно использовать
CREATE TABLE AS с предложением WITH OIDS.
Примеры
Создание таблицы films_recent, содержащей только последние записи из таблицы films:
1716SELECT INTO
SELECT * INTO films_recent FROM films WHERE date_prod &gt;= ‘2002-01-01’;
Совместимость
В стандарте SQL команда SELECT INTO применяется для передачи скалярных значений клиентской
программе, но не для создания новой таблицы. Именно это применение имеет место в ECPG (см.
Главу  36) и в PL/pgSQL (см. Главу  43). В PostgreSQL команда SELECT INTO связана с созданием
таблицы по историческим причинам. В новом коде для этих целей лучше использовать CREATE
TABLE AS.
См. также
CREATE TABLE AS
1717SET
SET — изменить параметр времени выполнения
Синтаксис
SET [ SESSION | LOCAL ] параметр_конфигурации ( TO | = ) ( значение | ‘значение’ |
DEFAULT )
SET [ SESSION | LOCAL ] TIME ZONE ( часовой_пояс | LOCAL | DEFAULT )
Описание
Команда SET изменяет конфигурационные параметры времени выполнения. С помощью SET можно
«на лету» изменить многие из параметров, перечисленных в Главе 19. (Но для изменения некото-
рых могут потребоваться права суперпользователя, а другие нельзя изменять после запуска сер-
вера или сеанса.) SET влияет на значение параметра только в рамках текущего сеанса.
Если команда SET (или равнозначная SET SESSION) выполняется внутри транзакции, которая затем
прерывается, эффект команды SET пропадает, когда транзакция откатывается. Если же окружаю-
щая транзакция фиксируется, этот эффект сохраняется до конца сеанса, если его не переопреде-
лит другая команда SET.
Действие SET LOCAL продолжается только до конца текущей транзакции, независимо от того, фик-
сируется она или нет. Особый случай представляет использование SET с последующей SET LOCAL
в одной транзакции: значение, заданное SET LOCAL, будет сохраняться до конца транзакции, но
после этого (если транзакция фиксируется) восстановится значение, заданное командой SET.
Действия SET или SET LOCAL также отменяются при откате к точке сохранения, установленной до
выполнения этих команд.
Если SET LOCAL применяется в функции, параметр SET для которой устанавливает значение той
же переменной (см. CREATE FUNCTION), действие команды SET LOCAL прекращается при выхо-
де из функции; то есть, в любом случае восстанавливается значение, существовавшее при вызове
функции. Это позволяет использовать SET LOCAL для динамических и неоднократных изменений
параметра в рамках функции, и при этом иметь удобную возможность использовать параметр SET
для сохранения и восстановления значения, полученного извне. Однако обычная команда SET пе-
реопределяет любой параметр SET окружающей функции; её действие сохраняется, если не про-
исходит откат транзакции.
Примечание
В PostgreSQL с версии 8.0 до 8.2 действие SET LOCAL могло отменяться при освобож-
дении ранее установленной точки сохранения или при успешном выходе из блока ис-
ключения PL/pgSQL. Затем это поведение было признано неинтуитивным, и было из-
менено.
Параметры
SESSION
Указывает, что команда действует в рамках текущего сеанса. (Это поведение по умолчанию,
если не указано ни SESSION, ни LOCAL.)
LOCAL
Указывает, что команда действует только в рамках текущей транзакции. После COMMIT или
ROLLBACK в силу вновь вступает значение, определённое на уровне сеанса. При выполнении та-
кой команды вне блока транзакции выдаётся предупреждение и больше ничего не происходит.
1718SET
параметр_конфигурации
Имя устанавливаемого параметра времени выполнения. Доступные параметры описаны в Гла-
ве 19 и ниже.
значение
Новое значение параметра. Параметры могут задаваться в виде строковых констант, иденти-
фикаторов, чисел или списков перечисленных типов через запятую, в зависимости от конкрет-
ного параметра. Указание DEFAULT в данном контексте позволяет сбросить параметр к значе-
нию по умолчанию (то есть, к тому значению, которое он имел бы, если в текущем сеансе не
выполнялись бы команды SET).
Помимо конфигурационных параметров, описанных в Главе 19, есть ещё несколько параметров,
которые можно изменить только командой SET или которые имеют особый синтаксис:
SCHEMA
SET SCHEMA ‘значение’ — альтернативное написание команды SET search_path TO значение.
Такой синтаксис позволяет указать только одну схему.
NAMES
SET NAMES значение — альтернативное написание команды SET client_encoding TO значение.
SEED
Устанавливает внутреннее начальное значение для генератора случайных чисел (функции
random). В качестве значения допускаются числа с плавающей точкой от -1 до 1, для внутрен-
31
него применения они затем умножаются на 2 -1.
Это начальное значение также можно установить, вызвав функцию setseed:
SELECT setseed(значение);
TIME ZONE
SET TIME ZONE значение — альтернативное написание команды SET timezone TO значение.
Синтаксис SET TIME ZONE позволяет указывать часовой пояс в специальном формате. Напри-
мер, допускаются следующие значения:
‘PST8PDT’
Часовой пояс Беркли, штат Калифорния.
‘Europe/Rome’
Часовой пояс Италии.
-7
Часовой пояс, сдвинутый от UTC на 7 часов к западу (равнозначен PDT). Положительные
значения означают сдвиг от UTC к востоку.
INTERVAL ‘-08:00’ HOUR TO MINUTE
Часовой пояс, сдвинутый от UTC на 8 часов к западу (равнозначен PST).
LOCAL
DEFAULT
Устанавливает в качестве часового пояса местный часовой пояс (то есть, значение сервер-
ного параметра timezone по умолчанию).
Значения часового пояса, заданные в виде чисел или интервалов, внутри переводятся в формат
часовых поясов POSIX. Например, после SET TIME ZONE -7, команда SHOW TIME ZONE покажет
&lt;-07&gt;+07.
1719SET
Узнать о часовых поясах подробнее можно в Подразделе 8.5.3.
Замечания
Также изменить значение параметра можно с помощью функции set_config; см. Раздел 9.26. Кро-
ме того, выполнив UPDATE в системном представлении pg_settings, можно произвести то же дей-
ствие, что выполняет SET.
Примеры
Установка пути поиска схем:
SET search_path TO my_schema, public;
Установка традиционного стиля даты POSTGRES с форматом ввода «день, месяц, год»:
SET datestyle TO postgres, dmy;
Установка часового пояса для Беркли, штат Калифорния:
SET TIME ZONE ‘PST8PDT’;
Установка часового пояса Италии:
SET TIME ZONE ‘Europe/Rome’;
Совместимость
SET TIME ZONE расширяет синтаксис, определённый в стандарте SQL. Стандарт допускает только
числовые смещения часовых поясов, тогда как PostgreSQL позволяет задавать часовой пояс более
гибко. Все другие функции SET являются расширениями PostgreSQL.
См. также
RESET, SHOW
1720SET CONSTRAINTS
SET CONSTRAINTS — установить время проверки ограничений для текущей транзакции
Синтаксис
SET CONSTRAINTS ( ALL | имя [, …] ) ( DEFERRED | IMMEDIATE )
Описание
SET CONSTRAINTS определяет, когда будут проверяться ограничения в текущей транзакции. Огра-
ничения IMMEDIATE проверяются в конце каждого оператора, а ограничения DEFERRED откладыва-
ются до фиксации транзакции. Режим IMMEDIATE или DEFERRED задаётся для каждого ограничения
независимо.
При создании ограничение получает одну из следующих характеристик: DEFERRABLE INITIALLY
DEFERRED (откладываемое, изначально отложенное), DEFERRABLE INITIALLY IMMEDIATE (отклады-
ваемое, изначально немедленное) или NOT DEFERRABLE (неоткладываемое). Третий вариант всегда
подразумевает IMMEDIATE и на него команда SET CONSTRAINTS не влияет. Первые два варианта за-
пускаются в каждой транзакции в указанном режиме, но их поведение можно изменить в рамках
транзакции командой SET CONSTRAINTS.
SET CONSTRAINTS со списком имён ограничений меняет режим только этих ограничений (все они
должны быть откладываемыми). Имя любого ограничения можно дополнить схемой. Если имя схе-
мы не указано, в поисках первого подходящего имени будет просматриваться текущий путь поиска
схем. SET CONSTRAINTS ALL меняет режим всех откладываемых ограничений.
Когда SET CONSTRAINTS меняет режим ограничения с DEFERRED на IMMEDIATE, новый режим начина-
ет действовать в обратную сторону: все изменения данных, ожидающие проверки в конце транзак-
ции, вместо этого проверяются в момент выполнения команды SET CONSTRAINTS. Если какое-либо
ограничение нарушается, при выполнении SET CONSTRAINTS происходит ошибка (и режим провер-
ки не меняется). Таким образом, с помощью SET CONSTRAINTS можно принудительно проверить
ограничения в определённом месте транзакции.
В настоящее время это распространяется только на ограничения UNIQUE, PRIMARY KEY, REFERENCES
(внешний ключ) и EXCLUDE. Ограничения NOT NULL и CHECK всегда проверяются немедленно в мо-
мент добавления или изменения строки (не в конце оператора). Ограничения уникальности и огра-
ничения-исключения, объявленные без указания DEFERRABLE, так же проверяются немедленно.
Срабатывание триггеров, объявленных как «триггеры ограничений» так же зависит от этой коман-
ды — они срабатывают в момент, когда должно проверяться соответствующее ограничение.
Замечания
Так как PostgreSQL не требует, чтобы имена ограничений были уникальны в схеме (достаточно
уникальности в таблице), возможно, что для заданного имени найдётся несколько соответствую-
щих ограничений. В этом случае SET CONSTRAINTS подействует на все эти ограничения. Для имён
без указания схемы, её действие будет распространяться только на ограничение(я), найденное в
первой из схем; другие схемы просматриваться не будут.
Эта команда меняет поведение ограничений только в текущей транзакции. При выполнении этой
команды вне блока транзакции выдаётся предупреждение и больше ничего не происходит.
Совместимость
Эта команда реализует поведение, описанное в стандарте SQL, с одним исключением — в
PostgreSQL она не влияет на проверку ограничений NOT NULL и CHECK. Кроме того, PostgreSQL
1721SET CONSTRAINTS
проверяет неоткладываемые ограничения уникальности немедленно, а не в конце оператора, как
предлагает стандарт.
1722SET ROLE
SET ROLE — установить идентификатор текущего пользователя в рамках сеанса
Синтаксис
SET [ SESSION | LOCAL ] ROLE имя_роли
SET [ SESSION | LOCAL ] ROLE NONE
RESET ROLE
Описание
Эта команда меняет идентификатор текущего пользователя в активном сеансе SQL на имя_роли.
Имя роли может быть записано в виде идентификатора или строковой константы. После SET ROLE,
права доступа для команд SQL проверяются так, как если бы сеанс изначально был установлен с
этим именем роли.
Указывая определённое имя_роли, текущий пользователь должен являться членом этой роли. (Если
пользователь сеанса является суперпользователем, он может выбрать любую роль.)
Указания SESSION и LOCAL действуют на эту команду так же, как и на обычную команду SET.
Формы NONE и RESET сбрасывают идентификатор текущего пользователя, так что активным стано-
вится идентификатор пользователя сеанса. Эти формы могут выполняться любыми пользователя-
ми.
Замечания
С помощью этой команды можно как добавить права, так и ограничить их. Если роль пользователя
сеанса имеет атрибут INHERITS, она автоматически получает права всех ролей, на которые может
переключиться (с помощью SET ROLE); в этом случае SET ROLE убирает все права, назначенные
непосредственно пользователю сеанса и другим ролям, в которые он включён, и оставляет только
права, назначенные указанной роли. Если же роль пользователя сеанса имеет атрибут NOINHERITS,
SET ROLE убирает права, назначенные непосредственно пользователю сеанса, и вместо них назна-
чает права, которые имеет указанная роль.
В частности, когда суперпользователь переключается на роль не суперпользователя (используя
SET ROLE), он теряет свои права суперпользователя.
SET ROLE оказывает действие, сравнимое с SET SESSION AUTHORIZATION, но проверка прав вы-
полняется по-другому. Также SET SESSION AUTHORIZATION определяет, какие роли разрешены для
последующей SET ROLE, тогда как при смене ролей командой SET ROLE набор ролей, допустимых
для последующей команды SET ROLE не меняется.
SET ROLE не обрабатывает сеансовые переменные, указанные в свойствах роли (ALTER ROLE); они
устанавливаются только при подключении.
SET ROLE нельзя использовать внутри функции с характеристикой SECURITY DEFINER.
Примеры
SELECT SESSION_USER, CURRENT_USER;
session_user | current_user
————–+————–
peter
| peter
SET ROLE ‘paul’;
1723SET ROLE
SELECT SESSION_USER, CURRENT_USER;
session_user | current_user
————–+————–
peter
| paul
Совместимость
PostgreSQL принимает идентификаторы (“имя_роли”), тогда как стандарт SQL требует, чтобы имя
роли записывалось в виде строковой константы. Стандарт не позволяет выполнять эту команду
в транзакции; в PostgreSQL такого ограничения нет, так как для него нет причины. Указания
SESSION и LOCAL относятся к расширениям PostgreSQL, так же, как и синтаксис RESET.
См. также
SET SESSION AUTHORIZATION
1724SET SESSION AUTHORIZATION
SET SESSION AUTHORIZATION — установить идентификатор пользователя сеанса и идентифика-
тор текущего пользователя в рамках сеанса
Синтаксис
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION имя_пользователя
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT
RESET SESSION AUTHORIZATION
Описание
Эта команда меняет идентификатор пользователя сеанса и идентификатор текущего пользователя
в рамках активного сеанса SQL на имя_пользователя. Имя пользователя может быть записано в
виде идентификатора или строковой константы. С помощью этой команды, можно, например, вре-
менно переключиться на непривилегированного пользователя, сохранив возможность затем стать
суперпользователем.
Идентификатором пользователя сеанса изначально принимается имя пользователя, введённое
клиентом (возможно, прошедшее проверку подлинности). Идентификатор текущего пользователя
обычно совпадает с идентификатором пользователя сеанса, но может временно меняться в функ-
циях с характеристикой SECURITY DEFINER и подобными механизмами; также его можно изменить
командой SET ROLE. Идентификатор текущего пользователя принимается во внимание при про-
верке разрешений.
Идентификатор пользователя сеанса можно изменить, только если начальный пользователь сеан-
са (аутентифицированный пользователь) имеет права суперпользователя. В противном случае
эта команда разрешается, только если в ней указывается имя аутентифицированного пользовате-
ля.
Указания SESSION и LOCAL действуют на эту команду так же, как и на обычную команду SET.
Формы DEFAULT и RESET сбрасывают идентификаторы текущего пользователя и пользователя сеан-
са, так что текущим становится пользователь, изначально проходивший проверку подлинности.
Эти формы могут выполняться любым пользователем.
Замечания
SET SESSION AUTHORIZATION нельзя использовать в функции с характеристикой SECURITY DEFINER.
Примеры
SELECT SESSION_USER, CURRENT_USER;
session_user | current_user
————–+————–
peter
| peter
SET SESSION AUTHORIZATION ‘paul’;
SELECT SESSION_USER, CURRENT_USER;
session_user | current_user
————–+————–
paul
| paul
1725SET SESSION AUTHORIZATION
Совместимость
Стандарт SQL позволяет вместо строковой константы имя_пользователя указывать некоторые дру-
гие выражения, но на практике это не очень полезно. PostgreSQL допускает синтаксис идентифи-
каторов (“имя_пользователя”), а стандарт SQL — нет. Стандарт не позволяет выполнять эту коман-
ду в транзакции; в PostgreSQL такого ограничения нет, так как для него нет причины. Указания
SESSION и LOCAL относятся к расширениям PostgreSQL, так же, как и синтаксис RESET.
Набор прав, требуемых для выполнения этой команды, согласно стандарту, определяется реали-
зацией.
См. также
SET ROLE
1726SET TRANSACTION
SET TRANSACTION — установить характеристики текущей транзакции
Синтаксис
SET TRANSACTION режим_транзакции [, …]
SET TRANSACTION SNAPSHOT id_снимка
SET SESSION CHARACTERISTICS AS TRANSACTION режим_транзакции [, …]
Где режим_транзакции может быть следующим:
ISOLATION LEVEL ( SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ
UNCOMMITTED )
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
Описание
Команда SET TRANSACTION устанавливает характеристики текущей транзакции. На последующие
транзакции она не влияет. SET SESSION CHARACTERISTICS устанавливает характеристики транзак-
ции по умолчанию для последующих транзакций в рамках сеанса. Заданные по умолчанию харак-
теристики затем можно переопределить для отдельных транзакций командой SET TRANSACTION.
К характеристикам транзакции относится уровень изоляции транзакции, режим доступа транзак-
ции (чтение/запись или только чтение) и допустимость её откладывания. В дополнение к ним мож-
но выбрать снимок, но только для текущей транзакции, не для сеанса по умолчанию.
Уровень изоляции транзакции определяет, какие данные может видеть транзакция, когда парал-
лельно с ней выполняются другие транзакции:
READ COMMITTED
Оператор видит только те строки, которые были зафиксированы до начала его выполнения.
Этот уровень устанавливается по умолчанию.
REPEATABLE READ
Все операторы текущей транзакции видят только те строки, которые были зафиксированы пе-
ред первым запросом на выборку или изменение данных, выполненным в этой транзакции.
SERIALIZABLE
Все операторы текущей транзакции видят только те строки, которые были зафиксированы
перед первым запросом на выборку или изменение данных, выполненным в этой транзак-
ции. Если наложение операций чтения и записи параллельных сериализуемых транзакций
может привести к ситуации, невозможной при последовательном их выполнении (когда од-
на транзакция выполняется за другой), произойдёт откат одной из транзакций с ошибкой
serialization_failure (сбой сериализации).
В стандарте SQL определён ещё один уровень, READ UNCOMMITTED. В PostgreSQL уровень READ
UNCOMMITTED обрабатывается как READ COMMITTED.
Уровень изоляции транзакции нельзя изменить после выполнения первого запроса на выборку
или изменение данных (SELECT, INSERT, DELETE, UPDATE, FETCH или COPY) в текущей транзакции.
За дополнительными сведениями об изоляции транзакций и управлении параллельным доступом
обратитесь к Главе 13.
Режим доступа транзакции определяет, будет ли транзакция только читать данные или будет и
читать, и писать. По умолчанию подразумевается чтение/запись. В транзакции без записи запре-
1727SET TRANSACTION
щаются следующие команды SQL: INSERT, UPDATE, DELETE и COPY FROM, если только целевая таблица
не временная; любые команды CREATE, ALTER и DROP, а также COMMENT, GRANT, REVOKE, TRUNCATE; кро-
ме того, запрещаются EXPLAIN ANALYZE и EXECUTE, если команда, которую они должны выполнить,
относится к вышеперечисленным. Это высокоуровневое определение режима только для чтения,
которое в принципе не исключает запись на диск.
Свойство DEFERRABLE оказывает влияние, только если транзакция находится также в режимах
SERIALIZABLE и READ ONLY. Когда для транзакции установлены все три этих свойства, транзакция
может быть заблокирована при первой попытке получить свой снимок данных, после чего она
сможет выполняться без дополнительных усилий, обычных для режима SERIALIZABLE, и без риска
привести к сбою сериализации или пострадать от него. Этот режим подходит для длительных опе-
раций, например для построения отчётов или резервного копирования.
Команда SET TRANSACTION SNAPSHOT позволяет выполнить новую транзакцию со снимком данных,
который имеет уже существующая. Эта ранее созданная транзакция должна экспортировать этот
снимок с помощью функции pg_export_snapshot (см. Подраздел 9.26.5). Эта функция возвращает
идентификатор снимка, который и нужно передать команде SET TRANSACTION SNAPSHOT в качестве
идентификатора импортируемого снимка. В данной команде этот идентификатор должен записы-
ваться в виде строковой константы, например ‘000003A1-1’. SET TRANSACTION SNAPSHOT можно
выполнить только в начале транзакции, до первого запроса на выборку или изменение данных
(SELECT, INSERT, DELETE, UPDATE, FETCH или COPY) в текущей транзакции. Более того, для транзак-
ции уже должен быть установлен уровень изоляции SERIALIZABLE или REPEATABLE READ (в против-
ном случае, снимок будет сразу же потерян, так как на уровне READ COMMITTED для каждой ко-
манды делается новый снимок). Если импортирующая транзакция работает на уровне изоляции
SERIALIZABLE, то транзакция, экспортирующая снимок, также должна работать на этом уровне.
Кроме того, транзакции в режиме чтение/запись не могут импортировать снимок из транзакции
в режиме «только чтение».
Замечания
Если команде SET TRANSACTION не предшествует START TRANSACTION или BEGIN, она выдаёт преду-
преждение и больше ничего не делает.
Без SET TRANSACTION можно обойтись, задав требуемые режимы_транзакции в операторах BEGIN или
START TRANSACTION. Но для SET TRANSACTION SNAPSHOT такой возможности не предусмотрено.
Режимы транзакции для сеанса по умолчанию можно также задать в конфигурационных перемен-
ных default_transaction_isolation, default_transaction_read_only и default_transaction_deferrable. (На
практике, SET SESSION CHARACTERISTICS — это просто более многословная альтернатива измене-
нию этих переменных командой SET.) Это значит, что значения этих переменных по умолчанию
можно задать в файле конфигурации, с помощью команды ALTER DATABASE и т. д. За дополнитель-
ными сведениями обратитесь к Главе 19.
Примеры
Чтобы начать новую транзакцию со снимком данных, который получила уже существующая тран-
закция, его нужно сначала экспортировать из первой транзакции. При этом будет получен иден-
тификатор снимка, например:
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT pg_export_snapshot();
pg_export_snapshot
———————
00000003-0000001B-1
(1 row)
Затем этот идентификатор нужно передать команде SET TRANSACTION SNAPSHOT в начале новой
транзакции:
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
1728SET TRANSACTION
SET TRANSACTION SNAPSHOT ‘00000003-0000001B-1’;
Совместимость
Эти команды определены в стандарте SQL, за исключением режима транзакции DEFERRABLE и фор-
мы SET TRANSACTION SNAPSHOT, которые являются расширениями PostgreSQL.
В стандарте уровнем изоляции по умолчанию является SERIALIZABLE. В PostgreSQL уровнем по
умолчанию обычно считается READ COMMITTED, но его можно изменить, как описано выше.
В стандарте SQL есть ещё одна характеристика транзакции, которую нельзя задать этими коман-
дами: размер диагностической области. Эта специфическая концепция встраиваемого SQL, поэто-
му в сервере PostgreSQL она не реализована.
Стандарт SQL требует, чтобы последовательные режимы_транзакций разделялись запятыми, но по
историческим причинам PostgreSQL позволяет опустить запятые.
1729SHOW
SHOW — показать значение параметра времени выполнения
Синтаксис
SHOW имя
SHOW ALL
Описание
SHOW выводит текущие значения параметров времени выполнения. Эти переменные можно уста-
новить, воспользовавшись оператором SET, отредактировав файл конфигурации postgresql.conf,
передав в переменной окружения PGOPTIONS (при использовании psql или приложения на базе
libpq) либо в параметрах командной строки при запуске сервера postgres. За подробностями об-
ратитесь к Главе 19.
Параметры
имя
Имя параметра времени выполнения. Доступные параметры описаны в Главе 19 и на странице
справки SET. Кроме того, есть несколько параметров, которые можно просмотреть, но нельзя
изменить:
SERVER_VERSION
Показывает номер версии сервера.
SERVER_ENCODING
Показывает кодировку набора символов на стороне сервера. В настоящее время этот пара-
метр можно узнать, но нельзя изменить, так как кодировка определяется в момент созда-
ния базы данных.
LC_COLLATE
Показывает параметр локали базы данных, определяющий правило сортировки (порядок
текстовых строк). В настоящее время этот параметр можно узнать, но нельзя изменить, так
как он определяется в момент создания базы данных.
LC_CTYPE
Показывает параметр локали базы данных, определяющий классификацию символов. В на-
стоящее время этот параметр можно узнать, но нельзя изменить, так как он определяется
в момент создания базы данных.
IS_SUPERUSER
Возвращает true, если текущая роль обладает правами суперпользователя.
ALL
Показать значения всех конфигурационных параметров с описаниями.
Замечания
Ту же информацию выдаёт функция current_setting; см. Раздел 9.26. Кроме того, эту информацию
можно получить через системное представление pg_settings.
Примеры
Просмотр текущего значения параметра DateStyle:
1730SHOW
SHOW DateStyle;
DateStyle
———–
ISO, MDY
(1 row)
Просмотр текущего значения параметра geqo:
SHOW geqo;
geqo
——
on
(1 row)
Просмотр всех параметров:
SHOW ALL;
name
| setting |
description
————————-+———+————————————————-
allow_system_table_mods | off
| Allows modifications of the structure of …
.
.
.
xmloption
| content | Sets whether XML data in implicit parsing …
zero_damaged_pages
| off
| Continues processing past damaged page headers.
(196 rows)
Совместимость
Команда SHOW является расширением PostgreSQL.
См. также
SET, RESET
1731START TRANSACTION
START TRANSACTION — начать блок транзакции
Синтаксис
START TRANSACTION [ режим_транзакции [, …] ]
Где режим_транзакции может быть следующим:
ISOLATION LEVEL ( SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ
UNCOMMITTED )
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
Описание
Эта команда начинает новый блок транзакции. Если указан уровень изоляции, режим чтения/за-
писи или допустимость откладывания транзакции, новая транзакция получит эти характеристики,
как при выполнении команды SET TRANSACTION. Данная команда равнозначна команде BEGIN.
Параметры
За описанием параметров этого оператора обратитесь к SET TRANSACTION.
Совместимость
Согласно стандарту, выполнять START TRANSACTION, чтобы начать блок транзакции, необязательно:
блок неявно начинает любая команда SQL. Поведение PostgreSQL можно представить как неяв-
ное выполнение COMMIT после каждой команды, которой не предшествует START TRANSACTION (или
BEGIN), и поэтому такое поведение часто называется «автофиксацией». Другие реляционные СУБД
тоже могут предлагать автофиксацию как удобную возможность.
Значение DEFERRABLE параметра режим_транзакции является языковым расширением PostgreSQL.
Стандарт SQL требует, чтобы последовательные режимы_транзакций разделялись запятыми, но по
историческим причинам PostgreSQL позволяет опустить запятые.
См. также сведения о совместимости в описании SET TRANSACTION.
См. также
BEGIN, COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION
1732TRUNCATE
TRUNCATE — опустошить таблицу или набор таблиц
Синтаксис
TRUNCATE [ TABLE ] [ ONLY ] имя [ * ] [, … ]
[ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
Описание
Команда TRUNCATE быстро удаляет все строки из набора таблиц. Она действует так же, как без-
условная команда DELETE для каждой таблицы, но гораздо быстрее, так как она фактически не
сканирует таблицы. Более того, она немедленно высвобождает дисковое пространство, так что вы-
полнять операцию VACUUM после неё не требуется. Наиболее полезна она для больших таблиц.
Параметры
имя
Имя таблицы (возможно, дополненное схемой), подлежащей опустошению. Если перед именем
таблицы указано ONLY, очищается только заданная таблица. Без ONLY очищается и заданная
таблица, и все её потомки (если таковые есть). После имени таблицы можно также добавить
необязательное указание <em>, чтобы явно обозначить, что блокировка затрагивает и все дочерние
таблицы.
RESTART IDENTITY
Автоматически перезапускать последовательности, связанные со столбцами опустошаемой
таблицы.
CONTINUE IDENTITY
Не изменять значения последовательностей. Это поведение по умолчанию.
CASCADE
Автоматически опустошать все таблицы, ссылающиеся по внешнему ключу на заданные таб-
лицы, или на таблицы, затронутые в результате действия CASCADE.
RESTRICT
Отказать в опустошении любых таблиц, на которые по внешнему ключу ссылаются другие таб-
лицы, не перечисленные в этой команде. Это поведение по умолчанию.
Замечания
Чтобы опустошить таблицу, необходимо иметь право TRUNCATE для этой таблицы.
Команда TRUNCATE запрашивает блокировку ACCESS EXCLUSIVE для каждой таблицы, которую она
обрабатывает. Когда указано RESTART IDENTITY, все последовательности, которые должны быть
перезапущены, так же блокируются исключительно. В случаях, когда требуется обеспечить па-
раллельный доступ к таблице, следует использовать DELETE.
TRUNCATE нельзя использовать с таблицей, на которую по внешнему ключу ссылаются другие таб-
лицы, если только и эти таблицы не опустошаются этой же командой. Проверка допустимости
очистки в таких случаях потребовала бы сканирования таблицы, а главная идея данной команды в
том, чтобы не делать этого. Для автоматической обработки всех зависимых таблиц можно исполь-
зовать указание CASCADE — но будьте очень осторожны с ним, иначе вы можете потерять данные,
которые не собирались удалять!
1733TRUNCATE
При выполнении TRUNCATE не срабатывают никакие триггеры ON DELETE, которые могут быть
настроены для таблиц. Однако при этом срабатывают триггеры ON TRUNCATE. Если триггеры ON
TRUNCATE определены для любых из этих таблиц, то все триггеры BEFORE TRUNCATE срабатывают до
того, как происходит опустошение, а все триггеры AFTER TRUNCATE срабатывают после того, как
завершается опустошение последней таблицы и все последовательности сбрасываются. Триггеры
срабатывают по порядку обработки таблиц (сначала для таблиц, перечисленных в команде, затем
для тех, что затрагиваются каскадно).
Команда TRUNCATE небезопасна с точки зрения MVCC. После опустошения таблицы она будет вы-
глядеть пустой для параллельных транзакций, если они работают со снимком, полученным до опу-
стошения. За подробностями обратитесь к Разделу 13.5.
TRUNCATE является надёжной транзакционной операцией в отношении данных в таблицах: опусто-
шение будет безопасно отменено, если окружающая транзакция не будет зафиксирована.
С указанием RESTART IDENTITY подразумеваемые операции ALTER SEQUENCE RESTART также вы-
полняются транзакционно; то есть, они будут отменены, если окружающая транзакция не будет
зафиксирована. Это отличается от обычного поведения ALTER SEQUENCE RESTART. Учтите, что ес-
ли до того, как транзакция отменится, будут выполнены какие-либо дополнительные операции с
последовательностями, эффект этих операций также будет отменён, но не их влияние на значе-
ние currval(); то есть после транзакции currval() продолжит возвращать последнее значение
последовательности, полученное внутри прерванной транзакции, хотя сама последовательность
уже может быть несогласованной с ним. Подобным образом обычно ведёт себя currval() после
сбоя транзакции.
TRUNCATE в настоящее время не поддерживается для сторонних таблиц. Из этого следует, что если
у целевой таблицы есть дочерние таблицы, являющиеся сторонними, команда не будет выполнена.
Примеры
Опустошение таблиц bigtable и fattable:
TRUNCATE bigtable, fattable;
Та же операция и сброс всех связанных генераторов последовательностей:
TRUNCATE bigtable, fattable RESTART IDENTITY;
Опустошение таблицы othertable и каскадная обработка всех таблиц, ссылающихся на othertable
по ограничениям внешнего ключа:
TRUNCATE othertable CASCADE;
Совместимость
Стандарт SQL:2008 включает команду TRUNCATE с синтаксисом TRUNCATE TABLE имя_таблицы. Пред-
ложения CONTINUE IDENTITY/RESTART IDENTITY также описаны в стандарте, но с небольшими от-
личиями, хотя их назначение похоже. Поведение этой команды при параллельных операциях, со-
гласно стандарту, отчасти определяются реализацией, так что приведённые выше замечания при
необходимости следует учитывать и сопоставлять с другими реализациями.
См. также
DELETE
1734UNLISTEN
UNLISTEN — прекратить ожидание уведомления
Синтаксис
UNLISTEN ( канал | * )
Описание
UNLISTEN применяется для отмены существующей подписки на получение событий NOTIFY.
UNLISTEN отменяет существующую подписку в текущем сеансе PostgreSQL на канал уведомлений
с именем канал. Специальный знак * отменяет все подписки в текущем сеансе.
В описании NOTIFY использование LISTEN и NOTIFY рассматривается более подробно.
Параметры
канал
Имя канала уведомлений (любой идентификатор).
*
Отменяются все текущие подписки на уведомления для активного сеанса.
Замечания
Вы можете также попытаться отменить подписку на канал, на который не подписаны; предупре-
ждений или ошибки при этом не будет.
UNLISTEN * автоматически выполняется в конце каждого сеанса.
Транзакция, выполнившая UNLISTEN, не может быть подготовлена для двухфазной фиксации.
Примеры
Подписка на получение события:
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification “virtual” received from server process with PID 8448.
Сразу после выполнения UNLISTEN последующие сообщения NOTIFY игнорируются:
UNLISTEN virtual;
NOTIFY virtual;
– событие NOTIFY не поступает
Совместимость
Команда UNLISTEN отсутствует в стандарте SQL.
См. также
LISTEN, NOTIFY
1735UPDATE
UPDATE — изменить строки таблицы
Синтаксис
[ WITH [ RECURSIVE ] запрос_WITH [, …] ]
UPDATE [ ONLY ] имя_таблицы [ * ] [ [ AS ] псевдоним ]
SET ( имя_столбца = ( выражение | DEFAULT ) |
( имя_столбца [, …] ) = [ ROW ] ( ( выражение | DEFAULT ) [, …] ) |
( имя_столбца [, …] ) = ( вложенный_SELECT )
) [, …]
[ FROM список_FROM ]
[ WHERE условие | WHERE CURRENT OF имя_курсора ]
[ RETURNING * | выражение_результата [ [ AS ] имя_результата ] [, …] ]
Описание
UPDATE изменяет значения указанных столбцов во всех строках, удовлетворяющих условию. В пред-
ложении SET должны указываться только те столбцы, которые будут изменены; столбцы, не изме-
няемые явно, сохраняют свои предыдущие значения.
Изменить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя
способами: применяя вложенные запросы или указав дополнительные таблицы в предложении
FROM. Выбор предпочитаемого варианта зависит от конкретных обстоятельств.
Предложение RETURNING указывает, что команда UPDATE должна вычислить и возвратить значения
для каждой фактически изменённой строки. Вычислить в нём можно любое выражение со столб-
цами целевой таблицы и/или столбцами других таблиц, упомянутых во FROM. При этом в выражении
будут использоваться новые (изменённые) значения столбцов таблицы. Список RETURNING имеет
тот же синтаксис, что и список результатов SELECT.
Для выполнения этой команды необходимо иметь право UPDATE для таблицы, или как минимум для
столбцов, перечисленных в списке изменяемых. Также необходимо иметь право SELECT для всех
столбцов, значения которых считываются в выражениях или условии.
Параметры
запрос_WITH
Предложение WITH позволяет задать один или несколько подзапросов, на которые затем можно
ссылаться по имени в запросе UPDATE. Подробнее об этом см. Раздел 7.8 и SELECT.
имя_таблицы
Имя таблицы (возможно, дополненное схемой), строки которой будут изменены. Если перед
именем таблицы добавлено ONLY, соответствующие строки изменяются только в указанной таб-
лице. Без ONLY строки будут также изменены во всех таблицах, унаследованных от указанной.
При желании, после имени таблицы можно указать *, чтобы явно обозначить, что операция
затрагивает все дочерние таблицы.
псевдоним
Альтернативное имя целевой таблицы. Когда указывается это имя, оно полностью скрывает
фактическое имя таблицы. Например, в запросе UPDATE foo AS f дополнительные компоненты
оператора UPDATE должны обращаться к целевой таблице по имени f, а не foo.
имя_столбца
Имя столбца в таблице имя_таблицы. Имя столбца при необходимости может быть дополнено
именем вложенного поля или индексом массива. Имя таблицы добавлять к имени целевого
столбца не нужно — например, запись UPDATE table_name SET table_name.col = 1 ошибочна.
1736UPDATE
выражение
Выражение, результат которого присваивается столбцу. В этом выражении можно использо-
вать предыдущие значения этого и других столбцов таблицы.
DEFAULT
Присвоить столбцу значение по умолчанию (это может быть NULL, если для столбца не опре-
делено некоторое выражение по умолчанию).
вложенный_SELECT
Подзапрос SELECT, выдающий столько выходных столбцов, сколько перечислено в предшеству-
ющем ему списке столбцов в скобках. При выполнении этого подзапроса должна быть получена
максимум одна строка. Если он выдаёт одну строку, значения столбцов в нём присваиваются
целевым столбцам; если же он не возвращает строку, целевым столбцам присваивается NULL.
Этот подзапрос может обращаться к предыдущим значениям текущей изменяемой строки в
таблице.
список_FROM
Список табличных выражений, позволяющий использовать в условии WHERE и выражениях при-
сваивания столбцы из других таблиц. Этот список подобен тому, что задаётся в предложении
«Предложение FROM» оператора SELECT. Заметьте, что целевую таблицу нужно добавлять в спи-
сок_FROM только при формировании замкнутого соединения (в этом случае она должна фигу-
рировать в списке_FROM под псевдонимом).
условие
Выражение, возвращающее значение типа boolean. Изменены будут только те стоки, для ко-
торых это выражение возвращает true.
имя_курсора
Имя курсора, который будет использоваться в условии WHERE CURRENT OF. С таким условием
будет изменена строка, выбранная из этого курсора последней. Курсор должен образовываться
запросом, не применяющим группировку, к целевой таблице команды UPDATE. Заметьте, что
WHERE CURRENT OF нельзя задать вместе с булевским условием. За дополнительными сведениями
об использовании курсоров с WHERE CURRENT OF обратитесь к DECLARE.
выражение_результата
Выражение, которое будет вычисляться и возвращаться командой UPDATE после изменения
каждой строки. В этом выражении можно использовать имена любых столбцов таблицы
имя_таблицы или таблиц, перечисленных в списке FROM. Чтобы получить все столбцы, достаточ-
но написать *.
имя_результата
Имя, назначаемое возвращаемому столбцу.
Выводимая информация
В случае успешного завершения, UPDATE возвращает метку команды в виде
UPDATE число
Здесь число обозначает количество изменённых строк, включая те подлежащие изменению стро-
ки, значения в которых не были изменены. Заметьте, что это число может быть меньше количества
строк, удовлетворяющих условию, когда изменения отменяются триггером BEFORE UPDATE. Если
число равно 0, данный запрос не изменил ни одной строки (это не считается ошибкой).
Если команда UPDATE содержит предложение RETURNING, её результат будет похож на результат
оператора SELECT (с теми же столбцами и значениями, что содержатся в списке RETURNING), полу-
ченный для строк, изменённых этой командой.
1737UPDATE
Замечания
Когда присутствует предложение FROM, целевая таблица по сути соединяется с таблицами, пере-
численными в списке_FROM, и каждая выходная строка соединения представляет операцию изме-
нения для целевой таблицы. Применяя предложение FROM, необходимо обеспечить, чтобы соеди-
нение выдавало максимум одну выходную строку для каждой строки, которую нужно изменить.
Другими словами, целевая строка не должна соединяться с более чем одной строкой из других
таблиц. Если это условие нарушается, только одна из строк соединения будет использоваться для
изменения целевой строки, но какая именно, предсказать нельзя.
Из-за этой неопределённости надёжнее ссылаться на другие таблицы только в подзапросах, хотя
такие запросы часто хуже читаются и работают медленнее, чем соединение.
В секционированной таблице строка при изменении может перестать удовлетворять ограничению
содержащей её секции. При этом если есть другая секция в дереве секционирования, ограниче-
нию которой эта строка удовлетворяет, то она переносится в данную секцию. Если такой секции
нет, происходит ошибка. За кулисами перемещение строки выполняется посредством операций
DELETE и INSERT. Однако есть вероятность, что при параллельных операциях UPDATE и DELETE, за-
трагивающих одну и ту же строку, эта строка может потеряться. Подробнее об этом рассказывает-
ся в разделе Подраздел 5.10.2.3. В настоящее время строки не могут быть перемещены из секции,
являющейся сторонней таблицей, в какую-то другую секцию, но могут перемещаться в стороннюю
таблицу, если это поддерживает обёртка сторонних данных.
Примеры
Изменение слова Drama на Dramatic в столбце kind таблицы films:
UPDATE films SET kind = ‘Dramatic’ WHERE kind = ‘Drama’;
Изменение значений температуры и сброс уровня осадков к значению по умолчанию в одной стро-
ке таблицы weather:
UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
WHERE city = ‘San Francisco’ AND date = ‘2003-07-03’;
Выполнение той же операции с получением изменённых записей:
UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
WHERE city = ‘San Francisco’ AND date = ‘2003-07-03’
RETURNING temp_lo, temp_hi, prcp;
Такое же изменение с применением альтернативного синтаксиса со списком столбцов:
UPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)
WHERE city = ‘San Francisco’ AND date = ‘2003-07-03’;
Увеличение счётчика продаж для менеджера, занимающегося компанией Acme Corporation, с при-
менением предложения FROM:
UPDATE employees SET sales_count = sales_count + 1 FROM accounts
WHERE accounts.name = ‘Acme Corporation’
AND employees.id = accounts.sales_person;
Выполнение той же операции, с вложенным запросом в предложении WHERE:
UPDATE employees SET sales_count = sales_count + 1 WHERE id =
(SELECT sales_person FROM accounts WHERE name = ‘Acme Corporation’);
Изменение имени контакта в таблице счетов (это должно быть имя назначенного менеджера по
продажам):
UPDATE accounts SET (contact_first_name, contact_last_name) =
(SELECT first_name, last_name FROM salesmen
1738UPDATE
WHERE salesmen.id = accounts.sales_id);
Подобный результат можно получить, применив соединение:
UPDATE accounts SET contact_first_name = first_name,
contact_last_name = last_name
FROM salesmen WHERE salesmen.id = accounts.sales_id;
Однако, если salesmen.id — не уникальный ключ, второй запрос может давать непредсказуемые
результаты, тогда как первый запрос гарантированно выдаст ошибку, если найдётся несколько
записей с одним id. Кроме того, если соответствующая запись accounts.sales_id не найдётся,
первый запрос запишет в поля имени NULL, а второй вовсе не изменит строку.
Обновление статистики в сводной таблице в соответствии с текущими данными:
UPDATE summary s SET (sum_x, sum_y, avg_x, avg_y) =
(SELECT sum(x), sum(y), avg(x), avg(y) FROM data d
WHERE d.group_id = s.group_id);
Попытка добавить новый продукт вместе с количеством. Если такая запись уже существует, вместо
этого увеличить количество данного продукта в существующей записи. Чтобы реализовать этот
подход, не откатывая всю транзакцию, можно использовать точки сохранения:
BEGIN;
– другие операции
SAVEPOINT sp1;
INSERT INTO wines VALUES(‘Chateau Lafite 2003’, ‘24’);
– Предполагая, что здесь возникает ошибка из-за нарушения уникальности ключа,
– мы выполняем следующие команды:
ROLLBACK TO sp1;
UPDATE wines SET stock = stock + 24 WHERE winename = ‘Chateau Lafite 2003’;
– Продолжение других операций и в завершение…
COMMIT;
Изменение столбца kind таблицы films в строке, на которой в данный момент находится курсор
c_films:
UPDATE films SET kind = ‘Dramatic’ WHERE CURRENT OF c_films;
Совместимость
Эта команда соответствует стандарту SQL, за исключением предложений FROM и RETURNING, кото-
рые являются расширениями PostgreSQL, как и возможность применять WITH с UPDATE.
В некоторых других СУБД также поддерживается дополнительное предложение FROM, но предпо-
лагается, что целевая таблица должна ещё раз упоминаться в этом предложении. PostgreSQL вос-
принимает предложение FROM не так, поэтому будьте внимательны, портируя приложения, кото-
рые используют это расширение языка.
Согласно стандарту, исходным значением для вложенного списка имён столбцов в скобках может
быть любое выражение, выдающее строку с нужным количеством столбцов. PostgreSQL принимает
в качестве этого значения только конструктор строки или вложенный SELECT. Изменяемое значе-
ние отдельного столбца можно обозначать словом DEFAULT в конструкторе строки, но не внутри
вложенного SELECT.
1739VACUUM
VACUUM — провести сборку мусора и, возможно, проанализировать базу данных
Синтаксис
VACUUM [ ( параметр [, …] ) ] [ таблица_и_столбцы [, …] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ ANALYZE ] [ таблица_и_столбцы [, …] ]
Здесь допускается параметр:
FULL
FREEZE
VERBOSE
ANALYZE
DISABLE_PAGE_SKIPPING
и таблица_и_столбцы:
имя_таблицы [ ( имя_столбца [, …] ) ]
Описание
VACUUM высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных операциях
PostgreSQL кортежи, удалённые или устаревшие в результате обновления, физически не удаляют-
ся из таблицы; они сохраняются в ней, пока не будет выполнена команда VACUUM. Таким образом,
периодически необходимо выполнять VACUUM, особенно для часто изменяемых таблиц.
Без списка таблица_и_столбцы команда VACUUM обрабатывает все таблицы и материализованные
представления в текущей базе данных, на очистку которых текущий пользователь имеет право. С
этим списком VACUUM обрабатывает только указанную таблицу(ы).
VACUUM ANALYZE выполняет очистку (VACUUM), а затем анализ (ANALYZE) всех указанных таблиц. Это
удобная комбинация для регулярного обслуживания БД. За дополнительной информацией об ана-
лизе обратитесь к описанию ANALYZE.
Простая команда VACUUM (без FULL) только высвобождает пространство и делает его доступным для
повторного использования. Эта форма команды может работать параллельно с обычными опера-
циями чтения и записи таблицы, так она не требует исключительной блокировки. Однако освобож-
дённое место не возвращается операционной системе (в большинстве случаев); оно просто оста-
ётся доступным для размещения данных этой же таблицы. VACUUM FULL переписывает всё содер-
жимое таблицы в новый файл на диске, не содержащий ничего лишнего, что позволяет возвратить
неиспользованное пространство операционной системе. Эта форма работает намного медленнее
и запрашивает исключительную блокировку для каждой обрабатываемой таблицы.
Когда список параметров заключается в скобки, параметры могут быть записаны в любом порядке.
Без скобок параметры должны указываться именно в том порядке, который показан выше. Син-
таксис со скобками появился в PostgreSQL 9.0; вариант записи без скобок считается устаревшим.
Параметры
FULL
Выбирает режим «полной» очистки, который может освободить больше пространства, но вы-
полняется гораздо дольше и запрашивает исключительную блокировку таблицы. Этот режим
также требует дополнительное место на диске, так как он записывает новую копию таблицы
и не освобождает старую до завершения операции. Обычно это следует использовать, только
когда требуется высвободить значительный объём пространства, выделенного таблице.
1740VACUUM
FREEZE
Выбирает агрессивную «заморозку» кортежей. Добавление указания FREEZE равносильно вы-
полнению команды VACUUM с параметрами vacuum_freeze_min_age и vacuum_freeze_table_age,
равными нулю. Агрессивная заморозка всегда выполняется при перезаписи таблицы, поэтому
в режиме FULL это указание избыточно.
VERBOSE
Выводит подробный отчёт об очистке для каждой таблицы.
ANALYZE
Обновляет статистику, которую использует планировщик для выбора наиболее эффективного
способа выполнения запроса.
DISABLE_PAGE_SKIPPING
Обычно VACUUM пропускает страницы, учитывая карту видимости. Страницы, на которых, судя
по карте, все кортежи заморожены, можно пропускать всегда, а страницы, в которых все кор-
тежи видны всем транзакциям, могут обрабатываться только при агрессивной очистке. Более
того, за исключением агрессивной очистки, некоторые страницы можно пропускать, чтобы не
ждать, пока другие сеансы закончат их использовать. Этот параметр отключает пропуск стра-
ниц и предназначен для использования только когда целостность карты видимости вызывает
подозрения, что возможно при аппаратных или программных сбоях, приводящих к разруше-
нию БД.
имя_таблицы
Имя (возможно, дополненное схемой) определённой таблицы или материализованного пред-
ставления, подлежащего очистке. Если указанная таблица является секционированной, очист-
ке подвергаются все её конечные секции.
имя_столбца
Имя столбца, подлежащего анализу. По умолчанию анализируются все столбцы. Если указы-
вается список столбцов, также должно присутствовать указание ANALYZE.
Выводимая информация
С указанием VERBOSE команда VACUUM выдаёт сообщения о процессе очистки, отмечая текущую
обрабатываемую таблицу. Также она выводит различные статистические сведения о таблицах.
Замечания
Чтобы очистить таблицу, обычно нужно быть владельцем этой таблицы или суперпользователем.
Однако владельцам баз данных также разрешено сжимать все таблицы в своих базах, за исклю-
чением общих каталогов. (Ограничение в отношении общих каталогов означает, что настоящую
глобальную команду VACUUM может выполнить только суперпользователь.) VACUUM при обработке
пропускает все таблицы, на очистку которых текущий пользователь не имеет прав.
VACUUM нельзя выполнять внутри блока транзакции.
Для таблиц с индексами GIN, VACUUM (в любой форме) также завершает все ожидающие операции
добавления в индекс, перемещая записи индекса из очереди в соответствующие места в основной
структуре индекса GIN. За подробностями обратитесь к Подразделу 66.4.1.
Мы рекомендуем очищать активные производственные базы данных достаточно часто (как мини-
мум, каждую ночь), чтобы избавляться от «мёртвых» строк. После добавления или удаления боль-
шого числа строк может быть хорошей идеей выполнить команду VACUUM ANALYZE для каждой за-
тронутой таблицы. При этом результаты всех последних изменений будут отражены в системных
каталогах, что позволит планировщику запросов PostgreSQL принимать более эффективные реше-
ния при планировании.
1741VACUUM
Режим FULL не рекомендуется для обычного применения, но в некоторых случаях он бывает поле-
зен. Например, когда были удалены или изменены почти все строки таблицы, может возникнуть
желание физически сжать её, чтобы освободить место на диске и ускорить сканирование этой таб-
лицы. Чаще всего VACUUM FULL сжимает таблицу более эффективно, чем обычный VACUUM.
VACUUM создаёт значительную нагрузку на подсистему ввода/вывода, что может отрицательно ска-
заться на производительности других активных сеансов. Поэтому иногда полезно использовать
возможность задержки очистки с учётом её стоимости. За подробностями обратитесь к Подразде-
лу 19.4.4.
PostgreSQL включает средство «автоочистки», которое позволяет автоматизировать регулярную
очистку. Чтобы узнать больше об автоматической и ручной очистке, обратитесь к Разделу 24.1.
Примеры
Очистка одной таблицы onek, проведение её анализа для оптимизатора и печать подробного отчёта
о действиях операции очистки:
VACUUM (VERBOSE, ANALYZE) onek;
Совместимость
Оператор VACUUM отсутствует в стандарте SQL.
См. также
vacuumdb, Подраздел 19.4.4, Подраздел 24.1.6
1742VALUES
VALUES — вычислить набор строк
Синтаксис
VALUES ( выражение [, …] ) [, …]
[ ORDER BY выражение_сортировки [ ASC | DESC | USING оператор ] [, …] ]
[ LIMIT ( число | ALL ) ]
[ OFFSET начало [ ROW | ROWS ] ]
[ FETCH ( FIRST | NEXT ) [ число ] ( ROW | ROWS ) ONLY ]
Описание
VALUES вычисляет значение строки или множество значений строк, заданное выражениями. Чаще
всего эта команда используется для формирования «таблицы констант» в большой команде, но её
можно использовать и отдельно.
Когда указывается больше, чем одна строка, все строки должны иметь одинаковое количество эле-
ментов. Типы данных результирующих столбцов таблицы определяются в результате совмещения
явных и неявных типов выражений, заданных для этих столбцов, по тем же правилам, что и в UNION
(см. Раздел 10.5).
В составе других команд синтаксис допускает использование VALUES везде, где допускается SELECT.
Так как грамматически она воспринимается как SELECT, с командой VALUES можно использовать
предложения ORDER BY, LIMIT (или равнозначное FETCH FIRST) и OFFSET.
Параметры
выражение
Константа или выражение, которое вычисляется и вставляется в указанное место результиру-
ющей таблицы (множества строк). В списке VALUES, находящемся на верхнем уровне оператора
INSERT, выражение может быть заменено словом DEFAULT, указывающим, что в целевой столбец
должно быть вставлено значение этого столбца по умолчанию. Когда VALUES употребляется в
других контекстах, указание DEFAULT использовать нельзя.
выражение_сортировки
Выражение или целочисленная константа, указывающая, как должны сортироваться стро-
ки результата. Это выражение может обращаться к столбцам результата VALUES по именам
column1, column2 и т. д. За дополнительными подробностями обратитесь к Подразделу «Пред-
ложение ORDER BY».
оператор
Оператор сортировки. За подробностями обратитесь к Подразделу «Предложение ORDER BY».
число
Максимальное число строк, которое должно быть возвращено. За подробностями обратитесь к
Подразделу «Предложение LIMIT».
начало
Число строк, которые должны быть пропущены, прежде чем начнётся выдача строк. За подроб-
ностями обратитесь к Подразделу «Предложение LIMIT».
Замечания
Следует избегать составления списков VALUES с очень большим количеством строк, так как при
этом можно столкнуться с нехваткой памяти или снижением производительности. Применение
1743VALUES
VALUES в команде INSERT — особый случай (так как ожидаемые типы столбцов становятся известны
из целевой таблицы команды INSERT и их не надо вычислять, сканируя весь список VALUES), так
что в этом контексте можно работать с гораздо более объёмными списками, чем в других.
Примеры
Простейшая команда VALUES:
VALUES (1, ‘one’), (2, ‘two’), (3, ‘three’);
Эта команда выдаст таблицу из двух столбцов и трёх строк. По сути она равнозначна запросу:
SELECT 1 AS column1, ‘one’ AS column2
UNION ALL
SELECT 2, ‘two’
UNION ALL
SELECT 3, ‘three’;
Более типично использование VALUES в составе большей команды SQL. Чаще всего она применя-
ется в INSERT:
INSERT INTO films (code, title, did, date_prod, kind)
VALUES (‘T_601’, ‘Yojimbo’, 106, ‘1961-06-16’, ‘Drama’);
В контексте INSERT список VALUES может содержать слово DEFAULT, указывающее, что в данном
месте вместо некоторого значения должно использоваться значение столбца по умолчанию:
INSERT INTO films VALUES
(‘UA502’, ‘Bananas’, 105, DEFAULT, ‘Comedy’, ‘82 minutes’),
(‘T_601’, ‘Yojimbo’, 106, DEFAULT, ‘Drama’, DEFAULT);
VALUES также может применяться там, где можно написать вложенный SELECT, например в пред-
ложении FROM:
SELECT f.</em>
FROM films f, (VALUES(‘MGM’, ‘Horror’), (‘UA’, ‘Sci-Fi’)) AS t (studio, kind)
WHERE f.studio = t.studio AND f.kind = t.kind;
UPDATE employees SET salary = salary * v.increase
FROM (VALUES(1, 200000, 1.2), (2, 400000, 1.4)) AS v (depno, target, increase)
WHERE employees.depno = v.depno AND employees.sales &gt;= v.target;
Заметьте, что когда VALUES используется в предложении FROM, предложение AS становится обяза-
тельным, так же, как и для SELECT. При этом не требуется указывать в AS имена всех столбцов,
но это рекомендуется делать. (По умолчанию PostgreSQL даёт столбцам VALUES имена column1,
column2 и т. д., но в других СУБД имена могут быть другими.)
Когда VALUES используется в команде INSERT, значения автоматически приводятся к типу данных
соответствующего целевого столбца. Когда оно используется в других контекстах, может потребо-
ваться указать нужный тип данных. Если все записи представлены строковыми константами в ка-
вычках, достаточно привести к нужному типу значения в первой строке, чтобы задать тип для всех:
SELECT * FROM machines
WHERE ip_address IN (VALUES(‘192.168.0.1’::inet), (‘192.168.0.10’), (‘192.168.1.43’));
Подсказка
Для простых проверок на включение IN лучше полагаться на форму IN со списком
скаляров, чем записывать запрос VALUES, как показано выше. Список скаляров проще
записать и обрабатывается он зачастую более эффективно.
1744VALUES
Совместимость
VALUES соответствует стандарту SQL. Указания LIMIT и OFFSET являются расширениями
PostgreSQL; см. также SELECT.
См. также
INSERT, SELECT
1745Клиентские
приложения PostgreSQL
Раздел описывает клиентские приложения и утилиты PostgreSQL. Некоторые из описанных при-
ложений требуют особые привилегии. Основной отличительной особенностью этих приложений
является возможность исполнения на любом компьютере, независимо от расположения сервера
баз данных.
Имя пользователя и базы данных передаются из командной строки на сервер без изменения ре-
гистра — все пробельные и специальные символы необходимо экранировать с помощью кавычек.
Имена таблиц и другие идентификаторы передаются регистр-независимо, за исключением отдель-
но описанных ситуаций, где может требоваться экранирование.
1746clusterdb
clusterdb — кластеризовать базу данных PostgreSQL
Синтаксис
clusterdb [параметр-подключения…] [ –verbose | -v ] [ –table | -t таблица ] … [имя_бд]
clusterdb [параметр-подключения…] [ –verbose | -v ] –all | -a
Описание
clusterdb это приложение для повторной кластеризации таблиц базы данных PostgreSQL. Утилита
находит ранее кластеризованные таблицы и проводит операцию на основании последнего исполь-
зованного индекса. Затрагиваются лишь ранее кластеризованные таблицы.
clusterdb — это обёртка для SQL-команды CLUSTER. Кластеризация баз данных с её помощью по
сути не отличается от выполнения того же действия при обращении к серверу другими способами.
Параметры
clusterdb принимает следующие аргументы командной строки:
-a
–all
Кластеризовать все базы данных.
[-d] имя_бд
[–dbname=]имя_бд
Указывает имя базы данных для кластеризации. Если оно не указано, и параметр -a (или –
all) не используется, то имя базы берётся из переменной окружения PGDATABASE. Если пере-
менная окружения не установлена, то берётся имя пользователя из параметров подключения
в качестве имени целевой базы.
-e
–echo
Вывести команды к серверу, генерируемые при выполнении clusterdb.
-q
–quiet
Подавлять вывод сообщений о прогрессе выполнения.
-t таблица
–table=таблица
Кластеризовать таблицу. Возможно множественное использование параметра -t.
-v
–verbose
Вывести подробную информацию во время процесса.
-V
–version
Вывести версию clusterdb и прервать дальнейшее выполнение.
1747clusterdb
-?
–help
Вывести справку по аргументам команды clusterdb.
clusterdb также принимает из командной строки параметры подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как clusterdb запрашивает пароль автоматически, если сер-
вер проверяет подлинность по паролю. Однако, чтобы понять это, clusterdb лишний раз под-
ключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненужную
попытку подключения.
–maintenance-db=имя_бд
Указывает имя базы данных, в качестве опорной, для определения необходимости кластериза-
ции других баз данных. По умолчанию используется postgres, а если она не существует, то
используется template1.
Переменные окружения
PGDATABASE
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей, обратитесь к CLUSTER и psql. Переменные окружения и па-
раметры подключения по умолчанию libpq будут применены при запуске утилиты, это следует
учитывать при диагностике.
1748clusterdb
Примеры
Для кластеризации базы данных test:
$ clusterdb test
Для кластеризации отдельной таблицы foo базы данных xyzzy:
$ clusterdb –table=foo xyzzy
См. также
CLUSTER
1749createdb
createdb — создать базу данных PostgreSQL
Синтаксис
createdb [параметр-подключения…] [параметр…] [имя_бд [описание]]
Описание
createdb создаёт базу данных PostgreSQL.
Чаще всего пользователь, выполняющий эту команду, назначается владельцем создаваемой базы
данных. Однако можно указать владельца явным образом с помощью флага -O, если у текущего
пользователя достаточно привилегий.
createdb это обёртка для SQL-команды CREATE DATABASE. Создание баз данных с её помощью по
сути не отличается от выполнения того же действия при обращении к серверу другими способами.
Параметры
createdb принимает в качестве аргументов:
имя_бд
Указывает имя создаваемой базы. Имя должно быть уникальным в рамках кластера PostgreSQL.
По умолчанию в качестве имени базы данных берётся имя текущего системного пользователя.
описание
Добавляет комментарий к создаваемой базе.
-D табличное_пространство
–tablespace=табличное_пространство
Указывает табличное пространство, используемое по умолчанию. Имя пространства обрабаты-
вается аналогично идентификаторам, заключённым в двойные кавычки.
-e
–echo
Вывести команды к серверу, генерируемые при выполнении createdb.
-E кодировка
–encoding=кодировка
Указывает кодировку базы данных. Поддерживаемые сервером PostgreSQL кодировки описаны
в Подразделе 23.3.1.
-l локаль
–locale=локаль
Указывает локаль базы данных. Имеет эффект одновременно установленных флагов –lc-
collate и –lc-ctype.
–lc-collate=локаль
Устанавливает параметр LC_COLLATE для базы данных.
–lc-ctype=локаль
Устанавливает параметр LC_CTYPE для базы данных.
1750createdb
-O владелец
–owner=владелец
Указывает пользователя в качестве владельца создаваемой базы. Имя пользователя обрабаты-
вается аналогично идентификаторам, заключённым в двойные кавычки.
-T шаблон
–template=шаблон
Указывает шаблон, на основе которого будет создана база данных. Имя шаблона обрабатыва-
ется аналогично идентификаторам, заключённым в двойные кавычки.
-V
–version
Вывести версию createdb и прервать дальнейшее исполнение.
-?
–help
Вывести помощь по команде createdb и прервать выполнение.
Флаги -D, -l, -E, -O, и -T по назначению соответствуют флагам SQL-команды CREATE DATABASE.
createdb также принимает из командной строки параметры подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как createdb запрашивает пароль автоматически, если сер-
вер проверяет подлинность по паролю. Однако, чтобы понять это, createdb лишний раз под-
ключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненужную
попытку подключения.
–maintenance-db=имя_бд
Указывает имя опорной базы данных, к которой при создании новой будет произведено под-
ключение. Если имя не указано, то будет использоваться postgres. Если же postgres не суще-
ствует, то будет использоваться template1.
1751createdb
Переменные окружения
PGDATABASE
Если установлено и не переопределено в командной строке, задаёт имя создаваемой базы дан-
ных.
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию. PGUSER указывает имя пользователя при создании ба-
зы данных, если не указано явно в командной строке или в переменной окружения PGDATABASE.
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей обратитесь к CREATE DATABASE и psql. При диагностике нуж-
но учитывать, что при запуске утилиты используются значения переменных окружения и пара-
метров подключения по умолчанию libpq.
Примеры
Создать базу данных demo на сервере, используемом по умолчанию, можно так:
$ createdb demo
Создать базу demo на сервере eden, порт 5000, из шаблонной базы template0 можно такой командой
командной строки, за которой стоит следующая команда SQL:
$ createdb -p 5000 -h eden -T template0 -e demo
CREATE DATABASE demo TEMPLATE template0;
См. также
dropdb, CREATE DATABASE
1752createuser
createuser — создать новую учётную запись PostgreSQL
Синтаксис
createuser [параметр-подключения…] [параметр…] [имя_пользователя]
Описание
createuser создаёт нового пользователя PostgreSQL, а если точнее — роль. Лишь суперпользо-
ватель и пользователи с привилегией CREATEROLE могут создавать новые роли, таким образом,
createuser должна запускаться от их лица.
Чтобы создать дополнительного суперпользователя, необходимо подключиться от имени суще-
ствующего, одного лишь права CREATEROLE недостаточно. Поскольку суперпользователи могут об-
ходить все ограничения доступа в базе данных, к назначению этих полномочий не следует отно-
ситься легкомысленно.
createuser — это обёртка для SQL-команды CREATE ROLE. Создание пользователей с её помощью
по сути не отличается от выполнения того же действия при обращении к серверу другими спосо-
бами.
Параметры
createuser принимает следующие аргументы:
имя_пользователя
Задаёт имя создаваемого пользователя PostgreSQL. Это имя должно отличаться от имён всех
существующих ролей в данной инсталляции PostgreSQL.
-c номер
–connection-limit=номер
Устанавливает максимальное допустимое количество соединений для создаваемого пользова-
теля. По умолчанию ограничение в количестве соединений отсутствует.
-d
–createdb
Разрешает новому пользователю создавать базы данных.
-D
–no-createdb
Запрещает новому пользователю создавать базы данных. Это поведение по умолчанию.
-e
–echo
Вывести команды к серверу, генерируемые при выполнении createuser.
-E
–encrypted
Параметр является устаревшим, но в целях совместимости ещё работает.
-g role
–role=role
Указывает роль, к которой будет добавлена текущая роль в качестве члена группы. Допускается
множественное использование флага -g.
1753createuser
-i
–inherit
Создаваемая роль автоматически унаследует права ролей, в которые она включается. Это по-
ведение по умолчанию.
-I
–no-inherit
Роль не будет наследовать права ролей, в которые она включается.
–interactive
Запросить имя для создаваемого пользователя, а также значения для флагов -d/-D, -r/-R, -s/-
S, если они явно не указаны в командной строке. До версии PostgreSQL 9.1 включительно это
было поведением по умолчанию.
-l
–login
Новый пользователь сможет подключаться к серверу (то есть его имя может быть идентифика-
тором начального пользователя сеанса). Это свойство по умолчанию.
-L
–no-login
Новый пользователь не сможет подключаться к серверу. (Роль без права входа на сервер тем
не менее полезна для управления разрешениями в базе данных.)
-P
–pwprompt
Если флаг указан, то createuser запросит пароль для создаваемого пользователя. Если не пла-
нируется аутентификация по паролю, то пароль можно не устанавливать.
-r
–createrole
Разрешает новому пользователю создавать другие роли, что означает наделение привилегией
CREATEROLE.
-R
–no-createrole
Запрещает пользователю создавать новые роли. Это поведение по умолчанию.
-s
–superuser
Создаваемая роль будет иметь права суперпользователя.
-S
–no-superuser
Новый пользователь не будет суперпользователем. Это поведение по умолчанию.
-V
–version
Вывести версию createuser и завершить выполнение.
–replication
Создаваемый пользователь будет наделён правом REPLICATION. Это рассмотрено подробнее в
документации по CREATE ROLE.
1754createuser
–no-replication
Создаваемый пользователь не будет иметь привилегии REPLICATION. Это рассмотрено подроб-
нее в документации по CREATE ROLE.
-?
–help
Вывести помощь по команде createuser.
createuser также принимает из командной строки параметры подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя для подключения (не имя создаваемого пользователя).
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как createuser запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, createuser лишний раз
подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненуж-
ную попытку подключения.
Переменные окружения
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей, обратитесь к CREATE ROLE и psql. Переменные окружения и
параметры подключения по умолчанию libpq будут применены при запуске утилиты, это следует
учитывать при диагностике.
1755createuser
Примеры
Чтобы создать роль joe на сервере, используемом по умолчанию:
$ createuser joe
Чтобы создать роль joe на сервере, используемом по умолчанию, с запросом дополнительных па-
раметров:
$ createuser –interactive joe
Назначить роль суперпользователем? (y/n) n
Разрешить новой роли создавать базы данных? (y/n) n
Разрешить новой роли создавать другие роли? (y/n) n
Чтобы создать того же пользователя joe с явно заданными атрибутами, подключившись к компью-
теру eden, порту 5000:
$ createuser -h eden -p 5000 -S -D -R -e joe
CREATE ROLE joe NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT LOGIN;
Чтобы создать роль joe с правами суперпользователя и предустановленным паролем:
$ createuser -P -s -e joe
Введите пароль для новой роли: xyzzy
Повторите его: xyzzy
CREATE ROLE joe PASSWORD ‘md5b5f5ba1a423792b526f799ae4eb3d59e’ SUPERUSER CREATEDB
CREATEROLE INHERIT LOGIN;
В приведённом примере введённый пароль отображается лишь для отражения сути, на деле же
он не выводится на экран. Как можно видеть, он шифруется прежде чем передаётся в команде
клиенту.
См. также
dropuser, CREATE ROLE
1756dropdb
dropdb — удалить базу данных PostgreSQL
Синтаксис
dropdb [параметр-подключения…] [параметр…] имя_бд
Описание
dropdb удаляет ранее созданную базу данных PostgreSQL, и должна выполняться от имени супер-
пользователя или её владельца.
dropdb это обёртка для SQL-команды DROP DATABASE. Удаление баз данных с её помощью по сути
не отличается от выполнения того же действия при обращении к серверу другими способами.
Параметры
dropdb принимает в качестве аргументов:
имя_бд
Указывает имя удаляемой базы данных.
-e
–echo
Вывести команды к серверу, генерируемые при выполнении dropdb.
-i
–interactive
Выводит вопрос о подтверждении перед удалением.
-V
–version
Выводит версию dropdb.
–if-exists
Не считать ошибкой, если база данных не существует. В этом случае будет выдано замечание.
-?
–help
Вывести справку по команде dropdb.
dropdb также принимает из командной строки параметры подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
1757dropdb
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как dropdb запрашивает пароль автоматически, если сер-
вер проверяет подлинность по паролю. Однако, чтобы понять это, dropdb лишний раз подклю-
чается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненужную по-
пытку подключения.
–maintenance-db=имя_бд
Указывает имя базы данных, к которой будет произведено подключение при удалении целевой.
Если имя не указано, то будет использовано postgres. Если же postgres не существует, то
будет использоваться template1.
Переменные окружения
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей, обратитесь к DROP DATABASE и psql. При диагностике сле-
дует учесть, что при запуске утилиты также применяются переменные окружения и параметры
подключения по умолчанию libpq.
Примеры
Для удаления базы данных demo на сервере, используемом по умолчанию:
$ dropdb demo
Для удаления базы данных demo на сервере eden, слушающим подключения на порту 5000, в ин-
терактивном режиме и выводом запросов к серверу:
$ dropdb -p 5000 -h eden -i -e demo
База данных “demo” будет удалена навсегда.
Продолжить? (y/n) y
DROP DATABASE demo;
См. также
createdb, DROP DATABASE
1758dropuser
dropuser — удалить учётную запись пользователя PostgreSQL
Синтаксис
dropuser [параметр-подключения…] [параметр…] [имя_пользователя]
Описание
dropuser удаляет ранее созданного пользователя PostgreSQL. Лишь суперпользователь или поль-
зователь с привилегией CREATEROLE могут удалять пользователей PostgreSQL. Необходимо быть
суперпользователем, чтобы удалить учётную запись другого суперпользователя.
dropuser это обёртка для SQL-команды DROP ROLE. Удаление пользователей с её помощью по сути
не отличается от выполнения того же действия при обращении к серверу другими способами.
Параметры
dropuser принимает в качестве аргументов:
имя_пользователя
Указывает имя удаляемой роли PostgreSQL. Если передан флаг -i/–interactive, а имя не ука-
зано в параметрах команды, его необходимо будет ввести интерактивно.
-e
–echo
Вывести команды к серверу, генерируемые при выполнении dropuser.
-i
–interactive
Вывести подтверждение об удалении роли, и запросить её имя, если оно не указано в парамет-
рах команды.
-V
–version
Вывести версию dropuser.
–if-exists
Перехватить ошибку, если пользователь не существует. В этом случае, вместо ошибки, будет
выведено информационное сообщение.
-?
–help
Вывести справку по команде dropuser.
dropuser также принимает из командной строки параметры подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
1759dropuser
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится текущее подключение к базе.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как dropuser запрашивает пароль автоматически, если сер-
вер проверяет подлинность по паролю. Однако, чтобы понять это, dropuser лишний раз под-
ключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненужную
попытку подключения.
Переменные окружения
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей, обратитесь к DROP ROLE и psql. При диагностике следует
учесть, что при запуске утилиты также применяются переменные окружения и параметры под-
ключения по умолчанию libpq.
Примеры
Чтобы удалить роль joe на сервере, используемом по умолчанию:
$ dropuser joe
Чтобы удалить роль joe на сервере eden, слушающем подключения на порту 5000, в интерактивном
режиме и с выводом выполняемых команд:
$ dropuser -p 5000 -h eden -i -e joe
Роль “joe” будет удалена навсегда.
Продолжить? (y/n) y
DROP ROLE joe;
См. также
createuser, DROP ROLE
1760ecpg
ecpg — встроенный C-препроцессор SQL
Синтаксис
ecpg [параметр…] файл…
Описание
ecpg это встроенный SQL препроцессор для программ, написанных на языке C. Он преобразует
программы на C, содержащие SQL-выражения, заменяя их вызовами встроенных функций. Полу-
чаемые на выходе файлы можно затем скомпилировать и скомпоновать.
ecpg преобразует каждый файл, переданный в параметрах, в соответствующий файл на C. Входным
файлам лучше давать расширения .pgc. Это расширение будет автоматически заменяться на .c.
Имя выходного файла также можно задать в параметре -o.
Данный раздел не содержит описания встроенного SQL-языка. Для более подробной информации
см. Главу 36.
Параметры
ecpg принимает в качестве аргументов:
-c
Автоматически генерировать код, написанный на языке C, из кода SQL. Сейчас это справедливо
для EXEC SQL TYPE.
-C режим
Установить режим совместимости; режим может принимать значения: INFORMIX, INFORMIX_SE
и ORACLE.
-D символ
Определить символ начала команд C-препроцессора.
-i
Также разбирать и системные включения.
-I каталог
Указать дополнительный путь включаемых файлов, используемый при выполнении EXEC SQL
INCLUDE. По умолчанию используются . (текущий каталог), /usr/local/include, каталог, зада-
ваемый при компиляции PostgreSQL (обычно — /usr/local/pgsql/include), и /usr/include, в
порядке, как это перечислено.
-o имя_файла
Указывает ecpg имя файла, в который будет осуществлен вывод.
-r параметр
Определяет поведение времени исполнения. Флаг может принимать следующие значения:
no_indicator
Использовать специальные символы для представления значений null. Исторически неко-
торые базы данных используют такой подход.
1761ecpg
prepare
Сформировать подготовленные выражения. libecpg сформирует кеш подготовленных выра-
жений и будет использовать их при необходимости повторно. В случае переполнения кеша,
libecpg освободит память за счёт вытеснения наименее используемых выражений.
questionmarks
Разрешает использовать знак вопроса в качестве аргумента подстановки в целях совмести-
мости. Ранее это было поведением по умолчанию.
-t
Включить автоматическую фиксацию транзакций. В этом режиме каждая SQL-команда будет
автоматически фиксироваться, пока не будет явно включена в блок транзакции. В режиме по
умолчанию команды фиксируются лишь при явном вызове EXEC SQL COMMIT.
-v
Вывести информацию о версии, а также путях поиска включаемых файлов.
–version
Вывести версию ecpg.
-?
–help
Вывести справку по команде ecpg.
Замечания
При компиляции полученных файлов, компилятор должен иметь возможность найти заголовочные
файлы ECPG в каталоге включений PostgreSQL. Для этого можно использовать флаг -I во время
компиляции, например, -I/usr/local/pgsql/include.
Программы на C со встроенным SQL необходимо скомпоновать с библиотекой libecpg, например,
используя флаг компоновщика -L/usr/local/pgsql/lib -lecpg.
Имена каталогов, подходящих для установки, можно найти в разделе pg_config.
Примеры
Если имеется исходный файл на C prog1.pgc со встроенным SQL, можно создать исполняемую
программу, используя следующую последовательность команд:
ecpg prog1.pgc
cc -I/usr/local/pgsql/include -c prog1.c
cc -o prog1 prog1.o -L/usr/local/pgsql/lib -lecpg
1762pg_basebackup
pg_basebackup — создать резервную копию кластера PostgreSQL
Синтаксис
pg_basebackup [параметр…]
Описание
pg_basebackup предназначен для создания резервных копий работающего кластера баз данных
PostgreSQL. Процедура создания копии не влияет на работу других клиентов. Полученные копии
могут использоваться для обеих стратегий восстановления — на заданный момент в прошлом (см.
Раздел 25.3) и в качестве отправной точки для ведомого сервера при реализации трансляции фай-
лов или потоковой репликации (см. Раздел 26.2).
pg_basebackup создаёт бинарную копию файлов кластера, контролируя режим создания копии ав-
томатически. Резервные копии всегда создаются для кластера целиком и невозможно создать ко-
пию для какой-либо сущности базы отдельно. Для этой цели можно использовать, например, ути-
литу pg_dump.
Копия создаётся через обычное подключение к PostgreSQL, и при этом используется протокол
репликации. Подключение должно осуществляться от лица суперпользователя или пользователя
с правом REPLICATION (см. Раздел  21.2), а в pg_hba.conf должно быть прописано подключение
для репликации. Значение max_wal_senders на сервере должно быть достаточно большим, чтобы
допускать минимум ещё одно подключение для копирования и одно для трансляции WAL (если
она используется).
Можно запустить одновременно несколько команд pg_basebackup, но с точки зрения производи-
тельности лучше делать всего одну копию одновременно, а затем копировать получаемый резуль-
тат.
С помощью pg_basebackup можно получить базовую копию не только на ведущем, но и на ведомом
сервере. Для этого на ведомом сервере необходимо разрешить подключения репликации (пара-
метры max_wal_senders и hot_standby, а также настроить аутентификацию компьютера). При этом
на ведущем необходимо включить full_page_writes.
Заметьте, что при копировании с ведомого сервера есть некоторые ограничения:
• Файл истории резервного копирования в целевом кластере баз данных не создаётся.
• При использовании ключа -X none нет гарантии, что все файлы WAL, требуемые для резерв-
ной копии, будут заархивированы в конце копирования.
• Если ведомый сервер переключается в роль ведущего в процессе копирования, копирование
прерывается.
• Все необходимые для резервной копии WAL-записи должны содержать полные страни-
цы, для чего нужно включить режим full_page_writes на ведущем и не использовать в
archive_command такие утилиты, как pg_compresslog, которые могут удалить записанные пол-
ные страницы из WAL.
Параметры
Описанные далее аргументы командной строки влияют на размещение и формат вывода.
-D каталог
–pgdata=каталог
Целевой каталог для записи данных. pg_basebackup создаст его и родительские, если необхо-
димо. Каталог может быть создан заранее, но должен быть пустым, иначе возникнет ошибка.
1763pg_basebackup
Если резервирование работает в режиме tar, а имя каталога имеет значение - (тире), то tar-
файл будет писаться в stdout.
Этот флаг является обязательным.
-F формат
–format=формат
Устанавливает формат вывода. формат может принимать следующие значения:
p
plain
Записывает выводимые данные в обычные файлы, сохраняя текущую схему размещения ка-
талогов данных и табличных пространств. Если кластер не имеет дополнительных таблич-
ных пространств, то вся база будет помещена в заданный каталог. Иначе основной каталог
хранения данных будет помещён в целевой каталог, а все остальные табличные простран-
ства — в те же абсолютные пути, в которых они находятся на сервере.
Это формат по умолчанию.
t
tar
Записывает в целевой каталог файлы в формате tar. Основной каталог хранения данных бу-
дет писаться в файл base.tar, а табличные пространства — в файлы, именованные в соот-
ветствии с их OID.
Если имя целевого каталога задано как - (тире), то данные будут писаться в стандартный
вывод, что позволяет, например, использовать gzip. Это возможно лишь когда не применя-
ются дополнительные табличные пространства и не используется трансляция WAL.
-r скорость_передачи
–max-rate=скорость_передачи
Максимальная скорость передачи данных с сервера. Значение задаётся в Кб/с. Для установки
значения в мегабайтах, можно использовать суффикс M. Также допустим суффикс k, но он не
принципиален. Допустимые значения лежат в рамках между 32 Кб/с и 1024 Мб/с.
Служит для снижения влияния на производительность сервера со стороны работающего
pg_basebackup.
Параметр всегда влияет на передачу данных каталога хранения. На передачу данных файлов
WAL влияние оказывается лишь при методе сбора fetch.
-R
–write-recovery-conf
Записать минимальный файл recovery.conf в каталог вывода (или базовый архивный файл при
использовании формата tar) для упрощения настройки ведомого сервера. В файл recovery.conf
будут записаны параметры соединения и, если указан, слот репликации, который использует
pg_basebackup, так что впоследствии при потоковой репликации будут использоваться те же
параметры.
-T старый_каталог=новый_каталог
–tablespace-mapping=старый_каталог=новый_каталог
Переместить табличное пространство из старого_каталога в новый_каталог в процессе копиро-
вания. Чтобы перемещение произошло, в параметре старый_каталог должен задаваться в точ-
ности путь табличного пространства, как он определён. (Но не будет ошибкой, если табличного
пространства, на которое указывает старый_каталог, в архиве не окажется.) И старый_каталог,
и новый_каталог должны задаваться абсолютными путями. Если в пути встречается символ =,
1764pg_basebackup
его необходимо экранировать обратной косой чертой. Этот параметр можно добавить несколь-
ко раз для нескольких табличных пространств. См. примеры ниже.
Если табличное пространство перемещается таким способом, символьные ссылки внутри ос-
новного каталога хранения данных также приводятся в соответствие с новым местоположени-
ем. Таким образом, для экземпляра сервера подготавливается новый каталог данных, в кото-
ром все табличные пространства оказываются в новом расположении.
–waldir=каталог_wal
Указывает размещение каталога хранения журнала предзаписи. Задаваемый в параметре ка-
талог_wal путь должен быть абсолютным. Каталог с журналом предзаписи можно задать толь-
ко при создании копии в простом режиме.
-X метод
–wal-method=метод
Включает все необходимые файлы журналов предзаписи (файлы WAL) в резервную копию. В
том числе включаются все журналы предзаписи, сгенерированные в процессе создания резерв-
ной копии. Если только не выбран метод none, главный процесс БД может быть запущен непо-
средственно с восстановленным каталогом, без обращения к дополнительному архиву журна-
лов; таким образом будет получена полностью самодостаточная резервная копия.
Для сбора журналов предзаписи поддерживаются следующие методы:
n
none
Не включать журнал предзаписи в резервную копию.
f
fetch
Файлы журнала предзаписи собираются в конце процесса копирования. Таким образом
необходимо установить достаточно большое значение параметра wal_keep_segments, чтобы
избежать преждевременного удаления файлов журнала. В случае удаления файлов до за-
вершения процесса копирования возникнет ошибка, а копия будет непригодной к исполь-
зованию.
Файлы журнала предзаписи будут записаны в файл base.tar.
s
stream
Передавать журнал предзаписи в процессе создания резервной копии. При этом открывает-
ся второе соединение к серверу, по которому будет передаваться журнал предзаписи, одно-
временно с созданием резервной копии. Таким образом будут использоваться два подклю-
чения из разрешённых параметром max_wal_senders. И если клиент будет успевать полу-
чать журнал предзаписи, ведущему серверу не потребуется хранить дополнительные фай-
лы журнала.
Файлы журнала предзаписи сохраняются в отдельном файле с именем pg_wal.tar (с серве-
ром старее 10 версии файл будет называться pg_xlog.tar).
Это значение по умолчанию.
-z
–gzip
Включает gzip-сжатие выводимого tar-файла с уровнем компрессии по умолчанию. Сжатие под-
держивается только для формата tar, при этом ко всем именам файлов tar добавляется суффикс
.gz.
1765pg_basebackup
-Z уровень
–compress=уровень
Включает gzip-сжатие выводимого tar-файла и задаёт уровень сжатия от 0 (без сжатия) до 9
(максимальное сжатие). Сжатие поддерживается только для формата tar, при этом ко всем
именам файлов tar добавляется суффикс .gz.
Описанные далее аргументы командной строки влияют на генерацию резервной копии и ход вы-
полнения приложения.
-c fast|spread
–checkpoint=fast|spread
Устанавливает режим контрольных точек: fast (быстрый) или spread (протяжённый, по умол-
чанию). Подробнее см. Подраздел 25.3.3.
-C
–create-slot
С данным параметром до начала копирования будет создан слот репликации с именем, задан-
ным в –slot. Если такой слот уже существует, выдаётся ошибка.
-l метка
–label=метка
Устанавливает метку для созданной резервной копии. Если не указана, то по умолчанию будет
использовано значение «pg_basebackup base backup».
-n
–no-clean
По умолчанию, когда программа pg_basebackup прерывается с ошибкой, она удаляет все ка-
талоги, которые она могла создать, прежде чем обнаружила, что не может завершить зада-
ние (например, каталог данных и каталог журнала предзаписи). Данный ключ отключает эту
очистку и тем самым полезен для отладки.
Заметьте, что каталоги табличных пространств не очищаются в любом случае.
-N
–no-sync
По умолчанию pg_basebackup ждёт, пока все файлы не будут надёжно записаны на диск. С
данным параметром pg_basebackup завершается немедленно, то есть выполняется быстрее, но
в случае неожиданного сбоя операционной системы резервная копия может оказаться испор-
ченной. Вообще этот параметр предназначен прежде всего для тестирования, для производ-
ственной среды он не подходит.
-P
–progress
Включает отчёт о прогрессе. Если этот режим включён, то во время создания копии будет пе-
редаваться примерный процент выполнения. Так как данные в базе могут меняться во время
копирования, это значение будет лишь приближённым и может достигать не точно 100%. В
частности, когда в копию включается журнал WAL, конечный размер невозможно предсказать
заранее, и в этом случае ожидаемый конечный размер будет увеличиваться, превысив ориен-
тировочный полный размер без WAL.
Если режим включён, то процесс копирования начнется с перечисления размеров всей базы, а
затем продолжится отправкой непосредственно данных. Это может немного увеличить время
операции, в частности, пройдёт больше времени до начала передачи данных.
-S имя_слота
–slot=имя_слота
Этот параметр может применяться только вместе с -X stream. Он устанавливает использование
заданного слота репликации при потоковой передаче WAL. Если базовая копия предназначена
1766pg_basebackup
для использования на ведомом сервере с потоковой репликацией, затем должен использовать-
ся слот с тем же именем в recovery.conf. Тем самым гарантируется, что сервер не удалит ни-
какие необходимые данные WAL после того, как базовая копия будет получена, и до того, как
начнётся потоковая репликация.
В случае отсутствия ключа -C требуется, чтобы указанный слот репликации уже существовал.
Если этот ключ не указан и сервер поддерживает временные слоты репликации (они появились
в версии 10), для трансляции WAL автоматически используется временный слот репликации.
-v
–verbose
Включает режим подробного вывода. Будет выводится некоторая дополнительная информация
при начале и завершении, а также имена обрабатываемых файлов, если включён отчёт о про-
грессе.
–no-slot
Этот ключ предотвращает создание временного слота репликации во время резервного копи-
рования, даже если это поддерживается сервером.
Временные слоты репликации создаются по умолчанию, если при трансляции журнала имя
слота не задаётся в параметре -S.
Основное предназначение этого ключа в том, чтобы можно было сделать базовую резервную
копию, когда на сервере не хватает свободных слотов репликации. Использование слотов ре-
пликации почти всегда предпочтительнее, так как при этом предотвращается удаление во вре-
мя резервного копирования необходимых файлов WAL с сервера.
–no-verify-checksums
Отключает проверку контрольных сумм, если они включены на сервере, с которого делается
резервная копия.
По умолчанию контрольные суммы проверяются и при выявлении их несоответствия выдаётся
ненулевой код завершения. Однако базовая резервная копия не удаляется в этом случае, как
и с ключом –no-clean.
Далее описаны параметры управления подключением.
-d строка_подключения
–dbname=строка_подключения
Указывает параметры подключения к серверу в формате строки подключения. См. Подраз-
дел 34.1.1 для более подробной информации.
Параметр называется –dbname для согласованности с другими клиентскими приложениями,
но так как pg_basebackup не подключается к какой-либо конкретной базе, это имя в строке
подключения игнорируется.
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета. Значение по умолчанию берётся из переменной
окружения PGHOST, если она установлена. В противном случае выполняется подключение к
Unix-сокету.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной окружения PGPORT,
если она установлена, либо числом, заданным при компиляции.
1767pg_basebackup
-s interval
–status-interval=interval
Указывает интервал в секундах между отправкой пакетов статуса, отправляемых на сервер.
Это позволяет упростить мониторинг прогресса. Чтобы выключить периодическое обновление
статуса, необходимо установить значение в ноль. При этом обновление будет отправляться по
запросу сервера для избежания отсоединения по истечению времени. Значение по умолчанию
составляет 10 секунд.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как pg_basebackup запрашивает пароль автоматически, ес-
ли сервер проверяет подлинность по паролю. Однако, чтобы понять это, pg_basebackup лиш-
ний раз подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту
ненужную попытку подключения.
Другие флаги:
-V
–version
Вывести версию pg_basebackup.
-?
–help
Вывести справку по команде pg_basebackup.
Переменные окружения
Как и большинство других утилит PostgreSQL, приложение также использует переменные окру-
жения, поддерживаемые libpq (см. Раздел 34.14).
Замечания
Прежде чем начнётся копирование, на сервере с копируемой базой необходимо выполнить кон-
трольную точку. И если копирование запускается без ключа –checkpoint=fast, это может занять
некоторое время, в течение которого pg_basebackup не будет проявлять никакой активности.
Резервная копия будет включать в себя все файлы каталога хранения данных и табличных про-
странств, а также конфигурационные файлы и прочие файлы, размещённые в каталоге данных, за
исключением определённых временных файлов, принадлежащих PostgreSQL. Однако копируются
лишь простые файлы и каталоги, кроме них, сохраняются только символические ссылки на таб-
личные пространства. Символические ссылки, указывающие на определённые каталоги, извест-
ные PostgreSQL, копируются как пустые каталоги. Другие символические ссылки и файлы спе-
цустройств игнорируются. За дополнительными подробностями обратитесь к Разделу 53.4.
1768pg_basebackup
Если не указан параметр –tablespace-mapping, табличные пространства в простом формате бу-
дут копироваться в тот же путь, который они имеют на сервере. Поэтому при наличии табличных
пространств создать базовую копию в простом формате на том же сервере не удастся, так как ко-
пия будет направлена в те же каталоги, где располагаются исходные табличные пространства.
Когда применяется режим формата tar, пользователь должен позаботиться о том, чтобы все архи-
вы tar были распакованы до запуска сервера PostgreSQL. Если имеются дополнительные таблич-
ные пространства, архивы tar для них должны быть распакованы в правильные каталоги. В таком
случае для этих табличных пространств сервером будут созданы символические ссылки, согласно
содержимому файла tablespace_map, включённого в архив base.tar.
pg_basebackup совместим с серверами той же или более младших версий, но не ниже 9.1. Однако
режим трансляции WAL (-X stream) поддерживается с версиями сервера не ниже 9.3, а режим
формата tar (–format=tar) текущей версии совместим только с версиями сервера не ниже 9.5.
pg_basebackup сохранит разрешения для группы в форматах plain и tar, если разрешения для
группы установлены в исходном кластере.
Примеры
Создание резервной копии сервера mydbserver и сохранение её в локальном каталоге /usr/local/
pgsql/data:
$ pg_basebackup -h mydbserver -D /usr/local/pgsql/data
Создание резервной копии локального сервера в отдельных сжатых файлах tar для каждого таб-
личного пространства и сохранение их в каталоге backup с индикатором прогресса в процессе вы-
полнения:
$ pg_basebackup -D backup -Ft -z -P
Создание резервной копии локальной базы данных с одним табличным пространством и сжатие
её с помощью bzip2:
$ pg_basebackup -D - -Ft -X fetch | bzip2 &gt; backup.tar.bz2
(Эта команда прервётся с ошибкой, если в базе данных будет несколько табличных пространств.)
Создание резервной копии локальной базы данных с перемещением табличного пространства /
opt/ts в ./backup/ts:
$ pg_basebackup -D backup/data -T /opt/ts=$(pwd)/backup/ts
См. также
pg_dump
1769pgbench
pgbench — запустить тест производительности PostgreSQL
Синтаксис
pgbench -i [параметр…] [имя_бд]
pgbench [параметр…] [имя_бд]
Описание
pgbench — это простая программа для запуска тестов производительности PostgreSQL. Она много-
кратно выполняет одну последовательность команд, возможно в параллельных сеансах базы дан-
ных, а затем вычисляет среднюю скорость транзакций (число транзакций в секунду). По умолча-
нию pgbench тестирует сценарий, примерно соответствующий TPC-B, который состоит из пяти ко-
манд SELECT, UPDATE и INSERT в одной транзакции. Однако вы можете легко протестировать и дру-
гие сценарии, написав собственные скрипты транзакций.
Типичный вывод pgbench выглядит так:
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
В первых шести строках выводятся значения некоторых самых важных параметров. В следующей
строке показывается количество выполненных и запланированных транзакций (это будет произ-
ведение числа клиентов и числа транзакций для одного клиента); эти количества будут равны, ес-
ли только выполнение не завершится досрочно. (В режиме -T выводится только число фактически
выполненных транзакций.) В последних двух строках показывается число транзакций в секунду,
подсчитанное с учётом и без учёта времени установления подключения к серверу.
Для запускаемого по умолчанию теста типа TPC-B требуется предварительно подготовить опреде-
лённые таблицы. Чтобы создать и наполнить эти таблицы, следует запустить pgbench с ключом -
i (инициализировать). (Если вы применяете нестандартный скрипт, это не требуется, но тем не
менее нужно подготовить конфигурацию, нужную вашему тесту.) Запуск инициализации выглядит
так:
pgbench -i [ другие-параметры ] имя_базы
где имя_базы — имя уже существующей базы, в которой будет проводиться тест. (Чтобы указать,
как подключиться к серверу баз данных, вы также можете добавить параметры -h, -p и/или -U.)
Внимание
pgbench
-i создаёт четыре таблицы pgbench_accounts, pgbench_branches,
pgbench_history и pgbench_tellers, предварительно уничтожая существующие табли-
цы с этими именами. Если вы вдруг используете эти имена в своей базе данных, обяза-
тельно переключитесь на другую базу!
С «коэффициентом масштаба», по умолчанию равным 1, эти таблицы изначально содержат такое
количество строк:
1770pgbench
table
    <h1 id="of-rows">of rows</h1>
    <hr />
    <p>pgbench_branches
1
pgbench_tellers
10
pgbench_accounts
100000
pgbench_history
0
Эти числа можно (и в большинстве случаев даже нужно) увеличить, воспользовавшись параметром
-s (коэффициент масштаба). При этом также может быть полезен ключ -F (фактор заполнения).
Подготовив требуемую конфигурацию, можно запустить тест производительности командой без -
i, то есть:
pgbench [ параметры ] имя_базы
Практически во всех случаях, чтобы получить полезные результаты, необходимо передать ка-
кие-либо дополнительные параметры. Наиболее важные параметры: -c (число клиентов), -t (чис-
ло транзакций), -T (длительность) и -f (файл со скриптом). Полный список параметров приведён
ниже.
Параметры
Следующий список разделён на три подраздела: одни параметры используются при инициализа-
ции базы данных, другие при проведении тестирования, а третьи в обоих случаях.
Параметры инициализации
pgbench принимает следующие аргументы командной строки для инициализации:
-i
–initialize
Требуется для вызова режима инициализации.
-I этапы_инициализации
–init-steps=этапы_инициализации
Выполнять только выбранные из всех обычных подготовительных этапов. В параметре этапы_и-
нициализации отдельные символы для каждого этапа выбирают, какие этапы должны выпол-
няться. Все этапы выполняются в определённом порядке. Список этапов по умолчанию: dtgvp.
Полный перечень подготовительных этапов:
d (Drop, удалить)
Удалить все существующие таблицы pgbench.
t (create Tables, создать таблицы)
Создать таблицы, используемые стандартным сценарием pgbench,
pgbench_accounts, pgbench_branches, pgbench_history и pgbench_tellers.
а
именно:
g (Generate data, сгенерировать данные)
Сгенерировать данные и загрузить их в стандартные таблицы, заменив все уже существую-
щие данные.
v (Vacuum, очистка)
Вызывать VACUUM для стандартных таблиц.
p (create Primary keys, создать первичные ключи)
Создать первичные ключи в стандартных таблицах.
1771pgbench
f (create Foreign keys, создать внешние ключи)
Создать ограничения внешних ключей между стандартными таблицами. (Заметьте, что это
действие по умолчанию не выполняется.)
-F фактор_заполнения
–fillfactor=фактор_заполнения
Создать таблицы pgbench_accounts, pgbench_tellers и pgbench_branches с заданным фактором
заполнения. Значение по умолчанию — 100.
-n
–no-vacuum
Не выполнять очистку во время инициализации. (Этот параметр выключает этап инициализа-
ции v, даже если он был указан в -I.)
-q
–quiet
Переключить вывод в немногословный режим, когда выводится только одно сообщение о про-
грессе в 5 секунд. В режиме по умолчанию одно сообщение выводится на каждые 100000 строк,
при этом за секунду обычно выводится довольно много строк (особенно на хорошем оборудо-
вании).
-s коэффициент_масштаба
–scale=коэффициент_масштаба
Умножить число генерируемых строк на заданный коэффициент. Например, с ключом -s 100
в таблицу pgbench_accounts будут записаны 10 000 000 строк. Значение по умолчанию — 1.
При коэффициенте, равном 20 000 или больше, столбцы, содержащие идентификаторы счетов
(столбцы aid), перейдут к большим целым числам (типу bigint), чтобы в них могли уместиться
все возможные значения идентификаторов.
–foreign-keys
Создать ограничения внешних ключей между стандартными таблицами. (Этот ключ добавляет
этап f к последовательности подготовительных этапов, если он отсутствует.)
–index-tablespace=табл_пространство_индексов
Создать индексы в указанном табличном пространстве, а не в пространстве по умолчанию.
–tablespace=табличное_пространство
Создать таблицы в указанном табличном пространстве, а не в пространстве по умолчанию.
–unlogged-tables
Создать все таблицы как нежурналируемые, а не как постоянные таблицы.
Параметры тестирования производительности
pgbench принимает следующие аргументы командной строки для тестирования производительно-
сти:
-b имя_скрипта[@вес]
–builtin=имя_скрипта[@вес]
Добавляет указанный встроенный скрипт в список выполняемых скриптов. Необязательный
целочисленный вес, задаваемый после @, позволяет изменить вероятность выбора скрипта. Ес-
ли он не указан, подразумевается значение 1. В число встроенных скриптов входят tpcb-like,
1772pgbench
simple-update и select-only. Также принимаются однозначные начала их имён. Со специаль-
ным именем list программа выводит список встроенных скриптов и немедленно завершается.
-c клиенты
–client=клиенты
Число имитируемых клиентов, то есть число одновременных сеансов базы данных. Значение
по умолчанию — 1.
-C
–connect
Устанавливать новое подключение для каждой транзакции вместо одного для каждого клиента.
Это полезно для оценивания издержек подключений.
-d
–debug
Выводить отладочные сообщения.
-D имя_переменной=значение
–define=имя_переменной=значение
Определить переменную для пользовательского скрипта (см. ниже). Параметр -D может добав-
ляться неоднократно.
-f имя_файла[@вес]
–file=имя_файла[@вес]
Добавить в список выполняемых скриптов скрипт транзакции из файла имя_файла. Изменить
вероятность выбора этого скрипта позволяет необязательный целочисленный вес, задаваемый
после @. Подробности описаны ниже.
-j потоки
–jobs=потоки
Число рабочих потоков в pgbench. Использовать нескольких потоков может быть полезно на
многопроцессорных компьютерах. Клиенты распределяются по доступным потокам равномер-
но, насколько это возможно. Значение по умолчанию — 1.
-l
–log
Записать информацию о каждой транзакции в файл протокола. Подробности описаны ниже.
-L предел
–latency-limit=предел
Транзакции, продолжающиеся дольше указанного предела (в миллисекундах), подсчитываются
и отмечаются отдельно, как опаздывающие.
В режиме ограничения скорости (–rate=…) транзакции, которые отстают от графика более
чем на заданный предел (в мс) и поэтому никак не могут уложиться в отведённый интервал, не
передаются серверу вовсе. Они подсчитываются и отмечаются отдельно как пропущенные.
-M режим_запросов
–protocol=режим_запросов
Протокол, выбираемый для передачи запросов на сервер:
• simple: использовать протокол простых запросов.
• extended: использовать протокол расширенных запросов.
• prepared: использовать протокол расширенных запросов с подготовленными операторами.
1773pgbench
По умолчанию выбирается протокол простых запросов. (За подробностями обратитесь к Гла-
ве 53.)
-n
–no-vacuum
Не производить очистку таблиц перед запуском теста. Этот параметр необходим, если вы при-
меняете собственный сценарий, не затрагивающий стандартные таблицы pgbench_accounts,
pgbench_branches, pgbench_history и pgbench_tellers.
-N
–skip-some-updates
Запустить встроенный упрощённый скрипт simple-update. Краткий вариант записи -b simple-
update.
-P сек
–progress=сек
Выводить отчёт о прогрессе через заданное число секунд (сек). Выдаваемый отчёт включает
время, прошедшее с момента запуска, скорость (в TPS) с момента предыдущего отчёта, а также
среднее время ожидания транзакций и стандартное отклонение. В режиме ограничения ско-
рости (-R) время ожидания вычисляется относительно назначенного времени запуска транзак-
ции, а не фактического времени её начала, так что оно включает и среднее время отставания
от графика.
-r
–report-latencies
Выводить по завершении тестировании средняя время ожидания операторов (время выполне-
ния с точки зрения клиента) для каждой команды. Подробности описаны ниже.
-R скорость передачи
–rate=скорость передачи
Выполнять транзакции, ориентируясь на заданную скорость, а не максимально быстро (по
умолчанию). Скорость задаётся в транзакциях в секунду. Если заданная скорость превышает
максимально возможную, это ограничение скорости не повлияет на результаты.
Для получения нужной скорости транзакции запускаются со случайными задержками, имею-
щими распределение Пуассона. При этом запланированное время запуска отсчитывается от
начального времени, а не от завершения предыдущей транзакции. Это означает, что если ка-
кие-то транзакции отстанут от изначально рассчитанного времени завершения, всё же возмож-
но, что последующие нагонят график.
В режиме ограничения скорости время ожидания транзакций, выводимое по итогам тестирова-
ния, вычисляется, исходя из запланированного времени запуска, так что в него входит время,
которое очередная транзакция должна была ждать завершения предыдущей транзакции. Это
время называется временем отклонения от графика, и его среднее и максимальное значения
выводятся отдельно. Время ожидания транзакций с момента их фактического запуска, то есть
время, потраченное на выполнение транзакций в базе данных, можно получить, если вычесть
время отклонения от графика из времени ожидания транзакций.
Если ограничение –latency-limit задаётся вместе с –rate, транзакция может заведомо не
вписываться в отведённое ей время, если предыдущая транзакция завершится слишком позд-
но, так как ожидаемое время окончания транзакции отсчитывается от времени запуска по гра-
фику. Такие транзакции не передаются серверу, а пропускаются и подсчитываются отдельно.
Большое значение отклонения от графика свидетельствует о том, что система не успевает вы-
полнять транзакции с заданной скоростью и выбранным числом клиентов и потоков. Когда
среднее время ожидания транзакции превышает запланированный интервал между транзак-
1774pgbench
циями, каждая последующая транзакция будет отставать от графика, и чем дольше будет вы-
полняться тестирование, тем больше будет отставание. Когда это наблюдается, нужно умень-
шить скорость транзакций.
-s коэффициент_масштаба
–scale=коэффициент_масштаба
Показать заданный коэффициент масштаба в выводе pgbench. Для встроенных тестов это не
требуется; корректный коэффициент масштаба будет получен в результате подсчёта строк в
таблице pgbench_branches. Однако при использовании только нестандартных тестов (запуска-
емых с ключом -f) без этого параметра в качестве коэффициента масштаба будет выводиться 1.
-S
–select-only
Запустить встроенный скрипт select-only (только выборка). Краткий вариант записи -b select-
only.
-t транзакции
–transactions=транзакции
Число транзакций, которые будут выполняться каждым клиентом (по умолчанию 10).
-T секунды
–time=секунды
Выполнять тест с ограничением по времени (в секундах), а не по числу транзакций для каждого
клиента. Параметры -t и -T являются взаимоисключающими.
-v
–vacuum-all
Очищать все четыре стандартные таблицы перед запуском теста. Без параметров -n и -v
pgbench будет очищать от старых записей таблицы pgbench_tellers и pgbench_branches, а
также опустошать pgbench_history.
–aggregate-interval=секунды
Длительность интервала агрегации (в секундах). Может использоваться только с ключом -l. С
данным параметром в протокол выводится сводка по интервалам, как описано ниже.
–log-prefix=префикс
Задать префикс имён файлов для файлов протоколов, создаваемых с ключом –log. Префикс
по умолчанию — pgbench_log.
–progress-timestamp
При отображении прогресса (с параметром -P) выводить текущее время (в формате Unix), а не
количество секунд от начала запуска. Время задаётся в секундах с точностью до миллисекунд.
Это помогает сравнивать журналы, записываемые разными средствами.
–random-seed=ЗАТРАВКА
Установить затравку для генератора случайных чисел. Инициализирует генератор случайных
чисел, который затем выдаёт последовательность начальных состояний отдельных генераторов
для каждого потока. ЗАТРАВКА может принимать следующие значения: time (по умолчанию,
затравка базируется на текущем времени), rand (задействовать надёжный генератор случай-
ных чисел или выдать ошибку, если он отсутствует) или беззнаковое десятичное число. Гене-
ратор случайных чисел может вызываться явно из скрипта pgbench (функциями random…)
или неявно (например, для планирования выполнения транзакций с ключом –rate). В случае
установки значения явным образом оно выводится в терминале. Любое значение, допустимое
в качестве ЗАТРАВКИ, можно также задать в переменной окружения PGBENCH_RANDOM_SEED. Что-
1775pgbench
бы заданная затравка применялась во всех возможных случаях использования, задайте этот
параметр первым или установите переменную окружения.
Явное указание определённой затравки позволяет точно воспроизвести выполнение pgbench в
части использования случайных чисел. Так как случайное состояние поддерживается внутри
потока, это означает, что выполнение pgbench при одинаковых запусках повторится в точно-
сти, если один поток используется одним клиентом и отсутствуют внешние зависимости или
зависимости от данных. Со статистической точки зрения точное воспроизведение выполнения
нежелательно, так как это может скрыть вариативность производительности или показать за-
вышенную скорость, например из-за попадания в одни и те же страницы данных. Однако это
может быть очень полезно для отладки, например, для повторения редкого сценария, приво-
дящего к ошибке. Используйте данную возможность обдуманно.
–sampling-rate=скорость передачи
Частота выборки для записи данных в протокол, изменяя которую можно уменьшить объём
протокола. При указании этого параметра в протокол выводится информация только о задан-
ном проценте транзакций. Со значением 1.0 в нём будут отмечаться все транзакции, а с 0.05
только 5%.
Обрабатывая протокол, не забудьте учесть частоту выборки. Например, вычисляя скорость
(TPS), вам нужно будет соответственно умножить содержащиеся в нём числа (то есть, с часто-
той выборки 0.01 вы получите только 1/100 фактической скорости).
Общие параметры
pgbench принимает следующие общие аргументы командной строки:
-h компьютер
–host=компьютер
Адрес сервера баз данных
-p порт
–port=порт
Номер порта сервера баз данных
-U имя_пользователя
–username=имя_пользователя
Имя пользователя для подключения
-V
–version
Вывести версию pgbench и завершиться.
-?
–help
Вывести справку об аргументах командной строки pgbench и завершиться.
Замечания
Каково содержание «транзакции», которую выполняет pgbench?
Программа pgbench выполняет тестовые скрипты, выбирая их случайным образом из заданного
списка. В том числе это встроенные скрипты, заданные аргументами -b, и пользовательские скрип-
ты, заданные аргументами -f. Для каждого скрипта можно задать относительный вес после @,
чтобы скорректировать вероятность его выбора. Вес по умолчанию — 1. Скрипты с весом 0 игно-
рируются.
1776pgbench
Стандартный встроенный скрипт (также вызываемый с ключом -b tpcb-like) выдаёт семь команд
в транзакции со случайно выбранными aid, tid, bid и balance. Его сценарий написан по мотивам
теста производительности TPC-B, но это не собственно TPC-B, потому он называется так.</p>
    <ol>
      <li>BEGIN;</li>
      <li>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</li>
      <li>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</li>
      <li>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</li>
      <li>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</li>
      <li>INSERT
INTO
pgbench_history
(tid,
bid,
(:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
aid,
delta,
mtime)
VALUES</li>
      <li>END;
При выборе встроенного скрипта simple-update (или указании -N) шаги 4 и 5 исключаются из
транзакции. Это позволяет избежать конкуренции при обращении к этим таблицам, но тест ста-
новится ещё менее похожим на TPC-B.
При выборе встроенного теста select-only (или указании -S) выполняется только SELECT.
Пользовательские скрипты
Программа pgbench поддерживает запуск пользовательских сценариев оценки производительно-
сти, позволяя заменять стандартный скрипт транзакции (описанный выше) скриптом, считывае-
мым из файла (с параметром -f). В этом случае «транзакцией» считается одно выполнение дан-
ного скрипта.
Файл скрипта содержит одну или несколько команд SQL, разделённых точкой с запятой. Пустые
строки и строки, начинающиеся с –, игнорируются. В файлах скриптов также могут содержаться
«метакоманды», которые обрабатывает сама программа pgbench, как описано ниже.
Примечание
До версии PostgreSQL 9.6, SQL-команды в файлах скриптов завершались символами
перевода строки, и поэтому они не могли занимать несколько строк. Теперь для разде-
ления последовательных команд SQL требуется добавлять точку с запятой (хотя без
неё можно обойтись в конце SQL-команды, за которой идёт метакоманда). Если вам
нужно создать файл скрипта, работающий и со старыми версиями pgbench, записывай-
те каждую команду SQL в отдельной строке и завершайте её точкой с запятой.
Для файлов скриптов реализован простой механизм подстановки переменных. Имя переменных
должно состоять из букв (буквы могут быть не латинскими), цифр и подчёркиваний. Переменные
можно задать в командной строке параметрами -D, описанными выше, или метакомандами, рас-
сматриваемыми ниже. Помимо переменных, которые можно установить параметрами командной
строки -D, есть несколько автоматически устанавливаемых переменных; они перечислены в Таб-
лице 241. Если значение этих переменных задаётся в параметре -D, оно переопределяет автома-
тическое значение. Когда значение переменной определено, его можно вставить в команду SQL,
написав :имя_переменной. Каждый клиентский сеанс, если их несколько, получает собственный
набор переменных.
Таблица 241. Автоматические переменные
Переменная Описание
client_id уникальное число, идентифицирующее клиент-
ский сеанс (начиная с нуля)
1777pgbench
Переменная Описание
default_seed затравка, используемая в хеш-функциях по
умолчанию
random_seed затравка генератора случайных чисел (в отсут-
ствие переопределения с ключом -D)
scale текущий коэффициент масштаба
Метакоманды в скрипте начинаются с обратной косой черты () и обычно продолжаются до конца
строки, хотя их можно переносить на следующую строку последовательностью символов: обратная
косая, возврат каретки. Аргументы метакоманд разделяются пробелами. Поддерживаемые мета-
команды представлены ниже:
\if выражение
\elif выражение
\else
\endif
Эта группа команд реализует вкладываемые условные блоки, подобные \if выражение в psql.
В качестве условных задаются те же выражения, что и в \set, при этом истинным считается
любое ненулевое значение.
\set имя_переменной выражение
Устанавливает для переменной имя_переменной значение, вычисленное из выражения. Выраже-
ние может содержать константу NULL, логические константы TRUE и FALSE, целочисленные кон-
станты (например, 5432), константы с плавающей точкой (например, 3.14159), ссылки на пере-
менные :имя_переменной, операторы с обычными для SQL приоритетами и ассоциативностью,
вызовы функций, общие условные SQL-выражения CASE, а также скобки.
Функции и большинство операторов возвращают NULL для аргументов NULL.
При проверке условия отличные от нуля числовые значения воспринимаются как TRUE, а чис-
ловые нулевые значения и NULL — как FALSE.
Если в конструкции CASE отсутствует заключительное ELSE, значением по умолчанию считает-
ся NULL.
Примеры:
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
(100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END
\sleep номер [ us | ms | s ]
Приостанавливает выполнение скрипта на заданное число микросекунд (us), миллисекунд (ms)
или секунд (s). Когда единицы не указываются, подразумеваются секунды. Здесь число может
быть целочисленной константой или ссылкой :имя_переменной на переменную с целочислен-
ным значением.
Пример:
\sleep 10 ms
\setshell имя_переменной команда [ аргумент … ]
Присваивает переменной имя_переменной результат команды оболочки команда с указанными
аргументами. Эта команда должна просто выдать целочисленное значение в стандартный вы-
вод.
1778pgbench
Здесь команда и каждый аргумент может быть либо текстовой константой, либо ссылкой на
переменную :имя_переменной. Если вы хотите записать аргумент, начинающийся с двоеточия,
добавьте перед аргументом дополнительное двоеточие.
Пример:
\setshell назначаемая_переменная команда
строковый_аргумент :переменная ::строка_начинающаяся_двоеточием
\shell команда [ аргумент … ]
Действует так же, как и \setshell, но не учитывает результат команды.
Пример:
\shell команда строковый_аргумент :переменная ::строка_начинающаяся_двоеточием
Встроенные операторы
Арифметические, битовые и логические операторы, а также операторы сравнения, перечисленные
в Таблице 242, встроены в pgbench и могут применяться в выражениях в \set.
Таблица 242. Операторы pgbench, в порядке увеличения приоритета
Оператор Описание Пример Результат
OR логическое ИЛИ 5 or 0 TRUE
AND логическое И 3 and 0 FALSE
NOT логическое НЕ not false TRUE
IS [NOT] (NULL|TRUE|
FALSE) проверки значений 1 is null FALSE
ISNULL|NOTNULL проверки на NULL 1 notnull TRUE
= равно 5 = 4 FALSE
&lt;&gt; не равно 5 &lt;&gt; 4 TRUE
!= не равно 5 != 5 FALSE
&lt; меньше 5 &lt; 4 FALSE
&lt;= меньше или равно 5 &lt;= 4 FALSE
        <blockquote>
          <p>больше 5 &gt; 4 TRUE
= больше или равно 5 &gt;= 4 TRUE
| целочисленное битовое 1 | 2
ИЛИ 3</p>
          <h1 id="целочисленное-битовое-1--3">целочисленное битовое 1 # 3</h1>
          <p>исключающее ИЛИ 2
&amp; целочисленное битовое 1 &amp; 3
И 1
~ целочисленное битовое ~ 1
НЕ -2
« целочисленный
вый сдвиг влево бито- 1 « 2 4</p>
          <blockquote>
            <p>целочисленный
бито- 8 » 2
вый сдвиг вправо 2</p>
          </blockquote>
        </blockquote>
      </li>
    </ol>
  </li>
  <li>сложение 5 + 4 9</li>
  <li>вычитание 3 - 2.0 1.0</li>
  <li>умножение 5 * 4 20
1779pgbench
Оператор Описание
Пример
Результат
/ деление (при целочис- 5 / 3
ленном остаток отбра-
сывается) 1
% остаток от деления 3 % 2 1</li>
  <li>смена знака - 2.0 -2.0
Встроенные функции
Функции, перечисленные в Таблице 243, встроены в pgbench и могут применяться в выражениях
в метакоманде \set.
Таблица 243. Функции pgbench
Функция Тип результата Описание abs( a) то же, что и a модуль числа ( abs(-17)
абсолютное значе-
ние) 17
debug( a) то же, что и a выводит a в stderr debug(5432.1)
и возвращает a 5432.1
double( i) double приведение к типу double(5432)
с плавающей точ-
кой 5432.0
exp( x) double экспонента 2.718281828459045
greatest( a
… ] )
Пример
exp(1.0)
[, double, если любой наибольшее зна- greatest(5,
из аргументов (a) чение среди аргу- 3, 2)
— double, а иначе ментов
целое число
4,
5
псевдоним
для hash(10, 5432)
hash_murmur2() -5817877081768721676
integer
hash_fnv1a( a
[, затравка ] ) хеш FNV-1a -7793829335365542153
hash_murmur2( a integer
[, затравка ] ) хеш MurmurHash2 hash_murmur2(
10, 5432) -5817877081768721676
приведение к це- int(5.4 + 3.8)
лочисленному ти-
пу 9
hash( a [,
травка ] )
integer
int( x)
least( a [,
] )
ln( x)
mod( i,
за- integer
Результат
j)
pi()
hash_fnv1a(10,
5432)
… double, если любой наименьшее зна- least(5, 4, 3,
из аргументов (a) чение среди аргу- 2.1)
— double, а иначе ментов
целое число
2.1
double натуральный лога- ln(
1.0
рифм
2.718281828459045)
integer остаток
ния
double значение констан- pi()
ты PI
от
деле- mod(54, 32)
22
3.1415926535
8979323846
pow( x,
power( x, y), double
y) возведение в сте- pow(2.0,
10) , 1024.0
пень
power(2.0, 10)
random( lb, ub) integer случайное целое random(1, 10)
число с равномер-
1780
целое между 1 и 10pgbench
Функция
Тип результата
integer
random_
exponential(
lb,
ub,
пара-
метр)
Описание
Пример
ным распределе-
нием в интервале
[lb, ub] Результат
случайное целое random_
число с экспонен- exponential(1,
циальным распре- 10, 3.0)
делением в интер-
вале [lb, ub] , см.
ниже целое между 1 и 10
random_
gaussian( lb,
ub, параметр) integer целое число с рас- random_
пределением Гаус- gaussian(1,
са в интервале 10, 2.5)
[lb, ub] , см. ни-
же целое между 1 и 10
random_
zipfian( lb,
ub, параметр) integer целое число с рас- random_zipfian(
пределением
1, 10, 1.5)
Ципфа в интерва-
ле [lb, ub] , см.
ниже целое между 1 и 10
sqrt( x) double квадратный
рень 1.414213562
ко- sqrt(2.0)
Функция random выдаёт значения с равномерным распределением, то есть вероятности получения
всех чисел в интервале равны. Функции random_exponential, random_gaussian и random_zipfian
требуют указания дополнительного параметра типа double, определяющего точную форму распре-
деления.
• Для экспоненциального распределения parameter управляет распределением, обрезая быстро
спадающее экспоненциальное распределение в точке parameter, а затем это распределение
проецируется на целые числа между границами. Точнее говоря, с
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
значение i между min и max выдаётся с вероятностью: f(i) - f(i + 1).
Интуиция подсказывает, что чем больше parameter, тем чаще будут выдаваться значения,
близкие к min, и тем реже значения, близкие к max. Чем parameter ближе к 0, тем более плос-
ким (более равномерным) будет распределение. В грубом приближении при таком распреде-
лении наиболее частый 1% значений в диапазоне рядом с min выдаётся parameter% времени.
Значение parameter должно быть строго положительным.
• Для распределения Гаусса по интервалу строится обычное нормальное распределение (клас-
сическая кривая Гаусса в форме колокола) и этот интервал обрезается в точке -parameter
слева и +parameter справа. Вероятнее всего при таком распределении выдаются значения из
середины интервала. Точнее говоря, если PHI(x) — функция распределения нормальной слу-
чайной величины со средним значением mu, равным (max + min) / 2.0, и
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
(2.0 * PHI(parameter) - 1)
тогда значение i между min и max включительно выдаётся с вероятностью: f(i + 0.5) - f(i</li>
  <li>0.5). Интуиция подсказывает, что чем больше parameter, тем чаще будут выдаваться значе-
ния в середине интервала, и тем реже значения у границ min и max. Около 67% значений бу-
дут выдаваться из среднего интервала 1.0 / parameter, то есть плюс/минус 0.5 / parameter
от среднего значения, и 95% из среднего интервала 2.0 / parameter, то есть плюс/минус
1.0 / parameter от среднего значения; например, если parameter равен 4.0, 67% значений
выдаются из средней четверти (1.0 / 4.0) интервала (то есть от 3.0 / 8.0 до 5.0 / 8.0) и 95%
1781pgbench
из средней половины (2.0 / 4.0) интервала (из второй и третьей четвертей). Чтобы преобра-
зование Бокса-Мюллера было быстрым, parameter должен быть не меньше 2.0.
• Функция random_zipfian генерирует приблизительное ограниченное распределение по зако-
ну Ципфа. Для параметра в интервале (0, 1) выбирается приблизительный алгоритм, реализо-
ванный по книге «Quickly Generating Billion-Record Synthetic Databases» («Быстрая генерация
синтетических баз данных с миллиардами записей», Джим Грей и соавторы, SIGMOD 1994).
Для параметра в интервале (1, 1000) выбирается метод отклонения, основанный на материале
книги «Non-Uniform Random Variate Generation» («Генерация неравномерно распределённых
случайных чисел» Люк Деврой, стр. 550-551, Springer 1986). При значении параметра, равном
1.0, распределение не определено. При значениях параметра, превышающих и близких к 1.0,
и при небольшом интервале скорость генерации будет низкой.
параметр определяет, насколько неравномерно распределение. Чем больше параметр, тем ча-
ще выдаются значения, близкие к началу интервала. Чем он ближе к 0, тем более плоским
(равномерным) будет распределение.
Функции хеширования hash, hash_murmur2 и hash_fnv1a принимают на вход аргумент и необяза-
тельный параметр с затравкой. Если значение затравки не задаётся, используется значение пе-
ременной :default_seed, которая инициализируется случайным числом (если не задаётся явно
ключом командной строки -D). Функции хеширования могут использоваться для разброса распре-
деления случайных функций, таких как random_zipfian или random_exponential. Например, сле-
дующий скрипт pgbench эмулирует возможную реальную нагрузку, типичную для социальных ме-
диа- и блог-платформ, где несколько пользователей генерируют львиную долю нагрузки:
\set r random_zipfian(0, 100000000, 1.07)
\set k abs(hash(:r)) % 1000000
В некоторых случаях требуются другие разнообразные распределения, не коррелирующие друг с
другом, и тогда может быть полезно явное указание затравки:
\set k1 abs(hash(:r, :default_seed + 123)) % 1000000
\set k2 abs(hash(:r, :default_seed + 321)) % 1000000
В качестве примера взгляните на встроенное определение транзакции типа TPC-B:
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES
(:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
С таким скриптом транзакция на каждой итерации будет обращаться к разным, случайно выбира-
емым строкам. (Этот пример показывает, почему важно, чтобы в каждом клиентском сеансе были
собственные переменные — в противном случае они не будут независимо обращаться к разным
строкам.)
Протоколирование транзакций
С параметром -l (но без –aggregate-interval), pgbench записывает информацию о каждой тран-
закции в протокол. Этот файл протокола будет называться префикс.nnn, где префикс по умолчанию
— pgbench_log, а nnn — PID процесса pgbench. Префикс можно сменить, воспользовавшись ключом
–log-prefix. Если параметр -j равен 2 или выше, будет создано несколько рабочих потоков, и
каждый будет записывать отдельный протокол. Первый рабочий процесс будет использовать файл
с тем же именем, что и в стандартном случае с одним потоком, а файлы остальных потоков будут
называться префикс.nnn.mmm, где mmm — последовательный номер рабочего процесса, начиная с 1.
1782pgbench
Протокол имеет следующий формат:
код_клиента число_транзакций длительность номер_скрипта время_эпохи время_мкс
[ отставание_от_графика ]
Здесь код_клиента показывает, в сеансе какого клиента запускалась транзакция, число_транзак-
ций отражает, сколько транзакций выполнялось в этом сеансе, длительность — общее время тран-
закций (в микросекундах), номер_скрипта показывает, какой файл скрипта использовался (это по-
лезно при указании нескольких скриптов ключами -f и -b), а время_эпохи/время_мкс — отметка
времени в формате Unix и смещение в микросекундах (из этих чисел можно получить время стан-
дарта ISO 8601 с дробными секундами), показывающие, когда транзакция была завершена. Поле
отставание_от_графика представляет разницу между запланированным временем запуска тран-
закции и фактическим временем запуска (в микросекундах). Оно выводится, только когда приме-
няется параметр –rate. Когда одновременно применяются параметры –rate и –latency-limit,
в поле длительность для пропущенных транзакций будет выводиться skipped.
Фрагмент протокола, полученного при выполнении с одним клиентом:
0
0
0
0
199
200
201
202
2241
2465
2513
2038
0
0
0
0
1175850568
1175850568
1175850569
1175850569
995598
998079
608
2663
Ещё один пример с –rate=100 и –latency-limit=5 (обратите внимание на дополнительный стол-
бец отставание_от_графика):
0
0
0
0
0
0
0
81
82
83
83
83
84
85
4621 0 1412881037 912698 3005
6173 0 1412881037 914578 4304
skipped 0 1412881037 914578 5217
skipped 0 1412881037 914578 5099
4722 0 1412881037 916203 3108
4142 0 1412881037 918023 2333
2465 0 1412881037 919759 740
В этом примере транзакция 82 опоздала, так как её длительность (6.173 мс) превысила ограниче-
ние в 5 мс. Следующие две транзакции были пропущены, так как было слишком поздно их начи-
нать.
Когда проводится длительное тестирование с большим количеством транзакций, файлы протоко-
лов могут быть очень объёмными. Чтобы в них записывалась только случайная выборка транзак-
ций, можно запустить команду с параметром –sampling-rate.
Протоколирование с агрегированием
С параметром –aggregate-interval протоколы имеют несколько иной формат:
начало_интервала число_транзакций сумма_длительности сумма_длительности_2 мин_длительность м
[сумма_задержки сумма_задержки_2 мин_задержка макс_задержка [ пропущено_транзакций ] ]
Здесь начало_интервала — начальное время интервала (в формате времени UNIX), число_тран-
закций — количество транзакций в данном интервале, сумма_длительности — суммарная длитель-
ность транзакций, сумма_длительности_2 — сумма квадратов длительностей транзакций в интер-
вале, мин_длительность — минимальная длительность в интервале, а макс_задержка — максималь-
ная. Следующие поля, сумма_задержки, сумма_задержки_2, мин_задержка и макс_задержка, присут-
ствуют, только если применяется параметр –rate. Они отражают время, на которое задержалась
каждая транзакция, ожидая завершения предыдущей, то есть разницу между временем фактиче-
ского запуска и запланированным временем. Самое последнее поле, пропущено_транзакций, тоже
присутствует, только если применяется ключ –latency-limit. В нём выводится число транзак-
ций, пропущенных из-за того, что их запуск задержался слишком надолго. Каждая транзакция
учитывается в том интервале, в котором она была зафиксирована.
Пример вывода:
1783pgbench
1345828501
1345828503
1345828505
1345828507
1345828509
5601
7884
7208
7685
7073
1542744
1979812
1979422
1980268
1979779
483552416
565806736
567277552
569784714
573489941
61 2573
60 1479
59 1391
60 1398
236 1411
Заметьте, что простой протокол (без агрегирования) показывает, какой скрипт использовался для
каждой транзакции, в отличие от протокола с агрегированием. Таким образом, если вам нужны
подобные сведения, но в разрезе скриптов, вам придётся агрегировать данные самостоятельно.
Время ожидания по операторам
С параметром -r программа pgbench учитывает время выполнения каждого оператора каждым
клиентом. Затем по завершении тестирования она выводит среднее по всем значениям как время
ожидания каждого оператора.
Со стандартным скриптом вывод будет примерно таким:
starting vacuum…end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
0.002 \set aid random(1, 100000 * :scale)
0.005 \set bid random(1, 1 * :scale)
0.002 \set tid random(1, 10 * :scale)
0.001 \set delta random(-5000, 5000)
0.326 BEGIN;
0.603 UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid
= :aid;
0.454 SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
5.528 UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid
= :tid;
7.335 UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid
= :bid;
0.371 INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES
(:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
1.212 END;
Если задействуется несколько файлов скриптов, средние значения выводятся отдельно для каж-
дого файла.
Учтите, что сбор дополнительных временных показателей влечёт некоторые издержки и приво-
дит к снижению средней скорости и, как результат, падению TPS. На сколько именно снизится
скорость, во многом зависит от платформы и оборудования. Хороший способ оценить, каковы эти
издержки — сравнить средние значения TPS, получаемые с подсчётом времени операторов и без
такого подсчёта.
Полезные советы
Используя pgbench, можно без особого труда получить абсолютно бессмысленные числа. После-
дуйте приведённым советам, чтобы получить полезные результаты.
1784pgbench
Во-первых, никогда не доверяйте тестам, которые выполняются всего несколько секунд. Восполь-
зуйтесь параметром -t и -T и установите время выполнения не меньше нескольких минут, чтобы
избавиться от шума в средних значениях. В некоторых случаях для получения воспроизводимых
результатов тестирование должно продолжаться несколько часов. Чтобы понять, были ли получе-
ны воспроизводимые значения, имеет смысл запустить тестирование несколько раз.
Для стандартного сценария по типу TPC-B начальный коэффициент масштаба (-s) должен быть не
меньше числа клиентов, с каким вы намерены проводить тестирование (-c); в противном случае вы,
по большому счёту, будете замерять время конкурентных изменений. Таблица pgbench_branches
содержит всего -s строк, а каждая транзакция хочет изменить одну из них, так что если значение
-c превышает -s, это несомненно приведёт к тому, что многие транзакции будут блокироваться
другими.
Стандартный сценарий тестирования также довольно сильно зависит от того, сколько времени про-
шло с момента инициализации таблиц: накопление неактуальных строк и «мёртвого» пространства
в таблицах влияет на результаты. Чтобы правильно оценить результаты, необходимо учитывать,
сколько всего изменений было произведено и когда выполнялась очистка. Если же включена ав-
тоочистка, это может быть чревато непредсказуемыми изменениями оценок производительности.
Полезность результатов pgbench также может ограничиваться тем, что тестирование с большим
числом клиентских сеансов само по себе нагружает систему. Этого можно избежать, запуская
pgbench на другом компьютере, не на сервере баз данных, хотя при этом большое значение име-
ет скорость сети. Иногда, оценивая производительность одного сервера, полезно запускать даже
несколько экземпляров pgbench параллельно, на отдельных клиентских компьютерах.
Безопасность
Если к базе данных, которая не приведена в соответствие шаблону безопасного использования
схем, имеют доступ недоверенные пользователи, не запускайте pgbench в этой базе. Программа
pgbench использует неполные имена и не настраивает для себя путь поиска.
1785pg_config
pg_config — вывести информацию об установленной версии PostgreSQL
Синтаксис
pg_config [параметр…]
Описание
Утилита pg_config выводит параметры конфигурации текущей установленной версии PostgreSQL.
Это помогает, например, найти заголовочные файлы и библиотеки, требующиеся программным
средствам, которые хотят взаимодействовать с PostgreSQL.
Параметры
При использовании pg_config можно передать следующие параметры:
–bindir
Вывести расположение исполняемых файлов. Можно использовать, например, для поиска ути-
литы psql. Обычно там же находится и сама утилита pg_config.
–docdir
Вывести расположение файлов документации.
–htmldir
Вывести расположение файлов документации в формате HTML.
–includedir
Вывести расположение заголовочных C-файлов клиентских интерфейсов.
–pkgincludedir
Вывести расположение других заголовочных C-файлов.
–includedir-server
Вывести расположение заголовочных C-файлов для программирования серверной части.
–libdir
Вывести расположение библиотек объектного кода.
–pkglibdir
Вывести расположение динамически подгружаемых модулей, либо путь, где сервер должен их
искать. По этому пути также могут размещаться и другие архитектурно-зависимые файлы.
–localedir
Вывести расположение файлов поддержки локалей. Если поддержка локалей не была сконфи-
гурирована на этапе сборки PostgreSQL, будет выведена пустая строка.
–mandir
Вывести расположение страниц руководства man.
–sharedir
Вывести расположение архитектурно-независимых вспомогательных файлов.
1786pg_config
–sysconfdir
Вывести расположение системных конфигурационных файлов.
–pgxs
Вывести расположение файлов сборки расширений.
–configure
Вывести список параметров configure, использованных при сборке PostgreSQL. Это может при-
годиться, чтобы при последующей сборке сделать идентичную конфигурацию. Или для того,
чтобы найти с какими параметрами был собран используемый бинарный пакет. (Стоит отме-
тить, что бинарные пакеты нередко содержат патчи, специфичные для дистрибутивов.) См.
примеры ниже.
–cc
Вывести использованное при сборке PostgreSQL значение переменной CC. Оно отражает, какой
C-компилятор применялся.
–cppflags
Вывести использованное при сборке PostgreSQL значение переменной CPPFLAGS. Оно отражает
флаги C-компилятора, применённые для препроцессора. Обычно это флаги -I.
–cflags
Вывести использованное при сборке PostgreSQL значение переменной CFLAGS. Оно отражает
флаги C-компилятора, применённые при сборке.
–cflags_sl
Вывести использованное при сборке PostgreSQL значение переменной CFLAGS_SL. Оно отража-
ет дополнительные флаги C-компилятора для сборки разделяемых библиотек.
–ldflags
Вывести использованное при сборке PostgreSQL значение переменной LDFLAGS. Оно отражает
флаги компоновщика.
–ldflags_ex
Вывести использованное при сборке PostgreSQL значение переменной LDFLAGS_EX. Оно отра-
жает флаги компоновщика, использованные при сборке лишь исполняемых файлов.
–ldflags_sl
Вывести использованное при сборке PostgreSQL значение переменной LDFLAGS_SL. Оно отра-
жает флаги компоновщика, использованные при сборке лишь разделяемых библиотек.
–libs
Вывести использованное при сборке PostgreSQL значение переменной LIBS. Обычно оно отра-
жает флаги подключения внешних библиотек к PostgreSQL, переданные с ключом -l.
–version
Вывести версию PostgreSQL.
-?
–help
Вывести справку по команде pg_config.
1787pg_config
Если одновременно передано несколько параметров, то выводимая информация будет следовать
согласно их порядку. Если параметры не переданы, то будет выведена вся информация с подпися-
ми, к чему она относится.
Замечания
Параметры –docdir, –pkgincludedir, –localedir, –mandir, –sharedir, –sysconfdir, –cc, –
cppflags, –cflags, –cflags_sl, –ldflags, –ldflags_sl и –libs доступны, начиная с версии
PostgreSQL 8.1. Параметр –htmldir добавлен в PostgreSQL 8.4. Параметр –ldflags_ex добавлен
в PostgreSQL 9.0.
Пример
Чтобы воспроизвести конфигурацию сборки текущей инсталляции PostgreSQL, можно выполнить
команду:
eval ./configure <code class="highlighter-rouge">pg_config --configure</code>
Вывод pg_config –configure содержит символы экранирования, поэтому значения аргументов,
содержащие пробелы, представлены корректно. Таким образом, для получения корректного ре-
зультата необходимо применить eval.
1788pg_dump
pg_dump — выгрузить базу данных PostgreSQL в формате скрипта в файл или архив
Синтаксис
pg_dump [параметр-подключения…] [параметр…] [имя_бд]
Описание
pg_dump — это программа для создания резервных копий базы данных PostgreSQL. Она создаёт
целостные копии, даже если база параллельно используется. Программа pg_dump не препятствует
доступу других пользователей к базе данных (ни для чтения, ни для записи).
Программа pg_dump выгружает только одну базу данных. Чтобы выгрузить весь кластер или со-
хранить глобальные объекты, относящиеся ко всем базам в кластере, например, роли и табличные
пространства, воспользуйтесь программой pg_dumpall.
Выгружаемые данные могут быть сохранены в виде скрипта, либо в одном из архивных форматов.
Скрипты представляют собой текстовые файлы, содержащие SQL-команды, необходимые для вос-
создания базы данных до состояния на момент создания скрипта. Для восстановления из скрипта
его содержимое можно передать psql. Скрипты можно использовать для восстановления базы на
других машинах, в том числе с иной архитектурой, а с некоторыми коррективами даже в других
СУБД.
Для восстановления из архивных форматов файлов используется утилита pg_restore. Эти форматы
позволяют указывать pg_restore какие объекты базы данных восстановить, а также позволяют из-
менить порядок следования восстанавливаемых объектов. Архивные форматы файлов спроектиро-
ваны так, чтобы их можно были переносить на другие платформы с другой архитектурой.
Применение архивных форматов в сочетании утилит pg_restore и pg_dump позволяет организо-
вывать эффективный механизм архивации и переноса данных. pg_dump можно использовать для
резервирования всей базы данных, а затем при применении pg_restore выбрать нужные объекты
для восстановления. Наиболее гибкие форматы резервных файлов это «custom» (-Fc) и «directory»
(-Fd). Они позволяют выбрать и изменить порядок объектов, поддерживают восстановление в
несколько потоков, а также сжимаются по умолчанию. При этом формат «directory» единствен-
ный, позволяющий выгружать данные в несколько потоков.
Во время работы pg_dump следует обращать внимание на предупреждения, которые печатаются в
стандартный поток ошибок, особенно ввиду рассмотренных далее ограничений.
Параметры
Параметры командной строки для управления содержимым и форматом вывода.
имя_бд
Указывает имя базы данных, из которой будут выгружаться данные. Если имя не задано, то ис-
пользуется значение переменной окружения PGDATABASE. Если и переменная не задана, то в ка-
честве имени базы будет взято имя пользователя, под которым осуществляется подключение.
-a
–data-only
Выводить только данные, но не схемы объектов (DDL). Будут копироваться данные таблиц, боль-
шие объекты, значения последовательностей.
Флаг похож на –section=data, но по историческим причинам не равнозначен ему.
1789pg_dump
-b
–blobs
Включить большие объекты в выгрузку. Это поведение по умолчанию при отсутствии ключей
–schema, –table или –schema-only. Таким образом, ключ -b полезен, лишь когда нужно до-
бавить большие объекты при выгрузке только избранной схемы или таблицы. Заметьте, что
большие объекты относятся к данным, и поэтому будут выгружаться, когда используется ключ
–data-only, но не ключ –schema-only.
-B
–no-blobs
Исключить из выгрузки большие объекты.
Когда задаётся и -b, и -B, большие объекты при выгрузке данных будут выводиться (см. описа-
ние ключа -b).
-c
–clean
Включить в выходной файл команды удаления (DROP) объектов базы данных перед командами
создания (CREATE) этих объектов. Если дополнительно не указать флаг –if-exists, то при
восстановлении в базу данных, где некоторые объекты отсутствуют, попытка удаления несуще-
ствующего объекта будет приводить к ошибке, которую можно игнорировать.
Параметр полезен только для вывода файлов в формате plain. Для архивных форматов, этот
параметр можно указывать при вызове pg_restore.
-C
–create
Сформировать в начале вывода команду для создания базы данных и затем подключения к ней.
В этом случае не важно, какая база указана в параметрах подключения перед выполнением
скрипта. Также, если указан ключ –clean, то скрипт сначала удалит, а затем пересоздаст базу
данных перед подключением к ней.
С ключом –create в выходной файл также включается комментарий к базе данных (если он
задан) и все назначения переменных конфигурации, связанные с базой данных, то есть все
команды ALTER DATABASE … SET … и ALTER ROLE … IN DATABASE … SET …, ссылающиеся
на эту базу данных. Также выгружаются права доступа к самой базе данных, если не добавлен
ключ –no-acl.
Параметр полезен только для вывода файлов в формате plain. Для архивных форматов, этот
параметр можно указывать при вызове pg_restore.
-E кодировка
–encoding=кодировка
Создать копию в заданной кодировке. По умолчанию копия создаётся в кодировке, используе-
мой базой данных. Другой способ достичь того же результата — задать желаемую кодировку
в переменной окружения PGCLIENTENCODING.
-f файл
–file=файл
Отправить вывод в указанный файл. Параметр можно не указывать, если используется формат
с выводом в файл. В этом случае будет использован стандартный вывод. Однако для формата с
выводом в каталог параметр является обязательным и должен указывать на путь к каталогу. В
таком случае каталог будет создан командой pg_dump и не должен существовать заранее.
-F format
–format=format
Указывает формат вывода копии. format может принимать следующие значения:
1790pg_dump
p
plain
Сформировать текстовый SQL-скрипт. Это поведение по умолчанию.
c
custom
Вывести копию в архивном формате, пригодном для дальнейшего использования утилитой
pg_restore. Наравне с directory является наиболее гибким форматом, позволяющим вруч-
ную выбирать и сортировать восстанавливаемые объекты. Вывод в этом формате по умол-
чанию сжимается.
d
directory
Выгрузить в формате каталога. Этот формат пригоден для дальнейшего использования ути-
литой pg_restore. При этом будет создан каталог, в котором для каждой таблицы и большого
объекта будут созданы отдельные файлы, а также файл оглавления в машинно-читаемом
формате, понятном для pg_restore. С полученной резервной копией можно работать штат-
ными средствами Unix, например, несжатую копию можно сжать посредством gzip. Этот
формат по умолчанию сжимается, а также поддерживает работу в несколько потоков.
t
tar
Вывести копию в формате tar, для дальнейшего использования утилитой pg_restore. Этот
формат совместим с форматом вывода в каталог: если архив распаковать, получится кор-
ректная копия в формате каталога. Однако формат tar не поддерживает сжатие. Также,
применяя формат tar, при восстановлении нельзя изменить относительный порядок элемен-
тов данных.
-j njobs
–jobs=njobs
Запустить выгрузку в несколько потоков, которые смогут параллельно обрабатывать njobs таб-
лиц. Это уменьшает время работы, но увеличивает нагрузку на сервер. Этот параметр можно
использовать только с форматом вывода directory, так как это единственный формат, позво-
ляющий нескольким процессам одновременно записывать данные.
pg_dump откроет njobs + 1 соединений с базой данных. Таким образом необходимо обеспечить
достаточное значение параметра max_connections.
Если во время выгрузки в несколько потоков, параллельно работающие сессии будут запраши-
вать эксклюзивные блокировки на объекты базы данных, то pg_dump может завершиться ава-
рийно. Дело в том, что головной процесс pg_dump вначале запрашивает разделяемые блоки-
ровки на объекты, которые позже будут выгружать рабочие процессы. Это делается для того,
чтобы никто не смог удалить объекты на время работы pg_dump. Если же другая сессия запро-
сит эксклюзивную блокировку на объект, то запрос на блокировку будет поставлен в очередь,
до тех пор пока разделяемая блокировка головного процесса pg_dump не будет снята. В после-
дующем, любая попытка доступа к этому объекту будет вставать в очередь, вслед за эксклюзив-
ной блокировкой. В том числе в очередь попадет и рабочий процесс pg_dump. Если не принять
меры предосторожности, то получим классическую взаимоблокировку. Для предупреждения
подобных конфликтов, рабочий процесс pg_dump ещё раз запрашивает разделяемую блокиров-
ку на объект с указанием NOWAIT. И если он не смог получить блокировку, значит кто-то ещё
запросил эксклюзивную блокировку объекта. А это значит, что нет возможности продолжить
выгрузку, поэтому pg_dump прерывает дальнейшую работу.
Для получения целостной резервной копии серверу баз данных необходимо поддерживать
функциональность синхронизированных снимков, которая была введена в версии PostgreSQL
9.2 для ведущих серверов и в 10 для ведомых. Это позволяет разным клиентам работать с одной
и той же версией данных, несмотря на использование разных подключений. pg_dump -j исполь-
1791pg_dump
зует множественные подключения. Первое подключение осуществляется головным процессом,
а последующие — рабочими процессами. Без функциональности синхронизируемых снимков
нет гарантии того, что каждое подключение увидит одни и те же данные, что может привести
к несогласованности данных резервной копии.
Если необходимо выполнить выгрузку в несколько потоков на сервере версии до 9.2, необходи-
мо быть уверенным, что база данных не будет изменяться с момента подключения головного
процесса и до момента, когда последний рабочий процесс подключится к базе данных. Для
этого, проще всего перед запуском pg_dump остановить все процессы, модифицирующие дан-
ные (DML и DDL). Также, при запуске pg_dump -j на сервере PostgreSQL до версии 9.2 нужно
указывать параметр –no-synchronized-snapshots.
-n схема
–schema=схема
Выгрузить только схемы, соответствующие шаблону схема; вместе с этими схемами будут вы-
гружены и все содержащиеся в них объекты. Когда этот параметр отсутствует, выгружаются
все несистемные схемы в целевой базе данных. Чтобы выгрузить несколько схем, ключ -n мож-
но указать несколько раз. Кроме того, параметр схема интерпретируется как шаблон по тем
же правилам, что и с командами psql \d (см. Подраздел «Шаблоны поиска»), так что несколько
схем можно выбрать и шаблоном со знаками подстановки. Используя знаки подстановки, при
необходимости заключайте шаблон в кавычки, чтобы эти знаки не разворачивала оболочка си-
стемы; см. Раздел «Примеры».
Примечание
При использовании -n, pg_dump не выгружает объекты других схем, от которых вы-
гружаемая схема может зависеть. Таким образом не гарантируется, что выгружен-
ная схема будет успешно восстановлена на чистой базе данных.
Примечание
Не принадлежащие схемам объекты (например, большие бинарные объекты), не
выгружаются с параметром -n. Однако можно указать –blobs, чтобы они попали
в выгрузку.
-N схема
–exclude-schema=схема
Не выгружать схемы, соответствующие шаблону схема. Шаблон интерпретируется по тем же
правилам, что и для параметра -n. Параметр -N можно использовать в команде несколько раз
для исключения схем, соответствующих нескольким шаблонам.
При одновременном использовании параметров -n и -N будут выгружаться схемы, соответству-
ющие шаблону параметра -n и не противоречащие шаблону параметра -N.
-o
–oids
Выгружать идентификаторы объектов (OIDs) вместе с данными таблиц. Используйте этот па-
раметр, если в приложении есть ссылки на OID, например во внешних ключах. В противном
случае, этот параметр лучше не использовать.
-O
–no-owner
Не формировать команды, устанавливающие владельца объектов базы данных. По умолчанию
pg_dump генерирует команды ALTER OWNER или SET SESSION AUTHORIZATION для назначения
1792pg_dump
владельцев объектов базы. Эти команды завершатся неудачно, если скрипт будет запущен не
суперпользователем или не владельцем объектов. Чтобы создать скрипт, который можно вы-
полнить при восстановлении от лица произвольного пользователя и назначить его в качестве
владельца объектов восстанавливаемой базы, необходимо указать флаг -O.
Параметр полезен только для вывода файлов в формате plain. Для архивных форматов, этот
параметр можно указывать при вызове pg_restore.
-R
–no-reconnect
Параметр является устаревшим, но в целях совместимости ещё работает.
-s
–schema-only
Выгружать только определения объектов (схемы), без данных.
Действие параметра противоположно действию –data-only. Это похоже на указание –
section=pre-data –section=post-data, но по историческим причинам не равнозначно ему.
(Не путайте этот параметр с –schema, где слово «схема» используется в другом значении.)
Чтобы не выгружать данные отдельных таблиц, используйте параметр –exclude-table-data.
-S имя_пользователя
–superuser=имя_пользователя
Указать суперпользователя, который будет использоваться для отключения триггеров. Пара-
метр имеет значение только вместе с –disable-triggers. Обычно его лучше не использовать,
а запускать полученный скрипт от имени суперпользователя.
-t таблица
–table=таблица
Выгрузить только таблицы, соответствующие шаблону таблица. В этом контексте под «табли-
цей» подразумеваются также представления, материализованные представления, последова-
тельности и сторонние таблицы. Чтобы выбрать несколько таблиц, ключ -t можно указать
несколько раз. Кроме того, параметр таблица интерпретируется как шаблон по тем же прави-
лам, что и с командами psql \d (см. Подраздел «Шаблоны поиска»), так что несколько таблиц
можно выбрать и с шаблоном со знаками подстановки. Используя знаки подстановки, при необ-
ходимости заключайте шаблон в кавычки, чтобы эти знаки не разворачивала оболочка систе-
мы; см. Раздел «Примеры».
Параметры -n и -N не оказывают влияния на параметр -t, так как отобранные с его помощью
таблицы всё равно будут выгружены.
Примечание
При использовании -t, pg_dump не выгружает прочие объекты, от которых выгру-
жаемые таблицы могут зависеть. Таким образом не гарантируется, что выгружен-
ные таблицы будут успешно восстановлены на чистой базе данных.
Примечание
Поведение параметра -t для версий ниже чем PostgreSQL 8.2 отличается от более
поздних. Прежде, указание -t таблица включало все таблицы, соответствующие
шаблону таблица, а сейчас это приведёт к выгрузке только тех таблиц, которые бу-
дут обнаружены в текущем пути поиска. Для получения старого поведения можно
1793pg_dump
использовать конструкцию вида -t ‘<em>.таблица’. Также, чтобы указать таблицу из
конкретной схемы, сейчас лучше использовать -t схема.таблица, вместо старой
конструкции -n схема -t таблица.
-T таблица
–exclude-table=таблица
Не выгружать таблицы, соответствующие шаблону таблица. Шаблон интерпретируется по тем
же правилам, что и для параметра -t. Параметр -T можно использовать в команде несколько
раз для исключения таблиц, соответствующих нескольким шаблонам.
При одновременном использовании параметров -t и -T будут выгружаться таблицы, соответ-
ствующие шаблону параметра -t и не противоречащие шаблону параметра -T.
-v
–verbose
Включить подробный режим. pg_dump будет выводить в стандартный поток ошибок подробные
комментарии к объектам, включая время начала и окончания выгрузки, а также сообщения о
прогрессе выполнения.
-V
–version
Вывести версию pg_dump.
-x
–no-privileges
–no-acl
Не выгружать права доступа (команды GRANT/REVOKE).
-Z 0..9
–compress=0..9
Установить уровень сжатия данных. Ноль означает, что сжатие выключено. Для архивного фор-
мата custom будут сжиматься файлы отдельных таблиц. По умолчанию применяется умерен-
ный уровень сжатия. Если указать отличный от нулевого уровень сжатия для формата plain,
то сжиматься будет весь выходной файл, как это было бы при передаче файла команде gzip.
Но по умолчанию для plain сжатие данных отключено. Формат tar в настоящий момент не
поддерживает сжатие.
–binary-upgrade
Этот параметр предназначен для утилит обновления сервера. Использование для иных целей
не рекомендуется и не поддерживается. Поведение параметра может быть изменено в после-
дующих версиях без предварительного уведомления.
–column-inserts
–attribute-inserts
Выгружать данные таблиц в виде команд INSERT с явным указанием столбцов (INSERT INTO
table (column, …) VALUES …). В этом случае, скорость восстановления значительно сни-
зится. Полезно в тех случаях, когда загружать данные нужно не в PostgreSQL. Также, посколь-
ку для каждой строки генерируется отдельная команда, сбой при последующей загрузке при-
ведёт к потере конкретной строки, а не всей таблицы.
–disable-dollar-quoting
Этот параметр запрещает заключать в доллары тело функций, что оставляет возможность толь-
ко заключать их в кавычки, применяя стандартный синтаксис SQL.
1794pg_dump
–disable-triggers
Используется при выгрузке одних данных. Указывает pg_dump включать в вывод команды для
временного выключения триггеров при восстановлении в целевой базе данных. Применяется в
ситуациях, когда существуют проверки ссылочной целостности или другие триггеры, которые
необходимо выключить на время восстановления.
В настоящее время команды, генерируемые с параметром –disable-triggers, должны испол-
няться от имени суперпользователя. Таким образом, необходимо также передавать флаг -S,
либо при восстановлении выполнять скрипт от имени суперпользователя.
Параметр полезен только для вывода файлов в формате plain. Для архивных форматов, этот
параметр можно указывать при вызове pg_restore.
–enable-row-security
Этот параметр имеет смысл только при выгрузке содержимого таблицы, для которой включе-
на защита строк. По умолчанию pg_dump устанавливает для row_security значение off, чтобы
убедиться, что выгружаются все данные из таблицы. Если пользователь не имеет достаточных
прав для обхода защиты строк, выдаётся ошибка. Этот параметр указывает pg_dump включить
row_security, что позволит пользователю выгрузить часть содержимого таблицы, к которой он
имеет доступ.
Заметьте, что в настоящее время для использования этого параметра обычно желательно, что-
бы данные были выгружены в формате INSERT, так как команда COPY FROM в процессе восста-
новления не поддерживает защиту строк.
–exclude-table-data=таблица
Не выгружать содержимое таблиц, соответствующих шаблону таблица. Шаблон таблицы ин-
терпретируется по тем же правилам, что и для параметра -t. Параметр –exclude-table-
data можно использовать в команде несколько раз для исключения таблиц, соответствующих
нескольким шаблонам. Полезно, когда нужно получить определение таблицы, без содержимо-
го.
Чтобы не выгружать содержимое всех таблиц базы, используйте параметр –schema-only.
–if-exists
При очистке целевой базы использовать условные команды (добавлять предложение IF
EXISTS). Применяется только с параметром –clean.
–inserts
Выгружать данные таблиц в виде команд INSERT вместо COPY. В этом случае, скорость восста-
новления значительно снизится. Полезно в тех случаях, когда загружать данные нужно не в
PostgreSQL. Также, поскольку для каждой строки генерируется отдельная команда, сбой при
последующей загрузке приведёт к потере конкретной строки, а не всей таблицы. Обратите вни-
мание, что последующая загрузка может завершиться неудачно, если у таблицы изменён по-
рядок столбцов. Можно использовать параметр –column-inserts, для которого порядок столб-
цов не важен, но он работает ещё медленнее.
–load-via-partition-root
При выгрузке данных для секции таблицы выводить команды COPY или INSERT, ссылающиеся на
корневую таблицу в иерархии секционирования, а не на эту секцию. В результате при загруз-
ке данных подходящая секция будет выбираться заново для каждой строки. Это может быть
полезно при перезагрузке данных, когда на целевом сервере строки не всегда попадают в те
же секции, в которых они находились на исходном. Это возможно, например, когда столбец
разбиения имеет текстовый тип и в двух системах по-разному определено правило сортировки,
по которому упорядочивается этот столбец.
1795pg_dump
При восстановлении из архива с этим параметром лучше не использовать распараллеливание,
так как pg_restore не будет иметь представления, в какие секции попадут данные. Это может
повлечь снижение производительности из-за конфликтов блокировки между параллельными
заданиями или даже сбой из-за того, что ограничения внешнего ключа вступят в силу прежде,
чем будут загружены все нужные данные.
–lock-wait-timeout=время_ожидания
Не ждать бесконечно получения разделяемых блокировок таблиц в начале процедуры вы-
грузки. Вместо этого выдать ошибку, если не удастся заблокировать таблицы за указанное
время_ожидания. Это время можно задать в любом из форматов, принимаемых командой SET
statement_timeout. (Допустимые форматы зависят от версии сервера, выгружающего данные,
но количество миллисекунд в виде целого числа принимают все версии.)
–no-comments
Не выгружать комментарии.
–no-publications
Не выгружать публикации.
–no-security-labels
Не выгружать метки безопасности.
–no-subscriptions
Не выгружать подписки.
–no-sync
По умолчанию pg_dump ждёт, пока все файлы не будут надёжно записаны на диск. С данным па-
раметром pg_dump завершается немедленно, то есть выполняется быстрее, но в случае неожи-
данного сбоя операционной системы выгруженные данные могут оказаться испорченными. Во-
обще этот параметр предназначен прежде всего для тестирования, для производственной сре-
ды он не подходит.
–no-synchronized-snapshots
Позволяет запускать pg_dump -j на серверах с версией ниже чем 9.2. Подробнее в описании
параметра -j.
–no-tablespaces
Не формировать команды для указания табличных пространств. Все объекты будут создаваться
в табличном пространстве по умолчанию.
Параметр полезен только для вывода файлов в формате plain. Для архивных форматов, этот
параметр можно указывать при вызове pg_restore.
–no-unlogged-table-data
Не выгружать данные нежурналируемых таблиц. Параметр не влияет на выгрузку определения
таблиц, он только подавляет вывод содержимого таблиц. При запуске на резервном сервере,
содержимое нежурналируемых таблиц никогда не выгружается.
–quote-all-identifiers
Принудительно экранировать все идентификаторы. Этот параметр рекомендуется при выгруз-
ке базы, когда основная версия сервера PostgreSQL, с которого выгружается база, отличает-
ся от версии pg_dump, или когда выгруженная копия предназначена для загрузки на серве-
ре с другой основной версией. По умолчанию pg_dump экранирует только те идентификато-
ры, которые являются зарезервированными словами в собственной основной версии. Иногда
1796pg_dump
это приводит к проблемам совместимости с серверами других версий, в которых множество
зарезервированных слов может быть несколько другим. Применение параметра –quote-all-
identifiers предотвращает подобные проблемы, ценой ухудшения читаемости скрипта с вы-
груженными данными.
–section=имя секции
Выгружать лишь указанную секцию. Имя секции может принимать значения pre-data, data
или post-data. Для выгрузки нескольких секций, параметр можно использовать несколько раз
в одной команде. По умолчанию резервируются все секции.
Секция data содержит непосредственно данные таблиц, больших объектов и значения после-
довательностей. Секция post-data содержит определения индексов, триггеров, правил и огра-
ничений (кроме ограничений проверки, созданных без NOT VALID ). Секция pre-data включает
определения остальных элементов.
–serializable-deferrable
Использовать при выгрузке транзакцию с уровнем изоляции serializable для получения сним-
ка, согласованного с последующими состояниями базы. Правда для этого нужно выждать мо-
мент, когда в потоке транзакций нет аномалий, и поэтому нет риска, что выгрузка завершится
неудачно, и риска отката других транзакций с ошибкой serialization_failure. Более подроб-
но изоляция транзакций и управление одновременным доступом описывается в Главе 13.
Параметр не особо полезен в случаях, когда требуется восстановление после сбоя. Он полезен
для создания копии базы данных, в которой формируются отчёты и выполняются другие опера-
ции чтения, в то время как в основной базе продолжается обычная работа. Без этого параметра
выгрузка может содержать не целостное состояние базы данных. Например, если использует-
ся пакетная обработка, статус пакета может отражаться как завершённый, в то время как в
выгрузке будут не все элементы пакета.
Параметр не будет влиять на результат, если во время запуска pg_dump нет активных транзак-
ций на чтение-запись. Если же активные транзакции чтения-записи есть, то начало выгрузки
может быть отложено на неопределённый период времени. После того как выгрузка началась,
производительность с этим ключом или без него будет одинаковой.
–snapshot=имя_снимка
Использовать заданный синхронный снимок при выгрузке данных из базы (за подробностями
обратитесь к Таблице 9.82).
Этот параметр полезен, когда требуется синхронизировать выгружаемые данные со слотом
логической репликации (см. Главу 49) или с другим одновременным сеансом.
В случае с параллельной выгрузкой будет использоваться имя снимка, определённое этим па-
раметром; новый снимок не будет сделан.
–strict-names
Требует, чтобы каждому указанию схемы (-n/–schema) и таблицы (-t/–table) соответствовала
минимум одна схема/таблица в выгружаемой базе данных. Заметьте, что если не находится
вообще ни одной схемы/таблицы для заданных шаблонов, pg_dump выдаёт ошибку и без ключа
–strict-names.
Этот параметр не действует на ключи -N/–exclude-schema, -T/–exclude-table или –
exclude-table-data. Если не находятся объекты, соответствующие шаблонам исключения, это
не считается ошибкой.
–use-set-session-authorization
Выводить команды SET SESSION AUTHORIZATION, соответствующие стандарту, вместо ALTER
OWNER, для назначения владельцев объектов. В результате выгруженный скрипт будет более
1797pg_dump
стандартизированным, но может не восстановиться корректно, в зависимости от истории объ-
ектов. Кроме того, для использования SET SESSION AUTHORIZATION при восстановлении нужны
права суперпользователя, в то время как ALTER OWNER требует меньших привилегий.
-?
–help
Показать справку по аргументам командной строки pg_dump и завершиться.
Далее описаны параметры управления подключением.
-d имя_бд
–dbname=имя_бд
Указывает имя базы данных для подключения. Эквивалентно указанию dbname в качестве пер-
вого аргумента, не являющегося параметром в командной строке.
Если параметр содержит символ =, или начинается с допустимого префикса URI, например,
postgresql:// или postgres://, то он трактуется аналогично строке подключения conninfo.
За дополнительными сведениями обратитесь к Разделу 34.1.
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета. Значение по умолчанию берётся из переменной
окружения PGHOST, если она установлена. В противном случае выполняется подключение к
Unix-сокету.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной окружения PGPORT,
если она установлена, либо числом, заданным при компиляции.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как pg_dump запрашивает пароль автоматически, если сер-
вер проверяет подлинность по паролю. Однако, чтобы понять это, pg_dump лишний раз под-
ключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненужную
попытку подключения.
–role=имя роли
Задаёт имя роли, которая будет осуществлять выгрузку. Получив это имя, pg_dump выполнит
SET ROLE имя_роли после подключения к базе данных. Это полезно, когда проходящий проверку
1798pg_dump
пользователь (указанный в -U) не имеет прав, необходимых для pg_dump, но может переклю-
читься на роль, наделённую этими правами. В некоторых окружениях правила запрещают под-
ключаться к серверу непосредственно суперпользователю, и этот параметр позволяет выпол-
нить выгрузку, не нарушая их.
Переменные окружения
PGDATABASE
PGHOST
PGOPTIONS
PGPORT
PGUSER
Параметры подключения по умолчанию.
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
pg_dump на низком уровне выполняет команды SELECT. Если есть проблемы с работой pg_dump,
убедитесь, что в базе данных можно выполнить SELECT, например из psql. Также следует учиты-
вать, что при этом применяются все свойства подключения по умолчанию и переменные окруже-
ния, которые использует клиентская библиотека libpq.
Обычно действия pg_dump в базе данных отслеживаются сборщиком статистики. Если это неже-
лательно, то можно установить параметр track_counts в false в переменной окружения PGOPTIONS
или в команде ALTER USER.
Замечания
Если в базу данных кластера template1 устанавливались дополнительные объекты, то следует убе-
диться, что выгрузка pg_dump загружается в пустую базу данных. Иначе существует вероятность
возникновения ошибок дублирования создаваемых объектов. Чтобы создать пустую базу данных,
копируйте её из шаблона template0, вместо template1, например:
CREATE DATABASE foo WITH TEMPLATE template0;
Если выгружаются только данные с одновременным использованием –disable-triggers,
pg_dump сформирует команды для выключения табличных триггеров перед вставкой данных, а
после них — команды, включающие триггеры обратно. Если восстановление будет прервано в се-
редине процесса, системный каталог может остаться в неверном состоянии.
Сформированный pg_dump файл не содержит статистики, которую использует планировщик для
принятия решений при планировании запросов. Поэтому после восстановления разумно будет вы-
полнить ANALYZE для достижения оптимальной производительности; за дополнительными сведе-
ниями обратитесь к Подразделу 24.1.3 и Подразделу 24.1.6.
Так как pg_dump применяется для переноса данных в новые версии PostgreSQL, предполагает-
ся, что вывод pg_dump можно загрузить на сервер PostgreSQL более новой версии, чем версия
pg_dump. pg_dump может также выгружать данные серверов PostgreSQL более старых версий, чем
его собственная. (В настоящее время поддерживаются версии, начиная с 8.0.) Однако утилита
pg_dump не может выгружать данные с серверов PostgreSQL более новых основных версий; она не
будет даже пытаться делать это, во избежание некорректной выгрузки. Также не гарантируется,
что вывод pg_dump может быть загружен на сервере более старой основной версии — даже если
данные были выгружены с сервера той же версии. Для загрузки такого файла на старом сервере
может потребоваться вручную исправить в нём синтаксис, не воспринимаемый старой версией.
Имея дело с разными версиями, рекомендуется применять параметр –quote-all-identifiers,
так как он может предотвратить проблемы, возникающие при изменении множества зарезервиро-
ванных слов в разных версиях PostgreSQL.
1799pg_dump
Выгружая подписки на логическую репликацию, pg_dump будет выдавать команды CREATE
SUBSCRIPTION с указанием NOCONNECT, так что при восстановления подписки не будут устанавли-
ваться удалённые подключения для создания слота репликации или для начального копирования
таблиц. Таким образом, выгруженные данные могут быть восстановлены без сетевого доступа к
удалённым серверам. Вновь активировать подписки должным образом — задача пользователя. Ес-
ли задействованные серверы поменялись, возможно, придётся скорректировать строки подключе-
ния. Также может быть уместно опустошить целевые таблицы перед началом полного копирова-
ния таблиц.
Примеры
Выгрузка базы данных mydb в файл SQL-скрипта:
$ pg_dump mydb &gt; db.sql
Восстановление из ранее полученного скрипта в чистую базу newdb:
$ psql -d newdb -f db.sql
Выгрузка базы данных в формате custom:
$ pg_dump -Fc mydb &gt; db.dump
Выгрузка базы данных в формате directory:
$ pg_dump -Fd mydb -f dumpdir
Выгрузка базы данных в формате directory в 5 параллельных потоков:
$ pg_dump -Fd mydb -j 5 -f dumpdir
Восстановление из архива в чистую новую базу данных newdb:
$ pg_restore -d newdb db.dump
Восстановление архива в ту же базу данных, из которой он был выгружен, с предварительным
удалением текущего содержимого этой базы данных:
$ pg_restore -d postgres –clean –create db.dump
Выгрузка отдельной таблицы mytab:
$ pg_dump -t mytab mydb &gt; db.sql
Выгрузка всех таблиц, имена которых начинаются с emp и которые принадлежат схеме detroit,
кроме таблицы employee_log:
$ pg_dump -t ‘detroit.emp</em>’ -T detroit.employee_log mydb &gt; db.sql
Выгрузка всех схем, имена которых начинаются с east или west, заканчиваются на gsm и не со-
держат test:
$ pg_dump -n ‘east<em>gsm’ -n ‘west</em>gsm’ -N ‘<em>test</em>’ mydb &gt; db.sql
То же самое, но с использованием регулярного выражения:
$ pg_dump -n ‘(east|west)<em>gsm’ -N ‘</em>test<em>’ mydb &gt; db.sql
Выгрузка всех объектов базы данных, кроме таблиц, имена которых начинаются с ts_:
$ pg_dump -T ‘ts_</em>’ mydb &gt; db.sql
Чтобы указать имя в верхнем или смешанном регистре в ключе -t и связанных с ним, это имя нуж-
но заключить в кавычки; иначе оно будет приведено к нижнему регистру (см. Подраздел «Шабло-
ны поиска»). Но кавычки являются спецсимволом для оболочки, так что и их нужно заключать
1800pg_dump
в кавычки. Так, чтобы выгрузить одну таблицу с именем в смешанном регистре, нужно написать
примерно следующее:
$ pg_dump -t “"MixedCaseName"” mydb &gt; mytab.sql
См. также
pg_dumpall, pg_restore, psql
1801pg_dumpall
pg_dumpall — выгрузить кластер баз данных PostgreSQL в формате скрипта
Синтаксис
pg_dumpall [параметр-подключения…] [параметр…]
Описание
Утилита pg_dumpall предназначена для записи («выгрузки») всех баз данных кластера PostgreSQL
в один файл в формате скрипта. Этот файл содержит команды SQL, так что передав его на вход
psql, можно восстановить все базы данных. Для формирования этого файла вызывается pg_dump
для каждой базы данных в кластере. pg_dumpall также выгружает глобальные объекты, общие для
всех баз данных, то есть роли и табличные пространства. (Программа pg_dump не сохраняет эти
объекты.)
Так как утилита pg_dumpall читает таблицы из всех баз данных, для получения полного содержи-
мого баз запускать её, как правило, нужно от имени суперпользователя. Также права суперполь-
зователя требуются при последующем выполнении сохранённого скрипта, чтобы он смог добавить
роли и создать базы данных.
Генерируемый SQL-скрипт записывается в стандартное устройство вывода. Чтобы перенаправить
его в файл, воспользуйтесь параметром [-f|file] или операторами оболочки.
Утилите pg_dumpall требуется подключаться к серверу PostgreSQL несколько раз (к каждой базе
по отдельности). Если вы проходите проверку подлинности по паролю, вам придётся каждый раз
вводить пароль. Чтобы избежать этого, удобно иметь файл ~/.pgpass. За дополнительными сведе-
ниями обратитесь к Разделу 34.15.
Параметры
Параметры командной строки для управления содержимым и форматом вывода.
-a
–data-only
Выгружать только данные, без схемы (определений данных).
-c
–clean
Добавить команды SQL для удаления (DROP) баз данных перед командами, создающими их. В
дополнение к ним добавляются команды DROP для ролей и табличных пространств.
-E кодировка
–encoding=кодировка
Создать копию в заданной кодировке. По умолчанию копия создаётся в кодировке базы дан-
ных. (Другой способ достичь того же результата — задать желаемую кодировку в переменной
окружения PGCLIENTENCODING.)
-f имя_файла
–file=имя_файла
Направить вывод в указанный файл. Если этот параметр опущен, скрипт записывается в стан-
дартный вывод.
-g
–globals-only
Выгружать только глобальные объекты (роли и табличные пространства), без баз данных.
1802pg_dumpall
-o
–oids
Выгружать идентификаторы объектов (OIDs) вместе с данными таблиц. Используйте этот па-
раметр, если в приложении есть ссылки на OID, например во внешних ключах. В противном
случае, этот параметр лучше не использовать.
-O
–no-owner
Не генерировать команды, устанавливающие владение объектами, как в исходной базе данных.
По умолчанию, pg_dumpall генерирует команды ALTER OWNER или SET SESSION AUTHORIZATION,
восстанавливающие исходных владельцев для создаваемых элементов схемы. Однако выпол-
нить эти команды сможет только суперпользователь (или пользователь, владеющий всеми объ-
ектами, создаваемыми скриптом). Чтобы получить скрипт, который сможет восстановить лю-
бой пользователь (но при этом он станет владельцем всех объектов), используется -O.
-r
–roles-only
Выгружать только роли, без баз данных и табличных пространств.
-s
–schema-only
Выгружать только определения объектов (схемы), без данных.
-S имя_пользователя
–superuser=имя_пользователя
Указать суперпользователя, который будет использоваться для отключения триггеров. Пара-
метр имеет значение только вместе с –disable-triggers. Обычно его лучше не использовать,
а запускать полученный скрипт от имени суперпользователя.
-t
–tablespaces-only
Выгружать только табличные пространства, без баз данных и ролей.
-v
–verbose
Включить режим подробных сообщений. В этом режиме pg_dumpall записывает в выходной
файл время начала/завершения выгрузки, а в стандартный канал ошибок — сообщения о про-
цессе. При этом подробные сообщения будет также выводить pg_dump.
-V
–version
Сообщить версию pg_dumpall и завершиться.
-x
–no-privileges
–no-acl
Не выгружать права доступа (команды GRANT/REVOKE).
–binary-upgrade
Этот параметр предназначен для утилит обновления сервера. Использование для иных целей
не рекомендуется и не поддерживается. Поведение параметра может быть изменено в после-
дующих версиях без предварительного уведомления.
1803pg_dumpall
–column-inserts
–attribute-inserts
Выгружать данные в виде команд INSERT с явно задаваемыми именами столбцов (INSERT INTO
таблица (столбец, …) VALUES …). При этом восстановление будет очень медленным;
в основном это применяется для выгрузки данных, которые затем будут загружаться не в
PostgreSQL.
–disable-dollar-quoting
Этот параметр запрещает заключать в доллары тело функций, что оставляет возможность толь-
ко заключать их в кавычки, применяя стандартный синтаксис SQL.
–disable-triggers
Этот параметр действует только при выгрузке одних данных. С ним pg_dumpall добавляет ко-
манды, отключающие триггеры в целевых таблицах на время загрузки данных. Используйте
его, если в ваших таблицах определены проверки ссылочной целостности или другие триггеры,
которые вы не хотели бы выполнять в процессе загрузки данных.
В настоящее время команды, генерируемые с параметром –disable-triggers, должны испол-
няться от имени суперпользователя. Таким образом, необходимо также передавать флаг -S,
либо при восстановлении выполнять скрипт от имени суперпользователя.
–if-exists
Использовать условные команды (т. е. добавлять предложение IF EXISTS) при удалении базы
данных и других объектов. Этот параметр принимается, только если также указан параметр
–clean.
–inserts
Выгружать данные в виде команд INSERT, а не COPY. При этом восстановление значительно за-
медлится; в основном это применяется для выгрузки данных, которые затем будут загружаться
не в PostgreSQL. Заметьте, что восстановление может вовсе не выполниться при изменении
порядка столбцов в таблицах. В этом смысле параметр –column-inserts безопаснее, но вос-
становление будет ещё медленнее.
–load-via-partition-root
При выгрузке данных для секции таблицы выводить команды COPY или INSERT, ссылающиеся на
корневую таблицу в иерархии секционирования, а не на эту секцию. В результате при загруз-
ке данных подходящая секция будет выбираться заново для каждой строки. Это может быть
полезно при перезагрузке данных, когда на целевом сервере строки не всегда попадают в те
же секции, в которых они находились на исходном. Это возможно, например, когда столбец
разбиения имеет текстовый тип и в двух системах по-разному определено правило сортировки,
по которому упорядочивается этот столбец.
–lock-wait-timeout=время_ожидания
Не ждать бесконечно получения разделяемых блокировок таблиц в начале процедуры вы-
грузки. Вместо этого выдать ошибку, если не удастся заблокировать таблицы за указанное
время_ожидания. Это время можно задать в любом из форматов, принимаемых командой SET
statement_timeout. Допустимые значения зависят от версии сервера, выгружающего данные,
но количество миллисекунд в виде целого числа принимают все версии, начиная с 7.3. Более
ранние версии игнорируют этот параметр.
–no-comments
Не выгружать комментарии.
–no-publications
Не выгружать публикации.
1804pg_dumpall
–no-role-passwords
Не выгружать пароли ролей. При восстановлении все роли получат пароль NULL и не смогут
пройти проверку подлинности, пока им не будут назначены пароли. Так как значения паролей
не нужны, когда используется это указание, информация о ролях считывается из системного
представления pg_roles, а не из pg_authid. Таким образом, данный вариант может быть также
полезен, если доступ к pg_authid ограничен политикой безопасности.
–no-security-labels
Не выгружать метки безопасности.
–no-subscriptions
Не выгружать подписки.
–no-sync
По умолчанию pg_dumpall ждёт, пока все файлы не будут надёжно записаны на диск. С данным
параметром pg_dumpall завершается немедленно, то есть выполняется быстрее, но в случае
неожиданного сбоя операционной системы выгруженные данные могут оказаться испорченны-
ми. Вообще этот параметр предназначен прежде всего для тестирования, для производствен-
ной среды он не подходит.
–no-tablespaces
Не выводить команды, создающие или выбирающие табличные пространства для объектов. С
этим параметром все объекты будут созданы в пространстве по умолчанию, установленном во
время восстановления.
–no-unlogged-table-data
Не выгружать содержимое нежурналируемых таблиц. Этот параметр не влияет на то, как вы-
гружаются определения этих таблиц (схема); он отключает только выгрузку данных из них.
–quote-all-identifiers
Принудительно экранировать все идентификаторы. Этот параметр рекомендуется при выгруз-
ке базы, когда основная версия сервера PostgreSQL, с которого выгружается база, отличает-
ся от версии pg_dumpall, или когда выгруженная копия предназначена для загрузки на серве-
ре с другой основной версией. По умолчанию pg_dumpall экранирует только те идентификато-
ры, которые являются зарезервированными словами в собственной основной версии. Иногда
это приводит к проблемам совместимости с серверами других версий, в которых множество
зарезервированных слов может быть несколько другим. Применение параметра –quote-all-
identifiers предотвращает подобные проблемы, ценой ухудшения читаемости скрипта с вы-
груженными данными.
–use-set-session-authorization
Выводить команды SET SESSION AUTHORIZATION, соответствующие стандарту, вместо ALTER
OWNER, для назначения владельцев объектов. В результате выгруженный скрипт будет более
стандартизированным, но может не восстановиться корректно, в зависимости от истории объ-
ектов.
-?
–help
Показать справку по аргументам командной строки pg_dumpall и завершиться.
Далее описаны параметры управления подключением.
-d строка_подключения
–dbname=строка_подключения
Указывает параметры подключения к серверу в формате строки подключения. См. Подраз-
дел 34.1.1 для более подробной информации.
1805pg_dumpall
Этот параметр называется –dbname для согласованности с другими клиентскими приложени-
ями, но так как pg_dumpall подключается не к одной базе данных, имя базы в строке подклю-
чения игнорируется. Чтобы указать имя базы данных для начального подключения, которое
будет использоваться для выгрузки глобальных объектов и обнаружения других выгружаемых
баз, воспользуйтесь параметром -l.
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер баз данных. Если значение начина-
ется с косой черты, оно определяет каталог Unix-сокета. Значение по умолчанию берётся из
переменной окружения PGHOST, если она установлена. В противном случае выполняется под-
ключение к Unix-сокету.
-l имя_бд
–database=имя_бд
Задаёт имя базы данных, через подключение к которой будут выгружаться глобальные объекты
и находиться другие выгружаемые базы. По умолчанию используется база postgres, а в случае
её отсутствия — template1.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной окружения PGPORT,
если она установлена, либо числом, заданным при компиляции.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как pg_dumpall запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, pg_dumpall лишний раз
подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненуж-
ную попытку подключения.
Заметьте, что пароль будет запрашиваться повторно для выгрузки каждой базы данных. Поэто-
му обычно лучше настроить файл ~/.pgpass, и не вводить пароль каждый раз вручную.
–role=имя роли
Задаёт имя роли, которая будет осуществлять выгрузку. Получив это имя, pg_dumpall выполнит
SET ROLE имя_роли после подключения к базе данных. Это полезно, когда проходящий провер-
ку пользователь (указанный в -U) не имеет прав, необходимых для pg_dumpall, но может пере-
ключиться на роль, наделённую этими правами. В некоторых окружениях правила запрещают
подключаться к серверу непосредственно суперпользователю, и этот параметр позволяет вы-
полнить выгрузку, не нарушая их.
1806pg_dumpall
Переменные окружения
PGHOST
PGOPTIONS
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Замечания
Так как pg_dumpall внутри себя вызывает pg_dump, часть диагностических сообщений будет отно-
ситься к pg_dump.
Ключ –clean может быть полезен, даже если вы намереваетесь восстановить копию из скрипта в
новом кластере. С –clean скрипт сможет удалить и пересоздать встроенные базы данных postgres
и template1, так что они получат свойства, которые имели одноимённые базы в исходном кластере
(например, локаль и кодировку). Без данного ключа эти базы сохранят свои свойства уровня базы
данных, а также всё существующее содержимое.
После восстановления имеет смысл запустить ANALYZE для каждой базы данных, чтобы оптимиза-
тор получил актуальную статистику. Также можно запустить анализ для всех баз данных, выпол-
нив команду vacuumdb -a -z.
Не следует ожидать, что скрипт выгрузки будет выполняться абсолютно без ошибок. В частности,
так как он будет содержать CREATE ROLE для каждой существующей в исходном кластере роли, при
попытке создать суперпользователя определённо произойдёт ошибка «role already exists» (роль
уже существует), если только целевой кластер был инициализирован не с другим начальным име-
нем суперпользователя. Эта ошибка некритична и её следует просто игнорировать. С ключом –
clean весьма вероятны другие незначительные сообщения об ошибках, связанные с несуществу-
ющими объектами; их число можно минимизировать, добавив ключ –if-exists.
При использовании pg_dumpall требуется, чтобы все необходимые каталоги табличных про-
странств существовали до восстановления; в противном случае, создание баз данных в нестандарт-
ном размещении завершится ошибкой.
Примеры
Выгрузка всех баз данных:
$ pg_dumpall &gt; db.out
Загрузить базы данных из этого файла можно так:
$ psql -f db.out postgres
К какой базе вы подключаетесь, в принципе не имеет значения, так как скрипт, созданный утили-
той pg_dumpall, будет содержать все команды, требующиеся для создания сохранённых баз дан-
ных и подключения к ним. Однако это важно, если применяется ключ –clean — тогда вы должны
изначально подключиться к базе postgres; скрипт попытается прежде всего удалить остальные
базы данных, но не сможет этого сделать для базы, к которой вы подключены.
См. также
Обратитесь к описанию pg_dump, чтобы узнать об условиях, при которых могут возникнуть про-
блемы.
1807pg_isready
pg_isready — проверить соединение с сервером PostgreSQL
Синтаксис
pg_isready [параметр-подключения…] [параметр…]
Описание
Утилита pg_isready предназначена для проверки соединения с сервером баз данных PostgreSQL.
Результат проверки передаётся в коде завершения.
Параметры
-d имя_бд
–dbname=имя_бд
Задаёт имя базы данных, к которой нужно подключиться.
Если этот параметр содержит знак = или начинается с допустимого префикса URI
(postgresql:// или postgres://), он воспринимается как строка conninfo. За дополнительны-
ми сведениями обратитесь к Подразделу 34.1.1.
-h компьютер
–host=компьютер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной среды PGPORT, если
она установлена, либо числом, заданным при компиляции, обычно 5432.
-q
–quiet
Не выводить сообщение о состоянии. Это полезно в скриптах.
-t секунды
–timeout=секунды
Максимальное время ожидания (в секундах) при попытке подключения, по истечении которого
констатируется, что сервер не отвечает. Значение по умолчанию — 3 секунды.
-U имя_пользователя
–username=имя_пользователя
Подключиться к базе данных с заданным именем пользователя вместо подразумеваемого по
умолчанию.
-V
–version
Сообщить версию pg_isready и завершиться.
-?
–help
Показать справку по аргументам командной строки pg_isready и завершиться.
1808pg_isready
Код завершения
Утилита pg_isready возвращает в оболочку 0, если сервер принимает подключения, 1, если он сбра-
сывает подключения (например, во время загрузки), 2, если при попытке подключения не получен
ответ, и 3, если попытки подключения не было (например, из-за некорректных параметров).
Переменные окружения
Как и большинство других утилит PostgreSQL, pg_isready также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Замечания
Чтобы получить состояние сервера, передавать имя пользователя, пароль и имя базы данных
не требуется; но если передать некорректные значения, сервер выведет в журнал сообщение о
неудачной попытке подключения.
Примеры
Обычное использование:
$ pg_isready
/tmp:5432 - accepting connections
$ echo $?
0
Запуск с параметрами подключения, во время загрузки кластера PostgreSQL:
$ pg_isready -h localhost -p 5433
localhost:5433 - rejecting connections
$ echo $?
1
Запуск с параметрами подключения, в случае, когда кластер PostgreSQL недоступен:
$ pg_isready -h someremotehost
someremotehost:5432 - no response
$ echo $?
2
1809pg_receivewal
pg_receivewal — получает журналы предзаписи с сервера PostgreSQL
Синтаксис
pg_receivewal [параметр…]
Описание
Утилита pg_receivewal предназначена для приёма журнала предзаписи от работающего кластера
PostgreSQL. Журнал предзаписи передаётся по протоколу потоковой репликации и записывается в
локальный каталог. Затем этот каталог можно использовать в качестве архива для восстановления
состояния на момент времени (см. Раздел 25.3).
pg_receivewal принимает журнал предзаписи в реальном времени по мере того, как он генери-
руется на сервере, и не ждёт завершения сегментов, как это делает archive_command. Поэтому
pg_receivewal можно использовать, не устанавливая archive_timeout.
В отличие от приёмника WAL, работающего на ведомом сервере PostgreSQL, pg_receivewal по умол-
чанию сохраняет на диск данные WAL, только когда файл WAL закрывается. Чтобы сохранять дан-
ные в реальном времени, нужно указать параметр –synchronous.
Журнал предзаписи передаётся через обычное подключение к PostgreSQL, с использованием про-
токола репликации. Подключение должен устанавливать суперпользователь или пользователь с
правом REPLICATION (см. Раздел 21.2), а в pg_hba.conf должно разрешаться подключение для ре-
пликации. Кроме того, параметр max_wal_senders на сервере должен быть достаточно большим,
чтобы можно было создать ещё один сеанс для передачи потока.
Если подключение разорвалось или его c самого начала не удаётся установить из-за некритиче-
ской ошибки, pg_receivewal будет бесконечно повторять попытки подключения и восстановит пе-
редачу, как только сможет. Чтобы отменить это поведение, воспользуйтесь параметром -n.
В отсутствие критичных ошибок pg_receivewal будет выполняться до прерывания сигналом SIGINT
(Control+C).
Параметры
-D каталог
–directory=каталог
Каталог, в который будут записываться данные.
Этот параметр является обязательным.
-E lsn
–endpos=lsn
Автоматически прекратить репликацию и завершить работу с кодом выхода 0 (без ошибки) при
достижении заданного LSN.
Если будет получена запись с LSN, равным заданному lsn, она будет обработана.
–if-not-exists
Не выдавать ошибку, когда указан параметр –create-slot и слот с заданным именем уже
существует.
-n
–no-loop
Не повторять цикл при ошибках подключения, а сразу завершать работу, возвращая ошибку.
1810pg_receivewal
–no-sync
С этим ключом pg_receivewal не будет принудительно сбрасывать данные WAL на диск. Этот
вариант быстрее, но при последующем сбое операционной системы сегменты WAL могут ока-
заться испорченными. Обычно этот ключ полезен при тестировании, но при создании архива
WAL в производственной среде использовать его не следует.
Этот ключ несовместим с –synchronous.
-s интервал
–status-interval=интервал
Указывает интервал в секундах между отправками серверу пакетов состояния. Это позволя-
ет упростить мониторинг прогресса. Чтобы выключить периодическое обновление состояния,
необходимо установить значение в ноль. При этом обновление будет отправляться по запросу
сервера для избежания отсоединения по истечению времени. Значение по умолчанию состав-
ляет 10 секунд.
-S имя_слота
–slot=имя_слота
Указывает pg_receivewal использовать существующий слот репликации (см. Подраздел 26.2.6).
Когда задан этот параметр, pg_receivewal будет сообщать серверу текущую позицию сохране-
ния, отмечая, какой сегмент был сохранён на диске, чтобы сервер мог удалить этот сегмент,
если он больше не нужен.
Когда клиент репликации pg_receivewal настроен на сервере как синхронный ведомый сервер,
для используемого слота репликации серверу будет передаваться позиция сохранённых дан-
ных, но только когда файл WAL закрывается. Таким образом, в такой конфигурации транзак-
ции на ведущем сервере будут ожидать завершения продолжительное время и по сути будут
работать неудовлетворительно. Чтобы эта конфигурация работала корректно, нужно дополни-
тельно указать параметр –synchronous (см. ниже).
–synchronous
Сохранять данные WAL на диск сразу после того, как они были получены. Также передавать
пакет состояния сразу после сохранения, вне зависимости от –status-interval.
Этот параметр следует указывать, если клиент репликации pg_receivewal настроен на сервере
как синхронный ведомый, чтобы обеспечить своевременную передачу ответа серверу.
-v
–verbose
Включает режим подробных сообщений.
-Z уровень
–compress=уровень
Включает gzip-сжатие журналов предзаписи и задаёт уровень сжатия от 0 (без сжатия) до 9
(максимальное сжатие). При этом ко всем именам файлов tar добавляется суффикс .gz.
Далее описаны параметры управления подключением.
-d строка_подключения
–dbname=строка_подключения
Указывает параметры подключения к серверу в формате строки подключения. См. Подраз-
дел 34.1.1 для более подробной информации.
Параметр называется –dbname для согласованности с другими клиентскими приложениями,
но так как pg_receivewal не подключается к какой-либо конкретной базе, это имя в строке под-
ключения игнорируется.
1811pg_receivewal
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета. Значение по умолчанию берётся из переменной
окружения PGHOST, если она установлена. В противном случае выполняется подключение к
Unix-сокету.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной окружения PGPORT,
если она установлена, либо числом, заданным при компиляции.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя для подключения.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как pg_receivewal запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, pg_receivewal лишний
раз подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту
ненужную попытку подключения.
pg_receivewal может выполнить одно из двух действий в отношении слотов физической реплика-
ции:
–create-slot
Создать слот физической репликации с именем, заданным аргументом –slot, и завершиться.
–drop-slot
Удалить слот репликации с именем, заданным аргументом –slot, и завершиться.
Другие флаги:
-V
–version
Сообщить версию pg_receivewal и завершиться.
-?
–help
Вывести справку по аргументам командной строки pg_receivewal и завершиться.
Код завершения
pg_receivewal завершится с кодом 0 при прерывании сигналом SIGINT. (Это штатный способ его
завершения, поэтому получение этого сигнала не считается ошибкой.) При критических ошибках
или получении других сигналов код выхода будет ненулевым.
1812pg_receivewal
Переменные окружения
Эта утилита, как и большинство других утилит PostgreSQL, использует переменные среды, поддер-
живаемые libpq (см. Раздел 34.14).
Замечания
Применяя pg_receivewal вместо archive_command в качестве основного способа резервного копи-
рования WAL, настоятельно рекомендуется использовать слоты репликации. В противном случае
сервер вполне может переписать или удалить файлы журнала предзаписи, прежде чем они бу-
дут скопированы, так как он не получает никакой информации, через archive_command или слоты
репликации, о том, как проходит архивация потока WAL. Учтите, однако, что при использовании
слота репликации может заполниться всё место на диске, если принимающая сторона не будет
успевать принимать данные WAL.
pg_receivewal сохранит разрешения для группы в полученных файлах WAL, если такие разрешения
установлены в исходном кластере.
Примеры
Следующая команда принимает журнал предзаписи с сервера mydbserver и сохраняет его в ло-
кальном каталоге /usr/local/pgsql/archive:
$ pg_receivewal -h mydbserver -D /usr/local/pgsql/archive
См. также
pg_basebackup
1813pg_recvlogical
pg_recvlogical — управление потоками логического декодирования PostgreSQL
Синтаксис
pg_recvlogical [параметр…]
Описание
Утилита pg_recvlogical управляет слотами логического декодирования и принимает данные из
таких слотов репликации.
Она создаёт соединение в режиме репликации, так что на него распространяются те же ограни-
чения, что и с pg_receivewal, плюс ограничения логической репликации (см. Главу 49).
pg_recvlogical не предоставляет возможностей, соответствующих режимам peek и get в SQL-
интерфейсе логического декодирования. Она передаёт серверу подтверждения воспроизведения
данных по мере их получения и при штатном выходе. Чтобы просмотреть данные, ожидающие пе-
редачи через слот, не принимая их, воспользуйтесь функцией pg_logical_slot_peek_changes.
Параметры
Для выбора действия необходимо указать минимум один из этих параметров:
–create-slot
Создать новый слот логической репликации с именем, заданным аргументом –slot, используя
модуль вывода, заданный аргументом –plugin, для базы данных, указанной в –dbname.
–drop-slot
Удалить слот репликации с именем, заданным аргументом –slot, и завершиться.
–start
Начать приём потока изменений из слота логической репликации с именем, заданным аргу-
ментом –slot, и продолжать до сигнала прерывания. Если передача потока прерывается на
другой стороне из-за выключения или остановки сервера, цикл подключения и передачи по-
вторяется (если не добавлен параметр –no-loop).
Формат потока определяется модулем вывода, выбранным при создании слота.
Для получения потока подключаться нужно к той же базе, для которой создавался слот.
Параметры –create-slot и –start исключают друг друга. Действие –drop-slot несовместимо
с любыми другими действиями.
Следующие параметры командной строки управляют расположением и форматом выводимых дан-
ных, а также другим поведением репликации:
-E lsn
–endpos=lsn
В режиме –start автоматически закончить репликацию и выйти с кодом обычного заверше-
ния 0, когда при приёме данных достигается указанный LSN. Если этот ключ указывается не
в режиме –start, выдаётся ошибка.
Если встречается запись с LSN, в точности равным lsn, эта запись будет выведена.
С указанием –endpos границы транзакций не отслеживаются, так что вывод программы мо-
жет оказаться обрезанным посередине транзакции. Частично полученная транзакция не будет
1814pg_recvlogical
считаться принятой и будет воспроизведена заново при следующем чтении из этого слота. От-
дельные сообщения не обрезаются никогда.
-f имя_файла
–file=имя_файла
Записывать полученные и декодированные данные транзакций в указанный файл. Для вывода
в stdout укажите - (минус).
-F секунды
–fsync-interval=секунды
Устанавливает, как часто pg_recvlogical будет вызывать fsync(), чтобы гарантировать, что вы-
ходной файл надёжно сохранён на диске.
Сервер время от времени даёт клиенту команду сохранить данные и сообщить сохранённую
позицию, но этот параметр позволяет выполнять сохранение чаще.
При значении, равном 0, функция fsync() вообще не вызывается, но серверу сообщается новая
позиция. Это может привести к потере данных в случае сбоя.
-I lsn
–startpos=lsn
В режиме –start репликация начнётся с данного LSN. Как это работает, подробно описыва-
ется в Главе 49 и Разделе 53.4. В других режимах игнорируется.
–if-not-exists
Не выдавать ошибку, когда указан параметр –create-slot и слот с заданным именем уже
существует.
-n
–no-loop
Когда подключение к серверу потеряно, не повторять цикл, просто завершить работу.
-o имя[=значение]
–option=имя[=значение]
Передаёт параметр имя_параметра модулю вывода, при этом может быть передано и его зна-
чение. Набор параметров и их действия зависят от выбранного модуля вывода.
-P модуль
–plugin=модуль
Использовать указанный модуль вывода логического декодирования при создании слота. См.
Главу 49. Этот параметр не действует, если слот уже существует.
-s секунды
–status-interval=секунды
Этот параметр действует так же, как одноимённый параметр pg_receivewal (см. его описание
там).
-S имя_слота
–slot=имя_слота
Этот параметр задаёт имя слота логической репликации, который будет использоваться в ре-
жиме –start, создаваться в режиме –create-slot или удаляться в режиме –drop-slot.
-v
–verbose
Включает режим подробных сообщений.
1815pg_recvlogical
Далее описаны параметры управления подключением.
-d база_данных
–dbname=база_данных
Этот параметр выбирает базу данных для подключения. Как именно она используется, можно
узнать в описании соответствующих действий. Это может быть строка подключения libpq; за
дополнительными сведениями обратитесь к Подразделу 34.1.1. По умолчанию имя базы опре-
деляется именем пользователя.
-h имя_компьютера-или-ip
–host=имя_компьютера-или-ip
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета. Значение по умолчанию берётся из переменной
окружения PGHOST, если она установлена. В противном случае выполняется подключение к
Unix-сокету.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной окружения PGPORT,
если она установлена, либо числом, заданным при компиляции.
-U user
–username=user
Имя пользователя для подключения. По умолчанию это имя текущего пользователя операци-
онной системы.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как pg_recvlogical запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, pg_recvlogical лишний
раз подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту
ненужную попытку подключения.
Также есть следующие дополнительные параметры:
-V
–version
Сообщить версию pg_recvlogical и завершиться.
-?
–help
Показать справку по аргументам командной строки pg_recvlogical и завершиться.
Переменные окружения
Как и большинство других утилит PostgreSQL, приложение также использует переменные окру-
жения, поддерживаемые libpq (см. Раздел 34.14).
1816pg_recvlogical
Замечания
pg_recvlogical сохранит разрешения для группы в полученных файлах WAL, если такие разрешения
установлены в исходном кластере.
Примеры
Примеры использования можно найти в Разделе 49.1.
См. также
pg_receivewal
1817pg_restore
pg_restore — восстановить базу данных PostgreSQL из файла архива, созданного командой pg_dump
Синтаксис
pg_restore [параметр-подключения…] [параметр…] [имя_файла]
Описание
Утилита pg_restore предназначена для восстановления базы данных PostgreSQL из архива, создан-
ного командой pg_dump в любом из не текстовых форматов. Она выполняет команды, необходимые
для восстановления того состояния базы данных, в котором база была сохранена. При наличии
файлов архивов, pg_restore может восстанавливать данные избирательно или даже переупорядо-
чить объекты перед восстановлением. Заметьте, что разработанный для файлов архива формат не
привязан к архитектуре.
Утилита pg_restore может работать в двух режимах. Если указывается имя базы данных, pg_restore
подключается к этой базе данных и восстанавливает содержимое архива непосредственно в неё.
В противном случае, создаётся SQL-скрипт с командами, необходимыми для пересоздания базы
данных, который затем выводится в файл или в стандартное устройство вывода. Сформированный
скрипт будет в точности соответствовать выводу pg_dump в простом текстовом формате. Поэтому
некоторые из параметров, управляющих выводом, аналогичны параметрам pg_dump.
Разумеется, pg_restore может восстановить информацию, только если она присутствует в файле
архива, и только в существующем виде. Например, если архив был создан с указанием «выгрузить
данные в виде команд INSERT», pg_restore не сможет загрузить эти данные, используя операторы
COPY.
Параметры
Утилита pg_restore принимает следующие аргументы командной строки.
имя_файла
Указывает расположение восстанавливаемого файла архива (или каталога, для архива в фор-
мате каталога). По умолчанию используется устройство стандартного ввода.
-a
–data-only
Восстанавливать только данные, без схемы (определений данных). При этом восстанавливают-
ся данные таблиц, большие объекты и значения последовательностей, имеющиеся в архиве.
Флаг похож на –section=data, но по историческим причинам не равнозначен ему.
-c
–clean
Удалить (DROP) объекты базы данных, прежде чем пересоздавать их. (Без дополнительного
указания –if-exists при этом могут выдаваться безвредные сообщения об ошибках, если та-
ких объектов не окажется в целевой базе данных.)
-C
–create
Создать базу данных, прежде чем восстанавливать данные. Если также указан параметр –
clean, удалить и пересоздать целевую базу данных перед подключением к ней.
С ключом –create программа pg_restore также восстанавливает комментарий к базе данных
(если он задан) и все назначения переменных конфигурации, связанные с базой данных, то есть
1818pg_restore
все команды ALTER DATABASE … SET … и ALTER ROLE … IN DATABASE … SET …, ссы-
лающиеся на эту базу данных. Также восстанавливаются права доступа к самой базе данных,
если не добавлен ключ –no-acl.
С этим параметром база, заданная параметром -d, применяется только для подключения и вы-
полнения начальных команд DROP DATABASE и CREATE DATABASE. Все данные восстанавливаются
в базу данных, имя которой записано в архиве.
-d имя_бд
–dbname=имя_бд
Подключиться к базе данных имя_базы и восстановить данные непосредственно в неё.
-e
–exit-on-error
Завершать работу в случае возникновения ошибки при выполнении команд SQL в базе дан-
ных. По умолчанию процесс восстановления продолжается, а по его окончании выдаётся число
ошибок.
-f имя_файла
–file=имя_файла
Задаёт файл для вывода сгенерированного скрипта или списка объектов, полученного с пара-
метром -l. По умолчанию используется стандартный вывод.
-F format
–format=format
Задаёт формат архива. Указывать формат необязательно, так как pg_restore определяет формат
автоматически. Но если формат задаётся, допускается один из этих вариантов:
c
custom
Архив сохранён в специальном формате pg_dump.
d
directory
Архив сохранён в каталоге.
t
tar
Архив сохранён в формате tar.
-I индекс
–index=индекс
Восстановить определение только заданного индекса. Добавив дополнительные ключи -I, мож-
но указать несколько индексов.
-j число-заданий
–jobs=число-заданий
Запустить наиболее длительные операции pg_restore (в частности, загрузку данных, создание
индексов или ограничений) в нескольких параллельных заданиях. Это позволяет кардинально
сократить время восстановления большой базы данных, когда сервер работает на многопроцес-
сорном компьютере.
Каждое задание выполняется в отдельном задании или потоке, в зависимости от операционной
системы, и использует отдельное подключение к серверу.
1819pg_restore
Оптимальное значение этого параметра зависит от аппаратной конфигурации сервера, клиента
и сети. В частности, имеет значение количество процессорных ядер и устройство дискового
хранилища. В качестве начального значения можно выбрать число ядер на сервере, но и при
увеличении этого значения во многих случаях восстановление будет быстрее. Конечно, при
слишком больших значениях производительность упадёт из-за перегрузки.
Этот параметр поддерживается только с архивом в специальном формате или в каталоге. Вход-
ные данные должны поступать из обычного файла или каталога (а не, например из канала вво-
да). Данный параметр игнорируется, когда генерируется скрипт (нет прямого подключения к
базе данных). Кроме того, несколько заданий не могут выполняться в сочетании с параметром
–single-transaction.
-l
–list
Вывести оглавление архива. Вывод этой операции можно подать на вход этой же команде с
параметром -L. Учтите, что когда вместе с -l применяются параметры фильтрации (например,
-n или -t), они сокращают список выводимых объектов.
-L файл-список
–use-list=файл-список
Восстановить из архива только элементы, перечисленные в файле-списке, и в том порядке, в
каком они идут в этом файле. Заметьте, что когда вместе с -L применяются параметры филь-
трации (например, -n или -t), они дополнительно ограничивают восстанавливаемые объекты.
Данный файл-список обычно представляет собой отредактированный результат предыдущей
операции -l. Строки в нём могут быть переставлены или удалены, а также могут быть заком-
ментированы точкой с запятой (;), добавленной в начале строки. См. примеры ниже.
-n схема
–schema=схема
Восстановить только объекты в указанной схеме. Добавив дополнительные ключи -n, можно
указать несколько схем. Этот параметр можно сочетать с -t, чтобы восстановить только опре-
делённую таблицу.
-N схема
–exclude-schema=схема
Не восстанавливать объекты в указанной схеме. Добавив дополнительные ключи -N, можно
исключить несколько схем.
Когда и с ключом -n, и с ключом -N передаётся имя одной схемы, ключ -N выигрывает и схема
исключается.
-O
–no-owner
Не генерировать команды, устанавливающие владение объектами, как в исходной базе данных.
По умолчанию, pg_restore генерирует команды ALTER OWNER или SET SESSION AUTHORIZATION,
восстанавливающие исходных владельцев создаваемых элементов схемы. Однако эти команды
можно будет выполнить, только если к базе данных первоначально подключается суперполь-
зователь (или пользователь, владеющими всеми объектами в скрипте). Чтобы получить скрипт,
который сможет восстановить любой подключающийся пользователь (но при этом он станет
владельцем всех созданных объектов), используется -O.
-P имя-функции(тип-аргумента[, …])
–function=имя-функции(тип-аргумента[, …])
Восстановить только указанную функцию. При этом важно записать имя функции и аргумен-
ты в точности так, как они фигурируют в оглавлении файла архива. Добавив дополнительные
ключи -P, можно указать несколько функций.
1820pg_restore
-R
–no-reconnect
Параметр является устаревшим, но в целях совместимости ещё работает.
-s
–schema-only
Восстановить только схему (определения данных), без данных, в объёме, в котором элементы
схемы представлены в архиве.
Действие параметра противоположно действию –data-only. Это похоже на указание –
section=pre-data –section=post-data, но по историческим причинам не равнозначно ему.
(Не путайте этот параметр с –schema, где слово «схема» используется в другом значении.)
-S имя_пользователя
–superuser=имя_пользователя
Задаёт имя суперпользователя, полномочия которого будут использоваться для отключения
триггеров. Этот параметр применяется только с параметром –disable-triggers.
-t таблица
–table=таблица
Восстановить определение и/или данные только указанной таблицы. В этом контексте под «таб-
лицей» подразумеваются также представления, материализованные представления, последо-
вательности и сторонние таблицы. Чтобы выбрать несколько таблиц, ключ -t можно указать
несколько раз. Этот параметр можно скомбинировать с -n, чтобы выбрать таблицу(ы) в опре-
делённой схеме.
Примечание
Когда указывается -t, pg_restore не пытается восстанавливать объекты базы дан-
ных, от которых могут зависеть выбранные таблицы. Таким образом, в этом случае
не гарантируется, что выгруженные таблицы будут успешно восстановлены в чи-
стой базе данных.
Примечание
Этот флаг действует не совсем так, как флаг -t утилиты pg_dump. В настоящее вре-
мя pg_restore не поддерживает выбор объектов по маске, а также не позволяет ука-
зать имя схемы с -t. И хотя pg_dump с флагом -t также выгружает подчинённые
объекты (например, индексы) выбранных таблиц, pg_restore с флагом -t такие под-
чинённые объекты не обрабатывает.
Примечание
В версиях PostgreSQL до 9.6 этот флаг выбирал только таблицы, но не другие типы
отношений.
-T триггер
–trigger=триггер
Восстановить только указанный триггер. Добавив дополнительные ключи -T, можно указать
несколько триггеров.
1821pg_restore
-v
–verbose
Включает режим подробных сообщений.
-V
–version
Сообщить версию pg_restore и завершиться.
-x
–no-privileges
–no-acl
Не восстанавливать права доступа (не выполнять команды GRANT/REVOKE).
-1
–single-transaction
Произвести восстановление в одной транзакции (то есть, завернуть выполняемые команды в
BEGIN/COMMIT). При этом гарантируется, что либо все команды будут выполнены успешно, либо
не будет никаких изменений. Этот режим подразумевает –exit-on-error.
–disable-triggers
Этот параметр действует только при выгрузке одних данных. С ним pg_restore выполняет ко-
манды, отключающие триггеры в целевых таблицах на время загрузки данных. Используйте
его, если в ваших таблицах определены проверки ссылочной целостности или другие триггеры,
которые вы не хотели бы выполнять в процессе загрузки данных.
В настоящее время команды, генерируемые с –disable-triggers, должны выполнятся супер-
пользователем. Поэтому необходимо также задать имя суперпользователя в параметре -S или,
что предпочтительнее, запускать pg_restore от имени суперпользователя PostgreSQL.
–enable-row-security
Этот параметр имеет смысл только при восстановлении содержимого таблицы, для которой
включена защита строк. По умолчанию pg_restore устанавливает для row_security значение off
для уверенности, что в таблице восстановлены все данные. Если у пользователя недостаточно
прав для обхода защиты строк, выдаётся ошибка. Этот параметр указывает pg_restore устано-
вить в row_security значение on, чтобы пользователь мог попытаться восстановить содержимое
таблицы с включённой защитой строк. Однако и при этом возможна ошибка, если пользователь
не будет иметь права добавлять в эту таблицу выгруженные строки данных.
Заметьте, что в настоящее время для этого требуется, чтобы выгрузка выполнялась в режиме
INSERT, так как COPY FROM не поддерживает защиту строк.
–if-exists
При удалении объектов базы использовать условные команды (то есть добавлять предложение
IF EXISTS). Применяется только с параметром –clean.
–no-comments
Не выводить команды, восстанавливающие комментарии, даже если они содержатся в архиве.
–no-data-for-failed-tables
По умолчанию данные восстанавливаются даже при ошибке команды создания таблицы (на-
пример, когда она уже существует). С этим параметром данные в таком случае не восстанав-
ливаются. Это поведение полезно, если в целевой таблице уже содержатся нужные данные.
Например, вспомогательные таблицы для расширений PostgreSQL (в частности, PostGIS) могут
быть уже заполнены; этот параметр позволяет предотвратить дублирование или загрузку уста-
ревших данных в эти таблицы.
1822pg_restore
Этот параметр действует только при восстановлении непосредственно в базу данных (не при
генерации SQL-скрипта).
–no-publications
Не выводить команды, восстанавливающие публикации, даже если они содержатся в архиве.
–no-security-labels
Не выводить команды, восстанавливающие метки безопасности, даже если они содержатся в
архиве.
–no-subscriptions
Не выводить команды, восстанавливающие подписки, даже если они содержатся в архиве.
–no-tablespaces
Не формировать команды для указания табличных пространств. Все объекты будут создаваться
в табличном пространстве по умолчанию.
–section=имя секции
Восстановить только указанный раздел. В качестве имени раздела можно задать pre-data, data
или post-data. Указав этот параметр неоднократно, можно выбрать несколько разделов. По
умолчанию восстанавливаются все разделы.
Раздел «data» содержит собственно данные таблиц и определения больших объектов. В разде-
ле «post-data» содержатся определения индексов, триггеров, правил и ограничений (кроме от-
дельно проверяемых). Раздел «pre-data» содержит все остальные определения.
–strict-names
Требует, чтобы каждому указанию схемы (-n/–schema) и таблицы (-t/–table) соответствовала
минимум одна схема/таблица в файле резервной копии.
–use-set-session-authorization
Выводить команды SET SESSION AUTHORIZATION, соответствующие стандарту, вместо ALTER
OWNER, для назначения владельцев объектов. В результате выгруженный скрипт будет более
стандартизированным, но может не восстановиться корректно, в зависимости от истории объ-
ектов.
-?
–help
Показать справку по аргументам командной строки pg_restore и завершиться.
pg_restore также принимает в качестве параметров соединения следующие аргументы командной
строки:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета. Значение по умолчанию берётся из переменной
окружения PGHOST, если она установлена. В противном случае выполняется подключение к
Unix-сокету.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной окружения PGPORT,
если она установлена, либо числом, заданным при компиляции.
1823pg_restore
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как pg_restore запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, pg_restore лишний раз
подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненуж-
ную попытку подключения.
–role=имя роли
Задаёт имя роли, которая будет осуществлять восстановление. Получив это имя, pg_restore вы-
полнит SET ROLE имя_роли после подключения к базе данных. Это полезно, когда проходящий
проверку пользователь (указанный в -U) не имеет прав, необходимых для pg_restore, но может
переключиться на роль, наделённую этими правами. В некоторых окружениях правила запре-
щают подключаться к серверу непосредственно суперпользователю, и этот параметр позволя-
ет выполнить восстановление, не нарушая их.
Переменные окружения
PGHOST
PGOPTIONS
PGPORT
PGUSER
Параметры подключения по умолчанию
Как и большинство других утилит PostgreSQL, эта утилита также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14). Однако она не учитывает PGDATABASE, когда имя базы
не указано.
Диагностика
Когда с параметром -d устанавливается прямое подключение к базе данных, pg_restore выполня-
ет обычные операторы SQL. При этом применяются все свойства подключения по умолчанию и
переменные окружения, которые использует клиентская библиотека libpq. Если вы сталкиваетесь
с проблемами при запуске pg_restore, убедитесь в том, что вы можете получить информацию из
базы данных, используя, например psql.
Замечания
Если в вашей инсталляции база данных template1 содержит какие-либо дополнения, важно убе-
диться в том, что вывод pg_restore загружается в действительно пустую базу; иначе вы, скорее
всего, получите ошибки из-за дублирования определений создаваемых объектов. Чтобы получить
пустую базу данных без дополнительных объектов, выберите в качестве шаблона template0, а не
template1, например так:
CREATE DATABASE foo WITH TEMPLATE template0;
1824pg_restore
Ограничения pg_restore описаны ниже.
• При восстановлении данных в уже существующие таблицы с параметром –disable-triggers,
pg_restore выполняет команды, отключающие триггеры в пользовательских таблицах до до-
бавления данных, а затем, после добавления данных, выполняет команды, снова включающие
эти триггеры. Если восстановление прервётся в середине, системные каталоги могут оказать-
ся в некорректном состоянии.
• Утилита pg_restore не способна восстанавливать большие объекты избирательно; например,
только для определённой таблицы. Если архив содержит большие объекты, они будут восста-
новлены все, либо не будут восстановлены никакие (если они были исключены параметрами -
L, -t и т. п.).
Также обратитесь к документации pg_dump, чтобы узнать о связанных ограничениях pg_dump.
После восстановления имеет смысл запустить ANALYZE для каждой восстановленной таблицы, что-
бы оптимизатор получил актуальную статистику; за дополнительными сведениями обратитесь к
Подразделу 24.1.3 и Подразделу 24.1.6.
Примеры
Предположим, что мы выгрузили базу данных mydb в файл специального формата:
$ pg_dump -Fc mydb &gt; db.dump
Мы можем удалить базу данных и восстановить её из копии:
$ dropdb mydb
$ pg_restore -C -d postgres db.dump
В аргументе -d можно указать любую базу данных, существующую в кластере; pg_restore исполь-
зует её, только чтобы выполнить команду CREATE DATABASE для базы mydb. С параметром -C данные
всегда восстанавливаются в базу, имя которой записано в файле архива.
Восстановить данные в новую базу newdb можно так:
$ createdb -T template0 newdb
$ pg_restore -d newdb db.dump
Обратите внимание, мы не используем параметр -C, а вместо этого подключаемся непосредствен-
но к базе, в которую хотим восстановить данные. Также заметьте, что мы создаём базу данных из
шаблона template0, а не template1, чтобы изначально она была гарантированно пустой.
Чтобы переупорядочить элементы базы данных, сначала необходимо получить оглавление архива:
$ pg_restore -l db.dump &gt; db.list
Файл оглавления содержит заголовок и по одной строке для каждого элемента, например:
;
; Archive created at Mon Sep 14 13:55:39 2009
;
dbname: DBDEMOS
;
TOC Entries: 81
;
Compression: 9
;
Dump Version: 1.10-0
;
Format: CUSTOM
;
Integer: 4 bytes
;
Offset: 8 bytes
;
Dumped from database version: 8.3.5
;
Dumped by pg_dump version: 8.3.8
;
;
; Selected TOC Entries:
;
1825pg_restore
3; 2615 2200 SCHEMA - public pasha
1861; 0 0 COMMENT - SCHEMA public pasha
1862; 0 0 ACL - public pasha
317; 1247 17715 TYPE public composite pasha
319; 1247 25899 DOMAIN public domain0 pasha
С точки с запятой начинаются комментарии, а число в начале строки обозначает внутренний иден-
тификатор, назначаемый каждому элементу в архиве.
Строки в этом файле можно закомментировать, удалить или переместить. Например, список:
10; 145433 TABLE map_resolutions postgres
;2; 145344 TABLE species postgres
;4; 145359 TABLE nt_header postgres
6; 145402 TABLE species_records postgres
;8; 145416 TABLE ss_old postgres
можно передать утилите pg_restore, чтобы восстановить только элементы 10 и 6 в указанном по-
рядке:
$ pg_restore -L db.list db.dump
См. также
pg_dump, pg_dumpall, psql
1826psql
psql — интерактивный терминал PostgreSQL
Синтаксис
psql [параметр…] [имя_бд [имя_пользователя]]
Описание
Программа psql — это терминальный клиент для работы с PostgreSQL. Она позволяет интерактив-
но вводить запросы, передавать их в PostgreSQL и видеть результаты. Также запросы могут быть
получены из файла или из аргументов командной строки. Кроме того, psql предоставляет ряд ме-
такоманд и различные возможности, подобные тем, что имеются у командных оболочек, для об-
легчения написания скриптов и автоматизации широкого спектра задач.
Параметры
-a
–echo-all
Отправляет на стандартный вывод все непустые входные строки по мере их чтения. (Это не
относится к строкам, считанным в интерактивном режиме.) Эквивалентно установке перемен-
ной ECHO в значение all.
-A
–no-align
Переключение на невыровненный режим вывода. (По умолчанию, наоборот, используется вы-
ровненный режим вывода.) Равнозначно команде \pset format unaligned.
-b
–echo-errors
Посылает все команды SQL с ошибками на стандартный вывод. Равнозначно присвоению пере-
менной ECHO значения errors.
-c команда
–command=команда
Передаёт psql команду для выполнения. Этот ключ можно повторять и комбинировать в любом
порядке с ключом -f. Когда указывается -c или -f, psql не читает команды со стандартного
ввода; вместо этого она завершается сразу после обработки всех ключей -c и -f по порядку.
Заданная команда должна быть либо командной строкой, которая полностью интерпретируется
сервером (т. е. не использует специфические функции psql), либо одиночной командой с обрат-
ной косой чертой. Таким образом, используя -c, нельзя смешивать метакоманды SQL и psql.
Но это можно сделать, передав несколько ключей -c или передав строку в psql через канал:
psql -c ‘\x’ -c ‘SELECT * FROM foo;’
или
echo ‘\x \ SELECT * FROM foo;’ | psql
(\ — разделитель метакоманд.)
Каждая строка SQL-команд, заданная ключом -c, передаётся на сервер как один запрос. По-
этому сервер выполняет её в одной транзакции, даже когда эта строка содержит несколько
1827psql
команд SQL, если только в ней не содержатся явные команды BEGIN/COMMIT, разделяющие её
на несколько транзакций. (Подробнее о том, как сервер обрабатывает строки, включающие
несколько команд, рассказывается в Подразделе 53.2.2.1.) Кроме того, psql печатает резуль-
тат только последней SQL-команды в строке. Это отличается от поведения, когда та же строка
считывается из файла или подаётся на стандартный ввод psql, так как в последнем случае psql
передаёт каждую команду SQL отдельно.
Из-за такого поведения указание нескольких SQL-команд в одной строке -c часто приводит к
неожиданным результатам. Поэтому лучше использовать несколько ключей -c или подавать
команды на стандартный ввод psql, применяя либо echo, как показано выше, либо создаваемый
прямо в оболочке текст, например:
psql «EOF
\x
SELECT * FROM foo;
EOF
-d имя_бд
–dbname=имя_бд
Указывает имя базы данных для подключения. Эквивалентно указанию dbname в качестве пер-
вого аргумента, не являющегося параметром в командной строке.
Если этот параметр содержит знак = или начинается с допустимого префикса URI
(postgresql:// или postgres://), он воспринимается как строка conninfo. За дополнительны-
ми сведениями обратитесь к Подразделу 34.1.1.
-e
–echo-queries
Посылает все команды SQL, отправленные на сервер, ещё и на стандартный вывод. Эквивалент-
но установке переменной ECHO в значение queries.
-E
–echo-hidden
Отображает фактические запросы, генерируемые \d и другими командами, начинающимися с
. Это можно использовать для изучения внутренних операций в psql. Эквивалентно установке
переменной ECHO_HIDDEN значения on.
-f имя_файла
–file=имя_файла
Читает команды из файла имя_файла, а не из стандартного ввода. Этот ключ можно повторять
и комбинировать в любом порядке с ключом -c. Если указан ключ -c или -f, программа psql
не читает команды со стандартного ввода; вместо этого она завершается после обработки всех
ключей -c и -f по очереди. Не считая этого, данный ключ по большому счёту равнозначен
метакоманде \i.
Если имя_файла задано символом - (минус), считывается стандартный ввод до признака конца
файла или до метакоманды \q. Это позволяет перемежать интерактивный ввод с вводом из
файлов. Однако заметьте, что Readline в этом случае не применяется (так же, как и с ключом
-n).
Использование этого параметра немного отличается от psql &lt; filename. В основном, оба ва-
рианта будут делать то, что вы ожидаете, но с -f доступны некоторые полезные свойства, та-
кие как сообщения об ошибках с номерами строк. Также есть небольшая вероятность, что за-
пуск в таком режиме будет быстрее. С другой стороны, вариант с перенаправлением ввода из
командного интерпретатора (в теории) гарантирует получение точно такого же вывода, какой
вы получили бы, если бы ввели всё вручную.
1828psql
-F separator
–field-separator=separator
Использование separator в качестве разделителя полей при невыровненном режиме вывода.
Эквивалентно \pset fieldsep или \f.
-h компьютер
–host=компьютер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-H
–html
Включает табличный вывод в формате HTML. Эквивалентно \pset format html или команде \H.
-l
–list
Выводит список всех доступных баз данных и завершает работу. Другие параметры, не связан-
ные с соединением, игнорируются. Это похоже на метакоманду \list.
Когда используется этот аргумент, psql будет подключаться к базе данных postgres, если толь-
ко в командной строке не задана другая база данных (в параметре -d или не через параметры,
а, например, через запись службы, но не через переменную окружения).
-L имя_файла
–log-file=имя_файла
В дополнение к обычному выводу, записывает вывод результатов всех запросов в файл
filename.
-n
–no-readline
Отключает использование Readline для редактирования командной строки и использования
истории команд. Может быть полезно для выключения расширенных действий клавиши табу-
ляции при вырезании и вставке.
-o имя_файла
–output=имя_файла
Записывает вывод результатов всех запросов в файл filename. Эквивалентно команде \o.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения. Значение по умолчанию определяется переменной среды PGPORT, если
она установлена, либо числом, заданным при компиляции, обычно 5432.
-P assignment
–pset=assignment
Задаёт параметры печати, в стиле команды \pset. Обратите внимание, что имя параметра и
значение разделяются знаком равенства, а не пробела. Например, чтобы установить формат
вывода в LaTeX, нужно написать -P format=latex.
-q
–quiet
Указывает, что psql должен работать без вывода дополнительных сообщений. По умолчанию,
выводятся приветствия и различные информационные сообщения. Этого не произойдёт с ис-
1829psql
пользованием данного параметра. Полезно вместе с параметром -c. Этот же эффект можно
получить, установив для переменной QUIET значение on.
-R separator
–record-separator=separator
Использовать разделитель как разделитель записей при невыровненном режиме вывода. Рав-
нозначно команде \pset recordsep.
-s
–single-step
Запуск в пошаговом режиме. Это означает, что пользователь будет подтверждать выполнение
каждой команды, отправляемой на сервер, с возможностью отменить выполнение. Использу-
ется для отладки скриптов.
-S
–single-line
Запуск в однострочном режиме, при котором символ новой строки завершает SQL-команды,
также как это делает точка с запятой.
Примечание
Этот режим реализован для тех, кому он нужен, но это не обязательно означает, что
и вам нужно его использовать. В частности, если смешивать в одной строке команды
SQL и метакоманды, порядок их выполнения может быть не всегда понятен для
неопытного пользователя.
-t
–tuples-only
Отключает вывод имён столбцов и результирующей строки с количеством выбранных записей.
Равнозначно команде \t или \pset tuples_only.
-T table_options
–table-attr=table_options
Задаёт атрибуты, которые будут вставлены в тег HTML table. За подробностями обратитесь к
описанию \pset tableattr.
-U имя_пользователя
–username=имя_пользователя
Подключение к базе данных под пользователем username вместо используемого по умолчанию.
(Разумеется, при наличии прав на это.)
-v assignment
–set=assignment
–variable=assignment
Выполняет присвоение значения переменной, как метакоманда \set. Обратите внимание, что
необходимо разделить имя переменной и значение (при наличии) знаком равенства в команд-
ной строке. Чтобы сбросить переменную, оставьте имя переменной без знака равенства. Что-
бы установить пустое значение, добавьте знак равенства, но опустите значение. Эти присваи-
вания выполняются во время обработки командной строки, так что переменные, отражающие
состояние соединения, будут перезаписаны позже.
-V
–version
Выводит версию psql и завершает работу.
1830psql
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
Обратите внимание, что этот параметр действует на протяжении всей сессии и, таким образом,
влияет на метакоманду \connect, также как и на первую попытку соединения.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как psql запрашивает пароль автоматически, если сервер
проверяет подлинность по паролю. Однако, чтобы понять это, psql лишний раз подключается
к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненужную попытку
подключения.
Обратите внимание, что этот параметр действует на протяжении всей сессии и, таким образом,
влияет на метакоманду \connect, также как и на первую попытку соединения.
-x
–expanded
Включает режим развёрнутого вывода таблицы. Равнозначно команде \x или \pset expanded.
-X,
–no-psqlrc
Не читать стартовые файлы (ни общесистемный файл psqlrc, ни пользовательский файл
~/.psqlrc).
-z
–field-separator-zero
Установить нулевой байт в качестве разделителя полей для невыровненного режима вывода.
Равнозначно команде \pset fieldsep_zero.
-0
–record-separator-zero
Установить нулевой байт в качестве разделителя записей для невыровненного режима вывода.
Это полезно при взаимодействии с другими программами, например, с xargs -0. Равнозначно
команде \pset recordsep_zero.
-1
–single-transaction
Этот параметр может применяться только в сочетании с одним или несколькими параметрами
-c и/или -f. С ним psql выполняет команду BEGIN перед обработкой первого такого параметра и
COMMIT после последнего, заворачивая таким образом все команды в одну транзакцию. Это га-
рантирует, что либо все команды завершатся успешно, либо никакие изменения не сохранятся.
Если в самих этих командах содержатся операторы BEGIN, COMMIT или ROLLBACK, этот параметр
не даст желаемого эффекта. Кроме того, если какая-либо отдельная команда не может выпол-
няться внутри блока транзакции, с этим параметром вся транзакция прервётся с ошибкой.
-?
–help[=тема]
Показать справку по psql и завершиться. Необязательный параметр тема (по умолчанию
options) выбирает описание интересующей части psql: commands описывает команды psql с об-
1831psql
ратной косой чертой; options описывает параметры командной строки, которые можно пере-
дать psql; а variables выдаёт справку по переменным конфигурации psql.
Код завершения
При нормальном завершении psql возвращает 0 в командную оболочку ОС, 1 — если произошла
фатальная ошибка в самом psql (например, нехватка памяти, файл не найден), 2 — при неудачном
соединении с сервером неинтерактивного сеанса, 3 — при ошибке в скрипте и установленной пе-
ременной ON_ERROR_STOP.
Использование
Подключение к базе данных
psql это клиент для PostgreSQL. Для подключения к базе данных нужно знать имя базы данных,
имя сервера, номер порта сервера и имя пользователя, под которым вы хотите подключиться. Эти
свойства можно задать через аргументы командной строки, а именно -d, -h, -p и -U соответствен-
но. Если в командной строке есть аргумент, который не относится к параметрам psql, то он ис-
пользуется в качестве имени базы данных (или имени пользователя, если база данных уже зада-
на). Задавать все эти аргументы необязательно, у них есть разумные значения по умолчанию. Ес-
ли опустить имя сервера, psql будет подключаться через Unix-сокет к локальному серверу, либо
подключаться к localhost по TCP/IP в системах, не поддерживающих UNIX-сокеты. Номер порта
по умолчанию определяется во время компиляции. Поскольку сервер базы данных использует то
же значение по умолчанию, чаще всего указывать номер порта не нужно. Имя пользователя по
умолчанию, как и имя базы данных по умолчанию, совпадает с именем пользователя в операци-
онной системе. Заметьте, что просто так подключаться к любой базе данных под любым именем
пользователя вы не сможете. Узнать о ваших правах можно у администратора баз данных.
Если значения по умолчанию не подходят, можно сэкономить на вводе параметров подключения,
установив переменные среды PGDATABASE, PGHOST, PGPORT и/или PGUSER. (Другие переменные среды
описаны в Разделе 34.14.) Также удобно иметь файл ~/.pgpass, чтобы не вводить пароли снова и
снова. За дополнительными сведениями обратитесь к Разделу 34.15.
Альтернативный вариант указания параметров подключения — использование строки conninfo
или URI вместо имени базы данных. Этот механизм даёт широкие возможности для управления
соединением. Например:
$ psql “service=myservice sslmode=require”
$ psql postgresql://dbmaster:5433/mydb?sslmode=require
Этот способ также позволяет использовать LDAP для получения параметров подключения, как
описано в Разделе 34.17. Более полно все имеющиеся параметры соединения описаны в Подраз-
деле 34.1.2.
Если соединение не может быть установлено по любой причине (например, нет прав, сервер не
работает и т. д.), psql вернёт ошибку и прекратит работу.
Если и стандартный ввод, и стандартный вывод являются терминалом, то psql установит кодировку
клиента в «auto», и подходящая клиентская кодировка будет определяться из локальных установок
(переменная окружения LC_CTYPE в Unix). Если это работает не так, как ожидалось, кодировку
клиента можно изменить, установив переменную окружения PGCLIENTENCODING.
Ввод SQL-команд
Как правило, приглашение psql состоит из имени базы данных, к которой psql в данный момент
подключён, а затем строки =&gt;. Например:
$ psql testdb
psql (11.1)
Type “help” for help.
testdb=&gt;
1832psql
В командной строке пользователь может вводить команды SQL. Обычно введённые строки отправ-
ляются на сервер, когда встречается точка с запятой, завершающая команду. Конец строки не за-
вершает команду. Это позволяет разбивать команды на несколько строк для лучшего понимания.
Если команда была отправлена и выполнена без ошибок, то результат команды выводится на экран.
Если к базе данных, которая не приведена в соответствие шаблону безопасного использования
схем, имеют доступ недоверенные пользователи, начинайте сеанс с удаления доступных им для
записи схем из пути поиска (search_path). Для этого можно добавить options=-csearch_path= в
строку подключения или выполнить команду SELECT pg_catalog.set_config(‘search_path’, ‘’,
false) перед другими командами SQL. Это касается не только psql, но и любых других интерфейсов
для выполнения произвольных SQL-команд.
При каждом выполнении команды psql также проверяет асинхронные уведомления о событиях,
генерируемые командами LISTEN и NOTIFY.
Комментарии в стиле C передаются для обработки на сервер, в то время как комментарии в стан-
дарте SQL psql удаляет перед отправкой.
Метакоманды
Всё, что вводится в psql не взятое в кавычки и начинающееся с обратной косой черты, является
метакомандой psql и обрабатывается самим psql. Эти команды делают psql полезным для задач
администрирования и разработки скриптов.
Формат команды psql следующий: обратная косая черта, сразу за ней команда, затем аргументы.
Аргументы отделяются от команды и друг от друга любым количеством пробелов.
Чтобы включить пробел в значение аргумента, нужно заключить его в одинарные кавычки. Что-
бы включить одинарную кавычку в значение аргумента, нужно написать две одинарные кавычки
внутри текста в одинарных кавычках. Всё, что содержится в одинарных кавычках подлежит заме-
нам, принятым в языке C: \n (новая строка), \t (табуляция), \b (backspace), \r (возврат каретки),
\f (подача страницы), \цифры (восьмеричное число), и \xцифры (шестнадцатеричное число). Если
внутри текста в одинарных кавычках встречается обратная косая перед любым другим символом,
то она экранирует этот символ.
Если внутри аргумента не в кавычках встречается имя переменной psql с предшествующим двоето-
чием (:), оно заменяется значением переменной, как описано в Подразделе «Интерполяция SQL».
Также будут работать описанные там формы :’имя_переменной’ и :”имя_переменной”. Конструк-
ция :(?имя_переменной) позволяет проверить, определена ли переменная. Она заменяется значе-
нием TRUE или FALSE. Экранирование обратной косой чертой защищает двоеточие от замены.
Текст аргумента, заключённый в обратные кавычки (<code class="highlighter-rouge">), считается командной строкой, которая
передаётся в командную оболочку ОС. Вывод от этой команды (с удалёнными в конце символами
новой строки) заменяет текст в обратных кавычках. В содержимом этого текста не обрабатывают-
ся никакие спецпоследовательности или особые знаки, за исключением того, что все вхождения
:имя_переменной, где имя_переменной — это имя переменной psql, заменяются значением этой пе-
ременной. Также вхождения :'имя_переменной' заменяются значением переменной, заключён-
ным в апострофы с тем, что это было одним аргументом команды оболочки. (Последняя форма
почти всегда более предпочтительна, если только вы не абсолютно точно знаете, чего ожидать в
переменной.) Так как символы перевода строки и возврата каретки могут быть надёжно экрани-
рованы не на всех платформах, форма :'variable_name' выводит сообщение об ошибке и подста-
новка значения переменной не производится, когда это значение содержит такие символы.
Некоторые команды принимают идентификатор SQL (например, имя таблицы) в качестве аргу-
мента. Такие аргументы следуют правилам синтаксиса SQL: буквы, не взятые в кавычки, преобра-
зуются в нижний регистр, буквы, взятые в двойные кавычки (") предотвращают преобразование
регистра и позволяют включать пробелы в идентификатор. Внутри двойных кавычек две двойные
кавычки сокращаются до одной. Например, FOO"BAR"BAZ интерпретируется как fooBARbaz, а "A
weird"" name" становится A weird" name.
1833psql
Разбор аргументов останавливается в конце строки или когда встречается другая обратная косая
черта, не внутри кавычек. Обратная косая не внутри кавычек рассматривается как начало новой
метакоманды. Специальная последовательность \\ (две обратных косых черты) обозначает окон-
чание аргументов, далее продолжается разбор команд SQL, если таковые имеются. Таким образом,
команды SQL и psql можно свободно смешивать на одной строке. Но в любом случае, аргументы
метакоманды не могут выходить за пределы текущей строки.
Многие из метакоманд оперируют с буфером текущего запроса. Этот буфер содержит произволь-
ный текст команд SQL, который был введён, но ещё не отправлен серверу для выполнения. В него
будут входить и предыдущие строки, а также текст, расположенный в строке метакоманды перед
ней.
Определены следующие метакоманды:
\a
Если текущий режим вывода таблицы невыровненный, то он переключается на выровненный
режим. Если текущий режим выровненный, то устанавливается невыровненный. Эта команда
поддерживается для обратной совместимости. См. \pset для более общего решения.
\c или \connect [ -reuse-previous=on|off ] [ имя_базы [ имя_пользователя ] [ компьютер
] [ порт ] | строка_подключения ]
Устанавливает новое подключение к серверу PostgreSQL. Параметры подключения можно ука-
зывать как позиционно (в показанном порядке), так и передавая аргумент строка_подключения
(подробнее о строках подключения рассказывается в Подразделе 34.1.1).
Когда в команде опускается имя базы данных, пользователь, компьютер или порт, для ново-
го подключения могут использоваться значения от предыдущего. По умолчанию значения от
предыдущего подключения используются повторно, если только не указывается строка под-
ключения (строка_подключения). Если передать в первом аргументе -reuse-previous=on или
-reuse-previous=off, это поведение переопределяется. Когда в команде не задаётся или не
используется повторно некоторый параметр, применяется значение по умолчанию, принятое
в libpq. Указание в параметре имя_базы, имя_пользователя, компьютер или порт значения - рав-
носильно опущению этого параметра.
Если новое подключение успешно установлено, предыдущее подключение закрывается. Если
попытка подключения не удалась (неверное имя пользователя, доступ запрещён и т. д.), то
предыдущее соединение останется активным, только если psql находится в интерактивном ре-
жиме. Если скрипт выполняется неинтерактивно, обработка немедленно останавливается с со-
общением об ошибке. Различное поведение выбрано для удобства пользователя в качестве за-
щиты от опечаток с одной стороны и в качестве меры безопасности, не позволяющей случайно
запустить скрипты в неправильной базе, с другой.
Примеры:
=&gt;
=&gt;
=&gt;
=&gt;
\c
\c
\c
\c
mydb myuser host.dom 6432
service=foo
"host=localhost port=5432 dbname=mydb connect_timeout=10 sslmode=disable"
postgresql://tom@localhost/mydb?application_name=myapp
\C [ заголовок ]
Задаёт заголовок, который будет выводиться для результатов любых запросов или отменяет
установленный ранее заголовок. Эта команда эквивалентна \pset title title. (Название этой
команды происходит от «caption», так как ранее это использовалось только для задания заго-
ловков HTML таблиц.)
\cd [ каталог ]
Заменяет текущий рабочий каталог на directory. Без аргумента устанавливается домашний
каталог текущего пользователя.
1834psql
Подсказка
для печати текущего рабочего каталога используйте \! pwd.
\conninfo
Выводит информацию о текущем подключении к базе данных.
\copy ( таблица [ ( список_столбцов ) ] | ( запрос ) ) ( from | to ) ( 'имя_файла' |
program 'команда' | stdin | stdout | pstdin | pstdout ) [ [ with ] ( параметр [, ...] ) ]
Производит копирование данных с участием клиента. При этом выполняется SQL-команда
COPY, но вместо чтения или записи в файл на сервере, psql читает или записывает файл и
пересылает данные между сервером и локальной файловой системой. Это означает, что для
доступа к файлам используются привилегии локального пользователя, а не сервера, и не тре-
буются привилегии суперпользователя SQL.
Когда указана program, psql выполняет command и данные из/в command передаются между сер-
вером и клиентом. Это опять же означает, что для выполнения программ используются приви-
легии локального пользователя, а не сервера, и не требуются привилегии суперпользователя
SQL.
При выполнении \copy ... from stdin строки с данными считываются из источника, выпол-
нившего команду, и считываются до тех пор, пока не встретится \. или не будет достигнут ко-
нец файла. Этот параметр полезен для заполнения таблиц прямо в SQL-скриптах. При выпол-
нении \copy ... to stdout вывод направляется в то же место, что и вывод psql команд. Статус
команды COPY count не отображается, чтобы не перепутать со строкой данных. Для чтения/за-
писи стандартного ввода/вывода psql, вне зависимости от источника текущей команды или па-
раметра \o, используйте from pstdin или to pstdout.
Синтаксис команды похож на синтаксис SQL-команды COPY. Все параметры, кроме источника
и получателя данных, задаются так же, как и в COPY. Поэтому при обработке метакоманды
\copy применяются другие правила разбора. В отличие от большинства других метакоманд,
для неё остаток строки всегда воспринимается как аргументы \copy, и в этих аргументах не
выполняется ни подстановка переменных, ни раскрытие обратных кавычек.
Подсказка
Эта операция не так эффективна, как SQL-команда COPY, потому что все данные
перемещаются между клиентом и сервером. Для больших объёмов данных SQL-ко-
манда может быть предпочтительнее.
\copyright
Показывает информацию об авторских правах и условиях распространения PostgreSQL.
\crosstabview [ столбВ [ столбГ [ столбТ [ столбсортГ ] ] ] ]
Выполняет содержимое буфера текущего запроса (как \g) и показывает результат в виде пе-
рекрёстной таблицы. Заданный запрос должен возвращать минимум три столбца. Столбец ре-
зультата, заданный параметром столбВ, будет образовывать вертикальные заголовки, а стол-
бец, заданный параметром столбГ, — горизонтальные. Заданный параметром столбТ столбец
будет поставлять данные для отображения внутри таблицы. Столбец, выбранный параметром
столбсортГ, будет необязательным столбцом сортировки горизонтальных заголовков.
Каждое указание столбца может представлять собой имя или номер столбца (начиная с 1). К
именам применяются обычные принятые в SQL правила учёта регистра и кавычек. По умол-
чанию в качестве столбВ подразумевается столбец 1, а в качестве столбГ — столбец 2. Если
1835psql
столбВ и столбГ задаются явно, они должны различаться. Если столбТ не задан, в результате
запроса должно быть ровно три столбца, и в качестве столбТ выбирается столбец, отличный
от столбВ и столбГ.
Вертикальный заголовок, выводимый в самом левом столбце, содержит значения из столбца
столбВ, в том же порядке, в каком их возвращает запрос, но без дубликатов.
Горизонтальный заголовок, выводимый в первой строке, содержит значения из столбца столбГ,
без дубликатов. По умолчанию они располагаются в том порядке, в каком их возвращает за-
прос. Но если задан необязательный аргумент столбсортГ, он определяет столбец, который
должен содержать целые числа, и тогда значения из столбГ будут располагаться в горизон-
тальном заголовке по порядку значений в столбсортГ.
Внутри перекрёстной таблицы для каждого уникального значения x в столбГ и каждого уни-
кального значения y в столбВ, ячейка, размещённая на пересечении (x,y) содержит значение
столбТ в строке результата запроса, в которой значение столбГ равно x, а значение столбВ — y.
Если такой строки не находится, ячейка остаётся пустой. Если же находится несколько таких
строк, выдаётся ошибка.
\d[S+] [ шаблон ]
Для каждого отношения (таблицы, представления, материализованного представления, индек-
са, последовательности, внешней таблицы) или составного типа, соответствующих шаблону, по-
казывает все столбцы, их типы, табличное пространство (если оно изменено) и любые специ-
альные атрибуты, такие как NOT NULL или значения по умолчанию. Также показываются свя-
занные индексы, ограничения, правила и триггеры. Для сторонних таблиц также показывает-
ся связанный сторонний сервер. («Соответствие шаблону» определяется ниже в Подразделе
«Шаблоны поиска».)
Для некоторых типов отношений \d показывает дополнительную информацию по каждому
столбцу: значения столбца для последовательностей, индексируемые выражения для индексов
и параметры обёртки сторонних данных для сторонних таблиц.
Вариант команды \d+ похож на \d, но выводит больше информации: комментарии к столбцам
таблицы, наличие в таблице OID, для представления показывается его определение, отличные
от значений по умолчанию установки replica identity.
По умолчанию отображаются только объекты, созданные пользователем. Для включения си-
стемных объектов нужно задать шаблон или добавить модификатор S.
Примечание
Если \d используется без аргумента шаблон, эта команда удобства ради воспринима-
ется как \dtvmsE и выдаёт список всех видимых таблиц, представлений, мат. пред-
ставлений, последовательностей и сторонних таблиц.
\da[S] [ шаблон ]
Выводит список агрегатных функций вместе с типом возвращаемого значения и типами дан-
ных, которыми они оперируют. Если указан шаблон, показываются только те агрегатные функ-
ции, имена которых соответствуют ему. По умолчанию показываются только объекты, создан-
ные пользователями. Для включения системных объектов нужно задать шаблон или добавить
модификатор S.
\dA[+] [ шаблон ]
Выводит список методов доступа. Если указан шаблон, показываются только те методы доступа,
имена которых соответствуют ему. При добавлении + к имени команды для каждого метода
доступа показывается его описание и связанная функция-обработчик.
1836psql
\db[+] [ шаблон ]
Выводит список табличных пространств. Если указан шаблон, показываются только те таблич-
ные пространства, имена которых соответствуют ему. При добавлении + к имени команды для
каждого объекта дополнительно выводятся параметры, объём на диске, права доступа и опи-
сание.
\dc[S+] [ шаблон ]
Выводит список преобразований между кодировками наборов символов. Если указан шаблон,
показываются только те преобразования кодировок, имена которых соответствуют ему. По
умолчанию показываются только объекты, созданные пользователями. Для включения систем-
ных объектов нужно задать шаблон или добавить модификатор S. При добавлении + к имени
команды для каждого объекта дополнительно будет выводиться описание.
\dC[+] [ шаблон ]
Выводит список приведений типов. Если указан шаблон, показываются только те приведения
типов, имена которых соответствуют ему. При добавлении + к имени команды для каждого
объекта дополнительно будет выводиться описание.
\dd[S] [ шаблон ]
Показывает описания объектов следующих видов: ограничение, класс операторов, семейство
операторов, правило и триггер. Описания остальных объектов можно посмотреть соответству-
ющими метакомандами для этих типов объектов.
\dd показывает описания для объектов, соответствующих шаблону, или для доступных объектов
указанных типов, если аргументы не заданы. Но в любом случае выводятся только те объекты,
которые имеют описание. По умолчанию показываются только объекты, созданные пользовате-
лями. Для включения системных объектов нужно задать шаблон или добавить модификатор S.
Описания объектов создаются SQL-командой COMMENT.
\dD[S+] [ шаблон ]
Выводит список доменов. Если указан шаблон, показываются только те домены, имена которых
соответствуют ему. По умолчанию показываются только объекты, созданные пользователями.
Для включения системных объектов нужно задать шаблон или добавить модификатор S. При
добавлении + к имени команды для каждого объекта дополнительно будут выводиться права
доступа и описание.
\ddp [ шаблон ]
Выводит список прав доступа по умолчанию. Выводится строка для каждой роли (и схемы, если
применимо), для которой права доступа по умолчанию отличаются от встроенных. Если указан
шаблон, выводятся строки только для тех ролей и схем, имена которых соответствуют ему.
Права доступа по умолчанию устанавливаются командой ALTER DEFAULT PRIVILEGES. Смысл
отображаемых привилегий объясняется в описании GRANT.
\dE[S+]
\di[S+]
\dm[S+]
\ds[S+]
\dt[S+]
\dv[S+]
[
[
[
[
[
[
шаблон
шаблон
шаблон
шаблон
шаблон
шаблон
]
]
]
]
]
]
В этой группе команд буквы E, i, m, s, t и v обозначают соответственно: внешнюю таблицу, ин-
декс, материализованное представление, последовательность, таблицу и представление. Мож-
но указывать все или часть этих букв, в произвольном порядке, чтобы получить список объек-
тов этих типов. Например, \dit выводит список индексов и таблиц. При добавлении + к имени
команды для каждого объекта дополнительно будут выводиться физический размер на диске
1837psql
и описание, при наличии. Если указан шаблон, выводятся только объекты, имена которых соот-
ветствуют ему. По умолчанию показываются только объекты, созданные пользователями. Для
включения системных объектов нужно задать шаблон или добавить модификатор S.
\des[+] [ шаблон ]
Выводит список сторонних серверов (мнемоника: «external servers»). Если указан шаблон, вы-
водятся только те серверы, имена которых соответствуют ему. Если используется форма \des
+, то выводится полное описание каждого сервера, включая права доступа, тип, версию, пара-
метры и описание.
\det[+] [ шаблон ]
Выводит список сторонних таблиц (мнемоника: «external tables»). Если указан шаблон, выводят-
ся только те записи, имя таблицы или схемы которых соответствуют ему. Если используется
форма \det+, то дополнительно выводятся общие параметры и описание сторонней таблицы.
\deu[+] [ шаблон ]
Выводит список сопоставлений пользователей (мнемоника: «external users»). Если указан шаб-
лон, выводятся только сопоставления, в которых имена пользователей соответствуют ему. Ес-
ли используется форма \deu+, то выводится дополнительная информация о каждом сопостав-
лении пользователей.
Внимание
\deu+ также может отображать имя и пароль удалённого пользователя, поэтому
следует позаботиться о том, чтобы не раскрывать их.
\dew[+] [ шаблон ]
Выводит список обёрток сторонних данных (мнемоника: «external wrappers»). Если указан шаб-
лон, выводятся только те обёртки сторонних данных, имена которых соответствуют ему. Если
используется форма \dew+, то дополнительно выводятся права доступа, параметры и описание
обёртки.
\df[anptwS+] [ шаблон ]
Выводит список функций с типами данных их результатов, аргументов и классификацией:
«agg» (агрегатная), «normal», (обычная), «procedure» (процедурная), «trigger» (триггерная) или
«window» (оконная). Чтобы получить функции только определённого вида (видов), добавьте в
команду соответствующие буквы a, n, p, t или w. Если задан шаблон, показываются только те
функции, имена которых соответствуют ему. По умолчанию показываются только функции, со-
зданные пользователями; для включения системных объектов нужно задать шаблон или доба-
вить модификатор S. Если используется форма \df+, то дополнительно выводятся характери-
стики каждой функции: изменчивость, допустимость распараллеливания, владелец, классифи-
кация по безопасности, права доступа, язык, исходный код и описание.
Подсказка
Чтобы найти функции с аргументами или возвращаемыми значениями определён-
ного типа данных, воспользуйтесь имеющейся в постраничнике возможностью по-
иска в выводе \df.
\dF[+] [ шаблон ]
Выводит список конфигураций текстового поиска. Если указан шаблон, показываются только те
конфигурации, имена которых соответствуют ему. Если используется форма \dF+, то выводится
полное описание для каждой конфигурации, включая базовый синтаксический анализатор и
используемые словари для каждого типа фрагментов.
1838psql
\dFd[+] [ шаблон ]
Выводит список словарей текстового поиска. Если указан шаблон, показываются только слова-
ри, имена которых соответствуют ему. Если используется форма \dFd+, то выводится дополни-
тельная информация о каждом словаре, включая базовый шаблон текстового поиска и пара-
метры инициализации.
\dFp[+] [ шаблон ]
Выводит список анализаторов текстового поиска. Если указан шаблон, показываются только
те анализаторы, имена которых соответствуют ему. Если используется форма \dFp+, то выво-
дится полное описание для каждого анализатора, включая базовые функции и список типов
фрагментов.
\dFt[+] [ шаблон ]
Выводит список шаблонов текстового поиска. Если указан шаблон, показываются только шаб-
лоны, имена которых соответствуют ему. Если используется форма \dFt+, то выводится допол-
нительная информация о каждом шаблоне, включая имена основных функций.
\dg[S+] [ шаблон ]
Выводит список ролей базы данных. (Так как понятия «пользователи» и «группы» были объеди-
нены в «роли», эта команда теперь эквивалентна \du.) По умолчанию выводятся только роли,
созданные пользователями: чтобы увидеть и системные роли, добавьте модификатор S. Если
указан шаблон, выводятся только те роли, имена которых соответствуют ему. Если использует-
ся форма \dg+, то выводится дополнительная информация о каждой роли; в настоящее время
это комментарий роли.
\dl
Это псевдоним для \lo_list, показывает список больших объектов.
\dL[S+] [ шаблон ]
Выводит список процедурных языков. Если указан шаблон, выводятся только те языки, имена
которых соответствуют ему. По умолчанию показываются только языки, созданные пользова-
телями. Для включения системных объектов нужно задать шаблон или добавить модификатор
S. При добавлении + к имени команды для каждого языка дополнительно будут выводиться:
обработчик вызова, функция проверки, права доступа и является ли язык системным объектом.
\dn[S+] [ шаблон ]
Выводит список схем (пространств имён). Если указан шаблон, выводятся только те схемы, име-
на которых соответствуют ему. По умолчанию показываются только объекты, созданные поль-
зователями. Для включения системных объектов нужно задать шаблон или добавить модифи-
катор S. При добавлении + к имени команды для каждого объекта дополнительно будут выво-
диться права доступа и описание, при наличии.
\do[S+] [ шаблон ]
Выводит список операторов, их операндов и типы результата. Если указан шаблон, выводятся
только те операторы, имена которых соответствуют ему. По умолчанию показываются только
объекты, созданные пользователями. Для включения системных объектов нужно задать шаб-
лон или добавить модификатор S. При добавлении + к имени команды для каждого оператора
будет выводиться дополнительная информация, сейчас это имя функции, на которой основан
оператор.
\dO[S+] [ шаблон ]
Выводит список правил сортировки. Если указан шаблон, выводятся только те правила, имена
которых соответствуют ему. По умолчанию показываются только объекты, созданные пользо-
вателями. Для включения системных объектов нужно задать шаблон или добавить модифика-
тор S. При добавлении + к имени команды для каждого объекта дополнительно будет выводить-
1839psql
ся описание, при наличии. Обратите внимание, что отображаются только правила сортировки,
применимые к кодировке текущей базы данных, поэтому результат команды может отличаться
для различных баз данных этой же установки PostgreSQL.
\dp [ шаблон ]
Выводит список таблиц, представлений и последовательностей с их правами доступа. Если ука-
зан шаблон, отображаются только таблицы, представления и последовательности, имена кото-
рых соответствуют ему.
Для установки прав доступа используются команды GRANT и REVOKE. Смысл отображаемых
привилегий объясняется в описании GRANT.
\drds [ шаблон-ролей [ шаблон-баз ] ]
Выводит список специфических параметров конфигурации. Эти параметры могут быть специ-
фическими для роли, специфическими для базы данных, или обеих. Параметры шаблон-ролей и
шаблон-баз используются для отбора определённых ролей и баз данных, соответственно. Если
они опущены, или указано *, выводятся все параметры конфигурации, в том числе не относя-
щиеся к ролям или базам данных.
Команды ALTER ROLE и ALTER DATABASE используются для определения параметров конфи-
гурации, специфических для роли или базы данных.
\dRp[+] [ шаблон ]
Выводит список реплицируемых публикаций. Если указан шаблон, выводятся только те подпис-
ки, имена которых соответствуют ему. При добавлении + к имени команды для каждой публи-
кации показываются также связанные с ней таблицы.
\dRs[+] [ шаблон ]
Выводит список подписок на репликацию. Если указан шаблон, выводятся только те подписки,
имена которых соответствуют ему. При добавлении + к имени команды выводятся дополнитель-
ные свойства подписок.
\dT[S+] [ шаблон ]
Выводит список типов данных. Если указан шаблон, выводятся только те типы, имена которых
соответствуют ему. При добавлении + к имени команды для каждого типа данных дополнитель-
но будет выводиться: внутреннее имя типа, размер, допустимые значения для типа enum и права
доступа. По умолчанию показываются только объекты, созданные пользователями. Для вклю-
чения системных объектов нужно задать шаблон или добавить модификатор S.
\du[S+] [ шаблон ]
Выводит список ролей базы данных. (Так как понятия «пользователи» и «группы» были объеди-
нены в «роли», эта команда теперь равнозначна \dg.) По умолчанию выводятся только роли,
созданные пользователями: чтобы увидеть и системные роли, добавьте модификатор S. Если
указан шаблон, выводятся только те роли, имена которых соответствуют ему. Если использует-
ся форма \du+, то выводится дополнительная информация о каждой роли; в настоящее время
это комментарий роли.
\dx[+] [ шаблон ]
Выводит список установленных расширений. Если указан шаблон, выводятся только расшире-
ния, имена которых соответствуют ему. Если используется форма \dx+, то для каждого расши-
рения выводятся все принадлежащие ему объекты.
\dy[+] [ шаблон ]
Выводит список событийных триггеров. Если указан шаблон, выводятся только те событийные
триггеры, имена которых соответствуют ему. При добавлении + к имени команды для каждого
объекта дополнительно будет выводиться описание.
1840psql
\e или \edit [имя_файла] [номер_строки]
Если указано имя_файла, файл открывается для редактирования; после выхода из редактора
содержимое файла копируется в буфер текущего запроса. Если имя_файла не задано, буфер те-
кущего запроса копируется во временный файл, который затем редактируется тем же образом.
Либо, если буфер текущего запроса пуст, во временный файл копируется последний выполнен-
ный запрос, и он затем так же редактируется.
Новое содержимое буфера запроса затем разбирается согласно обычным правилам psql, при
этом весь буфер обрабатывается как одна строка. Все законченные запросы немедленно выпол-
няются; то есть, если буфер запроса содержит точку с запятой или заканчивается ей, выполня-
ется всё его содержимое до этого знака. Оставшийся текст будет ждать выполнения в буфере
запроса; вы можете ввести точку с запятой или \g, чтобы передать его, либо \r, чтобы сбросить
его, очистив буфер запроса. Прочтение буфера как одной строки в основном отражается на
метакомандах: всё, что находится в буфере после метакоманды, будет воспринято как аргумен-
ты метакоманды, даже если этот текст продолжается на нескольких строках. (Поэтому таким
способом нельзя выполнять скрипты с метакомандами. Для таких скриптов используйте \i.)
Если указан номер строки, psql будет позиционировать курсор на указанную строку файла или
буфера запроса. Обратите внимание, что если указан один аргумент и он числовой, psql пред-
полагает, что это номер строки, а не имя файла.
Подсказка
Как настроить редактор и изменить его поведение, рассказывается в разделе «Пе-
ременные окружения».
\echo текст [ ... ]
Выводит аргументы на стандартный вывод, разделяя их одним пробелом, в конце следует пе-
ревод строки. Команда полезна для формирования вывода из скриптов. Например:
=&gt; \echo </code>date`
Tue Oct 26 21:40:57 CEST 1999
Если первый аргумент -n без кавычек, то перевод строки в конце не ставится.
Подсказка
Если используется команда \o для перенаправления вывода запросов, возможно,
следует применять команду \qecho вместо этой.
\ef [описание_функции [номер_строки]]
Эта команда извлекает из базы определение заданной функции или процедуры в форме коман-
ды CREATE OR REPLACE FUNCTION или CREATE OR REPLACE PROCEDURE и открывает его на редак-
тирование. Редактирование осуществляется таким же образом, как и при выполнении \edit.
После выхода из редактора изменённая команда остаётся в буфере запроса; введите точку с
запятой или \g, чтобы отправить её серверу, либо \r, чтобы отменить.
Для функции может быть задано только имя или имя и аргументы, например foo(integer,
text). Типы аргументов необходимы, если существует более чем одна функция с тем же име-
нем.
Если функция не указана, для редактирования открывается пустая заготовка CREATE FUNCTION.
Если указан номер строки, psql будет позиционировать курсор на указанную строку тела функ-
ции. (Обратите внимание, что тело функции обычно не начинается на первой строке файла).
1841psql
В отличие от большинства других метакоманд весь остаток строки всегда воспринимается как
аргументы \ef, и в этих аргументах не выполняется ни подстановка переменных, ни раскрытие
обратных кавычек.
Подсказка
Как настроить редактор и изменить его поведение, рассказывается в разделе «Пе-
ременные окружения».
\encoding [ кодировка ]
Устанавливает кодировку набора символов на клиенте. Без аргумента команда показывает те-
кущую кодировку.
\errverbose
Повторяет последнее серверное сообщение об ошибке с максимальным уровнем детализации,
как если бы переменная VERBOSITY имела значение verbose, а SHOW_CONTEXT — always.
\ev [имя_представления [номер_строки]]
Эта команда извлекает и открывает на редактирование определение указанного представления
в форме команды CREATE OR REPLACE VIEW. Редактирование осуществляется так же, как и с
\edit. После выхода из редактора изменённая команда остаётся в буфере запроса; введите
точку с запятой или \g, чтобы выполнить её, либо \r, чтобы её сбросить.
Если представление не указано, для редактирования открывается пустая заготовка CREATE
VIEW.
Если указан номер строки, psql установит курсор на заданную строку в определении представ-
ления.
В отличие от большинства других метакоманд весь остаток строки всегда воспринимается как
аргументы \ev, и в этих аргументах не выполняется ни подстановка переменных, ни раскрытие
обратных кавычек.
\f [ строка ]
Устанавливает разделитель полей для невыровненного режима вывода запросов. По умолча-
нию используется вертикальная черта (|). Равнозначно команде \pset fieldsep.
\g [ имя_файла ]
\g [ |команда ]
Отправляет содержимое буфера текущего запроса на сервер для выполнения. Если передаётся
аргумент, вывод запроса записывается в указанный файл или передаётся через поток заданной
команде оболочки, а не отображается как обычно. Вывод направляется в файл или команду,
только если запрос успешно вернул 0 или более строк, но не когда запрос завершился неудачно
или выполнялась команда, не возвращающая данные.
Если буфер текущего запроса пуст, вместо этого повторно выполняется предыдущий запрос.
За исключением этой особенности, метакоманда \g без аргумента по сути равнозначна точке
с запятой. Метакоманда \g с аргументом является «одноразовой» альтернативой команде \o.
Если аргумент начинается с |, весь остаток строки воспринимается как команда, подлежащая
выполнению, в которой не производится ни подстановка переменных, ни раскрытие обратных
кавычек. Это продолжение строки просто передаётся оболочке в буквальном виде.
\gdesc
Показывает описание (то есть имена и типы данных столбцов) результата текущего запроса в
буфере. Сам запрос при этом не выполняется; но если он содержит какие-либо синтаксические
ошибки, они выдаются обычным образом.
1842psql
Если буфер текущего запроса пуст, будет повторно описан последний переданный запрос.
\gexec
Отправляет буфер текущего запроса на сервер, а затем обрабатывает содержимое каждого
столбца каждой строки результата запроса (если он непустой) как SQL-оператор, то есть ис-
полняет его. Например, следующая команда создаст индексы по каждому столбцу my_table:
=&gt; SELECT format(‘create index on my_table(%I)’, attname)
-&gt; FROM pg_attribute
-&gt; WHERE attrelid = ‘my_table’::regclass AND attnum &gt; 0
-&gt; ORDER BY attnum
-&gt; \gexec
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE INDEX
Генерируемые запросы выполняются в том порядке, в каком возвращаются строки, слева на-
право, если возвращается несколько столбцов. Поля NULL игнорируются. Эти запросы переда-
ются для обработки на сервер буквально, так что это не могут быть метакоманды psql или за-
просы, использующие переменные psql. В случае сбоя в одном из запросов, выполнение остав-
шихся запросов продолжается, если только не установлена переменная ON_ERROR_STOP. На вы-
полнение каждого запроса оказывает влияние параметр ECHO. (Применяя команду \gexec, ре-
комендуется устанавливать в ECHO режим all или queries.) Такие расширенные средства, как
протоколирование запросов, пошаговый режим, замер времени и т. п., так же действуют при
выполнении каждого генерируемого запроса.
Если буфер текущего запроса пуст, будет повторно выполнен последний переданный запрос.
\gset [ префикс ]
Отправляет буфер текущего запроса на сервер для выполнения и сохраняет результат запроса
в переменных psql (см. Подраздел «Переменные»). Выполняемый запрос должен возвращать
ровно одну строку. Каждый столбец строки результата сохраняется в отдельной переменной,
которая называется так же, как и столбец. Например:
=&gt; SELECT ‘hello’ AS var1, 10 AS var2
-&gt; \gset
=&gt; \echo :var1 :var2
hello 10
Если указан prefix, то он добавляется в начале к именам переменных:
=&gt; SELECT ‘hello’ AS var1, 10 AS var2
-&gt; \gset result_
=&gt; \echo :result_var1 :result_var2
hello 10
Если значение столбца NULL, то вместо присвоения значения соответствующая переменная
удаляется.
Если запрос завершается ошибкой или не возвращает одну строку, то никакие переменные не
меняются.
Если буфер текущего запроса пуст, будет повторно выполнен последний переданный запрос.
\gx [ имя_файла ]
\gx [ |команда ]
Метакоманда \gx подобна \g, но принудительно включает расширенный режим вывода для
текущего запроса. См. \x.
1843psql
\h или \help [ command ]
Выводит подсказку по синтаксису указанной команды SQL. Если command не указана, то psql
выводит список всех команд, для которых доступна справка. Если в качестве command указана
звёздочка (<em>), то выводится справка по всем командам SQL.
В отличие от большинства других метакоманд весь остаток строки всегда воспринимается как
аргументы \help, и в этих аргументах не выполняется ни подстановка переменных, ни раскры-
тие обратных кавычек.
Примечание
Для упрощения ввода команды, состоящие из нескольких слов, можно не заключать
в кавычки. Таким образом, можно просто писать \help alter table.
\H или \html
Включает вывод запросов в формате HTML. Если формат HTML уже включён, происходит пе-
реключение обратно на выровненный формат. Эта команда используется для совместимости и
удобства, но в описании \pset вы можете узнать о других вариантах вывода.
\i или \include имя_файла
Читает ввод из файла имя_файла и выполняет его, как будто он был набран на клавиатуре.
Если имя_файла задано как - (минус), читается стандартный ввод до признака конца файла или
до метакоманды \q. Это может быть полезно для совмещения интерактивного ввода со вводом
команд из файлов. Заметьте, что при этом поведение Readline будет применяться, только если
оно активно на внешнем уровне.
Примечание
Если вы хотите видеть строки файла на экране по мере их чтения, необходимо уста-
новить для переменной ECHO значение all.
\if выражение
\elif выражение
\else
\endif
Эта группа команд реализует вложенные условные блоки. Условный блок должен начинаться
командой \if и заканчиваться \endif. Между ними может быть любое количество предложе-
ний \elif, которые могут быть дополнительно завершаться одним предложением \else. Между
командами, формирующими блок условия, могут размещаться (и обычно размещаются) обыч-
ные запросы и другие типы команд в обратных кавычках.
Команды \if и \elif считывают свои аргументы и вычисляют их как логические выражения.
Если выражение выдаёт true, обработка продолжается как обычно; в противном случае вход-
ные строки пропускаются до достижения соответствующих команд \elif, \else или \endif.
Как только проверка \if или \elif оказывается успешной, аргументы последующих команд
\elif в том же блоке не вычисляются, а считаются ложными. Строки, следующие за \else, об-
рабатываются только если ни одна из предыдущих проверок \if или \elif не была успешной.
В аргументе выражение команд \if и \elif производится подстановка переменных и раскрытие
кавычек, как и в аргументе любой другой команды с обратной косой. После этого полученное
значение оценивается как значение переменной да/нет. Так что истинным значением будет
любое однозначное вхождение без учёта регистра одной из строк (или подстрок): true, false,
1, 0, on, off, yes, no. Например, строки t, T и tR все будут восприниматься как true.
1844psql
Если выражения не приводятся к значениям true или false, будет выдано предупреждение, а
их результат будет считаться ложным.
Пропускаемые строки разбираются как обычно (в них выявляются запросы и команды с обрат-
ной косой), но не передаются серверу, а команды с обратной косой, отличные от условных (\if,
\elif, \else, \endif), просто игнорируются. В командах условий проверяется только правиль-
ность вложенности. Ссылки на переменные в пропускаемых строках не разворачиваются, как
не выполняется и раскрытие обратных кавычек.
Все команды с обратной косой в одном условном блоке должны содержаться в одном исходном
файле. Если до того, как будут закрыты все локальные блоки \if, в основном файле команд
будет достигнут конец файла или встретится включение другого файла (команда \include),
psql выдаст ошибку.
Например:
– проверка существования двух отдельных записей в базе данных и сохранение
– результатов в двух разных переменных psql
SELECT
EXISTS(SELECT 1 FROM customer WHERE customer_id = 123) as is_customer,
EXISTS(SELECT 1 FROM employee WHERE employee_id = 456) as is_employee
\gset
\if :is_customer
SELECT * FROM customer WHERE customer_id = 123;
\elif :is_employee
\echo ‘is not a customer but is an employee’
SELECT * FROM employee WHERE employee_id = 456;
\else
\if yes
\echo ‘not a customer or employee’
\else
\echo ‘this will never print’
\endif
\endif
\ir или \include_relative filename
Команда \ir похожа на \i, но по-разному интерпретирует относительные имена файлов. При
выполнении в интерактивном режиме две команды ведут себя одинаково. Однако, при вызове
из скрипта \ir интерпретирует имена файлов относительно каталога, в котором расположен
скрипт, а не текущего рабочего каталога.
\l[+] или \list[+] [ шаблон ]
Выводит список баз данных на сервере и показывает их имена, владельцев, кодировку набо-
ра символов и права доступа. Если указан шаблон, выводятся только базы данных, имена кото-
рых соответствуют ему. При добавлении + к имени команды также отображаются: размер базы
данных, табличное пространство по умолчанию и описание. (Информация о размере доступна
только для баз данных, к которым текущий пользователь может подключиться.)
\lo_export oid_БО имя_файла
Читает большой объект с OID loid из базы данных и записывает его в файл имя_файла. Обратите
внимание, что это несколько отличается от функции сервера lo_export, которая действует с
правами пользователя, от имени которого работает сервер базы данных, и в файловой системе
сервера.
Подсказка
Используйте \lo_list для получения OID больших объектов.
1845psql
\lo_import имя_файла [ комментарий ]
Сохраняет файл в большом объекте PostgreSQL. При этом с объектом может быть связан ука-
занный комментарий. Пример:
foo=&gt; \lo_import ‘/home/peter/pictures/photo.xcf’ ‘a picture of me’
lo_import 152801
Ответ указывает на то, что большой объект получил OID 152801, который может быть исполь-
зован для доступа к вновь созданному объекту в будущем. Для удобства чтения рекомендуется
всегда связывать объекты с понятными комментариями. OID и комментарии можно посмотреть
с помощью команды \lo_list.
Обратите внимание, что это немного отличается от функции сервера lo_import, так как дей-
ствует от имени локального пользователя в локальной файловой системе, а не пользователя
сервера в файловой системе сервера.
\lo_list
Показывает список всех больших объектов PostgreSQL, хранящихся в базе данных, вместе с
предоставленными комментариями.
\lo_unlink oid_БО
Удаляет большой объект с OID loid из базы данных.
Подсказка
Используйте \lo_list для получения OID больших объектов.
\o или \out [ имя_файла ]
\o или \out [ |команда ]
Результаты запросов будут сохраняться в файле имя_файла или перенаправляться команде обо-
лочки (заданной аргументом команда). Если аргумент не указан, результаты запросов перена-
правляются на стандартный вывод.
Если аргумент начинается с |, весь остаток строки воспринимается как команда, подлежащая
выполнению, в которой не производится ни подстановка переменных, ни раскрытие обратных
кавычек. Это продолжение строки просто передаётся оболочке в буквальном виде.
«Результаты запросов» включают в себя все таблицы, ответы команд, уведомления, полученные
от сервера баз данных, а также вывод от метакоманд, обращающихся к базе (таких как \d), но
не сообщения об ошибках.
Подсказка
Чтобы вставить текст между результатами запросов, используйте \qecho.
\p или \print
Печатает содержимое буфера текущего запроса на стандартный вывод. Если этот буфер пуст,
будет напечатан последний выполненный запрос.
\password [ имя_пользователя ]
Изменяет пароль указанного пользователя (по умолчанию, текущего пользователя). Эта коман-
да запрашивает новый пароль, шифрует и отправляет его на сервер в виде команды ALTER ROLE.
Это гарантирует, что новый пароль не отображается в открытом виде в истории команд, жур-
нале сервера или в другом месте.
1846psql
\prompt [ текст ] имя
Предлагает пользователю ввести значение, которое будет присвоено переменной имя. Допол-
нительно можно указать подсказку text. (Если подсказка состоит из нескольких слов, то её
текст нужно взять в одинарные кавычки).
По умолчанию, \prompt использует терминал для ввода и вывода. Однако, если используется
параметр командной строки -f, \prompt использует стандартный ввод и стандартный вывод.
\pset [ параметр [ значение ] ]
Эта команда устанавливает параметры, влияющие на вывод результатов запросов. option ука-
зывает, какой параметр необходимо установить. Семантика value меняется в зависимости от
выбранного параметра. Для некоторых параметров, отсутствие value означает переключение
значения, либо сброс значения, как описано ниже в разделе конкретного параметра. Если та-
кое поведение не упоминается, то пропуск value приводит к отображению текущего значения
параметра.
\pset без аргументов выводит текущий статус всех параметров команды.
Имеются следующие параметры:
border
Здесь значение должно быть числом. В целом, чем больше это число, тем больше границ и
линий будет в таблицах, но детали зависят от формата. В формате HTML заданное значение
напрямую отображается в атрибут border=…. Для большинства других форматов имеют
смысл только значения 0 (нет границы), 1 (внутренние разделительные линии) и 2 (граница
таблицы), а значения больше 2 воспринимаются как border = 2. Форматы latex и latex-
longtable дополнительно поддерживают значение 3, добавляющее разделительные линии
между строками данных.
columns
Устанавливает максимальную ширину для формата wrapped, а также ограничение по шири-
не, свыше которого будет требоваться постраничник или произойдёт переключение в вер-
тикальное отображение при режиме expanded auto. При значении 0 (по умолчанию) макси-
мальная ширина управляется переменной среды COLUMNS или шириной экрана, если COLUMNS
не установлена. Кроме того, если columns равно нулю, то формат wrapped влияет только на
вывод на экран. Если columns не равно 0, то это также влияет на вывод в файл или в другую
команду через канал.
expanded (или x)
Указанное значение допускает варианты on или off, которые включают или отключают
развёрнутый режим, либо auto. Если значение опущено, команда включает/отключает ре-
жим. Когда развёрнутый режим включён, результаты запроса выводятся в две колонки: имя
столбца в левой, данные в правой. Этот режим полезен, если данные не помещаются на
экране в обычном «горизонтальном» режиме. При выборе auto развёрнутый режим исполь-
зуется, когда результат запроса содержит несколько столбцов и по ширине не умещается
на экране; в противном случае используется обычный режим. Режим auto распространя-
ется только на форматы aligned и wrapped. С другими форматами он всегда равнозначен
отключённому состоянию.
fieldsep
Устанавливает разделитель полей для невыровненного режима вывода запросов. Таким об-
разом, можно формировать вывод, в котором значения будут разделены табуляцией или за-
пятыми. Это может быть предпочтительным для использования в других программах. Для
установки символа табуляции в качестве разделителя полей, введите \pset fieldsep ‘\t’.
По умолчанию используется вертикальная черта (‘|’).
1847psql
fieldsep_zero
Устанавливает разделитель полей для невыровненного режима вывода в нулевой байт.
footer
Для value возможны два значения: on или off, которые включают или отключают вывод
результирующей строки с количеством выбранных записей (n строк). Если value не ука-
зано, то команда переключает текущее значение в on или off.
format
Устанавливает один из следующих форматов вывода: unaligned, aligned, wrapped, html,
asciidoc, latex (использует tabular), latex-longtable или troff-ms. Допускается сокра-
щение слова до уникального значения. (Это значит, что одной буквы будет достаточно.)
В формате unaligned все столбцы размещаются на одной строке и отделяются друг от друга
разделителем полей. Это полезно для создания вывода, который будет читаться другими
программами (например, формат с выводом значений, разделённых запятыми или табуля-
цией).
Формат aligned это стандартный, удобочитаемый, хорошо отформатированный текстовый
вывод. Используется по умолчанию.
Формат wrapped похож на aligned, но переносит длинные значения столбцов на новые стро-
ки, чтобы общий вывод поместился в заданную ширину. Задание ширины вывода описано
в параметре columns. Обратите внимание, что psql не будет пытаться переносить на новые
строки заголовки столбцов. Поэтому формат wrapped работает так же, как aligned если об-
щая ширина, требуемая для всех заголовков столбцов, превышает установленную макси-
мальную ширину.
Форматы html, asciidoc, latex, latex-longtable и troff-ms выводят таблицы, которые
предназначены для включения в документы с помощью соответствующего языка разметки.
Они не являются полноценными документами! Возможно это необязательно в HTML, но в
LaTeX необходимо иметь полный упаковщик документа. latex-longtable также требует на-
личия пакетов LaTeX longtable и booktabs.
linestyle
Задаёт стиль отрисовки линий границы: ascii, old-ascii или unicode. Допускается сокра-
щение слова до уникального значения. (Это значит, что одной буквы будет достаточно.) Зна-
чение по умолчанию: ascii. Этот параметр действует только в форматах aligned и wrapped.
Стиль ascii использует обычные символы ASCII. Символы новой строки в данных показы-
ваются с использованием символа + в правом поле. Когда при формате wrapped происходит
перенос данных на новую строку (без символа новой строки), ставится точка (.) в правом
поле первой строки и точка в левом поле следующей строки.
Стиль old-ascii использует обычные символы ASCII в стиле PostgreSQL 8.4 и раньше. Сим-
волы новой строки в данных отображаются, используя символ : вместо левого разделителя
полей. Когда происходит перенос данных на новую строку без символа новой строки, сим-
вол ; используется вместо левого разделителя полей.
Стиль unicode использует символы Юникода для рисования линий. Символы новой строки в
данных показываются с использованием символа возврата каретки в правом поле. Когда при
формате wrapped происходит перенос данных на новую строку (без символа новой строки),
ставится символ многоточия в правом поле первой строки и в левом поле следующей строки.
Когда значение border больше нуля, параметр linestyle также определяет символы, ко-
торыми будут рисоваться границы. Обычные символы ASCII работают везде, но символы
Юникода смотрятся лучше на терминалах, распознающих их.
1848psql
null
Устанавливает строку, которая будет напечатана вместо значения null. По умолчанию не
печатается ничего, что можно ошибочно принять за пустую строку. Например, можно было
бы предпочесть \pset null ‘(null)’.
numericlocale
Если задаётся значение, возможны два варианта: on или off, которые включают или отклю-
чают отображение специфичного для локали символа, разделяющего группы цифр левее
десятичной точки. Если значение не указано, то команда переключает вывод чисел с лока-
лизованного на обычный и обратно.
pager
Управляет использованием постраничника для просмотра результатов запросов и справоч-
ной информации psql. Если установлена переменная среды PSQL_PAGER или PAGER, вывод
передаётся указанной программе. В противном случае используется платформозависимая
программа по умолчанию (например, more).
Если pager имеет значение off, программа постраничного просмотра (постраничник) не
используется. Если pager имеет значение on, эта программа используется при необходимо-
сти, т. е. когда вывод на терминал не помещается на экране. Параметр pager также может
иметь значение always, при этом постраничник будет использоваться всегда, независимо
от того, помещается вывод на экран терминала или нет. Команда \pset pager без указания
значения переключает варианты on и off.
pager_min_lines
Если в pager_min_lines задаётся число, превышающее высоту страницы, программа по-
страничного вывода не будет вызываться, пока не наберётся заданное число строк для вы-
вода. Значение по умолчанию — 0.
recordsep
Устанавливает разделитель записей (строк) для невыровненного режима вывода. По умол-
чанию используется символ новой строки.
recordsep_zero
Устанавливает разделитель записей для невыровненного режима вывода в нулевой байт.
tableattr (или T)
Устанавливает атрибуты, которые будут помещены в тег table, при формате вывода HTML.
Например, это может быть cellpadding или border. Заметьте, что, вероятно, не нужно здесь
задавать border, так как для этого уже есть \pset border. Если value не задано, атрибуты
таблицы удаляются.
В формате latex-longtable этот параметр контролирует пропорциональную ширину каж-
дого столбца, данные которого выровнены по левому краю. Он указывается как список раз-
делённых пробелами значений, например ‘0.2 0.2 0.6’. Для неуказанных столбцов ис-
пользуется последнее из заданных значений.
title (или C)
Устанавливает заголовок таблицы для любых впоследствии выводимых таблиц. Это можно
использовать для задания описательных тегов при формировании вывода. Если value не
задано, заголовок таблицы удаляется.
tuples_only (или t)
Для value возможны два значения: on или off, которые включают или отключают режим
вывода только кортежей. Если value не указано, то команда переключает с режима вывода
1849psql
только кортежей на обычный режим и обратно. Обычный вывод включает в себя дополни-
тельную информацию, такую как заголовки столбцов и различные колонтитулы. В режиме
вывода только кортежей отображаются только фактические табличные данные.
unicode_border_linestyle
Устанавливает стиль рисования границ для стиля линий unicode: single (одинарный) или
double (двойной).
unicode_column_linestyle
Устанавливает стиль рисования колонок для стиля линий unicode: single (одинарный) или
double (двойной).
unicode_header_linestyle
Устанавливает стиль рисования заголовка для стиля линий unicode: single (одинарный)
или double (двойной).
Иллюстрацию того, как могут выглядеть различные форматы, можно увидеть в разделе «При-
меры».
Подсказка
Для некоторых параметров \pset есть короткие команды. См. \a, \C, \f, \H, \t, \T
и \x.
\q или \quit
Выход из psql. При использовании в скрипте прекращается только выполнение этого скрипта.
\qecho текст [ … ]
Эта команда идентична \echo за исключением того, что вывод будет записываться в канал
вывода запросов, установленный \o.
\r или \reset
Сбрасывает (очищает) буфер запроса.
\s [ имя_файла ]
Записывает историю команд psql в файл имя_файла. Если имя_файла не указано, то история
команд выводится на стандартный вывод (с использованием постраничника, когда уместно).
Этот параметр недоступен, если psql был собран без поддержки Readline.
\set [ имя [ значение [ … ] ] ]
Задаёт для переменной psql имя указанное значение или, если указано несколько значений,
все эти значения, соединённые вместе. Если присутствует только один аргумент, значением
переменной становится пустая строка. Для сброса переменной используйте команду \unset.
\set без аргументов выводит имена и значения всех psql переменных, установленных в насто-
ящее время.
Имена переменных могут содержать буквы, цифры и знаки подчёркивания. Подробнее см. раз-
дел «Переменные» ниже. Имена переменных чувствительны к регистру.
Некоторые переменные имеют особенности в том, как они управляют поведением psql или ав-
томатически устанавливаются, отражая состояние соединения. Эти переменные документиро-
ваны ниже, в Подразделе «Переменные».
1850psql
Примечание
Эта команда не имеет отношения к SQL-команде SET.
\setenv имя [ значение ]
Задаёт для переменной среды name значение value или, если value не задано, удаляет пере-
менную среды. Пример:
testdb=&gt; \setenv PAGER less
testdb=&gt; \setenv LESS -imx4F
\sf[+] описание_функции
Эта команда извлекает из базы и выводит определение заданной функции или процедуры в
форме команды CREATE OR REPLACE FUNCTION или CREATE OR REPLACE PROCEDURE. Определение
выдаётся в текущий канал вывода запроса, установленный \o.
Для функции может быть задано только имя или имя и аргументы, например foo(integer,
text). Типы аргументов необходимы, если существует более чем одна функция с тем же име-
нем.
При добавлении + к имени команды строки вывода нумеруются, первая строка тела функции
получит номер 1.
В отличие от большинства других метакоманд весь остаток строки всегда воспринимается как
аргументы \sf, и в этих аргументах не выполняется ни подстановка переменных, ни раскрытие
обратных кавычек.
\sv[+] имя_представления
Извлекает из базы данных и выводит определение указанного представления в форме команды
CREATE OR REPLACE VIEW. Определение выводится в текущий канал вывода запросов, установ-
ленный \o.
При добавлении + к имени команды строки вывода нумеруются, начиная с 1.
В отличие от большинства других метакоманд весь остаток строки всегда воспринимается как
аргументы \sv, и в этих аргументах не выполняется ни подстановка переменных, ни раскрытие
обратных кавычек.
\t
Включает/выключает отображение имён столбцов и результирующей строки с количеством вы-
бранных записей для запросов. Эта команда эквивалентна \pset tuples_only и предоставлена
для удобства.
\T table_options
Устанавливает атрибуты, которые будут помещены в тег table при формате вывода HTML. Эта
команда эквивалентна \pset tableattr table_options.
\timing [ on | off ]
С параметром данная команда, в зависимости от него, включает/отключает отображение вре-
мени выполнения каждого SQL-оператора. Без параметра она меняет состояние отображения
на противоположное. Время выводится в миллисекундах; интервалы больше 1 секунды выво-
дятся в формате минуты:секунды, а при необходимости в вывод также добавляются часы и дни.
\unset имя
Удаляет psql переменную name.
1851psql
Большинство переменных, управляющих поведением psql, нельзя сбросить; команда \unset для
них воспринимается как установка значений по умолчанию. См. Подраздел «Переменные» ни-
же.
\w или \write filename
\w или \write |command
Выводит буфер текущего запроса в файл имя_файла или через канал в команду оболочки ко-
манда. Если этот буфер пуст, будет выведен последний выполненный запрос.
Если аргумент начинается с |, весь остаток строки воспринимается как команда, подлежащая
выполнению, в которой не производится ни подстановка переменных, ни раскрытие обратных
кавычек. Это продолжение строки просто передаётся оболочке в буквальном виде.
\watch [ секунды ]
Эта команда многократно выполняет текущий запрос в буфере (как \g), пока не будет прервана
или не возникнет ошибка. Аргумент задаёт количество секунд ожидания между выполнениями
запроса (по умолчанию 2). Результат каждого запроса выводится с заголовком, включающим
строку \pset title (если она задана), время запуска запроса и интервал задержки.
Если буфер текущего запроса пуст, будет повторно выполнен последний переданный запрос.
\x [ on | off | auto ]
Устанавливает или переключает режим развёрнутого вывода таблицы. Это эквивалентно \pset
expanded.
\z [ шаблон ]
Выводит список таблиц, представлений и последовательностей с их правами доступа. Если ука-
зан шаблон, отображаются только таблицы, представления и последовательности, имена кото-
рых соответствуют ему.
Это псевдоним для \dp («показать права доступа»).
! [ команда ]
Без аргументов запускает подчинённую оболочку; когда эта оболочка завершается, psql про-
должает работу. Если добавлен аргумент, запускает команду оболочки команда.
В отличие от большинства других метакоманд весь остаток строки всегда воспринимается как
аргументы !, и в этих аргументах не выполняется ни подстановка переменных, ни раскрытие
обратных кавычек. Этот текст просто передаётся оболочке в буквальном виде.
\? [ тема ]
Показывает справочную информацию. Необязательный параметр тема (по умолчанию
commands) выбирает описание интересующей части psql: commands описывает команды psql с
обратной косой чертой; options описывает параметры командной строки, которые можно пе-
редать psql; а variables выдаёт справку по переменным конфигурации psql.
\;
Точка с запятой после косой черты не является метакомандой в том смысле, что предыдущие;
при её вводе в буфер просто добавляется точка с запятой без обработки.
Обычно psql передаёт SQL-команду серверу, как только встречает завершающую команду точ-
ку с запятой, даже если текущая строка на этом не заканчивается. Так, например, при вводе
select 1; select 2; select 3;
на сервер по отдельности будут переданы три SQL-команды, и результат каждой команды будет
выведен перед переходом к следующей. Однако если точка с запятой вводится как \;, команда
не передаётся на обработку, так что команды до и после этих символов по сути объединяются
и передаются серверу в одном запросе. Поэтому, например, при выполнении
1852psql
select 1\; select 2\; select 3;
серверу передаются сразу три SQL-команды при достижении неэкранированной точки с запя-
той. Сервер выполняет такой запрос как одну транзакцию, если только в строку не включены
явные команды BEGIN/COMMIT, которые разделят её на несколько транзакций. (Подробнее о том,
как сервер обрабатывает строки, включающие несколько команд, рассказывается в Подразде-
ле 53.2.2.1.) psql выводит результат только последнего запроса из всей строки. Так, в послед-
нем примере psql выводит только 3, хотя на самом деле выполнялись все три команды.
Шаблоны поиска
Различные \d команды принимают параметр pattern для указания имени (имён) объектов для
отображения. В простейшем случае шаблон - это точное имя объекта. Символы внутри шаблона
обычно приводятся к нижнему регистру, как и для имён SQL-объектов; к примеру \dt FOO выво-
дит таблицу с именем foo. Как и для SQL имён, двойные кавычки вокруг шаблона предотвраща-
ют перевод в нижний регистр. Для включения символа двойной кавычки в шаблон используются
два символа двойных кавычек подряд внутри шаблона в двойных кавычках. Опять же, это соответ-
ствует правилам для SQL-идентификаторов. Например \dt “FOO”“BAR” будет выводить таблицу с
именем FOO”BAR (но не foo”bar). В отличие от обычных правил для SQL-имён, можно взять в двой-
ные кавычки только часть шаблона, например \dt FOO”FOO”BAR будет выводить таблицу с именем
fooFOObar.
Если pattern вообще не указан, \d команды выводят все объекты, видимые для текущей схемы. Это
эквивалентно указанию * в качестве шаблона. (Объект считается видимым, если схема, в которой
он находится, лежит на пути поиска, и объект с таким типом и именем на пути поиска ещё не
появлялся. Это эквивалентно утверждению, что на объект можно ссылаться по имени, без явного
указания схемы.) Чтобы увидеть все объекты в базе данных, независимо от видимости, в качестве
шаблона используется *.</em>.
Внутри шаблона * обозначает любое количество символов, включая отсутствие символов. ? соот-
ветствует любому одному символу. (Это соответствует шаблонам имён файлов в Unix.) Например,
\dt int* отображает все таблицы, имена которых начинаются на int. Однако внутри двойных ка-
вычек * и ? теряют своё специальное значение и становятся обычными символами.
Шаблон, содержащий точку (.), интерпретируется как шаблон имени схемы, за которым следует
шаблон имени объекта. Например, \dt foo<em>.</em>bar* отображает все таблицы, имена которых вклю-
чают bar, и расположенные в схемах, имена которых начинаются с foo. Шаблону, не содержаще-
му точку, могут соответствовать только объекты текущей схемы. Опять же, точка внутри двойных
кавычек теряет своё специальное значение.
Опытные пользователи могут использовать возможности регулярных выражений, такие как клас-
сы символов. Например [0-9] соответствует любой цифре. Все специальные символы регулярных
выражений работают как описано в Подразделе 9.7.3, за исключением: . используется в качестве
разделителя, как говорилось выше; * соответствует регулярному выражению .<em>; ? соответствует
., а также символ $, который не имеет специального значения. При необходимости эти символы
можно эмулировать указывая ? для эмуляции ., (R+|) для R</em>, (R|) для R?. $ не требуется, как
символ регулярного выражения, потому что шаблон должен соответствовать имени целиком, в от-
личие от обычной интерпретации регулярных выражений (другими словами, $ автоматически до-
бавляется в шаблон). Используйте * в начале и/или в конце, если не хотите, чтобы шаблон закреп-
лялся. Обратите внимание, что внутри двойных кавычек, все специальные символы регулярных
выражений теряют своё специальное значение и соответствуют сами себе. Также, специальные
символы регулярных выражений не действуют в шаблонах для имён операторов (т. е. в аргументе
команды \do).
Расширенные возможности
Переменные
psql предоставляет возможности подстановки переменных подобные тем, что используются в ко-
мандных оболочках Unix. Переменные представляют собой пары имя/значение, где значением мо-
1853psql
жет быть любая строка любой длины. Имя должно состоять из букв (включая нелатинские буквы),
цифр и знаков подчёркивания.
Чтобы установить переменную, используется метакоманда psql \set. Например:
testdb=&gt; \set foo bar
присваивает переменной foo значение bar. Чтобы получить значение переменной, нужно поста-
вить двоеточие перед её именем, например:
testdb=&gt; \echo :foo
bar
Это работает как в обычных SQL-командах, так и в метакомандах; подробности в разделе «Интер-
поляция SQL» ниже.
При вызове \set без второго аргумента переменной присваивается пустая строка. Для сброса (то
есть удаления) переменной используйте команду \unset. Чтобы посмотреть значения всех пере-
менных, вызовите \set без аргументов.
Примечание
На аргументы \set распространяются те же правила подстановки, что и для других
команд. Таким образом можно создавать интересные ссылки, например \set :foo
‘something’, получая «мягкие ссылки» в Perl или «переменные переменных» в PHP.
К сожалению (или к счастью?), с этими конструкциями нельзя сделать ничего полез-
ного. С другой стороны, \set bar :foo является прекрасным способом копирования
переменной.
Некоторые переменные обрабатываются в psql особым образом. Они представляют собой опреде-
лённые параметры, которые могут быть изменены во время выполнения путём присваивания но-
вого значения, а в некоторых переменных содержится изменяемое состояние psql. По соглаше-
нию, имена специальных переменных состоят только из заглавных ASCII-букв (и, возможно, цифр и
знаков подчёркивания). Для максимальной совместимости в будущем старайтесь не использовать
такие имена для собственных переменных.
Переменные, управляющие поведением psql, обычно нельзя сбросить или задать для них недопу-
стимые значения. Команда \unset для них допускается, но воспринимается как установка значе-
ния по умолчанию. Команда \set без второго аргумента воспринимается как присвоение перемен-
ной значения on, для управляющих переменных, принимающих это значение, и не принимается
для других. Также управляющие переменные, принимающие значения on и off, примут и другие
общепринятые написания логических значений, например true и false.
Специальные переменные:
AUTOCOMMIT
При значении on (по умолчанию) после каждой успешно выполненной команды выполняется
фиксация изменений. Чтобы отложить фиксацию изменений в этом режиме, нужно выполнить
SQL-команду BEGIN или START TRANSACTION. При значении off или если переменная не опреде-
лена, фиксация изменений не происходит до тех пор, пока явно не выполнена команда COMMIT
или END. При значении off неявно выполняется BEGIN непосредственно перед любой командой,
за исключением случаев когда: команда уже в транзакционном блоке; перед самой командой
BEGIN или другой командой управления транзакциями; перед командой, которая не может вы-
полняться внутри транзакционного блока (например VACUUM).
Примечание
Если режим autocommit отключён, необходимо явно откатывать изменения в
неуспешных транзакциях, выполняя команду ABORT или ROLLBACK. Также имейте в
1854psql
виду, что при выходе из сессии без фиксации изменений несохранённые изменения
будут потеряны.
Примечание
Включённый режим autocommit является традиционным для PostgreSQL, а выклю-
ченный режим ближе к спецификации SQL. Если вы предпочитаете отключить ре-
жим autocommit, это можно сделать в общесистемном файле psqlrc или в персо-
нальном файле ~/.psqlrc.
COMP_KEYWORD_CASE
Определяет, какой регистр букв будет использован при автоматическом завершении ключевых
слов SQL. Если установлено в lower или upper, будет использоваться нижний или верхний ре-
гистр соответственно. Если установлено в preserve-lower или preserve-upper (по умолчанию),
то завершаемое слово будет в том же регистре, что и уже введённое начало слова, но последу-
ющие слова, завершаемые полностью, будут в нижнем или верхнем регистре соответственно.
DBNAME
Имя базы данных, к которой вы сейчас подключены. Устанавливается всякий раз при подклю-
чении к базе данных (в том числе при старте программы), но эту переменную можно изменить
или сбросить.
ECHO
Со значением all все непустые входящие строки выводятся на стандартный вывод по мере их
чтения. (Это не относится к строкам, считываемым интерактивно.) Чтобы выбрать такое пове-
дение при запуске программы, добавьте ключ -a. Со значением queries psql выводит каждый
запрос, отправляемый серверу, на стандартный вывод. Этому значению соответствует ключ
-e. Со значением errors в стандартный канал ошибок выдаются только запросы, вызвавшие
ошибки. Ему соответствует ключ -b. Со значением none (по умолчанию), никакие запросы не
выводятся.
ECHO_HIDDEN
Если эта переменная имеет значение on и метакоманда обращается к базе данных, снача-
ла выводится текст нижележащего запроса. Это помогает изучать внутреннее устройство
PostgreSQL и реализовывать похожую функциональность в своих программах. (Чтобы включить
такое поведение при запуске программы, воспользуйтесь ключом -E.) Если вы зададите для
этой переменной значение noexec, запросы будут просто показываться, но не будут отправ-
ляться на сервер и выполняться. Значение по умолчанию — off.
ENCODING
Текущая кодировка символов на стороне клиента. Устанавливается всякий раз при подклю-
чении к базе данных (в том числе при старте программы) и при смене кодировки командой
\encoding, но эту переменную можно изменить или сбросить.
ERROR
true в случае ошибки последнего SQL-запроса, false, если он был выполнен успешно. См.
также SQLSTATE.
FETCH_COUNT
Если значение этой переменной — целое число больше нуля, результаты запросов SELECT из-
влекаются из базы данных и отображаются группами с заданным количеством строк, в отличие
от поведения по умолчанию, когда перед отображением результирующий набор накапливает-
ся целиком. Это позволяет использовать ограниченный размер памяти независимо от разме-
1855psql
ра выборки. При включении этой функциональности обычно используются значения от 100 до
    <ol>
      <li>Имейте в виду, что запрос может завершиться ошибкой после отображения некоторого
количества строк.
Подсказка
Хотя можно использовать любой формат вывода, формат по умолчанию aligned как
правило выглядит хуже, потому что каждая группа по FETCH_COUNT строк формати-
руется отдельно, что может привести к разной ширине столбцов в разных группах.
Остальные форматы вывода работают лучше.
HISTCONTROL
Если переменная имеет значение ignorespace, строки, начинающиеся с пробела, не сохраня-
ются в истории. Если она имеет значение ignoredups, в историю не добавляются строки, кото-
рые в ней уже есть. Значение ignoreboth объединяет эти два варианта. Со значением none (по
умолчанию) в истории сохраняются все строки, считываемые в интерактивном режиме.
Примечание
Эта функциональность была бессовестно списана с Bash.
HISTFILE
Имя файла, в котором будет сохраняться список истории команд. Если эта переменная не опре-
делена, имя файла берётся из переменной окружения PSQL_HISTORY. Если и она не задана, ис-
пользуется имя по умолчанию — ~/.psql_history или %APPDATA%\postgresql\psql_history в
Windows. Например, если установить:
\set HISTFILE ~/.psql_history- :DBNAME
в ~/.psqlrc, psql будет вести отдельный файл истории для каждой базы данных.
Примечание
Эта функциональность была бессовестно списана с Bash.
HISTSIZE
Максимальное число команд, которые будут сохраняться в истории команд (по умолчанию 500).
Если задано отрицательное значение, ограничение не накладывается.
Примечание
Эта функциональность была бессовестно списана с Bash.
HOST
Имя компьютера, где работает сервер базы данных, к которому вы сейчас подключены. Уста-
навливается всякий раз при подключении к базе данных (в том числе при старте программы),
но эту переменную можно изменить или сбросить.
IGNOREEOF
Если равно 1 или меньше, символ конца файла (EOF, обычно передаётся сочетанием клавиш
Control+D) в интерактивном сеансе psql завершит работу приложения. Если значение больше
1, оно определяет, сколько последовательных символов EOF нужно ввести, чтобы завершить
1856psql
интерактивный сеанс. Если значение переменной не является числовым, оно воспринимается
как 10. По умолчанию — 0.
Примечание
Эта функциональность была бессовестно списана с Bash.
LASTOID
Содержит значение последнего OID, полученного командой INSERT или \lo_import. Коррект-
ное значение переменной гарантируется до тех пор, пока не будет отображён результат сле-
дующей SQL-команды.
LAST_ERROR_MESSAGE
LAST_ERROR_SQLSTATE
Основное сообщение об ошибке и связанный код SQLSTATE для последнего неудавшегося за-
проса в текущем сеансе psql либо пустая строка и 00000, если в текущем сеансе не происходи-
ли ошибки.
ON_ERROR_ROLLBACK
При значении on, если команда в блоке транзакции выдаёт ошибку, ошибка игнорируется и
транзакция продолжается. Со значением interactive такие ошибки игнорируются только в
интерактивных сеансах, но не в скриптах. Со значением off (по умолчанию) команда в блоке
транзакции, выдающая ошибку, прерывает всю транзакцию. Для реализации режима отката
транзакции за вас неявно выполняется команда SAVEPOINT непосредственно перед каждой ко-
мандой в блоке транзакции, а в случае ошибки команды происходит откат к этой точке сохра-
нения.
ON_ERROR_STOP
По умолчанию, после возникновения ошибки обработка команд продолжается. Если эта пере-
менная установлена в значение on, обработка команд будет немедленно прекращена. В интер-
активном режиме psql вернётся в командную строку; иначе psql прекратит работу с кодом воз-
врата 3, чтобы отличить этот случай от фатальных ошибок, для которых используется код воз-
врата 1. В любом случае, выполнение всех запущенных скриптов (высокоуровневый скрипт и
любые другие, которые он мог запустить) будет немедленно прекращено. Если высокоуровне-
вая командная строка содержит несколько SQL-команд, выполнение завершится на текущей
команде.
PORT
Содержит порт сервера базы данных, к которому вы сейчас подключены. Устанавливается вся-
кий раз при подключении к базе данных (в том числе при старте программы), но эту перемен-
ную можно изменить или сбросить.
PROMPT1
PROMPT2
PROMPT3
Указывают, как должны выглядеть приглашения psql. См. Подраздел «Настройка приглаше-
ний».
QUIET
Установка значения on эквивалента параметру командной строки -q. Это, вероятно, не слиш-
ком полезно в интерактивном режиме.
ROW_COUNT
Число строк, возвращённых или обработанных последним SQL-запросом, либо 0, если запрос
завершился неудачно или не возвратил количество строк.
1857psql
SERVER_VERSION_NAME
SERVER_VERSION_NUM
Номер версии сервера в виде строки, например 9.6.2, 10.1 или 11beta1, и в числовом виде,
например, 90602 или 100001. Они устанавливаются при каждом подключении к базе данных (в
том числе при запуске программы), но их можно изменить или сбросить.
SHOW_CONTEXT
Этой переменной можно присвоить значения never (никогда), errors (ошибки) или always (все-
гда), определяющие, когда в сообщениях с сервера будут выводиться поля КОНТЕКСТ. По умол-
чанию выбран вариант errors (что означает, что контекст будет выводиться в сообщениях об
ошибках, но не в предупреждениях и уведомлениях). Этот параметр не действует, когда уста-
новлен уровень VERBOSITY terse. (Когда вам потребуется подробная версия только что выдан-
ной ошибки, может быть полезна команда \errverbose.)
SINGLELINE
Установка значения on эквивалентна параметру командной строки -S.
SINGLESTEP
Эта переменная эквивалентна параметру командной строки -s.
SQLSTATE
Код ошибки (см. Приложение A), связанной с неудачным выполнением последнего SQL-запро-
са, либо 00000 в случае его успешного завершения.
USER
Содержит имя пользователя базы данных, который сейчас подключён. Устанавливается всякий
раз при подключении к базе данных (в том числе при старте программы), но эту переменную
можно изменить или сбросить.
VERBOSITY
Этой переменной можно присвоить значения default, verbose или terse для изменения уров-
ня детализации в сообщениях об ошибках. (См. также команду \errverbose, полезную, когда
требуется подробная версия только что выданной ошибки.)
VERSION
VERSION_NAME
VERSION_NUM
Эти переменные устанавливаются при запуске программы и отражают версию psql соответ-
ственно в виде развёрнутой строки, краткой строки (например, 9.6.2, 10.1 или 11beta1) и чис-
ла (например, 90602 или 100001). Их можно изменить или сбросить.
Интерполяция SQL
Ключевой особенностью переменных psql является возможность подставлять («интерполировать»)
их в команды SQL, также как и в аргументы метакоманд. Кроме того, psql предоставляет средства
для корректного использования кавычек для значений переменных, которые используются как
литералы или идентификаторы SQL. Чтобы подставить значение без кавычек, нужно добавить пе-
ред именем переменной двоеточие (:). Например:
testdb=&gt; \set foo ‘my_table’
testdb=&gt; SELECT * FROM :foo;
будет запрашивать таблицу my_table. Обратите внимание, что это может быть небезопасным: зна-
чение переменной копируется буквально, поэтому оно может содержать непарные кавычки или
даже метакоманды. При применении необходимо убедиться, что это имеет смысл.
Когда значение будет использоваться в качестве SQL литерала или идентификатора, безопаснее
заключить его в кавычки. Если значение переменной используется как SQL литерал, то после
1858psql
двоеточия нужно написать имя переменной в одинарных кавычках. Если значение переменной ис-
пользуется как SQL идентификатор, то после двоеточия нужно написать имя переменной в двой-
ных кавычках. Эти конструкции корректно работают с кавычками и другими специальными сим-
волами, которые могут содержаться в значении переменной. Предыдущий пример более безопас-
но выглядит так:
testdb=&gt; \set foo ‘my_table’
testdb=&gt; SELECT * FROM :”foo”;
Подстановка переменных не будет выполняться, если SQL литералы или идентификаторы заклю-
чены в кавычки. Поэтому конструкция ‘:foo’ не превратится во взятое в кавычки значение пере-
менной (и это было бы небезопасно, если бы работало, так как обработка кавычек внутри значения
переменной была бы некорректной).
Один из примеров использования данного механизма — это копирование содержимого файла в
столбец таблицы. Сначала загрузим содержимое файла в переменную, затем подставим значение
переменной как строку в кавычках:
testdb=&gt; \set content <code class="highlighter-rouge">cat my_file.txt</code>
testdb=&gt; INSERT INTO my_table VALUES (:’content’);
(Отметим, что это пока не будет работать, если my_file.txt содержит байт NUL. psql не поддер-
живает NUL в значениях переменных.)
Так как двоеточие может легально присутствовать в SQL-командах, попытка подстановки (напри-
мер для :name, :’name’ или :”name”) не выполняется, если переменная не установлена. В любом
случае, можно экранировать двоеточие с помощью обратной косой черты, чтобы предотвратить
подстановку.
Специальная конструкция :(?имя) возвращает TRUE или FALSE в зависимости от того, существует
ли переменная, и таким образом всегда подменяется значением, если только двоеточие не экра-
нировано обратной косой чертой.
Использование двоеточия для переменных является стандартом SQL для встраиваемых языков за-
просов, таких как ECPG. Использование двоеточия для срезов массивов и приведения типов явля-
ется расширениями PostgreSQL, что иногда может конфликтовать со стандартным использовани-
ем. Использование двоеточия и кавычек для экранирования значения переменной при подстанов-
ке в качестве SQL литерала или идентификатора — это расширение psql.
Настройка приглашений
Приглашения, выдаваемые psql, можно настроить по своему вкусу. Три переменные PROMPT1,
PROMPT2 и PROMPT3 содержат строки и спецпоследовательности, задающие внешний вид приглаше-
ния. Приглашение 1 (PROMPT1) — это обычное приглашение, которое выдаётся, когда psql ожидает
ввода новой команды. Приглашение 2 (PROMPT2) выдаётся, когда при вводе команды ожидается
дополнительные строки, например потому что команда не была завершена точкой с запятой или
не закрыты кавычки. Приглашение 3 (PROMPT3) выдаётся при выполнении SQL-команды COPY FROM
STDIN, когда в терминале нужно ввести значение новой строки.
Значения этих переменных выводятся буквально, за исключением случаев, когда в них встречает-
ся знак процента (%). В зависимости от следующего символа будет подставляться определённый
текст. Существуют следующие подстановки:
%M
Полное имя компьютера (с именем домена) сервера базы данных или [local], если подключе-
ние выполнено через Unix-сокет, либо [local:/dir/name], если при компиляции был изменён
путь Unix-сокета по умолчанию.
%m
Имя компьютера, где работает сервер баз данных, усечённое до первой точки или [local], если
подключение выполнено через Unix-сокет.
1859psql
%&gt;
Номер порта, который прослушивает сервер базы данных.
%n
Имя пользователя базы данных для текущей сессии. (Это значение может меняться в течение
сессии в результате выполнения команды SET SESSION AUTHORIZATION.)
%/
Имя текущей базы данных.
%~
Похоже на %/, но выводит тильду ~, если текущая база данных совпадает с базой данных по
умолчанию.
%#
Если пользователь текущей сессии является суперпользователем базы данных, то выводит #,
иначе &gt;. (Это значение может меняться в течение сессии в результате выполнения команды
SET SESSION AUTHORIZATION.)
%p
PID обслуживающего процесса для текущего подключения.
%R
В приглашении 1 это обычно символ =, но @, если сеанс находится в неактивной ветви блока
условия, либо ^ в однострочном режиме либо !, если сеанс не подключён к базе данных (что
возможно при ошибке \connect). В приглашении 2 %R заменяется символом, показывающим,
почему psql ожидает дополнительный ввод: -, если команда просто ещё не была завершена, но
<em>, если не завершён комментарий /</em> … <em>/; апостроф, если не завершена строка в апострофах;
кавычки, если не завершён идентификатор в кавычках; знак доллара, если не завершена строка
в долларах; либо (, если после открывающей скобки не хватает закрывающей. В приглашении
3 %R не выдаёт ничего.
%x
Состояние транзакции: пустая строка, если не в транзакционном блоке; *, когда в транзакци-
онном блоке; !, когда в транзакционном блоке, в котором произошла ошибка и ?, когда состо-
яние транзакции не определено (например, нет подключения к базе данных).
%l
Номер строки в текущем операторе, начиная с 1.
%цифры
Подставляется символ с указанным восьмеричным кодом.
%:имя:
Значение переменной psql имя. За подробностями обратитесь к разделу «Переменные».
%<code class="highlighter-rouge">команда</code>
Подставляется вывод команды command, как и в обычной подстановке с обратными апострофа-
ми.
%[ … %]
Приглашения могут содержать управляющие символы терминала, которые, например, изме-
няют цвет, фон и стиль текста приглашения или изменяют заголовок окна терминала. Для то-
1860psql
го, чтобы возможности редактирования Readline работали правильно, непечатаемые символы
нужно расположить между %[ и %], чтобы сделать невидимыми. Можно делать несколько таких
включений в приглашение. Например:
testdb=&gt; \set PROMPT1 ‘%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# ‘
выдаст жирное (1;), желтое на черном (33;40) приглашение для VT100 совместимых цветных
терминалов.
Чтобы вставить знак процента, нужно написать %%. По умолчанию используются значения ‘%/%R
%# ‘ для PROMPT1 и PROMPT2 и ‘» ‘ для PROMPT3.
Примечание
Эта функциональность была бессовестно списана с tcsh.
Редактирование командной строки
psql поддерживает библиотеку Readline для удобного редактирования командной строки. История
команд автоматически сохраняется при выходе из psql и загружается при запуске. Завершение
клавишей TAB также поддерживается, хотя логика завершения не претендует на роль анализатора
SQL. Запросы, генерируемые завершением по TAB, также могут конфликтовать с другими команда-
ми SQL, например SET TRANSACTION ISOLATION LEVEL. Если по какой-либо причине вам не нравится
завершение по клавише TAB, его можно отключить в файле .inputrc в вашем домашнем каталоге:
$if psql
set disable-completion on
$endif
(Это возможность не psql, а Readline. Читайте документацию к Readline для дополнительной ин-
формации.)
Переменные окружения
COLUMNS
Если \pset columns равно нулю, управляет шириной формата вывода wrapped, а также опреде-
ляет, нужно ли использовать постраничник и нужно ли переключаться в вертикальный формат
в режиме expanded auto.
PGDATABASE
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию (см. Раздел 34.14).
PSQL_EDITOR
EDITOR
VISUAL
Редактор, используемый командами \e, \ef и \ev. Эти переменные рассматриваются в том же
порядке; в силу вступает первое установленное значение. Если ни одна из переменных не уста-
новлена, по умолчанию в Unix-системах используется vi, а в Windows — notepad.exe.
PSQL_EDITOR_LINENUMBER_ARG
Если в командах \e, \ef или \ev указан номер строки, эта переменная задаёт аргумент команд-
ной строки, с которым номер строки может быть передан в редактор. Например, для редакторов
Emacs и vi это знак плюс. Добавьте в конец значения пробел, если он требуется для отделения
имени аргумента от номера строки. Примеры:
1861psql
PSQL_EDITOR_LINENUMBER_ARG=’+’
PSQL_EDITOR_LINENUMBER_ARG=’–line ‘
Значение по умолчанию + в Unix-подобных системах (соответствует редактору по умолчанию
vi и многим другим распространённым редакторам). На платформе Windows нет значения по
умолчанию.
PSQL_HISTORY
Альтернативное расположение файла с историей команд. Допускается использование тильды
(~).
PSQL_PAGER
PAGER
Если результат запроса не помещается на экране, он пропускается через эту программу. Обыч-
но это more или less. От использования постраничника можно отказаться, присвоив перемен-
ной PSQL_PAGER или PAGER пустую строку, либо изменив соответствующие параметры с помо-
щью команды \pset. Данные переменные просматриваются в этом же порядке; используется
первая установленная. Если не установлена ни одна из переменных, в большинстве платформ
используется more, а в Cygwin — less.
PSQLRC
Альтернативное расположение пользовательского файла .psqlrc. Допускается использование
тильды (~).
SHELL
Команда операционной системы, выполняемая метакомандой !.
TMPDIR
Каталог для хранения временных файлов. По умолчанию /tmp.
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Файлы
psqlrc и ~/.psqlrc
При запуске без параметра -X программа psql пытается считать и выполнить команды из об-
щесистемного стартового файла (psqlrc), а затем из персонального стартового файла пользо-
вателя (~/.psqlrc), после подключения к базе данных, но перед получением обычных команд.
Этими файлами можно воспользоваться для настройки клиента и/или сервера, как правило, с
помощью команд \set и SET.
Общесистемный стартовый файл называется psqlrc, он будет искаться в каталоге установки
«конфигурация системы». Для того чтобы узнать этот каталог, надёжнее всего выполнить ко-
манду pg_config –sysconfdir. По умолчанию он расположен в ../etc/ относительно катало-
га, содержащего исполняемые файлы PostgreSQL. Имя этого каталога можно задать явно через
переменную окружения PGSYSCONFDIR.
Персональный стартовый файл пользователя называется .psqlrc, он будет искаться в домаш-
нем каталоге вызывающего пользователя. В Windows, где отсутствует такое понятие, персо-
нальный стартовый файл называется %APPDATA%\postgresql\psqlrc.conf. Расположение пер-
сонального стартового файла пользователя можно задать явно через переменную окружения
PSQLRC.
Оба стартовых файла, общесистемный и персональный, можно привязать к конкретной версии
psql. Для этого в конце имени файла нужно добавить номер основного или корректирующего
1862psql
релиза PostgreSQL, например ~/.psqlrc-9.2 или ~/.psqlrc-9.2.5. При наличии нескольких
файлов, файл с более детальным номером версии будет иметь предпочтение.
.psql_history
История командной строки хранится в файле ~/.psql_history или %APPDATA%\postgresql
\psql_history на Windows.
Расположение файла истории можно задать явно через переменную psql HISTFILE или через
переменную окружения PSQL_HISTORY.
Замечания
• psql лучше всего работает с серверами той же или более старой основной версии. Сбой мета-
команды наиболее вероятен, если версия сервера новее, чем версия psql. Однако, команды се-
мейства \d должны работать с версиями сервера до 7.4, хотя и необязательно с серверами но-
вее, чем сам psql. Общая функциональность запуска SQL-команд и отображения результатов
запросов также должна работать на серверах с более новой основной версией, но это не га-
рантируется во всех случаях.
Если вы хотите, применяя psql, подключаться к нескольким серверам с различными основны-
ми версиями, рекомендуется использовать последнюю версию psql. Также можно собрать ко-
пии psql от каждой основной версии и использовать ту, которая соответствует версии сервера.
Но на практике в этих дополнительных сложностях нет необходимости.
• В PostgreSQL до версии 9.6 параметр -c подразумевал -X (–no-psqlrc); теперь это не так.
• В PostgreSQL до 8.4 программа psql могла принять первый аргумент однобуквенной команды
с обратной косой чертой сразу после команды, без промежуточного пробела. Теперь раздели-
тельный пробельный символ обязателен.
Замечания для пользователей Windows
psql создан как «консольное приложение». Поскольку в Windows консольные окна используют ко-
дировку символов отличную от той, что используется для остальной системы, нужно проявить осо-
бую осторожность при использовании 8-битных символов. Если psql обнаружит проблемную кодо-
вую страницу консоли, он предупредит вас при запуске. Чтобы изменить кодовую страницу консо-
ли, необходимы две вещи:
• Задать кодовую страницу, выполнив cmd.exe /c chcp 1251. (1251 это кодовая страница для
России, замените на ваше значение.) При использовании Cygwin, эту команду можно записать
в /etc/profile.
• Установите консольный шрифт в Lucida Console, потому что растровый шрифт не работает с
кодовой страницей ANSI.
Примеры
Первый пример показывает, что для ввода одной команды может потребоваться несколько строк.
Обратите внимание, как меняется приглашение:
testdb=&gt; CREATE TABLE my_table (
testdb(&gt; first integer not null default 0,
testdb(&gt; second text)
testdb-&gt; ;
CREATE TABLE
Теперь посмотрим на определение таблицы:
testdb=&gt; \d my_table
Таблица “public.my_table”
Столбец |
Тип
| Правило сортировки | Допустимость NULL | По умолчанию
first
| integer |
| not null
|
0
1863psql
second
| text
|
|
|
Теперь изменим приглашение на что-то более интересное:
testdb=&gt; \set PROMPT1 ‘%n@%m %~%R%# ‘
peter@localhost testdb=&gt;
Предположим, что вы внесли данные в таблицу и хотите на них посмотреть:
peter@localhost testdb=&gt; SELECT * FROM my_table;
first | second
——-+——–
1 | Один
2 | Два
3 | Три
4 | Четыре
(4 строки)
Таблицу можно вывести разными способами при помощи команды \pset:
peter@localhost testdb=&gt; \pset border 2
Установлен стиль границ: 2.
peter@localhost testdb=&gt; SELECT * FROM my_table;
+——-+——–+
| first | second |
+——-+——–+
|
1 | Один
|
|
2 | Два
|
|
3 | Три
|
|
4 | Четыре |
+——-+——–+
(4 строки)
peter@localhost testdb=&gt; \pset border 0
Установлен стиль границ: 0.
peter@localhost testdb=&gt; SELECT * FROM my_table;
first second
—– ——
1 Один
2 Два
3 Три
4 Четыре
(4 строки)
peter@localhost testdb=&gt; \pset border 1
Установлен стиль границ: 1.
peter@localhost testdb=&gt; \pset format unaligned
Формат вывода: unaligned.
peter@localhost testdb=&gt; \pset fieldsep ‘,’
Разделитель полей: “,”.
peter@localhost testdb=&gt; \pset tuples_only
Выводятся только кортежи.
peter@localhost testdb=&gt; SELECT second, first FROM my_table;
Один,1
Два,2
Три,3
Четыре,4
Также можно использовать короткие команды:
peter@localhost testdb=&gt; \a \t \x
Формат вывода: aligned.
1864psql
Режим вывода только кортежей выключен.
Расширенный вывод включён.
peter@localhost testdb=&gt; SELECT * FROM my_table;
-[ RECORD 1 ]-
first | 1
second | Один
-[ RECORD 2 ]-
first | 2
second | Два
-[ RECORD 3 ]-
first | 3
second | Три
-[ RECORD 4 ]-
first | 4
second | Четыре
Когда это уместно, результаты запроса можно просмотреть в виде перекрёстной таблицы с помо-
щью команды \crosstabview:
testdb=&gt; SELECT first, second, first &gt; 2 AS gt2 FROM my_table;
first | second | gt2
——-+——–+—–
1 | one
| f
2 | two
| f
3 | three | t
4 | four
| t
(4 rows)
testdb=&gt; \crosstabview first second
first | one | two | three | four
——-+—–+—–+——-+——
1 | f
|
|
|
2 |
| f
|
|
3 |
|
| t
|
4 |
|
|
| t
(4 rows)
Второй пример показывает таблицу умножения, строки в которой отсортированы в обратном чис-
ловом порядке, а столбцы — независимо, по возрастанию числовых значений.
testdb=&gt; SELECT t1.first as “A”, t2.first+100 AS “B”, t1.first</em>(t2.first+100) as “AxB”,
testdb(&gt; row_number() over(order by t2.first) AS ord
testdb(&gt; FROM my_table t1 CROSS JOIN my_table t2 ORDER BY 1 DESC
testdb(&gt; \crosstabview “A” “B” “AxB” ord
A | 101 | 102 | 103 | 104
—+—–+—–+—–+—–
4 | 404 | 408 | 412 | 416
3 | 303 | 306 | 309 | 312
2 | 202 | 204 | 206 | 208
1 | 101 | 102 | 103 | 104
(4 rows)
1865reindexdb
reindexdb — переиндексировать базу данных PostgreSQL
Синтаксис
reindexdb [параметр-подключения…] [параметр…] [ –schema | -S схема ] … [ –table | -t таблица
] … [ –index | -i индекс ] … [имя_бд]
reindexdb [параметр-подключения…] [параметр…] –all | -a
reindexdb [параметр-подключения…] [параметр…] –system | -s [имя_бд]
Описание
Утилита reindexdb предназначена для перестроения индексов в базе данных PostgreSQL.
Утилита reindexdb представляет собой обёртку SQL-команды REINDEX. Переиндексация базы дан-
ных с её помощью по сути не отличается от переиндексации при обращении к серверу другими
способами.
Параметры
reindexdb принимает следующие аргументы командной строки:
-a
–all
Переиндексировать все базы данных.
[-d] имя_бд
[–dbname=]имя_бд
Задаёт имя базы данных, подлежащей переиндексации. Если это имя не задано и отсутствует
параметр -a (или –all), имя базы данных берётся из переменной окружения PGDATABASE. Если
и эта переменная не задана, выбирается имя подключающегося пользователя.
-e
–echo
Выводить команды, которые reindexdb генерирует и передаёт серверу.
-i индекс
–index=индекс
Пересоздать только указанный индекс. Добавив дополнительные ключи -i, можно пересоздать
несколько индексов.
-q
–quiet
Подавлять вывод сообщений о прогрессе выполнения.
-s
–system
Переиндексировать системные каталоги базы данных.
-S схема
–schema=схема
Переиндексировать только указанную схему. Переиндексировать несколько схем можно, доба-
вив несколько ключей -S.
1866reindexdb
-t таблица
–table=таблица
Переиндексировать только указанную таблицу. Переиндексировать несколько таблиц можно,
добавив несколько ключей -t.
-v
–verbose
Вывести подробную информацию во время процесса.
-V
–version
Сообщить версию reindexdb и завершиться.
-?
–help
Показать справку по аргументам командной строки reindexdb и завершиться.
Утилита reindexdb также принимает следующие аргументы командной строки в качестве парамет-
ров подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как reindexdb запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, reindexdb лишний раз
подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненуж-
ную попытку подключения.
–maintenance-db=имя_бд
Задаёт имя базы данных, через подключение к которой будут находиться другие базы, подле-
жащие переиндексации. По умолчанию используется postgres, а в случае её отсутствия —
template1.
1867reindexdb
Переменные окружения
PGDATABASE
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей, обратитесь к описаниям REINDEX и psql, где обсуждаются
потенциальные проблемы и сообщения об ошибках. Учтите, что на целевом компьютере должен
работать сервер баз данных. При этом применяются все свойства подключения по умолчанию и
переменные окружения, которые использует клиентская библиотека libpq.
Замечания
Утилите reindexdb может потребоваться подключаться к серверу PostgreSQL несколько раз, и при
этом она будет каждый раз запрашивать пароль. В таких случаях удобно иметь файл ~/.pgpass.
За дополнительными сведениями обратитесь к Разделу 34.15.
Примеры
Переиндексирование базы данных test:
$ reindexdb test
Переиндексирование таблицы foo и индекса bar в базе данных abcd:
$ reindexdb –table=foo –index=bar abcd
См. также
REINDEX
1868vacuumdb
vacuumdb — выполнить очистку и анализ базы данных PostgreSQL
Синтаксис
vacuumdb [параметр-подключения…] [параметр…] [ –table | -t таблица [( столбец [,…] )] ] … [имя_бд]
vacuumdb [параметр-подключения…] [параметр…] –all | -a
Описание
Утилита vacuumdb предназначена для очистки базы данных PostgreSQL. Кроме того, vacuumdb
генерирует внутреннюю статистику, которую использует оптимизатор запросов PostgreSQL.
Утилита vacuumdb представляют собой обёртку SQL-команды VACUUM. Выполнение очистки и
анализа баз данных с её помощью по сути не отличается от выполнения тех же действий при
обращении к серверу другими способами.
Параметры
Утилита vacuumdb принимает следующие аргументы командной строки:
-a
–all
Очистить все базы данных.
[-d] имя_бд
[–dbname=]имя_бд
Задаёт имя базы данных, подлежащей очистке. Если это имя не задано и отсутствует параметр
-a (или –all), имя базы данных берётся из переменной окружения PGDATABASE. Если и эта
переменная не задана, выбирается имя подключающегося пользователя.
-e
–echo
Выводить команды, которые vacuumdb генерирует и передаёт серверу.
-f
–full
Произвести «полную» очистку.
-F
–freeze
Агрессивно «замораживать» версии строк.
-j njobs
–jobs=njobs
Выполнять команды VACUUM или ANALYZE в параллельном режиме, запуская одновременно
njobs команд. Это сокращает время обработки, но увеличивает нагрузку на сервер.
vacuumdb откроет njobs подключений к базе данных, так что убедитесь в том, что значение
max_connections достаточно велико, чтобы все эти подключения были приняты.
Заметьте, что использование этого режима с параметром -f (FULL) может привести к отказам
из-за взаимоблокировок, если параллельно начнут обрабатываться определённые системные
каталоги.
1869vacuumdb
-q
–quiet
Подавлять вывод сообщений о прогрессе выполнения.
-t таблица [ (столбец [,…]) ]
–table=таблица [ (столбец [,…]) ]
Производить очистку или анализ только указанной таблицы. Имена столбцов можно указать
только в сочетании с параметрами –analyze и –analyze-only. Добавив дополнительные клю-
чи -t, можно обработать несколько таблиц.
Подсказка
Если вы указываете столбцы, вам, вероятно, придётся экранировать скобки в обо-
лочке. (См. примеры ниже.)
-v
–verbose
Вывести подробную информацию во время процесса.
-V
–version
Сообщить версию vacuumdb и завершиться.
-z
–analyze
Также вычислить статистику для оптимизатора.
-Z
–analyze-only
Только вычислить статистику для оптимизатора (не производить очистку).
–analyze-in-stages
Только вычислить статистику для оптимизатора (без очистки), подобно –analyze-only. Но для
скорейшего получения полезной статистики, выполнить анализ в несколько проходов (в насто-
ящее время, три) с разными параметрами.
Этот параметр полезен при необходимости провести анализ базы данных, только что наполнен-
ной данными из архива или командой pg_upgrade. С этим параметром vacuumdb постарается
получить некоторую статистику как можно скорее, чтобы базой можно было пользоваться, а
на следующих проходах вычислит полную статистику.
-?
–help
Показать справку по аргументам командной строки vacuumdb и завершиться.
Утилита reindexdb также принимает следующие аргументы командной строки в качестве парамет-
ров подключения:
-h сервер
–host=сервер
Указывает имя компьютера, на котором работает сервер. Если значение начинается с косой
черты, оно определяет каталог Unix-сокета.
1870vacuumdb
-p порт
–port=порт
Указывает TCP-порт или расширение файла локального Unix-сокета, через который сервер при-
нимает подключения.
-U имя_пользователя
–username=имя_пользователя
Имя пользователя, под которым производится подключение.
-w
–no-password
Не выдавать запрос на ввод пароля. Если сервер требует аутентификацию по паролю и пароль
не доступен с помощью других средств, таких как файл .pgpass, попытка соединения не удаст-
ся. Этот параметр может быть полезен в пакетных заданиях и скриптах, где нет пользователя,
который вводит пароль.
-W
–password
Принудительно запрашивать пароль перед подключением к базе данных.
Это несущественный параметр, так как vacuumdb запрашивает пароль автоматически, если
сервер проверяет подлинность по паролю. Однако, чтобы понять это, vacuumdb лишний раз
подключается к серверу. Поэтому иногда имеет смысл ввести -W, чтобы исключить эту ненуж-
ную попытку подключения.
–maintenance-db=имя_бд
Задаёт имя базы данных, через подключение к которой будут находиться другие базы, подле-
жащие очистке. По умолчанию используется postgres, а в случае её отсутствия — template1.
Переменные окружения
PGDATABASE
PGHOST
PGPORT
PGUSER
Параметры подключения по умолчанию
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Диагностика
В случае возникновения трудностей, обратитесь к описаниям VACUUM и psql, где обсуждаются
потенциальные проблемы и сообщения об ошибках. Учтите, что на целевом компьютере должен
работать сервер баз данных. При этом применяются все свойства подключения по умолчанию и
переменные окружения, которые использует клиентская библиотека libpq.
Замечания
Утилите vacuumdb может потребоваться подключаться к серверу PostgreSQL несколько раз, и при
этом она будет каждый раз запрашивать пароль. В таких случаях удобно иметь файл ~/.pgpass.
За дополнительными сведениями обратитесь к Разделу 34.15.
Примеры
Очистка базы данных test:
1871vacuumdb
$ vacuumdb test
Очистка и анализ для оптимизатора базы данных bigdb:
$ vacuumdb –analyze bigdb
Очистка одной таблицы foo в базе данных xyzzy и анализ только столбца bar таблицы для опти-
мизатора:
$ vacuumdb –analyze –verbose –table=’foo(bar)’ xyzzy
См. также
VACUUM
1872Серверные приложения PostgreSQL
В этой части содержится справочная информация о серверных приложениях и вспомогательных
утилитах PostgreSQL. Описываемые команды могут быть полезны только на том компьютере, где
работает сервер баз данных. Другие утилиты рассмотрены в Справке: «Клиентские приложения
PostgreSQL».
1873initdb
initdb — создать кластер баз данных PostgreSQL
Синтаксис
initdb [параметр…] [ –pgdata | -D ]каталог
Описание
Команда initdb создаёт новый кластер баз данных PostgreSQL. Кластер — это коллекция баз дан-
ных под управлением единого экземпляра сервера.
Инициализация кластера базы данных заключается в создании каталогов для хранения данных,
формировании общих системных таблиц (относящихся ко всему кластеру, а не к какой-либо базе)
и создании баз данных template1 и postgres. Впоследствии все новые базы создаются на осно-
ве шаблона template1 (все дополнения, установленные в template1 автоматически копируются в
каждую новую базу данных). База postgres используется пользователями, утилитами и сторонни-
ми приложениями по умолчанию.
При попытке создать каталог для хранения данных initdb может столкнуться с нехваткой прав
доступа, если этот каталог принадлежит суперпользователю root. В таком случае необходимо на-
значить пользователя базы данных владельцем этого каталога при помощи chown. Затем выпол-
нить su для смены пользователя и дальнейшего выполнения initdb.
Команда initdb должна выполняться от имени пользователя, под которым будет запускаться сер-
вер, так как ему необходим полный доступ к файлам и каталогам, создаваемым initdb. Сервер
не может запускаться от имени суперпользователя, поэтому выполнение команды initdb от его
лица будет отклонено.
Из соображений безопасности новый кластер, созданный программой initdb, будет доступен толь-
ко для владельца кластера. Ключ –allow-group-access позволяет разрешить чтение файлов в
кластере всем пользователям, входящим в группу владельца кластера. Это полезно для выполне-
ния резервного копирования от имени непривилегированного пользователя.
initdb инициализирует локали и кодировки баз данных кластера, которые будут использоваться
по умолчанию. Кодировка, порядок сортировки (LC_COLLATE), классы наборов символов (LC_CTYPE,
например, заглавные, строчные буквы, цифры) могут устанавливаться раздельно при создании но-
вой базы данных. initdb определяет параметры локали для шаблона template1, которые будут
применяться по умолчанию для новых баз.
Чтобы изменить порядок сортировки по умолчанию или классы наборов символов, используются
параметры –lc-collate и –lc-ctype. Порядок сортировки, отличающийся от C или POSIX, ока-
зывает влияние на производительность. Поэтому необходимо тщательно выбирать необходимую и
достаточную локаль при выполнении initdb.
Другие категории локали можно изменить и после старта сервера. Также можно использовать па-
раметр –locale, чтобы задать локаль для всех категорий одновременно, включая порядок сорти-
ровки и классы наборов символов. Значения локалей сервера (lc_*) можно вывести командой SHOW
ALL. Узнать об этом больше можно в Разделе 23.1.
Для изменения кодировки по умолчанию используется параметр –encoding. Узнать об этом боль-
ше можно в Разделе 23.3.
1874initdb
Параметры
-A authmethod
–auth=authmethod
Параметр определяет метод аутентификации по умолчанию для локальных пользователей, ис-
пользуемый в файле pg_hba.conf (строки host и local). Программа initdb предварительно вне-
сёт указанный метод аутентификации в pg_hba.conf в записи как обычных соединений, так и
соединений для репликации.
Не используйте trust, если не можете доверять всем локальным пользователям в вашей систе-
ме. Режим trust используется по умолчанию для облегчения процесса установки.
–auth-host=authmethod
Параметр указывает метод аутентификации для локальных пользователей, подключающихся
по TCP/IP, используемый в pg_hba.conf (строки host).
–auth-local=authmethod
Параметр выбирает метод аутентификации локальных пользователей, подключающихся через
Unix-сокет, используемый в pg_hba.conf (строки local).
-D каталог
–pgdata=каталог
Параметр указывает каталог хранения данных кластера. Это единственный обязательный па-
раметр для команды initdb. При этом его можно указать в переменной окружения PGDATA, что
будет удобным при дальнейшем использовании (postgres обращается к этой же переменной).
-E кодировка
–encoding=кодировка
Устанавливает кодировку шаблона и новых баз данных по умолчанию, если не указать иное
при их создании. По умолчанию устанавливается исходя из указанной локали, и далее, если не
удалось определить, выбирается SQL_ASCII. Кодировки, поддерживаемые сервером PostgreSQL,
описаны в Подразделе 23.3.1.
-g
–allow-group-access
Позволяет пользователям, входящим в группу владельца кластера, читать все файлы кластера,
создаваемые программой initdb.
-k
–data-checksums
Применять контрольные суммы на страницах данных для выявления сбоев при вводе/выводе,
которые иначе останутся незамеченными. Расчёт контрольных сумм может значительно по-
влияет на производительность. Этот режим можно включить только при инициализации и нель-
зя изменить позже. Когда контрольные суммы включены, они рассчитываются для всех объек-
тов и во всех базах данных.
–locale=локаль
Устанавливает локаль кластера по умолчанию. Если флаг не указан, локаль устанавливается
согласно окружению, в котором исполняется команда initdb. Поддерживаемые локали описа-
ны в Разделе 23.1.
1875initdb
–lc-collate=локаль
–lc-ctype=локаль
–lc-messages=локаль
–lc-monetary=локаль
–lc-numeric=локаль
–lc-time=локаль
Аналогично –locale устанавливает необходимую локаль, но в заданной категории.
–no-locale
Аналогично флагу –locale=C.
-N
–no-sync
По умолчанию initdb ждёт, пока все файлы не будут надёжно записаны на диск. С данным
параметром initdb завершается немедленно, то есть выполняется быстрее, но в случае неожи-
данного сбоя операционной системы каталог данных может оказаться испорченным. Вообще
этот параметр предназначен прежде всего для тестирования, для производственной среды он
не подходит.
–pwfile=имя_файла
Принуждает initdb читать пароль суперпользователя базы данных из файла, первая строка
которого используется в качестве пароля.
-S
–sync-only
Безопасно записывает все файлы базы на диск и останавливается. Другие операции initdb при
этом не выполняются.
-T конфигурация
–text-search-config=конфигурация
Устанавливает конфигурацию текстового поиска по умолчанию. За дополнительными сведени-
ями обратитесь к default_text_search_config.
-U имя_пользователя
–username=имя_пользователя
Устанавливает имя суперпользователя базы данных. По умолчанию используется имя пользо-
вателя ОС, запустившего initdb. По факту, само по себе имя суперпользователя базы данных
не важно, но этот параметр позволяет оставить привычное postgres, если имя пользователя ОС
другое.
-W
–pwprompt
Указывает initdb запросить пароль, который будет назначен суперпользователю базы данных.
Это не важно, если не планируется использовать аутентификацию по паролю. В ином случае
этот режим аутентификации оказывается неприменимым, пока пароль не задан.
-X каталог
–waldir=каталог
Этот параметр указывает каталог для хранения журнала предзаписи.
–wal-segsize=размер
Задаёт размер сегмента WAL, в мегабайтах. Такой размер будет иметь каждый отдельный файл
в журнале WAL. По умолчанию размер равен 16 мегабайтам. Значение должно задаваться сте-
1876initdb
пенью 2 от 1 до 1024 (в мегабайтах). Этот параметр можно установить только во время иници-
ализации и нельзя изменить позже.
Этот размер бывает полезно поменять при тонкой настройке трансляции или архивации WAL.
Кроме того, в базах данных с WAL большого объёма огромное количество файлов WAL в ката-
логе может стать проблемой с точки зрения производительности и администрирования. Уве-
личение размера файлов WAL приводит к уменьшению числа этих файлов.
Другие реже используемые параметры описаны здесь:
-d
–debug
Выводит отладочные сообщения загрузчика и ряд других сообщений, не очень интересных ши-
рокой публике. Загрузчик — это приложение initdb, используемое для создания каталога таб-
лиц. С этим параметром выдаётся очень много крайне скучных сообщений.
-L каталог
Указывает initdb, где необходимо искать входные файлы для развёртывания кластера. Обычно
это не требуется. Приложение само запросит эти данные, если будет необходимо.
-n
–no-clean
По умолчанию, при выявлении ошибки на этапе развёртывания кластера, initdb удаляет все
файлы, которые к тому моменту были созданы. Параметр предотвращает очистку файлов для
целей отладки.
Прочие параметры:
-V
–version
Выводит версию initdb и останавливается.
-?
–help
Показывает помощь по аргументам команды initdb и останавливается.
Переменные окружения
PGDATA
Указывает каталог хранения данных кластера, можно изменить параметром -D.
TZ
Указывает часовой пояс кластера по умолчанию. Значение — это полное имя часового пояса
(см. Подраздел 8.5.3).
Эта утилита, как и большинство других утилит PostgreSQL, также использует переменные среды,
поддерживаемые libpq (см. Раздел 34.14).
Замечания
initdb можно выполнить командой pg_ctl initdb.
См. также
pg_ctl, postgres
1877pg_archivecleanup
pg_archivecleanup — вычистить файлы архивов WAL PostgreSQL
Синтаксис
pg_archivecleanup [параметр…] расположение_архива старейший_сохраняемый_файл
Описание
Утилита
pg_archivecleanup
предназначена
для
использования
в
качестве
archive_cleanup_command для удаления старых файлов WAL на резервном сервере (см. Раз-
дел 26.2). pg_archivecleanup можно использовать и как отдельную программу для выполнения тех
же действий.
Чтобы использовать pg_archivecleanup на резервном сервере, добавьте эту строку в файл конфигу-
рации recovery.conf:
archive_cleanup_command = ‘pg_archivecleanup расположение_архива %r’
Здесь расположение_архива определяет каталог, из которого должны удаляться файлы сегментов
WAL.
Вызываемая в качестве archive_cleanup_command, эта программа просматривает расположени-
е_архива и удаляет все файлы WAL, логически предшествующие значению аргумента %r. Целью
этой операции является сокращение числа сохраняемых файлов без потери возможности восста-
новления при перезапуске. Такой вариант использования уместен, когда расположение_архива
указывает на область рабочих файлов конкретного резервного сервера, но не когда расположени-
е_архива — каталог с архивом WAL для долговременного хранения, или когда несколько резерв-
ных серверов восстанавливают записи WAL из одного расположения.
При отдельном использовании этой программы из каталога расположение_архива будут удале-
ны все файлы WAL, логически предшествующие файлу старейший_сохраняемый_файл. В этом ре-
жиме, если вы укажете имя файла с расширением .partial или .backup, старейший_сохраня-
емый_файл будет определяться по имени без расширения. Благодаря такой интерпретации рас-
ширения .backup будут корректно удалены все файлы WAL, заархивированные до определённой
базовой копии. Например, следующая команда удалит все файлы старее файла WAL с именем
000000010000003700000010:
pg_archivecleanup -d archive 000000010000003700000010.00000020.backup
pg_archivecleanup:
pg_archivecleanup:
pg_archivecleanup:
keep WAL file “archive/000000010000003700000010” and later
removing file “archive/00000001000000370000000F”
removing file “archive/00000001000000370000000E”
pg_archivecleanup рассчитывает на то, что расположение_архива доступно для чтения и записи
пользователю, владеющему серверным процессом.
Параметры
pg_archivecleanup принимает следующие аргументы командной строки:
-d
Выводить подробные отладочные сообщения в stderr.
-n
Вывести имена файлов, которые должны быть удалены, в stdout (не выполняя удаление).
1878pg_archivecleanup
-V
–version
Вывести версию pg_archivecleanup и завершиться.
-x расширение
Установить расширение, которое будет убрано из имён файлов до принятия решения об уда-
лении определённых файлов. Это обычно полезно для очистки файлов архивов, которые сжи-
маются для хранения и получают расширение, задаваемое программой сжатия. Например: -
x .gz.
-?
–help
Вывести справку об аргументах командной строки pg_archivecleanup и завершиться.
Замечания
Программа pg_archivecleanup рассчитана на работу с PostgreSQL 8.0 и новее как отдельная утили-
та, а также с PostgreSQL 9.0 и новее как команда очистки архива.
Программа pg_archivecleanup написана на C; её исходный код легко поддаётся модификации (он
содержит секции, предназначенные для изменения при надобности)
Примеры
В системах Linux или Unix можно использовать команду:
archive_cleanup_command = ‘pg_archivecleanup -d /mnt/standby/archive %r 2»cleanup.log’
Предполагается, что каталог архива физически располагается на резервном сервере, так что ко-
манда archive_command обращается к нему по NFS, но для резервного сервера эти файлы локаль-
ные. Эта команда будет:
• выводить отладочную информацию в cleanup.log
• удалять ставшие ненужными файлы из каталога архива
См. также
pg_standby
1879pg_controldata
pg_controldata — вывести управляющую информацию кластера баз данных PostgreSQL
Синтаксис
pg_controldata [параметр] [[ –pgdata | -D ]datadir]
Описание
pg_controldata показывает свойства, установленные командой initdb, например, версию катало-
га. Она также выводит сведения о работе журнала предзаписи и контрольных точках. Эта инфор-
мация относится ко всему кластеру, а не к отдельной базе данных.
Утилита запускается от лица пользователя, создавшего кластер, так как требует права на чтение
в каталоге хранения данных. Можно указать путь к каталогу из командной строки, либо исполь-
зовать значение переменной окружения PGDATA. Также поддерживаются флаги -V и –version,
которые выводят версию pg_controldata и прерывают выполнение. Флаги -? и –help отображают
помощь по поддерживаемым командой аргументам.
Переменные окружения
PGDATA
Каталог размещения данных кластера по умолчанию
1880pg_ctl
pg_ctl — инициализировать, запустить, остановить или управлять сервером PostgreSQL
Синтаксис
pg_ctl init[db] [-D каталог_данных] [-s] [-o параметры-initdb]
pg_ctl start [-D каталог_данных] [-l имя_файла] [-W] [-t секунды] [-s] [-o параметры] [-p путь] [-c]
pg_ctl stop [-D каталог_данных] [-m s[mart] | f[ast] | i[mmediate] ] [-W] [-t секунды] [-s]
pg_ctl restart [-D каталог_данных] [-m s[mart] | f[ast] | i[mmediate] ] [-W] [-t секунды] [-s] [-
o параметры] [-c]
pg_ctl reload [-D каталог_данных] [-s]
pg_ctl status [-D каталог_данных]
pg_ctl promote [-D каталог_данных] [-W] [-t секунды] [-s]
pg_ctl kill имя_сигнала ид_процесса
В системах Microsoft Windows также:
pg_ctl register [-D каталог_данных] [-N имя_службы] [-U имя_пользователя] [-P пароль] [-S a[uto]
| d[emand] ] [-e source] [-W] [-t секунды] [-s] [-o параметры]
pg_ctl unregister [-N имя_службы]
Описание
pg_ctl — это утилита для начальной инициализации, запуска, остановки, повторного запуска и
управления кластером баз данных PostgreSQL (postgres). Сервер можно стартовать в ручном ре-
жиме, но pg_ctl реализует задачи направления вывода в журнал и отсоединения от терминала и
группы процессов, а также предоставляет удобный интерфейс остановки кластера.
Команда init (initdb) создаёт кластер баз данных PostgreSQL, то есть коллекцию баз данных,
которой будет управлять один экземпляр сервера. Эта команда вызывает программу initdb. За
подробностями обратитесь к initdb.
Команда start запускает сервер. Процесс запускается в фоне, а стандартный ввод связывается
с /dev/null (или nul в Windows). По умолчанию в Unix-подобных системах вывод и ошибки сер-
вера пишутся в устройство стандартного вывода (не ошибок) pg_ctl. Вывод pg_ctl следует перена-
править в файл или процесс, например, приложение ротации журналов rotatelogs; иначе postgres
будет писать вывод в управляющий терминал (в фоновом режиме) и останется в группе процессов
оболочки. В Windows вывод и ошибки сервера по умолчанию перенаправляются в терминал. Это
поведение по умолчанию можно изменить и направить вывод сервера в файл, добавив ключ -l.
Предпочтительными вариантами является использование -l или перенаправление вывода.
Команда stop останавливает сервер, работающий с указанным каталогом данных. Параметр -m
позволяет выбрать один из трёх режимов остановки. Режим «Smart» ожидает отключения всех
активных клиентов и завершения всех текущих процессов резервного копирования. Если сервер
работает в режиме горячего резерва, восстановление и потоковая репликация будут прерваны, как
только отключатся все клиенты. Режим «Fast» (выбираемый по умолчанию) не ожидает отключе-
ния клиентов и завершает все текущие процессы резервного копирования. Все активные транзак-
ции откатываются, а клиенты принудительно отключаются, после чего сервер останавливается.
Режим «Immediate» незамедлительно прерывает все серверные процессы, не выполняя процеду-
1881pg_ctl
ру штатной остановки. Этот вариант влечёт необходимость выполнить восстановление после сбоя
при следующем запуске сервера.
Команда restart по сути производит остановку и последующий запуск сервера. Это позволяет из-
менить параметры командной строки postgres либо применить изменения в файле конфигурации,
не вступающие в силу без перезапуска сервера. Если в командной строке при запуске сервера
указывались относительные пути, команда restart может не выполниться, если вызвать pg_ctl не
в том каталоге, где производился предыдущий запуск.
Команда reload просто посылает процессу сервера postgres сигнал SIGHUP, получив который он
перечитывает свои файлы конфигурации (postgresql.conf, pg_hba.conf и т. д.). Это позволяет
применить изменения параметров в файле конфигурации, не требующие полного перезапуска сер-
вера.
Команда status проверяет, работает ли сервер в указанном каталоге данных. Если да, она выдаёт
PID сервера и параметры командной строки, с которыми он был запущен. Если сервер не работает,
pg_ctl возвращает код выхода 3. Если в параметрах не указан доступный каталог данных, pg_ctl
возвращает код выхода 4.
Команда promote указывает серверу, работающему в режиме резерва с указанным каталогом дан-
ных, выйти из этого режима и начать операции чтения/записи.
Команда kill передаёт сигнал заданному процессу. Прежде все это полезно в Microsoft Windows,
где отсутствует встроенная команда kill. Для получения списка имён поддерживаемых сигналов
воспользуйтесь ключом –help.
Команда register регистрирует сервер PostgreSQL в качестве системной службы в Microsoft
Windows. Параметр -S позволяет выбрать тип запуска службы: «auto» (запускать службу автома-
тически при загрузке системы) или «demand» (запускать службу по требованию).
Режим unregister разрегистрирует системную службу в Microsoft Windows. Эта операция отме-
няет действие команды register.
Параметры
-c
–core-files
Способствует сбросу дампа памяти процесса при крахе сервера на платформах, где это возмож-
но, поднимая мягкие ограничения, задаваемые для файлов дампа. Это полезно при отладке
и диагностике проблем, так как позволяет получить трассировку стека отказавшего процесса
сервера.
-D каталог_данных
–pgdata=каталог_данных
Указывает размещение конфигурационных файлов кластера. Если этот ключ опущен, исполь-
зуется значение переменной окружения PGDATA.
-l имя_файла
–log=имя_файла
Направляет вывод сообщений сервера в файл имя_файла. Файл создаётся, если он ещё не суще-
ствует. При этом устанавливается umask 077, что предотвращает доступ других пользователей
к этому файлу.
-m режим
–mode=режим
Задаёт режим остановки кластера. Значением режим может быть smart, fast или immediate,
либо первая буква этих вариантов. Если этот ключ опущен, по умолчанию выбирается режим
fast.
1882pg_ctl
-o параметры
–options=параметры
Указывает параметры, которые будут передаваться непосредственно программе postgres.
Ключ -o можно указывать несколько раз, при этом ей будут переданы параметры из всех клю-
чей.
Задаваемые параметры обычно следует обрамлять одинарными или двойными кавычками, что-
бы они передавались одной группой.
-o параметры-initdb
–options=параметры-initdb
Указывает параметры, которые будут передаваться непосредственно программе initdb. Ключ
-o можно указывать несколько раз, при этом ей будут переданы параметры из всех ключей.
Задаваемые параметры-initdb обычно следует обрамлять одинарными или двойными кавычка-
ми, чтобы они передавались вместе одной группой.
-p путь
Указывает размещение исполняемого файла postgres. По умолчанию задействуется исполняе-
мый файл postgres из того же каталога, из которого запускался pg_ctl, а если это невозможно,
из жёстко заданного каталога инсталляции. Применять этот параметр может понадобиться,
только если вы делаете что-то необычное или получаете сообщения, что найти исполняемый
файл postgres не удаётся.
В режиме init этот параметр аналогичным образом задаёт размещение исполняемого файла
initdb.
-s
–silent
Выводить лишь ошибки, без сообщений информационного характера.
-t секунды
–timeout=секунды
Задаёт максимальное время (в секундах) ожидания завершения операции (см. параметр -w).
По умолчанию действует значение переменной среды PGCTLTIMEOUT или, если оно не задано,
60 секунд.
-V
–version
Выводит версию pg_ctl и прерывает выполнение.
-w
–wait
Ждать завершения операции. Этот режим поддерживается для команд start, stop, restart,
promote и register.
В процессе ожидания pg_ctl постоянно проверяет PID-файл сервера, приостанавливаясь на
короткое время между проверками. Запуск считается завершённым, когда PID-файл указывает
на то, что сервер готов принимать подключения. Остановка считается завершённой, когда сер-
вер удаляет свой PID-файл. Программа pg_ctl возвращает код выхода в зависимости от успеха
запуска или остановки.
Если операция не заканчивается за отведённое время (см. параметр -t), программа pg_ctl за-
вершается с ненулевым кодом выхода. Но заметьте, что при этом выполнение операции может
продолжиться и в конце концов увенчаться успехом.
1883pg_ctl
-W
–no-wait
Не ждать завершения операции. Этот режим противоположен режиму -w.
Если ожидание отключено, запрошенное действие вызывается, но о его результате ничего не
известно. В этом случае для проверки текущего состояния и результата операции потребуется
обратиться к файлу журнала сервера или воспользоваться внешней системой мониторинга.
В предыдущих выпусках PostgreSQL этот режим действовал по умолчанию (кроме команды
stop).
-?
–help
Вывести справку по команде pg_ctl и прервать выполнение.
Если некоторый параметр является допустимым, но не применим к выбранному режиму работы,
pg_ctl игнорирует его.
Параметры, специфичные для Windows
-e source
Имя источника событий, с которым pg_ctl будет записывать в системный журнал события при
запуске в виде службы Windows. Имя по умолчанию — PostgreSQL. Заметьте, что это влияет
только на сообщения, которые выдаёт сам pg_ctl; как только сервер запустится, он будет ис-
пользовать источник событий, заданный в event_source. Если произойдёт ошибка при запуске
сервера на ранней стадии, прежде чем будет считан этот параметр, он может также выдавать
сообщения с источником по умолчанию PostgreSQL.
-N имя_службы
Имя регистрируемой системной службы. Оно станет и собственно именем службы, и отобра-
жаемым именем. По умолчанию — PostgreSQL.
-P пароль
Пароль для пользователя, запускающего службу.
-S тип-запуска
Тип запуска системной службы. В качестве значения тип-запуска можно задать auto, demand
или первую букву этих слов. По умолчанию выбирается тип auto.
-U имя_пользователя
Имя пользователя, от имени которого будут запущена служба. Для доменных пользователей
используйте формат DOMAIN\username.
Переменные окружения
PGCTLTIMEOUT
Значение по умолчанию для максимального времени ожидания запуска или остановки сервера
(в секундах). По умолчанию это время составляет 60 секунд.
PGDATA
Размещение каталога хранения данных по умолчанию.
Для большинства режимов pg_ctl требуется знать расположение каталога данных; поэтому если
не задана переменная PGDATA, параметр -D является обязательным.
pg_ctl, как и большинство других утилит PostgreSQL, также использует переменные окружения,
поддерживаемые libpq (см. Раздел 34.14).
1884pg_ctl
Список дополнительных переменных, влияющих на работу сервера, можно найти в postgres.
Файлы
postmaster.pid
Проверяя этот файл в каталоге данных, pg_ctl определяет, работает ли сервер в настоящий
момент.
postmaster.opts
Если файл существует в каталоге хранения данных, то pg_ctl (при restart) передаст его содер-
жимое в качестве аргументов postgres, если не указаны иные значения в -o. Содержимое фай-
ла также отображается при вызове в режиме status.
Примеры
Запуск сервера
Запуск сервера и ожидание момента, когда он начнёт принимать подключения:
$ pg_ctl start
Чтобы запустить сервер с использованием порта 5433 и без fsync, выполните:
$ pg_ctl -o “-F -p 5433” start
Остановка сервера
Чтобы остановить сервер, выполните:
$ pg_ctl stop
Ключ -m позволяет управлять тем, как сервер будет остановлен:
$ pg_ctl stop -m smart
Повторный запуск сервера
Перезапуск сервера почти равнозначен остановке и запуску сервера за исключением того, что
по умолчанию pg_ctl сохраняет параметры командной строки, которые были переданы ранее за-
пущенному экземпляру. Таким образом, чтобы перезапустить сервер с теми же параметрами, с
какими он был запущен, выполните:
$ pg_ctl restart
Но если добавляется ключ -o, он заменяет все предыдущие параметры. Эта команда осуществит
перезапуск с использованием порта 5433 и без fsync:
$ pg_ctl -o “-F -p 5433” restart
Вывод состояния сервера
Ниже представлен примерный вывод pg_ctl:
$ pg_ctl status
pg_ctl: server is running (PID: 13718)
/usr/local/pgsql/bin/postgres “-D” “/usr/local/pgsql/data” “-p” “5433” “-B” “128”
Во второй строке показывается команда, которая будет выполнена в режиме перезапуска.
См. также
initdb, postgres
1885pg_resetwal
pg_resetwal — очистка журнала предзаписи и другой управляющей информации кластера
PostgreSQL
Синтаксис
pg_resetwal [ –force | -f ] [ –dry-run | -n ] [параметр…] [ –pgdata | -D ]каталог_данных
Описание
pg_resetwal очищает журнал предзаписи (WAL) и может сбросить некоторую другую управляю-
щую информацию, хранящуюся в файле pg_control. Данная функция может быть востребована
при повреждении этих файлов. Использовать её нужно только как крайнюю меру, когда запуск
сервера оказывается невозможен из-за этого повреждения.
После выполнения этой команды запуск сервера, скорее всего, будет возможен, однако стоит учи-
тывать, что база данных может содержать несогласованные данные из-за транзакций, зафиксиро-
ванных частично. Вы должны немедленно выгрузить данные, выполнить initdb, а затем восстано-
вить данные. После этого проверьте целостность базы и внесите необходимые коррективы.
Эту утилиту может запускать только пользователь, установивший сервер, так как ей нужны права
записи/чтения в каталоге хранения данных кластера. В целях безопасности каталог необходимо
указывать в командной строке. pg_resetwal не поддерживает переменную окружения PGDATA.
Если pg_resetwal выводит сообщение о невозможности определить данные из pg_control, то ко-
манду можно запустить принудительно, указав -f. В этом случае будут использованы наиболее ве-
роятные значения. Для большинства полей это нормально, но для некоторых может потребовать-
ся явное указание: следующее значение OID, следующее значение ID транзакции и времени, ID
мультитранзакции и смещение, начальная позиция WAL. Эти значения можно указать с помощью
описанных далее параметров. Если их невозможно определить, то флаг f позволяет это обойти,
однако, достоверность данных восстановленной базы останется под сомнением: крайне необходи-
мо незамедлительно выгрузить и затем восстановить данные. Не выполняйте никаких операций
модификации до создания дампа данных, так как это может привести к ещё более печальным по-
следствиям.
Параметры
-f
–force
Принудительно выполнять pg_resetwal, даже если не удаётся получить приемлемые данные
из pg_control, как описано выше.
-n
–dry-run
С ключом -n/–dry-run команда pg_resetwal отображает значения, извлечённые из
pg_control, а также значения, которые планируется изменить, и завершается, не внося ника-
ких изменений. Это, прежде всего, средство отладки, хотя оно может быть полезно и для того,
чтобы проверить корректность параметров, прежде чем pg_resetwal начнёт что-либо делать.
-V
–version
Показать версию, а затем завершиться.
-?
–help
Показать справку, а затем завершиться.
1886pg_resetwal
Следующие параметры необходимы, только когда pg_resetwal не может определить подходящие
значения, прочитав pg_control. Безопасные значения можно определить, как описано ниже. Для
значений, принимающих числовые аргументы, можно задать шестнадцатеричные значения, доба-
вив префикс 0x.
-c xid,xid
–commit-timestamp-ids=xid,xid
Вручную задать идентификаторы старейшей и новейшей транзакций, для которых можно по-
лучить время фиксации.
Безопасное значение идентификатора старейшей транзакции, для которой можно получить
время фиксации (первый компонент), можно определить, найдя наименьшее в числовом виде
имя файла в каталоге pg_commit_ts внутри каталога данных. Безопасное значение идентифи-
катора новейшей транзакции, для которой можно получить время фиксации (второй компо-
нент), можно определить, найдя, напротив, наибольшее в числовом виде имя файла в том же
каталоге. Числа в именах этих файлов представлены в шестнадцатеричном формате.
-e эпоха_xid
–epoch=эпоха_xid
Вручную задать эпоху в ID следующей транзакции.
Эпоха идентификаторов транзакции не хранится в базе данных нигде, кроме поля, устанавли-
ваемого командой pg_resetwal, поэтому если рассматривать собственно базу, допустимым бу-
дет любое значение. Это значение, возможно, понадобится скорректировать для обеспечения
правильной работы системы репликации, например, Slony-I и Skytools. В этом случае подходя-
щее значение следует получить из состояния нижележащей реплицированной базы данных.
-l walfile
–next-wal-file=walfile
Вручную задать начальную позицию WAL, указав имя файла следующего сегмента WAL.
Имя файла следующего сегмента WAL должно превышать имена любых других файлов сегмен-
тов WAL, в настоящее время находящихся в подкаталоге pg_wal каталога данных. Эти имена
тоже представлены в шестнадцатеричном виде и состоят из трёх частей. Первая из них — «ID
линии времени» и её обычно не следует менять. Например, если 00000001000000320000004A
— наибольшее значение в pg_wal, нужно указать -l 00000001000000320000004B или большее
число.
Заметьте, что при использовании нестандартных размеров сегментов WAL числа в именах фай-
лов WAL отличаются от LSN, выдаваемых системными функциями и представлениями. Этот
параметр принимает имя файла WAL, а не LSN.
Примечание
pg_resetwal ищет среди файлов каталога pg_wal, и по умолчанию выбирает значе-
ние для флага -l, идущее следующим после найденного. Таким образом, вручную
задавать параметр -l нужно лишь если известно о существовании сегментов WAL,
отсутствующих в настоящий момент в каталоге pg_wal (например, они могут нахо-
дится в отдельном архиве); либо если содержимое pg_wal было полностью утеряно.
-m mxid,mxid
–multixact-ids=mxid,mxid
Вручную задать ID следующей и старейшей мультитранзакции.
Безопасное значение следующего идентификатора мультитранзакции (первый компонент)
можно вычислить, найдя наибольшее числовое значение среди имён файлов, расположенных
1887pg_resetwal
в каталоге pg_multixact/offsets. К найденному значению необходимо прибавить один, затем
умножить на 65536 (0x10000). Для вычисления безопасного значения ID старейшей мультит-
ранзакции (второй компонент -m) необходимо найти наименьшее числовое значение среди тех
же файлов, и умножить его на 65536. Имена файлов представляются в шестнадцатеричном
формате, так что значения проще указывать в нём же, добавив в конце четыре нуля.
-o oid
–next-oid=oid
Вручную задать следующий OID.
Не существует относительно простого способа вычисления следующего за наибольшим из су-
ществующих значением OID, однако это некритично.
-O mxoff
–multixact-offset=mxoff
Вручную задать смещение следующей мультитранзакции.
Безопасное значение можно определить, найдя наибольшее числовое значение в имени фай-
ла в каталоге pg_multixact/members, прибавив один и умножив результат на 52352 (0xCC80).
Имена файлов представлены в шестнадцатеричном формате. Простого рецепта с прибавлени-
ем нулей в конце, как для других параметров, в данном случае нет.
–wal-segsize=размер_сегмента_wal
Задать другой размер сегмента WAL, в мегабайтах. Значение параметра должно быть степенью
2 от 1 до 1024 (в мегабайтах). Подробнее о нём можно узнать в описании такого же параметра
initdb.
Примечание
Хотя pg_resetwal выбирает стартовый адрес WAL, превышающий номер последнего
существующего файла сегмента WAL, при некоторых изменениях размера предыду-
щие имена файлов WAL могут использоваться повторно. Если наложение имён фай-
лов WAL приведёт к проблемам с вашей стратегией архивации, рекомендуется ис-
пользовать -l вместе с этим ключом, чтобы вручную задать начальный адрес WAL.
-x xid
–next-transaction-id=xid
Вручную задать ID следующей транзакции.
Безопасное значение можно определить, найдя наибольшее числовое значение в имени фай-
ла в подкаталоге pg_xact каталога данных, прибавив один и умножив результат на 1048576
(0x100000). Заметьте, что имена файлов представлены в шестнадцатеричном формате. Значе-
ние этого параметра обычно также проще задавать в шестнадцатеричном виде. Например, если
0011 — наибольшее значение в pg_xact, подходящим значением будет -x 0x1200000 (нужный
множитель дают пять последних нулей).
Замечания
Эту команду нельзя выполнять на работающем сервере. pg_resetwal отклонит выполнение при
обнаруженном блокирующем файле в каталоге хранения данных. Иногда при аварии сервера бло-
кирующий файл может остаться в системе. В этом случае необходимо самостоятельно удалить его,
чтобы дать возможность pg_resetwal отработать. Перед выполнением операции дважды проверь-
те, что сервер остановлен.
pg_resetwal работает только с серверами той же основной версии.
1888pg_resetwal
См. также
pg_controldata
1889pg_rewind
pg_rewind — синхронизировать каталог данных PostgreSQL с другим каталогом, ответвлённым от
него
Синтаксис
pg_rewind [параметр…] ( -D | –target-pgdata )каталог ( –source-pgdata=каталог | –source-
server=строка_подключения )
Описание
Утилита pg_rewind представляет собой средство синхронизации кластера PostgreSQL с другой ко-
пией того же кластера после расхождения линий времени этих кластеров. Обычный сценарий её
использования — вернуть в работу старый главный сервер после переключения на резервный, в
качестве резервного для сервера, ставшего главным.
Её результат равнозначен замене целевого каталога данных исходным. В файлах отношений она
копирует только изменённые блоки; все остальные файлы, включая файлы конфигурации, копи-
руются целиком. Преимущество pg_rewind по сравнению с созданием новой базовой копии или
такими средствами, как rsync, состоит в том, что pg_rewind не читает неизменённые блоки в кла-
стере. Благодаря этому она действует гораздо быстрее, когда база данных большая, но различия
между кластерами ограничиваются лишь небольшим количеством блоков.
Утилита pg_rewind изучает истории линий времени исходного и целевого кластеров с целью най-
ти точку, в которой они разошлись, и ожидает найти журналы WAL в каталоге pg_wal целевого
кластера вплоть до точки расхождения. Точка расхождения может быть найдена на целевой или
исходной линии времени либо в их общем предке. В типичном сценарии отработки отказа, когда
целевой кластер отключается вскоре после расхождения, это не проблема, но если целевой кла-
стер проработал долгое время после расхождения, старые файлы WAL могут быть уже удалены. В
этом случае их можно вручную скопировать из архива WAL в каталог pg_wal либо считать при за-
пуске, настроив recovery.conf. Варианты использования pg_rewind не ограничиваются отработ-
кой отказа; например, резервный сервер может быть повышен, выполнить несколько транзакций
с записью, а затем, после восстановления синхронизации, вновь стать резервным.
Когда целевой сервер запускается в первый раз после выполнения pg_rewind, он переходит в ре-
жим восстановления и воспроизводит все изменения из WAL с исходного сервера после точки рас-
хождения. Если какие-то сегменты WAL оказались недоступны на исходном сервере, когда выпол-
нялась pg_rewind, и поэтому не могли быть скопированы в ходе работы pg_rewind, их необходимо
предоставить, когда сервер будет запускаться. Это можно сделать, создав в целевом каталоге дан-
ных файл recovery.conf с подходящей командой restore_command.
Утилита pg_rewind требует, чтобы на целевом сервере был либо включён режим wal_log_hints в
postgresql.conf, либо включены контрольные суммы, когда кластер был инициализирован ко-
мандой initdb. Оба эти режима по умолчанию отключены. Также должен быть включён режим
full_page_writes, но он по умолчанию включён.
Предупреждение
Если во время работы pg_rewind происходит ошибка, вероятнее всего, целевой каталог
данных будет в состоянии, не подходящем для восстановления. В этом случае рекомен-
дуется сделать новую резервную копию.
Программа pg_rewind немедленно прекращает работу, если обнаруживает файлы,
непосредственная запись в которые невозможна. Это может иметь место, например,
когда на исходном и целевом серверах совпадают пути файлов сертификатов и ключей
SSL, доступных только для чтения. Если такие файлы существуют на целевом серве-
ре, их рекомендуется удалить до запуска pg_rewind. После выполнения синхронизации
1890pg_rewind
некоторые из таких файлов могут быть скопированы из источника и тогда может по-
требоваться удалить скопированные данные и восстановить ссылки/файлы, существо-
вавшие до синхронизации.
Параметры
pg_rewind принимает следующие аргументы командной строки:
-D каталог
–target-pgdata=каталог
Этот параметр задаёт целевой каталог данных, который будет синхронизирован с источником.
Целевой сервер должен быть отключён штатным образом до запуска pg_rewind
–source-pgdata=каталог
Задаёт путь в файловой системе к каталогу данных исходного сервера, с которым будет синхро-
низироваться целевой. Для применения этого ключа исходный сервер должен быть остановлен
штатным образом.
–source-server=строка_подключения
Задаёт строку подключения libpq для подключения к исходному серверу PostgreSQL, с которым
будет синхронизирован целевой. Подключение должно устанавливаться как обычное (не реп-
лицирующее) с правами суперпользователя. Для применения этого параметра исходный сер-
вер должен быть запущен и работать не в режиме восстановления.
-n
–dry-run
Делать всё, кроме внесения изменений в целевой каталог.
-P
–progress
Включает вывод сообщений о прогрессе. При этом в процессе копирования данных из исход-
ного кластера будет выдаваться приблизительный процент выполнения.
–debug
Выводить подробные отладочные сообщения, полезные в основном для разработчиков, отла-
живающих pg_rewind.
-V
–version
Показать версию, а затем завершиться.
-?
–help
Показать справку, а затем завершиться.
Переменные окружения
Когда используется –source-server, pg_rewind также использует переменные среды, поддержи-
ваемые libpq (см. Раздел 34.14).
Замечания
Как это работает
Основная идея состоит в том, чтобы перенести все изменения на уровне файловой системы из
исходного кластера в целевой:
1891pg_rewind</li>
      <li>Просканировать журнал WAL в целевом кластере, начиная с последней контрольной точки
перед моментом, когда история линии времени исходного кластера разошлась с целевым кла-
стером. Для каждой записи WAL отметить, какие блоки данных были затронуты. В результате
будет получен список всех блоков данных, которые были изменены в целевом кластере после
отделения исходного.</li>
      <li>Скопировать все эти изменённые блоки из исходного кластера в целевой либо на уровне фай-
ловой системы (–source-pgdata), либо на уровне SQL (–source-server).</li>
      <li>Скопировать все остальные файлы, в частности pg_xact и файлы конфигурации, из исходного
кластера в целевой (пропуская при этом файлы отношений). Как и при базовом копировании,
содержимое каталогов pg_dynshmem/, pg_notify/, pg_replslot/, pg_serial/, pg_snapshots/,
pg_stat_tmp/ и pg_subtrans/ исключается из данных, копируемых из исходного кластера.
Также исключаются файлы или каталоги с именами, начинающимися с pgsql_tmp, а также
файлы backup_label, tablespace_map, pg_internal.init, postmaster.opts и postmaster.pid.</li>
      <li>Применить WAL из исходного кластера, начиная с контрольной точки, созданной при отработ-
ке отказа. (Строго говоря, утилита pg_rewind не применяет WAL, она просто создаёт файл мет-
ки резервной копии, обнаружив который, PostgreSQL начинает воспроизведение всех записей
WAL от этой контрольной точки.)
1892pg_test_fsync
pg_test_fsync — подобрать наилучший вариант wal_sync_method для PostgreSQL
Синтаксис
pg_test_fsync [параметр…]
Описание
Программа pg_test_fsync предназначена для того, чтобы дать вам представление о том, какой из
вариантов wal_sync_method оптимален для вашей конкретной системы, а также выдать вспомога-
тельные диагностические сведения в случае проблем со вводом/выводом. Однако отличия, пока-
занные программой pg_test_fsync, могут не оказывать большого влияния на реальную производи-
тельность баз данных, в частности потому, что для многих серверов баз данных производитель-
ность упирается не в запись журналов предзаписи. pg_test_fsync выводит среднее время операции
синхронизации с ФС для каждого метода wal_sync_method, что также может быть полезно при по-
иске оптимального значения commit_delay.
Параметры
pg_test_fsync принимает следующие параметры командной строки:
-f
–filename
Задаёт имя файла для записи данных тестов. Этот файл должен находиться в той же файловой
системе, где размещается или будет размещаться каталог pg_wal. (В каталоге pg_wal содер-
жатся файлы WAL.) По умолчанию выбирается файл pg_test_fsync.out в текущем каталоге.
-s
–secs-per-test
Задаёт продолжительность каждого теста (в секундах). Чем больше длится тест, тем точнее ре-
зультат, но тем дольше работает программа. Со значением по умолчанию (5 секунд) программа
должна завершиться примерно за 2 минуты.
-V
–version
Вывести версию pg_test_fsync и завершиться.
-?
–help
Вывести справку об аргументах командной строки pg_test_fsync и завершиться.
См. также
postgres
1893pg_test_timing
pg_test_timing — определить издержки замера времени
Синтаксис
pg_test_timing [параметр…]
Описание
Программа pg_test_timing позволяет оценить издержки замера времени в вашей системе и убе-
диться в том, что системное время никогда не идёт назад. Системы, в которых замер времени яв-
ляется длительной операцией, дают менее точные результаты EXPLAIN ANALYZE.
Параметры
pg_test_timing принимает следующие аргументы командной строки:
-d длительность
–duration=длительность
Задаёт продолжительность теста (в секундах). Чем больше эта продолжительность, тем выше
точность и больше вероятность обнаружить аномалию с обратным ходом системных часов. По
умолчанию время тестирования — 3 секунды.
-V
–version
Вывести версию pg_test_timing и завершиться.
-?
–help
Вывести справку об аргументах командной строки pg_test_timing и завершиться.
Использование
Интерпретация результатов
В благоприятном случае практически все (&gt;90%) отдельные вызовы замеров времени должны вы-
полняться быстрее одной микросекунды. Средние издержки замера на цикл должны быть ещё
меньше, в пределах 100 наносекунд. Эта проба, взятая в системе Intel i7-860 через источник вре-
мени TSC, показывает отличную производительность:
Testing timing overhead for 3 seconds.
Per loop time including overhead: 35.96 ns
Histogram of timing durations:
&lt; us
% of total
count
1
96.40465
80435604
2
3.59518
2999652
4
0.00015
126
8
0.00002
13
16
0.00000
2
Заметьте, что время вызова в цикле и время в гистограмме выражается в разных единицах. Время
в цикле может определяться с точностью до наносекунд (ns), а длительность отдельного вызова
замера времени — только с точностью до микросекунд (us).
Измерение издержек исполнителя на замер времени
Когда исполнитель запроса выполняет запрос под контролем EXPLAIN ANALYZE, замеряется не толь-
ко общее время, но и время отдельных операций. Каковы издержки этих операций в вашей систе-
ме, можно узнать, подсчитав строки тестовой таблицы в программе psql:
1894pg_test_timing
CREATE TABLE t AS SELECT * FROM generate_series(1,100000);
\timing
SELECT COUNT(<em>) FROM t;
EXPLAIN ANALYZE SELECT COUNT(</em>) FROM t;
В системе i7-860 этот запрос выполняется 9.8 мс, а версия с EXPLAIN ANALYZE — 16.6 мс, при этом об-
рабатывается около 100 000 строк. Это различие в 6.8 мс означает, что издержки замера времени
для одной строки составляют около 68 нс, примерно вдвое больше, чем предсказала pg_test_timing.
Даже с такими относительно небольшими издержками операция COUNT с полным подсчётом вре-
мени выполняется почти на 70% дольше. На более сложных запросах издержки замера времени
могут быть не так важны.
Смена источника времени
В некоторых современных системах Linux можно в любой момент сменить источник времени, ко-
торый используется для замера времени. Второй пример иллюстрирует возможное замедление от
переключения на более медленный источник времени acpi_pm time в той же системе, в которой
были получены показанные выше хорошие результаты:
        <h1 id="cat-sysdevicessystemclocksourceclocksource0available_clocksource">cat /sys/devices/system/clocksource/clocksource0/available_clocksource</h1>
        <p>tsc hpet acpi_pm</p>
        <h1 id="echo-acpi_pm--sysdevicessystemclocksourceclocksource0current_clocksource">echo acpi_pm &gt; /sys/devices/system/clocksource/clocksource0/current_clocksource</h1>
        <h1 id="pg_test_timing">pg_test_timing</h1>
        <p>Per loop time including overhead: 722.92 ns
Histogram of timing durations:
&lt; us
% of total
count
1
27.84870
1155682
2
72.05956
2990371
4
0.07810
3241
8
0.01357
563
16
0.00007
3
В этой конфигурации тот же EXPLAIN ANALYZE выполняется 115.9 мс. Таким образом издержки
составили 1061 нс, что соответствует непосредственному результату этой утилиты с небольшим
коэффициентом. Такие большие издержки означают, что сам запрос выполняется лишь неболь-
шой процент всего времени, а основное время уходит на замеры времени. В такой конфигурации
временные показатели EXPLAIN ANALYZE для запросов со множеством замеряемых операций зна-
чительно увеличатся за счёт издержек замера времени.
FreeBSD так же позволяет сменять источник времени «на лету» и выводит информацию о выбран-
ном таймере при загрузке:</p>
        <h1 id="dmesg--grep-timecounter">dmesg | grep “Timecounter”</h1>
        <p>Timecounter “ACPI-fast” frequency 3579545 Hz quality 900
Timecounter “i8254” frequency 1193182 Hz quality 0
Timecounters tick every 10.000 msec
Timecounter “TSC” frequency 2531787134 Hz quality 800</p>
        <h1 id="sysctl-kerntimecounterhardwaretsc">sysctl kern.timecounter.hardware=TSC</h1>
        <p>kern.timecounter.hardware: ACPI-fast -&gt; TSC
Другие системы могут допускать смену источника времени только при загрузке. В старых систе-
мах Linux это можно было сделать только с помощью параметра ядра «clock». И даже в некоторых
самых последних системах можно увидеть только один источник времени — jiffies. Это старая про-
граммная реализация часов в Linux, которая может давать хорошее разрешение, когда поддержи-
вается достаточно хорошим оборудованием, как в этом примере:
$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource
jiffies
$ dmesg | grep time.c
time.c: Using 3.579545 MHz WALL PM GTOD PIT/TSC timer.
1895pg_test_timing
time.c: Detected 2400.153 MHz processor.
$ pg_test_timing
Testing timing overhead for 3 seconds.
Per timing duration including loop overhead: 97.75 ns
Histogram of timing durations:
&lt; us
% of total
count
1
90.23734
27694571
2
9.75277
2993204
4
0.00981
3010
8
0.00007
22
16
0.00000
1
32
0.00000
1
Аппаратные часы и точность замера времени
Измерение времени обычно осуществляется на компьютерах по аппаратным часам, точность ко-
торых может быть разного уровня. С некоторым оборудованием операционные системы могут пе-
редавать время системных часов непосредственно программам. Также системное время может
поступать с чипа, который просто генерирует прерывания по времени, с заведомо известным пе-
риодом. В любом случае ядра операционных систем предоставляют источник времени, который
скрывает эти детали. Но точность этого источника и возможная скорость получения результатов
от него зависит от нижележащего оборудования.
Неточность в замерах времени может приводить к нестабильности системы. Поэтому стоит очень
тщательно протестировать выбранный источник времени. Иногда по умолчанию в ОС выбирается
источник не более точный, а более надёжный. И если вы используете виртуальную машину, по-
интересуйтесь, какие источники времени рекомендуется использовать с ней. Имитация таймеров
на виртуальном оборудовании связана с дополнительными сложностями, и производители средств
виртуализации часто рекомендуют определённые параметры для операционных систем.
Источник времени TSC (Time Stamp Counter, Счётчик отметки времени) наиболее точный из всех
для процессоров текущего поколения. Его рекомендуется использовать для получения системного
времени, когда он поддерживается операционной системой и показания TSC надёжны. Возмож-
ны ситуации, когда TSC не является точным источником времени, и таким образом, оказывается
ненадёжным. Например, в старых системах показания TSC могут зависеть от температуры про-
цессора, что не годится для точного замера времени. При попытке использовать TSC в некоторых
старых многоядерных процессорах можно получить разное время на различных ядрах. В резуль-
тате может оказаться, что время идёт назад (эту аномалию выявляет данная программа). И даже
на самых современных системах не всегда можно получить точное время через TSC в режимах
очень агрессивного энергосбережения.
Новые операционные системы могут проверять наличие известных проблем TSC и переключаться
на более медленный, но более стабильный источник времени, если они проявляются. Если ваша
система поддерживает источник TSC, но не выбирает его по умолчанию, возможно, он отключён
обоснованно. С другой стороны, некоторые операционные системы могут не выявлять все возмож-
ные проблемы, либо разрешают использовать TSC даже в ситуациях, когда он определённо нето-
чен.
HPET (High Precision Event Timer, Таймер событий высокой точности) рекомендуется использовать
в системах, где он имеется, а TSC неточен. Сам этот чип можно запрограммировать для получения
точности до 100 наносекунд, но системное время с такой точностью вы не получите.
ACPI (Advanced Configuration and Power Interface, Расширенный интерфейс конфигурации и пита-
ния) обеспечивает таймер PM (Управления питанием), который в Linux называется acpi_pm. Вре-
мя, поступающее из acpi_pm, в лучшем случае будет иметь разрешение 300 наносекунд.
На старом оборудовании PC применялись таймеры 8254 PIT (Programmable Interval Timer, Програм-
мируемый интервальный таймер), RTC (Real-Time Clock, Часы реального времени), таймер APIC
(Advanced Programmable Interrupt Controller, Расширенный программируемый контроллер преры-
ваний) и Cyclone. Все эти таймеры обеспечивали точность до миллисекунд.
1896pg_test_timing
См. также
EXPLAIN
1897pg_upgrade
pg_upgrade — обновить экземпляр сервера PostgreSQL
Синтаксис
pg_upgrade -b старый_каталог_bin -B новый_каталог_bin -d старый_каталог_конфигурации -D но-
вый_каталог_конфигурации [параметр…]
Описание
Программа pg_upgrade (ранее называвшаяся pg_migrator) позволяет обновить данные в каталоге
базы данных PostgreSQL до последней основной версии PostgreSQL без операции выгрузки/пере-
загрузки данных, обычно необходимой при обновлениях основной версии, например, при перехо-
де от 9.5.8 к 9.6.4 или от 10.7 к 11.2. Эти действия не требуются при установке корректирующей
версии, например, при переходе от 9.6.2 к 9.6.3 или от 10.1 к 10.2.
С выходом новых основных версий в PostgreSQL регулярно добавляются новые возможности, кото-
рые часто меняют структуру системных таблицы, но внутренний формат хранения меняется ред-
ко. Учитывая этот факт, pg_upgrade позволяет выполнить быстрое обновление, создавая систем-
ные таблицы заново, но сохраняя старые файлы данных. Если при обновлении основной версии
формат хранения данных изменится так, что данные в старом формате окажутся нечитаемыми,
pg_upgrade не сможет произвести такое обновление. (Сообщество разработчиков постарается не
допустить подобных ситуаций.)
Программа pg_upgrade делает всё возможное, чтобы убедиться в том, что старый и новый кластеры
двоично-совместимы, в частности проверяя параметры времени компиляции и разрядность (32/64
бита) исполняемых файлов. Важно, чтобы и все внешние модули тоже были двоично-совместимы-
ми, хотя это pg_upgrade проверить не может.
pg_upgrade поддерживает обновление с версии 8.4.X и новее до текущей основной версии
PostgreSQL, включая бета-выпуски и сборки снимков кода.
Параметры
pg_upgrade принимает следующие аргументы командной строки:
-b каталог_bin
–old-bindir=каталог_bin
каталог с исполняемыми файлами старой версии PostgreSQL; переменная окружения PGBINOLD
-B каталог_bin
–new-bindir=каталог_bin
каталог с исполняемыми файлами новой версии PostgreSQL; переменная окружения PGBINNEW
-c
–check
только проверить кластеры, не изменять никакие данные
-d каталог_конфигурации
–old-datadir=каталог_конфигурации
каталог конфигурации старого кластера; переменная окружения PGDATAOLD
-D каталог_конфигурации
–new-datadir=каталог_конфигурации
каталог конфигурации нового кластера; переменная окружения PGDATANEW
1898pg_upgrade
-j
–jobs
число одновременно задействуемых процессов или потоков
-k
–link
использовать жёсткие ссылки вместо копирования файлов в новый кластер
-o параметры
–old-options параметры
параметры, передаваемые непосредственно старой программе postgres; несколько парамет-
ров складываются вместе
-O параметры
–new-options параметры
параметры, передаваемые непосредственно новой программе postgres; несколько параметров
складываются вместе
-p порт
–old-port=порт
номер порта старого кластера; переменная окружения PGPORTOLD
-P порт
–new-port=порт
номер порта нового кластера; переменная окружения PGPORTNEW
-r
–retain
сохранить SQL и журналы сообщений даже при успешном завершении
-U имя_пользователя
–username=имя_пользователя
имя пользователя, установившего кластер; переменная окружения PGUSER
-v
–verbose
включить подробные внутренние сообщения
-V
–version
показать версию, а затем завершиться
-?
–help
показать справку, а затем завершиться
Использование
Далее описан план обновления с использованием pg_upgrade:
1.
Переместить старый кластер (необязательно)
Если ваш каталог инсталляции привязан к версии, например, /opt/PostgreSQL/11, перемещать
его не требуется. Все графические инсталляторы выбирают при установке каталоги, привя-
занные к версии.
Если ваш каталог инсталляции не привязан к версии, например /usr/local/pgsql, необходи-
мо переместить каталог текущей инсталляции PostgreSQL, чтобы он не конфликтовал с новой
1899pg_upgrade
инсталляцией PostgreSQL. Когда текущий сервер PostgreSQL отключён, каталог этой инстал-
ляции PostgreSQL можно безопасно переместить; если старый каталог /usr/local/pgsql, его
можно переименовать, выполнив:
mv /usr/local/pgsql /usr/local/pgsql.old
2.
Собрать новую версию при установке из исходного кода
Соберите из исходного кода новую версию PostgreSQL с флагами configure, совместимыми с
флагами старого кластера. Программа pg_upgrade проверит результаты pg_controldata, чтобы
убедиться, что все параметры совместимы, прежде чем начинать обновление.
3.
Установить новые исполняемые файлы PostgreSQL
Установите новые исполняемые файлы сервера и вспомогательные файлы. Программа
pg_upgrade включена в инсталляцию по умолчанию.
При установке из исходного кода, если вы хотите разместить сервер в нестандартном каталоге,
воспользуйтесь переменной prefix:
make prefix=/usr/local/pgsql.new install
4.
Инициализировать новый кластер PostgreSQL
Инициализируйте новый кластер, используя initdb. При этом так же необходимо указать фла-
ги initdb, совместимые с флагами в старом кластере. Многие готовые инсталляторы выполня-
ют это действие автоматически. Запускать новый кластер не требуется.
5.
Установите дополнительные разделяемые объектные файлы
Установите в новый кластер все нестандартные разделяемые объектные файлы (или DLL), ко-
торые использовались в старом кластере, например, pgcrypto.so, где бы они ни находились —
в contrib или в другом месте. Устанавливать определения схемы (например, CREATE EXTENSION
pgcrypto) не требуется, так как они будут перенесены из старого кластера. Кроме того, в новый
кластер нужно скопировать и все нестандартные файлы поддержки полнотекстового поиска
(словари, тезаурусы, списки синонимов и стоп-слов).
6.
Настроить аутентификацию
Программа pg_upgrade будет подключаться к новому и старому серверу несколько раз, так что
имеет смысл установить режим аутентификации peer в pg_hba.conf или использовать файл
~/.pgpass (см. Раздел 34.15).
7.
Остановить оба сервера
Убедитесь в том, что оба сервера баз данных остановлены. Для этого в Unix можно выполнить:
pg_ctl -D /opt/PostgreSQL/9.6 stop
pg_ctl -D /opt/PostgreSQL/11 stop
А в Windows, с соответствующими именами служб:
NET STOP postgresql-9.6
NET STOP postgresql-11
Ведомые серверы с потоковой репликацией и трансляцией журнала могут продолжать рабо-
тать до последнего шага.
8.
Подготовиться к обновлению ведомых серверов
Если вы производите обновление ведомых серверов (как описано в разделе Шаг 10), удосто-
верьтесь, что эти серверы находятся в актуальном состоянии, запустив pg_controldata в ста-
рых ведущем и ведомых кластерах. Убедитесь в том, что «Положение последней контрольной
точки» во всех кластерах одинаковое. (Несовпадение будет иметь место, если старые ведомые
серверы будут отключены раньше, чем старый ведущий, или если старые сервера продолжа-
ют работать.) Также смените wal_level на replica в файле postgresql.conf нового ведущего
кластера.
1900pg_upgrade
9.
Запустить pg_upgrade
Всегда запускайте программу pg_upgrade от нового сервера, а не от старого. pg_upgrade тре-
бует указания каталогов данных старого и нового кластера, а также каталогов исполняемых
файлов (bin). Вы можете также определить имя пользователя и номера портов, и нужно ли
копировать файлы данных (по умолчанию) или создавать ссылки на них.
Если выбрать вариант со ссылкой на данные, обновление выполнится гораздо быстрее (так
как файлы не копируются) и потребует меньше места на диске, но вы лишитесь возможности
обращаться к вашему старому кластеру, запустив новый после обновления. Этот вариант также
требует, чтобы каталоги данных старого и нового кластера располагались в одной файловой
системе. (Табличные пространства и pg_wal могут находиться в других файловых системах.)
Полный список параметров вы можете получить, выполнив pg_upgrade –help.
Параметр –jobs позволяет задействовать для копирования/связывания файлов и для выгруз-
ки/перезагрузки схем баз данных несколько процессорных ядер. В качестве начального значе-
ния параметра стоит выбрать максимум из числа процессорных ядер и числа табличных про-
странств. Этот параметр может радикально сократить время обновления сервера со множе-
ством баз данных, работающего в многопроцессорной системе.
В Windows вы должны войти в систему с административными полномочиями, затем запустить
командную строку от имени пользователя postgres, задать подходящий путь:
RUNAS /USER:postgres “CMD.EXE”
SET PATH=%PATH%;C:\Program Files\PostgreSQL\11\bin;
Наконец, запустить pg_upgrade с путями каталогов в кавычках, например, так:
pg_upgrade.exe
–old-datadir “C:/Program Files/PostgreSQL/9.6/data”
–new-datadir “C:/Program Files/PostgreSQL/11/data”
–old-bindir “C:/Program Files/PostgreSQL/9.6/bin”
–new-bindir “C:/Program Files/PostgreSQL/11/bin”
При запуске pg_upgrade проверит два кластера на совместимость и, если всё в порядке, вы-
полнит обновление. Также возможно запустить pg_upgrade –check, чтобы ограничиться толь-
ко проверками (при этом старый сервер может продолжать работать). Команда pg_upgrade
–check также сообщит, какие коррективы вам нужно будет внести вручную после обновле-
ния. Если вы планируете использовать режим ссылок на данные, укажите вместе с –check
параметр –link, чтобы были проведены специальные проверки для этого режима. Программе
pg_upgrade требуются права на запись в текущий каталог.
Очевидно, никто не должен обращаться к кластерам в процессе обновления. Программа
pg_upgrade по умолчанию запускает серверы с портом 50432, чтобы не допустить нежелатель-
ных клиентских подключений. В процессе обновления оба кластера могут использовать один
номер порта, так как они не будут работать одновременно. Однако для проверки старого рабо-
тающего сервера новый порт должен отличаться от старого.
Если при восстановлении схемы базы данных происходит ошибка, pg_upgrade завершает свою
работу и вы должны вернуться к старому кластеру, как описывается ниже в Шаг 16. Чтобы
попробовать pg_upgrade ещё раз, вы должны внести коррективы в старом кластере, чтобы
pg_upgrade могла успешно восстановить схему. Если проблема возникла в модуле contrib, мо-
жет потребоваться удалить этот модуль contrib в старом кластере, а затем установить его в но-
вом после обновления (предполагается, что этот модуль не хранит пользовательские данные).</p>
      </li>
      <li>Обновить ведомые серверы с потоковой репликацией и трансляцией журнала
Если вы используете режим ссылок и у вас реализована потоковая репликация (см. Подраз-
дел 26.2.5) или трансляция журнала (см. Раздел 26.2) для ведомых серверов, вы можете быстро
обновить эти серверы следующим образом. Вам не нужно будет запускать на них pg_upgrade,
вместо этого вы выполните rsync на ведущем. Не запускайте никакие серверы на этом этапе.
1901pg_upgrade
Если вы не используете режим ссылок, либо у вас нет rsync или вы не хотите его использовать,
либо если вам нужен более простой вариант, пропустите инструкции в этом разделе и просто
пересоздайте ведомые серверы сразу после завершения pg_upgrade и запуска нового ведущего
сервера.
a.
Установите новые исполняемые файлы PostgreSQL на ведомых серверах
Убедитесь в том, что на всех ведомых серверах установлены новые исполняемые и вспомо-
гательные файлы.
b.
Убедитесь в том, что новые каталоги данных на ведомых серверах ## существуют
Новые каталоги данных ведомых серверов должны отсутствовать либо быть пустыми.
Если запускалась программа initdb, удалите новые каталоги данных на ведомых.
c.
Установите дополнительные разделяемые объектные файлы
Установите на новых ведомых серверах те же дополнительные разделяемые объектные
файлы, что вы установили в новом ведущем кластере.
d.
Остановите ведомые серверы
Если ведомые серверы продолжают работу, остановите их, следуя приведённым выше ин-
струкциям.
e.
Сохраните файлы конфигурации
Сохраните все нужные вам файлы конфигурации из старых каталогов конфигурации ведо-
мых серверов, в частности postgresql.conf и recovery.conf, так как они будут перезапи-
саны или удалены на следующем этапе.
f.
Запустите rsync
Когда используется режим ссылок, ведомые серверы можно быстро обновить, применив
rsync. Для этого в каталоге, внутри которого находятся каталоги старого и нового кластера,
для каждого ведомого сервера выполните на ведущем:
rsync –archive –delete –hard-links –size-only –no-inc-recursive old_cluster
new_cluster remote_dir
Здесь каталоги old_cluster и new_cluster задаются относительно текущего каталога на
ведущем, а remote_dir находится над каталогами старого и нового кластера на ведомом.
Структура подкаталогов в заданных каталогах на ведущем и ведомых серверах должна быть
одинаковой. Обратитесь к странице руководства rsync, где подробно описано, как указать
удалённый каталог, например так:
rsync –archive –delete –hard-links –size-only –no-inc-recursive /opt/
PostgreSQL/9.5 \
/opt/PostgreSQL/9.6 standby.example.com:/opt/PostgreSQL
Проверить, что будет делать команда, можно, воспользовавшись параметром rsync –dry-
run. Выполнить rsync на ведущем необходимо как минимум с одним ведомым, но затем,
пока обновлённый ведомый остаётся остановленным, можно запускать rsync на нём для
обновления других ведомых.
В ходе этой операции записываются ссылки, созданные режимом ссылок pg_upgrade, свя-
зывающие файлы нового и старого кластера на ведущем сервере. Затем в старом класте-
ре ведомого находятся соответствующие файлы и в новом кластере ведомого создаются
ссылки на них. Файлы, не связанные ссылками на ведущем, копируются с него на ведо-
мый. (Обычно их объём невелик.) Это позволяет произвести обновление ведомого быстро.
К сожалению, при этом rsync будет напрасно копировать файлы, связанные с временными
и нежурналируемыми таблицами, так как они обычно не будут существовать на ведомых
серверах.
1902pg_upgrade
Если у вас есть табличные пространства, вам потребуется выполнить подобную команду
rsync для каталогов всех табличных пространств, например:
rsync –archive –delete –hard-links –size-only –no-inc-recursive /vol1/
pg_tblsp/PG_9.5_201510051 \
/vol1/pg_tblsp/PG_9.6_201608131 standby.example.com:/vol1/pg_tblsp
Если вы вынесли pg_wal за пределы каталогов данных, нужно будет запустить rsync и для
этих каталогов.
g.
Настройте ведомые серверы с потоковой репликацией и трансляцией журнала
Настройте серверы для трансляции журнала. (Запускать pg_start_backup() и
pg_stop_backup() или делать копию файловой системы не нужно, так как ведомые серверы
остаются синхронизированными с ведущим.)</li>
      <li>Восстановить pg_hba.conf
Если вы изменяли pg_hba.conf, восстановите его исходное состояние. Также может потребо-
ваться скорректировать другие файлы конфигурации в новом кластере, чтобы они соответство-
вали старому, например postgresql.conf.</li>
      <li>Запустить новый сервер
Теперь можно безопасно запустить новый сервер, а затем ведомые серверы, синхронизирован-
ные с ним с помощью rsync.</li>
      <li>Действия после обновления
Если после обновления требуются какие-то дополнительные действия, программа pg_upgrade
выдаст предупреждения об этом по завершении работы. Она также сгенерирует файлы скрип-
тов, которые должны запускаться администратором. Эти скрипты будут подключаться к каж-
дой базе данных, требующей дополнительных операций. Каждый такой скрипт следует выпол-
нять командой:
psql –username=postgres –file=script.sql postgres
Эти скрипты могут выполняться в любом порядке, а после выполнения их можно удалить.
Внимание
Обычно к таблицам, задействованным в перестраивающих базу скриптах, опасно
обращаться, пока эти скрипты не сделают свою работу; при этом можно получить
некорректный результат или плохую производительность. К таблицам, не задей-
ствованным в таких скриптах, можно обращаться немедленно.</li>
      <li>Статистика
Так как статистика оптимизатора не передаётся в процессе работы pg_upgrade, вы получите
указание запустить соответствующую команду для воссоздания этой информации после обнов-
ления. Возможно, для этого вам понадобится установить параметры подключения к новому
кластеру.</li>
      <li>Удалить старый кластер
Если вы удовлетворены результатами обновления, вы можете удалить каталоги данных старого
кластера, запустив скрипт, упомянутый в выводе pg_upgrade после обновления. (Автоматиче-
ское удаление невозможно, если в старом каталоге данных находятся дополнительные таблич-
ные пространства.) Также вы можете удалить каталоги старой инсталляции (например, bin,
share).</li>
      <li>Возврат к старому кластеру
Если выполнив команду pg_upgrade, вы захотите вернуться к старому кластеру, возможны сле-
дующие варианты:
1903pg_upgrade
• Если pg_upgrade запускалась с ключом –check, никакие изменения в старом кластере не
производились и его использование можно продолжить в любой момент.
• Если pg_upgrade запускалась с параметром –link, файлы данных будут разделяться ста-
рым и новым кластером. Если новый кластер уже запускался, он произвёл запись в эти
файлы, так что использовать старый кластер небезопасно.
• Если pg_upgrade запускалась без ключа –link или новый сервер не запускался, старый
кластер не претерпел никаких изменений, за исключением того, что в режиме ссылки на
данные к имени $PGDATA/global/pg_control было добавлено окончание .old. Чтобы про-
должить использование старого кластера, можно просто убрать окончание .old из име-
ни файла $PGDATA/global/pg_control; после этого старый кластер можно будет перезапу-
стить.
Замечания
pg_upgrade не поддерживает обновление баз данных, в которых есть таблицы со столбцами, име-
ющими следующие системные типы данных reg*, ссылающиеся на OID: regproc, regprocedure,
regoper, regoperator, regconfig и regdictionary. (Обновление regtype возможно.)
Программа pg_upgrade сообщит обо всех актуальных для вашей инсталляции ошибках и потребно-
стях перестроения или переиндексации базы; при этом будут созданы завершающие обновление
скрипты, перестраивающие таблицы или индексы. Если вы попытаетесь автоматизировать обнов-
ление множества серверов, вы обнаружите, что для кластеров с одинаковыми схемами баз данных
потребуются одинаковые действия после обновления; это объясняется тем, что эти действия дик-
туются схемой базы данных, а не данными пользователей.
Для проверки развёртывания новой версии создайте копию только схемы старого кластера, напол-
ните этот кластер фиктивными данными, и попробуйте обновить его.
Если вы производите обновление кластера PostgreSQL версии до 9.2, в которой используется ка-
талог только с файлами конфигурации, вы должны передать расположение собственно каталога
с данными программе pg_upgrade, а расположение каталога конфигурации передать серверу, на-
пример -d /каталог-данных -o ‘-D /каталог-конфигурации’.
Если вы используете старый сервер версии до 9.1, работающий с нестандартным каталогом Unix-
сокетов, либо его стандартное расположение отличается от принятого в новой версии, задайте в
PGHOST расположение сокета старого сервера. (К Windows это не относится.)
Если вы хотите использовать режим ссылок на данные, но не хотите каких-либо изменений в ста-
ром кластере при запуске нового, сделайте копию старого кластера и обновите его в этом режи-
ме. Чтобы получить рабочую копию старого кластера, воспользуйтесь командой rsync и создайте
предварительную копию кластера при работающем сервере, а затем отключите старый сервер и
ещё раз запустите rsync –checksum, чтобы привести эту копию в согласованное состояние. (Ключ
–checksum необходим, потому что rsync различает время с точностью только до секунд.) При
этом вы можете исключить некоторые файлы, например postmaster.pid, как описано в Подразде-
ле 25.3.3. Если ваша файловая система поддерживает снимки файловой системы или копирование
при записи, вы можете воспользоваться этим для создания копии старого кластера и табличных
пространств; при этом важно, чтобы такие снимки и копии файлов создавались одномоментно или
когда сервер баз данных отключён.
См. также
initdb, pg_ctl, pg_dump, postgres
1904pg_verify_checksums
pg_verify_checksums — проверить контрольные суммы данных в кластере PostgreSQL
Синтаксис
pg_verify_checksums [параметр…] [[ -D | –pgdata ]каталог_данных]
Описание
pg_verify_checksums проверяет контрольные суммы данных в кластере PostgreSQL. Для
pg_verify_checksums требуется, чтобы сервер был остановлен в штатном режиме. Код состояния
будет нулевым в случае ошибок контрольных сумм и ненулевым в противном случае.
Параметры
Принимаются следующие параметры командной строки:
-D каталог
–pgdata=каталог
Указывает каталог, в котором располагается кластер баз данных.
-v
–verbose
Выводить подробные сообщения, в частности список всех проверенных файлов.
-r файловый_узел_отношения
Проверять контрольные суммы только в отношении с указанным файловым узлом.
-V
–version
Сообщить версию pg_verify_checksums и завершиться.
-?
–help
Показать справку по аргументам командной строки pg_verify_checksums и завершиться.
Переменные окружения
PGDATA
Указывает каталог, в котором располагается кластер баз данных; можно переопределить па-
раметром -D.
1905pg_waldump
pg_waldump — вывести журнал предзаписи кластера БД PostgreSQL в понятном человеку виде
Синтаксис
pg_waldump [параметр…] [начальный_сегмент [конечный_сегмент] ]
Описание
Программа pg_waldump показывает содержимое журнала предзаписи (WAL) и прежде всего полез-
на для целей отладки и обучения.
Эту утилиту может запускать только пользователь, установивший сервер, так как ей требуется
доступ на чтение к каталогу данных.
Параметры
Следующие аргументы командной строки задают расположение данных и формат вывода:
начальный_сегмент
Начать чтение с указанного файла сегмента журнала. Это неявно определяет каталог, в кото-
ром будут находиться файлы, и целевую линию времени.
конечный_сегмент
Остановиться после чтения указанного файла сегмента журнала.
-b
–bkp-details
Выводить подробные сведения о блоках-копиях страниц.
-e конец
–end=конец
Прекратить чтение в заданной позиции в WAL, а не читать поток до конца.
-f
–follow
Достигнув конца корректного WAL, проверять раз в секунду поступление новых записей WAL.
-n предел
–limit=предел
Вывести заданное число записей и остановиться.
-p путь
–path=путь
Задаёт каталог, содержащий файлы сегментов журнала, либо каталог с подкаталогом pg_wal,
содержащим такие файлы. По умолчанию в поисках этих файлов просматривается текущий
каталог, подкаталог pg_wal текущего каталога и подкаталог pg_wal каталога PGDATA.
-r менеджер_ресурсов
–rmgr=менеджер_ресурсов
Выводить только записи, созданные указанным менеджером ресурсов. Когда в качестве имени
менеджера передаётся list, программа выводит только список возможных имён менеджеров
ресурсов и завершается.
1906pg_waldump
-s начало
–start=начало
Позиция в WAL, с которой нужно начать чтение. По умолчанию чтение начинается с первой
корректной записи журнала в самом первом из найденных файлов.
-t линия_времени
–timeline=линия_времени
Линия времени, из которой будут читаться записи журнала. По умолчанию используется зна-
чение, заданное параметром начальный_сегмент, если он присутствует, а иначе — 1.
-V
–version
Вывести версию pg_waldump и завершиться.
-x ид_транзакции
–xid=ид_транзакции
Вывести только записи, относящиеся к указанной транзакции.
-z
–stats[=record]
Вывести общую статистику (число и размер записей и образов полных страниц) вместо отдель-
ных записей. Возможен вариант получения статистики по записям, а не по менеджерам ресур-
сов.
-?
–help
Вывести справку об аргументах командной строки pg_waldump и завершиться.
Замечания
Когда сервер работает, результаты могут быть некорректными.
Выводятся записи только указанной линии времени (или линии времени по умолчанию, если она
не задана явно). Записи в других линиях времени игнорируются.
pg_waldump не будет читать файлы WAL с расширением .partial. Если требуется прочитать такие
файлы, расширение .partial нужно убрать из их имён.
См. также
Раздел 30.5
1907postgres
postgres — Сервер баз данных PostgreSQL
Синтаксис
postgres [параметр…]
Описание
postgres это сервер баз данных PostgreSQL. Для получения доступа к базе данных клиент уста-
навливает соединение (локально или по сети) с сервером postgres. После установки соединения
сервер postgres поднимает выделенный процесс для его обслуживания.
Один экземпляр postgres всегда управляет данными ровно одного кластера баз данных. Кластер
— это коллекция баз данных, хранящихся в файловой системе в определённом размещении («об-
ласти данных»). На одном физическом сервере можно запустить несколько экземпляров postgres
одновременно, при условии, что они используют различные области данных и порты. При запуске
postgres необходимо указать размещение данных, которое задаётся в параметре -D или перемен-
ной окружения PGDATA, значение по умолчанию отсутствует. Обычно -D или PGDATA указывает на
каталог, созданный во время развёртывания кластера с помощью initdb. Иные варианты рассмот-
рены в Разделе 19.2.
По умолчанию postgres запускается не в фоновом режиме, а вывод журнала осуществляет в стан-
дартный поток ошибок. На практике postgres должен запускаться в фоновом режиме, возможно,
при старте системы.
Команду postgres также возможно использовать в однопользовательском режиме. В основном
этот режим используется на этапе начальной загрузки при выполнении initdb. Иногда также при-
меняется в целях отладки или после аварийного сбоя. Стоит обратить внимание, что одно-пользо-
вательский режим не совсем корректно использовать для отладки, так как условия далеки от ре-
альных боевых. При запуске из командной строки в однопользовательском режиме можно вводить
запросы и видеть результаты их выполнения на экране в форме пригодной для разработки, нежели
конечных пользователей. Также в этом режиме ID сессионного пользователя выставляется в еди-
ницу, а пользователь неявно наделяется правами суперпользователя. Существование пользовате-
ля необязательно, поэтому режим можно использовать в некоторых ситуациях при повреждениях
системных каталогов.
Параметры
Программа postgres принимает следующие аргументы командной строки. За подробным описа-
нием параметров обратитесь к Главе  19. От необходимости вводить большинство этих парамет-
ров можно избавиться, записав их в файл конфигурации. Некоторые (безопасные) параметры мож-
но также задать со стороны подключающегося клиента (в зависимости от приложения), чтобы
они применялись только к одному сеансу. Например, если установлена переменная окружения
PGOPTIONS, клиенты на базе libpq передадут эту строку серверу, который воспримет её как пара-
метры, передаваемые в командной строке postgres.
Параметры общего назначения
-B количество-буферов
Устанавливает количество разделяемых между процессами буферов. Значение по умолчанию
выбирается автоматически при развёртывании кластера с помощью initdb. Установка флага
аналогична конфигурации параметра shared_buffers.
-c имя=значение
Устанавливает заданный параметр времени исполнения. Конфигурационные параметры, под-
держиваемые PostgreSQL, описаны в Главе  19. Большинство других параметров командной
1908postgres
строки на самом деле представляют собой краткие формы такого присвоения значений пара-
метрам. Для установления нескольких параметров -c можно указывать многократно.
-C имя
Отображает значение заданного параметра времени исполнения и прерывает дальнейшее вы-
полнение (подробнее см. выше). Можно применять на работающем сервере, при этом будут
возвращены значения postgresql.conf с учётом проведённых в рамках вызова изменений. Зна-
чения, переданные при старте кластера, не отображаются.
Параметр предназначен для приложений, взаимодействующих с сервером, например, pg_ctl, и
запрашивающих параметры конфигурации. Пользовательские приложения должны использо-
вать команду SHOW или представление pg_settings.
-d уровень-отладки
Устанавливает уровень отладки (от 1 до 5). Чем выше значение, тем подробнее осуществляется
вывод в журнал сервера. Также возможно передать -d 0 для отдельной сессии, что предотвра-
тит в её рамках влияние выставленного для postgres значения.
-D datadir
Указывает размещение конфигурационных файлов базы в пределах файловой системы. За по-
дробностями обратитесь к Разделу 19.2.
-e
Устанавливает формат вводимых дат по умолчанию в «European» с последовательностью зна-
чений DMY. Также влияет на вывод дня, идущего перед значением месяца, более подробно см.
Раздел 8.5.
-F
Отключает вызовы fsync для увеличения производительности, но с увеличением рисков потери
данных в случае краха системы. Этот параметр работает аналогично параметру конфигурации
fsync. Внимательно прочтите документацию перед использованием данного параметра!
-h компьютер
Указывает IP-адрес или имя компьютера, на котором сервер postgres принимает клиентские
подключения по TCP/IP. Значением может быть список адресов, разделённых запятыми, либо
символ *, обозначающий все доступные интерфейсы. Если значение опущено, то подключения
принимаются только через Unix-сокеты. По умолчанию принимаются подключения только к
localhost. Флаг работает аналогично конфигурационному параметру listen_addresses.
-i
Позволяет клиентам подключаться по TCP/IP. Без этого параметра допускаются лишь локаль-
ные подключения. Действие этого параметра аналогично действию параметра конфигурации
listen_addresses со значением * в postgresql.conf или ключа -h.
Параметр устарел, так как не даёт полной функциональности listen_addresses. Лучше устанав-
ливать значение listen_addresses напрямую.
-k каталог
Указывает каталог Unix-сокета, через который postgres будет принимать подключения. Зна-
чением параметра может быть список каталогов через запятую. Если это значение пустое, ис-
пользование Unix-сокетов запрещается, разрешаются только подключения по TCP/IP. По умол-
чанию выбирается каталог /tmp, но его можно сменить на этапе компиляции. Этот параметр
действует аналогично параметру конфигурации unix_socket_directories.
1909postgres
-l
Включает поддержку безопасных соединений с использованием SSL шифрования. PostgreSQL
необходимо скомпилировать с поддержкой SSL для использования этого флага. Подробнее ис-
пользование SSL описано в Раздел 18.9.
-N максимальное количество соединений
Устанавливает максимально возможное количество одновременных клиентских соединений.
Значение по умолчанию устанавливается автоматически на этапе развёртывания с помощью
initdb. Флаг работает аналогично конфигурационному параметру max_connections.
-o дополнительные-параметры
Аргументы командной строки, поступившие через дополнительные-параметры, передаются
всем обслуживающим процессам, запускаемым этим процессом postgres.
Пробелы в строке дополнительные-параметры воспринимаются как разделяющие аргументы,
если перед ними нет обратной косой черты (); чтобы представить обратную косую черту
буквально, продублируйте её (\). Также можно задать несколько аргументов, используя -o
несколько раз.
Использование этого параметра считается устаревшим, так как на данный момент все пара-
метры postgres можно задать в командной строке.
-p порт
Указывает порт TCP/IP или расширение файла локального Unix-сокета, через который postgres
принимает подключения клиентских приложений. По умолчанию принимает значение пере-
менной окружения PGPORT, или, если значение PGPORT не установлено, то используется значе-
ние, установленное на этапе компиляции (обычно это 5432). Если значение порта меняется, то
на стороне клиентов это необходимо учитывать, установив, либо PGPORT, либо флаг командной
строки.
-s
Отображает информацию о времени и другую статистику после каждой выполненной команды,
что полезно для оценки производительности во время настройки количества буферов.
-S рабочая-память
Указывает объём рабочей памяти для внутренних сортировок и хешированных строк во избе-
жание использования временных файлов. Обратитесь к описанию параметра work_mem, приве-
дённому в Подразделе 19.4.1.
-V
–version
Отображает версию postgres и прерывает дальнейшее выполнение.
–имя=значение
Устанавливает заданный параметр времени исполнения. Является короткой формой ключа -c.
–describe-config
Выводит значения конфигурационных переменных сервера, их описаний и значений по умол-
чанию в формате команды COPY со знаком табуляции в качестве разделителя. В основном это
предназначено для средств администрирования.
-?
–help
Выводит помощь по аргументам команды postgres.
1910postgres
Параметры для внутреннего использования
Далее описанные параметры, в основном, применяются в целях отладки, а в некоторых случаях
при восстановлении сильно повреждённых баз данных. Их описание приведено для системных раз-
работчиков PostgreSQL, поэтому они могут быть изменены без уведомления.
-f ( s | i | o | b | t | n | m | h )
Запрещает использование специфических методов сканирования и объединения: s и i выклю-
чают последовательное сканирование и по индексу соответственно, а o, b и t выключает ска-
нирование только по индексу, сканирование по битовым векторам, и сканирование по ID кор-
тежей соответственно, в то время как n, m и h выключает вложенные циклы, слияния и хеши-
рование соответственно.
Ни последовательное сканирование, ни вложенные циклы невозможно выключить полностью.
Флаги -fs и -fn просто указывают планировщику избегать выполнения этих операций при на-
личии других альтернатив.
-n
Параметр предназначен для отладки сервера в случае аномального завершения процесса.
Обычная практика в таком случае — завершение порождённых процессов с дальнейшей ини-
циализацией разделяемой памяти и семафоров. Это связано с тем, что потерянный процесс мог
повредить область разделяемой памяти. Параметр указывает postgres не производить повтор-
ной инициализации общих структур данных, что позволяет произвести дальнейшую отладку
текущего состояния памяти и семафоров.
-O
Разрешает модифицировать структуру системных таблиц. Используется командой initdb.
-P
Игнорировать системные индексы при чтении, но продолжать обновлять их при изменениях
системных таблиц. Это используется при их восстановлении после повреждения.
-t pa[rser] | pl[anner] | e[xecutor]
Выводит статистику по времени исполнения каждого запроса в контексте каждого системного
модуля. Использование флага совместно с -s невозможно.
-T
Параметр предназначен для отладки сервера в случае аномального завершения процесса.
Обычная практика в таком случае — завершение порождённых процессов с дальнейшей ини-
циализацией разделяемой памяти и семафоров. Это связано с тем, что потерянный процесс
мог повредить область разделяемой памяти. Параметр указывает postgres на необходимость
остановки порождённых процессов сигналом SIGSTOP, но не завершит их, что позволяет разра-
ботчикам сделать снимки памяти процессов.
-v протокол
Указывает для данного сеанса версию протокола взаимодействия сервера с клиентом. Флаг
используется лишь для внутренних целей.
-W секунды
При старте сервера производится задержка на указанное количество секунд, после чего про-
изводится процедура аутентификации, что позволяет подключить отладчик к процессу.
Параметры для однопользовательского режима
Следующие параметры применимы только для однопользовательского режима (см. Раздел «Одно-
пользовательский режим»).
1911postgres
–single
Устанавливает однопользовательский режим. Параметр должен идти первым в командной
строке.
база_данных
Указывает имя базы данных, к которой производится подключение. Параметр должен идти по-
следним в командной строке. Если не указан, то используется имя текущего системного поль-
зователя.
-E
Выводить все команды в устройство стандартного вывода прежде чем выполнять их.
-j
Считать признаком окончания ввода команды точку с запятой с двумя переводами строки, а
не один перевод строки.
-r имя_файла
Отправляет вывод журнала сервера в файл filename. Этот параметр применяется лишь при
запуске из командной строки.
Переменные окружения
PGCLIENTENCODING
Кодировка, используемая клиентом по умолчанию. Может переопределяться на стороне кли-
ента, а также устанавливаться в конфигурационном файле сервера.
PGDATA
Каталог размещения данных кластера по умолчанию
PGDATESTYLE
Значение по умолчанию для параметра времени исполнения DateStyle. Применение этой пе-
ременной является устаревшим.
PGPORT
Порт по умолчанию, лучше устанавливать в конфигурационном файле.
Диагностика
Ошибки с упоминанием о semget или shmget говорят о возможной необходимости проведения бо-
лее оптимального конфигурирования ядра. Подробнее это обсуждается в Разделе 18.4. Отложить
переконфигурирование можно, уменьшив shared_buffers для снижения общего потребления раз-
деляемой памяти PostgreSQL и/или уменьшив max_connections для снижения затрат на использо-
вание семафоров.
Необходимо внимательно проверять сообщения об ошибке с упоминанием о другом запущенном
экземпляре, например, с использованием команды
$ ps ax | grep postgres
или
$ ps -ef | grep postgres
в зависимости от ОС. Если есть полная уверенность, что противоречий нет, необходимо самосто-
ятельно удалить упомянутый в сообщении запирающий файл и повторить попытку.
Упоминание о невозможности привязки к порту в сообщениях об ошибках может указывать на
то, что он уже занят другим процессом помимо PostgreSQL. Также сообщение может возникнуть
при мгновенном рестарте postgres на том же порту. В этом случае нужно немного подождать,
1912postgres
пока ОС не закроет порт, и повторить попытку. Ещё возможна ситуация, в которой используется
резервный системный порт. Например, многие Unix-подобные ОС резервируют «доверительные»
порты от 1024 и ниже, и лишь суперпользователь имеет к ним доступ.
Замечания
Для комфортного запуска и остановки сервера можно использовать утилиту pg_ctl.
Если возможно, не используйте сигнал SIGKILL для головного процесса postgres. В этом случае
postgres не освободит системные ресурсы, например, разделяемую память и семафоры. Это может
привести к проблемам при повторном запуске postgres.
Для корректного завершения postgres используются сигналы SIGTERM, SIGINT или SIGQUIT. При
первом будут ожидаться все дочерние процессы до их завершения, второй приведёт к принудитель-
ному закрытию соединений, а третий — к незамедлительному выходу без корректного завершения,
приводящему к необходимости выполнения процедуры восстановления на следующем старте.
Получая сигнал SIGHUP, сервер перечитывает свои файлы конфигурации. Также возможно отпра-
вить SIGHUP отдельному процессу, но это чаще всего бессмысленно.
Для отмены исполняющегося запроса, отправьте SIGINT обслуживающему его процессу. Для чи-
стого завершения серверного процесса отправьте ему SIGTERM. Также см. pg_cancel_backend и
pg_terminate_backend в Подразделе  9.26.2, которые являются аналогами в форме SQL-инструк-
ций.
Сервер postgres обрабатывает SIGQUIT для завершения дочерних процессов в грязную, и сигнал
не должен отправляться пользователем. Также не стоит посылать SIGKILL серверному процессу
— головной postgres процесс расценит это как аварию и принудительно завершит остальные по-
рождённые, как это было бы сделано при процедуре восстановления после сбоя.
Ошибки
Флаги, начинающиеся с – не работают в ОС FreeBSD или OpenBSD. Чтобы обойти это, используйте
-c. Это ошибка ОС. В будущих релизах PostgreSQL будет предоставлен обходной путь, если ошибка
так и не будет устранена.
Однопользовательский режим
Для запуска сервера в однопользовательском режиме используется, например, команда
postgres –single -D /usr/local/pgsql/data другие параметры my_database
Необходимо указать корректный путь к каталогу хранения данных в параметре -D, или установить
переменную окружения PGDATA. Также замените имя базы данных на необходимое.
Обычно перевод строки в однопользовательском режиме сервер воспринимает как завершение
ввода команды; точка с запятой не имеет для него такого значения, как для psql. Поэтому, что-
бы ввести команду, занимающую несколько строк, необходимо добавлять в конце каждой строки,
кроме последней, обратную косую черту. Обратная косая черта и следующий за ней символ пере-
вода строки автоматически убираются из вводимой команды. Заметьте, что это происходит даже
внутри строковой константы или комментария.
Но если применить аргумент командной строки -j, одиночный символ перевода строки не будет
завершать ввод команды; это будет делать последовательность «точка с запятой, перевод строки,
перевод строки». То есть для завершения команды нужно ввести точку с запятой, и сразу за ней
пустую строку. Просто точка с запятой, дополненная переводом строки, в этом режиме не имеет
специального значения. Внутри строковых констант и комментариев такая завершающая после-
довательность воспринимается в том же ключе.
Вне зависимости от режима ввода, символ точки с запятой, введённый не прямо перед или в со-
ставе последовательности завершения команды, воспринимается как разделитель команд. После
1913postgres
ввода завершающей последовательности введённые с разделителями несколько операторов будут
выполняться в одной транзакции.
Для завершения сеанса введите символ конца файла (EOF, обычно это сочетание Control+D). Если
вы вводили текст после окончания ввода последней команды, символ EOF будет воспринят как
символ завершения команды, и для выхода потребуется ещё один EOF.
Заметьте, что однопользовательский режим не предоставляет особых возможностей для редакти-
рования команд (например, нет истории команд). Также в однопользовательском режиме не про-
изводятся никакие фоновые действия, например, не выполняются автоматические контрольные
точки или репликация.
Примеры
Для запуска postgres в фоновом режиме с параметрами по умолчанию:
$ nohup postgres &gt;logfile 2&gt;&amp;1 &lt;/dev/null &amp;
Для запуска postgres с определённым портом, например, 1234:
$ postgres -p 1234
Для соединения с помощью psql укажите этот порт в параметре -p:
$ psql -p 1234
или в переменной окружения PGPORT:
$ export PGPORT=1234
$ psql
Именованный параметр времени исполнения можно указать одним из приведённых способом:
$ postgres -c work_mem=1234
$ postgres –work-mem=1234
Любой из методов переопределяет значение work_mem конфигурации postgresql.conf. Символ
подчёркивания в именах можно указать и в виде тире. Задавать параметры обычно (не считая
кратковременных экспериментов) лучше в postgresql.conf, а не в аргументах командной строки.
См. также
initdb, pg_ctl
1914postmaster
postmaster — Сервер баз данных PostgreSQL
Синтаксис
postmaster [параметр…]
Описание
postmaster это устаревшее название postgres.
См. также
postgres
1915</li>
    </ol>
  </li>
</ul>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-050/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-050/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-050/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-049/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
