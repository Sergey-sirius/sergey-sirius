<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page6/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page6/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-065/" title="Глава 65. Индексы SP-GiST"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 65. Индексы SP-GiST"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-065/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~22 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-065/" rel="bookmark" title="Глава 65. Индексы SP-GiST" itemprop="url">Глава 65. Индексы SP-GiST</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 65. Индексы SP-GiST</p>

<p>65.1. Введение</p>

<p>Аббревиатура SP-GiST расшифровывается как «Space-Partitioned GiST» (GiST с разбиением про-
странства). SP-GiST поддерживает деревья поиска с разбиением, что облегчает разработку широ-
кого спектра различных несбалансированных структур данных, в том числе деревьев квадрантов,
а также k-мерных и префиксных деревьев. Общей характеристикой этих структур является то, что
они последовательно разбивают пространство поиска на сегменты, которые не обязательно долж-
ны быть равного размера. При этом поиск, хорошо соответствующий правилу разбиения, с таким
индексом может быть очень быстрым.
Эти популярные структуры данных изначально конструировались для работы в памяти. При таком
применении они обычно представляются в виде набора динамически выделяемых узлов, связыва-
емых указателями. Однако подобную схему нельзя в таком виде перенести на диск, так как цепоч-
ки указателей могут быть довольно длинными, и поэтому потребуется слишком много обращений
к диску. Структуры данных для хранения на диске, напротив, должны иметь большую разветвлён-
ность для минимизации объёма ввода/вывода. Для решения этой задачи SP-GiST сопоставляет уз-
лы дерева поиска со страницами на диске так, чтобы при поиске требовалось обращаться только
к нескольким страницам на диске, даже если при этом нужно просмотреть множество узлов.
Как и GiST, SP-GiST призван дать возможность разрабатывать дополнительные типы данных с со-
ответствующими методами доступа экспертам в предметной области типа данных, а не специали-
стам по СУБД.
Представленная здесь информация частично позаимствована с сайта Проекта индексации SP-
GiST Университета Пердью. Сопровождением реализации SP-GiST в PostgreSQL в основном зани-
маются Фёдор Сигаев и Олег Бартунов; дополнительные сведения можно получить на их сайте.
65.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов SP-GiST, перечисленные в Таб-
лице 65.1.
Таблица 65.1. Встроенные классы операторов SP-GiST
Имя Индексируемый тип данных Индексируемые операторы
kd_point_ops point « &lt;@ &lt;^ » &gt;^ ~=
quad_point_ops point « &lt;@ &lt;^ » &gt;^ ~=
range_ops любой тип диапазона &amp;&amp; &amp;&lt; &amp;&gt; -|- « &lt;@ = » @&gt;
box_ops box « &amp;&lt; &amp;&amp; &amp;&gt; » ~= @&gt; &lt;@ &amp;&lt;| «| |</p>
<blockquote>
  <blockquote>
    <p>|&amp;&gt;
poly_ops polygon « &amp;&lt; &amp;&amp; &amp;&gt; » ~= @&gt; &lt;@ &amp;&lt;| «| |
|&amp;&gt;
text_ops text &lt; &lt;= = &gt; &gt;= ~&lt;=~ ~&lt;~ ~&gt;=~ ~&gt;~ ^@
inet_ops inet, cidr &amp;&amp; » »= &gt; &gt;= &lt;&gt; « «= &lt; &lt;= =
Из двух классов операторов для типа point классом по умолчанию является quad_point_ops. Класс
kd_point_ops поддерживает те же операторы, но использует другую структуру данных индекса,
которая может дать выигрыш в скорости для некоторых приложений.
65.3. Расширяемость
SP-GiST предлагает интерфейс с высоким уровнем абстракции и таким образом требует от разра-
ботчика метода доступа реализовать только методы, специфичные для конкретного типа данных.
Ядро SP-GiST отвечает за эффективную схему обращений к диску и поиск в структуре дерева, а
также берёт на себя заботу о параллельном доступе и поддержке журнала.
2150Индексы SP-GiST
Кортежи в листьях дерева SP-GiST содержат значения того же типа данных, что и индексируе-
мый столбец. На верхнем уровне эти кортежи содержат всегда исходное индексируемое значение
данных, но на более нижних могут содержать только сокращённое представление, например, суф-
фикс. В этом случае опорные функции класса операторов должны уметь восстанавливать исходное
значение, собирая его из внутренних кортежей, которые нужно пройти для достижения уровня
конкретного листа.
Внутренние кортежи устроены сложнее, так как они представляют собой точки разветвления в
дереве поиска. Каждый внутренний кортеж содержит набор из одного или нескольких узлов, пред-
ставляющих группы сходных значений листьев. Узел содержит ответвление, приводящее либо к
другому, внутреннему кортежу нижнего уровня, либо к короткому списку кортежей в листьях, ле-
жащих в одной странице индекса. Для каждого узла обычно задаётся метка, описывающая его;
например, в префиксном дереве меткой может быть очередной символ в строковом значении. (С
другой стороны, класс операторов может опускать метки узлов, если он имеет дело с фиксирован-
ным набором узлов во всех внутренних кортежах; см. Подраздел 65.4.2.) Дополнительно внутрен-
ний кортеж может хранить префикс, описывающий все его члены. В префиксном дереве это мо-
жет быть общий префикс всех представленных ниже строк. Значением префикса не обязательно
должен быть префикс, а могут быть любые данные, требующиеся классу операторов; например, в
дереве квадрантов это может быть центральная точка, от которой отмеряются четыре квадранта.
В этом случае внутренний кортеж дерева квадрантов будет также содержать четыре узла, соот-
ветствующие квадрантам вокруг этой центральной точки.
Некоторые алгоритмы деревьев требует знания уровня (или глубины) текущего кортежа, так что
ядро SP-GiST даёт возможность классам операторов контролировать число уровней при спуске по
дереву. Также имеется поддержка пошагового восстановления представленного значения, когда
это требуется, и передачи вниз дополнительных данных (так называемых переходящих значений)
при спуске.
Примечание
Ядро SP-GiST берёт на себя заботу о значениях NULL. Хотя в индексах SP-GiST не хра-
нятся записи для NULL в индексируемых столбцах, это скрыто от кода класса опера-
торов; записи индексов или условия поиска с NULL никогда не передаются методам
класса операторов. (Предполагается, что операторы SP-GiST строгие и не могут возвра-
щать положительный результат для значений NULL.) Поэтому значения NULL здесь
больше обсуждаться не будут.
Класс операторов индекса для SP-GiST должен предоставить пять методов и может дополнительно
предоставить ещё один. Все пять обязательных методов должны по единому соглашению прини-
мать два аргумента internal, первым из которых будет указатель на структуру C, содержащую
входные значения для опорного метода, а вторым — указатель на структуру C, в которую должны
помещаться выходные значения. Четыре из этих методов должны возвращать просто void, так как
их результаты помещаются в выходную структуру; однако leaf_consistent дополнительно возвра-
щает результат boolean. Эти методы не должны менять никакие поля в их входных структурах.
Выходная структура всегда обнуляется перед вызовом пользовательского метода. Необязательный
шестой метод compress принимает в единственном аргументе данные, подлежащие индексирова-
нию, и возвращает значение, подходящее для физического хранения в кортеже уровня листьев.
Пользователь должен определить следующие пять обязательных методов:
config
Возвращает статическую информацию о реализации индекса, включая OID типов данных пре-
фикса и метки узла.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_config(internal, internal) RETURNS void …
2151Индексы SP-GiST
В первом аргументе передаётся указатель на структуру spgConfigIn языка C, содержа-
щие входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgConfigOut языка C, в которую функция должна поместить результат.
typedef struct spgConfigIn
{
Oid
attType;
} spgConfigIn;
typedef struct spgConfigOut
{
Oid
prefixType;
Oid
labelType;
Oid
leafType;
bool
canReturnData;
данные <em>/
bool
longValuesOK;
одной странице */
} spgConfigOut;
/</em> Индексируемый тип данных <em>/
/</em>
/*
/*
/*
Тип данных префикса во внутренних кортежах <em>/
Тип данных метки узла во внутренних кортежах */
Тип данных в кортежах уровня листьев */
Класс операторов может восстановить исходные
/</em> Класс может принимать значения, не умещающиеся на
Поле attType передаётся для поддержки полиморфных классов операторов; для обычных клас-
сов операторов с фиксированным типом оно будет всегда содержать одно значение и поэтому
его можно просто игнорировать.
Для классов операторов, не использующих префиксы, в prefixType можно установить VOIDOID.
Подобным образом, для классов операторов, не использующих метки узлов, в labelType тоже
можно установить VOIDOID. Признак canReturnData следует установить, если класс операторов
может восстановить изначально переданное в индекс значение. Признак longValuesOK должен
устанавливаться, только если attType переменной длины и класс операторов может фрагмен-
тировать длинные значения, повторяя суффиксы (см. Подраздел 65.4.1).
Значение leafType обычно совпадает с attType. Для обеспечения обратной совместимости ме-
тоду config разрешается оставить leafType неинициализированным; это будет иметь тот же
эффект, что и присвоение leafType значения attType. Когда attType и leafType различаются,
должен предоставляться метод compress. Метод compress отвечает за преобразование данных,
подлежащих индексации, из типа attType в тип leafType. Заметьте, что обе функции, оценива-
ющие согласованность, получают значения scankeys неизменёнными, не прошедшими через
compress.
choose
Выбирает метод для добавления нового значения во внутренний кортеж.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_choose(internal, internal) RETURNS void …
В первом аргументе передаётся указатель на структуру spgChooseIn языка C, содержащую
входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgChooseOut, в которую функция должна поместить результат.
typedef struct spgChooseIn
{
Datum
datum;
<em>/
Datum
leafDatum;
листе */
int
level;
/</em> исходное значение, которое должно индексироваться
/* текущее значение, которое должно сохраниться в
/* текущий уровень (начиная с нуля) <em>/
/</em> Данные из текущего внутреннего кортежа <em>/
bool
allTheSame;
/</em> кортеж с признаком все-равны? <em>/
bool
hasPrefix;
/</em> у кортежа есть префикс? <em>/
2152Индексы SP-GiST
Datum
prefixDatum;
int
nNodes;
Datum
*nodeLabels;
} spgChooseIn;
/</em> если да, то это значение префикса <em>/
/</em> число узлов во внутреннем кортеже <em>/
/</em> значения меток узлов (NULL, если их нет) <em>/
typedef enum spgChooseResultType
{
spgMatchNode = 1,
/</em> спуститься в существующий узел <em>/
spgAddNode,
/</em> добавить узел во внутренний кортеж <em>/
spgSplitTuple
/</em> разделить внутренний кортеж (изменить его
префикс) <em>/
} spgChooseResultType;
typedef struct spgChooseOut
{
spgChooseResultType resultType;
/</em> код действия, см. выше <em>/
union
{
struct
/</em> результаты для spgMatchNode <em>/
{
int
nodeN;
/</em> спуститься к этому узлу (нумерация с 0) <em>/
int
levelAdd;
/</em> шаг увеличения уровня <em>/
Datum
restDatum; /</em> новое значение листа <em>/
}
matchNode;
struct
/</em> результаты для spgAddNode <em>/
{
Datum
nodeLabel; /</em> метка нового узла <em>/
int
nodeN;
/</em> куда вставлять её (нумерация с 0) <em>/
}
addNode;
struct
/</em> результаты для spgSplitTuple <em>/
{
/</em> Информация для формирования нового внутреннего кортежа верхнего
уровня с одним дочерним кортежем <em>/
bool
prefixHasPrefix;
/</em> кортеж должен иметь префикс? <em>/
Datum
prefixPrefixDatum; /</em> если да, его значение <em>/
int
prefixNNodes;
/</em> число узлов <em>/
Datum
*prefixNodeLabels;
/</em> их метки (или NULL, если</p>
    <ul>
      <li>меток нет) <em>/
int
childNodeN;
/</em> узел, который получит дочерний кортеж
<em>/
/</em> Информация для формирования нового внутреннего кортежа нижнего уровня
со всеми старыми узлами <em>/
bool
postfixHasPrefix;
/</em> кортеж должен иметь префикс? <em>/
Datum
postfixPrefixDatum; /</em> если да, его значение <em>/
}
splitTuple;
}
result;
} spgChooseOut;
В datum передаётся исходное значение типа spgConfigIn.attType, которое должно быть встав-
лено в индекс. В leafDatum содержится значение типа spgConfigOut.leafType, изначально
представляющее собой результат метода compress, применённого к datum, если метод compress
реализован, а иначе — собственно значение datum. leafDatum может быть другим на нижних
уровнях дерева, если его изменят функции choose или picksplit. Когда поиск места добавле-
ния достигает страницы уровня листа, в создаваемом кортеже листа сохраняется текущее зна-
чение leafDatum. В level задаётся текущий уровень внутреннего кортежа, начиная с нуля для
уровня корня. Признак allTheSame устанавливается, если текущий внутренний кортеж содер-
жит несколько равнозначных узлов (см. Подраздел 65.4.3). Признак hasPrefix устанавливает-
2153Индексы SP-GiST
ся, если текущий внутренний кортеж содержит префикс; в этом случае в prefixDatum задаётся
его значение. Поле nNodes задаёт число дочерних узлов, содержащихся во внутреннем корте-
же, а nodeLabels представляет массив их меток или NULL, если меток у них нет.
Функция choose может определить, соответствует ли новое значение одному из существующих
дочерних узлов, или что нужно добавить новый дочерний узел, или что новое значение не со-
гласуется с префиксом кортежа и внутренний кортеж нужно разделить, чтобы получить менее
ограничивающий префикс.
Если новое значение соответствует одному из существующих дочерних узлов, установите в
resultType значение spgMatchNode. Установите в nodeN номер этого узла в массиве узлов (ну-
мерация начинается с нуля). Установите в levelAdd значение, на которое должен увеличивать-
ся уровень (level) при спуске через этот узел, либо оставьте его нулевым, если класс операто-
ров не отслеживает уровни. Установите restDatum, равным leafDatum, если класс операторов
не меняет значения данных от уровня к уровню, а в противном случае запишите в него изме-
нённое значение, которое должно использоваться в качестве leafDatum на следующем уровне.
Если нужно добавить новый дочерний узел, установите в resultType значение spgAddNode. В
nodeLabel задайте метку для нового узла, а в nodeN позицию (отсчитываемую от нуля), в кото-
рую должен вставляться узел в массиве узлов. После того как узел будет добавлен, функция
choose вызывается снова с изменённым внутренним кортежем; в результате этого вызова дол-
жен быть получен результат spgMatchNode.
Если новое значение не согласуется с префиксом кортежа, установите в resultType значе-
ние spgSplitTuple. Это действие приводит к перемещению всех существующих узлов в но-
вый внутренний кортеж нижнего уровня и замене существующего внутреннего кортежа кор-
тежем, содержащим одну ссылку вниз на новый внутренний кортеж. Установите признак
prefixHasPrefix, чтобы указать, должен ли новый верхний кортеж иметь префикс, и если
да, задайте в prefixPrefixDatum значение префикса. Это новое значение префикса должно
быть в достаточной мере менее ограничивающим, чем исходное, чтобы в индекс было приня-
то новое значение. Запишите в prefixNNodes число требующихся узлов в новом кортеже, а в
prefixNodeLabels — указатель на выделенный через palloc массив с их метками или NULL, если
метки узлов не нужны. Заметьте, что общий размер нового кортежа верхнего уровня не должен
превышать общий размер кортежа, который он замещает; это ограничивает длины нового пре-
фикса и новых меток. Установите в childNodeN индекс (начиная с нуля) узла, который будет ссы-
латься на новый внутренний кортеж нижнего уровня. Установите признак postfixHasPrefix,
чтобы указать, должен ли новый внутренний кортеж нижнего уровня иметь префикс, и если
да, задайте в postfixPrefixDatum значение префикса. Сочетание этих двух префиксов и метки
узла, ссылающегося вниз, (если она есть) должно иметь то же значение, что и исходный пре-
фикс, так как нет возможности ни изменить метки узлов, перемещённых в новый кортеж ниж-
него уровня, ни изменить какие-либо нижние записи индекса. После того как узел разделён,
функция choose будет вызвана снова с заменяемым внутренним кортежем. При этом вызове
может быть возвращён результат spgAddNode, если подходящий узел не был создан действием
spgSplitTuple. В конце концов choose должна вернуть spgMatchNode, чтобы операция добавле-
ния могла перейти на следующий уровень.
picksplit
Выбирает, как создать новый внутренний кортеж по набору кортежей в листьях.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void …
В первом аргументе передаётся указатель на структуру spgPickSplitIn языка C, содержа-
щую входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgPickSplitOut языка C, в которую функция должна поместить результат.
typedef struct spgPickSplitIn
{
2154Индексы SP-GiST
int
nTuples;
Datum
*datums;
int
level;
} spgPickSplitIn;
typedef struct spgPickSplitOut
{
bool
hasPrefix;
Datum
prefixDatum;
int
Datum
nNodes;
*nodeLabels;
/</em> число кортежей в листьях <em>/
/</em> их значения (массив длины nTuples) <em>/
/</em> текущий уровень (отсчитывая от 0) <em>/
/</em> новый внутренний кортеж должен иметь префикс? <em>/
/</em> если да, его значение <em>/
/</em> число узлов для нового внутреннего кортежа <em>/
/</em> их метки (или NULL, если их нет) <em>/
int
*mapTuplesToNodes;
Datum
*leafTupleDatums;
} spgPickSplitOut;
/</em> номер узла для каждого кортежа в листе <em>/
/</em> значения, помещаемые в каждый новый кортеж <em>/
В nTuples задаётся число предоставленных кортежей уровня листьев, а в datums — массив их
значений типа spgConfigOut.leafType. В level указывается текущий уровень, который должны
разделять все кортежи листьев, и который станет уровнем нового внутреннего кортежа.
Установите признак hasPrefix, чтобы указать, должен ли новый внутренний кортеж иметь пре-
фикс, и если да, задайте в prefixDatum значение префикса. Установите в nNodes количество уз-
лов, которые будут содержаться во внутреннем кортеже, а в nodeLabels — массив значений их
меток либо NULL, если узлам не нужны метки. Поместите в mapTuplesToNodes указатель на мас-
сив, назначающий номера узлов (начиная с нуля) каждому кортежу листа. В leafTupleDatums
передайте массив значений, которые должны быть сохранены в новых кортежах листьев (они
будут совпадать со входными значениями (datums), если класс операторов не изменяет значе-
ния от уровня к следующему). Заметьте, что функция picksplit сама должна выделить память,
используя palloc, для массивов nodeLabels, mapTuplesToNodes и leafTupleDatums.
Если передаётся несколько кортежей листьев, ожидается, что функция picksplit классифици-
рует их и разделит на несколько узлов; иначе нельзя будет разнести кортежи листьев по раз-
ным страницам, что является конечной целью этой операции. Таким образом, если picksplit
в итоге помещает все кортежи листьев в один узел, ядро SP-GiST меняет это решение и создаёт
внутренний кортеж, в котором кортежи листьев связываются случайным образом с несколь-
кими узлами с одинаковыми метками. Такой кортеж помечается флагом allTheSame, показы-
вающим, что все узлы равны. Функции choose и inner_consistent должны работать с такими
внутренними кортежами особым образом. За дополнительными сведениями обратитесь к Под-
разделу 65.4.3.
picksplit может применяться к одному кортежу на уровне листьев, только когда функция
config установила в longValuesOK значение true и было передано входное значение, большее
страницы. В этом случае цель операции — отделить префикс и получить новое, более короткое
значение для листа. Этот вызов будет повторяться, пока значение уровня листа не уменьшится
настолько, чтобы уместиться в странице. За дополнительными сведениями обратитесь к Под-
разделу 65.4.1.
inner_consistent
Возвращает набор узлов (ветвей), по которым надо продолжать поиск.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void …
В первом аргументе передаётся указатель на структуру spgInnerConsistentIn языка C, содер-
жащую входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgInnerConsistentOut языка C, в которую функция должна поместить результат.
typedef struct spgInnerConsistentIn
2155Индексы SP-GiST
{
ScanKey
int
scankeys;
nkeys;
/</em> массив операторов и искомых значений <em>/
/</em> длина массива <em>/
Datum
reconstructedValue;
/</em> значение, восстановленное для родителя <em>/
void
*traversalValue; /</em> переходящее значение, специфичное для класса
операторов <em>/
MemoryContext traversalMemoryContext;
/</em> переходящие значения нужно помещать
сюда <em>/
int
level;
/</em> текущий уровень (отсчитывается от нуля) <em>/
bool
returnData;
/</em> нужно ли возвращать исходные данные? <em>/
/</em> Данные из текущего внутреннего кортежа <em>/
bool
allTheSame;
/</em> кортеж с признаком все-равны? <em>/
bool
hasPrefix;
/</em> у кортежа есть префикс? <em>/
Datum
prefixDatum;
/</em> если да, то это значение префикса <em>/
int
nNodes;
/</em> число узлов во внутреннем кортеже <em>/
Datum
*nodeLabels;
/</em> значения меток узлов (NULL, если их нет) <em>/
} spgInnerConsistentIn;
typedef struct spgInnerConsistentOut
{
int
nNodes;
/</em> число дочерних узлов, которые нужно посетить <em>/
int
*nodeNumbers;
/</em> их номера в массиве узлов <em>/
int
*levelAdds;
/</em> шаги увеличения уровня для этих узлов <em>/
Datum
*reconstructedValues;
/</em> связанные восстановленные значения <em>/
void
**traversalValues;
/</em> переходящие значения, специфичные для
класса операторов <em>/
} spgInnerConsistentOut;
Массив scankeys длины nkeys описывает условия поиска по индексу. Эти условия объединя-
ются операцией И — найдены должны быть только те записи, которые удовлетворяют всем
условиям. (Заметьте, что с nkeys = 0 подразумевается, что запросу удовлетворяют все записи
в индексе.) Обычно эту функцию интересуют только поля sk_strategy и sk_argument в каж-
дой записи массива, в которых определяется соответственно индексируемый оператор и иско-
мое значение. В частности, нет необходимости проверять sk_flags, чтобы распознать NULL
в искомом значении, так как ядро SP-GiST отфильтрует такие условия. В reconstructedValue
передаётся значение, восстановленное для родительского кортежа; это может быть (Datum)
0 на уровне корня или если функция inner_consistent не установила значение на преды-
дущем уровне. Значение reconstructedValue всегда имеет тип spgConfigOut.leafType. В
traversalValue передаётся указатель на переходящие данные, полученные из предыдущего
вызова inner_consistent для родительского кортежа индекса, либо NULL на уровне корня. По-
ле traversalMemoryContext указывает на контекст памяти, в котором нужно сохранить выход-
ные переходящие данные (см. ниже). В level передаётся уровень текущего внутреннего кор-
тежа (уровень корня считается нулевым). Флаг returnData устанавливается, когда для этого
запроса нужно получить восстановленные данные; это возможно, только если функция config
установила признак canReturnData. Признак allTheSame устанавливается, если текущий внут-
ренний кортеж имеет пометку «все-равны»; в этом случае все узлы имеют одну метку (если
имеют) и значит, либо все они, либо никакой не соответствует запросу (см. Подраздел 65.4.3).
Признак hasPrefix устанавливается, если текущий внутренний кортеж содержит префикс; в
этом случае в prefixDatum находится его значение. В nNodes задаётся число дочерних узлов,
содержащихся во внутреннем кортеже, а в nodeLabels — массив их меток либо NULL, если они
не имеют меток.
В nNodes нужно записать число дочерних узлов, которые потребуется посетить при поиске, а
в nodeNumbers — массив их индексов. Если класс операторов отслеживает уровни, в levelAdds
нужно передать массив с шагами увеличения уровня при посещении каждого узла. (Часто шаг
будет одним для всех узлов, но может быть и по-другому, поэтому применяется массив.) Ес-
2156Индексы SP-GiST
ли потребовалось восстановить значения, поместите в reconstructedValues указатель на мас-
сив значений типа spgConfigOut.leafType, восстановленных для каждого дочернего узла, ко-
торый нужно посетить; в противном случае оставьте reconstructedValues равным NULL. Ес-
ли желательно передать дополнительные данные («переходящие значения») на нижние уров-
ни при поиске по дереву, поместите в traversalValues указатель на массив соответствую-
щих переходящих значений, по одному для каждого дочернего узла, который нужно посе-
тить; в противном случае оставьте в traversalValues значение NULL. Заметьте, что функция
inner_consistent сама должна выделять память, используя palloc, для массивов nodeNumbers,
levelAdds, distances, reconstructedValues и traversalValues в текущем контексте памя-
ти. Однако выходные переходящие значения, на которые указывает массив traversalValues,
должны размещаться в контексте traversalMemoryContext. При этом каждое переходящее зна-
чения должно располагаться в отдельном блоке памяти palloc.
leaf_consistent
Возвращает true, если кортеж листа удовлетворяет запросу.
В SQL эта функция должна объявляться так:
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool …
В первом аргументе передаётся указатель на структуру spgLeafConsistentIn языка C, содер-
жащую входные данные для функции. Во втором аргументе передаётся указатель на структуру
spgLeafConsistentOut языка C, в которую функция должна поместить результат.
typedef struct spgLeafConsistentIn
{
ScanKey
scankeys;
/</em> массив операторов и искомых значений <em>/
int
nkeys;
/</em> длина массива <em>/
Datum
reconstructedValue;
/</em> значение, восстановленное для родителя <em>/
void
*traversalValue; /</em> переходящее значение, специфичное для класса
операторов <em>/
int
level;
/</em> текущий уровень (отсчитывая от нуля) <em>/
bool
returnData;
/</em> нужно ли возвращать исходные данные? <em>/
Datum
leafDatum;
} spgLeafConsistentIn;
/</em> значение в кортеже листа <em>/
typedef struct spgLeafConsistentOut
{
Datum
leafValue;
/</em> восстановленные исходные данные, при наличии <em>/
bool
recheck;
/</em> true, если оператор нужно перепроверить */
} spgLeafConsistentOut;
Массив scankeys длины nkeys описывает условия поиска по индексу. Эти условия объединя-
ются операцией И — запросу удовлетворяют только те записи в индексе, которые удовлетво-
ряют всем этим условиям. (Заметьте, что с nkeys = 0 подразумевается, что запросу удовле-
творяют все записи в индексе.) Обычно эту функцию интересуют только поля sk_strategy
и sk_argument в каждой записи массива, в которых определяются соответственно индекси-
руемый оператор и искомое значение. В частности, нет необходимости проверять sk_flags,
чтобы распознать NULL в искомом значении, так как ядро SP-GiST отфильтрует такие усло-
вия. В reconstructedValue передаётся значение, восстановленное для родительского кор-
тежа; это может быть (Datum) 0 на уровне корня или если функция inner_consistent не
установила значение на предыдущем уровне. Значение reconstructedValue всегда имеет тип
spgConfigOut.leafType. В traversalValue передаётся указатель на переходящие данные, полу-
ченные из предыдущего вызова inner_consistent для родительского кортежа индекса, либо
NULL на уровне корня. В level передаётся уровень текущего внутреннего кортежа (уровень
корня считается нулевым). Флаг returnData устанавливается, когда для этого запроса нужно
получить восстановленные данные; это возможно, только если функция config установила при-
2157Индексы SP-GiST
знак canReturnData. В leafDatum передаётся значение ключа типа spgConfigOut.leafType, за-
писанное в текущем кортеже листа.
Эта функция должна вернуть true, если кортеж листа соответствует запросу, или false в про-
тивном случае. В случае положительного результата, если в поле returnData передано true,
нужно поместить в leafValue значение типа spgConfigIn.attType, изначально переданное для
индексации в этот кортеж. Кроме того, флагу recheck можно присвоить true, если соответствие
неточное, так что для установления точного результата проверки нужно повторно применить
оператор(ы) к актуальному кортежу данных.
Дополнительно пользователь может определить метод:
Datum compress(Datum in)
Преобразует элемент данных в формат, подходящий для физического хранения в кортеже уров-
ня листьев на странице индекса. Эта функция принимает значение spgConfigIn.attType и воз-
вращает spgConfigOut.leafType (это значение должно быть не в виде TOAST).
Все опорные методы SP-GiST обычно вызываются в кратковременных контекстах памяти; то есть
CurrentMemoryContext сбрасывается после обработки каждого кортежа. Таким образом, можно не
заботиться об освобождении любых блоков памяти, выделенных функцией palloc. (Метод config
является исключением: в нём нужно не допускать утечек памяти. Но обычно метод config не
делает ничего, кроме как присваивает константы переданной структуре параметров.)
Если индексируемый столбец имеет сортируемый тип данных, правило сортировки индекса будет
передаваться всем опорным методам, используя стандартный механизм PG_GET_COLLATION().
65.4. Реализация
В этом разделе освещаются тонкости реализации и особенности, о которых полезно знать тем, кто
будет реализовывать классы операторов SP-GiST.
65.4.1. Ограничения SP-GiST
Отдельные кортежи листьев и внутренние кортежи должны умещаться в одной странице индек-
са (по умолчанию её размер 8 Кбайт). Таким образом при индексировании значений типов дан-
ных переменной длины большие значения могут поддерживаться только такими схемами, как пре-
фиксные деревья, в которых каждый уровень дерева включает префикс, достаточно короткий для
помещения в страницу, и на конечном уровне листьев содержится суффикс, который также до-
статочно мал, чтобы поместиться в странице. Класс операторов должен устанавливать признак
longValuesOK, только если он готов организовывать такую структуру. Если этот признак не уста-
новлен, ядро SP-GiST не примет запрос на индексацию значения, которое слишком велико для
одной страницы индекса.
Также класс операторов должен отвечать за то, чтобы внутренние кортежи при расширении не
выходили за пределы страницы индекса; это ограничивает число дочерних узлов, которые могут
принадлежать одному внутреннему кортежу, а также максимальный размер значения префикса.
Ещё одно ограничение состоит в том, что когда узел внутреннего кортежа указывает на набор кор-
тежей листьев, все эти кортежи должны находиться в одной странице индекса. (Это конструктив-
ное ограничение введено для оптимизации позиционирования и экономии места на ссылках, свя-
зывающих такие кортежи вместе.) Если набор кортежей листьев оказывается слишком большим
для одной страницы, выполняется разделение и вставляется промежуточный внутренний кортеж.
Чтобы устранить возникшую проблему, новый внутренний кортеж должен разделять набор зна-
чений в листе на несколько групп узлов. Если функция picksplit класса операторов не может
сделать это, ядро SP-GiST переходит к чрезвычайным мерам, описанным в Подразделе 65.4.3.
65.4.2. SP-GiST без меток узлов
В некоторых древовидных схемах каждый внутренний кортеж содержит фиксированный набор
узлов; например, в дереве квадрантов это всегда четыре узла, соответствующие четырём квад-
2158Индексы SP-GiST
рантам вокруг центральной точки внутреннего кортежа. В таком случае код обычно работа-
ет с узлами по номерам и необходимости в явных метках узлов нет. Чтобы убрать метки уз-
лов (и таким образом сэкономить место), функция picksplit может возвратить NULL вместо
массива nodeLabels, а функция choose аналогично может возвратить NULL вместо массива
prefixNodeLabels во время действия spgSplitTuple. В результате при последующих вызовах функ-
ций choose и inner_consistent им вместо nodeLabels будет передаваться NULL. В принципе мет-
ки узлов могут применяться для одних внутренних кортежей и отсутствовать у других в том же
индексе.
Когда внутренний кортеж содержит узлы без меток, функция choose не может выбрать действие
spgAddNode, так как в этом случае предполагается, что набор узлов фиксированный.
65.4.3. Внутренние кортежи «все-равны»
Ядро SP-GiST может переопределить результаты функции picksplit класса операторов, когда эта
функция не может разделить поступившие значения листьев на минимум две категории узлов.
Когда это происходит, создаётся новый внутренний кортеж с несколькими узлами, каждый из ко-
торых имеет одну метку (если имеет), которую picksplit дала одному узлу, а значения листьев
распределяются случайно между этими равнозначными узлами. Для этого внутреннего кортежа
устанавливается флаг allTheSame, который предупреждает функции choose и inner_consistent,
что кортеж не содержит набор узлов, который они обычно ожидают.
Когда обрабатывается кортеж с флагом allTheSame, выбранное функцией choose действие
spgMatchNode воспринимается как указание, что новое значение можно присвоить одному из рав-
нозначных узлов; код ядра будет игнорировать полученное значение nodeN и спустится в один
из узлов, выбранный случайно (чтобы дерево было сбалансированным). Будет считаться ошиб-
кой, если choose выберет действие spgAddNode, так как при этом не все узлы окажутся равны;
если добавляемое значение не соответствует существующим узлам, должно выбираться действие
spgSplitTuple.
Также, когда обрабатывается кортеж с флагом allTheSame, функция inner_consistent должна
вернуть все или не возвращать никакие узлы для продолжения поиска по индексу, так как все узлы
равнозначны. Для этого может потребоваться, а может и не потребоваться код обработки особого
случая, в зависимости от того, как inner_consistent обычно воспринимает узлы.
65.5. Примеры
Дистрибутив исходного кода PostgreSQL содержит несколько примеров классов операторов индек-
са SP-GiST, перечисленных в Таблице 65.1. Код их реализации вы можете найти в src/backend/
access/spgist/ и src/backend/utils/adt/.
2159</li>
    </ul>
  </blockquote>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-064/" title="Глава 64. Индексы GiST"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 64. Индексы GiST"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-064/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~16 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-064/" rel="bookmark" title="Глава 64. Индексы GiST" itemprop="url">Глава 64. Индексы GiST</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 64. Индексы GiST</p>

<p>64.1. Введение</p>

<p>GiST расшифровывается как «Generalized Search Tree» (Обобщённое поисковое дерево). Это сба-
лансированный иерархический метод доступа, который представляет собой базовый шаблон, на
основе которого могут реализовываться произвольные схемы индексации. На базе GiST могут быть
реализованы B-деревья, R-деревья и многие другие схемы индексации.
Ключевым преимуществом GiST является то, что он позволяет разрабатывать дополнительные ти-
пы данных с соответствующими методами доступа экспертам в предметной области типа данных,
а не специалистам по СУБД.
Представленная здесь информация частично позаимствована с сайта Проекта индексации GiST
Калифорнийского университета в Беркли и из диссертации Марселя Корнакера Методы доступа
для СУБД следующего поколения. Сопровождением реализации SP-GiST в PostgreSQL в основном
занимаются Фёдор Сигаев и Олег Бартунов; дополнительные сведения можно получить на их сай-
те.
64.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов GiST, перечисленные в Табли-
це 64.1. (Некоторые дополнительные модули, описанные в Приложении F, добавляют другие клас-
сы операторов GiST.)
Таблица 64.1. Встроенные классы операторов GiST
Имя Индексируемый тип Индексируемые опе- Операторы упорядо-
данных
раторы
чивания
box_ops box
&amp;&amp; &amp;&gt; &amp;&lt; &amp;&lt;| » « «| &lt;@
@&gt; @ |&amp;&gt; |» ~ ~=
circle_ops circle
&amp;&amp; &amp;&gt; &amp;&lt; &amp;&lt;| » « «| &lt;@ &lt;-&gt;
@&gt; @ |&amp;&gt; |» ~ ~=
inet_ops inet, cidr
&amp;&amp; » »= &gt; &gt;= &lt;&gt; « «=
&lt; &lt;= =
point_ops point</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>^ « &lt;@ &lt;@ &lt;@ &lt;^ ~=
poly_ops polygon
&amp;&amp; &amp;&gt; &amp;&lt; &amp;&lt;| » « «| &lt;@ &lt;-&gt;
@&gt; @ |&amp;&gt; |» ~ ~=
range_ops любой тип диапазона
&amp;&amp; &amp;&gt; &amp;&lt; » « &lt;@ -|- =
@&gt; @&gt;
tsquery_ops tsquery
&lt;@ @&gt;
tsvector_ops tsvector
@@
&lt;-&gt;
По историческим причинам класс операторов inet_ops не является классом по умолчанию для
типов inet и cidr. Чтобы использовать его, укажите имя класса в CREATE INDEX, например:
CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);
64.3. Расширяемость
Реализация нового метода доступа индекса традиционно была большой и сложной задачей. Что-
бы её решить, необходимо было понимать внутреннее устройство базы данных, в частности рабо-
ту менеджера блокировок и журнала предзаписи. Но с интерфейсом GiST, реализующим высокий
уровень абстракции, разработчик метода доступа должен реализовать только смысловое напол-
нение индексируемого типа данных. Уровень GiST берёт на себя заботу о параллельном доступе,
поддержке журнала и поиске в структуре дерева.
2139Индексы GiST
Эту расширяемость не следует путать с расширяемостью других стандартных деревьев поиска в
смысле поддержки различных типов данных. Например, PostgreSQL поддерживает расширяемость
B-деревьев и индексов по хешу. Это означает, что в PostgreSQL вы можете построить B-дерево или
хеш-таблицу по любому желаемому типу данных. Но такие B-деревья будут поддерживать только
предикаты сравнений (&lt;, =, &gt;), а индексы по хешу только запросы с равенством.
Поэтому, если вы проиндексируете в PostgreSQL в B-дереве, например, коллекцию изображений,
вы сможете выполнять только проверки вида «равны ли изображения X и Y», «меньше ли изобра-
жение X изображения Y» и «больше ли изображение X изображения Y». Это может быть полезно, в
зависимости от того, как вы определите операции «равно», «меньше» и «больше». Однако, исполь-
зуя индекс на базе GiST, возможно удовлетворять и запросы из предметной области, например,
«найти все изображения лошадей» или «найти все пересвеченные изображения».
Всё, что нужно, чтобы получить работающий метод доступа GiST — это реализовать несколько
методов, определяющих поведение ключей в дереве. Конечно, эти методы должны быть довольно
изощрёнными, чтобы поддерживать изощрённые запросы, но для всех стандартных запросов (B-
деревьев, R-деревьев и т. д.) они относительно просты. Словом, GiST сочетает расширяемость с
универсальностью, повторным использованием кода и аккуратным интерфейсом.
Класс операторов индекса GiST должен предоставить пять методов и может дополнительно
предоставлять ещё четыре. Корректность индекса обеспечивается реализацией методов same,
consistent и union, а его эффективность (по размеру и скорости) будет зависеть от методов
penalty и picksplit. Два необязательных метода, compress и decompress, позволяют реализовать
внутреннее представление данных дерева, не совпадающее с типом индексируемых данных. Дан-
ные листьев индекса должны быть индексируемого типа, тогда как в остальных узлах дерева мо-
гут быть произвольные структуры C (но при этом должны соблюдаться правила, предъявляемые
PostgreSQL к типам данных; прочитайте о varlena для данных переменного размера). Если внут-
ренний тип данных дерева существует на уровне SQL, в команде CREATE OPERATOR CLASS можно ис-
пользовать указание STORAGE. Необязательный восьмой метод distance нужно реализовать, толь-
ко если класс операторов желает поддерживать упорядоченные сканирования (поиск ближайших
соседей). Необязательный девятый метод fetch требуется, если класс операторов должен поддер-
живать сканирование только индекса и при этом предоставляется метод compress.
consistent
Для переданной записи индекса p и значения запроса q эта функция определяет, является
ли запись индекса «соответствующей» запросу; то есть, может ли предикат «индексирован-
ный_столбец индексируемый_оператор q» удовлетворяться для какой-либо строки, представлен-
ной данной записью индекса? Для записей на уровне листьев это равносильно проверке ин-
дексируемого условия, тогда как для внутреннего узла дерева требуется определить, нужно
ли сканировать поддерево индекса, относящееся к данному узлу. Когда результат true, также
должен возвращаться флаг recheck, показывающий, точно ли удовлетворяется предикат или
это лишь потенциально возможно. Если recheck = false, это означает, что индекс проверил
условие предиката в точности, тогда как при recheck = true проверяемая строка будет только
кандидатом на совпадение. В этом случае система автоматически перепроверит индексируе-
мый_оператор с действительным значением строки, чтобы окончательно определить, соответ-
ствует ли оно запросу. Благодаря этому GiST поддерживает индексы как точной, так и неточ-
ной структуры.
В SQL эта функция должна объявляться примерно так:
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid,
internal)
RETURNS bool
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
А соответствующий код в модуле C может реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_consistent);
2140Индексы GiST
Datum
my_consistent(PG_FUNCTION_ARGS)
{
GISTENTRY <em>entry = (GISTENTRY *) PG_GETARG_POINTER(0);
data_type *query = PG_GETARG_DATA_TYPE_P(1);
StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
/</em> Oid subtype = PG_GETARG_OID(3); <em>/
bool
*recheck = (bool *) PG_GETARG_POINTER(4);
data_type *key = DatumGetDataType(entry-&gt;key);
bool
retval;
/</em></p>
      <ul>
        <li>Определить возвращаемое значение как функцию стратегии, ключа и запроса.
*</li>
        <li>Вызовите GIST_LEAF(entry), чтобы узнать текущую позицию в дереве индекса,</li>
        <li>что удобно, например для поддержки оператора = (вы можете проверить</li>
        <li>равенство в листьях дерева и непустое пересечение в остальных</li>
        <li>узлах).
<em>/
*recheck = true;
/</em> или false, если проверка точная <em>/
PG_RETURN_BOOL(retval);
}
Здесь key — это элемент в индексе, а query — значение, искомое в индексе. Параметр
StrategyNumber показывает, какой оператор из класса операторов применяется — он соответ-
ствует одному из номеров операторов, заданных в команде CREATE OPERATOR CLASS.
В зависимости от того, какие операторы включены в класс, тип данных query может быть раз-
ным для разных операторов, так как это будет тот тип, что фигурирует в правой части опера-
тора, и он может отличаться от индексируемого типа данных, фигурирующего слева. (В пока-
занном выше шаблоне предполагается, что допускается только один тип; в противном случае
получение значения query зависело бы от оператора.) В SQL-объявлении функции consistent
для аргумента query рекомендуется установить индексированный тип данного класса опера-
торов, хотя фактический тип может быть каким-то другим, в зависимости от оператора.
union
Этот метод консолидирует информацию в дереве. Получив набор записей, он должен сгенери-
ровать в индексе новую запись, представляющие все эти записи.
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
И соответствующий код в модуле C должен реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_union);
Datum
my_union(PG_FUNCTION_ARGS)
{
GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
GISTENTRY *ent = entryvec-&gt;vector;
data_type *out,
*tmp,
*old;
int
numranges,
2141Индексы GiST
i = 0;
numranges = entryvec-&gt;n;
tmp = DatumGetDataType(ent[0].key);
out = tmp;
if (numranges == 1)
{
out = data_type_deep_copy(tmp);
PG_RETURN_DATA_TYPE_P(out);
}
for (i = 1; i &lt; numranges; i++)
{
old = out;
tmp = DatumGetDataType(ent[i].key);
out = my_union_implementation(out, tmp);
}
PG_RETURN_DATA_TYPE_P(out);
}
Как можно заметить, в этом шаблоне мы имеем дело с типом данных, для которого union(X,
Y, Z) = union(union(X, Y), Z). Достаточно просто можно поддержать и такие типы данных,
для которых это не выполняется, реализовав соответствующий алгоритм объединения в этом
опорном методе GiST.
Результатом функции union должно быть значение типа хранения индекса, каким бы он ни
был (он может совпадать с типом индексированного столбца, а может и отличаться от него).
Функция, реализующая union, должна возвращать указатель на память, выделенную вызовом
palloc(). Она не может просто вернуть полученное значение как есть, даже если оно имеет
тот же тип.
Как показано выше, первый аргумент internal функции union на самом деле представляет
указатель GistEntryVector. Во втором аргументе (его можно игнорировать) передаётся указа-
тель на целочисленную переменную. (Раньше требовалось, чтобы функция union сохраняла в
этой переменной размер результирующего значения, но теперь такого требования нет.)
compress
Преобразует элемент данных в формат, подходящий для физического хранения в странице ин-
декса. Если метод compress не реализован, элементы данных хранятся в индексе без модифи-
кации.
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
И соответствующий код в модуле C должен реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_compress);
Datum
my_compress(PG_FUNCTION_ARGS)
{
GISTENTRY *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
GISTENTRY *retval;
2142Индексы GiST
if (entry-&gt;leafkey)
{
/</em> заменить entry-&gt;key сжатой версией <em>/
compressed_data_type *compressed_data =
palloc(sizeof(compressed_data_type));
/</em> заполнить <em>compressed_data из entry-&gt;key … */
retval = palloc(sizeof(GISTENTRY));
gistentryinit(</em>retval, PointerGetDatum(compressed_data),
entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
}
else
{
/* обычно с записями внутренних узлов ничего делать не нужно <em>/
retval = entry;
}
PG_RETURN_POINTER(retval);
}
Разумеется, compressed_data_type (тип сжатых данных) нужно привести к нужному типу, при
преобразовании в который будут сжиматься узлы на уровне листьев.
decompress
Преобразует сохранённое представление данных в формат, с которым смогут работать другие
методы GiST в классе операторов. Если метод decompress опускается, подразумевается, что эти
методы могут работать непосредственно с форматом хранения данных. (Метод decompress не
обязательно будет обратным к compress; в частности, если функция compress сохраняет данные
с потерями, decompress не сможет восстановить в точности исходные данные. Поэтому метод
decompress в общем случае неравнозначен fetch, так как другим методам GiST может не по-
требоваться восстанавливать данные полностью.)
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
И соответствующий код в модуле C должен реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_decompress);
Datum
my_decompress(PG_FUNCTION_ARGS)
{
PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
Этот шаблон подходит для случая, когда преобразовывать данные не нужно. (Но, разумеется,
ещё проще и в большинстве случаев рекомендуется вовсе опустить этот метод.)
penalty
Возвращает значение, выражающее «стоимость» добавления новой записи в конкретную ветвь
дерева. Элементы будут вставляться по тому направлению в дереве, для которого значение
penalty минимально. Результаты penalty должны быть неотрицательными; если возвращается
отрицательное значение, оно воспринимается как ноль.
В SQL эта функция должна объявляться так:
2143Индексы GiST
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT; – в некоторых случая функции стоимости не должны быть строгими
И соответствующий код в модуле C может реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_penalty);
Datum
my_penalty(PG_FUNCTION_ARGS)
{
GISTENTRY *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
GISTENTRY *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
float
*penalty = (float *) PG_GETARG_POINTER(2);
data_type *orig = DatumGetDataType(origentry-&gt;key);
data_type *new = DatumGetDataType(newentry-&gt;key);
*penalty = my_penalty_implementation(orig, new);
PG_RETURN_POINTER(penalty);
}
По историческим причинам функция penalty не просто возвращает результат типа float; вме-
сто этого она должна сохранить его значение по адресу, указанному третьим аргументом. Соб-
ственно возвращаемое значение игнорируется, хотя в нём принято возвращать этот же адрес.
Функция penalty важна для хорошей производительности индекса. Она будет вызываться во
время добавления записи, чтобы выбрать ветвь для дальнейшего движения, когда в дерево нуж-
но добавить новый элемент. Это имеет значение во время запроса, так как чем более сбалан-
сирован индекс, тем быстрее будет поиск в нём.
picksplit
Когда необходимо разделить страницу индекса, эта функция решает, какие записи должны
остаться в старой странице, а какие нужно перенести в новую.
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
И соответствующий код в модуле C может реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_picksplit);
Datum
my_picksplit(PG_FUNCTION_ARGS)
{
GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
OffsetNumber maxoff = entryvec-&gt;n - 1;
GISTENTRY *ent = entryvec-&gt;vector;
int
i,
nbytes;
OffsetNumber *left,
*right;
data_type *tmp_union;
data_type *unionL;
data_type *unionR;
GISTENTRY **raw_entryvec;
2144Индексы GiST
maxoff = entryvec-&gt;n - 1;
nbytes = (maxoff + 1) * sizeof(OffsetNumber);
v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
left = v-&gt;spl_left;
v-&gt;spl_nleft = 0;
v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
right = v-&gt;spl_right;
v-&gt;spl_nright = 0;
unionL = NULL;
unionR = NULL;
/</em> Инициализировать чистый вектор записи. <em>/
raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);
for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
{
int
real_index = raw_entryvec[i] - entryvec-&gt;vector;
tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
Assert(tmp_union != NULL);
/</em></li>
        <li>Выбрать, куда помещать записи индекса и изменить unionL и unionR</li>
        <li>соответственно. Добавить записи в v_spl_left или</li>
        <li>v_spl_right и увеличить счётчики.
<em>/
if (my_choice_is_left(unionL, curl, unionR, curr))
{
if (unionL == NULL)
unionL = tmp_union;
else
unionL = my_union_implementation(unionL, tmp_union);
*left = real_index;
++left;
++(v-&gt;spl_nleft);
}
else
{
/</em></li>
        <li>То же самое с правой стороной
<em>/
}
}
v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
PG_RETURN_POINTER(v);
}
Заметьте, что результат функции picksplit доставляется через полученную на вход структуру
v. Собственно возвращаемое значение игнорируется, хотя в нём принято возвращать адрес v.
2145Индексы GiST
Как и penalty, функция picksplit важна для хорошей производительности индекса. Сложность
создания быстродействующих индексов GiST заключается как раз в разработке подходящих
реализаций penalty и picksplit.
same
Возвращает true, если два элемента индекса равны, и false в противном случае. («Элемент ин-
декса» — это значение типа хранения индекса, а не обязательно исходного типа индексируе-
мого столбца.)
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
И соответствующий код в модуле C может реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_same);
Datum
my_same(PG_FUNCTION_ARGS)
{
prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
bool
*result = (bool *) PG_GETARG_POINTER(2);
*result = my_eq(v1, v2);
PG_RETURN_POINTER(result);
}
По историческим причинам функция same не просто возвращает результат булевского типа;
вместо этого она должна сохранить флаг по адресу, указанному третьим аргументом. Собствен-
но возвращаемое значение игнорируется, хотя в нём принято возвращать этот же адрес.
distance
Для переданной записи индекса p и значения запроса q эта функция определяет «дистанцию»
от записи индекса до значения в запросе. Эта функция должна быть представлена, если класс
операторов содержит какие-либо операторы упорядочивания. Запрос с оператором упорядо-
чивания будет выполняться так, чтобы записи индекса с наименьшей «дистанцией» возвраща-
лись первыми, так что результаты должны согласовываться со смысловым значением операто-
ра. Для записи на уровне листьев результат представляет только дистанцию до этой записи, а
для внутреннего узла дерева это будет минимальная дистанция, которая может быть получена
среди всех его потомков.
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
И соответствующий код в модуле C должен реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_distance);
Datum
my_distance(PG_FUNCTION_ARGS)
{
GISTENTRY *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
data_type *query = PG_GETARG_DATA_TYPE_P(1);
2146Индексы GiST
StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
/</em> Oid subtype = PG_GETARG_OID(3); <em>/
/</em> bool <em>recheck = (bool *) PG_GETARG_POINTER(4); */
data_type *key = DatumGetDataType(entry-&gt;key);
double
retval;
/</em></li>
        <li>определить возвращаемое значение как функцию стратегии, ключа и запроса.
<em>/
PG_RETURN_FLOAT8(retval);
}
Функции distance передаются те же аргументы, что и функции consistent.
При определении дистанции допускается некоторая неточность, если результат никогда не бу-
дет превышать действительную дистанцию до элемента. Так, например, в геометрических при-
ложениях бывает достаточно определить дистанцию до описанного прямоугольника. Для внут-
реннего узла дерева результат не должен превышать дистанцию до любого из его дочерних уз-
лов. Если возвращаемая дистанция неточная, функция должна установить флаг *recheck. (Это
необязательно для внутренних узлов дерева; для них результат всегда считается неточным.) В
этом случае исполнитель вычислит точную дистанцию, выбрав кортеж из кучи, и переупоря-
дочит кортежи при необходимости.
Если функция distance возвращает *recheck = true для любого узла на уровне листьев, типом
результата исходного оператора упорядочивания должен быть float8 или float4, и значения
результата функции distance должны быть сравнимы с результатами исходного оператора упо-
рядочивания, так как исполнитель будет выполнять сортировку, используя и результаты функ-
ции distance, и уточнённые результаты оператора упорядочивания. В противном случае зна-
чениями результата distance могут быть любые конечные значения float8, при условии, что
относительный порядок значений результата соответствует порядку, который даёт оператор
упорядочивания. (Значения бесконечность и минус бесконечность применяются внутри для
особых случаев, например, представления NULL, поэтому возвращать такие значения из функ-
ций distance не рекомендуется.)
fetch
Преобразует сжатое представление элемента данных в индексе в исходный тип данных, для
сканирования только индекса. Возвращаемые данные должны быть точной, не примерной ко-
пией изначально проиндексированного значения.
В SQL эта функция должна объявляться так:
CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS ‘MODULE_PATHNAME’
LANGUAGE C STRICT;
В качестве аргумента ей передаётся указатель на структуру GISTENTRY. При вызове её поле key
содержит данные листа в сжатой форме (не NULL). Возвращаемое значение — ещё одна струк-
тура GISTENTRY, в которой поле key содержит те же данные в исходной, развёрнутой форме.
Если функция compress класса операторов не делает с данными листьев ничего, метод fetch
может возвратить аргумент без изменений. Либо, если класс операторов не имеет функции
compress, метод fetch тоже может быть опущен, так как он в любом случае не должен ничего
делать.
Соответствующий код в модуле C должен реализовываться по такому шаблону:
PG_FUNCTION_INFO_V1(my_fetch);
Datum
2147Индексы GiST
my_fetch(PG_FUNCTION_ARGS)
{
GISTENTRY *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
input_data_type *in = DatumGetP(entry-&gt;key);
fetched_data_type *fetched_data;
GISTENTRY *retval;
retval = palloc(sizeof(GISTENTRY));
fetched_data = palloc(sizeof(fetched_data_type));
/</em></li>
        <li>Преобразовать структуру ‘fetched_data’ в Datum исходного типа данных.
<em>/
/</em> заполнить <em>retval из fetch_data. */
gistentryinit(</em>retval, PointerGetDatum(converted_datum),
entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
PG_RETURN_POINTER(retval);
}
Если метод сжатия является неточным для записей уровня листьев, такой класс операторов не
может поддерживать сканирование только индекса и не должен определять функцию fetch.
Все опорные методы GiST обычно вызываются в кратковременных контекстах памяти; то есть,
CurrentMemoryContext сбрасывается после обработки каждого кортежа. Таким образом можно не
заботиться об освобождении любых блоков памяти, выделенных функцией palloc. Однако в неко-
торых случаях для опорного метода полезно кешировать какие-либо данные между вызовами. Для
этого нужно разместить долгоживущие данные в контексте fcinfo-&gt;flinfo-&gt;fn_mcxt и сохранить
указатель на них в fcinfo-&gt;flinfo-&gt;fn_extra. Такие данные смогут просуществовать всё время
операции с индексом (например, одно сканирование индекса GiST, построение индекса или добав-
ление кортежа в индекс). Не забудьте вызвать pfree для предыдущего значения, заменяя значение
в fn_extra, чтобы не допустить накопления утечек памяти в ходе операции.
64.4. Реализация
64.4.1. Построение GiST с буферизацией
Если попытаться построить большой индекс GiST, просто добавляя все кортежи по очереди, скорее
всего это будет медленно, потому что если кортежи индексов будут разбросаны по всему индексу,
а индекс будет большим и не поместится в кеше, при добавлении записей потребуется произвести
множество операций произвольного доступа. Начиная с версии 9.2, PostgreSQL поддерживает бо-
лее эффективный метод построения индексов с применением буферизации, что позволяет карди-
нально сократить число операций произвольного доступа, требующихся при обработке неупорядо-
ченных наборов данных. Для хорошо упорядоченных наборов выигрыш может быть минимальным
или вообще отсутствовать, так как всего несколько страниц будут принимать новые кортежи в один
момент времени, и эти страницы будут умещаться в кеше, даже если весь индекс очень большой.
Однако, при построении индекса с буферизацией приходится гораздо чаще вызывать функцию
penalty, на что уходят дополнительные ресурсы процессора. Кроме того, используемым для этой
операции буферам требуется временное место на диске, вплоть до размера результирующего ин-
декса. Буферизация также может повлиять на качество результирующего индекса, как в положи-
тельную, так и в отрицательную сторону. Это влияние зависит от различных факторов, например,
от распределения поступающих данных и от реализации класса операторов.
По умолчанию при построении индекса GiST включается буферизация, когда размер индекса до-
стигает значения effective_cache_size. Этот режим можно вручную включить или отключить с по-
мощью параметра buffering команды CREATE INDEX. Поведение по умолчанию достаточно эф-
2148Индексы GiST
фективно в большинстве случаев, но если входные данные упорядочены, выключив буферизацию,
можно получить некоторое ускорение.
64.5. Примеры
В дистрибутив исходного кода PostgreSQL включены несколько примеров методов индексов, реа-
лизованных на базе GiST. В настоящее время ядро системы обеспечивает поддержку текстового
поиска (индексацию типов tsvector и tsquery), а также функциональность R-дерева для некото-
рых встроенных геометрических типов данных (см. src/backend/access/gist/gistproc.c). Клас-
сы операторов GiST содержатся также и в следующих дополнительных модулях (contrib):
btree_gist
Функциональность B-дерева для различных типов данных
cube
Индексирование для многомерных кубов
hstore
Модуль для хранения пар (ключ, значение)
intarray
RD-дерево для одномерных массивов значений int4
ltree
Индексирование древовидных структур
pg_trgm
Схожесть текста на основе статистики триграмм
seg
Индексирование «диапазонов чисел с плавающей точкой»
2149</li>
      </ul>
    </blockquote>
  </blockquote>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-063/" title="Глава 63. Индексы B-деревья"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 63. Индексы B-деревья"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-063/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~6 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-063/" rel="bookmark" title="Глава 63. Индексы B-деревья" itemprop="url">Глава 63. Индексы B-деревья</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 63. Индексы B-деревья</p>

<p>63.1. Введение</p>

<p>PostgreSQL включает реализацию стандартной индексной структуры данных — B-дерева (btree,
многонаправленного бинарного дерева). В индекс-B-дерево могут быть загружены данные любого
типа, которые можно отсортировать в чётко определённом линейном порядке. Единственное его
ограничение состоит в том, что размер записи в индексе не может превышать примерно треть
страницы (после сжатия TOAST, если оно применяется).
Так как каждый класс операторов btree устанавливает порядок сортировки для своего типа дан-
ных, классы операторов btree (или, фактически, семейства операторов) оказались показательны-
ми и полезными для представления и понимания семантики сортировки в PostgreSQL. Как след-
ствие, они приобрели некоторые возможности, которые выходят за рамки необходимого минимума
для поддержки индексов btree и используются частями системы, довольно далёкими от методов
доступа btree.
63.2. Поведение классов операторов B-дерева
Как показано в Таблице 38.2, класс операторов btree должен предоставить пять операторов срав-
нения, &lt;, &lt;=, =, &gt;= и &gt;. Хотя можно было ожидать, что частью этого класса будет и оператор &lt;&gt;, но
это не так, потому что использовать &lt;&gt; в предложении WHERE для поиска по индексу практически
бесполезно. (Для некоторых целей планировщик условно относит оператор &lt;&gt; к классу операторов
btree, но он находит данный оператор как отрицание оператора =, а не обращаясь к pg_amop.)
Когда несколько типов данных имеют практически одинаковую семантику сортировки, их классы
операторов можно сгруппировать в семейство операторов. Это полезно тем, что позволяет плани-
ровщику делать выводы о межтиповых сравнениях. Каждый класс операторов в семействе должен
содержать операторы для одного своего типа входных данных (и сопутствующие опорные функ-
ции), тогда как межтиповые операторы сравнения и опорные функции являются «слабо» связан-
ными с семейством. В семейство рекомендуется включать полный набор межтиповых операторов,
чтобы планировщик мог представить любые условия, которые он может вывести, используя тран-
зитивность.
Семейство операторов btree должно удовлетворять нескольким базовым положениям:
• Оператор = должен представлять отношение эквивалентности; то есть для всех отличных от
NULL значений A, B, C определённого типа данных:
• A = A — истина (рефлексивность)
• если A = B, то B = A (симметрия)
• если A = B и B = C, то A = C (транзитивность)
• Оператор &lt; должен представлять отношение строгого упорядочивания; то есть для всех от-
личных от NULL значений A, B, C:
• A &lt; A — ложно (антирефлексивность)
• если A &lt; B и B &lt; C, то A &lt; C (транзитивность)
• Более того, упорядочивание действует глобально; то есть для любых отличных от NULL значе-
ний A, B:
• истинным является ровно одно из условий: A &lt; B, A = B или B &lt; A (трихотомия)
(Разумеется, определение функции, осуществляющей сравнение, вытекает из закона трихото-
мии.)
Остальные три оператора определяются через операторы = и &lt; очевидным образом и должны ра-
ботать согласованно с последними.
2136Индексы B-деревья
Для семейства операторов, поддерживающего несколько типов данных, вышеперечисленные за-
коны должны выполняться при значениях A, B, C, относящихся к любым типам из семейства. Тран-
зитивность обеспечить сложнее всего, так как в ситуациях с разными типами она требует согла-
сованного поведения двух или трёх различных операторов. Так например, в одном семействе опе-
раторов не смогут работать типы float8 и numeric, по крайней мере при текущем подходе, когда
значения numeric преобразуются во float8 для сравнения с float8. Из-за ограниченной точности
типа float8 различные значения numeric могут оказаться равными одному значению float8, что
нарушит закон транзитивности.
Ещё одно требование для семейства, рассчитанного на несколько типов данных, состоит в том, что
любое неявное или двоично-совместимое приведение, которое определено между типами, вклю-
чёнными в семейство операторов, не должно менять соответствующий порядок сортировки.
Должно быть достаточно понятно, почему индекс-B-дерево требует выполнения этих законов для
одного типа данных: без этого упорядочивание ключей невозможно. Кроме того, для поиска в ин-
дексе по ключу другого типа данных необходимо, чтобы значения двух типов сравнивались кор-
ректно. Расширение семейства до трёх или более типов данных не является обязательным для са-
мого механизма индекса btree, но может быть полезным для планировщика в целях оптимизации.
63.3. Опорные функции B-деревьев
Как показано в Таблица 38.8, btree определяет одну необходимую и две необязательных опорных
функции.
Для всех комбинаций типов данных, для которых семейство операторов btree предоставляет опе-
раторы сравнения, оно должно предоставлять опорную функцию сравнения в pg_amproc с номером
1 и c amproclefttype/amprocrighttype, равными левому и правому типу сравнения (то есть тем же
типам данных, с которыми соответствующие операторы зарегистрированы в pg_amop). Эта функ-
ция сравнения должна принимать два отличных от NULL значения A и B и возвращать значение
int32, которое будет &lt; 0, 0 или &gt; 0, когда A &lt; B, A = B или A &gt; B, соответственно. Результат NULL не
допускается: все значения типа данных должны быть сравнимыми. Примеры можно найти в src/
backend/access/nbtree/nbtcompare.c.
Если сравниваемые значения имеют сортируемый тип данных, опорной функции сравне-
ния будет передан OID соответствующего правила сортировки через стандартный механизм
PG_GET_COLLATION().
Дополнительно семейство операторов btree может предоставить функции поддержки сортировки,
которые регистрируются под номером опорной функции 2. Эти функции позволяют реализовывать
сравнения для целей сортировки гораздо эффективнее, чем это возможно при прямолинейном вы-
зове функции поддержки сравнения. Задействованные в этом программные интерфейсы опреде-
лены в src/include/utils/sortsupport.h.
Дополнительно семейство операторов btree может предоставить опорные функции in_range, кото-
рые регистрируются под номером 3. Они не используются в ходе операций с индексом btree; вме-
сто этого они расширяют семантику семейства операторов, чтобы оно могло поддерживать окон-
ные предложения RANGE смещение PRECEDING и RANGE смещение FOLLOWING (см. Подраздел  4.2.8).
По сути они предоставляют дополнительную информацию, позволяющую добавлять или вычитать
смещение в соответствии с порядком сортировки, принятым в семействе.
Функция in_range должна иметь сигнатуру
in_range(значение type1, база type1, смещение type2, вычитание bool, меньше bool)
returns bool
Значение и база должны быть одного типа данных, и этот тип должен поддерживаться семейством
операторов (то есть это должен быть тип, для которого реализуется сортировка). Однако смещение
может быть другого типа, который никаким другим образом не поддерживается данным семей-
ством. Например, встроенное семейство time_ops предоставляет функцию, для которой смещение
2137Индексы B-деревья
имеет тип interval. Семейство может предоставлять функции in_range для любых из своих под-
держиваемых типов и одного или нескольких типов смещений. Каждая функция in_range должна
регистрироваться в pg_amproc с полем amproclefttype, равным type1, и amprocrighttype, равным
type2.
Суть действия функции in_range зависит от двух логических флагов. Она должна прибавить или
вычесть из базы смещение, а затем сравнить значение с результатом следующим образом:
• если !вычитание и !меньше, возвращается значение &gt;= (база + смещение)
• если !вычитание и меньше, возвращается значение &lt;= (база + смещение)
• если вычитание и !меньше, возвращается значение &gt;= (база - смещение)
• если вычитание и меньше, возвращается значение &lt;= (база - смещение)
Прежде чем делать это, функция должна проверить знак смещения и, если оно отрицательное,
выдать ошибку ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE (22013) с текстом ошибки «invalid
preceding or following size in window function» (неверная предшествующая или последующая вели-
чина в оконной функции). (Это требуется стандартом SQL, но нестандартные семейства операто-
ров могут проигнорировать данное ограничение, так как оно не несёт большой смысловой нагруз-
ки.) Проверка этого требования делегируется функции in_range, чтобы коду ядра не требовалось
понимать, что означает «меньше нуля» для произвольного типа данных.
Кроме того, функции in_range, если это практично, могут не выдавать ошибку, когда операция
база + смещение или база - смещение приводит к переполнению. Правильный результат сравнения
можно получить, даже если это значение выходит за границы допустимого диапазона этого типа
данных. Заметьте, что если для типа данных определены такие понятия, как «бесконечность» и
«NaN», могут потребоваться дополнительные меры для обеспечения согласованности результатов
in_range с обычным порядком сортировки данного семейства операторов.
Результаты функции in_range должны соответствовать порядку сортировки, устанавливаемому се-
мейством операторов. Точнее говоря, при любых фиксированных аргументах смещение и вычитание
справедливо:
• Если in_range с меньше = true возвращает true для некоторого значения1 и базы, true должно
возвращаться для каждого значения2 &lt;= значению1 с той же базой.
• Если in_range с меньше = true возвращает false для некоторого значения1 и базы, false должно
возвращаться для любого значения2 &gt;= значению1 с той же базой.
• Если in_range с меньше = true возвращает true для некоторого значения и базы1, true должно
возвращаться для каждой базы2 &gt;= базе1 с тем же значением.
• Если in_range с меньше = true возвращает false для некоторого значения и базы1, false должно
возвращаться для любой базы2 &lt;= базе1 с тем же значением.
Аналогичные утверждения с противоположными условиями должны выполняться при меньше =
false.
Если упорядочиваемый тип (type1) является сортируемым, функции in_range будет передан OID
соответствующего правила сортировки через стандартный механизм PG_GET_COLLATION().
Функции in_range не должны обрабатывать NULL в аргументах и обычно помечаются как строгие.
63.4. Реализация
Вводное описание реализации индекса btree можно найти в src/backend/access/nbtree/README.
2138</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page5/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page4/">4</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page5/">5</a></li>
      
    
      
        <li><strong class="current-page">6</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page7/">7</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page8/">8</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page7/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>