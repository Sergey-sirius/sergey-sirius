<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page6/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page6/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-062/" title="Глава 62. Унифицированные записи WAL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 62. Унифицированные записи WAL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-062/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~2 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-062/" rel="bookmark" title="Глава 62. Унифицированные записи WAL" itemprop="url">Глава 62. Унифицированные записи WAL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 62. Унифицированные записи WAL</p>

<p>Хотя у всех внутренних модулей, взаимодействующих с WAL, имеются собственные типы записей
WAL, существует также унифицированный тип записей WAL, описывающий изменения в страни-
цах унифицированным образом. Это полезно для расширений, реализующих собственные методы
доступа, так как они не могут зарегистрировать свои подпрограммы воспроизведения изменений
WAL.
API для конструирования унифицированных записей WAL определён в access/generic_xlog.h и
реализован в access/transam/generic_xlog.c.
Чтобы сформировать запись изменения данных для WAL, применяя механизм унифицированных
записей WAL, выполните следующие действия:</p>
<ol>
  <li>state = GenericXLogStart(relation) — начните формирование унифицированной записи WAL
для заданного отношения.</li>
  <li>page = GenericXLogRegisterBuffer(state, buffer, flags) — зарегистрируйте буфер, кото-
рый будет изменён текущей унифицированной записью WAL. Эта функция возвращает указа-
тель на временную копию страницы буфера, в которой должны производиться изменения. (Мо-
дифицировать непосредственно содержимое буфера нельзя.) В третьем аргументе передаётся
битовая маска флагов, применимых к этой операции. В настоящее время флаг только один —
GENERIC_XLOG_FULL_IMAGE, который показывает, что в запись WAL нужно включить образ всей
страницы, а не только изменения. Обычно этот флаг должен устанавливаться, когда страница
новая или полностью перезаписана. Вызов GenericXLogRegisterBuffer можно повторять, если
фиксируемое в WAL действие изменяет несколько страниц.</li>
  <li>Применить изменения к образам страниц, полученным на предыдущем шаге.</li>
  <li>GenericXLogFinish(state) — завершите изменения в буферах и выдайте унифицированную за-
пись WAL.
Формирование записи WAL можно прервать на любом шаге, вызвав GenericXLogAbort(state). При
этом будут отменены все изменения, внесённые в копии образов страниц.
Используя механизм унифицированных записей WAL, необходимо учитывать следующее:
• Модифицировать буферы напрямую нельзя! Все изменения должны производиться в копиях,
полученных от функции GenericXLogRegisterBuffer(). Другими словами, код, формирующий
унифицированные записи WAL, никогда не должен сам вызывать BufferGetPage(). Однако,
вызывающий код отвечает за закрепление/открепление и блокировку/разблокировку буферов
в подходящие моменты времени. Исключительная блокировка каждого целевого буфера долж-
на удерживаться от вызова GenericXLogRegisterBuffer() до GenericXLogFinish().
• Регистрацию буферов (шаг 2) и модификацию образов страниц (шаг 3) можно свободно сме-
шивать, оба этих шага можно повторять в любой последовательности. Но помните, что буферы
должны регистрироваться в том же порядке, в каком для них должны получаться блокировки
при воспроизведении.
• Максимальное число буферов, которые можно зарегистрировать для унифицированной за-
писи WAL, составляет MAX_GENERIC_XLOG_PAGES. При исчерпании этого лимита будет выдана
ошибка.
• Унифицированный тип WAL подразумевает, что страницы, подлежащие изменению, имеют
стандартную структуру, в частности между pd_lower и pd_upper нет полезных данных.
• Так как изменяются копии страниц буфера, GenericXLogStart() не начинает критическую
секцию. Таким образом вы можете безопасно выделять память, выдать ошибку и т. п. между
GenericXLogStart() и GenericXLogFinish(). Единственная фактическая критическая секция
присутствует внутри GenericXLogFinish(). При выходе по ошибке так же не нужно заботить-
ся о вызове GenericXLogAbort().
2134Унифицированные записи WAL
• GenericXLogFinish() помечает буферы как грязные и устанавливает для них LSN. Вам делать
явно это не нужно.
• Для нежурналируемых отношений всё работает так же, за исключением того, что фактически
запись в WAL не выдаётся. Таким образом, явно проверять, является ли отношение нежурна-
лируемым, не требуется.
• Функция воспроизведения унифицированных изменений WAL получит исключительные бло-
кировки буферов в том же порядке, в каком они были зарегистрированы. После воспроизведе-
ния всех изменений блокировки в том же порядке и освобождаются.
• Если для регистрируемого буфера не задаётся GENERIC_XLOG_FULL_IMAGE, унифицированная
запись WAL содержит различие между старым и новым образом страницы, которое вычисля-
ется при побайтовом сравнении. Результат оказывается не очень компактным при перемеще-
нии данных в странице, но это может быть доработано в будущем.
2135</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-061/" title="Глава 61. Определение интерфейса для методов доступа индекса"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 61. Определение интерфейса для методов доступа индекса"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-061/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~33 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-061/" rel="bookmark" title="Глава 61. Определение интерфейса для методов доступа индекса" itemprop="url">Глава 61. Определение интерфейса для методов доступа индекса</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 61. Определение интерфейса для методов доступа индекса</p>

<p>В этой главе описывается интерфейс между ядром системы PostgreSQL и методами доступа ин-
дексов, которые управляют отдельными типами индексов. Ядро системы не знает об индексах ни-
чего, кроме того, что описано здесь; благодаря этому можно реализовывать абсолютно новые типы
индексов, разрабатывая код в виде расширения.
Все индексы PostgreSQL являются, говоря на техническом уровне, вторичными индексами; то
есть, они физически отделены от файла таблицы, к которой относятся. Каждый индекс хранится
в собственном отдельном физическом отношении и описывается в отдельной записи в каталоге
pg_class. Содержимое индекса находится полностью под контролем соответствующего метода до-
ступа. На практике все методы доступа индексов делят индексы на страницы стандартного раз-
мера, чтобы для обращения к содержимому индекса можно было задействовать обычный мене-
джер хранилища и менеджер буферов. (Более того, большинство существующих методов доступа
используют одну структуру страницы, описанную в Разделе 68.6, и одинаковый формат заголовков
кортежей индекса; но эти решения методам доступа не навязываются.)
Индекс по сути представляет собой сопоставление некоторых значений ключей данных с иденти-
фикаторами кортежей, TID (Tuple Identifier), или версиями строк в основной таблице индекса.
TID состоит из номера блока и номера записи в этом блоке (см. Раздел 68.6). Этой информации
достаточно, чтобы выбрать определённую версию строки из таблицы. Индексы сами по себе не
знают, что в модели MVCC у одной логической строки может быть несколько существующих вер-
сий; для индекса каждый кортеж — независимый объект, которому нужна своя запись в индексе.
Таким образом, при изменении строки для неё всегда заново создаются новые записи индекса, да-
же если значения ключа не изменились. (Кортежи HOT представляют собой исключение из этого
утверждения; но индексы всё равно не имеют с этим дела.) Записи индексов для мёртвых кортежей
высвобождаются (при очистке), когда высвобождаются сами мёртвые кортежи.
61.1. Базовая структура API для индексов
Каждый метод доступа индекса описывается строкой в системном каталоге pg_am. В записи pg_am
указывается имя и функция-обработчик для метода доступа. Эти записи могут создаваться и уда-
ляться командами SQL CREATE ACCESS METHOD и DROP ACCESS METHOD.
Функция-обработчик метода доступа должна объявляться как принимающая один аргумент ти-
па internal и возвращающая псевдотип index_am_handler. Аргумент в данном случае фиктив-
ный, и нужен только для того, чтобы эту функцию нельзя было вызывать непосредственно из ко-
манд SQL. Возвращать эта функция должна структуру типа IndexAmRoutine (в памяти palloc), со-
держащую всё, что нужно знать коду ядра, чтобы использовать этот метод доступа. Структура
IndexAmRoutine, также называемая структурой API метода доступа, содержит поля, задающие
разнообразные предопределённые свойства метода доступа, например, поддерживает ли он со-
ставные индексы. Что более важно, она содержит указатели на опорные функции для метода до-
ступа. Это обычные функции на C и они не видны и не могут быть вызваны на уровне SQL. Опорные
функции описаны в Разделе 61.2.
Структура IndexAmRoutine определяется так:
typedef struct IndexAmRoutine
{
NodeTag
type;
/*</p>
<ul>
  <li>Общее число стратегий (операторов), с которыми возможен поиск/применение</li>
  <li>этого метода доступа (МД). Ноль, если у этого МД нет фиксированного набора</li>
  <li>назначенных стратегий.
<em>/
uint16
amstrategies;
2119Определение интерфейса
для методов доступа индекса
/</em> общее число опорных функций, используемых этим МД <em>/
uint16
amsupport;
/</em> поддерживает ли МД упорядочивание (ORDER BY) значений индексированного столбца?
<em>/
bool
amcanorder;
/</em> поддерживает ли МД упорядочивание (ORDER BY) результата оператора с
индексированным столбцом? <em>/
bool
amcanorderbyop;
/</em> поддерживает ли МД сканирование в обратном направлении? <em>/
bool
amcanbackward;
/</em> поддерживает ли МД уникальные индексы (UNIQUE)? <em>/
bool
amcanunique;
/</em> поддерживает ли МД индексы с несколькими столбцами? <em>/
bool
amcanmulticol;
/</em> требуется ли для сканирования с МД ограничение первого столбца индекса? <em>/
bool
amoptionalkey;
/</em> воспринимает ли МД условия ScalarArrayOpExpr? <em>/
bool
amsearcharray;
/</em> воспринимает ли МД условия IS NULL/IS NOT NULL? <em>/
bool
amsearchnulls;
/</em> может ли тип, хранящийся в индексе, отличаться от типа столбца? <em>/
bool
amstorage;
/</em> возможна ли кластеризация по индексу этого типа? <em>/
bool
amclusterable;
/</em> МД обрабатывает предикатные блокировки? <em>/
bool
ampredlocks;
/</em> МД поддерживает параллельное сканирование? <em>/
bool
amcanparallel;
/</em> МД поддерживает столбцы, включённые в индекс с помощью INCLUDE? <em>/
bool
amcaninclude;
/</em> тип данных, хранящихся в индексе, либо InvalidOid, если он переменный <em>/
Oid
amkeytype;
/</em> интерфейсные функции <em>/
ambuild_function ambuild;
ambuildempty_function ambuildempty;
aminsert_function aminsert;
ambulkdelete_function ambulkdelete;
amvacuumcleanup_function amvacuumcleanup;
amcanreturn_function amcanreturn;
/</em> может
amcostestimate_function amcostestimate;
amoptions_function amoptions;
amproperty_function amproperty;
/* может
amvalidate_function amvalidate;
ambeginscan_function ambeginscan;
amrescan_function amrescan;
amgettuple_function amgettuple;
/* может
amgetbitmap_function amgetbitmap;
/* может
amendscan_function amendscan;
ammarkpos_function ammarkpos;
/* может
amrestrpos_function amrestrpos;
/* может
быть NULL <em>/
быть NULL */
быть NULL */
быть NULL */
быть NULL */
быть NULL */
/</em> интерфейсные функции для поддержки параллельного сканирования по индексу
amestimateparallelscan_function amestimateparallelscan; /* может быть NULL
aminitparallelscan_function aminitparallelscan;
/* может быть NULL
amparallelrescan_function amparallelrescan;
/* может быть NULL
} IndexAmRoutine;
2120
*/
*/
*/
*/Определение интерфейса
для методов доступа индекса
Чтобы метод доступа индекса применялся, необходимо также определить семейства операторов
и классы операторов в pg_opfamily, pg_opclass, pg_amop и pg_amproc. Эти записи позволяют пла-
нировщику понять, для каких видов условий запросов могут применяться индексы с данными ме-
тодом доступа. Семейства и классы операторов описываются в Разделе 38.15; этот материал необ-
ходимо изучить, прежде чем читать данную главу.
Отдельный индекс определяется записью в pg_class, описывающей его как физическое отноше-
ние, и записью в pg_index, представляющей логическое содержание индекса — то есть, набор
столбцов индекса и семантическое значение этих столбцов, установленное соответствующими
классами операторов. Столбцами индекса (значениями ключа) могут быть либо простые столбцы
нижележащей таблицы, либо выражения, вычисляемые по строкам таблицы. Для метода доступа
индекса обычно не важно, откуда поступают значения ключа индекса (они всегда поступают в
вычисленном виде), но очень важна информация о классе операторов в каталоге pg_index. Обе эти
записи каталогов представлены в составе структуры данных Relation, которая передаётся всем
функциям, реализующим операции с индексом.
С некоторыми полями флагов в IndexAmRoutine связаны неочевидные следствия. Требования ин-
дексов с amcanunique описаны в Разделе 61.5. Флаг amcanmulticol показывает, что метод доступа
поддерживает составные индексы, а amoptionalkey обозначает, что метод позволяет выполнить
сканирование при отсутствии индексируемого ограничивающего условия для первого столбца ин-
декса. Когда amcanmulticol равен false, amoptionalkey по сути говорит, поддерживает ли метод до-
ступа полное сканирование по индексу без ограничивающего условия. Методы доступа, поддержи-
вающие индексы по нескольким столбцам, должны поддерживать сканирования при отсутствии
ограничений любых или всех столбцов после первого; однако они могут требовать присутствия
какого-либо ограничения для первого столбца индекса, и это требование отмечается значением
false флага amoptionalkey. В amoptionalkey для метода доступа может устанавливаться false, на-
пример, когда этот метод доступа не индексирует значения. Так как большинство индексируемых
операторов — строгие, и поэтому не могут вернуть true для операндов NULL, на первый взгляд
кажется заманчивой идея не хранить записи индекса для значений NULL: они всё равно никак
не могут быть прочитаны при сканировании индекса. Однако этот аргумент отпадает, когда при
сканировании индекса вовсе отсутствует ограничение данного столбца индекса. На практике это
означает, что индексы с установленным флагом amoptionalkey должны индексировать значения
NULL, так как планировщик может склониться к использованию этого индекса вообще без ключей.
С этим связано ещё одно ограничение — метод доступа индекса, поддерживающий составные ин-
дексы, должен поддерживать индексирование значений NULL в столбцах после первого, так как
планировщик будет полагать, что индекс можно применять для запросов, в которых эти столбцы
не ограничиваются. Например, рассмотрим индекс по (a,b) и запрос с ограничением WHERE a =
    <ol>
      <li>Система будет полагать, что по этому индексу можно просканировать строки с a = 4, но это
будет неверно, если индекс исключит строки, в которых b — NULL. Однако, этот индекс вполне
может исключить строки, в которых первый столбец содержит NULL. Метод индекса, который ин-
дексирует значения NULL, может также установить флаг amsearchnulls, отметив тем самым, что
он поддерживает в качестве условий поиска IS NULL и IS NOT NULL.
61.2. Функции для метода доступа индекса
Метод доступа индекса должен определить в IndexAmRoutine следующие функции построения и
обслуживания индексов:
IndexBuildResult *
ambuild (Relation heapRelation,
Relation indexRelation,
IndexInfo *indexInfo);
Строит новый индекс. Отношение индекса уже физически создано, но пока пусто. Оно долж-
но быть наполнено фиксированными данными, которые требуются методу доступа, и запи-
сями для всех кортежей, уже существующих в таблице. Обычно функция ambuild вызывает
IndexBuildHeapScan() для поиска в таблице существующих кортежей и для вычисления ключей,
которые должны вставляться в этот индекс. Эта функция должна возвращать структуру, выделен-
ную вызовом palloc и содержащую статистику нового индекса.
2121Определение интерфейса
для методов доступа индекса
void
ambuildempty (Relation indexRelation);
Создаёт пустой индекс и записывает его в слой инициализации (INIT_FORKNUM) данного отношения.
Этот метод вызывается только для нежурналируемых индексов; пустой индекс, записанный в слой
инициализации, будет копироваться в основной слой отношения при каждом перезапуске сервера.
bool
aminsert (Relation indexRelation,
Datum *values,
bool *isnull,
ItemPointer heap_tid,
Relation heapRelation,
IndexUniqueCheck checkUnique,
IndexInfo *indexInfo);
Вставляет новый кортеж в существующий индекс. В массивах values и isnull передаются значе-
ния ключа, которые должны быть проиндексированы, а в heap_tid — идентификатор индексиру-
емого кортежа (TID). Если метод доступа поддерживает уникальные индексы (флаг amcanunique
установлен), параметр checkUnique указывает, какая проверка уникальности должна выполнять-
ся. Это зависит от того, является ли ограничение уникальности откладываемым; за подробностя-
ми обратитесь к Разделу 61.5. Обычно параметр heapRelation нужен методу доступа только для
проверки уникальности (так как он должен обратиться к основным данным, чтобы убедиться в ак-
туальности кортежа).
Возвращаемый функцией булевский результат имеет значение, только когда параметр
checkUnique равен UNIQUE_CHECK_PARTIAL. В этом случае результат true означает, что новая запись
признана уникальной, тогда как false означает, что она может быть неуникальной (и требуется
назначить отложенную проверку уникальности). В других случаях рекомендуется возвращать по-
стоянный результат false.
Некоторые индексы могут индексировать не все кортежи. Если кортеж не будет индексирован,
aminsert должна просто завершиться, не делая ничего.
Если МД индекса хочет кешировать данные между операциями добавления в индекс в одном опе-
раторе SQL, он может выделить память в indexInfo-&gt;ii_Context и сохранить указатель на эти
данные в поле indexInfo-&gt;ii_AmCache (которое изначально равно NULL).
IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
IndexBulkDeleteResult *stats,
IndexBulkDeleteCallback callback,
void *callback_state);
Удаляет кортеж(и) из индекса. Это операция «массового удаления», которая предположитель-
но будет реализована путём сканирования всего индекса и проверки для каждой записи, долж-
на ли она удаляться. Переданная функция callback должна вызываться в стиле callback(TID,
callback_state) с результатом bool, который говорит, должна ли удаляться запись индекса, на
которую указывает передаваемый TID. Возвращать эта функция должна NULL или структуру, вы-
деленную вызовом palloc и содержащую статистику результата удаления. NULL можно вернуть,
если никакая информация не должна передаваться в amvacuumcleanup.
Из-за ограничения maintenance_work_mem процедура ambulkdelete может вызываться несколько
раз, когда удалению подлежит большое количество кортежей. В аргументе stats передаётся ре-
зультат предыдущего вызова для данного индекса (при первом вызове в ходе операции VACUUM он
содержит NULL). Это позволяет методу доступа накапливать статистику в процессе всей опера-
ции. Обычно ambulkdelete модифицирует и возвращает одну и ту же структуру, если в stats пе-
редаётся не NULL.
IndexBulkDeleteResult *
2122Определение интерфейса
для методов доступа индекса
amvacuumcleanup (IndexVacuumInfo *info,
IndexBulkDeleteResult *stats);
Провести очистку после операции VACUUM (до этого ambulkdelete могла вызываться несколько или
ноль раз). От этой функции не требуется ничего, кроме как выдать статистику по индексу, но она
может произвести массовую очистку, например, высвободить пустые страницы индекса. В stats
ей передаётся структура, возвращённая при последнем вызове ambulkdelete, либо NULL, если
ambulkdelete не вызывалась, так как никакие кортежи удалять не требовалось. Эта функция долж-
на возвращать NULL или структуру, выделенную вызовом palloc. Содержащаяся в этой структу-
ре статистика будет отражена в записи в pg_class и попадёт в вывод команды VACUUM, если она
выполнялась с указанием VERBOSE. NULL может возвращаться, если индекс вовсе не изменился в
процессе операции VACUUM, но в противном случае должна возвращаться корректная статистика.
Начиная с PostgreSQL версии 8.4, amvacuumcleanup также вызывается в конце операции ANALYZE.
В этом случае stats всегда NULL и любое возвращаемое значение игнорируется. Этот вариант
вызова можно распознать, проверив поле info-&gt;analyze_only. При таком вызове методу доступа
рекомендуется ничего не делать, кроме как провести очистку после добавления данных, и только
в рабочем процессе автоочистки.
bool
amcanreturn (Relation indexRelation, int attno);
Проверяет, поддерживается ли сканирование только индекса для заданного столбца, когда для
записи индекса возвращаются значения индексируемых столбцов в виде IndexTuple. Атрибуты ну-
меруются с 1, то есть для первого столбца attno равен 1. Возвращает true, если такое сканирование
поддерживается, а иначе false. Если метод доступа индекса в принципе не поддерживает скани-
рование только индекса, в поле amcanreturn его структуры IndexAmRoutine можно записать NULL.
void
amcostestimate (PlannerInfo *root,
IndexPath *path,
double loop_count,
Cost *indexStartupCost,
Cost *indexTotalCost,
Selectivity *indexSelectivity,
double *indexCorrelation,
double *indexPages);
Рассчитывает примерную стоимость сканирования индекса. Эта функция полностью описывается
ниже в Разделе 61.6.
bytea *
amoptions (ArrayType *reloptions,
bool validate);
Разбирает и проверяет массив параметров для индекса. Эта функция вызывается, только когда для
индекса задан отличный от NULL массив reloptions. Массив reloptions состоит из элементов типа
text, содержащих записи вида имя=значение. Данная функция должна получить значение типа
bytea, которое будет скопировано в поле rd_options записи индекса в relcache. Содержимое этого
значения bytea определяется самим методом доступа; большинство стандартных методов доступа
помещают в него структуру StdRdOptions. Когда параметр validate равен true, эта функция долж-
на выдать подходящее сообщение об ошибке, если какие-либо параметры нераспознаны или име-
ют недопустимые значения; если же validate равен false, некорректные записи должны просто
игнорироваться. (В validate передаётся false, когда параметры уже загружены в pg_catalog; при
этом неверная запись может быть обнаружена, только если в методе доступа поменялись правила
обработки параметров, и в этом случае стоит просто игнорировать такие записи.) NULL можно
вернуть, когда нужно получить поведение по умолчанию.
bool
amproperty (Oid index_oid, int attno,
2123Определение интерфейса
для методов доступа индекса
IndexAMProperty prop, const char *propname,
bool *res, bool *isnull);
Процедура amproperty позволяет методам доступа индексов переопределять стандартное поведе-
ние функции pg_index_column_has_property и связанных с ней. Если метод доступа не проявляет
никаких особенностей при запросе свойств индексов, поле amproperty в структуре IndexAmRoutine
может содержать NULL. В противном случае процедура amproperty будет вызываться с нуле-
выми параметрами index_oid и attno при вызове pg_indexam_has_property, либо с корректным
index_oid и нулевым attno при вызове pg_index_has_property, либо с корректным index_oid и
положительным attno при вызове pg_index_column_has_property. В prop передаётся значение пе-
речисления, указывающее на проверяемое значение, а в propname — строка с именем свойства.
Если код ядра не распознаёт имя свойства, в prop передаётся AMPROP_UNKNOWN. Методы доступа
могут воспринимать нестандартные имена свойств, проверяя propname на совпадение (для согла-
сованности с кодом ядра используйте для проверки pg_strcasecmp); для имён, известных коду яд-
ра, лучше проверять prop. Если процедура amproperty возвращает true, это значит, что она уста-
новила результат проверки свойства: она должна задать в *res возвращаемое булевское значение
или установить в *isnull значение true, чтобы возвратить NULL. (Перед вызовом обе упомянутые
переменные инициализируются значением false.) Если amproperty возвращает false, код ядра
переключается на обычную логику определения результата проверки свойства.
Методы доступа, поддерживающие операторы упорядочивания, должны реализовывать проверку
свойства AMPROP_DISTANCE_ORDERABLE, так как код ядра не знает, как это сделать и возвращает
NULL. Также может быть полезно реализовать проверку AMPROP_RETURNABLE, если это можно сде-
лать проще, чем обращаясь к индексу и вызывая amcanreturn (что делает код ядра по умолчанию).
Для всех остальных стандартных свойств поведение ядра по умолчанию можно считать удовлетво-
рительным.
bool
amvalidate (Oid opclassoid);
Проверяет записи в каталоге для заданного класса операторов, насколько это может сделать ме-
тод доступа. Например, это может включать проверку, все ли необходимые опорные функции реа-
лизованы. Функция amvalidate должна вернуть false, если класс операторов непригоден к исполь-
зованию. Сообщения о проблеме следует выдать через ereport.
Цель индекса, конечно, в том, чтобы поддерживать поиск кортежей, соответствующих индекси-
руемому условию WHERE, по ограничению или ключу поиска. Сканирование индекса описывается
более полно ниже, в Разделе 61.3. Метод доступа индекса может поддерживать «простое» скани-
рование, сканирование по «битовой карте» или и то, и другое. Метод доступа должен или может
реализовывать следующие функции, связанные со сканированием:
IndexScanDesc
ambeginscan (Relation indexRelation,
int nkeys,
int norderbys);
Подготавливает метод к сканированию индекса. В параметрах nkeys и norderbys задаётся коли-
чество операторов условия и сортировки, которые будут задействованы при сканировании; это мо-
жет быть полезно для выделения памяти. Заметьте, что фактические значения ключей сканирова-
ния в этот момент ещё не предоставляются. В результате функция должна выдать структуру, вы-
деленную средствами palloc. В связи с особенностями реализации, метод доступа должен создать
эту структуру, вызвав RelationGetIndexScan(). В большинстве случаев все действия ambeginscan
сводятся только к выполнению этого вызова и, возможно, получению блокировок; всё самое инте-
ресное при запуске сканирования индекса происходит в amrescan.
void
amrescan (IndexScanDesc scan,
ScanKey keys,
int nkeys,
2124Определение интерфейса
для методов доступа индекса
ScanKey orderbys,
int norderbys);
Запускает или перезапускает сканирование индекса, возможно, с новыми ключами сканирования.
(Для перезапуска сканирования с ранее переданными ключами в keys и/или orderbys передаётся
NULL.) Заметьте, что количество ключей или операторов сортировки не может превышать значе-
ния, поступившие в ambeginscan. На практике возможность перезапуска используется, когда в со-
единении со вложенным циклом выбирается новый внешний кортеж, так что требуется сравнение
с новым ключом, но структура ключей сканирования не меняется.
boolean
amgettuple (IndexScanDesc scan,
ScanDirection direction);
Выбирает следующий кортеж в ходе данного сканирования, с передвижением по индексу в задан-
ном направлении (вперёд или назад). Возвращает true, если кортеж был получен, или false, если
подходящих кортежей не осталось. В случае успеха в структуре scan сохраняется TID кортежа.
Заметьте, что под «успехом» здесь подразумевается только, что индекс содержит запись, соот-
ветствующую ключам сканирования, а не то, что данный кортеж обязательно существует в дан-
ных или оказывается видимым в снимке вызывающего субъекта. При положительном результате
amgettuple должна также установить для свойства scan-&gt;xs_recheck значение true или false. Зна-
чение false будет означать, что запись индекса точно соответствует ключам сканирования, а true
— что есть сомнение в этом, так что условия, представленные ключами сканирования, необходимо
ещё раз перепроверить для фактического кортежа, когда он будет получен. Это свойство введе-
но для поддержки «неточных» операторов индексов. Заметьте, что такая перепроверка касается
только условий сканирования; предикат частичного индекса (если он имеется) никогда не пере-
проверяется кодом, вызывающим amgettuple.
Если индекс поддерживает сканирование только индекса (то есть amcanreturn для него равен true),
то в случае успеха метод доступа должен также проверить флаг scan-&gt;xs_want_itup и, если он
установлен, должен вернуть исходные индексированные данные для этой записи индекса. Данные
могут возвращаться посредством указателя на IndexTuple, сохранённого в scan-&gt;xs_itup, с де-
скриптором scan-&gt;xs_itupdesc; либо посредством указателя на HeapTuple, сохранённого в scan-
        <blockquote>
          <p>xs_hitup, с дескриптором кортежа scan-&gt;xs_hitupdesc. (Второй вариант должен использоваться
при восстановлении данных, которые могут не уместиться в IndexTuple.) В любом случае за управ-
ление целевой областью данных, определяемой этим указателем, отвечает метод доступа. Данные
должны оставаться актуальными как минимум до следующего вызова amgettuple, amrescan или
amendscan в процессе сканирования.
Функция amgettuple должна быть реализована, только если метод доступа поддерживает «про-
стое» сканирование индекса. В противном случае поле amgettuple в структуре IndexAmRoutine
должно содержать NULL.
int64
amgetbitmap (IndexScanDesc scan,
TIDBitmap *tbm);
Выбирает все кортежи для данного сканирования и добавляет их в передаваемую вызывающим
кодом структуру TIDBitmap (то есть, получает логическое объединение множества TID выбранных
кортежей с множеством, уже записанным в битовой карте). Возвращает эта функция число полу-
ченных кортежей (это может быть только приблизительная оценка; например, некоторые методы
доступа не учитывают повторяющиеся значения). Добавляя идентификаторы кортежей в битовую
карту, amgetbitmap может обозначить, что для этих кортежей нужно перепроверить условия ска-
нирования. Для этого так же, как и в amgettuple, устанавливается выходной параметр xs_recheck.
Замечание: в текущей реализации эта возможность увязывается с возможностью неточного хра-
нения самих битовых карт, таким образом вызывающий код перепроверяет для отмеченных корте-
жей и условия сканирования, и предикат частичного индекса (если он имеется). Однако так может
быть не всегда. Функции amgetbitmap и amgettuple не могут использоваться в одном сканировании
индекса; есть и другие ограничения в применении amgetbitmap, описанные в Разделе 61.3.
2125Определение интерфейса
для методов доступа индекса
Функция amgetbitmap должна быть реализована, только если метод доступа поддерживает ска-
нирование индекса «по битовой карте». В противном случае поле amgetbitmap в структуре
IndexAmRoutine должно содержать NULL.
void
amendscan (IndexScanDesc scan);
Завершает сканирование и освобождает ресурсы. Саму структуру scan освобождать не следует,
но любые блокировки или закрепления объектов, установленные внутри метода доступа, должны
быть сняты.
void
ammarkpos (IndexScanDesc scan);
Помечает текущую позицию сканирования. Метод доступа должен поддерживать сохранение толь-
ко одной позиции в процессе сканирования.
Функция ammarkpos должна быть реализована, только если метод доступа поддерживает сканиро-
вание по порядку. Если это не так, в поле ammarkpos в структуре IndexAmRoutine можно записать
NULL.
void
amrestrpos (IndexScanDesc scan);
Восстанавливает позицию сканирования, отмеченную последней.
Функция amrestrpos должна быть реализована, только если метод доступа поддерживает скани-
рование по порядку. Если это не так, в поле amrestrpos в структуре IndexAmRoutine можно запи-
сать NULL.
Помимо обычного сканирования некоторые типы индексов могут поддерживать параллельное ска-
нирование индекса, что позволяет осуществлять совместное сканирование индекса нескольким
обслуживающим процессам. Для этого метод доступа должен организовать работу так, чтобы каж-
дый из взаимодействующих процессов возвращал подмножество кортежей, которое бы возвраща-
лось при обычном, не параллельном сканировании, и таким образом, чтобы объединение этих под-
множеств совпадало с множеством кортежей, возвращаемых при обычном сканировании. Более
того, чтобы не требовалась глобальная сортировка кортежей, возвращаемых при параллельном
сканировании, порядок кортежей в подмножествах, выдаваемых всеми взаимодействующими про-
цессами, должен соответствовать запрошенному. Для поддержки параллельного сканирования по
индексу должны быть реализованы следующие функции:
Size
amestimateparallelscan (void);
Рассчитывает и возвращает объём (в байтах) в динамической разделяемой памяти, который может
потребоваться для осуществления параллельного сканирования. (Этот объём дополняет, а не заме-
няет объём памяти, затребованный для данных, независимо от МД, в ParallelIndexScanDescData.)
Эту функцию можно не реализовывать для методов доступа, которые не поддерживают параллель-
ное сканирование, или для которых объём дополнительно требующейся памяти равен нулю.
void
aminitparallelscan (void *target);
Эта функция будет вызываться для инициализации области динамической разделяемой памяти
в начале параллельного сканирования. Параметр target будет указывать на область объёма, не
меньшего, чем возвратила функция amestimateparallelscan, и данная функция может хранить в
этой области любые нужные ей данные.
Эту функцию можно не реализовывать для методов доступа, которые не поддерживают параллель-
ное сканирование, или когда выделенная область в разделяемой памяти не требует инициализа-
ции.
2126Определение интерфейса
для методов доступа индекса
void
amparallelrescan (IndexScanDesc scan);
Эта функция, если её реализовать, будет вызываться перед перезапуском параллельного ска-
нирования индекса. Она должна сбросить всё разделяемое состояние, установленное функцией
aminitparallelscan, с тем, чтобы такое сканирование перезапустилось с начала.
61.3. Сканирование индекса
В процессе сканирования метод доступа индекса отвечает только за выдачу идентификаторов всех
кортежей, которые по его представлению соответствуют ключам сканирования. Метод доступа
не участвует в самой процедуре выборки этих кортежей из основной таблицы и не определяет,
удовлетворяют ли эти кортежи условиям видимости или другим ограничениям.
Ключом сканирования является внутреннее представление предложения WHERE в виде ключ_ин-
декса оператор константа, где ключ индекса — один из столбцов индекса, а оператор — один из
членов семейства операторов, связанного с типом данного столбца. При сканировании по индексу
могут задаваться несколько или ноль ключей сканирования, результаты поиска которых должны
неявно объединяться операцией AND — ожидается, что возвращаемые кортежи будут удовлетво-
рять всем заданным условиям.
Метод доступа для конкретного запроса может сообщить, что индекс является неточным или,
другими словами, требует перепроверки. Это подразумевает, что при сканировании индекса будут
возвращены все записи, соответствующие ключу сканирования, плюс, возможно, дополнительные
записи, которые ему не соответствуют. Внутренний механизм сканирования затем повторно при-
менит условия индекса к кортежу данных, чтобы проверить, нужно ли его выбирать на самом де-
ле. Если признак перепроверки не установлен, при сканировании индекса должны возвращаться
только соответствующие ключам записи.
Заметьте, что именно метод доступа должен гарантировать, что корректно будут найдены все и
только те записи, которые соответствуют всем переданным ключам сканирования. Также учтите,
что ядро системы просто передаёт все предложения WHERE с подходящими ключами индекса и се-
мействами операторов, не проводя семантический анализ на предмет их избыточности или про-
тиворечивости. Например, с условием WHERE x &gt; 4 AND x &gt; 14, где x — столбец с индексом-B-де-
ревом, именно самой функции amrescan в методе B-дерева предоставляется возможность понять,
что первый ключ сканирования избыточный и может быть отброшен. Объём предварительной об-
работки, которую нужно произвести для этого в amrescan, зависит от того, до какой степени метод
доступа должен сводить ключи к «нормализованной» форме.
Некоторые методы доступа возвращают записи индекса в чётко определённом порядке, в отличие
от других. Фактически есть два различных варианта реализации упорядоченного вывода некото-
рым методом доступа:
• Для методов доступа, которые всегда возвращают записи в порядке их естественной сортиров-
ки (как например, в B-дереве), устанавливается признак amcanorder. В настоящее время опе-
раторам проверки равенства и упорядочивания при этом должны назначаться номера соот-
ветствующих стратегий B-дерева.
• Для методов доступа, которые поддерживают операторы упорядочивания, устанавливается
признак amcanorderbyop. Он показывает, что индекс может возвращать записи в порядке,
определяемом предложением ORDER BY ключ_индекса оператор константа. Модификаторы для
такого сканирования могут передаваться в amrescan, как описывалось ранее.
У функции amgettuple есть аргумент direction, который может принимать значение
ForwardScanDirection (обычный вариант, сканирование вперёд) или BackwardScanDirection (ска-
нирование назад). Если в первом вызове после amrescan указывается BackwardScanDirection, то
множество соответствующих записей индекса сканируется от конца к началу, а не в обычном на-
правлении от начала к концу. В этом случае amgettuple должна вернуть последний соответствую-
щий кортеж индекса, а не первый как обычно. (Это распространяется только на методы доступа
с установленным признаком amcanorder.) После первого вызова amgettuple должна быть готова
продолжать сканирование в любом направлении от записи, выданной последней до этого. (Но если
2127Определение интерфейса
для методов доступа индекса
признак amcanbackward не установлен, при всех последующих вызовах должно сохраняться то же
направление, что было в первом.)
Методы доступа, которые поддерживают упорядоченное сканирование, должны уметь «помечать»
позицию сканирования и затем возвращаться к помеченной позиции (возможно, несколько раз
к одной и той же позиции). Но запоминаться должна только одна позиция в ходе сканирова-
ния; последующий вызов ammarkpos переопределяет ранее сохранённую позицию. Метод доступа,
не поддерживающий упорядоченное сканирование, не должен определять функции ammarkpos и
amrestrpos в IndexAmRoutine; достаточно записать в эти указатели NULL.
И позиция сканирования, и отмеченная позиция (при наличии) должны поддерживаться в согла-
сованном состоянии с учётом одновременных добавлений или удалений записей в индексе. Не
будет ошибкой, если только что вставленная запись не будет выдана при сканировании, которое
могло бы найти эту запись, если бы она существовала до его начала, либо если сканирование вы-
даст такую запись после перезапуска или возврата, даже если она не была выдана в первый раз.
Подобным образом, параллельное удаление может отражаться, а может и не отражаться в резуль-
татах сканирования. Важно только, чтобы при таких операциях добавления или удаления не про-
исходило потерь или дублирования записей, которые в этих операциях не участвовали.
Если индекс сохраняет исходные индексируемые значения данных (а не их искажённое представ-
ление), обычно полезно поддержать сканирование только индекса, при котором индекс возвраща-
ет фактические данные, а не только TID кортежа данных. Это позволит соптимизировать ввод/вы-
вод, только если карта видимости показывает, что TID относится к полностью видимой странице; в
противном случае всё равно придётся посетить кортеж, чтобы проверить его видимость для MVCC.
Но это не является заботой метода доступа.
Вместо amgettuple, сканирование индекса может осуществляться функцией amgetbitmap, кото-
рая выбирает все кортежи за один вызов. Это может быть значительно эффективнее amgettuple,
так как позволяет избежать циклов блокировки/разблокировки в методе доступа. В принципе,
amgetbitmap должна давать тот же эффект, что и многократные вызовы amgettuple, но простоты
ради мы накладываем ряд дополнительных ограничений. Во-первых, amgetbitmap возвращает все
кортежи сразу и не поддерживает пометку позиций и возвращение к ним. Во-вторых, кортежи,
возвращаемые в битовой карте, не упорядочиваются каким-либо определённым образом, поэтому
amgetbitmap не принимает аргумент direction. (И операторы упорядочивания никогда не будут
передаваться для такого сканирования.) Кроме того, сканирование только индекса с amgetbitmap
неосуществимо, так как нет никакой возможности возвратить содержимое кортежей индекса. На-
конец, amgetbitmap не гарантирует, что будут установлены какие-либо блокировки для возвраща-
емых кортежей, и следствия этого описаны в Разделе 61.4.
Заметьте, что метод доступа может реализовывать только функцию amgetbitmap, но не amgettuple,
и наоборот, если его внутренняя реализация несовместима с одной из этих функций.
61.4. Замечания о блокировке с индексами
Методы доступа индекса должны справляться с параллельными операциями обновления индек-
са, производимыми несколькими процессами. Ядро системы PostgreSQL получает блокировку
AccessShareLock для индекса в процессе сканирования и RowExclusiveLock при модификации ин-
декса (включая и обычную очистку командой VACUUM). Так как эти типы блокировок не конфлик-
туют, метод доступа должен сам устанавливать более тонкие блокировки, которые ему могут по-
требоваться. Исключительная блокировка индекса в целом устанавливается только при создании
и уничтожении индекса или операции REINDEX.
Реализация типа индекса, поддерживающего параллельные изменения, обычно требует глубокого
и всестороннего анализа требуемого поведения. Для общего представления вы можете узнать о
конструктивных решениях, принятых при реализации B-дерева и индекса по хешу, обратившись к
src/backend/access/nbtree/README и src/backend/access/hash/README.
Помимо собственных внутренних требований индексов к целостности, при параллельном обновле-
нии данных возникают вопросы согласованности родительской таблицы (основных данных) и ин-
2128Определение интерфейса
для методов доступа индекса
декса. Вследствие того, что PostgreSQL отделяет чтение и изменение основных данных от чтения
и изменения индекса, образуются временные интервалы, в которых индекс может быть несогла-
сованным с данными. Мы решаем эту проблему, применяя следующие правила:
• Новая запись в области данных добавляется до того, как для неё будут созданы записи в ин-
дексах. (Таким образом, при параллельном сканировании индекса эта запись в данных ско-
рее всего не будет замечена. Это не проблема, так как читателю индекса всё равно не нужны
незафиксированные строки. Но учтите написанное в Разделе 61.5.)
• Когда запись данных удаляется (командой VACUUM), сначала должны удалиться все созданные
для неё записи в индексах.
• Сканирование индекса должно закрепить страницу индекса, на которой находится элемент,
возвращённый последним вызовом amgettuple, а ambulkdelete не должна удалять записи со
страниц, закреплённых другими процессами. Чем обосновано это правило, описывается ниже.
Без третьего правила читатель индекса мог бы увидеть запись индекса за мгновение до того, как
она была удалена процедурой VACUUM, а затем обратиться к соответствующей записи данных после
того, как VACUUM удалит и её. Это не приведёт к серьёзным проблемам, если данный элемент оста-
ётся незадействованным, когда к нему обращается читатель, так как пустой слот будет игнориро-
ваться функцией heap_fetch(). Но как быть, если третий процесс уже занял этот слот какими-то
своими данными? Когда применяется снимок, совместимый с MVCC, и это не проблема, так как эти
данные определённо окажутся слишком новыми при проверке видимости для данного снимка. Од-
нако, для снимка несовместимого с MVCC (например, снимка SnapshotAny), может так получить-
ся, что будет возвращена строка, на самом деле не соответствующая ключам сканирования. Мы
можем защититься от такого исхода, потребовав, чтобы ключи сканирования всегда перепроверя-
лись для строки данных, но это слишком дорогостоящее решение. Вместо этого, мы закрепляем
страницу индекса как промежуточный объект, показывающий, что читатель может всё ещё быть
«в пути» от записи индекса к соответствующей строке данных. Благодаря тому, что ambulkdelete
блокируется при обращении к этой закреплённой странице, процедура VACUUM не сможет удалить
строку данных, пока её извлечение не закончит читатель. Это решение оказывается очень недо-
рогим по времени выполнения, а издержки блокирования привносятся только в редких случаях,
когда действительно возникает конфликт.
Такое решение требует, чтобы сканирования индексов выполнялись «синхронно»: мы должны вы-
бирать каждый следующий кортеж данных сразу после того получили соответствущую запись ин-
декса. Это оказывается невыгодно по ряду причин. «Асинхронное» сканирование, при котором мы
собираем множество TID из индекса, и обращаемся за кортежами данных только после этого, вле-
чёт гораздо меньше издержек с блокировками и позволяет обращаться к данным более эффектив-
ным образом. Согласно проведённому выше анализу, мы должны использовать синхронный под-
ход для снимков, несовместимых с MVCC, но для запросов со снимками MVCC будет работать и
асинхронное сканирование.
При сканировании индекса с amgetbitmap, метод доступа не закрепляет страницы индекса ни для
каких из возвращаемых кортежей. Поэтому такое сканирование можно безопасно применять толь-
ко со снимками MVCC.
Когда флаг ampredlocks не установлен, любое сканирование с данным методом доступа в сериали-
зуемой транзакции будет получать неблокирующую предикатную блокировку для всего индекса.
Это будет приводить к конфликту чтения-записи при добавлении любого кортежа в этот индекс па-
раллельной сериализуемой транзакцией. Если среди набора параллельных сериализуемых тран-
закций выявляются определённые варианты конфликтов чтения-записи, одна из этих транзакций
может быть отменена для сохранения целостности данных. Когда данный флаг установлен, это
означает, что метод доступа реализует более точную предикатную блокировку, что способствует
сокращению частоты отмены транзакций по этой причине.
61.5. Проверки уникальности в индексе
PostgreSQL реализует ограничения уникальности SQL, применяя уникальные индексы, то есть та-
кие индексы, которые не принимают несколько записей с одинаковыми ключами. Для метода до-
2129Определение интерфейса
для методов доступа индекса
ступа, поддерживающего это свойство, устанавливается признак amcanunique. (В настоящее время
это поддерживают только В-деревья.) Столбцы, указанные в предложении INCLUDE, не учитывают-
ся при контроле уникальности.
Вследствие особенностей MVCC, всегда необходимо допускать физическое сосуществование в ин-
дексе дублирующихся записей: такие записи могут относиться к последовательным версиям одной
логической строки. На самом деле мы хотим добиться только того, чтобы никакой снимок MVCC
не мог содержать две строки с одинаковыми ключами индекса. Из этого вытекают следующие си-
туации, которые необходимо отследить, добавляя новую строку в уникальный индекс:
• Если конфликтующая строка была удалена текущей транзакцией, это не проблема. (В частно-
сти из-за того, что UPDATE всегда удаляет старую версию строки, прежде чем вставлять но-
вую, операцию UPDATE можно выполнять со строкой, не меняя её ключ.)
• Если конфликтующая строка была добавлена ещё не зафиксированной транзакцией, запрос,
претендующий на добавление новой строки, должен подождать, пока эта транзакция не будет
зафиксирована. Если она откатывается, конфликт исчезает. Если она фиксируется и при этом
оставляет конфликтующую строку, возникает нарушение уникальности. (На практике мы про-
сто ждём завершения другой транзакции и затем пересматриваем проверку видимости.)
• Подобным образом, если конфликтующая строка была удалена ещё не зафиксированной тран-
закцией, запрос, претендующий на добавление новой строки, должен дождаться фиксации
или отката этой транзакции, а затем повторить проверку.
Более того, непосредственно перед тем как сообщать о нарушении уникальности согласно выше-
приведённым правилам, метод доступа должен перепроверить, продолжает ли существовать до-
бавляемая строка. Если она признана «мёртвой», о предвиденном нарушении он сообщать не дол-
жен. (Такого не должно быть при обычном сценарии добавления строки текущей транзакцией, од-
нако это может произойти в процессе CREATE UNIQUE INDEX CONCURRENTLY.)
Мы требуем, чтобы метод доступа выполнял эти проверки сам, и это означает, что он должен об-
ратиться к основным данным и проверить состояние фиксации всех строк, которые согласно со-
держимого индекса содержат дублирующиеся ключи. Это без сомнения некрасивый и немодуль-
ный подход, но он избавляет от излишней работы: если бы мы делали отдельную пробу, то поиск
конфликтующей строки по индексу пришлось бы по сути повторять, пытаясь найти место, куда
вставить запись для новой строки. Более того, не представляется возможным избежать условий
гонки, если проверка конфликта не будет неотъемлемой частью процедуры добавления новой за-
писи индекса.
Если ограничение уникальности откладываемое, возникает дополнительная сложность: нам нуж-
на возможность добавлять запись индекса для новой строки, но отложить выводы о нарушении
уникальности до конца оператора или даже позже. Чтобы избежать ненужного повторного поиска
по индексу, метод доступа должен произвести предварительную проверку уникальности во время
изначального добавления строк. Если при этом окажется, что никакие кортежи не конфликтуют,
на этом проверка заканчивается. В противном случае мы планируем перепроверку на время, когда
это ограничение начинает действовать. Если во время перепроверки продолжают существовать
и вставленный кортеж, и какой-либо другой с тем же ключом, должна выдаваться ошибка. (За-
метьте, что в данном случае под «существованием» понимается «существование любого кортежа
в цепочке HOT записей индекса».) Для реализации этой схемы в aminsert передаётся параметр
checkUnique, принимающий одно из следующих значений:
• UNIQUE_CHECK_NO указывает, что проверка уникальности не должна выполняться (это не уни-
кальный индекс).
• UNIQUE_CHECK_YES указывает, что это неоткладываемый уникальный индекс и проверку уни-
кальности нужно выполнить немедленно, как описано выше.
• UNIQUE_CHECK_PARTIAL указывает, что это откладываемое ограничение уникальности.
PostgreSQL выбирает этот режим для добавления записи индекса для каждой строки. Метод
доступа должен допускать добавление в индекс дублирующихся записей и сообщать о воз-
можных конфликтах, возвращая false из aminsert. Для каждой такой строки (для которой воз-
вращается false) будет запланирована отложенная перепроверка.
2130Определение интерфейса
для методов доступа индекса
Метод доступа должен отметить все строки, которые могут нарушать ограничение уникально-
сти, но не будет ошибкой, если он допустит ложное срабатывание. Это позволяет произвести
проверку, не дожидаясь завершения других транзакций; конфликты, выявленные на этой ста-
дии, не считаются ошибками и будут перепроверены позже, когда они могут быть уже исчер-
паны.
• UNIQUE_CHECK_EXISTING указывает, что это отложенная перепроверка строки, которая бы-
ла отмечена как возможно нарушающая ограничение. Хотя для этой проверки вызывается
aminsert, метод доступа не должен добавлять новую запись индекса в данном случае, так как
эта запись уже существует. Вместо этого, метод доступа должен проверить, нет ли в индексе
другой такой же записи. Если она находится и соответствующая ей строка продолжает суще-
ствовать, должна выдаваться ошибка.
Для варианта UNIQUE_CHECK_EXISTING в методе доступа рекомендуется дополнительно прове-
рить, что для целевой строки действительно имеется запись в индексе и сообщить об ошиб-
ке, если это не так. Это хорошая идея, так как значения кортежа индекса, передаваемые в
aminsert, будут рассчитаны заново. Если в определении индекса задействованы функции, ко-
торые на самом деле не постоянные, мы можем проверять неправильную область индекса. До-
полнительно убедившись в существовании целевой строки при перепроверке, мы можем быть
уверены, что сканируются те же значения кортежа, что передавались при изначальном добав-
лении строки.
61.6. Функции оценки стоимости индекса
Функции amcostestimate даётся информация, описывающая возможное сканирование индекса,
включая списки предложений WHERE и ORDER BY, которые были выбраны как применимые с
данным индексом. Она должна вернуть оценки стоимости обращения к индексу и избиратель-
ность предложений WHERE (то есть, процент строк основной таблицы, который будет получен в
ходе сканирования индекса). Для простых случаев почти всю работу оценщика стоимости мож-
но произвести, вызывая стандартные процедуры оптимизатора; смысл существования функции
amcostestimate в том, чтобы методы доступа индексов могли поделиться знаниями, специфичны-
ми для типа индекса, когда это может помочь улучшить стандартные оценки.
Каждая функция amcostestimate должна иметь такую сигнатуру:
void
amcostestimate (PlannerInfo *root,
IndexPath *path,
double loop_count,
Cost *indexStartupCost,
Cost *indexTotalCost,
Selectivity *indexSelectivity,
double *indexCorrelation,
double *indexPages);
Первые три параметра передают входные значения:
root
Информация планировщика о выполняемом запросе.
path
Рассматриваемый путь доступа к индексу. В нём действительны все поля, кроме значений сто-
имости и избирательности.
loop_count
Число повторений сканирования индекса, которое должно приниматься во внимание при оцен-
ке стоимости. Обычно оно будет больше одного, когда при соединении со вложенным циклом
планируется параметризованное сканирование. Заметьте, что оценки стоимости, тем не менее,
2131Определение интерфейса
для методов доступа индекса
должны рассчитываться для всего одного сканирования; большие значения loop_count лишь
дают основания предположить, что при многократном сканировании положительное влияние
может оказать кеширование.
Последние пять параметров — указатели на переменные для выходных значений:
*indexStartupCost
Стоимость выполнения запуска индекса
*indexTotalCost
Общая стоимость использования индекса
*indexSelectivity
Избирательность индекса
*indexCorrelation
Коэффициент корреляции между порядком сканирования индекса и порядком записей в ниже-
лежащей таблице
*indexPages
Количество страниц индекса на уровне листьев
Заметьте, что функции оценки стоимости должны разрабатываться на C, а не на SQL или другом
доступном процедурном языке, так как они должны обращаться к внутренним структурам данным
планировщика/оптимизатора.
Стоимости обращения к индексу следует вычислять с использованием параметров, объявленных в
src/backend/optimizer/path/costsize.c: последовательная выборка дискового блока имеет сто-
имость seq_page_cost, непоследовательная выборка — random_page_cost, а стоимостью обработки
одной строки индекса обычно принимается cpu_index_tuple_cost. Кроме того, за каждый опера-
тор сравнения, вызываемый при обработке индекса, должна взиматься цена cpu_operator_cost
(особенно за вычисление собственно условий индекса).
Стоимость доступа должна включать стоимости всех дисковых и процессорных ресурсов, требую-
щихся для сканирования самого индекса, но не стоимости извлечения или обработки строк основ-
ной таблицы, с которой связан индекс.
«Стоимость запуска» составляет часть общей стоимости сканирования, которая должна быть по-
трачена, прежде чем можно будет начать чтение первой строки. Для большинства индексов она
может считаться нулевой, но для типов индексов с высокими затратами на запуск она может быть
больше нуля.
Значение в indexSelectivity должно показывать, какой процент строк основной таблицы ожида-
ется получить при сканировании таблицы. В случае неточного запроса это обычно будет больше
процента строк, действительно удовлетворяющих заданным ограничивающим условиям.
В indexCorrelation записывается корреляция (в диапазоне от -1.0 до 1.0) между порядком записей
в индексе и в таблице. Это значение будет корректировать оценку стоимости выборки строк из
основной таблицы.
В indexPages записывается число страниц на уровне листьев. Это помогает выбрать число испол-
нителей для параллельного сканирования индекса.
Когда loop_count больше нуля, возвращаться должны средние значения, ожидаемые для одного
сканирования индекса.
Оценка стоимости
Типичная процедура оценки выглядит следующим образом:
2132Определение интерфейса
для методов доступа индекса
1.
Рассчитать и вернуть процент строк родительской таблицы, которые будут посещены при за-
данных ограничивающих условиях. В отсутствие каких-либо знаний, специфичных для типа
индекса, использовать стандартную функцию оптимизатора clauselist_selectivity():
*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
path-&gt;indexinfo-&gt;rel-&gt;relid,
JOIN_INNER, NULL);</p>
        </blockquote>
      </li>
      <li>Оценить число строк индекса, которые будут посещены при сканировании. Для многих типов
индексов это будет произведение indexSelectivity и числа строк в индексе, но оно может быть
и больше. (Заметьте, что размер индекса в страницах и строках можно узнать из структуры
path-&gt;indexinfo.)</li>
      <li>Рассчитать число страниц индекса, которые будут получены при сканировании. Это может
быть просто произведение indexSelectivity и размера индекса в страницах.</li>
      <li>Вычислить стоимость обращения к индексу. Универсальный оценщик может сделать следую-
щее:
/*</li>
    </ol>
  </li>
  <li>Вообще предполагается, что страницы индекса будут считываться последовательно,</li>
  <li>так что стоимость их чтения cost seq_page_cost, а не random_page_cost.</li>
  <li>Также мы добавляем стоимость за вычисление условия индекса для каждой строки.</li>
  <li>Все стоимости считаются пропорционально возрастающими при сканировании.
*/
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
(cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
Однако при таком расчёте не учитывается амортизация чтения индекса при повторном скани-
ровании.
5.
Оценить корреляцию индекса. Для простого упорядоченного индекса по одному полю её мож-
но получить из pg_statistic. Если корреляция неизвестна, вернуть консервативную оценку —
ноль (корреляция отсутствует).
Примеры функций оценки стоимости можно найти в src/backend/utils/adt/selfuncs.c.
2133</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-060/" title="Глава 60. Генетический оптимизатор запросов"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 60. Генетический оптимизатор запросов"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-060/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~5 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-060/" rel="bookmark" title="Глава 60. Генетический оптимизатор запросов" itemprop="url">Глава 60. Генетический оптимизатор запросов</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 60. Генетический оптимизатор запросов</p>

<p>Автор
Разработал Мартин Утеш (<a href="mailto:utesch@aut.tu-freiberg.de">utesch@aut.tu-freiberg.de</a>) для Института автоматиче-
ского управления в Техническом университете Фрайбергская горная академия, Герма-
ния.
60.1. Обработка запроса как сложная задача оптими-
зации
Среди всех реляционных операторов самым сложным для обработки и оптимизации является со-
единение. В первую очередь потому, что по мере увеличения числа соединений в запросе число
возможных планов запроса увеличивается экспоненциально. Дополнительная сложность оптими-
зации связана с наличием различных методов соединения (например, в PostgreSQL это вложен-
ный цикл, соединение по хешу и соединение слиянием) для каждого отдельного соединения и раз-
нообразием индексов (например, в PostgreSQL это B-дерево, хеш, GiST и GIN), определяющих путь
доступа к отношениям.
Традиционный оптимизатор запросов PostgreSQL выполняет почти исчерпывающий поиск во всём
множестве возможных стратегий. Этот алгоритм, появившийся в СУБД IBM System R, находит
порядок соединений, близкий к оптимальному, но может требовать огромного количества време-
ни и памяти, когда число соединений оказывается большим. В результате обычный оптимизатор
PostgreSQL оказывается неподходящим для запросов, в которых соединяется большое количество
таблиц.
Институт автоматического управления в Техническом университете Фрайбергская горная акаде-
мия, Германия, столкнулся с этими проблемами, разрабатывая систему принятия решений на ос-
нове базы знаний для обслуживания электростанций, в которой в качестве СУБД планировалось
применять PostgreSQL. Для машины, делающей выводы на основе базы знаний, СУБД должна была
выполнять запросы с таким количеством соединений, что использование обычного оптимизатора
запросов оказалось неприемлемым.
Далее мы опишем реализацию генетического алгоритма, который решает проблему выбора по-
рядка соединений эффективным способом для запросов с большим числом соединений.
60.2. Генетические алгоритмы
Генетический алгоритм (ГА) реализует метод эвристической оптимизации, построенный на слу-
чайном поиске. В данном контексте множество возможных решений проблемы оптимизации на-
зывается популяцией особей. Степень адаптации особи к среде определяет функция приспособ-
ленности.
Координаты особи в пространстве поиска представляются хромосомами, которые по сути являют-
ся символьными строками. Фрагмент хромосомы, кодирующий значение одного оптимизируемого
параметра, называется геном. Обычно ген кодируется в виде двоичного или целочисленного зна-
чения.
В результате симуляции эволюционных операций (скрещивания, мутации и селекции) данный ал-
горитм формирует новые поколения особей, у которых приспособленность в среднем будет выше,
чем у их предшественников.
Как сказано в ответах на вопросы в группе comp.ai.genetic, нельзя не отметить, что ГА реализует
не чисто случайный поиск решения проблемы. В ГА происходят вероятностные процессы, но ре-
зультат явно оказывается не случайным (лучше случайного).
2115Генетический опти-
мизатор запросов
Рисунок 60.1. Диаграмма структуры генетического алгоритма
P(t) поколение предков на момент t
P’‘(t) поколение потомков на момент t
+=========================================+
|»»»»»&gt; Алгоритм ГА «««««««|
+=========================================+
| ИНИЦИАЛИЗАЦИЯ t := 0
|
+=========================================+
| ИНИЦИАЛИЗАЦИЯ P(t)
|
+=========================================+
| вычислить ПРИСПОСОБЛЕННОСТЬ P(t)
|
+=========================================+
| пока не выполняется УСЛОВИЕ ОСТАНОВКИ
|
|
+————————————-+
|
| P’(t) := СКРЕЩИВАНИЕ{P(t)}
|
|
+————————————-+
|
| P’‘(t) := МУТАЦИЯ{P’(t)}
|
|
+————————————-+
|
| P(t+1) := СЕЛЕКЦИЯ{P’‘(t) + P(t)}
|
|
+————————————-+
|
| вычислить ПРИСПОСОБЛЕННОСТЬ P’‘(t) |
|
+————————————-+
|
| t := t + 1
|
+===+=====================================+
60.3. Генетическая оптимизация запросов (GEQO) в
PostgreSQL
Модуль GEQO (Genetic Query Optimization, Генетическая оптимизация запросов) подходит к
проблеме оптимизации запроса как к хорошо известной задаче коммивояжёра (TSP, Traveling
Salesman Problem). Возможные планы запроса кодируются числами в строковом виде. Каждая
строка представляет порядок соединения одного отношения из запроса со следующим. Например,
дерево соединения
/\
/\ 2
/\ 3
4 1
кодируется строкой целых чисел ‘4-1-3-2’, которая означает: сначала соединить отношения ‘4’ и
‘1’, потом добавить ‘3’, а затем ‘2’, где 1, 2, 3, 4 — идентификаторы отношений внутри оптимизатора
PostgreSQL.
Реализация GEQO в PostgreSQL имеет следующие особые характеристики:
• Использование ГА с зафиксированным состоянием (когда заменяются наименее приспособ-
ленные особи популяции, а не всё поколение) способствует быстрой сходимости к улучшен-
ным планам запроса. Это важно для обработки запроса за приемлемое время;
• Использование скрещивания с обменом рёбер, которое очень удачно минимизирует число по-
терянных рёбер при решении задачи коммивояжёра с применением ГА;
• Мутация как генетический оператор считается устаревшей, так что для получения допусти-
мых путей TSP не требуются механизмы исправления.
Части модуля GEQO взяты из алгоритма Genitor, разработанного Д. Уитли.
В результате, модуль GEQO позволяет оптимизатору запросов PostgreSQL эффективно выполнять
запросы со множеством соединений, обходясь без полного перебора вариантов.
2116Генетический опти-
мизатор запросов
60.3.1. Построение возможных планов с GEQO
В процедуре планирования в GEQO используется код стандартного планировщика, который строит
планы сканирования отдельных отношений. Затем вырабатываются планы соединений с примене-
нием генетического подхода. Как было сказано выше, каждый план соединения представляется по-
следовательностью чисел, определяющей порядок соединений базовых отношений. На начальной
стадии код GEQO просто случайным образом генерирует несколько возможных последовательно-
стей. Затем для каждой рассматриваемой последовательности вызывается функция стандартного
планировщика, оценивающая стоимость запроса в случае выбора этого порядка соединений. (Для
каждого шага последовательности рассматриваются все три возможные стратегии соединения и
все изначально выбранные планы сканирования отношений. Результирующей оценкой стоимости
будет минимальная из всех возможных.) Последовательности соединений с наименьшей оценкой
стоимости считаются «более приспособленными», чем последовательности с большей оценкой.
Проанализировав возможные последовательности, генетический алгоритм отбрасывает наименее
приспособленные из них. Затем генерируются новые кандидаты путём объединения генов более
приспособленных последовательностей — для этого выбираются случайные фрагменты известных
последовательностей с низкой стоимостью, из которых складываются новые последовательности
для рассмотрения. Этот процесс повторяется, пока не будет рассмотрено некоторое предопреде-
лённое количество последовательностей соединений; после этого для построения окончательного
плана выбирается лучшая последовательность, найденная за всё время поиска.
Этот процесс по природе своей недетерминирован, вследствие случайного выбора при форми-
ровании начальной популяции и последующей «мутации» лучших кандидатов. Но во избежание
неожиданных изменений выбранного плана, на каждом проходе алгоритм GEQO перезапускает
свой генератор случайных чисел с текущим значением параметра geqo_seed. Поэтому пока зна-
чение geqo_seed и другие параметры GEQO остаются неизменными, для определённого запроса
(и других входных данных планировщика, в частности, статистики) будет строиться один и тот же
план. Если вы хотите поэкспериментировать с разными путями соединений, попробуйте изменить
geqo_seed.
60.3.2. Будущее развитие модуля PostgreSQL GEQO
Требуется провести дополнительную работу для выбора оптимальных параметров генетического
алгоритма. В файле src/backend/optimizer/geqo/geqo_main.c, подпрограммах gimme_pool_size
и gimme_number_generations, мы должны найти компромиссные значения параметров, удовлетво-
ряющие двум несовместимым требованиям:
• Оптимальность плана запроса
• Время вычисления
В текущей реализации приспособленность каждой рассматриваемой последовательности соеди-
нений рассчитывается стандартным планировщиком, который каждый раз вычисляет избиратель-
ность соединения и стоимость заново. С учётом того, что различные кандидаты могут содержать
общие подпоследовательности соединений, при этом будет повторяться большой объём работы.
Таким образом, расчёт можно значительно ускорить, сохраняя оценки стоимости для внутренних
соединений, но сложность состоит в том, чтобы уместить это состояние в разумные объёмы памяти.
На более общем уровне не вполне понятно, насколько уместно для оптимизации запросов исполь-
зовать ГА, предназначенный для решения задачи коммивояжёра. В этой задаче стоимость, свя-
занная с любой подстрокой (частью тура) не зависит от остального маршрута, но это определённо
не так для оптимизации запросов. Таким образом, возникает вопрос, насколько эффективно скре-
щивание путём обмена рёбрами.
60.4. Дополнительные источники информации
Дополнительную информацию о генетических алгоритмах можно получить в следующих источни-
ках:
• The Hitch-Hiker’s Guide to Evolutionary Computation, (Руководство для путешествующих авто-
стопом по эволюционным вычислениям, Ответы на часто задаваемые вопросы в группе news://
comp.ai.genetic)
2117Генетический опти-
мизатор запросов
• Evolutionary Computation and its application to art and design (Эволюционные вычисления и их
применение в искусстве и дизайне), Крейг Рейнольдс
• elma04
• fong
2118</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page5/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page4/">4</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page5/">5</a></li>
      
    
      
        <li><strong class="current-page">6</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page7/">7</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page8/">8</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page35/">35</a></li>
    

    
    
      <li><a href="http://localhost:4000/page7/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>