<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 24. Регламентные задачи обслуживания базы данных &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 24. Регламентные задачи обслуживания базы данных">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 24. Регламентные задачи обслуживания базы данных">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-024/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-024/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 24. Регламентные задачи обслуживания базы данных">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-024/" rel="bookmark" title="Глава 24. Регламентные задачи обслуживания базы данных">Глава 24. Регламентные задачи обслуживания базы данных</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~25 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 24. Регламентные задачи обслуживания базы данных</p>

<p>Как и в любой СУБД, в PostgreSQL для достижения оптимальной производительности нужно ре-
гулярно выполнять определённые процедуры. Задачи, которые рассматриваются в этой главе, яв-
ляются обязательными, но они по природе своей повторяющиеся и легко поддаются автоматиза-
ции с использованием стандартных средств, таких как задания cron или Планировщика задач в
Windows. Создание соответствующих заданий и контроль над их успешным выполнением входят в
обязанности администратора базы данных.
Одной из очевидных задач обслуживания СУБД является регулярное создание резервных копий
данных. При отсутствии свежей резервной копии у вас не будет шанса восстановить систему после
катастрофы (сбой диска, пожар, удаление важной таблицы по ошибке и т. д.). Механизмы резерв-
ного копирования и восстановления в PostgreSQL детально рассматриваются в Главе 25.
Другое важное направление обслуживания СУБД — периодическая «очистка» базы данных. Эта
операция рассматривается в Разделе 24.1. С ней тесно связано обновление статистики, которая
будет использоваться планировщиком запросов; оно рассматривается в Подразделе 24.1.3.
Ещё одной задачей, требующей периодического выполнения, является управление файлами жур-
нала. Она рассматривается в Разделе 24.3.
Для контроля состояния базы данных и для отслеживания нестандартных ситуаций можно исполь-
зовать check_postgres. Скрипт check_postgres можно интегрировать с Nagios и MRTG, однако он
может работать и самостоятельно.
По сравнению с некоторыми другими СУБД PostgreSQL неприхотлив в обслуживании. Тем не ме-
нее, должное внимание к вышеперечисленным задачам будет значительно способствовать ком-
фортной и производительной работе с СУБД.
24.1. Регламентная очистка
Базы данных PostgreSQL требуют периодического проведения процедуры обслуживания, которая
называется очисткой. Во многих случаях очистку достаточно выполнять с помощью демона ав-
тоочистки, который описан в Подразделе 24.1.6. Возможно, в вашей ситуации для получения оп-
тимальных результатов потребуется настроить описанные там же параметры автоочистки. Неко-
торые администраторы СУБД могут дополнить или заменить действие этого демона командами
VACUUM (обычно они выполняются по расписанию в заданиях cron или Планировщика задач). Чтобы
правильно организовать очистку вручную, необходимо понимать темы, которые будут рассмотре-
ны в следующих подразделах. Администраторы, которые полагаются на автоочистку, возможно,
всё же захотят просмотреть этот материал, чтобы лучше понимать и настраивать эту процедуру.
24.1.1. Основные принципы очистки
Команды VACUUM в PostgreSQL должны обрабатывать каждую таблицу по следующим причинам:</p>
<ol>
  <li>Для высвобождения или повторного использования дискового пространства, занятого изменён-
ными или удалёнными строками.</li>
  <li>Для обновления статистики по данным, используемой планировщиком запросов PostgreSQL.</li>
  <li>Для обновления карты видимости, которая ускоряет сканирование только индекса.</li>
  <li>Для предотвращения потери очень старых данных из-за зацикливания идентификаторов тран-
закций или мультитранзакций.
Разные причины диктуют выполнение действий VACUUM с разной частотой и в разном объёме, как
рассматривается в следующих подразделах.
Существует два варианта VACUUM: обычный VACUUM и VACUUM FULL. Команда VACUUM FULL может вы-
свободить больше дискового пространства, однако работает медленнее. Кроме того, обычная ко-
619Регламентные задачи об-
служивания базы данных
манда VACUUM может выполняться параллельно с использованием производственной базы данных.
(При этом такие команды как SELECT, INSERT, UPDATE и DELETE будут выполняться нормально, хотя
нельзя будет изменить определение таблицы командами типа ALTER TABLE.) Команда VACUUM FULL
требует исключительной блокировки обрабатываемой таблицы и поэтому не может выполняться
параллельно с другими операциями с этой таблицей. По этой причине администраторы, как пра-
вило, должны стараться использовать обычную команду VACUUM и избегать VACUUM FULL.
Команда VACUUM порождает существенный объём трафика ввода/вывода, который может стать при-
чиной низкой производительности в других активных сеансах. Это влияние фоновой очистки мож-
но регулировать, настраивая параметры конфигурации (см. Подраздел 19.4.4).
24.1.2. Высвобождение дискового пространства
В PostgreSQL команды UPDATE или DELETE не вызывают немедленного удаления старой версии из-
меняемых строк. Этот подход необходим для реализации эффективного многоверсионного управ-
ления конкурентным доступом (MVCC, см. Главу 13): версия строки не должна удаляться до тех
пор, пока она остаётся потенциально видимой для других транзакций. Однако в конце концов уста-
ревшая или удалённая версия строки оказывается не нужна ни одной из транзакций. После этого
занимаемое ей место должно быть освобождено и может быть отдано новым строкам, во избежа-
ние неограниченного роста потребности в дисковом пространстве. Это происходит при выполне-
нии команды VACUUM.
Обычная форма VACUUM удаляет неиспользуемые версии строк в таблицах и индексах и помечает
пространство свободным для дальнейшего использования. Однако это дисковое пространство не
возвращается операционной системе, кроме особого случая, когда полностью освобождаются од-
на или несколько страниц в конце таблицы и можно легко получить исключительную блокировку
таблицы. Команда VACUUM FULL, напротив, кардинально сжимает таблицы, записывая абсолютно
новую версию файла таблицы без неиспользуемого пространства. Это минимизирует размер таб-
лицы, однако может занять много времени. Кроме того, для этого требуется больше места на диске
для записи новой копии таблицы до завершения операции.
Обычно цель регулярной очистки — выполнять простую очистку (VACUUM) достаточно часто, чтобы
не возникала необходимость в VACUUM FULL. Демон автоочистки пытается работать в этом режиме,
и на самом деле он сам никогда не выполняет VACUUM FULL. Основная идея такого подхода не в
том, чтобы минимизировать размер таблиц, а в том, чтобы поддерживать использование дискового
пространства на стабильном уровне: каждая таблица занимает объём, равный её минимальному
размеру, плюс объём, который был занят между процедурами очистки. Хотя с помощью VACUUM
FULL можно сжать таблицу до минимума и возвратить дисковое пространство операционной систе-
ме, большого смысла в этом нет, если в будущем таблица так же вырастет снова. Следовательно,
для активно изменяемых таблиц лучше с умеренной частотой выполнять VACUUM, чем очень редко
выполнять VACUUM FULL.
Некоторые администраторы предпочитают планировать очистку БД самостоятельно, например,
проводя все работы ночью в период низкой загрузки. Однако очистка только по фиксированно-
му расписанию плоха тем, что при резком скачке интенсивности изменений таблица может раз-
растить настолько, что для высвобождения пространства действительно понадобится выполнить
VACUUM FULL. Использование демона автоочистки снимает эту проблему, поскольку он планирует
очистку динамически, отслеживая интенсивность изменений. Полностью отключать этот демон
может иметь смысл, только если вы имеете дело с предельно предсказуемой загрузкой. Возможен
и компромиссный вариант — настроить параметры демона автоочистки так, чтобы он реагировал
только на необычайно высокую интенсивность изменений и мог удержать ситуацию под контро-
лем, в то время как команды VACUUM, запускаемые по расписанию, будут выполнять основную ра-
боту в периоды нормальной загрузки.
Если же автоочистка не применяется, обычно планируется выполнение VACUUM для всей базы дан-
ных раз в сутки в период низкой активности, и в случае необходимости оно дополняется более
частой очисткой интенсивно изменяемых таблиц. (В некоторых ситуациях, когда изменения про-
изводятся крайне интенсивно, самые востребованные таблицы могут очищаться раз в несколько
620Регламентные задачи об-
служивания базы данных
минут.) Если в вашем кластере несколько баз данных, не забывайте выполнять VACUUM для каждой
из них; при этом может быть полезна программа vacuumdb.
Подсказка
Результат обычного VACUUM может быть неудовлетворительным, когда вследствие мас-
сового изменения или удаления строк в таблице оказывается много мёртвых версий
строк. Если у вас есть такая таблица и вам нужно освободить лишнее пространство,
которое она занимает, используйте команду VACUUM FULL или, в качестве альтернати-
вы, CLUSTER или один из вариантов ALTER TABLE, выполняющий перезапись таблицы.
Эти команды записывают абсолютно новую копию таблицы и строят для неё индексы.
Все эти варианты требуют исключительной блокировки. Заметьте, что они также на
время требуют дополнительного пространства на диске в объёме, приблизительно рав-
ном размеру таблицы, поскольку старые копии таблицы и индексов нельзя удалить до
завершения создания новых копий.
Подсказка
Если у вас есть таблица, всё содержимое которой периодически удаляется, рассмот-
рите возможность использования TRUNCATE вместо DELETE с последующей командой
VACUUM. TRUNCATE немедленно удаляет всё содержимое таблицы, не требуя последую-
щей очистки (VACUUM или VACUUM FULL) для высвобождения неиспользуемого дисково-
го пространства. Недостатком такого подхода является нарушение строгой семантики
MVCC.
24.1.3. Обновление статистики планировщика
Планировщик запросов в PostgreSQL, выбирая эффективные планы запросов, полагается на ста-
тистическую информацию о содержимом таблиц. Эта статистика собирается командой ANALYZE,
которая может вызываться сама по себе или как дополнительное действие команды VACUUM. Ста-
тистика должна быть достаточно точной, так как в противном случае неудачно выбранные планы
запросов могут снизить производительность базы данных.
Демон автоочистки, если он включён, будет автоматически выполнять ANALYZE после существен-
ных изменений содержимого таблицы. Однако администраторы могут предпочесть выполнение
ANALYZE вручную, в частности, если известно, что производимые в таблице изменения не повлия-
ют на статистику по «интересным» столбцам. Демон же планирует выполнение ANALYZE в зависи-
мости только от количества вставленных или изменённых строк; он не знает, приведут ли они к
значимым изменениям статистики.
Как и процедура очистки для высвобождения пространства, частое обновление статистики полез-
нее для интенсивно изменяемых таблиц, нежели для тех таблиц, которые изменяются редко. Од-
нако даже в случае часто изменяемой таблицы обновление статистики может не требоваться, ес-
ли статистическое распределение данных меняется слабо. Как правило, достаточно оценить, на-
сколько меняются максимальное и минимальное значения в столбцах таблицы. Например, макси-
мальное значение в столбце timestamp, хранящем время изменения строки, будет постоянно уве-
личиваться по мере добавления и изменения строк; для такого столбца может потребоваться более
частое обновление статистики, чем, к примеру, для столбца, содержащего адреса страниц (URL),
которые запрашивались с сайта. Столбец с URL-адресами может меняться столь же часто, однако
статистическое распределение его значений, вероятно, будет изменяться относительно медленно.
Команду ANALYZE можно выполнять для отдельных таблиц и даже просто для отдельных столбцов
таблицы, поэтому, если того требует приложение, одни статистические данные можно обновлять
чаще, чем другие. Однако на практике обычно лучше просто анализировать всю базу данных, по-
621Регламентные задачи об-
служивания базы данных
скольку это быстрая операция, так как ANALYZE читает не каждую отдельную строку, а статисти-
чески случайную выборку строк таблицы.
Подсказка
Хотя индивидуальная настройка частоты ANALYZE для отдельных столбцов может быть
не очень полезной, смысл может иметь настройка детализации статистики, собирае-
мой командой ANALYZE. Для столбцов, которые часто используются в предложениях
WHERE, и имеют очень неравномерное распределение данных, может потребоваться бо-
лее детальная, по сравнению с другими столбцами, гистограмма данных. В таких слу-
чаях можно воспользоваться командой ALTER TABLE SET STATISTICS или изменить зна-
чение по умолчанию параметра уровня БД default_statistics_target.
Кроме того, по умолчанию информация об избирательности функций ограничена. Од-
нако если вы создаёте индекс по выражению с вызовом функции, об этой функции бу-
дет собрана полезная статистическая информация, которая может значительно улуч-
шить планы запросов, в которых используется данный индекс.
Подсказка
Демон автоочистки не выполняет команды ANALYZE для сторонних таблиц, поскольку
он не знает, как часто это следует делать. Если для получения качественных планов
вашим запросам необходима статистика по сторонним таблицам, будет хорошей идеей
дополнительно запускать ANALYZE для них по подходящему расписанию.
24.1.4. Обновление карты видимости
Процедура очистки поддерживает карты видимости для каждой таблицы, позволяющие опреде-
лить, в каких страницах есть только записи, заведомо видимые для всех активных транзакций (и
всех будущих транзакций, пока страница не будет изменена). Это имеет два применения. Во-пер-
вых, сам процесс очистки может пропускать такие страницы при следующем запуске, поскольку
на этих страницах вычищать нечего.
Во-вторых, с такими картами PostgreSQL может выдавать результаты некоторых запросов, исполь-
зуя только индекс, не обращаясь к данным таблицы. Так как индексы PostgreSQL не содержат
информацию о видимости записей, при обычном сканировании по индексу необходимо извлечь
соответствующую запись из таблицы и проверить её видимость для текущей транзакции. Поэтому
при сканировании только индекса, наоборот, сначала проверяется карта видимости. Если извест-
но, что все записи на странице видимы, то выборку из таблицы можно пропустить. Это наиболее
полезно с большими наборах данных, когда благодаря карте видимости можно оптимизировать
чтение с диска. Карта видимости значительно меньше таблицы, поэтому она легко помещается в
кеш, даже когда объём самих страниц очень велик.
24.1.5. Предотвращение ошибок из-за зацикливания счётчика
транзакций
В PostgreSQL семантика транзакций MVCC зависит от возможности сравнения номеров идентифи-
каторов транзакций (XID): версия строки, у которой XID добавившей её транзакции больше, чем
XID текущей транзакции, относится «к будущему» и не должна быть видна в текущей транзакции.
Однако поскольку идентификаторы транзакций имеют ограниченный размер (32 бита), кластер,
работающий долгое время (более 4 миллиардов транзакций) столкнётся с зацикливанием иденти-
фикаторов транзакций: счётчик XID прокрутится до нуля, и внезапно транзакции, которые отно-
сились к прошлому, окажутся в будущем — это означает, что их результаты станут невидимыми.
Одним словом, это катастрофическая потеря данных. (На самом деле данные никуда не пропада-
622Регламентные задачи об-
служивания базы данных
ют, однако если вы не можете их получить, то это слабое утешение.) Для того чтобы этого избе-
жать, необходимо выполнять очистку для каждой таблицы в каждой базе данных как минимум
единожды на два миллиардов транзакций.
Периодическое выполнение очистки решает эту проблему, потому что процедура VACUUM помечает
строки как замороженные, указывая, что они были вставлены транзакцией, зафиксированной до-
статочно давно, так что эффект добавляющей транзакции с точки зрения MVCC определённо бу-
дет виден во всех текущих и будущих транзакциях. Обычные значения XID сравниваются по моду-
32
лю 2 . Это означает, что для каждого обычного XID существуют два миллиарда значений XID, ко-
торые «старше» него, и два миллиарда значений, которые «младше» него; другими словами, про-
странство значений XID циклично и не имеет конечной точки. Следовательно, как только создаёт-
ся версия строки с обычным XID, для следующих двух миллиардов транзакций эта версия строки
оказывается «в прошлом», неважно о каком значении обычного XID идет речь. Если после двух
миллиардов транзакций эта версия строки всё ещё существует, она внезапно окажется в будущем.
Для того чтобы это предотвратить, в какой-то момент значение XID для старых версий строк долж-
но быть заменено на FrozenTransactionId (заморожено) до того, как будет достигнута граница в
два миллиарда транзакций. После получения этого особенного XID для всех обычных транзакций
эти версии строк будут относиться «к прошлому», независимо от зацикливания, и, таким образом,
эти версии строк будут действительны до момента их удаления, когда бы это ни произошло.
Примечание
В версиях PostgreSQL до 9.4 замораживание было реализовано как замена XID добав-
ления строки специальным идентификатором FrozenTransactionId, который можно
было увидеть в системной колонке xmin данной строки. В новых версиях просто уста-
навливается битовый флаг, а исходный xmin строки сохраняется для возможного рас-
следования в будущем. Однако строки с xmin, равным FrozenTransactionId (2), мож-
но по-прежнему встретить в базах данных, обновлённых (с применением pg_upgrade)
с версий до 9.4.
Также системные каталоги могут содержать строки со значением xmin, равным
BootstrapTransactionId (1), показывающим, что они были вставлены на первом этапе
initdb. Как и FrozenTransactionId, этот специальный XID считается более старым, чем
любой обычный XID.
Параметр vacuum_freeze_min_age определяет, насколько старым должен стать XID, чтобы строки
с таким XID были заморожены. Увеличение его значения помогает избежать ненужной работы,
если строки, которые могли бы быть заморожены в ближайшее время, будут изменены ещё раз, а
уменьшение приводит к увеличению количества транзакций, которые могут выполниться, прежде
чем потребуется очередная очистка таблицы.
VACUUM определяет, какие страницы таблицы нужно сканировать, анализируя карту видимости.
Обычно при этой операции пропускаются страницы, в которых нет мёртвых версий строк, даже
если в них могут быть версии строк со старыми XID. Таким образом, обычная команда VACUUM не
будет всегда замораживать все версии строк, имеющиеся в таблице. Периодически VACUUM будет
также производить агрессивную очистку, пропуская только те страницы, которые не содержат ни
мёртвых строк, ни незамороженных значений XID или MXID. Когда VACUUM будет делать это, зави-
сит от параметра vacuum_freeze_table_age: полностью видимые, но не полностью замороженные
страницы будут сканироваться, если число транзакций, прошедших со времени последнего такого
сканирования, оказывается больше чем vacuum_freeze_table_age минус vacuum_freeze_min_age.
Если vacuum_freeze_table_age равно 0, VACUUM будет применять эту более агрессивную стратегию
при каждом сканировании.
Максимальное время, в течение которого таблица может обходиться без очистки, составляет два
миллиарда транзакций минус значение vacuum_freeze_min_age с момента последней агрессивной
очистки. Если бы таблица не подвергалась очистке дольше, была бы возможна потеря данных. Что-
бы гарантировать, что это не произойдёт, для любой таблицы, которая может содержать значения
623Регламентные задачи об-
служивания базы данных
XID старше, чем возраст, указанный в конфигурационном параметре autovacuum_freeze_max_age,
вызывается автоочистка. (Это случится, даже если автоочистка отключена.)
Это означает, что если очистка таблицы не вызывается другим способом, то автоочистка
для неё будет вызываться приблизительно через каждые autovacuum_freeze_max_age минус
vacuum_freeze_min_age транзакций. Для таблиц, очищаемых регулярно для высвобождения про-
странства, это неактуально. В то же время статичные таблицы (включая таблицы, в которых дан-
ные вставляются, но не изменяются и не удаляются) не нуждаются в очистке для высвобожде-
ния пространства, поэтому для очень больших статичных таблиц имеет смысл увеличить интер-
вал между вынужденными запусками автоочистки. Очевидно, это можно сделать, либо увеличив
autovacuum_freeze_max_age, либо уменьшив vacuum_freeze_min_age.
Фактический
максимум
для
vacuum_freeze_table_age
составляет
0.95
*
autovacuum_freeze_max_age; большее значение будет ограничено этим пределом. Значение, пре-
вышающее autovacuum_freeze_max_age, не имело бы смысла, поскольку по достижении этого зна-
чения в любом случае вызывалась бы автоочистка для предотвращения зацикливания, а коэффи-
циент 0.95 оставляет немного времени для того, чтобы запустить команду VACUUM вручную до того,
как это произойдёт. Как правило, установленное значение vacuum_freeze_table_age должно быть
несколько меньше autovacuum_freeze_max_age, чтобы оставленный промежуток был достаточен
для выполнения в этом окне VACUUM по расписанию или автоочистки, управляемой обычной актив-
ностью операций удаления и изменения. Если это значение будет слишком близким к максимуму,
автоочистка для предотвращения зацикливания будет выполняться, даже если таблица только что
была очищена для высвобождения пространства, в то же время при небольшом значении будет
чаще производиться агрессивная очистка.
Единственный минус увеличения autovacuum_freeze_max_age (и vacuum_freeze_table_age с
ним) заключается в том, что подкаталоги pg_xact и pg_commit_ts в кластере баз дан-
ных будут занимать больше места, поскольку в них нужно будет хранить статус и (при
включённом track_commit_timestamp) время фиксации всех транзакций вплоть до горизонта
autovacuum_freeze_max_age. Для статуса фиксации используется по два бита на транзакцию, по-
этому если в autovacuum_freeze_max_age установлено максимально допустимое значение в два
миллиарда, то размер pg_xact может составить примерно половину гигабайта, а pg_commit_ts
примерно 20 ГБ. Если по сравнению с объёмом вашей базы данных этот объём незначителен, тогда
рекомендуется установить для autovacuum_freeze_max_age максимально допустимое значение. В
противном случае установите значение этого параметра в зависимости от объёма, который вы го-
товы выделить для pg_xact и pg_commit_ts. (Значению по умолчанию, 200 миллионам транзакций,
соответствует приблизительно 50 МБ в pg_xact и около 2 ГБ в pg_commit_ts.)
Уменьшение значения vacuum_freeze_min_age, с другой стороны, чревато тем, что команда VACUUM
может выполнять бесполезную работу: замораживание версии строки — пустая трата времени,
если эта строка будет вскоре изменена (и в результате получит новый XID). Поэтому значение
этого параметра должно быть достаточно большим для того, чтобы строки не замораживались,
пока их последующее изменение не станет маловероятным.
Для отслеживания возраста самых старых значений XID в базе данных команда VACUUM сохра-
няет статистику по XID в системных таблицах pg_class и pg_database. В частности, столбец
relfrozenxid в записи для определённой таблицы в pg_class содержит граничное значение XID,
с которым в последний раз выполнялась агрессивная очистка (VACUUM) этой таблицы. Все строки,
добавленные транзакциями с более ранними XID, гарантированно будут заморожены. Аналогич-
но столбец datfrozenxid в записи для базы данных в pg_database представляет нижнюю грани-
цу обычных значений XID, встречающихся в этой базе — он просто хранит минимальное из всех
значений relfrozenxid для таблиц этой базы. Эту информацию удобно получать с помощью таких
запросов:
SELECT c.oid::regclass as table_name,
greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
624Регламентные задачи об-
служивания базы данных
WHERE c.relkind IN (‘r’, ‘m’);
SELECT datname, age(datfrozenxid) FROM pg_database;
Столбец age показывает количество транзакций от граничного значения XID до XID текущей тран-
закции.
Обычно VACUUM сканирует только те страницы, которые изменялись после последней очистки, од-
нако relfrozenxid может увеличиться только при сканировании всех страниц таблицы, включая
те, что могут содержать незамороженные XID. Это происходит когда возраст relfrozenxid дости-
гает vacuum_freeze_table_age транзакций, когда VACUUM вызывается с указанием FREEZE, или ко-
гда оказывается, что очистку для удаления мёртвых версий строк нужно провести во всех ещё не
замороженных страницах. Когда VACUUM сканирует в таблице каждую ещё не полностью заморо-
женную страницу, значение age(relfrozenxid) в результате должно стать немного больше, чем
установленное значение vacuum_freeze_min_age (больше на число транзакций, начатых с момента
запуска VACUUM). Если по достижении autovacuum_freeze_max_age для таблицы ни разу не будет
выполнена операция relfrozenxid, в скором времени для неё будет принудительно запущена ав-
тоочистка.
Если по какой-либо причине автоочистка не может вычистить старые значения XID из таблицы,
система начинает выдавать предупреждающие сообщения, подобные приведённому ниже, когда
самое старое значение XID в базе данных оказывается в десяти миллионах транзакций от точки
зацикливания:
ПРЕДУПРЕЖДЕНИЕ: база данных “mydb” должна быть очищена (предельное число транзакций:
177009986)
ПОДСКАЗКА: Во избежание отключения базы данных выполните очистку (VACUUM) всей базы
“mydb”.
(Проблему можно решить, как предлагает подсказка, запустив VACUUM вручную; однако учтите, что
выполнять VACUUM должен суперпользователь, в противном случае эта процедура не сможет об-
работать системные каталоги и, следовательно, не сможет увеличить значение datfrozenxid для
базы данных.) Если эти предупреждения игнорировать, система отключится и не будет начинать
никаких транзакций, как только до точки зацикливания останется менее 1 миллиона транзакций:
ОШИБКА: база данных не принимает команды во избежание потери данных из-за зацикливания
в БД “mydb”
ПОДСКАЗКА: Остановите управляющий процесс (postmaster) и выполните очистку (VACUUM)
базы данных в однопользовательском режиме.
Резерв в 1 миллион транзакций позволяет администратору провести восстановление без потери
данных, выполнив необходимые команды VACUUM вручную. Однако, поскольку после безопасной
остановки система не будет исполнять команды, администратору останется только перезапустить
сервер в однопользовательском режиме, чтобы запустить VACUUM. За подробной информацией об
использовании однопользовательского режима обратитесь к странице справки по postgres.
24.1.5.1. Мультитранзакции и зацикливание
Идентификаторы мультитранзакций используются для поддержки блокировки строк несколь-
кими транзакциями одновременно. Поскольку в заголовке строки есть только ограниченное про-
странство для хранения информации о блокировках, в нём указывается «идентификатор множе-
ственной транзакции», или идентификатор мультитранзакции для краткости, когда строку бло-
кируют одновременно несколько транзакций. Информация о том, какие именно идентификато-
ры транзакций относятся к определённой мультитранзакции, хранится отдельно в подкаталоге
pg_multixact, а в поле xmax в заголовке строки сохраняется только идентификатор мультитранзак-
ции. Как и идентификаторы транзакций, идентификаторы мультитранзакций исполнены в виде 32-
разрядного счётчика и хранятся аналогично, что требует аккуратного управления их возрастом,
очисткой хранилища и предотвращением зацикливаний. Существует отдельная область, в которой
содержится список членов каждой мультитранзакции, где счётчики также 32-битные и требуют
должного контроля.
625Регламентные задачи об-
служивания базы данных
Когда VACUUM сканирует какую-либо часть таблицы, каждый идентификатор мультитранзакции
старее чем vacuum_multixact_freeze_min_age заменяется другим значением, которое может быть
нулевым, идентификатором одиночной транзакции или новым идентификатором мультитранзак-
ции. Для каждой таблицы в pg_class.relminmxid хранится самый старый возможный идентифика-
тор мультитранзакции, всё ещё задействованный в какой-либо строке этой таблицы. Если это зна-
чение оказывается старее vacuum_multixact_freeze_table_age, выполняется агрессивная очистка.
Как рассказывалось в предыдущем разделе, при агрессивной очистке будут пропускаться только
те страницы, которые считаются полностью замороженными. Узнать возраст pg_class.relminmxid
можно с помощью функции mxid_age().
Благодаря агрессивным операциям VACUUM, вне зависимости от их причины, это значение для таб-
лицы будет увеличиваться. В конце концов, по мере сканирования всех таблиц во всех базах дан-
ных и увеличения их старейших значений мультитранзакций, информация о старых мультитран-
закциях может быть удалена с диска.
В качестве меры защиты, агрессивное сканирование с целью очистки будет происходить для любой
таблицы, возраст мультитранзакций которой больше, чем autovacuum_multixact_freeze_max_age.
Агрессивное сканирование также будет выполняться постепенно со всеми таблицами, начиная с
имеющих старейшие мультитранзакции, если объём занятой области членов мультитранзакций
превышает 50% от объёма адресуемого пространства. Эти два варианта агрессивного сканирова-
ния осуществляются, даже если процесс автоочистки отключён.
24.1.6. Демон автоочистки
В PostgreSQL имеется не обязательная, но настоятельно рекомендуемая к использованию функ-
ция, называемая автоочисткой, предназначение которой — автоматизировать выполнение ко-
манд VACUUM и ANALYZE . Когда автоочистка включена, она проверяет, в каких таблицах было встав-
лено, изменено или удалено много строк. При этих проверках используются средства сбора ста-
тистики; поэтому автоочистка будет работать, только если параметр track_counts имеет значение
true. В конфигурации по умолчанию автоочистка включена и соответствующие параметры имеют
подходящие значения.
«Демон автоочистки» на самом деле состоит из нескольких процессов. Существует постоянный
фоновый процесс, называемый процессом запуска автоочистки, который отвечает за запуск ра-
бочих процессов автоочистки для всех баз данных. Этот контролирующий процесс распреде-
ляет работу по времени, стараясь запускать рабочий процесс для каждой базы данных каждые
autovacuum_naptime секунд. (Следовательно, если всего имеется N баз данных, новый рабочий про-
цесс будет запускаться каждые autovacuum_naptime/N секунд.) Одновременно могут выполняться
до autovacuum_max_workers рабочих процессов. Если число баз данных, требующих обработки,
превышает autovacuum_max_workers, обработка следующей базы начинается сразу по завершении
первого рабочего процесса. Каждый рабочий процесс проверяет все таблицы в своей базе данных
и в случае необходимости выполняет VACUUM и/или ANALYZE. Для отслеживания действий рабочих
процессов можно установить параметр log_autovacuum_min_duration.
Если в течение короткого промежутка времени потребность в очистке возникает для нескольких
больших таблиц, все рабочие процессы автоочистки могут продолжительное время заниматься
очисткой только этих таблиц. В результате другие таблицы и базы данных будут ожидать очистки,
пока не появится свободный рабочий процесс. Число рабочих процессов для одной базы не огра-
ничивается, при этом каждый процесс старается не повторять работу, только что выполненную
другими. Заметьте, что в ограничениях max_connections или superuser_reserved_connections число
выполняющихся рабочих процессов не учитывается.
Для таблиц с relfrozenxid, устаревшим более чем на autovacuum_freeze_max_age транзакций,
очистка выполняется всегда (это также применимо к таблицам, для которых максимальный по-
рог заморозки был изменён через параметры хранения; см. ниже). В противном случае, очистка
таблицы производится, если количество кортежей, устаревших с момента последнего выполнения
VACUUM, превышает «пороговое значение очистки». Пороговое значение очистки определяется как:
порог очистки = базовый порог очистки + коэффициент доли для очистки * количество
кортежей
626Регламентные задачи об-
служивания базы данных
где базовый порог очистки — значение autovacuum_vacuum_threshold, коэффициент доли —
autovacuum_vacuum_scale_factor, а количество кортежей — pg_class.reltuples. Количество уста-
ревших кортежей получается от сборщика статистики; оно представляет собой приблизительное
число, обновляемое после каждой операции UPDATE и DELETE. (Точность не гарантируется, потому
что при большой нагрузке часть информации может быть утеряна.) Если значение relfrozenxid
для таблицы старее vacuum_freeze_table_age транзакций, производится агрессивная очистка с
целью заморозить старые версии строк и увеличить значение relfrozenxid; в противном случае
сканируются только страницы, изменённые после последней очистки.
Для выполнения сбора статистики используется аналогичное условие: пороговое значение, опре-
деляемое как:
порог анализа = базовый порог анализа + коэффициент доли для анализа * количество
кортежей
сравнивается с общим количеством кортежей добавленных, изменённых или удалённых после по-
следнего выполнения ANALYZE.
Автоочистка не обрабатывает временные таблицы. Поэтому очистку и сбор статистики в них нужно
производить с помощью SQL-команд в обычном сеансе.
Используемые по умолчанию пороговые значения и коэффициенты берутся из postgresql.conf,
однако их (и многие другие параметры, управляющие автоочисткой) можно переопределить для
каждой таблицы; за подробностями обратитесь к Подразделу «Параметры хранения». Если ка-
кие-либо значения определены через параметры хранения таблицы, при обработке этой таблицы
действуют они, а в противном случае — глобальные параметры. За более подробной информацией
о глобальных параметрах обратитесь к Разделу 19.10.
Когда выполняются несколько рабочих процессов, параметры задержки автоочистки по стоимости
(см. Подраздел 19.4.4) «распределяются» между всеми этими процессами, так что общее воздей-
ствие на систему остаётся неизменным, независимо от их числа. Однако этот алгоритм распреде-
ления нагрузки не учитывает процессы, обрабатывающие таблицы с индивидуальными значения-
ми параметров хранения autovacuum_vacuum_cost_delay и autovacuum_vacuum_cost_limit.
24.2. Регулярная переиндексация
В некоторых ситуациях стоит периодически перестраивать индексы, выполняя команду REINDEX
или последовательность отдельных шагов по восстановлению индексов.
Страницы индексов на основе B-деревьев, которые стали абсолютно пустыми, могут быть исполь-
зованы повторно. Однако возможность неэффективного использования пространства всё же оста-
ётся: если со страницы были удалены почти все, но не все ключи индекса, страница всё равно оста-
ётся занятой. Следовательно, шаблон использования, при котором со временем удаляются многие,
но не все ключи в каждом диапазоне, приведёт к неэффективному расходованию пространства. В
таких случаях рекомендуется периодически проводить переиндексацию.
Возможность потери пространства в индексах на основе не B-деревьев глубоко не исследовалась.
Поэтому имеет смысл периодически отслеживать физический размер индекса, когда применяется
индекс такого типа.
Кроме того, с B-деревьями доступ по недавно построенному индексу осуществляется немного быст-
рее, нежели доступ по индексу, который неоднократно изменялся, поскольку в недавно построен-
ном индексе страницы, близкие логически, обычно расположены так же близко и физически. (Это
соображение неприменимо к индексам, которые основаны не на B-деревьях.) Поэтому периодиче-
ски проводить переиндексацию стоит хотя бы для того, чтобы увеличить скорость доступа.
Команду REINDEX можно безопасно и просто применять во всех случаях. Но так как она требует
исключительной блокировки таблицы, часто предпочтительнее перестраивать индекс в несколько
этапов, включающих создание и замену индекса. Типы индексов, которые поддерживает CREATE
INDEX с указанием CONCURRENTLY, можно построить именно так. Если это удаётся и получен рабо-
627Регламентные задачи об-
служивания базы данных
чий индекс, изначальный индекс можно заменить им, выполнив ALTER INDEX и DROP INDEX. Ко-
гда индекс используется для обеспечения уникальности или других ограничений, может потребо-
ваться команда ALTER TABLE, чтобы поменять существующее ограничение на то, что обеспечива-
ет новый индекс. Обстоятельно продумайте эту многоходовую процедуру, прежде чем выполнять
её, так как не все индексы можно перестроить таким образом, и предусмотрите обработку ошибок.
24.3. Обслуживание журнала
Журнал сервера базы данных желательно сохранять где-либо, а не просто сбрасывать его в /dev/
null. Этот журнал бесценен при диагностике проблем. Однако он может быть очень объёмным
(особенно при высоких уровнях отладки), так что хранить его неограниченно долго вы вряд ли за-
хотите. Поэтому необходимо организовать ротацию журнальных файлов так, чтобы новые файлы
создавались, а старые удалялись через разумный промежуток времени.
Если просто направить stderr команды postgres в файл, вы получите в нём журнал сообщений,
но очистить этот файл можно будет, только если остановить и перезапустить сервер. Это может
быть допустимо при использовании PostgreSQL в среде разработки, но вряд ли такой вариант будет
приемлемым в производственной среде.
Лучшим подходом будет перенаправление вывода сервера stderr в какую-либо программу ро-
тации журнальных файлов. Существует и встроенное средство ротации журнальных файлов,
которое можно использовать, установив для параметра logging_collector значение true в
postgresql.conf. Параметры, управляющие этой программой, описаны в Подразделе 19.8.1. Этот
подход также можно использовать для получения содержимого журнала в формате CSV (значе-
ния, разделённые запятыми).
Вы также можете использовать внешнюю программу для ротации журнальных файлов, если уже
применяете такое приложение для других серверных приложений. Например, утилиту rotatelogs,
включённую в дистрибутив Apache, можно использовать и с PostgreSQL. Для этого просто направь-
те вывод stderr сервера в желаемую программу. Если вы запускаете сервер, используя pg_ctl, то
stderr уже будет перенаправлен в stdout, так что будет достаточно просто применить конвейер,
например:
pg_ctl start | rotatelogs /var/log/pgsql_log 86400
Ещё одно решение промышленного уровня заключается в передаче журнала в syslog, чтобы ро-
тацией файлов занималась уже служба syslog. Для этого присвойте параметру конфигурации
log_destination значение syslog (для вывода журнала только в syslog) в postgresql.conf. Затем
вы сможете посылать сигнал SIGHUP службе syslog, когда захотите принудительно начать запись
нового журнального файла. Если вы хотите автоматизировать ротацию журнальных файлов, про-
грамму logrotate можно настроить и для работы с журнальными файлами, которые формирует
syslog.
Однако во многих системах, а особенно c большими сообщениями, syslog работает не очень надёж-
но; он может обрезать или терять сообщения как раз тогда, когда они вам нужны. Кроме того, в
Linux, syslog&gt; сбрасывает каждое сообщение на диск, от чего страдает производительность. (Для
отключения этой синхронной записи можно добавить «-» перед именем файла в файле конфигу-
рации syslog.)
Обратите внимание, что все описанные выше решения обеспечивают создание новых журнальных
файлов через задаваемые промежутки времени, но не удаление старых, ставших бесполезными
файлов журналов. Возможно, вы захотите создать задание для периодического удаления старых
файлов. Кроме того, вы можете настроить программу ротации файлов так, чтобы старые файлы
журналов циклически перезаписывались.
Также вам может быть полезен pgBadger — инструмент для сложного анализа файлов журнала.
Кроме того, check_postgres может посылать уведомления в Nagios, когда в журнале появляются
важные сообщения, а также при обнаружении других нестандартных ситуаций.
628</li>
</ol>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-024/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-024/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-024/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-023/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Script_Mount_FTP_Folder/" title="Монтируем папку FTP в файловую систему Bash  SCRIPT">Монтируем папку FTP в файловую систему Bash  SCRIPT</a></h3>
      <p>Bash Монтируем папку FTP в файловую систему Bash  SCRIPT: <a href="http://localhost:4000/Script_Mount_FTP_Folder/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Script_bash-copy-ftp/" title="Копируем на FTP скриптом bash">Копируем на FTP скриптом bash</a></h4>
        <span>Published on January 17, 2019</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Work-Project-Manager/" title="Коротко - работа менеджера проектов">Коротко - работа менеджера проектов</a></h4>
        <span>Published on December 04, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
