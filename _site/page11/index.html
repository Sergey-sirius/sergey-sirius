<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page11/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page11/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" title="Глава 47. Интерфейс программирования сервера"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 47. Интерфейс программирования сервера"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~40 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" rel="bookmark" title="Глава 47. Интерфейс программирования сервера" itemprop="url">Глава 47. Интерфейс программирования сервера</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 47. Интерфейс программирования сервера</p>

<p>Интерфейс программирования сервера (SPI, Server Programming Interface) даёт разработчикам
пользовательских функций на C возможность запускать команды SQL из своих функций. SPI пред-
ставляет собой набор интерфейсных функций, упрощающих доступ к анализатору, планировщику
и исполнителю запросов. В SPI есть также функции для управления памятью.
Примечание
Доступные процедурные языки предоставляют различные средства для выполнения
SQL-команд из функций. Большинство этих средств основаны на SPI, так что эта доку-
ментация будет полезна и тем, кто использует эти языки.
Учтите, что если команда, вызванная через SPI, прерывается ошибкой, управление не возвраща-
ется в вашу функцию на C. Вместо этого происходит откат транзакции или подтранзакции, из ко-
торой вызывалась ваша функция. (Это может показаться удивительным, с учётом того, что для
большинства функций SPI описаны соглашения по возврату ошибок. Однако эти соглашения при-
менимы только к ошибкам, выявляемым в самих функциях SPI.) Получить управление после ошиб-
ки можно, только организовав собственную подтранзакцию, окружающую вызовы SPI, в которых
возможна ошибка.
Функции SPI выдают неотрицательный результат в случае успеха (либо через возвращаемое це-
лочисленное значение, либо в глобальной переменной SPI_result, как описано ниже). В случае
ошибки выдаётся отрицательный результат или NULL.
Файлы исходного кода, использующие SPI, должны включать заголовочный файл executor/spi.h.
47.1. Интерфейсные функции
1226Интерфейс програм-
мирования сервера
SPI_connect
SPI_connect, SPI_connect_ext — подключить функцию на C к менеджеру SPI
Синтаксис
int SPI_connect(void)
int SPI_connect_ext(int options)
Описание
SPI_connect устанавливает подключение вызова функции на C к менеджеру SPI. Данную функцию
необходимо использовать, если вы хотите выполнять команды через SPI. Некоторые вспомогатель-
ные функции SPI могут вызываться из неподключённых функций.
SPI_connect_ext делает то же самое, но принимает один аргумент, через который можно передать
дополнительные флаги. В настоящее время поддерживаются следующие флаги:
SPI_OPT_NONATOMIC
Переводит подключение SPI в неатомарный режим, в котором разрешаются вызовы функций
управления транзакциями SPI_commit, SPI_rollback и SPI_start_transaction. В обычном ре-
жиме вызов этих функций приводит к немедленной ошибке.
Вызов SPI_connect() равнозначен SPI_connect_ext(0).
Возвращаемое значение
SPI_OK_CONNECT
при успехе
SPI_ERROR_CONNECT
при ошибке
1227Интерфейс програм-
мирования сервера
SPI_finish
SPI_finish — отключить функцию на C от менеджера SPI
Синтаксис
int SPI_finish(void)
Описание
SPI_finish закрывает текущее соединение с менеджером SPI. Эту функцию необходимо вызывать
после завершения операций SPI, которые должны выполняться в текущем вызове функции на C.
Однако если вы прерываете транзакцию, выполняя elog(ERROR), о закрытии соединения можно не
беспокоиться. В этом случае SPI произведёт очистку автоматически.
Возвращаемое значение
SPI_OK_FINISH
если отключение выполнено корректно
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
1228Интерфейс програм-
мирования сервера
SPI_execute
SPI_execute — выполнить команду
Синтаксис
int SPI_execute(const char * command, bool read_only, long count)
Описание
SPI_execute выполняет заданную команду SQL для получения строк в количестве, ограниченном
count. С параметром read_only, равным true, команда должна только читать данные; это несколь-
ко сокращает издержки на её выполнение.
Эту функцию можно вызывать только из подключённой функции на C.
Если count равен 0, команда выполняется для всех строк, к которым она применима. Если count
больше нуля, будет получено не более чем count строк; выполнение команды остановится при
достижении этого предела, практически так же, как и с предложением LIMIT в запросе. Например,
команда:
SPI_execute(“SELECT * FROM foo”, true, 5);
получит из таблицы не более 5 строк. Заметьте, что это ограничение действует, только когда ко-
манда действительно возвращает строки. Например, эта команда:
SPI_execute(“INSERT INTO foo SELECT * FROM bar”, false, 5);
вставляет все строки из bar, игнорируя параметр count. Однако команда
SPI_execute(“INSERT INTO foo SELECT * FROM bar RETURNING <em>”, false, 5);
вставит не более 5 строк, так как её выполнение будет остановлено после получения пятой строки,
выданной предложением RETURNING.
В одной строке можно передать несколько команд; SPI_execute возвращает результат команды,
выполненной последней. Параметр count при этом будет применяться к каждой команде по от-
дельности (несмотря даже на то, что возвращён будет только последний результат). Это ограни-
чение не будет распространяться на скрытые команды, генерируемые правилами.
Когда параметр read_only равен false, SPI_execute увеличивает счётчик команд и получает но-
вый снимок перед выполнением каждой очередной команды в строке. Этот снимок фактически
не меняется при текущем уровне изоляции транзакций SERIALIZABLE или REPEATABLE READ, но в
режиме READ COMMITTED после обновления снимка очередная команда может видеть результаты
только что зафиксированных транзакций из других сеансов. Это важно для согласованного пове-
дения, когда команды модифицируют базу данных.
Когда параметр read_only равен true, SPI_execute не обновляет снимок и не увеличивает счётчик
команд, и допускает в строке команд только SELECT. Заданные команды выполняются со снимком,
ранее полученным для окружающего запроса. Этот режим выполнения несколько быстрее режима
чтения/записи вследствие исключения издержек, связанных с отдельными командами. Он также
позволяет создавать подлинно стабильные функции: так как последующие вызовы в транзакции
будут использовать один снимок, результаты команд не изменятся.
Смешивать команды, только читающие, с командами, читающими и пишущими, в одной процедуре,
использующей SPI, обычно неразумно; запросы только на чтение не увидят результатов изменений
в базе данных, произведённых пишущими запросами.
Число строк, которые были фактически обработаны командой (последней), возвращается в гло-
бальной переменной SPI_processed. Если эта функция возвращает значение SPI_OK_SELECT,
SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING или SPI_OK_UPDATE_RETURNING, вы можете об-
1229Интерфейс програм-
мирования сервера
ратиться по глобальному указателю SPITupleTable *SPI_tuptable и прочитать строки резуль-
тата. Некоторые служебные команды (например, EXPLAIN) также возвращают наборы строк, и
SPI_tuptable будет содержать их результаты и в этих случаях. Другие вспомогательные команды
(COPY, CREATE TABLE AS) не возвращают набор строк, так что указатель SPI_tuptable равен NULL,
но они так же возвращают число обработанных строк в SPI_processed.
Структура SPITupleTable определена так:
typedef struct
{
MemoryContext tuptabcxt;
uint64
alloced;
uint64
free;
TupleDesc
tupdesc;
HeapTuple *vals;
} SPITupleTable;
/</em>
/*
/*
/*
/*
контекст таблицы результатов в памяти <em>/
число занятых значений */
число свободных значений */
дескриптор строки */
данные строк */
vals представляет собой массив указателей на строки. (Число записей в нём указывается в
SPI_processed.) Поле tupdesc содержит дескриптор строки, который вы сможете передать функ-
циям SPI, работающими со строками. Поля tuptabcxt, alloced и free предназначены для внутрен-
него использования, а не для процедур, работающих с SPI.
SPI_finish освобождает все структуры SPITupleTable, размещённые в памяти для текущей функ-
ции на C. Вы можете освободить структуру конкретной результирующей таблицы, если она вам не
нужна, вызвав SPI_freetuptable.
Аргументы
const char * command
строка с командой, которая должна быть выполнена
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Если команда была выполнена успешно, возвращается одно из следующих (неотрицательных) зна-
чений:
SPI_OK_SELECT
если выполнялась команда SELECT (но не SELECT INTO)
SPI_OK_SELINTO
если выполнялась команда SELECT INTO
SPI_OK_INSERT
если выполнялась команда INSERT
SPI_OK_DELETE
если выполнялась команда DELETE
SPI_OK_UPDATE
если выполнялась команда UPDATE
1230Интерфейс програм-
мирования сервера
SPI_OK_INSERT_RETURNING
если выполнялась команда INSERT RETURNING
SPI_OK_DELETE_RETURNING
если выполнялась команда DELETE RETURNING
SPI_OK_UPDATE_RETURNING
если выполнялась команда UPDATE RETURNING
SPI_OK_UTILITY
если выполнялась служебная команда (например, CREATE TABLE)
SPI_OK_REWRITTEN
если команда была преобразована правилом в команду другого вида (например, UPDATE стал
командой INSERT).
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в качестве command передан NULL или count меньше 0
SPI_ERROR_COPY
при попытке выполнить COPY TO stdout или COPY FROM stdin
SPI_ERROR_TRANSACTION
при попытке выполнить команду управления транзакциями (BEGIN, COMMIT, ROLLBACK,
SAVEPOINT, PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED или любую их вариацию)
SPI_ERROR_OPUNKNOWN
если тип команды неизвестен (такого быть не должно)
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Все функции SPI, выполняющие запросы, заполняют и SPI_processed, и SPI_tuptable (только ука-
затель, но не содержимое структуры). Сохраните эти две глобальные переменные в локальных пе-
ременных функции на C, если хотите обращаться к таблице результата SPI_execute или другой
функции, выполняющей запрос, в нескольких вызовах процедуры.
1231Интерфейс програм-
мирования сервера
SPI_exec
SPI_exec — выполнить команду чтения/записи
Синтаксис
int SPI_exec(const char * command, long count)
Описание
SPI_exec действует подобно SPI_execute, но ей не передаётся параметр read_only (всегда подра-
зумевается false).
Аргументы
const char * command
строка с командой, которая должна быть выполнена
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute.
1232Интерфейс програм-
мирования сервера
SPI_execute_with_args
SPI_execute_with_args — выполнить команду с выделенными параметрами
Синтаксис
int SPI_execute_with_args(const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, long count)
Описание
SPI_execute_with_args выполняет команду, которая может включать ссылки на параметры, пере-
даваемые извне. В тексте команды параметры обозначаются символами $n, а в вызове указывают-
ся типы данных и значения для каждого такого символа. Параметры read_only и count имеют тот
же смысл, что и в SPI_execute.
Основное преимущество этой функции по сравнению с SPI_execute в том, что она позволяет пе-
редавать в команду значения данных, не требуя кропотливой подготовки строк, и таким образом
сокращает риск атак с SQL-инъекцией.
Подобного результата можно достичь, вызвав SPI_prepare и затем SPI_execute_plan; однако с
данной функцией план запроса всегда подстраивается под переданные конкретные значения па-
раметров. Поэтому для разового выполнения запроса рекомендуется применять эту функцию. Ес-
ли же одна и та же команда должна выполняться с самыми разными параметрами, какой вариант
окажется быстрее, будет зависеть от стоимости повторного планирования и выигрыша от выбора
специализированных планов.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_execute_with_args считает, что ни один из параметров не
равен NULL. В противном случае элемент массива nulls должен содержать ‘ ‘, если значение
соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1233Интерфейс програм-
мирования сервера
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1234Интерфейс програм-
мирования сервера
SPI_prepare
SPI_prepare — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare(const char * command, int nargs, Oid * argtypes)
Описание
SPI_prepare создаёт и возвращает подготовленный оператор для заданной команды. Подготовлен-
ный оператор может быть затем неоднократно выполнен функцией SPI_execute_plan.
Когда одна и та же или похожие команды выполняются неоднократно, обычно выгоднее произве-
сти анализ запроса только раз, а ещё выгоднее может быть повторно использовать план выполне-
ния команды. SPI_prepare преобразует строку команды в подготовленный оператор, включающий
в себя результаты анализа запроса. Подготовленный оператор также оставляет место для кеши-
рования плана выполнения, если выбор специализированного плана для каждого выполнения не
принесёт пользы.
Подготавливаемую команду можно сделать более общей, записав параметры ($1, $2, etc.) вместо
значений, задаваемыми константами в обычной команде. Фактические значения параметров в
этом случае будут задаваться при вызове SPI_execute_plan. Это позволяет применять подготов-
ленную команду в более широком круге ситуаций, чем это возможно без параметров.
Оператор, возвращаемый функцией SPI_prepare, может использоваться только в текущем вызове
функции на C, так как SPI_finish освобождает память, выделенную для такого оператора. Но этот
оператор может быть сохранён на будущее с помощью функций SPI_keepplan или SPI_saveplan.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
Возвращаемое значение
SPI_prepare возвращает ненулевой указатель на SPIPlan, скрытую структуру, представляющую
подготовленный оператор. В случае ошибки возвращается NULL, а в SPI_result устанавлива-
ется один из кодов ошибок, определённых для SPI_execute, за исключением того, что код
SPI_ERROR_ARGUMENT устанавливается, когда command — NULL, когда nargs меньше 0 или когда nargs
больше 0, а argtypes — NULL.
Замечания
Если параметры не определены, при первом использовании SPI_execute_plan создаётся общий
план, который затем будет применяться при последующих вызовах. Если же присутствуют пара-
метры, SPI_execute_plan будет создавать специализированные планы для конкретных значений
параметров. После достаточного количества использований полученного подготовленного опера-
тора, функция SPI_execute_plan построит общий план, и если он не будет значительно дороже
специализированных, она начнёт использовать его, а не будет строить план заново. Если это пове-
дение по умолчанию не устраивает, его можно изменить, передав флаг CURSOR_OPT_GENERIC_PLAN
1235Интерфейс програм-
мирования сервера
или CURSOR_OPT_CUSTOM_PLAN в SPI_prepare_cursor, чтобы ограничиться использованием только
общего или специализированных планов, соответственно.
Хотя основной смысл подготовленного оператора в том, чтобы избежать повторного разбора и пла-
нирования запроса, PostgreSQL всё же будет принудительно повторять разбор и планирование за-
проса перед его выполнением, если со времени предыдущего использования подготовленного опе-
ратора произойдут изменения определений (DDL) объектов базы, задействованных в этом запросе.
Также, если перед очередным использованием было изменено значение search_path, запрос будет
разобран заново с новым значением search_path. (Последняя особенность появилась в PostgreSQL
9.3.) Чтобы узнать о поведении подготовленных операторов больше, обратитесь к PREPARE.
Эту функцию следует вызывать только из подключённой функции на C.
SPIPlanPtr объявлен в spi.h как указатель на скрытую структуру. Пытаться обращаться к её со-
держимому напрямую не стоит, так как ваш код скорее всего сломается при выходе новых версий
PostgreSQL.
Имя SPIPlanPtr объясняется отчасти историческими причинами, так как теперь эта структура
может не содержать собственно план выполнения.
1236Интерфейс програм-
мирования сервера
SPI_prepare_cursor
SPI_prepare_cursor — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_cursor(const char * command, int nargs,
Oid * argtypes, int cursorOptions)
Описание
Функция SPI_prepare_cursor равнозначна SPI_prepare, за исключением того, что ей можно пере-
дать «параметры курсора». Эти параметры задаются битовой маской со значениями, определён-
ными в nodes/parsenodes.h для поля options структуры DeclareCursorStmt. SPI_prepare подра-
зумевает, что эти параметры всегда нулевые.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_cursor возвращает результат по тем же соглашениям, что и SPI_prepare.
Замечания
К
числу
полезных
бит,
которые
можно
задать
в
cursorOptions,
относятся
CURSOR_OPT_SCROLL, CURSOR_OPT_NO_SCROLL, CURSOR_OPT_FAST_PLAN, CURSOR_OPT_GENERIC_PLAN и
CURSOR_OPT_CUSTOM_PLAN. Заметьте, что параметр CURSOR_OPT_HOLD игнорируется.
1237Интерфейс програм-
мирования сервера
SPI_prepare_params
SPI_prepare_params — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_params(const char * command,
ParserSetupHook parserSetup,
void * parserSetupArg,
int cursorOptions)
Описание
SPI_prepare_params создаёт и возвращает подготовленный оператор для заданной команды, но не
выполняет саму команду. Эта функция равнозначна SPI_prepare_cursor, но позволяет вызываю-
щему дополнительно установить функции-обработчики для управления разбором ссылок на внеш-
ние параметры.
Аргументы
const char * command
строка команды
ParserSetupHook parserSetup
Функция настройки обработчиков разбора
void * parserSetupArg
аргумент для сквозной передачи в parserSetup
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_params возвращает результат по тем же соглашениям, что и SPI_prepare.
1238Интерфейс програм-
мирования сервера
SPI_getargcount
SPI_getargcount — получить число аргументов, требующихся оператору, подготовленному функ-
цией SPI_prepare
Синтаксис
int SPI_getargcount(SPIPlanPtr plan)
Описание
SPI_getargcount возвращает число аргументов, требующихся для выполнения оператора, подго-
товленного функцией SPI_prepare.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Число аргументов, которое ожидает план, заданный параметром plan. Если значение plan невер-
ное или NULL, в SPI_result устанавливается код SPI_ERROR_ARGUMENT, а функция возвращает -1.
1239Интерфейс програм-
мирования сервера
SPI_getargtypeid
SPI_getargtypeid — получить OID типа аргумента для оператора, подготовленного функцией
SPI_prepare
Синтаксис
Oid SPI_getargtypeid(SPIPlanPtr plan, int argIndex)
Описание
SPI_getargtypeid возвращает OID, представляющий тип аргумента под номером argIndex опера-
тора, подготовленного функцией SPI_prepare. Первый аргумент идёт под номером ноль.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
int argIndex
индекс аргумента, начиная с нуля
Возвращаемое значение
OID типа аргумента с заданным индексом. Если значение plan неверное или NULL, либо argIndex
меньше 0 или не меньше числа аргументов, объявленных при подготовке плана (передаваемого в
plan), в SPI_result устанавливается SPI_ERROR_ARGUMENT и возвращается InvalidOid.
1240Интерфейс програм-
мирования сервера
SPI_is_cursor_plan
SPI_is_cursor_plan — выдать true, если оператор, подготовленный функцией SPI_prepare, можно
использовать с SPI_cursor_open
Синтаксис
bool SPI_is_cursor_plan(SPIPlanPtr plan)
Описание
SPI_is_cursor_plan возвращает true, если оператор, подготовленный функцией SPI_prepare,
можно передать в качестве аргумента SPI_cursor_open, или false в противном случае. Для поло-
жительного ответа в plan должна быть представлена одна команда, и эта команда должна возвра-
щать кортежи; например, SELECT может быть подходящей командой, если он не содержит предло-
жения INTO, а UPDATE подходит, только если он содержит предложение RETURNING.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Значение true или false, показывающее, можно ли для подготовленного оператора, заданного
параметром plan, получить курсор, при SPI_result равном нулю. Если дать ответ невозможно
(например, если значение plan неверное или NULL, либо вызывающий не подключён к SPI), в
SPI_result устанавливается соответствующий код ошибки и возвращается false.
1241Интерфейс програм-
мирования сервера
SPI_execute_plan
SPI_execute_plan — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan(SPIPlanPtr plan, Datum * values, const char * nulls,
bool read_only, long count)
Описание
SPI_execute_plan выполняет оператор, подготовленный функцией SPI_prepare или родственными
ей. Параметры read_only и count имеют тот же смысл, что и в SPI_execute.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execute_plan считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute, со следующими дополнительными вариантами
ошибок (отрицательных результатов):
SPI_ERROR_ARGUMENT
Если plan неверный или NULL, либо count меньше 0
SPI_ERROR_PARAM
Если в values передан NULL и plan был подготовлен с другими параметрами
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1242Интерфейс програм-
мирования сервера
SPI_execute_plan_with_paramlist
SPI_execute_plan_with_paramlist — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan_with_paramlist(SPIPlanPtr plan,
ParamListInfo params,
bool read_only,
long count)
Описание
SPI_execute_plan_with_paramlist выполняет оператор, подготовленный функцией SPI_prepare.
Данная функция равнозначна SPI_execute_plan, не считая того, что информация о значениях па-
раметров, передаваемых запросу, представляется по-другому. Представление ParamListInfo мо-
жет быть удобным для передачи значений, уже имеющих нужный формат. Эта функция также под-
держивает динамические наборы параметров, которые реализуются через функции-обработчики,
устанавливаемые в ParamListInfo.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute_plan, если вызов
был успешным.
1243Интерфейс програм-
мирования сервера
SPI_execp
SPI_execp — выполнить оператор в режиме чтения/записи
Синтаксис
int SPI_execp(SPIPlanPtr plan, Datum * values, const char * nulls, long count)
Описание
SPI_execp действует подобно SPI_execute_plan, но ей не передаётся параметр read_only (всегда
подразумевается false).
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execp считает, что ни один из параметров не равен NULL. В
противном случае элемент массива nulls должен содержать ‘ ‘, если значение соответствую-
щего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем случае значение,
переданное в соответствующем элементе values, не учитывается.) Заметьте, что nulls — это
не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1244Интерфейс програм-
мирования сервера
SPI_cursor_open
SPI_cursor_open — открыть курсор для оператора, созданного функцией SPI_prepare
Синтаксис
Portal SPI_cursor_open(const char * name, SPIPlanPtr plan,
Datum * values, const char * nulls,
bool read_only)
Описание
SPI_cursor_open открывает курсор (внутри называемый порталом), через который будет выпол-
няться оператор, подготовленный функцией SPI_prepare. Параметры этой функции имеют тот же
смысл, что и соответствующие параметры SPI_execute_plan.
Применение курсора по сравнению с непосредственным выполнением оператора даёт двойную
выгоду. Во-первых, строки результата можно получать в небольших количествах, без риска исчер-
пать всю память при выполнении запросов, возвращающих много строк. Во-вторых, портал может
существовать и после завершения текущей функции на C (на самом деле он может просущество-
вать до конца текущей транзакции). Возвратив имя портала в код, вызывающий функцию на C,
можно организовать выдачу результата в виде набора строк.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_cursor_open считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1245Интерфейс програм-
мирования сервера
SPI_cursor_open_with_args
SPI_cursor_open_with_args — открывает курсор для запроса с параметрами
Синтаксис
Portal SPI_cursor_open_with_args(const char *name,
const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, int cursorOptions)
Описание
SPI_cursor_open_with_args открывает курсор (внутри называемый порталом) для выполнения за-
данного запроса. Большинство параметров имеют тот же смысл, что и соответствующие парамет-
ры функций SPI_prepare_cursor и SPI_cursor_open.
Для разового выполнения запроса эту функцию следует предпочесть SPI_prepare_cursor с после-
дующей SPI_cursor_open. Если же одна и та же команда должна выполняться с самыми разными
параметрами, какой вариант окажется быстрее, будет зависеть от стоимости повторного планиро-
вания и выигрыша от выбора специализированных планов.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_cursor_open_with_args считает, что ни один из параметров
не равен NULL. В противном случае, элемент массива nulls должен содержать ‘ ‘, если значе-
ние соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1246Интерфейс програм-
мирования сервера
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1247Интерфейс програм-
мирования сервера
SPI_cursor_open_with_paramlist
SPI_cursor_open_with_paramlist — открыть курсор с параметрами
Синтаксис
Portal SPI_cursor_open_with_paramlist(const char *name,
SPIPlanPtr plan,
ParamListInfo params,
bool read_only)
Описание
SPI_cursor_open_with_paramlist открывает курсор (внутри называемый порталом) для вы-
полнения оператора, подготовленного функцией SPI_prepare. Эта функция равнозначна
SPI_cursor_open, не считая того, что информация о значениях параметров, передаваемых запро-
су, представляется по-другому. Представление ParamListInfo может быть удобным для передачи
значений, уже имеющих нужный формат. Эта функция также поддерживает динамические набо-
ры параметров через функции-обработчики, устанавливаемые в ParamListInfo.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1248Интерфейс програм-
мирования сервера
SPI_cursor_find
SPI_cursor_find — найти существующий курсор по имени
Синтаксис
Portal SPI_cursor_find(const char * name)
Описание
SPI_cursor_find находит существующий портал по имени. В основном это полезно для разреше-
ния имени курсора, возвращённого в текстовом виде какой-то другой функцией.
Аргументы
const char * name
имя портала
Возвращаемое значение
указатель на портал с заданным именем или NULL, если такой портал не найден
1249Интерфейс програм-
мирования сервера
SPI_cursor_fetch
SPI_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_cursor_fetch(Portal portal, bool forward, long count)
Описание
SPI_cursor_fetch выбирает некоторое количество строк через курсор. Эта функция реализует
подмножество возможностей SQL-команды FETCH (расширенную функциональность предоставля-
ет SPI_scroll_cursor_fetch).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для выборки с перемещением вперёд, false — назад
long count
максимальное число строк, которое нужно выбрать
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Выборка назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1250Интерфейс програм-
мирования сервера
SPI_cursor_move
SPI_cursor_move — переместить курсор
Синтаксис
void SPI_cursor_move(Portal portal, bool forward, long count)
Описание
SPI_cursor_move перемещает курсор на несколько строк. Эта функция реализует подмно-
жество возможностей SQL-команды MOVE (расширенную функциональность предоставляет
SPI_scroll_cursor_move).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для перемещения вперёд, false — назад
long count
максимальное число строк, на какое возможно перемещение
Замечания
Перемещение назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1251Интерфейс програм-
мирования сервера
SPI_scroll_cursor_fetch
SPI_scroll_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_scroll_cursor_fetch(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_fetch выбирает некоторое количество строк через курсор. Её функциональ-
ность равнозначна FETCH в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, выбираемых с направлением FETCH_FORWARD или FETCH_BACKWARD; абсолютный но-
мер выбираемой строки с вариантом FETCH_ABSOLUTE; либо относительный номер выбираемой
строки с вариантом FETCH_RELATIVE
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1252Интерфейс програм-
мирования сервера
SPI_scroll_cursor_move
SPI_scroll_cursor_move — переместить курсор
Синтаксис
void SPI_scroll_cursor_move(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_move перемещает курсор на несколько строк. Её функциональность равнознач-
на MOVE в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, на которое сдвигается курсор, с направлением FETCH_FORWARD или FETCH_BACKWARD;
абсолютный номер строки, к которой переходит курсор, с направлением FETCH_ABSOLUTE; либо
относительный номер строки, к которой переходит курсор, с направлением FETCH_RELATIVE
Возвращаемое значение
В случае успеха переменная SPI_processed устанавливается как в SPI_execute. В SPI_tuptable
оказывается NULL, так как эта функция не возвращает никакие строки.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1253Интерфейс програм-
мирования сервера
SPI_cursor_close
SPI_cursor_close — закрыть курсор
Синтаксис
void SPI_cursor_close(Portal portal)
Описание
SPI_cursor_close закрывает ранее созданный курсор и освобождает память, занятую его порта-
лом.
Все открытые курсоры закрываются автоматически в конце транзакции. Вызывать
SPI_cursor_close может потребоваться, только если возникает желание освободить ресурсы ско-
рее.
Аргументы
Portal portal
портал, содержащий курсор
1254Интерфейс програм-
мирования сервера
SPI_keepplan
SPI_keepplan — сохранить подготовленный оператор
Синтаксис
int SPI_keepplan(SPIPlanPtr plan)
Описание
SPI_keepplan закрепляет переданный оператор (подготовленный функцией SPI_prepare), чтобы
он не был ликвидирован функцией SPI_finish или диспетчером транзакций. Это даёт возможность
повторно использовать подготовленные операторы при последующих вызовах вашей функции на
C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
Замечания
Переданный оператор перемещается в постоянное хранилище путём смены указателя (копировать
данные не требуется). Если позже вы захотите удалить его, выполните для него SPI_freeplan.
1255Интерфейс програм-
мирования сервера
SPI_saveplan
SPI_saveplan — сохранить подготовленный оператор
Синтаксис
SPIPlanPtr SPI_saveplan(SPIPlanPtr plan)
Описание
SPI_saveplan копирует переданный оператор (подготовленный функцией SPI_prepare) в память,
чтобы он не был ликвидирован функцией SPI_finish или менеджером транзакций, и возвращает
указатель на скопированный оператор. Это даёт возможность повторно использовать подготовлен-
ные операторы при последующих вызовах вашей функции на C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
Указатель на скопированный оператор, либо NULL в случае ошибки. При ошибке SPI_result при-
нимает одно из этих значений:
SPI_ERROR_ARGUMENT
если plan неверный или NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Изначально переданный оператор не освобождается, поэтому вы можете выполнить SPI_freeplan
для него, чтобы высвободить память до SPI_finish.
В большинстве случаев SPI_keepplan предпочтительнее данной функции, так как она даёт при-
мерно тот же результат, но обходится без физического копирования структур данных подготов-
ленного оператора.
1256Интерфейс програм-
мирования сервера
SPI_register_relation
SPI_register_relation — сделать эфемерное именованное отношение доступным по имени в запросах
SPI
Синтаксис
int SPI_register_relation(EphemeralNamedRelation enr)
Описание
SPI_register_relation делает эфемерное именованное отношение (со связанной информацией)
доступным в запросах, планируемых и выполняемых через текущее подключение SPI.
Аргументы
EphemeralNamedRelation enr
запись эфемерного именованного отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_REGISTER
если отношение было успешно зарегистрировано по имени
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если NULL передан в enr или в поле name
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя, заданное в поле name структуры enr, уже зарегистрировано для этого отношения
1257Интерфейс програм-
мирования сервера
SPI_unregister_relation
SPI_unregister_relation — удалить эфемерное именованное отношение из реестра
Синтаксис
int SPI_unregister_relation(const char * name)
Описание
SPI_unregister_relation удаляет эфемерное именованное отношение из реестра для текущего
подключения.
Аргументы
const char * name
имя записи отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_UNREGISTER
если совокупность кортежей была успешно удалена из реестра
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в name передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_NOT_FOUND
если name не находится в реестре для текущего подключения
1258Интерфейс програм-
мирования сервера
SPI_register_trigger_data
SPI_register_trigger_data — сделать эфемерные данные триггера доступными в запросах SPI
Синтаксис
int SPI_register_trigger_data(TriggerData *tdata)
Описание
SPI_register_trigger_data делает эфемерные отношения, которые перехватывает триггер, до-
ступными для запросов, планируемых и выполняемых через текущее подключение SPI. В настоя-
щее время это переходные таблицы, перехватываемые триггером AFTER, определённым с предло-
жением REFERENCING OLD/NEW TABLE AS. Эта функция должна вызываться функцией, реализующей
триггер на языке программирования, после подключения.
Аргументы
TriggerData *tdata
объект TriggerData, передаваемый функцией, реализующей триггер, через fcinfo-&gt;context
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_TD_REGISTER
если перехваченные данные триггера (при наличии) были успешно зарегистрированы
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в tdata передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя в любом из переходных отношений в данных триггера уже зарегистрировано для этого
подключения
47.2. Вспомогательные интерфейсные функции
Функции, описанные здесь, предоставляют возможности для извлечения информации из наборов
результатов, возвращаемых SPI_execute и другими функциями SPI.
Все функции, описанные в этом разделе, могут использоваться и в подключённых, и в неподклю-
чённых функциях на C.
1259Интерфейс програм-
мирования сервера
SPI_fname
SPI_fname — определить имя столбца с заданным номером
Синтаксис
char * SPI_fname(TupleDesc rowdesc, int colnumber)
Описание
SPI_fname возвращает копию имени столбца с заданным номером. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя столбца; NULL, если colnumber вне допустимого диапазона. В случае ошибки в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1260Интерфейс програм-
мирования сервера
SPI_fnumber
SPI_fnumber — определить номер столбца с заданным именем
Синтаксис
int SPI_fnumber(TupleDesc rowdesc, const char * colname)
Описание
SPI_fnumber возвращает номер столбца, имеющего заданное имя.
Если colname ссылается на системный столбец (например, oid), возвращается соответствующий
отрицательный номер столбца. Вызывающий должен проверять, не была ли возвращена ошибка,
сравнивая значение результата именно с SPI_ERROR_NOATTRIBUTE; проверка результата по условию
меньше или равно нулю не будет корректной, если только системные столбцы не должны исклю-
чаться.
Аргументы
TupleDesc rowdesc
описание строк
const char * colname
имя столбца
Возвращаемое значение
Номер
столбца
(начиная
с
1
для
столбцов,
создаваемых
SPI_ERROR_NOATTRIBUTE, если столбец с заданным именем не найден.
1261
пользователем),
либоИнтерфейс програм-
мирования сервера
SPI_getvalue
SPI_getvalue — получить строковое значение указанного столбца
Синтаксис
char * SPI_getvalue(HeapTuple row, TupleDesc rowdesc, int colnumber)
Описание
SPI_getvalue возвращает строковое представление значения указанного столбца.
Результат возвращается в памяти, размещённой функцией palloc. (Когда он будет не нужен, эту
память можно освободить с помощью pfree.)
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Значение столбца, либо NULL, если столбец содержит NULL, colnumber вне допустимого диапазона
(в SPI_result при этом устанавливается SPI_ERROR_NOATTRIBUTE) или если отсутствует функция
вывода (в SPI_result устанавливается SPI_ERROR_NOOUTFUNC).
1262Интерфейс програм-
мирования сервера
SPI_getbinval
SPI_getbinval — получить двоичное значение указанного столбца
Синтаксис
Datum SPI_getbinval(HeapTuple row, TupleDesc rowdesc, int colnumber,
bool * isnull)
Описание
SPI_getbinval возвращает значение указанного столбца во внутренней форме (в структуре Datum).
Эта функция не выделяет новый блок памяти для данных. В случае с типом, передаваемым по
ссылке, возвращаемым значением будет указатель на переданную строку данных.
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
bool * isnull
признак того, что столбец содержит NULL
Возвращаемое значение
Возвращается двоичное значение столбца. Если этот столбец содержит NULL, переменной, на ко-
торую указывает isnull, присваивается true; в противном случае — false.
При ошибке в SPI_result устанавливается SPI_ERROR_NOATTRIBUTE.
1263Интерфейс програм-
мирования сервера
SPI_gettype
SPI_gettype — получить имя типа данных указанного столбца
Синтаксис
char * SPI_gettype(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettype возвращает копию имени типа данных указанного столбца. (Когда эта копия имени
будет не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя типа данных указанного столбца, либо NULL в случае ошибки. При ошибке в SPI_result уста-
навливается SPI_ERROR_NOATTRIBUTE.
1264Интерфейс програм-
мирования сервера
SPI_gettypeid
SPI_gettypeid — получить OID типа данных указанного столбца
Синтаксис
Oid SPI_gettypeid(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettypeid возвращает OID типа данных указанного столбца.
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
OID типа данных указанного столбца, либо InvalidOid в случае ошибки. При ошибке в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1265Интерфейс програм-
мирования сервера
SPI_getrelname
SPI_getrelname — возвращает имя указанного отношения
Синтаксис
char * SPI_getrelname(Relation rel)
Описание
SPI_getrelname возвращает копию имени указанного отношения. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя указанного отношения.
1266Интерфейс програм-
мирования сервера
SPI_getnspname
SPI_getnspname — возвращает пространство имён указанного отношения
Синтаксис
char * SPI_getnspname(Relation rel)
Описание
SPI_getnspname возвращает копию имени пространства имён, к которому принадлежит указанное
отношение (Relation). Пространство имён по-другому называется схемой отношения. Когда зна-
чение, возвращённое этой функцией, будет не нужно, освободите его с помощью pfree.
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя пространства имён указанного отношения.
1267Интерфейс програм-
мирования сервера
SPI_result_code_string
SPI_result_code_string — возвращает код ошибки в виде строки
Синтаксис
const char * SPI_result_code_string(int code);
Описание
SPI_result_code_string выдаёт строковое представление для кода результата, который возвра-
щается различными функциями SPI или находится в SPI_result.
Аргументы
int code
код результата
Возвращаемое значение
Строковое представление кода результата.
47.3. Управление памятью
PostgreSQL выделяет память в контекстах памяти, и тем самым реализует удобный способ управ-
ления выделением памяти в различных местах, с разными сроками жизни выделенной памяти.
При уничтожении контекста освобождается вся выделенная в нём память. Таким образом, нет
необходимости контролировать каждый отдельный объект во избежание утечек памяти; вместо
этого достаточно управлять только небольшим числом контекстов. Функция palloc и родственные
ей освобождают память из «текущего» контекста.
SPI_connect создаёт новый контекст памяти и делает его текущим. SPI_finish восстанавли-
вает контекст, который был текущим до этого, и уничтожает контекст, созданный функцией
SPI_connect. Эти действия обеспечивают при выходе из вашей функции на C освобождение вре-
менной памяти, выделенной внутри этой функции, во избежание утечки памяти.
Однако если ваша функция на C должна вернуть объект в выделенной памяти (как значение ти-
па, передаваемого по ссылке), эту память нельзя выделять через palloc, как минимум пока уста-
новлено подключение к SPI. Если вы попытаетесь это сделать, объект будет освобождён при вы-
зове SPI_finish и ваша функция не будет работать надёжно. Для решения этой проблемы выде-
ляйте память для возвращаемого объекта, используя SPI_palloc. SPI_palloc выделяет память в
«верхнем контексте исполнителя», то есть, в контексте памяти, который был текущим при вызо-
ве SPI_connect; именно этот контекст подходит для значения, возвращаемого из функции на C.
Некоторые из вспомогательных функций, описанных в этом разделе, также возвращают объекты,
созданные в верхнем контексте исполнителя.
Когда вызывается SPI_connect, текущим контекстом становится частный контекст функции на C,
создаваемый в SPI_connect. Все операции выделения памяти, выполняемые функциями palloc,
repalloc или служебными функциями SPI (кроме описанных в этом разделе исключений), произво-
дятся в этом контексте. Когда функция на C отключается от менеджера SPI (выполняя SPI_finish),
текущим контекстом снова становится верхний контекст исполнителя, а вся память, выделенная
в контексте этой функции, освобождается, так что использовать её дальше нельзя.
1268Интерфейс програм-
мирования сервера
SPI_palloc
SPI_palloc — выделить память в верхнем контексте исполнителя
Синтаксис
void * SPI_palloc(Size size)
Описание
SPI_palloc выделяет память в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она выдаёт ошибку.
Аргументы
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на выделенный блок памяти заданного размера
1269Интерфейс програм-
мирования сервера
SPI_repalloc
SPI_repalloc — поменять блок памяти в верхнем контексте исполнителя
Синтаксис
void * SPI_repalloc(void * pointer, Size size)
Описание
SPI_repalloc изменяет размер блока памяти, ранее выделенного функцией SPI_palloc.
Эта функция теперь не отличается от простой repalloc. Она сохранена только для обратной сов-
местимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий изменению
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на новый блок памяти указанного размера, в который скопировано содержимое преж-
него блока
1270Интерфейс програм-
мирования сервера
SPI_pfree
SPI_pfree — освободить память в верхнем контексте исполнителя
Синтаксис
void SPI_pfree(void * pointer)
Описание
SPI_pfree освобождает память, ранее выделенную функцией SPI_palloc или SPI_repalloc.
Эта функция теперь не отличается от простой pfree. Она сохранена только для обратной совме-
стимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий освобождению
1271Интерфейс програм-
мирования сервера
SPI_copytuple
SPI_copytuple — скопировать строку в верхнем контексте исполнителя
Синтаксис
HeapTuple SPI_copytuple(HeapTuple row)
Описание
SPI_copytuple делает копию строки в верхнем контексте исполнителя. Обычно это применяется,
когда нужно вернуть изменённую строку из триггера. В функции, которая должна возвращать со-
ставной тип, нужно использовать SPI_returntuple.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
HeapTuple row
строка, подлежащая копированию
Возвращаемое значение
скопированная строка либо NULL в случае ошибки (SPI_result содержит код ошибки)
1272Интерфейс програм-
мирования сервера
SPI_returntuple
SPI_returntuple — подготовить строку для возврата в виде Datum
Синтаксис
HeapTupleHeader SPI_returntuple(HeapTuple row, TupleDesc rowdesc)
Описание
SPI_returntuple делает копию строки в верхнем контексте исполнителя и возвращает её в форме
типа Datum. Чтобы выдать результат, полученный указатель остаётся только преобразовать в Datum
функцией PointerGetDatum.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Заметьте, что эту операцию следует применять в функциях, объявленных как возвращающие со-
ставные типы. В триггерах она не применяется; чтобы вернуть изменённую строку из триггера,
используйте SPI_copytuple.
Аргументы
HeapTuple row
строка, подлежащая копированию
TupleDesc rowdesc
дескриптор строки (передавайте каждый раз один дескриптор для более эффективного кеши-
рования)
Возвращаемое значение
HeapTupleHeader, указывающий на скопированную строку, или NULL в случае ошибки (SPI_result
содержит код ошибки)
1273Интерфейс програм-
мирования сервера
SPI_modifytuple
SPI_modifytuple — создать строку, заменяя отдельные поля в данной
Синтаксис
HeapTuple SPI_modifytuple(Relation rel, HeapTuple row, int ncols,
int * colnum, Datum * values, const char * nulls)
Описание
SPI_modifytuple создаёт новую строку, подставляя новые значения для указанных столбцов и ко-
пируя исходное содержимое остальных столбцов. Исходная строка не изменяется. Новая строка
возвращается в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
Relation rel
Используется только в качестве дескриптора строки. (Передача отношения вместо собственно
дескриптора строки — нехорошая особенность.)
HeapTuple row
строка, подлежащая изменению
int ncols
число изменяемых столбцов
int * colnum
массив длины ncols, содержащий номера изменяемых столбцов (начиная с 1)
Datum * values
массив длины ncols, содержащий новые значения указанных столбцов
const char * nulls
массив длины ncols, описывающий, в каких столбцах передаётся NULL
Если в nulls передаётся NULL, SPI_modifytuple считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль ‘\0’ в конце не нужен.
Возвращаемое значение
новая строка с изменениями, размещённая в верхнем контексте исполнителя, или NULL при ошибке
(SPI_result содержит код ошибки)
В случае ошибки в SPI_result устанавливается:
SPI_ERROR_ARGUMENT
если rel — NULL, либо row — NULL, либо ncols меньше или равно 0, либо colnum — NULL, либо
values — NULL
1274Интерфейс програм-
мирования сервера
SPI_ERROR_NOATTRIBUTE
если colnum содержит недопустимый номер столбца (меньше или равен 0, либо больше числа
столбцов в строке row)
SPI_ERROR_UNCONNECTED
если SPI неактивен
1275Интерфейс програм-
мирования сервера
SPI_freetuple
SPI_freetuple — освободить строку, размещённую в верхнем контексте исполнителя
Синтаксис
void SPI_freetuple(HeapTuple row)
Описание
SPI_freetuple освобождает строку, ранее размещённую в верхнем контексте исполнителя.
Эта функция теперь не отличается от простой heap_freetuple. Она сохранена только для обратной
совместимости с существующим кодом.
Аргументы
HeapTuple row
строка, подлежащая освобождению
1276Интерфейс програм-
мирования сервера
SPI_freetuptable
SPI_freetuptable — освободить набор строк, созданный SPI_execute или подобной функцией
Синтаксис
void SPI_freetuptable(SPITupleTable * tuptable)
Описание
SPI_freetuptable освобождает набор строк, созданных предыдущей функцией SPI выполнения ко-
манд, например SPI_execute. Таким образом, при вызове этой функции в качестве аргумента часто
передаётся глобальная переменная SPI_tuptable.
Эта функция полезна, когда функция на C, использующая SPI, должна выполнить несколько ко-
манд, но не хочет сохранять результаты предыдущих команд до завершения. Заметьте, что любые
не освобождённые таким образом наборы строк будут всё равно освобождены при выполнении
SPI_finish. Кроме того, если была запущена подтранзакция, а затем она прервалась в ходе выпол-
нения использующей SPI функции, все наборы строк, созданные в рамках подтранзакции, будут
автоматически освобождены.
Начиная с PostgreSQL версии 9.3, SPI_freetuptable содержит защитную логику, отфильтровыва-
ющую повторные запросы на удаление одного и того же набора строк. В предыдущих версиях по-
вторное удаление могло приводить к сбоям.
Аргументы
SPITupleTable * tuptable
указатель на набор строк, который нужно освободить (если NULL, ничего не происходит)
1277Интерфейс програм-
мирования сервера
SPI_freeplan
SPI_freeplan — освободить ранее сохранённый подготовленный оператор
Синтаксис
int SPI_freeplan(SPIPlanPtr plan)
Описание
SPI_freeplan освобождает подготовленный оператор, до этого выданный функцией SPI_prepare
или сохранённый функциями SPI_keepplan и SPI_saveplan.
Аргументы
SPIPlanPtr plan
указатель на оператор, подлежащий освобождению
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
47.4. Управление транзакциями
Выполнять команды управления транзакциями (в частности, COMMIT и ROLLBACK) через функции
SPI, такие как SPI_execute, нельзя. Однако имеются отдельные интерфейсные функции, которые
предназначены для управления транзакциями через SPI.
Вообще говоря, не всегда безопасно и разумно начинать и заканчивать транзакции в произволь-
ных определяемых пользователями функциях, вызываемых из SQL, не принимая во внимание кон-
текст их вызова. Например, завершение транзакции в середине функции, вызванной в сложном
SQL-выражении внутри некоторой SQL-команды, скорее всего приведёт к странным внутренним
ошибкам или сбоям. Представленные здесь интерфейсные функции прежде всего предназначены
для использования реализациями процедурных языков с целью управления транзакциями в про-
цедурах уровня SQL, вызываемых командой CALL (при этом учитывается её контекст). Та же логи-
ка может быть реализована в процедурах на C, использующих SPI, но подробное освещение этой
темы выходит за рамки данной документации.
1278Интерфейс програм-
мирования сервера
SPI_commit
SPI_commit — зафиксировать текущую транзакцию
Синтаксис
void SPI_commit(void)
Описание
SPI_commit фиксирует текущую транзакцию. Это примерно равносильно выполнению SQL-коман-
ды COMMIT. После того как транзакция зафиксирована, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1279Интерфейс програм-
мирования сервера
SPI_rollback
SPI_rollback — прервать текущую транзакцию
Синтаксис
void SPI_rollback(void)
Описание
SPI_rollback откатывает текущую транзакцию. Это примерно равносильно выполнению SQL-ко-
манды ROLLBACK. После того как транзакция отменена, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1280Интерфейс програм-
мирования сервера
SPI_start_transaction
SPI_start_transaction — начать новую транзакцию
Синтаксис
void SPI_start_transaction(void)
Описание
Функция SPI_start_transaction начинает новую транзакцию. Она может вызываться только по-
сле SPI_commit или SPI_rollback, когда нет активной транзакции. Обычно, когда вызывается про-
цедура, использующая SPI, транзакция уже выполняется, поэтому при попытке начать ещё одну
до завершения текущей возникнет ошибка.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
47.5. Видимость изменений в данных
Видимость изменений в данных, которые производятся функциями, использующими SPI, (или лю-
быми другими функциями на C), описывается следующими правилами:
• В процессе выполнения SQL-команды любые произведённые ей изменения не видны для неё
самой. Например, в команде:
INSERT INTO a SELECT * FROM a;
вставляемые строки не видны в части SELECT.
• Изменения, произведённые командой К, видны во всех командах, запущенных после К, неза-
висимо от того, были ли эти команды запущены из К (во время выполнения К) или после за-
вершения К.
• Команды, выполняемые через SPI внутри функции, вызванной SQL-командой (будь то обычная
функция или триггер), следуют одному или другому из вышеприведённых правил в зависи-
мости флага чтения/записи, переданного SPI. Команды, выполняемые в режиме «только чте-
ние», следует первому правилу: они не видят изменений, произведённых вызывающей коман-
дой. Команды, выполняемые в режиме «чтение-запись», следуют второму правилу: они могут
видеть все произведённые к этому времени изменения.
• Все стандартные процедурные языки устанавливают режим чтения-записи в SPI в зависимо-
сти от атрибута изменчивости функции. Команды функций STABLE и IMMUTABLE выполняются в
режиме «только чтение», тогда как команды функций VOLATILE — в режиме «чтение-запись».
Хотя авторы функций на C могут нарушить это соглашение, вряд ли это будет хорошей идеей.
В следующем разделе приводится пример, иллюстрирующий применение этих правил.
47.6. Примеры
Этот раздел содержит очень простой пример использования SPI. Функция execq принимает в ка-
честве первого аргумента команду SQL, а в качестве второго число строк, выполняет команду, вы-
зывая SPI_exec, и возвращает число строк, обработанных этой командой. Более сложные примеры
работы с SPI вы можете найти в src/test/regress/regress.c в дереве исходного кода, а также в
модуле spi.
#include “postgres.h”
1281Интерфейс програм-
мирования сервера
#include “executor/spi.h”
#include “utils/builtins.h”
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(execq);
Datum
execq(PG_FUNCTION_ARGS)
{
char *command;
int cnt;
int ret;
uint64 proc;
/</em> Преобразовать данный текстовый объект в строку C <em>/
command = text_to_cstring(PG_GETARG_TEXT_PP(1));
cnt = PG_GETARG_INT32(2);
SPI_connect();
ret = SPI_exec(command, cnt);
proc = SPI_processed;
/</em></p>
<ul>
  <li>Если были выбраны какие-то строки, вывести их через elog(INFO).
*/
if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
{
TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
SPITupleTable *tuptable = SPI_tuptable;
char buf[8192];
uint64 j;
for (j = 0; j &lt; proc; j++)
{
HeapTuple tuple = tuptable-&gt;vals[j];
int i;
for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), “ %s%s”,
SPI_getvalue(tuple, tupdesc, i),
(i == tupdesc-&gt;natts) ? “ “ : “ |”);
elog(INFO, “EXECQ: %s”, buf);
}
}
SPI_finish();
pfree(command);
PG_RETURN_INT64(proc);
}
Так эта функция будет объявляться после того, как она будет скомпилирована в разделяемую биб-
лиотеку (подробности в Подразделе 38.10.5):
CREATE FUNCTION execq(text, integer) RETURNS int8
AS ‘имя_файла’
LANGUAGE C STRICT;
1282Интерфейс програм-
мирования сервера
Демонстрация использования:
=&gt; SELECT execq(‘CREATE TABLE a (x integer)’, 0);
execq
——-
0
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘INSERT INTO a VALUES (0)’, 0));
INSERT 0 1
=&gt; SELECT execq(‘SELECT * FROM a’, 0);
INFO: EXECQ: 0
– вставлено функцией execq
INFO: EXECQ: 1
– возвращено функцией execq и вставлено командой INSERT
execq
——-
2
(1 row)
=&gt; SELECT execq(‘INSERT INTO a SELECT x + 2 FROM a’, 1);
execq
——-
1
(1 row)
=&gt; SELECT execq(‘SELECT * FROM a’, 10);
INFO: EXECQ: 0
INFO: EXECQ: 1
INFO: EXECQ: 2
– 0 + 2, вставлена только одна строка - как указано
execq
——-
3
(1 row)
– 10 — только максимальное значение, 3 — реальное число строк
=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
– нет строк в a (0) + 1
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INFO: EXECQ: 1
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
2
– была одна строка в a + 1
(2 rows)
– Этот пример демонстрирует правило видимости изменений в данных:
=&gt; INSERT INTO a SELECT execq(‘SELECT * FROM a’, 0) * x FROM a;
1283Интерфейс програм-
мирования сервера
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 2
INSERT 0 2
=&gt; SELECT * FROM a;
x
—
1
2
2
– 2 строки * 1 (x в первой в строке)
6
– 3 строки (2 + 1 только вставленная) * 2 (x во второй строке)
(4 rows)
^^^^^^
строки, видимые в execq() при разных вызовах
1284</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" title="Глава 46. PL/Python — процедурный язык Python"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 46. PL/Python — процедурный язык Python"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-046/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" rel="bookmark" title="Глава 46. PL/Python — процедурный язык Python" itemprop="url">Глава 46. PL/Python — процедурный язык Python</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 46. PL/Python — процедурный язык Python</p>

<p>Процедурный язык PL/Python позволяет писать функции PostgreSQL на языке Python.
Чтобы установить PL/Python в определённую базу данных, выполните команду CREATE EXTENSION
plpythonu (но смотрите также Раздел 46.1).
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
PL/Python представлен только в виде «недоверенного» языка, что означает, что он никаким спо-
собом не ограничивает действия пользователей, и поэтому он называется plpythonu. Доверенная
вариация plpython может появиться в будущем, если в Python будет разработан безопасный меха-
низм выполнения. Автор функции на недоверенном языке PL/Python должен позаботиться о том,
чтобы эту функцию нельзя было использовать не по назначению, так как она может делать всё, что
может пользователь с правами администратора баз данных. Создавать функции на недоверенных
языках, таких как plpythonu, разрешено только суперпользователям.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Python в процессе установки. (За дополнительными сведениями обратитесь к инструк-
циям по установке.) Пользователи двоичных пакетов могут найти PL/Python в отдель-
ном модуле.
46.1. Python 2 и Python 3
PL/Python поддерживает две вариации языка: Python 2 и Python 3. (Более точная информация о
поддерживаемых второстепенных версиях Python может содержаться в инструкциях по установке
PostgreSQL.) Так как языки Python 2 и Python 3 несовместимы в некоторых важных аспектах, во
избежание смешения их в PL/Python применяется следующая схема именования:
• Язык PostgreSQL с именем plpython2u представляет реализацию PL/Python, основанную на ва-
риации языка Python 2.
• Язык PostgreSQL с именем plpython3u представляет реализацию PL/Python, основанную на ва-
риации языка Python 3.
• Язык с именем plpythonu представляет реализацию PL/Python, основанную на версии Python
по умолчанию, в данный момент это Python 2. (Этот выбор по умолчанию не зависит от того,
какая версия считается локальной версией «по умолчанию», например, на какую версию ука-
зывает /usr/bin/python.) Выбор по умолчанию в отдалённом будущем выпуске PostgreSQL
может быть сменён на Python 3, в зависимости от того, как будет происходить переход на
Python 3 в сообществе Python.
Эта схема аналогична рекомендациям, данным в PEP 394, по выбору имени команды python и
переходу с версии на версию.
Будет ли доступен PL/Python для Python 2 или для Python 3, либо сразу для обеих версий, зависит
от конфигурации сборки или установленных пакетов.
1210PL/Python — проце-
дурный язык Python
Подсказка
Какая вариация будет собрана, зависит от того, как версия Python будет найдена при
установке или будет задана в переменной окружения PYTHON; см. Раздел 16.4. Чтобы в
одной инсталляции присутствовали обе вариации PL/Python, необходимо сконфигури-
ровать и настроить дерево исходного кода дважды.
В результате формируется такая стратегия использования и смены определённой версии:
• Существующие пользователи и пользователи, которым в настоящее время неинтересен Python
3, могут выбрать имя языка plpythonu и им не придётся ничего менять в обозримом будущем.
Чтобы упростить миграцию на Python 3, которая произойдёт в конце концов, рекомендуется
постепенно проверять «готовность к будущему» кода, обновляя его до версий Python 2.6/2.7.
На практике многие функции PL/Python можно мигрировать на Python 3 с минимальными из-
менениями или вовсе без изменений.
• Пользователи, знающие, что их код очень сильно зависит от Python 2, и не планирующие ко-
гда-либо менять его, могут использовать имя языка plpython2u. Это будет работать ещё очень
и очень долго, пока в PostgreSQL не будет полностью ликвидирована поддержка Python 2.
• Пользователи, желающие погрузиться в Python 3, могут выбрать имя языка plpython3u, и их
код будет работать всегда, по сегодняшним стандартам. В отдалённом будущем, когда верси-
ей по умолчанию может стать Python 3, цифру «3» из имени языка можно будет убрать из эс-
тетических соображений.
• Смельчаки, желающие уже сегодня получить операционное окружение только с Python 3, мо-
гут модифицировать pg_pltemplate, чтобы имя plpythonu было равнозначно plpython3u, отда-
вая себе отчёт в том, что такая инсталляция будет несовместима с остальным миром.
Дополнительную информацию о переходе на Python 3 можно также найти в описании Что нового
в Python 3.0.
Использовать PL/Python на базе Python 2 и PL/Python на базе Python 3 в одном сеансе нельзя, так
как это приведёт к конфликту символов в динамических модулях, что может повлечь сбой сервер-
ного процесса PostgreSQL. В системе есть проверка, предотвращающая смешение основных вер-
сий Python в одном сеансе, которая прервёт сеанс при выявлении расхождения. Однако использо-
вать обе вариации в одной базе данных всё же возможно, обращаясь к ним в разных сеансах.
46.2. Функции на PL/Python
Функции на PL/Python объявляются стандартным образом с помощью команды CREATE FUNCTION:
CREATE FUNCTION funcname (argument-list)
RETURNS return-type
AS $$</p>
<h1 id="Тело-функции-на-plpython">Тело функции на PL/Python</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Тело функции содержит просто скрипт на языке Python. Когда вызывается функция, её аргументы
передаются в виде элементов списка args; именованные аргументы также передаются скрипту
Python как обычные переменные. С именованными аргументами скрипт обычно лучше читается.
Результат из кода Python возвращается обычным способом: командой return или yield (в случае
функции, возвращающей множество). Если возвращаемое значение не определено, Python возвра-
щает None. Исполнитель PL/Python преобразует None языка Python в значение NULL языка SQL.
В процедуре код Python должен возвращать None (обычно для этого процедура завершается без
оператора return или используется оператор return без аргумента); в противном случае выдаётся
ошибка.
Например, функцию, возвращающее большее из двух целых чисел, можно определить так:
1211PL/Python — проце-
дурный язык Python
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS</script>
if a &gt; b:
return a
return b
<script type="math/tex">LANGUAGE plpythonu;
Код на Python, заданный в качестве тела объявляемой функции, становится телом функции Python.
Например, для показанного выше объявления получается функция:
def __plpython_procedure_pymax_23456():
if a > b:
return a
return b
Здесь 23456 — это OID, который PostgreSQL присвоил данной функции.
Значения аргументов задаются в глобальных переменных. Согласно правилам видимости в Python,
тонким следствием этого является то, что переменной аргумента нельзя присвоить внутри функ-
ции выражение, включающее имя самой этой переменной, если только эта переменная не объяв-
лена глобальной в текущем блоке. Например, следующий код не будет работать:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS</script>
x = x.strip() # ошибка
return x
<script type="math/tex">LANGUAGE plpythonu;
так как присвоение x значения делает x локальной переменной для всего блока, и при этом x
в правой части присваивания оказывается ещё не определённой локальной переменной x, а не
параметром функции PL/Python. Добавив оператор global, это можно исправить:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS</script>
global x
x = x.strip() # теперь всё в порядке
return x
<script type="math/tex">LANGUAGE plpythonu;
Однако рекомендуется не полагаться на такие особенности реализации PL/Python, а принять, что
параметры функции предназначены только для чтения.
46.3. Значения данных
Вообще говоря, цель исполнителя PL/Python — обеспечить «естественное» соответствие между
мирами PostgreSQL и Python. Этим объясняется выбор правил сопоставления данных, описанных
ниже.
46.3.1. Сопоставление типов данных
Когда вызывается функция PL/Python, её аргументы преобразуются из типа PostgreSQL в соответ-
ствующий тип Python по таким правилам:
• Тип PostgreSQL boolean преобразуется в bool языка Python.
• Типы PostgreSQL smallint и int преобразуются в тип int языка Python. Типы PostgreSQL
bigint и oid становятся типами long в Python 2 и int в Python 3.
• Типы PostgreSQL real и double преобразуются в тип float языка Python.
• Тип PostgreSQL numeric преобразуется в Decimal среды Python. Этот тип импортируется из
пакета cdecimal, при его наличии. В противном случае используется decimal.Decimal из
1212PL/Python — проце-
дурный язык Python
стандартной библиотеки. Тип cdecimal работает значительно быстрее, чем decimal. Однако
в Python версии 3.3 и выше тип cdecimal включается в стандартную библиотеку под именем
decimal, так что теперь этого различия нет.
• Тип PostgreSQL bytea становится типом str в Python 2 и bytes в Python 3. В Python 2 такую
строку следует воспринимать как последовательность байт без какой-либо определённой ко-
дировки символов.
• Все другие типы данных, включая типы символьных строк PostgreSQL, преобразуются в тип
str языка Python. В Python 2 эта строка будет передаваться в кодировке сервера PostgreSQL; в
Python 3 это будет строка в Unicode, как и все строки.
• Информация о нескалярных типах данных приведена ниже.
При завершении функции PL/Python её значение результата преобразуется в тип данных, объяв-
ленный как тип результата в PostgreSQL, следующим образом:
• Когда тип результата функции в PostgreSQL — boolean, возвращаемое значение приводится к
логическому типу по правилам, принятым в Python. То есть false будет возвращено для 0 и пу-
стой строки, но, обратите внимание, для 'f' будет возвращено true.
• Когда тип результата функции PostgreSQL — bytea, возвращаемое значение будет преобразо-
вано в строку (Python 2) или набор байт (Python 3), используя встроенные средства Python, а
затем будет приведено к типу bytea.
• Для всех других типов результата PostgreSQL возвращаемое значение преобразуется в строку
с помощью встроенной в Python функции str, и полученная строка передаётся функции ввода
типа данных PostgreSQL. (Если значение в Python имеет тип float, оно преобразуется встро-
енной функцией repr, а не str, для недопущения потери точности.)
Из кода Python 2 строки должны передаваться в PostgreSQL в кодировке сервера PostgreSQL.
При передаче строки, неприемлемой для текущей кодировки сервера, возникает ошибка, но
не все несоответствия кодировки могут быть выявлены, так что с некорректной кодировкой
всё же могут быть получены нечитаемые строки. Строки Unicode переводятся в нужную коди-
ровку автоматически, так что использовать их может быть безопаснее и удобнее. В Python 3
все строки имеют кодировку Unicode.
• Информация о нескалярных типах данных приведена ниже.
Заметьте, что логические несоответствия между объявленным в PostgreSQL типом результата и
типом фактически возвращаемого объекта Python игнорируются — значение преобразуется в лю-
бом случае.
46.3.2. Null, None
Если функции передаётся значение SQL NULL, в Python значением этого аргумента будет None.
Например, функция pymax, определённая как показано в Раздел 46.2, возвратит неверный ответ,
получив аргументы NULL. Мы могли бы добавить указание STRICT в определение функции, чтобы
PostgreSQL поступал немного разумнее: при передаче значения NULL функция вовсе не будет
вызываться, будет сразу возвращён результат NULL. С другой стороны, мы могли бы проверить
аргументы на NULL в теле функции:
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS</script>
if (a is None) or (b is None):
return None
if a &gt; b:
return a
return b
<script type="math/tex">LANGUAGE plpythonu;
Как показано выше, чтобы выдать из функции PL/Python значение SQL NULL, нужно вернуть зна-
чение None. Это можно сделать и в строгой, и в нестрогой функции.
1213PL/Python — проце-
дурный язык Python
46.3.3. Массивы, списки
Значения массивов SQL передаются в PL/Python в виде списка Python. Чтобы вернуть значение
массива SQL из функции PL/Python, возвратите список Python:
CREATE FUNCTION return_arr()
RETURNS int[]
AS</script>
return [1, 2, 3, 4, 5]
<script type="math/tex">LANGUAGE plpythonu;
SELECT return_arr();
return_arr
-------------
(1,2,3,4,5)
(1 row)
Многомерные массивы передаются в PL/Python в виде вложенных списков Python. Например, двух-
мерный массив представляется как список списков. При передаче многомерного массива SQL из
функции PL/Python необходимо, чтобы все внутренние списки на каждом уровне имели одинако-
вый размер. Например:
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS</script>
plpy.info(x, type(x))
return x
<script type="math/tex">% <![CDATA[
LANGUAGE plpythonu;
SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO: ([[1, 2, 3], [4, 5, 6]], <type 'list'>)
test_type_conversion_array_int4
---------------------------------
((1,2,3),(4,5,6))
(1 row)
Другие последовательности Python, например кортежи, тоже принимаются для обратной совме-
стимости с PostgreSQL версии 9.6 и ниже (где многомерные массивы не поддерживались). Однако
они всегда воспринимаются как одномерные массивы, чтобы не возникало неоднозначности с со-
ставными типами. По этой же причине когда в многомерном массиве используется составной тип,
он должен представляться как кортеж, а не список.
Учтите, что в Python и строки являются последовательностями, что может давать неожиданные
эффекты, хорошо знакомые тем, кто программирует на Python:
CREATE FUNCTION return_str_arr()
RETURNS varchar[]
AS %]]></script>
return “hello”
<script type="math/tex">LANGUAGE plpythonu;
SELECT return_str_arr();
return_str_arr
----------------
(h,e,l,l,o)
(1 row)
46.3.4. Составные типы
Аргументы составного типа передаются функции в виде сопоставлений Python. Именами элемен-
тов сопоставления являются атрибуты составного типа. Если атрибут в переданной строке имеет
значение NULL, он передаётся в сопоставлении значением None. Пример работы с составным ти-
пом:
1214PL/Python — проце-
дурный язык Python
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid (e employee)
RETURNS boolean
AS</script>
if e[“salary”] &gt; 200000:
return True
if (e[“age”] &lt; 30) and (e[“salary”] &gt; 100000):
return True
return False
<script type="math/tex">LANGUAGE plpythonu;
Возвратить составной тип или строку таблицы из функции Python можно несколькими способами.
В следующих примерах предполагается, что у нас объявлен тип:
CREATE TYPE named_value AS (
name
text,
value integer
);
Результат этого типа можно вернуть как:
Последовательность (кортеж или список, но не множество, так как оно не индексируется)
В возвращаемых объектах последовательностей должно быть столько элементов, сколько полей
в составном типе результата. Элемент с индексом 0 присваивается первому полю составного
типа, с индексом 1 — второму и т. д. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
return ( name, value )</p>
<h1 id="или-альтернативный-вариант-в-виде-кортежа-return--name-value-">или альтернативный вариант, в виде кортежа: return [ name, value ]</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте в соответствующую позицию None.
Когда возвращается массив составных значений, его нельзя представить в виде списка, так как
невозможно однозначно определить, представляет ли список Python составной тип или ещё
одну размерность массива.
Сопоставление (словарь)
Значение столбца результата получается из сопоставления, в котором ключом является имя
столбца. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
return ( “name”: name, “value”: value )
<script type="math/tex">LANGUAGE plpythonu;
Любые дополнительные пары ключ/значение в словаре игнорируются, а отсутствие нужных
ключей считается ошибкой. Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте None
с именем соответствующего столбца в качестве ключа.
Объект (любой объект с методом __getattr__)
Объект передаётся аналогично сопоставлению. Пример:
1215PL/Python — проце-
дурный язык Python
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
class named_value:
def <strong>init</strong> (self, n, v):
self.name = n
self.value = v
return named_value(name, value)</p>
<h1 id="или-просто">или просто</h1>
<p>class nv: pass
nv.name = name
nv.value = value
return nv
<script type="math/tex">LANGUAGE plpythonu;
Также поддерживаются функции с параметрами OUT (выходными). Например:
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS</script>
return (1, 2)
<script type="math/tex">LANGUAGE plpythonu;
SELECT * FROM multiout_simple();
Выходные параметры процедуры выдаются таким же образом. Например:
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS</script>
return (a * 3, b * 3)
<script type="math/tex">LANGUAGE plpythonu;
CALL python_triple(5, 10);
46.3.5. Функции, возвращающие множества
Функция PL/Python также может возвращать множества, содержащие скалярные и составные ти-
пы. Это можно осуществить разными способами, так как возвращаемый объект внутри превраща-
ется в итератор. В следующих примерах предполагается, что у нас есть составной тип:
CREATE TYPE greeting AS (
how text,
who text
);
Множество в качестве результата можно возвратить, применив:
Последовательность (кортеж, список, множество)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script></p>
<h1 id="возвращает-кортеж-содержащий-списки-в-качестве-составных-типов">возвращает кортеж, содержащий списки в качестве составных типов</h1>
<h1 id="также-будут-работать-и-остальные-комбинации">также будут работать и остальные комбинации</h1>
<p>return ( [ how, “World” ], [ how, “PostgreSQL” ], [ how, “PL/Python” ] )
<script type="math/tex">LANGUAGE plpythonu;
Итератор (любой объект, реализующий методы __iter__ и next)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script>
class producer:
def <strong>init</strong> (self, how, who):
1216PL/Python — проце-
дурный язык Python
self.how = how
self.who = who
self.ndx = -1
def <strong>iter</strong> (self):
return self
def next (self):
self.ndx += 1
if self.ndx == len(self.who):
raise StopIteration
return ( self.how, self.who[self.ndx] )
return producer(how, [ “World”, “PostgreSQL”, “PL/Python” ])
<script type="math/tex">LANGUAGE plpythonu;
Генератор (yield)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script>
for who in [ “World”, “PostgreSQL”, “PL/Python” ]:
yield ( how, who )
<script type="math/tex">LANGUAGE plpythonu;
Также поддерживаются функции, возвращающие множества, с параметрами OUT (объявленные с
RETURNS SETOF record). Например:
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS
SETOF record AS</script>
return [(1, 2)] * n
<script type="math/tex">LANGUAGE plpythonu;
SELECT * FROM multiout_simple_setof(3);
46.4. Совместное использование данных
Для сохранения внутренних данных при повторных вызовах одной и той же функции предусмотрен
глобальный словарь SD. Для размещения публичных данных предназначен глобальный словарь GD,
доступный всем функциям на Python в сеансе; используйте его с осторожностью.
Каждая функция получает собственную среду выполнения в интерпретаторе Python, так что гло-
бальные данные и аргументы функции, например myfunc, не будут доступны в myfunc2. Исключе-
ние составляют данные в словаре GD, как сказано выше.
46.5. Анонимные блоки кода
PL/Python также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO</script></p>
<h1 id="Код-на-plpython">Код на PL/Python</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
46.6. Триггерные функции
Когда функция используется как триггер, словарь TD содержит значения, связанные с работой
триггера:
1217PL/Python — проце-
дурный язык Python
TD["event"]
содержит название события в виде строки: INSERT, UPDATE, DELETE или TRUNCATE.
TD["when"]
содержит одну из строк: BEFORE, AFTER или INSTEAD OF.
TD["level"]
содержит ROW или STATEMENT.
TD["new"]
TD["old"]
Для триггера уровня строки одно или оба этих поля содержат соответствующие строки тригге-
ра, в зависимости от события триггера.
TD["name"]
содержит имя триггера.
TD["table_name"]
содержит имя таблицы, для которой сработал триггер.
TD["table_schema"]
содержит схему таблицы, для которой сработал триггер.
TD["relid"]
содержит OID таблицы, для которой сработал триггер.
TD["args"]
Если в команде CREATE TRIGGER задавались аргументы, их можно получить как элементы мас-
сива с TD["args"][0] по TD["args"][n-1].
Если в TD["when"] передано BEFORE или INSTEAD OF, а в TD["level"] — ROW, вы можете вернуть
значение None или "OK" из функции Python, чтобы показать, что строка не была изменена, значение
"SKIP", чтобы прервать событие, либо, если в TD["event"] передана команда INSERT или UPDATE,
вы можете вернуть "MODIFY", чтобы показать, что новая строка была изменена. Во всех других
случаях возвращаемое значение игнорируется.
46.7. Обращение к базе данных
Исполнитель языка PL/Python автоматически импортирует модуль Python с именем plpy. Вы в сво-
ём коде можете использовать функции и константы, объявленные в этом модуле, обращаясь к ним
по именам вида plpy.имя.
46.7.1. Функции обращения к базе данных
Модуль plpy содержит различные функции для выполнения команд в базе данных:
plpy.execute(запрос [, макс-строк])
При вызове plpy.execute со строкой запроса и необязательным аргументом, ограничивающим
число строк, выполняется заданный запрос, а то, что он выдаёт, возвращается в виде объекта
результата.
Объект результата имитирует список или словарь. Получить из него данные можно по номеру
строки и имени столбца. Например, команда:
rv = plpy.execute("SELECT * FROM my_table", 5)
1218PL/Python — проце-
дурный язык Python
вернёт не более 5 строк из отношения my_table. Если в my_table есть столбец my_column, к
нему можно обратиться так:
foo = rv[i]["my_column"]
Число возвращённых в этом объекте строк можно получить, воспользовавшись встроенной
функцией len.
Для объекта результата определены следующие дополнительные методы:
nrows()
Возвращает число строк, обработанных командой. Заметьте, что это число не обязательно
будет равно числу возвращённых строк. Например, команда UPDATE устанавливает это зна-
чение, но не возвращает строк (без указания RETURNING).
status()
Значение состояния, возвращённое SPI_execute().
colnames()
coltypes()
coltypmods()
Возвращают список имён столбцов, список OID типов столбцов и список модификаторов
типа этих столбцов, соответственно.
Эти методы вызывают исключение, когда им передаётся объект, полученный от команды, не
возвращающей результирующий набор, например, UPDATE без RETURNING, либо DROP TABLE.
Но эти методы вполне можно использовать с результатом, содержащим ноль строк.
__str__()
Стандартный метод __str__ определён так, чтобы можно было, например, вывести отладоч-
ное сообщение с результатами запроса, вызвав plpy.debug(rv).
Объект результата может быть изменён.
Заметьте, что при вызове plpy.execute весь набор результатов будет прочитан в память. Эту
функцию следует использовать, только если вы знаете, что набор будет относительно неболь-
шим. Если вы хотите исключить риск переполнения памяти при выборке результатов большого
объёма, используйте plpy.cursor вместо plpy.execute.
plpy.prepare(запрос [, типы_аргументов])
plpy.execute(план [, аргументы [, макс-строк]])
Функция plpy.prepare подготавливает план выполнения для запроса. Она вызывается со стро-
кой запроса и списком типов параметров (если в запросе есть параметры). Например:
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1",
["text"])
Здесь text представляет переменную, передаваемую в качестве параметра $1. Второй аргумент
необязателен, если запросу не нужно передавать никакие параметры.
Чтобы запустить подготовленный оператор на выполнение, используйте вариацию функции
plpy.execute:
rv = plpy.execute(plan, ["name"], 5)
Передайте план в первом аргументе (вместо строки запроса), а список значений, которые будут
подставлены в запрос, — во втором. Второй аргумент можно опустить, если запрос не прини-
мает никакие параметры. Третий аргумент, как и раньше, задаёт необязательное ограничение
максимального числа строк.
1219PL/Python — проце-
дурный язык Python
Вы также можете вызвать метод execute объекта плана:
rv = plan.execute(["name"], 5)
Параметры запросов и поля строк результата преобразуются между типами данных PostgreSQL
и Python как описано в Разделе 46.3.
Когда вы подготавливаете план, используя модуль PL/Python, он сохраняется автоматически.
Что это означает, вы можете узнать в документации SPI (Глава 47). Чтобы эффективно исполь-
зовать это в нескольких вызовах функции, может потребоваться применить словарь постоянно-
го хранения SD или GD (см. Раздел 46.4). Например:
CREATE FUNCTION usesavedplan() RETURNS trigger AS</script>
if “plan” in SD:
plan = SD[“plan”]
else:
plan = plpy.prepare(“SELECT 1”)
SD[“plan”] = plan</p>
<h1 id="остальной-код-функции">остальной код функции</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
plpy.cursor(запрос)
plpy.cursor(план [, аргументы])
Функция plpy.cursor принимает те же аргументы, что и plpy.execute (кроме ограничения
строк) и возвращает объект курсора, который позволяет обрабатывать объёмные наборы ре-
зультатов небольшими порциями. Как и plpy.execute, этой функции можно передать строку
запроса или объект плана со списком аргументов, а можно вызывать функцию cursor как ме-
тод объекта плана.
Объект курсора реализует метод fetch, который принимает целочисленный параметр и воз-
вращает объект результата. При каждом следующем вызове fetch возвращаемый объект будет
содержать следующий набор строк, в количестве, не превышающем значение параметра. Ко-
гда строки закончатся, fetch начнёт возвращать пустой объект результата. Объекты курсора
также предоставляют интерфейс итератора, выдающий по строке за один раз, пока не будут
выданы все строки. Данные, выбираемые таким образом, возвращаются не как объекты резуль-
тата, а как словари (одной строке результата соответствует один словарь).
Следующий пример демонстрирует обработку содержимого большой таблицы двумя способа-
ми:
CREATE FUNCTION count_odd_iterator() RETURNS integer AS</script>
odd = 0
for row in plpy.cursor(“select num from largetable”):
if row[‘num’] % 2:
odd += 1
return odd
<script type="math/tex">LANGUAGE plpythonu;
CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS</script>
odd = 0
cursor = plpy.cursor(“select num from largetable”)
while True:
rows = cursor.fetch(batch_size)
if not rows:
break
for row in rows:
if row[‘num’] % 2:
odd += 1
return odd
<script type="math/tex">LANGUAGE plpythonu;
1220PL/Python — проце-
дурный язык Python
CREATE FUNCTION count_odd_prepared() RETURNS integer AS</script>
odd = 0
plan = plpy.prepare(“select num from largetable where num % $1 &lt;&gt; 0”, [“integer”])
rows = list(plpy.cursor(plan, [2])) # или: = list(plan.cursor([2]))
return len(rows)
<script type="math/tex">LANGUAGE plpythonu;
Курсоры ликвидируются автоматически. Но если вы хотите явно освободить все ресурсы, за-
нятые курсором, вызовите метод close. Продолжать получать данные через курсор, который
был закрыт, нельзя.
Подсказка
Не путайте объекты, создаваемые функцией plpy.cursor, с курсорами DB-API, опре-
делёнными в спецификации API для работы с базами данных в Python. Они не име-
ют ничего общего, кроме имени.
46.7.2. Обработка ошибок
Функции, обращающиеся к базе данных, могут сталкиваться с ошибками, в результате которых
они будут прерываться и вызывать исключение. Обе функции plpy.execute и plpy.prepare могут
вызывать экземпляр подкласса исключения plpy.SPIError, которое по умолчание прекращает вы-
полнение функции. Эту ошибку можно обработать, как и любое другое исключение в Python, при-
менив конструкцию try/except. Например:
CREATE FUNCTION try_adding_joe() RETURNS text AS</script>
try:
plpy.execute(“INSERT INTO users(username) VALUES (‘joe’)”)
except plpy.SPIError:
return “something went wrong”
else:
return “Joe added”
<script type="math/tex">LANGUAGE plpythonu;
Фактический класс вызываемого исключения соответствует определённому условию возник-
новения ошибки. Список всех возможных условий приведён в Таблице  A.1. В модуле
plpy.spiexceptions определяются классы исключений для каждого условия PostgreSQL, с име-
нами, производными от имён условий. Например, имя division_by_zero становится именем
DivisionByZero, unique_violation — именем UniqueViolation, fdw_error — именем FdwError и т.
д. Все эти классы исключений наследуются от SPIError. Такое разделение на классы упрощает
обработку определённых ошибок, например:
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS</script>
from plpy import spiexceptions
try:
plan = plpy.prepare(“INSERT INTO fractions (frac) VALUES ($1 / $2)”, [“int”,
“int”])
plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
return “denominator cannot equal zero”
except spiexceptions.UniqueViolation:
return “already have that fraction”
except plpy.SPIError, e:
return “other error, SQLSTATE %s” % e.sqlstate
else:
return “fraction inserted”
1221PL/Python — проце-
дурный язык Python
<script type="math/tex">LANGUAGE plpythonu;
Заметьте, что так как все исключения из модуля plpy.spiexceptions наследуются от исключения
SPIError, команда except, обрабатывающая это исключение, будет перехватывать все ошибки при
обращении к базе данных.
В качестве другого варианта обработки различных условий ошибок, вы можете перехватывать ис-
ключение SPIError и определять конкретное условие ошибки внутри блока except по значению ат-
рибута sqlstate объекта исключения. Этот атрибут содержит строку с кодом ошибки «SQLSTATE».
Конечный результат при таком подходе примерно тот же.
46.8. Явные подтранзакции
Перехват ошибок, произошедших при обращении к базе данных, как описано в Подразделе 46.7.2,
может привести к нежелательной ситуации, когда часть операций будет успешно выполнена,
прежде чем произойдёт сбой. Данные останутся в несогласованном состоянии после обработки
такой ошибки. PL/Python предлагает решение этой проблемы в форме явных подтранзакций.
46.8.1. Менеджеры контекста подтранзакций
Рассмотрим функцию, осуществляющую перевод средств между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS</script>
try:
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
Если при выполнении второго оператора UPDATE произойдёт исключение, эта функция сообщит
об ошибке, но результат первого UPDATE будет, тем не менее, зафиксирован. Другими словами,
средства будут списаны со счёта Джо, но не зачислятся на счёт Мэри.
Во избежание таких проблем вы можете завернуть вызовы plpy.execute в явную подтранзакцию.
Модуль plpy предоставляет вспомогательный объект для управления явными подтранзакциями,
создаваемый функцией plpy.subtransaction(). Объекты, созданные этой функцией, реализуют
интерфейс менеджера контекста. Используя явные подтранзакции, мы можем переписать нашу
функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS</script>
try:
with plpy.subtransaction():
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
1222PL/Python — проце-
дурный язык Python
Заметьте, что конструкция try/catch по-прежнему нужна. Без неё исключение распространится
вверх по стеку Python и приведёт к прерыванию всей функции с ошибкой PostgreSQL, так что в
таблицу operations запись не добавится. Менеджер контекста подтранзакции не перехватывает
ошибки, он только гарантирует, что все операции с базой данных в его области действия будут
атомарно зафиксированы или отменены. Откат блока подтранзакции происходит при исключении
любого вида, а не только исключения, вызванного ошибками при обращении к базе данных. Обыч-
ное исключение Python, вызванное внутри блока явной подтранзакции, также приведёт к откату
этой подтранзакции.
46.8.2. Старые версии Python
Синтаксис использования менеджеров контекста с ключевым словом with по умолчанию поддер-
живается в Python 2.6. В PL/Python с более старой версией Python тоже возможно использовать
явные подтранзакции, хотя и не так прозрачно. При этом вы можете вызывать методы __enter__
и __exit__ менеджера контекста по удобным псевдонимам enter и exit. Для такого случая функ-
цию перечисления средств можно переписать так:
CREATE FUNCTION transfer_funds_old() RETURNS void AS</script>
try:
subxact = plpy.subtransaction()
subxact.enter()
try:
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except:
import sys
subxact.exit(*sys.exc_info())
raise
else:
subxact.exit(None, None, None)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
Примечание
Хотя менеджеры контекста были реализованы в 2.5, для использования синтаксиса
with в этой версии нужно применить «будущий оператор». Однако по техническим
причинам «будущие операторы» в функциях PL/Python использовать нельзя.
46.9. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в ко-
манде DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, вызови-
те plpy.commit(), а чтобы откатить — plpy.rollback(). (Заметьте, что выполнить SQL-команды
COMMIT или ROLLBACK через plpy.execute или подобную функцию нельзя. Соответствующие опера-
ции могут выполняться только данными функциями.) После завершения одной транзакции следу-
ющая начинается автоматически, отдельной функции для этого нет.
Пример:
1223PL/Python — проце-
дурный язык Python
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS</script>
for i in range(0, 10):
plpy.execute(“INSERT INTO test1 (a) VALUES (%d)” % i)
if i % 2 == 0:
plpy.commit()
else:
plpy.rollback()
<script type="math/tex">;
CALL transaction_test1();
Транзакцию нельзя завершить в случае существования открытой явной подтранзакции.
46.10. Вспомогательные функции
Модуль plpy также предоставляет функции
plpy.debug( msg, **kwargs )
plpy.log( msg, **kwargs )
plpy.info( msg, **kwargs )
plpy.notice( msg, **kwargs )
plpy.warning( msg, **kwargs )
plpy.error( msg, **kwargs )
plpy.fatal( msg, **kwargs )
Функции plpy.error и plpy.fatal на самом деле выдают исключение Python, которое, если его
не перехватить, распространяется в вызывающий запрос, что приводит к прерыванию текущей
транзакции или подтранзакции. Команды raise plpy.Error(msg) и raise plpy.Fatal(msg) рав-
нозначны вызовам plpy.error(msg) и plpy.fatal(msg), соответственно, но форма raise не позво-
ляет передавать аргументы с ключами. Другие функции просто выдают сообщения разных уров-
ней важности. Будут ли сообщения определённого уровня передаваться клиентам и/или записы-
ваться в журнал сервера, определяется конфигурационными переменными log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
Аргумент msg задаётся как позиционный. Для обратной совместимости может быть передано
несколько позиционных аргументов. В этом случае сообщением для клиента становится строковое
представление кортежа позиционных аргументов.
Дополнительно только по ключам принимаются следующие аргументы:
detail
hint
sqlstate
schema_name
table_name
column_name
datatype_name
constraint_name
Строковое представление объектов, передаваемых в аргументах по ключам, позволяет выдать кли-
енту более богатую информацию. Например:
CREATE FUNCTION raise_custom_exception() RETURNS void AS</script>
plpy.error(“custom exception message”,
detail=”some info about exception”,
hint=”hint for users”)
$$ LANGUAGE plpythonu;
1224PL/Python — проце-
дурный язык Python
=# SELECT raise_custom_exception();
ERROR: plpy.Error: custom exception message
DETAIL: some info about exception
HINT: hint for users
CONTEXT: Traceback (most recent call last):
PL/Python function “raise_custom_exception”, line 4, in <module>
hint="hint for users")
PL/Python function "raise_custom_exception"
Ещё
один
набор
вспомогательных
функций
образуют
plpy.quote_literal(строка),
plpy.quote_nullable(строка) и plpy.quote_ident(строка). Они равнозначны встроенным функ-
циям заключения в кавычки, описанным в Разделе 9.4. Они полезны при конструировании свобод-
но составляемых запросов. На PL/Python динамический SQL, показанный в Примере 43.1, форми-
руется так:
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
plpy.quote_ident(colname),
plpy.quote_nullable(newvalue),
plpy.quote_literal(keyvalue)))
46.11. Переменные окружения
Некоторые переменные окружения, воспринимаемые интерпретатором Python, тоже могут влиять
на поведение PL/Python. При необходимости их нужно установить в среде основного серверного
процесса PostgreSQL, например, в скрипте запуска. Множество доступных переменных окружения
зависит от версии Python; за подробностями обратитесь к документации Python. На момент напи-
сания этой документации, на поведение PL/Python влияли следующие переменные окружения, при
наличии подходящей версии Python:
• PYTHONHOME
• PYTHONPATH
• PYTHONY2K
• PYTHONOPTIMIZE
• PYTHONDEBUG
• PYTHONVERBOSE
• PYTHONCASEOK
• PYTHONDONTWRITEBYTECODE
• PYTHONIOENCODING
• PYTHONUSERBASE
• PYTHONHASHSEED
(Похоже, что вследствие тонкостей реализации Python, не зависящих от исполнителя PL/Python,
некоторые переменные окружения, перечисленные на странице руководства man python, действу-
ют только в интерпретаторе для командной строки, но не во встраиваемом интерпретаторе Python.)
1225</module></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-045/" title="Глава 45. PL/Perl — процедурный язык Perl"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 45. PL/Perl — процедурный язык Perl"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-045/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~10 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-045/" rel="bookmark" title="Глава 45. PL/Perl — процедурный язык Perl" itemprop="url">Глава 45. PL/Perl — процедурный язык Perl</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 45. PL/Perl — процедурный язык Perl</p>

<p>PL/Perl — это загружаемый процедурный язык, позволяющий реализовывать функции PostgreSQL
на языке программирования Perl.
Основным преимуществом PL/Perl является то, что он позволяет применять в сохранённых функци-
ях множество функций и операторов «перемалывания строк», имеющихся в Perl. Разобрать слож-
ные строки на языке Perl может быть гораздо проще, чем используя строковые функции и управ-
ляющие структуры в PL/pgSQL.
Чтобы установить PL/Perl в определённую базу данных, выполните команду CREATE EXTENSION
plperl.
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Perl в процессе установки. (За дополнительными сведениями обратитесь к Главе 16.)
Пользователи двоичных пакетов могут найти PL/Perl в отдельном модуле.
45.1. Функции на PL/Perl и их аргументы
Чтобы создать функцию на языке PL/Perl, используйте стандартный синтаксис CREATE FUNCTION:
CREATE FUNCTION имя_функции (типы-аргументов) RETURNS тип-результата AS $$</p>
<h1 id="Тело-функции-на-plperl">Тело функции на PL/Perl</h1>
<p><script type="math/tex">LANGUAGE plperl;
Тело функции содержит обычный код Perl. Фактически, код обвязки PL/Perl помещает этот код
в подпрограмму Perl. Функция PL/Perl вызывается в скалярном контексте, так что она не может
вернуть список. Не скалярные значения (массивы, записи и множества) можно вернуть по ссылке,
как описывается ниже.
В процедуре PL/Perl возвращаемое из кода Perl значение игнорируется.
PL/Perl также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO</script></p>
<h1 id="Код-plperl">Код PL/Perl</h1>
<p><script type="math/tex">LANGUAGE plperl;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
Примечание
Использовать вложенные именованные подпрограммы в Perl опасно, особенно если они
обращаются к лексическим переменным в окружающей области. Так как функция PL/
Perl оборачивается в подпрограмму, любая именованная функция внутри неё будет вло-
женной. Вообще гораздо безопаснее создавать анонимные подпрограммы и вызывать
их по ссылке на код. Дополнительную информацию вы можете получить на странице
руководства man perldiag, в описании ошибок Variable "%s" will not stay shared
(Переменная "%s" не останется разделяемой) и Variable "%s" is not available (Пе-
1195PL/Perl — процедурный язык Perl
ременная "%s" недоступна), либо найти в Интернете по ключевым словам «perl nested
named subroutine» (perl вложенная именованная подпрограмма).
Синтаксис команды CREATE FUNCTION требует, чтобы тело функции было записано как строковая
константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. Под-
раздел 4.1.2.4). Если вы решите применять синтаксис спецпоследовательностей E'', вам придётся
дублировать апострофы (') и обратную косую черту (\) в теле функции (см. Подраздел 4.1.2.1).
Аргументы и результат обрабатываются как и в любой другой подпрограмме на Perl: аргументы
передаются в @_, а результирующим значением будет указанное в return или полученное в по-
следнем выражении, вычисленном в функции.
Например, функцию, возвращающую большее из двух целых чисел, можно определить так:
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS</script>
if ($<em>[0] &gt; $</em>[1]) { return $<em>[0]; }
return $</em>[1];
<script type="math/tex">LANGUAGE plperl;
Примечание
Аргументы будут преобразованы из кодировки базы данных в UTF-8 для использования
в PL/Perl, а при выходе снова будут преобразованы из UTF-8 в кодировку базы данных.
Если функции передаётся NULL-значение SQL, значением аргумента в Perl станет «undefined».
Показанное выше определение функции будет не очень хорошо обрабатывать значения NULL (в
действительности они будут восприняты как нули). Мы могли бы добавить указание STRICT в это
определение, чтобы PostgreSQL поступал немного разумнее: при передаче значения NULL функ-
ция вовсе не будет вызываться, будет сразу возвращён результат NULL. С другой стороны, мы
могли бы проверить значения undefined в теле функции. Например, предположим, что нам нужна
функция perl_max, которая с одним аргументом NULL и вторым аргументом не NULL должна воз-
вращать не NULL, а второй аргумент:
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS</script>
my ($x, $y) = @_;
if (not defined $x) {
return undef if not defined $y;
return $y;
}
return $x if not defined $y;
return $x if $x &gt; $y;
return $y;
<script type="math/tex">LANGUAGE plperl;
Как показано выше, чтобы выдать значение SQL NULL, нужно вернуть значение undefined. Это
можно сделать и в строгой, и в нестрогой функции.
Всё в аргументах функции, что не является ссылкой, является строкой, то есть стандартным для
PostgreSQL внешним текстовым представлением соответствующего типа данных. В случае с обыч-
ными числовыми или текстовыми типами, Perl просто воспринимает их должным образом, и про-
граммист, как правило, может об этом не думать. Однако в более сложных случаях может потре-
боваться преобразовать аргумент в форму, подходящую для использования в Perl. Например, для
преобразования типа bytea в двоичное значение можно использовать функцию decode_bytea.
Аналогично, значения, передаваемые в PostgreSQL, должны быть в формате внешнего текстового
представления. Например, для подготовки двоичных данных к возврату в значении bytea можно
воспользоваться функцией encode_bytea.
Perl может возвращать массивы PostgreSQL как ссылки на массивы Perl. Например, так:
1196PL/Perl — процедурный язык Perl
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS</script>
return [[‘a”b’,’c,d’],[‘e\f’,’g’]];
<script type="math/tex">LANGUAGE plperl;
select returns_array();
Perl передаёт массивы PostgreSQL как объект, сопоставленный с PostgreSQL::InServer::ARRAY. С
этим объектом можно работать как со ссылкой на массив или строкой, что допускает обратную
совместимость с кодом Perl, написанным для PostgreSQL версии до 9.1. Например:
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS</script>
my $arg = shift;
my $result = “”;
return undef if (!defined $arg);</p>
<h1 id="в-качестве-ссылки-на-массив">в качестве ссылки на массив</h1>
<p>for (@$arg) {
$result .= $_;
}</p>
<h1 id="также-работает-со-строкой">также работает со строкой</h1>
<p>$result .= $arg;
return $result;
<script type="math/tex">LANGUAGE plperl;
SELECT concat_array_elements(ARRAY['PL','/','Perl']);
Примечание
Многомерные массивы представляются как ссылки на массивы меньшей размерности
со ссылками — этот способ хорошо знаком каждому программисту на Perl.
Аргументы составного типа передаются функции как ссылки на хеши. Ключами хеша являются
имена атрибутов составного типа. Например:
CREATE TABLE employee (
name text,
basesalary integer,
bonus integer
);
CREATE FUNCTION empcomp(employee) RETURNS integer AS</script>
my ($emp) = @<em>;
return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
<script type="math/tex">LANGUAGE plperl;
SELECT name, empcomp(employee.*) FROM employee;
Функция на PL/Perl может вернуть результат составного типа, применяя тот же подход: возвратить
ссылку на хеш с требуемыми атрибутами. Например, так:
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);
CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS</script>
return {f2 =&gt; ‘hello’, f1 =&gt; 1, f3 =&gt; ‘world’};
<script type="math/tex">LANGUAGE plperl;
1197PL/Perl — процедурный язык Perl
SELECT * FROM perl_row();
Столбцы объявленного типа результата, отсутствующие в хеше, будут возвращены как значения
NULL.
Подобным образом в виде ссылки на хеш могут быть возвращены выходные аргументы процедуры:
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS</script>
my ($a, $b) = @</em>;
return {a =&gt; $a * 3, b =&gt; $b * 3};
<script type="math/tex">LANGUAGE plperl;
CALL perl_triple(5, 10);
Функции на PL/Perl могут также возвращать множества со скалярными или составными типами.
Обычно желательно возвращать результат по одной строке, чтобы сократить время подготовки
с одной стороны, и чтобы не потребовалось накапливать весь набор данных в памяти, с другой.
Это можно реализовать с помощью функции return_next, как показано ниже. Заметьте, что после
последнего вызова return_next, нужно поместить return или (что лучше) return undef.
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS</script>
foreach (0..$<em>[0]) {
return_next($</em>);
}
return undef;
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set_int(5);
CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS</script>
return_next({ f1 =&gt; 1, f2 =&gt; ‘Hello’, f3 =&gt; ‘World’ });
return_next({ f1 =&gt; 2, f2 =&gt; ‘Hello’, f3 =&gt; ‘PostgreSQL’ });
return_next({ f1 =&gt; 3, f2 =&gt; ‘Hello’, f3 =&gt; ‘PL/Perl’ });
return undef;
<script type="math/tex">LANGUAGE plperl;
Для небольших наборов данных можно также вернуть ссылку на массив, содержащий скаляры,
ссылки на массивы, либо ссылки на хеши для простых типов, типов массивов и составных типов,
соответственно. Ниже приведена пара простых примеров, показывающих, как возвратить весь на-
бор данных в виде ссылки на массив:
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS</script>
return [0..$<em>[0]];
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set_int(5);
CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS</script>
return [
{ f1 =&gt; 1, f2 =&gt; ‘Hello’, f3 =&gt; ‘World’ },
{ f1 =&gt; 2, f2 =&gt; ‘Hello’, f3 =&gt; ‘PostgreSQL’ },
{ f1 =&gt; 3, f2 =&gt; ‘Hello’, f3 =&gt; ‘PL/Perl’ }
];
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set();
Если вы хотите использовать в своём коде strict, у вас есть несколько вариантов. Для временного
глобального использования вы можете задать для plperl.use_strict значение true командой SET.
1198PL/Perl — процедурный язык Perl
Это повлияет на компилируемые впоследствии функции PL/Perl, но не на функции, уже скомпили-
рованные в текущем сеансе. Для постоянного глобального использования вы можете присвоить
параметру plperl.use_strict значение true в файле postgresql.conf.
Для постоянного использования strict в опредёлённых функциях вы можете просто написать:
use strict;
в начале тела этих функций.
Вы также можете использовать указания feature в use, если используете Perl версии 5.10.0 или
новее.
45.2. Значения в PL/Perl
Значения аргументов, передаваемые в код функции PL/Perl, представляют собой просто входные
аргументы, преобразованные в текстовый вид (так же, как при выводе оператором SELECT). И на-
оборот, команды return и return_next могут принять любую строку, соответствующую формату
ввода для объявленного типа результата функции.
45.3. Встроенные функции
45.3.1. Обращение к базе данных из PL/Perl
Обращаться к самой базе данных из кода Perl можно, используя следующие функции:
spi_exec_query(запрос [, макс-строк])
spi_exec_query выполняет команду SQL и возвращает весь набор строк в виде ссылки на мас-
сив хешей. Эту функцию следует использовать, только если вы знаете, что набор будет
относительно небольшим. Так выглядит пример запроса (SELECT) с дополнительно заданным
максимальным числом строк:
$rv = spi_exec_query('SELECT * FROM my_table', 5);
Этот запрос возвращает не больше 5 строк из таблицы my_table. Если в my_table есть столбец
my_column, получить его значение из строки $i результата можно следующим образом:
$foo = $rv->{rows}[$i]->{my_column};
Общее число строк, возвращённых запросом SELECT, можно получить так:
$nrows = $rv->{processed}
Так можно выполнить команду другого типа:
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
Затем можно получить статус команды (например, SPI_OK_INSERT) следующим образом:
$res = $rv->{status};
Чтобы получить число затронутых строк, выполните:
$nrows = $rv->{processed};
Полный пример:
CREATE TABLE test (
i int,
v varchar
);
1199PL/Perl — процедурный язык Perl
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
test
test
test
test
(i,
(i,
(i,
(i,
v)
v)
v)
v)
VALUES
VALUES
VALUES
VALUES
(1,
(2,
(3,
(4,
'first line');
'second line');
'third line');
'immortal');
CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS</script>
my $rv = spi_exec_query(‘select i, v from test;’);
my $status = $rv-&gt;{status};
my $nrows = $rv-&gt;{processed};
foreach my $rn (0 .. $nrows - 1) {
my $row = $rv-&gt;{rows}[$rn];
$row-&gt;{i} += 200 if defined($row-&gt;{i});
$row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
return_next($row);
}
return undef;
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM test_munge();
spi_query(команда)
spi_fetchrow(cursor)
spi_cursor_close(cursor)
Функции spi_query и spi_fetchrow применяются в паре, когда набор строк может быть очень
большим или когда нужно возвращать строки по мере их поступления. Функция spi_fetchrow
работает только с spi_query. Следующий пример показывает, как использовать их вместе:
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);
CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS</script>
use Digest::MD5 qw(md5_hex);
my $file = ‘/usr/share/dict/words’;
my $t = localtime;
elog(NOTICE, “opening file $file at $t” );
open my $fh, ‘&lt;’, $file # здесь мы обращаемся к файлу!
or elog(ERROR, “cannot open $file for reading: $!”);
my @words = &lt;$fh&gt;;
close $fh;
$t = localtime;
elog(NOTICE, “closed file $file at $t”);
chomp(@words);
my $row;
my $sth = spi_query(“SELECT * FROM generate_series(1,$</em>[0]) AS b(a)”);
while (defined ($row = spi_fetchrow($sth))) {
return_next({
the_num =&gt; $row-&gt;{a},
the_text =&gt; md5<em>hex($words[rand @words])
});
}
return;
<script type="math/tex">LANGUAGE plperlu;
SELECT * from lotsa_md5(500);
Обычно вызов spi_fetchrow нужно повторять, пока не будет получен результат undef, показы-
вающий, что все строки уже прочитаны. Курсор, возвращаемый функцией spi_query, автома-
тически освобождается, когда spi_fetchrow возвращает undef. Если вы не хотите читать все
строки, освободите курсор, выполнив spi_cursor_close, чтобы не допустить утечки памяти.
1200PL/Perl — процедурный язык Perl
spi_prepare(команда, типы аргументов)
spi_query_prepared(план, аргументы)
spi_exec_prepared(план [, атрибуты], аргументы)
spi_freeplan(план)
Функции spi_prepare, spi_query_prepared, spi_exec_prepared и spi_freeplan реализуют ту
же функциональность, но для подготовленных запросов. Функция spi_prepare принимает стро-
ку запроса с нумерованными местозаполнителями аргументов ($1, $2 и т. д.) и список строк
с типами аргументов:
$plan = spi_prepare('SELECT * FROM test WHERE id > $1 AND name = $2',
'INTEGER', 'TEXT');
План запроса, подготовленный вызовом spi_prepare, можно использовать вместо строки за-
проса либо в spi_exec_prepared, возвращающей тот же результат, что и spi_exec_query, ли-
бо в spi_query_prepared, возвращающей курсор так же, как spi_query, который затем можно
передать в spi_fetchrow. В необязательном втором параметре spi_exec_prepared можно пере-
дать хеш с атрибутами; в настоящее время поддерживается только атрибут limit, задающий
максимальное число строк, которое может вернуть запрос.
Подготовленные запросы хороши тем, что позволяют использовать единожды подготовленный
план для неоднократного выполнения запроса. Когда план оказывается не нужен, его можно
освободить, вызвав spi_freeplan:
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS</script>
$_SHARED{my_plan} = spi_prepare(‘SELECT (now() + $1)::date AS now’,
‘INTERVAL’);
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS</script>
return spi_exec_prepared(
$_SHARED{my_plan},
$</em>[0]
)-&gt;{rows}-&gt;[0]-&gt;{now};
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION done() RETURNS VOID AS</script>
spi_freeplan( $<em>SHARED{my_plan});
undef $_SHARED{my_plan};
<script type="math/tex">LANGUAGE plperl;
SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();
add_time | add_time | add_time
------------+------------+------------
2005-12-10 | 2005-12-11 | 2005-12-12
Заметьте, что параметры для spi_prepare обозначаются как $1, $2, $3 и т. д., так что по воз-
можности не записывайте строки запросов в двойных кавычках, чтобы не спровоцировать труд-
ноуловимые ошибки.
Ещё
один
пример,
spi_exec_prepared:
иллюстрирующий
использование
необязательного
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
FROM generate_series(1,3) AS id;
CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS</script>
$_SHARED{plan} = spi_prepare(‘SELECT * FROM hosts
1201
параметраPL/Perl — процедурный язык Perl
WHERE address « $1’, ‘inet’);
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS</script>
return spi_exec_prepared(
$_SHARED{plan},
{limit =&gt; 2},
$</em>[0]
)-&gt;{rows};
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS</script>
spi_freeplan($<em>SHARED{plan});
undef $_SHARED{plan};
<script type="math/tex">LANGUAGE plperl;
SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();
query_hosts
-----------------
(1,192.168.1.1)
(2,192.168.1.2)
(2 rows)
spi_commit()
spi_rollback()
Эти функции фиксируют или откатывают текущую транзакцию. Они могут вызываться только в
процедурах или в анонимных блоках кода (в команде DO), вызываемых из кода верхнего уровня.
(Заметьте, что выполнить SQL-команды COMMIT или ROLLBACK через spi_exec_query или подоб-
ную функцию нельзя. Соответствующие операции могут выполняться только данными функци-
ями.) После завершения одной транзакции следующая начинается автоматически, отдельной
функции для этого нет.
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS</script>
foreach my $i (0..9) {
spi_exec_query(“INSERT INTO test1 (a) VALUES ($i)”);
if ($i % 2 == 0) {
spi_commit();
} else {
spi_rollback();
}
}
<script type="math/tex">;
CALL transaction_test1();
45.3.2. Вспомогательные функции в PL/Perl
elog(уровень, сообщение)
Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни сообщений: DEBUG
(ОТЛАДКА), LOG (СООБЩЕНИЕ), INFO (ИНФОРМАЦИЯ), NOTICE (ЗАМЕЧАНИЕ), WARNING (ПРЕ-
ДУПРЕЖДЕНИЕ) и ERROR (ОШИБКА). С уровнем ERROR выдаётся ошибка; если она не перехва-
1202PL/Perl — процедурный язык Perl
тывается окружающим кодом Perl, она распространяется в вызывающий запрос, что приводит к
прерыванию текущей транзакции или подтранзакции. По сути то же самое делает команда die
языка Perl. При использовании других уровней происходит просто вывод сообщения с задан-
ным уровнем важности. Будут ли сообщения определённого уровня передаваться клиенту и/или
записываться в журнал, определяется конфигурационными параметрами log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
quote_literal(строка)
Оформляет переданную строку для использования в качестве текстовой строки в SQL-опера-
торе. Включённые в неё апострофы и обратная косая черта при этом дублируются. Заметьте,
что quote_literal возвращает undef, когда получает аргумент undef; если такие аргументы
возможны, часто лучше использовать quote_nullable.
quote_nullable(строка)
Оформляет переданную строку для использования в качестве текстовой строки в SQL-операто-
ре; либо, если поступает аргумент undef, возвращает строку "NULL" (без кавычек). Символы
апостроф и обратная косая черта дублируются должным образом.
quote_ident(строка)
Оформляет переданную строку для использования в качестве идентификатора в SQL-операто-
ре. При необходимости идентификатор заключается в кавычки (например, если он содержит
символы, недопустимые в открытом виде, или буквы в разном регистре). Если переданная стро-
ка содержит кавычки, они дублируются.
decode_bytea(строка)
Возвращает неформатированные двоичные данные, представленные содержимым заданной
строки, которая должна быть закодирована как bytea.
encode_bytea(строка)
Возвращает закодированные в виде bytea двоичные данные, содержащиеся в переданной стро-
ке.
encode_array_literal(массив)
encode_array_literal(массив, разделитель)
Возвращает содержимое указанного массива в виде строки в формате массива (см. Подраз-
дел 8.15.2). Возвращает значение аргумента неизменённым, если это не ссылка не массив. Раз-
делитель элементов в строке массива по умолчанию — ", " (если разделитель не определён
или undef).
encode_typed_literal(значение, имя_типа)
Преобразует переменную Perl в значение типа данных, указанного во втором аргументе, и воз-
вращает строковое представление этого значения. Корректно обрабатывает вложенные масси-
вы и значения составных типов.
encode_array_constructor(массив)
Возвращает содержимое переданного массива в виде строки в формате конструктора массива
(см. Подраздел 4.2.12). Отдельные значения заключаются в кавычки функцией quote_nullable.
Возвращает значение аргумента, заключённое в кавычки функцией quote_nullable, если ар-
гумент — не ссылка на массив.
looks_like_number(строка)
Возвращает значение true, если содержимое переданной строки похоже на число, по правилам
Perl, и false в обратном случае. Возвращает undef для аргумента undef. Ведущие и замыкающие
1203PL/Perl — процедурный язык Perl
пробелы игнорируются. Строки Inf и Infinity считаются представляющими число (бесконеч-
ность).
is_array_ref(аргумент)
Возвращает значение true, если переданный аргумент можно воспринять как ссылку на массив,
то есть это ссылка на ARRAY или PostgreSQL::InServer::ARRAY. В противном случае возвращает
false.
45.4. Глобальные значения в PL/Perl
Вы можете использовать для хранения данных, включая ссылки на код, глобальный хеш %_SHARED.
Эти данные будут сохраняться между вызовами функции на протяжении всего текущего сеанса.
Простой пример работы с разделяемыми данными:
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS</script>
if ($_SHARED{$</em>[0]} = $<em>[1]) {
return ‘ok’;
} else {
return “cannot set shared variable $</em>[0] to $<em>[1]”;
}
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS</script>
return $_SHARED{$</em>[0]};
<script type="math/tex">LANGUAGE plperl;
SELECT set_var('sample', 'Hello, PL/Perl!
SELECT get_var('sample');
How''s tricks?');
Это чуть более сложный пример, в котором используется ссылка на код:
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS</script>
$_SHARED{myquote} = sub {
my $arg = shift;
$arg =~ s/([’\])/\$1/g;
return “‘$arg’”;
};
<script type="math/tex">LANGUAGE plperl;
SELECT myfuncs(); /* инициализация функции */
/* Определение функции, использующей функцию заключения в кавычки */
CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS</script>
my $text_to_quote = shift;
my $qfunc = $_SHARED{myquote};
return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
(Код выше можно было бы упростить до однострочной команды return</p>
<blockquote>
  <p>($_[0]); в ущерб читаемости.)
$_SHARED{myquote}-
По соображениям безопасности, PL/Perl выполняет функции, вызываемые некоторой ролью SQL,
в отдельном интерпретаторе Perl, выделенном для этой роли. Это предотвращает случайное или
злонамеренное влияние одного пользователя на поведение функций PL/Perl другого пользователя.
В каждом интерпретаторе будет своё значение переменной %_SHARED и собственное глобальное
состояние. Таким образом, две функции PL/Perl будут разделять одно значение %_SHARED, только
если они выполняются одной ролью SQL. В приложении, выполняющем код в одном сеансе с раз-
1204PL/Perl — процедурный язык Perl
ными ролями SQL (вызывающем функции SECURITY DEFINER, использующем команду SET ROLE и т.
д.) может понадобиться явно предпринять дополнительные меры, чтобы функции на PL/Perl могли
разделять данные через %_SHARED. Для этого сначала установите для функций, которые должны
взаимодействовать, одного владельца, а затем задайте для них свойство SECURITY DEFINER. Разу-
меется, при этом нужно позаботиться о том, чтобы эти функции не могли сделать ничего непреду-
смотренного.
45.5. Доверенный и недоверенный PL/Perl
Обычно PL/Perl устанавливается в базу данных как «доверенный» язык программирования с име-
нем plperl. При этом в целях безопасности определённые операции в Perl запрещаются. Вообще
говоря, запрещаются все операции, взаимодействующие с окружением. В том числе, это опера-
ции с файлами, require и use (для внешних модулей). Поэтому функции на PL/Perl, в отличие от
функций на C, никаким образом не могут взаимодействовать с внутренними механизмами сервера
баз данных или обращаться к операционной системе с правами серверного процесса. Вследствие
этого, использовать этот язык можно разрешить любому непривилегированному пользователю баз
данных.
В следующем примере показана функция, которая не будет работать, потому что операции с фай-
ловой системы запрещены по соображениям безопасности:
CREATE FUNCTION badfunc() RETURNS integer AS <script type="math/tex">my $tmpfile = "/tmp/badfile";
open my $fh, '>', $tmpfile
or elog(ERROR, qq{could not open the file "$tmpfile": $!});
print $fh "Testing writing to a file\n";
close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
return 1;</script> LANGUAGE plperl;
Создать эту функцию не удастся, так как при проверке её правильности будет обнаружено исполь-
зование запрещённого оператора.
Иногда возникает желание написать на Perl код, функциональность которого не будет ограничи-
ваться. Например, может потребоваться функция на Perl, которая будет посылать почту. Для таких
потребностей PL/Perl также можно установить как «недоверенный» язык (обычно его называют
PL/PerlU). В этом случае будут доступны все возможности языка Perl. Устанавливая язык, укажите
имя plperlu, чтобы выбрать недоверенную вариацию PL/Perl.
Автор функции на PL/PerlU должен позаботиться о том, чтобы эту функцию нельзя было использо-
вать не по назначению, так как она может делать всё, что может пользователь с правами админи-
стратора баз данных. Заметьте, что СУБД позволяет создавать функции на недоверенных языках
только суперпользователям базы данных.
Если показанная выше функция будет создана суперпользователем, и при этом будет выбран язык
plperlu, она выполнится успешно.
Таким же образом, в анонимном блоке кода на Perl разрешены абсолютно любые операции, если
в качестве языка вместо plperl выбирается plperlu, но выполнять этот код должен суперпользо-
ватель.
Примечание
Тогда как функции на PL/Perl исполняются отдельными интерпретаторами Perl для
каждой роли SQL, все функции на PL/PerlU, вызываемые в рамках сеанса, исполняются
в одном интерпретаторе Perl (отличном от тех, что исполняют функции PL/Perl). Бла-
годаря этому, функции PL/PerlU могут свободно разделять общие данные, но между
функциями PL/Perl и PL/PerlU взаимодействие невозможно.
1205PL/Perl — процедурный язык Perl
Примечание
Perl поддерживает работу нескольких интерпретаторов в одном процессе, только если
он был собран с нужными флагами, а именно, с флагом usemultiplicity или с флагом
useithreads. (В отсутствие веских причин использовать потоки предпочтительным яв-
ляется вариант usemultiplicity. Дополнительную информацию вы можете получить
на странице man perlembed.) При использовании PL/Perl с версией Perl, собранной без
этих флагов, в рамках сеанса можно будет запустить только один интерпретатор Perl,
так что в сеансе будет возможно выполнять либо функции PL/PerlU, либо функции PL/
Perl (и вызывать их должна одна роль SQL).
45.6. Триггеры на PL/Perl
PL/Perl можно использовать для написания триггерных функций. В триггерной функции хеш-мас-
сив $_TD содержит информацию о произошедшем событии триггера. $_TD — глобальная перемен-
ная, которая получает нужное локальное значение при каждом вызове триггера. Хеш-массив $_TD
содержит следующие поля:
$_TD-&gt;{new}{foo}
Новое значение столбца foo
$_TD-&gt;{old}{foo}
Старое значение столбца foo
$_TD-&gt;{name}
Имя вызываемого триггера
$_TD-&gt;{event}
Событие триггера: INSERT, UPDATE, DELETE, TRUNCATE или UNKNOWN
$_TD-&gt;{when}
Когда вызывается триггер: BEFORE (ДО), AFTER (ПОСЛЕ), INSTEAD OF (ВМЕСТО) или UNKNOWN
(НЕИЗВЕСТНО)
$_TD-&gt;{level}
Уровень триггера: ROW (СТРОКА), STATEMENT (ОПЕРАТОР) или UNKNOWN (НЕИЗВЕСТНЫЙ)
$_TD-&gt;{relid}
OID таблицы, для которой сработал триггер
$_TD-&gt;{table_name}
Имя таблицы, для которой сработал триггер
$_TD-&gt;{relname}
Имя таблицы, для которой сработал триггер. Это обращение устарело и может быть ликвиди-
ровано в будущем выпуске. Используйте вместо него $_TD-&gt;{table_name}.
$_TD-&gt;{table_schema}
Имя схемы, содержащей таблицу, для которой сработал триггер
$_TD-&gt;{argc}
Число аргументов в триггерной функции
1206PL/Perl — процедурный язык Perl
@{$_TD-&gt;{args}}
Аргументы триггерной функции. Не определено, если $_TD-&gt;{argc} равно 0.
В триггерах уровня строки возможны следующие варианты возврата:
return;
Выполнить операцию
“SKIP”
Не выполнять операцию
“MODIFY”
Указывает, что строка NEW была изменена триггерной функцией
Следующий пример триггерной функции иллюстрирует описанные выше варианты:
CREATE TABLE test (
i int,
v varchar
);
CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
return “SKIP”;</p>
  <h1 id="пропустить-команду-insertupdate">пропустить команду INSERT/UPDATE</h1>
  <p>} elsif ($_TD-&gt;{new}{v} ne “immortal”) {
$_TD-&gt;{new}{v} .= “(modified by trigger)”;
return “MODIFY”; # изменить строку и выполнить команду INSERT/UPDATE
} else {
return;</p>
  <h1 id="выполнить-команду-insertupdate">выполнить команду INSERT/UPDATE</h1>
  <p>}
<script type="math/tex">LANGUAGE plperl;
CREATE TRIGGER test_valid_id_trig
BEFORE INSERT OR UPDATE ON test
FOR EACH ROW EXECUTE FUNCTION valid_id();
45.7. Событийные триггеры на PL/Perl
PL/Perl можно использовать для написания функций событийных триггеров. В функции событий-
ного триггера хеш-массив $_TD содержит информацию о произошедшем событии триггера. $_TD —
глобальная переменная, которая получает нужное локальное значение при каждом вызове триг-
гера. Хеш-массив $_TD содержит следующие поля:
$_TD->{event}
Имя события, при котором срабатывает этот триггер.
$_TD->{tag}
Тег команды, для которой срабатывает этот триггер.
Возвращаемое значение триггерной функции игнорируется.
Следующий пример функции событийного триггера иллюстрирует описанное выше:
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS</script>
elog(NOTICE, “perlsnitch: “ . $_TD-&gt;{event} . “ “ . $_TD-&gt;{tag} . “ “);
$$ LANGUAGE plperl;
CREATE EVENT TRIGGER perl_a_snitch
1207PL/Perl — процедурный язык Perl
ON ddl_command_start
EXECUTE FUNCTION perlsnitch();
45.8. Внутренние особенности PL/Perl
45.8.1. Конфигурирование
В этом разделе описываются параметры конфигурации, влияющие на работу PL/Perl.
plperl.on_init (string)
Задаёт код Perl, который будет выполняться при первой инициализации интерпретатора Perl, до
того, как он получает специализацию plperl или plperlu. Когда этот код выполняется, функ-
ции SPI ещё не доступны. Если выполнение кода завершается ошибкой, инициализация интер-
претатора прерывается и ошибка распространяется в вызывающий запрос, в результате чего
текущая транзакция или подтранзакция прерывается.
Размер этого кода ограничивается одной строкой. Более объёмный код можно поместить в мо-
дуль и загрузить этот модуль в строке on_init. Например:
plperl.on_init = ‘require “plperlinit.pl”’
plperl.on_init = ‘use lib “/my/app”; use MyApp::PgInit;’
Любые модули, загруженные в plperl.on_init, явно или неявно, будут доступны для исполь-
зования в коде на языке plperl. Это может создать угрозу безопасности. Чтобы определить,
какие модули были загружены, можно выполнить:
DO ‘elog(WARNING, join “, “, sort keys %INC)’ LANGUAGE plperl;
Если библиотека plperl включена в shared_preload_libraries, инициализация произойдёт в глав-
ном процессе (postmaster) и в этом случае необходимо очень серьёзно оценить риск наруше-
ния работоспособности этого процесса. Основной смысл использовать эту возможность в том,
чтобы модули Perl, подключаемые в plperl.on_init, загружались только при запуске главно-
го процесса, и это исключало бы издержки загрузки для отдельных сеансов. Однако, имейте
в виду, что эти издержки исключаются только при загрузке в сеансе первого интерпретатора
Perl — будь то PL/PerlU или PL/Perl для первой SQL-роли, вызывающей функцию на PL/Perl. Лю-
бые дополнительные интерпретаторы Perl, создаваемые в сеансе базы данных, должны будут
выполнять plperl.on_init заново. Также учтите, что в Windows предварительная загрузка не
даёт никакого выигрыша, так как интерпретатор Perl, созданный в главном процессе, не пере-
даётся дочерним процессам.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
plperl.on_plperl_init (string)
plperl.on_plperlu_init (string)
В этих параметрах задаётся код Perl, который будет выполняться в момент, когда интерпрета-
тор Perl получает специализацию plperl или plperlu, соответственно. Это произойдёт, когда в
рамках сеанса будет первый раз вызвана функция на PL/Perl или PL/PerlU, либо когда потребу-
ется дополнительный интерпретатор при использовании другого языка или при вызове функ-
ции PL/Perl новой SQL-ролью. Этот код выполняется после инициализации, произведённой в
plperl.on_init. Однако функции SPI в момент исполнения этого кода ещё не доступны. Код в
plperl.on_plperl_init запускается после того, как интерпретатор «помещается под замок»,
так что в нём разрешаются только доверенные операции.
Если этот код завершается ошибкой, инициализация прерывается и ошибка распространяется
в вызывающий запрос, что приводит к прерыванию текущей транзакции или подтранзакции.
При этом любые действия, уже произведённые в Perl, не будут отменены; однако использовать-
ся этот интерпретатор больше не будет. При следующей попытке использовать этот язык си-
стема попытается заново инициализировать свежий интерпретатор Perl.
1208PL/Perl — процедурный язык Perl
Изменять эти параметры разрешено только суперпользователям. Хотя изменить их можно в
рамках сеанса, такие изменения не повлияют на работу интерпретаторов Perl, задействованных
для выполнения функций ранее.
plperl.use_strict (boolean)
При значении, равном true, последующая компиляция функций PL/Perl будет выполняться с
включённым указанием strict. Этот параметр не влияет на функции, уже скомпилированные
в текущем сеансе.
45.8.2. Ограничения и недостающие возможности
Следующие возможности в настоящее время в PL/Perl отсутствуют, но их реализация будет желан-
ной доработкой.
• Функции на PL/Perl не могут напрямую вызывать друг друга.
• SPI ещё не полностью реализован.
• Если вы выбираете очень большие наборы данных, используя spi_exec_query, вы должны по-
нимать, что все эти данные загружаются в память. Вы можете избежать этого, используя пару
функций spi_query/spi_fetchrow, как показано ранее.
Похожая проблема возникает, если функция, возвращающая множество, передаёт в
PostgreSQL большое число строк, выполняя return. Этой проблемы так же можно избежать,
выполняя для каждой возвращаемой строки return_next, как показано ранее.
• Когда сеанс завершается штатно, не по причине критической ошибки, в Perl выполняются все
блоки END, которые были определены. Никакие другие действия в настоящее время не выпол-
няются. В частности, буферы файлов автоматически не сбрасываются и объекты автоматиче-
ски не уничтожаются.
1209</p>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page10/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page9/">9</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page10/">10</a></li>
      
    
      
        <li><strong class="current-page">11</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page12/">12</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page13/">13</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page35/">35</a></li>
    

    
    
      <li><a href="http://localhost:4000/page12/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>