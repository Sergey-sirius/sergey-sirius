<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page11/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page11/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-048/" title="Глава 48. Фоновые рабочие процессы"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 48. Фоновые рабочие процессы"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-048/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-048/" rel="bookmark" title="Глава 48. Фоновые рабочие процессы" itemprop="url">Глава 48. Фоновые рабочие процессы</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 48. Фоновые рабочие процессы</p>

<p>PostgreSQL поддерживает расширенную возможность запускать пользовательский код в отдель-
ных процессах. Такие процессы запускаются, останавливаются и контролируются главным про-
цессом postgres, который позволяет тесно связать их жизненный цикл с состоянием сервера. Эти
процессы могут получать доступ к области разделяемой памяти PostgreSQL и устанавливать внут-
ренние подключения к базам данных; они также могут последовательно запускать транзакции,
как и обычные серверные процессы, обслуживающие клиентов. Кроме того, используя libpq, они
могут подключаться к серверу и работать как обычные клиентские приложения.
Предупреждение
С использованием фоновых рабочих процессов сопряжены угрозы стабильности и без-
опасности, так как они реализуются на языке C, и значит имеют неограниченный до-
ступ к данным. Администраторы, желающие использовать модули, в которых задей-
ствованы фоновые рабочие процессы, должны быть крайне осторожными. Запускать
рабочие процессы можно разрешать только модулям, прошедшим всесторонний аудит.
Рабочие процессы могут инициализироваться во время запуска PostgreSQL, если имя соответ-
ствующего модуля добавлено в shared_preload_libraries. Модуль, желающий запустить рабо-
чий процесс, может зарегистрировать его, вызвав RegisterBackgroundWorker(BackgroundWorker
<em>worker) из своей функции _PG_init(). Рабочие процессы также могут быть запущены по-
сле запуска системы с помощью функции RegisterDynamicBackgroundWorker(BackgroundWorker
*worker, BackgroundWorkerHandle **handle). В отличие от RegisterBackgroundWorker, которую
можно вызывать только из главного управляющего процесса, RegisterDynamicBackgroundWorker
должна вызываться из обычного обслуживающего процесса или другого рабочего процесса.
Структура BackgroundWorker определяется так:
typedef void (</em>bgworker_main_type)(Datum main_arg);
typedef struct BackgroundWorker
{
char
bgw_name[BGW_MAXLEN];
char
bgw_type[BGW_MAXLEN];
int
bgw_flags;
BgWorkerStartTime bgw_start_time;
int
bgw_restart_time;
/* время в секундах либо BGW_NEVER_RESTART */
char
bgw_library_name[BGW_MAXLEN];
char
bgw_function_name[BGW_MAXLEN];
Datum
bgw_main_arg;
char
bgw_extra[BGW_EXTRALEN];
int
bgw_notify_pid;
} BackgroundWorker;
Поля bgw_name и bgw_type содержат строки, выводимые в отладочных сообщениях, списках про-
цессов и подобных контекстах. Строка bgw_type должна быть одинаковой для всех рабочих про-
цессов одного типа, чтобы такие процессы можно было сгруппировать, например, в списке процес-
сов. bgw_name, с другой стороны, может содержать дополнительную информацию об определённом
процессе. (Обычно строка bgw_name содержит тип в некотором виде, но строго это не требуется.)
Поле bgw_flags представляет битовую маску, обозначающую запрашиваемые модулем возможно-
сти. Допустимые в нём флаги:
BGWORKER_SHMEM_ACCESS
Запрашивается доступ к общей памяти. Рабочие процессы без доступа к общей памяти не могут
обращаться к общим структурам данных PostgreSQL, в частности, к обычным и лёгким блоки-
1285Фоновые рабочие процессы
ровкам, общим буферам, или каким-либо структурам данным, которые рабочий процесс может
создавать для собственного пользования.
BGWORKER_BACKEND_DATABASE_CONNECTION
Запрашивается возможность устанавливать подключение к базе данных, через ко-
торое можно запускать транзакции и запросы. Рабочий процесс, использующий
BGWORKER_BACKEND_DATABASE_CONNECTION для подключения к базе данных, должен также запро-
сить доступ к разделяемой памяти, установив BGWORKER_SHMEM_ACCESS; в противном случае про-
цесс не запустится.
В bgw_start_time определяется состояние сервера, в котором postgres должен запустить этот про-
цесс; возможные варианты: BgWorkerStart_PostmasterStart (выполнить запуск сразу после того,
как postgres завершит инициализацию; процессы, выбирающие такой режим, не могут подклю-
чаться к базам данных), BgWorkerStart_ConsistentState (выполнить запуск, когда будет достиг-
нуто согласованное состояние горячего резерва, и когда процессы могут подключаться к базам
данных и выполнять запросы на чтение), и BgWorkerStart_RecoveryFinished (выполнить запуск,
как только система перейдёт в обычный режим чтения-записи). Заметьте, что два последних ва-
рианта различаются только для серверов горячего резерва. Заметьте также, что этот параметр
указывает только, когда должны запускаться процессы; при переходе в другое состояние они не
будут останавливаться.
bgw_restart_time задаёт паузу (в секундах), которую должен сделать postgres, прежде чем пе-
резапускать процесс в случае его отказа. Это может быть любое положительное значение, либо
BGW_NEVER_RESTART, указывающее, что процесс не нужно перезапускать в случае сбоя.
bgw_library_name определяет имя библиотеки, в которой следует искать точку входа для запуска
рабочего процесса. Указанная библиотека будет динамически загружена рабочим процессом, а
вызываемая функция будет выбрана по имени bgw_function_name. Для функции, загружаемой из
кода ядра, в этом поле должно быть “postgres”.
bgw_function_name определяет имя функции в динамически загружаемой библиотеке, которая бу-
дет точкой входа в новый рабочий процесс.
В bgw_main_arg задаётся аргумент Datum, передаваемый основной функции фонового процесса.
Эта функция должна принимать один аргумент типа Datum и возвращать void. В качестве этого
аргумента ей и передаётся bgw_main_arg. Кроме того, глобальная переменная MyBgworkerEntry
указывает на копию структуры BackgroundWorker, переданной при регистрации; содержимое этой
структуры может быть полезно рабочему процессу.
В Windows (и везде, где определяется EXEC_BACKEND) или в динамических рабочих процессах пере-
давать Datum по ссылке небезопасно, возможна только передача по значению. Поэтому если функ-
ции требуется аргумент, наиболее безопасно будет передать int32 или другое небольшое значение,
содержащее индекс в массиве, размещённом в разделяемой памяти. Если же попытаться передать
значение cstring или text, этот указатель нельзя будет использовать в новом рабочем процессе.
Поле bgw_extra может содержать дополнительные данные, передаваемые фоновому рабочему про-
цессу. В отличие от bgw_main_arg, эти данные не передаются в качестве аргумента основной функ-
ции рабочего процесса, но могут быть получены через MyBgworkerEntry, как описывалось выше.
В bgw_notify_pid задаётся PID обслуживающего процесса PostgreSQL, которому главный процесс
должен посылать сигнал SIGUSR1 при запуске и завершении нового рабочего процесса. Это поле
должно содержать 0 для рабочих процессов, регистрируемых при запуске главного процесса, либо
когда обслуживающий процесс не желает ждать окончания запуска рабочего процесса. Во всех
остальных случаях в нём должно быть значение MyProcPid.
Запущенный
процесс
может
подключиться
к
базе
данных,
вызвав
BackgroundWorkerInitializeConnection(char *dbname, char *username, uint32 flags) или
BackgroundWorkerInitializeConnectionByOid(Oid dboid, Oid useroid, uint32 flags). Через это
1286Фоновые рабочие процессы
подключение процесс может выполнять транзакции и запросы, используя интерфейс SPI. Если в
dbname передаётся NULL или dboid равен InvalidOid, сеанс не подключается ни к какой конкрет-
ной базе данных, но может обращаться к общим каталогам. Если в username передаётся NULL или
useroid равен InvalidOid, процесс будет действовать от имени суперпользователя, созданного во
время initdb. Значение BGWORKER_BYPASS_ALLOWCONN в поле flags позволяет подключаться к ба-
зам, не принимающим подключения пользователей. Рабочий процесс может вызвать только одну
из этих двух функций и только один раз. Переключаться между базами данных он не может.
Сигналы изначально блокируются при вызове основной функции рабочего процесса и долж-
ны быть разблокированы ей: это позволяет процессу при необходимости настроить соб-
ственные обработчики событий. Новый процесс может разблокировать сигналы, вызвав
BackgroundWorkerUnblockSignals, и заблокировать их, вызвав BackgroundWorkerBlockSignals.
Если bgw_restart_time для рабочего процесса имеет значение BGW_NEVER_RESTART, ли-
бо он завершается с кодом выхода 0, либо если его работа заканчивается вызовом
TerminateBackgroundWorker, он автоматически перестаёт контролироваться управляющим про-
цессом при выходе. В противном случае он будет перезапущен через время, заданное в
bgw_restart_time, либо немедленно, если управляющему серверу пришлось переинициализиро-
вать кластер из-за сбоя обслуживающего процесса. Обслуживающие процессы, которым нужно
только приостановить своё выполнение на время, должны переходить в состояние прерываемого
ожидания, а не завершаться; для этого используется функция WaitLatch(). При вызове этой функ-
ции обязательно установите флаг WL_POSTMASTER_DEATH и проверьте код возврата, чтобы корректно
выйти в экстренном случае, когда был завершён сам postgres.
Когда рабочий процесс регистрируется функцией RegisterDynamicBackgroundWorker, обслужива-
ющий процесс, производящий эту регистрацию, может получить информацию о состоянии по-
рождённого процесса. Обслуживающие процессы, желающие сделать это, должны передать адрес
BackgroundWorkerHandle * во втором аргументе RegisterDynamicBackgroundWorker. Если рабочий
процесс успешно зарегистрирован, по этому адресу будет записан указатель на скрытую струк-
туру, который можно затем передать функции GetBackgroundWorkerPid(BackgroundWorkerHandle
*,
pid_t
*) или TerminateBackgroundWorker(BackgroundWorkerHandle
*). Вызывая
GetBackgroundWorkerPid, можно опрашивать состояние рабочего процесса: значение резуль-
тата BGWH_NOT_YET_STARTED показывает, что рабочий процесс ещё не запущен управляющим;
BGWH_STOPPED показывает, что он был запущен, но сейчас не работает; и BGWH_STARTED показывает,
что он работает в данный момент. В последнем случае через второй аргумент также возвращается
PID этого процесса. Обрабатывая вызов TerminateBackgroundWorker, управляющий процесс посы-
лает SIGTERM рабочему процессу, если он работает, и перестаёт его контролировать сразу по его
завершении.
В некоторых случаях процессу, регистрирующему рабочий процесс, может потребоваться до-
ждаться завершения запуска этого процесса. Это можно реализовать, записав в bgw_notify_pid
значение MyProcPid, а затем передав указатель BackgroundWorkerHandle *, полученный во вре-
мя регистрации, функции WaitForBackgroundWorkerStartup(BackgroundWorkerHandle *handle,
pid_t *). Эта функция заблокирует выполнение, пока управляющий процесс не попытается запу-
стить рабочий процесс, либо пока сам управляющий процесс не завершится. Если рабочий про-
цесс запущен, возвращается значение BGWH_STARTED и по переданному адресу записывается PID.
В противном случае возвращается BGWH_STOPPED или BGWH_POSTMASTER_DIED.
Процесс
также
может
ожидать
завершения
рабочего
процесса,
вызвав
функ-
цию WaitForBackgroundWorkerShutdown(BackgroundWorkerHandle
*handle) с указателем
BackgroundWorkerHandle *, полученным при регистрации. Эта функция заблокирует выполне-
ние, пока не завершится рабочий процесс либо управляющий процесс. При завершении ра-
бочего процесса эта функция возвращает BGWH_STOPPED, а при завершении управляющего —
BGWH_POSTMASTER_DIED.
Если фоновый рабочий процесс передаёт асинхронные уведомления, вызывая команду NOTIFY че-
рез SPI (Server Programming Interface, Интерфейс программирования сервера), он должен явно
вызвать ProcessCompletedNotifies после фиксации окружающей транзакции, чтобы все эти уве-
1287Фоновые рабочие процессы
домления были доставлены. Если рабочий процесс зарегистрируется для получения асинхронных
уведомлений, вызвав LISTEN через SPI, уведомления будут выводиться, но перехватить и обрабо-
тать эти уведомления программным образом нет возможности.
Рабочий пример, демонстрирующий некоторые полезные приёмы, можно найти в модуле src/
test/modules/worker_spi.
Максимальное число рабочих процессов, которые можно зарегистрировать, ограничивается зна-
чением max_worker_processes.
1288</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" title="Глава 47. Интерфейс программирования сервера"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 47. Интерфейс программирования сервера"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~40 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" rel="bookmark" title="Глава 47. Интерфейс программирования сервера" itemprop="url">Глава 47. Интерфейс программирования сервера</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 47. Интерфейс программирования сервера</p>

<p>Интерфейс программирования сервера (SPI, Server Programming Interface) даёт разработчикам
пользовательских функций на C возможность запускать команды SQL из своих функций. SPI пред-
ставляет собой набор интерфейсных функций, упрощающих доступ к анализатору, планировщику
и исполнителю запросов. В SPI есть также функции для управления памятью.
Примечание
Доступные процедурные языки предоставляют различные средства для выполнения
SQL-команд из функций. Большинство этих средств основаны на SPI, так что эта доку-
ментация будет полезна и тем, кто использует эти языки.
Учтите, что если команда, вызванная через SPI, прерывается ошибкой, управление не возвраща-
ется в вашу функцию на C. Вместо этого происходит откат транзакции или подтранзакции, из ко-
торой вызывалась ваша функция. (Это может показаться удивительным, с учётом того, что для
большинства функций SPI описаны соглашения по возврату ошибок. Однако эти соглашения при-
менимы только к ошибкам, выявляемым в самих функциях SPI.) Получить управление после ошиб-
ки можно, только организовав собственную подтранзакцию, окружающую вызовы SPI, в которых
возможна ошибка.
Функции SPI выдают неотрицательный результат в случае успеха (либо через возвращаемое це-
лочисленное значение, либо в глобальной переменной SPI_result, как описано ниже). В случае
ошибки выдаётся отрицательный результат или NULL.
Файлы исходного кода, использующие SPI, должны включать заголовочный файл executor/spi.h.
47.1. Интерфейсные функции
1226Интерфейс програм-
мирования сервера
SPI_connect
SPI_connect, SPI_connect_ext — подключить функцию на C к менеджеру SPI
Синтаксис
int SPI_connect(void)
int SPI_connect_ext(int options)
Описание
SPI_connect устанавливает подключение вызова функции на C к менеджеру SPI. Данную функцию
необходимо использовать, если вы хотите выполнять команды через SPI. Некоторые вспомогатель-
ные функции SPI могут вызываться из неподключённых функций.
SPI_connect_ext делает то же самое, но принимает один аргумент, через который можно передать
дополнительные флаги. В настоящее время поддерживаются следующие флаги:
SPI_OPT_NONATOMIC
Переводит подключение SPI в неатомарный режим, в котором разрешаются вызовы функций
управления транзакциями SPI_commit, SPI_rollback и SPI_start_transaction. В обычном ре-
жиме вызов этих функций приводит к немедленной ошибке.
Вызов SPI_connect() равнозначен SPI_connect_ext(0).
Возвращаемое значение
SPI_OK_CONNECT
при успехе
SPI_ERROR_CONNECT
при ошибке
1227Интерфейс програм-
мирования сервера
SPI_finish
SPI_finish — отключить функцию на C от менеджера SPI
Синтаксис
int SPI_finish(void)
Описание
SPI_finish закрывает текущее соединение с менеджером SPI. Эту функцию необходимо вызывать
после завершения операций SPI, которые должны выполняться в текущем вызове функции на C.
Однако если вы прерываете транзакцию, выполняя elog(ERROR), о закрытии соединения можно не
беспокоиться. В этом случае SPI произведёт очистку автоматически.
Возвращаемое значение
SPI_OK_FINISH
если отключение выполнено корректно
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
1228Интерфейс програм-
мирования сервера
SPI_execute
SPI_execute — выполнить команду
Синтаксис
int SPI_execute(const char * command, bool read_only, long count)
Описание
SPI_execute выполняет заданную команду SQL для получения строк в количестве, ограниченном
count. С параметром read_only, равным true, команда должна только читать данные; это несколь-
ко сокращает издержки на её выполнение.
Эту функцию можно вызывать только из подключённой функции на C.
Если count равен 0, команда выполняется для всех строк, к которым она применима. Если count
больше нуля, будет получено не более чем count строк; выполнение команды остановится при
достижении этого предела, практически так же, как и с предложением LIMIT в запросе. Например,
команда:
SPI_execute(“SELECT * FROM foo”, true, 5);
получит из таблицы не более 5 строк. Заметьте, что это ограничение действует, только когда ко-
манда действительно возвращает строки. Например, эта команда:
SPI_execute(“INSERT INTO foo SELECT * FROM bar”, false, 5);
вставляет все строки из bar, игнорируя параметр count. Однако команда
SPI_execute(“INSERT INTO foo SELECT * FROM bar RETURNING <em>”, false, 5);
вставит не более 5 строк, так как её выполнение будет остановлено после получения пятой строки,
выданной предложением RETURNING.
В одной строке можно передать несколько команд; SPI_execute возвращает результат команды,
выполненной последней. Параметр count при этом будет применяться к каждой команде по от-
дельности (несмотря даже на то, что возвращён будет только последний результат). Это ограни-
чение не будет распространяться на скрытые команды, генерируемые правилами.
Когда параметр read_only равен false, SPI_execute увеличивает счётчик команд и получает но-
вый снимок перед выполнением каждой очередной команды в строке. Этот снимок фактически
не меняется при текущем уровне изоляции транзакций SERIALIZABLE или REPEATABLE READ, но в
режиме READ COMMITTED после обновления снимка очередная команда может видеть результаты
только что зафиксированных транзакций из других сеансов. Это важно для согласованного пове-
дения, когда команды модифицируют базу данных.
Когда параметр read_only равен true, SPI_execute не обновляет снимок и не увеличивает счётчик
команд, и допускает в строке команд только SELECT. Заданные команды выполняются со снимком,
ранее полученным для окружающего запроса. Этот режим выполнения несколько быстрее режима
чтения/записи вследствие исключения издержек, связанных с отдельными командами. Он также
позволяет создавать подлинно стабильные функции: так как последующие вызовы в транзакции
будут использовать один снимок, результаты команд не изменятся.
Смешивать команды, только читающие, с командами, читающими и пишущими, в одной процедуре,
использующей SPI, обычно неразумно; запросы только на чтение не увидят результатов изменений
в базе данных, произведённых пишущими запросами.
Число строк, которые были фактически обработаны командой (последней), возвращается в гло-
бальной переменной SPI_processed. Если эта функция возвращает значение SPI_OK_SELECT,
SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING или SPI_OK_UPDATE_RETURNING, вы можете об-
1229Интерфейс програм-
мирования сервера
ратиться по глобальному указателю SPITupleTable *SPI_tuptable и прочитать строки резуль-
тата. Некоторые служебные команды (например, EXPLAIN) также возвращают наборы строк, и
SPI_tuptable будет содержать их результаты и в этих случаях. Другие вспомогательные команды
(COPY, CREATE TABLE AS) не возвращают набор строк, так что указатель SPI_tuptable равен NULL,
но они так же возвращают число обработанных строк в SPI_processed.
Структура SPITupleTable определена так:
typedef struct
{
MemoryContext tuptabcxt;
uint64
alloced;
uint64
free;
TupleDesc
tupdesc;
HeapTuple *vals;
} SPITupleTable;
/</em>
/*
/*
/*
/*
контекст таблицы результатов в памяти <em>/
число занятых значений */
число свободных значений */
дескриптор строки */
данные строк */
vals представляет собой массив указателей на строки. (Число записей в нём указывается в
SPI_processed.) Поле tupdesc содержит дескриптор строки, который вы сможете передать функ-
циям SPI, работающими со строками. Поля tuptabcxt, alloced и free предназначены для внутрен-
него использования, а не для процедур, работающих с SPI.
SPI_finish освобождает все структуры SPITupleTable, размещённые в памяти для текущей функ-
ции на C. Вы можете освободить структуру конкретной результирующей таблицы, если она вам не
нужна, вызвав SPI_freetuptable.
Аргументы
const char * command
строка с командой, которая должна быть выполнена
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Если команда была выполнена успешно, возвращается одно из следующих (неотрицательных) зна-
чений:
SPI_OK_SELECT
если выполнялась команда SELECT (но не SELECT INTO)
SPI_OK_SELINTO
если выполнялась команда SELECT INTO
SPI_OK_INSERT
если выполнялась команда INSERT
SPI_OK_DELETE
если выполнялась команда DELETE
SPI_OK_UPDATE
если выполнялась команда UPDATE
1230Интерфейс програм-
мирования сервера
SPI_OK_INSERT_RETURNING
если выполнялась команда INSERT RETURNING
SPI_OK_DELETE_RETURNING
если выполнялась команда DELETE RETURNING
SPI_OK_UPDATE_RETURNING
если выполнялась команда UPDATE RETURNING
SPI_OK_UTILITY
если выполнялась служебная команда (например, CREATE TABLE)
SPI_OK_REWRITTEN
если команда была преобразована правилом в команду другого вида (например, UPDATE стал
командой INSERT).
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в качестве command передан NULL или count меньше 0
SPI_ERROR_COPY
при попытке выполнить COPY TO stdout или COPY FROM stdin
SPI_ERROR_TRANSACTION
при попытке выполнить команду управления транзакциями (BEGIN, COMMIT, ROLLBACK,
SAVEPOINT, PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED или любую их вариацию)
SPI_ERROR_OPUNKNOWN
если тип команды неизвестен (такого быть не должно)
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Все функции SPI, выполняющие запросы, заполняют и SPI_processed, и SPI_tuptable (только ука-
затель, но не содержимое структуры). Сохраните эти две глобальные переменные в локальных пе-
ременных функции на C, если хотите обращаться к таблице результата SPI_execute или другой
функции, выполняющей запрос, в нескольких вызовах процедуры.
1231Интерфейс програм-
мирования сервера
SPI_exec
SPI_exec — выполнить команду чтения/записи
Синтаксис
int SPI_exec(const char * command, long count)
Описание
SPI_exec действует подобно SPI_execute, но ей не передаётся параметр read_only (всегда подра-
зумевается false).
Аргументы
const char * command
строка с командой, которая должна быть выполнена
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute.
1232Интерфейс програм-
мирования сервера
SPI_execute_with_args
SPI_execute_with_args — выполнить команду с выделенными параметрами
Синтаксис
int SPI_execute_with_args(const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, long count)
Описание
SPI_execute_with_args выполняет команду, которая может включать ссылки на параметры, пере-
даваемые извне. В тексте команды параметры обозначаются символами $n, а в вызове указывают-
ся типы данных и значения для каждого такого символа. Параметры read_only и count имеют тот
же смысл, что и в SPI_execute.
Основное преимущество этой функции по сравнению с SPI_execute в том, что она позволяет пе-
редавать в команду значения данных, не требуя кропотливой подготовки строк, и таким образом
сокращает риск атак с SQL-инъекцией.
Подобного результата можно достичь, вызвав SPI_prepare и затем SPI_execute_plan; однако с
данной функцией план запроса всегда подстраивается под переданные конкретные значения па-
раметров. Поэтому для разового выполнения запроса рекомендуется применять эту функцию. Ес-
ли же одна и та же команда должна выполняться с самыми разными параметрами, какой вариант
окажется быстрее, будет зависеть от стоимости повторного планирования и выигрыша от выбора
специализированных планов.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_execute_with_args считает, что ни один из параметров не
равен NULL. В противном случае элемент массива nulls должен содержать ‘ ‘, если значение
соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1233Интерфейс програм-
мирования сервера
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1234Интерфейс програм-
мирования сервера
SPI_prepare
SPI_prepare — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare(const char * command, int nargs, Oid * argtypes)
Описание
SPI_prepare создаёт и возвращает подготовленный оператор для заданной команды. Подготовлен-
ный оператор может быть затем неоднократно выполнен функцией SPI_execute_plan.
Когда одна и та же или похожие команды выполняются неоднократно, обычно выгоднее произве-
сти анализ запроса только раз, а ещё выгоднее может быть повторно использовать план выполне-
ния команды. SPI_prepare преобразует строку команды в подготовленный оператор, включающий
в себя результаты анализа запроса. Подготовленный оператор также оставляет место для кеши-
рования плана выполнения, если выбор специализированного плана для каждого выполнения не
принесёт пользы.
Подготавливаемую команду можно сделать более общей, записав параметры ($1, $2, etc.) вместо
значений, задаваемыми константами в обычной команде. Фактические значения параметров в
этом случае будут задаваться при вызове SPI_execute_plan. Это позволяет применять подготов-
ленную команду в более широком круге ситуаций, чем это возможно без параметров.
Оператор, возвращаемый функцией SPI_prepare, может использоваться только в текущем вызове
функции на C, так как SPI_finish освобождает память, выделенную для такого оператора. Но этот
оператор может быть сохранён на будущее с помощью функций SPI_keepplan или SPI_saveplan.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
Возвращаемое значение
SPI_prepare возвращает ненулевой указатель на SPIPlan, скрытую структуру, представляющую
подготовленный оператор. В случае ошибки возвращается NULL, а в SPI_result устанавлива-
ется один из кодов ошибок, определённых для SPI_execute, за исключением того, что код
SPI_ERROR_ARGUMENT устанавливается, когда command — NULL, когда nargs меньше 0 или когда nargs
больше 0, а argtypes — NULL.
Замечания
Если параметры не определены, при первом использовании SPI_execute_plan создаётся общий
план, который затем будет применяться при последующих вызовах. Если же присутствуют пара-
метры, SPI_execute_plan будет создавать специализированные планы для конкретных значений
параметров. После достаточного количества использований полученного подготовленного опера-
тора, функция SPI_execute_plan построит общий план, и если он не будет значительно дороже
специализированных, она начнёт использовать его, а не будет строить план заново. Если это пове-
дение по умолчанию не устраивает, его можно изменить, передав флаг CURSOR_OPT_GENERIC_PLAN
1235Интерфейс програм-
мирования сервера
или CURSOR_OPT_CUSTOM_PLAN в SPI_prepare_cursor, чтобы ограничиться использованием только
общего или специализированных планов, соответственно.
Хотя основной смысл подготовленного оператора в том, чтобы избежать повторного разбора и пла-
нирования запроса, PostgreSQL всё же будет принудительно повторять разбор и планирование за-
проса перед его выполнением, если со времени предыдущего использования подготовленного опе-
ратора произойдут изменения определений (DDL) объектов базы, задействованных в этом запросе.
Также, если перед очередным использованием было изменено значение search_path, запрос будет
разобран заново с новым значением search_path. (Последняя особенность появилась в PostgreSQL
9.3.) Чтобы узнать о поведении подготовленных операторов больше, обратитесь к PREPARE.
Эту функцию следует вызывать только из подключённой функции на C.
SPIPlanPtr объявлен в spi.h как указатель на скрытую структуру. Пытаться обращаться к её со-
держимому напрямую не стоит, так как ваш код скорее всего сломается при выходе новых версий
PostgreSQL.
Имя SPIPlanPtr объясняется отчасти историческими причинами, так как теперь эта структура
может не содержать собственно план выполнения.
1236Интерфейс програм-
мирования сервера
SPI_prepare_cursor
SPI_prepare_cursor — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_cursor(const char * command, int nargs,
Oid * argtypes, int cursorOptions)
Описание
Функция SPI_prepare_cursor равнозначна SPI_prepare, за исключением того, что ей можно пере-
дать «параметры курсора». Эти параметры задаются битовой маской со значениями, определён-
ными в nodes/parsenodes.h для поля options структуры DeclareCursorStmt. SPI_prepare подра-
зумевает, что эти параметры всегда нулевые.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_cursor возвращает результат по тем же соглашениям, что и SPI_prepare.
Замечания
К
числу
полезных
бит,
которые
можно
задать
в
cursorOptions,
относятся
CURSOR_OPT_SCROLL, CURSOR_OPT_NO_SCROLL, CURSOR_OPT_FAST_PLAN, CURSOR_OPT_GENERIC_PLAN и
CURSOR_OPT_CUSTOM_PLAN. Заметьте, что параметр CURSOR_OPT_HOLD игнорируется.
1237Интерфейс програм-
мирования сервера
SPI_prepare_params
SPI_prepare_params — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_params(const char * command,
ParserSetupHook parserSetup,
void * parserSetupArg,
int cursorOptions)
Описание
SPI_prepare_params создаёт и возвращает подготовленный оператор для заданной команды, но не
выполняет саму команду. Эта функция равнозначна SPI_prepare_cursor, но позволяет вызываю-
щему дополнительно установить функции-обработчики для управления разбором ссылок на внеш-
ние параметры.
Аргументы
const char * command
строка команды
ParserSetupHook parserSetup
Функция настройки обработчиков разбора
void * parserSetupArg
аргумент для сквозной передачи в parserSetup
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_params возвращает результат по тем же соглашениям, что и SPI_prepare.
1238Интерфейс програм-
мирования сервера
SPI_getargcount
SPI_getargcount — получить число аргументов, требующихся оператору, подготовленному функ-
цией SPI_prepare
Синтаксис
int SPI_getargcount(SPIPlanPtr plan)
Описание
SPI_getargcount возвращает число аргументов, требующихся для выполнения оператора, подго-
товленного функцией SPI_prepare.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Число аргументов, которое ожидает план, заданный параметром plan. Если значение plan невер-
ное или NULL, в SPI_result устанавливается код SPI_ERROR_ARGUMENT, а функция возвращает -1.
1239Интерфейс програм-
мирования сервера
SPI_getargtypeid
SPI_getargtypeid — получить OID типа аргумента для оператора, подготовленного функцией
SPI_prepare
Синтаксис
Oid SPI_getargtypeid(SPIPlanPtr plan, int argIndex)
Описание
SPI_getargtypeid возвращает OID, представляющий тип аргумента под номером argIndex опера-
тора, подготовленного функцией SPI_prepare. Первый аргумент идёт под номером ноль.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
int argIndex
индекс аргумента, начиная с нуля
Возвращаемое значение
OID типа аргумента с заданным индексом. Если значение plan неверное или NULL, либо argIndex
меньше 0 или не меньше числа аргументов, объявленных при подготовке плана (передаваемого в
plan), в SPI_result устанавливается SPI_ERROR_ARGUMENT и возвращается InvalidOid.
1240Интерфейс програм-
мирования сервера
SPI_is_cursor_plan
SPI_is_cursor_plan — выдать true, если оператор, подготовленный функцией SPI_prepare, можно
использовать с SPI_cursor_open
Синтаксис
bool SPI_is_cursor_plan(SPIPlanPtr plan)
Описание
SPI_is_cursor_plan возвращает true, если оператор, подготовленный функцией SPI_prepare,
можно передать в качестве аргумента SPI_cursor_open, или false в противном случае. Для поло-
жительного ответа в plan должна быть представлена одна команда, и эта команда должна возвра-
щать кортежи; например, SELECT может быть подходящей командой, если он не содержит предло-
жения INTO, а UPDATE подходит, только если он содержит предложение RETURNING.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Значение true или false, показывающее, можно ли для подготовленного оператора, заданного
параметром plan, получить курсор, при SPI_result равном нулю. Если дать ответ невозможно
(например, если значение plan неверное или NULL, либо вызывающий не подключён к SPI), в
SPI_result устанавливается соответствующий код ошибки и возвращается false.
1241Интерфейс програм-
мирования сервера
SPI_execute_plan
SPI_execute_plan — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan(SPIPlanPtr plan, Datum * values, const char * nulls,
bool read_only, long count)
Описание
SPI_execute_plan выполняет оператор, подготовленный функцией SPI_prepare или родственными
ей. Параметры read_only и count имеют тот же смысл, что и в SPI_execute.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execute_plan считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute, со следующими дополнительными вариантами
ошибок (отрицательных результатов):
SPI_ERROR_ARGUMENT
Если plan неверный или NULL, либо count меньше 0
SPI_ERROR_PARAM
Если в values передан NULL и plan был подготовлен с другими параметрами
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1242Интерфейс програм-
мирования сервера
SPI_execute_plan_with_paramlist
SPI_execute_plan_with_paramlist — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan_with_paramlist(SPIPlanPtr plan,
ParamListInfo params,
bool read_only,
long count)
Описание
SPI_execute_plan_with_paramlist выполняет оператор, подготовленный функцией SPI_prepare.
Данная функция равнозначна SPI_execute_plan, не считая того, что информация о значениях па-
раметров, передаваемых запросу, представляется по-другому. Представление ParamListInfo мо-
жет быть удобным для передачи значений, уже имеющих нужный формат. Эта функция также под-
держивает динамические наборы параметров, которые реализуются через функции-обработчики,
устанавливаемые в ParamListInfo.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute_plan, если вызов
был успешным.
1243Интерфейс програм-
мирования сервера
SPI_execp
SPI_execp — выполнить оператор в режиме чтения/записи
Синтаксис
int SPI_execp(SPIPlanPtr plan, Datum * values, const char * nulls, long count)
Описание
SPI_execp действует подобно SPI_execute_plan, но ей не передаётся параметр read_only (всегда
подразумевается false).
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execp считает, что ни один из параметров не равен NULL. В
противном случае элемент массива nulls должен содержать ‘ ‘, если значение соответствую-
щего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем случае значение,
переданное в соответствующем элементе values, не учитывается.) Заметьте, что nulls — это
не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1244Интерфейс програм-
мирования сервера
SPI_cursor_open
SPI_cursor_open — открыть курсор для оператора, созданного функцией SPI_prepare
Синтаксис
Portal SPI_cursor_open(const char * name, SPIPlanPtr plan,
Datum * values, const char * nulls,
bool read_only)
Описание
SPI_cursor_open открывает курсор (внутри называемый порталом), через который будет выпол-
няться оператор, подготовленный функцией SPI_prepare. Параметры этой функции имеют тот же
смысл, что и соответствующие параметры SPI_execute_plan.
Применение курсора по сравнению с непосредственным выполнением оператора даёт двойную
выгоду. Во-первых, строки результата можно получать в небольших количествах, без риска исчер-
пать всю память при выполнении запросов, возвращающих много строк. Во-вторых, портал может
существовать и после завершения текущей функции на C (на самом деле он может просущество-
вать до конца текущей транзакции). Возвратив имя портала в код, вызывающий функцию на C,
можно организовать выдачу результата в виде набора строк.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_cursor_open считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1245Интерфейс програм-
мирования сервера
SPI_cursor_open_with_args
SPI_cursor_open_with_args — открывает курсор для запроса с параметрами
Синтаксис
Portal SPI_cursor_open_with_args(const char *name,
const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, int cursorOptions)
Описание
SPI_cursor_open_with_args открывает курсор (внутри называемый порталом) для выполнения за-
данного запроса. Большинство параметров имеют тот же смысл, что и соответствующие парамет-
ры функций SPI_prepare_cursor и SPI_cursor_open.
Для разового выполнения запроса эту функцию следует предпочесть SPI_prepare_cursor с после-
дующей SPI_cursor_open. Если же одна и та же команда должна выполняться с самыми разными
параметрами, какой вариант окажется быстрее, будет зависеть от стоимости повторного планиро-
вания и выигрыша от выбора специализированных планов.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_cursor_open_with_args считает, что ни один из параметров
не равен NULL. В противном случае, элемент массива nulls должен содержать ‘ ‘, если значе-
ние соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1246Интерфейс програм-
мирования сервера
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1247Интерфейс програм-
мирования сервера
SPI_cursor_open_with_paramlist
SPI_cursor_open_with_paramlist — открыть курсор с параметрами
Синтаксис
Portal SPI_cursor_open_with_paramlist(const char *name,
SPIPlanPtr plan,
ParamListInfo params,
bool read_only)
Описание
SPI_cursor_open_with_paramlist открывает курсор (внутри называемый порталом) для вы-
полнения оператора, подготовленного функцией SPI_prepare. Эта функция равнозначна
SPI_cursor_open, не считая того, что информация о значениях параметров, передаваемых запро-
су, представляется по-другому. Представление ParamListInfo может быть удобным для передачи
значений, уже имеющих нужный формат. Эта функция также поддерживает динамические набо-
ры параметров через функции-обработчики, устанавливаемые в ParamListInfo.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1248Интерфейс програм-
мирования сервера
SPI_cursor_find
SPI_cursor_find — найти существующий курсор по имени
Синтаксис
Portal SPI_cursor_find(const char * name)
Описание
SPI_cursor_find находит существующий портал по имени. В основном это полезно для разреше-
ния имени курсора, возвращённого в текстовом виде какой-то другой функцией.
Аргументы
const char * name
имя портала
Возвращаемое значение
указатель на портал с заданным именем или NULL, если такой портал не найден
1249Интерфейс програм-
мирования сервера
SPI_cursor_fetch
SPI_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_cursor_fetch(Portal portal, bool forward, long count)
Описание
SPI_cursor_fetch выбирает некоторое количество строк через курсор. Эта функция реализует
подмножество возможностей SQL-команды FETCH (расширенную функциональность предоставля-
ет SPI_scroll_cursor_fetch).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для выборки с перемещением вперёд, false — назад
long count
максимальное число строк, которое нужно выбрать
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Выборка назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1250Интерфейс програм-
мирования сервера
SPI_cursor_move
SPI_cursor_move — переместить курсор
Синтаксис
void SPI_cursor_move(Portal portal, bool forward, long count)
Описание
SPI_cursor_move перемещает курсор на несколько строк. Эта функция реализует подмно-
жество возможностей SQL-команды MOVE (расширенную функциональность предоставляет
SPI_scroll_cursor_move).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для перемещения вперёд, false — назад
long count
максимальное число строк, на какое возможно перемещение
Замечания
Перемещение назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1251Интерфейс програм-
мирования сервера
SPI_scroll_cursor_fetch
SPI_scroll_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_scroll_cursor_fetch(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_fetch выбирает некоторое количество строк через курсор. Её функциональ-
ность равнозначна FETCH в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, выбираемых с направлением FETCH_FORWARD или FETCH_BACKWARD; абсолютный но-
мер выбираемой строки с вариантом FETCH_ABSOLUTE; либо относительный номер выбираемой
строки с вариантом FETCH_RELATIVE
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1252Интерфейс програм-
мирования сервера
SPI_scroll_cursor_move
SPI_scroll_cursor_move — переместить курсор
Синтаксис
void SPI_scroll_cursor_move(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_move перемещает курсор на несколько строк. Её функциональность равнознач-
на MOVE в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, на которое сдвигается курсор, с направлением FETCH_FORWARD или FETCH_BACKWARD;
абсолютный номер строки, к которой переходит курсор, с направлением FETCH_ABSOLUTE; либо
относительный номер строки, к которой переходит курсор, с направлением FETCH_RELATIVE
Возвращаемое значение
В случае успеха переменная SPI_processed устанавливается как в SPI_execute. В SPI_tuptable
оказывается NULL, так как эта функция не возвращает никакие строки.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1253Интерфейс програм-
мирования сервера
SPI_cursor_close
SPI_cursor_close — закрыть курсор
Синтаксис
void SPI_cursor_close(Portal portal)
Описание
SPI_cursor_close закрывает ранее созданный курсор и освобождает память, занятую его порта-
лом.
Все открытые курсоры закрываются автоматически в конце транзакции. Вызывать
SPI_cursor_close может потребоваться, только если возникает желание освободить ресурсы ско-
рее.
Аргументы
Portal portal
портал, содержащий курсор
1254Интерфейс програм-
мирования сервера
SPI_keepplan
SPI_keepplan — сохранить подготовленный оператор
Синтаксис
int SPI_keepplan(SPIPlanPtr plan)
Описание
SPI_keepplan закрепляет переданный оператор (подготовленный функцией SPI_prepare), чтобы
он не был ликвидирован функцией SPI_finish или диспетчером транзакций. Это даёт возможность
повторно использовать подготовленные операторы при последующих вызовах вашей функции на
C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
Замечания
Переданный оператор перемещается в постоянное хранилище путём смены указателя (копировать
данные не требуется). Если позже вы захотите удалить его, выполните для него SPI_freeplan.
1255Интерфейс програм-
мирования сервера
SPI_saveplan
SPI_saveplan — сохранить подготовленный оператор
Синтаксис
SPIPlanPtr SPI_saveplan(SPIPlanPtr plan)
Описание
SPI_saveplan копирует переданный оператор (подготовленный функцией SPI_prepare) в память,
чтобы он не был ликвидирован функцией SPI_finish или менеджером транзакций, и возвращает
указатель на скопированный оператор. Это даёт возможность повторно использовать подготовлен-
ные операторы при последующих вызовах вашей функции на C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
Указатель на скопированный оператор, либо NULL в случае ошибки. При ошибке SPI_result при-
нимает одно из этих значений:
SPI_ERROR_ARGUMENT
если plan неверный или NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Изначально переданный оператор не освобождается, поэтому вы можете выполнить SPI_freeplan
для него, чтобы высвободить память до SPI_finish.
В большинстве случаев SPI_keepplan предпочтительнее данной функции, так как она даёт при-
мерно тот же результат, но обходится без физического копирования структур данных подготов-
ленного оператора.
1256Интерфейс програм-
мирования сервера
SPI_register_relation
SPI_register_relation — сделать эфемерное именованное отношение доступным по имени в запросах
SPI
Синтаксис
int SPI_register_relation(EphemeralNamedRelation enr)
Описание
SPI_register_relation делает эфемерное именованное отношение (со связанной информацией)
доступным в запросах, планируемых и выполняемых через текущее подключение SPI.
Аргументы
EphemeralNamedRelation enr
запись эфемерного именованного отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_REGISTER
если отношение было успешно зарегистрировано по имени
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если NULL передан в enr или в поле name
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя, заданное в поле name структуры enr, уже зарегистрировано для этого отношения
1257Интерфейс програм-
мирования сервера
SPI_unregister_relation
SPI_unregister_relation — удалить эфемерное именованное отношение из реестра
Синтаксис
int SPI_unregister_relation(const char * name)
Описание
SPI_unregister_relation удаляет эфемерное именованное отношение из реестра для текущего
подключения.
Аргументы
const char * name
имя записи отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_UNREGISTER
если совокупность кортежей была успешно удалена из реестра
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в name передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_NOT_FOUND
если name не находится в реестре для текущего подключения
1258Интерфейс програм-
мирования сервера
SPI_register_trigger_data
SPI_register_trigger_data — сделать эфемерные данные триггера доступными в запросах SPI
Синтаксис
int SPI_register_trigger_data(TriggerData *tdata)
Описание
SPI_register_trigger_data делает эфемерные отношения, которые перехватывает триггер, до-
ступными для запросов, планируемых и выполняемых через текущее подключение SPI. В настоя-
щее время это переходные таблицы, перехватываемые триггером AFTER, определённым с предло-
жением REFERENCING OLD/NEW TABLE AS. Эта функция должна вызываться функцией, реализующей
триггер на языке программирования, после подключения.
Аргументы
TriggerData *tdata
объект TriggerData, передаваемый функцией, реализующей триггер, через fcinfo-&gt;context
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_TD_REGISTER
если перехваченные данные триггера (при наличии) были успешно зарегистрированы
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в tdata передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя в любом из переходных отношений в данных триггера уже зарегистрировано для этого
подключения
47.2. Вспомогательные интерфейсные функции
Функции, описанные здесь, предоставляют возможности для извлечения информации из наборов
результатов, возвращаемых SPI_execute и другими функциями SPI.
Все функции, описанные в этом разделе, могут использоваться и в подключённых, и в неподклю-
чённых функциях на C.
1259Интерфейс програм-
мирования сервера
SPI_fname
SPI_fname — определить имя столбца с заданным номером
Синтаксис
char * SPI_fname(TupleDesc rowdesc, int colnumber)
Описание
SPI_fname возвращает копию имени столбца с заданным номером. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя столбца; NULL, если colnumber вне допустимого диапазона. В случае ошибки в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1260Интерфейс програм-
мирования сервера
SPI_fnumber
SPI_fnumber — определить номер столбца с заданным именем
Синтаксис
int SPI_fnumber(TupleDesc rowdesc, const char * colname)
Описание
SPI_fnumber возвращает номер столбца, имеющего заданное имя.
Если colname ссылается на системный столбец (например, oid), возвращается соответствующий
отрицательный номер столбца. Вызывающий должен проверять, не была ли возвращена ошибка,
сравнивая значение результата именно с SPI_ERROR_NOATTRIBUTE; проверка результата по условию
меньше или равно нулю не будет корректной, если только системные столбцы не должны исклю-
чаться.
Аргументы
TupleDesc rowdesc
описание строк
const char * colname
имя столбца
Возвращаемое значение
Номер
столбца
(начиная
с
1
для
столбцов,
создаваемых
SPI_ERROR_NOATTRIBUTE, если столбец с заданным именем не найден.
1261
пользователем),
либоИнтерфейс програм-
мирования сервера
SPI_getvalue
SPI_getvalue — получить строковое значение указанного столбца
Синтаксис
char * SPI_getvalue(HeapTuple row, TupleDesc rowdesc, int colnumber)
Описание
SPI_getvalue возвращает строковое представление значения указанного столбца.
Результат возвращается в памяти, размещённой функцией palloc. (Когда он будет не нужен, эту
память можно освободить с помощью pfree.)
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Значение столбца, либо NULL, если столбец содержит NULL, colnumber вне допустимого диапазона
(в SPI_result при этом устанавливается SPI_ERROR_NOATTRIBUTE) или если отсутствует функция
вывода (в SPI_result устанавливается SPI_ERROR_NOOUTFUNC).
1262Интерфейс програм-
мирования сервера
SPI_getbinval
SPI_getbinval — получить двоичное значение указанного столбца
Синтаксис
Datum SPI_getbinval(HeapTuple row, TupleDesc rowdesc, int colnumber,
bool * isnull)
Описание
SPI_getbinval возвращает значение указанного столбца во внутренней форме (в структуре Datum).
Эта функция не выделяет новый блок памяти для данных. В случае с типом, передаваемым по
ссылке, возвращаемым значением будет указатель на переданную строку данных.
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
bool * isnull
признак того, что столбец содержит NULL
Возвращаемое значение
Возвращается двоичное значение столбца. Если этот столбец содержит NULL, переменной, на ко-
торую указывает isnull, присваивается true; в противном случае — false.
При ошибке в SPI_result устанавливается SPI_ERROR_NOATTRIBUTE.
1263Интерфейс програм-
мирования сервера
SPI_gettype
SPI_gettype — получить имя типа данных указанного столбца
Синтаксис
char * SPI_gettype(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettype возвращает копию имени типа данных указанного столбца. (Когда эта копия имени
будет не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя типа данных указанного столбца, либо NULL в случае ошибки. При ошибке в SPI_result уста-
навливается SPI_ERROR_NOATTRIBUTE.
1264Интерфейс програм-
мирования сервера
SPI_gettypeid
SPI_gettypeid — получить OID типа данных указанного столбца
Синтаксис
Oid SPI_gettypeid(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettypeid возвращает OID типа данных указанного столбца.
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
OID типа данных указанного столбца, либо InvalidOid в случае ошибки. При ошибке в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1265Интерфейс програм-
мирования сервера
SPI_getrelname
SPI_getrelname — возвращает имя указанного отношения
Синтаксис
char * SPI_getrelname(Relation rel)
Описание
SPI_getrelname возвращает копию имени указанного отношения. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя указанного отношения.
1266Интерфейс програм-
мирования сервера
SPI_getnspname
SPI_getnspname — возвращает пространство имён указанного отношения
Синтаксис
char * SPI_getnspname(Relation rel)
Описание
SPI_getnspname возвращает копию имени пространства имён, к которому принадлежит указанное
отношение (Relation). Пространство имён по-другому называется схемой отношения. Когда зна-
чение, возвращённое этой функцией, будет не нужно, освободите его с помощью pfree.
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя пространства имён указанного отношения.
1267Интерфейс програм-
мирования сервера
SPI_result_code_string
SPI_result_code_string — возвращает код ошибки в виде строки
Синтаксис
const char * SPI_result_code_string(int code);
Описание
SPI_result_code_string выдаёт строковое представление для кода результата, который возвра-
щается различными функциями SPI или находится в SPI_result.
Аргументы
int code
код результата
Возвращаемое значение
Строковое представление кода результата.
47.3. Управление памятью
PostgreSQL выделяет память в контекстах памяти, и тем самым реализует удобный способ управ-
ления выделением памяти в различных местах, с разными сроками жизни выделенной памяти.
При уничтожении контекста освобождается вся выделенная в нём память. Таким образом, нет
необходимости контролировать каждый отдельный объект во избежание утечек памяти; вместо
этого достаточно управлять только небольшим числом контекстов. Функция palloc и родственные
ей освобождают память из «текущего» контекста.
SPI_connect создаёт новый контекст памяти и делает его текущим. SPI_finish восстанавли-
вает контекст, который был текущим до этого, и уничтожает контекст, созданный функцией
SPI_connect. Эти действия обеспечивают при выходе из вашей функции на C освобождение вре-
менной памяти, выделенной внутри этой функции, во избежание утечки памяти.
Однако если ваша функция на C должна вернуть объект в выделенной памяти (как значение ти-
па, передаваемого по ссылке), эту память нельзя выделять через palloc, как минимум пока уста-
новлено подключение к SPI. Если вы попытаетесь это сделать, объект будет освобождён при вы-
зове SPI_finish и ваша функция не будет работать надёжно. Для решения этой проблемы выде-
ляйте память для возвращаемого объекта, используя SPI_palloc. SPI_palloc выделяет память в
«верхнем контексте исполнителя», то есть, в контексте памяти, который был текущим при вызо-
ве SPI_connect; именно этот контекст подходит для значения, возвращаемого из функции на C.
Некоторые из вспомогательных функций, описанных в этом разделе, также возвращают объекты,
созданные в верхнем контексте исполнителя.
Когда вызывается SPI_connect, текущим контекстом становится частный контекст функции на C,
создаваемый в SPI_connect. Все операции выделения памяти, выполняемые функциями palloc,
repalloc или служебными функциями SPI (кроме описанных в этом разделе исключений), произво-
дятся в этом контексте. Когда функция на C отключается от менеджера SPI (выполняя SPI_finish),
текущим контекстом снова становится верхний контекст исполнителя, а вся память, выделенная
в контексте этой функции, освобождается, так что использовать её дальше нельзя.
1268Интерфейс програм-
мирования сервера
SPI_palloc
SPI_palloc — выделить память в верхнем контексте исполнителя
Синтаксис
void * SPI_palloc(Size size)
Описание
SPI_palloc выделяет память в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она выдаёт ошибку.
Аргументы
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на выделенный блок памяти заданного размера
1269Интерфейс програм-
мирования сервера
SPI_repalloc
SPI_repalloc — поменять блок памяти в верхнем контексте исполнителя
Синтаксис
void * SPI_repalloc(void * pointer, Size size)
Описание
SPI_repalloc изменяет размер блока памяти, ранее выделенного функцией SPI_palloc.
Эта функция теперь не отличается от простой repalloc. Она сохранена только для обратной сов-
местимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий изменению
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на новый блок памяти указанного размера, в который скопировано содержимое преж-
него блока
1270Интерфейс програм-
мирования сервера
SPI_pfree
SPI_pfree — освободить память в верхнем контексте исполнителя
Синтаксис
void SPI_pfree(void * pointer)
Описание
SPI_pfree освобождает память, ранее выделенную функцией SPI_palloc или SPI_repalloc.
Эта функция теперь не отличается от простой pfree. Она сохранена только для обратной совме-
стимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий освобождению
1271Интерфейс програм-
мирования сервера
SPI_copytuple
SPI_copytuple — скопировать строку в верхнем контексте исполнителя
Синтаксис
HeapTuple SPI_copytuple(HeapTuple row)
Описание
SPI_copytuple делает копию строки в верхнем контексте исполнителя. Обычно это применяется,
когда нужно вернуть изменённую строку из триггера. В функции, которая должна возвращать со-
ставной тип, нужно использовать SPI_returntuple.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
HeapTuple row
строка, подлежащая копированию
Возвращаемое значение
скопированная строка либо NULL в случае ошибки (SPI_result содержит код ошибки)
1272Интерфейс програм-
мирования сервера
SPI_returntuple
SPI_returntuple — подготовить строку для возврата в виде Datum
Синтаксис
HeapTupleHeader SPI_returntuple(HeapTuple row, TupleDesc rowdesc)
Описание
SPI_returntuple делает копию строки в верхнем контексте исполнителя и возвращает её в форме
типа Datum. Чтобы выдать результат, полученный указатель остаётся только преобразовать в Datum
функцией PointerGetDatum.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Заметьте, что эту операцию следует применять в функциях, объявленных как возвращающие со-
ставные типы. В триггерах она не применяется; чтобы вернуть изменённую строку из триггера,
используйте SPI_copytuple.
Аргументы
HeapTuple row
строка, подлежащая копированию
TupleDesc rowdesc
дескриптор строки (передавайте каждый раз один дескриптор для более эффективного кеши-
рования)
Возвращаемое значение
HeapTupleHeader, указывающий на скопированную строку, или NULL в случае ошибки (SPI_result
содержит код ошибки)
1273Интерфейс програм-
мирования сервера
SPI_modifytuple
SPI_modifytuple — создать строку, заменяя отдельные поля в данной
Синтаксис
HeapTuple SPI_modifytuple(Relation rel, HeapTuple row, int ncols,
int * colnum, Datum * values, const char * nulls)
Описание
SPI_modifytuple создаёт новую строку, подставляя новые значения для указанных столбцов и ко-
пируя исходное содержимое остальных столбцов. Исходная строка не изменяется. Новая строка
возвращается в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
Relation rel
Используется только в качестве дескриптора строки. (Передача отношения вместо собственно
дескриптора строки — нехорошая особенность.)
HeapTuple row
строка, подлежащая изменению
int ncols
число изменяемых столбцов
int * colnum
массив длины ncols, содержащий номера изменяемых столбцов (начиная с 1)
Datum * values
массив длины ncols, содержащий новые значения указанных столбцов
const char * nulls
массив длины ncols, описывающий, в каких столбцах передаётся NULL
Если в nulls передаётся NULL, SPI_modifytuple считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль ‘\0’ в конце не нужен.
Возвращаемое значение
новая строка с изменениями, размещённая в верхнем контексте исполнителя, или NULL при ошибке
(SPI_result содержит код ошибки)
В случае ошибки в SPI_result устанавливается:
SPI_ERROR_ARGUMENT
если rel — NULL, либо row — NULL, либо ncols меньше или равно 0, либо colnum — NULL, либо
values — NULL
1274Интерфейс програм-
мирования сервера
SPI_ERROR_NOATTRIBUTE
если colnum содержит недопустимый номер столбца (меньше или равен 0, либо больше числа
столбцов в строке row)
SPI_ERROR_UNCONNECTED
если SPI неактивен
1275Интерфейс програм-
мирования сервера
SPI_freetuple
SPI_freetuple — освободить строку, размещённую в верхнем контексте исполнителя
Синтаксис
void SPI_freetuple(HeapTuple row)
Описание
SPI_freetuple освобождает строку, ранее размещённую в верхнем контексте исполнителя.
Эта функция теперь не отличается от простой heap_freetuple. Она сохранена только для обратной
совместимости с существующим кодом.
Аргументы
HeapTuple row
строка, подлежащая освобождению
1276Интерфейс програм-
мирования сервера
SPI_freetuptable
SPI_freetuptable — освободить набор строк, созданный SPI_execute или подобной функцией
Синтаксис
void SPI_freetuptable(SPITupleTable * tuptable)
Описание
SPI_freetuptable освобождает набор строк, созданных предыдущей функцией SPI выполнения ко-
манд, например SPI_execute. Таким образом, при вызове этой функции в качестве аргумента часто
передаётся глобальная переменная SPI_tuptable.
Эта функция полезна, когда функция на C, использующая SPI, должна выполнить несколько ко-
манд, но не хочет сохранять результаты предыдущих команд до завершения. Заметьте, что любые
не освобождённые таким образом наборы строк будут всё равно освобождены при выполнении
SPI_finish. Кроме того, если была запущена подтранзакция, а затем она прервалась в ходе выпол-
нения использующей SPI функции, все наборы строк, созданные в рамках подтранзакции, будут
автоматически освобождены.
Начиная с PostgreSQL версии 9.3, SPI_freetuptable содержит защитную логику, отфильтровыва-
ющую повторные запросы на удаление одного и того же набора строк. В предыдущих версиях по-
вторное удаление могло приводить к сбоям.
Аргументы
SPITupleTable * tuptable
указатель на набор строк, который нужно освободить (если NULL, ничего не происходит)
1277Интерфейс програм-
мирования сервера
SPI_freeplan
SPI_freeplan — освободить ранее сохранённый подготовленный оператор
Синтаксис
int SPI_freeplan(SPIPlanPtr plan)
Описание
SPI_freeplan освобождает подготовленный оператор, до этого выданный функцией SPI_prepare
или сохранённый функциями SPI_keepplan и SPI_saveplan.
Аргументы
SPIPlanPtr plan
указатель на оператор, подлежащий освобождению
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
47.4. Управление транзакциями
Выполнять команды управления транзакциями (в частности, COMMIT и ROLLBACK) через функции
SPI, такие как SPI_execute, нельзя. Однако имеются отдельные интерфейсные функции, которые
предназначены для управления транзакциями через SPI.
Вообще говоря, не всегда безопасно и разумно начинать и заканчивать транзакции в произволь-
ных определяемых пользователями функциях, вызываемых из SQL, не принимая во внимание кон-
текст их вызова. Например, завершение транзакции в середине функции, вызванной в сложном
SQL-выражении внутри некоторой SQL-команды, скорее всего приведёт к странным внутренним
ошибкам или сбоям. Представленные здесь интерфейсные функции прежде всего предназначены
для использования реализациями процедурных языков с целью управления транзакциями в про-
цедурах уровня SQL, вызываемых командой CALL (при этом учитывается её контекст). Та же логи-
ка может быть реализована в процедурах на C, использующих SPI, но подробное освещение этой
темы выходит за рамки данной документации.
1278Интерфейс програм-
мирования сервера
SPI_commit
SPI_commit — зафиксировать текущую транзакцию
Синтаксис
void SPI_commit(void)
Описание
SPI_commit фиксирует текущую транзакцию. Это примерно равносильно выполнению SQL-коман-
ды COMMIT. После того как транзакция зафиксирована, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1279Интерфейс програм-
мирования сервера
SPI_rollback
SPI_rollback — прервать текущую транзакцию
Синтаксис
void SPI_rollback(void)
Описание
SPI_rollback откатывает текущую транзакцию. Это примерно равносильно выполнению SQL-ко-
манды ROLLBACK. После того как транзакция отменена, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1280Интерфейс програм-
мирования сервера
SPI_start_transaction
SPI_start_transaction — начать новую транзакцию
Синтаксис
void SPI_start_transaction(void)
Описание
Функция SPI_start_transaction начинает новую транзакцию. Она может вызываться только по-
сле SPI_commit или SPI_rollback, когда нет активной транзакции. Обычно, когда вызывается про-
цедура, использующая SPI, транзакция уже выполняется, поэтому при попытке начать ещё одну
до завершения текущей возникнет ошибка.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
47.5. Видимость изменений в данных
Видимость изменений в данных, которые производятся функциями, использующими SPI, (или лю-
быми другими функциями на C), описывается следующими правилами:
• В процессе выполнения SQL-команды любые произведённые ей изменения не видны для неё
самой. Например, в команде:
INSERT INTO a SELECT * FROM a;
вставляемые строки не видны в части SELECT.
• Изменения, произведённые командой К, видны во всех командах, запущенных после К, неза-
висимо от того, были ли эти команды запущены из К (во время выполнения К) или после за-
вершения К.
• Команды, выполняемые через SPI внутри функции, вызванной SQL-командой (будь то обычная
функция или триггер), следуют одному или другому из вышеприведённых правил в зависи-
мости флага чтения/записи, переданного SPI. Команды, выполняемые в режиме «только чте-
ние», следует первому правилу: они не видят изменений, произведённых вызывающей коман-
дой. Команды, выполняемые в режиме «чтение-запись», следуют второму правилу: они могут
видеть все произведённые к этому времени изменения.
• Все стандартные процедурные языки устанавливают режим чтения-записи в SPI в зависимо-
сти от атрибута изменчивости функции. Команды функций STABLE и IMMUTABLE выполняются в
режиме «только чтение», тогда как команды функций VOLATILE — в режиме «чтение-запись».
Хотя авторы функций на C могут нарушить это соглашение, вряд ли это будет хорошей идеей.
В следующем разделе приводится пример, иллюстрирующий применение этих правил.
47.6. Примеры
Этот раздел содержит очень простой пример использования SPI. Функция execq принимает в ка-
честве первого аргумента команду SQL, а в качестве второго число строк, выполняет команду, вы-
зывая SPI_exec, и возвращает число строк, обработанных этой командой. Более сложные примеры
работы с SPI вы можете найти в src/test/regress/regress.c в дереве исходного кода, а также в
модуле spi.
#include “postgres.h”
1281Интерфейс програм-
мирования сервера
#include “executor/spi.h”
#include “utils/builtins.h”
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(execq);
Datum
execq(PG_FUNCTION_ARGS)
{
char *command;
int cnt;
int ret;
uint64 proc;
/</em> Преобразовать данный текстовый объект в строку C <em>/
command = text_to_cstring(PG_GETARG_TEXT_PP(1));
cnt = PG_GETARG_INT32(2);
SPI_connect();
ret = SPI_exec(command, cnt);
proc = SPI_processed;
/</em></p>
<ul>
  <li>Если были выбраны какие-то строки, вывести их через elog(INFO).
*/
if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
{
TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
SPITupleTable *tuptable = SPI_tuptable;
char buf[8192];
uint64 j;
for (j = 0; j &lt; proc; j++)
{
HeapTuple tuple = tuptable-&gt;vals[j];
int i;
for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), “ %s%s”,
SPI_getvalue(tuple, tupdesc, i),
(i == tupdesc-&gt;natts) ? “ “ : “ |”);
elog(INFO, “EXECQ: %s”, buf);
}
}
SPI_finish();
pfree(command);
PG_RETURN_INT64(proc);
}
Так эта функция будет объявляться после того, как она будет скомпилирована в разделяемую биб-
лиотеку (подробности в Подразделе 38.10.5):
CREATE FUNCTION execq(text, integer) RETURNS int8
AS ‘имя_файла’
LANGUAGE C STRICT;
1282Интерфейс програм-
мирования сервера
Демонстрация использования:
=&gt; SELECT execq(‘CREATE TABLE a (x integer)’, 0);
execq
——-
0
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘INSERT INTO a VALUES (0)’, 0));
INSERT 0 1
=&gt; SELECT execq(‘SELECT * FROM a’, 0);
INFO: EXECQ: 0
– вставлено функцией execq
INFO: EXECQ: 1
– возвращено функцией execq и вставлено командой INSERT
execq
——-
2
(1 row)
=&gt; SELECT execq(‘INSERT INTO a SELECT x + 2 FROM a’, 1);
execq
——-
1
(1 row)
=&gt; SELECT execq(‘SELECT * FROM a’, 10);
INFO: EXECQ: 0
INFO: EXECQ: 1
INFO: EXECQ: 2
– 0 + 2, вставлена только одна строка - как указано
execq
——-
3
(1 row)
– 10 — только максимальное значение, 3 — реальное число строк
=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
– нет строк в a (0) + 1
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INFO: EXECQ: 1
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
2
– была одна строка в a + 1
(2 rows)
– Этот пример демонстрирует правило видимости изменений в данных:
=&gt; INSERT INTO a SELECT execq(‘SELECT * FROM a’, 0) * x FROM a;
1283Интерфейс програм-
мирования сервера
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 2
INSERT 0 2
=&gt; SELECT * FROM a;
x
—
1
2
2
– 2 строки * 1 (x в первой в строке)
6
– 3 строки (2 + 1 только вставленная) * 2 (x во второй строке)
(4 rows)
^^^^^^
строки, видимые в execq() при разных вызовах
1284</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" title="Глава 46. PL/Python — процедурный язык Python"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 46. PL/Python — процедурный язык Python"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-046/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" rel="bookmark" title="Глава 46. PL/Python — процедурный язык Python" itemprop="url">Глава 46. PL/Python — процедурный язык Python</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 46. PL/Python — процедурный язык Python</p>

<p>Процедурный язык PL/Python позволяет писать функции PostgreSQL на языке Python.
Чтобы установить PL/Python в определённую базу данных, выполните команду CREATE EXTENSION
plpythonu (но смотрите также Раздел 46.1).
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
PL/Python представлен только в виде «недоверенного» языка, что означает, что он никаким спо-
собом не ограничивает действия пользователей, и поэтому он называется plpythonu. Доверенная
вариация plpython может появиться в будущем, если в Python будет разработан безопасный меха-
низм выполнения. Автор функции на недоверенном языке PL/Python должен позаботиться о том,
чтобы эту функцию нельзя было использовать не по назначению, так как она может делать всё, что
может пользователь с правами администратора баз данных. Создавать функции на недоверенных
языках, таких как plpythonu, разрешено только суперпользователям.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Python в процессе установки. (За дополнительными сведениями обратитесь к инструк-
циям по установке.) Пользователи двоичных пакетов могут найти PL/Python в отдель-
ном модуле.
46.1. Python 2 и Python 3
PL/Python поддерживает две вариации языка: Python 2 и Python 3. (Более точная информация о
поддерживаемых второстепенных версиях Python может содержаться в инструкциях по установке
PostgreSQL.) Так как языки Python 2 и Python 3 несовместимы в некоторых важных аспектах, во
избежание смешения их в PL/Python применяется следующая схема именования:
• Язык PostgreSQL с именем plpython2u представляет реализацию PL/Python, основанную на ва-
риации языка Python 2.
• Язык PostgreSQL с именем plpython3u представляет реализацию PL/Python, основанную на ва-
риации языка Python 3.
• Язык с именем plpythonu представляет реализацию PL/Python, основанную на версии Python
по умолчанию, в данный момент это Python 2. (Этот выбор по умолчанию не зависит от того,
какая версия считается локальной версией «по умолчанию», например, на какую версию ука-
зывает /usr/bin/python.) Выбор по умолчанию в отдалённом будущем выпуске PostgreSQL
может быть сменён на Python 3, в зависимости от того, как будет происходить переход на
Python 3 в сообществе Python.
Эта схема аналогична рекомендациям, данным в PEP 394, по выбору имени команды python и
переходу с версии на версию.
Будет ли доступен PL/Python для Python 2 или для Python 3, либо сразу для обеих версий, зависит
от конфигурации сборки или установленных пакетов.
1210PL/Python — проце-
дурный язык Python
Подсказка
Какая вариация будет собрана, зависит от того, как версия Python будет найдена при
установке или будет задана в переменной окружения PYTHON; см. Раздел 16.4. Чтобы в
одной инсталляции присутствовали обе вариации PL/Python, необходимо сконфигури-
ровать и настроить дерево исходного кода дважды.
В результате формируется такая стратегия использования и смены определённой версии:
• Существующие пользователи и пользователи, которым в настоящее время неинтересен Python
3, могут выбрать имя языка plpythonu и им не придётся ничего менять в обозримом будущем.
Чтобы упростить миграцию на Python 3, которая произойдёт в конце концов, рекомендуется
постепенно проверять «готовность к будущему» кода, обновляя его до версий Python 2.6/2.7.
На практике многие функции PL/Python можно мигрировать на Python 3 с минимальными из-
менениями или вовсе без изменений.
• Пользователи, знающие, что их код очень сильно зависит от Python 2, и не планирующие ко-
гда-либо менять его, могут использовать имя языка plpython2u. Это будет работать ещё очень
и очень долго, пока в PostgreSQL не будет полностью ликвидирована поддержка Python 2.
• Пользователи, желающие погрузиться в Python 3, могут выбрать имя языка plpython3u, и их
код будет работать всегда, по сегодняшним стандартам. В отдалённом будущем, когда верси-
ей по умолчанию может стать Python 3, цифру «3» из имени языка можно будет убрать из эс-
тетических соображений.
• Смельчаки, желающие уже сегодня получить операционное окружение только с Python 3, мо-
гут модифицировать pg_pltemplate, чтобы имя plpythonu было равнозначно plpython3u, отда-
вая себе отчёт в том, что такая инсталляция будет несовместима с остальным миром.
Дополнительную информацию о переходе на Python 3 можно также найти в описании Что нового
в Python 3.0.
Использовать PL/Python на базе Python 2 и PL/Python на базе Python 3 в одном сеансе нельзя, так
как это приведёт к конфликту символов в динамических модулях, что может повлечь сбой сервер-
ного процесса PostgreSQL. В системе есть проверка, предотвращающая смешение основных вер-
сий Python в одном сеансе, которая прервёт сеанс при выявлении расхождения. Однако использо-
вать обе вариации в одной базе данных всё же возможно, обращаясь к ним в разных сеансах.
46.2. Функции на PL/Python
Функции на PL/Python объявляются стандартным образом с помощью команды CREATE FUNCTION:
CREATE FUNCTION funcname (argument-list)
RETURNS return-type
AS $$</p>
<h1 id="Тело-функции-на-plpython">Тело функции на PL/Python</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Тело функции содержит просто скрипт на языке Python. Когда вызывается функция, её аргументы
передаются в виде элементов списка args; именованные аргументы также передаются скрипту
Python как обычные переменные. С именованными аргументами скрипт обычно лучше читается.
Результат из кода Python возвращается обычным способом: командой return или yield (в случае
функции, возвращающей множество). Если возвращаемое значение не определено, Python возвра-
щает None. Исполнитель PL/Python преобразует None языка Python в значение NULL языка SQL.
В процедуре код Python должен возвращать None (обычно для этого процедура завершается без
оператора return или используется оператор return без аргумента); в противном случае выдаётся
ошибка.
Например, функцию, возвращающее большее из двух целых чисел, можно определить так:
1211PL/Python — проце-
дурный язык Python
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS</script>
if a &gt; b:
return a
return b
<script type="math/tex">LANGUAGE plpythonu;
Код на Python, заданный в качестве тела объявляемой функции, становится телом функции Python.
Например, для показанного выше объявления получается функция:
def __plpython_procedure_pymax_23456():
if a > b:
return a
return b
Здесь 23456 — это OID, который PostgreSQL присвоил данной функции.
Значения аргументов задаются в глобальных переменных. Согласно правилам видимости в Python,
тонким следствием этого является то, что переменной аргумента нельзя присвоить внутри функ-
ции выражение, включающее имя самой этой переменной, если только эта переменная не объяв-
лена глобальной в текущем блоке. Например, следующий код не будет работать:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS</script>
x = x.strip() # ошибка
return x
<script type="math/tex">LANGUAGE plpythonu;
так как присвоение x значения делает x локальной переменной для всего блока, и при этом x
в правой части присваивания оказывается ещё не определённой локальной переменной x, а не
параметром функции PL/Python. Добавив оператор global, это можно исправить:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS</script>
global x
x = x.strip() # теперь всё в порядке
return x
<script type="math/tex">LANGUAGE plpythonu;
Однако рекомендуется не полагаться на такие особенности реализации PL/Python, а принять, что
параметры функции предназначены только для чтения.
46.3. Значения данных
Вообще говоря, цель исполнителя PL/Python — обеспечить «естественное» соответствие между
мирами PostgreSQL и Python. Этим объясняется выбор правил сопоставления данных, описанных
ниже.
46.3.1. Сопоставление типов данных
Когда вызывается функция PL/Python, её аргументы преобразуются из типа PostgreSQL в соответ-
ствующий тип Python по таким правилам:
• Тип PostgreSQL boolean преобразуется в bool языка Python.
• Типы PostgreSQL smallint и int преобразуются в тип int языка Python. Типы PostgreSQL
bigint и oid становятся типами long в Python 2 и int в Python 3.
• Типы PostgreSQL real и double преобразуются в тип float языка Python.
• Тип PostgreSQL numeric преобразуется в Decimal среды Python. Этот тип импортируется из
пакета cdecimal, при его наличии. В противном случае используется decimal.Decimal из
1212PL/Python — проце-
дурный язык Python
стандартной библиотеки. Тип cdecimal работает значительно быстрее, чем decimal. Однако
в Python версии 3.3 и выше тип cdecimal включается в стандартную библиотеку под именем
decimal, так что теперь этого различия нет.
• Тип PostgreSQL bytea становится типом str в Python 2 и bytes в Python 3. В Python 2 такую
строку следует воспринимать как последовательность байт без какой-либо определённой ко-
дировки символов.
• Все другие типы данных, включая типы символьных строк PostgreSQL, преобразуются в тип
str языка Python. В Python 2 эта строка будет передаваться в кодировке сервера PostgreSQL; в
Python 3 это будет строка в Unicode, как и все строки.
• Информация о нескалярных типах данных приведена ниже.
При завершении функции PL/Python её значение результата преобразуется в тип данных, объяв-
ленный как тип результата в PostgreSQL, следующим образом:
• Когда тип результата функции в PostgreSQL — boolean, возвращаемое значение приводится к
логическому типу по правилам, принятым в Python. То есть false будет возвращено для 0 и пу-
стой строки, но, обратите внимание, для 'f' будет возвращено true.
• Когда тип результата функции PostgreSQL — bytea, возвращаемое значение будет преобразо-
вано в строку (Python 2) или набор байт (Python 3), используя встроенные средства Python, а
затем будет приведено к типу bytea.
• Для всех других типов результата PostgreSQL возвращаемое значение преобразуется в строку
с помощью встроенной в Python функции str, и полученная строка передаётся функции ввода
типа данных PostgreSQL. (Если значение в Python имеет тип float, оно преобразуется встро-
енной функцией repr, а не str, для недопущения потери точности.)
Из кода Python 2 строки должны передаваться в PostgreSQL в кодировке сервера PostgreSQL.
При передаче строки, неприемлемой для текущей кодировки сервера, возникает ошибка, но
не все несоответствия кодировки могут быть выявлены, так что с некорректной кодировкой
всё же могут быть получены нечитаемые строки. Строки Unicode переводятся в нужную коди-
ровку автоматически, так что использовать их может быть безопаснее и удобнее. В Python 3
все строки имеют кодировку Unicode.
• Информация о нескалярных типах данных приведена ниже.
Заметьте, что логические несоответствия между объявленным в PostgreSQL типом результата и
типом фактически возвращаемого объекта Python игнорируются — значение преобразуется в лю-
бом случае.
46.3.2. Null, None
Если функции передаётся значение SQL NULL, в Python значением этого аргумента будет None.
Например, функция pymax, определённая как показано в Раздел 46.2, возвратит неверный ответ,
получив аргументы NULL. Мы могли бы добавить указание STRICT в определение функции, чтобы
PostgreSQL поступал немного разумнее: при передаче значения NULL функция вовсе не будет
вызываться, будет сразу возвращён результат NULL. С другой стороны, мы могли бы проверить
аргументы на NULL в теле функции:
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS</script>
if (a is None) or (b is None):
return None
if a &gt; b:
return a
return b
<script type="math/tex">LANGUAGE plpythonu;
Как показано выше, чтобы выдать из функции PL/Python значение SQL NULL, нужно вернуть зна-
чение None. Это можно сделать и в строгой, и в нестрогой функции.
1213PL/Python — проце-
дурный язык Python
46.3.3. Массивы, списки
Значения массивов SQL передаются в PL/Python в виде списка Python. Чтобы вернуть значение
массива SQL из функции PL/Python, возвратите список Python:
CREATE FUNCTION return_arr()
RETURNS int[]
AS</script>
return [1, 2, 3, 4, 5]
<script type="math/tex">LANGUAGE plpythonu;
SELECT return_arr();
return_arr
-------------
(1,2,3,4,5)
(1 row)
Многомерные массивы передаются в PL/Python в виде вложенных списков Python. Например, двух-
мерный массив представляется как список списков. При передаче многомерного массива SQL из
функции PL/Python необходимо, чтобы все внутренние списки на каждом уровне имели одинако-
вый размер. Например:
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS</script>
plpy.info(x, type(x))
return x
<script type="math/tex">% <![CDATA[
LANGUAGE plpythonu;
SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO: ([[1, 2, 3], [4, 5, 6]], <type 'list'>)
test_type_conversion_array_int4
---------------------------------
((1,2,3),(4,5,6))
(1 row)
Другие последовательности Python, например кортежи, тоже принимаются для обратной совме-
стимости с PostgreSQL версии 9.6 и ниже (где многомерные массивы не поддерживались). Однако
они всегда воспринимаются как одномерные массивы, чтобы не возникало неоднозначности с со-
ставными типами. По этой же причине когда в многомерном массиве используется составной тип,
он должен представляться как кортеж, а не список.
Учтите, что в Python и строки являются последовательностями, что может давать неожиданные
эффекты, хорошо знакомые тем, кто программирует на Python:
CREATE FUNCTION return_str_arr()
RETURNS varchar[]
AS %]]></script>
return “hello”
<script type="math/tex">LANGUAGE plpythonu;
SELECT return_str_arr();
return_str_arr
----------------
(h,e,l,l,o)
(1 row)
46.3.4. Составные типы
Аргументы составного типа передаются функции в виде сопоставлений Python. Именами элемен-
тов сопоставления являются атрибуты составного типа. Если атрибут в переданной строке имеет
значение NULL, он передаётся в сопоставлении значением None. Пример работы с составным ти-
пом:
1214PL/Python — проце-
дурный язык Python
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid (e employee)
RETURNS boolean
AS</script>
if e[“salary”] &gt; 200000:
return True
if (e[“age”] &lt; 30) and (e[“salary”] &gt; 100000):
return True
return False
<script type="math/tex">LANGUAGE plpythonu;
Возвратить составной тип или строку таблицы из функции Python можно несколькими способами.
В следующих примерах предполагается, что у нас объявлен тип:
CREATE TYPE named_value AS (
name
text,
value integer
);
Результат этого типа можно вернуть как:
Последовательность (кортеж или список, но не множество, так как оно не индексируется)
В возвращаемых объектах последовательностей должно быть столько элементов, сколько полей
в составном типе результата. Элемент с индексом 0 присваивается первому полю составного
типа, с индексом 1 — второму и т. д. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
return ( name, value )</p>
<h1 id="или-альтернативный-вариант-в-виде-кортежа-return--name-value-">или альтернативный вариант, в виде кортежа: return [ name, value ]</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте в соответствующую позицию None.
Когда возвращается массив составных значений, его нельзя представить в виде списка, так как
невозможно однозначно определить, представляет ли список Python составной тип или ещё
одну размерность массива.
Сопоставление (словарь)
Значение столбца результата получается из сопоставления, в котором ключом является имя
столбца. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
return ( “name”: name, “value”: value )
<script type="math/tex">LANGUAGE plpythonu;
Любые дополнительные пары ключ/значение в словаре игнорируются, а отсутствие нужных
ключей считается ошибкой. Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте None
с именем соответствующего столбца в качестве ключа.
Объект (любой объект с методом __getattr__)
Объект передаётся аналогично сопоставлению. Пример:
1215PL/Python — проце-
дурный язык Python
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
class named_value:
def <strong>init</strong> (self, n, v):
self.name = n
self.value = v
return named_value(name, value)</p>
<h1 id="или-просто">или просто</h1>
<p>class nv: pass
nv.name = name
nv.value = value
return nv
<script type="math/tex">LANGUAGE plpythonu;
Также поддерживаются функции с параметрами OUT (выходными). Например:
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS</script>
return (1, 2)
<script type="math/tex">LANGUAGE plpythonu;
SELECT * FROM multiout_simple();
Выходные параметры процедуры выдаются таким же образом. Например:
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS</script>
return (a * 3, b * 3)
<script type="math/tex">LANGUAGE plpythonu;
CALL python_triple(5, 10);
46.3.5. Функции, возвращающие множества
Функция PL/Python также может возвращать множества, содержащие скалярные и составные ти-
пы. Это можно осуществить разными способами, так как возвращаемый объект внутри превраща-
ется в итератор. В следующих примерах предполагается, что у нас есть составной тип:
CREATE TYPE greeting AS (
how text,
who text
);
Множество в качестве результата можно возвратить, применив:
Последовательность (кортеж, список, множество)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script></p>
<h1 id="возвращает-кортеж-содержащий-списки-в-качестве-составных-типов">возвращает кортеж, содержащий списки в качестве составных типов</h1>
<h1 id="также-будут-работать-и-остальные-комбинации">также будут работать и остальные комбинации</h1>
<p>return ( [ how, “World” ], [ how, “PostgreSQL” ], [ how, “PL/Python” ] )
<script type="math/tex">LANGUAGE plpythonu;
Итератор (любой объект, реализующий методы __iter__ и next)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script>
class producer:
def <strong>init</strong> (self, how, who):
1216PL/Python — проце-
дурный язык Python
self.how = how
self.who = who
self.ndx = -1
def <strong>iter</strong> (self):
return self
def next (self):
self.ndx += 1
if self.ndx == len(self.who):
raise StopIteration
return ( self.how, self.who[self.ndx] )
return producer(how, [ “World”, “PostgreSQL”, “PL/Python” ])
<script type="math/tex">LANGUAGE plpythonu;
Генератор (yield)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script>
for who in [ “World”, “PostgreSQL”, “PL/Python” ]:
yield ( how, who )
<script type="math/tex">LANGUAGE plpythonu;
Также поддерживаются функции, возвращающие множества, с параметрами OUT (объявленные с
RETURNS SETOF record). Например:
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS
SETOF record AS</script>
return [(1, 2)] * n
<script type="math/tex">LANGUAGE plpythonu;
SELECT * FROM multiout_simple_setof(3);
46.4. Совместное использование данных
Для сохранения внутренних данных при повторных вызовах одной и той же функции предусмотрен
глобальный словарь SD. Для размещения публичных данных предназначен глобальный словарь GD,
доступный всем функциям на Python в сеансе; используйте его с осторожностью.
Каждая функция получает собственную среду выполнения в интерпретаторе Python, так что гло-
бальные данные и аргументы функции, например myfunc, не будут доступны в myfunc2. Исключе-
ние составляют данные в словаре GD, как сказано выше.
46.5. Анонимные блоки кода
PL/Python также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO</script></p>
<h1 id="Код-на-plpython">Код на PL/Python</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
46.6. Триггерные функции
Когда функция используется как триггер, словарь TD содержит значения, связанные с работой
триггера:
1217PL/Python — проце-
дурный язык Python
TD["event"]
содержит название события в виде строки: INSERT, UPDATE, DELETE или TRUNCATE.
TD["when"]
содержит одну из строк: BEFORE, AFTER или INSTEAD OF.
TD["level"]
содержит ROW или STATEMENT.
TD["new"]
TD["old"]
Для триггера уровня строки одно или оба этих поля содержат соответствующие строки тригге-
ра, в зависимости от события триггера.
TD["name"]
содержит имя триггера.
TD["table_name"]
содержит имя таблицы, для которой сработал триггер.
TD["table_schema"]
содержит схему таблицы, для которой сработал триггер.
TD["relid"]
содержит OID таблицы, для которой сработал триггер.
TD["args"]
Если в команде CREATE TRIGGER задавались аргументы, их можно получить как элементы мас-
сива с TD["args"][0] по TD["args"][n-1].
Если в TD["when"] передано BEFORE или INSTEAD OF, а в TD["level"] — ROW, вы можете вернуть
значение None или "OK" из функции Python, чтобы показать, что строка не была изменена, значение
"SKIP", чтобы прервать событие, либо, если в TD["event"] передана команда INSERT или UPDATE,
вы можете вернуть "MODIFY", чтобы показать, что новая строка была изменена. Во всех других
случаях возвращаемое значение игнорируется.
46.7. Обращение к базе данных
Исполнитель языка PL/Python автоматически импортирует модуль Python с именем plpy. Вы в сво-
ём коде можете использовать функции и константы, объявленные в этом модуле, обращаясь к ним
по именам вида plpy.имя.
46.7.1. Функции обращения к базе данных
Модуль plpy содержит различные функции для выполнения команд в базе данных:
plpy.execute(запрос [, макс-строк])
При вызове plpy.execute со строкой запроса и необязательным аргументом, ограничивающим
число строк, выполняется заданный запрос, а то, что он выдаёт, возвращается в виде объекта
результата.
Объект результата имитирует список или словарь. Получить из него данные можно по номеру
строки и имени столбца. Например, команда:
rv = plpy.execute("SELECT * FROM my_table", 5)
1218PL/Python — проце-
дурный язык Python
вернёт не более 5 строк из отношения my_table. Если в my_table есть столбец my_column, к
нему можно обратиться так:
foo = rv[i]["my_column"]
Число возвращённых в этом объекте строк можно получить, воспользовавшись встроенной
функцией len.
Для объекта результата определены следующие дополнительные методы:
nrows()
Возвращает число строк, обработанных командой. Заметьте, что это число не обязательно
будет равно числу возвращённых строк. Например, команда UPDATE устанавливает это зна-
чение, но не возвращает строк (без указания RETURNING).
status()
Значение состояния, возвращённое SPI_execute().
colnames()
coltypes()
coltypmods()
Возвращают список имён столбцов, список OID типов столбцов и список модификаторов
типа этих столбцов, соответственно.
Эти методы вызывают исключение, когда им передаётся объект, полученный от команды, не
возвращающей результирующий набор, например, UPDATE без RETURNING, либо DROP TABLE.
Но эти методы вполне можно использовать с результатом, содержащим ноль строк.
__str__()
Стандартный метод __str__ определён так, чтобы можно было, например, вывести отладоч-
ное сообщение с результатами запроса, вызвав plpy.debug(rv).
Объект результата может быть изменён.
Заметьте, что при вызове plpy.execute весь набор результатов будет прочитан в память. Эту
функцию следует использовать, только если вы знаете, что набор будет относительно неболь-
шим. Если вы хотите исключить риск переполнения памяти при выборке результатов большого
объёма, используйте plpy.cursor вместо plpy.execute.
plpy.prepare(запрос [, типы_аргументов])
plpy.execute(план [, аргументы [, макс-строк]])
Функция plpy.prepare подготавливает план выполнения для запроса. Она вызывается со стро-
кой запроса и списком типов параметров (если в запросе есть параметры). Например:
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1",
["text"])
Здесь text представляет переменную, передаваемую в качестве параметра $1. Второй аргумент
необязателен, если запросу не нужно передавать никакие параметры.
Чтобы запустить подготовленный оператор на выполнение, используйте вариацию функции
plpy.execute:
rv = plpy.execute(plan, ["name"], 5)
Передайте план в первом аргументе (вместо строки запроса), а список значений, которые будут
подставлены в запрос, — во втором. Второй аргумент можно опустить, если запрос не прини-
мает никакие параметры. Третий аргумент, как и раньше, задаёт необязательное ограничение
максимального числа строк.
1219PL/Python — проце-
дурный язык Python
Вы также можете вызвать метод execute объекта плана:
rv = plan.execute(["name"], 5)
Параметры запросов и поля строк результата преобразуются между типами данных PostgreSQL
и Python как описано в Разделе 46.3.
Когда вы подготавливаете план, используя модуль PL/Python, он сохраняется автоматически.
Что это означает, вы можете узнать в документации SPI (Глава 47). Чтобы эффективно исполь-
зовать это в нескольких вызовах функции, может потребоваться применить словарь постоянно-
го хранения SD или GD (см. Раздел 46.4). Например:
CREATE FUNCTION usesavedplan() RETURNS trigger AS</script>
if “plan” in SD:
plan = SD[“plan”]
else:
plan = plpy.prepare(“SELECT 1”)
SD[“plan”] = plan</p>
<h1 id="остальной-код-функции">остальной код функции</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
plpy.cursor(запрос)
plpy.cursor(план [, аргументы])
Функция plpy.cursor принимает те же аргументы, что и plpy.execute (кроме ограничения
строк) и возвращает объект курсора, который позволяет обрабатывать объёмные наборы ре-
зультатов небольшими порциями. Как и plpy.execute, этой функции можно передать строку
запроса или объект плана со списком аргументов, а можно вызывать функцию cursor как ме-
тод объекта плана.
Объект курсора реализует метод fetch, который принимает целочисленный параметр и воз-
вращает объект результата. При каждом следующем вызове fetch возвращаемый объект будет
содержать следующий набор строк, в количестве, не превышающем значение параметра. Ко-
гда строки закончатся, fetch начнёт возвращать пустой объект результата. Объекты курсора
также предоставляют интерфейс итератора, выдающий по строке за один раз, пока не будут
выданы все строки. Данные, выбираемые таким образом, возвращаются не как объекты резуль-
тата, а как словари (одной строке результата соответствует один словарь).
Следующий пример демонстрирует обработку содержимого большой таблицы двумя способа-
ми:
CREATE FUNCTION count_odd_iterator() RETURNS integer AS</script>
odd = 0
for row in plpy.cursor(“select num from largetable”):
if row[‘num’] % 2:
odd += 1
return odd
<script type="math/tex">LANGUAGE plpythonu;
CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS</script>
odd = 0
cursor = plpy.cursor(“select num from largetable”)
while True:
rows = cursor.fetch(batch_size)
if not rows:
break
for row in rows:
if row[‘num’] % 2:
odd += 1
return odd
<script type="math/tex">LANGUAGE plpythonu;
1220PL/Python — проце-
дурный язык Python
CREATE FUNCTION count_odd_prepared() RETURNS integer AS</script>
odd = 0
plan = plpy.prepare(“select num from largetable where num % $1 &lt;&gt; 0”, [“integer”])
rows = list(plpy.cursor(plan, [2])) # или: = list(plan.cursor([2]))
return len(rows)
<script type="math/tex">LANGUAGE plpythonu;
Курсоры ликвидируются автоматически. Но если вы хотите явно освободить все ресурсы, за-
нятые курсором, вызовите метод close. Продолжать получать данные через курсор, который
был закрыт, нельзя.
Подсказка
Не путайте объекты, создаваемые функцией plpy.cursor, с курсорами DB-API, опре-
делёнными в спецификации API для работы с базами данных в Python. Они не име-
ют ничего общего, кроме имени.
46.7.2. Обработка ошибок
Функции, обращающиеся к базе данных, могут сталкиваться с ошибками, в результате которых
они будут прерываться и вызывать исключение. Обе функции plpy.execute и plpy.prepare могут
вызывать экземпляр подкласса исключения plpy.SPIError, которое по умолчание прекращает вы-
полнение функции. Эту ошибку можно обработать, как и любое другое исключение в Python, при-
менив конструкцию try/except. Например:
CREATE FUNCTION try_adding_joe() RETURNS text AS</script>
try:
plpy.execute(“INSERT INTO users(username) VALUES (‘joe’)”)
except plpy.SPIError:
return “something went wrong”
else:
return “Joe added”
<script type="math/tex">LANGUAGE plpythonu;
Фактический класс вызываемого исключения соответствует определённому условию возник-
новения ошибки. Список всех возможных условий приведён в Таблице  A.1. В модуле
plpy.spiexceptions определяются классы исключений для каждого условия PostgreSQL, с име-
нами, производными от имён условий. Например, имя division_by_zero становится именем
DivisionByZero, unique_violation — именем UniqueViolation, fdw_error — именем FdwError и т.
д. Все эти классы исключений наследуются от SPIError. Такое разделение на классы упрощает
обработку определённых ошибок, например:
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS</script>
from plpy import spiexceptions
try:
plan = plpy.prepare(“INSERT INTO fractions (frac) VALUES ($1 / $2)”, [“int”,
“int”])
plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
return “denominator cannot equal zero”
except spiexceptions.UniqueViolation:
return “already have that fraction”
except plpy.SPIError, e:
return “other error, SQLSTATE %s” % e.sqlstate
else:
return “fraction inserted”
1221PL/Python — проце-
дурный язык Python
<script type="math/tex">LANGUAGE plpythonu;
Заметьте, что так как все исключения из модуля plpy.spiexceptions наследуются от исключения
SPIError, команда except, обрабатывающая это исключение, будет перехватывать все ошибки при
обращении к базе данных.
В качестве другого варианта обработки различных условий ошибок, вы можете перехватывать ис-
ключение SPIError и определять конкретное условие ошибки внутри блока except по значению ат-
рибута sqlstate объекта исключения. Этот атрибут содержит строку с кодом ошибки «SQLSTATE».
Конечный результат при таком подходе примерно тот же.
46.8. Явные подтранзакции
Перехват ошибок, произошедших при обращении к базе данных, как описано в Подразделе 46.7.2,
может привести к нежелательной ситуации, когда часть операций будет успешно выполнена,
прежде чем произойдёт сбой. Данные останутся в несогласованном состоянии после обработки
такой ошибки. PL/Python предлагает решение этой проблемы в форме явных подтранзакций.
46.8.1. Менеджеры контекста подтранзакций
Рассмотрим функцию, осуществляющую перевод средств между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS</script>
try:
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
Если при выполнении второго оператора UPDATE произойдёт исключение, эта функция сообщит
об ошибке, но результат первого UPDATE будет, тем не менее, зафиксирован. Другими словами,
средства будут списаны со счёта Джо, но не зачислятся на счёт Мэри.
Во избежание таких проблем вы можете завернуть вызовы plpy.execute в явную подтранзакцию.
Модуль plpy предоставляет вспомогательный объект для управления явными подтранзакциями,
создаваемый функцией plpy.subtransaction(). Объекты, созданные этой функцией, реализуют
интерфейс менеджера контекста. Используя явные подтранзакции, мы можем переписать нашу
функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS</script>
try:
with plpy.subtransaction():
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
1222PL/Python — проце-
дурный язык Python
Заметьте, что конструкция try/catch по-прежнему нужна. Без неё исключение распространится
вверх по стеку Python и приведёт к прерыванию всей функции с ошибкой PostgreSQL, так что в
таблицу operations запись не добавится. Менеджер контекста подтранзакции не перехватывает
ошибки, он только гарантирует, что все операции с базой данных в его области действия будут
атомарно зафиксированы или отменены. Откат блока подтранзакции происходит при исключении
любого вида, а не только исключения, вызванного ошибками при обращении к базе данных. Обыч-
ное исключение Python, вызванное внутри блока явной подтранзакции, также приведёт к откату
этой подтранзакции.
46.8.2. Старые версии Python
Синтаксис использования менеджеров контекста с ключевым словом with по умолчанию поддер-
живается в Python 2.6. В PL/Python с более старой версией Python тоже возможно использовать
явные подтранзакции, хотя и не так прозрачно. При этом вы можете вызывать методы __enter__
и __exit__ менеджера контекста по удобным псевдонимам enter и exit. Для такого случая функ-
цию перечисления средств можно переписать так:
CREATE FUNCTION transfer_funds_old() RETURNS void AS</script>
try:
subxact = plpy.subtransaction()
subxact.enter()
try:
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except:
import sys
subxact.exit(*sys.exc_info())
raise
else:
subxact.exit(None, None, None)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
Примечание
Хотя менеджеры контекста были реализованы в 2.5, для использования синтаксиса
with в этой версии нужно применить «будущий оператор». Однако по техническим
причинам «будущие операторы» в функциях PL/Python использовать нельзя.
46.9. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в ко-
манде DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, вызови-
те plpy.commit(), а чтобы откатить — plpy.rollback(). (Заметьте, что выполнить SQL-команды
COMMIT или ROLLBACK через plpy.execute или подобную функцию нельзя. Соответствующие опера-
ции могут выполняться только данными функциями.) После завершения одной транзакции следу-
ющая начинается автоматически, отдельной функции для этого нет.
Пример:
1223PL/Python — проце-
дурный язык Python
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS</script>
for i in range(0, 10):
plpy.execute(“INSERT INTO test1 (a) VALUES (%d)” % i)
if i % 2 == 0:
plpy.commit()
else:
plpy.rollback()
<script type="math/tex">;
CALL transaction_test1();
Транзакцию нельзя завершить в случае существования открытой явной подтранзакции.
46.10. Вспомогательные функции
Модуль plpy также предоставляет функции
plpy.debug( msg, **kwargs )
plpy.log( msg, **kwargs )
plpy.info( msg, **kwargs )
plpy.notice( msg, **kwargs )
plpy.warning( msg, **kwargs )
plpy.error( msg, **kwargs )
plpy.fatal( msg, **kwargs )
Функции plpy.error и plpy.fatal на самом деле выдают исключение Python, которое, если его
не перехватить, распространяется в вызывающий запрос, что приводит к прерыванию текущей
транзакции или подтранзакции. Команды raise plpy.Error(msg) и raise plpy.Fatal(msg) рав-
нозначны вызовам plpy.error(msg) и plpy.fatal(msg), соответственно, но форма raise не позво-
ляет передавать аргументы с ключами. Другие функции просто выдают сообщения разных уров-
ней важности. Будут ли сообщения определённого уровня передаваться клиентам и/или записы-
ваться в журнал сервера, определяется конфигурационными переменными log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
Аргумент msg задаётся как позиционный. Для обратной совместимости может быть передано
несколько позиционных аргументов. В этом случае сообщением для клиента становится строковое
представление кортежа позиционных аргументов.
Дополнительно только по ключам принимаются следующие аргументы:
detail
hint
sqlstate
schema_name
table_name
column_name
datatype_name
constraint_name
Строковое представление объектов, передаваемых в аргументах по ключам, позволяет выдать кли-
енту более богатую информацию. Например:
CREATE FUNCTION raise_custom_exception() RETURNS void AS</script>
plpy.error(“custom exception message”,
detail=”some info about exception”,
hint=”hint for users”)
$$ LANGUAGE plpythonu;
1224PL/Python — проце-
дурный язык Python
=# SELECT raise_custom_exception();
ERROR: plpy.Error: custom exception message
DETAIL: some info about exception
HINT: hint for users
CONTEXT: Traceback (most recent call last):
PL/Python function “raise_custom_exception”, line 4, in <module>
hint="hint for users")
PL/Python function "raise_custom_exception"
Ещё
один
набор
вспомогательных
функций
образуют
plpy.quote_literal(строка),
plpy.quote_nullable(строка) и plpy.quote_ident(строка). Они равнозначны встроенным функ-
циям заключения в кавычки, описанным в Разделе 9.4. Они полезны при конструировании свобод-
но составляемых запросов. На PL/Python динамический SQL, показанный в Примере 43.1, форми-
руется так:
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
plpy.quote_ident(colname),
plpy.quote_nullable(newvalue),
plpy.quote_literal(keyvalue)))
46.11. Переменные окружения
Некоторые переменные окружения, воспринимаемые интерпретатором Python, тоже могут влиять
на поведение PL/Python. При необходимости их нужно установить в среде основного серверного
процесса PostgreSQL, например, в скрипте запуска. Множество доступных переменных окружения
зависит от версии Python; за подробностями обратитесь к документации Python. На момент напи-
сания этой документации, на поведение PL/Python влияли следующие переменные окружения, при
наличии подходящей версии Python:
• PYTHONHOME
• PYTHONPATH
• PYTHONY2K
• PYTHONOPTIMIZE
• PYTHONDEBUG
• PYTHONVERBOSE
• PYTHONCASEOK
• PYTHONDONTWRITEBYTECODE
• PYTHONIOENCODING
• PYTHONUSERBASE
• PYTHONHASHSEED
(Похоже, что вследствие тонкостей реализации Python, не зависящих от исполнителя PL/Python,
некоторые переменные окружения, перечисленные на странице руководства man python, действу-
ют только в интерпретаторе для командной строки, но не во встраиваемом интерпретаторе Python.)
1225</module></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page10/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page9/">9</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page10/">10</a></li>
      
    
      
        <li><strong class="current-page">11</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page12/">12</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page13/">13</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page12/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>