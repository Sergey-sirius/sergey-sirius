<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page11/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page11/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-049/" title="Глава 49. Логическое декодирование"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 49. Логическое декодирование"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-049/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~13 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-049/" rel="bookmark" title="Глава 49. Логическое декодирование" itemprop="url">Глава 49. Логическое декодирование</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 49. Логическое декодирование</p>

<p>PostgreSQL обеспечивает инфраструктуру для потоковой передачи изменений, выполняемых че-
рез SQL, внешним потребителям. Эта функциональность может быть полезна для самых разных
целей, включая аудит и реализацию репликации.
Изменения передаются в потоках, связываемых со слотами логической репликации.
Формат, в котором передаются изменения, определяет используемый модуль вывода. Пример мо-
дуля вывода включён в дистрибутив PostgreSQL. Также возможно разработать и другие модули,
расширяющие выбор доступных форматов, не затрагивая код ядра самого сервера. Любой модуль
вывода получает на вход отдельные строки, создаваемые командой INSERT, и новые версии строк,
которые создаёт UPDATE. Доступность старых версий строк для UPDATE и DELETE зависит от выбора
варианта идентификации реплики (см. описание REPLICA IDENTITY).
Изменения могут быть получены либо по протоколу потоковой репликации (см. Раздел 53.4 и Раз-
дел 49.3), либо через функции, вызываемые в SQL (см. Раздел 49.4). Также возможно разработать
дополнительные методы для обработки данных, поступающих через слот репликации, не модифи-
цируя код ядра сервера (см. Раздел 49.7).
49.1. Примеры логического декодирования
Следующий пример демонстрирует управление логическим декодированием на уровне SQL.
Прежде чем вы сможете использовать логическое декодирование, вы должны установить в
wal_level значение logical, а в max_replication_slots значение, не меньшее 1. После этого вы долж-
ны подключиться к целевой базе данных (в следующем примере, это postgres) как суперпользо-
ватель.
postgres=# – Создать слот с именем ‘regression_slot’, использующий модуль вывода
‘test_decoding’
postgres=# SELECT * FROM pg_create_logical_replication_slot(‘regression_slot’,
‘test_decoding’);
slot_name
|
lsn
—————–+———–
regression_slot | 0/16B1970
(1 row)
postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn,
confirmed_flush_lsn FROM pg_replication_slots;
slot_name
|
plugin
| slot_type | database | active | restart_lsn |
confirmed_flush_lsn
—————–+—————+———–+———-+——–+————-
+—————–
regression_slot | test_decoding | logical
| postgres | f
| 0/16A4408
|
0/16A4440
(1 row)
postgres=# – Пока никакие изменения не видны
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
lsn | xid | data
—–+—–+——
(0 rows)
postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE
postgres=# – DDL не реплицируется, поэтому видна только транзакция
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
1289Логическое декодирование
lsn
| xid |
data
———–+——-+————–
0/BA2DA58 | 10297 | BEGIN 10297
0/BA5A5A0 | 10297 | COMMIT 10297
(2 rows)
postgres=# – Когда изменения прочитаны, они считаются обработанными и уже не выдаются
postgres=# – в последующем вызове:
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
lsn | xid | data
—–+—–+——
(0 rows)
postgres=#
postgres=#
postgres=#
postgres=#
BEGIN;
INSERT INTO data(data) VALUES(‘1’);
INSERT INTO data(data) VALUES(‘2’);
COMMIT;
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A688 | 10298 | BEGIN 10298
0/BA5A6F0 | 10298 | table public.data: INSERT: id[integer]:1 data[text]:’1’
0/BA5A7F8 | 10298 | table public.data: INSERT: id[integer]:2 data[text]:’2’
0/BA5A8A8 | 10298 | COMMIT 10298
(4 rows)
postgres=# INSERT INTO data(data) VALUES(‘3’);
postgres=# – Также можно заглянуть вперёд в потоке изменений, не считывая эти
изменения
postgres=# SELECT * FROM pg_logical_slot_peek_changes(‘regression_slot’, NULL, NULL);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A8E0 | 10299 | BEGIN 10299
0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:’3’
0/BA5A990 | 10299 | COMMIT 10299
(3 rows)
postgres=# – Следующий вызов pg_logical_slot_peek_changes() снова возвращает те же
изменения
postgres=# SELECT * FROM pg_logical_slot_peek_changes(‘regression_slot’, NULL, NULL);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A8E0 | 10299 | BEGIN 10299
0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:’3’
0/BA5A990 | 10299 | COMMIT 10299
(3 rows)
postgres=# – Модулю вывода можно передать параметры, влияющие на форматирование
postgres=# SELECT * FROM pg_logical_slot_peek_changes(‘regression_slot’, NULL, NULL,
‘include-timestamp’, ‘on’);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A8E0 | 10299 | BEGIN 10299
0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:’3’
0/BA5A990 | 10299 | COMMIT 10299 (at 2017-05-10 12:07:21.272494-04)
(3 rows)
1290Логическое декодирование
postgres=# – Не забудьте удалить слот, который вам больше не нужен, чтобы он
postgres=# – не потреблял ресурсы сервера:
postgres=# SELECT pg_drop_replication_slot(‘regression_slot’);
pg_drop_replication_slot
———————–
(1 row)
Следующий пример показывает, как можно управлять логическим декодированием средствами
протокола потоковой репликации, используя программу pg_recvlogical, включённую в дистрибутив
PostgreSQL. Для этого нужно, чтобы конфигурация аутентификации клиентов допускала подклю-
чения для репликации (см. Подраздел 26.2.5.1) и чтобы значение max_wal_senders было достаточ-
но большим и позволило установить дополнительное подключение.
$ pg_recvlogical -d postgres –slot=test –create-slot
$ pg_recvlogical -d postgres –slot=test –start -f -
Control+Z
$ psql -d postgres -c “INSERT INTO data(data) VALUES(‘4’);”
$ fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:’4’
COMMIT 693
Control+C
$ pg_recvlogical -d postgres –slot=test –drop-slot
49.2. Концепции логического декодирования
49.2.1. Логическое декодирование
Логическое декодирование — это процедура извлечения всех постоянных изменений, происходя-
щих в таблицах базы данных, в согласованном и понятном формате, который можно интерпрети-
ровать, не имея полного представления о внутреннем состоянии базы данных.
В PostgreSQL логическое декодирование реализуется путём перевода содержимого журнала пред-
записи, описывающего изменения на уровне хранения, в специальную форму уровня приложения,
например, в поток кортежей или операторов SQL.
49.2.2. Слоты репликации
В контексте логической репликации слот представляет поток изменений, которые могут быть вос-
произведены клиентом в том порядке, в каком они происходили на исходном сервере. Через каж-
дый слот передаётся последовательность изменений в одной базе данных.
Примечание
В PostgreSQL также есть слоты потоковой репликации (см. Подраздел 26.2.5), но они
используются несколько по-другому.
Слоту репликации назначается идентификатор, уникальный для всех баз данных в кластере
PostgreSQL. Слоты сохраняются независимо от подключений, использующих их, и защищены от
сбоев сервера.
При обычных условиях через логический слот каждое изменение передаётся только один раз. Те-
кущая позиция в каждом слоте сохраняется только в контрольной точке, так что в случае сбоя
слот может вернуться к предыдущему LSN, вследствие чего последние изменения могут быть пе-
реданы повторно при перезапуске сервера. За исключение нежелательных эффектов от повторной
обработки одного и того же сообщения отвечают клиенты логического декодирования. Клиенты
1291Логическое декодирование
могут запоминать при декодировании, какой последний LSN они уже получали, и пропускать по-
вторяющиеся данные или (при использовании протокола репликации) запрашивать, чтобы деко-
дирование начиналось с этого LSN, а не с позиции, выбираемой сервером. Для этого разработан
механизм отслеживания репликации, о котором можно узнать подробнее в описании источников
репликации.
Для одной базы данных могут существовать несколько независимых слотов. Каждый слот имеет
собственное состояние, что позволяет различным потребителям получать изменения с разных по-
зиций в потоке изменений базы данных. Для большинства приложений каждому потребителю тре-
буется отдельный слот.
Слот логической репликации ничего не знает о состоянии получателя(ей). Возможно даже иметь
несколько различных потребителей одного слота в разные моменты времени; они просто будут
получать изменения с момента, когда их перестал получать предыдущий потребитель. Но в любой
определённый момент получать изменения может только один потребитель.
Внимание
Слоты репликации сохраняются при сбоях сервера и ничего не знают о состоянии их
потребителя. Они не дают удалять требуемые ресурсы, даже когда не используются ни-
каким подключением. На это уходит место в хранилище, так как ни сегменты WAL, ни
требуемые строки из системных каталогов нельзя будет удалить в результате VACUUM,
пока они нужны этому слоту репликации. В особых случаях это может привести к от-
ключению базы для предотвращения зацикливания идентификаторов транзакций (см.
Подраздел  24.1.5). Поэтому, если слот больше не требуется, его следует ликвидиро-
вать.
49.2.3. Модули вывода
Модули вывода переводят данные из внутреннего представления в журнале предзаписи в формат,
устраивающий потребителя слота репликации.
49.2.4. Экспортированные снимки
Когда новый слот репликации создаётся через интерфейс потоковой репликации, экспортирует-
ся снимок (см. CREATE_REPLICATION_SLOT), который будет показывать ровно то состояние базы
данных, изменения после которого будут включаться в поток изменений. Используя его, можно
создать новую реплику, воспользовавшись командой SET TRANSACTION SNAPSHOT, чтобы получить
состояние базы в момент создания слота. После этого данную транзакцию можно использовать для
выгрузки состояния базы на момент экспорта снимка, а затем изменять это состояние, применяя
содержимое слота, так что никакие изменения не будут потеряны.
Создание снимка возможно не всегда. В частности, невозможно создать снимок при подключении
к горячему резерву. Приложения, которым не требуется экспорт снимка, могут подавить его, вос-
пользовавшись указанием NOEXPORT_SNAPSHOT.
49.3. Интерфейс протокола потоковой репликации
Команды
• CREATE_REPLICATION_SLOT имя_слота LOGICAL модуль_вывода
• DROP_REPLICATION_SLOT имя_слота [ WAIT ]
• START_REPLICATION SLOT имя_слота LOGICAL …
применяются для создания, удаления и передачи изменений из слота репликации, соответственно.
Эти команды доступны только для соединения репликации; их нельзя использовать в обычном
SQL. Подробнее они описаны в Разделе 53.4.
1292Логическое декодирование
Для управления логическим декодированием по соединению потоковой репликации можно при-
менять программу pg_recvlogical. (Внутри неё используются эти команды.)
49.4. Интерфейс логического декодирования на уров-
не SQL
Подробнее API уровня SQL для взаимодействия с механизмом логическим декодированием описан
в Подразделе 9.26.6.
Синхронная репликация (см. Подраздел  26.2.8) поддерживается только для слотов репликации,
которые используются через интерфейс потоковой репликации. Интерфейс функций и дополни-
тельные, не системные интерфейсы не поддерживают синхронную репликацию.
49.5. Системные каталоги, связанные с логическим де-
кодированием
Информацию о текущем состоянии слотов репликации и соединений потоковой репликации отоб-
ражают представления pg_replication_slots и pg_stat_replication, соответственно. Эти пред-
ставления относятся и к физической, и к логической репликации.
49.6. Модули вывода логического декодирования
Пример модуля вывода можно найти в подкаталоге contrib/test_decoding в дереве исходного
кода PostgreSQL.
49.6.1. Функция инициализации
Модуль вывода загружается в результате динамической загрузки разделяемой библиотеки
(при этом в качестве имени библиотеки задаётся имя модуля). Для нахождения библиоте-
ки применяется обычный путь поиска библиотек. В этой библиотеке должна быть функция
_PG_output_plugin_init, которая показывает, что библиотека на самом деле представляет собой
модуль вывода, и устанавливает требуемые обработчики модуля вывода. Этой функции передаёт-
ся структура, в которой должны быть заполнены указатели на функции-обработчики отдельных
действий.
typedef struct OutputPluginCallbacks
{
LogicalDecodeStartupCB startup_cb;
LogicalDecodeBeginCB begin_cb;
LogicalDecodeChangeCB change_cb;
LogicalDecodeTruncateCB truncate_cb;
LogicalDecodeCommitCB commit_cb;
LogicalDecodeMessageCB message_cb;
LogicalDecodeFilterByOriginCB filter_by_origin_cb;
LogicalDecodeShutdownCB shutdown_cb;
} OutputPluginCallbacks;
typedef void (<em>LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);
Обработчики begin_cb, change_cb и commit_cb должны устанавливаться обязательно, а
startup_cb, filter_by_origin_cb, truncate_cb и shutdown_cb могут отсутствовать. Если
truncate_cb не установлен, но потребуется декодировать операцию TRUNCATE, она будет проигно-
рирована.
49.6.2. Возможности
Для декодирования, форматирования и вывода изменений модули вывода могут использовать
практически всю обычную инфраструктуру сервера, включая вызов функций вывода типов. К от-
ношениям разрешается доступ только на чтение, если только эти отношения были созданы про-
1293Логическое декодирование
граммой initdb в схеме pg_catalog, либо помечены как пользовательские таблицы каталогов ко-
мандами
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
Любые действия, которые требуют присвоения идентификатора транзакции, запрещаются. В
частности, к этим действиям относятся операции записи в таблицы, изменения DDL и вызов
txid_current().
49.6.3. Режимы вывода
Обработчики в модуле вывода могут передавать данные потребителю в практически любых фор-
матах. Для некоторых вариантов использования, например, просмотра изменений через SQL,
вывод информации в типах, которые могут содержать произвольные данные (например, bytea),
может быть неудобоваримым. Если модуль вывода выводит только текстовые данные в коди-
ровке сервера, он может объявить это, установив в OutputPluginOptions.output_type значение
OUTPUT_PLUGIN_TEXTUAL_OUTPUT вместо OUTPUT_PLUGIN_BINARY_OUTPUT в обработчике запуска. В
этом случае все данные должны быть в кодировке сервера, чтобы их можно было передать в зна-
чении типа text. Это контролируется в сборках с включёнными проверочными утверждениями.
49.6.4. Обработчики в модуле вывода
Модуль вывода уведомляется о происходящих изменениях через различные обработчики, которые
он должен установить.
Параллельные транзакции декодируются в порядке фиксирования, при этом только изменения,
относящиеся к определённой транзакции, декодируются между вызовами обработчиков begin и
commit. Транзакции, отменённые явно или неявно, никогда не декодируются. Успешные точки со-
хранения заворачиваются в транзакцию, содержащую их, в том порядке, в како они выполнялись
в этой транзакции.
Примечание
Декодироваться будут только те транзакции, которые уже успешно сброшены на диск.
Вследствие этого, COMMIT может не декодироваться в следующем сразу за ним вызове
pg_logical_slot_get_changes(), когда synchronous_commit имеет значение off.
49.6.4.1. Обработчик запуска
Необязательный обработчик startup_cb вызывается, когда слот репликации создаётся или через
него запрашивается передача изменений, независимо от того, в каком количестве изменения го-
товы к передаче.
typedef void (</em>LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
OutputPluginOptions *options,
bool is_init);
Параметр is_init будет равен true, когда слот репликации создаётся, и false в противном случае.
Параметр options указывает на структуру параметров, которые могут устанавливать модули вы-
вода:
typedef struct OutputPluginOptions
{
OutputPluginOutputType output_type;
bool
receive_rewrites;
} OutputPluginOptions;
В
поле
output_type
должно
быть
значение
OUTPUT_PLUGIN_TEXTUAL_OUTPUT
или
OUTPUT_PLUGIN_BINARY_OUTPUT. См. также Подраздел  49.6.3. Если поле receive_rewrites равно
1294Логическое декодирование
true, модуль вывода также будет вызываться для изменений, связанных с перезаписью кучи при
определённых операциях DDL. Эти изменения представляют интерес для модулей, осуществляю-
щих репликацию DDL, но для их обработки может потребоваться особый подход.
Обработчик
запуска
должен
проверить
параметры,
представленные
в
ctx-</p>
<blockquote>
  <p>output_plugin_options. Если модулю вывода требуется поддерживать состояние, он может со-
хранить его в ctx-&gt;output_plugin_private.
49.6.4.2. Обработчик выключения
Необязательный обработчик shutdown_cb вызывается, когда ранее активный слот репликации пе-
рестаёт использоваться, так что ресурсы, занятые модулем вывода, можно освободить. При этом
слот не обязательно удаляется, прекращается только потоковая передача через него.
typedef void (<em>LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);
49.6.4.3. Обработчик начала транзакции
Обязательный обработчик begin_cb вызывается, когда декодируется начало зафиксированной
транзакции. Прерванные транзакции и их содержимое никогда не декодируется.
typedef void (</em>LogicalDecodeBeginCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn);
Параметр txn содержит метаинформацию о транзакции, в частности её идентификатор и время
её фиксирования.
49.6.4.4. Обработчик завершения транзакции
Обязательный обработчик commit_cb вызывается, когда декодируется фиксирование транзакции.
Перед этим обработчиком будет вызываться обработчик change_cb для всех изменённых строк
(если строки были изменены).
typedef void (</em>LogicalDecodeCommitCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn,
XLogRecPtr commit_lsn);
49.6.4.5. Обработчик изменения
Обязательный обработчик change_cb вызывается для каждого отдельного изменения строки в
транзакции, производимого командами INSERT, UPDATE или DELETE. Даже если команда изменила
несколько строк сразу, этот обработчик будет вызываться для каждой отдельной строки.
typedef void (</em>LogicalDecodeChangeCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn,
Relation relation,
ReorderBufferChange *change);
Параметры ctx и txn имеют то же содержимое, что и для обработчиков begin_cb и commit_cb; до-
полнительный дескриптор отношения relation указывает на отношение, к которому принадлежит
строка, а структура change описывает передаваемое изменение строки.
Примечание
В процессе логического декодирования могут быть обработаны изменения только в
таблицах, не являющихся нежурналируемыми (см. описание UNLOGGED) или временны-
ми (см. описание TEMPORARY или TEMP).
49.6.4.6. Обработчик опустошения
Обработчик truncate_cb вызывается для команды TRUNCATE.
1295Логическое декодирование
typedef void (</em>LogicalDecodeTruncateCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn,
int nrelations,
Relation relations[],
ReorderBufferChange *change);
Он получает те же параметры, что и change_cb. Но так как операции TRUNCATE в таблицах, свя-
занных внешними ключами, должны выполняться одновременно, данный обработчик получает на
вход не одно отношение, а массив отношений. За подробностями обратитесь к описанию операто-
ра TRUNCATE.
49.6.4.7. Обработчик фильтрации источника
Необязательный обработчик filter_by_origin_cb вызывается, чтобы отметить, интересуют ли мо-
дуль вывода изменения, воспроизводимые из указанного источника (origin_id).
typedef bool (</em>LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext <em>ctx,
RepOriginId origin_id);
В параметре ctx передаётся та же информация, что и для других обработчиков. Чтобы отметить,
что изменения, поступающие из переданного узла, не представляют интереса, модуль должен вер-
нуть true, вследствие чего эти изменения будут фильтроваться; в противном случае он должен вер-
нуть false. Другие обработчики для фильтруемых транзакций и изменений вызываться не будут.
Это полезно при реализации каскадной или разнонаправленной репликации. Фильтрация по ис-
точнику в таких конфигурациях позволяет предотвратить передачу взад-вперёд одних и тех же
изменений. Хотя информацию об источнике можно также извлечь из транзакций и изменений,
фильтрация с помощью этого обработчика гораздо более эффективна.
49.6.4.8. Обработчик произвольных сообщений
Необязательный обработчик message_cb вызывается при получении сообщения логического деко-
дирования.
typedef void (</em>LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,
ReorderBufferTXN *txn,
XLogRecPtr message_lsn,
bool transactional,
const char *prefix,
Size message_size,
const char *message);
Параметр txn содержит метаинформацию о транзакции, включая время её фиксации и её XID. За-
метьте, однако, что в нём может передаваться NULL, когда сообщение нетранзакционное и тран-
закции, в которой было выдано сообщение, ещё не назначен XID. В параметре lsn отмечается по-
зиция сообщения в WAL. Параметр transactional показывает, было ли сообщение передано как
транзакционное. В параметре prefix передаётся некоторый префикс (завершающийся нулём), по
которому текущий модуль может выделять интересующие его сообщения. И наконец, параметр
message содержит само сообщение размером message_size байт.
Необходимо дополнительно позаботиться о том, чтобы префикс, определяющий интересующие мо-
дуль вывода сообщения, был уникальным. Удачным выбором обычно будет имя расширения или
самого модуля вывода.
49.6.5. Функции для формирования вывода
Чтобы действительно вывести данные, модули вывода могут записывать их в буфер StringInfo че-
рез ctx-&gt;out, внутри обработчиков begin_cb, commit_cb или change_cb. Прежде чем записывать
данные в этот буфер, необходимо вызвать OutputPluginPrepareWrite(ctx, last_write), а завер-
шив запись в буфер, нужно вызвать OutputPluginWrite(ctx, last_write), чтобы собственно про-
извести запись. Параметр last_write указывает, была ли эта определённая операция записи по-
следней в данном обработчике.
1296Логическое декодирование
Следующий пример показывает, как вывести данные для потребителя модуля вывода:
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx-&gt;out, “BEGIN %u”, txn-&gt;xid);
OutputPluginWrite(ctx, true);
49.7. Запись вывода логического декодирования
Архитектура сервера позволяет добавлять другие методы вывода для логического декодирования.
За подробностями обратитесь к коду src/backend/replication/logical/logicalfuncs.c. По сути,
необходимо реализовать три функции: одну для чтения WAL, другую для подготовки к записи, и
третью для записи вывода (см. Подраздел 49.6.5).
49.8. Поддержка синхронной репликации для логиче-
ского декодирования
Логическое декодирование может использоваться для реализации синхронной репликации с тем
же внешним интерфейсом, что и синхронная репликация поверх потоковой репликации. Для это-
го потоковая передача данных должна происходить через интерфейс потоковой репликации (см.
Раздел 49.3). Клиенты такой репликации должны посылать сообщения Обновление состояния ре-
зервного сервера (F) (см. Раздел 53.4), как и клиенты потоковой репликации.
Примечание
Синхронная реплика, получающая изменения через логическое декодирование, будет
работать в рамках одной базы данных. Так как synchronous_standby_names в настоящее
время, напротив, устанавливается на уровне сервера, это означает, что этот подход не
будет работать корректно при использовании нескольких баз данных.
1297</p>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-048/" title="Глава 48. Фоновые рабочие процессы"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 48. Фоновые рабочие процессы"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-048/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-048/" rel="bookmark" title="Глава 48. Фоновые рабочие процессы" itemprop="url">Глава 48. Фоновые рабочие процессы</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 48. Фоновые рабочие процессы</p>

<p>PostgreSQL поддерживает расширенную возможность запускать пользовательский код в отдель-
ных процессах. Такие процессы запускаются, останавливаются и контролируются главным про-
цессом postgres, который позволяет тесно связать их жизненный цикл с состоянием сервера. Эти
процессы могут получать доступ к области разделяемой памяти PostgreSQL и устанавливать внут-
ренние подключения к базам данных; они также могут последовательно запускать транзакции,
как и обычные серверные процессы, обслуживающие клиентов. Кроме того, используя libpq, они
могут подключаться к серверу и работать как обычные клиентские приложения.
Предупреждение
С использованием фоновых рабочих процессов сопряжены угрозы стабильности и без-
опасности, так как они реализуются на языке C, и значит имеют неограниченный до-
ступ к данным. Администраторы, желающие использовать модули, в которых задей-
ствованы фоновые рабочие процессы, должны быть крайне осторожными. Запускать
рабочие процессы можно разрешать только модулям, прошедшим всесторонний аудит.
Рабочие процессы могут инициализироваться во время запуска PostgreSQL, если имя соответ-
ствующего модуля добавлено в shared_preload_libraries. Модуль, желающий запустить рабо-
чий процесс, может зарегистрировать его, вызвав RegisterBackgroundWorker(BackgroundWorker
<em>worker) из своей функции _PG_init(). Рабочие процессы также могут быть запущены по-
сле запуска системы с помощью функции RegisterDynamicBackgroundWorker(BackgroundWorker
*worker, BackgroundWorkerHandle **handle). В отличие от RegisterBackgroundWorker, которую
можно вызывать только из главного управляющего процесса, RegisterDynamicBackgroundWorker
должна вызываться из обычного обслуживающего процесса или другого рабочего процесса.
Структура BackgroundWorker определяется так:
typedef void (</em>bgworker_main_type)(Datum main_arg);
typedef struct BackgroundWorker
{
char
bgw_name[BGW_MAXLEN];
char
bgw_type[BGW_MAXLEN];
int
bgw_flags;
BgWorkerStartTime bgw_start_time;
int
bgw_restart_time;
/* время в секундах либо BGW_NEVER_RESTART */
char
bgw_library_name[BGW_MAXLEN];
char
bgw_function_name[BGW_MAXLEN];
Datum
bgw_main_arg;
char
bgw_extra[BGW_EXTRALEN];
int
bgw_notify_pid;
} BackgroundWorker;
Поля bgw_name и bgw_type содержат строки, выводимые в отладочных сообщениях, списках про-
цессов и подобных контекстах. Строка bgw_type должна быть одинаковой для всех рабочих про-
цессов одного типа, чтобы такие процессы можно было сгруппировать, например, в списке процес-
сов. bgw_name, с другой стороны, может содержать дополнительную информацию об определённом
процессе. (Обычно строка bgw_name содержит тип в некотором виде, но строго это не требуется.)
Поле bgw_flags представляет битовую маску, обозначающую запрашиваемые модулем возможно-
сти. Допустимые в нём флаги:
BGWORKER_SHMEM_ACCESS
Запрашивается доступ к общей памяти. Рабочие процессы без доступа к общей памяти не могут
обращаться к общим структурам данных PostgreSQL, в частности, к обычным и лёгким блоки-
1285Фоновые рабочие процессы
ровкам, общим буферам, или каким-либо структурам данным, которые рабочий процесс может
создавать для собственного пользования.
BGWORKER_BACKEND_DATABASE_CONNECTION
Запрашивается возможность устанавливать подключение к базе данных, через ко-
торое можно запускать транзакции и запросы. Рабочий процесс, использующий
BGWORKER_BACKEND_DATABASE_CONNECTION для подключения к базе данных, должен также запро-
сить доступ к разделяемой памяти, установив BGWORKER_SHMEM_ACCESS; в противном случае про-
цесс не запустится.
В bgw_start_time определяется состояние сервера, в котором postgres должен запустить этот про-
цесс; возможные варианты: BgWorkerStart_PostmasterStart (выполнить запуск сразу после того,
как postgres завершит инициализацию; процессы, выбирающие такой режим, не могут подклю-
чаться к базам данных), BgWorkerStart_ConsistentState (выполнить запуск, когда будет достиг-
нуто согласованное состояние горячего резерва, и когда процессы могут подключаться к базам
данных и выполнять запросы на чтение), и BgWorkerStart_RecoveryFinished (выполнить запуск,
как только система перейдёт в обычный режим чтения-записи). Заметьте, что два последних ва-
рианта различаются только для серверов горячего резерва. Заметьте также, что этот параметр
указывает только, когда должны запускаться процессы; при переходе в другое состояние они не
будут останавливаться.
bgw_restart_time задаёт паузу (в секундах), которую должен сделать postgres, прежде чем пе-
резапускать процесс в случае его отказа. Это может быть любое положительное значение, либо
BGW_NEVER_RESTART, указывающее, что процесс не нужно перезапускать в случае сбоя.
bgw_library_name определяет имя библиотеки, в которой следует искать точку входа для запуска
рабочего процесса. Указанная библиотека будет динамически загружена рабочим процессом, а
вызываемая функция будет выбрана по имени bgw_function_name. Для функции, загружаемой из
кода ядра, в этом поле должно быть “postgres”.
bgw_function_name определяет имя функции в динамически загружаемой библиотеке, которая бу-
дет точкой входа в новый рабочий процесс.
В bgw_main_arg задаётся аргумент Datum, передаваемый основной функции фонового процесса.
Эта функция должна принимать один аргумент типа Datum и возвращать void. В качестве этого
аргумента ей и передаётся bgw_main_arg. Кроме того, глобальная переменная MyBgworkerEntry
указывает на копию структуры BackgroundWorker, переданной при регистрации; содержимое этой
структуры может быть полезно рабочему процессу.
В Windows (и везде, где определяется EXEC_BACKEND) или в динамических рабочих процессах пере-
давать Datum по ссылке небезопасно, возможна только передача по значению. Поэтому если функ-
ции требуется аргумент, наиболее безопасно будет передать int32 или другое небольшое значение,
содержащее индекс в массиве, размещённом в разделяемой памяти. Если же попытаться передать
значение cstring или text, этот указатель нельзя будет использовать в новом рабочем процессе.
Поле bgw_extra может содержать дополнительные данные, передаваемые фоновому рабочему про-
цессу. В отличие от bgw_main_arg, эти данные не передаются в качестве аргумента основной функ-
ции рабочего процесса, но могут быть получены через MyBgworkerEntry, как описывалось выше.
В bgw_notify_pid задаётся PID обслуживающего процесса PostgreSQL, которому главный процесс
должен посылать сигнал SIGUSR1 при запуске и завершении нового рабочего процесса. Это поле
должно содержать 0 для рабочих процессов, регистрируемых при запуске главного процесса, либо
когда обслуживающий процесс не желает ждать окончания запуска рабочего процесса. Во всех
остальных случаях в нём должно быть значение MyProcPid.
Запущенный
процесс
может
подключиться
к
базе
данных,
вызвав
BackgroundWorkerInitializeConnection(char *dbname, char *username, uint32 flags) или
BackgroundWorkerInitializeConnectionByOid(Oid dboid, Oid useroid, uint32 flags). Через это
1286Фоновые рабочие процессы
подключение процесс может выполнять транзакции и запросы, используя интерфейс SPI. Если в
dbname передаётся NULL или dboid равен InvalidOid, сеанс не подключается ни к какой конкрет-
ной базе данных, но может обращаться к общим каталогам. Если в username передаётся NULL или
useroid равен InvalidOid, процесс будет действовать от имени суперпользователя, созданного во
время initdb. Значение BGWORKER_BYPASS_ALLOWCONN в поле flags позволяет подключаться к ба-
зам, не принимающим подключения пользователей. Рабочий процесс может вызвать только одну
из этих двух функций и только один раз. Переключаться между базами данных он не может.
Сигналы изначально блокируются при вызове основной функции рабочего процесса и долж-
ны быть разблокированы ей: это позволяет процессу при необходимости настроить соб-
ственные обработчики событий. Новый процесс может разблокировать сигналы, вызвав
BackgroundWorkerUnblockSignals, и заблокировать их, вызвав BackgroundWorkerBlockSignals.
Если bgw_restart_time для рабочего процесса имеет значение BGW_NEVER_RESTART, ли-
бо он завершается с кодом выхода 0, либо если его работа заканчивается вызовом
TerminateBackgroundWorker, он автоматически перестаёт контролироваться управляющим про-
цессом при выходе. В противном случае он будет перезапущен через время, заданное в
bgw_restart_time, либо немедленно, если управляющему серверу пришлось переинициализиро-
вать кластер из-за сбоя обслуживающего процесса. Обслуживающие процессы, которым нужно
только приостановить своё выполнение на время, должны переходить в состояние прерываемого
ожидания, а не завершаться; для этого используется функция WaitLatch(). При вызове этой функ-
ции обязательно установите флаг WL_POSTMASTER_DEATH и проверьте код возврата, чтобы корректно
выйти в экстренном случае, когда был завершён сам postgres.
Когда рабочий процесс регистрируется функцией RegisterDynamicBackgroundWorker, обслужива-
ющий процесс, производящий эту регистрацию, может получить информацию о состоянии по-
рождённого процесса. Обслуживающие процессы, желающие сделать это, должны передать адрес
BackgroundWorkerHandle * во втором аргументе RegisterDynamicBackgroundWorker. Если рабочий
процесс успешно зарегистрирован, по этому адресу будет записан указатель на скрытую струк-
туру, который можно затем передать функции GetBackgroundWorkerPid(BackgroundWorkerHandle
*,
pid_t
*) или TerminateBackgroundWorker(BackgroundWorkerHandle
*). Вызывая
GetBackgroundWorkerPid, можно опрашивать состояние рабочего процесса: значение резуль-
тата BGWH_NOT_YET_STARTED показывает, что рабочий процесс ещё не запущен управляющим;
BGWH_STOPPED показывает, что он был запущен, но сейчас не работает; и BGWH_STARTED показывает,
что он работает в данный момент. В последнем случае через второй аргумент также возвращается
PID этого процесса. Обрабатывая вызов TerminateBackgroundWorker, управляющий процесс посы-
лает SIGTERM рабочему процессу, если он работает, и перестаёт его контролировать сразу по его
завершении.
В некоторых случаях процессу, регистрирующему рабочий процесс, может потребоваться до-
ждаться завершения запуска этого процесса. Это можно реализовать, записав в bgw_notify_pid
значение MyProcPid, а затем передав указатель BackgroundWorkerHandle *, полученный во вре-
мя регистрации, функции WaitForBackgroundWorkerStartup(BackgroundWorkerHandle *handle,
pid_t *). Эта функция заблокирует выполнение, пока управляющий процесс не попытается запу-
стить рабочий процесс, либо пока сам управляющий процесс не завершится. Если рабочий про-
цесс запущен, возвращается значение BGWH_STARTED и по переданному адресу записывается PID.
В противном случае возвращается BGWH_STOPPED или BGWH_POSTMASTER_DIED.
Процесс
также
может
ожидать
завершения
рабочего
процесса,
вызвав
функ-
цию WaitForBackgroundWorkerShutdown(BackgroundWorkerHandle
*handle) с указателем
BackgroundWorkerHandle *, полученным при регистрации. Эта функция заблокирует выполне-
ние, пока не завершится рабочий процесс либо управляющий процесс. При завершении ра-
бочего процесса эта функция возвращает BGWH_STOPPED, а при завершении управляющего —
BGWH_POSTMASTER_DIED.
Если фоновый рабочий процесс передаёт асинхронные уведомления, вызывая команду NOTIFY че-
рез SPI (Server Programming Interface, Интерфейс программирования сервера), он должен явно
вызвать ProcessCompletedNotifies после фиксации окружающей транзакции, чтобы все эти уве-
1287Фоновые рабочие процессы
домления были доставлены. Если рабочий процесс зарегистрируется для получения асинхронных
уведомлений, вызвав LISTEN через SPI, уведомления будут выводиться, но перехватить и обрабо-
тать эти уведомления программным образом нет возможности.
Рабочий пример, демонстрирующий некоторые полезные приёмы, можно найти в модуле src/
test/modules/worker_spi.
Максимальное число рабочих процессов, которые можно зарегистрировать, ограничивается зна-
чением max_worker_processes.
1288</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" title="Глава 47. Интерфейс программирования сервера"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 47. Интерфейс программирования сервера"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~40 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" rel="bookmark" title="Глава 47. Интерфейс программирования сервера" itemprop="url">Глава 47. Интерфейс программирования сервера</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 47. Интерфейс программирования сервера</p>

<p>Интерфейс программирования сервера (SPI, Server Programming Interface) даёт разработчикам
пользовательских функций на C возможность запускать команды SQL из своих функций. SPI пред-
ставляет собой набор интерфейсных функций, упрощающих доступ к анализатору, планировщику
и исполнителю запросов. В SPI есть также функции для управления памятью.
Примечание
Доступные процедурные языки предоставляют различные средства для выполнения
SQL-команд из функций. Большинство этих средств основаны на SPI, так что эта доку-
ментация будет полезна и тем, кто использует эти языки.
Учтите, что если команда, вызванная через SPI, прерывается ошибкой, управление не возвраща-
ется в вашу функцию на C. Вместо этого происходит откат транзакции или подтранзакции, из ко-
торой вызывалась ваша функция. (Это может показаться удивительным, с учётом того, что для
большинства функций SPI описаны соглашения по возврату ошибок. Однако эти соглашения при-
менимы только к ошибкам, выявляемым в самих функциях SPI.) Получить управление после ошиб-
ки можно, только организовав собственную подтранзакцию, окружающую вызовы SPI, в которых
возможна ошибка.
Функции SPI выдают неотрицательный результат в случае успеха (либо через возвращаемое це-
лочисленное значение, либо в глобальной переменной SPI_result, как описано ниже). В случае
ошибки выдаётся отрицательный результат или NULL.
Файлы исходного кода, использующие SPI, должны включать заголовочный файл executor/spi.h.
47.1. Интерфейсные функции
1226Интерфейс програм-
мирования сервера
SPI_connect
SPI_connect, SPI_connect_ext — подключить функцию на C к менеджеру SPI
Синтаксис
int SPI_connect(void)
int SPI_connect_ext(int options)
Описание
SPI_connect устанавливает подключение вызова функции на C к менеджеру SPI. Данную функцию
необходимо использовать, если вы хотите выполнять команды через SPI. Некоторые вспомогатель-
ные функции SPI могут вызываться из неподключённых функций.
SPI_connect_ext делает то же самое, но принимает один аргумент, через который можно передать
дополнительные флаги. В настоящее время поддерживаются следующие флаги:
SPI_OPT_NONATOMIC
Переводит подключение SPI в неатомарный режим, в котором разрешаются вызовы функций
управления транзакциями SPI_commit, SPI_rollback и SPI_start_transaction. В обычном ре-
жиме вызов этих функций приводит к немедленной ошибке.
Вызов SPI_connect() равнозначен SPI_connect_ext(0).
Возвращаемое значение
SPI_OK_CONNECT
при успехе
SPI_ERROR_CONNECT
при ошибке
1227Интерфейс програм-
мирования сервера
SPI_finish
SPI_finish — отключить функцию на C от менеджера SPI
Синтаксис
int SPI_finish(void)
Описание
SPI_finish закрывает текущее соединение с менеджером SPI. Эту функцию необходимо вызывать
после завершения операций SPI, которые должны выполняться в текущем вызове функции на C.
Однако если вы прерываете транзакцию, выполняя elog(ERROR), о закрытии соединения можно не
беспокоиться. В этом случае SPI произведёт очистку автоматически.
Возвращаемое значение
SPI_OK_FINISH
если отключение выполнено корректно
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
1228Интерфейс програм-
мирования сервера
SPI_execute
SPI_execute — выполнить команду
Синтаксис
int SPI_execute(const char * command, bool read_only, long count)
Описание
SPI_execute выполняет заданную команду SQL для получения строк в количестве, ограниченном
count. С параметром read_only, равным true, команда должна только читать данные; это несколь-
ко сокращает издержки на её выполнение.
Эту функцию можно вызывать только из подключённой функции на C.
Если count равен 0, команда выполняется для всех строк, к которым она применима. Если count
больше нуля, будет получено не более чем count строк; выполнение команды остановится при
достижении этого предела, практически так же, как и с предложением LIMIT в запросе. Например,
команда:
SPI_execute(“SELECT * FROM foo”, true, 5);
получит из таблицы не более 5 строк. Заметьте, что это ограничение действует, только когда ко-
манда действительно возвращает строки. Например, эта команда:
SPI_execute(“INSERT INTO foo SELECT * FROM bar”, false, 5);
вставляет все строки из bar, игнорируя параметр count. Однако команда
SPI_execute(“INSERT INTO foo SELECT * FROM bar RETURNING <em>”, false, 5);
вставит не более 5 строк, так как её выполнение будет остановлено после получения пятой строки,
выданной предложением RETURNING.
В одной строке можно передать несколько команд; SPI_execute возвращает результат команды,
выполненной последней. Параметр count при этом будет применяться к каждой команде по от-
дельности (несмотря даже на то, что возвращён будет только последний результат). Это ограни-
чение не будет распространяться на скрытые команды, генерируемые правилами.
Когда параметр read_only равен false, SPI_execute увеличивает счётчик команд и получает но-
вый снимок перед выполнением каждой очередной команды в строке. Этот снимок фактически
не меняется при текущем уровне изоляции транзакций SERIALIZABLE или REPEATABLE READ, но в
режиме READ COMMITTED после обновления снимка очередная команда может видеть результаты
только что зафиксированных транзакций из других сеансов. Это важно для согласованного пове-
дения, когда команды модифицируют базу данных.
Когда параметр read_only равен true, SPI_execute не обновляет снимок и не увеличивает счётчик
команд, и допускает в строке команд только SELECT. Заданные команды выполняются со снимком,
ранее полученным для окружающего запроса. Этот режим выполнения несколько быстрее режима
чтения/записи вследствие исключения издержек, связанных с отдельными командами. Он также
позволяет создавать подлинно стабильные функции: так как последующие вызовы в транзакции
будут использовать один снимок, результаты команд не изменятся.
Смешивать команды, только читающие, с командами, читающими и пишущими, в одной процедуре,
использующей SPI, обычно неразумно; запросы только на чтение не увидят результатов изменений
в базе данных, произведённых пишущими запросами.
Число строк, которые были фактически обработаны командой (последней), возвращается в гло-
бальной переменной SPI_processed. Если эта функция возвращает значение SPI_OK_SELECT,
SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING или SPI_OK_UPDATE_RETURNING, вы можете об-
1229Интерфейс програм-
мирования сервера
ратиться по глобальному указателю SPITupleTable *SPI_tuptable и прочитать строки резуль-
тата. Некоторые служебные команды (например, EXPLAIN) также возвращают наборы строк, и
SPI_tuptable будет содержать их результаты и в этих случаях. Другие вспомогательные команды
(COPY, CREATE TABLE AS) не возвращают набор строк, так что указатель SPI_tuptable равен NULL,
но они так же возвращают число обработанных строк в SPI_processed.
Структура SPITupleTable определена так:
typedef struct
{
MemoryContext tuptabcxt;
uint64
alloced;
uint64
free;
TupleDesc
tupdesc;
HeapTuple *vals;
} SPITupleTable;
/</em>
/*
/*
/*
/*
контекст таблицы результатов в памяти <em>/
число занятых значений */
число свободных значений */
дескриптор строки */
данные строк */
vals представляет собой массив указателей на строки. (Число записей в нём указывается в
SPI_processed.) Поле tupdesc содержит дескриптор строки, который вы сможете передать функ-
циям SPI, работающими со строками. Поля tuptabcxt, alloced и free предназначены для внутрен-
него использования, а не для процедур, работающих с SPI.
SPI_finish освобождает все структуры SPITupleTable, размещённые в памяти для текущей функ-
ции на C. Вы можете освободить структуру конкретной результирующей таблицы, если она вам не
нужна, вызвав SPI_freetuptable.
Аргументы
const char * command
строка с командой, которая должна быть выполнена
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Если команда была выполнена успешно, возвращается одно из следующих (неотрицательных) зна-
чений:
SPI_OK_SELECT
если выполнялась команда SELECT (но не SELECT INTO)
SPI_OK_SELINTO
если выполнялась команда SELECT INTO
SPI_OK_INSERT
если выполнялась команда INSERT
SPI_OK_DELETE
если выполнялась команда DELETE
SPI_OK_UPDATE
если выполнялась команда UPDATE
1230Интерфейс програм-
мирования сервера
SPI_OK_INSERT_RETURNING
если выполнялась команда INSERT RETURNING
SPI_OK_DELETE_RETURNING
если выполнялась команда DELETE RETURNING
SPI_OK_UPDATE_RETURNING
если выполнялась команда UPDATE RETURNING
SPI_OK_UTILITY
если выполнялась служебная команда (например, CREATE TABLE)
SPI_OK_REWRITTEN
если команда была преобразована правилом в команду другого вида (например, UPDATE стал
командой INSERT).
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в качестве command передан NULL или count меньше 0
SPI_ERROR_COPY
при попытке выполнить COPY TO stdout или COPY FROM stdin
SPI_ERROR_TRANSACTION
при попытке выполнить команду управления транзакциями (BEGIN, COMMIT, ROLLBACK,
SAVEPOINT, PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED или любую их вариацию)
SPI_ERROR_OPUNKNOWN
если тип команды неизвестен (такого быть не должно)
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Все функции SPI, выполняющие запросы, заполняют и SPI_processed, и SPI_tuptable (только ука-
затель, но не содержимое структуры). Сохраните эти две глобальные переменные в локальных пе-
ременных функции на C, если хотите обращаться к таблице результата SPI_execute или другой
функции, выполняющей запрос, в нескольких вызовах процедуры.
1231Интерфейс програм-
мирования сервера
SPI_exec
SPI_exec — выполнить команду чтения/записи
Синтаксис
int SPI_exec(const char * command, long count)
Описание
SPI_exec действует подобно SPI_execute, но ей не передаётся параметр read_only (всегда подра-
зумевается false).
Аргументы
const char * command
строка с командой, которая должна быть выполнена
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute.
1232Интерфейс програм-
мирования сервера
SPI_execute_with_args
SPI_execute_with_args — выполнить команду с выделенными параметрами
Синтаксис
int SPI_execute_with_args(const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, long count)
Описание
SPI_execute_with_args выполняет команду, которая может включать ссылки на параметры, пере-
даваемые извне. В тексте команды параметры обозначаются символами $n, а в вызове указывают-
ся типы данных и значения для каждого такого символа. Параметры read_only и count имеют тот
же смысл, что и в SPI_execute.
Основное преимущество этой функции по сравнению с SPI_execute в том, что она позволяет пе-
редавать в команду значения данных, не требуя кропотливой подготовки строк, и таким образом
сокращает риск атак с SQL-инъекцией.
Подобного результата можно достичь, вызвав SPI_prepare и затем SPI_execute_plan; однако с
данной функцией план запроса всегда подстраивается под переданные конкретные значения па-
раметров. Поэтому для разового выполнения запроса рекомендуется применять эту функцию. Ес-
ли же одна и та же команда должна выполняться с самыми разными параметрами, какой вариант
окажется быстрее, будет зависеть от стоимости повторного планирования и выигрыша от выбора
специализированных планов.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_execute_with_args считает, что ни один из параметров не
равен NULL. В противном случае элемент массива nulls должен содержать ‘ ‘, если значение
соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1233Интерфейс програм-
мирования сервера
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1234Интерфейс програм-
мирования сервера
SPI_prepare
SPI_prepare — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare(const char * command, int nargs, Oid * argtypes)
Описание
SPI_prepare создаёт и возвращает подготовленный оператор для заданной команды. Подготовлен-
ный оператор может быть затем неоднократно выполнен функцией SPI_execute_plan.
Когда одна и та же или похожие команды выполняются неоднократно, обычно выгоднее произве-
сти анализ запроса только раз, а ещё выгоднее может быть повторно использовать план выполне-
ния команды. SPI_prepare преобразует строку команды в подготовленный оператор, включающий
в себя результаты анализа запроса. Подготовленный оператор также оставляет место для кеши-
рования плана выполнения, если выбор специализированного плана для каждого выполнения не
принесёт пользы.
Подготавливаемую команду можно сделать более общей, записав параметры ($1, $2, etc.) вместо
значений, задаваемыми константами в обычной команде. Фактические значения параметров в
этом случае будут задаваться при вызове SPI_execute_plan. Это позволяет применять подготов-
ленную команду в более широком круге ситуаций, чем это возможно без параметров.
Оператор, возвращаемый функцией SPI_prepare, может использоваться только в текущем вызове
функции на C, так как SPI_finish освобождает память, выделенную для такого оператора. Но этот
оператор может быть сохранён на будущее с помощью функций SPI_keepplan или SPI_saveplan.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
Возвращаемое значение
SPI_prepare возвращает ненулевой указатель на SPIPlan, скрытую структуру, представляющую
подготовленный оператор. В случае ошибки возвращается NULL, а в SPI_result устанавлива-
ется один из кодов ошибок, определённых для SPI_execute, за исключением того, что код
SPI_ERROR_ARGUMENT устанавливается, когда command — NULL, когда nargs меньше 0 или когда nargs
больше 0, а argtypes — NULL.
Замечания
Если параметры не определены, при первом использовании SPI_execute_plan создаётся общий
план, который затем будет применяться при последующих вызовах. Если же присутствуют пара-
метры, SPI_execute_plan будет создавать специализированные планы для конкретных значений
параметров. После достаточного количества использований полученного подготовленного опера-
тора, функция SPI_execute_plan построит общий план, и если он не будет значительно дороже
специализированных, она начнёт использовать его, а не будет строить план заново. Если это пове-
дение по умолчанию не устраивает, его можно изменить, передав флаг CURSOR_OPT_GENERIC_PLAN
1235Интерфейс програм-
мирования сервера
или CURSOR_OPT_CUSTOM_PLAN в SPI_prepare_cursor, чтобы ограничиться использованием только
общего или специализированных планов, соответственно.
Хотя основной смысл подготовленного оператора в том, чтобы избежать повторного разбора и пла-
нирования запроса, PostgreSQL всё же будет принудительно повторять разбор и планирование за-
проса перед его выполнением, если со времени предыдущего использования подготовленного опе-
ратора произойдут изменения определений (DDL) объектов базы, задействованных в этом запросе.
Также, если перед очередным использованием было изменено значение search_path, запрос будет
разобран заново с новым значением search_path. (Последняя особенность появилась в PostgreSQL
9.3.) Чтобы узнать о поведении подготовленных операторов больше, обратитесь к PREPARE.
Эту функцию следует вызывать только из подключённой функции на C.
SPIPlanPtr объявлен в spi.h как указатель на скрытую структуру. Пытаться обращаться к её со-
держимому напрямую не стоит, так как ваш код скорее всего сломается при выходе новых версий
PostgreSQL.
Имя SPIPlanPtr объясняется отчасти историческими причинами, так как теперь эта структура
может не содержать собственно план выполнения.
1236Интерфейс програм-
мирования сервера
SPI_prepare_cursor
SPI_prepare_cursor — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_cursor(const char * command, int nargs,
Oid * argtypes, int cursorOptions)
Описание
Функция SPI_prepare_cursor равнозначна SPI_prepare, за исключением того, что ей можно пере-
дать «параметры курсора». Эти параметры задаются битовой маской со значениями, определён-
ными в nodes/parsenodes.h для поля options структуры DeclareCursorStmt. SPI_prepare подра-
зумевает, что эти параметры всегда нулевые.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_cursor возвращает результат по тем же соглашениям, что и SPI_prepare.
Замечания
К
числу
полезных
бит,
которые
можно
задать
в
cursorOptions,
относятся
CURSOR_OPT_SCROLL, CURSOR_OPT_NO_SCROLL, CURSOR_OPT_FAST_PLAN, CURSOR_OPT_GENERIC_PLAN и
CURSOR_OPT_CUSTOM_PLAN. Заметьте, что параметр CURSOR_OPT_HOLD игнорируется.
1237Интерфейс програм-
мирования сервера
SPI_prepare_params
SPI_prepare_params — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_params(const char * command,
ParserSetupHook parserSetup,
void * parserSetupArg,
int cursorOptions)
Описание
SPI_prepare_params создаёт и возвращает подготовленный оператор для заданной команды, но не
выполняет саму команду. Эта функция равнозначна SPI_prepare_cursor, но позволяет вызываю-
щему дополнительно установить функции-обработчики для управления разбором ссылок на внеш-
ние параметры.
Аргументы
const char * command
строка команды
ParserSetupHook parserSetup
Функция настройки обработчиков разбора
void * parserSetupArg
аргумент для сквозной передачи в parserSetup
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_params возвращает результат по тем же соглашениям, что и SPI_prepare.
1238Интерфейс програм-
мирования сервера
SPI_getargcount
SPI_getargcount — получить число аргументов, требующихся оператору, подготовленному функ-
цией SPI_prepare
Синтаксис
int SPI_getargcount(SPIPlanPtr plan)
Описание
SPI_getargcount возвращает число аргументов, требующихся для выполнения оператора, подго-
товленного функцией SPI_prepare.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Число аргументов, которое ожидает план, заданный параметром plan. Если значение plan невер-
ное или NULL, в SPI_result устанавливается код SPI_ERROR_ARGUMENT, а функция возвращает -1.
1239Интерфейс програм-
мирования сервера
SPI_getargtypeid
SPI_getargtypeid — получить OID типа аргумента для оператора, подготовленного функцией
SPI_prepare
Синтаксис
Oid SPI_getargtypeid(SPIPlanPtr plan, int argIndex)
Описание
SPI_getargtypeid возвращает OID, представляющий тип аргумента под номером argIndex опера-
тора, подготовленного функцией SPI_prepare. Первый аргумент идёт под номером ноль.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
int argIndex
индекс аргумента, начиная с нуля
Возвращаемое значение
OID типа аргумента с заданным индексом. Если значение plan неверное или NULL, либо argIndex
меньше 0 или не меньше числа аргументов, объявленных при подготовке плана (передаваемого в
plan), в SPI_result устанавливается SPI_ERROR_ARGUMENT и возвращается InvalidOid.
1240Интерфейс програм-
мирования сервера
SPI_is_cursor_plan
SPI_is_cursor_plan — выдать true, если оператор, подготовленный функцией SPI_prepare, можно
использовать с SPI_cursor_open
Синтаксис
bool SPI_is_cursor_plan(SPIPlanPtr plan)
Описание
SPI_is_cursor_plan возвращает true, если оператор, подготовленный функцией SPI_prepare,
можно передать в качестве аргумента SPI_cursor_open, или false в противном случае. Для поло-
жительного ответа в plan должна быть представлена одна команда, и эта команда должна возвра-
щать кортежи; например, SELECT может быть подходящей командой, если он не содержит предло-
жения INTO, а UPDATE подходит, только если он содержит предложение RETURNING.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Значение true или false, показывающее, можно ли для подготовленного оператора, заданного
параметром plan, получить курсор, при SPI_result равном нулю. Если дать ответ невозможно
(например, если значение plan неверное или NULL, либо вызывающий не подключён к SPI), в
SPI_result устанавливается соответствующий код ошибки и возвращается false.
1241Интерфейс програм-
мирования сервера
SPI_execute_plan
SPI_execute_plan — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan(SPIPlanPtr plan, Datum * values, const char * nulls,
bool read_only, long count)
Описание
SPI_execute_plan выполняет оператор, подготовленный функцией SPI_prepare или родственными
ей. Параметры read_only и count имеют тот же смысл, что и в SPI_execute.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execute_plan считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute, со следующими дополнительными вариантами
ошибок (отрицательных результатов):
SPI_ERROR_ARGUMENT
Если plan неверный или NULL, либо count меньше 0
SPI_ERROR_PARAM
Если в values передан NULL и plan был подготовлен с другими параметрами
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1242Интерфейс програм-
мирования сервера
SPI_execute_plan_with_paramlist
SPI_execute_plan_with_paramlist — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan_with_paramlist(SPIPlanPtr plan,
ParamListInfo params,
bool read_only,
long count)
Описание
SPI_execute_plan_with_paramlist выполняет оператор, подготовленный функцией SPI_prepare.
Данная функция равнозначна SPI_execute_plan, не считая того, что информация о значениях па-
раметров, передаваемых запросу, представляется по-другому. Представление ParamListInfo мо-
жет быть удобным для передачи значений, уже имеющих нужный формат. Эта функция также под-
держивает динамические наборы параметров, которые реализуются через функции-обработчики,
устанавливаемые в ParamListInfo.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute_plan, если вызов
был успешным.
1243Интерфейс програм-
мирования сервера
SPI_execp
SPI_execp — выполнить оператор в режиме чтения/записи
Синтаксис
int SPI_execp(SPIPlanPtr plan, Datum * values, const char * nulls, long count)
Описание
SPI_execp действует подобно SPI_execute_plan, но ей не передаётся параметр read_only (всегда
подразумевается false).
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execp считает, что ни один из параметров не равен NULL. В
противном случае элемент массива nulls должен содержать ‘ ‘, если значение соответствую-
щего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем случае значение,
переданное в соответствующем элементе values, не учитывается.) Заметьте, что nulls — это
не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1244Интерфейс програм-
мирования сервера
SPI_cursor_open
SPI_cursor_open — открыть курсор для оператора, созданного функцией SPI_prepare
Синтаксис
Portal SPI_cursor_open(const char * name, SPIPlanPtr plan,
Datum * values, const char * nulls,
bool read_only)
Описание
SPI_cursor_open открывает курсор (внутри называемый порталом), через который будет выпол-
няться оператор, подготовленный функцией SPI_prepare. Параметры этой функции имеют тот же
смысл, что и соответствующие параметры SPI_execute_plan.
Применение курсора по сравнению с непосредственным выполнением оператора даёт двойную
выгоду. Во-первых, строки результата можно получать в небольших количествах, без риска исчер-
пать всю память при выполнении запросов, возвращающих много строк. Во-вторых, портал может
существовать и после завершения текущей функции на C (на самом деле он может просущество-
вать до конца текущей транзакции). Возвратив имя портала в код, вызывающий функцию на C,
можно организовать выдачу результата в виде набора строк.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_cursor_open считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1245Интерфейс програм-
мирования сервера
SPI_cursor_open_with_args
SPI_cursor_open_with_args — открывает курсор для запроса с параметрами
Синтаксис
Portal SPI_cursor_open_with_args(const char *name,
const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, int cursorOptions)
Описание
SPI_cursor_open_with_args открывает курсор (внутри называемый порталом) для выполнения за-
данного запроса. Большинство параметров имеют тот же смысл, что и соответствующие парамет-
ры функций SPI_prepare_cursor и SPI_cursor_open.
Для разового выполнения запроса эту функцию следует предпочесть SPI_prepare_cursor с после-
дующей SPI_cursor_open. Если же одна и та же команда должна выполняться с самыми разными
параметрами, какой вариант окажется быстрее, будет зависеть от стоимости повторного планиро-
вания и выигрыша от выбора специализированных планов.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_cursor_open_with_args считает, что ни один из параметров
не равен NULL. В противном случае, элемент массива nulls должен содержать ‘ ‘, если значе-
ние соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1246Интерфейс програм-
мирования сервера
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1247Интерфейс програм-
мирования сервера
SPI_cursor_open_with_paramlist
SPI_cursor_open_with_paramlist — открыть курсор с параметрами
Синтаксис
Portal SPI_cursor_open_with_paramlist(const char *name,
SPIPlanPtr plan,
ParamListInfo params,
bool read_only)
Описание
SPI_cursor_open_with_paramlist открывает курсор (внутри называемый порталом) для вы-
полнения оператора, подготовленного функцией SPI_prepare. Эта функция равнозначна
SPI_cursor_open, не считая того, что информация о значениях параметров, передаваемых запро-
су, представляется по-другому. Представление ParamListInfo может быть удобным для передачи
значений, уже имеющих нужный формат. Эта функция также поддерживает динамические набо-
ры параметров через функции-обработчики, устанавливаемые в ParamListInfo.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1248Интерфейс програм-
мирования сервера
SPI_cursor_find
SPI_cursor_find — найти существующий курсор по имени
Синтаксис
Portal SPI_cursor_find(const char * name)
Описание
SPI_cursor_find находит существующий портал по имени. В основном это полезно для разреше-
ния имени курсора, возвращённого в текстовом виде какой-то другой функцией.
Аргументы
const char * name
имя портала
Возвращаемое значение
указатель на портал с заданным именем или NULL, если такой портал не найден
1249Интерфейс програм-
мирования сервера
SPI_cursor_fetch
SPI_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_cursor_fetch(Portal portal, bool forward, long count)
Описание
SPI_cursor_fetch выбирает некоторое количество строк через курсор. Эта функция реализует
подмножество возможностей SQL-команды FETCH (расширенную функциональность предоставля-
ет SPI_scroll_cursor_fetch).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для выборки с перемещением вперёд, false — назад
long count
максимальное число строк, которое нужно выбрать
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Выборка назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1250Интерфейс програм-
мирования сервера
SPI_cursor_move
SPI_cursor_move — переместить курсор
Синтаксис
void SPI_cursor_move(Portal portal, bool forward, long count)
Описание
SPI_cursor_move перемещает курсор на несколько строк. Эта функция реализует подмно-
жество возможностей SQL-команды MOVE (расширенную функциональность предоставляет
SPI_scroll_cursor_move).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для перемещения вперёд, false — назад
long count
максимальное число строк, на какое возможно перемещение
Замечания
Перемещение назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1251Интерфейс програм-
мирования сервера
SPI_scroll_cursor_fetch
SPI_scroll_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_scroll_cursor_fetch(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_fetch выбирает некоторое количество строк через курсор. Её функциональ-
ность равнозначна FETCH в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, выбираемых с направлением FETCH_FORWARD или FETCH_BACKWARD; абсолютный но-
мер выбираемой строки с вариантом FETCH_ABSOLUTE; либо относительный номер выбираемой
строки с вариантом FETCH_RELATIVE
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1252Интерфейс програм-
мирования сервера
SPI_scroll_cursor_move
SPI_scroll_cursor_move — переместить курсор
Синтаксис
void SPI_scroll_cursor_move(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_move перемещает курсор на несколько строк. Её функциональность равнознач-
на MOVE в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, на которое сдвигается курсор, с направлением FETCH_FORWARD или FETCH_BACKWARD;
абсолютный номер строки, к которой переходит курсор, с направлением FETCH_ABSOLUTE; либо
относительный номер строки, к которой переходит курсор, с направлением FETCH_RELATIVE
Возвращаемое значение
В случае успеха переменная SPI_processed устанавливается как в SPI_execute. В SPI_tuptable
оказывается NULL, так как эта функция не возвращает никакие строки.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1253Интерфейс програм-
мирования сервера
SPI_cursor_close
SPI_cursor_close — закрыть курсор
Синтаксис
void SPI_cursor_close(Portal portal)
Описание
SPI_cursor_close закрывает ранее созданный курсор и освобождает память, занятую его порта-
лом.
Все открытые курсоры закрываются автоматически в конце транзакции. Вызывать
SPI_cursor_close может потребоваться, только если возникает желание освободить ресурсы ско-
рее.
Аргументы
Portal portal
портал, содержащий курсор
1254Интерфейс програм-
мирования сервера
SPI_keepplan
SPI_keepplan — сохранить подготовленный оператор
Синтаксис
int SPI_keepplan(SPIPlanPtr plan)
Описание
SPI_keepplan закрепляет переданный оператор (подготовленный функцией SPI_prepare), чтобы
он не был ликвидирован функцией SPI_finish или диспетчером транзакций. Это даёт возможность
повторно использовать подготовленные операторы при последующих вызовах вашей функции на
C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
Замечания
Переданный оператор перемещается в постоянное хранилище путём смены указателя (копировать
данные не требуется). Если позже вы захотите удалить его, выполните для него SPI_freeplan.
1255Интерфейс програм-
мирования сервера
SPI_saveplan
SPI_saveplan — сохранить подготовленный оператор
Синтаксис
SPIPlanPtr SPI_saveplan(SPIPlanPtr plan)
Описание
SPI_saveplan копирует переданный оператор (подготовленный функцией SPI_prepare) в память,
чтобы он не был ликвидирован функцией SPI_finish или менеджером транзакций, и возвращает
указатель на скопированный оператор. Это даёт возможность повторно использовать подготовлен-
ные операторы при последующих вызовах вашей функции на C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
Указатель на скопированный оператор, либо NULL в случае ошибки. При ошибке SPI_result при-
нимает одно из этих значений:
SPI_ERROR_ARGUMENT
если plan неверный или NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Изначально переданный оператор не освобождается, поэтому вы можете выполнить SPI_freeplan
для него, чтобы высвободить память до SPI_finish.
В большинстве случаев SPI_keepplan предпочтительнее данной функции, так как она даёт при-
мерно тот же результат, но обходится без физического копирования структур данных подготов-
ленного оператора.
1256Интерфейс програм-
мирования сервера
SPI_register_relation
SPI_register_relation — сделать эфемерное именованное отношение доступным по имени в запросах
SPI
Синтаксис
int SPI_register_relation(EphemeralNamedRelation enr)
Описание
SPI_register_relation делает эфемерное именованное отношение (со связанной информацией)
доступным в запросах, планируемых и выполняемых через текущее подключение SPI.
Аргументы
EphemeralNamedRelation enr
запись эфемерного именованного отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_REGISTER
если отношение было успешно зарегистрировано по имени
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если NULL передан в enr или в поле name
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя, заданное в поле name структуры enr, уже зарегистрировано для этого отношения
1257Интерфейс програм-
мирования сервера
SPI_unregister_relation
SPI_unregister_relation — удалить эфемерное именованное отношение из реестра
Синтаксис
int SPI_unregister_relation(const char * name)
Описание
SPI_unregister_relation удаляет эфемерное именованное отношение из реестра для текущего
подключения.
Аргументы
const char * name
имя записи отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_UNREGISTER
если совокупность кортежей была успешно удалена из реестра
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в name передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_NOT_FOUND
если name не находится в реестре для текущего подключения
1258Интерфейс програм-
мирования сервера
SPI_register_trigger_data
SPI_register_trigger_data — сделать эфемерные данные триггера доступными в запросах SPI
Синтаксис
int SPI_register_trigger_data(TriggerData *tdata)
Описание
SPI_register_trigger_data делает эфемерные отношения, которые перехватывает триггер, до-
ступными для запросов, планируемых и выполняемых через текущее подключение SPI. В настоя-
щее время это переходные таблицы, перехватываемые триггером AFTER, определённым с предло-
жением REFERENCING OLD/NEW TABLE AS. Эта функция должна вызываться функцией, реализующей
триггер на языке программирования, после подключения.
Аргументы
TriggerData *tdata
объект TriggerData, передаваемый функцией, реализующей триггер, через fcinfo-&gt;context
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_TD_REGISTER
если перехваченные данные триггера (при наличии) были успешно зарегистрированы
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в tdata передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя в любом из переходных отношений в данных триггера уже зарегистрировано для этого
подключения
47.2. Вспомогательные интерфейсные функции
Функции, описанные здесь, предоставляют возможности для извлечения информации из наборов
результатов, возвращаемых SPI_execute и другими функциями SPI.
Все функции, описанные в этом разделе, могут использоваться и в подключённых, и в неподклю-
чённых функциях на C.
1259Интерфейс програм-
мирования сервера
SPI_fname
SPI_fname — определить имя столбца с заданным номером
Синтаксис
char * SPI_fname(TupleDesc rowdesc, int colnumber)
Описание
SPI_fname возвращает копию имени столбца с заданным номером. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя столбца; NULL, если colnumber вне допустимого диапазона. В случае ошибки в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1260Интерфейс програм-
мирования сервера
SPI_fnumber
SPI_fnumber — определить номер столбца с заданным именем
Синтаксис
int SPI_fnumber(TupleDesc rowdesc, const char * colname)
Описание
SPI_fnumber возвращает номер столбца, имеющего заданное имя.
Если colname ссылается на системный столбец (например, oid), возвращается соответствующий
отрицательный номер столбца. Вызывающий должен проверять, не была ли возвращена ошибка,
сравнивая значение результата именно с SPI_ERROR_NOATTRIBUTE; проверка результата по условию
меньше или равно нулю не будет корректной, если только системные столбцы не должны исклю-
чаться.
Аргументы
TupleDesc rowdesc
описание строк
const char * colname
имя столбца
Возвращаемое значение
Номер
столбца
(начиная
с
1
для
столбцов,
создаваемых
SPI_ERROR_NOATTRIBUTE, если столбец с заданным именем не найден.
1261
пользователем),
либоИнтерфейс програм-
мирования сервера
SPI_getvalue
SPI_getvalue — получить строковое значение указанного столбца
Синтаксис
char * SPI_getvalue(HeapTuple row, TupleDesc rowdesc, int colnumber)
Описание
SPI_getvalue возвращает строковое представление значения указанного столбца.
Результат возвращается в памяти, размещённой функцией palloc. (Когда он будет не нужен, эту
память можно освободить с помощью pfree.)
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Значение столбца, либо NULL, если столбец содержит NULL, colnumber вне допустимого диапазона
(в SPI_result при этом устанавливается SPI_ERROR_NOATTRIBUTE) или если отсутствует функция
вывода (в SPI_result устанавливается SPI_ERROR_NOOUTFUNC).
1262Интерфейс програм-
мирования сервера
SPI_getbinval
SPI_getbinval — получить двоичное значение указанного столбца
Синтаксис
Datum SPI_getbinval(HeapTuple row, TupleDesc rowdesc, int colnumber,
bool * isnull)
Описание
SPI_getbinval возвращает значение указанного столбца во внутренней форме (в структуре Datum).
Эта функция не выделяет новый блок памяти для данных. В случае с типом, передаваемым по
ссылке, возвращаемым значением будет указатель на переданную строку данных.
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
bool * isnull
признак того, что столбец содержит NULL
Возвращаемое значение
Возвращается двоичное значение столбца. Если этот столбец содержит NULL, переменной, на ко-
торую указывает isnull, присваивается true; в противном случае — false.
При ошибке в SPI_result устанавливается SPI_ERROR_NOATTRIBUTE.
1263Интерфейс програм-
мирования сервера
SPI_gettype
SPI_gettype — получить имя типа данных указанного столбца
Синтаксис
char * SPI_gettype(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettype возвращает копию имени типа данных указанного столбца. (Когда эта копия имени
будет не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя типа данных указанного столбца, либо NULL в случае ошибки. При ошибке в SPI_result уста-
навливается SPI_ERROR_NOATTRIBUTE.
1264Интерфейс програм-
мирования сервера
SPI_gettypeid
SPI_gettypeid — получить OID типа данных указанного столбца
Синтаксис
Oid SPI_gettypeid(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettypeid возвращает OID типа данных указанного столбца.
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
OID типа данных указанного столбца, либо InvalidOid в случае ошибки. При ошибке в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1265Интерфейс програм-
мирования сервера
SPI_getrelname
SPI_getrelname — возвращает имя указанного отношения
Синтаксис
char * SPI_getrelname(Relation rel)
Описание
SPI_getrelname возвращает копию имени указанного отношения. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя указанного отношения.
1266Интерфейс програм-
мирования сервера
SPI_getnspname
SPI_getnspname — возвращает пространство имён указанного отношения
Синтаксис
char * SPI_getnspname(Relation rel)
Описание
SPI_getnspname возвращает копию имени пространства имён, к которому принадлежит указанное
отношение (Relation). Пространство имён по-другому называется схемой отношения. Когда зна-
чение, возвращённое этой функцией, будет не нужно, освободите его с помощью pfree.
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя пространства имён указанного отношения.
1267Интерфейс програм-
мирования сервера
SPI_result_code_string
SPI_result_code_string — возвращает код ошибки в виде строки
Синтаксис
const char * SPI_result_code_string(int code);
Описание
SPI_result_code_string выдаёт строковое представление для кода результата, который возвра-
щается различными функциями SPI или находится в SPI_result.
Аргументы
int code
код результата
Возвращаемое значение
Строковое представление кода результата.
47.3. Управление памятью
PostgreSQL выделяет память в контекстах памяти, и тем самым реализует удобный способ управ-
ления выделением памяти в различных местах, с разными сроками жизни выделенной памяти.
При уничтожении контекста освобождается вся выделенная в нём память. Таким образом, нет
необходимости контролировать каждый отдельный объект во избежание утечек памяти; вместо
этого достаточно управлять только небольшим числом контекстов. Функция palloc и родственные
ей освобождают память из «текущего» контекста.
SPI_connect создаёт новый контекст памяти и делает его текущим. SPI_finish восстанавли-
вает контекст, который был текущим до этого, и уничтожает контекст, созданный функцией
SPI_connect. Эти действия обеспечивают при выходе из вашей функции на C освобождение вре-
менной памяти, выделенной внутри этой функции, во избежание утечки памяти.
Однако если ваша функция на C должна вернуть объект в выделенной памяти (как значение ти-
па, передаваемого по ссылке), эту память нельзя выделять через palloc, как минимум пока уста-
новлено подключение к SPI. Если вы попытаетесь это сделать, объект будет освобождён при вы-
зове SPI_finish и ваша функция не будет работать надёжно. Для решения этой проблемы выде-
ляйте память для возвращаемого объекта, используя SPI_palloc. SPI_palloc выделяет память в
«верхнем контексте исполнителя», то есть, в контексте памяти, который был текущим при вызо-
ве SPI_connect; именно этот контекст подходит для значения, возвращаемого из функции на C.
Некоторые из вспомогательных функций, описанных в этом разделе, также возвращают объекты,
созданные в верхнем контексте исполнителя.
Когда вызывается SPI_connect, текущим контекстом становится частный контекст функции на C,
создаваемый в SPI_connect. Все операции выделения памяти, выполняемые функциями palloc,
repalloc или служебными функциями SPI (кроме описанных в этом разделе исключений), произво-
дятся в этом контексте. Когда функция на C отключается от менеджера SPI (выполняя SPI_finish),
текущим контекстом снова становится верхний контекст исполнителя, а вся память, выделенная
в контексте этой функции, освобождается, так что использовать её дальше нельзя.
1268Интерфейс програм-
мирования сервера
SPI_palloc
SPI_palloc — выделить память в верхнем контексте исполнителя
Синтаксис
void * SPI_palloc(Size size)
Описание
SPI_palloc выделяет память в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она выдаёт ошибку.
Аргументы
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на выделенный блок памяти заданного размера
1269Интерфейс програм-
мирования сервера
SPI_repalloc
SPI_repalloc — поменять блок памяти в верхнем контексте исполнителя
Синтаксис
void * SPI_repalloc(void * pointer, Size size)
Описание
SPI_repalloc изменяет размер блока памяти, ранее выделенного функцией SPI_palloc.
Эта функция теперь не отличается от простой repalloc. Она сохранена только для обратной сов-
местимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий изменению
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на новый блок памяти указанного размера, в который скопировано содержимое преж-
него блока
1270Интерфейс програм-
мирования сервера
SPI_pfree
SPI_pfree — освободить память в верхнем контексте исполнителя
Синтаксис
void SPI_pfree(void * pointer)
Описание
SPI_pfree освобождает память, ранее выделенную функцией SPI_palloc или SPI_repalloc.
Эта функция теперь не отличается от простой pfree. Она сохранена только для обратной совме-
стимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий освобождению
1271Интерфейс програм-
мирования сервера
SPI_copytuple
SPI_copytuple — скопировать строку в верхнем контексте исполнителя
Синтаксис
HeapTuple SPI_copytuple(HeapTuple row)
Описание
SPI_copytuple делает копию строки в верхнем контексте исполнителя. Обычно это применяется,
когда нужно вернуть изменённую строку из триггера. В функции, которая должна возвращать со-
ставной тип, нужно использовать SPI_returntuple.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
HeapTuple row
строка, подлежащая копированию
Возвращаемое значение
скопированная строка либо NULL в случае ошибки (SPI_result содержит код ошибки)
1272Интерфейс програм-
мирования сервера
SPI_returntuple
SPI_returntuple — подготовить строку для возврата в виде Datum
Синтаксис
HeapTupleHeader SPI_returntuple(HeapTuple row, TupleDesc rowdesc)
Описание
SPI_returntuple делает копию строки в верхнем контексте исполнителя и возвращает её в форме
типа Datum. Чтобы выдать результат, полученный указатель остаётся только преобразовать в Datum
функцией PointerGetDatum.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Заметьте, что эту операцию следует применять в функциях, объявленных как возвращающие со-
ставные типы. В триггерах она не применяется; чтобы вернуть изменённую строку из триггера,
используйте SPI_copytuple.
Аргументы
HeapTuple row
строка, подлежащая копированию
TupleDesc rowdesc
дескриптор строки (передавайте каждый раз один дескриптор для более эффективного кеши-
рования)
Возвращаемое значение
HeapTupleHeader, указывающий на скопированную строку, или NULL в случае ошибки (SPI_result
содержит код ошибки)
1273Интерфейс програм-
мирования сервера
SPI_modifytuple
SPI_modifytuple — создать строку, заменяя отдельные поля в данной
Синтаксис
HeapTuple SPI_modifytuple(Relation rel, HeapTuple row, int ncols,
int * colnum, Datum * values, const char * nulls)
Описание
SPI_modifytuple создаёт новую строку, подставляя новые значения для указанных столбцов и ко-
пируя исходное содержимое остальных столбцов. Исходная строка не изменяется. Новая строка
возвращается в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
Relation rel
Используется только в качестве дескриптора строки. (Передача отношения вместо собственно
дескриптора строки — нехорошая особенность.)
HeapTuple row
строка, подлежащая изменению
int ncols
число изменяемых столбцов
int * colnum
массив длины ncols, содержащий номера изменяемых столбцов (начиная с 1)
Datum * values
массив длины ncols, содержащий новые значения указанных столбцов
const char * nulls
массив длины ncols, описывающий, в каких столбцах передаётся NULL
Если в nulls передаётся NULL, SPI_modifytuple считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль ‘\0’ в конце не нужен.
Возвращаемое значение
новая строка с изменениями, размещённая в верхнем контексте исполнителя, или NULL при ошибке
(SPI_result содержит код ошибки)
В случае ошибки в SPI_result устанавливается:
SPI_ERROR_ARGUMENT
если rel — NULL, либо row — NULL, либо ncols меньше или равно 0, либо colnum — NULL, либо
values — NULL
1274Интерфейс програм-
мирования сервера
SPI_ERROR_NOATTRIBUTE
если colnum содержит недопустимый номер столбца (меньше или равен 0, либо больше числа
столбцов в строке row)
SPI_ERROR_UNCONNECTED
если SPI неактивен
1275Интерфейс програм-
мирования сервера
SPI_freetuple
SPI_freetuple — освободить строку, размещённую в верхнем контексте исполнителя
Синтаксис
void SPI_freetuple(HeapTuple row)
Описание
SPI_freetuple освобождает строку, ранее размещённую в верхнем контексте исполнителя.
Эта функция теперь не отличается от простой heap_freetuple. Она сохранена только для обратной
совместимости с существующим кодом.
Аргументы
HeapTuple row
строка, подлежащая освобождению
1276Интерфейс програм-
мирования сервера
SPI_freetuptable
SPI_freetuptable — освободить набор строк, созданный SPI_execute или подобной функцией
Синтаксис
void SPI_freetuptable(SPITupleTable * tuptable)
Описание
SPI_freetuptable освобождает набор строк, созданных предыдущей функцией SPI выполнения ко-
манд, например SPI_execute. Таким образом, при вызове этой функции в качестве аргумента часто
передаётся глобальная переменная SPI_tuptable.
Эта функция полезна, когда функция на C, использующая SPI, должна выполнить несколько ко-
манд, но не хочет сохранять результаты предыдущих команд до завершения. Заметьте, что любые
не освобождённые таким образом наборы строк будут всё равно освобождены при выполнении
SPI_finish. Кроме того, если была запущена подтранзакция, а затем она прервалась в ходе выпол-
нения использующей SPI функции, все наборы строк, созданные в рамках подтранзакции, будут
автоматически освобождены.
Начиная с PostgreSQL версии 9.3, SPI_freetuptable содержит защитную логику, отфильтровыва-
ющую повторные запросы на удаление одного и того же набора строк. В предыдущих версиях по-
вторное удаление могло приводить к сбоям.
Аргументы
SPITupleTable * tuptable
указатель на набор строк, который нужно освободить (если NULL, ничего не происходит)
1277Интерфейс програм-
мирования сервера
SPI_freeplan
SPI_freeplan — освободить ранее сохранённый подготовленный оператор
Синтаксис
int SPI_freeplan(SPIPlanPtr plan)
Описание
SPI_freeplan освобождает подготовленный оператор, до этого выданный функцией SPI_prepare
или сохранённый функциями SPI_keepplan и SPI_saveplan.
Аргументы
SPIPlanPtr plan
указатель на оператор, подлежащий освобождению
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
47.4. Управление транзакциями
Выполнять команды управления транзакциями (в частности, COMMIT и ROLLBACK) через функции
SPI, такие как SPI_execute, нельзя. Однако имеются отдельные интерфейсные функции, которые
предназначены для управления транзакциями через SPI.
Вообще говоря, не всегда безопасно и разумно начинать и заканчивать транзакции в произволь-
ных определяемых пользователями функциях, вызываемых из SQL, не принимая во внимание кон-
текст их вызова. Например, завершение транзакции в середине функции, вызванной в сложном
SQL-выражении внутри некоторой SQL-команды, скорее всего приведёт к странным внутренним
ошибкам или сбоям. Представленные здесь интерфейсные функции прежде всего предназначены
для использования реализациями процедурных языков с целью управления транзакциями в про-
цедурах уровня SQL, вызываемых командой CALL (при этом учитывается её контекст). Та же логи-
ка может быть реализована в процедурах на C, использующих SPI, но подробное освещение этой
темы выходит за рамки данной документации.
1278Интерфейс програм-
мирования сервера
SPI_commit
SPI_commit — зафиксировать текущую транзакцию
Синтаксис
void SPI_commit(void)
Описание
SPI_commit фиксирует текущую транзакцию. Это примерно равносильно выполнению SQL-коман-
ды COMMIT. После того как транзакция зафиксирована, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1279Интерфейс програм-
мирования сервера
SPI_rollback
SPI_rollback — прервать текущую транзакцию
Синтаксис
void SPI_rollback(void)
Описание
SPI_rollback откатывает текущую транзакцию. Это примерно равносильно выполнению SQL-ко-
манды ROLLBACK. После того как транзакция отменена, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1280Интерфейс програм-
мирования сервера
SPI_start_transaction
SPI_start_transaction — начать новую транзакцию
Синтаксис
void SPI_start_transaction(void)
Описание
Функция SPI_start_transaction начинает новую транзакцию. Она может вызываться только по-
сле SPI_commit или SPI_rollback, когда нет активной транзакции. Обычно, когда вызывается про-
цедура, использующая SPI, транзакция уже выполняется, поэтому при попытке начать ещё одну
до завершения текущей возникнет ошибка.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
47.5. Видимость изменений в данных
Видимость изменений в данных, которые производятся функциями, использующими SPI, (или лю-
быми другими функциями на C), описывается следующими правилами:
• В процессе выполнения SQL-команды любые произведённые ей изменения не видны для неё
самой. Например, в команде:
INSERT INTO a SELECT * FROM a;
вставляемые строки не видны в части SELECT.
• Изменения, произведённые командой К, видны во всех командах, запущенных после К, неза-
висимо от того, были ли эти команды запущены из К (во время выполнения К) или после за-
вершения К.
• Команды, выполняемые через SPI внутри функции, вызванной SQL-командой (будь то обычная
функция или триггер), следуют одному или другому из вышеприведённых правил в зависи-
мости флага чтения/записи, переданного SPI. Команды, выполняемые в режиме «только чте-
ние», следует первому правилу: они не видят изменений, произведённых вызывающей коман-
дой. Команды, выполняемые в режиме «чтение-запись», следуют второму правилу: они могут
видеть все произведённые к этому времени изменения.
• Все стандартные процедурные языки устанавливают режим чтения-записи в SPI в зависимо-
сти от атрибута изменчивости функции. Команды функций STABLE и IMMUTABLE выполняются в
режиме «только чтение», тогда как команды функций VOLATILE — в режиме «чтение-запись».
Хотя авторы функций на C могут нарушить это соглашение, вряд ли это будет хорошей идеей.
В следующем разделе приводится пример, иллюстрирующий применение этих правил.
47.6. Примеры
Этот раздел содержит очень простой пример использования SPI. Функция execq принимает в ка-
честве первого аргумента команду SQL, а в качестве второго число строк, выполняет команду, вы-
зывая SPI_exec, и возвращает число строк, обработанных этой командой. Более сложные примеры
работы с SPI вы можете найти в src/test/regress/regress.c в дереве исходного кода, а также в
модуле spi.
#include “postgres.h”
1281Интерфейс програм-
мирования сервера
#include “executor/spi.h”
#include “utils/builtins.h”
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(execq);
Datum
execq(PG_FUNCTION_ARGS)
{
char *command;
int cnt;
int ret;
uint64 proc;
/</em> Преобразовать данный текстовый объект в строку C <em>/
command = text_to_cstring(PG_GETARG_TEXT_PP(1));
cnt = PG_GETARG_INT32(2);
SPI_connect();
ret = SPI_exec(command, cnt);
proc = SPI_processed;
/</em></p>
<ul>
  <li>Если были выбраны какие-то строки, вывести их через elog(INFO).
*/
if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
{
TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
SPITupleTable *tuptable = SPI_tuptable;
char buf[8192];
uint64 j;
for (j = 0; j &lt; proc; j++)
{
HeapTuple tuple = tuptable-&gt;vals[j];
int i;
for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), “ %s%s”,
SPI_getvalue(tuple, tupdesc, i),
(i == tupdesc-&gt;natts) ? “ “ : “ |”);
elog(INFO, “EXECQ: %s”, buf);
}
}
SPI_finish();
pfree(command);
PG_RETURN_INT64(proc);
}
Так эта функция будет объявляться после того, как она будет скомпилирована в разделяемую биб-
лиотеку (подробности в Подразделе 38.10.5):
CREATE FUNCTION execq(text, integer) RETURNS int8
AS ‘имя_файла’
LANGUAGE C STRICT;
1282Интерфейс програм-
мирования сервера
Демонстрация использования:
=&gt; SELECT execq(‘CREATE TABLE a (x integer)’, 0);
execq
——-
0
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘INSERT INTO a VALUES (0)’, 0));
INSERT 0 1
=&gt; SELECT execq(‘SELECT * FROM a’, 0);
INFO: EXECQ: 0
– вставлено функцией execq
INFO: EXECQ: 1
– возвращено функцией execq и вставлено командой INSERT
execq
——-
2
(1 row)
=&gt; SELECT execq(‘INSERT INTO a SELECT x + 2 FROM a’, 1);
execq
——-
1
(1 row)
=&gt; SELECT execq(‘SELECT * FROM a’, 10);
INFO: EXECQ: 0
INFO: EXECQ: 1
INFO: EXECQ: 2
– 0 + 2, вставлена только одна строка - как указано
execq
——-
3
(1 row)
– 10 — только максимальное значение, 3 — реальное число строк
=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
– нет строк в a (0) + 1
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INFO: EXECQ: 1
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
2
– была одна строка в a + 1
(2 rows)
– Этот пример демонстрирует правило видимости изменений в данных:
=&gt; INSERT INTO a SELECT execq(‘SELECT * FROM a’, 0) * x FROM a;
1283Интерфейс програм-
мирования сервера
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 2
INSERT 0 2
=&gt; SELECT * FROM a;
x
—
1
2
2
– 2 строки * 1 (x в первой в строке)
6
– 3 строки (2 + 1 только вставленная) * 2 (x во второй строке)
(4 rows)
^^^^^^
строки, видимые в execq() при разных вызовах
1284</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page10/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page9/">9</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page10/">10</a></li>
      
    
      
        <li><strong class="current-page">11</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page12/">12</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page13/">13</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page12/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>