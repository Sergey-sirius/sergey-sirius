<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page3/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page3/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-072/" title="Приложение B. Поддержка даты и времени"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Приложение B. Поддержка даты и времени"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-072/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~9 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-072/" rel="bookmark" title="Приложение B. Поддержка даты и времени" itemprop="url">Приложение B. Поддержка даты и времени</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Приложение B. Поддержка даты и времени</p>

<p>PostgreSQL использует внутренний эвристический анализатор для поддержки всех значений даты
и времени. Дата и время вводятся как строки и разделяются на различные поля, при этом пред-
варительно определяется, какого рода информация содержится в конкретном поле. Каждое поле
интерпретируется и получает числовое значение, игнорируется или отклоняется. Анализатор со-
держит внутренние справочные таблицы для текстовых полей, включая месяцы, дни недели и ча-
совые пояса.
Данное приложение включает информацию о содержании справочных таблиц и описывает этапы,
необходимые анализатору для распознавания даты и времени.
B.1. Интерпретация данных даты и времени
Все значения даты и времени расшифровываются при помощи следующей процедуры.
1.
2.
3.
Разделить входную строку на фрагменты и определить каждый фрагмент как строку, время,
часовой пояс или цифру.
a. Если числовой фрагмент содержит двоеточие (:), значит эта строка представляет время.
Включаются все последующие цифры и двоеточия.
b. Если числовой фрагмент содержит тире (-), косую черту (/) или две и более точек (.),
то это строка даты, которая, возможно, включает название месяца. Если фрагмент даты
уже встречался, он интерпретируется как название часового пояса (например, America/
New_York).
c. Если этот фрагмент является лишь числом, он представляет собой отдельное поле или со-
ставную дату ISO 8601 (например, 19990113 для 13 января 1999 года) или время (например,
141516 для 14:15:16).
d. Если фрагмент начинается с плюса (+) или минуса (-), то это или числовой часовой пояс
или специальное поле.
Если фрагмент является текстовой строкой, сопоставить его с возможными строками:
a. Выполнить двоичный поиск в справочной таблице соответствующего фрагмента в виде аб-
бревиатуры часового пояса.
b. Если фрагмент не найден, выполнить подобный просмотр в таблице двоичного поиска,
чтобы определить фрагмент как специальную строку (например, today), день (например,
Thursday), месяц (например, January) или неучитываемое слово (например, at, on).
c. Если фрагмент всё же не найден, выдать ошибку.
Когда фрагмент является числом или числовым полем:
a. Если получено восемь или шесть цифр и никакое другое поле даты ранее не было прочита-
но, интерпретировать их как «составленную дату» (например, 19990118 или 990118). Такая
дата интерпретируется как ГГГГММДД или ГГММДД.
b. Если фрагмент представляет собой трёхзначное число, и год уже был прочитан, интерпре-
тировать как день года.
c. Если это четыре или шесть цифр и год уже был прочитан, интерпретировать как время
(ЧЧММ или ЧЧММСС).
d. Если найдены три или более цифр, а поля даты ещё не были найдены, интерпретировать
как год (это ведёт к установке порядка гг-мм-дд для оставшихся полей даты).
2207Поддержка даты и времени
e.
В противном случае подразумевается, что порядок сортировки полей даты определяется
значением DateStyle: мм-дд-гг, дд-мм-гг или гг-мм-дд. Выдать ошибку, если оказалось, что
поле месяца или дня вышло за пределы диапазона.</p>
<ol>
  <li>Если указан год до н. э., отнять год и добавить единицу для внутреннего хранения. (В григори-
анском календаре отсутствует нулевой год, поэтому 1 год до н. э. становится нулевым.)</li>
  <li>Если год до н. э. не был указан, и если поле года имело два разряда, установить для записи
года четыре разряда. Если поле меньше 70, добавить 2000, в противном случае добавить 1900.
Подсказка
Годы с 1 по 99 н. э. по григорианскому календарю могут вводится при помощи
четырёхзначного числа с начальными нулями (например, 0099 это год 99 н. э.).
B.2. Ключевые слова для обозначения даты и времени
Таблица B.1 показывает фрагменты, которые распознаются как названия месяцев.
Таблица B.1. Названия месяцев
Месяц Аббревиатуры
January Jan
February Feb
March Mar
April Apr
May
June Jun
July Jul
August Aug
September Sep, Sept
October Oct
November Nov
December Dec
Таблица B.2 показывает фрагменты, которые распознаются как названия дней недели.
Таблица B.2. Названия дней недели
День Аббревиатуры
Sunday Sun
Monday Mon
Tuesday Tue, Tues
Wednesday Wed, Weds
Thursday Thu, Thur, Thurs
Friday Fri
Saturday Sat
Таблица B.3 показывает фрагменты, которые выполняют различные функции модификаторов.
2208Поддержка даты и времени
Таблица B.3. Модификаторы поля даты/времени
Идентификатор Описание
AM Время до 12:00
AT игнорируется
JULIAN, JD, J Следующее поле является юлианской датой
ON игнорируется
PM Время 12:00 и более позднее
T Следующее поле указывает на время
B.3. Файлы конфигурации даты/времени
Поскольку аббревиатуры часовых поясов недостаточно стандартизированы, PostgreSQL предлага-
ет средства для определения набора аббревиатур, принимаемых сервером. Параметром выполне-
ния timezone_abbreviations определяется активный набор аббревиатур. Хотя данный параметр мо-
жет быть изменён любым пользователем базы данных, возможные значения для него контролиру-
ются администратором базы данных и являются именами конфигурационных файлов, хранящих-
ся в …/share/timezonesets/ каталога установки. Добавляя или изменяя файлы в этом каталоге,
администратор может определить местную специфику выбора аббревиатур часовых поясов.
Значение timezone_abbreviations может быть установлено в любое имя файла, находящегося
в …/share/timezonesets/, если имя файла состоит только из букв. (Запрет на использование
небуквенных символов в timezone_abbreviations делает невозможным чтение файлов, находя-
щихся вне заданного каталога, а также резервных файлов редактора и прочих внешних файлов.)
Файл аббревиатур часовых поясов может содержать пустые строки и комментарии, начинающиеся
с #. Строки, не имеющие комментариев, должны иметь один из следующих форматов:
аббревиатура_пояса смещение
аббревиатура_пояса смещение D
аббревиатура_пояса имя_часового_пояса
@INCLUDE имя_файла
@OVERRIDE
Поле аббревиатура_пояса лишь задаёт определяемую аббревиатуру. Смещение — это целое число,
задающее эквивалентное смещение от UTC в секундах, положительное — к востоку от Гринвич-
ского меридиана, а отрицательное — к западу. Например, -18000 означало бы пять часов к запа-
ду от Гринвича, или Североамериканское восточное время. D указывает, что название пояса пред-
ставляет местное летнее, а не поясное время.
В качестве альтернативы может быть задано имя_часового_пояса, определённое в базе данных
часовых поясов IANA. В этом случае система обращается к определению пояса, чтобы выяснить,
используется или использовалась ли аббревиатура для этого пояса, и если да, действовать будет
соответствующее значение — то есть, значение, действовавшее в указанный момент времени, или
действовавшее непосредственно перед ним, если текущее на тот момент неизвестно, либо самое
старое значение, если первое определение появилось после этого момента. Это поведение важно
для тех аббревиатур, значение которых менялось в ходе истории. Также допускается определение
аббревиатуры через имя часового пояса, с которым эта аббревиатура не связана; в таком случае
использование аббревиатуры равнозначно написанию просто имени пояса.
Подсказка
Простое целочисленное смещение предпочтительнее использовать, когда определяется
аббревиатура, смещение которой от UTC никогда не менялось, так как обрабатывать
подобные аббревиатуры гораздо легче, чем те, что требуют обращения к определению
часового пояса.
2209Поддержка даты и времени
Использование @INCLUDE позволяет включить другой файл в каталоге …/share/timezonesets/.
Включение может быть вложенным до ограниченной глубины.
Использование @OVERRIDE указывает, что последующие записи в файле могут переопределять
предыдущие (как правило, это записи, полученные из включённых файлов). Без этого указания
конфликтующие определения аббревиатуры одного и того же часового пояса считаются ошибкой.
При установке без внесения изменений, файл Default содержит все неконфликтующие аббревиа-
туры часовых поясов для большей части земного шара. Дополнительные файлы Australia и India
предоставляются для данных регионов. Эти файлы сначала включают файл Default, а затем до-
бавляют и изменяют аббревиатуры по мере необходимости.
В качестве справочной информации стандартная установка также содержит файлы Africa.txt,
America.txt и т. д., содержащие информацию о каждой используемой аббревиатуре часового поя-
са, включённой в базу данных часовых поясов IANA. Определения названий часовых поясов, нахо-
дящиеся в этих файлах, можно копировать и помещать в файл с нестандартной конфигурацией по
мере необходимости. Заметьте, что данные файлы нельзя указывать непосредственно в значении
timezone_abbreviations, так как их имена включают точку.
Примечание
Если при чтении набора аббревиатур часовых поясов возникает ошибка, новое значе-
ние не применяется и сохраняется старый набор. Если ошибка возникает при запуске
базы данных, происходит сбой.
Внимание
Аббревиатуры часового пояса, определённые в файле конфигурации, переопределяют
не относящиеся к часовому поясу значения, встроенные в PostgreSQL. Например, файл
конфигурации Australia определяет SAT (для Южноавстралийского стандартного вре-
мени, South Australian Standard Time). Когда этот файл активен, SAT не будет распозна-
ваться как сокращение слова “суббота”.
Внимание
Если вы модифицируете файлы в …/share/timezonesets/, вы можете сами выполнить
резервное копирование, так как обычный дамп базы данных не содержит этот каталог.
B.4. История единиц измерения времени
Стандарт SQL устанавливает, что «В определении „литерала типа дата-время“, „значения типа
дата-время“ ограничены естественными правилами, касающимися дат и времени согласно григо-
рианскому календарю». Следуя стандарту SQL, PostgreSQL подсчитывает даты исключительно в
григорианском календаре, включая годы, когда этот календарь ещё не использовался. Это прави-
ло известно как пролептический григорианский календарь.
Юлианский календарь был введён Юлием Цезарем в 45 г. до н. э. Он широко использовался запад-
ной цивилизацией до 1582 года, когда страны начали переходить на григорианский календарь. В
юлианском календаре тропический год длится приблизительно 365 1/4 дня = 365,25 дня. Каждые
128 лет накапливается примерно 1 день.
Накапливающаяся погрешность побудила папу Григория XIII реформировать календарь в соответ-
ствии с постановлениями Тридентского собора. В григорианском календаре тропический год длит-
2210Поддержка даты и времени
ся приблизительно 365 + 97 / 400 дней = 365,2425 дней. Таком образом, погрешность в один день
тропического года накапливается примерно за 3300 лет.
Приблизительное число 365+97/400 получается из-за того, что из каждых 400 лет 97 високосные.
При этом действуют следующие правила:
Каждый год кратный 4 является високосным.
Однако каждый год кратный 100 не является високосным.
Тем не менее, каждый год кратный 400 всё же является високосным.
Таким образом, 1700, 1800, 1900, 2100 и 2200 не являются високосными годами. Но 1600, 2000 и
2400 — високосные. А в юлианском календаре високосными считаются все годы, кратные 4.
Папская булла, изданная в феврале 1582 года, предписывала сделать октябрь 1582 года на 10 дней
короче, чтобы 15 октября следовало сразу за 4 октября. Это правило соблюдалось в Италии, Поль-
ше, Португалии и Испании. Вскоре к ним присоединились и прочие католические страны, но про-
тестантские страны вводили эти изменения неохотно, а страны греческой православной церкви
не переходили на новый календарь до начала 20 века. В 1752 г. реформа была проведена в Вели-
кобритании и её доминионах (включая территорию сегодняшних Соединённых Штатов Америки).
Таким образом, за 2 сентября 1752 года следовало 14 сентября 1752 года. Поэтому в системах Unix
программа cal выводит следующее:
$ cal 9 1752
September 1752
S M Tu W Th F S
1 2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
Но этот календарь действует только в Великобритании и доминионах. В других местах он является
недействительным. Чтобы избежать сложностей и возможной путаницы при отслеживании кален-
дарей, которыми фактически пользовались в различных местах в разное время, PostgreSQL при-
меняет правила григорианского календаря ко всем датам, даже если это нарушает историческую
достоверность.
Разные календари были составлены в различных частях земного шара, многие из них до григори-
анской системы. Например, появление китайского календаря относится к 14 веку до н. э. Легенда
гласит, что император Хуан-ди изобрёл этот календарь в 2637 г. до н. э. В Китайской Народной
Республике григорианский календарь используется для официальных и коммерческих нужд. Ки-
тайский календарь используется для определения дат традиционных праздников.
Юлианский период является ещё одним типом календаря. Он не имеет отношения к юлианско-
му календарю, несмотря на схожие названия. Данный способ измерения времени был изобретён
французским учёным Жозефом Жюстом Скалигером (1540-1609) и так назван, вероятно, в честь
отца Скалигера, итальянского учёного Юлия Цезаря Скалигера (1484-1558). В юлианском перио-
де, каждый день имеет порядковый номер, начиная с 0 (иногда его называют юлианская дата или
JD 0). Первый день имеет номер 0 и соответствует 1 января 4713 г. до н. э. по юлианскому кален-
дарю или 24 ноября 4714 г. до н. э. по григорианскому календарю. Юлианская дата чаще всего
используется в астрономических расчётах для записи ночных наблюдений, и поэтому день длится
от полудня до полудня UTC, а не с полуночи до полуночи: Первый юлианский день (JD 0) обозна-
чает 24 часа от полудня UTC 24 ноября 4714 г. до н. э. до полудня UTC 25 ноября 4714 г. до н. э.
Хотя PostgreSQL поддерживает юлианскую дату для записи входных и выходных дат (а также, ис-
пользует юлианские даты для некоторых внутренних вычислений в формате дата-время), полдень
не считается началом суток. PostgreSQL рассматривает юлианский день как длящийся от полуно-
чи до полуночи.
2211</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-071/" title="Приложение A. Коды ошибок PostgreSQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Приложение A. Коды ошибок PostgreSQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-071/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~5 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-071/" rel="bookmark" title="Приложение A. Коды ошибок PostgreSQL" itemprop="url">Приложение A. Коды ошибок PostgreSQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Часть VIII. Приложения
Приложение A. Коды ошибок PostgreSQL</p>

<p>Всем сообщениям, которые выдаёт сервер PostgreSQL, назначены пятисимвольные коды ошибок,
соответствующие кодам «SQLSTATE», описанным в стандарте SQL. Приложения, которые должны
знать, какое условие ошибки имело место, обычно проверяют код ошибки и только потом обраща-
ются к текстовому сообщению об ошибке. Коды ошибок, скорее всего, не изменятся от выпуска к
выпуску PostgreSQL, и они не меняются при локализации как сообщения об ошибках. Заметьте,
что отдельные, но не все коды ошибок, которые выдаёт PostgreSQL, определены стандартом SQL;
некоторые дополнительные коды ошибок для условий, не описанных стандартом, были добавлены
независимо или позаимствованы из других баз данных.
Согласно стандарту, первые два символа кода ошибки обозначают класс ошибок, а последние три
символа обозначают определённое условие в этом классе. Таким образом, приложение, не знаю-
щее значение определённого кода ошибки, всё же может понять, что делать, по классу ошибки.
В Таблице A.1 перечислены все коды ошибок, определённые в PostgreSQL 11.1. (Некоторые коды в
настоящее время не используются, хотя они определены в стандарте SQL.) Также показаны клас-
сы ошибок. Для каждого класса ошибок имеется «стандартный» код ошибки с последними тремя
символами 000. Этот код выдаётся только для таких условий ошибок, которые относятся к некото-
рому классу, но не имеют более определённого кода.
Символ, указанный в столбце «Имя условия», определяет условие в PL/pgSQL. Имена условий мо-
гут записываться в верхнем или нижнем регистре. (Заметьте, что PL/pgSQL, в отличие от ошибок,
не распознаёт предупреждения; то есть классы 00, 01 и 02.)
Для некоторых типов ошибок сервер сообщает имя объекта базы данных (таблица, столбец таб-
лицы, тип данных или ограничение), связанного с ошибкой; например, имя уникального ограни-
чения, вызвавшего ошибку unique_violation. Такие имена передаются в отдельных полях сооб-
щения об ошибке, чтобы приложениям не пришлось извлекать его из возможно локализованного
текста ошибки для человека. На момент выхода PostgreSQL 9.3 полностью охватывались только
ошибки класса SQLSTATE 23 (нарушения ограничений целостности), но в будущем должны быть
охвачены и другие классы.
Таблица A.1. Коды ошибок PostgreSQL
Код ошибки
Имя условия
Класс 00 — Успешное завершение
00000
successful_completion
Класс 01 — Предупреждение
01000 warning
0100C dynamic_result_sets_returned
01008 implicit_zero_bit_padding
01003 null_value_eliminated_in_set_function
01007 privilege_not_granted
01006 privilege_not_revoked
01004 string_data_right_truncation
01P01 deprecated_feature
Класс 02 — Нет данных (это также класс предупреждений согласно стандарту SQL)
02000 no_data
02001 no_additional_dynamic_result_sets_
returned
2198Коды ошибок PostgreSQL
Код ошибки
Имя условия
Класс 03 — SQL-оператор ещё не завершён
03000
sql_statement_not_yet_complete
Класс 08 — Исключение, связанное с подключением
08000 connection_exception
08003 connection_does_not_exist
08006 connection_failure
08001 sqlclient_unable_to_establish_
sqlconnection
08004 sqlserver_rejected_establishment_of_
sqlconnection
08007 transaction_resolution_unknown
08P01 protocol_violation
Класс 09 — Исключение с действием триггера
09000
triggered_action_exception
Класс 0A — Неподдерживаемая функциональность
0A000
feature_not_supported
Класс 0B — Неверное начало транзакции
0B000
invalid_transaction_initiation
Класс 0F — Исключение с указателем на данные
0F000 locator_exception
0F001 invalid_locator_specification
Класс 0L — Неверный праводатель
0L000 invalid_grantor
0LP01 invalid_grant_operation
Класс 0P — Неверное указание роли
0P000
invalid_role_specification
Класс 0Z — Исключение диагностики
0Z000 diagnostics_exception
0Z002 stacked_diagnostics_accessed_without_
active_handler
Класс 20 — Case не найден
20000
case_not_found
Класс 21 — Нарушение количества
21000
cardinality_violation
Класс 22 — Исключение в данных
22000 data_exception
2202E array_subscript_error
22021 character_not_in_repertoire
22008 datetime_field_overflow
22012 division_by_zero
22005 error_in_assignment
2199Коды ошибок PostgreSQL
Код ошибки Имя условия
2200B escape_character_conflict
22022 indicator_overflow
22015 interval_field_overflow
2201E invalid_argument_for_logarithm
22014 invalid_argument_for_ntile_function
22016 invalid_argument_for_nth_value_
function
2201F invalid_argument_for_power_function
2201G invalid_argument_for_width_bucket_
function
22018 invalid_character_value_for_cast
22007 invalid_datetime_format
22019 invalid_escape_character
2200D invalid_escape_octet
22025 invalid_escape_sequence
22P06 nonstandard_use_of_escape_character
22010 invalid_indicator_parameter_value
22023 invalid_parameter_value
22013 invalid_preceding_or_following_size
2201B invalid_regular_expression
2201W invalid_row_count_in_limit_clause
2201X invalid_row_count_in_result_offset_
clause
2202H invalid_tablesample_argument
2202G invalid_tablesample_repeat
22009 invalid_time_zone_displacement_value
2200C invalid_use_of_escape_character
2200G most_specific_type_mismatch
22004 null_value_not_allowed
22002 null_value_no_indicator_parameter
22003 numeric_value_out_of_range
2200H sequence_generator_limit_exceeded
22026 string_data_length_mismatch
22001 string_data_right_truncation
22011 substring_error
22027 trim_error
22024 unterminated_c_string
2200F zero_length_character_string
22P01 floating_point_exception
22P02 invalid_text_representation
22P03 invalid_binary_representation
2200Коды ошибок PostgreSQL
Код ошибки Имя условия
22P04 bad_copy_file_format
22P05 untranslatable_character
2200L not_an_xml_document
2200M invalid_xml_document
2200N invalid_xml_content
2200S invalid_xml_comment
2200T invalid_xml_processing_instruction
Класс 23 — Нарушение ограничения целостности
23000 integrity_constraint_violation
23001 restrict_violation
23502 not_null_violation
23503 foreign_key_violation
23505 unique_violation
23514 check_violation
23P01 exclusion_violation
Класс 24 — Неверное состояние курсора
24000
invalid_cursor_state
Класс 25 — Неверное состояние транзакции
25000 invalid_transaction_state
25001 active_sql_transaction
25002 branch_transaction_already_active
25008 held_cursor_requires_same_isolation_
level
25003 inappropriate_access_mode_for_branch_
transaction
25004 inappropriate_isolation_level_for_
branch_transaction
25005 no_active_sql_transaction_for_branch_
transaction
25006 read_only_sql_transaction
25007 schema_and_data_statement_mixing_not_
supported
25P01 no_active_sql_transaction
25P02 in_failed_sql_transaction
25P03 idle_in_transaction_session_timeout
Класс 26 — Неверное имя SQL-оператора
26000
invalid_sql_statement_name
Класс 27 — Нарушение при изменении данных в триггере
27000
triggered_data_change_violation
Класс 28 — Неверное указание авторизации
28000
invalid_authorization_specification
2201Коды ошибок PostgreSQL
Код ошибки Имя условия
28P01 invalid_password
Класс 2B — Зависимые описания привилегий всё ещё существуют
2B000 dependent_privilege_descriptors_still_
exist
2BP01 dependent_objects_still_exist
Класс 2D — Неверное завершение транзакции
2D000
invalid_transaction_termination
Класс 2F — Исключение в подпрограмме SQL
2F000 sql_routine_exception
2F005 function_executed_no_return_statement
2F002 modifying_sql_data_not_permitted
2F003 prohibited_sql_statement_attempted
2F004 reading_sql_data_not_permitted
Класс 34 — Неверное имя курсора
34000
invalid_cursor_name
Класс 38 — Исключение во внешней подпрограмме
38000 external_routine_exception
38001 containing_sql_not_permitted
38002 modifying_sql_data_not_permitted
38003 prohibited_sql_statement_attempted
38004 reading_sql_data_not_permitted
Класс 39 — Исключение при вызове внешней подпрограммы
39000 external_routine_invocation_exception
39001 invalid_sqlstate_returned
39004 null_value_not_allowed
39P01 trigger_protocol_violated
39P02 srf_protocol_violated
39P03 event_trigger_protocol_violated
Класс 3B — Исключение точки сохранения
3B000 savepoint_exception
3B001 invalid_savepoint_specification
Класс 3D — Неверное имя каталога
3D000
invalid_catalog_name
Класс 3F — Неверное имя схемы
3F000
invalid_schema_name
Класс 40 — Откат транзакции
40000 transaction_rollback
40002 transaction_integrity_constraint_
violation
40001 serialization_failure
40003 statement_completion_unknown
2202Коды ошибок PostgreSQL
Код ошибки Имя условия
40P01 deadlock_detected
Класс 42 — Ошибка синтаксиса или нарушение правила доступа
42000 syntax_error_or_access_rule_violation
42601 syntax_error
42501 insufficient_privilege
42846 cannot_coerce
42803 grouping_error
42P20 windowing_error
42P19 invalid_recursion
42830 invalid_foreign_key
42602 invalid_name
42622 name_too_long
42939 reserved_name
42804 datatype_mismatch
42P18 indeterminate_datatype
42P21 collation_mismatch
42P22 indeterminate_collation
42809 wrong_object_type
428C9 generated_always
42703 undefined_column
42883 undefined_function
42P01 undefined_table
42P02 undefined_parameter
42704 undefined_object
42701 duplicate_column
42P03 duplicate_cursor
42P04 duplicate_database
42723 duplicate_function
42P05 duplicate_prepared_statement
42P06 duplicate_schema
42P07 duplicate_table
42712 duplicate_alias
42710 duplicate_object
42702 ambiguous_column
42725 ambiguous_function
42P08 ambiguous_parameter
42P09 ambiguous_alias
42P10 invalid_column_reference
42611 invalid_column_definition
42P11 invalid_cursor_definition
2203Коды ошибок PostgreSQL
Код ошибки Имя условия
42P12 invalid_database_definition
42P13 invalid_function_definition
42P14 invalid_prepared_statement_definition
42P15 invalid_schema_definition
42P16 invalid_table_definition
42P17 invalid_object_definition
Класс 44 — Нарушение WITH CHECK OPTION
44000
with_check_option_violation
Класс 53 — Нехватка ресурсов
53000 insufficient_resources
53100 disk_full
53200 out_of_memory
53300 too_many_connections
53400 configuration_limit_exceeded
Класс 54 — Превышение ограничения программы
54000 program_limit_exceeded
54001 statement_too_complex
54011 too_many_columns
54023 too_many_arguments
Класс 55 — Объект не в требуемом состоянии
55000 object_not_in_prerequisite_state
55006 object_in_use
55P02 cant_change_runtime_param
55P03 lock_not_available
Класс 57 — Вмешательство оператора
57000 operator_intervention
57014 query_canceled
57P01 admin_shutdown
57P02 crash_shutdown
57P03 cannot_connect_now
57P04 database_dropped
Класс 58 — Ошибка системы (ошибка, внешняя по отношению к PostgreSQL)
58000 system_error
58030 io_error
58P01 undefined_file
58P02 duplicate_file
Класс 72 — Ошибка снимка
72000
snapshot_too_old
Класс F0 — Ошибка файла конфигурации
F0000
config_file_error
2204Коды ошибок PostgreSQL
Код ошибки Имя условия
F0001 lock_file_exists
Класс HV — Ошибка обёртки сторонних данных (SQL/MED)
HV000 fdw_error
HV005 fdw_column_name_not_found
HV002 fdw_dynamic_parameter_value_needed
HV010 fdw_function_sequence_error
HV021 fdw_inconsistent_descriptor_information
HV024 fdw_invalid_attribute_value
HV007 fdw_invalid_column_name
HV008 fdw_invalid_column_number
HV004 fdw_invalid_data_type
HV006 fdw_invalid_data_type_descriptors
HV091 fdw_invalid_descriptor_field_
identifier
HV00B fdw_invalid_handle
HV00C fdw_invalid_option_index
HV00D fdw_invalid_option_name
HV090 fdw_invalid_string_length_or_buffer_
length
HV00A fdw_invalid_string_format
HV009 fdw_invalid_use_of_null_pointer
HV014 fdw_too_many_handles
HV001 fdw_out_of_memory
HV00P fdw_no_schemas
HV00J fdw_option_name_not_found
HV00K fdw_reply_handle
HV00Q fdw_schema_not_found
HV00R fdw_table_not_found
HV00L fdw_unable_to_create_execution
HV00M fdw_unable_to_create_reply
HV00N fdw_unable_to_establish_connection
Класс P0 — Ошибка PL/pgSQL
P0000 plpgsql_error
P0001 raise_exception
P0002 no_data_found
P0003 too_many_rows
P0004 assert_failure
Класс XX — Внутренняя ошибка
XX000 internal_error
XX001 data_corrupted
2205Коды ошибок PostgreSQL
Код ошибки Имя условия
XX002 index_corrupted
2206</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-070/" title="Глава 70. Как планировщик использует статистику"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 70. Как планировщик использует статистику"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-070/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-070/" rel="bookmark" title="Глава 70. Как планировщик использует статистику" itemprop="url">Глава 70. Как планировщик использует статистику</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 70. Как планировщик использует статистику</p>

<p>Данная глава основана на материалах, рассмотренных ранее (см. Раздел 14.1 и Раздел 14.2), и по-
дробнее рассказывает о том, как планировщик использует статистику для определения количества
строк, которое может вернуть каждая часть запроса. Это важная составляющая процесса создания
плана запроса, предоставляющая большую часть исходного материала для расчёта стоимости.
Целью данной главы является не подробное документирование кода, а общее описание его работы.
Возможно, это поможет тем, кто пожелает в дальнейшем ознакомиться с кодом.
70.1. Примеры оценки количества строк
В приведённых ниже примерах используются таблицы базы данных регрессионного тестирования
PostgreSQL. Приведённые листинги получены в версии 8.3. Поведение более ранних (или поздних)
версий может отличаться. Заметьте также, что поскольку команда ANALYZE использует случайную
выборку при формировании статистики, после любого нового выполнения команды ANALYZE ре-
зультаты незначительно изменятся.
Давайте начнём с очень простого запроса:
EXPLAIN SELECT * FROM tenk1;
QUERY PLAN
————————————————————-
Seq Scan on tenk1 (cost=0.00..458.00 rows=10000 width=244)
Как планировщик определяет мощность tenk1, рассматривается выше (см. Раздел  14.2), но для
полноты здесь говорится об этом ещё раз. Количество страниц и строк берётся в pg_class:
SELECT relpages, reltuples FROM pg_class WHERE relname = ‘tenk1’;
relpages | reltuples
———-+———–
358 |
10000
Это текущие цифры, полученные при последнем выполнении команд VACUUM или ANALYZE, при-
менённых к этой таблице. Затем планировщик выполняет выборку фактического текущего числа
страниц в таблице (это недорогая операция, для которой не требуется сканирование таблицы). Ес-
ли оно отличается от relpages, то reltuples изменяется для того, чтобы привести это значение
к текущей оценке количества строк. В показанном выше примере значение relpages является ак-
туальным, поэтому количество строк берётся равным reltuples.
Давайте обратимся к примеру с диапазонным условием в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;
QUERY PLAN
——————————————————————————–
Bitmap Heap Scan on tenk1 (cost=24.06..394.64 rows=1007 width=244)
Recheck Cond: (unique1 &lt; 1000)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..23.80 rows=1007 width=0)
Index Cond: (unique1 &lt; 1000)
Планировщик рассматривает условие предложения WHERE и находит в справочнике функцию из-
бирательности для оператора &lt; в pg_operator. Это значение содержится в столбце oprrest, и в
данном случае значением является scalarltsel. Функция scalarltsel извлекает гистограмму для
unique1 из pg_statistic. Для вводимых вручную запросов удобнее просматривать более простое
представление pg_stats:
2189Как планировщик ис-
пользует статистику
SELECT histogram_bounds FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’unique1’;
histogram_bounds
——————————————————
{0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}
Затем обрабатывается часть гистограммы, которая соответствует условию «&lt; 1000». Таким обра-
зом и определяется избирательность. Гистограмма делит диапазон на равные частотные группы,
поэтому нужно лишь определить группу, содержащую наше значение, и подсчитать её долю и
долю групп, предшествующих данной. Очевидно, что значение 1000 находится во второй группе
(993-1997). Если предположить, что внутри каждой группы распределение значений линейное, мы
можем вычислить избирательность следующим образом:
selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets
= (1 + (1000 - 993)/(1997 - 993))/10
= 0.100697
т. е. сумма элементов одной целой группы и пропорциональной части элементов второй, делённая
на число групп. Теперь примерное число строк может быть рассчитано как произведение избира-
тельности и мощности tenk1:
rows = rel_cardinality * selectivity
= 10000 * 0.100697
= 1007 (округлённо)
Далее, давайте рассмотрим пример с условием на равенство в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = ‘CRAAAA’;
QUERY PLAN
———————————————————-
Seq Scan on tenk1 (cost=0.00..483.00 rows=30 width=244)
Filter: (stringu1 = ‘CRAAAA’::name)
Планировщик вновь проверяет условие в предложении WHERE и определяет функцию избиратель-
ности для =, и этой функцией является eqsel. Для оценки равенства гистограмма бесполезна, вме-
сто неё для оценки избирательности используется список наиболее распространённых значений
(Most Commom Values, MCV). Давайте рассмотрим MCV и соответствующие дополнительные столб-
цы, которые пригодятся позже:
SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’stringu1’;
null_frac
| 0
n_distinct
| 676
most_common_vals |
{EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}
most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}
Так как значение CRAAAA оказалось в списке MCV, избирательность будет определяться просто
соответствующим элементом в списке частот наиболее распространённых значений (Most Common
Frequencies, MCF):
selectivity = mcf[3]
= 0.003
Как и в предыдущем примере, оценка числа строк берётся как произведение мощности и избира-
тельности tenk1:
rows = 10000 * 0.003
= 30
Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке MCV:
2190Как планировщик ис-
пользует статистику
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = ‘xxx’;
QUERY PLAN
———————————————————-
Seq Scan on tenk1 (cost=0.00..483.00 rows=15 width=244)
Filter: (stringu1 = ‘xxx’::name)
Это совершенно другая задача — как оценить избирательность значения, которого нет в списке
MCV. При её решении используется факт отсутствия данного значения в списке в сочетании с
частотой для каждого значения из списка MCV.
selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)
= (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +
0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)
= 0.0014559
Т. е. нужно сложить частоты значений из списка MCV, отнять полученное число от единицы, и
полученное значение разделить на количество остальных уникальных значений. Эти вычисления
основаны на предположении, что значения, которые не входят в список MCV, имеют равномерное
распределение. Заметьте, что в данном примере нет неопределённых значений, поэтому о них
беспокоиться не нужно (иначе их долю также пришлось бы вычитать из числителя). Оценка числа
строк затем производится как обычно:
rows = 10000 * 0.0014559
= 15 (округлённо)
Предыдущий пример с unique1 &lt; 1000 был большим упрощением того, что в действительности
делает scalarltsel. Но после того, как мы увидели пример использования списка MCV, мы можем
внести некоторые дополнения. Что касается самого примера, в нём все было правильно, поскольку
unique1 это уникальный столбец, у него нет значений в списке MCV (очевидно, в данном случае
нет значения, которое является более распространённым, чем любое другое). Для неуникального
столбца обычно создаётся как гистограмма, так и список MCV, при этом гистограмма не включает
значения, представленные в списке MCV. Данный способ позволяет выполнить более точный под-
счёт. В этой ситуации scalarltsel напрямую применяет условие «&lt; 1000» к каждому значению
списка MCV и суммирует частоты значений MCV, для которых условие является верным. Это даёт
точную оценку избирательности для той части таблицы, которая содержит значения из списка
MCV. Подобным же образом используется гистограмма для оценки избирательности для той части
таблицы, которая не содержит значения из списка MCV, а затем эти две цифры складываются для
оценки общей избирательности. Например, рассмотрим
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; ‘IAAAAA’;
QUERY PLAN
————————————————————
Seq Scan on tenk1 (cost=0.00..483.00 rows=3077 width=244)
Filter: (stringu1 &lt; ‘IAAAAA’::name)
Мы уже видели данные списка MCV для stringu1, а это его гистограмма:
SELECT histogram_bounds FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’stringu1’;
histogram_bounds
——————————————————————————–
{AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}
Проверяя список MCV, находим, что условие stringu1 &lt; ‘IAAAAA’ соответствует первым шести
записям, но не соответствует последним четырём, поэтому избирательность для значений, соот-
ветствующих значениям в списке MCV, такова:
selectivity = sum(relevant mvfs)
= 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003
= 0.01833333
2191Как планировщик ис-
пользует статистику
Сумма всех частот из списка MCF также сообщает нам, что общая часть представленной списком
MCV совокупности записей равняется 0.03033333, и поэтому представленная гистограммой часть
равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе их пришлось бы
также исключить). Видно, что значение IAAAAA попадает почти в конец третьего столбца гисто-
граммы. Основываясь на простых предположениях относительно частоты различных символов,
планировщик получает число 0.298387 для части значений, представленных в гистограмме, кото-
рые меньше чем IAAAAA. Затем объединяем оценки части значений из списка MCV и значений, не
содержащихся в нём:
selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction
= 0.01833333 + 0.298387 * 0.96966667
= 0.307669
rows
= 10000 * 0.307669
= 3077 (округлённо)
В этом конкретном примере, корректировка со стороны списка MCV достаточно мала, потому что
распределение значений столбца довольно плоское (статистика, показывающая конкретные зна-
чения как более распространённые, чаще всего получается вследствие статистической погреш-
ности). В более типичном случае, когда некоторые значения являются значительно более распро-
странёнными по сравнению с другими, этот более сложный метод повышает точность вследствие
точного определения избирательности наиболее распространённых значений.
Теперь давайте рассмотрим случай с более чем одним условием в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = ‘xxx’;
QUERY PLAN
——————————————————————————–
Bitmap Heap Scan on tenk1 (cost=23.80..396.91 rows=1 width=244)
Recheck Cond: (unique1 &lt; 1000)
Filter: (stringu1 = ‘xxx’::name)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..23.80 rows=1007 width=0)
Index Cond: (unique1 &lt; 1000)
Планировщик исходит из того, что два условия независимы, таким образом, отдельные значения
избирательности можно перемножить:
selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = ‘xxx’)
= 0.100697 * 0.0014559
= 0.0001466
rows
= 10000 * 0.0001466
= 1 (округлённо)
Заметьте, что число строк, которые предполагается вернуть через сканирование битового индекса,
соответствует условию, используемому при работе индекса; это важно, так как влияет на оценку
стоимости для последующих выборок из таблицы.
В заключение исследуем запрос, выполняющий соединение:
EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;
QUERY PLAN
————————————————————————————–
Nested Loop (cost=4.64..456.23 rows=50 width=488)
-&gt; Bitmap Heap Scan on tenk1 t1 (cost=4.64..142.17 rows=50 width=244)
Recheck Cond: (unique1 &lt; 50)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..4.63 rows=50 width=0)
Index Cond: (unique1 &lt; 50)
-&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.00..6.27 rows=1 width=244)
2192Как планировщик ис-
пользует статистику
Index Cond: (unique2 = t1.unique2)
Ограничение, накладываемое на tenk1, unique1 &lt; 50, производится до соединения вложенным
циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным условием. На этот
раз значение 50 попадает в первый столбец гистограммы unique1:
selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets
= (0 + (50 - 0)/(993 - 0))/10
= 0.005035
rows
= 10000 * 0.005035
= 50 (округлённо)
Ограничение для соединения следующее t2.unique2 = t1.unique2. Здесь используется уже из-
вестный нам оператор =, однако функцию избирательности получаем из столбца oprjoin представ-
ления pg_operator, и эта функция — eqjoinsel. Функция eqjoinsel находит статистические дан-
ные как для tenk2, так и для tenk1:
SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats
WHERE tablename IN (‘tenk1’, ‘tenk2’) AND attname=’unique2’;
tablename | null_frac | n_distinct | most_common_vals
———–+———–+————+——————
tenk1
|
0 |
-1 |
tenk2
|
0 |
-1 |
В этом случае нет данных MCV для unique2, потому что все значения будут уникальными. Таким
образом, используется алгоритм, зависящий только от числа различающихся значений для обеих
таблиц и от данных с неопределёнными значениями:
selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/
num_distinct2)
= (1 - 0) * (1 - 0) / max(10000, 10000)
= 0.0001
Т. е., вычитаем долю неопределённых значений из единицы для каждой таблицы и делим на мак-
симальное из чисел различающихся значений. Количество строк, которое соединение, вероятно,
сгенерирует, вычисляется как мощность декартова произведения двух входных значений, умно-
женная на избирательность:
rows = (outer_cardinality * inner_cardinality) * selectivity
= (50 * 10000) * 0.0001
= 50
Если бы имелись списки MCV для двух столбцов, функцией eqjoinsel использовалось бы прямое
сравнение со списками MCV для определения общей избирательности той части данных, которая
содержит значения списка MCV. Оценка остальной части данных при этом выполнялась бы пред-
ставленным выше способом.
Заметьте, что здесь выводится для inner_cardinality значение 10000, то есть исходный размер
tenk2. Если изучить вывод EXPLAIN, может показаться, что оценка количества строк вычисляется
как 50 * 1, то есть число внешних строк умножается на ориентировочное число строк, получаемых
при каждом внутреннем сканировании индекса в tenk2. Но это не так, ведь размер результата
соединения оценивается до того, как выбирается конкретный план соединения. Если всё работает
корректно, оба варианта вычисления этого размера должны давать один и тот же ответ, но из-за
ошибок округления и других факторов иногда они значительно различаются.
Для интересующихся более подробной информацией: оценка размера таблицы (до выполнения
условий в предложении WHERE) реализована в файле src/backend/optimizer/util/plancat.c.
Основная логика для вычисления избирательности предложений находится в src/backend/
optimizer/path/clausesel.c. Специфичные для отдельных операторов функции избирательности,
в основном, расположены в src/backend/utils/adt/selfuncs.c.
2193Как планировщик ис-
пользует статистику
70.2. Примеры многовариантной статистики
70.2.1. Функциональные зависимости
Многовариантную корреляцию можно продемонстрировать на очень простом наборе данных —
таблице с двумя столбцами, содержащими одинаковые значения:
CREATE TABLE t (a INT, b INT);
INSERT INTO t SELECT i % 100, i % 100 FROM generate_series(1, 10000) s(i);
ANALYZE t;
Как рассказывается в Разделе 14.2, планировщик может определить мощность t, исходя из числа
страниц и строк, полученного из pg_class:
SELECT relpages, reltuples FROM pg_class WHERE relname = ‘t’;
relpages | reltuples
———-+———–
45 |
10000
Распределение данных очень простое: в каждом столбце содержится всего 100 различных значе-
ний, равномерно распределённых.
Следующий пример показывает результат оценивания условия WHERE по столбцу a:
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1;
QUERY PLAN
——————————————————————————-
Seq Scan on t (cost=0.00..170.00 rows=100 width=8) (actual rows=100 loops=1)
Filter: (a = 1)
Rows Removed by Filter: 9900
Планировщик рассматривает условие и определяет, что его избирательность равна 1%. Сравнивая
эту оценку и фактическое число строк, мы видим, что оценка очень точна (на самом деле абсолют-
на точна, так как таблица очень маленькая). Если изменить условие WHERE, чтобы использовался
столбец b, будет получен такой же план. Но посмотрите, что получится, если мы применим оди-
наковое условие к двум столбцам, объединив их оператором AND:
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;
QUERY PLAN
—————————————————————————–
Seq Scan on t (cost=0.00..195.00 rows=1 width=8) (actual rows=100 loops=1)
Filter: ((a = 1) AND (b = 1))
Rows Removed by Filter: 9900
Планировщик оценивает избирательность каждого условия индивидуально, и получает ту же оцен-
ку в 1%, что и выше. Затем он предполагает, что условия независимы, так что он перемножает
избирательности и выдаёт окончательную оценку избирательности, равную всего 0.01%. Это зна-
чительная недооценка, так как фактическое число строк, соответствующих условию, (100) на два
порядка больше.
Эту проблему можно решить, создав объект статистики, который укажет команде ANALYZE вычис-
лить многовариантную статистику функциональной зависимости по двум столбцам:
CREATE STATISTICS stts (dependencies) ON a, b FROM t;
ANALYZE t;
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;
QUERY PLAN
——————————————————————————-
Seq Scan on t (cost=0.00..195.00 rows=100 width=8) (actual rows=100 loops=1)
Filter: ((a = 1) AND (b = 1))
Rows Removed by Filter: 9900
2194Как планировщик ис-
пользует статистику
70.2.2. Многовариантное число различных значений
Подобная проблема возникает с оценкой мощности наборов с несколькими столбцами, например,
с оценкой числа групп, которые могут быть выданы предложением GROUP BY. Когда в GROUP BY
указан один столбец, оценка числа различных значений (которую можно увидеть как ожидаемое
число строк, выдаваемое узлом HashAggregate) очень точная:
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(<em>) FROM t GROUP BY a;
QUERY PLAN
—————————————————————————————–
HashAggregate (cost=195.00..196.00 rows=100 width=12) (actual rows=100 loops=1)
Group Key: a
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=4) (actual rows=10000
loops=1)
Но оценка числа групп в запросе с двумя столбцами в GROUP BY без многовариантной статистики,
как и в предыдущем примере, отличается от правильной на порядок:
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(</em>) FROM t GROUP BY a, b;
QUERY PLAN
——————————————————————————————–
HashAggregate (cost=220.00..230.00 rows=1000 width=16) (actual rows=100 loops=1)
Group Key: a, b
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000
loops=1)
Если переопределить объект статистики, чтобы он включал подсчёт числа различных значений
для двух столбцов, оценка станет гораздо лучше:
DROP STATISTICS stts;
CREATE STATISTICS stts (dependencies, ndistinct) ON a, b FROM t;
ANALYZE t;
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;
QUERY PLAN
——————————————————————————————–
HashAggregate (cost=220.00..221.00 rows=100 width=16) (actual rows=100 loops=1)
Group Key: a, b
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000
loops=1)
70.3. Статистика планировщика и безопасность
Доступ к таблице pg_statistic разрешён только суперпользователям, так что обычные пользо-
ватели не могут получить из неё сведения о содержимом таблиц других пользователей. Но неко-
торые функции оценки избирательности будут использовать пользовательский оператор (опера-
тор, фигурирующий в запросе, или связанный) для анализа сохранённой статистики. Например,
чтобы определить применимость сохранённого самого частого значения, функция оценки избира-
тельности должна задействовать соответствующий оператор = для сравнения константы в запро-
се с этим сохранённым значением. Таким образом, данные pg_statistic в принципе могут пере-
даваться пользовательским операторам. А особым образом сконструированный оператор может
выводить наружу передаваемые ему операнды преднамеренно (например, записывая их в журнал
или помещая в другую таблицу) либо непреднамеренно (показывая их значения в сообщениях об
ошибках). В любом случае это даёт возможность пользователю, не имеющему доступа к таблице
pg_statistic, увидеть содержащиеся в ней данные.
Для предотвращения этого все встроенные функции оценки избирательности действуют по следу-
ющим правилам. Чтобы сохранённая статистика могла использоваться при планировании запроса,
текущий пользователь должен иметь либо право SELECT для таблицы или задействованных столб-
2195Как планировщик ис-
пользует статистику
цов, либо у оператора должна быть характеристика LEAKPROOF (точнее, она должна быть у функции,
реализующей этот оператор). В противном случае оценка избирательности будет осуществляться
так, как если бы статистики не было вовсе, и планировщик продолжит работу с общими или вто-
ричными предположениями.
Если пользователь не имеет требуемого права доступа к таблице или столбцам, то во многих слу-
чаях при выполнении запроса в конце концов возникнет ошибка «нет доступа», так что этот меха-
низм будет незаметен на практике. Но если пользователь читает данные из представления с ба-
рьером безопасности, планировщик может захотеть проверить статистику нижележащей таблицы,
которая недоступна пользователю непосредственно. В этом случае оператор должен быть герме-
тичным; иначе статистика не будет использоваться. Это не будет иметь внешних проявлений кро-
ме того, что план запроса может быть неоптимальным. В случае подозрений, что вы столкнулись с
этим, попробуйте запустить запрос от имени пользователя с расширенными правами и проверьте,
не выбирается ли другой план запроса.
Это ограничение применяется только тогда, когда планировщику может потребоваться выполнить
пользовательский оператор с одним или несколькими значениями из pg_statistic. При этом пла-
нировщику разрешено использовать общую статистическую информацию, например, процент зна-
чений NULL или количество различных значений в столбце, вне зависимости от прав доступа.
Реализуемые в дополнительных расширениях функции оценки избирательности, которые могут
обращаться к статистике, вызывая пользовательские операторы, должны следовать тем же прави-
лам безопасности. За практическими указаниями обратитесь к исходному коду PostgreSQL.
2196</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page2/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page2/">2</a></li>
      
    
      
        <li><strong class="current-page">3</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page4/">4</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page5/">5</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page4/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>