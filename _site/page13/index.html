<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page13/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page13/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-043/" title="Глава 43. PL/pgSQL — процедурный язык SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 43. PL/pgSQL — процедурный язык SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-043/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~84 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-043/" rel="bookmark" title="Глава 43. PL/pgSQL — процедурный язык SQL" itemprop="url">Глава 43. PL/pgSQL — процедурный язык SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 43. PL/pgSQL — процедурный язык SQL</p>

<p>43.1. Обзор
PL/pgSQL это процедурный язык для СУБД PostgreSQL. Целью проектирования PL/pgSQL было
создание загружаемого процедурного языка, который:
• используется для создания функций и триггеров,
• добавляет управляющие структуры к языку SQL,
• может выполнять сложные вычисления,
• наследует все пользовательские типы, функции и операторы,
• может быть определён как доверенный язык,
• прост в использовании.
Функции PL/pgSQL могут использоваться везде, где допустимы встроенные функции. Например,
можно создать функции со сложными вычислениями и условной логикой, а затем использовать их
при определении операторов или в индексных выражениях.
В версии PostgreSQL 9.0 и выше, PL/pgSQL устанавливается по умолчанию. Тем не менее, это по-
прежнему загружаемый модуль и администраторы, особо заботящиеся о безопасности, могут уда-
лить его при необходимости.
43.1.1. Преимущества использования PL/pgSQL
PostgreSQL и большинство других СУБД используют SQL в качестве языка запросов. SQL хорошо
переносим и прост в изучении. Однако каждый оператор SQL выполняется индивидуально на сер-
вере базы данных.
Это значит, что ваше клиентское приложение должно каждый запрос отправлять на сервер, ждать
пока он будет обработан, получать результат, делать некоторые вычисления, затем отправлять
последующие запросы на сервер. Всё это требует межпроцессного взаимодействия, а также несёт
нагрузку на сеть, если клиент и сервер базы данных расположены на разных компьютерах.
PL/pgSQL позволяет сгруппировать блок вычислений и последовательность запросов внутри сер-
вера базы данных, таким образом, мы получаем силу процедурного языка и простоту использова-
ния SQL при значительной экономии накладных расходов на клиент-серверное взаимодействие.
• Исключаются дополнительные обращения между клиентом и сервером
• Промежуточные ненужные результаты не передаются между сервером и клиентом
• Есть возможность избежать многочисленных разборов одного запроса
В результате это приводит к значительному увеличению производительности по сравнению с при-
ложением, которое не использует хранимых функций.
Кроме того, PL/pgSQL позволяет использовать все типы данных, операторы и функции SQL.
43.1.2. Поддерживаемые типы данных аргументов и возвращае-
мых значений
Функции на PL/pgSQL могут принимать в качестве аргументов все поддерживаемые сервером ска-
лярные типы данных или массивы и возвращать в качестве результата любой из этих типов. Они
могут принимать и возвращать именованные составные типы (типы строк таблицы). Также есть
возможность объявить функцию на PL/pgSQL как принимающую record, то есть ей может быть
передан любой составной тип, или как возвращающую record, то есть её результатом будет стро-
ковый тип, столбцы которого определит спецификация вызывающего запроса, как описано в Под-
разделе 7.2.1.4.
1124PL/pgSQL — проце-
дурный язык SQL
Использование маркера VARIADIC позволяет объявлять функции на PL/pgSQL с переменным чис-
лом аргументов. Это работает точно так же, как и для функций на SQL, как описано в Подразде-
ле 38.5.5.
Функции на PL/pgSQL могут принимать и возвращать полиморфные типы anyelement, anyarray,
anynonarray, anyenum и anyrange. В таких случаях фактические типы данных могут меняться от
вызова к вызову, как описано в Подраздел 38.2.5. Пример показан в Подразделе 43.3.1.
Функции на PL/pgSQL могут возвращать «множества» (или таблицы) любого типа, которые могут
быть возвращены в виде одного объекта. Такие функции генерируют вывод, выполняя команду
RETURN NEXT для каждого элемента результирующего набора или RETURN QUERY для вывода резуль-
тата запроса.
Наконец, при отсутствии полезного возвращаемого значения функция на PL/pgSQL может возвра-
щать void. (С другой стороны, её также можно оформить в виде процедуры.)
Функции на PL/pgSQL можно объявить с выходными параметрами вместо явного задания типа воз-
вращаемого значения. Это не добавляет никаких фундаментальных возможностей языку, но часто
бывает удобно, особенно для возвращения нескольких значений. Нотация RETURNS TABLE может
использоваться вместо RETURNS SETOF.
Конкретные примеры рассматриваются в Подразделе 43.3.1 и Подразделе 43.6.1.
43.2. Структура PL/pgSQL
Функции, написанные на PL/pgSQL, определяются на сервере командами CREATE FUNCTION. Та-
кая команда обычно выглядит, например, так:
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS ‘тело функции’
LANGUAGE plpgsql;
Если рассматривать CREATE FUNCTION, тело функции представляет собой просто текстовую стро-
ку. Часто для написания тела функции удобнее заключать эту строку в доллары (см. Подраз-
дел 4.1.2.4), а не в обычные апострофы. Если не применять заключение в доллары, все апострофы
или обратные косые черты в теле функции придётся экранировать, дублируя их. Почти во всех
примерах в этой главе тело функций заключается в доллары.
PL/pgSQL это блочно-структурированный язык. Текст тела функции должен быть блоком. Струк-
тура блока:
[ «метка» ]
[ DECLARE
объявления ]
BEGIN
операторы
END [ метка ];
Каждое объявление и каждый оператор в блоке должны завершаться символом “;”(точка с запя-
той). Блок, вложенный в другой блок, должен иметь точку с запятой после END, как показано выше.
Однако финальный END, завершающий тело функции, не требует точки с запятой.
Подсказка
Распространённой ошибкой является добавление точки с запятой сразу после BEGIN.
Это неправильно и приведёт к синтаксической ошибке.
Метка требуется только тогда, когда нужно идентифицировать блок в операторе EXIT, или допол-
нить имена переменных, объявленных в этом блоке. Если метка указана после END, то она должна
совпадать с меткой в начале блока.
1125PL/pgSQL — проце-
дурный язык SQL
Ключевые слова не чувствительны к регистру символов. Как и в обычных SQL-командах, иденти-
фикаторы неявно преобразуются к нижнему регистру, если они не взяты в двойные кавычки.
Комментарии в PL/pgSQL коде работают так же, как и в обычном SQL. Двойное тире (–) начина-
ет комментарий, который завершается в конце строки. Блочный комментарий начинается с /* и
завершается <em>/. Блочные комментарии могут быть вложенными.
Любой оператор в выполняемой секции блока может быть вложенным блоком. Вложенные блоки
используются для логической группировки нескольких операторов или локализации области дей-
ствия переменных для группы операторов. Во время выполнения вложенного блока переменные,
объявленные в нём, скрывают переменные внешних блоков с такими же именами. Чтобы получить
доступ к внешним переменным, нужно дополнить их имена меткой блока. Например:
CREATE FUNCTION somefunc() RETURNS integer AS <script type="math/tex">% <![CDATA[
<< outerblock >>
DECLARE
quantity integer := 30;
BEGIN
RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 30
quantity := 50;
--
-- Вложенный блок
--
DECLARE
quantity integer := 80;
BEGIN
RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 80
RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;
Выводится 50
END;
RAISE NOTICE 'Сейчас quantity = %', quantity;
--
-- Выводится 50
RETURN quantity;
END; %]]></script> LANGUAGE plpgsql;
Примечание
Существует скрытый «внешний блок», окружающий тело каждой функции на PL/
pgSQL. Этот блок содержит объявления параметров функции (если они есть), а также
некоторые специальные переменные, такие как FOUND (см. Подраздел 43.5.5). Этот блок
имеет метку, совпадающую с именем функции, таким образом, параметры и специаль-
ные переменные могут быть дополнены именем функции.
Важно не путать использование BEGIN/END для группировки операторов в PL/pgSQL с одноимённы-
ми SQL-командами для управления транзакциями. BEGIN/END в PL/pgSQL служат только для груп-
пировки предложений; они не начинают и не заканчивают транзакции. Управление транзакция-
ми в PL/pgSQL описывается в Разделе 43.8. Кроме того, блок с предложением EXCEPTION по сути
создаёт вложенную транзакцию, которую можно отменить, не затрагивая внешнюю транзакцию.
Подробнее это описано в Подразделе 43.6.8.
43.3. Объявления
Все переменные, используемые в блоке, должны быть определены в секции объявления. (За ис-
ключением переменной-счётчика цикла FOR, которая объявляется автоматически. Для цикла по
диапазону чисел автоматически объявляется целочисленная переменная, а для цикла по резуль-
татам курсора - переменная типа record.)
1126PL/pgSQL — проце-
дурный язык SQL
Переменные PL/pgSQL могут иметь любой тип данных SQL, такой как integer, varchar, char.
Примеры объявления переменных:
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
Общий синтаксис объявления переменной:
имя [ CONSTANT ] тип [ COLLATE имя_правила_сортировки ] [ NOT NULL ] [ { DEFAULT | := |
= } выражение ];
Предложение DEFAULT, если присутствует, задаёт начальное значение, которое присваивается пе-
ременной при входе в блок. Если отсутствует, то переменная инициализируется SQL-значением
NULL. Указание CONSTANT предотвращает изменение значения переменной после инициализации,
таким образом, значение остаётся постоянным в течение всего блока. Параметр COLLATE определя-
ет правило сортировки, которое будет использоваться для этой переменной (см. Подраздел 43.3.6).
Если указано NOT NULL, то попытка присвоить NULL во время выполнения приведёт к ошибке. Все
переменные, объявленные как NOT NULL, должны иметь непустые значения по умолчанию. Можно
использовать знак равенства (=) вместо совместимого с PL/SQL :=.
Значение по умолчанию вычисляется и присваивается переменной каждый раз при входе в блок
(не только при первом вызове функции). Так, например, если переменная типа timestamp имеет
функцию now() в качестве значения по умолчанию, это приведёт к тому, что переменная всегда
будет содержать время текущего вызова функции, а не время, когда функция была предварительно
скомпилирована.
Примеры:
quantity integer DEFAULT 32;
url varchar := ‘http://mysite.com’;
user_id CONSTANT integer := 10;
43.3.1. Объявление параметров функции
Переданные в функцию параметры именуются идентификаторами $1, $2 и т. д. Дополнительно, для
улучшения читаемости, можно объявить псевдонимы для параметров $n. Либо псевдоним, либо
цифровой идентификатор используются для обозначения параметра.
Создать псевдоним можно двумя способами. Предпочтительный способ это дать имя параметру в
команде CREATE FUNCTION, например:
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS <script type="math/tex">BEGIN
RETURN subtotal * 0.06;
END;</script> LANGUAGE plpgsql;
Другой способ это явное объявление псевдонима при помощи синтаксиса:
имя ALIAS FOR $n;
Предыдущий пример для этого стиля выглядит так:
CREATE FUNCTION sales_tax(real) RETURNS real AS <script type="math/tex">DECLARE
subtotal ALIAS FOR $1;
BEGIN
RETURN subtotal * 0.06;
END;
1127PL/pgSQL — проце-
дурный язык SQL</script> LANGUAGE plpgsql;
Примечание
Эти два примера не полностью эквивалентны. В первом случае, на subtotal можно
ссылаться как sales_tax.subtotal, а во втором случае такая ссылка невозможна. (Ес-
ли бы к внутреннему блоку была добавлена метка, то subtotal можно было бы допол-
нить этой меткой.)
Ещё несколько примеров:
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS <script type="math/tex">DECLARE
v_string ALIAS FOR $1;
index ALIAS FOR $2;
BEGIN
-- вычисления, использующие v_string и index
END;</script> LANGUAGE plpgsql;
CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS <script type="math/tex">BEGIN
RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;</script> LANGUAGE plpgsql;
Когда функция на PL/pgSQL объявляется с выходными параметрами, им выдаются цифровые иден-
тификаторы $n и для них можно создавать псевдонимы точно таким же способом, как и для обыч-
ных входных параметров. Выходной параметр это фактически переменная, стартующая с NULL
и которой присваивается значение во время выполнения функции. Возвращается последнее при-
своенное значение. Например, функция sales_tax может быть переписана так:
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS <script type="math/tex">BEGIN
tax := subtotal * 0.06;
END;</script> LANGUAGE plpgsql;
Обратите внимание, что мы опустили RETURNS real — хотя можно было и включить, но это было
бы излишним.
Выходные параметры наиболее полезны для возвращения нескольких значений. Простейший при-
мер:
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS <script type="math/tex">BEGIN
sum := x + y;
prod := x * y;
END;</script> LANGUAGE plpgsql;
Как обсуждалось в Подразделе 38.5.4, здесь фактически создаётся анонимный тип record для воз-
вращения результата функции. Если используется предложение RETURNS, то оно должна выглядеть
как RETURNS record.
Есть ещё способ объявить функцию на PL/pgSQL с использованием RETURNS TABLE, например:
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS <script type="math/tex">1128PL/pgSQL — проце-
дурный язык SQL
BEGIN
RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s
WHERE s.itemno = p_itemno;
END;</script> LANGUAGE plpgsql;
Это в точности соответствует объявлению одного или нескольких параметров OUT и указанию
RETURNS SETOF некий_тип.
Для функции на PL/pgSQL, возвращающей полиморфный тип (anyelement, anyarray, anynonarray,
anyenum, anyrange), создаётся специальный параметр $0. Его тип данных соответствует типу, фак-
тически возвращаемому функцией, и который устанавливается на основании фактических типов
входных параметров (см. Подраздел 38.2.5). Это позволяет функции получить доступ к фактически
возвращаемому типу данных, как показано в Подразделе 43.3.3. Параметр $0 инициализируется в
NULL и его можно изменять внутри функции. Таким образом, его можно использовать для хранения
возвращаемого значения, хотя это необязательно. Параметру $0 можно дать псевдоним. В следу-
ющем примере функция работает с любым типом данных, поддерживающим оператор +:
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS <script type="math/tex">DECLARE
result ALIAS FOR $0;
BEGIN
result := v1 + v2 + v3;
RETURN result;
END;</script> LANGUAGE plpgsql;
Такой же эффект получается при объявлении одного или нескольких выходных параметров поли-
морфного типа. При этом $0 не создаётся; выходные параметры сами используются для этой цели.
Например:
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
OUT sum anyelement)
AS <script type="math/tex">BEGIN
sum := v1 + v2 + v3;
END;</script> LANGUAGE plpgsql;
43.3.2. ALIAS
новое_имя ALIAS FOR старое_имя;
Синтаксис ALIAS более общий, чем предполагалось в предыдущем разделе: псевдонимы можно
объявлять для любых переменных, а не только для параметров функции. Основная практическая
польза в том, чтобы назначить другие имена переменным с предопределёнными названиями, та-
ким как NEW или OLD в триггерной функции.
Примеры:
DECLARE
prior ALIAS FOR old;
updated ALIAS FOR new;
Поскольку ALIAS даёт два различных способа именования одних и тех же объектов, то его неогра-
ниченное использование может привести к путанице. Лучше всего использовать ALIAS для пере-
именования предопределённых имён.
43.3.3. Наследование типов данных
переменная%TYPE
1129PL/pgSQL — проце-
дурный язык SQL
Конструкция %TYPE предоставляет тип данных переменной или столбца таблицы. Её можно исполь-
зовать для объявления переменных, содержащих значения из базы данных. Например, для объяв-
ления переменной с таким же типом, как и столбец user_id в таблице users нужно написать:
user_id users.user_id%TYPE;
Используя %TYPE, не нужно знать тип данных структуры, на которую вы ссылаетесь. И самое глав-
ное, если в будущем тип данных изменится (например: тип данных для user_id поменяется с
integer на real), то вам может не понадобиться изменять определение функции.
Использование %TYPE особенно полезно в полиморфных функциях, поскольку типы данных, необ-
ходимые для внутренних переменных, могут меняться от одного вызова к другому. Соответствую-
щие переменные могут быть созданы с применением %TYPE к аргументам и возвращаемому значе-
нию функции.
43.3.4. Типы кортежей
имя имя_таблицы%ROWTYPE;
имя имя_составного_типа;
Переменная составного типа называется строковой переменной (или переменной типа строки).
Значением такой переменной может быть целая строка, полученная в результате выполнения за-
проса SELECT или FOR, при условии, что набор столбцов запроса соответствует заявленному типу
переменной. Доступ к отдельным значениям полей строковой переменной осуществляется, как
обычно, через точку, например rowvar.field.
Строковая переменная может быть объявлена с таким же типом, как и строка в существующей
таблице или представлении, используя нотацию имя_таблицы%ROWTYPE; или с именем составного
типа. (Поскольку каждая таблица имеет соответствующий составной тип с таким же именем, то
на самом деле в PostgreSQL не имеет значения, пишете ли вы %ROWTYPE или нет. Но использование
%ROWTYPE более переносимо.)
Параметры функции могут быть составного типа (строки таблицы). В этом случае соответствую-
щий идентификатор $n будет строковой переменной, поля которой можно выбирать, например
$1.user_id.
Ниже приведён пример использования составных типов. table1 и table2 это существующие таб-
лицы, имеющие, по меньшей мере, перечисленные столбцы:
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS <script type="math/tex">DECLARE
t2_row table2%ROWTYPE;
BEGIN
SELECT * INTO t2_row FROM table2 WHERE ... ;
RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;</script> LANGUAGE plpgsql;
SELECT merge_fields(t.</em>) FROM table1 t WHERE … ;
43.3.5. Тип record
имя RECORD;
Переменные типа record похожи на переменные строкового типа, но они не имеют предопреде-
лённой структуры. Они приобретают фактическую структуру от строки, которая им присваивается
командами SELECT или FOR. Структура переменной типа record может меняться каждый раз при
присвоении значения. Следствием этого является то, что пока значение не присвоено первый раз,
переменная типа record не имеет структуры и любая попытка получить доступ к отдельному полю
приведёт к ошибке во время исполнения.
1130PL/pgSQL — проце-
дурный язык SQL
Обратите внимание, что RECORD это не подлинный тип данных, а только лишь заполнитель. Также
следует понимать, что функция на PL/pgSQL, имеющая тип возвращаемого значения record, это
не то же самое, что и переменная типа record, хотя такая функция может использовать перемен-
ную типа record для хранения своего результата. В обоих случаях фактическая структура стро-
ки неизвестна во время создания функции, но для функции, возвращающей record, фактическая
структура определяется во время разбора вызывающего запроса, в то время как переменная типа
record может менять свою структуру на лету.
43.3.6. Упорядочение переменных PL/pgSQL
Когда функция на PL/pgSQL имеет один или несколько параметров сортируемых типов данных,
правило сортировки определяется при каждом вызове функции в зависимости от правил сортиров-
ки фактических аргументов, как описано в Разделе 23.2. Если оно определено успешно (т. е. сре-
ди аргументов нет конфликтов между неявными правилами сортировки), то все соответствующие
параметры неявно трактуются как имеющее это правило сортировки. Внутри функции это будет
влиять на поведение операторов, зависящих от используемого правила сортировки. Рассмотрим
пример:
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS <script type="math/tex">% <![CDATA[
BEGIN
RETURN a < b;
END; %]]></script> LANGUAGE plpgsql;
SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE “C”) FROM table1;
В первом случае less_than будет использовать для сравнения общее правило сортировки для
text_field_1 и text_field_2, в то время как во втором случае будет использоваться правило C.
Кроме того, определённое для вызова функции правило сортировки также будет использоваться
для любых локальных переменных соответствующего типа. Таким образом, функция не станет ра-
ботать по-другому, если её переписать так:
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS <script type="math/tex">% <![CDATA[
DECLARE
local_a text := a;
local_b text := b;
BEGIN
RETURN local_a < local_b;
END; %]]></script> LANGUAGE plpgsql;
Если параметров с типами данных, поддерживающими сортировку, нет, или для параметров невоз-
можно определить общее правило сортировки, тогда для параметров и локальных переменных
применяются правила, принятые для их типа данных по умолчанию (которые обычно совпадают
с правилами сортировки по умолчанию, принятыми для базы данных, но могут отличаться для пе-
ременных доменных типов).
Локальная переменная может иметь правило сортировки, отличное от правила по умолчанию. Для
этого используется параметр COLLATE в объявлении переменной, например:
DECLARE
local_a text COLLATE “en_US”;
Этот параметр переопределяет правило сортировки, которое получила бы переменная в соответ-
ствии с вышеуказанными правилами.
И, конечно же, можно явно указывать параметр COLLATE для конкретных операций внутри функ-
ции, если к ним требуется применить конкретное правило сортировки. Например:
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS <script type="math/tex">% <![CDATA[
1131PL/pgSQL — проце-
дурный язык SQL
BEGIN
RETURN a < b COLLATE "C";
END; %]]></script> LANGUAGE plpgsql;
Как и в обычной SQL-команде, это переопределяет правила сортировки, связанные с полями таб-
лицы, параметрами и локальными переменными, которые используются в данном выражении.
43.4. Выражения
Все выражения, используемые в операторах PL/pgSQL, обрабатываются основным исполнителем
SQL-сервера. Например, для вычисления такого выражения:
IF выражение THEN …
PL/pgSQL отправит следующий запрос исполнителю SQL:
SELECT выражение
При формировании команды SELECT все вхождения имён переменных PL/pgSQL заменяются пара-
метрами, как подробно описано в Подразделе 43.11.1. Это позволяет один раз подготовить план
выполнения команды SELECT и повторно использовать его в последующих вычислениях с различ-
ными значениями переменных. Таким образом, при первом использовании выражения, по сути
происходит выполнение команды PREPARE. Например, если мы объявили две целочисленные пере-
менные x и y, и написали:
IF x &lt; y THEN …
то, что реально происходит за сценой, эквивалентно:
PREPARE имя_оператора(integer, integer) AS SELECT $1 &lt; $2;
и затем, эта подготовленная команда исполняется (EXECUTE) для каждого оператора IF с текущими
значениями переменных PL/pgSQL, переданных как значения параметров. Обычно эти детали не
важны для пользователей PL/pgSQL, но их полезно знать при диагностировании проблем. Более
подробно об этом рассказывается в Подразделе 43.11.2.
43.5. Основные операторы
В этом и последующих разделах описаны все типы операторов, которые понимает PL/pgSQL. Все,
что не признается в качестве одного из этих типов операторов, считается командой SQL и отправ-
ляется для исполнения в основную машину базы данных, как описано в Подразделе 43.5.2 и Под-
разделе 43.5.3.
43.5.1. Присваивания
Присвоение значения переменной PL/pgSQL записывается в виде:
переменная { := | = } выражение;
Как описывалось ранее, выражение в таком операторе вычисляется с помощью SQL-команды
SELECT, посылаемой в основную машину базы данных. Выражение должно получить одно значение
(возможно, значение строки, если переменная строкового типа или типа record). Целевая пере-
менная может быть простой переменной (возможно, дополненной именем блока), полем в пере-
менной строкового типа или записи; или элементом массива, который является простой перемен-
ной или полем. Для присвоения можно использовать знак равенства (=) вместо совместимого с PL/
SQL :=.
Если тип данных результата выражения не соответствует типу данных переменной, это значе-
ние будет преобразовано к нужному типу с использованием приведения присваивания (см. Раз-
дел 10.4). В случае отсутствия приведения присваивания для этой пары типов, интерпретатор PL/
pgSQL попытается преобразовать значение результата через текстовый формат, то есть применив
функцию вывода типа результата, а за ней функцию ввода типа переменной. Заметьте, что при
1132PL/pgSQL — проце-
дурный язык SQL
этом функция ввода может выдавать ошибки времени выполнения, если не воспримет строковое
представление значения результата.
Примеры:
tax := subtotal * 0.06;
my_record.user_id := 20;
43.5.2. Выполнение команды, не возвращающей результат
В функции на PL/pgSQL можно выполнить любую команду SQL, не возвращающую строк, просто
написав эту команду (например, INSERT без предложения RETURNING).
Имя любой переменной PL/pgSQL в тексте команды рассматривается как параметр, а затем теку-
щее значение переменной подставляется в качестве значения параметра во время выполнения.
Это в точности совпадает с описанной ранее обработкой для выражений; за подробностями обра-
титесь к Подразделу 43.11.1.
При выполнении SQL-команды таким образом, PL/pgSQL может кешировать и повторно использо-
вать план выполнения команды, как обсуждается в Подразделе 43.11.2.
Иногда бывает полезно вычислить значение выражения или запроса SELECT, но отказаться от ре-
зультата, например, при вызове функции, у которой есть побочные эффекты, но нет полезного ре-
зультата. Для этого в PL/pgSQL, используется оператор PERFORM:
PERFORM запрос;
Эта команда выполняет запрос и отбрасывает результат. Запросы пишутся таким же образом, как
и в команде SQL SELECT, но ключевое слово SELECT заменяется на PERFORM. Для запросов WITH по-
сле PERFORM нужно поместить запрос в скобки. (В этом случае запрос может вернуть только одну
строку.) Переменные PL/pgSQL будут подставлены в запрос так же, как и в команду, не возвра-
щающую результат, план запроса также кешируется. Кроме того, специальная переменная FOUND
устанавливается в истину, если запрос возвращает, по крайней мере, одну строку, или ложь, если
не возвращает ни одной строки (см. Подраздел 43.5.5).
Примечание
Можно предположить, что такой же результат получается непосредственно командой
SELECT, но в настоящее время использование PERFORM является единственным спосо-
бом. Команда SQL, которая может возвращать строки, например SELECT, будет откло-
нена с ошибкой, если не имеет предложения INTO, как описано в следующем разделе.
Пример:
PERFORM create_mv(‘cs_session_page_requests_mv’, my_query);
43.5.3. Выполнение запроса, возвращающего одну строку
Результат SQL-команды, возвращающей одну строку (возможно из нескольких столбцов), может
быть присвоен переменной типа record, переменной строкового типа или списку скалярных пере-
менных. Для этого нужно к основной команде SQL добавить предложение INTO. Так, например:
SELECT
INSERT
UPDATE
DELETE
выражения_select INTO [STRICT] цель FROM …;
… RETURNING выражения INTO [STRICT] цель;
… RETURNING выражения INTO [STRICT] цель;
… RETURNING выражения INTO [STRICT] цель;
где цель может быть переменной типа record, строковой переменной или разделённым запяты-
ми списком скалярных переменных, полей записи/строки. Переменные PL/pgSQL подставляются
1133PL/pgSQL — проце-
дурный язык SQL
в оставшуюся часть запроса, план выполнения кешируется, так же, как было описано выше для
команд, не возвращающих строки. Это работает для команд SELECT, INSERT/UPDATE/DELETE с пред-
ложением RETURNING и утилит, возвращающих результат в виде набора строк (таких, как EXPLAIN).
За исключением предложения INTO, это те же SQL-команды, как их можно написать вне PL/pgSQL.
Подсказка
Обратите внимание, что данная интерпретация SELECT с INTO полностью отличается от
PostgreSQL команды SELECT INTO, где в INTO указывается вновь создаваемая таблица.
Если вы хотите в функции на PL/pgSQL создать таблицу, основанную на результате
команды SELECT, используйте синтаксис CREATE TABLE … AS SELECT.
Если результат запроса присваивается переменной строкового типа или списку переменных, то
они должны в точности соответствовать по количеству и типам данных столбцам результата, ина-
че произойдёт ошибка во время выполнения. Если используется переменная типа record, то она
автоматически приводится к строковому типу результата запроса.
Предложение INTO может появиться практически в любом месте SQL-команды. Обычно его запи-
сывают непосредственно перед или сразу после списка выражения_select в SELECT или в конце
команды для команд других типов. Рекомендуется следовать этому соглашению на случай, если
правила разбора PL/pgSQL ужесточатся в будущих версиях.
Если указание STRICT отсутствует в предложении INTO, то цели присваивается первая строка, воз-
вращённая запросом; или NULL, если запрос не вернул строк. (Заметим, что понятие «первая стро-
ка» определяется неоднозначно без ORDER BY.) Все остальные строки результата после первой
отбрасываются. Можно проверить специальную переменную FOUND (см. Подраздел 43.5.5), чтобы
определить, была ли возвращена запись:
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
RAISE EXCEPTION ‘Сотрудник % не найден’, myname;
END IF;
Если добавлено указание STRICT, то запрос должен вернуть ровно одну строку или произойдёт
ошибка во время выполнения: либо NO_DATA_FOUND (нет строк), либо TOO_MANY_ROWS (более одной
строки). Можно использовать секцию исключений в блоке для обработки ошибок, например:
BEGIN
SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
EXCEPTION
WHEN NO_DATA_FOUND THEN
RAISE EXCEPTION ‘Сотрудник % не найден’, myname;
WHEN TOO_MANY_ROWS THEN
RAISE EXCEPTION ‘Сотрудник % уже существует’, myname;
END;
После успешного выполнения команды с указанием STRICT, значение переменной FOUND всегда
устанавливается в истину.
Для INSERT/UPDATE/DELETE с RETURNING, PL/pgSQL возвращает ошибку, если выбрано более одной
строки, даже в том случае, когда указание STRICT отсутствует. Так происходит потому, что у этих
команд нет возможности, типа ORDER BY, указать какая из задействованных строк должна быть
возвращена.
Если для функции включён режим print_strict_params, то при возникновении ошибки, связанной
с нарушением условия STRICT, в детальную (DETAIL) часть сообщения об ошибке будет включена
информация о параметрах, переданных запросу. Изменить значение print_strict_params можно
установкой параметра plpgsql.print_strict_params. Но это повлияет только на функции, ском-
1134PL/pgSQL — проце-
дурный язык SQL
пилированные после изменения. Для конкретной функции можно использовать указание компи-
лятора, например:
CREATE FUNCTION get_userid(username text) RETURNS int
AS <script type="math/tex">#print_strict_params on
DECLARE
userid int;
BEGIN
SELECT users.userid INTO STRICT userid
FROM users WHERE users.username = get_userid.username;
RETURN userid;
END</script> LANGUAGE plpgsql;
В случае сбоя будет сформировано примерно такое сообщение об ошибке
ERROR: query returned no rows
DETAIL: parameters: $1 = ‘nosuchuser’
CONTEXT: PL/pgSQL function get_userid(text) line 6 at SQL statement
Примечание
С указанием STRICT поведение SELECT INTO и связанных операторов соответствует при-
нятому в Oracle PL/SQL.
Как действовать в случаях, когда требуется обработать несколько строк результата, описано в
Подразделе 43.6.6.
43.5.4. Выполнение динамически формируемых команд
Часто требуется динамически формировать команды внутри функций на PL/pgSQL, то есть такие
команды, в которых при каждом выполнении могут использоваться разные таблицы или типы дан-
ных. Обычно PL/pgSQL кеширует планы выполнения (как описано в Подразделе 43.11.2), но в слу-
чае с динамическими командами это не будет работать. Для исполнения динамических команд
предусмотрен оператор EXECUTE:
EXECUTE строка-команды [ INTO [STRICT] цель ] [ USING выражение [, … ] ];
где строка-команды это выражение, формирующее строку (типа text) с текстом команды, которую
нужно выполнить. Необязательная цель — это переменная-запись, переменная-кортеж или раз-
делённый запятыми список простых переменных и полей записи/кортежа, куда будут помещены
результаты команды. Необязательные выражения в USING формируют значения, которые будут
вставлены в команду.
В сформированном тексте команды замена имён переменных PL/pgSQL на их значения проводить-
ся не будет. Все необходимые значения переменных должны быть вставлены в командную строку
при её построении, либо нужно использовать параметры, как описано ниже.
Также, нет никакого плана кеширования для команд, выполняемых с помощью EXECUTE. Вместо
этого план создаётся каждый раз при выполнении. Таким образом, строка команды может дина-
мически создаваться внутри функции для выполнения действий с различными таблицами и столб-
цами.
Предложение INTO указывает, куда должны быть помещены результаты SQL-команды, возвращаю-
щей строки. Если используется переменная строкового типа или список переменных, то они долж-
ны в точности соответствовать структуре результата запроса (когда используется переменная ти-
па record, она автоматически приводится к строковому типу результата запроса). Если возвраща-
ется несколько строк, то только первая будет присвоена переменной(ым) в INTO. Если не возвра-
1135PL/pgSQL — проце-
дурный язык SQL
щается ни одной строки, то присваивается NULL. Без предложения INTO результаты запроса от-
брасываются.
С указанием STRICT запрос должен вернуть ровно одну строку, иначе выдаётся сообщение об ошиб-
ке.
В тексте команды можно использовать значения параметров, ссылки на параметры обозначаются
как $1, $2 и т. д. Эти символы указывают на значения, находящиеся в предложении USING. Такой
метод зачастую предпочтительнее, чем вставка значений в команду в виде текста: он позволяет
исключить во время исполнения дополнительные расходы на преобразования значений в текст и
обратно, и не открывает возможности для SQL-инъекций, не требуя применять экранирование или
кавычки для спецсимволов. Пример:
EXECUTE ‘SELECT count(<em>) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2’
INTO c
USING checked_user, checked_date;
Обратите внимание, что символы параметров можно использовать только вместо значений дан-
ных. Если же требуется динамически формировать имена таблиц или столбцов, их необходимо
вставлять в виде текста. Например, если в предыдущем запросе необходимо динамически задавать
имя таблицы, можно сделать следующее:
EXECUTE ‘SELECT count(</em>) FROM ‘
|| quote_ident(tabname)
|| ‘ WHERE inserted_by = $1 AND inserted &lt;= $2’
INTO c
USING checked_user, checked_date;
В качестве более аккуратного решения, вместо имени таблиц или столбцов можно использовать
указание формата %I с функцией format() (текст, разделённый символами новой строки, соеди-
няется вместе):
EXECUTE format(‘SELECT count(*) FROM %I ‘
‘WHERE inserted_by = $1 AND inserted &lt;= $2’, tabname)
INTO c
USING checked_user, checked_date;
Ещё одно ограничение состоит в том, что символы параметров могут использоваться только в ко-
мандах SELECT, INSERT, UPDATE и DELETE. В операторы других типов (обычно называемые служеб-
ными) значения нужно вставлять в текстовом виде, даже если это просто значения данных.
Команда EXECUTE c неизменяемым текстом и параметрами USING (как в первом примере выше),
функционально эквивалентна команде, записанной напрямую в PL/pgSQL, в которой переменные
PL/pgSQL автоматически заменяются значениями. Важное отличие в том, что EXECUTE при каж-
дом исполнении заново строит план команды с учётом текущих значений параметров, тогда как
PL/pgSQL строит общий план выполнения и кеширует его при повторном использовании. В тех
случаях, когда наилучший план выполнения сильно зависит от значений параметров, может быть
полезно использовать EXECUTE для гарантии того, что не будет выбран общий план.
В настоящее время команда SELECT INTO не поддерживается в EXECUTE, вместо этого нужно вы-
полнять обычный SELECT и указать INTO для самой команды EXECUTE.
Примечание
Оператор EXECUTE в PL/pgSQL не имеет отношения к одноимённому SQL-оператору сер-
вера PostgreSQL. Серверный EXECUTE не может напрямую использоваться в функциях
на PL/pgSQL (и в этом нет необходимости).
Пример 43.1. Использование кавычек в динамических запросах
1136PL/pgSQL — проце-
дурный язык SQL
При работе с динамическими командами часто приходится иметь дело с экранированием одинар-
ных кавычек. Рекомендуемым методом для взятия текста в кавычки в теле функции является экра-
нирование знаками доллара. (Если имеется унаследованный код, не использующий этот метод,
пожалуйста, обратитесь к обзору в Подразделе 43.12.1, это поможет сэкономить усилия при пере-
воде кода к более приемлемому виду.)
Динамические значения требуют особого внимания, так как они могут содержать апострофы. На-
пример, можно использовать функцию format() (предполагается, что тело функции заключается
в доллары, так что апострофы дублировать не нужно):
EXECUTE format(‘UPDATE tbl SET %I = $1 ‘
‘WHERE key = $2’, colname) USING newvalue, keyvalue;
Также можно напрямую вызывать функции заключения в кавычки:
EXECUTE ‘UPDATE tbl SET ‘
|| quote_ident(colname)
|| ‘ = ‘
|| quote_literal(newvalue)
|| ‘ WHERE key = ‘
|| quote_literal(keyvalue);
Этот пример демонстрирует использование функций quote_ident и quote_literal (см. Раздел 9.4).
Для надёжности, выражения, содержащие идентификаторы столбцов и таблиц должны использо-
вать функцию quote_ident при добавлении в текст запроса. А для выражений со значениями, ко-
торые должны быть обычными строками, используется функция quote_literal. Эти функции вы-
полняют соответствующие шаги, чтобы вернуть текст, по ситуации заключённый в двойные или
одинарные кавычки и с правильно экранированными специальными символами.
Так как функция quote_literal помечена как STRICT, то она всегда возвращает NULL, если пе-
реданный ей аргумент имеет значение NULL. В приведённом выше примере, если newvalue или
keyvalue были NULL, вся строка с текстом запроса станет NULL, что приведёт к ошибке в EXECUTE.
Для предотвращения этой проблемы используйте функцию quote_nullable, которая работает так
же, как quote_literal за исключением того, что при вызове с пустым аргументом возвращает
строку ‘NULL’. Например:
EXECUTE ‘UPDATE tbl SET ‘
|| quote_ident(colname)
|| ‘ = ‘
|| quote_nullable(newvalue)
|| ‘ WHERE key = ‘
|| quote_nullable(keyvalue);
Если вы имеете дело со значениями, которые могут быть пустыми, то, как правило, нужно исполь-
зовать quote_nullable вместо quote_literal.
Как обычно, необходимо убедиться, что значения NULL в запросе не принесут неожиданных ре-
зультатов. Например, следующее условие WHERE
‘WHERE key = ‘ || quote_nullable(keyvalue)
никогда не выполнится, если keyvalue — NULL, так как применение = с операндом, имеющим зна-
чение NULL, всегда даёт NULL. Если требуется, чтобы NULL обрабатывалось как обычное значе-
ние, то условие выше нужно переписать так:
‘WHERE key IS NOT DISTINCT FROM ‘ || quote_nullable(keyvalue)
(В настоящее время IS NOT DISTINCT FROM работает менее эффективно, чем =, так что исполь-
зуйте этот способ, только если это действительно необходимо. Подробнее особенности NULL и IS
DISTINCT описаны в Разделе 9.2.)
Обратите внимание, что использование знака $ полезно только для взятия в кавычки фиксирован-
ного текста. Плохая идея написать этот пример так:
1137PL/pgSQL — проце-
дурный язык SQL
EXECUTE ‘UPDATE tbl SET ‘
|| quote_ident(colname)
|| ‘ = <script type="math/tex">'
|| newvalue
|| '</script> WHERE key = ‘
|| quote_literal(keyvalue);
потому что newvalue может также содержать <script type="math/tex">% <![CDATA[
. Эта же проблема может возникнуть и с любым
другим разделителем, используемым после знака $. Поэтому, чтобы безопасно заключить зара-
нее неизвестный текст в кавычки, нужно использовать соответствующие функции: quote_literal,
quote_nullable, или quote_ident.
Динамические операторы SQL также можно безопасно сформировать, используя функцию format
(см. Раздел 9.4). Например:
EXECUTE format('UPDATE tbl SET %I = %L '
'WHERE key = %L', colname, newvalue, keyvalue);
Указание %I равнозначно вызову quote_ident, а %L — вызову quote_nullable. Функция format мо-
жет применяться в сочетании с предложением USING:
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
USING newvalue, keyvalue;
Эта форма лучше, так как с ней переменные обрабатываются в их собственном формате данных,
а не преобразуются безусловно в текст, чтобы затем выводиться с использованием %L. Она также
и более эффективна.
Более объёмный пример использования динамической команды и EXECUTE можно увидеть в При-
мере 43.10. В нём создаётся и динамически выполняется команда CREATE FUNCTION для определе-
ния новой функции.
43.5.5. Статус выполнения команды
Определить результат команды можно несколькими способами. Во-первых, можно воспользовать-
ся командой GET DIAGNOSTICS, имеющей форму:
GET [ CURRENT ] DIAGNOSTICS переменная { = | := } элемент [ , ... ];
Эта команда позволяет получить системные индикаторы состояния. Слово CURRENT не несёт смыс-
ловой нагрузки (но см. также описание GET STACKED DIAGNOSTICS в Подразделе  43.6.8.1). Каж-
дый элемент представляется ключевым словом, указывающим, какое значение состояния нужно
присвоить заданной переменной (она должна иметь подходящий тип данных, чтобы принять его).
Доступные в настоящее время элементы состояния показаны в Таблице 43.1. Вместо принятого в
стандарте SQL присваивания (=) можно применять присваивание с двоеточием (:=). Например:
GET DIAGNOSTICS integer_var = ROW_COUNT;
Таблица 43.1. Доступные элементы диагностики
Имя Тип Описание
ROW_COUNT bigint число строк, обработанных по-
следней командой SQL
RESULT_OID oid OID последней строки, встав-
ленной предыдущей командой
SQL (полезен только после ко-
манды INSERT для таблицы, со-
держащей OID)
PG_CONTEXT text строки текста, описывающие
текущий стек вызовов (см. Под-
раздел 43.6.9)
1138PL/pgSQL — проце-
дурный язык SQL
Второй способ определения статуса выполнения команды заключается в проверке значения спе-
циальной переменной FOUND, имеющей тип boolean. При вызове функции на PL/pgSQL, перемен-
ная FOUND инициализируется в ложь. Далее, значение переменной изменяется следующими опе-
раторами:
• SELECT INTO записывает в FOUND true, если строка присвоена, или false, если строки не были
получены.
• PERFORM записывает в FOUND true, если строки выбраны (и отброшены) или false, если строки
не выбраны.
• UPDATE, INSERT и DELETE записывают в FOUND true, если при их выполнении была задействована
хотя бы одна строка, или false, если ни одна строка не была задействована.
• FETCH записывают в FOUND true, если команда вернула строку, или false, если строка не выбра-
на.
• MOVE записывают в FOUND true при успешном перемещении курсора, в противном случае —
false.
• FOR, как и FOREACH, записывает в FOUND true, если была произведена хотя бы одна итерация
цикла, в противном случае — false. При этом значение FOUND будет установлено только после
выхода из цикла. Пока цикл выполняется, оператор цикла не изменяет значение переменной.
Но другие операторы внутри цикла могут менять значение FOUND.
• RETURN QUERY и RETURN QUERY EXECUTE записывают в FOUND true, если запрос вернул хотя бы
одну строку, или false, если строки не выбраны.
Другие операторы PL/pgSQL не меняют значение FOUND. Помните в частности, что EXECUTE изме-
няет вывод GET DIAGNOSTICS, но не меняет FOUND.
FOUND является локальной переменной в каждой функции PL/pgSQL и любые её изменения, влияют
только на текущую функцию.
43.5.6. Не делать ничего
Иногда бывает полезен оператор, который не делает ничего. Например, он может показывать, что
одна из ветвей if/then/else сознательно оставлена пустой. Для этих целей используется NULL:
NULL;
В следующем примере два фрагмента кода эквивалентны:
BEGIN
y := x / 0;
EXCEPTION
WHEN division_by_zero THEN
NULL; -- ошибка игнорируется
END;
BEGIN
y := x / 0;
EXCEPTION
WHEN division_by_zero THEN
END;
-- ошибка игнорируется
Какой вариант выбрать — дело вкуса.
Примечание
В Oracle PL/SQL не допускаются пустые списки операторов, поэтому NULL обязателен
в подобных ситуациях. В PL/pgSQL разрешается не писать ничего.
1139PL/pgSQL — проце-
дурный язык SQL
43.6. Управляющие структуры
Управляющие структуры, вероятно, наиболее полезная и важная часть PL/pgSQL. С их помощью
можно очень гибко и эффективно манипулировать данными PostgreSQL.
43.6.1. Команды для возврата значения из функции
Две команды позволяют вернуть данные из функции: RETURN и RETURN NEXT.
43.6.1.1. RETURN
RETURN выражение;
RETURN с последующим выражением прекращает выполнение функции и возвращает значение вы-
ражения в вызывающую программу. Эта форма используется для функций PL/pgSQL, которые не
возвращают набор строк.
В функции, возвращающей скалярный тип, результирующее выражение автоматически приводит-
ся к типу возвращаемого значения. Однако, чтобы вернуть составной тип (строку), возвращаемое
выражение должно в точности содержать требуемый набор столбцов. При этом может потребо-
ваться явное приведение типов.
Для функции с выходными параметрами просто используйте RETURN без выражения. Будут возвра-
щены текущие значения выходных параметров.
Для функции, возвращающей void, RETURN можно использовать в любом месте, но без выражения
после RETURN.
Возвращаемое значение функции не может остаться не определённым. Если достигнут конец бло-
ка верхнего уровня, а оператор RETURN так и не встретился, происходит ошибка времени исполне-
ния. Это не касается функций с выходными параметрами и функций, возвращающих void. Для них
оператор RETURN выполняется автоматически по окончании блока верхнего уровня.
Несколько примеров:
-- Функции, возвращающие скалярный тип данных
RETURN 1 + 2;
RETURN scalar_var;
-- Функции, возвращающие составной тип данных
RETURN composite_type_var;
RETURN (1, 2, 'three'::text); -- требуется приведение типов
43.6.1.2. RETURN NEXT и RETURN QUERY
RETURN NEXT выражение;
RETURN QUERY запрос;
RETURN QUERY EXECUTE строка-команды [USING выражение [, ...]];
Для функций на PL/pgSQL, возвращающих SETOF некий_тип, нужно действовать несколько по-
иному. Отдельные элементы возвращаемого значения формируются командами RETURN NEXT или
RETURN QUERY, а финальная команда RETURN без аргументов завершает выполнение функции. RETURN
NEXT используется как со скалярными, так и с составными типами данных. Для составного типа
результат функции возвращается в виде таблицы. RETURN QUERY добавляет результат выполнения
запроса к результату функции. RETURN NEXT и RETURN QUERY можно свободно смешивать в теле
функции, в этом случае их результаты будут объединены.
RETURN NEXT и RETURN QUERY не выполняют возврат из функции. Они просто добавляют строки в
результирующее множество. Затем выполнение продолжается со следующего оператора в функ-
ции. Успешное выполнение RETURN NEXT и RETURN QUERY формирует множество строк результата.
1140PL/pgSQL — проце-
дурный язык SQL
Для выхода из функции используется RETURN, обязательно без аргументов (или можно просто до-
ждаться окончания выполнения функции).
RETURN QUERY имеет разновидность RETURN QUERY EXECUTE, предназначенную для динамического
выполнения запроса. В текст запроса можно добавить параметры, используя USING, также как и
с командой EXECUTE.
Для функции с выходными параметрами просто используйте RETURN NEXT без аргументов. При
каждом исполнении RETURN NEXT текущие значения выходных параметров сохраняются для после-
дующего возврата в качестве строки результата. Обратите внимание, что если функция с выход-
ными параметрами должна возвращать множество значений, то при объявлении нужно указывать
RETURNS SETOF. При этом если выходных параметров несколько, то используется RETURNS SETOF
record, а если только один с типом некий_тип, то RETURNS SETOF некий_тип.
Пример использования RETURN NEXT:
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');
CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
r foo%rowtype;
BEGIN
FOR r IN
SELECT * FROM foo WHERE fooid > 0
LOOP
-- здесь возможна обработка данных
RETURN NEXT r; -- возвращается текущая строка запроса
END LOOP;
RETURN;
END
$BODY$
LANGUAGE plpgsql;
SELECT * FROM get_all_foo();
Пример использования RETURN QUERY:
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
RETURN QUERY SELECT flightid
FROM flight
WHERE flightdate >= $1
AND flightdate < ($1 + 1);
-- Так как выполнение ещё не закончено, можно проверить, были ли возвращены строки,
-- и если нет, выдать исключение.
IF NOT FOUND THEN
RAISE EXCEPTION 'Нет рейсов на дату: %.', $1;
END IF;
RETURN;
END
$BODY$
LANGUAGE plpgsql;
1141PL/pgSQL — проце-
дурный язык SQL
-- Возвращает доступные рейсы либо вызывает исключение, если таковых нет.
SELECT * FROM get_available_flightid(CURRENT_DATE);
Примечание
В текущей реализации RETURN NEXT и RETURN QUERY результирующее множество накап-
ливается целиком, прежде чем будет возвращено из функции. Если множество очень
большое, то это может отрицательно сказаться на производительности, так как при
нехватке оперативной памяти данные записываются на диск. В следующих версиях PL/
pgSQL это ограничение будет снято. В настоящее время управлять количеством опера-
тивной памяти в подобных случаях можно параметром конфигурации work_mem. При
наличии свободной памяти администраторы должны рассмотреть возможность увели-
чения значения данного параметра.
43.6.2. Завершение процедуры
Процедура не возвращает никакого значения, поэтому она может завершаться без оператора
RETURN. Если вы хотите досрочно завершить выполнение кода оператором RETURN, напишите про-
сто RETURN без возвращаемого выражения.
Если у процедуры есть выходные параметры, конечные значения соответствующих им переменных
будут выданы вызывающему коду.
43.6.3. Вызов процедуры
Функция, процедура или блок DO в PL/pgSQL может вызвать процедуру, используя оператор CALL.
Выходные параметры при этом обрабатываются не так, как это делает CALL в обычном SQL. Каж-
дому параметру INOUT для процедуры должна соответствовать переменная в операторе CALL, и
этой переменной по завершении процедуры будет присвоено возвращаемое процедурой значение.
Например:
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS %]]></script>
BEGIN
x := x * 3;
END;
<script type="math/tex">;
DO</script>
DECLARE myvar int := 5;
BEGIN
CALL triple(myvar);
RAISE NOTICE ‘myvar = %’, myvar;
END
$$;
– выводится 15
43.6.4. Условные операторы
Операторы IF и CASE позволяют выполнять команды в зависимости от определённых условий. PL/
pgSQL поддерживает три формы IF:
• IF … THEN … END IF
• IF … THEN … ELSE … END IF
• IF … THEN … ELSIF … THEN … ELSE … END IF
и две формы CASE:
• CASE … WHEN … THEN … ELSE … END CASE
1142PL/pgSQL — проце-
дурный язык SQL
• CASE WHEN … THEN … ELSE … END CASE
43.6.4.1. IF-THEN
IF логическое-выражение THEN
операторы
END IF;
IF-THEN это простейшая форма IF. Операторы между THEN и END IF выполняются, если условие
(логическое-выражение) истинно. В противном случае они опускаются.
Пример:
IF v_user_id &lt;&gt; 0 THEN
UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
43.6.4.2. IF-THEN-ELSE
IF логическое-выражение THEN
операторы
ELSE
операторы
END IF;
IF-THEN-ELSE добавляет к IF-THEN возможность указать альтернативный набор операторов, кото-
рые будут выполнены, если условие не истинно (в том числе, если условие NULL).
Примеры:
IF parentid IS NULL OR parentid = ‘’
THEN
RETURN fullname;
ELSE
RETURN hp_true_filename(parentid) || ‘/’ || fullname;
END IF;
IF v_count
INSERT
RETURN
ELSE
RETURN
END IF;</p>
<blockquote>
  <p>0 THEN
INTO users_count (count) VALUES (v_count);
‘t’;
‘f’;
43.6.4.3. IF-THEN-ELSIF
IF логическое-выражение THEN
операторы
[ELSIF логическое-выражение THEN операторы [ELSIF логическое-выражение THEN операторы
…]]
[ELSE операторы]
END IF;
В некоторых случаях двух альтернатив недостаточно. IF-THEN-ELSIF обеспечивает удобный способ
проверки нескольких вариантов по очереди. Условия в IF последовательно проверяются до тех пор,
пока не будет найдено первое истинное. После этого операторы, относящиеся к этому условию,
выполняются, и управление переходит к следующей после END IF команде. (Все последующие
условия не проверяются.) Если ни одно из условий IF не является истинным, то выполняется блок
ELSE (если присутствует).
Пример:
IF number = 0 THEN
result := ‘zero’;
1143PL/pgSQL — проце-
дурный язык SQL
ELSIF number &gt; 0 THEN
result := ‘positive’;
ELSIF number &lt; 0 THEN
result := ‘negative’;
ELSE
– остаётся только один вариант: number имеет значение NULL
result := ‘NULL’;
END IF;
Вместо ключевого слова ELSIF можно использовать ELSEIF.
Другой вариант сделать то же самое, это использование вложенных операторов IF-THEN-ELSE, как
в следующем примере:
IF demo_row.sex = ‘m’ THEN
pretty_sex := ‘man’;
ELSE
IF demo_row.sex = ‘f’ THEN
pretty_sex := ‘woman’;
END IF;
END IF;
Однако это требует написания соответствующих END IF для каждого IF, что при наличии несколь-
ких альтернатив делает код более громоздким, чем использование ELSIF.
43.6.4.4. Простой CASE
CASE выражение-поиска
WHEN выражение [, выражение […]] THEN
операторы
[WHEN выражение [, выражение […]] THEN операторы …]
[ELSE операторы]
END CASE;
Простая форма CASE реализует условное выполнение на основе сравнения операндов. Выраже-
ние-поиска вычисляется (один раз) и последовательно сравнивается с каждым выражением в усло-
виях WHEN. Если совпадение найдено, то выполняются соответствующие операторы и управление
переходит к следующей после END CASE команде. (Все последующие выражения WHEN не проверя-
ются.) Если совпадение не было найдено, то выполняются операторы в ELSE. Но если ELSE нет, то
вызывается исключение CASE_NOT_FOUND.
Пример:
CASE x
WHEN 1, 2 THEN
msg := ‘один или два’;
ELSE
msg := ‘значение, отличное от один или два’;
END CASE;
43.6.4.5. CASE с перебором условий
CASE
WHEN логическое-выражение THEN
операторы
[WHEN логическое-выражение THEN операторы …]
[ELSE операторы]
END CASE;
Эта форма CASE реализует условное выполнение, основываясь на истинности логических условий.
Каждое логическое-выражение в предложении WHEN вычисляется по порядку до тех пор, пока не
1144PL/pgSQL — проце-
дурный язык SQL
будет найдено истинное. Затем выполняются соответствующие операторы и управление переходит
к следующей после END CASE команде. (Все последующие выражения WHEN не проверяются.) Если
ни одно из условий не окажется истинным, то выполняются операторы в ELSE. Но если ELSE нет,
то вызывается исключение CASE_NOT_FOUND.
Пример:
CASE
WHEN x BETWEEN 0 AND 10 THEN
msg := ‘значение в диапазоне между 0 и 10’;
WHEN x BETWEEN 11 AND 20 THEN
msg := ‘значение в диапазоне между 11 и 20’;
END CASE;
Эта форма CASE полностью эквивалента IF-THEN-ELSIF, за исключением того, что при невыполне-
нии всех условий и отсутствии ELSE, IF-THEN-ELSIF ничего не делает, а CASE вызывает ошибку.
43.6.5. Простые циклы
Операторы LOOP, EXIT, CONTINUE, WHILE, FOR и FOREACH позволяют повторить серию команд в функ-
ции на PL/pgSQL.
43.6.5.1. LOOP
[«метка»]
LOOP
операторы
END LOOP [ метка ];
LOOP организует безусловный цикл, который повторяется до бесконечности, пока не будет прекра-
щён операторами EXIT или RETURN. Для вложенных циклов можно использовать метку в операторах
EXIT и CONTINUE, чтобы указать, к какому циклу эти операторы относятся.
43.6.5.2. EXIT
EXIT [ метка ] [WHEN логическое-выражение];
Если метка не указана, то завершается самый внутренний цикл, далее выполняется оператор, сле-
дующий за END LOOP. Если метка указана, то она должна относиться к текущему или внешнему
циклу, или это может быть метка блока. При этом в именованном цикле/блоке выполнение пре-
кращается, а управление переходит к следующему оператору после соответствующего END.
При наличии WHEN цикл прекращается, только если логическое-выражение истинно. В противном
случае управление переходит к оператору, следующему за EXIT.
EXIT можно использовать со всеми типами циклов, не только с безусловным.
Когда EXIT используется для выхода из блока, управление переходит к следующему оператору по-
сле окончания блока. Обратите внимание, что для выхода из блока нужно обязательно указывать
метку. EXIT без метки не позволяет прекратить работу блока. (Это изменение по сравнению с вер-
сиями PostgreSQL до 8.4, в которых разрешалось использовать EXIT без метки для прекращения
работы текущего блока.)
Примеры:
LOOP
– здесь производятся вычисления
IF count &gt; 0 THEN
EXIT; – выход из цикла
END IF;
END LOOP;
1145PL/pgSQL — проце-
дурный язык SQL
LOOP
– здесь производятся вычисления
EXIT WHEN count &gt; 0; – аналогично предыдущему примеру
END LOOP;
«ablock»
BEGIN
– здесь производятся вычисления
IF stocks &gt; 100000 THEN
EXIT ablock; – выход из блока BEGIN
END IF;
– вычисления не будут выполнены, если stocks &gt; 100000
END;
43.6.5.3. CONTINUE
CONTINUE [ метка ] [WHEN логическое-выражение];
Если метка не указана, то начинается следующая итерация самого внутреннего цикла. То есть все
оставшиеся в цикле операторы пропускаются, и управление переходит к управляющему выраже-
нию цикла (если есть) для определения, нужна ли ещё одна итерация цикла. Если метка присут-
ствует, то она указывает на метку цикла, выполнение которого будет продолжено.
При наличии WHEN следующая итерация цикла начинается только тогда, когда логическое-выра-
жение истинно. В противном случае управление переходит к оператору, следующему за CONTINUE.
CONTINUE можно использовать со всеми типами циклов, не только с безусловным.
Примеры:
LOOP
– здесь производятся вычисления
EXIT WHEN count &gt; 100;
CONTINUE WHEN count &lt; 50;
– вычисления для count в диапазоне 50 .. 100
END LOOP;
43.6.5.4. WHILE
[«метка»]
WHILE логическое-выражение LOOP
операторы
END LOOP [ метка ];
WHILE выполняет серию команд до тех пор, пока истинно логическое-выражение. Выражение про-
веряется непосредственно перед каждым входом в тело цикла.
Пример:
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
– здесь производятся вычисления
END LOOP;
WHILE NOT done LOOP
– здесь производятся вычисления
END LOOP;
43.6.5.5. FOR (целочисленный вариант)
[«метка»]
FOR имя IN [REVERSE] выражение .. выражение [BY выражение] LOOP
операторы
1146PL/pgSQL — проце-
дурный язык SQL
END LOOP [ метка ];
В этой форме цикла FOR итерации выполняются по диапазону целых чисел. Переменная имя авто-
матически определяется с типом integer и существует только внутри цикла (если уже существует
переменная с таким именем, то внутри цикла она будет игнорироваться). Выражения для нижней
и верхней границы диапазона чисел вычисляются один раз при входе в цикл. Если не указано BY,
то шаг итерации 1, в противном случае используется значение в BY, которое вычисляется, опять
же, один раз при входе в цикл. Если указано REVERSE, то после каждой итерации величина шага
вычитается, а не добавляется.
Примеры целочисленного FOR:
FOR i IN 1..10 LOOP
– внутри цикла переменная i будет иметь значения 1,2,3,4,5,6,7,8,9,10
END LOOP;
FOR i IN REVERSE 10..1 LOOP
– внутри цикла переменная i будет иметь значения 10,9,8,7,6,5,4,3,2,1
END LOOP;
FOR i IN REVERSE 10..1 BY 2 LOOP
– внутри цикла переменная i будет иметь значения 10,8,6,4,2
END LOOP;
Если нижняя граница цикла больше верхней границы (или меньше, в случае REVERSE), то тело
цикла не выполняется вообще. При этом ошибка не возникает.
Если с циклом FOR связана метка, к целочисленной переменной цикла можно обращаться по имени,
указывая эту метку.
43.6.6. Цикл по результатам запроса
Другой вариант FOR позволяет организовать цикл по результатам запроса. Синтаксис:
[ «метка» ]
FOR цель IN запрос LOOP
операторы
END LOOP [ метка ];
Переменная цель может быть строковой переменной, переменной типа record или разделённым
запятыми списком скалярных переменных. Переменной цель последовательно присваиваются
строки результата запроса, и для каждой строки выполняется тело цикла. Пример:
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS <script type="math/tex">DECLARE
mviews RECORD;
BEGIN
RAISE NOTICE 'Refreshing materialized views...';
FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP
-- Здесь "mviews" содержит одну запись из cs_materialized_views
RAISE NOTICE 'Refreshing materialized view %s ...',
quote_ident(mviews.mv_name);
EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
END LOOP;
RAISE NOTICE 'Done refreshing materialized views.';
RETURN 1;
1147PL/pgSQL — проце-
дурный язык SQL
END;</script> LANGUAGE plpgsql;
Если цикл завершается по команде EXIT, то последняя присвоенная строка доступна и после цикла.
В качестве запроса в этом типе оператора FOR может задаваться любая команда SQL, возвраща-
ющая строки. Чаще всего это SELECT, но также можно использовать и INSERT, UPDATE или DELETE
с предложением RETURNING. Кроме того, возможно применение и некоторых служебных команд,
например EXPLAIN.
Для переменных PL/pgSQL в тексте запроса выполняется подстановка значений, план запроса ке-
шируется для возможного повторного использования, как подробно описано в Подразделе 43.11.1
и Подразделе 43.11.2.
Ещё одна разновидность этого типа цикла FOR-IN-EXECUTE:
[ «метка» ]
FOR цель IN EXECUTE выражение_проверки [ USING выражение [, … ] ] LOOP
операторы
END LOOP [ метка ];
Она похожа на предыдущую форму, за исключением того, что текст запроса указывается в виде
строкового выражения. Текст запроса формируется и для него строится план выполнения при
каждом входе в цикл. Это даёт программисту выбор между скоростью предварительно разобран-
ного запроса и гибкостью динамического запроса, так же, как и в случае с обычным оператором
EXECUTE. Как и в EXECUTE, значения параметров могут быть добавлены в команду с использованием
USING.
Ещё один способ организовать цикл по результатам запроса это объявить курсор. Описание в Под-
разделе 43.7.4.
43.6.7. Цикл по элементам массива
Цикл FOREACH очень похож на FOR. Отличие в том, что вместо перебора строк SQL-запроса проис-
ходит перебор элементов массива. (В целом, FOREACH предназначен для перебора выражений со-
ставного типа. Варианты реализации цикла для работы с прочими составными выражениями по-
мимо массивов могут быть добавлены в будущем.) Синтаксис цикла FOREACH:
[ «метка» ]
FOREACH цель [ SLICE число ] IN ARRAY выражение LOOP
операторы
END LOOP [ метка ];
Без указания SLICE, или если SLICE равен 0, цикл выполняется по всем элементам массива, полу-
ченного из выражения. Переменной цель последовательно присваивается каждый элемент массива
и для него выполняется тело цикла. Пример цикла по элементам целочисленного массива:
CREATE FUNCTION sum(int[]) RETURNS int8 AS <script type="math/tex">DECLARE
s int8 := 0;
x int;
BEGIN
FOREACH x IN ARRAY $1
LOOP
s := s + x;
END LOOP;
RETURN s;
END;</script> LANGUAGE plpgsql;
Обход элементов проводится в том порядке, в котором они сохранялись, независимо от размерно-
сти массива. Как правило, цель это одиночная переменная, но может быть и списком переменных,
1148PL/pgSQL — проце-
дурный язык SQL
когда элементы массива имеют составной тип (записи). В этом случае переменным присваиваются
значения из последовательных столбцов составного элемента массива.
При положительном значении SLICE FOREACH выполняет итерации по срезам массива, а не по от-
дельным элементам. Значение SLICE должно быть целым числом, не превышающим размерности
массива. Переменная цель должна быть массивом, который получает последовательные срезы ис-
ходного массива, где размерность каждого среза задаётся значением SLICE. Пример цикла по од-
номерным срезам:
CREATE FUNCTION scan_rows(int[]) RETURNS void AS <script type="math/tex">DECLARE
x int[];
BEGIN
FOREACH x SLICE 1 IN ARRAY $1
LOOP
RAISE NOTICE 'row = %', x;
END LOOP;
END;</script> LANGUAGE plpgsql;
SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);
NOTICE:
NOTICE:
NOTICE:
NOTICE:
row
row
row
row
=
=
=
=
{1,2,3}
{4,5,6}
{7,8,9}
{10,11,12}
43.6.8. Обработка ошибок
По умолчанию любая возникающая ошибка прерывает выполнение функции на PL/pgSQL, а также
транзакцию, относящуюся к этой функции. Использование в блоке секции EXCEPTION позволяет
перехватывать и обрабатывать ошибки. Синтаксис секции EXCEPTION расширяет синтаксис обыч-
ного блока:
[ «метка» ]
[ DECLARE
объявления ]
BEGIN
операторы
EXCEPTION
WHEN условие [ OR условие … ] THEN
операторы_обработчика
[ WHEN условие [ OR условие … ] THEN
операторы_обработчика
… ]
END;
Если ошибок не было, то выполняются все операторы блока и управление переходит к следую-
щему оператору после END. Но если при выполнении оператора происходит ошибка, то дальней-
шая обработка прекращается и управление переходит к списку исключений в секции EXCEPTION. В
этом списке ищется первое исключение, условие которого соответствует ошибке. Если исключе-
ние найдено, то выполняются соответствующие операторы_обработчика и управление переходит
к следующему оператору после END. Если исключение не найдено, то ошибка передаётся наружу,
как будто секции EXCEPTION не было. При этом ошибку можно перехватить в секции EXCEPTION
внешнего блока. Если ошибка так и не была перехвачена, то обработка функции прекращается.
В качестве условия может задаваться одно из имён, перечисленных в Приложении A. Если задаёт-
ся имя категории, ему соответствуют все ошибки в данной категории. Специальному имени усло-
вия OTHERS (другие) соответствуют все типы ошибок, кроме QUERY_CANCELED и ASSERT_FAILURE. (И
эти два типа ошибок можно перехватить по имени, но часто это неразумно.) Имена условий вос-
1149PL/pgSQL — проце-
дурный язык SQL
принимаются без учёта регистра. Условие ошибки также можно задать кодом SQLSTATE; например,
эти два варианта равнозначны:
WHEN division_by_zero THEN …
WHEN SQLSTATE ‘22012’ THEN …
Если при выполнении операторов_обработчика возникнет новая ошибка, то она не может быть пе-
рехвачена в этой секции EXCEPTION. Ошибка передаётся наружу и её можно перехватить в секции
EXCEPTION внешнего блока.
При выполнении команд в секции EXCEPTION локальные переменные функции на PL/pgSQL сохра-
няют те значения, которые были на момент возникновения ошибки. Однако, будут отменены все
изменения в базе данных, выполненные в блоке. В качестве примера рассмотрим следующий фраг-
мент:
INSERT INTO mytab(firstname, lastname) VALUES(‘Tom’, ‘Jones’);
BEGIN
UPDATE mytab SET firstname = ‘Joe’ WHERE lastname = ‘Jones’;
x := x + 1;
y := x / 0;
EXCEPTION
WHEN division_by_zero THEN
RAISE NOTICE ‘перехватили ошибку division_by_zero’;
RETURN x;
END;
При присвоении значения переменной y произойдёт ошибка division_by_zero. Она будет пере-
хвачена в секции EXCEPTION. Оператор RETURN вернёт значение x, увеличенное на единицу, но из-
менения сделанные командой UPDATE будут отменены. Изменения, выполненные командой INSERT,
которая предшествует блоку, не будут отменены. В результате, база данных будет содержать Tom
Jones, а не Joe Jones.
Подсказка
Наличие секции EXCEPTION значительно увеличивает накладные расходы на вход/выход
из блока, поэтому не используйте EXCEPTION без надобности.
Пример 43.2. Обработка исключений для команд UPDATE/INSERT
В этом примере обработка исключений помогает выполнить либо команду UPDATE, либо INSERT, в
зависимости от ситуации. Однако в современных приложениях вместо этого приёма рекомендует-
ся использовать INSERT с ON CONFLICT DO UPDATE. Данный пример предназначен в первую очередь
для демонстрации управления выполнением PL/pgSQL:
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);
CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
<script type="math/tex">BEGIN
LOOP
-- сначала попытаться изменить запись по ключу
UPDATE db SET b = data WHERE a = key;
IF found THEN
RETURN;
END IF;
-- записи с таким ключом нет, поэтому её нужно добавить
-- если параллельно будет вставлена запись с таким же ключом,
-- произойдёт ошибка уникальности
BEGIN
1150PL/pgSQL — проце-
дурный язык SQL
INSERT INTO db(a,b) VALUES (key, data);
RETURN;
EXCEPTION WHEN unique_violation THEN
-- здесь не нужно ничего делать,
-- просто продолжить цикл, чтобы повторить UPDATE.
END;
END LOOP;
END;</script>
LANGUAGE plpgsql;
SELECT merge_db(1, ‘david’);
SELECT merge_db(1, ‘dennis’);
В этом коде предполагается, что ошибка unique_violation вызывается самой командой INSERT, а
не, скажем, внутренним оператором INSERT в функции триггера для этой таблицы. Некорректное
поведение также возможно, если в таблице будет несколько уникальных индексов; тогда операция
будет повторяться вне зависимости от того, нарушение какого индекса вызвало ошибку. Используя
средства, рассмотренные далее, можно сделать код более надёжным, проверяя, что перехвачена
именно ожидаемая ошибка.
43.6.8.1. Получение информации об ошибке
При обработке исключений часто бывает необходимым получить детальную информацию о про-
изошедшей ошибке. Для этого в PL/pgSQL есть два способа: использование специальных перемен-
ных и команда GET STACKED DIAGNOSTICS.
Внутри секции EXCEPTION специальная переменная SQLSTATE содержит код ошибки, для которой
было вызвано исключение (список возможных кодов ошибок приведён в Таблице A.1). Специальная
переменная SQLERRM содержит сообщение об ошибке, связанное с исключением. Эти переменные
являются неопределёнными вне секции EXCEPTION.
Также в обработчике исключения можно получить информацию о текущем исключении командой
GET STACKED DIAGNOSTICS, которая имеет вид:
GET STACKED DIAGNOSTICS переменная { = | := } элемент [ , … ];
Каждый элемент представляется ключевым словом, указывающим, какое значение состояния нуж-
но присвоить заданной переменной (она должна иметь подходящий тип данных, чтобы принять
его). Доступные в настоящее время элементы состояния показаны в Таблице 43.2.
Таблица 43.2. Элементы диагностики ошибок
Имя Тип Описание
RETURNED_SQLSTATE text код исключения,
мый SQLSTATE
COLUMN_NAME text имя столбца, относящегося к
исключению
CONSTRAINT_NAME text имя ограничения целостности,
относящегося к исключению
PG_DATATYPE_NAME text имя типа данных, относящегося
к исключению
MESSAGE_TEXT text текст основного сообщения ис-
ключения
TABLE_NAME text имя таблицы, относящейся к ис-
ключению
SCHEMA_NAME text имя схемы, относящейся к ис-
ключению
1151
возвращае-PL/pgSQL — проце-
дурный язык SQL
Имя Тип Описание
PG_EXCEPTION_DETAIL text текст детального сообщения ис-
ключения (если есть)
PG_EXCEPTION_HINT text текст подсказки к исключению
(если есть)
PG_EXCEPTION_CONTEXT text строки текста, описывающие
стек вызовов в момент исключе-
ния (см. Подраздел 43.6.9)
Если исключение не устанавливает значение для идентификатора, то возвращается пустая строка.
Пример:
DECLARE
text_var1 text;
text_var2 text;
text_var3 text;
BEGIN
– здесь происходит обработка, которая может вызвать исключение
…
EXCEPTION WHEN OTHERS THEN
GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
text_var2 = PG_EXCEPTION_DETAIL,
text_var3 = PG_EXCEPTION_HINT;
END;
43.6.9. Получение информации о месте выполнения
Команда GET DIAGNOSTICS, ранее описанная в Подразделе 43.5.5, получает информацию о текущем
состоянии выполнения кода (тогда как команда GET STACKED DIAGNOSTICS, рассмотренная ранее,
выдаёт информацию о состоянии выполнения в момент предыдущей ошибки). Её элемент состо-
яния PG_CONTEXT позволяет определить текущее место выполнения кода. PG_CONTEXT возвращает
текст с несколькими строками, описывающий стек вызова. В первой строке отмечается текущая
функция и выполняемая в данный момент команда GET DIAGNOSTICS, а во второй и последующих
строках отмечаются функции выше по стеку вызовов. Например:
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS <script type="math/tex">BEGIN
RETURN inner_func();
END;</script> LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS <script type="math/tex">DECLARE
stack text;
BEGIN
GET DIAGNOSTICS stack = PG_CONTEXT;
RAISE NOTICE E'--- Стек вызова ---\n%', stack;
RETURN 1;
END;</script> LANGUAGE plpgsql;
SELECT outer_func();
NOTICE: — Стек вызова —
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT: PL/pgSQL function outer_func() line 3 at RETURN
1152PL/pgSQL — проце-
дурный язык SQL
outer_func
————
1
(1 row)
GET STACKED DIAGNOSTICS … PG_EXCEPTION_CONTEXT возвращает похожий стек вызовов, но опи-
сывает не текущее место, а место, в котором произошла ошибка.
43.7. Курсоры
Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить курсор, инкапсули-
рующий запрос, и затем получать результат запроса по нескольку строк за раз. Одна из причин
так делать заключается в том, чтобы избежать переполнения памяти, когда результат содержит
большое количество строк. (Пользователям PL/pgSQL не нужно об этом беспокоиться, так как цик-
лы FOR автоматически используют курсоры, чтобы избежать проблем с памятью.) Более интерес-
ным вариантом использования является возврат из функции ссылки на курсор, что позволяет вы-
зывающему получать строки запроса. Это эффективный способ получать большие наборы строк
из функций.
43.7.1. Объявление курсорных переменных
Доступ к курсорам в PL/pgSQL осуществляется через курсорные переменные, которые всегда име-
ют специальный тип данных refcursor. Один из способов создать курсорную переменную, просто
объявить её как переменную типа refcursor. Другой способ заключается в использовании синтак-
сиса объявления курсора, который в общем виде выглядит так:
имя [ [ NO ] SCROLL ] CURSOR [ ( аргументы ) ] FOR запрос;
(Для совместимости с Oracle, FOR можно заменять на IS.) С указанием SCROLL курсор можно будет
прокручивать назад. При NO SCROLL прокрутка назад не разрешается. Если ничего не указано, то
возможность прокрутки назад зависит от запроса. Если указаны аргументы, то они должны пред-
ставлять собой пары имя тип_данных, разделённые через запятую. Эти пары определяют имена,
которые будут заменены значениями параметров в данном запросе. Фактические значения для
замены этих имён появятся позже, при открытии курсора.
Примеры:
DECLARE
curs1 refcursor;
curs2 CURSOR FOR SELECT * FROM tenk1;
curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
Все три переменные имеют тип данных refcursor. Первая может быть использована с любым за-
просом, вторая связана (bound) с полностью сформированным запросом, а последняя связана с
параметризованным запросом. (key будет заменён целочисленным значением параметра при от-
крытии курсора.) Про переменную curs1 говорят, что она является несвязанной (unbound), так как
к ней не привязан никакой запрос.
43.7.2. Открытие курсора
Прежде чем получать строки из курсора, его нужно открыть. (Это эквивалентно действию SQL-
команды DECLARE CURSOR.) В PL/pgSQL есть три формы оператора OPEN, две из которых использу-
ются для несвязанных курсорных переменных, а третья для связанных.
Примечание
Связанные курсорные переменные можно использовать с циклом FOR без явного от-
крытия курсора, как описано в Подразделе 43.7.4.
1153PL/pgSQL — проце-
дурный язык SQL
43.7.2.1. OPEN FOR запрос
OPEN несвязанная_переменная_курсора [[NO] SCROLL] FOR запрос;
Курсорная переменная открывается и получает конкретный запрос для выполнения. Курсор не
может уже быть открытым, а курсорная переменная обязана быть несвязанной (то есть просто
переменной типа refcursor). Запрос должен быть командой SELECT или любой другой, которая
возвращает строки (к примеру EXPLAIN). Запрос обрабатывается так же, как и другие команды SQL
в PL/pgSQL: имена переменных PL/pgSQL заменяются на значения, план запроса кешируется для
повторного использования. Подстановка значений переменных PL/pgSQL проводится при откры-
тии курсора командой OPEN, последующие изменения значений переменных не влияют на работу
курсора. SCROLL и NO SCROLL имеют тот же смысл, что и для связанного курсора.
Пример:
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
43.7.2.2. OPEN FOR EXECUTE
OPEN несвязанная_переменная_курсора [[NO] SCROLL] FOR EXECUTE строка_запроса
[USING выражение [, …]];
Переменная курсора открывается и получает конкретный запрос для выполнения. Курсор не мо-
жет быть уже открыт и он должен быть объявлен как несвязанная переменная курсора (то есть,
как просто переменная refcursor). Запрос задаётся строковым выражением, так же, как в команде
EXECUTE. Как обычно, это даёт возможность гибко менять план запроса от раза к разу (см. Подраз-
дел 43.11.2). Это также означает, что замена переменных происходит не в самой строке команды.
Как и с EXECUTE, значения параметров вставляются в динамическую команду, используя format()
и USING. Параметры SCROLL и NO SCROLL здесь действуют так же, как и со связанным курсором.
Пример:
OPEN curs1 FOR EXECUTE format(‘SELECT * FROM %I WHERE col1 = $1’,tabname) USING
keyvalue;
В этом примере в текст запроса вставляется имя таблицы с применением format(). Значение,
сравниваемое с col1, вставляется посредством параметра USING, так что заключать его в апостро-
фы не нужно.
43.7.2.3. Открытие связанного курсора
OPEN связанная_переменная_курсора [( [имя_аргумента :=] значение_аргумента [, …] )];
Эта форма OPEN используется для открытия курсорной переменной, которая была связана с запро-
сом при объявлении. Курсор не может уже быть открытым. Список фактических значений аргу-
ментов должен присутствовать только в том случае, если курсор объявлялся с параметрами. Эти
значения будут подставлены в запрос.
План запроса для связанного курсора всегда считается кешируемым. В этом случае, нет эквива-
лента EXECUTE. Обратите внимание, что SCROLL и NO SCROLL не могут быть указаны в этой форме
OPEN, возможность прокрутки назад была определена при объявлении курсора.
При передаче значений аргументов можно использовать позиционную или именную нотацию. В
позиционной нотации все аргументы указываются по порядку. В именной нотации имя каждого
аргумента отделяется от выражения аргумента с помощью :=. Это подобно вызову функций, опи-
санному в Разделе 4.3. Также разрешается смешивать позиционную и именную нотации.
Примеры (здесь используются ранее объявленные курсоры):
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
1154PL/pgSQL — проце-
дурный язык SQL
Так как для связанного курсора выполняется подстановка значений переменных, то, на самом
деле, существует два способа передать значения в курсор. Либо использовать явные аргументы
в OPEN, либо неявно, ссылаясь на переменные PL/pgSQL в запросе. В связанном курсоре можно
ссылаться только на те переменные, которые были объявлены до самого курсора. В любом случае,
значение переменной для подстановки в запрос будет определяться на момент выполнения OPEN.
Вот ещё один способ получить тот же результат с curs3, как в примере выше:
DECLARE
key integer;
curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
key := 42;
OPEN curs4;
43.7.3. Использование курсоров
После того как курсор будет открыт, с ним можно работать при помощи описанных здесь опера-
торов.
Работать с курсором необязательно в той же функции, где он был открыт. Из функции можно
вернуть значение с типом refcursor, что позволит вызывающему продолжить работу с курсором.
(Внутри refcursor представляет собой обычное строковое имя так называемого портала, содер-
жащего активный запрос курсора. Это имя можно передавать, присваивать другим переменным с
типом refcursor и так далее, при этом портал не нарушается.)
Все порталы неявно закрываются в конце транзакции, поэтому значение refcursor можно исполь-
зовать для ссылки на открытый курсор только до конца транзакции.
43.7.3.1. FETCH
FETCH [направление { FROM | IN }] курсор INTO цель;
FETCH извлекает следующую строку из курсора в цель. В качестве цели может быть строковая пе-
ременная, переменная типа record, или разделённый запятыми список простых переменных, как
и в SELECT INTO. Если следующей строки нет, цели присваивается NULL. Как и в SELECT INTO,
проверить, была ли получена запись, можно при помощи специальной переменной FOUND.
Здесь направление может быть любым допустимым в SQL-команде FETCH вариантом, кроме тех,
что извлекают более одной строки. А именно: NEXT, PRIOR, FIRST, LAST, ABSOLUTE число, RELATIVE
число, FORWARD или BACKWARD. Без указания направления подразумевается вариант NEXT. Везде, где
используется число, оно может определяться любым целочисленным выражением (в отличие от
SQL-команды FETCH, допускающей только целочисленные константы). Значения направления, ко-
торые требуют перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт
с указанием SCROLL.
курсор это переменная с типом refcursor, которая ссылается на открытый портал курсора.
Примеры:
FETCH
FETCH
FETCH
FETCH
curs1 INTO rowvar;
curs2 INTO foo, bar, baz;
LAST FROM curs3 INTO x, y;
RELATIVE -2 FROM curs4 INTO x;
43.7.3.2. MOVE
MOVE [направление { FROM | IN }] курсор;
MOVE перемещает курсор без извлечения данных. MOVE работает точно также как и FETCH, но при
этом только перемещает курсор и не извлекает строку, к которой переместился. Как и в SELECT
INTO, проверить успешность перемещения можно с помощью специальной переменной FOUND.
1155PL/pgSQL — проце-
дурный язык SQL
Примеры:
MOVE
MOVE
MOVE
MOVE
curs1;
LAST FROM curs3;
RELATIVE -2 FROM curs4;
FORWARD 2 FROM curs4;
43.7.3.3. UPDATE/DELETE WHERE CURRENT OF
UPDATE таблица SET … WHERE CURRENT OF курсор;
DELETE FROM таблица WHERE CURRENT OF курсор;
Когда курсор позиционирован на строку таблицы, эту строку можно изменить или удалить при по-
мощи курсора. Есть ограничения на то, каким может быть запрос курсора (в частности, не должно
быть группировок), и крайне желательно использовать указание FOR UPDATE. За дополнительными
сведениями обратитесь к странице справки DECLARE.
Пример:
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
43.7.3.4. CLOSE
CLOSE курсор;
CLOSE закрывает связанный с курсором портал. Используется для того, чтобы освободить ресурсы
раньше, чем закончится транзакция, или чтобы освободить курсорную переменную для повторно-
го открытия.
Пример:
CLOSE curs1;
43.7.3.5. Возврат курсора из функции
Курсоры можно возвращать из функции на PL/pgSQL. Это полезно, когда нужно вернуть множество
строк и столбцов, особенно если выборки очень большие. Для этого, в функции открывается кур-
сор и его имя возвращается вызывающему (или просто открывается курсор, используя указанное
имя портала, каким-либо образом известное вызывающему). Вызывающий затем может извлекать
строки из курсора. Курсор может быть закрыт вызывающим или он будет автоматически закрыт
при завершении транзакции.
Имя портала, используемое для курсора, может быть указано разработчиком или будет генериро-
ваться автоматически. Чтобы указать имя портала, нужно просто присвоить строку в переменную
refcursor перед его открытием. Значение строки переменной refcursor будет использоваться ко-
мандой OPEN как имя портала. Однако, если переменная refcursor имеет значение NULL, OPEN
автоматически генерирует имя, которое не конфликтует с любым существующим порталом и при-
сваивает его переменной refcursor.
Примечание
Связанная курсорная переменная инициализируется в строковое значение, представ-
ляющее собой имя самой переменной. Таким образом, имя портала совпадает с именем
курсорной переменной, кроме случаев, когда разработчик переопределил имя, при-
своив новое значение перед открытием курсора. Несвязанная курсорная переменная
инициализируется в NULL и получит автоматически сгенерированное уникальное имя,
если не будет переопределена.
Следующий пример показывает один из способов передачи имени курсора вызывающему:
CREATE TABLE test (col text);
INSERT INTO test VALUES (‘123’);
1156PL/pgSQL — проце-
дурный язык SQL
CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS ‘
BEGIN
OPEN $1 FOR SELECT col FROM test;
RETURN $1;
END;
‘ LANGUAGE plpgsql;
BEGIN;
SELECT reffunc(‘funccursor’);
FETCH ALL IN funccursor;
COMMIT;
В следующем примере используется автоматическая генерация имени курсора:
CREATE FUNCTION reffunc2() RETURNS refcursor AS ‘
DECLARE
ref refcursor;
BEGIN
OPEN ref FOR SELECT col FROM test;
RETURN ref;
END;
‘ LANGUAGE plpgsql;
– для использования курсоров, необходимо начать транзакцию
BEGIN;
SELECT reffunc2();
reffunc2
——————–</p>
</blockquote>
<p>&lt;unnamed cursor 1&gt;
(1 row)
FETCH ALL IN “&lt;unnamed cursor 1&gt;”;
COMMIT;
В следующем примере показан один из способов вернуть несколько курсоров из одной функции:
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS <script type="math/tex">BEGIN
OPEN $1 FOR SELECT * FROM table_1;
RETURN NEXT $1;
OPEN $2 FOR SELECT * FROM table_2;
RETURN NEXT $2;
END;</script> LANGUAGE plpgsql;
– для использования курсоров необходимо начать транзакцию
BEGIN;
SELECT * FROM myfunc(‘a’, ‘b’);
FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
43.7.4. Обработка курсора в цикле
Один из вариантов цикла FOR позволяет перебирать строки, возвращённые курсором. Вот его син-
таксис:
1157PL/pgSQL — проце-
дурный язык SQL
[ «метка» ]
FOR переменная-запись IN связанная_переменная_курсора [ ( [ имя_аргумента
:= ] значение_аргумента [, …] ) ] LOOP
операторы
END LOOP [ метка ];
Курсорная переменная должна быть связана с запросом при объявлении. Курсор не может быть
открытым. Команда FOR автоматически открывает курсор и автоматически закрывает при завер-
шении цикла. Список фактических значений аргументов должен присутствовать только в том слу-
чае, если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос, также как
и при выполнении OPEN (см. Подраздел 43.7.2.3).
Данная переменная-запись автоматически определяется как переменная типа record и существу-
ет только внутри цикла (другие объявленные переменные с таким именем игнорируется в цикле).
Каждая возвращаемая курсором строка последовательно присваивается этой переменной и вы-
полняется тело цикла.
43.8. Управление транзакциями
В процедурах, вызываемых командой CALL, а также в анонимных блоках кода (в команде DO) мож-
но завершать транзакции, выполняя COMMIT и ROLLBACK. После завершения транзакции этими ко-
мандами новая будет начата автоматически, поэтому отдельной команды START TRANSACTION нет.
(Заметьте, что команды BEGIN и END в PL/pgSQL имеют другой смысл.)
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS <script type="math/tex">BEGIN
FOR i IN 0..9 LOOP
INSERT INTO test1 (a) VALUES (i);
IF i % 2 = 0 THEN
COMMIT;
ELSE
ROLLBACK;
END IF;
END LOOP;
END</script>;
CALL transaction_test1();
Управление транзакциями возможно только в вызовах CALL или DO в коде верхнего уровня или
во вложенных CALL или DO без других промежуточных команд. Например, в стеке вызовов CALL
proc1() → CALL proc2() → CALL proc3() вторая и третья процедуры могут управлять транзакциями.
Но в стеке CALL proc1() → SELECT func2() → CALL proc3() последняя процедура лишена этой
возможности из-за промежуточного SELECT.
Циклам с курсорами присущи некоторые особенности. Рассмотрите этот пример:
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS <script type="math/tex">DECLARE
r RECORD;
BEGIN
FOR r IN SELECT * FROM test2 ORDER BY x LOOP
INSERT INTO test1 (a) VALUES (r.x);
1158PL/pgSQL — проце-
дурный язык SQL
COMMIT;
END LOOP;
END;</script>;
CALL transaction_test2();
Обычно курсоры автоматически закрываются при фиксировании транзакции. Однако курсор, со-
здаваемый внутри цикла подобным образом, автоматически преобразуется в удерживаемый кур-
сор первой командой COMMIT или ROLLBACK. Это означает, что курсор полностью вычисляется при
выполнении первой команды COMMIT или ROLLBACK, а не для каждой очередной строки. При этом он
автоматически удаляется после цикла, так что это происходит практически незаметно для поль-
зователя.
Команды управления транзакциями не допускаются в циклах с курсором, которыми управляют
запросы, производящие не только чтение, но и модификацию данных (например, UPDATE …
RETURNING).
Транзакция не может завершаться внутри блока с обработчиками исключений.
43.9. Сообщения и ошибки
43.9.1. Вывод сообщений и ошибок
Команда RAISE предназначена для вывода сообщений и вызова ошибок.
RAISE [
[, …
RAISE [
RAISE [
RAISE [
RAISE ;
уровень
] ];
уровень
уровень
уровень
] ‘формат’ [, выражение [, … ]] [ USING параметр = значение
] имя_условия [ USING параметр = выражение [, … ] ];
] SQLSTATE ‘sqlstate’ [ USING параметр = выражение [, … ] ];
] USING параметр = выражение [, … ];
уровень задаёт уровень важности ошибки. Возможные значения: DEBUG, LOG, INFO, NOTICE, WARNING
и EXCEPTION. По умолчанию используется EXCEPTION. EXCEPTION вызывает ошибку (что обычно пре-
рывает текущую транзакцию), остальные значения уровня только генерируют сообщения с раз-
личными уровнями приоритета. Будут ли сообщения конкретного приоритета переданы клиенту
или записаны в журнал сервера, или и то, и другое, зависит от конфигурационных переменных
log_min_messages и client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
После указания уровня, если оно есть, можно задать формат (это должна быть простая строковая
константа, не выражение). Строка формата определяет вид текста об ошибке, который будет вы-
дан. За строкой формата могут следовать необязательные выражения аргументов, которые будут
вставлены в сообщение. Внутри строки формата знак % заменяется строковым представлением
значения очередного аргумента. Чтобы выдать символ % буквально, продублируйте его (как %%).
Число аргументов должно совпадать с числом местозаполнителей % в строке формата, иначе при
компиляции функции возникнет ошибка.
В следующем примере символ % будет заменён на значение v_job_id:
RAISE NOTICE ‘Вызов функции cs_create_job(%)’, v_job_id;
При помощи USING и последующих элементов параметр = выражение можно добавить дополнитель-
ную информацию к отчёту об ошибке. Все выражения представляют собой строковые выражения.
Возможные ключевые слова для параметра следующие:
MESSAGE
Устанавливает текст сообщения об ошибке. Этот параметр не может использоваться, если в
команде RAISE присутствует формат перед USING.
1159PL/pgSQL — проце-
дурный язык SQL
DETAIL
Предоставляет детальное сообщение об ошибке.
HINT
Предоставляет подсказку по вызванной ошибке.
ERRCODE
Устанавливает код ошибки (SQLSTATE). Код ошибки задаётся либо по имени, как показано в
Приложении A, или напрямую, пятисимвольный код SQLSTATE.
COLUMN
CONSTRAINT
DATATYPE
TABLE
SCHEMA
Предоставляет имя соответствующего объекта, связанного с ошибкой.
Этот пример прерывает транзакцию и устанавливает сообщение об ошибке с подсказкой:
RAISE EXCEPTION ‘Несуществующий ID –&gt; %’, user_id
USING HINT = ‘Проверьте ваш пользовательский ID’;
Следующие два примера демонстрируют эквивалентные способы задания SQLSTATE:
RAISE ‘Duplicate user ID: %’, user_id USING ERRCODE = ‘unique_violation’;
RAISE ‘Duplicate user ID: %’, user_id USING ERRCODE = ‘23505’;
У команды RAISE есть и другой синтаксис, в котором в качестве главного аргумента используется
имя или код SQLSTATE ошибки. Например:
RAISE division_by_zero;
RAISE SQLSTATE ‘22012’;
Предложение USING в этом синтаксисе можно использовать для того, чтобы переопределить стан-
дартное сообщение об ошибке, детальное сообщение, подсказку. Ещё один вариант предыдущего
примера:
RAISE unique_violation USING MESSAGE = ‘ID пользователя уже существует: ‘ || user_id;
Ещё один вариант — использовать RAISE USING или RAISE уровень USING, а всё остальное записать
в списке USING.
И заключительный вариант, в котором RAISE не имеет параметров вообще. Эта форма может ис-
пользоваться только в секции EXCEPTION блока и предназначена для того, чтобы повторно вызвать
ошибку, которая сейчас перехвачена и обрабатывается.
Примечание
До версии PostgreSQL 9.1 команда RAISE без параметров всегда вызывала ошибку с
выходом из блока, содержащего активную секцию EXCEPTION. Эту ошибку нельзя было
перехватить, даже если RAISE в секции EXCEPTION поместить во вложенный блок со
своей секцией EXCEPTION. Это было сочтено удивительным и не совместимым с Oracle
PL/SQL.
Если в команде RAISE EXCEPTION не задано ни имя, ни SQLSTATE код, то по умолчанию используются
RAISE_EXCEPTION (P0001). В качестве текста сообщения об ошибке (если не задан) используется
имя или SQLSTATE код.
1160PL/pgSQL — проце-
дурный язык SQL
Примечание
При задании SQLSTATE кода необязательно использовать только список предопределён-
ных кодов ошибок. В качестве кода ошибки может быть любое пятисимвольное значе-
ние, состоящее из цифр и/или ASCII символов в верхнем регистре, кроме 00000. Не ре-
комендуется использовать коды ошибок, которые заканчиваются на 000, потому что
так обозначаются коды категорий. И чтобы их перехватить, нужно перехватывать це-
лую категорию.
43.9.2. Проверка утверждений
Оператор ASSERT представляет удобное средство вставлять отладочные проверки в функции PL/
pgSQL.
ASSERT условие [ , сообщение ];
Здесь условие — это булевское выражение, которое, как ожидается, должно быть всегда истин-
ным; если это так, оператор ASSERT больше ничего не делает. Если же оно возвращает ложь или
NULL, этот оператор выдаёт исключение ASSERT_FAILURE. (Если ошибка происходит при вычисле-
нии условия, она выдаётся как обычная ошибка.)
Если в нём задаётся необязательное сообщение, результат этого выражения (если он не NULL) за-
меняет сообщение об ошибке по умолчанию «assertion failed» (нарушение истинности), в случае,
если условие не выполняется. В обычном случае, когда условие утверждения выполняется, выра-
жение сообщения не вычисляется.
Проверку утверждений можно включить или отключить с помощью конфигурационного парамет-
ра plpgsql.check_asserts, принимающего булевское значение; по умолчанию она включена (on).
Если этот параметр отключён (off), операторы ASSERT ничего не делают.
Учтите, что оператор ASSERT предназначен для выявления программных дефектов, а не для вывода
обычных ошибок (для этого используется оператор RAISE, описанный выше).
43.10. Триггерные функции
В PL/pgSQL можно создавать триггерные функции, которые будут вызываться при изменениях
данных или событиях в базе данных. Триггерная функция создаётся командой CREATE FUNCTION,
при этом у функции не должно быть аргументов, а типом возвращаемого значения должен быть
trigger (для триггеров, срабатывающих при изменениях данных) или event_trigger (для тригге-
ров, срабатывающих при событиях в базе). Для триггеров автоматически определяются специаль-
ные локальные переменные с именами вида TG_имя, описывающие условие, повлёкшее вызов триг-
гера.
43.10.1. Триггеры при изменении данных
Триггер при изменении данных объявляется как функция без аргументов и с типом результата
trigger. Заметьте, что эта функция должна объявляться без аргументов, даже если ожидается,
что она будет получать аргументы, заданные в команде CREATE TRIGGER — такие аргументы пере-
даются через TG_ARGV, как описано ниже.
Когда функция на PL/pgSQL срабатывает как триггер, в блоке верхнего уровня автоматически со-
здаются несколько специальных переменных:
NEW
Тип данных RECORD. Переменная содержит новую строку базы данных для команд INSERT/UPDATE
в триггерах уровня строки. В триггерах уровня оператора и для команды DELETE этой перемен-
ной значение не присваивается.
1161PL/pgSQL — проце-
дурный язык SQL
OLD
Тип данных RECORD. Переменная содержит старую строку базы данных для команд UPDATE/
DELETE в триггерах уровня строки. В триггерах уровня оператора и для команды INSERT этой
переменной значение не присваивается.
TG_NAME
Тип данных name. Переменная содержит имя сработавшего триггера.
TG_WHEN
Тип данных text. Строка, содержащая BEFORE, AFTER или INSTEAD OF, в зависимости от опреде-
ления триггера.
TG_LEVEL
Тип данных text. Строка, содержащая ROW или STATEMENT, в зависимости от определения триг-
гера.
TG_OP
Тип данных text. Строка, содержащая INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от
того, для какой операции сработал триггер.
TG_RELID
Тип данных oid. OID таблицы, для которой сработал триггер.
TG_RELNAME
Тип данных name. Имя таблицы, для которой сработал триггер. Эта переменная устарела и мо-
жет стать недоступной в будущих релизах. Вместо неё нужно использовать TG_TABLE_NAME.
TG_TABLE_NAME
Тип данных name. Имя таблицы, для которой сработал триггер.
TG_TABLE_SCHEMA
Тип данных name. Имя схемы, содержащей таблицу, для которой сработал триггер.
TG_NARGS
Тип данных integer. Число аргументов в команде CREATE TRIGGER, которые передаются в триг-
герную функцию.
TG_ARGV[]
Тип данных массив text. Аргументы от оператора CREATE TRIGGER. Индекс массива начинается
с 0. Для недопустимых значений индекса ( &lt; 0 или &gt;= tg_nargs) возвращается NULL.
Триггерная функция должна вернуть либо NULL, либо запись/строку, соответствующую структуре
таблице, для которой сработал триггер.
Если BEFORE триггер уровня строки возвращает NULL, то все дальнейшие действия с этой строкой
прекращаются (т. е. не срабатывают последующие триггеры, команда INSERT/UPDATE/DELETE для
этой строки не выполняется). Если возвращается не NULL, то дальнейшая обработка продолжается
именно с этой строкой. Возвращение строки отличной от начальной NEW, изменяет строку, которая
будет вставлена или изменена. Поэтому, если в триггерной функции нужно выполнить некоторые
действия и не менять саму строку, то нужно возвратить переменную NEW (или её эквивалент). Для
того чтобы изменить сохраняемую строку, можно поменять отдельные значения в переменной NEW
и затем её вернуть. Либо создать и вернуть полностью новую переменную. В случае строчного
триггера BEFORE для команды DELETE само возвращаемое значение не имеет прямого эффекта, но
оно должно быть отличным от NULL, чтобы не прерывать обработку строки. Обратите внимание,
что переменная NEW всегда NULL в триггерах на DELETE, поэтому возвращать её не имеет смысла.
Традиционной идиомой для триггеров DELETE является возврат переменной OLD.
1162PL/pgSQL — проце-
дурный язык SQL
Триггеры INSTEAD OF (это всегда триггеры уровня строк и они могут применяться только с пред-
ставлениями) могут возвращать NULL, чтобы показать, что они не выполняли никаких изменений,
так что обработку этой строки можно не продолжать (то есть, не вызывать последующие триггеры
и не считать строку в числе обработанных строк для окружающих команд INSERT/UPDATE/DELETE).
В противном случае должно быть возвращено значение, отличное от NULL, показывающее, что
триггер выполнил запрошенную операцию. Для операций INSERT и UPDATE возвращаемым значе-
нием должно быть NEW, которое триггерная функция может модифицировать для поддержки пред-
ложений INSERT RETURNING и UPDATE RETURNING (это также повлияет на значение строки, переда-
ваемое последующим триггерам, или доступное под специальным псевдонимом EXCLUDED в опера-
торе INSERT с предложением ON CONFLICT DO UPDATE). Для операций DELETE возвращаемым значе-
нием должно быть OLD.
Возвращаемое значение для строчного триггера AFTER и триггеров уровня оператора (BEFORE
или AFTER) всегда игнорируется. Это может быть и NULL. Однако, в этих триггерах по-прежнему
можно прервать вызвавшую их команду, для этого нужно явно вызвать ошибку.
Пример 43.3 показывает пример триггерной функции в PL/pgSQL.
Пример 43.3. Триггерная функция на PL/pgSQL
Триггер, показанный в этом примере, при любом добавлении или изменении строки в таблице
сохраняет в этой строке информацию о текущем пользователе и отметку времени. Кроме того, он
требует, чтобы было указано имя сотрудника и зарплата задавалась положительным числом.
CREATE TABLE emp (
empname text,
salary integer,
last_date timestamp,
last_user text
);
CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
BEGIN
– Проверить, что указаны имя сотрудника и зарплата
IF NEW.empname IS NULL THEN
RAISE EXCEPTION ‘empname cannot be null’;
END IF;
IF NEW.salary IS NULL THEN
RAISE EXCEPTION ‘% cannot have null salary’, NEW.empname;
END IF;
– Кто будет работать, если за это надо будет платить?
IF NEW.salary &lt; 0 THEN
RAISE EXCEPTION ‘% cannot have a negative salary’, NEW.empname;
END IF;
– Запомнить, кто и когда изменил запись
NEW.last_date := current_timestamp;
NEW.last_user := current_user;
RETURN NEW;
END;
$emp_stamp$ LANGUAGE plpgsql;
CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW EXECUTE FUNCTION emp_stamp();
Другой вариант ведения журнала изменений для таблицы предполагает создание новой таблицы,
которая будет содержать отдельную запись для каждой выполненной команды INSERT, UPDATE,
1163PL/pgSQL — проце-
дурный язык SQL
DELETE. Этот подход можно рассматривать как протоколирование изменений таблицы для аудита.
Пример 43.4 показывает реализацию соответствующей триггерной функции в PL/pgSQL.
Пример 43.4. Триггерная функция для аудита в PL/pgSQL
Показанный в этом примере триггер гарантирует, что любое добавление, изменение или удаление
строки в таблице emp будет зафиксировано в таблице emp_audit (для аудита). Также он фиксирует
текущее время, имя пользователя и тип выполняемой операции.
CREATE TABLE emp (
empname
salary
);
text NOT NULL,
integer
CREATE TABLE emp_audit(
operation
char(1)
stamp
timestamp
userid
text
empname
text
salary integer
);
NOT
NOT
NOT
NOT
NULL,
NULL,
NULL,
NULL,
CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
BEGIN
–
– Добавление строки в emp_audit, которая отражает операцию, выполняемую в emp;
– для определения типа операции применяется специальная переменная TG_OP.
–
IF (TG_OP = ‘DELETE’) THEN
INSERT INTO emp_audit SELECT ‘D’, now(), user, OLD.<em>;
ELSIF (TG_OP = ‘UPDATE’) THEN
INSERT INTO emp_audit SELECT ‘U’, now(), user, NEW.</em>;
ELSIF (TG_OP = ‘INSERT’) THEN
INSERT INTO emp_audit SELECT ‘I’, now(), user, NEW.*;
END IF;
RETURN NULL; – возвращаемое значение для триггера AFTER игнорируется
END;
$emp_audit$ LANGUAGE plpgsql;
CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
У предыдущего примера есть разновидность, которая использует представление, соединяющее ос-
новную таблицу и таблицу аудита, для отображения даты последнего изменения каждой строки.
При этом подходе по-прежнему ведётся полный журнал аудита в отдельной таблице, но также
имеется представление с упрощенным аудиторским следом. Это представление содержит времен-
ную метку, которая вычисляется для каждой строки из данных аудиторской таблицы. Пример 43.5
показывает пример триггера на представление для аудита в PL/pgSQL.
Пример 43.5. Триггерная функция на PL/pgSQL для аудита в представлении
В этом примере триггер, связанный с представлением, делает это представление изменяемым и
гарантирует, что любая команда на добавление, изменение или удаление строки в представлении
будет записана для аудита в таблицу emp_audit. Также записываются временная метка, имя поль-
зователя и тип выполняемой операции. Представление показывает дату последнего изменения
для каждой строки.
CREATE TABLE emp (
empname
salary
text PRIMARY KEY,
integer
1164PL/pgSQL — проце-
дурный язык SQL
);
CREATE TABLE emp_audit(
operation
char(1)
userid
text
empname
text
salary
integer,
stamp
timestamp
);
NOT NULL,
NOT NULL,
NOT NULL,
NOT NULL
CREATE VIEW emp_view AS
SELECT e.empname,
e.salary,
max(ea.stamp) AS last_updated
FROM emp e
LEFT JOIN emp_audit ea ON ea.empname = e.empname
GROUP BY 1, 2;
CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS <script type="math/tex">BEGIN
--
-- Выполнить требуемую операцию в emp и добавить в emp_audit строку,
-- отражающую эту операцию.
--
IF (TG_OP = 'DELETE') THEN
DELETE FROM emp WHERE empname = OLD.empname;
IF NOT FOUND THEN RETURN NULL; END IF;
OLD.last_updated = now();
INSERT INTO emp_audit VALUES('D', user, OLD.*);
RETURN OLD;
ELSIF (TG_OP = 'UPDATE') THEN
UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
IF NOT FOUND THEN RETURN NULL; END IF;
NEW.last_updated = now();
INSERT INTO emp_audit VALUES('U', user, NEW.*);
RETURN NEW;
ELSIF (TG_OP = 'INSERT') THEN
INSERT INTO emp VALUES(NEW.empname, NEW.salary);
NEW.last_updated = now();
INSERT INTO emp_audit VALUES('I', user, NEW.*);
RETURN NEW;
END IF;
END;</script> LANGUAGE plpgsql;
CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
FOR EACH ROW EXECUTE FUNCTION update_emp_view();
Один из вариантов использования триггеров это поддержание в актуальном состоянии отдельной
таблицы итогов для некоторой таблицы. В некоторых случаях отдельная таблица с итогами мо-
жет использоваться в запросах вместо основной таблицы. При этом зачастую время выполнения
запросов значительно сокращается. Эта техника широко используется в хранилищах данных, где
таблицы фактов могут быть очень большими. Пример 43.6 демонстрирует триггерную функцию на
PL/pgSQL, которая поддерживает таблицу итогов для таблицы фактов в хранилище данных.
1165PL/pgSQL — проце-
дурный язык SQL
Пример 43.6. Триггерная функция на PL/pgSQL для ведения таблицы итогов
Представленная здесь схема данных частично основана на примере Grocery Store из книги The
Data Warehouse Toolkit (автор Ralph Kimball).
–
– Основные таблицы: таблица временных периодов и таблица фактов продаж
–
CREATE TABLE time_dimension (
time_key
integer NOT NULL,
day_of_week
integer NOT NULL,
day_of_month
integer NOT NULL,
month
integer NOT NULL,
quarter
integer NOT NULL,
year
integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);
CREATE TABLE sales_fact (
time_key
product_key
store_key
amount_sold
units_sold
amount_cost
);
CREATE INDEX sales_fact_time ON
integer NOT NULL,
integer NOT NULL,
integer NOT NULL,
numeric(12,2) NOT NULL,
integer NOT NULL,
numeric(12,2) NOT NULL
sales_fact(time_key);
–
– Таблица с итогами продаж по периодам
–
CREATE TABLE sales_summary_bytime (
time_key
integer NOT NULL,
amount_sold
numeric(15,2) NOT NULL,
units_sold
numeric(12) NOT NULL,
amount_cost
numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);
–
– Функция и триггер для пересчёта столбцов итогов при выполнении
– команд INSERT, UPDATE, DELETE
–
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
DECLARE
delta_time_key
integer;
delta_amount_sold
numeric(15,2);
delta_units_sold
numeric(12);
delta_amount_cost
numeric(15,2);
BEGIN
– Вычислить изменение количества/суммы.
IF (TG_OP = ‘DELETE’) THEN
delta_time_key = OLD.time_key;
delta_amount_sold = -1 * OLD.amount_sold;
delta_units_sold = -1 * OLD.units_sold;
delta_amount_cost = -1 * OLD.amount_cost;
1166PL/pgSQL — проце-
дурный язык SQL
ELSIF (TG_OP = ‘UPDATE’) THEN
–
–
–
IF
Запретить изменение time_key -
(это ограничение не должно вызвать неудобств, так как
в основном изменения будут выполняться по схеме DELETE + INSERT).
( OLD.time_key != NEW.time_key) THEN
RAISE EXCEPTION ‘Update of time_key : % -&gt; % not allowed’,
OLD.time_key, NEW.time_key;
END IF;
delta_time_key = OLD.time_key;
delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
delta_units_sold = NEW.units_sold - OLD.units_sold;
delta_amount_cost = NEW.amount_cost - OLD.amount_cost;
ELSIF (TG_OP = ‘INSERT’) THEN
delta_time_key = NEW.time_key;
delta_amount_sold = NEW.amount_sold;
delta_units_sold = NEW.units_sold;
delta_amount_cost = NEW.amount_cost;
END IF;
– Внести новые значения в существующую строку итогов или
– добавить новую.
«insert_update»
LOOP
UPDATE sales_summary_bytime
SET amount_sold = amount_sold + delta_amount_sold,
units_sold = units_sold + delta_units_sold,
amount_cost = amount_cost + delta_amount_cost
WHERE time_key = delta_time_key;
EXIT insert_update WHEN found;
BEGIN
INSERT INTO sales_summary_bytime (
time_key,
amount_sold,
units_sold,
amount_cost)
VALUES (
delta_time_key,
delta_amount_sold,
delta_units_sold,
delta_amount_cost
);
EXIT insert_update;
EXCEPTION
WHEN UNIQUE_VIOLATION THEN
– ничего не делать
END;
END LOOP insert_update;
1167PL/pgSQL — проце-
дурный язык SQL
RETURN NULL;
END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;
CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();
INSERT
INSERT
INSERT
INSERT
SELECT
DELETE
SELECT
UPDATE
SELECT
INTO sales_fact VALUES(1,1,1,10,3,15);
INTO sales_fact VALUES(1,2,1,20,5,35);
INTO sales_fact VALUES(2,2,1,40,15,135);
INTO sales_fact VALUES(2,3,1,10,1,13);</p>
<ul>
  <li>FROM sales_summary_bytime;
FROM sales_fact WHERE product_key = 1;</li>
  <li>FROM sales_summary_bytime;
sales_fact SET units_sold = units_sold * 2;</li>
  <li>FROM sales_summary_bytime;
Триггеры AFTER также могут использовать переходные таблицы для просмотра всего набора
строк, изменённых оператором, вызвавшим триггер. Команда CREATE TRIGGER назначает имена
одной или обеим переходным таблицам, а затем функция может по этим именам обращаться к ним
как к временным таблицам только для чтения. Это иллюстрирует Пример 43.7.
Пример 43.7. Организация аудита с переходными таблицами
В данном примере достигается тот же результат, что и в Пример 43.4, но вместо триггера, сраба-
тывающего для каждой строки, в нём используется триггер, срабатывающий единожды для опера-
тора и получающий нужные ему данные в переходной таблице. Это может быть гораздо быстрее,
чем вариант с построчным триггером, когда целевой оператор изменяет сразу множество строк.
Заметьте, что мы должны объявить отдельные триггеры для каждого вида события, так как предло-
жения REFERENCING в каждом случае будут разными. Но это не мешает при желании использовать
одну триггерную функцию. (На практике может быть лучше использовать три отдельные функции
и не проверять TG_OP во время выполнения.)
CREATE TABLE emp (
empname
salary
);
text NOT NULL,
integer
CREATE TABLE emp_audit(
operation
char(1)
stamp
timestamp
userid
text
empname
text
salary integer
);
NOT
NOT
NOT
NOT
NULL,
NULL,
NULL,
NULL,
CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
BEGIN
–
– Добавление строк в emp_audit, которые отражают операции, выполняемые в emp;
– для определения типа операций применяется специальная переменная TG_OP.
–
IF (TG_OP = ‘DELETE’) THEN
INSERT INTO emp_audit
SELECT ‘D’, now(), user, o.* FROM old_table o;
1168PL/pgSQL — проце-
дурный язык SQL
ELSIF (TG_OP = ‘UPDATE’) THEN
INSERT INTO emp_audit
SELECT ‘U’, now(), user, n.* FROM new_table n;
ELSIF (TG_OP = ‘INSERT’) THEN
INSERT INTO emp_audit
SELECT ‘I’, now(), user, n.* FROM new_table n;
END IF;
RETURN NULL; – возвращаемое значение для триггера AFTER игнорируется
END;
$emp_audit$ LANGUAGE plpgsql;
CREATE TRIGGER emp_audit_ins
AFTER INSERT ON emp
REFERENCING NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
AFTER UPDATE ON emp
REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
AFTER DELETE ON emp
REFERENCING OLD TABLE AS old_table
FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
43.10.2. Триггеры событий
В PL/pgSQL можно создавать событийные триггеры. PostgreSQL требует, чтобы функция, которая
вызывается как событийный триггер, объявлялась без аргументов и типом возвращаемого значе-
ния был event_trigger.
Когда функция на PL/pgSQL вызывается как событийный триггер, в блоке верхнего уровня авто-
матически создаются несколько специальных переменных:
TG_EVENT
Тип данных text. Строка, содержащая событие, для которого сработал триггер.
TG_TAG
Тип данных text. Переменная, содержащая тег команды, для которой сработал триггер.
Пример 43.8 демонстрирует реализацию функции событийного триггера на PL/pgSQL.
Пример 43.8. Функция событийного триггера на PL/pgSQL
Триггер в этом примере просто выдаёт сообщение NOTICE каждый раз, когда выполняется поддер-
живаемая команда.
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS <script type="math/tex">BEGIN
RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;</script> LANGUAGE plpgsql;
CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
43.11. PL/pgSQL изнутри
В этом разделе обсуждаются некоторые детали реализации, которые пользователям PL/pgSQL
важно знать.
1169PL/pgSQL — проце-
дурный язык SQL
43.11.1. Подстановка переменных
SQL-операторы и выражения внутри функции на PL/pgSQL могут ссылаться на переменные и пара-
метры этой функции. За кулисами PL/pgSQL заменяет параметры запросов для таких ссылок. Па-
раметры будут заменены только в местах, где параметр или ссылка на столбец синтаксически до-
пустимы. Как крайний случай, рассмотрим следующий пример плохого стиля программирования:
INSERT INTO foo (foo) VALUES (foo);
Первый раз foo появляется на том месте, где синтаксически должно быть имя таблицы, поэтому
замены не будет, даже если функция имеет переменную foo. Второй раз foo встречается там, где
должно быть имя столбца таблицы, поэтому замены не будет и здесь. Только третье вхождение foo
является кандидатом на то, чтобы быть ссылкой на переменную функции.
Примечание
Версии PostgreSQL до 9.0 пытаются заменить переменную во всех трёх случаях, что
приводит к синтаксической ошибке.
Если имена переменных синтаксически не отличаются от названий столбцов таблицы, то возмож-
на двусмысленность и в ссылках на таблицы. Является ли данное имя ссылкой на столбец таблицы
или ссылкой на переменную? Изменим предыдущий пример:
INSERT INTO dest (col) SELECT foo + bar FROM src;
Здесь dest и src должны быть именами таблиц, col должен быть столбцом dest. Однако, foo и bar
могут быть как переменными функции, так и столбцами src.
По умолчанию, PL/pgSQL выдаст ошибку, если имя в операторе SQL может относиться как к пере-
менной, так и к столбцу таблицы. Ситуацию можно исправить переименованием переменной, пе-
реименованием столбца, точной квалификацией неоднозначной ссылки или указанием PL/pgSQL
машине, какую интерпретацию предпочесть.
Самое простое решение — переименовать переменную или столбец. Общее правило кодирования
предполагает использование различных соглашений о наименовании для переменных PL/pgSQL
и столбцов таблиц. Например, если имена переменных всегда имеют вид v_имя, а имена столбцов
никогда не начинаются на v_, то конфликты исключены.
В качестве альтернативы можно дополнить имена неоднозначных ссылок, чтобы сделать их точ-
ными. В приведённом выше примере src.foo однозначно бы определялась, как ссылка на столбец
таблицы. Чтобы сделать однозначной ссылку на переменную, переменная должна быть объявлена
в блоке с меткой, и далее нужно использовать эту метку (см. Раздел 43.2). Например:
«block»
DECLARE
foo int;
BEGIN
foo := …;
INSERT INTO dest (col) SELECT block.foo + bar FROM src;
Здесь block.foo ссылается на переменную, даже если в таблице src есть столбец foo. Парамет-
ры функции, а также специальные переменные, такие как FOUND, могут быть дополнены именем
функции, потому что они неявно объявлены во внешнем блоке, метка которого совпадает с именем
функции.
Иногда может быть не очень практичным исправлять таким способом все неоднозначные ссылки
в большом куске PL/pgSQL кода. В таких случаях можно указать, чтобы PL/pgSQL разрешал неод-
нозначные ссылки в пользу переменных (это совместимо с PL/pgSQL до версии PostgreSQL 9.0),
или в пользу столбцов таблицы (совместимо с некоторыми другими системами, такими как Oracle).
1170PL/pgSQL — проце-
дурный язык SQL
На уровне всей системы поведение PL/pgSQL регулируется установкой конфигурационного па-
раметра plpgsql.variable_conflict, имеющего значения: error, use_variable или use_column
(error устанавливается по умолчанию при установке системы). Изменение этого параметра вли-
яет на все последующие компиляции операторов в функциях на PL/pgSQL, но не на операторы
уже скомпилированные в текущей сессии. Так как изменение этого параметра может привести
к неожиданным изменениям в поведении функций на PL/pgSQL, он может быть изменён только
суперпользователем.
Поведение PL/pgSQL можно изменять для каждой отдельной функции, если добавить в начало
функции одну из этих специальных команд:
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
Эти команды влияют только на функцию, в которой они записаны и перекрывают действие
plpgsql.variable_conflict. Пример:
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS <script type="math/tex">#variable_conflict use_variable
DECLARE
curtime timestamp := now();
BEGIN
UPDATE users SET last_modified = curtime, comment = comment
WHERE users.id = id;
END;</script> LANGUAGE plpgsql;
В команде UPDATE, curtime, comment и id будут ссылаться на переменные и параметры функции вне
зависимости от того, есть ли столбцы с такими именами в таблице users. Обратите внимание, что
нужно дополнить именем таблицы ссылку на users.id в предложении WHERE, чтобы она ссылалась
на столбец таблицы. При этом необязательно дополнять ссылку на comment в левой части списка
UPDATE, так как синтаксически в этом месте должно быть имя столбца таблицы users. Эту функцию
можно было бы записать и без зависимости от значения variable_conflict:
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS <script type="math/tex">% <![CDATA[
<<fn>>
DECLARE
curtime timestamp := now();
BEGIN
UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
WHERE users.id = stamp_user.id;
END; %]]></script> LANGUAGE plpgsql;
Замена переменных не происходит в строке, исполняемой командой EXECUTE или её вариантом.
Если нужно вставлять изменяющиеся значения в такую команду, то это делается либо при постро-
ении самой командной строки или с использованием USING, как показано в Подразделе 43.5.4.
Замена переменных в настоящее время работает только в командах SELECT, INSERT, UPDATE и
DELETE, потому что основная SQL машина допускает использование параметров запроса только в
этих командах. Чтобы использовать изменяемые имена или значения в других типах операторов
(обычно называются утилиты), необходимо построить текст команды в виде строки и выполнить
её в EXECUTE.
43.11.2. Кеширование плана
Интерпретатор PL/pgSQL анализирует исходный текст функции и строит внутреннее бинарное де-
рево инструкций при первом вызове функции (для каждой сессии). В дерево инструкций полностью
переводится вся структура операторов PL/pgSQL, но для выражений и команд SQL, используемых
в функции, это происходит не сразу.
1171PL/pgSQL — проце-
дурный язык SQL
При первом выполнении в функции каждого выражения или команды SQL интерпретатор PL/
pgSQL разбирает и анализирует команду для создания подготовленного к выполнению оператора с
помощью функции SPI_prepare менеджера интерфейса программирования сервера. Последующие
обращения к этому выражению или команде повторно используют подготовленный к выполнению
оператор. Таким образом, SQL-команды, находящиеся в редко посещаемой ветке кода условного
оператора, не несут накладных расходов на разбор команд, если они так и не будут выполнены в
текущей сессии. Здесь есть недостаток, заключающийся в том, что ошибки в определённом выра-
жении или команде не могут быть обнаружены, пока выполнение не дойдёт до этой части функции.
(Тривиальные синтаксические ошибки обнаружатся в ходе первоначального разбора, но ничего
более серьёзного не будет обнаружено до исполнения.)
Кроме того, PL/pgSQL (точнее, менеджер интерфейса программирования сервера) будет пытаться
кешировать план выполнения для любого подготовленного к исполнению оператора. При каждом
вызове оператора, если не используется план из кеша, генерируется новый план выполнения, и
текущие значения параметров (то есть значения переменных PL/pgSQL) могут быть использованы
для оптимизации нового плана. Если оператор не имеет параметров или выполняется много раз,
менеджер интерфейса программирования сервера рассмотрит вопрос о создании и кешировании
(для повторного использования) общего плана, не зависящего от значений параметров. Как пра-
вило, это происходит в тех случаях, когда план выполнения не очень чувствителен к имеющим-
ся ссылкам на значения переменных PL/pgSQL. В противном случае, выгоднее каждый раз фор-
мировать новый план. Более подробно поведение подготовленных операторов рассматривается в
PREPARE.
Чтобы PL/pgSQL мог сохранять подготовленные операторы и планы выполнения, команды SQL в
коде PL/pgSQL, должны использовать одни и те же таблицы и столбцы при каждом исполнении.
А это значит, что в SQL-командах нельзя использовать названия таблиц и столбцов в качестве па-
раметров. Чтобы обойти это ограничение, нужно построить динамическую команду для операто-
ра PL/pgSQL EXECUTE — ценой будет разбор и построение нового плана выполнения при каждом
вызове.
Изменчивая природа переменных типа record представляет ещё одну проблему в этой связи. Ко-
гда поля переменной типа record используются в выражениях или операторах, типы данных по-
лей не должны меняться от одного вызова функции к другому, так как при анализе каждого вы-
ражения будет использоваться тот тип данных, который присутствовал при первом вызове. При
необходимости можно использовать EXECUTE для решения этой проблемы.
Если функция используется в качестве триггера более чем для одной таблицы, PL/pgSQL незави-
симо подготавливает и кеширует операторы для каждой такой таблицы. То есть создаётся кеш
для каждой комбинации триггерная функция + таблица, а не только для каждой функции. Это
устраняет некоторые проблемы, связанные с различными типами данных. Например, триггерная
функция сможет успешно работать со столбцом key, даже если в разных таблицах этот столбец
имеет разные типы данных.
Таким же образом, функции с полиморфными типами аргументов имеют отдельный кеш для каж-
дой комбинации фактических типов аргументов, так что различия типов данных не вызывают
неожиданных сбоев.
Кеширование операторов иногда приводит к неожиданным эффектам при интерпретации чувстви-
тельных ко времени значений. Например, есть разница между тем, что делают эти две функции:
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS <script type="math/tex">BEGIN
INSERT INTO logtable VALUES (logtxt, 'now');
END;</script> LANGUAGE plpgsql;
и
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS <script type="math/tex">DECLARE
curtime timestamp;
1172PL/pgSQL — проце-
дурный язык SQL
BEGIN
curtime := 'now';
INSERT INTO logtable VALUES (logtxt, curtime);
END;</script> LANGUAGE plpgsql;
В случае logfunc1, при анализе INSERT, основной анализатор PostgreSQL знает, что строку ‘now’
следует толковать как timestamp, потому что целевой столбец таблицы logtable имеет такой тип
данных. Таким образом, ‘now’ будет преобразовано в константу timestamp при анализе INSERT, а
затем эта константа будет использоваться в последующих вызовах logfunc1 в течение всей сессии.
Разумеется, это не то, что хотел программист. Лучше было бы использовать функцию now() или
current_timestamp.
В случае logfunc2, основной анализатор PostgreSQL не знает, какого типа будет ‘now’ и поэтому
возвращает значение типа text, содержащее строку now. При последующем присвоении локаль-
ной переменной curtime интерпретатор PL/pgSQL приводит эту строку к типу timestamp, вызывая
функции text_out и timestamp_in. Таким образом, метка времени будет обновляться при каждом
выполнении, как и ожидается программистом. И хотя всё работает как ожидалось, это ужасно
неэффективно, поэтому использование функции now() по-прежнему значительно лучше.
43.12. Советы по разработке на PL/pgSQL
Хороший способ разрабатывать на PL/pgSQL заключается в том, чтобы в одном окне с текстовым
редактором по выбору создавать тексты функций, а в другом окне с psql загружать и тестировать
эти функции. В таком случае удобно записывать функцию, используя CREATE OR REPLACE FUNCTION.
Таким образом, можно легко загрузить файл для обновления определения функции. Например:
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS <script type="math/tex">....</script> LANGUAGE plpgsql;
В psql, можно загрузить или перезагрузить такой файл определения функции, выполнив:
\i filename.sql
а затем сразу выполнять команды SQL для тестирования функции.
Ещё один хороший способ разрабатывать на PL/pgSQL связан с использованием GUI инструментов,
облегчающих разработку на процедурном языке. Один из примеров такого инструмента pgAdmin,
хотя есть и другие. Такие инструменты часто предоставляют удобные возможности, такие как
экранирование одинарных кавычек, отладка и повторное создание функций.
43.12.1. Обработка кавычек
Код функции на PL/pgSQL указывается в команде CREATE FUNCTION в виде строки. Если писать стро-
ку в обычном порядке, внутри одинарных кавычек, то любой символ одинарной кавычки должен
быть удвоен, также как и должен быть удвоен каждый знак обратной косой черты (если использу-
ется синтаксис с экранированием в строках). Удвоение кавычек в лучшем случае утомительно, а
в более сложных случаях код может стать совершенно непонятным, так как легко может потребо-
ваться полудюжина или более кавычек идущих подряд. Вместо этого при создании тела функции
рекомендуется использовать знаки доллара в качестве кавычек (см. Подраздел 4.1.2.4). При та-
ком подходе никогда не потребуется дублировать кавычки, но придётся позаботиться о том, что-
бы иметь разные долларовые разделители для каждого уровня вложенности. Например, команду
CREATE FUNCTION можно записать так:
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
….
$PROC$ LANGUAGE plpgsql;
Внутри можно использовать кавычки для простых текстовых строк и <script type="math/tex">для разграничения фраг-
ментов SQL-команды, собираемой из отдельных строк. Если нужно взять в кавычки текст, который
включает</script>, можно использовать $Q$, и так далее.
1173PL/pgSQL — проце-
дурный язык SQL
Следующая таблица показывает, как применяются знаки кавычек, если не используется экрани-
рование долларами. Это может быть полезно при переводе кода, не использующего экранирование
знаками доллара, в нечто более понятное.
1 кавычка
В начале и конце тела функции, например:
CREATE FUNCTION foo() RETURNS integer AS ‘
….
‘ LANGUAGE plpgsql;
Внутри такой функции любая кавычка должна дублироваться.
2 кавычки
Для строковых литералов внутри тела функции, например:
a_output := ‘‘Blah’’;
SELECT * FROM users WHERE f_name=’‘foobar’’;
При использовании знаков доллара можно просто написать:
a_output := ‘Blah’;
SELECT * FROM users WHERE f_name=’foobar’;
и именно это увидит исполнитель PL/pgSQL в обоих случаях.
4 кавычки
Когда нужны одинарные кавычки в строковой константе внутри тела функции, например:
a_output := a_output || ‘’ AND name LIKE ‘’'’foobar’’’’ AND xyz’’
К a_output будет добавлено: AND name LIKE ‘foobar’ AND xyz
При использовании знаков доллара это записывается так:
a_output := a_output || <script type="math/tex">AND name LIKE 'foobar' AND xyz</script>
будьте внимательны, при этом не должно быть внешнего долларового разделителя <script type="math/tex">.
6 кавычек
Когда нужны одинарные кавычки в строковой константе внутри тела функции, при этом кавыч-
ки находятся в конце строковой константы. Например:
a_output := a_output || '' AND name LIKE ''''foobar''''''
К a_output будет добавлено: AND name LIKE 'foobar'.
При использовании знаков доллара это записывается так:
a_output := a_output ||</script> AND name LIKE ‘foobar’<script type="math/tex">10 кавычек
Когда нужны две одиночные кавычки в строковой константе (это уже 8 кавычек), примыкаю-
щие к концу строковой константы (ещё 2). Вероятно, такое может понадобиться при разработ-
ке функции, которая генерирует другие функции, как показано в Примере 43.10. Например:
a_output := a_output || '' if v_'' ||
referrer_keys.kind || '' like ''''''''''
|| referrer_keys.key_string || ''''''''''
then return '''''' || referrer_keys.referrer_type
|| ''''''; end if;'';
1174PL/pgSQL — проце-
дурный язык SQL
Значение a_output затем будет:
if v_... like ''...'' then return ''...''; end if;
При использовании знаков доллара:
a_output := a_output ||</script> if v_<script type="math/tex">|| referrer_keys.kind ||</script> like ‘<script type="math/tex">|| referrer_keys.key_string ||</script>’
then return ‘<script type="math/tex">|| referrer_keys.referrer_type
||</script>’; end if;<script type="math/tex">;
где предполагается, что нужны только одиночные кавычки в a_output, так как потребуется
повторное взятие в кавычки перед использованием.
43.12.2. Дополнительные проверки во время компиляции
Чтобы помочь найти и предупредить простые, но часто встречающиеся проблемы, PL/PgSQL предо-
ставляет дополнительные проверки. Если они включены в конфигурации, то во время компиляции
функций будут выдаваться дополнительные сообщения WARNING или ошибки ERROR. Функция, при
компиляции которой выдавалось WARNING, при последующем выполнении не будет выдавать это
сообщение и её можно протестировать в отдельной среде разработки.
Для включения этих проверок используются параметры конфигурации plpgsql.extra_warnings
для предупреждений и plpgsql.extra_errors для ошибок. Каждому из параметров можно присво-
ить список значений, разделённый через запятую, значение "none" или "all". По умолчанию ис-
пользуется "none". В настоящий момент доступна только одна проверка:
shadowed_variables
Проверяет, что объявление новой переменной не скрывает ранее объявленную переменную.
Следующий пример показывает эффект от установки plpgsql.extra_warnings в значение
shadowed_variables:
SET plpgsql.extra_warnings TO 'shadowed_variables';
CREATE FUNCTION foo(f1 int) RETURNS int AS</script>
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING: variable “f1” shadows a previously defined variable
LINE 3: f1 int;</li>
</ul>
<p>CREATE FUNCTION
43.13. Портирование из Oracle PL/SQL
В этом разделе рассматриваются различия между языками PostgreSQL PL/pgSQL и Oracle PL/SQL,
чтобы помочь разработчикам, переносящим приложения из Oracle® в PostgreSQL.
PL/pgSQL во многих аспектах похож на PL/SQL . Это блочно-структурированный, императивный
язык, в котором все переменные должны объявляться. Присвоения, циклы, условные операторы в
обоих языках похожи. Основные отличия, которые необходимо иметь в виду при портировании с
PL/SQL в PL/pgSQL, следующие:
• Если имя, используемое в SQL-команде, может быть как именем столбца таблицы, так и ссыл-
кой на переменную функции, то PL/SQL считает, что это имя столбца таблицы. Это соответ-
ствует поведению PL/pgSQL при plpgsql.variable_conflict = use_column, что не является
значением по умолчанию, как описано в Подразделе 43.11.1. В первую очередь, было бы пра-
1175PL/pgSQL — проце-
дурный язык SQL
вильно избегать таких двусмысленностей, но если требуется портировать большое количество
кода, зависящее от данного поведения, то установка переменной variable_conflict может
быть лучшим решением.
• В PostgreSQL тело функции должно быть записано в виде строки. Поэтому нужно использо-
вать знак доллара в качестве кавычек или экранировать одиночные кавычки в теле функции.
(См. Подраздел 43.12.1.)
• Имена типов данных часто требуют корректировки. Например, в Oracle строковые значения
часто объявляются с типом varchar2, не являющимся стандартным типом SQL. В PostgreSQL
вместо него нужно использовать varchar или text. Подобным образом, тип number нужно за-
менять на numeric или другой числовой тип, если найдётся более подходящий.
• Для группировки функций вместо пакетов используются схемы.
• Так как пакетов нет, нет и пакетных переменных. Это несколько раздражает. Вместо этого
можно хранить состояние каждого сеанса во временных таблицах.
• Целочисленные циклы FOR с указанием REVERSE работают по-разному. В PL/SQL значение
счётчика уменьшается от второго числа к первому, в то время как в PL/pgSQL счётчик умень-
шается от первого ко второму. Поэтому при портировании нужно менять местами границы
цикла. Это печально, но вряд ли будет изменено. (См. Подраздел 43.6.5.5.)
• Циклы FOR по запросам (не курсорам) также работают по-разному. Переменная цикла долж-
на быть объявлена, в то время как в PL/SQL она объявляется неявно. Преимущество в том, что
значения переменных доступны и после выхода из цикла.
• Существуют некоторые отличия в нотации при использовании курсорных переменных.
43.13.1. Примеры портирования
Пример 43.9 показывает, как портировать простую функцию из PL/SQL в PL/pgSQL.
Пример 43.9. Портирование простой функции из PL/SQL в PL/pgSQL
Функция Oracle PL/SQL:
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
v_version varchar2)
RETURN varchar2 IS
BEGIN
IF v_version IS NULL THEN
RETURN v_name;
END IF;
RETURN v_name || ‘/’ || v_version;
END;
/
show errors;
Пройдемся по этой функции и посмотрим различия по сравнению с PL/pgSQL:
• Имя типа varchar2 нужно сменить на varchar или text. В примерах данного раздела мы бу-
дем использовать varchar, но обычно лучше выбрать text, если не требуется ограничивать
длину строк.
• Ключевое слово RETURN в прототипе функции (не в теле функции) заменяется на RETURNS в
PostgreSQL. Кроме того, IS становится AS, и нужно добавить предложение LANGUAGE, потому
что PL/pgSQL — не единственный возможный язык.
• В PostgreSQL тело функции является строкой, поэтому нужно использовать кавычки или зна-
ки доллара. Это заменяет завершающий / в подходе Oracle.
• Команда show errors не существует в PostgreSQL и не требуется, так как ошибки будут выво-
диться автоматически.
1176PL/pgSQL — проце-
дурный язык SQL
Вот как эта функция будет выглядеть после портирования в PostgreSQL:
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
v_version varchar)
RETURNS varchar AS <script type="math/tex">BEGIN
IF v_version IS NULL THEN
RETURN v_name;
END IF;
RETURN v_name || '/' || v_version;
END;</script> LANGUAGE plpgsql;
Пример 43.10 показывает, как портировать функцию, которая создаёт другую функцию, и как об-
рабатывать проблемы с кавычками.
Пример 43.10. Портирование функции, создающей другую функцию, из PL/SQL в PL/pgSQL
Следующая процедура получает строки из SELECT и строит большую функцию, в целях эффектив-
ности возвращающую результат в операторах IF.
Версия Oracle:
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
CURSOR referrer_keys IS
SELECT * FROM cs_referrer_keys
ORDER BY try_order;
func_cmd VARCHAR(4000);
BEGIN
func_cmd := ‘CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN’;
FOR referrer_key IN referrer_keys LOOP
func_cmd := func_cmd ||
‘ IF v_’ || referrer_key.kind
|| ‘ LIKE ‘’’ || referrer_key.key_string
|| ‘’’ THEN RETURN ‘’’ || referrer_key.referrer_type
|| ‘’’; END IF;’;
END LOOP;
func_cmd := func_cmd || ‘ RETURN NULL; END;’;
EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
В конечном итоге в PostgreSQL эта функция может выглядеть так:
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() AS $func$
DECLARE
referrer_keys CURSOR IS
SELECT * FROM cs_referrer_keys
ORDER BY try_order;
func_body text;
func_cmd text;
BEGIN
func_body := ‘BEGIN’;
FOR referrer_key IN referrer_keys LOOP
func_body := func_body ||
1177PL/pgSQL — проце-
дурный язык SQL
‘ IF v_’ || referrer_key.kind
|| ‘ LIKE ‘ || quote_literal(referrer_key.key_string)
|| ‘ THEN RETURN ‘ || quote_literal(referrer_key.referrer_type)
|| ‘; END IF;’ ;
END LOOP;
func_body := func_body || ‘ RETURN NULL; END;’;
func_cmd :=
‘CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
v_domain varchar,
v_url varchar)
RETURNS varchar AS ‘
|| quote_literal(func_body)
|| ‘ LANGUAGE plpgsql;’ ;
EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
Обратите внимание, что тело функции строится отдельно, с использованием quote_literal для
удвоения кавычек. Эта техника необходима, потому что мы не можем безопасно использовать зна-
ки доллара при определении новой функции: мы не знаем наверняка, какие строки будут встав-
лены из referrer_key.key_string. (Мы предполагаем, что referrer_key.kind всегда имеет зна-
чение из списка: host, domain или url, но referrer_key.key_string может быть чем угодно, в
частности, может содержать знаки доллара.) На самом деле, в этой функций есть улучшение по
сравнению с оригиналом Oracle, потому что не будет генерироваться неправильный код, когда
referrer_key.key_string или referrer_key.referrer_type содержат кавычки.
Пример 43.11 показывает, как портировать функцию с выходными параметрами (OUT) и манипули-
рующую строками. В PostgreSQL нет встроенной функции instr, но её можно создать, используя
комбинацию других функций. В Подраздел 43.13.3 приведена реализации instr на PL/pgSQL, ко-
торая может быть полезна вам при портировании ваших функций.
Пример 43.11. Портирование из PL/SQL в PL/pgSQL процедуры, которая манипулирует
строками и содержит OUT параметры
Следующая процедура на языке Oracle PL/SQL разбирает URL и возвращает составляющие его
элементы (сервер, путь и запрос).
Версия Oracle:
CREATE OR REPLACE PROCEDURE cs_parse_url(
v_url IN VARCHAR2,
v_host OUT VARCHAR2, – Возвращается как результат
v_path OUT VARCHAR2, – И это тоже
v_query OUT VARCHAR2) – И это
IS
a_pos1 INTEGER;
a_pos2 INTEGER;
BEGIN
v_host := NULL;
v_path := NULL;
v_query := NULL;
a_pos1 := instr(v_url, ‘//’);
IF a_pos1 = 0 THEN
RETURN;
END IF;
a_pos2 := instr(v_url, ‘/’, a_pos1 + 2);
1178PL/pgSQL — проце-
дурный язык SQL
IF a_pos2 = 0 THEN
v_host := substr(v_url, a_pos1 + 2);
v_path := ‘/’;
RETURN;
END IF;
v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
a_pos1 := instr(v_url, ‘?’, a_pos2 + 1);
IF a_pos1 = 0 THEN
v_path := substr(v_url, a_pos2);
RETURN;
END IF;
v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
Вот возможная трансляция в PL/pgSQL:
CREATE OR REPLACE FUNCTION cs_parse_url(
v_url IN VARCHAR,
v_host OUT VARCHAR, – Возвращается как результат
v_path OUT VARCHAR, – И это тоже
v_query OUT VARCHAR) – И это
AS <script type="math/tex">DECLARE
a_pos1 INTEGER;
a_pos2 INTEGER;
BEGIN
v_host := NULL;
v_path := NULL;
v_query := NULL;
a_pos1 := instr(v_url, '//');
IF a_pos1 = 0 THEN
RETURN;
END IF;
a_pos2 := instr(v_url, '/', a_pos1 + 2);
IF a_pos2 = 0 THEN
v_host := substr(v_url, a_pos1 + 2);
v_path := '/';
RETURN;
END IF;
v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
a_pos1 := instr(v_url, '?', a_pos2 + 1);
IF a_pos1 = 0 THEN
v_path := substr(v_url, a_pos2);
RETURN;
END IF;
v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
v_query := substr(v_url, a_pos1 + 1);
END;</script> LANGUAGE plpgsql;
1179PL/pgSQL — проце-
дурный язык SQL
Эту функцию можно использовать так:
SELECT * FROM cs_parse_url(‘http://foobar.com/query.cgi?baz’);
Пример 43.12 показывает, как портировать процедуру, использующую большое количество специ-
фических для Oracle возможностей.
Пример 43.12. Портирование процедуры из PL/SQL в PL/pgSQL
Версия Oracle:
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
a_running_job_count INTEGER;
BEGIN
LOCK TABLE cs_jobs IN EXCLUSIVE MODE;
SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;
IF a_running_job_count &gt; 0 THEN
COMMIT; – освободить блокировку
raise_application_error(-20000,
‘Unable to create a new job: a job is currently running.’);
END IF;
DELETE FROM cs_active_job;
INSERT INTO cs_active_job(job_id) VALUES (v_job_id);
BEGIN
INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
EXCEPTION
WHEN dup_val_on_index THEN NULL; – ничего не делать, если задание уже есть
END;
COMMIT;
END;
/
show errors
Вот как эту процедуру можно переписать на PL/pgSQL:
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) AS <script type="math/tex">DECLARE
a_running_job_count integer;
BEGIN
LOCK TABLE cs_jobs IN EXCLUSIVE MODE;
SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;
IF a_running_job_count > 0 THEN
COMMIT; -- освободить блокировку
RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; --
END IF;
DELETE FROM cs_active_job;
INSERT INTO cs_active_job(job_id) VALUES (v_job_id);
BEGIN
INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
EXCEPTION
WHEN unique_violation THEN -- 2
-- ничего не делать, если задание уже есть
END;
1180
1PL/pgSQL — проце-
дурный язык SQL
COMMIT;
END;</script> LANGUAGE plpgsql;
1
2
Синтаксис RAISE существенно отличается от Oracle, хотя основной вариант RAISE имя_исклю-
чения работает похоже.
Имена исключений, поддерживаемые PL/pgSQL, отличаются от исключений в Oracle. Количе-
ство встроенных имён исключений значительно больше (см. Приложение A). В настоящее вре-
мя нет способа задать пользовательское имя исключения, хотя вместо этого можно вызывать
ошибку с заданным пользователем значением SQLSTATE.
43.13.2. На что ещё обратить внимание
В этом разделе рассматриваются ещё несколько вещей, на которые нужно обращать внимание при
портировании функций из Oracle PL/SQL в PostgreSQL.
43.13.2.1. Неявный откат изменений после возникновения исключения
В PL/pgSQL при перехвате исключения в секции EXCEPTION все изменения в базе данных с начала
блока автоматически откатываются. В Oracle это эквивалентно следующему:
BEGIN
SAVEPOINT s1;
… здесь код …
EXCEPTION
WHEN … THEN
ROLLBACK TO s1;
… здесь код …
WHEN … THEN
ROLLBACK TO s1;
… здесь код …
END;
При портировании процедуры Oracle, которая использует SAVEPOINT и ROLLBACK TO в таком же
стиле, задача простая: достаточно убрать операторы SAVEPOINT и ROLLBACK TO. Если же SAVEPOINT
и ROLLBACK TO используются по-другому, то придётся подумать.
43.13.2.2. EXECUTE
PL/pgSQL версия EXECUTE работает аналогично версии в PL/SQL, но нужно помнить об использова-
нии quote_literal и quote_ident, как описано в Подразделе 43.5.4. Без использования этих функ-
ций конструкции типа EXECUTE ‘SELECT * FROM $1’; будут работать ненадёжно.
43.13.2.3. Оптимизация функций на PL/pgSQL
Для оптимизации исполнения PostgreSQL предоставляет два модификатора при создании функ-
ции: «изменчивость» (будет ли функция всегда возвращать тот же результат при тех же аргумен-
тах) и «строгость» (возвращает ли функция NULL, если хотя бы один из аргументов NULL). Для
получения подробной информации обратитесь к справочной странице CREATE FUNCTION.
При использовании этих атрибутов оптимизации оператор CREATE FUNCTION может выглядеть при-
мерно так:
CREATE FUNCTION foo(…) RETURNS integer AS <script type="math/tex">...</script> LANGUAGE plpgsql STRICT IMMUTABLE;
43.13.3. Приложение
Этот раздел содержит код для совместимых с Oracle функций instr, которые можно использовать
для упрощения портирования.
1181PL/pgSQL — проце-
дурный язык SQL
–
–
–
–
–
–
–
–
–
–
–
–
instr functions that mimic Oracle’s counterpart
Syntax: instr(string1, string2 [, n [, m]])
where [] denotes optional parameters.
Search string1, beginning at the nth character, for the mth occurrence
of string2. If n is negative, search backwards, starting at the abs(n)’th
character from the end of string1.
If n is not passed, assume 1 (search starts at first character).
If m is not passed, assume 1 (find first occurrence).
Returns starting index of string2 in string1, or 0 if string2 is not found.
CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS <script type="math/tex">BEGIN
RETURN instr($1, $2, 1);
END;</script> LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
beg_index integer)
RETURNS integer AS <script type="math/tex">% <![CDATA[
DECLARE
pos integer NOT NULL DEFAULT 0;
temp_str varchar;
beg integer;
length integer;
ss_length integer;
BEGIN
IF beg_index > 0 THEN
temp_str := substring(string FROM beg_index);
pos := position(string_to_search_for IN temp_str);
IF pos = 0 THEN
RETURN 0;
ELSE
RETURN pos + beg_index - 1;
END IF;
ELSIF beg_index < 0 THEN
ss_length := char_length(string_to_search_for);
length := char_length(string);
beg := length + 1 + beg_index;
WHILE beg > 0 LOOP
temp_str := substring(string FROM beg FOR ss_length);
IF string_to_search_for = temp_str THEN
RETURN beg;
END IF;
beg := beg - 1;
END LOOP;
RETURN 0;
ELSE
RETURN 0;
END IF;
1182PL/pgSQL — проце-
дурный язык SQL
END; %]]></script> LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
beg_index integer, occur_index integer)
RETURNS integer AS <script type="math/tex">% <![CDATA[
DECLARE
pos integer NOT NULL DEFAULT 0;
occur_number integer NOT NULL DEFAULT 0;
temp_str varchar;
beg integer;
i integer;
length integer;
ss_length integer;
BEGIN
IF occur_index <= 0 THEN
RAISE 'argument ''%'' is out of range', occur_index
USING ERRCODE = '22003';
END IF;
IF beg_index > 0 THEN
beg := beg_index - 1;
FOR i IN 1..occur_index LOOP
temp_str := substring(string FROM beg + 1);
pos := position(string_to_search_for IN temp_str);
IF pos = 0 THEN
RETURN 0;
END IF;
beg := beg + pos;
END LOOP;
RETURN beg;
ELSIF beg_index < 0 THEN
ss_length := char_length(string_to_search_for);
length := char_length(string);
beg := length + 1 + beg_index;
WHILE beg > 0 LOOP
temp_str := substring(string FROM beg FOR ss_length);
IF string_to_search_for = temp_str THEN
occur_number := occur_number + 1;
IF occur_number = occur_index THEN
RETURN beg;
END IF;
END IF;
beg := beg - 1;
END LOOP;
RETURN 0;
ELSE
RETURN 0;
END IF;
END; %]]></script> LANGUAGE plpgsql STRICT IMMUTABLE;
1183</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-042/" title="Глава 42. Процедурные языки"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 42. Процедурные языки"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-042/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~4 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-042/" rel="bookmark" title="Глава 42. Процедурные языки" itemprop="url">Глава 42. Процедурные языки</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 42. Процедурные языки</p>

<p>PostgreSQL позволяет разрабатывать пользовательские функции не только на SQL и C, но и на
других языках. Эти языки в целом называются процедурными языками (PL, Procedural Language).
Если функция написана на процедурном языке, сервер баз данных сам по себе не знает, как интер-
претировать её исходный текст. Вместо этого он передаёт эту задачу специальному обработчику,
понимающему данный язык. Обработчик может либо выполнить всю работу по разбору, синтакси-
ческому анализу, выполнению кода и т. д., либо действовать как «прослойка» между PostgreSQL и
внешним исполнителем языка программирования. Сам обработчик представляет собой функцию
на языке C, скомпилированную в виде разделяемого объекта и загружаемую по требованию, как
и любая другая функция на C.
В настоящее время стандартный дистрибутив PostgreSQL включает четыре процедурных языка:
PL/pgSQL (Глава  43), PL/Tcl (Глава  44), PL/Perl (Глава  45) и PL/Python (Глава  46). Существуют и
другие процедурные языки, поддержка которых не включена в базовый дистрибутив. Информацию
о них можно найти в Приложении H. Кроме того, пользователи могут реализовать и другие языки;
основы разработки нового процедурного языка рассматриваются в Главе 56.
42.1. Установка процедурных языков
Прежде всего, процедурный язык должен быть «установлен» в каждую базу данных, где он будет
использоваться. Но процедурные языки, устанавливаемые в базу данных template1, автоматиче-
ски становятся доступными во всех впоследствии создаваемых базах, так как их определения в
template1 будут скопированы командой CREATE DATABASE. Таким образом, администратор баз дан-
ных может выбрать, какие языки будут доступны в определённых базах данных, и при желании
сделать некоторые языки доступными по умолчанию.
Для языков, включённых в стандартный дистрибутив, достаточно выполнить команду CREATE
EXTENSION имя_языка, чтобы установить язык в текущую базу данных. Описанная ниже ручная про-
цедура рекомендуется только для установки языков, не упакованных в виде расширений.
Установка процедурного языка вручную
Процедурный язык устанавливается в базу данных в пять этапов, и выполнять их должен админи-
стратор баз данных. В большинстве случаев необходимые команды SQL следует упаковать в виде
установочного скрипта «расширения», чтобы их можно было выполнить, воспользовавшись коман-
дой CREATE EXTENSION.</p>
<ol>
  <li>Разделяемый объект для обработчика языка должен быть скомпилирован и установлен в со-
ответствующий каталог библиотек. Это в принципе не отличается от сборки и установки до-
полнительных модулей с обычными функциями на языке C; см. Подраздел 38.10.5. Часто обра-
ботчик языка зависит от внешней библиотеки, в которой собственно реализован исполнитель
языка программирования; в таких случаях нужно установить и эту библиотеку.</li>
  <li>Обработчик должен быть объявлен командой
CREATE FUNCTION имя_функции_обработчика()
RETURNS language_handler
AS ‘путь-к-разделяемому-объекту’
LANGUAGE C;
Специальный тип возврата language_handler говорит СУБД, что эта функция не возвращает
какой-либо определённый тип данных SQL, и значит её нельзя использовать непосредственно
в операторах SQL.
3.
(Optional) Дополнительно обработчик языка может предоставить функцию обработки «внед-
рённого кода», которая будет выполнять анонимные блоки кода (команды DO), написанные на
этом языке. Если для языка есть обработчик внедрённого кода, объявите его такой командой:
CREATE FUNCTION имя_обработчика_внедрённого_кода(internal)
RETURNS void
1121Процедурные языки
AS ‘путь-к-разделяемому-объекту’
LANGUAGE C;
4.
(Optional) Кроме того, обработчик языка может предоставить функцию «проверки», которая бу-
дет проверять корректность определения функции, собственно не выполняя её. Функция про-
верки, если она существует, вызывается командой CREATE FUNCTION. Если такая функция для
языка определена, объявите её такой командой:
CREATE FUNCTION имя_функции_проверки(oid)
RETURNS void
AS ‘путь-к-разделяемому-объекту’
LANGUAGE C STRICT;
5.
Наконец, процедурный язык должен быть объявлен командой
CREATE [TRUSTED] [PROCEDURAL] LANGUAGE имя-языка
HANDLER имя_функции_обработчика
[INLINE имя_обработчика_внедрённого_кода]
[VALIDATOR имя_функции_проверки] ;
Необязательное ключевое слово TRUSTED (доверенный) указывает, что язык не предоставляет
пользователю доступ к данным, которого он не имел бы без него. Доверенные языки предна-
значены для обычных пользователей баз данных, не имеющих прав суперпользователя, и их
можно использовать для безопасного создания функций и процедур. Так как функции PL вы-
полняются внутри сервера баз данных, флаг TRUSTED следует устанавливать только для тех
языков, которые не позволяют обращаться к внутренним механизмам сервера или файловой
системе. Языки PL/pgSQL, PL/Tcl и PL/Perl считаются доверенными; языки PL/TclU, PL/PerlU и
PL/PythonU предоставляют неограниченную функциональность и их не следует помечать как
доверенные.
Примере 42.1 показывает, как выполняется процедура ручной установки для языка PL/Perl.
Пример 42.1. Установка PL/Perl вручную
Следующая команда говорит серверу баз данных, где найти разделяемый объект для функции-об-
работчика языка PL/Perl:
CREATE FUNCTION plperl_call_handler() RETURNS language_handler AS
‘$libdir/plperl’ LANGUAGE C;
Для PL/Perl реализованы обработчик внедрённого кода и функция проверки, так что их мы тоже
объявим:
CREATE FUNCTION plperl_inline_handler(internal) RETURNS void AS
‘$libdir/plperl’ LANGUAGE C;
CREATE FUNCTION plperl_validator(oid) RETURNS void AS
‘$libdir/plperl’ LANGUAGE C STRICT;
Следующая команда:
CREATE TRUSTED PROCEDURAL LANGUAGE plperl
HANDLER plperl_call_handler
INLINE plperl_inline_handler
VALIDATOR plperl_validator;
определяет, что ранее объявленные функции должны вызываться для функций и процедур с атри-
бутом языка plperl.
В стандартной инсталляции PostgreSQL обработчик языка PL/pgSQL уже собран и установлен в
каталог «библиотек»; более того, сам язык PL/pgSQL установлен во всех базах данных. Если при
сборке сконфигурирована поддержка Tcl, то обработчики для PL/Tcl и PL/TclU собираются и уста-
навливаются в каталог библиотек, но сам язык по умолчанию в базы данных не устанавливается.
Подобным образом, если сконфигурирована поддержка Perl, собираются и устанавливаются обра-
1122Процедурные языки
ботчики PL/Perl и PL/PerlU, а при включении поддержки Python устанавливается обработчик PL/
PythonU, но в базы данных эти языки по умолчанию не устанавливаются.
1123</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-041/" title="Глава 41. Система правил"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 41. Система правил"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-041/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~48 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-041/" rel="bookmark" title="Глава 41. Система правил" itemprop="url">Глава 41. Система правил</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 41. Система правил</p>

<p>В этой главе обсуждается система правил, реализованная в PostgreSQL. Промышленные системы
правил по сути довольно простые, но при их использовании приходится сталкиваться с множеством
неочевидных вещей.
В некоторых других базах данных определяются активные правила баз данных, которые обычно
реализуются в виде процедур и триггеров. Так же их можно реализовать и в PostgreSQL.
Система правил (точнее говоря, система правил перезаписи запросов) полностью отличается от
механизма хранимых процедур и триггеров. Она изменяет запросы по заданным правилам, а затем
передаёт модифицированный запрос планировщику для планирования и выполнения. Это очень
мощное средство, подходящее для решения множества задач, например, для определения пред-
ставлений и процедур на языке запросов или реализации версионности. Теоретические основы и
преимущества этой системы правил также описаны в ston90b и ong90 (на английском языке).
41.1. Дерево запроса
Чтобы понять, как работает система правил, нужно знать, когда она вызывается, что принимает
на вход и какой результат выдаёт.
Система правил внедрена между анализатором запросов и планировщиком. Она принимает разо-
бранный запрос, одно дерево запроса, и определённые пользователем правила перезаписи, тоже
представленные деревьями с некоторой дополнительной информацией, и создаёт некоторое коли-
чество деревьев запросов в результате. Таким образом, на входе и выходе этой системы оказыва-
ется то, что может сформировать анализатор запросов, и как следствие, всё, с чем работает эта
система, представимо в виде операторов SQL.
Так что же такое дерево запроса? Это внутреннее представление оператора SQL, в котором
все образующие его части хранятся отдельно. Эти деревья можно увидеть в журнале серве-
ра, если установить параметры конфигурации debug_print_parse, debug_print_rewritten или
debug_print_plan. Действия правил также хранятся в виде деревьев запросов, в системном ката-
логе pg_rewrite. Они не форматируются как при выводе в журнал, но содержат точно такую же
информацию.
Для прочтения неформатированного дерева требуется некоторый навык. Но так как представле-
ния дерева запросов в виде SQL достаточно, чтобы понять систему правил, в этой главе не будет
рассказываться, как их читать.
Читая SQL-представления деревьев запросов в этой главе, необходимо понимать, на какие части
разбивается оператор, когда он преобразуется в структуру дерева запроса. Дерево запроса состоит
из следующих частей:
тип команды
Это простое значение, говорящее, какая команда (SELECT, INSERT, UPDATE или DELETE) сгенери-
ровала дерево запросов.
список отношений
Список отношений представляет собой массив отношений, используемых в запросе. В запросе
SELECT он включает отношения, указанные после ключевого слова FROM.
Каждый элемент списка отношений представляет таблицу или представление и говорит, с ка-
ким именем они упоминаются в других частях запроса. В дереве запросов записываются номе-
ра элементов списка отношений, а не их имена, поэтому для него неактуальна проблема дуб-
лирования имён, как для оператора SQL. Такая проблема может возникнуть при объединении
списков отношений, образованных разными правилами. В этой главе данная ситуация рассмат-
риваться не будет.
1095Система правил
результирующее отношение
Индекс в списке отношений, указывающий на отношение, которое будет получать результаты
запроса.
В запросах SELECT результирующее отношение отсутствует. (Особый случай SELECT INTO прак-
тически равнозначен CREATE TABLE с последующим INSERT … SELECT и здесь отдельно не
рассматривается.)
Для команд INSERT, UPDATE и DELETE результирующим отношением будет таблица (или пред-
ставление!), в которой будут происходить изменения.
выходной список
Выходной список — это список выражений, определяющих результат запроса. В случае SELECT,
это выражения, которые образуют окончательный набор выходных данных. Они соответствуют
выражениям, записанным между ключевыми словами SELECT и FROM. (Указание * — это просто
краткое обозначение имён всех столбцов отношения. Анализатор разворачивает его в список
отдельных столбцов, так что система правил никогда не видит его.)
Командам DELETE не нужен обычный выходной список, так как они не выдают никакие результа-
ты. Вместо этого планировщик добавляет в пустой выходной список специальную запись CTID,
чтобы исполнитель мог найти удаляемую строку. (CTID добавляется, когда результирующее от-
ношение — обычная таблица. Если это представление, планировщиком добавляется перемен-
ная, содержащая всю строку, как рассказывается в Подразделе 41.2.4.)
Для команд INSERT выходной список описывает новые строки, которые должны попасть в ре-
зультирующее отношение. Он включает выражения в предложении VALUES или предложении
SELECT в INSERT … SELECT. На первом этапе процесс перезаписи добавляет элементы выход-
ного списка для столбцов, которым ничего не присвоила исходная команда, но имеющих зна-
чения по умолчанию. Все остальные столбцы (без заданного значения и значения по умолча-
нию) планировщик заполняет константой NULL.
Для команд UPDATE выходной список описывает новые строки, которые должны заменить ста-
рые. В системе правил он содержит только выражения из части SET столбец = выражение. Для
пропущенных столбцов планировщик вставляет выражения, копирующие значения из старой
строки в новую. Так же, как и с командой DELETE, при этом добавляется CTID или переменная
со всей строкой, чтобы исполнитель мог найти изменяемую старую строку.
Каждая запись в выходном списке содержит выражение, которое может быть константой, пе-
ременной, указывающей на столбец отношения в таблице отношений, параметром или деревом
выражений, образованным из констант, переменных, операторов, вызовов функций и т. д.
условие фильтра
Условие фильтра запроса — это выражение, во многом похожее на те, что содержатся в вы-
ходном списке. Результат этого выражения — логический, он говорит, должна ли выполнять-
ся операция (INSERT, UPDATE, DELETE или SELECT) для данной строки в результате. Оно соответ-
ствует предложению WHERE SQL-оператора.
дерево соединения
Дерево соединения запроса показывает структуру предложения FROM. Для простых запросов
вида SELECT … FROM a, b, c, дерево соединения — это просто список элементов FROM, так
как они могут соединяться в любом порядке. Но с выражениями JOIN, особенно с внешними
соединениями, приходится соединять отношения именно в заданном порядке. В этом случае
дерево соединения отражает структуру выражений JOIN. Ограничения, связанные с конкрет-
ными предложениями JOIN (из выражений ON или USING), тоже сохраняются в виде условных
выражений, добавленных к соответствующим узлам дерева соединения. Как оказалось, выра-
жение WHERE верхнего уровня тоже удобно хранить как условие, добавленное к элементу верх-
1096Система правил
него уровня дерева соединения. Поэтому в дереве соединения на самом деле представляются
оба предложения оператора SELECT — FROM и WHERE.
другие
Другие части дерева запроса, например, предложение ORDER BY, в данном контексте не пред-
ставляют интереса. Система правил выполняет в них некоторые подстановки, применяя пра-
вила, но это не имеет непосредственного отношения к основам системы правил.
41.2. Система правил и представления
Представления в PostgreSQL реализованы на основе системы правил. Фактически по сути нет ни-
какого отличия
CREATE VIEW myview AS SELECT * FROM mytab;
от следующих двух команд:
CREATE TABLE myview (same column list as mytab);
CREATE RULE “_RETURN” AS ON SELECT TO myview DO INSTEAD
SELECT * FROM mytab;
так как именно эти действия CREATE VIEW выполняет внутри. Это имеет некоторые побочные эф-
фекты. В частности, информация о представлениях в системных каталогах PostgreSQL ничем не
отличается от информации о таблицах. Поэтому при анализе запроса нет абсолютно никакой раз-
ницы между таблицами и представлениями. Они представляют собой одно и то же — отношения.
41.2.1. Как работают правила SELECT
Правила ON SELECT применяются ко всем запросам на последнем этапе, даже если это команда
INSERT, UPDATE или DELETE. Эти правила отличаются от правил других видов тем, что они моди-
фицируют непосредственно дерево запросов, а не создают новое. Поэтому мы начнём описание с
правил SELECT.
В настоящее время возможно только одно действие в правиле ON SELECT и это должно быть без-
условное действие SELECT, выполняемое в режиме INSTEAD. Это ограничение было введено, что-
бы сделать правила достаточно безопасными для применения обычными пользователями, так что
действие правил ON SELECT сводится к реализации представлений.
В примерах этой главы рассматриваются два представления с соединением, которые выполняют
некоторые вычисления, и которые, в свою очередь, используются другими представлениями. Пер-
вое из этих двух представлений затем модифицируется, к нему добавляются правила для операций
INSERT, UPDATE и DELETE, так что в итоге получается представление, которое работает как обычная
таблица с некоторыми необычными функциями. Это не самый простой пример для начала, поэто-
му понять некоторые вещи будет сложнее. Но лучше иметь один пример, поэтапно охватывающий
все обсуждаемые здесь темы, чем несколько различных, при восприятии которых в итоге может
возникнуть путаница.
Например, нам нужна простейшая функция min, которая возвратит минимальное из двух целых
чисел. Её можно создать так:
CREATE FUNCTION min(integer, integer) RETURNS integer AS <script type="math/tex">% <![CDATA[
SELECT CASE WHEN $1 < $2 THEN $1 ELSE $2 END %]]></script> LANGUAGE SQL STRICT;
Таблицы, которые понадобятся нам для описания системы правил, выглядят так:
CREATE TABLE shoe_data (
shoename
text,
sh_avail
integer,
slcolor
text,
slminlen
real,
–
–
–
–
первичный ключ
число имеющихся пар
предпочитаемый цвет шнурков
минимальная длина шнурков
1097Система правил
slmaxlen
slunit
real,
text
– максимальная длина шнурков
– единица длины
);
CREATE TABLE shoelace_data (
sl_name
text,
sl_avail
integer,
sl_color
text,
sl_len
real,
sl_unit
text
); –
–
–
–
–
CREATE TABLE unit (
un_name
text,
un_fact
real
); – первичный ключ
– коэффициент для перевода в см
первичный ключ
число имеющихся пар
цвет шнурков
длина шнурков
единица длины
Как можно догадаться, в них хранятся данные обувной фабрики.
Представления создаются так:
CREATE VIEW shoe AS
SELECT sh.shoename,
sh.sh_avail,
sh.slcolor,
sh.slminlen,
sh.slminlen * un.un_fact AS slminlen_cm,
sh.slmaxlen,
sh.slmaxlen * un.un_fact AS slmaxlen_cm,
sh.slunit
FROM shoe_data sh, unit un
WHERE sh.slunit = un.un_name;
CREATE VIEW shoelace AS
SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name;
CREATE VIEW shoe_ready AS
SELECT rsh.shoename,
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM shoe rsh, shoelace rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;
Команда CREATE VIEW для представления shoelace (самого простого из имеющихся) создаёт отно-
шение shoelace и запись в pg_rewrite о правиле перезаписи, которое должно применяться, когда
в запросе на выборку задействуется отношение shoelace. Для этого правила не задаются условия
применения (о них рассказывается ниже, в описании правил не для SELECT, так как правила SELECT
в настоящее бывают только безусловными) и оно действует в режиме INSTEAD. Заметьте, что усло-
вия применения отличаются от условий фильтра запроса, например, действие для нашего правила
1098Система правил
содержит условие фильтра. Действие правила выражается одним деревом запроса, которое явля-
ется копией оператора SELECT в команде, создающей представление.
Примечание
Два дополнительных элемента списка отношений NEW и OLD, которые можно увидеть в
соответствующей строке pg_rewrite, не представляют интереса для правил SELECT.
Сейчас мы наполним таблицы unit (единицы измерения), shoe_data (данные о туфлях) и
shoelace_data (данные о шнурках) и выполним простой запрос к представлению:
INSERT INTO unit VALUES (‘cm’, 1.0);
INSERT INTO unit VALUES (‘m’, 100.0);
INSERT INTO unit VALUES (‘inch’, 2.54);
INSERT
INSERT
INSERT
INSERT INTO
INTO
INTO
INTO shoe_data
shoe_data
shoe_data
shoe_data
VALUES
VALUES
VALUES
VALUES
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
(‘sh1’,
(‘sh2’,
(‘sh3’,
(‘sh4’,
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
2,
0,
4,
3,
‘black’,
‘black’,
‘brown’,
‘brown’,
(‘sl1’,
(‘sl2’,
(‘sl3’,
(‘sl4’,
(‘sl5’,
(‘sl6’,
(‘sl7’,
(‘sl8’,
5,
6,
0,
8,
4,
0,
7,
1,
70.0,
30.0,
50.0,
40.0,
‘black’,
‘black’,
‘black’,
‘black’,
‘brown’,
‘brown’,
‘brown’,
‘brown’,
90.0,
40.0,
65.0,
50.0,
‘cm’);
‘inch’);
‘cm’);
‘inch’);
80.0, ‘cm’);
100.0, ‘cm’);
35.0, ‘inch’);
40.0, ‘inch’);
1.0, ‘m’);
0.9, ‘m’);
60, ‘cm’);
40, ‘inch’);
SELECT * FROM shoelace;
sl_name
| sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———–+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
7 | brown
|
60 | cm
|
60
sl3
|
0 | black
|
35 | inch
|
88.9
sl4
|
8 | black
|
40 | inch
|
101.6
sl8
|
1 | brown
|
40 | inch
|
101.6
sl5
|
4 | brown
|
1 | m
|
100
sl6
|
0 | brown
|
0.9 | m
|
90
(8 rows)
Это самый простой запрос SELECT, который можно выполнить с нашими представлениями, и мы
воспользуемся этим, чтобы объяснить азы правил представлений. Запрос SELECT * FROM shoelace
интерпретируется анализатором запросов и преобразуется в дерево запроса:
SELECT shoelace.sl_name, shoelace.sl_avail,
shoelace.sl_color, shoelace.sl_len,
shoelace.sl_unit, shoelace.sl_len_cm
FROM shoelace shoelace;
Это дерево передаётся в систему правил, которая проходит по списку отношений и проверяет, есть
ли какие-либо правила для этих отношений. Обрабатывая элемент отношения shoelace (сейчас он
единственный), система правил находит правило _RETURN с деревом запроса:
SELECT s.sl_name, s.sl_avail,
s.sl_color, s.sl_len, s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
1099Система правил
FROM shoelace old, shoelace new,
shoelace_data s, unit u
WHERE s.sl_unit = u.un_name;
Чтобы развернуть представление, механизм перезаписи просто формирует новый элемент для
списка отношений — подзапрос, содержащий дерево действия правила, и подставляет этот эле-
мент вместо исходного, на который ссылалось представление. Получившееся перезаписанное де-
рево запроса будет почти таким как дерево запроса:
SELECT shoelace.sl_name, shoelace.sl_avail,
shoelace.sl_color, shoelace.sl_len,
shoelace.sl_unit, shoelace.sl_len_cm
FROM (SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name) shoelace;
Однако есть одно различие: в списке отношений подзапроса будут содержаться два дополнитель-
ных элемента: shoelace old и shoelace new. Эти элементы не принимают непосредственного уча-
стия в запросе, так как они не задействованы в дереве соединения подзапроса и в целевом списке.
Механизм перезаписи использует их для хранения информации о проверке прав доступа, которая
изначально хранилась в элементе, указывающем на представление. Таким образом, исполнитель
будет по-прежнему проверять, имеет ли пользователь необходимые права для доступа к представ-
лению, хотя в перезаписанном запросе это представление не фигурирует непосредственно.
Так было применено первое правило. Система правил продолжит проверку оставшихся элементов
списка отношений на верхнем уровне запроса (в данном случае таких элементов нет) и рекурсивно
проверит элементы списка отношений в добавленном подзапросе, не ссылаются ли они на пред-
ставления. (Но old и new разворачиваться не будут — иначе мы получили бы бесконечную рекур-
сию!) В этом примере для shoelace_data и unit нет правил перезаписи, так что перезапись завер-
шается и результат, полученный выше, передаётся планировщику.
Сейчас мы хотим написать запрос, который выбирает туфли из имеющихся в данный момент, для
которых есть подходящие шнурки (по цвету и длине) и число готовых пар больше или равно двум.
SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;
shoename | sh_avail | sl_name | sl_avail | total_avail
———-+———-+———+———-+————-
sh1
|
2 | sl1
|
5 |
2
sh3
|
4 | sl7
|
7 |
4
(2 rows)
На этот раз анализатор запроса выводит такое дерево:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM shoe_ready shoe_ready
WHERE shoe_ready.total_avail &gt;= 2;
Первое правило применяется к представлению shoe_ready и в результате получается дерево за-
проса:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM (SELECT rsh.shoename,
1100Система правил
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM shoe rsh, shoelace rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
WHERE shoe_ready.total_avail &gt;= 2;
Подобным образом, правила для shoe и shoelace подставляются в список отношений, что даёт
окончательное дерево запроса:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM (SELECT rsh.shoename,
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM (SELECT sh.shoename,
sh.sh_avail,
sh.slcolor,
sh.slminlen,
sh.slminlen * un.un_fact AS slminlen_cm,
sh.slmaxlen,
sh.slmaxlen * un.un_fact AS slmaxlen_cm,
sh.slunit
FROM shoe_data sh, unit un
WHERE sh.slunit = un.un_name) rsh,
(SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name) rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
WHERE shoe_ready.total_avail &gt; 2;
На практике планировщик будет сворачивать это дерево до двух уровней: команды нижнего уров-
ня SELECT будут «подняты» к среднему SELECT, так как обрабатывать их отдельно нет необходимо-
сти. Но средний оператор SELECT не будет совмещён с верхним, так как он содержит агрегатные
функции. Если поднять его выше, поведение самого верхнего SELECT изменится нежелательным
образом. В целом же, сворачивание дерева запросов — это оптимизация, которая не должна за-
трагивать работу механизма перезаписи.
41.2.2. Правила представлений не для SELECT
До этого в описании правил представлений не затрагивались два компонента дерева запросов —
тип команды и результирующее отношение. На самом деле, тип команды не важен для правил
представления, но результирующее отношение может повлиять на работу механизма перезаписи,
потому что если это представление, требуются дополнительные операции.
Есть только несколько отличий между деревом запроса для SELECT и деревом для другой команды.
Очевидно, у них различные типы команд, и для команды, отличной от SELECT, результирующее от-
1101Система правил
ношение указывает на элемент в списке отношений, куда должен попасть результат. Все осталь-
ные компоненты в точности те же. Поэтому, например, если взять таблицы t1 и t2 со столбцами
a и b, деревья запросов для этих операторов:
SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;
UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;
будут практически одинаковыми. В частности:
• Списки отношений содержат элементы для таблиц t1 и t2.
• Выходные списки содержат одну переменную, указывающую на столбец b элемента-отноше-
ния для таблицы t2.
• Выражения условий сравнивают столбцы a обоих элементов-отношений на равенство.
• Деревья соединений показывают простое соединение между t1 и t2.
Как следствие, для обоих деревьев строятся похожие планы выполнения, с соединением двух таб-
лиц. Для UPDATE планировщик добавляет в выходной список недостающие столбцы из t1 и оконча-
тельное дерево становится таким:
UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;
В результате исполнитель, обрабатывающий соединение, выдаёт тот же результат, что и запрос:
SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
Но с UPDATE есть маленькая проблема: часть плана исполнителя, в которой выполняется соедине-
ние, не представляет, для чего предназначены результаты соединения. Она просто выдаёт резуль-
тирующий набор строк. Фактически есть одна команда SELECT, а другая, UPDATE, обрабатывается
исполнителем выше, где он уже знает, что это команда UPDATE и что результат должен попасть в
таблицу t1. Но какие из строк таблицы должны заменяться новыми?
Для решения этой проблемы в выходной список операторов UPDATE (и DELETE) добавляется ещё
один элемент: идентификатор текущего кортежа (Current Tuple ID, CTID).Это системный столбец,
содержащий номер блока в файле и позицию строки в блоке. Зная таблицу, по CTID можно полу-
чить исходную строку в t1, подлежащую изменению. С добавленным в выходной список CTID за-
прос фактически выглядит так:
SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
Теперь мы перейдём ещё к одной особенности PostgreSQL. Старые строки таблицы не переписы-
ваются, поэтому ROLLBACK выполняется быстро. С командой UPDATE в таблицу вставляется новая
строка результата (без CTID) и в заголовке старой строки, на которую указывает CTID, в поля cmax
и xmax записываются текущий счётчик команд и идентификатор текущей транзакции. Таким об-
разом, старая строка оказывается скрытой и после фиксирования транзакции процесс очистки
может окончательно удалить неактуальную версию строки.
Зная всё это, мы можем применять правила представлений абсолютно таким же образом к любой
команде — никаких различий нет.
41.2.3. Преимущества представлений в PostgreSQL
Выше было показано, как система правил внедряет определения представлений в исходное дерево
запроса. Во втором примере простой запрос SELECT к одному представлению создал окончательное
дерево запроса, соединяющее 4 таблицы (таблица unit использовалась дважды с разными имена-
ми).
Преимущество реализации представлений через систему правил заключается в том, что плани-
ровщик получает в одном дереве запроса всю информацию о таблицах, которые нужно прочитать,
о том, как связаны эти таблицы, об условиях в представлениях, а также об условиях, заданных в
1102Система правил
исходном запросе. И всё это имеет место, когда сам исходный запрос представляет собой соеди-
нение представлений. Планировщик должен выбрать лучший способ выполнения запроса, и чем
больше информации он получит, тем лучше может быть его выбор. И то, как в PostgreSQL реали-
зована система правил, гарантирует, что ему поступает вся информация, собранная о запросе на
данный момент.
41.2.4. Изменение представления
Но что произойдёт, если записать имя представления в качестве целевого отношения команды
INSERT, UPDATE или DELETE? Если проделать подстановки, описанные выше, будет получено дерево
запроса, в котором результирующее отношение указывает на элемент-подзапрос, что не будет ра-
ботать. Однако PostgreSQL даёт ряд возможностей, чтобы сделать представления изменяемыми.
Если подзапрос выбирает данные из одного базового отношения и он достаточно прост, механизм
перезаписи может автоматически заменить его нижележащим базовым отношением, чтобы ко-
манды INSERT, UPDATE или DELETE обращались к базовому отношению. Представления, «достаточно
простые» для этого, называются автоматически изменяемыми. Подробнее виды представлений,
которые могут изменяться автоматически, описаны в CREATE VIEW.
Эту задачу также можно решить, создав триггер INSTEAD OF для представления. В этом случае пе-
резапись будет работать немного по-другому. Для INSERT механизм перезаписи не делает с пред-
ставлением ничего, оставляя его результирующим отношением запроса. Для UPDATE и DELETE ему
по-прежнему придётся разворачивать запрос представления, чтобы получить «старые» строки,
которые эта команда попытается изменить или удалить. Поэтому представление разворачивается
как обычно, но в запрос добавляется ещё один элемент списка отношений, указывающий на пред-
ставление в роли результирующего отношения.
При этом возникает проблема идентификации строк в представлении, подлежащих изменению.
Вспомните, что когда результирующее отношение является таблицей, в выходной список добавля-
ется специальное поле CTID, указывающее на физическое расположение изменяемых строк. Но
это не будет работать, когда результирующее отношение — представление, так как в представле-
ниях нет CTID, потому что их строки физически нигде не находятся. Вместо этого, для операций
UPDATE или DELETE в выходной список добавляется специальный элемент wholerow (вся строка),
который разворачивается в содержимое всех столбцов представления. Используя этот элемент,
исполнитель передаёт строку «old» в триггер INSTEAD OF. Какие именно строки должны изменять-
ся фактически, будет решать сам триггер, исходя из полученных значений старых и новых строк.
Кроме того, пользователь может определить правила INSTEAD, в которых задать действия замены
для команд INSERT, UPDATE и DELETE с представлением. Эти правила обычно преобразуют команду
в другую команду, изменяющую одну или несколько таблиц, а не представление. Эта тема осве-
щается в Разделе 41.4.
Заметьте, что такие правила вычисляются сначала, перезаписывая исходный запрос до того, как
он будет планироваться и выполняться. Поэтому, если для представления определены и триггеры
INSTEAD OF, и правила для INSERT, UPDATE или DELETE, сначала вычисляются правила, а в зависи-
мости от их действия, триггеры могут не вызываться вовсе.
Автоматическая перезапись запросов INSERT, UPDATE или DELETE с простыми представлениями все-
гда производится в последнюю очередь. Таким образом, если у представления есть правила или
триггеры, они переопределяют поведение автоматически изменяемых представлений.
Если для представления не определены правила INSTEAD или триггеры INSTEAD OF, и запрос не
удаётся автоматически переписать в виде обращения к нижележащему базовому отношению, воз-
никает ошибка, потому что исполнитель не сможет изменить такое представление.
41.3. Материализованные представления
Материализованные представления в PostgreSQL основаны на системе правил, как и представле-
ния, но их содержимое сохраняется как таблица. Основное отличие между:
1103Система правил
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;
и этой командой:
CREATE TABLE mymatview AS SELECT * FROM mytab;
состоит в том, что материализованное представление впоследствии нельзя будет изменить непо-
средственно, а запрос, создающий материализованное представление, сохраняется точно так же,
как запрос представления, и получить актуальные данные в материализованном представлении
можно так:
REFRESH MATERIALIZED VIEW mymatview;
Информация о материализованном представлении в системных каталогах PostgreSQL ничем не от-
личается от информации о таблице или представлении. Поэтому для анализатора запроса матери-
ализованное представление является просто отношением, как таблица или представление. Когда
запрос обращается к материализованному представлению, данные возвращаются непосредствен-
но из него, как из таблицы; правило применяется, только чтобы его наполнить.
Хотя обращение к данным в материализованном представлении часто выполняется гораздо быст-
рее, чем обращение к нижележащим таблицам напрямую или через представление, данные в нём
не всегда актуальные (но иногда это вполне приемлемо). Рассмотрим таблицу с данными продаж:
CREATE TABLE invoice (
invoice_no
integer
seller_no
integer,
invoice_date date,
invoice_amt
numeric(13,2)
);
PRIMARY KEY,
– идентификатор продавца
– дата продажи
– сумма продажи
Если пользователям нужно быстро обработать исторические данные, возможно их интересуют
только общие показатели, а полнота данных на текущий момент не важна:
CREATE MATERIALIZED VIEW sales_summary AS
SELECT
seller_no,
invoice_date,
sum(invoice_amt)::numeric(13,2) as sales_amt
FROM invoice
WHERE invoice_date &lt; CURRENT_DATE
GROUP BY
seller_no,
invoice_date
ORDER BY
seller_no,
invoice_date;
CREATE UNIQUE INDEX sales_summary_seller
ON sales_summary (seller_no, invoice_date);
Это материализованное представление может быть полезно для построения графика в информа-
ционной панели менеджеров по продажам. Для ежесуточного обновления статистики можно за-
планировать задание по расписанию, которое будет выполнять этот оператор:
REFRESH MATERIALIZED VIEW sales_summary;
Ещё одно применение материализованного представления — предоставить быстрый доступ к дан-
ным, получаемым с удалённой системы через обёртку сторонних данных. Ниже приведён простой
пример с обёрткой file_fdw, с замерами времени, но так как при этом использовался кеш локаль-
ной системы, выигрыш в производительности при обращении к удалённой системе обычно будет
гораздо больше, чем показано здесь. Заметьте, что мы также использовали возможность добавить
индекс в материализованное представление, тогда как file_fdw индексы не поддерживает; при
других видах доступа к сторонним данным такого преимущества может не быть.
1104Система правил
Подготовка:
CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
SERVER local_file
OPTIONS (filename ‘/usr/share/dict/words’);
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;
Теперь давайте проверим написание слова. Сначала непосредственно через обёртку file_fdw:
SELECT count(<em>) FROM words WHERE word = ‘caterpiler’;
count
——-
0
(1 row)
Выполнив EXPLAIN ANALYZE, мы получаем:
Aggregate (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181
rows=1 loops=1)
-&gt; Foreign Scan on words (cost=0.00..21761.41 rows=1032 width=0) (actual
time=188.177..188.177 rows=0 loops=1)
Filter: (word = ‘caterpiler’::text)
Rows Removed by Filter: 479829
Foreign File: /usr/share/dict/words
Foreign File Size: 4953699
Planning time: 0.118 ms
Execution time: 188.273 ms
Если же теперь обратиться к материализованному представлению, запрос выполнится гораздо
быстрее:
Aggregate (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
-&gt; Index Only Scan using wrd_word on wrd (cost=0.42..4.44 rows=1 width=0) (actual
time=0.039..0.039 rows=0 loops=1)
Index Cond: (word = ‘caterpiler’::text)
Heap Fetches: 0
Planning time: 0.164 ms
Execution time: 0.117 ms
В любом случае слово записано неправильно, поэтому давайте попробуем найти то, что имелось
в виду. Сначала опять через file_fdw:
SELECT word FROM words ORDER BY word &lt;-&gt; ‘caterpiler’ LIMIT 10;
word
—————
cater
caterpillar
Caterpillar
caterpillars
caterpillar’s
Caterpillar’s
caterer
caterer’s
caters
catered
1105Система правил
(10 rows)
Limit (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594
rows=10 loops=1)
-&gt; Sort (cost=11583.61..11804.76 rows=88459 width=32) (actual
time=1431.589..1431.591 rows=10 loops=1)
Sort Key: ((word &lt;-&gt; ‘caterpiler’::text))
Sort Method: top-N heapsort Memory: 25kB
-&gt; Foreign Scan on words (cost=0.00..9672.05 rows=88459 width=32) (actual
time=0.057..1286.455 rows=479829 loops=1)
Foreign File: /usr/share/dict/words
Foreign File Size: 4953699
Planning time: 0.128 ms
Execution time: 1431.679 ms
Затем через материализованное представление:
Limit (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10
loops=1)
-&gt; Index Scan using wrd_trgm on wrd (cost=0.29..37020.87 rows=479829 width=10)
(actual time=187.219..188.252 rows=10 loops=1)
Order By: (word &lt;-&gt; ‘caterpiler’::text)
Planning time: 0.196 ms
Execution time: 198.640 ms
Если периодическое обновление данных из другого источника в локальной базе данных вас устра-
ивает, этот подход может дать значительный выигрыш в скорости.
41.4. Правила для INSERT, UPDATE и DELETE
Правила, определяемые для команд INSERT, UPDATE и DELETE, значительно отличаются от правил
представлений, описанных в предыдущем разделе. Во-первых, команда CREATE RULE позволяет со-
здавать правила со следующими особенностями:
• Они могут не определять действия.
• Они могут определять несколько действий.
• Они могут действовать в режиме INSTEAD или ALSO (по умолчанию).
• Становятся полезными псевдоотношения NEW и OLD.
• Они могут иметь условия применения.
Во-вторых, они не модифицируют само исходное дерево запроса. Вместо этого они создают
несколько новых деревьев запросов и могут заменить исходное.
Внимание
Во многих случаях для задач, выполнимых с использованием правил для INSERT/UPDATE/
DELETE, лучше применять триггеры. Оформляются триггеры чуть сложнее, но понять
их смысл гораздо проще. К тому же с правилами могут быть получены неожиданные
результаты, когда исходный запрос содержит изменчивые функции: в процессе испол-
нения правил эти функции могут вызываться большее число раз, чем ожидается.
Кроме того, в некоторых случаях эти типы правил вообще нельзя применять; а имен-
но, с предложениями WITH в исходном запросе и с вложенными подзапросами SELECT
с множественным присваиванием в списке SET запросов UPDATE. Это объясняется тем,
что копирование этих конструкций в запрос правила привело бы к многократному вы-
числению вложенного запроса, что пошло бы в разрез с выраженными намерениями
автора запроса.
1106Система правил
41.4.1. Как работают правила для изменения
Запомните синтаксис:
CREATE [ OR REPLACE ] RULE имя AS ON событие
TO таблица [ WHERE условие ]
DO [ ALSO | INSTEAD ] { NOTHING | команда | ( команда ; команда … ) }
В дальнейшем, под правилами для изменения подразумеваются правила, определяемые для ко-
манд INSERT, UPDATE или DELETE.
Правила для изменения применяются системой правил, когда результирующее отношение и тип
команды в дереве запроса совпадает с объектом и событием, заданным в команде CREATE RULE. Для
такого правила система правил создаёт список деревьев запросов. Изначально этот список пуст.
С правилом может быть связано ноль (ключевое слово NOTHING), одно или несколько действий.
Простоты ради мы рассмотрим правило с одним действием. Правило может иметь, а может не
иметь условия применения, и действует в режиме INSTEAD или ALSO (по умолчанию).
Что такое условие применения правила? Это условие, которое говорит, когда нужно, а когда не
нужно применять действия правила. В этом условии можно обращаться к псевдоотношениям NEW
и/или OLD, которые представляют целевое отношение (но с особым значением).
Всего есть три варианта формирования деревьев запросов для правила с одним действием.
Без условия применения в режиме ALSO или INSTEAD
дерево запроса из действия правила с добавленным условием исходного дерева
С условием применения в режиме ALSO
дерево запроса из действия правила с условием применения правила и условием, добавленным
из исходного дерева
С условием применения в режиме INSTEAD
дерево запроса из действия правила с условием применения правила и условием из исходного
дерева; также добавляется исходное дерево запроса с условием, обратным условию примене-
ния правила
Наконец, для правил ALSO в список добавляется исходное дерево запроса без изменений. Так как
исходное дерево запроса также добавляют только правила INSTEAD с условиями применения, в
итоге для правила с одним действием мы можем получить только одно или два дерева запросов.
Для правил ON INSERT исходный запрос (если он не перекрывается режимом INSTEAD) выполняет-
ся перед действиями, добавленными правилами. Поэтому эти действия могут видеть вставленные
строки. Но для правил ON UPDATE и ON DELETE исходный запрос выполняется после действий, до-
бавленных правилами. При таком порядке эти действия будут видеть строки, подлежащие измене-
нию или удалению; иначе бы действия не работали, не найдя строк, соответствующих их условиям
применения (эти строки уже будут изменены или удалены).
Деревья запросов, полученные из действий правил, снова попадают в систему перезаписи, где мо-
гут примениться дополнительные правила, добавляющие или убирающие деревья запроса. Поэто-
му действия правила должны выполнять команды другого типа или работать с другим результиру-
ющим отношением, иначе возникнет бесконечная рекурсия. (Система выявляет подобное рекур-
сивное разворачивание правил и выдаёт ошибку.)
Деревья запросов, заданные для действий в системном каталоге pg_rewrite, представляют собой
только шаблоны. Так как они могут обращаться к элементам NEW и OLD в списке отношений, их
можно будет использовать только после некоторых подстановок. В случае ссылки на NEW соответ-
ствующий элемент ищется в целевом списке исходного запроса. Если он найден, ссылка заменя-
ется выражением этого элемента. В противном случае NEW означает то же самое, что и OLD (для
1107Система правил
команды UPDATE) или заменяется значением NULL (для команды INSERT). Любые ссылки на OLD
заменяются ссылкой на элемент результирующего отношения в списке отношений.
После того как система применит все правила для изменения, она применяет правила представ-
ления к полученному дереву (или деревьям) запроса. Представления не могут добавлять новые
действия для изменения, поэтому нет необходимости применять такие правила к результату пе-
резаписи представления.
41.4.1.1. Пошаговый разбор первого правила
Предположим, что нам нужно отслеживать изменения в столбце sl_avail таблицы shoelace_data.
Мы можем создать таблицу для ведения журнала и правило, которое будет добавлять в неё записи
по условию, когда для shoelace_data выполняется UPDATE.
CREATE TABLE shoelace_log (
sl_name
text,
sl_avail
integer,
log_who
text,
log_when
timestamp
);
–
–
–
–
шнурки, количество которых изменилось
новое количество
кто изменил
когда
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
DO INSERT INTO shoelace_log VALUES (
NEW.sl_name,
NEW.sl_avail,
current_user,
current_timestamp
);
Теперь, если кто-то выполнит:
UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = ‘sl7’;
мы увидим в таблице журнала:
SELECT * FROM shoelace_log;
sl_name | sl_avail | log_who | log_when
———+———-+———+———————————-
sl7
|
6 | Al
| Tue Oct 20 16:14:45 1998 MET DST
(1 row)
Именно это нам и нужно. При этом внутри происходит следующее. Анализатор запроса создаёт
дерево:
UPDATE shoelace_data SET sl_avail = 6
FROM shoelace_data shoelace_data
WHERE shoelace_data.sl_name = ‘sl7’;
В системном каталоге находится правило log_shoelace, настроенное на изменение (ON UPDATE) с
условием применения:
NEW.sl_avail &lt;&gt; OLD.sl_avail
и действием:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old;
(Это выглядит несколько странно, так как обычно нельзя написать INSERT … VALUES … FROM.
Предложение FROM здесь добавлено, просто чтобы показать, что в дереве запроса для ссылок new и
1108Система правил
old есть элементы в списке отношений. Они необходимы для того, чтобы к ним могли обращаться
переменные в дереве запроса команды INSERT.)
Так как это правило ALSO с условием применения, система правил должна выдать два дерева за-
просов: изменённое действие правила и исходное дерево запроса. На первом шаге список отноше-
ний исходного запроса вставляется в дерево действия правила и получается:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data;
На втором шаге в это дерево добавляется условие применения правила, так что результирующий
набор ограничивается строками, в которых меняется sl_avail:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE new.sl_avail &lt;&gt; old.sl_avail;
(Это выглядит ещё более странно, ведь в INSERT … VALUES не записывается и предложение WHERE,
но планировщик и исполнитель не испытывают затруднений с этим. Они всё равно должны под-
держивать эту функциональность для INSERT … SELECT.)
На третьем шаге добавляется условие исходного дерева, что ещё больше ограничивает результи-
рующий набор, оставляя в нём только строки, которые затронул бы исходный запрос:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE new.sl_avail &lt;&gt; old.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
На четвёртом шаге ссылки на NEW заменяются элементами выходного списка из исходного дерева
запроса или переменными из результирующего отношения:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE 6 &lt;&gt; old.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
На последнем, пятом шаге ссылки на OLD заменяются ссылками на результирующее отношение:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE 6 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
Вот и всё. Так как правило действует в режиме ALSO, мы также выводим исходное дерево запроса.
Таким образом, система правил выдаёт список с двумя деревьями запросов, соответствующими
этим операторам:
1109Система правил
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data
WHERE 6 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
UPDATE shoelace_data SET sl_avail = 6
WHERE sl_name = ‘sl7’;
Они выполняются в показанном порядке и именно это должно делать данное правило.
Благодаря заменам и добавленным условиям в журнал не добавится запись, например, при таком
исходном запросе:
UPDATE shoelace_data SET sl_color = ‘green’
WHERE sl_name = ‘sl7’;
В этом случае исходное дерево запроса не содержит элемент выходного списка для sl_avail, так
что NEW.sl_avail будет заменено переменной shoelace_data.sl_avail. Таким образом, дополни-
тельная команда, созданная правилом, будет такой:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, shoelace_data.sl_avail,
current_user, current_timestamp )
FROM shoelace_data
WHERE shoelace_data.sl_avail &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
Это условие применения не будет выполняться никогда.
Это также будет работать, если исходный запрос изменяет несколько строк. Так, если кто-то вы-
полнит команду:
UPDATE shoelace_data SET sl_avail = 0
WHERE sl_color = ‘black’;
фактически будут изменены четыре строки (sl1, sl2, sl3 и sl4). Но для sl3 значение sl_avail = 0.
В этом случае условие исходного дерева другое, так что это правило выдаёт такое дополнительное
дерево запроса:
INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
current_user, current_timestamp
FROM shoelace_data
WHERE 0 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_color = ‘black’;
. С таким деревом запроса в журнал определённо будут добавлены три записи. И это абсолютно
правильно.
Здесь мы видим, почему важно, чтобы исходное дерево запроса выполнялось в конце. Если бы
оператор UPDATE выполнился сначала, все строки уже получили бы нулевые значения, так что
записывающий в журнал INSERT не нашёл бы строк, в которых 0 &lt;&gt; shoelace_data.sl_avail.
41.4.2. Сочетание с представлениями
Есть один простой вариант защититься от ранее упомянутой возможности выполнять INSERT,
UPDATE или DELETE для представлений, когда это нежелательно — создать правила, просто отбра-
сывающие деревья этих запросов. В нашем случае они будут выглядеть так:
CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
1110Система правил
DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
DO INSTEAD NOTHING;
Если теперь кто-то попытается выполнить одну из этих операций с представлением shoe, система
правил применит эти правила. Так как это правила без действий в режиме INSTEAD, результирую-
щий список деревьев запроса будет пуст и весь запрос аннулируется, так что после работы систе-
мы правил будет нечего оптимизировать и выполнять.
Более сложный вариант — использовать систему правил для создания правил, преобразующих
дерево запроса в выполняющее нужную операцию с реальными таблицами. Чтобы реализовать это
с представлением shoelace, мы создадим следующие правила:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
DO INSTEAD
INSERT INTO shoelace_data VALUES (
NEW.sl_name,
NEW.sl_avail,
NEW.sl_color,
NEW.sl_len,
NEW.sl_unit
);
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
DO INSTEAD
UPDATE shoelace_data
SET sl_name = NEW.sl_name,
sl_avail = NEW.sl_avail,
sl_color = NEW.sl_color,
sl_len = NEW.sl_len,
sl_unit = NEW.sl_unit
WHERE sl_name = OLD.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace
DO INSTEAD
DELETE FROM shoelace_data
WHERE sl_name = OLD.sl_name;
Если вы хотите поддерживать также запросы к представлению с RETURNING, вам надо создать пра-
вила с предложениями RETURNING, которые будут вычислять строки представления. Это обычно
довольно тривиально для представлений с одной нижележащей таблицей, но несколько затрудни-
тельно для представлений с соединением, таких как shoelace. Например, для INSERT это будет
выглядеть так:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
DO INSTEAD
INSERT INTO shoelace_data VALUES (
NEW.sl_name,
NEW.sl_avail,
NEW.sl_color,
NEW.sl_len,
NEW.sl_unit
)
RETURNING
shoelace_data.</em>,
(SELECT shoelace_data.sl_len * u.un_fact
FROM unit u WHERE shoelace_data.sl_unit = u.un_name);
Заметьте, что это одно правило поддерживает запросы и INSERT, и INSERT RETURNING к этому пред-
ставлению — предложение RETURNING просто игнорируется при обычном INSERT.
1111Система правил
Теперь предположим, что на фабрику прибывает партия шнурков с объёмной сопроводительной
накладной. Но вы не хотите вручную вносить по одной записи в представление shoelace. Вместо
этого можно создать две маленькие таблицы: в первую вы будете вставлять записи из накладной,
а вторая пригодится для специального приёма. Для этого мы выполним следующие команды:
CREATE TABLE shoelace_arrive (
arr_name
text,
arr_quant
integer
);
CREATE TABLE shoelace_ok (
ok_name
text,
ok_quant
integer
);
CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
DO INSTEAD
UPDATE shoelace
SET sl_avail = sl_avail + NEW.ok_quant
WHERE sl_name = NEW.ok_name;
Теперь вы можете наполнить таблицу shoelace_arrive данными о поступивших шнурках из на-
кладной:
SELECT * FROM shoelace_arrive;
arr_name | arr_quant
———-+———–
sl3
|
10
sl6
|
20
sl8
|
20
(3 rows)
Взгляните на текущие данные:
SELECT * FROM shoelace;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———-+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
6 | brown
|
60 | cm
|
60
sl3
|
0 | black
|
35 | inch
|
88.9
sl4
|
8 | black
|
40 | inch
|
101.6
sl8
|
1 | brown
|
40 | inch
|
101.6
sl5
|
4 | brown
|
1 | m
|
100
sl6
|
0 | brown
|
0.9 | m
|
90
(8 rows)
Теперь переместите прибывшие шнурки во вторую таблицу:
INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
Проверьте, что получилось:
SELECT * FROM shoelace ORDER BY sl_name;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———-+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
6 | brown
|
60 | cm
|
60
sl4
|
8 | black
|
40 | inch
|
101.6
1112Система правил
sl3
sl8
sl5
sl6
(8 rows)
|
|
|
|
10
21
4
20
|
|
|
|
black
brown
brown
brown
|
|
|
|
35
40
1
0.9
|
|
|
|
inch
inch
m
m
|
|
|
|
88.9
101.6
100
90
SELECT * FROM shoelace_log;
sl_name | sl_avail | log_who| log_when
———+———-+——–+———————————-
sl7
|
6 | Al
| Tue Oct 20 19:14:45 1998 MET DST
sl3
|
10 | Al
| Tue Oct 20 19:25:16 1998 MET DST
sl6
|
20 | Al
| Tue Oct 20 19:25:16 1998 MET DST
sl8
|
21 | Al
| Tue Oct 20 19:25:16 1998 MET DST
(4 rows)
Чтобы получить эти результаты из одного INSERT … SELECT, была проделана большая работа.
Мы подробно опишем всё преобразование дерева запросов в продолжении этой главы. Начнём с
дерева, выданного анализатором запроса:
INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
Теперь применяется первое правило shoelace_ok_ins, создающее такое дерево:
UPDATE shoelace
SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace
WHERE shoelace.sl_name = shoelace_arrive.arr_name;
и отбрасывающее исходный INSERT в shoelace_ok. Этот переписанный запрос снова поступает в
систему правил и второе применяемое правило shoelace_upd выдаёт:
UPDATE shoelace_data
SET sl_name = shoelace.sl_name,
sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
sl_color = shoelace.sl_color,
sl_len = shoelace.sl_len,
sl_unit = shoelace.sl_unit
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
shoelace new, shoelace_data shoelace_data
WHERE shoelace.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = shoelace.sl_name;
Это тоже правило INSTEAD, так что предыдущее дерево запроса отбрасывается. Заметьте, что этот
запрос по-прежнему использует представление shoelace. Но система правил ещё не закончила
свою работу, она продолжает и применяет правило _RETURN, так что мы получаем:
UPDATE shoelace_data
SET sl_name = s.sl_name,
sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
sl_color = s.sl_color,
sl_len = s.sl_len,
sl_unit = s.sl_unit
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
1113Система правил
shoelace new, shoelace_data shoelace_data,
shoelace old, shoelace new,
shoelace_data s, unit u
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name;
Наконец, применяется правило log_shoelace и выдаётся дополнительное дерево запроса:
INSERT INTO shoelace_log
SELECT s.sl_name,
s.sl_avail + shoelace_arrive.arr_quant,
current_user,
current_timestamp
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
shoelace new, shoelace_data shoelace_data,
shoelace old, shoelace new,
shoelace_data s, unit u,
shoelace_data old, shoelace_data new
shoelace_log shoelace_log
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name
AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;
Теперь, обработав все правила, система правил выдаёт построенные деревья запросов.
В итоге мы получаем два дерева запросов, равнозначные следующим операторам SQL:
INSERT INTO shoelace_log
SELECT s.sl_name,
s.sl_avail + shoelace_arrive.arr_quant,
current_user,
current_timestamp
FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
shoelace_data s
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name
AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;
UPDATE shoelace_data
SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive,
shoelace_data shoelace_data,
shoelace_data s
WHERE s.sl_name = shoelace_arrive.sl_name
AND shoelace_data.sl_name = s.sl_name;
В результате вся операция, в ходе которой данные, поступающие из одного отношения, вставля-
ются в другое, вставка преобразуется в изменение третьего, что затем становится изменением
четвёртого, и запись об этом изменении добавляется в пятое, сводится к двум запросам.
Здесь можно заметить маленькую не очень красивую деталь. Как видно, в этих двух запросах таб-
лица shoelace_data фигурирует в списке отношений дважды, тогда как определённо достаточно и
одного вхождения. Планировщик не понимает этого и поэтому для дерева запроса INSERT, выдан-
ного системой правил, будет получен такой план:
Nested Loop
-&gt; Merge Join
-&gt; Seq Scan
-&gt; Sort
1114Система правил
-&gt; Seq Scan on s
Seq Scan
-&gt; Sort
-&gt; Seq Scan on shoelace_arrive
Seq Scan on shoelace_data
-&gt;
-&gt;
Тогда как без лишнего элемента в списке отношений мы получили бы:
Merge Join
-&gt; Seq Scan
-&gt; Sort
-&gt;
-&gt; Seq Scan
-&gt; Sort
-&gt;
Seq Scan on s
Seq Scan on shoelace_arrive
При этом в журнале оказались бы точно такие же записи. Таким образом, применение правил по-
влекло дополнительное сканирование таблицы shoelace_data, в котором не было никакой необхо-
димости. И такое же избыточное сканирование выполняется ещё раз в UPDATE. Отнеситесь к этому
с пониманием, ведь сделать всё это возможным в принципе было действительно сложно.
И наконец, ещё одна, завершающая демонстрация системы правил PostgreSQL и всей её мощи.
Предположим, что вы добавили в базу данных шнурки с экстраординарными цветами:
INSERT INTO shoelace VALUES (‘sl9’, 0, ‘pink’, 35.0, ‘inch’, 0.0);
INSERT INTO shoelace VALUES (‘sl10’, 1000, ‘magenta’, 40.0, ‘inch’, 0.0);
Давайте создадим представление, чтобы убедиться, что шнурки (записи в shoelace) не подходят
ни к каким туфлям. Оно будет определено так:
CREATE VIEW shoelace_mismatch AS
SELECT * FROM shoelace WHERE NOT EXISTS
(SELECT shoename FROM shoe WHERE slcolor = sl_color);
Через него мы получаем наши записи:
SELECT * FROM shoelace_mismatch;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———+———-+———-+——–+———+———–
sl9
|
0 | pink
|
35 | inch
|
88.9
sl10
|
1000 | magenta |
40 | inch
|
101.6
Теперь мы хотим, чтобы шнурки, которые ни к чему не подходят, удалялись из базы данных. Чтобы
немного усложнить задачу для PostgreSQL, мы не будем удалять их непосредственно из таблицы.
Вместо этого мы создадим ещё одно представление:
CREATE VIEW shoelace_can_delete AS
SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;
И удалим их так:
DELETE FROM shoelace WHERE EXISTS
(SELECT * FROM shoelace_can_delete
WHERE sl_name = shoelace.sl_name);
Вуаля:
SELECT * FROM shoelace;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
1115Система правил
sl7
sl4
sl3
sl8
sl10
sl5
sl6
(9 rows)
|
|
|
|
|
|
|
6
8
10
21
1000
4
20
|
|
|
|
|
|
|
brown
black
black
brown
magenta
brown
brown
|
|
|
|
|
|
|
60
40
35
40
40
1
0.9
|
|
|
|
|
|
|
cm
inch
inch
inch
inch
m
m
|
|
|
|
|
|
|
60
101.6
88.9
101.6
101.6
100
90
Так запрос DELETE для представления с ограничивающим условием-подзапросом, использующим в
совокупности 4 вложенных/соединённых представления, с одним из которых тоже связано условие
с подзапросом, задействующим представление, и где используются вычисляемые столбцы пред-
ставлений, переписывается и преобразуется в одно дерево запроса, которое удаляет требуемые
данные из реальной таблицы.
На практике ситуации, когда необходима такая сложная конструкция, встречаются довольно ред-
ко, но, тем не менее, приятно осознавать, что всё это возможно и работает.
41.5. Правила и права
В результате переписывания запросов системой правил PostgreSQL обращение может происходить
не к тем таблицам/представлениям, к которым обращался исходный запрос. С правилами для из-
менения возможна так же и запись в другие таблицы.
Правила перезаписи не имеют отдельного владельца — владельцем правил перезаписи, опреде-
лённых для отношения (таблицы или представления), автоматически считается владелец этого
отношения. Система правил PostgreSQL меняет поведение стандартного механизма управления
доступом. К отношениям, используемым вследствие применения правил, проверяется доступ вла-
дельца правила, но не пользователя, выполняющего запрос. Это значит, что пользователь должен
иметь права, необходимые только для обращения к таблицам/представлениям, которые он явно
упоминает в своих запросах.
Например, представим, что у пользователя есть список телефонных номеров, некоторые из ко-
торых личные, а некоторые должна знать его ассистентка. Он может построить следующую кон-
струкцию:
CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
SELECT person, CASE WHEN NOT private THEN phone END AS phone
FROM phone_data;
GRANT SELECT ON phone_number TO assistant;
Никто, кроме него (и суперпользователей базы данных) не сможет обратиться к таблице
phone_data. Но так как ассистентке было дано (GRANT) соответствующее право, она сможет
выполнить SELECT для представления phone_number. Система правил преобразует SELECT из
phone_number в SELECT из таблицы phone_data. Так как пользователь является владельцем
phone_number, он же считается владельцем правила, доступ на чтение phone_data проверяется для
него, и выполнение запроса разрешается. Проверка прав доступа к phone_number тоже выполня-
ется, но при этом проверяется пользователь, выполняющий запрос, так что обращаться к этому
представлению смогут только сам пользователь и его ассистентка.
Права проверяются правило за правилом. То есть, в данный момент только ассистентка может
видеть открытые телефонные номера. Но она может создать другое представление и дать доступ
к нему всем (роли public), после чего все смогут видеть данные phone_number через представле-
ние ассистентки. Что она не может сделать, так это создать представление, которое обращается
к phone_data напрямую. (Вообще она может это сделать, но такое представление не будет рабо-
тать, так как при любой попытке прочитать его доступ к таблице будет запрещён.) И как только
пользователь заметит, что ассистентка открыла доступ к своему представлению phone_number, он
может лишить её права чтения этого представления. В результате все сразу потеряют доступ и к
представлению ассистентки.
1116Система правил
Может показаться, что такая проверка «правило-за-правилом» представляет уязвимость, но это не
так. Если бы даже этот механизм не работал, ассистентка могла бы создать таблицу со столбцами
как в phone_number и регулярно копировать туда данные. Тогда это были бы её собственные данные
и она могла бы открывать доступ к ним кому угодно. Другими словами, команда GRANT означает «Я
доверяю тебе». Если кто-то, кому вы доверяете, проделывает такие операции, стоит задуматься и,
возможно, лишить его доступа к данным, применив REVOKE.
Хотя представления могут применяться для скрытия содержимого определённых столбцов, как
описано выше, с их помощью нельзя надёжно скрыть данные в невидимых строках, если только не
установлен флаг security_barrier. Например, следующее представление небезопасно:
CREATE VIEW phone_number AS
SELECT person, phone FROM phone_data WHERE phone NOT LIKE ‘412%’;
Может показаться, что всё в порядке, ведь система правил преобразует SELECT из phone_number в
SELECT из phone_data и добавит ограничивающее условие, чтобы выдавались только строки с полем
phone, начинающимся не с 412. Но если пользователь может создавать собственные функции, ему
будет не сложно заставить планировщик выполнять функцию пользователя перед выражением NOT
LIKE. Например:
CREATE FUNCTION tricky(text, text) RETURNS bool AS <script type="math/tex">BEGIN
RAISE NOTICE '% => %', $1, $2;
RETURN true;
END</script> LANGUAGE plpgsql COST 0.0000000000000000000001;
SELECT * FROM phone_number WHERE tricky(person, phone);
Так он сможет получить все имена и номера телефонов из таблицы phone_data через сообщения
NOTICE, так как планировщик решит, что лучше выполнить недорогую функцию tricky перед бо-
лее дорогой операцией NOT LIKE. И даже если пользователь не имеет права создавать новые функ-
ции, он может использовать для подобных атак встроенные функции. (Например, многие функции
приведения показывают входные значения в сообщениях об ошибках.)
Подобные соображения распространяются и на правила для изменения. Применительно к приме-
рам предыдущего раздела, владелец таблиц в базе данных может дать кому-нибудь другому для
представления shoelace права SELECT, INSERT, UPDATE и DELETE, а для shoelace_log только SELECT.
Действие правила, добавляющее записи в журнал, всё равно будет выполняться успешно, а этот
другой пользователь сможет видеть записи в журнале. Но он не сможет создавать поддельные
записи, равно как и модифицировать или удалять существующие. В этом случае нет никакой воз-
можности заставить планировщик изменить порядок операций, так как единственное правило, ко-
торое обращается к shoelace_log — это безусловный INSERT. В более сложных сценариях это мо-
жет быть не так.
Когда требуется, чтобы представление обеспечивало защиту на уровне строк, к нему нужно при-
менить атрибут security_barrier. Это предотвратит утечку содержимого строк из злонамеренно
выбранных функций и операторов до того, как строки будут отфильтрованы представлением. На-
пример, показанное выше представление будет безопасным, если создать его так:
CREATE VIEW phone_number WITH (security_barrier) AS
SELECT person, phone FROM phone_data WHERE phone NOT LIKE ‘412%’;
Представления, созданные с атрибутом security_barrier, могут работать гораздо медленнее, чем
обычные. И вообще говоря, это неизбежно: самый быстрый план должен быть отвергнут, если он
может скомпрометировать защиту. Поэтому данный атрибут по умолчанию не устанавливается.
Планировщик запросов имеет больше свободы, работая с функциями, лишёнными побочных эф-
фектов. Такие функции называются герметичными (LEAKPROOF) и включают только простые ча-
сто используемые операторы, например, операторы равенства. Планировщик запросов может без-
опасно вычислять такие функции в любой момент выполнения запроса, так как при вызове их для
1117Система правил
строк, невидимых пользователю, не просочится никакая информация об этих строках. Более того,
функции, которые не принимают аргументы или которым не передаются аргументы из представ-
ления с барьером безопасности, можно не помечать как LEAKPROOF, чтобы они вышли наружу, так
как они никогда не получат данные из представления. И напротив, функции, которые могут вы-
звать ошибку в зависимости от значений аргументов (например, в случае переполнения или деле-
ния на ноль), герметичными не являются, и могут выдать существенную информацию о невидимых
строках, если будут выполнены перед фильтрами строк.
Важно понимать, что даже представление, созданное с атрибутом security_barrier, остаётся без-
опасным только в том смысле, что содержимое невидимых строк не будет передаваться потенци-
ально небезопасным функциям. Но пользователь может собрать некоторые сведения о невидимых
данных и другими способами; например, он может проанализировать план запроса, полученный
с EXPLAIN, или замерить время выполнения запросов с этим представлением. Злоумышленник мо-
жет сделать определённые выводы об объёме невидимых данных или даже получить некоторую
информацию о распределении данных или наиболее частых значениях (так как всё это отражается
в статистике для оптимизатора и, как следствие, влияет на время выполнения плана или даже на
выбор плана). Если возможность атаки через скрытые каналы вызывает опасения, вероятно, будет
разумным не предоставлять никакой доступ к этим данным.
41.6. Правила и статус команд
Сервер PostgreSQL возвращает строку состояния команды, например, INSERT 149592 1, для каж-
дой получаемой команды. Это довольно прозрачно, когда не задействуются правила, но что про-
изойдёт, если правила перезапишут запрос?
Правила влияют на состояния команды следующим образом:
• Если с запросом не связано безусловное правило INSTEAD, то выполняется заданный исход-
ный запрос и его статус выдаётся как обычно. (Но если определены какие-то условные прави-
ла INSTEAD, к исходному запросу добавляется условие, обратное их условиям применения. Это
может повлиять на число обрабатываемых строк и выводимый статус команды.)
• Если с запросом связано безусловное правило INSTEAD, исходный запрос не выполняется во-
все. В этом случае сервер возвратит статус команды от последнего запроса, вставленного пра-
вилом INSTEAD (условным или безусловным), и тип команды исходного запроса (INSERT, UPDATE
или DELETE). Если правила не добавили подходящего запроса, в возвращённом статусе коман-
ды показывается исходный тип запроса и нули вместо количества строк и OID.
Программист может добиться, чтобы статус команды во втором случае устанавливало нужное пра-
вило INSTEAD, назначив ему имя, стоящее по алфавиту после других активных правил, чтобы это
правило применялось последним.
41.7. Сравнение правил и триггеров
Многие вещи, которые можно сделать с помощью триггеров, можно также реализовать, используя
систему правил PostgreSQL. Однако, используя правила, нельзя реализовать, например, некото-
рые типы ограничений, в частности, внешние ключи. Хотя можно определить правило с ограни-
чивающим условием, которое будет преобразовать команду в NOTHING, если значение ключа не
находится в другой таблице, но при этом неподходящие данные будут отбрасываться молча, а это
не самый лучший вариант. Также, если требуется проверить правильность значений и, обнаружив
неверное значение, выдать ошибку, это нужно делать в триггере.
В этой главе мы разберём использование правил для изменения представлений. Все правила, при-
ведённые в примерах этой главы, можно также заменить триггерами INSTEAD OF для представле-
ний. Написать такие триггеры часто бывает проще, чем разработать правила, особенно если для
изменений применяется сложная логика.
Для тех задач, которые можно решить обоими способами, лучший выбирается в зависимости от
характера использования базы данных. Следует учитывать, что триггер срабатывает для каждой
обрабатываемой строки, а правило изменяет существующий запрос или создаёт ещё один. Поэто-
1118Система правил
му, если один оператор обрабатывает сразу много строк, правило, добавляющее дополнительную
команду, скорее всего, будет работать быстрее, чем триггер, который вызывается для каждой оче-
редной строки и должен каждый раз определять, что с ней делать. Однако триггеры концептуаль-
но гораздо проще правил, и использовать их правильно новичкам гораздо проще.
Давайте рассмотрим пример, показывающий, как выбор в пользу правил вместо триггеров оказы-
вается выигрышным в определённой ситуации. Пусть у нас есть две таблицы:
CREATE TABLE computer (
hostname
text,
manufacturer
text
); – индексированное
– индексированное
CREATE TABLE software (
software
text,
hostname
text
); – индексированное
– индексированное
Обе таблицы содержат несколько тысяч строк, а индексы по полю hostname являются уникальны-
ми. Правило или триггер должны реализовать ограничение, которое удалит строки из таблицы
software, ссылающиеся на удаляемый компьютер. Триггер выполнял бы такую команду:
DELETE FROM software WHERE hostname = $1;
Так как триггер вызывается для каждой отдельной строки, удаляемой из таблицы computer, он
может подготовить и сохранить план этой команды, а затем передавать значение hostname подго-
товленному запросу в параметрах. Правило же можно записать так:
CREATE RULE computer_del AS ON DELETE TO computer
DO DELETE FROM software WHERE hostname = OLD.hostname;
Теперь давайте взглянем на разные варианты удаления. В этом случае:
DELETE FROM computer WHERE hostname = ‘mypc.local.net’;
таблица computer сканируется по индексу (быстро), и команда, выполняемая триггером, так же бу-
дет применять сканирование по индексу (тоже быстро). Дополнительной командой правила будет:
DELETE FROM software WHERE computer.hostname = ‘mypc.local.net’
AND software.hostname = computer.hostname;
Так как созданы все необходимые индексы, планировщик создаст план
Nestloop
-&gt; Index Scan using comp_hostidx on computer
-&gt; Index Scan using soft_hostidx on software
Таким образом, большого различия в скорости между реализациями с триггером и с правилом не
будет.
Теперь мы хотим избавиться от 2000 компьютеров, у которых hostname начинается с old. Это мож-
но сделать двумя командами. Первая:
DELETE FROM computer WHERE hostname &gt;= ‘old’
AND hostname &lt; ‘ole’
Правило преобразует её в:
DELETE FROM software WHERE computer.hostname &gt;= ‘old’ AND computer.hostname &lt; ‘ole’
AND software.hostname = computer.hostname;
с планом:
Hash Join
-&gt; Seq Scan on software
-&gt; Hash
1119Система правил
-&gt;
Index Scan using comp_hostidx on computer
С другой возможной командой:
DELETE FROM computer WHERE hostname ~ ‘^old’;
для запроса, преобразованного правилом, получается следующий план:
Nestloop
-&gt; Index Scan using comp_hostidx on computer
-&gt; Index Scan using soft_hostidx on software
Это показывает, что планировщик не понимает, что ограничение по hostname в computer можно
также использовать для сканирования по индексу в software, когда несколько условий объединя-
ются с помощью AND, что он успешно делает для варианта команды с регулярным выражением.
Триггер будет вызываться для каждой из 2000 удаляемых записей о старых компьютерах, и это
приведёт к одному сканированию индекса в таблице computer и 2000 сканированиям индекса в
таблице software. Реализация с правилом делает это двумя командами, применяющими индексы.
Будет ли правило быстрее при последовательном сканировании, зависит от общего размера таб-
лицы software. С другой стороны, выполнение 2000 команд из триггера через менеджер SPI всё
равно займёт время, даже если все блоки индекса вскоре окажутся в кеше.
В завершение взгляните на эту команду:
DELETE FROM computer WHERE manufacturer = ‘bim’;
Она также может привести к удалению множества строк из таблицы computer. Поэтому триггер
снова пропустит через исполнитель такое же множество команд. Правило же выдаст следующую
команду:
DELETE FROM software WHERE computer.manufacturer = ‘bim’
AND software.hostname = computer.hostname;
План для этой команды снова будет содержать вложенный цикл по двум сканированиям индекса,
но на этот раз с другим индексом таблицы computer:
Nestloop
-&gt; Index Scan using comp_manufidx on computer
-&gt; Index Scan using soft_hostidx on software
Во всех этих случаях дополнительные команды будут более-менее независимыми от числа затра-
гиваемых строк.
Таким образом, правила будут значительно медленнее триггеров, только если их действия приво-
дят к образованию больших и плохо связанных соединений, когда планировщик оказывается бес-
силен.
1120</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page12/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page11/">11</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page12/">12</a></li>
      
    
      
        <li><strong class="current-page">13</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page14/">14</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page15/">15</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page14/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>