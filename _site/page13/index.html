<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page13/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page13/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-056/" title="Глава 56. Написание обработчика процедурного языка"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 56. Написание обработчика процедурного языка"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-056/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~5 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-056/" rel="bookmark" title="Глава 56. Написание обработчика процедурного языка" itemprop="url">Глава 56. Написание обработчика процедурного языка</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 56. Написание обработчика процедурного языка</p>

<p>Все функции, написанные на языке, вызываемом не через текущий интерфейс «версии 1» для ком-
пилируемых языков (а именно, это функции на процедурных языках и функции, написанные на
SQL) выполняются через обработчик вызова для заданного языка. Задача такого обработчика вы-
зова — выполнить функцию должным образом, например, интерпретируя для этого её исходный
текст. В этой главе в общих чертах рассказывается, как можно написать обработчик нового про-
цедурного языка.
Обработчик вызова процедурного языка — это «обычная » функция, которая разрабатывается на
компилируемом языке, таком как C, вызывается через интерфейс версии 1, и регистрируется в
PostgreSQL как не принимающая аргументы и возвращающая тип language_handler. Этот специ-
альный псевдотип помечает функцию как обработчик вызова и препятствует её вызову непосред-
ственно из команд SQL. Более подробно соглашение о вызовах и динамическая загрузка кода на
C описывается в Разделе 38.10.
Обработчик вызова вызывается так же, как и любая другая функция: он получает указатель на
переменную struct FunctionCallInfoData, содержащую значения аргументов и информацию о
вызываемой функции, и должен вернуть результат типа Datum (и, возможно, установить признак
isnull в структуре FunctionCallInfoData, если нужно вернуть результат SQL NULL). Отличие об-
работчика вызова от обычной вызываемой функцией состоит в том, что поле flinfo-&gt;fn_oid струк-
туры FunctionCallInfoData для него будет содержать OID вызываемой функции, а не самого обра-
ботчика. По этому OID обработчик вызова должен понять, какую функцию вызывать. Кроме того,
список передаваемых аргументов для него формируется в соответствии с объявлением целевой
функции, а не обработчика вызова.
Обработчик вызова сам должен выбрать запись функции из системного каталога pg_proc и про-
анализировать типы аргументов и результата вызываемой функции. Содержимое предложения AS
команды CREATE FUNCTION для этой функции будет находиться в столбце prosrc строки в pg_proc.
Обычно это исходный текст на процедурном языке, но в принципе это может быть и что-то другое,
например, путь к файлу или иные данные, говорящие обработчику вызова, что именно делать.
Часто функция многократно вызывается в одном SQL-операторе. Чтобы в таких случаях избежать
повторных обращений за информацией о вызываемой функции, обработчик вызова может восполь-
зоваться полем flinfo-&gt;fn_extra. Изначально оно содержит NULL, но обработчик вызова может
поместить в него указатель на требуемую информацию. При последующих вызовах, если поле
flinfo-&gt;fn_extra будет отлично от NULL, им можно воспользоваться и пропустить шаг получе-
ния этой информации. Обработчик вызова должен позаботиться о том, чтобы указатель в flinfo-</p>
<blockquote>
  <p>fn_extra указывал на блок памяти, который не будет освобождён раньше, чем завершится запрос
(именно столько может существовать структура FmgrInfo). В качестве одного из вариантов, это-
го можно добиться, разместив дополнительные данные в контексте памяти, заданном в flinfo-
fn_mcxt; срок жизни таких данных обычно совпадает со сроком жизни самой структуры FmgrInfo.
С другой стороны, обработчик может выбрать и более долгоживущий контекст памяти с тем, чтобы
кешировать определения функций и между запросами.
Когда функция на процедурном языке вызывается как триггер, ей не передаются аргументы
обычным способом; вместо этого поле context в FunctionCallInfoData указывает на структуру
TriggerData, тогда как при обычном вызове функции оно содержит NULL. Обработчик языка, в свою
очередь, должен каким-либо образом предоставить эту информацию функциям на этом процедур-
ном языке.
Шаблон обработчика процедурного языка, написанный на C, выглядит так:
#include “postgres.h”
#include “executor/spi.h”
#include “commands/trigger.h”
2085Написание обработчи-
ка процедурного языка
#include
#include
#include
#include
#include
“fmgr.h”
“access/heapam.h”
“utils/syscache.h”
“catalog/pg_proc.h”
“catalog/pg_type.h”
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(plsample_call_handler);
Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
Datum
retval;
if (CALLED_AS_TRIGGER(fcinfo))
{
/*</p>
  <ul>
    <li>Вызывается как триггерная функция
<em>/
TriggerData
*trigdata = (TriggerData *) fcinfo-&gt;context;
retval = …
}
else
{
/</em></li>
    <li>Вызывается как функция
*/
retval = …
}
return retval;
}
Чтобы завершить код обработчика, нужно добавить лишь несколько тысяч строк вместо многото-
чий.
Скомпилировав функцию-обработчик языка в загружаемый модуль (см. Подраздел 38.10.5), этот
язык (plsample) можно зарегистрировать следующими командами:
CREATE FUNCTION plsample_call_handler() RETURNS language_handler
AS ‘имя_файла’
LANGUAGE C;
CREATE LANGUAGE plsample
HANDLER plsample_call_handler;
Хотя обработчика вызова достаточно для создания простейшего процедурного языка, есть ещё две
функции, которые можно реализовать дополнительно, чтобы пользоваться языком было удобнее:
функция проверки и обработчик внедрённого кода. Функцию проверки можно реализовать, чтобы
производить проверку синтаксиса языка во время CREATE FUNCTION. Если же реализован обра-
ботчик внедрённого кода, этот язык будет поддерживать выполнение анонимных блоков кода ко-
мандой DO.
Если для процедурного языка предоставляется функция проверки, она должна быть объявлена как
функция, принимающая один параметр типа oid. Результат функции проверки игнорируется, так
что она обычно объявляется как возвращающая тип void. Эта функция будет вызываться в кон-
це выполнения команды CREATE FUNCTION, создающей или изменяющей функцию, написанную на
процедурном языке. Переданный ей OID указывает на строку в pg_proc для этой функции. Функ-
2086Написание обработчи-
ка процедурного языка
ция проверки должна выбрать эту строку обычным образом и произвести все необходимые провер-
ки. Прежде всего нужно вызвать CheckFunctionValidatorAccess(), чтобы отличить явные вызовы
этой функции от происходящих при выполнении команды CREATE FUNCTION. Затем обычно прове-
ряется, например, что типы аргументов и результата функции поддерживаются языком и что те-
ло функции синтаксически правильно для данного языка. Если функция проверки заключает, что
всё в порядке, она должна просто завершиться. Если же она обнаруживает ошибку, она должна
сообщить о ней через обычный механизм ereport(). Выданная таким образом ошибка приведёт к
откату транзакции, так что определение некорректной функции зафиксировано не будет.
Функции проверки обычно должны учитывать параметр check_function_bodies: если он отключён,
то дорогостоящие или зависящие от контекста проверки содержимого функции выполнять не сле-
дует. Если язык подразумевает выполнение кода в процессе компиляции, проверяющая функция
должна избегать проверок, которые влекут за собой такое выполнение. В частности, указанный
параметр отключает утилита pg_dump, чтобы она могла загружать функции на процедурных язы-
ках, не заботясь о побочных эффектах или зависимостях содержимого функций от других объектов
базы. (Вследствие этого требования, обработчик языка не должен полагать, что функция прошла
полную проверку. Смысл существования функции проверки не в том, чтобы убрать эти проверки
из обработчика вызова, а в том, чтобы немедленно уведомить пользователя об очевидных ошиб-
ках при выполнении CREATE FUNCTION.) Хотя выбор, что именно должно проверяться, по большо-
му счёту остаётся за функцией проверки, заметьте, что основной код CREATE FUNCTION выполняет
присваивания SET, связанные с функцией, только когда check_function_bodies включён. Таким
образом, проверки, результаты которых могут зависеть от параметров GUC, определённо должны
опускаться, когда check_function_bodies отключён, во избежание ложных ошибок при восстанов-
лении базы из копии.
Если для процедурного языка предоставляется обработчик встроенного кода, он должен объяв-
ляться в виде функции, принимающей один параметр типа internal. Результат такого обработчи-
ка игнорируется, поэтому обычно он объявляется как возвращающий тип void. Обработчик встро-
енного кода будет вызываться при выполнении оператора DO с данным процедурным языком. В ка-
честве параметра ему на самом деле передаётся указатель на структуру InlineCodeBlock, содер-
жащую информацию о параметрах DO, в частности, текст выполняемого анонимного блока внед-
рённого кода.
Все подобные объявления функций, а также саму команду CREATE LANGUAGE, рекомендуется упа-
ковывать в расширение так, чтобы для установки языка было достаточно простой команды CREATE
EXTENSION. За информацией о разработке расширений обратитесь к Разделу 38.16.
Реализация процедурных языков, включённых в стандартный дистрибутив, может послужить хо-
рошим примером при написании собственных обработчиков языков. Её вы можете найти в подка-
талоге src/pl дерева исходного кода. Некоторые полезные детали также можно узнать на страни-
це справки CREATE LANGUAGE.
2087</li>
  </ul>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-055/" title="Глава 55. Языковая поддержка"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 55. Языковая поддержка"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-055/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~10 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-055/" rel="bookmark" title="Глава 55. Языковая поддержка" itemprop="url">Глава 55. Языковая поддержка</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 55. Языковая поддержка</p>

<p>55.1. Переводчику</p>

<p>Программы PostgreSQL (серверные и клиентские) могут выдавать сообщения на предпочитаемом
вами языке — если эти сообщения были переведены. Создание и поддержка переведённых наборов
сообщений предполагает помощь со стороны людей, которые хорошо говорят на своём языке и
хотят сотрудничать с PostgreSQL. Для этого совершенно не обязательно быть программистом. В
данном разделе объясняется, как можно помочь.
55.1.1. Требования
Мы не будем оценивать ваши языковые навыки — данный раздел посвящён средствам программ-
ного обеспечения. Теоретически, требуется лишь текстовый редактор. Но, скорее всего, вы захо-
тите проверить свои переведённые сообщения. Когда вы выполняете configure, обязательно ис-
пользуйте параметр –enable-nls. Это также проверит библиотеку libintl и программу msgfmt, ко-
торые понадобятся всем пользователям в любом случае. Чтобы проверить свою работу, следуйте
соответствующим разделам инструкций по установке.
Если вы захотите выполнить перевод или слияние каталога сообщений (описано ниже), вам пона-
добятся, соответственно, программы xgettext и msgmerge в GNU-совместимой реализации. Позд-
нее, мы постараемся сделать так, что если вы будете использовать дистрибутив исходников, вам
не понадобится xgettext. (При работе с Git, вам всё же это будет необходимо). В настоящее время
рекомендуется GNU Gettext 0.10.36 или более поздняя версия.
К вашей реализации gettext должна прилагаться документация. Некоторая её часть, возможно,
будет продублирована ниже, но более подробную информацию следует искать там.
55.1.2. Основные понятия
Пары оригинальных (английских) сообщений и их (предположительно) переведённых эквивален-
тов хранятся в каталогах сообщений, по одному для каждой программы (хотя связанные програм-
мы могут иметь общий каталог) и для каждого языка перевода. Существует два формата, поддер-
живающих каталоги сообщений: Первый — «PO» (Portable Object, переносимый объект), который
является простым текстовым файлом с особым синтаксисом, редактируемый переводчиками. Вто-
рой — «MO» (Machine Object, машинный объект), который является двоичным файлом, генерируе-
мым из соответствующего файла PO, и используется при выполнении интернационализированной
программы. Переводчики не работают с файлами MO; фактически с ними едва ли кто-то работает
напрямую.
Файл каталога сообщений, как можно было предположить, имеет расширение .po или .mo. Базо-
вым именем является либо имя сопровождаемой им программы, либо язык, для которого создан
файл, в зависимости от ситуации. Это создаёт некоторую путаницу. Например, psql.po (файл PO
для psql) или fr.mo (файл MO на французском).
Здесь проиллюстрирован формат файлов PO:</p>
<h1 id="comment">comment</h1>
<p>msgid “original string”
msgstr “translated string”
msgid “more original”
msgstr “another translated”
“string can be broken up like this”
…
Строки msgid извлекаются из исходного кода программы (что необязательно, но это наиболее рас-
пространённый способ). Строки msgstr изначально пусты, и переводчик заполняет их переводами.
2080Языковая поддержка
Строки могут содержать экранирующие спецсимволы в стиле С и занимать несколько строк, как
в приведённом примере. (Следующая строка должна начинаться с начала строки.)
Символ # обозначает начало комментария. Если сразу за символом # следует пробел, то этим ком-
ментарием управляет переводчик. Комментарии также могут быть автоматическими, у которых
сразу за # следует символ, отличный от пробела. Они управляются различными инструментами,
которые работают с файлами PO и предназначены для переводчиков.
#. automatic comment
#: filename.c:1023
#, flags, flags
Комментарии в стиле #. извлекаются из исходного файла, где используется сообщение. Возмож-
но, программист вставил информацию для переводчика, например, о предполагаемом выравнива-
нии. Комментарий #: указывает точное место (места), где сообщение используется в исходном
коде. Переводчику не нужно смотреть на исходный код программы, но он может это сделать, ес-
ли сомневается в точности перевода. Комментарии #, содержат флаги, которые некоторым обра-
зом описывают сообщение. В настоящее время существует два флага: fuzzy устанавливается, ес-
ли сообщение, возможно, стало неактуально по причине изменений в исходном коде программы.
Переводчик может проверить это и, возможно, удалить флаг fuzzy. Заметьте, что fuzzy сообщения
недоступны конечному пользователю. Другой флаг это c-format, который указывает, что сообще-
ние является шаблоном формата в стиле printf. Это означает, что перевод также должен быть
строкой формата с таким же количеством и типом “заполнителей”. Существуют средства, которые
распознают и проверяют флаги c-format.
55.1.3. Создание и управление каталогами сообщений
Итак, как же создать «blank» каталог сообщений? Во-первых, зайдите в каталог, содержащий про-
грамму, сообщения которой необходимо перевести. Если имеется файл nls.mk, данная программа
подготовлена к переводу.
Если уже есть некоторые .po файлы, то кто-то уже занимался переводом. Файлы получают имя
language.po, где language это двухбуквенный языковой код ISO 639-1 (в нижнем регистре), на-
пример, fr.po для французского. Если требуется больше одного перевода на какой-либо язык,
файлы могут также быть названы language_region.po, где region это двухбуквенный код страны
ISO 3166-1 (в верхнем регистре), например, pt_BR.po для португальского в Бразилии. Если найден
необходимый язык, можно просто начать работать над этим файлом.
Если необходимо начать новый перевод, сначала выполните команду:
make init-po
В результате будет создан файл progname.pot. (.pot, чтобы отличать его от файлов PO, находящих-
ся «в эксплуатации». T означает «шаблон».) Скопируйте данный файл в language.po и редакти-
руйте его. Чтобы сообщить о том, что новый язык доступен, также редактируйте файл nls.mk и до-
бавляйте языковой код (или код языка и страны) к строке, которая выглядит следующим образом:
AVAIL_LANGUAGES := de fr
(Конечно, и другие языки могут появиться.)
По мере развития базовой программы или библиотеки, сообщения могут быть изменены или до-
бавлены программистами. В этом случае нет необходимости начинать с нуля. Вместо этого выпол-
ните команду:
make update-po
что создаст новый пустой файл каталога сообщений (файл с расширением pot, с которого вы на-
чали) и объединит его с существующими файлами PO. Если алгоритм слияния не распознаёт кон-
кретное сообщение, он ставит пометку «fuzzy», как говорилось выше. Новый файл PO сохраняется
с расширением .po.new.
2081Языковая поддержка
55.1.4. Редактирование файлов PO
Файлы PO можно редактировать при помощи обычного текстового редактора. Переводчику нужно
лишь вставить перевод между кавычками после директивы msgstr, добавить комментарии и изме-
нить флаг fuzzy. Существует также режим PO для Emacs, который представляется довольно полез-
ным.
Файлы PO не обязательно должны быть полностью заполнены. Программа автоматически вернётся
к использованию исходной строки, если перевод недоступен (или отсутствует). Вы вполне можете
предлагать для включения в исходный код неполный перевод; это даст возможность другим про-
должить работу над ним. Однако после слияния рекомендуется в первую очередь удалить ненуж-
ные неточные соответствия. Помните, что неточные соответствия в итоге не будут использоваться,
они могут лишь подсказывать, каким мог бы быть перевод похожей строки.
Ниже описаны моменты, которые следует учитывать при редактировании переводов:
• Если оригинал заканчивается переводом строки, важно, чтобы это было отражено и в перево-
де. То же относится к табуляции, и т. п.
• Если оригиналом является строка форматирования printf, то перевод должен иметь такой же
вид. Перевод также должен иметь те же спецификаторы формата в том же порядке. Иногда
правила языка таковы, что это невозможно или как минимум нелепо. В таком случае можно
модифицировать спецификаторы формата подобным образом:
msgstr “Die Datei %2$s hat %1$u Zeichen.”
Тогда первый заполнитель просто использует второй аргумент из списка.digits$ должен сто-
ять сразу за % до любых других модификаторов формата. (Эта возможность действительно су-
ществует в семействе функций printf. Вы, возможно, не слышали о ней раньше, потому что
она мало используется где-либо кроме интернационализации сообщений.)
• Если исходная строка содержит лингвистическую ошибку, сообщите об этом (или исправьте
самостоятельно в исходном коде программы) и переведите правильно. Верная строка может
быть добавлена, когда исходный программный код будет обновлен. Если исходная строка со-
держит фактическую ошибку, сообщите об этом (или исправьте самостоятельно) и не перево-
дите её. Вместо этого, можно отметить строку, оставив комментарий в файле PO.
• Сохраняйте стиль и тон исходной строки. В частности, сообщения, не являющиеся предложе-
ниями (cannot open file %s), вероятно, не следует начинать с заглавной буквы (если в вашем
языке есть разделение на регистры) или заканчивать точкой (если в вашем языке использу-
ются знаки препинания). Дополнительно см. Раздел 54.3.
• Если вы не знаете, что означает какое-либо сообщение, или если оно допускает двоякое тол-
кование, обратитесь за помощью через список рассылки разработчиков. По всей вероятности,
англоговорящие пользователи могут также его не понять или найти двусмысленным, поэтому
лучше исправить это сообщение.
55.2. Программисту
55.2.1. Механизмы
Данный раздел описывает как добавить языковую поддержку в программе или библиотеке, кото-
рая является частью дистрибутива PostgreSQL. В настоящий момент это относится только к про-
граммам на языке С.
Добавление языковой поддержки для программы
1.
Вставьте этот код в начало программы:
#ifdef ENABLE_NLS
#include <locale.h>
#endif
2082Языковая поддержка
...
#ifdef ENABLE_NLS
setlocale(LC_ALL, "");
bindtextdomain("progname", LOCALEDIR);
textdomain("progname");
#endif
(progname фактически может быть выбрана произвольно.)
2.
Везде, где сообщение нуждается в переводе, необходимо вставить вызов gettext(). Например:
fprintf(stderr, "panic level %d\n", lvl);
нужно заменить на:
fprintf(stderr, gettext("panic level %d\n"), lvl);
(gettext определяется как холостая команда, если NLS поддержка не настроена.)
Это часто приводит к немалой путанице. Один из распространённых подходов в этом случае:
#define _(x) gettext(x)
Ещё одно решение допустимо, если программа часто выполняет обмен данными через одну
или несколько функций, таких как ereport() в серверном процессе. Тогда вы выполняете внут-
ренний вызов функции gettext для каждой входящей строки.
3.
Добавьте файл nls.mk в каталог с исходными кодами программы. Данный файл будет считать-
ся сборочным файлом (makefile). В нём необходимо выполнить присвоение значений для сле-
дующих переменных:
CATALOG_NAME
Имя программы, которое указано в вызове textdomain().
AVAIL_LANGUAGES
Список выполненных переводов (изначально пустой).
GETTEXT_FILES
Список файлов, которые содержат подлежащие переводу строки, т. е. помеченные gettext
или альтернативным решением. В итоге, в него будут включены почти все исходные файлы
программы. Если список станет слишком длинным, можно первый «file» сделать + а второе
слово — файлом, который содержит по одному имени файла на строку.
GETTEXT_TRIGGERS
Утилитам, которые генерируют каталоги сообщений для работы переводчиков, должно
быть известно, какие вызовы функции содержат строки, подлежащие переводу. По умол-
чанию распознаются только вызовы gettext(). Если вы использовали _ или другие иден-
тификаторы, необходимо перечислить их здесь. Если подлежащая переводу строка не яв-
ляется первым аргументом, необходимо, чтобы элемент имел форму func:2 (для второго
аргумента). Если функция поддерживает сообщения в форме множественного числа, эле-
мент должен выглядеть следующим образом func:1,2 (идентификация аргументов в виде
сообщений в форме единственного и множественного числа).
Система сборки автоматически соберёт и установит каталоги сообщений.
55.2.2. Рекомендации по написанию сообщений
Ниже описаны некоторые рекомендации по написанию сообщений, которые легко перевести.
• Не составляйте предложения во время выполнения. Например:
printf("Files were %s.\n", flag ? "copied" : "removed");
2083Языковая поддержка
Порядок слов в предложении может отличаться в других языках. Также, даже если вы не за-
бываете вызывать gettext() для каждого фрагмента, возможно, что по отдельности они не бу-
дут переведены хорошо. Лучше продублировать небольшую часть кода, чтобы каждое сообще-
ние было переведено как единое целое. Лишь цифры, имена файлов и подобные текущие пере-
менные следует вставлять в текст сообщения во время выполнения.
• По тем же причинам следующий подход не будет работать:
printf("copied %d file%s", n, n!=1 ? "s" : "");
так как это подразумевает, как формируется форма множественного числа. Если вы думаете,
что сможете решить это таким способом:
if (n==1)
printf("copied 1 file");
else
printf("copied %d files", n):
возможно, вы будете разочарованы. В некоторых языках существует более двух форм, и они
образуются по особым правилам. Обычно лучше сформулировать сообщение, которое позво-
лит полностью избежать этой проблемы, например:
printf("number of copied files: %d", n);
Если вы действительно хотите формировать правильно составленные сообщения в форме мно-
жественного числа, есть способ этого добиться, но это несколько неудобно. При генерирова-
нии первичного или детализированного сообщения об ошибке в ereport(), можно написать
так:
errmsg_plural("copied %d file",
"copied %d files",
n,
n)
Первым аргументом является строка формата, соответствующая форме единственного чис-
ла в английском языке, вторым аргументом — строка формата, соответствующая форме мно-
жественного числа в английском языке, и третьим аргументом — управляющее целочислен-
ное значение, которое определяет, какую форму (единственного или множественного числа)
использовать. Последующие аргументы форматируются на основе строки формата, как обыч-
но. (Как правило, значение аргумента для управления формой множественного числа будет
также одним из значений, подлежащих форматированию, поэтому оно должно быть записа-
но дважды.) В английском языке важно лишь, является ли значение n единицей или нет, но
в других языках может быть много различных форм множественного числа. Переводчик рас-
сматривает две английские формы как группу и имеет возможность задать несколько вариан-
тов замены строк, при этом подходящий вариант выбирается исходя из текущего значения n.
Если вам нужно составить сообщение в форме множественного числа, которое не использует-
ся непосредственно при выводе сообщений в errmsg или errdetail, вы должны воспользовать-
ся базовой функцией ngettext. См. документацию по gettext.
• Если вы хотите передать какую-либо информацию переводчику, например о том, насколько
сообщение соотносится с другими выходными данными, перед строкой должен появиться ком-
ментарий, который начинается с translator, например:
/* translator: This message is not what it seems to be. */
Эти комментарии копируются в файлы каталога сообщений, чтобы переводчик мог их видеть.
2084</locale.h></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-054/" title="Глава 54. Соглашения по оформлению кода PostgreSQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 54. Соглашения по оформлению кода PostgreSQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-054/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~18 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-054/" rel="bookmark" title="Глава 54. Соглашения по оформлению кода PostgreSQL" itemprop="url">Глава 54. Соглашения по оформлению кода PostgreSQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 54. Соглашения по оформлению кода PostgreSQL</p>

<p>54.1. Форматирование</p>

<p>Исходный код форматируется с отступом на 4 позиции, с сохранением табуляции (т. е. символы
табуляции не разворачиваются в пробелы). Для каждого логического уровня отступа добавляется
одна табуляция.
Правила оформления (расположения скобок и т. д.) следуют соглашениям BSD. В частности, фи-
гурные скобки для управляемых ими блоков if, while, switch и т. д. размещаются в отдельных
строках.
Ограничьте размеры строк, чтобы код можно было читать в окне шириной 80 символов. (Это не
значит, что никогда нельзя заходить за 80 символов. Например, не стоит разбивать длинную стро-
ку сообщения в произвольных местах, просто чтобы код умещался в 80 символов, так как это в
результате скорее всего не сделает код более читабельным.)
Не используйте комментарии в стиле C++ (комментарии //). Строгие компиляторы ANSI C их
не принимают. По этой же причине не используйте расширения C++, например, не объявляйте
новые переменные в середине блока.
Предпочитаемый стиль многострочных блоков выглядит так:
/*</p>
<ul>
  <li>текст комментария начинается здесь</li>
  <li>и продолжается здесь
<em>/
Заметьте, что блоки комментариев, начинающиеся с первого символа, будут сохраняться утилитой
pgindent как есть, но содержимое блоков комментариев с отступами будет переразбито по строкам
как обычный текст. Если вы хотите сохранить разрывы строк в блоке с отступом, добавьте минусы
следующим образом:
/</em>———-</li>
  <li>текст комментария начинается здесь</li>
  <li>и продолжается здесь
<em>———-
*/
Хотя предлагаемые правки кода не обязательно должны следовать этим правилам форматирова-
ния, лучше их придерживаться. Ваш код будет пропущен через pgindent перед следующим выпус-
ком, поэтому нет смысла наводить в нём красоту по другим правилам. Для правок есть хорошее
правило: «оформляйте новый код так же, как выглядит существующий код вокруг».
В каталоге src/tools содержатся примеры файлов настройки, которые можно использовать с ре-
дакторами emacs, xemacs или vim для упрощения задачи форматирования кода в соответствии с
описанными соглашениями.
Чтобы табуляция показывалась должным образом в средствах просмотра текста more и less, их
можно вызвать так:
more -x4
less -x4
54.2. Вывод сообщений об ошибках в коде сервера
Сообщения об ошибках, предупреждения и обычные сообщения, выдаваемые в коде сервера долж-
ны создаваться функцией ereport или родственной её предшественницей elog. Использование
этой функции достаточно сложно и требует дополнительного объяснения.
2070Соглашения по оформ-
лению кода PostgreSQL
У каждого сообщения есть два обязательных элемента: уровень важности (от DEBUG до PANIC) и
основной текст сообщения. В дополнение к ним есть необязательные элементы, из которых часто
используется код идентификатора ошибки, соответствующий определению SQLSTATE в специфи-
кации SQL. Функция ereport сама по себе является просто оболочкой, которая существует в ос-
новном для синтаксического удобства, чтобы выдача сообщения выглядела как вызов функции в
коде C. Единственный параметр, который принимает непосредственно функция ereport, это уро-
вень важности. Основной текст и любые дополнительные элементы сообщения генерируются в
результате вызова вспомогательных функций, таких как errmsg, в вызове ereport.
Типичный вызов ereport выглядит примерно так:
ereport(ERROR,
(errcode(ERRCODE_DIVISION_BY_ZERO),
errmsg(“division by zero”)));
В нём задаётся уровень важности ERROR (заурядная ошибка). В вызове errcode указывается код
ошибки SQLSTATE по макросу, определённому в src/include/utils/errcodes.h. Вызов errmsg да-
ёт текст основного сообщения. Обратите внимание на дополнительный набор скобок, окружающих
вызовы вспомогательных функций — они загромождают код, но требуются синтаксисом.
Более сложный пример:
ereport(ERROR,
(errcode(ERRCODE_AMBIGUOUS_FUNCTION),
errmsg(“function %s is not unique”,
func_signature_string(funcname, nargs,
NIL, actual_arg_types)),
errhint(“Unable to choose a best candidate function. “
“You might need to add explicit typecasts.”)));
В нём демонстрируется использование кодов форматирования для включения значений времени
выполнения в текст сообщения. Также в нём добавляется дополнительное сообщение «подсказки».
При уровне важности ERROR или более высоком, ereport прерывает выполнение пользовательской
функции и не возвращает управление в вызывающий код. Если уровень важности ниже ERROR,
ereport завершается обычным способом.
Для ereport предлагаются следующие вспомогательные функции:
• errcode(sqlerrcode) задаёт код идентификатора ошибки SQLSTATE для дан-
ной ошибки. Если эта функция не вызывается, подразумевается идентифика-
тор ошибки ERRCODE_INTERNAL_ERROR при уровне важности ERROR или выше, либо
ERRCODE_WARNING при уровне важности WARNING, иначе (при уровне NOTICE или ниже) —
ERRCODE_SUCCESSFUL_COMPLETION. Хотя эти значения по умолчанию довольно разумны, всегда
стоит подумать, насколько они уместны, прежде чем опустить вызов errcode().
• errmsg(const char *msg, …) задаёт основной текст сообщения об ошибке и, возможно, зна-
чения времени выполнения, которые будут в него включаться. Эти включения записываются
кодами формата в стиле sprintf. В дополнение к стандартным кодам формата, принимаемым
функцией sprintf, можно использовать код формата %m, который вставит сообщение об ошиб-
1
ке, возвращённое строкой strerror для текущего значения errno. Для %m не требуется соот-
ветствующая запись в списке параметров errmsg. Заметьте, что эта строка будет пропущена
через gettext, то есть может быть локализована, до обработки кодов формата.
• errmsg_internal(const char *msg, …) действует как errmsg, но её строка сообщения не бу-
дет переводиться и включаться в словарь сообщений для интернационализации. Это следует
использовать для случаев, которые «не происходят никогда», так что тратить силы на их пере-
вод не стоит.
• errmsg_plural(const char *fmt_singular, const char *fmt_plural, unsigned long
n, …) действует подобно errmsg, но поддерживает различные формы сообщения с множе-
1
То есть значение, которое было текущим, когда была вызвана ereport; изменения errno во вспомогательных функциях выдачи сообщений на него не
повлияют. Это будет не так, если вы запишете strerror(errno) явно в списке параметров errmsg; поэтому делать так не нужно.
2071Соглашения по оформ-
лению кода PostgreSQL
ственными числами. Параметр fmt_singular задаёт строку формата на английском для един-
ственного числа, fmt_plural — формат для множественного числа, n задаёт целое число,
определяющее, какая именно форма множественного числа требуется, а остальные аргумен-
ты форматируются согласно выбранной строке формата. За дополнительными сведениями об-
ратитесь к Подразделу 55.2.2.
• errdetail(const char *msg, …) задаёт дополнительное «подробное» сообщение; оно долж-
но использоваться, когда есть дополнительная информация, которую неуместно включать в
основное сообщение. Строка сообщения обрабатывается так же, как и для errmsg.
• errdetail_internal(const char *msg, …) действует как errdetail, но её строка сообще-
ния не будет переводиться и включаться в словарь сообщений для интернационализации. Это
следует использовать для подробных сообщений, на перевод которых не стоит тратить силы,
например, когда это техническая информация, непонятная большинству пользователей.
• errdetail_plural(const char *fmt_singular, const char *fmt_plural, unsigned long
n, …) действует подобно errdetail, но поддерживает различные формы сообщения с мно-
жественными числами. За дополнительными сведениями обратитесь к Подразделу 55.2.2.
• errdetail_log(const char *msg, …) подобна errdetail, но выводимая строка попадает
только в журнал сервера, и никогда не передаётся клиенту. Если используется и errdetail
(или один из её эквивалентов), и errdetail_log, тогда одна строка передаётся клиенту, а дру-
гая отправляется в журнал. Это полезно для вывода подробных сообщений, имеющих конфи-
денциальный характер или большой размер, так что передавать их клиенту нежелательно.
• errdetail_log_plural(const char *fmt_singular, const char *fmt_plural, unsigned long
n, …) действует подобно errdetail_log, но поддерживает различные формы сообщения с
множественными числами. За дополнительными сведениями обратитесь к Подразделу 55.2.2.
• errhint(const char *msg, …) передаёт дополнительное сообщение «подсказки»; это поз-
воляет предложить решение проблемы, а не просто сообщить факты, связанные с ней. Строка
сообщения обрабатывается так же, как и для errmsg.
• errcontext(const char *msg, …) обычно не вызывается непосредственно с места вызова
ereport, а используется в функциях обратного вызова error_context_stack и выдаёт инфор-
мацию о контексте, в котором произошла ошибка, например, о текущем положении в функции
PL. Строка сообщения обрабатывается так же, как и для errmsg. В отличие от других вспомо-
гательных функций, внутри вызова ereport её можно вызывать неоднократно; добавляемые
таким образом последовательные сообщения складываются через символы перевода строк.
• errposition(int cursorpos) задаёт положение ошибки в тексте запроса. В настоящее время
это полезно только для ошибок, выявляемых на этапах лексического и синтаксического ана-
лиза запроса.
• errtable(Relation rel) определяет отношение, имя и схема которого должны быть включе-
ны во вспомогательные поля сообщения об ошибке.
• errtablecol(Relation rel, int attnum) определяет столбец, имя которого, вместе с именем
таблицы и схемы, должно быть включено во вспомогательные поля сообщения об ошибке.
• errtableconstraint(Relation rel, const char *conname) задаёт имя ограничения таблицы,
которое вместе с именем таблицы и схемы должно быть включено во вспомогательные поля
сообщения об ошибке. В данном контексте индекс считается ограничением, независимо от то-
го, имеется ли для него запись в pg_constraint. Заметьте, что при этом в качестве rel нужно
передавать нижележащее отношение, а не сам индекс.
• errdatatype(Oid datatypeOid) задаёт тип данных, имя которого, вместе с именем схемы,
должно включаться во вспомогательные поля сообщения об ошибке.
• errdomainconstraint(Oid datatypeOid, const char *conname) задаёт имя ограничения доме-
на, которое вместе с именем домена и схемы должно включаться во вспомогательные поля со-
общения об ошибке.
• errcode_for_file_access() — вспомогательная функция, выбирающая подходящий иденти-
фикатор SQLSTATE при сбое в системном вызове, в котором происходит обращение к фай-
2072Соглашения по оформ-
лению кода PostgreSQL
ловой системе. Какой код ошибки генерировать, она определяет по сохранённому значению
errno. Обычно это используется в сочетании с %m в основном сообщении об ошибке.
• errcode_for_socket_access() — вспомогательная функция, выбирающая подходящий иденти-
фикатор SQLSTATE при сбое в системном вызове, в котором происходит обращение к сокетам.
• errhidestmt(bool hide_stmt) может быть вызвана для подавления вывода поля ОПЕРАТОР:
(STATEMENT:) в журнал сервера. Обычно это уместно, когда само сообщение включает текст
текущего оператора.
• errhidecontext(bool hide_ctx) может быть вызвана для подавления вывода поля КОНТЕКСТ:
(CONTEXT:) в журнал сервера. Это следует использовать только для подробных отладочных со-
общений, в которых одна и та же информация о контексте, выводимая в журнал, будет только
чрезмерно замусоривать его.
Примечание
В вызове ereport следует использовать максимум одну из функций errtable,
errtablecol, errtableconstraint, errdatatype или errdomainconstraint. Данные
функции существуют для того, чтобы приложения могли извлечь имя объекта базы
данных, связанного с условием ошибки, так, чтобы для этого им не требовалось раз-
бирать текст ошибки, возможно локализованный. Эти функции должны использовать-
ся в случае ошибок, для которых может быть желательной автоматическая обработка.
Для версии PostgreSQL 9.3 этот подход распространяется полностью только на ошибки
класса SQLSTATE 23 (нарушение целостности ограничения), но в будущем область его
применения может быть расширена.
Существует также более старая, но тем не менее активно используемая функция elog. Вызов elog:
elog(level, “format string”, …);
полностью равнозначен вызову:
ereport(level, (errmsg_internal(“format string”, …)));
Заметьте, что код ошибки SQLSTATE всегда определяется неявно, а строка сообщения не подлежит
переводу. Таким образом, elog следует использовать только для внутренних ошибок и отладки на
низком уровне. Любое сообщение, которое может представлять интерес для обычных пользовате-
лей, должно проходить через ereport. Тем не менее, в системе есть достаточно много внутренних
проверок для случаев, «которые не должны происходить», и в них по-прежнему широко использу-
ется elog; для таких сообщений эта функция предпочитается из-за простоты записи.
Советы по написанию хороших сообщений об ошибках можно найти в Разделе 54.3.
54.3. Руководство по стилю сообщений об ошибках
Это руководство по стилю предлагается в надежде обеспечить единообразный и понятный поль-
зователю стиль для всех сообщений, которые выдаёт PostgreSQL.
54.3.1. Что и куда выводить
Основное сообщение должно быть кратким, фактологическим и, по возможности, не говорить о
тонкостях реализации, например, не упоминать конкретные имена функций. Под «кратким» по-
нимается «должно умещаться в одной строке при обычных условиях». Дополнительное подробное
сообщение добавляется, когда краткого сообщения недостаточно, или вы считаете, что нужно упо-
мянуть какие-то внутренние детали, например, конкретный системный вызов, в котором произо-
шла ошибка. И основное, и подробное сообщения должны сообщать исключительно факты. Чтобы
предложить решение проблемы, особенно, если это решение может быть применимо не всегда,
передайте его в сообщении-подсказке.
Например, вместо:
IpcMemoryCreate: ошибка в shmget(ключ=%d, размер=%u, 0%o): %m
2073Соглашения по оформ-
лению кода PostgreSQL
(плюс длинное дополнение, по сути представляющее собой подсказку)
следует записать:
Основное:
Подробное:
Подсказка:
не удалось создать сегмент разделяемой памяти: %m
Ошибка в системном вызове shmget(key=%d, size=%u, 0%o).
дополнительный текст
Объяснение: когда основное сообщение достаточно краткое, клиенты могут выделить для него ме-
сто на экране в предположении, что одной строки будет достаточно. Подробное сообщение и под-
сказка могут выводиться в режиме дополнительных сведений или, возможно, в разворачивающем-
ся окне «ошибка-подробности». Кроме того, подробности и подсказки обычно не записываются в
журнал сервера для сокращения его объёма. Детали реализации лучше опускать, так как пользо-
ватели не должны в них разбираться.
54.3.2. Форматирование
Не полагайтесь на какое-либо определённое форматирование в тексте сообщений. Следует ожи-
дать, что в клиентском интерфейсе и в журнале сервера длинные строки будут переноситься в
зависимости от ситуации. В длинных сообщениях можно обозначить предполагаемые места раз-
рыва абзацев символами новой строки (\n). Завершать сообщение этим символом не нужно. Также
не используйте табуляции или другие символы форматирования. (При выводе контекста ошибок
автоматически добавляются символы перевода строки для разделения уровней контекста, напри-
мер, вызовов функций.)
Объяснение: сообщение не обязательно будет выводиться в интерфейсе терминального типа. В
графических интерфейсах или браузерах эти инструкции форматирования в лучшем случае игно-
рируются.
54.3.3. Символы кавычек
В тексте на английском языке везде, где это уместно, следует использовать двойные кавычки. В
тексте на других языках следует единообразно использовать тот тип кавычек, который принят для
печати вывода других программ.
Объяснение: выбор двойных кавычек вместо апострофов несколько своевольный, но ему сейчас от-
даётся предпочтение. Некоторые разработчики предлагали выбирать тип кавычек в зависимости
от типа объекта, следуя соглашениям SQL (а именно, строки заключать в апострофы, а идентифи-
каторы в кавычки). Но это внутренняя техническая особенность языка, о которой многие пользо-
ватели даже не догадываются; кроме того, это нельзя распространить на другие типы сущностей
в кавычках, не всегда можно перевести на другие языки и к тому же довольно бессмысленно.
54.3.4. Использование кавычек
Всегда используйте кавычки для заключения имён файлов, задаваемых пользователем идентифи-
каторов и других переменных, которые могут содержать слова. Не заключайте в кавычки пере-
менные, которые никогда не будут содержать слова (например, имена операторов).
В коде сервера есть функции, которые при необходимости сами заключают выводимый результат в
кавычки (например, format_type_be()). Дополнительные кавычки вокруг результата таких функ-
ций добавлять не следует.
Объяснение: у объектов могут быть имена, создающие двусмысленность, когда они появляются в
сообщении. Всегда одинаково обозначайте, где начинается и где заканчивается встроенное имя.
Но не загромождайте сообщения ненужными или повторными знаками кавычек.
54.3.5. Грамматика и пунктуация
Правила для основного сообщения и дополнительного сообщения/подсказки различаются:
Основное сообщение об ошибке: не делайте первую букву заглавной. Не завершайте сообщение
точкой. Даже не думайте о том, чтобы завершить сообщение восклицательным знаком!
2074Соглашения по оформ-
лению кода PostgreSQL
Подробное сообщение и подсказка: пишите полные предложения и завершайте каждое точкой.
Начинайте первое слово предложения с большой буквы. Добавляйте два пробела после точки, если
за одним предложением следует другое (для английского текста; может не подходить для других
языков).
Строка с контекстом ошибки: не делайте первую букву заглавной и не завершайте строку точкой.
Строки контекста обычно не должны быть полными предложениями.
Объяснение: при отсутствии знаков пунктуации клиентским приложениям проще вставить сооб-
щение в самые разные грамматические контексты. Часто основные сообщения всё равно не явля-
ются грамматически полными предложениями. (Если сообщение настолько длинное, что занима-
ет не одно предложение, его следует поделить на основную и дополнительную часть.) Однако по-
дробные сообщения и подсказки по определению длиннее и могут содержать несколько предло-
жений. Единообразия ради, они должны следовать стилю полного предложения, даже если пред-
ложение всего одно.
54.3.6. Верхний регистр или нижний регистр
Пишите сообщение в нижнем регистре, включая первую букву основного сообщения об ошибке.
Используйте верхний регистр для команд SQL и ключевых слов, если они выводятся в сообщении.
Объяснение: так проще сделать, чтобы всё выглядело единообразно, так как некоторые сообщения
могут быть полными предложениями, а другие нет.
54.3.7. Избегайте пассивного залога
Используйте активный залог. Когда есть действующий субъект, формулируйте полные предложе-
ния («A не удалось сделать B»). Используйте телеграфный стиль без субъекта, если субъект — сама
программа; не пишите «я» от имени программы.
Объяснение: программа — не человек. Не создавайте впечатление, что это не так.
54.3.8. Настоящее или прошедшее время
Используйте прошедшее время, если попытка сделать что-то не удалась, но может быть успеш-
ной в следующий раз (возможно, после устранения некоторой проблемы). Используйте настоящее
время, если ошибка, определённо, постоянная.
Есть нетривиальное смысловое различие между предложениями вида:
не удалось открыть файл “%s”: %m
и:
нельзя открыть файл “%s”
Первое означает, что попытка открыть файл не удалась. Сообщение должно сообщать причину,
например, «переполнение диска» или «файл не существует». Прошедшее время уместно, потому
что в следующий раз диск может быть не переполнен или запрошенный файл будет найден.
Вторая форма показывает, что функциональность открытия файла с заданным именем полностью
отсутствует в программе, либо это невозможно в принципе. Настоящее время в этом случае умест-
но, так как это условие будет сохраняться неопределённое время.
Объяснение: конечно, средний пользователь не сможет сделать глубокие выводы, проанализиро-
вав синтаксическое время, но если язык даёт нам возможность такого выражения, мы должны
использовать это корректно.
54.3.9. Тип объекта
Цитируя имя объекта, указывайте также его тип.
Объяснение: иначе никто не поймёт, к чему относится «foo.bar.baz».
2075Соглашения по оформ-
лению кода PostgreSQL
54.3.10. Скобки
Квадратные скобки должны использоваться только (1) в описаниях команд и обозначать необяза-
тельные аргументы, либо (2) для обозначения индекса массива.
Объяснение: все другие варианты их использования не являются общепринятыми и будут вводить
в заблуждение.
54.3.11. Сборка сообщений об ошибках
Когда сообщение включает текст, сгенерированный в другом месте, внедряйте его следующим
образом:
не удалось открыть файл %s: %m
Объяснение: довольно сложно учесть все возможные варианты ошибок, которые будут вставляться
в предложение, чтобы оно при этом оставалось складным, поэтому требуется какая-то пунктуация.
Было предложение заключать включаемый текст в скобки, но это не вполне естественно, если этот
текст содержит наиболее важную часть сообщения, что часто имеет место.
54.3.12. Причины ошибок
Сообщения должны всегда сообщать о причине произошедшей ошибки. Например:
ПЛОХО:
ЛУЧШЕ:
не удалось открыть файл %s
не удалось открыть файл %s (ошибка ввода/вывода)
Если причина неизвестна, лучше исправить код.
54.3.13. Имена функций
Не включайте в текст ошибки имя функции, в которой возникла ошибка. У нас есть другие меха-
низмы, позволяющие узнать его, когда требуется, а для большинства пользователей это бесполез-
ная информация. Если текст ошибки оказывается бессвязным без имени функции, перефразируй-
те его.
ПЛОХО:
ЛУЧШЕ:
pg_atoi: ошибка в “z”: не удалось разобрать “z”
неверное значение для целого числа: “z”
Избегайте упоминания имён вызываемых функций; вместо этого скажите, что пытается делать
код:
ПЛОХО:
ЛУЧШЕ:
ошибка в open(): %m
не удалось открыть файл %s: %m
Если это действительно кажется необходимым, упомяните системный вызов в подробном сообще-
нии. (В некоторых случаях в подробном сообщении стоит показать фактические значения, пере-
даваемые системному вызову.)
Объяснение: пользователи не знают, что делают все эти функции.
54.3.14. Скользкие слова, которых следует избегать
Unable (Неспособен).  «Unable» — это почти пассивный залог. Лучше использовать «cannot»
(нельзя) или «could not» (не удалось), в зависимости от ситуации.
Bad (Плохое).  Сообщения об ошибках типа «bad result» (плохой результат) трудно воспринять
осмысленно. Лучше написать, почему результат «плохой», например, «invalid format» (неверный
формат).
Illegal (Нелегальное).  «Illegal» (нелегально) — то, что нарушает закон, всё остальное можно
называть «invalid» (неверным). Опять же лучше сказать, почему что-то неверное.
Unknown (Неизвестное).  Постарайтесь исключить «unknown» (неизвестное). Взгляните на со-
общение: «error: unknown response» (ошибка: неизвестный ответ). Если вы не знаете, что за ответ
2076Соглашения по оформ-
лению кода PostgreSQL
получен, как вы поняли, что он ошибочный? Вместо этого часто лучше сказать «unrecognized»
(нераспознанный). Также обязательно добавьте значение, которое не было воспринято.
ПЛОХО:
ЛУЧШЕ:
неизвестный тип узла
нераспознанный тип узла: 42
«Не найдено» или «не существует».  Если программа выполняет поиск ресурса, используя
нетривиальный алгоритм (например, поиск по пути), и этот алгоритм не срабатывает, лучше чест-
но сказать, что программа не смогла «найти» ресурс. С другой стороны, если ожидаемое располо-
жение ресурса точно известно, но программа не может обратиться к нему, скажите, что этот ре-
сурс не «существует». Формулировка с глаголом «найти» в данном случае звучит слабо и затруд-
няет понимание.
Разрешено, могу или возможно.  «May» (разрешено) подразумевает разрешение (например,
«Вам разрешено воспользоваться моими граблями.») и этому практически нет применения в доку-
ментации или сообщениях об ошибках. «Can» (могу) подразумевает способность (например, «Я мо-
гу поднять это бревно.»), а «might» (возможно) подразумевает возможность (например, «Сегодня
возможен дождь.»). Использование подходящего слова проясняет значение и облегчает перевод.
Сокращения.
Избегайте сокращений, например «can’t»; вместо это напишите «cannot».
54.3.15. Правильное написание
Пишите слова полностью. Например, избегайте (в английском):
• spec
• stats
• parens
• auth
• xact
Объяснение: так сообщения будут единообразными.
54.3.16. Локализация
Помните, что текст сообщений должен переводиться на другие языки. Следуйте советам, приве-
дённым в Подразделе 55.2.2, чтобы излишне не усложнять жизнь переводчикам.
54.4. Различные соглашения по оформлению кода
54.4.1. Стандарт C
Код в PostgreSQL должен использовать только те возможности языка, что описаны в стандарте
C89. Это означает, что код postgres должен успешно компилироваться компилятором, поддержи-
вающим C89, возможно, за исключением нескольких платформозависимых мест. Возможности бо-
лее поздних ревизий стандарта C или специфические особенности компилятора могут использо-
ваться, только если предусмотрен и вариант компиляции без них.
Например, в настоящее время используются конструкции static inline и _StaticAssert(), хотя
они относятся к более новым ревизиям стандарта C. Но если они недоступны, мы соответственно
переходим к определению функций без inline, и к использованию альтернативы, которая совме-
стима с C89 и выполняет те же проверки, но выдаёт довольно непонятные сообщения.
54.4.2. Внедрённые функции и макросы, подобные функциям
Допускается использование и макросов с аргументами, и функций static inline. Последний ва-
риант предпочтительнее, если возникает риск множественного вычисления выражений в макро-
се, как например в случае с
#define Max(x, y)
((x) &gt; (y) ? (x) : (y))
2077Соглашения по оформ-
лению кода PostgreSQL
или когда макрос может быть слишком объёмным. В других случаях использовать макросы — един-
ственный, или как минимум более простой вариант. Например, может быть полезна возможность
передавать макросу выражения различных типов.
Когда определение внедрённой функции обращается к символам (переменным, функциям), доступ-
ным только в серверном коде, такая функция не должна быть видна при включении в клиентский
код.
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
MemoryContext old = CurrentMemoryContext;
CurrentMemoryContext = context;
return old;
}
#endif
/</em> FRONTEND <em>/
В этом примере вызывается функция CurrentMemoryContext, существующая только на стороне сер-
вера, и поэтому функция скрыта директивой #ifndef FRONTEND. Это правило введено, потому что
некоторые компиляторы генерируют указатели на символы, фигурирующие во внедрённых функ-
циях, даже когда эти функции не используются.
54.4.3. Написание обработчиков сигналов
Чтобы код мог выполняться внутри обработчика сигналов, его нужно написать очень аккуратно.
Фундаментальная сложность состоит в том, что обработчик сигнала может прервать код в любой
момент, если он не отключён. Если код внутри обработчика сигнала использует то же состояние,
что и внешний основной код, это может привести к хаосу. В качестве примера представьте, что
произойдёт, если обработчик сигнала попытается получить ту же блокировку, которой уже владе-
ет прерванный код.
Если не предпринимать специальных мер, код в обработчиках сигналов может вызывать только
безопасные с точки зрения асинхронных сигналов функции (как это определяется в POSIX) и об-
ращаться к переменным типа volatile sig_atomic_t. Также безопасными для обработчиков сиг-
налов считаются несколько функций в postgres, в том числе, что важно, SetLatch().
В большинстве случаев обработчики событий должны только сообщить о поступлении сигнала
и пробудить код снаружи обработчика, используя защёлку. Например, обработчик может быть
таким:
static void
handle_sighup(SIGNAL_ARGS)
{
int
save_errno = errno;
got_SIGHUP = true;
SetLatch(MyLatch);
errno = save_errno;
}
Переменная errno сохраняется и восстанавливается, так как её может изменить SetLatch(). Если
этого не сделать, прерванный код, считывая errno, мог бы получить некорректное значение.
54.4.4. Вызов функций по указателям
Вызов функции по указателю может записываться по-разному. Ясности ради, когда указатель на
функцию — простая переменная, предпочтительным вариантом считается запись с явным разы-
менованием указателя, например:
2078Соглашения по оформ-
лению кода PostgreSQL
(</em>emit_log_hook) (edata);
(хотя будет работать и просто emit_log_hook(edata)). Когда указатель на функции является ча-
стью структуры, дополнительные знаки пунктуации можно и обычно даже нужно опускать, напри-
мер:
paramInfo-&gt;paramFetch(paramInfo, paramId);
2079</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page12/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page11/">11</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page12/">12</a></li>
      
    
      
        <li><strong class="current-page">13</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page14/">14</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page15/">15</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page40/">40</a></li>
    

    
    
      <li><a href="http://localhost:4000/page14/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>