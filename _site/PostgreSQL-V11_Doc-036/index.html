<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 36. ECPG — встраиваемый SQL в C &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 36. ECPG — встраиваемый SQL в C">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 36. ECPG — встраиваемый SQL в C">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-036/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-036/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 36. ECPG — встраиваемый SQL в C">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-036/" rel="bookmark" title="Глава 36. ECPG — встраиваемый SQL в C">Глава 36. ECPG — встраиваемый SQL в C</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~121 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 36. ECPG — встраиваемый SQL в C</p>

<p>В этой главе описывается встраиваемый SQL для PostgreSQL. Авторы этой разработки: Линус
Толке (<a href="mailto:linus@epact.se">linus@epact.se</a>) и Михаэль Мескес (<a href="mailto:meskes@postgresql.org">meskes@postgresql.org</a>). Изначально этот проект
предназначался для C. Сейчас он также работает с C++, но пока не распознаёт все конструкции
C++.
Эта документация не абсолютно полная, но так как этот интерфейс стандартизирован, дополни-
тельные сведения можно почерпнуть во многих ресурсах, посвящённых SQL.
36.1. Концепция
Программа со встраиваемым SQL состоит из кода, написанного на обычном языке программирова-
ния, в данном случае, С, дополненного командами SQL в специально обозначенных секциях. Чтобы
собрать программу, её исходный код (<em>.pgc) сначала нужно пропустить через препроцессор встра-
иваемого SQL, который превратит её в обычную программу на C (</em>.c), которую затем сможет об-
работать компилятор C. (Подробнее компиляция и компоновка описывается в Разделе 36.10). Пре-
образованные приложения ECPG вызывают функции в библиотеке libpq через библиотеку встраи-
ваемого SQL (ecpglib) и взаимодействуют с сервером PostgreSQL по обычному клиент-серверному
протоколу.
Встраиваемый SQL имеет ряд преимуществ по сравнению с другими методами вызова команд SQL
из кода C. Во-первых, этот механизм берёт на себя заботу о передаче информации через перемен-
ные в программе на C. Во-вторых, код SQL в программе проверяется на синтаксическую правиль-
ность во время сборки. В-третьих, встраиваемый SQL в C описан стандартом SQL и поддержива-
ется многими другими СУБД SQL. Реализация в PostgreSQL разработана так, чтобы максималь-
но соответствовать этому стандарту, поэтому обычно достаточно легко портировать в PostgreSQL
программы с встраиваемым SQL, написанные для других СУБД.
Как уже сказано, программы, написанные для интерфейса встраиваемого SQL, представляют со-
бой обычные программы на C с добавленным специальным кодом, который выполняет действия,
связанные с базой данных. Этот специальный код всегда имеет следующую форму:
EXEC SQL …;
Такие операторы синтаксически занимают место операторов C. В зависимости от конкретного опе-
ратора, они могут размещаться на глобальном уровне или внутри функции. Встраиваемые опера-
торы SQL следуют правилам учёта регистра, принятым в обычном коде SQL, а не в C. Они также
допускают вложенные комментарии в стиле C, разрешённые стандартом SQL. Однако остальная
часть программы, написанная на C, в соответствии со стандартом C содержать вложенные ком-
ментарии не может.
Все встраиваемые операторы SQL рассматриваются в следующих разделах.
36.2. Управление подключениями к базе данных
В этом разделе описывается, как открывать, закрывать и переключать подключения к базам дан-
ных.
36.2.1. Подключение к серверу баз данных
Подключение к базе данных выполняется следующим оператором:
EXEC SQL CONNECT TO цель-подключения [AS имя-подключения] [USER имя-пользователя];
Цель может задаваться следующими способами:
• имя_бд[@имя_сервера][:порт]
• tcp:postgresql://имя_сервера[:порт][/имя_бд][?параметры]
843ECPG — встраиваемый SQL в C
• unix:postgresql://имя_сервера[:порт][/имя_бд][?параметры]
• строковая константа SQL, содержащая одну из вышеприведённых записей
• ссылка на символьную переменную, содержащую одну из вышеприведённых записей (см. при-
меры)
• DEFAULT
Если цель подключения задаётся буквально (то есть не через переменную) и значение не заклю-
чается в кавычки, регистр в этой строке не учитывается, как в обычном SQL. В этом случае при
необходимости также можно заключить в двойные кавычки отдельные параметры. На практике,
чтобы не провоцировать ошибки, лучше заключать строку в апострофы, либо передавать её в пе-
ременной. С целью подключения DEFAULT устанавливается подключение к базе данных по умол-
чанию с именем пользователя по умолчанию. Другое имя пользователя или имя подключения в
этом случае указать нельзя.
Также разными способами можно указать имя пользователя:
• имя_пользователя
• имя_пользователя/пароль
• имя_пользователя IDENTIFIED BY пароль
• имя_пользователя USING пароль
В показанных выше строках имя_пользователя и пароль могут задаваться идентификатором или
строковой константой SQL, либо ссылкой на символьную переменную.
Указание имя-подключения применяется, когда в одной программе нужно использовать несколько
подключений. Его можно опустить, если программа работает только с одним подключением. Со-
единение, открытое последним, становится текущим и будет использоваться по умолчанию при
выполнении операторов SQL (это описывается далее в этой главе).
Если к базе данных, которая не приведена в соответствие шаблону безопасного использования
схем, имеют доступ недоверенные пользователи, начинайте сеанс с удаления доступных им для
записи схем из пути поиска (search_path). Например, добавьте options=-csearch_path= в options
или выполните EXEC SQL SELECT pg_catalog.set_config(‘search_path’, ‘’, false); после под-
ключения. Это касается не только ECPG, но и любых других интерфейсов для выполнения произ-
вольных SQL-команд.
Вот некоторые примеры оператора CONNECT:
EXEC SQL CONNECT TO mydb@sql.mydomain.com;
EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;
EXEC SQL BEGIN DECLARE SECTION;
const char <em>target = “mydb@sql.mydomain.com”;
const char *user = “john”;
const char *passwd = “secret”;
EXEC SQL END DECLARE SECTION;
…
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/</em> или EXEC SQL CONNECT TO :target USER :user/:passwd; */
В последней форме используется вариант, названный выше ссылкой на символьную переменную.
В последующих разделах вы узнаете, как в SQL-операторах можно использовать переменные C,
приставляя перед именем двоеточие.
Учтите, что формат цели подключения не описывается в стандарте SQL. Поэтому, если вы хотите
разрабатывать переносимые приложения, имеет смысл применить подход, показанный в послед-
нем примере, и сформировать строку подключения отдельно.
844ECPG — встраиваемый SQL в C
36.2.2. Выбор подключения
SQL-операторы в программах со встраиваемым SQL по умолчанию выполняются с текущим под-
ключением, то есть с подключением, которое было открыто последним. Если приложению нужно
управлять несколькими подключениями, это можно сделать двумя способами.
Первый вариант — явно выбирать подключение для каждого SQL-оператора, например, так:
EXEC SQL AT имя-подключения SELECT …;
Этот вариант хорошо подходит для случаев, когда приложению нужно использовать несколько
подключений в смешанном порядке.
Если ваше приложение выполняется в нескольких потоках, они не могут использовать подключе-
ние одновременно. Поэтому вы должны либо явно управлять доступом (используя мьютексы), либо
использовать отдельные подключения для каждого потока.
Второй вариант — выполнять оператор, переключающий текущее подключение. Этот оператор
записывается так:
EXEC SQL SET CONNECTION имя-подключения;
Этот вариант особенно удобен, когда с одним подключением нужно выполнить несколько опера-
торов.
Следующий пример программы демонстрирует управление несколькими подключениями к базам
данных:
#include <stdio.h>
EXEC SQL BEGIN DECLARE SECTION;
char dbname[1024];
EXEC SQL END DECLARE SECTION;
int
main()
{
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SQL
CONNECT TO testdb1 AS con1 USER testuser;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
CONNECT TO testdb2 AS con2 USER testuser;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
CONNECT TO testdb3 AS con3 USER testuser;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
/* This query would be executed in the last opened database "testdb3". */
EXEC SQL SELECT current_database() INTO :dbname;
printf("current=%s (should be testdb3)\n", dbname);
/* Using "AT" to run a query in "testdb2" */
EXEC SQL AT con2 SELECT current_database() INTO :dbname;
printf("current=%s (should be testdb2)\n", dbname);
/* Switch the current connection to "testdb1". */
EXEC SQL SET CONNECTION con1;
EXEC SQL SELECT current_database() INTO :dbname;
printf("current=%s (should be testdb1)\n", dbname);
EXEC SQL DISCONNECT ALL;
return 0;
}
845ECPG — встраиваемый SQL в C
Этот пример должен вывести следующее:
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
36.2.3. Закрытие подключения
Чтобы закрыть подключение, примените следующий оператор:
EXEC SQL DISCONNECT [подключение];
Подключение можно задать следующими способами:
• имя-подключения
• DEFAULT
• CURRENT
• ALL
Если имя подключения не задано, закрывается текущее подключение.
Хорошим стилем считается, когда приложение явно закрывает каждое подключение, которое оно
открыло.
36.3. Запуск команд SQL
В приложении со встраиваемым SQL можно запустить любую команду SQL. Ниже приведены
несколько примеров, показывающих как это делать.
36.3.1. Выполнение операторов SQL
Создание таблицы:
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
Добавление строк:
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
Удаление строк:
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
Изменение:
EXEC SQL UPDATE foo
SET ascii = 'foobar'
WHERE number = 9999;
EXEC SQL COMMIT;
Операторы SELECT, возвращающие одну строку результата, также могут выполняться непосред-
ственно командой EXEC SQL. Чтобы обработать наборы результатов с несколькими строками, при-
ложение должно использовать курсоры; см. Подраздел 36.3.2 ниже. (В отдельных случаях прило-
жение может выбрать сразу несколько строк в переменную массива; см. Подраздел 36.4.4.3.1.)
Выборка одной строки:
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
Так же можно получить параметр конфигурации командой SHOW:
846ECPG — встраиваемый SQL в C
EXEC SQL SHOW search_path INTO :var;
Идентификаторы вида :имя воспринимаются как переменные среды, то есть они ссылаются на
переменные программы C. Они рассматриваются в Разделе 36.4.
36.3.2. Использование курсоров
Чтобы получить набор результатов, содержащий несколько строк, приложение должно объявить
курсор и выбирать каждую строку через него. Использование курсора подразумевает следующие
шаги: объявление курсора, открытие его, выборку строки через курсор, повторение предыдущего
шага, и наконец, закрытие курсора.
Выборка с использованием курсоров:
EXEC SQL DECLARE foo_bar CURSOR FOR
SELECT number, ascii FROM foo
ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
Более подробно объявление курсора описывается в DECLARE, а команда FETCH описана в FETCH.
Примечание
Команда DECLARE в ECPG на самом деле не передаёт этот оператор серверу PostgreSQL.
Курсор открывается на сервере (командой сервера DECLARE) в момент, когда выполня-
ется команда OPEN.
36.3.3. Управление транзакциями
В режиме по умолчанию операторы фиксируются только когда выполняется EXEC SQL COMMIT. Ин-
терфейс встраиваемого SQL также поддерживает автофиксацию транзакций (так работает libpq
по умолчанию); она включается аргументом командной строки -t программы ecpg (см. ecpg) либо
оператором EXEC SQL SET AUTOCOMMIT TO ON. В режиме автофиксации каждая команда фиксиру-
ется автоматически, если только она не помещена в явный блок транзакции. Этот режим можно
выключить явным образом, выполнив EXEC SQL SET AUTOCOMMIT TO OFF.
Поддерживаются следующие команды управления транзакциями:
EXEC SQL COMMIT
Зафиксировать текущую транзакцию.
EXEC SQL ROLLBACK
Откатить текущую транзакцию.
EXEC SQL PREPARE TRANSACTIONид_транзакции
Подготовить текущую транзакцию для двухфазной фиксации.
EXEC SQL COMMIT PREPAREDид_транзакции
Зафиксировать транзакцию в подготовленном состоянии.
EXEC SQL ROLLBACK PREPAREDид_транзакции
Откатить транзакцию в подготовленном состоянии.
847ECPG — встраиваемый SQL в C
EXEC SQL SET AUTOCOMMIT TO ON
Включить режим автофиксации.
EXEC SQL SET AUTOCOMMIT TO OFF
Отключить режим автофиксации. По умолчанию он отключён.
36.3.4. Подготовленные операторы
Когда значения, передаваемые оператору SQL, неизвестны во время компиляции, или один и тот
же оператор будет использоваться многократно, могут быть полезны подготовленные операторы.
Оператор подготавливается командой PREPARE. Вместо значений, которые ещё неизвестны, встав-
ляются местозаполнители «?»:
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
Если оператор возвращает одну строку, приложение может вызвать EXECUTE после PREPARE для
выполнения этого оператора, указав фактические значения для местозаполнителей в предложе-
нии USING:
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
Если оператор возвращает несколько строк, приложение может использовать курсор, объявлен-
ный на базе подготовленного оператора. Чтобы привязать входные параметры, курсор нужно от-
крыть с предложением USING:
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
...
}
EXEC SQL CLOSE foo_bar;
Когда подготовленный оператор больше не нужен, его следует освободить:
EXEC SQL DEALLOCATE PREPARE имя;
Подробнее оператор PREPARE описан в PREPARE. Также обратитесь к Разделу 36.5 за дополнитель-
ными сведениями о местозаполнителях и входных параметрах.
36.4. Использование переменных среды
В Разделе 36.3 вы увидели, как можно выполнять операторы SQL в программе со встраиваемым
SQL. Некоторые из этих операторов использовали только фиксированные значения и не давали
возможности вставлять в операторы произвольные значения или обрабатывать значения, возвра-
щённые запросом. Операторы такого вида не очень полезны в реальных приложениях. В этом раз-
деле подробно описывается, как можно передавать данные между программой на C и встраивае-
мыми операторами SQL, используя простой механизм, так называемые переменные среды. В про-
грамме со встраиваемым SQL мы считаем SQL-операторы внедрёнными в код программы на C,
языке среды. Таким образом, переменные программы на C называются переменными среды.
Ещё один способ передать значения данных между сервером PostgreSQL и приложениями ECPG
заключается в использовании дескрипторов SQL, как описано в Разделе 36.7.
848ECPG — встраиваемый SQL в C
36.4.1. Обзор
Передавать данные между программой C и операторами SQL во встраиваемом SQL очень просто.
Вместо того, чтобы вставлять данные в оператор, что влечёт дополнительные усложнения, в част-
ности нужно правильно заключать значения в кавычки, можно просто записать имя переменной
C в операторе SQL, предварив его двоеточием. Например:
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
Этот оператор обращается к двум переменным C с именами v1 и v2 и также использует обычную
строковую константу SQL, показывая тем самым, что можно свободно сочетать разные виды дан-
ных.
Этот метод включения переменных C в операторы SQL работает везде, где оператор SQL прини-
мает выражение значения.
36.4.2. Секции объявлений
Чтобы передать данные из программы в базу данных, например, в виде параметров запроса, либо
получить данные из базы данных в программе, переменные C, которые должны содержать эти
данные, нужно объявить в специально помеченных секциях, чтобы препроцессор встраиваемого
SQL знал о них.
Секция начинается с:
EXEC SQL BEGIN DECLARE SECTION;
и заканчивается командой:
EXEC SQL END DECLARE SECTION;
Между этими строками должны располагаться обычные объявления переменных C, например:
int
char
x = 4;
foo[16], bar[16];
Как здесь показано, переменной можно присвоить начальное значение. Область видимости пере-
менной определяется расположением секции, в которой она объявляется в программе. Вы также
можете объявить переменную следующим образом (при этом неявно создаётся секция объявле-
ний):
EXEC SQL int i = 4;
Вы можете включать в программу столько секций объявлений, сколько захотите.
Эти объявления выводятся в результирующий файл как объявления обычных переменных C, так
что эти переменные не нужно объявлять снова. Переменные, которые не предназначены для ис-
пользования в командах SQL, можно объявить как обычно вне этих специальных секций.
Определение структуры или объединения тоже должно размещаться в секции DECLARE. В против-
ном случае препроцессор не сможет воспринять эти типы, так как не будет знать их определения.
36.4.3. Получение результатов запроса
Теперь вы умеете передавать данные, подготовленные вашей программой, в команду SQL. Но как
получить результаты запроса? Для этой цели во встраиваемом SQL есть особые вариации обычных
команд SELECT и FETCH. У этих команд есть специальное предложение INTO, определяющее, в ка-
кие переменные среды будут помещены получаемые значения. SELECT используется для запросов,
возвращающих только одну строку, а FETCH применяется с курсором для запросов, возвращающих
несколько строк.
Пример:
/*
849ECPG — встраиваемый SQL в C</stdio.h></p>
<ul>
  <li>предполагается существование такой таблицы:</li>
  <li>CREATE TABLE test1 (a int, b varchar(50));
*/
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;
…
EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
Предложение INTO размещается между списком выборки и предложением FROM. Число элементов
в списке выборки должно равняться числу элементов в списке после INTO (также называемом це-
левым списком).
Следующий пример демонстрирует использование команды FETCH:
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;
…
EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;
…
do
{
…
EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
…
} while (…);
Здесь предложение INTO размещается после всех остальных обычных предложений.
36.4.4. Сопоставление типов
Когда приложения ECPG передают данные между сервером PostgreSQL и программой на C, напри-
мер, получая результаты запроса с сервера или выполняя операторы SQL с входными параметрам,
эти данные должны преобразовываться из типов PostgreSQL в типы переменных языка среды (а
именно типы языка C) и наоборот. Одно из главных качеств ECPG состоит в том, что в большинстве
случаев он делает это автоматически.
В этом отношении можно выделить два вида типов данных. К первому относятся простые типы
данных PostgreSQL, такие как integer и text, которые приложение может непосредственно читать
и писать. С другими типами данных, такими как timestamp и numeric, можно работать только через
специальные функции; см. Подраздел 36.4.4.2.
В Таблице 36.1 показано, как типы данных PostgreSQL соответствуют типам данных C. Когда нужно
передать или получить значение определённого типа данных PostgreSQL, вы должны объявить
переменную C соответствующего типа C в секции объявлений.
Таблица 36.1. Соответствие между типами данных PostgreSQL и типами переменных C
Тип данных PostgreSQL Тип переменной среды
smallint short
850ECPG — встраиваемый SQL в C
Тип данных PostgreSQL Тип переменной среды
integer int
bigint long long int
decimal decimal
numeric numeric
real float
double precision double
smallserial short
serial int
bigserial long long int
oid unsigned int
character( n), varchar( n), text char[n+1], VARCHAR[n+1]
name char[NAMEDATALEN]
timestamp timestamp
interval interval
date date
boolean bool
bytea char *
a
a
b
a
a
a
c
a
С этим типом можно работать только через специальные функции; см. Подраздел 36.4.4.2.
b
c
объявляется в ecpglib.h
объявляется в ecpglib.h при отсутствии стандартного объявления
36.4.4.1. Работа с символьными строками
Для обработки типов символьных строк SQL, таких как varchar и text, предлагаются два варианта
объявления переменных среды.
Первый способ заключается в использовании char[], массива char, как чаще всего и представля-
ются символьные данные в C.
EXEC SQL BEGIN DECLARE SECTION;
char str[50];
EXEC SQL END DECLARE SECTION;
Заметьте, что о длине этого массива вы должны подумать сами. Если вы укажете данную перемен-
ную среды в качестве целевой переменной запроса, возвращающего строку длиннее 49 символов,
произойдёт переполнение буфера.
В качестве другого подхода можно использовать специальный тип VARCHAR, представленный в
ECPG. Определение массива типа VARCHAR преобразуется в структуру (struct) с собственным име-
нем для каждой переменной. Объявление вида:
VARCHAR var[180];
преобразуется в:
struct varchar_var { int len; char arr[180]; } var;
Член структуры arr содержит строку, включающую завершающий нулевой байт. Таким образом,
чтобы сохранить строку в переменной типа VARCHAR, эта переменная должна быть объявлена с
длиной, учитывающей завершающий нулевой байт. Член структуры len содержит длину строки,
сохранённой в arr, без завершающего нулевого байта. Когда на вход запросу подаётся переменная
среды, у которой strlen(arr) отличается от len, применяется наименьшее значение.
VARCHAR можно записать в верхнем или нижнем регистре, но не в смешанном.
851ECPG — встраиваемый SQL в C
Переменные char и VARCHAR также могут содержать значения других типов SQL в их строковом
представлении.
36.4.4.2. Обработка специальных типов данных
ECPG представляет некоторые особые типы, которые должны помочь вам легко оперировать неко-
торыми специальными типами данных PostgreSQL. В частности, в нём реализована поддержка ти-
пов numeric, decimal, date, timestamp и interval. Для этих типов нельзя подобрать полезное со-
ответствие с примитивными типами среды (например, int, long long int или char[]), так как
они имеют сложную внутреннюю структуру. Приложения, работающие с этими типами, должны
объявлять переменные особых типов и работать с ними, применяя функции из библиотеки pgtypes.
Эта библиотека, подробно описанная в Разделе 36.6 содержит базовые функции для оперирования
этими типами, чтобы вам не требовалось, например, передавать запрос SQL-серверу, когда нужно
просто добавить интервал к значению времени.
Эти особые типы данных описаны в следующих подразделах. Чтобы подробнее узнать о функциях
в библиотеке pgtypes, обратитесь к Разделу 36.6.
36.4.4.2.1. timestamp, date
Для работы с переменными timestamp в приложении ECPG применяется следующая схема.
Сначала в программу нужно включить заголовочный файл, чтобы получить определение типа
timestamp:
#include <pgtypes_timestamp.h>
Затем объявите в секции объявлений переменную типа timestamp:
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
Прочитав значение в эту переменную, выполняйте действия с ним, используя функции в библио-
теке pgtypes. В следующем примере значение timestamp преобразуется в текстовый вид (ASCII) с
помощью функции PGTYPEStimestamp_to_asc():
EXEC SQL SELECT now()::timestamp INTO :ts;
printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
Этот пример выведет такой результат:
ts = 2010-06-27 18:03:56.949343
Таким же образом можно работать и с типом DATE. В программу нужно включить pgtypes_date.h,
объявить переменную типа date, и затем можно будет преобразовать значение DATE в текстовый
вид, используя функцию PGTYPESdate_to_asc(). Чтобы подробнее узнать о функциях в библиотеке
pgtypes, обратитесь к Разделу 36.6.
36.4.4.2.2. interval
Принцип работы с типом interval тот же, что и с типами timestamp и date, однако для значения
типа interval нужно явно выделить память. Другими словами, блок памяти для этой переменной
должен размещаться в области кучи, а не в стеке.
Пример программы:
#include <stdio.h>
#include <stdlib.h>
#include <pgtypes_interval.h>
852ECPG — встраиваемый SQL в C
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
interval *in;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
in = PGTYPESinterval_new();
EXEC SQL SELECT '1 min'::interval INTO :in;
printf("interval = %s\n", PGTYPESinterval_to_asc(in));
PGTYPESinterval_free(in);
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
36.4.4.2.3. numeric, decimal
Типы numeric и decimal обрабатываются так же, как и тип interval: вы должны определить ука-
затель, выделить некоторое пространство памяти в куче и обращаться к переменной, используя
функции в библиотеке pgtypes. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обрати-
тесь к Разделу 36.6.
Для типа decimal никакие специальные функции не реализованы. Для дальнейшей обработки при-
ложение должно преобразовать его в переменную numeric, применив функцию из библиотеки
pgtypes.
Следующий пример демонстрирует работу с переменными типов numeric и decimal.
#include <stdio.h>
#include <stdlib.h>
#include <pgtypes_numeric.h>
EXEC SQL WHENEVER SQLERROR STOP;
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
numeric *num;
numeric *num2;
decimal *dec;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
num = PGTYPESnumeric_new();
dec = PGTYPESdecimal_new();
EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;
printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));
853ECPG — встраиваемый SQL в C
/* Преобразовать decimal в numeric, чтобы вывести десятичное значение. */
num2 = PGTYPESnumeric_new();
PGTYPESnumeric_from_decimal(dec, num2);
printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));
PGTYPESnumeric_free(num2);
PGTYPESdecimal_free(dec);
PGTYPESnumeric_free(num);
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
36.4.4.3. Переменные среды для непримитивных типов
В качестве переменных среды также можно использовать массивы, определения типов, структуры
и указатели.
36.4.4.3.1. Массивы
Для применения массивов в качестве переменных среды есть два варианта использования. Во-
первых, в массиве char[] или VARCHAR[] можно сохранить текстовую строку, как рассказывалось
в Подразделе 36.4.4.1. Во-вторых, в массив можно получить несколько строк из результата запро-
са, не используя курсор. Чтобы не применяя массивы, обработать результат запроса, состоящий
из нескольких строк, нужно использовать курсор и команду FETCH. Но с переменными-массивами
несколько строк можно получить сразу. Длина определяемого массива должна быть достаточной
для размещения всех строк, иначе скорее всего произойдёт переполнение буфера.
Следующий пример сканирует системную таблицу pg_database и показывает все OID и имена до-
ступных баз данных:
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
int dbid[8];
char dbname[8][16];
int i;
EXEC SQL END DECLARE SECTION;
memset(dbname, 0, sizeof(char)* 16 * 8);
memset(dbid, 0, sizeof(int) * 8);
EXEC SQL CONNECT TO testdb;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
/* Получить в массивы сразу несколько строк. */
EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;
for (i = 0; i &lt; 8; i++)
printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
854ECPG — встраиваемый SQL в C
Этот пример выводит следующий результат. (Точные значения зависят от локальных обстоя-
тельств.)
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
36.4.4.3.2. Структуры
Для получения значений сразу нескольких столбцов можно применить структуру, имена членов
которой совпадают с именами столбцов результата запроса. Структура позволяет обрабатывать
значения нескольких столбцов в одной переменной среды.
Следующий пример получает значения OID, имена и размеры имеющихся баз данных из систем-
ной таблицы pg_database, используя при этом функцию pg_database_size(). В этом примере пе-
ременная типа структуры dbinfo_t с членами, имена которых соответствуют именам всех столбцов
результата SELECT, применяется для получения одной строки результата без вовлечения в опера-
тор FETCH нескольких переменных среды.
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
int oid;
char datname[65];
long long int size;
} dbinfo_t;
dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;
memset(&amp;dbval, 0, sizeof(dbinfo_t));
EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size
FROM pg_database;
EXEC SQL OPEN cur1;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать несколько столбцов в одну структуру. */
EXEC SQL FETCH FROM cur1 INTO :dbval;
/* Напечатать члены структуры. */
printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname,
dbval.size);
}
EXEC SQL CLOSE cur1;
Этот пример показывает следующий результат. (Точные значения зависят от локальных обстоя-
тельств.)
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
855ECPG — встраиваемый SQL в C
oid=313780, datname=testdb, size=8183012
Переменные среды типа структуры «вбирают в себя» столько столбцов, сколько полей содержит
структура. Значения дополнительных столбцов можно присвоить другим переменным среды. На-
пример, приведённую выше программу можно видоизменить следующим образом, разместив пе-
ременную size вне структуры:
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
int oid;
char datname[65];
} dbinfo_t;
dbinfo_t dbval;
long long int size;
EXEC SQL END DECLARE SECTION;
memset(&amp;dbval, 0, sizeof(dbinfo_t));
EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size
FROM pg_database;
EXEC SQL OPEN cur1;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать несколько столбцов в одну структуру. */
EXEC SQL FETCH FROM cur1 INTO :dbval, :size;
/* Напечатать члены структуры. */
printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
}
EXEC SQL CLOSE cur1;
36.4.4.3.3. Определения типов
Чтобы сопоставить новые типы с уже существующими, используйте ключевое слово typedef.
EXEC SQL BEGIN DECLARE SECTION;
typedef char mychartype[40];
typedef long serial_t;
EXEC SQL END DECLARE SECTION;
Заметьте, что вы также можете написать:
EXEC SQL TYPE serial_t IS long;
Это объявление не обязательно должно находиться в секции объявлений.
36.4.4.3.4. Указатели
Вы можете объявлять указатели на самые распространённые типы. Учтите, однако, что указате-
ли нельзя использовать в качестве целевых переменных запросов без автовыделения. За дополни-
тельными сведениями об автовыделении обратитесь к Разделу 36.7.
EXEC SQL BEGIN DECLARE SECTION;
int
*intp;
char **charp;
EXEC SQL END DECLARE SECTION;
856ECPG — встраиваемый SQL в C
36.4.5. Обработка непримитивных типов данных SQL
В этом разделе описывается как работать с нескалярными и пользовательскими типами уровня
SQL в приложениях ECPG. Заметьте, что этот подход отличается от использования переменных
непримитивных типов, описанного в предыдущем разделе.
36.4.5.1. Массивы
Многомерные массивы уровня SQL в ECPG напрямую не поддерживаются, но одномерные масси-
вы уровня SQL могут быть сопоставлены с переменными-массивами среды C и наоборот. Однако
учтите, что когда создаётся оператор, ecpg не знает типов столбцов, поэтому не может проверить,
вводится ли массив C в соответствующий массив уровня SQL. Обрабатывая результат оператора
SQL, ecpg имеет необходимую информацию и таким образом может убедиться, что с обеих сторон
массивы.
Если запрос обращается к отдельным элементам массива, это избавляет от необходимости приме-
нять массивы в ECPG. В этом случае следует использовать переменную среды, имеющую тип, ко-
торый можно сопоставить типу элемента. Например, если типом столбца является массив integer,
можно использовать переменную среды типа int. Аналогично, если тип элемента — varchar или
text, можно использовать переменную типа char[] или VARCHAR[].
Предположим, что у нас есть таблица:
CREATE TABLE t3 (
ii integer[]
);
testdb=&gt; SELECT * FROM t3;
ii
-------------
{1,2,3,4,5}
(1 row)
Следующая программа получает 4-ый элемент массива и сохраняет его в переменной среды, име-
ющей тип int:
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH FROM cur1 INTO :ii ;
printf("ii=%d\n", ii);
}
EXEC SQL CLOSE cur1;
Этот пример выводит следующий результат:
ii=4
Чтобы сопоставить несколько элементов массива с несколькими элементами переменной-масси-
вом среды, каждый элемент массива SQL нужно по отдельности связать с каждым элементом мас-
сива среды, например:
EXEC SQL BEGIN DECLARE SECTION;
857ECPG — встраиваемый SQL в C
int ii_a[8];
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
...
}
Ещё раз обратите внимание, что в этом случае вариант
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* НЕПРАВИЛЬНО */
EXEC SQL FETCH FROM cur1 INTO :ii_a;
...
}
не будет работать корректно, так как столбец с типом массива нельзя напрямую сопоставить с
переменной-массивом среды.
Можно также применить обходное решение — хранить массивы в их внешнем строковом представ-
лении в переменных среды типа char[] или VARCHAR[]. Более подробно это представление описы-
вается в Подразделе 8.15.2. Заметьте, это означает, что с таким массивом в программе нельзя бу-
дет работать естественным образом (без дополнительного разбора текстового представления).
36.4.5.2. Составные типы
Составные типы в ECPG напрямую не поддерживаются, но есть простое обходное решение. Для
решения этой проблемы можно применить те же подходы, что были описаны выше для массивов:
обращаться к каждому атрибуту по отдельности или использовать внешнее строковое представле-
ние.
Для следующих примеров предполагается, что существует такой тип и таблица:
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
Самое очевидное решение заключается в обращении к каждому атрибуту по отдельности. Следу-
ющая программа получает данные из тестовой таблицы, выбирая атрибуты типа comp_t по одному:
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;
/* Указать каждый элемент столбца составного типа в списке SELECT. */
858ECPG — встраиваемый SQL в C
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать каждый элемент столбца составного типа в переменную среды. */
EXEC SQL FETCH FROM cur1 INTO :intval, :textval;
printf("intval=%d, textval=%s\n", intval, textval.arr);
}
EXEC SQL CLOSE cur1;
В развитие этого примера, переменные среды, в которые помещаются результаты команды FETCH,
можно собрать в одну структуру. Подробнее переменные среды в форме структуры описываются
в Подразделе 36.4.4.3.2. Чтобы перейти к структуре, пример можно изменить как показано ниже.
Переменные среды, intval и textval, становятся членами структуры comp_t, и эта структура ука-
зывается в команде FETCH.
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
int intval;
varchar textval[33];
} comp_t;
comp_t compval;
EXEC SQL END DECLARE SECTION;
/* Поместить каждый элемент составного типа в список SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Поместить все значения списка SELECT в одну структуру. */
EXEC SQL FETCH FROM cur1 INTO :compval;
printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
EXEC SQL CLOSE cur1;
Хотя в команде FETCH используется структура, имена атрибутов в предложении SELECT задаются
по одному. Это можно дополнительно улучшить, написав *, что будет обозначать все атрибуты
значения составного типа.
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
/* Выбрать все значения в списке SELECT в одну структуру. */
859ECPG — встраиваемый SQL в C
EXEC SQL FETCH FROM cur1 INTO :compval;
printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
Таким образом составные типы можно сопоставить со структурами практически прозрачно, хотя
ECPG и не понимает составные типы.
Наконец, также можно сохранить значения составного типа в их внешнем строковом представле-
нии в переменных среды типа char[] или VARCHAR[]. Однако при таком подходе нет простой воз-
можности обращаться из программы к полям значения.
36.4.5.3. Пользовательские базовые типы
Определяемые пользователем базовые типы не поддерживаются ECPG напрямую. Для них можно
использовать внешнее строковое представление и переменные среды типа char[] или VARCHAR[],
и это решение действительно будет подходящим и достаточным для большинства типов.
Следующий фрагмент кода демонстрирует использование типа данных complex из примера в Раз-
деле  38.12. Внешнее строковое представление этого типа имеет форму (%f,%f) и определено в
функциях complex_in() и complex_out() в Разделе 38.12. Следующий пример вставляет значения
комплексного типа (1,1) и (3,3) в столбцы a и b, а затем выбирает их из таблицы.
EXEC SQL BEGIN DECLARE SECTION;
varchar a[64];
varchar b[64];
EXEC SQL END DECLARE SECTION;
EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');
EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
EXEC SQL OPEN cur1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH FROM cur1 INTO :a, :b;
printf("a=%s, b=%s\n", a.arr, b.arr);
}
EXEC SQL CLOSE cur1;
Этот пример выводит следующий результат:
a=(1,1), b=(3,3)
Другое обходное решение состоит в том, чтобы избегать прямого использования пользовательских
типов в ECPG, а вместо этого создать функцию или приведение, выполняющее преобразование
между пользовательским типом и примитивным типом, который может обработать ECPG. Заметь-
те, однако, что приведения типов, особенно неявные, нужно добавлять в систему типов очень осто-
рожно.
Например:
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
После такого определения следующий код
860ECPG — встраиваемый SQL в C
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;
a
b
c
d
=
=
=
=
1;
2;
3;
4;
EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b),
create_complex(:c, :d));
будет работать так же, как
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
36.4.6. Индикаторы
Приведённые выше примеры никак не обрабатывали значения NULL. На самом деле, в примерах с
извлечением данных возникнет ошибка, если они выберут из базы данных значение NULL. Чтобы
можно было передавать значения NULL в базу данных или получать их из базы данных, вы долж-
ны добавить объявление второй переменной среды для каждой переменной среды, содержащей
данные. Эта вторая переменная среды называется индикатором и содержит флаг, показывающий,
что в данных передаётся NULL, и при этом значение основной переменной среды игнорируется.
Следующий пример демонстрирует правильную обработку значений NULL:
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:
...
EXEC SQL SELECT b INTO :val :val_ind FROM test1;
Переменная индикатора val_ind будет равна нулю, если значение не NULL, или отрицательному
числу, если NULL.
Индикатор выполняет ещё одну функцию: если он содержит положительное число, это означает,
что значение не NULL, но оно было обрезано, когда сохранялось в переменной среды.
Если препроцессору ecpg передаётся аргумент -r no_indicator, он работает в режиме «без ин-
дикатора». В этом режиме, если переменная индикатора не определена, значения NULL обозна-
чаются (при вводе и выводе) для символьных строк пустой строкой, а для целочисленных типов
наименьшим возможным значением этого типа (например, INT_MIN для int).
36.5. Динамический SQL
Во многих случаях конкретные операторы SQL, которые должно выполнять приложение, известны
в момент написания приложения. В некоторых случаях, однако, операторы SQL формируются во
время выполнения или поступают из внешнего источника. В этих случаях операторы SQL нельзя
внедрить непосредственно в исходный код C, но есть средство, позволяющее вызывать произволь-
ные операторы SQL, передаваемые в строковой переменной.
36.5.1. Выполнение операторов без набора результатов
Самый простой способ выполнить произвольный оператор SQL — применить команду EXECUTE
IMMEDIATE. Например:
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;
861ECPG — встраиваемый SQL в C
EXEC SQL EXECUTE IMMEDIATE :stmt;
EXECUTE IMMEDIATE можно применять для SQL-операторов, которые не возвращают набор резуль-
татов (например, DDL, INSERT, UPDATE, DELETE). Выполнять операторы, которые получают данные,
(например, SELECT) таким образом нельзя. Как выполнять такие операторы, рассказывается в сле-
дующем разделе.
36.5.2. Выполнение оператора с входными параметрами
Более эффективно выполнять произвольный оператор SQL можно, подготовив его один раз, а за-
тем запуская подготовленный оператор столько, сколько нужно. Также можно подготовить обоб-
щённую версию оператора, а затем выполнять специализированные его версии, подставляя в него
параметры. Подготавливая оператор, поставьте знаки вопроса там, где позже хотите подставить
параметры. Например:
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE mystmt FROM :stmt;
...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
Когда подготовленный оператор больше не нужен, его следует освободить:
EXEC SQL DEALLOCATE PREPARE имя;
36.5.3. Выполнение оператора с набором результатов
Для выполнения оператора SQL с одной строкой результата можно применить команду EXECUTE.
Чтобы сохранить результат, добавьте предложение INTO.
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a &gt; ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE mystmt FROM :stmt;
...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
Команда EXECUTE может содержать предложение INTO и/или предложение USING, либо не содер-
жать ни того, ни другого.
Если ожидается, что запрос вернёт более одной строки результата, следует применять курсор, как
показано в следующем примере. (Подробно курсоры описываются в Подразделе 36.3.2.)
EXEC
char
char
char
SQL BEGIN DECLARE SECTION;
dbaname[128];
datname[128];
*stmt = "SELECT u.usename as dbaname, d.datname "
" FROM pg_database d, pg_user u "
" WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL PREPARE stmt1 FROM :stmt;
862ECPG — встраиваемый SQL в C
EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
printf("dbaname=%s, datname=%s\n", dbaname, datname);
}
EXEC SQL CLOSE cursor1;
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
36.6. Библиотека pgtypes
Библиотека pgtypes сопоставляет типы базы данных PostgreSQL с их эквивалентами в C, которые
можно использовать в программах на C. Она также предлагает функции для выполнения простых
вычислений с этими типами в C, то есть без помощи сервера PostgreSQL. Рассмотрите следующий
пример:
EXEC SQL BEGIN DECLARE SECTION;
date date1;
timestamp ts1, tsout;
interval iv1;
char *out;
EXEC SQL END DECLARE SECTION;
PGTYPESdate_today(&amp;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&amp;ts1, &amp;iv1, &amp;tsout);
out = PGTYPEStimestamp_to_asc(&amp;tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);
36.6.1. Символьные строки
Некоторые функции, в частности PGTYPESnumeric_to_asc, возвращают указатель на строку в выде-
ленной для неё памяти. Их результаты должны освобождаться функцией PGTYPESchar_free, а не
free. (Это важно только в Windows, где выделение и освобождение памяти в определённых случа-
ях должно производиться одной библиотекой.)
36.6.2. Тип numeric
Тип numeric позволяет производить вычисления с произвольной точностью. Эквивалентный ему
тип на сервере PostgreSQL описан в Разделе 8.1. Ввиду того, что переменная имеет произвольную
точность, она должна расширяться и сжиматься динамически. Поэтому такие переменные можно
создавать только в области кучи, используя функции PGTYPESnumeric_new и PGTYPESnumeric_free.
Тип decimal подобен numeric, но имеет ограниченную точность, и поэтому может размещаться и
в области кучи, и в стеке.
Для работы с типом numeric можно использовать следующие функции:
PGTYPESnumeric_new
Запрашивает указатель на новую переменную, размещённую в памяти.
863ECPG — встраиваемый SQL в C
numeric *PGTYPESnumeric_new(void);
PGTYPESnumeric_free
Освобождает переменную типа numeric, высвобождая всю её память.
void PGTYPESnumeric_free(numeric *var);
PGTYPESnumeric_from_asc
Разбирает числовой тип из строковой записи.
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
Допускаются в частности следующие форматы: -2, .794, +3.44, 592.49E07 и -32.84e-4. Если
значение удаётся разобрать успешно, возвращается действительный указатель, в противном
случае указатель NULL. На данный момент ECPG всегда разбирает строку до конца, так что эта
функция не может вернуть адрес первого недопустимого символа в *endptr. Поэтому в endptr
свободно можно передать NULL.
PGTYPESnumeric_to_asc
Возвращает указатель на строку, выделенную функцией malloc и содержащую строковое пред-
ставление значения num числового типа.
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
Числовое значение будет выводиться с заданным в dscale количеством цифр после запятой,
округлённое при необходимости. Результат нужно освободить функцией PGTYPESchar_free().
PGTYPESnumeric_add
Суммирует две числовые переменные и возвращает результат в третьей.
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
Эта функция суммирует переменные var1 и var2 в результирующую переменную result. Функ-
ция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_sub
Вычисляет разность двух числовых переменных и возвращает результат в третьей.
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
Эта функция вычитает переменную var2 из var1. Результат операции помещается в перемен-
ную result. Функция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_mul
Перемножает две числовые переменные и возвращает результат в третьей.
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
Эта функция перемножает переменные var1 и var2. Результат операции сохраняется в пере-
менной result. Функция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_div
Вычисляет частное двух числовых переменных и возвращает результат в третьей.
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
Эта функция делит переменную var1 на var2. Результат операции сохраняется в переменной
result. Функция возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_cmp
Сравнивает две числовые переменные.
864ECPG — встраиваемый SQL в C
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
Эта функция производит сравнение двух числовых переменных. При ошибке возвращается
INT_MAX. В случае успеха функция возвращает одно из трёх возможных значений:
• 1, если var1 больше var2
• -1, если var1 меньше var2
• 0, если var1 и var2 равны
PGTYPESnumeric_from_int
Преобразует переменную int в переменную numeric.
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
Эта функция принимает целочисленную переменную со знаком типа signed int и сохраняет
её значение в переменной var типа numeric. Функция возвращает 0 в случае успеха и -1 при
ошибке.
PGTYPESnumeric_from_long
Преобразует переменную long int в переменную numeric.
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
Эта функция принимает целочисленную переменную со знаком типа signed long int и сохраняет
её значение в переменной var типа numeric. Функция возвращает 0 в случае успеха и -1 при
ошибке.
PGTYPESnumeric_copy
Копирует одну числовую переменную в другую.
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
Эта функция копирует значение переменной, на которую указывает src, в переменную, на ко-
торую указывает dst. Она возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_from_double
Преобразует переменную типа double в переменную numeric.
int
PGTYPESnumeric_from_double(double d, numeric *dst);
Эта функция принимает переменную типа double и сохраняет преобразованное значение в пе-
ременной, на которую указывает dst. Она возвращает 0 в случае успеха и -1 при ошибке.
PGTYPESnumeric_to_double
Преобразует переменную типа numeric в переменную double.
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
Эта функция преобразует значение типа numeric переменной, на которую указывает nv, в пе-
ременную типа double, на которую указывает dp. Она возвращает 0 в случае успеха и -1 при
ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной пере-
менной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
PGTYPESnumeric_to_int
Преобразует переменную типа numeric в переменную int.
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
Эта функция преобразует значение типа numeric переменной, на которую указывает nv, в це-
лочисленную переменную, на которую указывает ip. Она возвращает 0 в случае успеха и -1
при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной пе-
ременной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
865ECPG — встраиваемый SQL в C
PGTYPESnumeric_to_long
Преобразует переменную типа numeric в переменную long.
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
Эта функция преобразует значение типа numeric переменной, на которую указывает nv, в цело-
численную переменную типа long, на которую указывает lp. Она возвращает 0 в случае успеха
и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной
переменной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
PGTYPESnumeric_to_decimal
Преобразует переменную типа numeric в переменную decimal.
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
Эта функция преобразует значение типа numeric переменной, на которую указывает src, в пе-
ременную типа decimal, на которую указывает dst. Она возвращает 0 в случае успеха и -1 при
ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной пере-
менной errno дополнительно устанавливается значение PGTYPES_NUM_OVERFLOW.
PGTYPESnumeric_from_decimal
Преобразует переменную типа decimal в переменную numeric.
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
Эта функция преобразует значение типа decimal переменной, на которую указывает src, в пе-
ременную типа numeric, на которую указывает dst. Она возвращает 0 в случае успеха и -1 при
ошибке. Так как тип decimal реализован как ограниченная версия типа numeric, при таком
преобразовании переполнение невозможно.
36.6.3. Тип date
Тип date, реализованный в C, позволяет программам работать с данными типа date в SQL. Соот-
ветствующий тип сервера PostgreSQL описан в Разделе 8.5.
Для работы с типом date можно использовать следующие функции:
PGTYPESdate_from_timestamp
Извлекает часть даты из значения типа timestamp.
date PGTYPESdate_from_timestamp(timestamp dt);
Эта функция получает в единственном аргументе значение времени типа timestamp и возвра-
щает извлечённую из него дату.
PGTYPESdate_from_asc
Разбирает дату из её текстового представления.
date PGTYPESdate_from_asc(char *str, char **endptr);
Эта функция получает строку C char* str и указатель на строку C char* endptr. На данный
момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес
первого недопустимого символа в *endptr. Поэтому в endptr свободно можно передать NULL.
Заметьте, что эта функция всегда подразумевает формат дат MDY (месяц-день-год) и никакой
переменной для изменения этого формата в ECPG нет.
Все допустимые форматы ввода перечислены в Таблице 36.2.
Таблица 36.2. Допустимые форматы ввода для PGTYPESdate_from_asc
Ввод Результат
January 8, 1999 January 8, 1999
866ECPG — встраиваемый SQL в C
Ввод Результат
1999-01-08 January 8, 1999
1/8/1999 January 8, 1999
1/18/1999 January 18, 1999
01/02/03 February 1, 2003
1999-Jan-08 January 8, 1999
Jan-08-1999 January 8, 1999
08-Jan-1999 January 8, 1999
99-Jan-08 January 8, 1999
08-Jan-99 January 8, 1999
08-Jan-06 January 8, 2006
Jan-08-99 January 8, 1999
19990108 ISO 8601; January 8, 1999
990108 ISO 8601; January 8, 1999
1999.008 год и день года
J2451187 День по юлианскому календарю
January 8, 99 BC 99 год до нашей эры
PGTYPESdate_to_asc
Возвращает текстовое представление переменной типа date.
char *PGTYPESdate_to_asc(date dDate);
Эта функция получает в качестве единственного параметра дату dDate и выводит её в ви-
де 1999-01-18, то есть в формате YYYY-MM-DD. Результат необходимо освободить функцией
PGTYPESchar_free().
PGTYPESdate_julmdy
Извлекает значения дня, месяца и года из переменной типа date.
void PGTYPESdate_julmdy(date d, int *mdy);
Эта функция получает дату d и указатель на 3 целочисленных значения mdy. Имя переменной
указывает на порядок значений: в mdy[0] записывается номер месяца, в mdy[1] — номер дня,
а в mdy[2] — год.
PGTYPESdate_mdyjul
Образует значение даты из массива 3 целых чисел, задающих день, месяц и год даты.
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
Эта функция получает в первом аргументе массив из 3 целых чисел (mdy), а во втором указатель
на переменную типа date, в которую будет помещён результат операции.
PGTYPESdate_dayofweek
Возвращает число, представляющее день недели для заданной даты.
int PGTYPESdate_dayofweek(date d);
Эта функция принимает в единственном аргументе переменную d типа date и возвращает целое
число, выражающее день недели для этой даты.
• 0 — Воскресенье
• 1 — Понедельник
867ECPG — встраиваемый SQL в C
• 2 — Вторник
• 3 — Среда
• 4 — Четверг
• 5 — Пятница
• 6 — Суббота
PGTYPESdate_today
Выдаёт текущую дату.
void PGTYPESdate_today(date *d);
Эта функция получает указатель на переменную (d) типа date, в которую будет записана теку-
щая дата.
PGTYPESdate_fmt_asc
Преобразует переменную типа date в текстовое представление по маске формата.
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
Эта функция принимает дату для преобразования (dDate), маску формата (fmtstring) и строку,
в которую будет помещено текстовое представление даты (outbuf).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
В строке формата можно использовать следующие коды полей:
• dd — Номер дня в месяце.
• mm — Номер месяца в году.
• yy — Номер года в виде двух цифр.
• yyyy — Номер года в виде четырёх цифр.
• ddd — Название дня недели (сокращённое).
• mmm — Название месяца (сокращённое).
Все другие символы копируются в выводимую строку 1:1.
В Таблице  36.3 перечислены несколько возможных форматов. Это даёт представление, как
можно использовать эту функцию. Все строки вывода даны для одной даты: 23 ноября 1959 г.
Таблица 36.3. Допустимые форматы ввода для PGTYPESdate_fmt_asc
Формат Результат
mmddyy 112359
ddmmyy 231159
yymmdd 591123
yy/mm/dd 59/11/23
yy mm dd 59 11 23
yy.mm.dd 59.11.23
.mm.yyyy.dd. .11.1959.23.
mmm. dd, yyyy Nov. 23, 1959
mmm dd yyyy Nov 23 1959
yyyy dd mm 1959 23 11
ddd, mmm. dd, yyyy Mon, Nov. 23, 1959
(ddd) mmm. dd, yyyy (Mon) Nov. 23, 1959
868ECPG — встраиваемый SQL в C
PGTYPESdate_defmt_asc
Преобразует строку C char* в значение типа date по маске формата.
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
Эта функция принимает указатель на переменную типа date (d), в которую будет помещён ре-
зультат операции, маску формата для разбора даты (fmt) и строку C char*, содержащую тексто-
вое представление даты (str). Ожидается, что текстовое представление будет соответствовать
маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция
анализирует только порядок элементов и ищет в нём подстроки yy или yyyy, обозначающие по-
зицию года, подстроку mm, обозначающую позицию месяца, и dd, обозначающую позицию дня.
В Таблица  36.4 перечислены несколько возможных форматов. Это даёт представление, как
можно использовать эту функцию.
Таблица 36.4. Допустимые форматы ввода для rdefmtdate
Формат Строка Результат
ddmmyy 21-2-54 1954-02-21
ddmmyy 2-12-54 1954-12-02
ddmmyy 20111954 1954-11-20
ddmmyy 130464 1964-04-13
mmm.dd.yyyy MAR-12-1967 1967-03-12
yy/mm/dd 1954, February 3rd 1954-02-03
mmm.dd.yyyy 041269 1969-04-12
yy/mm/dd In the year 2525, in the
month of July, mankind will
be alive on the 28th day 2525-07-28
dd-mm-yy I said on the 28th of July 2525-07-28
in the year 2525
mmm.dd.yyyy 9/14/58 1958-09-14
yy/mm/dd 47/03/29 1947-03-29
mmm.dd.yyyy oct 28 1975 1975-10-28
mmddyy Nov 14th, 1985 1985-11-14
36.6.4. Тип timestamp
Тип timestamp, реализованный в C, позволяет программам работать с данными типа timestamp в
SQL. Соответствующий тип сервера PostgreSQL описан в Разделе 8.5.
Для работы с типом timestamp можно использовать следующие функции:
PGTYPEStimestamp_from_asc
Разбирает значение даты/времени из текстового представления в переменную типа timestamp.
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
Эта функция получает строку (str), которую нужно разобрать, и указатель на строку C char*
(endptr). На данный момент ECPG всегда разбирает строку до конца, так что эта функция не
может вернуть адрес первого недопустимого символа в *endptr. Поэтому в endptr свободно
можно передать NULL.
В случае успеха эта функция возвращает разобранное время, а в случае ошибки возвращается
PGTYPESInvalidTimestamp и в errno устанавливается значение PGTYPES_TS_BAD_TIMESTAMP. См.
замечание относительно PGTYPESInvalidTimestamp.
869ECPG — встраиваемый SQL в C
Вообще вводимая строка может содержать допустимое указание даты, пробельные символы и
допустимое указание времени в любом сочетании. Заметьте, что часовые пояса ECPG не под-
держивает. Эта функция может разобрать их, но не задействует их в вычислениях как это де-
лает, например, сервер PostgreSQL. Указания часового пояса во вводимой строке просто игно-
рируются.
В Таблица 36.5 приведены несколько примеров вводимых строк.
Таблица 36.5. Допустимые форматы ввода для PGTYPEStimestamp_from_asc
Ввод Результат
1999-01-08 04:05:06 1999-01-08 04:05:06
January 8 04:05:06 1999 PST 1999-01-08 04:05:06
1999-Jan-08 04:05:06.789-8 1999-01-08 04:05:06.789 (указание часово-
го пояса игнорируется)
J2451187 04:05-08:00 1999-01-08 04:05:00
пояса игнорируется)
(указание
часового
PGTYPEStimestamp_to_asc
Преобразует значение даты в строку C char*.
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
Эта функция принимает в качестве единственного аргумента tstamp значение типа timestamp
и возвращает размещённую в памяти строку, содержащую текстовое представление даты/вре-
мени. Результат необходимо освободить функцией PGTYPESchar_free().
PGTYPEStimestamp_current
Получает текущее время.
void PGTYPEStimestamp_current(timestamp *ts);
Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую
указывает ts.
PGTYPEStimestamp_fmt_asc
Преобразует переменную типа timestamp в строку C char* по маске формата.
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char
*fmtstr);
Эта функция получает в первом аргументе (ts) указатель на переменную типа timestamp, а в
последующих указатель на буфер вывода (output), максимальную длину строки, которую мо-
жет принять буфер (str_len), и маску формата, с которой будет выполняться преобразование
(fmtstr).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
В маске формата можно использовать коды формата, перечисленные ниже. Эти же коды при-
нимает функция strftime из библиотеки libc. Любые символы, не относящиеся к кодам форма-
та, будут просто скопированы в буфер вывода.
• %A — заменяется локализованным представлением полного названия дня недели.
• %a — заменяется локализованным представлением сокращённого названия дня недели.
• %B — заменяется локализованным представлением полного названия месяца.
• %b — заменяется локализованным представлением сокращённого названия месяца.
• %C — заменяется столетием (год / 100) в виде десятичного числа; одиночная цифра предва-
ряется нулём.
870ECPG — встраиваемый SQL в C
• %c — заменяется локализованным представлением даты и времени.
• %D — равнозначно %m/%d/%y.
• %d — заменяется днём месяца в виде десятичного числа (01-31).
• %E* %O* — расширения локали POSIX. Последовательности %Ec %EC %Ex %EX %Ey %EY %Od %Oe
%OH %OI %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy должны выводить альтернативные представле-
ния.
Кроме того, альтернативные названия месяцев представляет код формата %OB (использует-
ся отдельно, без упоминания дня).
• %e — заменяется днём в виде десятичного числа (1-31); одиночная цифра предваряется
пробелом.
• %F — равнозначно %Y-%m-%d.
• %G — заменяется годом в виде десятичного числа (со столетием). При этом годом считает-
ся тот, что содержит наибольшую часть недели (дни недели начинаются с понедельника).
• %g — заменяется тем же годом, что и %G, но в виде десятичного числа без столетия (00-99).
• %H — заменяется часами (в 24-часовом формате) в виде десятичного числа (00-23).
• %h — равнозначно %b.
• %I — заменяется часами (в 12-часовом формате) в виде десятичного числа (01-12).
• %j — заменяется днём года в виде десятичного числа (001-366).
• %k — заменяется часами (в 24-часовом формате) в виде десятичного числа (0-23); одиноч-
ная цифра предваряется пробелом.
• %l — заменяется часами (в 12-часовом формате) в виде десятичного числа (1-12); одиноч-
ная цифра предваряется пробелом.
• %M — заменяется минутами в виде десятичного числа (00-59).
• %m — заменяется номером месяца в виде десятичного числа (01-12).
• %n — заменяется символом новой строки.
• %O* — равнозначно %E*.
• %p — заменяется локализованным представлением «до полудня» или «после полудня» в за-
висимости от времени.
• %R — равнозначно %H:%M.
• %r — равнозначно %I:%M:%S %p.
• %S — заменяется секундами в виде десятичного числа (00-60).
• %s — заменяется числом секунд с начала эпохи, по мировому времени (UTC).
• %T — равнозначно %H:%M:%S
• %t — заменяется символом табуляции.
• %U — заменяется номером недели в году (первым днём недели считается воскресенье) в ви-
де десятичного числа (00-53).
• %u — заменяется номером дня недели (первым днём недели считается понедельник) в виде
десятичного числа (1-7).
• %V — заменяется номером недели в году (первым днём недели считается понедельник) в
виде десятичного числа (01-53). Если к недели, включающей 1 января, относятся 4 или
больше дней нового года, она считается неделей с номером 1; в противном случае это по-
следняя неделя предыдущего года, а неделей под номером 1 будет следующая.
• %v — равнозначно %e-%b-%Y.
871ECPG — встраиваемый SQL в C
• %W — заменяется номером недели в году (первым днём недели считается понедельник) в
виде десятичного числа (00-53).
• %w — заменяется номером дня недели (первым днём недели считается воскресенье) в виде
десятичного числа (0-6).
• %X — заменяется локализованным представлением времени.
• %x — заменяется локализованным представлением даты.
• %Y — заменяется годом со столетием в виде десятичного числа.
• %y — заменяется годом без столетия в виде десятичного числа (00-99).
• %Z — заменяется названием часового пояса.
• %z — заменяется смещением часового пояса от UTC; ведущий знак плюс обозначает сме-
щение к востоку от UTC, а знак минус — к западу, часы и минуты задаются парами цифр
без разделителя между ними (эта форма установлена для даты в RFC 822).
• %+ — заменяется локализованным представлением даты и времени.
• %-* — расширение GNU libc. Отключает дополнение чисел по ширине при выводе.
• $_* — расширение GNU libc. Явно включает дополнение пробелами.
• %0* — расширение GNU libc. Явно включает дополнение нулями.
• %% — заменяется символом %.
PGTYPEStimestamp_sub
Вычитает одно значение времени из другого и сохраняет результат в переменной типа interval.
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
Эта функция вычитает значение типа timestamp, на которое указывает ts2, из значения
timestamp, на которое указывает ts1, и сохраняет результат в переменной типа interval, на ко-
торую указывает iv.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
PGTYPEStimestamp_defmt_asc
Разбирает значение типа timestamp из текстового представления с заданной маской формата.
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
Эта функция получает текстовое представление даты/времени в переменной str, а также маску
формата для разбора в переменной fmt. Результат будет сохранён в переменной, на которую
указывает d.
Если вместо маски формата fmt передаётся NULL, эта функция переходит к стандартной маске
форматирования, а именно: %Y-%m-%d %H:%M:%S.
Данная функция является обратной к функции PGTYPEStimestamp_fmt_asc. Обратитесь к её до-
кументации, чтобы узнать о возможных вариантах маски формата.
PGTYPEStimestamp_add_interval
Добавляет переменную типа interval к переменной типа timestamp.
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
Эта функция получает указатель на переменную tin типа timestamp и указатель на перемен-
ную span типа interval. Она добавляет временной интервал к значению даты/времени и сохра-
няет полученную дату/время в переменной типа timestamp, на которую указывает tout.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
872ECPG — встраиваемый SQL в C
PGTYPEStimestamp_sub_interval
Вычитает переменную типа interval из переменной типа timestamp.
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
Эта функция вычитает значение типа interval, на которое указывает span, из значения типа
timestamp, на которое указывает tin, и сохраняет результат в переменной, на которую указы-
вает tout.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
36.6.5. Тип interval
Тип interval, реализованный в C, позволяет программам работать с данными типа interval в SQL.
Соответствующий тип сервера PostgreSQL описан в Разделе 8.5.
Для работы с типом interval можно использовать следующие функции:
PGTYPESinterval_new
Возвращает указатель на новую переменную interval, размещённую в памяти.
interval *PGTYPESinterval_new(void);
PGTYPESinterval_free
Освобождает место, занимаемое ранее размещённой в памяти переменной типа interval.
void PGTYPESinterval_new(interval *intvl);
PGTYPESinterval_from_asc
Разбирает значение типа interval из его текстового представления.
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
Эта функция разбирает входную строку str и возвращает указатель на размещённую в памяти
переменную типа interval. На данный момент ECPG всегда разбирает строку до конца, так что
эта функция не может вернуть адрес первого недопустимого символа в *endptr. Поэтому в
endptr свободно можно передать NULL.
PGTYPESinterval_to_asc
Преобразует переменную типа interval в текстовое представление.
char *PGTYPESinterval_to_asc(interval *span);
Эта функция преобразует переменную типа interval, на которую указывает span, в строку C
char*. Её вывод выглядит примерно так: @ 1 day 12 hours 59 mins 10 secs. Результат необ-
ходимо освободить функцией PGTYPESchar_free().
PGTYPESinterval_copy
Копирует переменную типа interval.
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
Эта функция копирует переменную типа interval, на которую указывает intvlsrc, в перемен-
ную, на которую указывает intvldest. Заметьте, что для целевой переменной необходимо пред-
варительно выделить память.
36.6.6. Тип decimal
Тип decimal похож на тип numeric, однако его максимальная точность ограничена 30 значащи-
ми цифрами. В отличие от типа numeric, который можно создать только в области кучи, тип
decimal можно создать и в стеке, и в области кучи (посредством функций PGTYPESdecimal_new и
PGTYPESdecimal_free). Для работы с типом decimal есть много других функций, подключаемых в
режиме совместимости с Informix, описанном в Разделе 36.15.
873ECPG — встраиваемый SQL в C
Для работы с типом decimal можно использовать следующие функции (содержащиеся не в библио-
теке libcompat).
PGTYPESdecimal_new
Запрашивает указатель на новую переменную decimal, размещённую в памяти.
decimal *PGTYPESdecimal_new(void);
PGTYPESdecimal_free
Освобождает переменную типа decimal, высвобождая всю её память.
void PGTYPESdecimal_free(decimal *var);
36.6.7. Значения errno, которые устанавливает pgtypeslib
PGTYPES_NUM_BAD_NUMERIC
Аргумент должен содержать переменную типа numeric (либо указывать на переменную типа
numeric), но представление этого типа в памяти оказалось некорректным.
PGTYPES_NUM_OVERFLOW
Произошло переполнение. Так как тип numeric может принимать значения практически любой
точности, при преобразовании этого типа в другие типы возможно переполнение.
PGTYPES_NUM_UNDERFLOW
Произошло антипереполнение. Так как тип numeric может принимать значения практически
любой точности, при преобразовании переменной этого типа в другие типы возможно антипе-
реполнение.
PGTYPES_NUM_DIVIDE_ZERO
Имела место попытка деления на ноль.
PGTYPES_DATE_BAD_DATE
Функции PGTYPESdate_from_asc передана некорректная строка даты.
PGTYPES_DATE_ERR_EARGS
Функции PGTYPESdate_defmt_asc переданы некорректные аргументы.
PGTYPES_DATE_ERR_ENOSHORTDATE
В строке, переданной функции PGTYPESdate_defmt_asc, оказался неправильный компонент да-
ты.
PGTYPES_INTVL_BAD_INTERVAL
Функции PGTYPESinterval_from_asc передана некорректная строка, задающая интервал, либо
функции PGTYPESinterval_to_asc передано некорректное значение интервала.
PGTYPES_DATE_ERR_ENOTDMY
Обнаружено несоответствие
PGTYPESdate_defmt_asc.
при
выводе
компонентов
день/месяц/год
в
PGTYPES_DATE_BAD_DAY
Функция PGTYPESdate_defmt_asc обнаружила некорректное значение дня месяца.
PGTYPES_DATE_BAD_MONTH
Функция PGTYPESdate_defmt_asc обнаружила некорректное значение месяца.
874
функцииECPG — встраиваемый SQL в C
PGTYPES_TS_BAD_TIMESTAMP
Функции PGTYPEStimestamp_from_asc передана некорректная строка даты/времени, либо функ-
ции PGTYPEStimestamp_to_asc передано некорректное значение типа timestamp.
PGTYPES_TS_ERR_EINFTIME
Значение типа timestamp, представляющее бесконечность, получено в недопустимом контек-
сте.
36.6.8. Специальные константы pgtypeslib
PGTYPESInvalidTimestamp
Значение типа timestamp, представляющее недопустимое время. Это значение возвраща-
ет функция PGTYPEStimestamp_from_asc при ошибке разбора. Заметьте, что вследствие осо-
бенности внутреннего представления типа timestamp, значение PGTYPESInvalidTimestamp в
то же время представляет корректное время (1899-12-31 23:59:59). Поэтому для выяв-
ления ошибок необходимо, чтобы приложение не только сравнивало результат функции
с PGTYPESInvalidTimestamp, но и проверяло условие errno != 0 после каждого вызова
PGTYPEStimestamp_from_asc.
36.7. Использование областей дескрипторов
Области дескрипторов SQL дают возможности для более сложной обработки результатов опера-
торов SELECT, FETCH и DESCRIBE. Область дескриптора SQL объединяет в одной структуре данные
одной строки и элементы метаданных. Эти метаданные особенно полезны при выполнении дина-
мических SQL-операторов, когда характер результирующих столбцов может быть неизвестен за-
ранее. PostgreSQL предлагает два подхода к использованию областей дескрипторов: именованные
области SQL-дескрипторов и области SQLDA в структурах C.
36.7.1. Именованные области SQL-дескрипторов
Именованная область SQL-дескриптора состоит из заголовка, содержащего сведения обо всём де-
скрипторе, и одного или нескольких дескрипторов элементов, которые по сути описывают отдель-
ные столбцы в строке результата.
Прежде чем вы сможете использовать область SQL-дескриптора, её нужно выделить:
EXEC SQL ALLOCATE DESCRIPTOR идентификатор;
Заданный идентификатор играет роль «имени переменной» области дескриптора. Когда дескрип-
тор оказывается ненужным, его следует освободить:
EXEC SQL DEALLOCATE DESCRIPTOR идентификатор;
Чтобы воспользоваться областью дескриптора, её нужно указать в качестве целевого объекта в
предложении INTO, вместо перечисления переменных среды:
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
Если набор результатов пуст, в области дескриптора будут, тем не менее, содержаться метаданные
из запроса, то есть имена полей.
Получить метаданные набора результатов для ещё не выполненных подготовленных запросов мож-
но, воспользовавшись оператором DESCRIBE:
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
875ECPG — встраиваемый SQL в C
До PostgreSQL версии 9.0 ключевое слово SQL было необязательным, так что предложения
DESCRIPTOR и SQL DESCRIPTOR создавали именованные области SQL-дескрипторов. Теперь оно ста-
ло обязательным; без слова SQL создаются области SQLDA, см. Подраздел 36.7.2.
В операторах DESCRIBE и FETCH ключевые слова INTO и USING действуют примерно одинаково: они
указывают вывести набор результатов и метаданные в область дескриптора.
Возникает вопрос: а как же получить данные из области дескриптора? Область дескриптора можно
представить как структуру с именованными полями. Чтобы получить значение поля из заголовка
и сохранить его в переменной среды, нужно выполнить команду:
EXEC SQL GET DESCRIPTOR имя :переменная_среды = поле;
В настоящее время определено только одно поле заголовка: COUNT, которое говорит, сколько об-
ластей дескрипторов элементов существует (то есть, сколько столбцов содержится в результате).
Переменная среды должна иметь целочисленный тип. Чтобы получить поле из области дескрип-
тора элемента, нужно выполнить команду:
EXEC SQL GET DESCRIPTOR имя VALUE номер :переменная_среды = поле;
В качестве num можно задать обычное целое или переменную среды, содержащую целое число.
Допустимые поля:
CARDINALITY (integer)
число строк в наборе результатов
DATA
собственно элемент данных (тип данных поля зависит от запроса)
DATETIME_INTERVAL_CODE (целое)
Когда TYPE равно 9, DATETIME_INTERVAL_CODE содержит значение 1 для DATE, 2 для TIME, 3 для
TIMESTAMP, 4 для TIME WITH TIME ZONE, либо 5 для TIMESTAMP WITH TIME ZONE.
DATETIME_INTERVAL_PRECISION (целое)
не реализовано
INDICATOR (целое)
индикатор (отмечающий значение NULL или усечение значения)
KEY_MEMBER (целое)
не реализовано
LENGTH (целое)
длина данных в символах
NAME (строка)
имя столбца
NULLABLE (целое)
не реализовано
OCTET_LENGTH (целое)
длина символьного представления данных в байтах
PRECISION (целое)
точность (для типа numeric)
876ECPG — встраиваемый SQL в C
RETURNED_LENGTH (целое)
длина данных в символах
RETURNED_OCTET_LENGTH (целое)
длина символьного представления данных в байтах
SCALE (целое)
масштаб (для типа numeric)
TYPE (целое)
числовой код типа данных столбца
В операторах EXECUTE, DECLARE и OPEN ключевые слова INTO и USING действуют по-разному. Область
дескриптора также можно сформировать вручную, чтобы передать входные параметры запросу
или курсору, а команда USING SQL DESCRIPTOR имя даёт возможность передать входные аргументы
параметризованному запросу. Оператор, формирующий именованную область SQL-дескриптора,
выглядит так:
EXEC SQL SET DESCRIPTOR имя VALUE номер поле = :переменная_среды;
PostgreSQL поддерживает выборку сразу нескольких записей в одном операторе FETCH и может
сохранить их данные в переменной среды, если эта переменная — массив. Например:
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;
EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
36.7.2. Области дескрипторов SQLDA
Область дескриптора SQLDA представляет собой структуру языка C, в которую можно получить
набор результатов и метаданные запроса. Одна такая структура содержит одну запись из набора
данных.
EXEC SQL include sqlda.h;
sqlda_t
*mysqlda;
EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
Заметьте, что ключевое слово SQL в этом случае опускается. Замечания относительно применения
ключевых слов INTO и USING в Подразделе 36.7.1 применимы и здесь, с дополнением. В операто-
ре DESCRIBE можно полностью опустить ключевое слово DESCRIPTOR, если присутствует ключевое
слово INTO:
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
Общая схема использования SQLDA выглядит так:
</pgtypes_numeric.h></stdlib.h></stdio.h></pgtypes_interval.h></stdlib.h></stdio.h></pgtypes_timestamp.h>    <ol>
      <li>Подготовить запрос и объявить курсор для него.</li>
      <li>Объявить SQLDA для строк результата.</li>
      <li>Объявить SQLDA для входных параметров и инициализировать их (выделить память, задать
параметры).</li>
      <li>Открыть курсор с входной SQLDA.</li>
      <li>Выбрать строки из курсора и сохранить их в выходной SQLDA.
877ECPG — встраиваемый SQL в C</li>
      <li>Прочитать значения из выходной SQLDA в переменные среды (и преобразовать при необходи-
мости).</li>
      <li>Закрыть курсор.</li>
      <li>Освободить область памяти, выделенную для входной SQLDA.
36.7.2.1. Структура данных SQLDA
Для SQLDA используются три типа данных: sqlda_t, sqlvar_t и struct sqlname.
Подсказка
Структура данных SQLDA в PostgreSQL подобна той, что используется в IBM DB2
Universal Database, так что часть технической информации по SQLDA в DB2 может быть
полезна и для понимания устройства SQLDA в PostgreSQL.
36.7.2.1.1. Структура sqlda_t
Тип структуры sqlda_t представляет тип собственно SQLDA. Эта структура описывает одну запись.
Две или более структур sqlda_t могут объединяться в связанный список по указателям в поле
desc_next, и таким образом образовывать упорядоченный набор строк. Поэтому, когда выбираются
две или более строк, приложение может прочитать их, проследуя по указателям desc_next во всех
узлах sqlda_t.
Тип sqlda_t определяется так:
struct sqlda_struct
{
char
sqldaid[8];
long
sqldabc;
short
sqln;
short
sqld;
struct sqlda_struct *desc_next;
struct sqlvar_struct sqlvar[1];
};
typedef struct sqlda_struct sqlda_t;
Его поля имеют следующее назначение:
sqldaid
Содержит строковую константу “SQLDA “.
sqldabc
Содержит размер выделенного пространства в байтах.
sqln
Содержит число входных параметров для параметризованного запроса, когда передаётся в опе-
раторы OPEN, DECLARE или EXECUTE с ключевым словом USING. В структуре, выводимой операто-
рами SELECT, EXECUTE или FETCH, данное значение совпадает с sqld.
sqld
Содержит число полей в наборе результатов.
desc_next
Если запрос выдаёт несколько записей, возвращается несколько связанных структур SQLDA, а
desc_next содержит указатель на следующую запись в списке.
878ECPG — встраиваемый SQL в C
sqlvar
Это массив столбцов в наборе результатов.
36.7.2.1.2. Структура sqlvar_t
Тип структуры sqlvar_t содержит значение столбца и метаданные, в частности, тип и длину. Эта
структура определяется так:
struct sqlvar_struct
{
short
sqltype;
short
sqllen;
char
*sqldata;
short
*sqlind;
struct sqlname sqlname;
};
typedef struct sqlvar_struct sqlvar_t;
Её поля имеют следующее назначение:
sqltype
Содержит идентификатор типа данного поля. Возможные значения перечислены в enum
ECPGttype в ecpgtype.h.
sqllen
Содержит двоичную длину поля, например, 4 байта для ECPGt_int.
sqldata
Указывает на данные. Формат данных описан в Подразделе 36.4.4.
sqlind
Указывает на индикатор NULL. 0 соответствует значению не NULL, -1 — NULL.
sqlname
Имя поля.
36.7.2.1.3. Структура struct sqlname
Структура struct sqlname содержит имя столбца. Она включена в sqlvar_t в качестве члена. Эта
структура определена так:
#define NAMEDATALEN 64
struct sqlname
{
short
char
};
length;
data[NAMEDATALEN];
Её поля имеют следующее назначение:
length
Содержит длину имени поля.
data
Содержит собственно имя поля.
36.7.2.2. Получение набора результатов с применением SQLDA
Чтобы получить набор результатов запроса через SQLDA, нужно проделать примерно следующее:
879ECPG — встраиваемый SQL в C</li>
      <li>Объявить структуру sqlda_t для получения набора результатов.</li>
      <li>Выполнить команды FETCH/EXECUTE/DESCRIBE для обработки запроса с указанной SQLDA.</li>
      <li>Определить число записей в наборе результатов, прочитав sqln, член структуры sqlda_t.</li>
      <li>Получить значения каждого столбца из элементов sqlvar[0], sqlvar[1] и т. д., составляющих
массив, включённый в структуру sqlda_t.</li>
      <li>Перейти к следующей строке (структуре sqlda_t) по указателю desc_next, члену структуры
sqlda_t.</li>
      <li>При необходимости повторить эти действия.
Далее показывается, как получить набор результатов через SQLDA.
Сначала объявите структуру sqlda_t, в которую будет помещён набор результатов.
sqlda_t <em>sqlda1;
Затем укажите эту SQLDA в команде. В данном примере это команда FETCH.
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
Обработайте все строки в цикле с переходом по связанному списку.
sqlda_t *cur_sqlda;
for (cur_sqlda = sqlda1;
cur_sqlda != NULL;
cur_sqlda = cur_sqlda-&gt;desc_next)
{
…
}
Внутри этого цикла реализуйте ещё один цикл чтения данных каждого столбца (структуры
sqlvar_t) в строке.
for (i = 0; i &lt; cur_sqlda-&gt;sqld; i++)
{
sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
char *sqldata = v.sqldata;
short sqllen = v.sqllen;
…
}
Чтобы получить значение столбца, прочитайте значение поля sqltype, члена структуры sqlvar_t.
Затем выберите подходящий способ, в зависимости от типа столбца, копирования данных из поля
sqlvar в переменную среды.
char var_buf[1024];
switch (v.sqltype)
{
case ECPGt_char:
memset(&amp;var_buf, 0, sizeof(var_buf));
memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 :
sqllen));
break;
case ECPGt_int: /</em> integer */
memcpy(&amp;intval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), “%d”, intval);
break;
880ECPG — встраиваемый SQL в C
…
}
36.7.2.3. Передача значений параметров через SQLDA
Чтобы передать параметры подготовленному запросу через SQLDA, нужно проделать примерно
следующее:</li>
      <li>Создать подготовленный запрос (подготовленный оператор)</li>
      <li>Объявить структуру sqlda_t в качестве входной SQLDA.</li>
      <li>Выделить область памяти (структуру sqlda_t) для входной SQLDA.</li>
      <li>Установить (скопировать) входные значения в выделенной памяти.</li>
      <li>Открыть курсор, указав входную SQLDA.
Рассмотрим это на примере.
Сначала создайте подготовленный оператор.
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = “SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid
= s.datid AND (d.datname = ? OR d.oid = ?)”;
EXEC SQL END DECLARE SECTION;
EXEC SQL PREPARE stmt1 FROM :query;
Затем выделите память для SQLDA и установите число входных параметров в поле sqln, члене
структуры sqlda_t. Когда для подготовленного запроса требуются два или более входных пара-
метров, приложение должно выделить дополнительное место в памяти, размер которого вычисля-
ется как (число параметров - 1) * sizeof(sqlvar_t). В показанном здесь примере выделяется место
для двух параметров.
sqlda_t <em>sqlda2;
sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
sqlda2-&gt;sqln = 2; /</em> число входных переменных <em>/
Выделив память, сохраните значения параметров в массиве sqlvar[]. (Этот же массив использу-
ется для значений столбцов, когда SQLDA получает набор результатов.) В данном примере пере-
даются два параметра: “postgres” (строкового типа) и 1 (целочисленного типа).
sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = “postgres”;
sqlda2-&gt;sqlvar[0].sqllen = 8;
int intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2-&gt;sqlvar[1].sqllen = sizeof(intval);
Откройте курсор с указанием ранее созданной SQLDA, чтобы входные параметры были переданы
подготовленному оператору.
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
Наконец, закончив использование входных SQLDA, необходимо явно освободить выделенную для
них память, в отличие от SQLDA, получающих результаты запросов.
free(sqlda2);
881ECPG — встраиваемый SQL в C
36.7.2.4. Пример приложения, использующего SQLDA
Представленный здесь пример программы показывает, как выбрать из системных каталогов ста-
тистику доступа к базам данных, определённых входными параметрами.
Это приложение соединяет записи двух системных таблиц, pg_database и pg_stat_database по OID
базы данных, и также выбирает и показывает статистику, принимая два входных параметра (база
данных postgres и OID 1).
Сначала создайте SQLDA для ввода параметров и SQLDA для вывода результатов.
EXEC SQL include sqlda.h;
sqlda_t *sqlda1; /</em> выходной дескриптор <em>/
sqlda_t *sqlda2; /</em> входной дескриптор <em>/
Затем подключитесь к базе данных, подготовьте оператор и объявите курсор для подготовленного
оператора.
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = “SELECT d.oid,</em> FROM pg_database d, pg_stat_database s WHERE
d.oid=s.datid AND ( d.datname=? OR d.oid=? )”;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config(‘search_path’, ‘’, false); EXEC SQL COMMIT;
EXEC SQL PREPARE stmt1 FROM :query;
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
Затем запишите некоторые значения параметров во входную SQLDA. Выделите память для входной
SQLDA и установите количество параметров в sqln. Запишите тип, значение и длину значения в
поля sqltype, sqldata и sqllen структуры sqlvar.
/* Создать структуру SQLDA для входных параметров. <em>/
sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
sqlda2-&gt;sqln = 2; /</em> число входных переменных <em>/
sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = “postgres”;
sqlda2-&gt;sqlvar[0].sqllen = 8;
intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *)&amp;intval;
sqlda2-&gt;sqlvar[1].sqllen = sizeof(intval);
Подготовив входную SQLDA, откройте курсор с ней.
/</em> Открыть курсор с входными параметрами. <em>/
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
Выберите строки из открытого курсора в выходную SQLDA. (Обычно, чтобы выбрать все строки в
наборе результатов, нужно повторять FETCH в цикле.)
while (1)
{
sqlda_t *cur_sqlda;
882ECPG — встраиваемый SQL в C
/</em> Назначить дескриптор курсору <em>/
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
Затем прочитайте выбранные записи из SQLDA, следуя по связанному списку структуры sqlda_t.
for (cur_sqlda = sqlda1 ;
cur_sqlda != NULL ;
cur_sqlda = cur_sqlda-&gt;desc_next)
{
…
Прочитайте все столбцы первой записи. Количество столбцов хранится в поле sqld, а данные пер-
вого столбца в sqlvar[0], оба эти поля — члены структуры sqlda_t.
/</em> Вывести каждый столбец в строке. <em>/
for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
{
sqlvar_t v = sqlda1-&gt;sqlvar[i];
char *sqldata = v.sqldata;
short sqllen = v.sqllen;
strncpy(name_buf, v.sqlname.data, v.sqlname.length);
name_buf[v.sqlname.length] = ‘\0’;
Теперь данные столбцов сохранены в переменной v. Скопируйте все элементы данных в перемен-
ные среды, определив тип столбца по полю v.sqltype.
switch (v.sqltype) {
int intval;
double doubleval;
unsigned long long int longlongval;
case ECPGt_char:
memset(&amp;var_buf, 0, sizeof(var_buf));
memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ?
sizeof(var_buf)-1 : sqllen));
break;
case ECPGt_int: /</em> integer */
memcpy(&amp;intval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), “%d”, intval);
break;
…
default:
…
}
printf(“%s = %s (type: %d)\n”, name_buf, var_buf, v.sqltype);
}
Закончив обработку всех записей, закройте курсор и отключитесь от базы данных.
EXEC SQL CLOSE cur1;
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
Вся программа показана в Примере 36.1.
883ECPG — встраиваемый SQL в C
Пример 36.1. Пример программы на базе SQLDA
#include
#include
#include
#include
#include</li>
    </ol>
  </li>
</ul>
<stdlib.h>
<string.h>
<stdlib.h>
<stdio.h>
<unistd.h>
EXEC SQL include sqlda.h;
sqlda_t *sqlda1; /* дескриптор для выходных данных */
sqlda_t *sqlda2; /* дескриптор для входных данных */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE
d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
int intval;
unsigned long long int longlongval;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL PREPARE stmt1 FROM :query;
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
/* Создать структуру SQLDA для входных параметров */
sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
sqlda2-&gt;sqln = 2; /* число входных переменных */
sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = "postgres";
sqlda2-&gt;sqlvar[0].sqllen = 8;
intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *) &intval;
sqlda2-&gt;sqlvar[1].sqllen = sizeof(intval);
/* Открыть курсор с входными параметрами. */
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
while (1)
{
sqlda_t *cur_sqlda;
/* Присвоить дескриптор курсору */
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
for (cur_sqlda = sqlda1 ;
884ECPG — встраиваемый SQL в C
cur_sqlda != NULL ;
cur_sqlda = cur_sqlda-&gt;desc_next)
{
int i;
char name_buf[1024];
char var_buf[1024];
/* Напечатать каждый столбец в строке. */
for (i=0 ; i<cur_sqlda->sqld ; i++)
{
sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
char *sqldata = v.sqldata;
short sqllen = v.sqllen;
strncpy(name_buf, v.sqlname.data, v.sqlname.length);
name_buf[v.sqlname.length] = '\0';
switch (v.sqltype)
{
case ECPGt_char:
memset(&amp;var_buf, 0, sizeof(var_buf));
memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ?
sizeof(var_buf)-1 : sqllen) );
break;
case ECPGt_int: /* integer */
memcpy(&amp;intval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), "%d", intval);
break;
case ECPGt_long_long: /* bigint */
memcpy(&amp;longlongval, sqldata, sqllen);
snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
break;
default:
{
int i;
memset(var_buf, 0, sizeof(var_buf));
for (i = 0; i &lt; sqllen; i++)
{
char tmpbuf[16];
snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char)
sqldata[i]);
strncat(var_buf, tmpbuf, sizeof(var_buf));
}
}
break;
}
printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
}
printf("\n");
}
}
EXEC SQL CLOSE cur1;
885ECPG — встраиваемый SQL в C
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
Вывод этой программы должен быть примерно таким (некоторые числа будут меняться).
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig = (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig = (type: 1)
datacl = (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
886ECPG — встраиваемый SQL в C
36.8. Обработка ошибок
В этом разделе описывается, как можно обрабатывать исключительные условия и предупрежде-
ния в программе со встраиваемым SQL. Для этого предназначены два средства, которые могут
дополнять друг друга.
• Можно настроить функции-обработчики для обработки предупреждений и ошибок, воспользо-
вавшись командой WHENEVER.
• Подробную информацию об ошибке или предупреждении можно получить через переменную
sqlca.
36.8.1. Установка обработчиков
Один простой метод перехвата ошибок и предупреждений заключается в назначении определён-
ного действия, которое будет выполняться при некотором условии. В общем виде:
EXEC SQL WHENEVER условие действие;
Здесь условие может быть следующим:
SQLERROR
Указанное действие вызывается, когда при выполнении оператора SQL происходит ошибка.
SQLWARNING
Указанное действие вызывается, когда при выполнении оператора SQL выдаётся предупрежде-
ние.
NOT FOUND
Указанное действие вызывается, когда оператор SQL получает или обрабатывает ноль строк.
(Это обстоятельство не считается ошибкой, но бывает полезно отследить его.)
действие может быть следующим:
CONTINUE
Это фактически означает, что условие игнорируется. Это поведение по умолчанию.
GOTO метка
GO TO метка
Перейти к указанной метке (используя оператор goto языка C).
SQLPRINT
Вывести сообщение в устройство стандартного вывода. Это полезно для простых программ или
при разработке прототипов. Содержание этого сообщения не настраивается.
STOP
Вызвать exit(1), что приведёт к завершению программы.
DO BREAK
Выполнить оператор break языка C. Этот вариант следует использовать только в циклах или
операторах switch.
DO CONTINUE
Выполнить оператор continue языка C. Этот вариант следует использовать только в циклах.
Данный оператор передаёт управление в начало цикла.
CALL имя (аргументы)
DO имя (аргументы)
Вызвать указанные функции C с заданными аргументами. (Эти вызовы имеют смысловые отли-
чия от CALL и DO в обычной грамматике PostgreSQL.)
887ECPG — встраиваемый SQL в C
В стандарте SQL описаны только действия CONTINUE и GOTO (и GO TO).
Ниже показан простой пример использования этих команд. Эта конструкция выводит простое со-
общение при выдаче предупреждения и прерывает программу в случае ошибки:
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
Оператор EXEC SQL WHENEVER является директивой препроцессора SQL, а не оператором языка C.
Устанавливаемое им действие при ошибках или предупреждениях применяется ко всем встраива-
емым операторам SQL ниже точки, где устанавливается обработчик, если только это действие не
было изменено после первой команды EXEC SQL WHENEVER, и до SQL-оператора, вызвавшего это
условие, вне зависимости от хода выполнения программы на C. Поэтому обе следующие програм-
мы на C не дадут желаемого эффекта:
/*
* НЕПРАВИЛЬНО
*/
int main(int argc, char *argv[])
{
...
if (verbose) {
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
}
...
EXEC SQL SELECT ...;
...
}
/*
* НЕПРАВИЛЬНО
*/
int main(int argc, char *argv[])
{
...
set_error_handler();
...
EXEC SQL SELECT ...;
...
}
static void set_error_handler(void)
{
EXEC SQL WHENEVER SQLERROR STOP;
}
36.8.2. sqlca
Для более гибкой обработки ошибок в интерфейсе встраиваемого SQL представлена глобальная
переменная с именем sqlca (SQL Communication Area, Область сведений SQL), имеющая следую-
щую структуру:
struct
{
char sqlcaid[8];
long sqlabc;
long sqlcode;
struct
{
int sqlerrml;
char sqlerrmc[SQLERRMC_LEN];
888ECPG — встраиваемый SQL в C
} sqlerrm;
char sqlerrp[8];
long sqlerrd[6];
char sqlwarn[8];
char sqlstate[5];
} sqlca;
(В многопоточной программе каждый поток автоматически получает собственную копию sqlca.
Это работает подобно стандартной в C глобальной переменной errno.)
Структура sqlca покрывает и предупреждения, и ошибки. Если в процессе выполнения операто-
ра выдаётся несколько предупреждений или ошибок, sqlca будет содержать сведения только о
последнем(ей) из них.
Если последний оператор SQL выполняется без ошибки, sqlca.sqlcode будет содержать 0, а
sqlca.sqlstate — "00000". Если выдаётся предупреждение или ошибка, в sqlca.sqlcode будет
содержаться отрицательное число, а sqlca.sqlstate будет отличаться от "00000". Положительное
значение sqlca.sqlcode устанавливается при нейтральном событии, например, когда последний
запрос возвращает ноль строк. Поля sqlcode и sqlstate представляют две различные схемы кодов
ошибок; подробнее они описаны ниже.
Если последний оператор SQL был успешным, в sqlca.sqlerrd[1] содержится OID обработан-
ной строки (если это уместно), а в sqlca.sqlerrd[2] количество обработанных или возвращённых
строк (если это уместно для команды).
В случае ошибки или предупреждения sqlca.sqlerrm.sqlerrmc будет содержать строку, описы-
вающую ошибку. Поле sqlca.sqlerrm.sqlerrml содержит длину сообщения об ошибке, которое
хранится в sqlca.sqlerrm.sqlerrmc (результат функции strlen(), который не очень интересен
для программиста C). Заметьте, что некоторые сообщения могут не умещаться в массив sqlerrmc
фиксированного размера; они будут обрезаться.
В случае предупреждения, в sqlca.sqlwarn[2] записывается символ W. (Во всех других случаях
значение будет отличным от W.) Символ W в sqlca.sqlwarn[1] показывает, что значение было об-
резано при сохранении в переменной среды. W в sqlca.sqlwarn[0] устанавливается, если преду-
преждение отмечается в каком-либо другом элементе массива.
Поля sqlcaid, sqlcabc, sqlerrp и остальные элементы sqlerrd и sqlwarn в настоящее время не
содержат полезной информации.
Структура sqlca не определена в стандарте SQL, но реализована в нескольких других СУБД SQL.
Принципиально она определяется одинаково, но если вы хотите, чтобы ваши приложения были
переносимыми, тщательно изучите различия реализаций.
В следующем примере, демонстрирующем применение WHENEVER в сочетании с sqlca, выводится
содержимое sqlca при возникновении ошибки. Это может быть полезно для отладки или в прото-
типах, пока не реализован более «дружественный пользователю» обработчик ошибок.
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();
void
print_sqlca()
{
fprintf(stderr, "==== sqlca ====\n");
fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n",
sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
889ECPG — встраиваемый SQL в C
fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0],
sqlca.sqlwarn[1], sqlca.sqlwarn[2],
sqlca.sqlwarn[3],
sqlca.sqlwarn[4], sqlca.sqlwarn[5],
sqlca.sqlwarn[6],
sqlca.sqlwarn[7]);
fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
fprintf(stderr, "===============\n");
}
Результат может выглядеть следующим образом (при ошибке, вызванной опечаткой в имени таб-
лицы):
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
36.8.3. SQLSTATE и SQLCODE
Поля sqlca.sqlstate и sqlca.sqlcode отражают две различные схемы, представляющие коды
ошибок. Обе схемы пришли из стандарта SQL, но схема SQLCODE была признана устаревшей в ре-
дакции SQL-92 и исключена в последующих редакциях. Поэтому в новых приложениях настоятель-
но рекомендуется использовать SQLSTATE.
SQLSTATE задаётся в массиве из пяти символов. Эти пять символов содержат цифры или буквы в
верхнем регистре, представляющие коды различных условий ошибок и предупреждений. SQLSTATE
определяется по иерархической схеме: первые два символа обозначают общий класс условия, а
следующие три — подкласс общего условия. Успешное состояние обозначается кодом 00000. По
большей части коды SQLSTATE определены в стандарте SQL. Сервер PostgreSQL поддерживает ко-
ды ошибок SQLSTATE естественным образом; поэтому используя во всех приложениях именно эту
схему кодов ошибок, можно добиться высокой степени согласованности. За дальнейшими сведе-
ниями обратитесь к Приложению A.
SQLCODE — устаревшая схема, в которой коды ошибок представлены просто целыми числами. Зна-
чение 0 обозначает успешное завершение, положительное значение — успешное завершение с
дополнительной информацией, а отрицательное говорит об ошибке. В стандарте SQL определено
только положительное значение +100, показывающее, что последняя команда вернула или затро-
нула ноль строк, но отрицательные значения не определены. Таким образом, с этой схемой нель-
зя рассчитывать на переносимость и она не имеет иерархической структуры. Исторически сложи-
лось, что процессор встраиваемого SQL для PostgreSQL назначает некоторые определённые зна-
чения SQLCODE для собственного использования; они перечислены ниже с числовыми значениями
и символьными именами. Помните, что эти коды несовместимы с другими реализациями SQL. По-
этому для упрощения перевода приложений на схему SQLSTATE вместе с этими кодами перечисля-
ются соответствующие значения SQLSTATE. Однако однозначного соответствия один-к-одному или
один-ко-многим между этими двумя схемами не существует (на самом деле это соответствие мно-
гие-ко-многим), поэтому следует свериться со списком SQLSTATE в Приложении A в каждом случае.
SQLCODE может принимать следующие значения:
0 (ECPG_NO_ERROR)
Показывает, что ошибки нет. (SQLSTATE 00000)
100 (ECPG_NOT_FOUND)
Это нейтральное условие, показывающее, что последняя команда вернула или обработала ноль
строк, либо курсор достиг конца. (SQLSTATE 02000)
890ECPG — встраиваемый SQL в C
Выбирая данные из курсора в цикле, можно проверять этот код, чтобы понять, когда нужно
прервать цикл, следующим образом:
while (1)
{
EXEC SQL FETCH ... ;
if (sqlca.sqlcode == ECPG_NOT_FOUND)
break;
}
Но WHENEVER NOT FOUND DO BREAK внутри по сути делает это же, поэтому такое явное условие
обычно ничем не лучше.
-12 (ECPG_OUT_OF_MEMORY)
Указывает, что закончилась виртуальная память. Числовое значение определено как -ENOMEM.
(SQLSTATE YE001)
-200 (ECPG_UNSUPPORTED)
Указывает, что препроцессор сгенерировал код, который не понимает библиотека. Возможно,
вы используете несовместимые версии препроцессора и библиотеки. (SQLSTATE YE002)
-201 (ECPG_TOO_MANY_ARGUMENTS)
Это означает, что в команде было указано больше переменных среды, чем она ожидает.
(SQLSTATE 07001 или 07002)
-202 (ECPG_TOO_FEW_ARGUMENTS)
Это означает, что в команде было указано меньше переменных среды, чем она ожидает.
(SQLSTATE 07001 или 07002)
-203 (ECPG_TOO_MANY_MATCHES)
Это означает, что запрос вернул несколько строк, но оператор был подготовлен только для
одной строки результата (например, потому что переданные переменные — не массивы).
(SQLSTATE 21000)
-204 (ECPG_INT_FORMAT)
Переменная среды типа int и данные в базе имеют разные типы, и в этих данных содержится
значение, которое нельзя преобразовать в int. Для этого преобразования библиотека исполь-
зует функцию strtol(). (SQLSTATE 42804)
-205 (ECPG_UINT_FORMAT)
Переменная среды типа unsigned int и данные в базе имеют разные типы, и в этих данных
содержится значение, которое нельзя преобразовать в unsigned int. Для этого преобразования
библиотека использует функцию strtoul(). (SQLSTATE 42804)
-206 (ECPG_FLOAT_FORMAT)
Переменная среды типа float и данные в базе имеют разные типы, и в этих данных содержит-
ся значение, которое нельзя преобразовать во float. Для этого преобразования библиотека
использует функцию strtod(). (SQLSTATE 42804)
-207 (ECPG_NUMERIC_FORMAT)
Переменная среды типа numeric и данные в базе имеют разные типы, и в этих данных содер-
жится значение, которое нельзя преобразовать в numeric. (SQLSTATE 42804)
-208 (ECPG_INTERVAL_FORMAT)
Переменная среды типа interval и данные в базе имеют разные типы, и в этих данных содер-
жится значение, которое нельзя преобразовать в interval. (SQLSTATE 42804)
891ECPG — встраиваемый SQL в C
-209 (ECPG_DATE_FORMAT)
Переменная среды типа date и данные в базе имеют разные типы, и в этих данных содержится
значение, которое нельзя преобразовать в date. (SQLSTATE 42804)
-210 (ECPG_TIMESTAMP_FORMAT)
Переменная среды типа timestamp и данные в базе имеют разные типы, и в этих данных содер-
жится значение, которое нельзя преобразовать в timestamp. (SQLSTATE 42804)
-211 (ECPG_CONVERT_BOOL)
Это означает, что переменная среды имеет тип bool, а значение в базе данных отличается от
't' или 'f'. (SQLSTATE 42804)
-212 (ECPG_EMPTY)
Серверу PostgreSQL был передан пустой оператор. (Этого обычно не должно происходить в про-
грамме со встраиваемым SQL, так что это может указывать на внутреннюю ошибку.) (SQLSTATE
YE002)
-213 (ECPG_MISSING_INDICATOR)
Возвращено значение NULL, но переменная-индикатор NULL не задана. (SQLSTATE 22002)
-214 (ECPG_NO_ARRAY)
Там, где требуется массив, была передана обычная переменная. (SQLSTATE 42804)
-215 (ECPG_DATA_NOT_ARRAY)
База данных возвратила обычную переменную там, где требуется значение-массив. (SQLSTATE
42804)
-216 (ECPG_ARRAY_INSERT)
Не удалось вставить значение в массив. (SQLSTATE 42804)
-220 (ECPG_NO_CONN)
Программа попыталась использовать несуществующее подключение. (SQLSTATE 08003)
-221 (ECPG_NOT_CONN)
Программа попыталась использовать подключение, которое существует, но не было открыто.
(Это внутренняя ошибка.) (SQLSTATE YE002)
-230 (ECPG_INVALID_STMT)
Оператор, который вы пытаетесь выполнить, не был подготовлен. (SQLSTATE 26000)
-239 (ECPG_INFORMIX_DUPLICATE_KEY)
Ошибка повторяющегося ключа, нарушение ограничения уникальности (режим совместимо-
сти с Informix). (SQLSTATE 23505)
-240 (ECPG_UNKNOWN_DESCRIPTOR)
Указанный дескриптор не найден. Оператор, который вы пытаетесь использовать, не был под-
готовлен. (SQLSTATE 33000)
-241 (ECPG_INVALID_DESCRIPTOR_INDEX)
Указанный индекс дескриптора вне диапазона. (SQLSTATE 07009)
-242 (ECPG_UNKNOWN_DESCRIPTOR_ITEM)
Запрошен неверный элемент дескриптора. (Это внутренняя ошибка.) (SQLSTATE YE002)
892ECPG — встраиваемый SQL в C
-243 (ECPG_VAR_NOT_NUMERIC)
При выполнении динамического оператора база данных возвратила числовое значение, тогда
как переменная среды — не числовая. (SQLSTATE 07006)
-244 (ECPG_VAR_NOT_CHAR)
При выполнении динамического оператора база данных возвратила не числовое значение, то-
гда как переменная среды — числовая. (SQLSTATE 07006)
-284 (ECPG_INFORMIX_SUBSELECT_NOT_ONE)
Результат подзапроса представлен не одной строкой (режим совместимости с Informix).
(SQLSTATE 21000)
-400 (ECPG_PGSQL)
Ошибка произошла на стороне сервера PostgreSQL. В тексте ошибки содержится сообщение
об ошибке от сервера PostgreSQL.
-401 (ECPG_TRANS)
Сервер PostgreSQL сообщает, что клиент не может запускать, фиксировать или отменять тран-
закцию. (SQLSTATE 08007)
-402 (ECPG_CONNECT)
Попытка подключения к базе данных была неудачной. (SQLSTATE 08001)
-403 (ECPG_DUPLICATE_KEY)
Ошибка повторяющегося ключа, нарушение ограничения уникальности. (SQLSTATE 23505)
-404 (ECPG_SUBSELECT_NOT_ONE)
Результат подзапроса представлен не одной строкой. (SQLSTATE 21000)
-602 (ECPG_WARNING_UNKNOWN_PORTAL)
Указано неверное имя курсора. (SQLSTATE 34000)
-603 (ECPG_WARNING_IN_TRANSACTION)
Транзакция в процессе выполнения. (SQLSTATE 25001)
-604 (ECPG_WARNING_NO_TRANSACTION)
Нет активной (выполняющейся) транзакции. (SQLSTATE 25P01)
-605 (ECPG_WARNING_PORTAL_EXISTS)
Было указано имя существующего курсора. (SQLSTATE 42P03)
36.9. Директивы препроцессора
Препроцессор ecpg поддерживает ряд директив, которые позволяют управлять разбором и обра-
боткой исходных файлов.
36.9.1. Включение файлов
Для включения внешнего файла в программу со встраиваемым SQL, используется конструкция:
EXEC SQL INCLUDE имя_файла;
EXEC SQL INCLUDE <имя_файла>;
EXEC SQL INCLUDE "имя_файла";
Встретив такую директиву, препроцессор встраиваемого SQL будет искать файл имя_файла.h, об-
рабатывать его и включать в выходной код C. В результате встраиваемые операторы SQL во вклю-
чённом таким образом файле будут обработаны корректно.
893ECPG — встраиваемый SQL в C
Препроцессор ecpg будет искать указанный файл в нескольких каталогах в следующем порядке:
• текущий каталог
• /usr/local/include
• каталог включаемых файлов PostgreSQL, определённый во время сборки (например, /usr/
local/pgsql/include)
• /usr/include
Но когда используется форма EXEC SQL INCLUDE "имя_файла", просматривается только текущий
каталог.
В каждом каталоге препроцессор будет сначала искать файл с заданным именем, а если не об-
наружит его, попытается найти файл с добавленным расширением .h (если только заданное имя
файла уже не содержит это расширение).
Заметьте, что команда EXEC SQL INCLUDE не равнозначна включению:
#include <имя_файла.h>
так как во втором случае включаемый файл не проходит через препроцессор SQL-команд. Есте-
ственно, директиву C #include можно по-прежнему применять для включения других заголовоч-
ных файлов.
Примечание
Имя включаемого файла чувствительно к регистру, несмотря на то, что остальная ко-
манда EXEC SQL INCLUDE подчиняется обычным правилам чувствительности к регистру
SQL.
36.9.2. Директивы define и undef
Во встраиваемом SQL есть конструкция, подобная директиве #define, известной в C:
EXEC SQL DEFINE имя;
EXEC SQL DEFINE имя значение;
Используя её, можно определить имя:
EXEC SQL DEFINE HAVE_FEATURE;
И также можно определить константы:
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
Удалить предыдущее определение позволяет команда undef:
EXEC SQL UNDEF MYNUMBER;
Разумеется, в программе со встраиваемым SQL можно продолжать использовать версии #define
и #undef языка C. Отличие состоит в том, когда вычисляются определяемые значения. Когда при-
меняется команда EXEC SQL DEFINE, вычислять определения и подставлять значения будет пре-
процессор ecpg. Например, если написать:
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
подстановку выполнит ecpg и компилятор C никогда не увидит имени или идентификатора
MYNUMBER. Заметьте, что с другой стороны #define не подходит для определения константы, кото-
рую вы хотите использовать во встраиваемом SQL, так как препроцессор встраиваемого SQL не
сможет увидеть это определение.
894ECPG — встраиваемый SQL в C
36.9.3. Директивы ifdef, ifndef, else, elif и endif
Для условной компиляции блоков кода можно использовать следующие указания:
EXEC SQL ifdef имя;
Проверяет имя и обрабатывает последующие строки, если имя было определено командой EXEC
SQL define имя.
EXEC SQL ifndef имя;
Проверяет имя и обрабатывает последующие строки, если имя не было определено командой
EXEC SQL define имя.
EXEC SQL else;
Начинает альтернативную ветвь условия, открытого командой EXEC SQL ifdef имя или EXEC
SQL ifndef имя.
EXEC SQL elif имя;
Проверяет имя и начинает альтернативную ветвь условия, если имя было определено командой
EXEC SQL define имя.
EXEC SQL endif;
Завершает ветвь условия.
Пример:
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SQL
SQL
ifndef TZVAR;
SET TIMEZONE TO 'GMT';
elif TZNAME;
SET TIMEZONE TO TZNAME;
else;
SET TIMEZONE TO TZVAR;
endif;
36.10. Компиляция программ со встраиваемым SQL
Теперь, когда вы получили представление, как писать программы на C со встраиваемым SQL, вы
наверное хотите узнать, как их компилировать. Прежде чем компилировать код C, необходимо
пропустить исходный файл через препроцессор встраиваемого SQL в C, который преобразует за-
писанные вами операторы SQL в вызовы специальных функций. После компиляции полученный
объектный код нужно скомпоновать со специальной библиотекой, содержащей необходимые функ-
ции. Эти функции получают информацию из аргументов, выполняют команды SQL через интер-
фейс libpq, и помещают результат в аргументы, заданные для вывода.
Программа препроцессора называется ecpg и входит в состав обычной инсталляции PostgreSQL.
Программам со встраиваемым SQL, как правило, даются имена с расширением .pgc. Если вы со-
здали код программы в файле prog1.pgc, вы можете обработать его, просто выполнив:
ecpg prog1.pgc
При этом будет создан файл prog1.c. Если имена входных файлов не следуют этому соглашению,
имя выходного файла можно задать явно в аргументе -o.
Обработанный препроцессором файл можно скомпилировать обычным образом, например, так:
cc -c prog1.c
В сгенерированные исходные файлы C включаются заголовочные файлы из инсталляции
PostgreSQL, поэтому если вы установили PostgreSQL так, что соответствующий каталог не про-
895ECPG — встраиваемый SQL в C
сматривается по умолчанию, вам придётся добавить указание вида -I/usr/local/pgsql/include
в командную строку компиляции.
Чтобы скомпоновать программу со встраиваемым SQL, необходимо подключить библиотеку
libecpg примерно так:
cc -o myprog prog1.o prog2.o ... -lecpg
Возможно, и для этого понадобится добавить в командную строку указание вида -L/usr/local/
pgsql/lib.
Чтобы узнать пути вашей инсталляции, можно воспользоваться командой pg_configили pkg-
config(в качестве имени пакета нужно указать libecpg).
Если вы организуете процесс сборки большого проекта с применением make, может быть удобно
включить в ваши сборочные файлы следующее неявное правило:
ECPG = ecpg
%.c: %.pgc
$(ECPG) $&lt;
Полный синтаксис вызова команды ecpg приведён в описании ecpg.
Библиотека ecpg по умолчанию потокобезопасна. Однако для компиляции клиентского кода могут
потребоваться параметры командной строки для настройки многопоточности.
36.11. Библиотечные функции
Библиотека libecpg в основном содержит «скрытые» функции, применяемые для реализации
функциональности, выражаемой встраиваемыми командами SQL. Но есть также некоторые функ-
ции, которые можно вызывать напрямую. Заметьте, что код, задействующий эти функции, будет
непереносимым.
• ECPGdebug(int вкл, FILE *поток) с первым аргументом, отличным от нуля, включает вывод
отладочных сообщений в заданный поток. Журнал сообщений, полученный таким образом, бу-
дет содержать все операторы SQL с заданными входными переменными и результаты, выдан-
ные сервером PostgreSQL. Это может быть очень полезно для поиска ошибок в командах SQL.
Примечание
В Windows, если библиотека ecpg и приложение скомпилированы с разными фла-
гами, эта функция может вызвать крах приложения из-за различий внутреннего
представления указателей FILE. В частности, флаги многопоточной/однопоточной,
выпускаемой/отладочной или статической/динамической сборки должны быть
одинаковыми для библиотеки и всех использующих её приложений.
• ECPGget_PGconn(const char *имя_подключения) возвращает указатель на подключение к ба-
зе данных, имеющее заданное имя. Если аргумент имя_подключения равен NULL, возвращается
указатель на текущее подключение. Если определить подключение не удаётся, возвращается
NULL. Полученный указатель на подключение, если требуется, можно использовать при вызо-
ве любых других функций libpq.
Примечание
Манипулировать подключениями, открытыми средствами ecpg, напрямую через
libpq не следует.
896ECPG — встраиваемый SQL в C
• ECPGtransactionStatus(const char *имя_подключения) возвращает состояние текущей тран-
закции для подключения, на которое указывает имя_подключения. Возвращаемые коды со-
стояния перечислены в описании входящей в libpq функции PQtransactionStatus() в Разде-
ле 34.2.
• ECPGstatus(int номер_строки, const char* имя_подключения) возвращает true при наличии
подключения к базе данных и false в противном случае. В аргументе имя_подключения можно
передать NULL, если применяется одно подключение.
36.12. Большие объекты
ECPG не поддерживает большие объекты напрямую, но приложение на базе ECPG может ра-
ботать с большими объектами, используя предназначенные для этого функции, получив необ-
ходимый объект PGconn в результате вызова ECPGget_PGconn(). (Однако использовать функцию
ECPGget_PGconn() и напрямую воздействовать на объекты PGconn следует очень осторожно; в иде-
але стоит исключить при этом другие обращения к базе данных через ECPG.)
Подробнее функция ECPGget_PGconn() описана в Разделе 36.11. Интерфейс функций для работы с
большими объектами рассмотрен в Главе 35.
Функции для работы с большими объектами должны вызываться в блоке транзакций, поэтому если
режим автофиксации отключён, необходимо явно выдавать команды BEGIN.
В Примере 36.2 приведён пример программы, показывающий, как создать, записать и прочитать
большой объект в приложении ECPG.
Пример 36.2. Программа на базе ECPG, работающая с большими объектами
#include
#include
#include
#include
<stdio.h>
<stdlib.h>
<libpq-fe.h>
&lt;libpq/libpq-fs.h&gt;
EXEC SQL WHENEVER SQLERROR STOP;
int
main(void)
{
PGconn
Oid
int
char
int
char
int
*conn;
loid;
fd;
buf[256];
buflen = 256;
buf2[256];
rc;
memset(buf, 1, buflen);
EXEC SQL CONNECT TO testdb AS con1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
conn = ECPGget_PGconn("con1");
printf("conn = %p\n", conn);
/* create */
loid = lo_create(conn, 0);
if (loid &lt; 0)
printf("lo_create() failed: %s", PQerrorMessage(conn));
printf("loid = %d\n", loid);
897ECPG — встраиваемый SQL в C
/* write test */
fd = lo_open(conn, loid, INV_READ|INV_WRITE);
if (fd &lt; 0)
printf("lo_open() failed: %s", PQerrorMessage(conn));
printf("fd = %d\n", fd);
rc = lo_write(conn, fd, buf, buflen);
if (rc &lt; 0)
printf("lo_write() failed\n");
rc = lo_close(conn, fd);
if (rc &lt; 0)
printf("lo_close() failed: %s", PQerrorMessage(conn));
/* read test */
fd = lo_open(conn, loid, INV_READ);
if (fd &lt; 0)
printf("lo_open() failed: %s", PQerrorMessage(conn));
printf("fd = %d\n", fd);
rc = lo_read(conn, fd, buf2, buflen);
if (rc &lt; 0)
printf("lo_read() failed\n");
rc = lo_close(conn, fd);
if (rc &lt; 0)
printf("lo_close() failed: %s", PQerrorMessage(conn));
/* check */
rc = memcmp(buf, buf2, buflen);
printf("memcmp() = %d\n", rc);
/* cleanup */
rc = lo_unlink(conn, loid);
if (rc &lt; 0)
printf("lo_unlink() failed: %s", PQerrorMessage(conn));
EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
return 0;
}
36.13. Приложения на C++
ECPG обеспечивает поддержку языка C++ в ограниченном объёме. Некоторые её особенности
описаны в этом разделе.
Препроцессор ecpg принимает входной файл, написанный на C (или языке, подобном C) со встра-
иваемыми командами SQL, преобразует встроенные команды SQL в конструкции языка C и в ре-
зультате формирует файл .c. Объявления библиотечных функций, вызываемых в конструкциях C,
которые генерирует ecpg, заворачиваются в блоки extern "C" { ... } при использовании C++,
так что они должны прозрачно работать в C++.
Однако вообще говоря, препроцессор ecpg понимает только C; он не воспринимает особый синтак-
сис и зарезервированные слова языка C++. Поэтому какой-то код SQL, встроенный в код прило-
898ECPG — встраиваемый SQL в C
жения на C++, в котором используются сложные особенности C++, может корректно не обрабо-
таться препроцессором или не работать как ожидается.
Надёжный подход к применению внедрённого кода SQL в приложении на C++ заключается в том,
чтобы скрыть вызовы ECPG в модуле C, который будет вызываться приложением на C++ для рабо-
ты с базой данных и который будет скомпонован с остальным кодом C++. Подробнее это описано
в Подразделе 36.13.2.
36.13.1. Область видимости переменных среды
Препроцессор ecpg имеет понимание области видимости переменных в C. С языком C это довольно
просто, так как область видимости переменных определяется их блоками кода. В C++, однако,
переменные-члены класса задействуются не в том блоке кода, в каком они объявлены, так что
препроцессор ecpg не сможет корректно определить область видимости таких переменных.
Например, в следующем случае препроцессор ecpg не сможет найти определение переменной
dbname в методе test, так что произойдёт ошибка.
class TestCpp
{
EXEC SQL BEGIN DECLARE SECTION;
char dbname[1024];
EXEC SQL END DECLARE SECTION;
public:
TestCpp();
void test();
~TestCpp();
};
TestCpp::TestCpp()
{
EXEC SQL CONNECT TO testdb1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}
void Test::test()
{
EXEC SQL SELECT current_database() INTO :dbname;
printf("current_database = %s\n", dbname);
}
TestCpp::~TestCpp()
{
EXEC SQL DISCONNECT ALL;
}
При обработке данного кода будет выдано сообщение:
ecpg test_cpp.pgc
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
(test_cpp.pgc:28: ОШИБКА: переменная "dbname" не объявлена)
Для решения этой проблемы можно немного изменить метод test и задействовать в нём локальную
переменную для промежуточного хранения. Но предложенный подход нельзя считать хорошим,
так как это портит код и снижает производительность.
void TestCpp::test()
{
EXEC SQL BEGIN DECLARE SECTION;
899ECPG — встраиваемый SQL в C
char tmp[1024];
EXEC SQL END DECLARE SECTION;
EXEC SQL SELECT current_database() INTO :tmp;
strlcpy(dbname, tmp, sizeof(tmp));
printf("current_database = %s\n", dbname);
}
36.13.2. Разработка приложения на C++ с внешним модулем на C
Если вы поняли технические ограничения препроцессора ecpg с C++, вы можете прийти к заклю-
чению, что для использования ECPG в приложениях на C++ лучше связывать код C с кодом C+
+ на стадии компоновки, а не внедрять команды SQL непосредственно в код на C++. В данном
разделе показывается, как отделить встраиваемые команды SQL от кода приложения на C++, на
простом примере. В этом примере приложение реализуется на C++, а взаимодействие с сервером
PostgreSQL построено на C и ECPG.
Для сборки нужно создать три типа файлов: файл на C (*.pgc), заголовочный файл и файл на C++:
test_mod.pgc
Модуль подпрограмм будет выполнять SQL-команды, встроенные в C. Этот код нужно будет
преобразовать в test_mod.c с помощью препроцессора.
#include "test_mod.h"
#include <stdio.h>
void
db_connect()
{
EXEC SQL CONNECT TO testdb1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL
COMMIT;
}
void
db_test()
{
EXEC SQL BEGIN DECLARE SECTION;
char dbname[1024];
EXEC SQL END DECLARE SECTION;
EXEC SQL SELECT current_database() INTO :dbname;
printf("current_database = %s\n", dbname);
}
void
db_disconnect()
{
EXEC SQL DISCONNECT ALL;
}
test_mod.h
Заголовочный файл с объявлениями функций в модуле на языке C (test_mod.pgc). Он включа-
ется в test_cpp.cpp. Объявления в этом файле должны заключаться в блок extern "C", так как
он будет связываться с модулем C++.
#ifdef __cplusplus
extern "C" {
900ECPG — встраиваемый SQL в C
#endif
void db_connect();
void db_test();
void db_disconnect();
#ifdef __cplusplus
}
#endif
test_cpp.cpp
Основной код приложения, содержащий функцию main, а также, в данном примере, класс C++.
#include "test_mod.h"
class TestCpp
{
public:
TestCpp();
void test();
~TestCpp();
};
TestCpp::TestCpp()
{
db_connect();
}
void
TestCpp::test()
{
db_test();
}
TestCpp::~TestCpp()
{
db_disconnect();
}
int
main(void)
{
TestCpp *t = new TestCpp();
t-&gt;test();
return 0;
}
Для сборки приложения проделайте следующее. Преобразуйте test_mod.pgc в test_mod.c с помо-
щью ecpg, а затем получите test_mod.o, скомпилировав test_mod.c компилятором C:
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
После этого получите test_cpp.o, скомпилировав test_cpp.cpp компилятором C++:
c++ -c test_cpp.cpp -o test_cpp.o
Наконец, свяжите полученные объектные файлы, test_cpp.o и test_mod.o, в один исполняемый
файл, выполнив компоновку под управлением компилятора C++:
901ECPG — встраиваемый SQL в C
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
36.14. Команды встраиваемого SQL
В этом разделе описаны все команды, предназначенные специально для встраиваемого SQL. В
Справке: «Команды SQL» также описаны обычные команды SQL, которые можно использовать и
как встраиваемые, если явно не отмечено обратное.
902ECPG — встраиваемый SQL в C
ALLOCATE DESCRIPTOR
ALLOCATE DESCRIPTOR — выделить область SQL-дескриптора
Синтаксис
ALLOCATE DESCRIPTOR имя
Описание
ALLOCATE DESCRIPTOR выделяет новую именованную область SQL-дескриптора, через которую мож-
но обмениваться данными между сервером PostgreSQL и программой на C.
После использования области дескрипторов должны освобождаться командой DEALLOCATE
DESCRIPTOR.
Параметры
имя
Имя SQL-дескриптора, задаётся с учётом регистра. Это может быть идентификатор SQL или
переменная среды.
Примеры
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
Совместимость
Команда ALLOCATE DESCRIPTOR описана в стандарте SQL.
См. также
DEALLOCATE DESCRIPTOR, GET DESCRIPTOR, SET DESCRIPTOR
903ECPG — встраиваемый SQL в C
CONNECT
CONNECT — установить подключение к базе данных
Синтаксис
CONNECT TO цель_подключения [ AS имя_подключения ] [ USER пользователь_подключения ]
CONNECT TO DEFAULT
CONNECT пользователь_подключения
DATABASE цель_подключения
Описание
Команда CONNECT устанавливает подключение клиента к серверу PostgreSQL.
Параметры
цель_подключения
цель_соединения задаёт целевой сервер и базу для подключения в одной из нескольких форм.
[ имя_бд ] [ @сервер ] [ :порт ]
Подключение по TCP/IP
unix:postgresql://сервер [ :порт ] / [ имя_бд ] [ ?параметр_подключения ]
Подключение через Unix-сокеты
tcp:postgresql://сервер [ :порт ] / [ имя_бд ] [ ?параметр_подключения ]
Подключение по TCP/IP
Строковая константа SQL
содержащая значение в одной из показанных выше форм
переменная среды
переменная среды типа char[] или VARCHAR[], содержащая значение в одной из показанных
выше форм
объект_соединения
Необязательный идентификатор подключения, позволяющий обращаться к этому подключе-
нию в других командах. Это может быть идентификатор SQL или переменная среды.
пользователь_подключения
Имя пользователя для подключения к базе данных.
В этом параметре также можно передать имя и пароль одним из следующих способов:
имя_пользователя/пароль, имя_пользователя IDENTIFIED BY пароль или имя_пользователя
USING пароль.
В качестве имени пользователя и пароля можно задать идентификаторы SQL, строковые кон-
станты или переменные среды.
DEFAULT
Использовать все параметры подключения по умолчанию, которые определены библиотекой
libpq.
Примеры
Несколько вариантов указания параметров подключения:
904ECPG — встраиваемый SQL в C
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
connectuser;
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
connectpw;
EXEC SQL CONNECT
BY connectpw;
EXEC SQL CONNECT
EXEC SQL CONNECT
EXEC SQL CONNECT
BY "connectpw";
EXEC SQL CONNECT
"connectpw";
EXEC SQL CONNECT
connectuser;
TO "connectdb" AS main;
TO "connectdb" AS second;
TO "unix:postgresql://200.46.204.71/connectdb" AS main USER
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
TO
"unix:postgresql://localhost/connectdb" AS main USER connectuser;
'connectdb' AS main;
'unix:postgresql://localhost/connectdb' AS main USER :user;
:db AS :id;
:db USER connectuser USING :pw;
@localhost AS main USER connectdb;
REGRESSDB1 as main;
AS main USER connectdb;
connectdb AS :id;
connectdb AS main USER connectuser/connectdb;
connectdb AS main;
connectdb@localhost AS main;
tcp:postgresql://localhost/ USER connectdb;
tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY
TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED
TO unix:postgresql://localhost/ AS main USER connectdb;
TO unix:postgresql://localhost/connectdb AS main USER connectuser;
TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED
TO unix:postgresql://localhost/connectdb USER connectuser USING
TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER
Следующий пример программы демонстрирует применение переменных среды для определения
параметров подключения:
int
main(void)
{
EXEC SQL BEGIN DECLARE
char *dbname
=
char *user
=
char *connection =
SECTION;
"testdb";
/* имя базы данных */
"testuser"; /* имя пользователя подключения */
"tcp:postgresql://localhost:5432/testdb";
/* строка подключения */
char ver[256];
/* буфер для хранения строки версии */
EXEC SQL END DECLARE SECTION;
ECPGdebug(1, stderr);
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
CONNECT TO :dbname USER :user;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
SELECT version() INTO :ver;
DISCONNECT;
printf("version: %s\n", ver);
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
CONNECT TO :connection USER :user;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
SELECT version() INTO :ver;
DISCONNECT;
printf("version: %s\n", ver);
905ECPG — встраиваемый SQL в C
return 0;
}
Совместимость
Команда CONNECT описана в стандарте SQL, но формат параметров подключения определяется ре-
ализацией.
См. также
DISCONNECT, SET CONNECTION
906ECPG — встраиваемый SQL в C
DEALLOCATE DESCRIPTOR
DEALLOCATE DESCRIPTOR — освободить область SQL-дескриптора
Синтаксис
DEALLOCATE DESCRIPTOR имя
Описание
DEALLOCATE DESCRIPTOR освобождает область именованного SQL-дескриптора.
Параметры
имя
Имя дескриптора, подлежащего освобождению, задаётся с учётом регистра. Это может быть
идентификатор SQL или переменная среды.
Примеры
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
Совместимость
Команда DEALLOCATE DESCRIPTOR описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, GET DESCRIPTOR, SET DESCRIPTOR
907ECPG — встраиваемый SQL в C
DECLARE
DECLARE — определить курсор
Синтаксис
DECLARE имя_курсора [
WITHOUT } HOLD ] FOR
DECLARE имя_курсора [
WITHOUT } HOLD ] FOR
BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH |
подготовленный_оператор
BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH |
запрос
Описание
DECLARE объявляет курсор для прохода по набору результатов подготовленного оператора. Эта ко-
манда несколько отличается от обычной SQL-команды DECLARE: тогда как последняя выполняет за-
прос и подготавливает набор результатов для получения, встраиваемая SQL-команда просто объ-
являет имя в качестве «переменной цикла» для прохода по набору результатов запроса; фактиче-
ски запрос выполнится, когда курсор будет открыт командой OPEN.
Параметры
имя_курсора
Имя курсора, задаётся с учётом регистра. Это может быть идентификатор SQL или переменная
среды.
подготовленный_оператор
Имя подготовленного запроса, задаваемое SQL-идентификатором или переменной среды.
запрос
Команда SELECT или VALUES, выдающая строки, которые будут получены через курсор.
Параметры курсора рассматриваются в описании DECLARE.
Примеры
Примеры объявления курсора для запроса:
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
Пример объявления курсора для подготовленного оператора:
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
Совместимость
Команда DECLARE описана в стандарте SQL.
См. также
OPEN, CLOSE, DECLARE
908ECPG — встраиваемый SQL в C
DESCRIBE
DESCRIBE — получить информацию о подготовленном операторе или наборе результатов
Синтаксис
DESCRIBE [ OUTPUT ] подготовленный_оператор USING [ SQL ] DESCRIPTOR имя_дескриптора
DESCRIBE [ OUTPUT ] подготовленный_оператор INTO [ SQL ] DESCRIPTOR имя_дескриптора
DESCRIBE [ OUTPUT ] подготовленный_оператор INTO имя_sqlda
Описание
DESCRIBE получает метаданные о результирующих столбцах, содержащихся в подготовленном опе-
раторе, не считывая собственно строки результата.
Параметры
подготовленный_оператор
Имя подготовленного оператора. Это может быть идентификатор SQL или переменная среды.
имя_дескриптора
Имя дескриптора, задаётся с учётом регистра. Это может быть идентификатор SQL или пере-
менная среды.
имя_sqlda
Имя переменной SQLDA.
Примеры
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
ALLOCATE DESCRIPTOR mydesc;
PREPARE stmt1 FROM :sql_stmt;
DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
DEALLOCATE DESCRIPTOR mydesc;
Совместимость
Команда DESCRIBE описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, GET DESCRIPTOR
909ECPG — встраиваемый SQL в C
DISCONNECT
DISCONNECT — закрыть подключение к базе данных
Синтаксис
DISCONNECT
DISCONNECT
DISCONNECT
DISCONNECT
имя_подключения
[ CURRENT ]
DEFAULT
ALL
Описание
DISCONNECT закрывает подключение (или все подключения) к базе данных.
Параметры
имя_подключения
Имя подключения к базе данных устанавливается командой CONNECT.
CURRENT
Закрывает «текущее» подключение, то есть подключение, открытое последним, либо установ-
ленное командой SET CONNECTION. Текущее подключение подразумевается по умолчанию, если
DISCONNECT выполняется без аргументов.
DEFAULT
Закрывает подключение по умолчанию.
ALL
Закрывает все открытые подключения.
Примеры
int
main(void)
{
EXEC SQL
EXEC SQL
EXEC SQL
EXEC SQL
CONNECT
CONNECT
CONNECT
CONNECT
TO
TO
TO
TO
testdb
testdb
testdb
testdb
AS
AS
AS
AS
EXEC SQL DISCONNECT CURRENT;
EXEC SQL DISCONNECT DEFAULT;
EXEC SQL DISCONNECT ALL;
DEFAULT USER testuser;
con1 USER testuser;
con2 USER testuser;
con3 USER testuser;
/* закрывает con3
*/
/* закрывает DEFAULT
*/
/* закрывает con2 и con1 */
return 0;
}
Совместимость
Команда DISCONNECT описана в стандарте SQL.
См. также
CONNECT, SET CONNECTION
910ECPG — встраиваемый SQL в C
EXECUTE IMMEDIATE
EXECUTE IMMEDIATE — динамически подготовить и выполнить оператор
Синтаксис
EXECUTE IMMEDIATE строка
Описание
EXECUTE IMMEDIATE немедленно подготавливает и выполняет динамически задаваемый оператор
SQL, не получая при этом строки результата.
Параметры
строка
Строковая константа C или переменная среды, содержащая SQL-оператор, который нужно вы-
полнить.
Примеры
Пример выполнения оператора INSERT с применением команды EXECUTE IMMEDIATE и переменной
среды command:
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1,
'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
Совместимость
Команда EXECUTE IMMEDIATE описана в стандарте SQL.
911ECPG — встраиваемый SQL в C
GET DESCRIPTOR
GET DESCRIPTOR — получить информацию из области дескриптора SQL
Синтаксис
GET DESCRIPTOR имя_дескриптора :cvariable = элемент_заголовка_дескриптора [, ... ]
GET DESCRIPTOR имя_дескриптора VALUE номер_столбца :cvariable = элемент_дескриптора
[, ... ]
Описание
GET DESCRIPTOR получает информацию о наборе результатов запроса из области дескриптора SQL
и сохраняет её в переменные среды. Область дескриптора обычно предварительно заполняется
командами FETCH или SELECT, чтобы из неё можно было перенести сопутствующую информацию
в переменные среды.
Эта команда имеет две формы: первая форма выдаёт элементы из «заголовка» дескриптора, ко-
торый относится ко всему набору результатов в целом. Например, это число строк. Другая фор-
ма, требующая указания в дополнительном параметре номера столбца, выдаёт информацию о кон-
кретном столбце строки. В качестве примеров можно привести имя столбца и фактическое значе-
ние в этом столбце.
Параметры
имя_дескриптора
Имя дескриптора.
элемент_заголовка_дескриптора
Идентификатор, определяющий, какой элемент заголовка нужно получить. В настоящее время
поддерживается только COUNT, позволяющий получить число столбцов в наборе результатов.
номер_столбца
Номер столбца, информацию о котором нужно получить. Нумерация начинается с 1.
элемент_дескриптора
Идентификатор, определяющий, какой элемент информации о столбце нужно получить. Спи-
сок поддерживаемых элементов приведён в Подразделе 36.7.1.
cvariable
Переменная среды, в которую будут сохранены данные, полученные из области дескриптора.
Примеры
Пример получения числа столбцов в наборе результатов:
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
Пример получения размера данных в первом столбце:
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
Пример получения содержимого данных второго столбца в виде строки:
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
Следующий пример демонстрирует всю процедуру выполнения SELECT current_database(); и вы-
вода числа столбцов, длины данных в столбце и содержимого столбца:
int
912ECPG — встраиваемый SQL в C
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
int d_count;
char d_data[1024];
int d_returned_octet_length;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL ALLOCATE DESCRIPTOR d;
/* Объявить, открыть курсор и присвоить ему дескриптор */
EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
EXEC SQL OPEN cur;
EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
/* Получить общее число столбцов */
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
printf("d_count
= %d\n", d_count);
/* Получить размер возвращённого столбца */
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
printf("d_returned_octet_length = %d\n", d_returned_octet_length);
/* Выбрать возвращённый столбец в виде текстовой строки */
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
printf("d_data
= %s\n", d_data);
/* Закрытие */
EXEC SQL CLOSE cur;
EXEC SQL COMMIT;
EXEC SQL DEALLOCATE DESCRIPTOR d;
EXEC SQL DISCONNECT ALL;
return 0;
}
При выполнении этого примера будет получен такой результат:
d_count
= 1
d_returned_octet_length = 6
d_data
= testdb
Совместимость
Команда GET DESCRIPTOR описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, SET DESCRIPTOR
913ECPG — встраиваемый SQL в C
OPEN
OPEN — открыть динамический курсор
Синтаксис
OPEN имя_курсора
OPEN имя_курсора USING значение [, ... ]
OPEN имя_курсора USING SQL DESCRIPTOR имя_дескриптора
Описание
OPEN открывает курсор и в дополнение может связывать фактические значения с местозаполни-
телями в объявлении курсора. Курсор должен быть предварительно объявлен командой DECLARE.
Команда OPEN запускает выполнение запроса на сервере.
Параметры
имя_курсора
Имя открываемого курсора. Этот может быть идентификатор SQL или переменная среды.
значение
Значение, связываемое с местозаполнителем в курсоре. Это может быть константа SQL, пере-
менная среды или переменная среды с индикатором.
имя_дескриптора
Имя дескриптора, содержащего значения, которые должны быть связаны с местозаполнителя-
ми в курсоре. Это может быть идентификатор SQL или переменная среды.
Примеры
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
OPEN
OPEN
OPEN
OPEN
a;
d USING 1, 'test';
c1 USING SQL DESCRIPTOR mydesc;
:curname1;
Совместимость
Команда OPEN описана в стандарте SQL.
См. также
DECLARE, CLOSE
914ECPG — встраиваемый SQL в C
PREPARE
PREPARE — подготовить оператор к выполнению
Синтаксис
PREPARE имя FROM строка
Описание
Команда PREPARE подготавливает к выполнению динамический оператор, задаваемый в виде стро-
ки. Она отличается от обычного SQL-оператора PREPARE, который также можно использовать
во встраиваемых командах. Для обоих типов подготовленных операторов применяется команда
EXECUTE.
Параметры
подготовленный_оператор
Идентификатор для подготовленного запроса.
строка
Строковая константа C или переменная среды, содержащая подготавливаемый оператор:
SELECT, INSERT, UPDATE или DELETE.
Примеры
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";
EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;
EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
Совместимость
Команда PREPARE описана в стандарте SQL.
См. также
EXECUTE
915ECPG — встраиваемый SQL в C
SET AUTOCOMMIT
SET AUTOCOMMIT — установить режим автофиксации для текущего сеанса
Синтаксис
SET AUTOCOMMIT { = | TO } { ON | OFF }
Описание
SET AUTOCOMMIT устанавливает режим автофиксации для текущего сеанса использования базы дан-
ных. По умолчанию программы со встраиваемым SQL работают не в режиме автофиксации, так что
в определённые моменты нужно явно выполнять COMMIT. Эта команда может переключить сеанс в
режим автофиксации, когда неявно фиксируется каждый отдельный оператор.
Совместимость
SET AUTOCOMMIT — расширение PostgreSQL ECPG.
916ECPG — встраиваемый SQL в C
SET CONNECTION
SET CONNECTION — выбрать подключение к базе данных
Синтаксис
SET CONNECTION [ TO | = ] имя_подключения
Описание
SET CONNECTION устанавливает «текущее» подключение к базе данных, которое будет использо-
ваться командами, не задающими подключение явно.
Параметры
имя_подключения
Имя подключения к базе данных устанавливается командой CONNECT.
DEFAULT
Устанавливает заданное подключение подключением по умолчанию.
Примеры
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
Совместимость
Команда SET CONNECTION описана в стандарте SQL.
См. также
CONNECT, DISCONNECT
917ECPG — встраиваемый SQL в C
SET DESCRIPTOR
SET DESCRIPTOR — внести информацию в область дескриптора SQL
Синтаксис
SET DESCRIPTOR имя_дескриптора элемент_заголовка_дескриптора = значение [, ... ]
SET DESCRIPTOR имя_дескриптора VALUE номер элемент_дескриптора = значение [, ...]
Описание
SET DESCRIPTOR заполняет область SQL-дескриптора значениями. Заполненная область дескрипто-
ра обычно применяется для привязывания параметров при выполнении подготовленного запроса.
Эта команда имеет две формы: первая применяется к «заголовку» дескриптора, который не за-
висит от конкретных данных. Вторая форма устанавливает значения для определённых полей по
номерам.
Параметры
имя_дескриптора
Имя дескриптора.
элемент_заголовка_дескриптора
Идентификатор, определяющий, какой элемент заголовка нужно задать. В настоящее время
поддерживается только COUNT, позволяющий задать число элементов в дескрипторе.
номер
Номер элемента дескриптора, для которого задаётся значение. Нумерация начинается с 1.
элемент_дескриптора
Идентификатор, определяющий, какой элемент нужно установить в дескрипторе. Список под-
держиваемых элементов приведён в Подразделе 36.7.1.
значение
Значение, которое нужно поместить в элемент дескриптора. Это может быть константа SQL
или переменная среды.
Примеры
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SET
SET
SET
SET
SET
DESCRIPTOR
DESCRIPTOR
DESCRIPTOR
DESCRIPTOR
DESCRIPTOR
indesc
indesc
indesc
indesc
indesc
COUNT
VALUE
VALUE
VALUE
VALUE
=
1
1
2
2
1;
DATA = 2;
DATA = :val1;
INDICATOR = :val1, DATA = 'some string';
INDICATOR = :val2null, DATA = :val2;
Совместимость
Команда SET DESCRIPTOR описана в стандарте SQL.
См. также
ALLOCATE DESCRIPTOR, GET DESCRIPTOR
918ECPG — встраиваемый SQL в C
TYPE
TYPE — создать новый тип данных
Синтаксис
TYPE имя_типа IS тип_С
Описание
Команда TYPE определяет новый тип C. Она равнозначна добавлению typedef в секции объявлений.
Эта команда принимается, только когда ecpg запускается с параметром -c.
Параметры
имя_типа
Имя нового типа. Это имя должно быть допустимым для типа в языке C.
тип_С
Определение типа C.
Примеры
EXEC SQL TYPE customer IS
struct
{
varchar name[50];
int
phone;
};
EXEC SQL TYPE cust_ind IS
struct ind
{
short
name_ind;
short
phone_ind;
};
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
TYPE
TYPE
TYPE
TYPE
TYPE
c IS char reference;
ind IS union { int integer; short smallint; };
intarray IS int[AMOUNT];
str IS varchar[BUFFERSIZ];
string IS char[11];
Пример программы, в которой используется EXEC SQL TYPE:
EXEC SQL WHENEVER SQLERROR SQLPRINT;
EXEC SQL TYPE tt IS
struct
{
varchar v[256];
int
i;
};
EXEC SQL TYPE tt_ind IS
struct ind {
short
v_ind;
short
i_ind;
};
919ECPG — встраиваемый SQL в C
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
tt t;
tt_ind t_ind;
EXEC SQL END DECLARE SECTION;
EXEC SQL CONNECT TO testdb AS con1;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;
printf("t.v = %s\n", t.v.arr);
printf("t.i = %d\n", t.i);
printf("t_ind.v_ind = %d\n", t_ind.v_ind);
printf("t_ind.i_ind = %d\n", t_ind.i_ind);
EXEC SQL DISCONNECT con1;
return 0;
}
Эта программа выдаёт следующее:
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
Совместимость
Команда TYPE — расширение PostgreSQL.
920ECPG — встраиваемый SQL в C
VAR
VAR — определить переменную
Синтаксис
VAR имя_переменной IS тип_С
Описание
Команда VAR назначает переменной среды новый тип данных C. Переменная среды должна быть
объявлена ранее в секции объявлений.
Параметры
имя_переменной
Имя переменной C.
тип_С
Определение типа C.
Примеры
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
Совместимость
Команда VAR — расширение PostgreSQL.
921ECPG — встраиваемый SQL в C
WHENEVER
WHENEVER — определить действие, которое должно выполняться, когда при обработке SQL-опе-
ратора возникает определённое условие
Синтаксис
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } действие
Описание
Устанавливает поведение в случае определённых условий (строки не найдены, выданы предупре-
ждения или ошибки SQL и т. д.), возникающих в ходе выполнения SQL.
Параметры
Описание параметров приведено в Подразделе 36.8.1.
Примеры
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
EXEC
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
SQL
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
WHENEVER
NOT FOUND CONTINUE;
NOT FOUND DO BREAK;
NOT FOUND DO CONTINUE;
SQLWARNING SQLPRINT;
SQLWARNING DO warn();
SQLERROR sqlprint;
SQLERROR CALL print2();
SQLERROR DO handle_error("select");
SQLERROR DO sqlnotice(NULL, NONO);
SQLERROR DO sqlprint();
SQLERROR GOTO error_label;
SQLERROR STOP;
Типичное применение конструкция WHENEVER NOT FOUND BREAK находит в обработке результатов
запроса в цикле:
int
main(void)
{
EXEC SQL
EXEC SQL
EXEC SQL
EXEC SQL
EXEC SQL
CONNECT TO testdb AS con1;
SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
ALLOCATE DESCRIPTOR d;
DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
OPEN cur;
/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;
while (1)
{
EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
...
}
EXEC SQL CLOSE cur;
EXEC SQL COMMIT;
EXEC SQL DEALLOCATE DESCRIPTOR d;
EXEC SQL DISCONNECT ALL;
922ECPG — встраиваемый SQL в C
return 0;
}
Совместимость
Команда WHENEVER описана в стандарте SQL, но большинство действий относятся к расширениям
PostgreSQL.
36.15. Режим совместимости с Informix
Препроцессор ecpg может работать в так называемом режиме совместимости с Informix. Если
этот режим включён, ecpg старается работать как предкомпилятор Informix для кода Informix E/
SQL. Вообще говоря, это позволяет записывать встраиваемые команды SQL, используя знак дол-
лара вместо слов EXEC SQL:
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
Примечание
Между $ и последующей директивой препроцессора (в частности, include, define,
ifdef и т. п.) не должно быть пробельных символов. В противном случае препроцессор
воспримет следующее слово как имя переменной среды.
Поддерживаются два режима совместимости: INFORMIX и INFORMIX_SE
При компоновке программ, использующих этот режим совместимости, обязательно подключите
библиотеку libcompat, поставляемую с ECPG.
Помимо ранее упомянутого синтаксического сахара, режим совместимости с Informix приносит из
E/SQL в ECPG набор функций для ввода, вывода и преобразования данных, а также встраиваемые
операторы SQL.
Режим совместимости с Informix тесно связан с библиотекой pgtypeslib из ECPG. Библиотека
pgtypeslib сопоставляет типы данных SQL с типами данных в ведущей программе на C, а большин-
ство дополнительных функций режима совместимости с Informix позволяют работать с этими ти-
пами C. Заметьте, однако, что степень совместимости ограничена. ECPG не пытается копировать
поведение Informix; вы можете выполнять примерно те же операции и пользоваться функции с
теми же именами и с тем же поведением, но если вы используете Informix, просто заменить одно
средство другим на данный момент нельзя. Более того, есть различия и в типах данных. В част-
ности, типы даты и интервала в PostgreSQL не воспринимают диапазоны, как например, YEAR TO
MINUTE, так что и в ECPG это не будет поддерживаться.
36.15.1. Дополнительные типы
Теперь в режиме Informix без указания typedef поддерживается специальный псевдотип Informix
"string" для хранения символьной строки, обрезаемой справа. На самом деле, в режиме Informix
ECPG откажется обрабатывать исходные файлы, содержащие определение типа typedef некото-
рый_тип string;
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* эта переменная будет содержать обрезанные данные */
EXEC SQL END DECLARE SECTION;
EXEC SQL FETCH MYCUR INTO :userid;
923ECPG — встраиваемый SQL в C
36.15.2. Дополнительные/недостающие операторы встраиваемого
SQL
CLOSE DATABASE
Этот оператор закрывает текущее подключение. Фактически это синоним команды DISCONNECT
CURRENT в ECPG:
$CLOSE DATABASE;
EXEC SQL CLOSE DATABASE;
/* закрыть текущее подключение */
FREE имя_курсора
Из-за различий в подходах ECPG и ESQL/C Informix (т. е. другого разделения на чисто грамма-
тические преобразования и вызовы нижележащей библиотеки времени выполнения), в ECPG
нет оператора FREE имя_курсора. Это связано с тем, что в ECPG команда DECLARE CURSOR не
сводится к вызову функции в библиотеке времени выполнения, которая бы принимала имя кур-
сора. Это значит, что курсоры SQL в библиотеке ECPG не требуют обслуживания, оно требует-
ся только на уровне сервера PostgreSQL.
FREE имя_оператора
Команда FREE имя_оператора является синонимом команды DEALLOCATE PREPARE имя_опера-
тора.
36.15.3. Области дескрипторов SQLDA, совместимые с Informix
Режим совместимости с Informix поддерживает структуру, отличную от описанной в Подразде-
ле 36.7.2. См. ниже:
struct sqlvar_compat
{
short
sqltype;
int
sqllen;
char
*sqldata;
short *sqlind;
char
*sqlname;
char
*sqlformat;
short
sqlitype;
short
sqlilen;
char
*sqlidata;
int
sqlxid;
char
*sqltypename;
short
sqltypelen;
short
sqlownerlen;
short
sqlsourcetype;
char
*sqlownername;
int
sqlsourceid;
char
*sqlilongdata;
int
sqlflags;
void
*sqlreserved;
};
struct sqlda_compat
{
short sqld;
struct sqlvar_compat *sqlvar;
char
desc_name[19];
short desc_occ;
struct sqlda_compat *desc_next;
void *reserved;
924ECPG — встраиваемый SQL в C
};
typedef struct sqlvar_compat
typedef struct sqlda_compat
sqlvar_t;
sqlda_t;
Глобальные свойства:
sqld
Число полей в дескрипторе SQLDA.
sqlvar
Указатель на свойства по полям.
desc_name
Не используется, заполняется нулями.
desc_occ
Размер структуры в памяти.
desc_next
Указатель на следующую структуру SQLDA, если набор результатов содержит больше одной
записи.
reserved
Неиспользуемый указатель, содержит NULL. Сохраняется для совместимости с Informix.
Свойства, относящиеся к полям, описаны ниже, они хранятся в массиве sqlvar:
sqltype
Тип поля. Соответствующие константы представлены в sqltypes.h
sqllen
Длина данных поля.
sqldata
Указатель на данные поля. Этот указатель имеет тип char *, но он указывает на данные в
двоичном формате. Например:
int intval;
switch (sqldata-&gt;sqlvar[i].sqltype)
{
case SQLINTEGER:
intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;
break;
...
}
sqlind
Указатель на индикатор NULL. Если возвращается командами DESCRIBE или FETCH, это все-
гда действительный указатель. Если передаётся на вход команде EXECUTE ... USING sqlda;,
NULL вместо указателя означает, что значение этого поля отлично от NULL. Чтобы обозначить
NULL в поле, необходимо корректно установить этот указатель и sqlitype. Например:
if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)
printf("value is NULL\n");
925ECPG — встраиваемый SQL в C
sqlname
Имя поля, в виде строки с завершающим 0.
sqlformat
Зарезервировано в Informix, значение PQfformat() для данного поля.
sqlitype
Тип данных индикатора NULL. При получении данных с сервера это всегда SQLSMINT. Когда
SQLDA используется в параметризованном запросе, данные индикатора обрабатываются в соот-
ветствии с указанным здесь типом.
sqlilen
Длина данных индикатора NULL.
sqlxid
Расширенный тип поля, результат функции PQftype().
sqltypename
sqltypelen
sqlownerlen
sqlsourcetype
sqlownername
sqlsourceid
sqlflags
sqlreserved
Не используются.
sqlilongdata
Совпадает с sqldata, если sqllen превышает 32 Кбайта.
Например:
EXEC SQL INCLUDE sqlda.h;
sqlda_t
SECTION */
*sqlda; /* Это объявление не обязательно должно быть внутри DECLARE
EXEC SQL BEGIN DECLARE SECTION;
char *prep_stmt = "select * from table1";
int i;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL PREPARE mystmt FROM :prep_stmt;
EXEC SQL DESCRIBE mystmt INTO sqlda;
printf("# of fields: %d\n", sqlda-&gt;sqld);
for (i = 0; i &lt; sqlda-&gt;sqld; i++)
printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);
EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
EXEC SQL OPEN mycursor;
EXEC SQL WHENEVER NOT FOUND GOTO out;
926ECPG — встраиваемый SQL в C
while (1)
{
EXEC SQL FETCH mycursor USING sqlda;
}
EXEC SQL CLOSE mycursor;
free(sqlda); /* Освобождать нужно только основную структуру,
* sqlda и sqlda-&gt;sqlvar находятся в одной выделенной области. */
Дополнительную информацию можно найти в заголовочном файле sqlda.h и в регрессионном те-
сте src/interfaces/ecpg/test/compat_informix/sqlda.pgc.
36.15.4. Дополнительные функции
decadd
Складывает два значения типа decimal.
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
Эта функция получает указатель на первый операнд типа decimal (arg1), указатель на второй
операнд типа decimal (arg2) и указатель на переменную типа decimal, в которую будет записана
сумма (sum). В случае успеха эта функция возвращает 0. ECPG_INFORMIX_NUM_OVERFLOW возвра-
щается в случае переполнения, а ECPG_INFORMIX_NUM_UNDERFLOW в случае антипереполнения.
При любых других ошибках возвращается -1, а в errno устанавливается код errno из pgtypeslib.
deccmp
Сравнивает два значения типа decimal.
int deccmp(decimal *arg1, decimal *arg2);
Эта функция получает указатель на первое значение типа decimal (arg1), указатель на второе
значение типа decimal (arg2) и возвращает целое, отражающее результат сравнения этих чи-
сел.
• 1, если значение, на которое указывает arg1, больше значения, на которое указывает var2
• -1, если значение, на которое указывает arg1, меньше значения, на которое указывает
arg2
• 0, если значение, на которое указывает arg1, равно значению, на которое указывает arg2
deccopy
Копирует значение типа decimal.
void deccopy(decimal *src, decimal *target);
Функция принимает в первом аргументе (src) указатель на значение decimal, которое долж-
но быть скопировано, а во втором аргументе (target) принимает указатель на структуру типа
decimal для скопированного значения.
deccvasc
Преобразует значение из представления ASCII в тип decimal.
int deccvasc(char *cp, int len, decimal *np);
Эта функция получает указатель на строку, содержащую строковое представление числа, ко-
торое нужно преобразовать, (cp), а также его длину len. В np передаётся указатель на пере-
менную типа decimal, в которую будет помещён результат преобразования.
Допустимыми являются, например следующие форматы: -2, .794, +3.44, 592.49E07 или
-32.84e-4.
927ECPG — встраиваемый SQL в C
В случае успеха эта функция возвращает 0. При переполнении или антипереполнении возвра-
щается ECPG_INFORMIX_NUM_OVERFLOW или ECPG_INFORMIX_NUM_UNDERFLOW, соответственно. Ес-
ли разобрать ASCII-представление не удаётся, возвращается ECPG_INFORMIX_BAD_NUMERIC или
ECPG_INFORMIX_BAD_EXPONENT, если не удаётся разобрать компонент экспоненты.
deccvdbl
Преобразует значение double в значение типа decimal.
int deccvdbl(double dbl, decimal *np);
Данная функция принимает в первом аргументе (dbl) переменную типа double, которая долж-
на быть преобразована. Во втором аргументе (np) она принимает указатель на переменную
decimal, в которую будет помещён результат операции.
Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить пре-
образование не удалось.
deccvint
Преобразует значение int в значение типа decimal.
int deccvint(int in, decimal *np);
Данная функция принимает в первом аргументе (in) переменную типа int, которая должна быть
преобразована. Во втором аргументе (np) она принимает указатель на переменную decimal, в
которую будет помещён результат операции.
Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить пре-
образование не удалось.
deccvlong
Преобразует значение long в значение типа decimal.
int deccvlong(long lng, decimal *np);
Данная функция принимает в первом аргументе (lng) переменную типа long, которая долж-
на быть преобразована. Во втором аргументе (np) она принимает указатель на переменную
decimal, в которую будет помещён результат операции.
Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить пре-
образование не удалось.
decdiv
Делит одну переменную типа decimal на другую.
int decdiv(decimal *n1, decimal *n2, decimal *result);
Эта функция получает указатели на переменные (n1 и n2) и вычисляет частное n1/n2. В result
передаётся указатель на переменную, в которую будет помещён результат операции.
В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае перепол-
нения или антипереполнения данная функция возвращает ECPG_INFORMIX_NUM_OVERFLOW или
ECPG_INFORMIX_NUM_UNDERFLOW, соответственно. При попытке деления на ноль возвращается
ECPG_INFORMIX_DIVIDE_ZERO.
decmul
Перемножает два значения типа decimal.
int decmul(decimal *n1, decimal *n2, decimal *result);
Эта функция получает указатели на переменные (n1 и n2) и вычисляет произведение n1*n2. В
result передаётся указатель на переменную, в которую будет помещён результат операции.
928ECPG — встраиваемый SQL в C
В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае перепол-
нения или антипереполнения данная функция возвращает ECPG_INFORMIX_NUM_OVERFLOW или
ECPG_INFORMIX_NUM_UNDERFLOW, соответственно.
decsub
Вычитает одно значение типа decimal из другого.
int decsub(decimal *n1, decimal *n2, decimal *result);
Эта функция получает указатели на переменные (n1 и n2) и вычисляет разность n1-n2. В result
передаётся указатель на переменную, в которую будет помещён результат операции.
В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае перепол-
нения или антипереполнения данная функция возвращает ECPG_INFORMIX_NUM_OVERFLOW или
ECPG_INFORMIX_NUM_UNDERFLOW, соответственно.
dectoasc
Преобразует переменную типа decimal в представление ASCII (в строку C char*).
int dectoasc(decimal *np, char *cp, int len, int right)
Эта функция получает указатель на переменную типа decimal (np), которая будет преобразо-
вана в текстовое представление. Аргумент cp указывает на буфер, в который будет помещён
результат операции. Аргумент right определяет, сколько должно выводиться цифр правее де-
сятичной точки. Результат будет округлён до этого числа десятичных цифр. Значение right,
равное -1, указывает, что выводиться должны все имеющиеся десятичные цифры. Если длина
выходного буфера, которую задаёт len, недостаточна для помещения в него текстового пред-
ставления, включая завершающий нулевой байт, в буфере сохраняется один знак * и возвра-
щается -1.
Эта функция возвращает -1, если буфер cp слишком мал, либо ECPG_INFORMIX_OUT_OF_MEMORY
при нехватке памяти.
dectodbl
Преобразует переменную типа decimal в тип double.
int dectodbl(decimal *np, double *dblp);
Эта функция получает указатель (np) на значение decimal, которое нужно преобразовать, и
указатель (dblp) на переменную double, в которую будет помещён результат операции.
В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование
не удалось.
dectoint
Преобразует переменную типа decimal в тип integer.
int dectoint(decimal *np, int *ip);
Эта функция получает указатель (np) на значение decimal, которое нужно преобразовать, и
указатель (ip) на целочисленную переменную, в которую будет помещён результат операции.
В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование
не удалось. В случае переполнения возвращается ECPG_INFORMIX_NUM_OVERFLOW.
Заметьте, что реализация ECPG отличается от реализации Informix. В Informix целое ограни-
чивается диапазоном -32767 .. 32767, тогда как в ECPG ограничение зависит от архитектуры
(-INT_MAX .. INT_MAX).
dectolong
Преобразует переменную типа decimal в тип long.
929ECPG — встраиваемый SQL в C
int dectolong(decimal *np, long *lngp);
Эта функция получает указатель (np) на значение decimal, которое нужно преобразовать, и
указатель (lngp) на переменную типа long, в которую будет помещён результат операции.
В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование
не удалось. В случае переполнения возвращается ECPG_INFORMIX_NUM_OVERFLOW.
Заметьте, что реализация ECPG отличается от реализации Informix. В Informix длинное целое
ограничено диапазоном -2 147 483 647 .. 2 147 483 647, тогда как в ECPG ограничение зависит
от архитектуры (-LONG_MAX .. LONG_MAX).
rdatestr
Преобразует дату в строку C char*.
int rdatestr(date d, char *str);
Эта функция принимает два аргумента. В первом (d) передаётся дата, которую нужно преобра-
зовать, а во втором указатель на целевую строку. Результат всегда выводится в формате yyyy-
mm-dd, так что для этой строки нужно выделить минимум 11 байт (включая завершающий ну-
левой байт).
Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.
Заметьте, что реализация ECPG отличается от реализации Informix. В Informix формат вывода
можно изменить переменными окружения, а в ECPG он фиксирован.
rstrdate
Разбирает текстовое представление даты.
int rstrdate(char *str, date *d);
Эта функция получает текстовое представление (str) даты, которую нужно преобразовать, и
указатель на переменную типа date (d). Для данной функции нельзя задать маску формата. Она
использует стандартную маску формата Informix, а именно: mm/dd/yyyy. Внутри эта функция
вызывает rdefmtdate. Таким образом, rstrdate не будет быстрее, и если у вас есть выбор, ис-
пользуйте функцию rdefmtdate, которая позволяет явно задать маску формата.
Эта функция возвращает те же значения, что и rdefmtdate.
rtoday
Выдаёт текущую дату.
void rtoday(date *d);
Эта функция получает указатель на переменную (d) типа date, в которую будет записана теку-
щая дата.
Внутри эта функция вызывает PGTYPESdate_today.
rjulmdy
Извлекает значения дня, месяца и года из переменной типа date.
int rjulmdy(date d, short mdy[3]);
Эта функция получает дату d и указатель на 3 коротких целочисленных значения mdy. Имя
переменной указывает на порядок значений: в mdy[0] записывается номер месяца, в mdy[1] —
номер дня, а в mdy[2] — год.
В текущем состоянии эта функция всегда возвращает 0.
Внутри эта функция вызывает PGTYPESdate_julmdy.
930ECPG — встраиваемый SQL в C
rdefmtdate
Преобразует символьную строку в значение типа date по маске формата.
int rdefmtdate(date *d, char *fmt, char *str);
Эта функция принимает указатель на переменную типа date (d), в которую будет помещён ре-
зультат операции, маску формата для разбора даты (fmt) и строку C char*, содержащую тексто-
вое представление даты (str). Ожидается, что текстовое представление будет соответствовать
маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция
анализирует только порядок элементов и ищет в нём подстроки yy или yyyy, обозначающие по-
зицию года, подстроку mm, обозначающую позицию месяца, и dd, обозначающую позицию дня.
Эта функция возвращает следующие значения:
• 0 — Функция выполнена успешно.
• ECPG_INFORMIX_ENOSHORTDATE — Дата не содержит разделителей между днём, месяцем и
годом. С таким форматом входная строка должна быть длиной ровно 6 или 8 байт, но это
не так.
• ECPG_INFORMIX_ENOTDMY — Строка формата не определяет корректно последовательный по-
рядок года, месяца и дня.
• ECPG_INFORMIX_BAD_DAY — Во входной строке отсутствует корректное указание дня.
• ECPG_INFORMIX_BAD_MONTH — Во входной строке отсутствует корректное указание месяца.
• ECPG_INFORMIX_BAD_YEAR — Во входной строке отсутствует корректное указание года.
В реализации этой функции вызывается PGTYPESdate_defmt_asc. Примеры вводимых строк при-
ведены в таблице в её описании.
rfmtdate
Преобразует переменную типа date в текстовое представление по маске формата.
int rfmtdate(date d, char *fmt, char *str);
Эта функция принимает дату для преобразования (d), маску формата (fmt) и строку, в которую
будет помещено текстовое представление даты (str).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
Внутри эта функция вызывает PGTYPESdate_fmt_asc, примеры форматов можно найти в её опи-
сании.
rmdyjul
Образует значение даты из массива 3 коротких целых, задающих день, месяц и год даты.
int rmdyjul(short mdy[3], date *d);
Эта функция получает в первом аргументе массив из 3 коротких целых (mdy), а во втором ука-
затель на переменную типа date, в которую будет помещён результат операции.
В настоящее время эта функция всегда возвращает 0.
В реализации этой функции вызывается PGTYPESdate_mdyjul.
rdayofweek
Возвращает число, представляющее день недели для заданной даты.
int rdayofweek(date d);
Эта функция принимает в единственном аргументе переменную d типа date и возвращает целое
число, выражающее день недели для этой даты.
931ECPG — встраиваемый SQL в C
• 0 — Воскресенье
• 1 — Понедельник
• 2 — Вторник
• 3 — Среда
• 4 — Четверг
• 5 — Пятница
• 6 — Суббота
В реализации этой функции вызывается PGTYPESdate_dayofweek.
dtcurrent
Получает текущее время.
void dtcurrent(timestamp *ts);
Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую
указывает ts.
dtcvasc
Разбирает время из текстового представления в переменную типа timestamp.
int dtcvasc(char *str, timestamp *ts);
Эта функция получает строку (str), которую нужно разобрать, и указатель на переменную типа
timestamp, в которую будет помещён результат операции (ts).
Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.
Внутри эта функция вызывает PGTYPEStimestamp_from_asc. Примеры вводимых строк приведе-
ны в таблице в её описании.
dtcvfmtasc
Разбирает время из текстового представления в переменную типа timestamp по маске формата.
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
Эта функция получает строку (inbuf), которую нужно разобрать, маску формата (fmtstr) и ука-
затель на переменную timestamp, в которой будет содержаться результат операции (dtvalue).
В реализации этой функции используется PGTYPEStimestamp_defmt_asc. Список допустимых
кодов формата приведён в её описании.
Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.
dtsub
Вычитает одно значение времени из другого и возвращает переменную типа interval.
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
Эта функция вычитает значение timestamp, на которое указывает ts2, из значения timestamp,
на которое указывает ts1, и сохраняет результат в переменной типа interval, на которую ука-
зывает iv.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
dttoasc
Преобразует переменную типа timestamp в строку C char*.
int dttoasc(timestamp *ts, char *output);
932ECPG — встраиваемый SQL в C
Эта функция получает указатель (ts) на переменную типа timestamp, которую нужно преобра-
зовать, и строку (output) для сохранения результата операции. Она преобразует ts в текстовое
представление согласно стандарту SQL, то есть по маске YYYY-MM-DD HH:MM:SS.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
dttofmtasc
Преобразует переменную типа timestamp в строку C char* по маске формата.
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
Эта функция получает в первом аргументе (ts) указатель на переменную типа timestamp, а в
последующих указатель на буфер вывода (output), максимальную длину строки, которую мо-
жет принять буфер (str_len), и маску формата, с которой будет выполняться преобразование
(fmtstr).
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
Внутри эта функция использует PGTYPEStimestamp_fmt_asc. Примеры допустимых масок фор-
мата можно найти в её описании.
intoasc
Преобразует переменную типа interval в строку C char*.
int intoasc(interval *i, char *str);
Эта функция получает указатель (i) на переменную типа interval, которую нужно преобразо-
вать, и строку (str) для сохранения результата операции. Она преобразует i в текстовое пред-
ставление согласно стандарту SQL, то есть по маске YYYY-MM-DD HH:MM:SS.
В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.
rfmtlong
Преобразует длинное целое в текстовое представление по маске формата.
int rfmtlong(long lng_val, char *fmt, char *outbuf);
Эта функция принимает значение типа long (lng_val), маску формата (fmt) и указатель на вы-
ходной буфер (outbuf). Она преобразует длинное целое в его текстовое представление соглас-
но заданной маске формата.
Маску формата можно составить из следующих символов, определяющих формат:
• * (звёздочка) — если в данной позиции будет пусто, заполнить её звёздочкой.
• &amp; (амперсанд) — если в данной позиции будет пусто, заполнить её нулём.
• # — заменить ведущие нули пробелами.
• &lt; — выровнять число в строке по левой стороне.
• , (запятая) — сгруппировать числа, содержащие четыре и более цифр, в группы по три
цифры через запятую.
• . (точка) — этот символ отделяет целую часть числа от дробной.
• - (минус) — с отрицательным числом должен выводиться знак минус.
• + (плюс) — с положительным числом должен выводиться знак плюс.
• ( — это символ заменяет знак минус перед отрицательным числом. Сам знак минус выво-
диться не будет.
• ) — этот символ заменяет минус и выводится после отрицательного числа.
• $ — символ денежной суммы.
933ECPG — встраиваемый SQL в C
rupshift
Приводит строку к верхнему регистру.
void rupshift(char *str);
Эта функция получает указатель на строку и приводит в ней каждый символ в нижнем регистре
к верхнему регистру.
byleng
Возвращает число символов в строке, не считая завершающих пробелов.
int byleng(char *str, int len);
Эта функция принимает в первом аргументе (str) строку фиксированной длины, а во втором
(len) её длину. Она возвращает число значимых символов, то есть длину строки без заверша-
ющих пробелов.
ldchar
Копирует строку фиксированной длины в строку с завершающим нулём.
void ldchar(char *src, int len, char *dest);
Эта функция принимает строку фиксированной длины (src), которую нужно скопировать, её
длину (len) и указатель на целевой буфер в памяти (dest). Учтите, что для буфера, на который
указывает dest, необходимо выделить как минимум len+1 байт. Данная функция копирует в
новую область не больше len байт (меньше, если в исходной строке есть завершающие пробелы)
и добавляет завершающий 0.
rgetmsg
int rgetmsg(int msgnum, char *s, int maxsize);
Эта функция определена, но не реализована на данный момент!
rtypalign
int rtypalign(int offset, int type);
Эта функция определена, но не реализована на данный момент!
rtypmsize
int rtypmsize(int type, int len);
Эта функция определена, но не реализована на данный момент!
rtypwidth
int rtypwidth(int sqltype, int sqllen);
Эта функция определена, но не реализована на данный момент!
rsetnull
Присваивает переменной NULL.
int rsetnull(int t, char *ptr);
Эта функция получает целое, определяющее тип переменной, и указатель на саму переменную,
приведённый к указателю C char*.
Определены следующие типы:
• CCHARTYPE — для переменной типа char или char*
• CSHORTTYPE — для переменной типа short int
• CINTTYPE — для переменной типа int
934ECPG — встраиваемый SQL в C
• CBOOLTYPE — для переменной типа boolean
• CFLOATTYPE — для переменной типа float
• CLONGTYPE — для переменной типа long
• CDOUBLETYPE — для переменной типа double
• CDECIMALTYPE — для переменной типа decimal
• CDATETYPE — для переменной типа date
• CDTIMETYPE — для переменной типа timestamp
Примеры вызова этой функции:
$char c[] = "abc
$short s = 17;
$int i = -74874;
";
rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &amp;s);
rsetnull(CINTTYPE, (char *) &amp;i);
risnull
Проверяет содержимое переменной на NULL.
int risnull(int t, char *ptr);
Эта функция получает тип проверяемой переменной (t), а также указатель на неё (ptr). За-
метьте, что этот указатель нужно привести к char*. Список возможных типов переменных при-
ведён в описании функции rsetnull.
Примеры использования этой функции:
$char c[] = "abc
$short s = 17;
$int i = -74874;
";
risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &amp;s);
risnull(CINTTYPE, (char *) &amp;i);
36.15.5. Дополнительные константы
Заметьте, что все эти константы относятся к ошибкам и все они представлены отрицательными
значениями. Из описаний различных констант вы также можете узнать, какими именно числами
они представлены в текущей реализации. Однако полагаться на эти числа не следует. Тем не ме-
нее, вы можете рассчитывать на то, что все эти значения будут отрицательными.
ECPG_INFORMIX_NUM_OVERFLOW
Функции возвращают это значение, если при вычислении происходит переполнение. Внутри
оно представляется числом -1200 (определение Informix).
ECPG_INFORMIX_NUM_UNDERFLOW
Функции возвращают это значение, если при вычислении происходит антипереполнение. Внут-
ри оно представляется числом -1201 (определение Informix).
ECPG_INFORMIX_DIVIDE_ZERO
Функции возвращают это значение при попытке деления на ноль. Внутри оно представляется
числом -1202 (определение Informix).
935ECPG — встраиваемый SQL в C
ECPG_INFORMIX_BAD_YEAR
Функции возвращают это значение, если при разборе даты встретилось некорректное указание
года. Внутри оно представляется числом -1204 (определение Informix).
ECPG_INFORMIX_BAD_MONTH
Функции возвращают это значение, если при разборе даты встретилось некорректное указание
месяца. Внутри оно представляется числом -1205 (определение Informix).
ECPG_INFORMIX_BAD_DAY
Функции возвращают это значение, если при разборе даты встретилось некорректное указание
дня. Внутри оно представляется числом -1206 (определение Informix).
ECPG_INFORMIX_ENOSHORTDATE
Функции возвращают это значение, если процедуре разбора даты требуется короткая запись
даты, но строка даты имеет неподходящую длину. Внутри оно представляется числом -1209
(определение Informix).
ECPG_INFORMIX_DATE_CONVERT
Функции возвращают это значение, если при форматировании даты происходит ошибка. Внутри
оно представляется числом -1210 (определение Informix).
ECPG_INFORMIX_OUT_OF_MEMORY
Функции возвращают это значение, если им не хватает памяти для выполнения операций. Внут-
ри оно представляется числом -1211 (определение Informix).
ECPG_INFORMIX_ENOTDMY
Функции возвращают это значение, если процедура разбора должна была получить маску фор-
мата (например, mmddyy), но не все поля были записаны правильно. Внутри оно представляется
числом -1212 (определение Informix).
ECPG_INFORMIX_BAD_NUMERIC
Функции возвращают это значение, если процедура разбора не может получить числовое зна-
чение из текстового представления, потому что оно некорректно, либо если процедура вычис-
ления не может произвести операцию с числовыми переменными из-за недопустимого значе-
ния минимум одной из этих переменных. Внутри оно представляется числом -1213 (определе-
ние Informix).
ECPG_INFORMIX_BAD_EXPONENT
Функции возвращают это значение, если процедура разбора не может воспринять экспоненту
в числе. Внутри оно представляется числом -1216 (определение Informix).
ECPG_INFORMIX_BAD_DATE
Функции возвращают это значение, если процедура разбора не может разобрать дату. Внутри
оно представляется числом -1218 (определение Informix).
ECPG_INFORMIX_EXTRA_CHARS
Функции возвращают это значение, если процедуре разбора передаются посторонние симво-
лы, которая она не может разобрать. Внутри оно представляется числом -1264 (определение
Informix).
36.16. Внутреннее устройство
В этом разделе рассказывается, как препроцессор ECPG устроен внутри. Эта информация может
оказаться полезной для пользователей, желающих понять, как использовать ECPG.
936ECPG — встраиваемый SQL в C
Первые четыре строки, которые ecpg записывает в вывод, фиксированы. Первые две строки содер-
жат комментарии, а следующие две директивы включения, подключающие интерфейс к библио-
теке. Затем препроцессор прочитывает файл и продолжает запись в вывод. Обычно он просто пе-
чатает всё в устройство вывода.
Встречая команду EXEC SQL, он вмешивается и изменяет её. Данная команда начинается со слов
EXEC SQL и заканчивается знаком ;. Всё между ними воспринимается как оператор SQL и разби-
рается для подстановки переменных.
Подстановка переменных имеет место, когда символ начинается с двоеточия (:). ECPG будет
искать переменную с таким именем среди переменных, ранее объявленных в секции EXEC SQL
DECLARE.
Самая важная функция в библиотеке — ECPGdo, которая осуществляет выполнение большинства
команд. Она принимает переменное число аргументов (это число легко может достигать 50, и мы
надеемся, что это не приведёт к проблемам ни на какой платформе).
Ей передаются следующие аргументы:
Номер строки
Номер исходной строки; используется только в сообщениях об ошибках.
Строка
Команда SQL, которая должна быть выполнена. На её содержимое влияют входные перемен-
ные, то есть переменные, добавленные в команду, но неизвестные во время компиляции. Ме-
ста, в которые должны вставляться переменные, обозначаются знаками ?.
Входные переменные
Для каждой входной переменной формируются десять аргументов. (См. ниже.)
ECPGt_EOIT
Перечисление (enum), показывающее, что больше входных переменных нет.
Выходные переменные
Для каждой входной переменной формируются десять аргументов. (См. ниже.) Эти переменные
заполняются данной функцией.
ECPGt_EORT
Перечисление (enum), показывающее, что больше выходных переменных нет.
Для каждой переменной, включённой в команду SQL, эта функция принимает десять аргументов:
1. Тип в виде специального символа.
2. Указатель на значение или указатель на указатель.
3. Размер переменной, если она имеет тип char или varchar.
4. Число элементов в массиве (при выборке данных в массив).
5. Смещение следующего элемента в массиве (при выборке данных в массив).
6. Тип переменной-индикатора в виде специального символа.
7. Указатель на переменную-индикатор.
8. 0
9. Число элементов в массиве индикаторов (при выборке данных в массив).
10.Смещение следующего элемента в массиве индикаторов (при выборке данных в массив).
937ECPG — встраиваемый SQL в C
Заметьте, что не все команды SQL обрабатываются таким образом. Например, команда открытия
курсора вида:
EXEC SQL OPEN курсор;
не копируется в вывод. Вместо этого в позиции команды OPEN применяется команда DECLARE этого
курсора, так как на самом деле курсор открывает она.
Ниже показан полный пример, демонстрирующий результат обработки препроцессором файла
foo.pgc (детали могут меняться от версии к версии препроцессора):
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
преобразуется в:
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;
/* exec sql begin declare section */
#line 1 "foo.pgc"
int index;
int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?
ECPGt_int,&amp;(index),1L,1L,sizeof(int),
ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
ECPGt_int,&amp;(result),1L,1L,sizeof(int),
ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
(Отступы здесь добавлены для читаемости, препроцессор их не вставляет.)
938
</ecpglib.h></ecpgtype.h></stdio.h></libpq-fe.h></stdlib.h></stdio.h></имя_файла.h></имя_файла></cur_sqlda-></unistd.h></stdio.h></stdlib.h></string.h></stdlib.h>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-036/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-036/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-036/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-035/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
