<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 3. Расширенные возможности &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 3. Расширенные возможности">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 3. Расширенные возможности">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-003/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-003/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 3. Расширенные возможности">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-003/" rel="bookmark" title="Глава 3. Расширенные возможности">Глава 3. Расширенные возможности</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~14 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 3. Расширенные возможности</p>

<p>3.1. Введение
В предыдущей главе мы изучили азы использования SQL для хранения и обработки данных в
PostgreSQL. Теперь мы обсудим более сложные возможности SQL, помогающие управлять данны-
ми и предотвратить их потерю или порчу. В конце главы мы рассмотрим некоторые расширения
PostgreSQL.
В этой главе мы будем время от времени ссылаться на примеры, приведённые в Главе 2 и изменять
или развивать их, поэтому будет полезно сначала прочитать предыдущую главу. Некоторые при-
меры этой главы также можно найти в файле advanced.sql в каталоге tutorial. Кроме того, этот
файл содержит пример данных для загрузки (здесь она повторно не рассматривается). Если вы не
знаете, как использовать этот файл, обратитесь к Разделу 2.1.
3.2. Представления
Вспомните запросы, с которыми мы имели дело в Разделе 2.6. Предположим, что вас интересует
составной список из погодных записей и координат городов, но вы не хотите каждый раз вводить
весь этот запрос. Вы можете создать представление по данному запросу, фактически присвоить
имя запросу, а затем обращаться к нему как к обычной таблице:
CREATE VIEW myview AS
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
SELECT * FROM myview;
Активное использование представлений — это ключевой аспект хорошего проектирования баз дан-
ных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые мо-
гут меняться по мере развития приложения, за надёжными интерфейсами.
Представления можно использовать практически везде, где можно использовать обычные табли-
цы. И довольно часто представления создаются на базе других представлений.
3.3. Внешние ключи
Вспомните таблицы weather и cities из Главы 2. Давайте рассмотрим следующую задачу: вы хо-
тите добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится
соответствующая строка в таблице cities. Это называется обеспечением ссылочной целостности
данных. В простых СУБД это пришлось бы реализовать (если это вообще возможно) так: сначала
явно проверить, есть ли соответствующие записи в таблице cities, а затем отклонить или вставить
новые записи в таблицу weather. Этот подход очень проблематичен и неудобен, поэтому всё это
PostgreSQL может сделать за вас.
Новое объявление таблицы будет выглядеть так:
CREATE TABLE cities (
city
varchar(80) primary key,
location point
);
CREATE TABLE weather (
city
varchar(80) references cities(city),
temp_lo
int,
temp_hi
int,
prcp
real,
14Расширенные возможности
date
date
);
Теперь попробуйте вставить недопустимую запись:
INSERT INTO weather VALUES (‘Berkeley’, 45, 53, 0.0, ‘1994-11-28’);
ОШИБКА: INSERT или UPDATE в таблице “weather” нарушает ограничение внешнего
ключа “weather_city_fkey”
ПОДРОБНОСТИ: Ключ (city)=(Berkeley) отсутствует в таблице “cities”.
Поведение внешних ключей можно подстроить согласно требованиям вашего приложения. Мы не
будем усложнять этот простой пример в данном введении, но вы можете обратиться за дополни-
тельной информацией к Главе 5. Правильно применяя внешние ключи, вы определённо создадите
более качественные приложения, поэтому мы настоятельно рекомендуем изучить их.
3.4. Транзакции
Транзакции — это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объ-
единяет последовательность действий в одну операцию “всё или ничего”. Промежуточные состо-
яния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно
завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.
Например, рассмотрим базу данных банка, в которой содержится информация о счетах клиентов,
а также общие суммы по отделениям банка. Предположим, что мы хотим перевести 100 долларов
со счёта Алисы на счёт Боба. Простоты ради, соответствующие SQL-команды можно записать так:
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
UPDATE branches SET balance = balance - 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Alice’);
UPDATE accounts SET balance = balance + 100.00
WHERE name = ‘Bob’;
UPDATE branches SET balance = balance + 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Bob’);
Точное содержание команд здесь не важно, важно лишь то, что для выполнения этой довольно
простой операции потребовалось несколько отдельных действий. При этом с точки зрения банка
необходимо, чтобы все эти действия выполнились вместе, либо не выполнились совсем. Если Боб
получит 100 долларов, но они не будут списаны со счёта Алисы, объяснить это сбоем системы
определённо не удастся. И наоборот, Алиса вряд ли будет довольна, если она переведёт деньги,
а до Боба они не дойдут. Нам нужна гарантия, что если что-то помешает выполнить операцию
до конца, ни одно из действий не оставит следа в базе данных. И мы получаем эту гарантию, объ-
единяя действия в одну транзакцию. Говорят, что транзакция атомарна: с точки зрения других
транзакций она либо выполняется и фиксируется полностью, либо не фиксируется совсем.
Нам также нужна гарантия, что после завершения и подтверждения транзакции системой баз дан-
ных, её результаты в самом деле сохраняются и не будут потеряны, даже если вскоре произойдёт
авария. Например, если мы списали сумму и выдали её Бобу, мы должны исключить возможность
того, что сумма на его счёте восстановится, как только он выйдет за двери банка. Транзакционная
база данных гарантирует, что все изменения записываются в постоянное хранилище (например,
на диск) до того, как транзакция будет считаться завершённой.
Другая важная характеристика транзакционных баз данных тесно связана с атомарностью изме-
нений: когда одновременно выполняется множество транзакций, каждая из них не видит незавер-
шённые изменения, произведённые другими. Например, если одна транзакция подсчитывает ба-
ланс по отделениям, будет неправильно, если она посчитает расход в отделении Алисы, но не учтёт
приход в отделении Боба, или наоборот. Поэтому свойство транзакций “всё или ничего” должно
определять не только, как изменения сохраняются в базе данных, но и как они видны в процессе
работы. Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока
она не будет завершена, а затем они становятся видны все сразу.
15Расширенные возможности
В PostgreSQL транзакция определяется набором SQL-команд, окружённым командами BEGIN и
COMMIT. Таким образом, наша банковская транзакция должна была бы выглядеть так:
BEGIN;
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
– …
COMMIT;
Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения (на-
пример, потому что оказалось, что баланс Алисы стал отрицательным), мы можем выполнить ко-
манду ROLLBACK вместо COMMIT, и все наши изменения будут отменены.
PostgreSQL на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не встави-
те команду BEGIN, то каждый отдельный оператор будет неявно окружён командами BEGIN и COMMIT
(в случае успешного завершения). Группу операторов, окружённых командами BEGIN и COMMIT ино-
гда называют блоком транзакции.
Примечание
Некоторые клиентские библиотеки добавляют команды BEGIN и COMMIT автоматически
и неявно создают за вас блоки транзакций. Подробнее об этом вы можете узнать в
документации интересующего вас интерфейса.
Операторами в транзакции можно также управлять на более детальном уровне, используя точ-
ки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и
фиксировать все остальные. Определив точку сохранения с помощью SAVEPOINT, при необходимо-
сти вы можете вернуться к ней с помощью команды ROLLBACK TO. Все изменения в базе данных,
произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произ-
ведённые ранее, сохраняются.
Когда вы возвращаетесь к точке сохранения, она продолжает существовать, так что вы можете от-
катываться к ней несколько раз. С другой стороны, если вы уверены, что вам не придётся откаты-
ваться к определённой точке сохранения, её можно удалить, чтобы система высвободила ресурсы.
Помните, что при удалении или откате к точке сохранения все точки сохранения, определённые
после неё, автоматически уничтожаются.
Всё это происходит в блоке транзакции, так что в других сеансах работы с базой данных этого не
видно. Совершённые действия становятся видны для других сеансов все сразу, только когда вы
фиксируете транзакцию, а отменённые действия не видны вообще никогда.
Вернувшись к банковской базе данных, предположим, что мы списываем 100 долларов со счёта
Алисы, добавляем их на счёт Боба, и вдруг оказывается, что деньги нужно было перевести Уолли.
В данном случае мы можем применить точки сохранения:
BEGIN;
UPDATE accounts SET balance = balance
WHERE name = ‘Alice’;
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Bob’;
– ошибочное действие… забыть его и
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Wally’;
COMMIT;</p>
<ul>
  <li>100.00</li>
  <li>100.00
использовать счёт Уолли</li>
  <li>100.00
Этот пример, конечно, несколько надуман, но он показывает, как можно управлять выполнением
команд в блоке транзакций, используя точки сохранения. Более того, ROLLBACK TO — это един-
16Расширенные возможности
ственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии
из-за ошибки системы, не считая возможности полностью отменить её и начать снова.
3.5. Оконные функции
Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с теку-
щей строкой. Её действие можно сравнить с вычислением, производимым агрегатной функцией.
Однако с оконными функциями строки не группируются в одну выходную строку, что имеет место
с обычными, не оконными, агрегатными функциями. Вместо этого, эти строки остаются отдельны-
ми сущностями. Внутри же, оконная функция, как и агрегатная, может обращаться не только к
текущей строке результата запроса.
Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его
отдела:
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
FROM empsalary;
depname | empno | salary |
avg
———–+——-+——–+———————–
develop
|
11 |
5200 | 5020.0000000000000000
develop
|
7 |
4200 | 5020.0000000000000000
develop
|
9 |
4500 | 5020.0000000000000000
develop
|
8 |
6000 | 5020.0000000000000000
develop
|
10 |
5200 | 5020.0000000000000000
personnel |
5 |
3500 | 3700.0000000000000000
personnel |
2 |
3900 | 3700.0000000000000000
sales
|
3 |
4800 | 4866.6666666666666667
sales
|
1 |
5000 | 4866.6666666666666667
sales
|
4 |
4800 | 4866.6666666666666667
(10 rows)
Первые три столбца извлекаются непосредственно из таблицы empsalary, при этом для каждой
строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычис-
ленное по всем строкам, имеющим то же значение depname, что и текущая строка. (Фактически
среднее вычисляет та же обычная, не оконная функция avg, но предложение OVER превращает её
в оконную, так что её действие ограничивается рамками окон.)
Вызов оконной функции всегда содержит предложение OVER, следующее за названием и аргумен-
тами оконной функции. Это синтаксически отличает её от обычной, не оконной агрегатной функ-
ции. Предложение OVER определяет, как именно нужно разделить строки запроса для обработки
оконной функцией. Предложение PARTITION BY, дополняющее OVER, разделяет строки по группам,
или разделам, объединяя одинаковые значения выражений PARTITION BY. Оконная функция вы-
числяется по строкам, попадающим в один раздел с текущей строкой.
Вы можете также определять порядок, в котором строки будут обрабатываться оконными функци-
ями, используя ORDER BY в OVER. (Порядок ORDER BY для окна может даже не совпадать с порядком,
в котором выводятся строки.) Например:
SELECT depname, empno, salary,
rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
depname | empno | salary | rank
———–+——-+——–+——
develop
|
8 |
6000 |
1
develop
|
10 |
5200 |
2
develop
|
11 |
5200 |
2
develop
|
9 |
4500 |
4
develop
|
7 |
4200 |
5
17Расширенные возможности
personnel
personnel
sales
sales
sales
(10 rows)
|
|
|
|
|
2
5
1
4
3
|
|
|
|
|
3900
3500
5000
4800
4800
|
|
|
|
|
1
2
1
2
2
Как показано здесь, функция rank выдаёт порядковый номер для каждого уникального значения
в разделе текущей строки, по которому выполняет сортировку предложение ORDER BY. У функции
rank нет параметров, так как её поведение полностью определяется предложением OVER.
Строки, обрабатываемые оконной функцией, представляют собой «виртуальные таблицы», создан-
ные из предложения FROM и затем прошедшие через фильтрацию и группировку WHERE и GROUP BY
и, возможно, условие HAVING. Например, строка, отфильтрованная из-за нарушения условия WHERE,
не будет видна для оконных функций. Запрос может содержать несколько оконных функций, раз-
деляющих данные по-разному с применением разных предложений OVER, но все они будут обраба-
тывать один и тот же набор строк этой виртуальной таблицы.
Мы уже видели, что ORDER BY можно опустить, если порядок строк не важен. Также возможно
опустить PARTITION BY, в этом случае образуется один раздел, содержащий все строки.
Есть ещё одно важное понятие, связанное с оконными функциями: для каждой строки существует
набор строк в её разделе, называемый рамкой окна. Некоторые оконные функции обрабатывают
только строки рамки окна, а не всего раздела. По умолчанию с указанием ORDER BY рамка состоит
из всех строк от начала раздела до текущей строки и строк, равных текущей по значению выра-
1
жения ORDER BY. Без ORDER BY рамка по умолчанию состоит из всех строк раздела. Посмотрите
на пример использования sum:
SELECT salary, sum(salary) OVER () FROM empsalary;
salary | sum
——–+——-
5200 | 47100
5000 | 47100
3500 | 47100
4800 | 47100
3900 | 47100
4200 | 47100
4500 | 47100
4800 | 47100
6000 | 47100
5200 | 47100
(10 rows)
Так как в этом примере нет указания ORDER BY в предложении OVER, рамка окна содержит все
строки раздела, а он, в свою очередь, без предложения PARTITION BY включает все строки таблицы;
другими словами, сумма вычисляется по всей таблице и мы получаем один результат для каждой
строки результата. Но если мы добавим ORDER BY, мы получим совсем другие результаты:
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
salary | sum
——–+——-
3500 | 3500
3900 | 7400
4200 | 11600
4500 | 16100
4800 | 25700
1
Рамки окна можно определять и другими способами, но в этом введении они не рассматриваются. Узнать о них подробнее вы можете в Подразделе 4.2.8.
18Расширенные возможности
4800 |
5000 |
5200 |
5200 |
6000 |
(10 rows)
25700
30700
41100
41100
47100
Здесь в сумме накапливаются зарплаты от первой (самой низкой) до текущей, включая повторяю-
щиеся текущие значения (обратите внимание на результат в строках с одинаковой зарплатой).
Оконные функции разрешается использовать в запросе только в списке SELECT и предложении
ORDER BY. Во всех остальных предложениях, включая GROUP BY, HAVING и WHERE, они запрещены.
Это объясняется тем, что логически они выполняются после этих предложений, а также после
не оконных агрегатных функций, и значит агрегатную функцию можно вызывать в аргументах
оконной, но не наоборот.
Если вам нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы
можете использовать вложенный запрос. Например:
SELECT depname, empno, salary, enroll_date
FROM
(SELECT depname, empno, salary, enroll_date,
rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
FROM empsalary
) AS ss
WHERE pos &lt; 3;
Данный запрос покажет только те строки внутреннего запроса, у которых rank (порядковый номер)
меньше 3.
Когда в запросе вычисляются несколько оконных функций для одинаково определённых окон, ко-
нечно можно написать для каждой из них отдельное предложение OVER, но при этом оно будет
дублироваться, что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна
выделить в предложение WINDOW, а затем ссылаться на него в OVER. Например:
SELECT sum(salary) OVER w, avg(salary) OVER w
FROM empsalary
WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
Подробнее об оконных функциях можно узнать в Подразделе 4.2.8, Разделе 9.21, Подразделе 7.2.5
и в справке SELECT.
3.6. Наследование
Наследование — это концепция, взятая из объектно-ориентированных баз данных. Она открывает
множество интересных возможностей при проектировании баз данных.
Давайте создадим две таблицы: cities (города) и capitals (столицы штатов). Естественно, столи-
цы штатов также являются городами, поэтому нам нужно явным образом добавлять их в резуль-
тат, когда мы хотим просмотреть все города. Если вы проявите смекалку, вы можете предложить,
например, такое решение:
CREATE TABLE
name
population
altitude
state
);
capitals (
text,
real,
int,
– (высота в футах)
char(2)
CREATE TABLE non_capitals (
name
text,
19Расширенные возможности
population real,
altitude
int
– (высота в футах)
);
CREATE VIEW cities AS
SELECT name, population, altitude FROM capitals
UNION
SELECT name, population, altitude FROM non_capitals;
Оно может устраивать, пока мы извлекаем данные, но если нам потребуется изменить несколько
строк, это будет выглядеть некрасиво.
Поэтому есть лучшее решение:
CREATE TABLE
name
population
altitude
);
cities (
text,
real,
int
– (высота в футах)
CREATE TABLE capitals (
state
char(2)
) INHERITS (cities);
В данном случае строка таблицы capitals наследует все столбцы (name, population и altitude)
от родительской таблицы cities. Столбец name имеет тип text, собственный тип PostgreSQL для
текстовых строк переменной длины. А в таблицу столиц добавлен дополнительный столбец state,
в котором будет указан штат. В PostgreSQL таблица может наследоваться от нуля или нескольких
других таблиц.
Например, следующий запрос выведет названия всех городов, включая столицы, находящихся вы-
ше 500 футов над уровнем моря:
SELECT name, altitude
FROM cities
WHERE altitude &gt; 500;
Результат его выполнения:
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Madison
|
845
(3 rows)
А следующий запрос находит все города, которые не являются столицами штатов, но также нахо-
дятся выше 500 футов:
SELECT name, altitude
FROM ONLY cities
WHERE altitude &gt; 500;
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
(2 rows)
Здесь слово ONLY перед названием таблицы cities указывает, что запрос следует выполнять только
для строк таблицы cities, не включая таблицы, унаследованные от cities. Многие операторы,
которые мы уже обсудили — SELECT, UPDATE и DELETE — поддерживают указание ONLY.
20Расширенные возможности
Примечание
Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уни-
кальности и внешними ключами, что ограничивает его применимость. Подробнее это
описывается в Разделе 5.9.
3.7. Заключение
PostgreSQL имеет множество возможностей, не затронутых в этом кратком введении, рассчитан-
ном на начинающих пользователей SQL. Эти возможности будут рассмотрены в деталях в продол-
жении книги.
Если вам необходима дополнительная вводная информация, посетите сайт PostgreSQL, там вы
найдёте ссылки на другие ресурсы.
21</li>
</ul>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-003/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-003/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-003/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-002/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
