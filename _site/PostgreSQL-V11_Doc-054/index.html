<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 54. Соглашения по оформлению кода PostgreSQL &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 54. Соглашения по оформлению кода PostgreSQL">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 54. Соглашения по оформлению кода PostgreSQL">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-054/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-054/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 54. Соглашения по оформлению кода PostgreSQL">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-054/" rel="bookmark" title="Глава 54. Соглашения по оформлению кода PostgreSQL">Глава 54. Соглашения по оформлению кода PostgreSQL</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~18 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 54. Соглашения по оформлению кода PostgreSQL</p>

<p>54.1. Форматирование</p>

<p>Исходный код форматируется с отступом на 4 позиции, с сохранением табуляции (т. е. символы
табуляции не разворачиваются в пробелы). Для каждого логического уровня отступа добавляется
одна табуляция.
Правила оформления (расположения скобок и т. д.) следуют соглашениям BSD. В частности, фи-
гурные скобки для управляемых ими блоков if, while, switch и т. д. размещаются в отдельных
строках.
Ограничьте размеры строк, чтобы код можно было читать в окне шириной 80 символов. (Это не
значит, что никогда нельзя заходить за 80 символов. Например, не стоит разбивать длинную стро-
ку сообщения в произвольных местах, просто чтобы код умещался в 80 символов, так как это в
результате скорее всего не сделает код более читабельным.)
Не используйте комментарии в стиле C++ (комментарии //). Строгие компиляторы ANSI C их
не принимают. По этой же причине не используйте расширения C++, например, не объявляйте
новые переменные в середине блока.
Предпочитаемый стиль многострочных блоков выглядит так:
/*</p>
<ul>
  <li>текст комментария начинается здесь</li>
  <li>и продолжается здесь
<em>/
Заметьте, что блоки комментариев, начинающиеся с первого символа, будут сохраняться утилитой
pgindent как есть, но содержимое блоков комментариев с отступами будет переразбито по строкам
как обычный текст. Если вы хотите сохранить разрывы строк в блоке с отступом, добавьте минусы
следующим образом:
/</em>———-</li>
  <li>текст комментария начинается здесь</li>
  <li>и продолжается здесь
<em>———-
*/
Хотя предлагаемые правки кода не обязательно должны следовать этим правилам форматирова-
ния, лучше их придерживаться. Ваш код будет пропущен через pgindent перед следующим выпус-
ком, поэтому нет смысла наводить в нём красоту по другим правилам. Для правок есть хорошее
правило: «оформляйте новый код так же, как выглядит существующий код вокруг».
В каталоге src/tools содержатся примеры файлов настройки, которые можно использовать с ре-
дакторами emacs, xemacs или vim для упрощения задачи форматирования кода в соответствии с
описанными соглашениями.
Чтобы табуляция показывалась должным образом в средствах просмотра текста more и less, их
можно вызвать так:
more -x4
less -x4
54.2. Вывод сообщений об ошибках в коде сервера
Сообщения об ошибках, предупреждения и обычные сообщения, выдаваемые в коде сервера долж-
ны создаваться функцией ereport или родственной её предшественницей elog. Использование
этой функции достаточно сложно и требует дополнительного объяснения.
2070Соглашения по оформ-
лению кода PostgreSQL
У каждого сообщения есть два обязательных элемента: уровень важности (от DEBUG до PANIC) и
основной текст сообщения. В дополнение к ним есть необязательные элементы, из которых часто
используется код идентификатора ошибки, соответствующий определению SQLSTATE в специфи-
кации SQL. Функция ereport сама по себе является просто оболочкой, которая существует в ос-
новном для синтаксического удобства, чтобы выдача сообщения выглядела как вызов функции в
коде C. Единственный параметр, который принимает непосредственно функция ereport, это уро-
вень важности. Основной текст и любые дополнительные элементы сообщения генерируются в
результате вызова вспомогательных функций, таких как errmsg, в вызове ereport.
Типичный вызов ereport выглядит примерно так:
ereport(ERROR,
(errcode(ERRCODE_DIVISION_BY_ZERO),
errmsg(“division by zero”)));
В нём задаётся уровень важности ERROR (заурядная ошибка). В вызове errcode указывается код
ошибки SQLSTATE по макросу, определённому в src/include/utils/errcodes.h. Вызов errmsg да-
ёт текст основного сообщения. Обратите внимание на дополнительный набор скобок, окружающих
вызовы вспомогательных функций — они загромождают код, но требуются синтаксисом.
Более сложный пример:
ereport(ERROR,
(errcode(ERRCODE_AMBIGUOUS_FUNCTION),
errmsg(“function %s is not unique”,
func_signature_string(funcname, nargs,
NIL, actual_arg_types)),
errhint(“Unable to choose a best candidate function. “
“You might need to add explicit typecasts.”)));
В нём демонстрируется использование кодов форматирования для включения значений времени
выполнения в текст сообщения. Также в нём добавляется дополнительное сообщение «подсказки».
При уровне важности ERROR или более высоком, ereport прерывает выполнение пользовательской
функции и не возвращает управление в вызывающий код. Если уровень важности ниже ERROR,
ereport завершается обычным способом.
Для ereport предлагаются следующие вспомогательные функции:
• errcode(sqlerrcode) задаёт код идентификатора ошибки SQLSTATE для дан-
ной ошибки. Если эта функция не вызывается, подразумевается идентифика-
тор ошибки ERRCODE_INTERNAL_ERROR при уровне важности ERROR или выше, либо
ERRCODE_WARNING при уровне важности WARNING, иначе (при уровне NOTICE или ниже) —
ERRCODE_SUCCESSFUL_COMPLETION. Хотя эти значения по умолчанию довольно разумны, всегда
стоит подумать, насколько они уместны, прежде чем опустить вызов errcode().
• errmsg(const char *msg, …) задаёт основной текст сообщения об ошибке и, возможно, зна-
чения времени выполнения, которые будут в него включаться. Эти включения записываются
кодами формата в стиле sprintf. В дополнение к стандартным кодам формата, принимаемым
функцией sprintf, можно использовать код формата %m, который вставит сообщение об ошиб-
1
ке, возвращённое строкой strerror для текущего значения errno. Для %m не требуется соот-
ветствующая запись в списке параметров errmsg. Заметьте, что эта строка будет пропущена
через gettext, то есть может быть локализована, до обработки кодов формата.
• errmsg_internal(const char *msg, …) действует как errmsg, но её строка сообщения не бу-
дет переводиться и включаться в словарь сообщений для интернационализации. Это следует
использовать для случаев, которые «не происходят никогда», так что тратить силы на их пере-
вод не стоит.
• errmsg_plural(const char *fmt_singular, const char *fmt_plural, unsigned long
n, …) действует подобно errmsg, но поддерживает различные формы сообщения с множе-
1
То есть значение, которое было текущим, когда была вызвана ereport; изменения errno во вспомогательных функциях выдачи сообщений на него не
повлияют. Это будет не так, если вы запишете strerror(errno) явно в списке параметров errmsg; поэтому делать так не нужно.
2071Соглашения по оформ-
лению кода PostgreSQL
ственными числами. Параметр fmt_singular задаёт строку формата на английском для един-
ственного числа, fmt_plural — формат для множественного числа, n задаёт целое число,
определяющее, какая именно форма множественного числа требуется, а остальные аргумен-
ты форматируются согласно выбранной строке формата. За дополнительными сведениями об-
ратитесь к Подразделу 55.2.2.
• errdetail(const char *msg, …) задаёт дополнительное «подробное» сообщение; оно долж-
но использоваться, когда есть дополнительная информация, которую неуместно включать в
основное сообщение. Строка сообщения обрабатывается так же, как и для errmsg.
• errdetail_internal(const char *msg, …) действует как errdetail, но её строка сообще-
ния не будет переводиться и включаться в словарь сообщений для интернационализации. Это
следует использовать для подробных сообщений, на перевод которых не стоит тратить силы,
например, когда это техническая информация, непонятная большинству пользователей.
• errdetail_plural(const char *fmt_singular, const char *fmt_plural, unsigned long
n, …) действует подобно errdetail, но поддерживает различные формы сообщения с мно-
жественными числами. За дополнительными сведениями обратитесь к Подразделу 55.2.2.
• errdetail_log(const char *msg, …) подобна errdetail, но выводимая строка попадает
только в журнал сервера, и никогда не передаётся клиенту. Если используется и errdetail
(или один из её эквивалентов), и errdetail_log, тогда одна строка передаётся клиенту, а дру-
гая отправляется в журнал. Это полезно для вывода подробных сообщений, имеющих конфи-
денциальный характер или большой размер, так что передавать их клиенту нежелательно.
• errdetail_log_plural(const char *fmt_singular, const char *fmt_plural, unsigned long
n, …) действует подобно errdetail_log, но поддерживает различные формы сообщения с
множественными числами. За дополнительными сведениями обратитесь к Подразделу 55.2.2.
• errhint(const char *msg, …) передаёт дополнительное сообщение «подсказки»; это поз-
воляет предложить решение проблемы, а не просто сообщить факты, связанные с ней. Строка
сообщения обрабатывается так же, как и для errmsg.
• errcontext(const char *msg, …) обычно не вызывается непосредственно с места вызова
ereport, а используется в функциях обратного вызова error_context_stack и выдаёт инфор-
мацию о контексте, в котором произошла ошибка, например, о текущем положении в функции
PL. Строка сообщения обрабатывается так же, как и для errmsg. В отличие от других вспомо-
гательных функций, внутри вызова ereport её можно вызывать неоднократно; добавляемые
таким образом последовательные сообщения складываются через символы перевода строк.
• errposition(int cursorpos) задаёт положение ошибки в тексте запроса. В настоящее время
это полезно только для ошибок, выявляемых на этапах лексического и синтаксического ана-
лиза запроса.
• errtable(Relation rel) определяет отношение, имя и схема которого должны быть включе-
ны во вспомогательные поля сообщения об ошибке.
• errtablecol(Relation rel, int attnum) определяет столбец, имя которого, вместе с именем
таблицы и схемы, должно быть включено во вспомогательные поля сообщения об ошибке.
• errtableconstraint(Relation rel, const char *conname) задаёт имя ограничения таблицы,
которое вместе с именем таблицы и схемы должно быть включено во вспомогательные поля
сообщения об ошибке. В данном контексте индекс считается ограничением, независимо от то-
го, имеется ли для него запись в pg_constraint. Заметьте, что при этом в качестве rel нужно
передавать нижележащее отношение, а не сам индекс.
• errdatatype(Oid datatypeOid) задаёт тип данных, имя которого, вместе с именем схемы,
должно включаться во вспомогательные поля сообщения об ошибке.
• errdomainconstraint(Oid datatypeOid, const char *conname) задаёт имя ограничения доме-
на, которое вместе с именем домена и схемы должно включаться во вспомогательные поля со-
общения об ошибке.
• errcode_for_file_access() — вспомогательная функция, выбирающая подходящий иденти-
фикатор SQLSTATE при сбое в системном вызове, в котором происходит обращение к фай-
2072Соглашения по оформ-
лению кода PostgreSQL
ловой системе. Какой код ошибки генерировать, она определяет по сохранённому значению
errno. Обычно это используется в сочетании с %m в основном сообщении об ошибке.
• errcode_for_socket_access() — вспомогательная функция, выбирающая подходящий иденти-
фикатор SQLSTATE при сбое в системном вызове, в котором происходит обращение к сокетам.
• errhidestmt(bool hide_stmt) может быть вызвана для подавления вывода поля ОПЕРАТОР:
(STATEMENT:) в журнал сервера. Обычно это уместно, когда само сообщение включает текст
текущего оператора.
• errhidecontext(bool hide_ctx) может быть вызвана для подавления вывода поля КОНТЕКСТ:
(CONTEXT:) в журнал сервера. Это следует использовать только для подробных отладочных со-
общений, в которых одна и та же информация о контексте, выводимая в журнал, будет только
чрезмерно замусоривать его.
Примечание
В вызове ereport следует использовать максимум одну из функций errtable,
errtablecol, errtableconstraint, errdatatype или errdomainconstraint. Данные
функции существуют для того, чтобы приложения могли извлечь имя объекта базы
данных, связанного с условием ошибки, так, чтобы для этого им не требовалось раз-
бирать текст ошибки, возможно локализованный. Эти функции должны использовать-
ся в случае ошибок, для которых может быть желательной автоматическая обработка.
Для версии PostgreSQL 9.3 этот подход распространяется полностью только на ошибки
класса SQLSTATE 23 (нарушение целостности ограничения), но в будущем область его
применения может быть расширена.
Существует также более старая, но тем не менее активно используемая функция elog. Вызов elog:
elog(level, “format string”, …);
полностью равнозначен вызову:
ereport(level, (errmsg_internal(“format string”, …)));
Заметьте, что код ошибки SQLSTATE всегда определяется неявно, а строка сообщения не подлежит
переводу. Таким образом, elog следует использовать только для внутренних ошибок и отладки на
низком уровне. Любое сообщение, которое может представлять интерес для обычных пользовате-
лей, должно проходить через ereport. Тем не менее, в системе есть достаточно много внутренних
проверок для случаев, «которые не должны происходить», и в них по-прежнему широко использу-
ется elog; для таких сообщений эта функция предпочитается из-за простоты записи.
Советы по написанию хороших сообщений об ошибках можно найти в Разделе 54.3.
54.3. Руководство по стилю сообщений об ошибках
Это руководство по стилю предлагается в надежде обеспечить единообразный и понятный поль-
зователю стиль для всех сообщений, которые выдаёт PostgreSQL.
54.3.1. Что и куда выводить
Основное сообщение должно быть кратким, фактологическим и, по возможности, не говорить о
тонкостях реализации, например, не упоминать конкретные имена функций. Под «кратким» по-
нимается «должно умещаться в одной строке при обычных условиях». Дополнительное подробное
сообщение добавляется, когда краткого сообщения недостаточно, или вы считаете, что нужно упо-
мянуть какие-то внутренние детали, например, конкретный системный вызов, в котором произо-
шла ошибка. И основное, и подробное сообщения должны сообщать исключительно факты. Чтобы
предложить решение проблемы, особенно, если это решение может быть применимо не всегда,
передайте его в сообщении-подсказке.
Например, вместо:
IpcMemoryCreate: ошибка в shmget(ключ=%d, размер=%u, 0%o): %m
2073Соглашения по оформ-
лению кода PostgreSQL
(плюс длинное дополнение, по сути представляющее собой подсказку)
следует записать:
Основное:
Подробное:
Подсказка:
не удалось создать сегмент разделяемой памяти: %m
Ошибка в системном вызове shmget(key=%d, size=%u, 0%o).
дополнительный текст
Объяснение: когда основное сообщение достаточно краткое, клиенты могут выделить для него ме-
сто на экране в предположении, что одной строки будет достаточно. Подробное сообщение и под-
сказка могут выводиться в режиме дополнительных сведений или, возможно, в разворачивающем-
ся окне «ошибка-подробности». Кроме того, подробности и подсказки обычно не записываются в
журнал сервера для сокращения его объёма. Детали реализации лучше опускать, так как пользо-
ватели не должны в них разбираться.
54.3.2. Форматирование
Не полагайтесь на какое-либо определённое форматирование в тексте сообщений. Следует ожи-
дать, что в клиентском интерфейсе и в журнале сервера длинные строки будут переноситься в
зависимости от ситуации. В длинных сообщениях можно обозначить предполагаемые места раз-
рыва абзацев символами новой строки (\n). Завершать сообщение этим символом не нужно. Также
не используйте табуляции или другие символы форматирования. (При выводе контекста ошибок
автоматически добавляются символы перевода строки для разделения уровней контекста, напри-
мер, вызовов функций.)
Объяснение: сообщение не обязательно будет выводиться в интерфейсе терминального типа. В
графических интерфейсах или браузерах эти инструкции форматирования в лучшем случае игно-
рируются.
54.3.3. Символы кавычек
В тексте на английском языке везде, где это уместно, следует использовать двойные кавычки. В
тексте на других языках следует единообразно использовать тот тип кавычек, который принят для
печати вывода других программ.
Объяснение: выбор двойных кавычек вместо апострофов несколько своевольный, но ему сейчас от-
даётся предпочтение. Некоторые разработчики предлагали выбирать тип кавычек в зависимости
от типа объекта, следуя соглашениям SQL (а именно, строки заключать в апострофы, а идентифи-
каторы в кавычки). Но это внутренняя техническая особенность языка, о которой многие пользо-
ватели даже не догадываются; кроме того, это нельзя распространить на другие типы сущностей
в кавычках, не всегда можно перевести на другие языки и к тому же довольно бессмысленно.
54.3.4. Использование кавычек
Всегда используйте кавычки для заключения имён файлов, задаваемых пользователем идентифи-
каторов и других переменных, которые могут содержать слова. Не заключайте в кавычки пере-
менные, которые никогда не будут содержать слова (например, имена операторов).
В коде сервера есть функции, которые при необходимости сами заключают выводимый результат в
кавычки (например, format_type_be()). Дополнительные кавычки вокруг результата таких функ-
ций добавлять не следует.
Объяснение: у объектов могут быть имена, создающие двусмысленность, когда они появляются в
сообщении. Всегда одинаково обозначайте, где начинается и где заканчивается встроенное имя.
Но не загромождайте сообщения ненужными или повторными знаками кавычек.
54.3.5. Грамматика и пунктуация
Правила для основного сообщения и дополнительного сообщения/подсказки различаются:
Основное сообщение об ошибке: не делайте первую букву заглавной. Не завершайте сообщение
точкой. Даже не думайте о том, чтобы завершить сообщение восклицательным знаком!
2074Соглашения по оформ-
лению кода PostgreSQL
Подробное сообщение и подсказка: пишите полные предложения и завершайте каждое точкой.
Начинайте первое слово предложения с большой буквы. Добавляйте два пробела после точки, если
за одним предложением следует другое (для английского текста; может не подходить для других
языков).
Строка с контекстом ошибки: не делайте первую букву заглавной и не завершайте строку точкой.
Строки контекста обычно не должны быть полными предложениями.
Объяснение: при отсутствии знаков пунктуации клиентским приложениям проще вставить сооб-
щение в самые разные грамматические контексты. Часто основные сообщения всё равно не явля-
ются грамматически полными предложениями. (Если сообщение настолько длинное, что занима-
ет не одно предложение, его следует поделить на основную и дополнительную часть.) Однако по-
дробные сообщения и подсказки по определению длиннее и могут содержать несколько предло-
жений. Единообразия ради, они должны следовать стилю полного предложения, даже если пред-
ложение всего одно.
54.3.6. Верхний регистр или нижний регистр
Пишите сообщение в нижнем регистре, включая первую букву основного сообщения об ошибке.
Используйте верхний регистр для команд SQL и ключевых слов, если они выводятся в сообщении.
Объяснение: так проще сделать, чтобы всё выглядело единообразно, так как некоторые сообщения
могут быть полными предложениями, а другие нет.
54.3.7. Избегайте пассивного залога
Используйте активный залог. Когда есть действующий субъект, формулируйте полные предложе-
ния («A не удалось сделать B»). Используйте телеграфный стиль без субъекта, если субъект — сама
программа; не пишите «я» от имени программы.
Объяснение: программа — не человек. Не создавайте впечатление, что это не так.
54.3.8. Настоящее или прошедшее время
Используйте прошедшее время, если попытка сделать что-то не удалась, но может быть успеш-
ной в следующий раз (возможно, после устранения некоторой проблемы). Используйте настоящее
время, если ошибка, определённо, постоянная.
Есть нетривиальное смысловое различие между предложениями вида:
не удалось открыть файл “%s”: %m
и:
нельзя открыть файл “%s”
Первое означает, что попытка открыть файл не удалась. Сообщение должно сообщать причину,
например, «переполнение диска» или «файл не существует». Прошедшее время уместно, потому
что в следующий раз диск может быть не переполнен или запрошенный файл будет найден.
Вторая форма показывает, что функциональность открытия файла с заданным именем полностью
отсутствует в программе, либо это невозможно в принципе. Настоящее время в этом случае умест-
но, так как это условие будет сохраняться неопределённое время.
Объяснение: конечно, средний пользователь не сможет сделать глубокие выводы, проанализиро-
вав синтаксическое время, но если язык даёт нам возможность такого выражения, мы должны
использовать это корректно.
54.3.9. Тип объекта
Цитируя имя объекта, указывайте также его тип.
Объяснение: иначе никто не поймёт, к чему относится «foo.bar.baz».
2075Соглашения по оформ-
лению кода PostgreSQL
54.3.10. Скобки
Квадратные скобки должны использоваться только (1) в описаниях команд и обозначать необяза-
тельные аргументы, либо (2) для обозначения индекса массива.
Объяснение: все другие варианты их использования не являются общепринятыми и будут вводить
в заблуждение.
54.3.11. Сборка сообщений об ошибках
Когда сообщение включает текст, сгенерированный в другом месте, внедряйте его следующим
образом:
не удалось открыть файл %s: %m
Объяснение: довольно сложно учесть все возможные варианты ошибок, которые будут вставляться
в предложение, чтобы оно при этом оставалось складным, поэтому требуется какая-то пунктуация.
Было предложение заключать включаемый текст в скобки, но это не вполне естественно, если этот
текст содержит наиболее важную часть сообщения, что часто имеет место.
54.3.12. Причины ошибок
Сообщения должны всегда сообщать о причине произошедшей ошибки. Например:
ПЛОХО:
ЛУЧШЕ:
не удалось открыть файл %s
не удалось открыть файл %s (ошибка ввода/вывода)
Если причина неизвестна, лучше исправить код.
54.3.13. Имена функций
Не включайте в текст ошибки имя функции, в которой возникла ошибка. У нас есть другие меха-
низмы, позволяющие узнать его, когда требуется, а для большинства пользователей это бесполез-
ная информация. Если текст ошибки оказывается бессвязным без имени функции, перефразируй-
те его.
ПЛОХО:
ЛУЧШЕ:
pg_atoi: ошибка в “z”: не удалось разобрать “z”
неверное значение для целого числа: “z”
Избегайте упоминания имён вызываемых функций; вместо этого скажите, что пытается делать
код:
ПЛОХО:
ЛУЧШЕ:
ошибка в open(): %m
не удалось открыть файл %s: %m
Если это действительно кажется необходимым, упомяните системный вызов в подробном сообще-
нии. (В некоторых случаях в подробном сообщении стоит показать фактические значения, пере-
даваемые системному вызову.)
Объяснение: пользователи не знают, что делают все эти функции.
54.3.14. Скользкие слова, которых следует избегать
Unable (Неспособен).  «Unable» — это почти пассивный залог. Лучше использовать «cannot»
(нельзя) или «could not» (не удалось), в зависимости от ситуации.
Bad (Плохое).  Сообщения об ошибках типа «bad result» (плохой результат) трудно воспринять
осмысленно. Лучше написать, почему результат «плохой», например, «invalid format» (неверный
формат).
Illegal (Нелегальное).  «Illegal» (нелегально) — то, что нарушает закон, всё остальное можно
называть «invalid» (неверным). Опять же лучше сказать, почему что-то неверное.
Unknown (Неизвестное).  Постарайтесь исключить «unknown» (неизвестное). Взгляните на со-
общение: «error: unknown response» (ошибка: неизвестный ответ). Если вы не знаете, что за ответ
2076Соглашения по оформ-
лению кода PostgreSQL
получен, как вы поняли, что он ошибочный? Вместо этого часто лучше сказать «unrecognized»
(нераспознанный). Также обязательно добавьте значение, которое не было воспринято.
ПЛОХО:
ЛУЧШЕ:
неизвестный тип узла
нераспознанный тип узла: 42
«Не найдено» или «не существует».  Если программа выполняет поиск ресурса, используя
нетривиальный алгоритм (например, поиск по пути), и этот алгоритм не срабатывает, лучше чест-
но сказать, что программа не смогла «найти» ресурс. С другой стороны, если ожидаемое располо-
жение ресурса точно известно, но программа не может обратиться к нему, скажите, что этот ре-
сурс не «существует». Формулировка с глаголом «найти» в данном случае звучит слабо и затруд-
няет понимание.
Разрешено, могу или возможно.  «May» (разрешено) подразумевает разрешение (например,
«Вам разрешено воспользоваться моими граблями.») и этому практически нет применения в доку-
ментации или сообщениях об ошибках. «Can» (могу) подразумевает способность (например, «Я мо-
гу поднять это бревно.»), а «might» (возможно) подразумевает возможность (например, «Сегодня
возможен дождь.»). Использование подходящего слова проясняет значение и облегчает перевод.
Сокращения.
Избегайте сокращений, например «can’t»; вместо это напишите «cannot».
54.3.15. Правильное написание
Пишите слова полностью. Например, избегайте (в английском):
• spec
• stats
• parens
• auth
• xact
Объяснение: так сообщения будут единообразными.
54.3.16. Локализация
Помните, что текст сообщений должен переводиться на другие языки. Следуйте советам, приве-
дённым в Подразделе 55.2.2, чтобы излишне не усложнять жизнь переводчикам.
54.4. Различные соглашения по оформлению кода
54.4.1. Стандарт C
Код в PostgreSQL должен использовать только те возможности языка, что описаны в стандарте
C89. Это означает, что код postgres должен успешно компилироваться компилятором, поддержи-
вающим C89, возможно, за исключением нескольких платформозависимых мест. Возможности бо-
лее поздних ревизий стандарта C или специфические особенности компилятора могут использо-
ваться, только если предусмотрен и вариант компиляции без них.
Например, в настоящее время используются конструкции static inline и _StaticAssert(), хотя
они относятся к более новым ревизиям стандарта C. Но если они недоступны, мы соответственно
переходим к определению функций без inline, и к использованию альтернативы, которая совме-
стима с C89 и выполняет те же проверки, но выдаёт довольно непонятные сообщения.
54.4.2. Внедрённые функции и макросы, подобные функциям
Допускается использование и макросов с аргументами, и функций static inline. Последний ва-
риант предпочтительнее, если возникает риск множественного вычисления выражений в макро-
се, как например в случае с
#define Max(x, y)
((x) &gt; (y) ? (x) : (y))
2077Соглашения по оформ-
лению кода PostgreSQL
или когда макрос может быть слишком объёмным. В других случаях использовать макросы — един-
ственный, или как минимум более простой вариант. Например, может быть полезна возможность
передавать макросу выражения различных типов.
Когда определение внедрённой функции обращается к символам (переменным, функциям), доступ-
ным только в серверном коде, такая функция не должна быть видна при включении в клиентский
код.
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
MemoryContext old = CurrentMemoryContext;
CurrentMemoryContext = context;
return old;
}
#endif
/</em> FRONTEND <em>/
В этом примере вызывается функция CurrentMemoryContext, существующая только на стороне сер-
вера, и поэтому функция скрыта директивой #ifndef FRONTEND. Это правило введено, потому что
некоторые компиляторы генерируют указатели на символы, фигурирующие во внедрённых функ-
циях, даже когда эти функции не используются.
54.4.3. Написание обработчиков сигналов
Чтобы код мог выполняться внутри обработчика сигналов, его нужно написать очень аккуратно.
Фундаментальная сложность состоит в том, что обработчик сигнала может прервать код в любой
момент, если он не отключён. Если код внутри обработчика сигнала использует то же состояние,
что и внешний основной код, это может привести к хаосу. В качестве примера представьте, что
произойдёт, если обработчик сигнала попытается получить ту же блокировку, которой уже владе-
ет прерванный код.
Если не предпринимать специальных мер, код в обработчиках сигналов может вызывать только
безопасные с точки зрения асинхронных сигналов функции (как это определяется в POSIX) и об-
ращаться к переменным типа volatile sig_atomic_t. Также безопасными для обработчиков сиг-
налов считаются несколько функций в postgres, в том числе, что важно, SetLatch().
В большинстве случаев обработчики событий должны только сообщить о поступлении сигнала
и пробудить код снаружи обработчика, используя защёлку. Например, обработчик может быть
таким:
static void
handle_sighup(SIGNAL_ARGS)
{
int
save_errno = errno;
got_SIGHUP = true;
SetLatch(MyLatch);
errno = save_errno;
}
Переменная errno сохраняется и восстанавливается, так как её может изменить SetLatch(). Если
этого не сделать, прерванный код, считывая errno, мог бы получить некорректное значение.
54.4.4. Вызов функций по указателям
Вызов функции по указателю может записываться по-разному. Ясности ради, когда указатель на
функцию — простая переменная, предпочтительным вариантом считается запись с явным разы-
менованием указателя, например:
2078Соглашения по оформ-
лению кода PostgreSQL
(</em>emit_log_hook) (edata);
(хотя будет работать и просто emit_log_hook(edata)). Когда указатель на функции является ча-
стью структуры, дополнительные знаки пунктуации можно и обычно даже нужно опускать, напри-
мер:
paramInfo-&gt;paramFetch(paramInfo, paramId);
2079</li>
</ul>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-054/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-054/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-054/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-053/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Git/" title="Просто о GIT">Просто о GIT</a></h3>
      <p>Шпаргалка GIT <a href="http://localhost:4000/Git/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/UML_resources/" title="UML средство проектирования и разработки">UML средство проектирования и разработки</a></h4>
        <span>Published on May 31, 2019</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Oracle_RESOURCE/" title="Базы данных. Oracle">Базы данных. Oracle</a></h4>
        <span>Published on May 31, 2019</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
