<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page17/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page17/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-032/" title="Глава 32. JIT-компиляция"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 32. JIT-компиляция"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-032/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~4 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-032/" rel="bookmark" title="Глава 32. JIT-компиляция" itemprop="url">Глава 32. JIT-компиляция</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 32. JIT-компиляция</p>

<p>В этой главе рассказывается о том, что такое JIT-компиляция, и как можно настроить её в
PostgreSQL.
32.1. Что такое JIT-компиляция?
JIT-компиляция (Just-In-Time compilation, Компиляция «точно в срок») — это производимая во вре-
мя выполнения процедура преобразования интерпретируемого варианта исполнения программы
в программу на языке процессора. Например, вместо использования универсального кода, способ-
ного вычислять произвольные SQL-выражения, для вычисления конкретного условия WHERE a.col
= 3 можно сгенерировать функцию, предназначенную именно для этого выражения, которую смо-
жет выполнять непосредственно процессор, так что она будет выполняться быстрее.
PostgreSQL поддерживает JIT-компиляцию с использованием LLVM, если сборка PostgreSQL про-
изводится с ключом –with-llvm.
Дополнительные подробности можно найти в файле src/backend/jit/README.
32.1.1. Операции, ускоряемые с применением JIT
В настоящее время реализация JIT в PostgreSQL поддерживает ускорение вычисления выражений
и преобразования кортежей. В будущем могут быть ускорены и некоторые другие операции.
Вычисление выражений производится при обработке предложений WHERE, целевых списков, агре-
гатов и проекций. Оно может быть ускорено в результате генерирования кода, предназначенного
для каждого конкретного случая.
Преобразование кортежей — процедура перевода кортежа с диска (см. Подраздел 68.6.1) в развёр-
нутое представление в памяти. Его можно ускорить, создав функции, предназначенные для опре-
делённой структуры таблицы и количества извлекаемых столбцов.
32.1.2. Встраивание
СУБД PostgreSQL очень гибка и позволяет определять новые типы данных, функции, операторы и
другие объекты базы данных; см. Главу 38. В действительности встроенные объекты реализуются
практически теми же механизмами. С этой гибкостью связаны некоторые издержки, например,
сопутствующие вызовам функций (см. Раздел 38.3). Для сокращения этих издержек JIT-компиля-
ция может встраивать тела маленьких функций в код выражений, использующих их. Это позволяет
соптимизировать значительный процент подобных издержек.
32.1.3. Оптимизация
В LLVM поддерживается оптимизация сгенерированного кода. Некоторые оптимизации обходятся
достаточно дёшево и могут выполняться при использовании JIT в любом случае, тогда как другие
оправданы только при длительных запросах. Подробнее об оптимизации рассказывается в https://
llvm.org/docs/Passes.html#transform-passes.
32.2. Когда применять JIT?
JIT-компиляция имеет смысл в первую очередь для длительных запросов, нагружающих процессор.
Например, такой характер обычно имеют аналитические запросы. Для быстрых запросов наклад-
ные расходы, связанные с выполнением JIT-компиляции, часто будут превышать выигрыш от их
ускорения.
Решение об использовании JIT-компиляции принимается на основании общей стоимости запроса
(см. Главу 70 и Подраздел 19.7.2). Стоимость запроса сравнивается со значением jit_above_cost,
и если она оказывается больше, производится JIT-компиляция. Затем принимаются ещё два реше-
742JIT-компиляция
ния. Во-первых, если его стоимость превышает и значение jit_inline_above_cost, тела небольших
функций и операторов, фигурирующих в запросе, будут встраиваться в вызывающий код. Во-вто-
рых, если стоимость запроса превышает значение jit_optimize_above_cost, при генерации кода за-
действуются дорогостоящие оптимизации для улучшения сгенерированного кода. Обе эти опера-
ции увеличивают накладные расходы JIT, но могут значительно сократить время выполнения за-
проса.
Эти решения принимаются на основе стоимости во время планирования, а не исполнения запроса.
Это означает, что в случае использования подготовленных операторов и общего плана (см. Раздел
«Замечания») принятие решений зависит от параметров конфигурации, действующих во время
подготовки запроса, а не во время выполнения.
Примечание
Если параметр jit имеет значение off или сервер не поддерживает JIT (например, по-
тому что он был скомпилирован без –with-llvm), JIT-компиляция выполняться не бу-
дет, даже если она была бы выгодна, исходя из описанных выше критериев. Присво-
енное параметру jit значение off учитывается и во время планирования, и во время
выполнения запросов.
EXPLAIN позволяет определить, используется ли JIT-компиляция. Например, так выглядит запрос,
не использующий JIT:
=# EXPLAIN ANALYZE SELECT SUM(relpages) FROM pg_class;
QUERY PLAN
——————————————————————————————–
Aggregate (cost=16.27..16.29 rows=1 width=8) (actual time=0.303..0.303 rows=1
loops=1)
-&gt; Seq Scan on pg_class (cost=0.00..15.42 rows=342 width=4) (actual
time=0.017..0.111 rows=356 loops=1)
Planning Time: 0.116 ms
Execution Time: 0.365 ms
(4 rows)
Учитывая стоимость планирования, отказ от использования JIT вполне обоснован, так как стои-
мость JIT-компиляции оказалась бы больше, чем выигрыш от оптимизации. Если уменьшить огра-
ничение стоимости, JIT будет использоваться:
=# SET jit_above_cost = 10;
SET
=# EXPLAIN ANALYZE SELECT SUM(relpages) FROM pg_class;
QUERY PLAN
——————————————————————————————–
Aggregate (cost=16.27..16.29 rows=1 width=8) (actual time=6.049..6.049 rows=1
loops=1)
-&gt; Seq Scan on pg_class (cost=0.00..15.42 rows=342 width=4) (actual
time=0.019..0.052 rows=356 loops=1)
Planning Time: 0.133 ms
JIT:
Functions: 3
Options: Inlining false, Optimization false, Expressions true, Deforming true
Timing: Generation 1.259 ms, Inlining 0.000 ms, Optimization 0.797 ms, Emission
5.048 ms, Total 7.104 ms
Execution Time: 7.416 ms
В данном случае видно, что JIT используется, но встраивание (Inlining) и дорогостоящие оптими-
зации (Optimization) не выполнялись. Чтобы их включить, помимо jit_above_cost нужно было также
уменьшить jit_inline_above_cost и jit_optimize_above_cost.
743JIT-компиляция
32.3. Конфигурация
Переменная конфигурации jit определяет, возможно ли использование JIT-компиляции. Если она
включена, переменные jit_above_cost, jit_inline_above_cost и jit_optimize_above_cost определяют, бу-
дет ли выполняться JIT-компиляция для запросов, и насколько ресурсоёмкой она может быть.
Параметр jit_provider определяет, какая реализация JIT-компиляции должна использоваться. Из-
менять его может потребоваться лишь в редких случаях. См. Подраздел 32.4.2.
Для целей отладки и разработки предназначен ряд дополнительных параметров конфигурации,
описанных в Разделе 19.17.
32.4. Расширяемость
32.4.1. Поддержка встраивания кода для расширений
Механизм JIT в PostgreSQL может встраивать в код реализации функций (типа C и internal), а
также операторов, использующих эти функции. Чтобы это встраивание выполнялось для функций
в расширениях, должно быть доступно определение этих функций. При сборке с использованием
PGXS расширения для сервера, скомпилированного с JIT-поддержкой LLVM, соответствующие фай-
лы будут собираться и устанавливаться автоматически.
Соответствующие файлы должны устанавливаться в $pkglibdir/bitcode/$extension/, а информа-
ция о них должна вноситься в $pkglibdir/bitcode/$extension.index.bc, где $pkglibdir — ката-
лог, который выдаёт команда pg_config –pkglibdir, а $extension — базовое имя разделяемой
библиотеки данного расширения.
Примечание
Для функций, встроенных в PostgreSQL, двоичный код устанавливается в $pkglibdir/
bitcode/postgres.
32.4.2. Подключаемые провайдеры JIT
PostgreSQL предоставляет реализацию JIT на базе LLVM. Интерфейс JIT предусматривает динами-
ческое подключение провайдера и позволяет менять провайдер без перекомпиляции (хотя в на-
стоящее время при сборке предоставляется поддержка встраивания только для LLVM). Провайдер
выбирается параметром jit_provider.
32.4.2.1. Интерфейс провайдера JIT
Провайдер JIT загружается путём динамической загрузки заданной разделяемой библиотеки. Для
поиска её используется обычный путь поиска библиотек. Чтобы предоставить требуемые функ-
ции-обработчики провайдера JIT и показать, что библиотека является реализацией провайдера JIT,
она должна содержать функцию, имеющую в C имя _PG_jit_provider_init. Этой функции пере-
даётся структура, которую нужно заполнить указателями на функции-обработчики определённых
действий.
struct JitProviderCallbacks
{
JitProviderResetAfterErrorCB reset_after_error;
JitProviderReleaseContextCB release_context;
JitProviderCompileExprCB compile_expr;
};
extern void _PG_jit_provider_init(JitProviderCallbacks *cb);
744</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-031/" title="Глава 31. Логическая репликация"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 31. Логическая репликация"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-031/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~12 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-031/" rel="bookmark" title="Глава 31. Логическая репликация" itemprop="url">Глава 31. Логическая репликация</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 31. Логическая репликация</p>

<p>Логическая репликация — это метод репликации объектов данных и изменений в них, использу-
ющий репликационные идентификаторы (обычно это первичный ключ). Мы называем такую ре-
пликацию «логической», в отличие от физической, которая построена на точных адресах блоков
и побайтовом копировании. PostgreSQL поддерживает оба механизма одновременно; см. Главу 26.
Логическая репликация позволяет более детально управлять репликацией данных и аспектами
безопасности.
В логической репликации используется модель публикаций/подписок с одним или несколькими
подписчиками, которые подписываются на одну или несколько публикаций на публикующем узле.
Подписчики получают данные из публикаций, на которые они подписаны, и могут затем повторно
опубликовать данные для организации каскадной репликации или более сложных конфигураций.
Логическая репликация таблицы обычно начинается с создания снимка данных в публикуемой
базе данных и копирования её подписчику. После этого изменения на стороне публикации пере-
даются подписчику в реальном времени, когда они происходят. Подписчик применяет изменения
в том же порядке, что и узел публикации, так что для публикаций в рамках одной подписки гаран-
тируется транзакционная целостность. Этот метод репликации данных иногда называется тран-
закционной репликацией.
Типичные сценарии использования логической репликации:
• Передача подписчикам инкрементальных изменений в одной базе данных или подмножестве
базы данных, когда они происходят.
• Срабатывание триггеров для отдельных изменений, когда их получает подписчик.
• Объединение нескольких баз данных в одну (например, для целей анализа).
• Репликация между разными основными версиями PostgreSQL.
• Репликация между экземплярами PostgreSQL на разных платформах (например, с Linux на
Windows)
• Предоставление доступа к реплицированным данным другим группам пользователей.
• Разделение подмножества базы данных между несколькими базами данных.
База данных подписчика функционирует так же, как и любой другой экземпляр базы PostgreSQL,
и может стать публикующей, если создать публикации в ней. Когда подписчик действует как ис-
ключительно читающее приложение, никаких конфликтов с одной подпиской не будет. Но они мо-
гут возникнуть, если в тот же набор таблиц производят запись какие-либо приложения или другие
подписчики.
31.1. Публикация
Публикация может быть определена на любом ведущем сервере физической репликации. Сервер,
на котором определяется публикация, называется публикующим. Публикация — это набор изме-
нений, выделяемых в таблице или в группе таблиц (он также может называться набором реплика-
ции). Публикация существует только в одной базе данных.
Публикации отличаются от схем и они никак не влияют на доступ к таблице. Если требуется, каж-
дую таблицу можно включить в несколько публикаций. В настоящее время публикации могут со-
держать только таблицы. Объекты в них нужно добавлять явным образом, если только публикация
не создана для всех таблиц (с указанием ALL TABLES).
Публикации могут ограничивать набор публикуемых изменений, выбирая любое сочетание опе-
раций из INSERT, UPDATE, DELETE и TRUNCATE, подобно тому как для разных типов событий могут
срабатывать триггеры. По умолчанию реплицируются все типы операций.
736Логическая репликация
Чтобы можно было реплицировать операции UPDATE и DELETE, в публикуемой таблице должен быть
настроен «репликационный идентификатор» для нахождения соответствующих строк для измене-
ния или удаления на стороне подписчика. По умолчанию это первичный ключ, если он создан.
Также репликационным идентификатором можно назначить другой уникальный индекс (с неко-
торыми дополнительными условиями). Если в таблице нет подходящего ключа, в качестве репли-
кационного идентификатора можно задать «full», что будет означать, что ключом будет вся стро-
ка. Это, однако, очень неэффективно и должно применяться как крайняя мера, если другого ре-
шения нет. Если на стороне публикации выбран репликационный идентификатор, отличный от
«full», то идентификатор, состоящий из того же или меньшего количества столбцов, также должен
быть определён на стороне подписчика. Подробнее о назначении репликационного идентифика-
тора рассказывается в REPLICA IDENTITY. Если в публикацию, в которой реплицируются операции
UPDATE и DELETE, добавляется таблица без репликационного идентификатора, то последующие ко-
манды UPDATE и DELETE на стороне публикации вызовут ошибку. Команды INSERT могут выполнять-
ся вне зависимости от такого идентификатора.
У каждой публикации может быть множество подписчиков.
Публикация создаётся командой CREATE PUBLICATION и может быть впоследствии изменена или
удалена с помощью соответствующих команд.
В публикации можно динамически добавлять или удалять отдельные таблицы, используя команду
ALTER PUBLICATION. Операции ADD TABLE и DROP TABLE являются транзакционными, так что ре-
пликация таблицы будет начата или закончена с определённым снимком только после фиксации
транзакции.
31.2. Подписка
Подписка — это принимающая сторона логической репликации. Узел, на котором определяется
подписка, называется подписчиком. В свойствах подписки определяется подключение к другой
базе данных и набор публикаций (из одной или нескольких), на которые подписчик хочет подпи-
саться.
База данных подписчика работает так же, как и экземпляр любой другой базы PostgreSQL, и может
быть публикующей для других баз, если в ней определены собственные подписки.
Узел подписчика может подписываться на несколько подписок, если требуется. В одной паре пуб-
ликующий сервер/подписчик могут быть определены несколько подписок, но при этом нужно по-
заботиться о том, чтобы публикуемые объекты в разных подписках не перекрывались.
Изменения в каждой подписке будут приходить через один слот репликации (см. Подраз-
дел 26.2.6). Дополнительные слоты репликации могут потребоваться для начальной синхрониза-
ции уже существующих данных таблиц.
Подписка логической репликации может представлять собой ведомый узел для синхронной ре-
пликации (см. Подраздел 26.2.8). В этом случае именем ведомого узла по умолчанию будет имя
подписки. Другое имя можно задать в свойстве application_name в строке подключения для дан-
ной подписки.
Подписки могут быть выгружены командой pg_dump, если её выполняет суперпользователь. В про-
тивном случае выдаётся предупреждение и подписки пропускаются, так как обычным пользова-
телям не разрешено читать всю информацию о подписках из каталога pg_subscription.
Подписки добавляются командой CREATE SUBSCRIPTION и могут быть остановлены/возобнов-
лены в любой момент командой ALTER SUBSCRIPTION, а также удалены командой DROP
SUBSCRIPTION.
Когда подписка удаляется и пересоздаётся, информация о синхронизации теряется. Это означает,
что после этого данные необходимо синхронизировать заново.
737Логическая репликация
Определения схемы не реплицируются, а публикуемые таблицы должны существовать в базе под-
писчика. Объектами репликации могут быть только обычные таблицы. Так, например, нельзя про-
извести репликацию в представление.
Таблицы публикации сопоставляются с таблицами подписчика по полностью заданным именам
таблиц. Репликация в таблицы с другими именами на стороне подписчика не поддерживается.
Столбцы таблиц также сопоставляются по именам. Другой порядок столбцов в целевой таблице
допускается, но типы столбцов должны совпадать. Целевая таблица может содержать дополни-
тельные столбцы, отсутствующие в публикуемой таблице. Они будут заполнены установленными
для них значениями по умолчанию.
31.2.1. Управление слотами репликации
Как было сказано ранее, каждая (активная) подписка получает изменения из слота репликации
на удалённой стороне (стороне публикации). Обычно удалённый слот репликации создаётся ав-
томатически, когда подписка создаётся командой CREATE SUBSCRIPTION, и удаляется автоматиче-
ски, когда она удаляется командой DROP SUBSCRIPTION. Однако в некоторых ситуациях может быть
полезно или необходимо манипулировать подпиской и нижележащим слотом по отдельности. На-
пример, возможны такие сценарии:
• При создании подписки слот репликации может уже существовать. В этом случае подписку
можно создать с параметром create_slot = false, чтобы она была связана с существующим
слотом.
• Про создании подписки удалённый узел может быть недоступен или находиться в нерабочем
состоянии. В этом случае подписку можно создать с указанием connect = false. При этом
подключение к удалённому узлу не будет устанавливаться. Этот вариант использует pg_dump.
Чтобы активировать такую подписку впоследствии, удалённый слот репликации нужно будет
создать вручную.
• При ликвидации публикации может потребоваться сохранить слот репликации. Например,
это полезно, когда нужно перенести базу данных подписчика на другой узел и активиро-
вать её там. В этом случае разорвите связь подписки со слотом, используя команду ALTER
SUBSCRIPTION, прежде чем удалять подписку.
• При ликвидации подписки удалённый узел может быть недоступен. В этом случае разорви-
те связь подписки со слотом, используя команду ALTER SUBSCRIPTION, прежде чем пытаться
удалять подписку. Если удалённый экземпляр базы данных прекратил существование, больше
никакие действия не требуются. Если же экземпляр удалённой базы данных просто оказался
недоступным, слот репликации нужно будет удалить вручную; в противном случае публикую-
щий сервер продолжит сохранять WAL и может в конце концов заполнить всё место на диске.
Такие случаи заслуживают самого серьёзного разбирательства.
31.3. Конфликты
Логическая репликация работает подобно обычным операциям DML в том смысле, что данные
будут изменены, даже если они независимо изменялись на стороне подписчика. Если входящие
данные нарушат какие-либо ограничения, репликация остановится. Эта ситуация называется кон-
фликтом. При репликации операций UPDATE или DELETE отсутствие данных не вызывает конфлик-
та, так что такие операции просто пропускаются.
В случае конфликта выдаётся ошибка и репликация останавливается; разрешить возникшую про-
блему пользователь должен вручную. Подробности конфликта можно найти в журнале серве-
ра-подписчика.
Разрешение может заключаться либо в изменении данных на стороне подписчика, что-
бы они не конфликтовали с приходящим изменением, либо в пропуске транзакции, кон-
фликтующей с существующими данными. Пропустить транзакцию можно, вызвав функцию
pg_replication_origin_advance(), которой передаётся в node_name соответствующее имя подпис-
738Логическая репликация
ки, а также позиция. Текущие позиции источников можно увидеть в системном представлении
pg_replication_origin_status.
31.4. Ограничения
Логическая репликация в настоящее время имеет ограничения и недостатки, описанные ниже.
Они могут быть устранены в будущих выпусках.
• Схема базы данных и команды DDL не реплицируются. Изначальную схему можно скопиро-
вать, воспользовавшись командой pg_dump –schema-only. Последующие изменения схемы
необходимо будет синхронизировать вручную. (Заметьте, однако, что схемы не обязательно
должны быть абсолютно идентичными на обеих сторонах репликации.) Если определения схе-
мы в исходной базе данных меняются, логическая репликация работает надёжно — когда дан-
ные после изменения схемы прибывают на сторону подписчика, но не вписываются в схему
его таблиц, выдаётся ошибка, требующая обновления схемы. Во многих случаях возникнове-
ние таких ошибок можно предупредить, сначала применяя дополняющие изменения на под-
писчике.
• Данные последовательностей не реплицируются. Данные в столбцах serial или столбцах иден-
тификации, выдаваемые последовательностями, конечно, будут реплицированы в составе таб-
лицы, но сама последовательность на подписчике будет сохранять стартовое значение. Ес-
ли подписчик используется в качестве базы только для чтения, обычно это не является про-
блемой. Если же, однако, предусматривается возможность переключения на базу подписчика
некоторым образом, текущие значения в этих последовательностях нужно будет обновить, ли-
бо скопировав текущие данные из базы публикации (вероятно, с применением pg_dump), либо
выбрав достаточно большие значения из самих таблиц.
• Репликация команд TRUNCATE поддерживается, но опустошение групп таблиц, соединённых
внешними ключами, стоит выполнять с осторожностью. При репликации действия TRUNCATE
подписчик опустошит ту же группу таблиц, которая была опустошена на публикующем сер-
вере (явным образом или в результате CASCADE), исключая таблицы, не входящие в подписку.
Данная операция завершится корректно, если все затронутые таблицы включены в одну и ту
же подписку. Если же некоторые таблицы, подлежащие опустошению на подписчике, связа-
ны по внешнему ключу с таблицами, не входящими в данную подписку, операция опустоше-
ния на сервере-подписчике завершится ошибкой.
• Большие объекты (см. Главу 35) не реплицируются. Это ограничение нельзя обойти никак,
кроме как хранить данные в обычных таблицах.
• Реплицировать данные возможно только из базовых таблиц в базовые таблицы. То есть табли-
цы на стороне публикации и на стороне подписки должны быть обычными, а не представлени-
ями, мат. представлениями, секционированными или сторонними таблицами. Это означает,
что вы можете реплицировать секции одну в одну, но реплицировать данные в таблицы, сек-
ционированные по-другому, нельзя. При попытке реплицировать таблицы, отличные от базо-
вых, будет выдана ошибка.
31.5. Архитектура
Логическая репликация начинается с копирования снимка данных в базе данных публикации. По
завершении этой операции изменения на стороне публикации передаются подписчику в реальном
времени, когда они происходят. Подписчик применяет изменения в том же порядке, в каком они
вносятся на узле публикации, так что для публикаций в рамках одной подписки гарантируется
транзакционная целостность.
Логическая репликация построена по схеме, подобной физической потоковой репликации (см.
Подраздел 26.2.5). Она реализуется процессами «walsender» (передачи WAL) и «apply» (примене-
ния). Процесс walsender запускает логическое декодирование (описанное в Главе 49) WAL и за-
гружает стандартный модуль логического декодирования (pgoutput). Этот модуль преобразует из-
менения, считываемые из WAL, в протокол логической репликации (см. Раздел 53.5) и отфильтро-
вывает данные согласно спецификации публикации. Затем данные последовательно передаются
739Логическая репликация
по протоколу логической репликации рабочему процессу применения изменений, который сопо-
ставляет данные с логическими таблицами и применяет отдельные изменения по мере их поступ-
ления, сохраняя транзакционный порядок.
Процесс применения изменений в базе данных подписчика всегда выполняется со значением
session_replication_role, равным replica, что влечёт соответствующие эффекты для триггеров
и ограничений.
Процесс применения логической репликации в настоящее время вызывает только триггеры уровня
строк, но не триггеры операторов. Однако начальная синхронизация таблицы реализована как
команда COPY и поэтому вызывает триггеры для INSERT и уровня строк, и уровня оператора.
31.5.1. Начальный снимок
Начальные данные существующих таблиц в подписке помещаются в снимок и копируются в парал-
лельном экземпляре процесса применения особого вида. Этот процесс создаёт собственный слот
репликации и производит копирование существующих данных. Когда существующие данные будут
скопированы, этот рабочий процесс переходит в режим синхронизации, в котором таблица при-
водится в синхронизированное состояние для основного процесса применения, то есть передаёт
все изменения, произошедшие во время начального копирования данных, используя стандартную
логическую репликацию. По завершении синхронизации управление репликацией этой таблицы
возвращается главному процессу, который продолжает репликацию в обычном режиме.
31.6. Мониторинг
Так как логическая репликация построена по схеме, подобной физической потоковой репликации,
мониторинг публикующего узла подобен мониторингу ведущего сервера при физической репли-
кации (см. Подраздел 26.2.5.2).
Информацию
о
подписке
для
мониторинга
можно
получить
в
представлении
pg_stat_subscription. Это представление содержит по одной строке для каждого рабочего про-
цесса подписчика. В зависимости от состояния подписки, с ней может быть связано ноль или бо-
лее активных рабочих процессов.
Обычно для включённой подписки работает только один процесс применения. Для отключённой
или нарушенной подписки это представление будет содержать ноль строк. Если выполняется на-
чальная синхронизация данных для каких-либо таблиц, для этих таблиц будут показаны дополни-
тельные рабочие процессы, производящие синхронизацию.
31.7. Безопасность
Роль, используемая для подключения репликации, должна иметь атрибут REPLICATION (или быть
суперпользователем). Доступ для этой роли должен быть настроен в pg_hba.conf, и эта роль также
должна иметь атрибут LOGIN.
Чтобы иметь возможность скопировать исходные данные таблицы, роль, используемая для соеди-
нения репликации, должна иметь право SELECT в публикуемой таблице (или быть суперпользова-
телем).
Чтобы создать публикацию, пользователь должен иметь право CREATE в базе данных.
Чтобы добавлять таблицы в публикацию, пользователь должен иметь права владельца для этих
таблиц. Создавать публикации, публикующие все таблицы автоматически, разрешено только су-
перпользователям.
Создавать подписки разрешено только суперпользователям.
Процесс применения изменений подписки будет выполняться в локальной базе с правами супер-
пользователя.
740Логическая репликация
Права проверяются только один раз при установлении подключения для репликации. Они не пе-
репроверяются при чтении каждой записи изменения с публикующего сервера и не перепроверя-
ются при применении каждого изменения.
31.8. Параметры конфигурации
Для осуществления логической репликации необходимо установить несколько параметров конфи-
гурации.
На публикующем сервере параметр wal_level должен иметь значение logical, а в
max_replication_slots должно быть задано число не меньше ожидаемого числа подписчиков
плюс некоторый резерв для синхронизации таблиц. А в max_wal_senders должно быть значение
как минимум равное max_replication_slots плюс число возможных физических реплик, работа-
ющих одновременно.
Также на стороне подписчика необходимо установить параметр max_replication_slots. В дан-
ном случае он должен быть не меньше числа подписок, на которые будет подписываться данный
подписчик. В max_logical_replication_workers необходимо установить минимум число подписок
плюс некоторый резерв для синхронизации таблиц. Кроме того, может потребоваться изменить
max_worker_processes, чтобы это число включало дополнительные рабочие процессы для репли-
кации (как минимум max_logical_replication_workers + 1). Заметьте, что некоторые расширения
и параллельные запросы также занимают слоты из числа max_worker_processes.
31.9. Быстрая настройка
Сначала установите параметры конфигурации в postgresql.conf:
wal_level = logical
Другие необходимые параметры по умолчанию имеют значения, подходящие для базовой настрой-
ки.
В файл pg_hba.conf необходимо внести изменения, чтобы разрешить репликацию (конкретные
значения будут зависеть от фактической конфигурации сети и имени пользователя, с которым вы
будете подключаться):
host
all
repuser
0.0.0.0/0
md5
Затем в базе данных публикации выполните:
CREATE PUBLICATION mypub FOR TABLE users, departments;
И в базе данных подписчика:
CREATE SUBSCRIPTION mysub CONNECTION ‘dbname=foo host=bar user=repuser’ PUBLICATION
mypub;
Показанная выше команда запустит процесс репликации, который вначале синхронизирует исход-
ное содержимого таблиц users и departments, а затем начнёт перенос инкрементальных измене-
ний в этих таблицах.
741</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-030/" title="Глава 30. Надёжность и журнал предзаписи"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 30. Надёжность и журнал предзаписи"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-030/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~24 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-030/" rel="bookmark" title="Глава 30. Надёжность и журнал предзаписи" itemprop="url">Глава 30. Надёжность и журнал предзаписи</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 30. Надёжность и журнал предзаписи</p>

<p>В данной главе рассказывается, как для обеспечения эффективной и надёжной работы использу-
ется журнал предзаписи.
30.1. Надёжность
Надёжность — это важное свойство любой серьёзной СУБД и PostgreSQL делает всё возможное,
чтобы гарантировать надёжность своего функционирования. Один из аспектов надёжности состо-
ит в том, что все данные записываются с помощью подтверждённых транзакций, которые сохра-
няются в энергонезависимой области, которая защищена от потери питания, сбоев операционной
системы и аппаратных отказов (разумеется, за исключением отказа самой энергонезависимой об-
ласти). Успешная запись данных в постоянное место хранения (диск или эквивалентный носитель)
обычно всё, что требуется. Фактически, даже если компьютер полностью вышел из строя, если
диски выжили, то они могут быть переставлены в другой похожий компьютер и все подтверждён-
ные транзакции останутся неповреждёнными.
Хотя периодическая запись данных на пластины диска может выглядеть как простая операция, это
не так, потому что диски значительно медленнее, чем оперативная память и процессор, а также
потому что между оперативной памятью и пластинами диска есть некоторые механизмы кеширо-
вания. Во-первых, есть буферный кеш операционной системы, который кеширует частые запросы к
блокам диска и комбинирует запись на диск. К счастью, все операционные системы предоставляют
приложениям способ принудительной записи из буферного кеша на диск и PostgreSQL использует
эту возможность. (Смотрите параметр wal_sync_method который отвечает за то как это делается.)
Далее, кеширование также может осуществляться контроллером диска; в особенности это касает-
ся RAID-контроллеров. В некоторых случаях это кеширование работает в режиме сквозной записи,
что означает, что запись осуществляется на диск как только приходят данные. В других случаях,
возможна работа в режиме отложенной записи, что означает, что запись осуществляется неко-
торое время спустя. Такой режим кеширования может создавать риск для надёжности, потому что
память контроллера диска непостоянна и будет потеряна в случае потери питания. Лучшие кон-
троллеры имеют так называемую батарею резервного питания (Battery-Backup Unit, BBU), кото-
рая сохраняет кеш контроллера на батарее, если пропадёт системное питание. После возобновле-
ния питания, данные, оставшиеся в кеше контроллера, будут записаны на диски.
И наконец, многие диски имеют кеширование. На каких-то дисках оно работает в режиме сквозной
записи, на других в режиме отложенной записи, что приводит к тем же проблемам потери данных
для кеша отложенной записи, что и с кешем в контроллерах дисков. Диски IDE и SATA, потреби-
тельского класса особенно, часто имеют кеш отложенной записи, который сбрасывается при поте-
ре питания. Многие SSD-накопители также имеют зависимый от питания кеш отложенной записи.
Обычно, такое кеширование можно выключить; однако, то, как это делается, различается для опе-
рационной системы и для типа диска:
• В Linux параметры дисков IDE и SATA могут быть получены с помощью команды hdparm -I;
кеширование записи включено, если за строкой Write cache следует *. Для выключения ке-
ширования записи может быть использована команда hdparm -W 0. Параметры SCSI-дисков
могут быть получены с помощью утилиты sdparm. Используйте sdparm –get=WCE, чтобы про-
верить, включено ли кеширование записи, и sdparm –clear=WCE, чтобы выключить его.
• Во FreeBSD параметры IDE-дисков могут быть получены с помощью команды atacontrol, а
кеширование записи выключается при помощи установки параметра hw.ata.wc=0 в файле
/boot/loader.conf; Для SCSI-дисков параметры могут быть получены, используя команду
camcontrol identify, а кеширование записи изменяется при помощи утилиты sdparm.
• В Solaris кешированием записи на диск управляет команда format -e. (Использование файло-
вой системы Solaris ZFS, при включённом кешировании записи на диск, является безопасным,
потому что она использует собственные команды сброса кеша на диск.)
727Надёжность и журнал предзаписи
• В Windows, если параметр wal_sync_method установлен в open_datasync (по умолчанию), ке-
ширование записи на диск может быть выключено снятием галочки My Computer\Open\disk
drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk. В
качестве альтернативы, можно установить параметр wal_sync_method в значение fsync или
fsync_writethrough, что предотвращает кеширование записи.
• В macOS кеширование записи можно отключить, установив для параметра wal_sync_method
значение fsync_writethrough.
Новые модели SATA-дисков (которые соответствуют стандарту ATAPI-6 или более позднему) пред-
лагают команду сброса кеша на диск (FLUSH CACHE EXT), а SCSI-диски уже давно поддерживают
похожую команду SYNCHRONIZE CACHE. Эти команды недоступны из PostgreSQL напрямую, но неко-
торые файловые системы (например, ZFS, ext4), могут использовать их для сброса данных из кеша
на пластины диска при включённом режиме кеша сквозной записи. К сожалению, такие файло-
вые системы ведут себя неоптимально при комбинировании с батареей резервного питания (BBU)
дискового контроллера. В таких случаях, команда синхронизации принуждает сохранять все дан-
ные на диск из кеша контроллера, сводя преимущество BBU к нулю. Вы можете запустить модуль
pg_test_fsync, чтобы увидеть, что вы попали в эту ситуацию. Если это так, преимущества произ-
водительности BBU могут быть восстановлены с помощью выключения барьеров записи для фай-
ловой системы или переконфигурирования контроллера диска, если это возможно. Если барьеры
записи выключены, убедитесь, что батарея годная; при отказе батареи может произойти потеря
данных. Есть надежда, что разработчики файловых систем и контроллеров дисков, в конце концов,
устранят это неоптимальное поведение.
Когда операционная система отправляет запрос на запись к аппаратному обеспечению для хра-
нения данных, она мало что может сделать, чтобы убедиться, что данные действительно сохране-
ны в какой-либо энергонезависимой области. Скорее, это является зоной ответственности адми-
нистратора, убедиться в целостности данных на всех компонентах хранения. Избегайте дисковых
контроллеров, которые не имеют батарей резервного питания для кеширования записи. На уровне
диска, запретите режим отложенной записи, если диск не может гарантировать, что данные будут
записаны перед выключением. Если вы используете SSD, знайте, что многие их них по умолчанию
не выполняют команды сброса кеша на диск. Вы можете протестировать надёжность поведения
подсистемы ввода/вывода, используя diskchecker.pl.
Другой риск потери данных состоит в самой записи на пластины диска. Пластины диска разделя-
ются на секторы, обычно по 512 байт каждый. Каждая операция физического чтения или записи
обрабатывает целый сектор. Когда дисковый накопитель получает запрос на запись, он может со-
ответствовать нескольким секторам по 512 байт (PostgreSQL обычно за один раз записывает 8192
байта или 16 секторов) и из-за отказа питания процесс записи может закончится неудачей в любое
время, что означает, что некоторые из 512-байтовых секторов будут записаны, а некоторые нет.
Чтобы защититься от таких сбоев, перед изменением фактической страницы на диске, PostgreSQL
периодически записывает полные образы страниц на постоянное устройство хранения WAL. С по-
мощью этого, во время восстановления после краха, PostgreSQL может восстановить из WAL стра-
ницы, которые записаны частично. Если у вас файловая система, которая защищена от частич-
ной записи страниц (например, ZFS), вы можете выключить работу с образами страниц, выключив
параметр full_page_writes. Батарея резервного питания (BBU) контроллера диска не защищает от
частичной записи страниц, если не гарантируется, что данные записаны в BBU как полные (8kB)
страницы.
PostgreSQL также защищает от некоторых видов повреждения данных на устройствах хранения,
которые могут произойти из-за аппаратных ошибок или из-за дефектов поверхности с течением
времени, например, при операциях чтения/записи во время сборки мусора.
• Каждая индивидуальная запись в WAL защищена с помощью контрольной суммы по алгорит-
му CRC-32 (32-bit), что позволяет судить о корректности данных в записи. Значение CRC уста-
навливается, когда мы пишем каждую запись WAL и проверяется в ходе восстановления после
сбоя, восстановления из архива, и при репликации.
• Страницы данных в настоящее время не защищаются контрольными суммами по умолчанию,
хотя полные образы страниц, записанные в WAL будут защищены; смотрите initdb для деталей
о включении в страницы данных информации о контрольных суммах.
728Надёжность и журнал предзаписи
• Для внутренних структур данных, таких как pg_xact, pg_subtrans, pg_multixact, pg_serial,
pg_notify, pg_stat, pg_snapshots не ведётся расчёт контрольной суммы, равно как и для
страниц, защищённых посредством полностраничной записи. Однако там, где такие структу-
ры данных являются постоянными, записи WAL пишутся таким образом, чтобы после сбоя бы-
ло возможно аккуратно повторить последние изменения, а эти записи WAL защищаются так
же, как описано выше.
• Файлы каталога pg_twophase защищены с помощью контрольной суммы CRC-32.
• Временные файлы данных, используемые в больших SQL-запросах для сортировки, материа-
лизации и промежуточных результатов, в настоящее время не защищаются контрольной сум-
мой, а изменения в этих файлах не отражаются в WAL.
PostgreSQL не защищает от корректируемых ошибок памяти; предполагается, что вы будете ра-
ботать с памятью, которая использует промышленный стандарт коррекции ошибок (ECC, Error
Correcting Codes) или лучшую защиту.
30.2. Журнал предзаписи (WAL)
Журнал предзаписи (WAL) — это стандартный метод обеспечения целостности данных. Детальное
описание можно найти в большинстве книг (если не во всех) по обработке транзакций. Вкратце,
основная идея WAL состоит в том, что изменения в файлах с данными (где находятся таблицы и
индексы) должны записываться только после того, как эти изменения были занесены в журнал,
т. е. после того как записи журнала, описывающие данные изменения, будут сохранены на посто-
янное устройство хранения. Если следовать этой процедуре, то записывать страницы данных на
диск после подтверждения каждой транзакции нет необходимости, потому что мы знаем, что если
случится сбой, то у нас будет возможность восстановить базу данных с помощью журнала: любые
изменения, которые не были применены к страницам с данными, могут быть воссозданы из запи-
сей журнала. (Это называется восстановлением с воспроизведением, или REDO.)
Подсказка
Поскольку WAL восстанавливает содержимое файлов базы данных, журналируемая
файловая система не является необходимой для надёжного хранения файлов с дан-
ными или файлов WAL. Фактически, журналирование может снизить производитель-
ность, особенно если журналирование заставляет сохранять данные файловой систе-
мы на диск. К счастью, такое сохранение при журналировании часто можно отключить
с помощью параметров монтирования файловой системы, например, data=writeback
для файловой системы ext3 в Linux. С другой стороны, с журналируемыми файловыми
системами увеличивается скорость загрузки после сбоя.
Результатом использования WAL является значительное уменьшение количества запросов запи-
си на диск, потому что для гарантии, что транзакция подтверждена, в записи на диск нуждается
только файл журнала, а не каждый файл данных изменённый в результате транзакции. Файл жур-
нала записывается последовательно и таким образом, затраты на синхронизацию журнала намно-
го меньше, чем затраты на запись страниц с данными. Это особенно справедливо для серверов,
которые обрабатывают много маленьких транзакций, изменяющих разные части хранилища дан-
ных. Таким образом, когда сервер обрабатывает множество мелких конкурентных транзакций, для
подтверждения многих транзакций достаточно одного вызова fsync на файл журнала.
WAL также делает возможным поддержку онлайнового резервного копирования и восстановления
на определённый момент времени, как описывается в Разделе  25.3. С помощью архивирования
данных WAL поддерживается возврат к любому моменту времени, который доступен в данных WAL:
мы просто устанавливаем предыдущую физическую резервную копию базы данных и воспроизво-
дим журнал WAL до нужного момента времени. Более того, физическая резервная копия не долж-
на быть мгновенным снимком состояния баз данных — если она была сделана некоторое время
назад, воспроизведение журнала WAL за этот период исправит все внутренние несоответствия.
729Надёжность и журнал предзаписи
30.3. Асинхронное подтверждение транзакций
Асинхронная фиксация — это возможность завершать транзакции быстрее, ценой того, что в слу-
чае краха СУБД последние транзакции могут быть потеряны. Для многих приложений такой ком-
промисс приемлем.
Как описано в предыдущей части, подтверждение транзакции обычно синхронное: сервер ждёт
сохранения записей WAL транзакции в постоянном хранилище, прежде чем сообщить клиенту об
успешном завершении. Таким образом, клиенту гарантируется, что транзакция, которую подтвер-
дил сервер, будет защищена, даже если сразу после этого произойдёт крах сервера. Однако, для
коротких транзакций данная задержка будет основной составляющей общего времени транзак-
ции. В режиме асинхронного подтверждения сервер сообщает об успешном завершении сразу, как
только транзакция будет завершена логически, прежде чем сгенерированные записи WAL факти-
чески будут записаны на диск. Это может значительно увеличить производительность при выпол-
нении небольших транзакций.
Асинхронное подтверждение транзакций приводит к риску потери данных. Существует короткое
окно между отчётом о завершении транзакции для клиента и временем, когда транзакция реаль-
но подтверждена (т. е. гарантируется, что она не будет потеряна в случае краха сервера). Таким
образом, асинхронное подтверждение транзакций не должно использоваться, если клиент будет
выполнять внешние действия, опираясь на предположение, что транзакция будет сохранена. На-
пример, банк конечно не должен использовать асинхронное подтверждение для транзакций в бан-
коматах, выдающих наличные. Но во многих случаях, таких как журналирование событий, столь
серьёзная гарантия сохранности данных не нужна.
Риск потери данных при использовании асинхронного подтверждения транзакций — это не риск
повреждения данных. Если случился крах СУБД, она будет восстановлена путём воспроизведения
WAL до последней записи, которая была записана на диск. Таким образом, будет восстановлено
целостное состояние СУБД, но любые транзакции, которые ещё не были сохранены на диск, в этом
состоянии не будут отражены. Чистый эффект будет заключаться в потере нескольких последних
транзакций. Поскольку транзакции воспроизводятся в том же порядке, в котором подтверждались,
воспроизведение не нарушает целостность — например, если транзакция “B” выполнила измене-
ния, которые влияют на предыдущую транзакцию “A”, то не может быть такого, что изменения,
выполненные “A” были потеряны, а изменения, внесённые “B” сохранены.
Пользователь может выбрать режим подтверждения для каждой транзакции, так что возможен
конкурентный запуск транзакций в синхронном и асинхронном режиме. Это позволяет достичь
гибкого компромисса между производительностью и конечно надёжностью транзакций. Режим
подтверждения транзакций управляется параметром synchronous_commit, который может быть из-
менён любым из способов, пригодным для установки параметров конфигурации. Режим, исполь-
зуемый для какой-либо конкретной транзакции, зависит от значения synchronous_commit, которое
действует на момент начала этой транзакции.
Некоторые команды, например DROP TABLE, принудительно запускают синхронное подтверждение
транзакции, независимо от значения synchronous_commit. Это сделано для того, чтобы иметь уве-
ренность в целостности данных между файловой системой сервера и логическим состоянием ба-
зы данных. Команды, которые поддерживают двухфазное подтверждение транзакций, такие как
PREPARE TRANSACTION, также всегда синхронные.
Если во время окна риска между асинхронным подтверждением транзакции и сохранением на
диск записей WAL, происходит крах СУБД, то изменения, сделанные во время этой транзак-
ции будут потеряны. Продолжительность окна риска ограничена, потому что фоновый процесс
(«WAL writer»), сохраняет не записанные записи WAL на диск каждые wal_writer_delay миллисе-
кунд. Фактически, максимальная продолжительность окна риска составляет трёхкратное значе-
ние wal_writer_delay, потому что WAL writer разработан так, чтобы сразу сохранять целые стра-
ницы во время периодов занятости.
730Надёжность и журнал предзаписи
Внимание
Режим немедленного завершения работы (immediate) эквивалентен краху сервера и
приведёт, таким образом, к потере всех не сохранённых асинхронных транзакций.
Асинхронное подтверждение транзакций предоставляет поведение, которое отличается от того,
что соответствует установке параметра fsync = off. Настройка fsync касается всего сервера и мо-
жет изменить поведение всех транзакций. Она выключает всю логику внутри PostgreSQL, которая
пытается синхронизировать запись отдельных порций в базу данных и, таким образом, крах си-
стемы (обусловленный отказом аппаратного обеспечения или операционной системы, который не
является сбоем самой СУБД PostgreSQL ) может в результате привести к повреждению состояния
базы данных. Во многих случаях, асинхронное подтверждение транзакций предоставляет лучшую
производительность, чем то, что можно получить выключением fsync, но без риска повреждения
данных.
commit_delay также выглядит очень похоже на асинхронное подтверждение транзакций, но по су-
ти это является методом асинхронного подтверждения транзакций (фактически, во время асин-
хронных транзакций commit_delay игнорируется). commit_delay приводит к задержке только пе-
ред тем, как синхронная транзакция пытается записать данные WAL на диск, в надежде, что оди-
ночная запись, выполняемая на одну такую транзакцию, сможет также обслужить другие транзак-
ции, которые подтверждаются приблизительно в это же время. Установку этого параметра мож-
но рассматривать как способ увеличения промежутка времени, в течение которого транзакции
группируются для единовременной записи на диск. Это распределяет стоимость записи между
несколькими транзакциями.
30.4. Настройка WAL
Существует несколько конфигурационных параметров относящихся к WAL, которые влияют на
производительность СУБД. Далее рассказывается об их использовании. Общую информацию об
установке параметров конфигурации сервера смотрите в Главе 19.
Контрольные точки— это точки в последовательности транзакций, в которых гарантируется, что
файлы с данными и индексами были обновлены всей информацией записанной перед контрольной
точкой. Во время контрольной точки, все страницы данных, находящиеся в памяти, сохраняются
на диск, а в файл журнала записывается специальная запись контрольной точки. (Сделанные из-
менения были перед этим записаны в файлы WAL.) В случае краха процедура восстановления ищет
последнюю запись контрольной точки, чтобы определить эту точку в журнале (называемую запи-
сью REDO), от которой процедура должна начать операцию воспроизведения изменений. Любые
изменения файлов данных перед этой точкой гарантированно находятся уже на диске. Таким об-
разом, после контрольной точки, сегменты журнала, которые предшествуют записи воспроизве-
дения, больше не нужны и могут быть удалены или пущены в циклическую перезапись. (Когда ар-
хивирование WAL будет завершено, сегменты журнала должны быть архивированы перед их уда-
лением или циклической перезаписи.)
Запись всех страниц данных из памяти на диск, которая требуется для контрольной точки, может
вызвать значительную нагрузку на дисковый ввод/вывод. По этой причине, активность записи по
контрольной точке регулируется так, что ввод/вывод начинается при старте контрольной точки и
завершается перед стартом следующей контрольной точки; это минимизирует потерю производи-
тельности во время прохождения контрольных точек.
Отдельный серверный процесс контрольных точек автоматически выполняет контрольные точки
с заданной частотой. Контрольные точки производятся каждые checkpoint_timeout секунд либо
при приближении к пределу max_wal_size, если это имеет место раньше. Значения по умолча-
нию: 5 минут и 1 Гбайт, соответственно. Если после предыдущей контрольной точки новые записи
WAL не добавились, следующие контрольные точки будут пропущены, даже если проходит время
checkpoint_timeout. (Если вы применяете архивацию WAL и хотите установить нижний предел
для частоты архивации, чтобы ограничить потенциальную потерю данных, вам следует настраи-
731Надёжность и журнал предзаписи
вать параметр archive_timeout, а не параметры контрольных точек.) Также можно выполнить кон-
трольную точку принудительно, воспользовавшись SQL-командой CHECKPOINT.
Уменьшение значений checkpoint_timeout и/или max_wal_size приводит к учащению контроль-
ных точек. Это позволяет ускорить восстановление после краха (поскольку для воспроизведения
нужно меньше данных), но с другой стороны нужно учитывать дополнительную нагрузку, возни-
кающую вследствие более частого сброса изменённых страниц данных на диск. Если включён ре-
жим full_page_writes (по умолчанию это так), нужно учесть и ещё один фактор. Для обеспечения
целостности страницы данных, при первом изменении страницы данных после контрольной точки
эта страница записывается в журнал целиком. В данном случае, чем меньше интервал между кон-
трольными точками, тем больше объём записи в журнал WAL, так что это частично дискредитиру-
ет идею уменьшения интервала записи, и в любом случае приводит к увеличению объёма обмена
с диском
Контрольные точки довольно дороги с точки зрения ресурсов, во-первых, потому что они требу-
ют записи всех буферов из памяти на диск, и во-вторых потому что они создают дополнительный
трафик WAL, о чём говорилось выше. Таким образом, будет благоразумным установить параметры
контрольных точек так, чтобы контрольные точки не выполнялись слишком часто. Для простой
проверки параметров контрольной точки можно установить параметр checkpoint_warning. Если
промежуток времени между контрольными точками будет меньше чем количество секунд, задан-
ное параметром checkpoint_warning, то в журнал сервера будет выдано сообщение с рекомен-
дацией увеличить max_wal_size. Эпизодическое появление такого сообщения не является пово-
дом для беспокойства. Но если оно появляется часто, необходимо увеличить значения парамет-
ров управления контрольными точками. Массовые операции, такие как COPY с большим объёмом
данных, могут привести к появлению нескольких таких предупреждений, если вы не установили
max_wal_size достаточно большим.
Чтобы избежать «заваливания» системы ввода/вывода при резкой интенсивной записи страниц, за-
пись «грязных» буферов во время контрольной точки растягивается на определённый период вре-
мени. Этот период управляется параметром checkpoint_completion_target, который задаётся как
часть интервала контрольной точки. Скорость ввода/вывода подстраивается так, чтобы контроль-
ная точка завершилась к моменту истечения заданной части от checkpoint_timeout секунд или до
превышения max_wal_size, если оно имеет место раньше. Со значением 0.5, заданным по умолча-
нию, можно ожидать, что PostgreSQL завершит процедуру контрольной точки примерно за поло-
вину времени до начала следующей. В системе, которая работает практически на пределе мощно-
сти ввода/вывода в обычном режиме, есть смысл увеличить checkpoint_completion_target, чтобы
уменьшить нагрузку ввода/вывода, связанную с контрольными точками. Но с другой стороны, рас-
тягивание контрольных точек влияет на время восстановления, так как для восстановления нужно
будет задействовать большее количество сегментов WAL. Хотя в checkpoint_completion_target
можно задать значение вплоть до 1.0, лучше выбрать значение меньше (по крайней мере, не боль-
ше 0.9), так как при контрольных точках выполняются и некоторые другие операции, помимо за-
писи «грязных» буферов. Со значением 1.0 контрольные точки, скорее всего, не будут завершать-
ся вовремя, что приведёт к потере производительности из-за неожиданных колебаний требуемого
количества сегментов WAL.
На платформах Linux и POSIX параметр checkpoint_flush_after позволяет принудить ОС к сбросу
страниц, записываемых во время контрольной точки, при накоплении заданного количества байт.
Если его не настроить, эти страницы могут оставаться в кеше страниц ОС, что повлечёт заторма-
живание при выполнении fsync в конце контрольной точки. Этот параметр часто помогает умень-
шить задержки транзакций, но может оказать и негативное влияние на производительность; осо-
бенно, когда объём нагрузки больше shared_buffers, но меньше кеша страниц в ОС.
Число файлов сегментов WAL в каталоге pg_wal зависит от min_wal_size, max_wal_size и объёма
WAL, сгенерированного в предыдущих циклах контрольных точек. Когда старые файлы сегментов
оказываются не нужны, они удаляются или перерабатываются (то есть переименовываются, чтобы
стать будущими сегментами в нумерованной последовательности). Если вследствие кратковремен-
ного скачка интенсивности записи в журнал, предел max_wal_size превышается, ненужные файлы
сегментов будут удаляться, пока система не опустится ниже этого предела. Оставаясь ниже этого
предела, система перерабатывает столько файлов WAL, сколько необходимо для покрытия ожида-
732Надёжность и журнал предзаписи
емой потребности до следующей контрольной точки, и удаляет остальные. Эта оценка базируется
на скользящем среднем числа файлов WAL, задействованных в предыдущих циклах контрольных
точек. Скользящее среднее увеличивается немедленно, если фактическое использование превы-
шает оценку, так что в нём в некоторой степени накапливается пиковое использование, а не сред-
нее. Значение min_wal_size ограничивает снизу число файлов WAL, которые будут переработаны
для будущего использования; такой объём WAL всегда будет перерабатываться, даже если система
простаивает и оценка использования говорит, что нужен совсем небольшой WAL.
Вне зависимости от max_wal_size, в количестве wal_keep_segments + 1 самые последние файлы
WAL сохраняются в любом случае. Так же, если применяется архивация WAL, старые сегменты не
могут быть удалены или переработаны, пока они не будут заархивированы. Если WAL архивирует-
ся медленнее, чем генерируется, либо если команда archive_command постоянно даёт сбои, старые
файлы WAL будут накапливаться в pg_wal, пока ситуация не будет разрешена. Медленно работа-
ющий или отказавший ведомый сервер, использующий слот репликации, даст тот же эффект (см.
Подраздел 26.2.6).
В режиме восстановления архива или горячего резерва сервер периодически выполняет точки
перезапуска, которые похожи на контрольные точки в обычном режиме работы: сервер принуди-
тельно сбрасывает своё состояние на диск, обновляет файл pg_control, чтобы показать, что уже
обработанные данные WAL не нужно сканировать снова, и затем перерабатывает все старые файлы
сегментов журнала в каталоге pg_wal. Точки перезапуска не могут выполняться чаще, чем кон-
трольные точки на главном сервере, так как они могут происходить только в записях контроль-
ных точек. Точка перезапуска производится, когда достигается запись контрольной точки и по-
сле предыдущей точки перезапуска прошло не меньше checkpoint_timeout секунд или размер
WAL может превысить max_wal_size. Однако из-за того, что на время выполнения точек переза-
пуска накладываются ограничения, max_wal_size часто превышается при восстановлении, вплоть
до объёма WAL, записываемого в цикле между контрольными точками. (Значение max_wal_size
никогда и не было жёстким пределом, так что всегда следует оставлять приличный запас сверху,
чтобы не остаться без свободного места на диске.)
Наиболее часто используются две связанные с WAL внутренние функции: XLogInsertRecord и
XLogFlush. XLogInsertRecord применяется для добавления записи в буферы WAL в разделяе-
мой памяти. Если места для новой записи недостаточно, XLogInsertRecord придётся записать
(переместить в кеш ядра) несколько заполненных буферов WAL. Это нежелательно, так как
XLogInsertRecord используется при каждом изменении в базе данных на низком уровне (напри-
мер, при добавлении строки) в момент, когда установлена исключительная блокировка задейство-
ванных страниц данных, поэтому данная операция должна быть максимально быстрой. Что ещё
хуже, запись буферов WAL может также повлечь создание нового сегмента журнала, что займёт
ещё больше времени. Обычно буферы WAL должны записываться и сохраняться на диске в функ-
ции XLogFlush, которая вызывается, по большей части, при фиксировании транзакции, чтобы ре-
зультаты транзакции сохранились в надёжном хранилище. В системах с интенсивной записью в
журнал вызовы XLogFlush могут иметь место не так часто, чтобы XLogInsertRecord не приходилось
производить запись. В таких системах следует увеличить число буферов WAL, изменив параметр
wal_buffers. Когда включён режим full_page_writes и система очень сильно загружена, увеличение
wal_buffers поможет сгладить скачки во времени ответа в период сразу после каждой контроль-
ной точки.
Параметр commit_delay определяет, на сколько микросекунд будет засыпать ведущий процесс
группы, записывающий в журнал, после получения блокировки в XLogFlush, пока подчинённые
формируют очередь на запись. Во время этой задержки другие серверные процессы смогут добав-
лять записи в WAL буферы журнала, чтобы все эти записи сохранились на диск в результате одной
операции синхронизации, которую выполнит ведущий. Ведущий процесс не засыпает, если отклю-
чён режим fsync, либо число сеансов с активными транзакциями меньше commit_siblings, так как
маловероятно, что какой-либо другой сеанс зафиксирует транзакцию в ближайшее время. Заметь-
те, что на некоторых платформах, разрешение этого таймера сна составляет 10 миллисекунд, так
что любое значение параметра commit_delay от 1 до 10000 микросекунд будет действовать одина-
ково. Кроме того, в некоторых системах состояние сна может продлиться несколько дольше, чем
требует параметр.
733Надёжность и журнал предзаписи
Так как цель commit_delay состоит в том, чтобы позволить стоимости каждой операции син-
хронизации амортизироваться через параллельную фиксацию транзакций (потенциально за счёт
задержки транзакции), необходимо определить количество той стоимости, прежде чем урегу-
лирование сможет быть выбрано разумно. Чем выше стоимость, тем более эффективный будет
commit_delay в увеличении пропускной способности транзакций в какой-то степени. Программа
pg_test_fsync может использоваться, чтобы измерить среднее время в микросекундах, которое за-
нимает одиночная работа сброса WAL на диск. Значение половины среднего времени сообщаемого
программой рекомендуется в качестве отправной точки для использования значения в параметре
commit_delay при оптимизации для конкретного объёма работы, и говорит о том, сколько нужно
времени для синхронизации сброса единственной операции записи 8 КБ. Настройка параметра
commit_delay особенно полезна в случае хранения WAL в хранилище с высокоскоростными диска-
ми, такими как твердотельные накопители (SSD) или RAID-массивы с кешем записи и аварийным
питанием на батарее; но это определённо должно тестироваться на репрезентативной рабочей
нагрузке. Более высокие значения commit_siblings должны использоваться в таких случаях, то-
гда как меньшие значения commit_siblings часто полезны на носителях с большими задержками.
Обратите внимание на то, что увеличение значения параметра commit_delay может увеличить за-
держку транзакции настолько, что пострадает общая производительность транзакций.
Даже если commit_delay равен нулю (значение по умолчанию), групповая фиксация все равно мо-
жет произойти, но группа будет состоять только из тех сеансов, которым понадобилось сбросить
записи о фиксации на диск за то время, пока происходил предыдущий сброс. Чем больше сеансов,
тем чаще это происходит даже при нулевом commit_delay, поэтому увеличение этого параметра
может и не оказать заметного действия. Установка commit_delay имеет смысл в двух случаях: (1)
когда несколько транзакций одновременно фиксируют изменения, (2) либо когда частота фикса-
ций ограничена пропускной способностью дисковой подсистемы. Однако при задержке из-за низ-
кой скорости вращения диска, эта настройка может оказаться полезной даже всего при двух се-
ансах.
Параметр wal_sync_method определяет, как PostgreSQL будет обращаться к ядру, чтобы принуди-
тельно сохранить WAL на диск. Все методы должны быть одинаковыми в плане надёжности, за
исключением fsync_writethrough, который может иногда принудительно сбрасывать кеш диска,
даже если другие методы не делают этого. Однако, какой из них самый быстрый, во многом опре-
деляется платформой; вы можете протестировать скорость, используя модуль pg_test_fsync. Обра-
тите внимание, что данный параметр не имеет значения, если fsync выключен.
Включение параметра конфигурации wal_debug (предоставляется, если PostgreSQL был скомпи-
лирован с его поддержкой) будет приводить к тому, что все вызовы связанных с WAL функций
XLogInsertRecord и XLogFlush будут протоколироваться в журнале сервера. В будущем данный
параметр может быть заменён более общим механизмом.
30.5. Внутреннее устройство WAL
WAL включается автоматически; от администратора не требуется никаких действий за исключе-
нием того, чтобы убедиться, что выполнены требования WAL к месту на диске, и что выполнены
все необходимые действия по тонкой настройке (см. Раздел 30.4).
Записи WAL добавляются в журналы WAL по мере поступления. Позицию добавления в журнал
определяет значение LSN (Log Sequence Number, Последовательный номер в журнале), представ-
ляющее собой смещение в байтах внутри журнала, монотонно увеличивающееся с каждой новой
записью. Значения LSN возвращаются с типом данных pg_lsn. Сравнивая эти значения, можно
вычислить объём данных WAL между ними, так что они могут быть полезны для вычисления про-
гресса при репликации и восстановлении.
Журналы WAL хранятся в виде набора файлов сегментов в каталоге pg_wal, который находится
в каталоге данных. Эти файлы обычно имеют размер 16 Мбайт каждый (его можно изменить, пе-
редав initdb другое значение в –wal-segsize). Каждый файл сегмента разделяется на страницы,
обычно по 8 Кбайт каждая (данный размер может быть изменён указанием configure –with-wal-
blocksize). Заголовки записей журнала описываются в access/xlogrecord.h; содержимое самой
734Надёжность и журнал предзаписи
записи зависит от типа события, которое сохраняется в журнале. Файлы сегментов имеют име-
на-номера, которые начинаются с 000000010000000000000000 и увеличиваются автоматически. За-
цикливание этих номеров не предусмотрено, но для использования всех доступных номеров потре-
буется очень, очень много времени.
Выгодно размещать журналы WAL на другом диске, отличном от того, где находятся основные фай-
лы базы данных. Для этого можно переместить каталог pg_wal в другое место (разумеется, когда
сервер остановлен) и создать символьную ссылку из исходного места на перемещённый каталог.
Для WAL важно, чтобы запись в журнал выполнялась до изменений данных в базе. Но этот порядок
могут нарушить дисковые устройства, которые ложно сообщают ядру об успешном завершении
записи, хотя фактически они только выполнили кеширование данных и пока не сохранили их на
диск. Сбой питания в такой ситуации может привести к неисправимому повреждению данных.
Администраторы должны убедиться, что диски, где хранятся файлы журналов WAL PostgreSQL, не
выдают таких ложных сообщений ядру. (См. Раздел 30.1.)
После выполнения контрольной точки и сброса журнала позиция контрольной точки сохраня-
ется в файл pg_control. Таким образом, при старте восстановления сервер сперва читает файл
pg_control и затем запись контрольной точки; затем он выполняет операцию REDO, сканируя впе-
рёд от позиции в журнале, обозначенной в записи контрольной точки. Поскольку полное содержи-
мое страниц данных сохраняется в журнале в первой странице после контрольной точки (предпо-
лагается, что включён режим full_page_writes), все страницы, изменённые с момента контрольной
точки, будут восстановлены в целостном состоянии.
В случае, если файл pg_control повреждён, мы должны поддерживать возможность сканирования
существующих сегментов журнала в обратном порядке — от новых к старым — чтобы найти по-
следнюю контрольную точку. Это пока не реализовано. pg_control является достаточно малень-
ким файлом (меньше, чем одна дисковая страница), который не должен попадать под проблему
частичной записи и на момент написания данной документации, не было ни одного сообщения
о сбоях СУБД исключительно из-за невозможности чтения самого файла pg_control. Таким обра-
зом, хотя теоретически это является слабым местом, на практике проблем с pg_control не обна-
ружено.
735</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page16/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page15/">15</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page16/">16</a></li>
      
    
      
        <li><strong class="current-page">17</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page18/">18</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page19/">19</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page18/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>