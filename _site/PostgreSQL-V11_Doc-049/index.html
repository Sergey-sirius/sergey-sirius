<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 49. Логическое декодирование &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 49. Логическое декодирование">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 49. Логическое декодирование">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-049/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-049/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 49. Логическое декодирование">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-049/" rel="bookmark" title="Глава 49. Логическое декодирование">Глава 49. Логическое декодирование</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~13 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 49. Логическое декодирование</p>

<p>PostgreSQL обеспечивает инфраструктуру для потоковой передачи изменений, выполняемых че-
рез SQL, внешним потребителям. Эта функциональность может быть полезна для самых разных
целей, включая аудит и реализацию репликации.
Изменения передаются в потоках, связываемых со слотами логической репликации.
Формат, в котором передаются изменения, определяет используемый модуль вывода. Пример мо-
дуля вывода включён в дистрибутив PostgreSQL. Также возможно разработать и другие модули,
расширяющие выбор доступных форматов, не затрагивая код ядра самого сервера. Любой модуль
вывода получает на вход отдельные строки, создаваемые командой INSERT, и новые версии строк,
которые создаёт UPDATE. Доступность старых версий строк для UPDATE и DELETE зависит от выбора
варианта идентификации реплики (см. описание REPLICA IDENTITY).
Изменения могут быть получены либо по протоколу потоковой репликации (см. Раздел 53.4 и Раз-
дел 49.3), либо через функции, вызываемые в SQL (см. Раздел 49.4). Также возможно разработать
дополнительные методы для обработки данных, поступающих через слот репликации, не модифи-
цируя код ядра сервера (см. Раздел 49.7).
49.1. Примеры логического декодирования
Следующий пример демонстрирует управление логическим декодированием на уровне SQL.
Прежде чем вы сможете использовать логическое декодирование, вы должны установить в
wal_level значение logical, а в max_replication_slots значение, не меньшее 1. После этого вы долж-
ны подключиться к целевой базе данных (в следующем примере, это postgres) как суперпользо-
ватель.
postgres=# – Создать слот с именем ‘regression_slot’, использующий модуль вывода
‘test_decoding’
postgres=# SELECT * FROM pg_create_logical_replication_slot(‘regression_slot’,
‘test_decoding’);
slot_name
|
lsn
—————–+———–
regression_slot | 0/16B1970
(1 row)
postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn,
confirmed_flush_lsn FROM pg_replication_slots;
slot_name
|
plugin
| slot_type | database | active | restart_lsn |
confirmed_flush_lsn
—————–+—————+———–+———-+——–+————-
+—————–
regression_slot | test_decoding | logical
| postgres | f
| 0/16A4408
|
0/16A4440
(1 row)
postgres=# – Пока никакие изменения не видны
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
lsn | xid | data
—–+—–+——
(0 rows)
postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE
postgres=# – DDL не реплицируется, поэтому видна только транзакция
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
1289Логическое декодирование
lsn
| xid |
data
———–+——-+————–
0/BA2DA58 | 10297 | BEGIN 10297
0/BA5A5A0 | 10297 | COMMIT 10297
(2 rows)
postgres=# – Когда изменения прочитаны, они считаются обработанными и уже не выдаются
postgres=# – в последующем вызове:
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
lsn | xid | data
—–+—–+——
(0 rows)
postgres=#
postgres=#
postgres=#
postgres=#
BEGIN;
INSERT INTO data(data) VALUES(‘1’);
INSERT INTO data(data) VALUES(‘2’);
COMMIT;
postgres=# SELECT * FROM pg_logical_slot_get_changes(‘regression_slot’, NULL, NULL);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A688 | 10298 | BEGIN 10298
0/BA5A6F0 | 10298 | table public.data: INSERT: id[integer]:1 data[text]:’1’
0/BA5A7F8 | 10298 | table public.data: INSERT: id[integer]:2 data[text]:’2’
0/BA5A8A8 | 10298 | COMMIT 10298
(4 rows)
postgres=# INSERT INTO data(data) VALUES(‘3’);
postgres=# – Также можно заглянуть вперёд в потоке изменений, не считывая эти
изменения
postgres=# SELECT * FROM pg_logical_slot_peek_changes(‘regression_slot’, NULL, NULL);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A8E0 | 10299 | BEGIN 10299
0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:’3’
0/BA5A990 | 10299 | COMMIT 10299
(3 rows)
postgres=# – Следующий вызов pg_logical_slot_peek_changes() снова возвращает те же
изменения
postgres=# SELECT * FROM pg_logical_slot_peek_changes(‘regression_slot’, NULL, NULL);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A8E0 | 10299 | BEGIN 10299
0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:’3’
0/BA5A990 | 10299 | COMMIT 10299
(3 rows)
postgres=# – Модулю вывода можно передать параметры, влияющие на форматирование
postgres=# SELECT * FROM pg_logical_slot_peek_changes(‘regression_slot’, NULL, NULL,
‘include-timestamp’, ‘on’);
lsn
| xid |
data
———–+——-+———————————————————
0/BA5A8E0 | 10299 | BEGIN 10299
0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:’3’
0/BA5A990 | 10299 | COMMIT 10299 (at 2017-05-10 12:07:21.272494-04)
(3 rows)
1290Логическое декодирование
postgres=# – Не забудьте удалить слот, который вам больше не нужен, чтобы он
postgres=# – не потреблял ресурсы сервера:
postgres=# SELECT pg_drop_replication_slot(‘regression_slot’);
pg_drop_replication_slot
———————–
(1 row)
Следующий пример показывает, как можно управлять логическим декодированием средствами
протокола потоковой репликации, используя программу pg_recvlogical, включённую в дистрибутив
PostgreSQL. Для этого нужно, чтобы конфигурация аутентификации клиентов допускала подклю-
чения для репликации (см. Подраздел 26.2.5.1) и чтобы значение max_wal_senders было достаточ-
но большим и позволило установить дополнительное подключение.
$ pg_recvlogical -d postgres –slot=test –create-slot
$ pg_recvlogical -d postgres –slot=test –start -f -
Control+Z
$ psql -d postgres -c “INSERT INTO data(data) VALUES(‘4’);”
$ fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:’4’
COMMIT 693
Control+C
$ pg_recvlogical -d postgres –slot=test –drop-slot
49.2. Концепции логического декодирования
49.2.1. Логическое декодирование
Логическое декодирование — это процедура извлечения всех постоянных изменений, происходя-
щих в таблицах базы данных, в согласованном и понятном формате, который можно интерпрети-
ровать, не имея полного представления о внутреннем состоянии базы данных.
В PostgreSQL логическое декодирование реализуется путём перевода содержимого журнала пред-
записи, описывающего изменения на уровне хранения, в специальную форму уровня приложения,
например, в поток кортежей или операторов SQL.
49.2.2. Слоты репликации
В контексте логической репликации слот представляет поток изменений, которые могут быть вос-
произведены клиентом в том порядке, в каком они происходили на исходном сервере. Через каж-
дый слот передаётся последовательность изменений в одной базе данных.
Примечание
В PostgreSQL также есть слоты потоковой репликации (см. Подраздел 26.2.5), но они
используются несколько по-другому.
Слоту репликации назначается идентификатор, уникальный для всех баз данных в кластере
PostgreSQL. Слоты сохраняются независимо от подключений, использующих их, и защищены от
сбоев сервера.
При обычных условиях через логический слот каждое изменение передаётся только один раз. Те-
кущая позиция в каждом слоте сохраняется только в контрольной точке, так что в случае сбоя
слот может вернуться к предыдущему LSN, вследствие чего последние изменения могут быть пе-
реданы повторно при перезапуске сервера. За исключение нежелательных эффектов от повторной
обработки одного и того же сообщения отвечают клиенты логического декодирования. Клиенты
1291Логическое декодирование
могут запоминать при декодировании, какой последний LSN они уже получали, и пропускать по-
вторяющиеся данные или (при использовании протокола репликации) запрашивать, чтобы деко-
дирование начиналось с этого LSN, а не с позиции, выбираемой сервером. Для этого разработан
механизм отслеживания репликации, о котором можно узнать подробнее в описании источников
репликации.
Для одной базы данных могут существовать несколько независимых слотов. Каждый слот имеет
собственное состояние, что позволяет различным потребителям получать изменения с разных по-
зиций в потоке изменений базы данных. Для большинства приложений каждому потребителю тре-
буется отдельный слот.
Слот логической репликации ничего не знает о состоянии получателя(ей). Возможно даже иметь
несколько различных потребителей одного слота в разные моменты времени; они просто будут
получать изменения с момента, когда их перестал получать предыдущий потребитель. Но в любой
определённый момент получать изменения может только один потребитель.
Внимание
Слоты репликации сохраняются при сбоях сервера и ничего не знают о состоянии их
потребителя. Они не дают удалять требуемые ресурсы, даже когда не используются ни-
каким подключением. На это уходит место в хранилище, так как ни сегменты WAL, ни
требуемые строки из системных каталогов нельзя будет удалить в результате VACUUM,
пока они нужны этому слоту репликации. В особых случаях это может привести к от-
ключению базы для предотвращения зацикливания идентификаторов транзакций (см.
Подраздел  24.1.5). Поэтому, если слот больше не требуется, его следует ликвидиро-
вать.
49.2.3. Модули вывода
Модули вывода переводят данные из внутреннего представления в журнале предзаписи в формат,
устраивающий потребителя слота репликации.
49.2.4. Экспортированные снимки
Когда новый слот репликации создаётся через интерфейс потоковой репликации, экспортирует-
ся снимок (см. CREATE_REPLICATION_SLOT), который будет показывать ровно то состояние базы
данных, изменения после которого будут включаться в поток изменений. Используя его, можно
создать новую реплику, воспользовавшись командой SET TRANSACTION SNAPSHOT, чтобы получить
состояние базы в момент создания слота. После этого данную транзакцию можно использовать для
выгрузки состояния базы на момент экспорта снимка, а затем изменять это состояние, применяя
содержимое слота, так что никакие изменения не будут потеряны.
Создание снимка возможно не всегда. В частности, невозможно создать снимок при подключении
к горячему резерву. Приложения, которым не требуется экспорт снимка, могут подавить его, вос-
пользовавшись указанием NOEXPORT_SNAPSHOT.
49.3. Интерфейс протокола потоковой репликации
Команды
• CREATE_REPLICATION_SLOT имя_слота LOGICAL модуль_вывода
• DROP_REPLICATION_SLOT имя_слота [ WAIT ]
• START_REPLICATION SLOT имя_слота LOGICAL …
применяются для создания, удаления и передачи изменений из слота репликации, соответственно.
Эти команды доступны только для соединения репликации; их нельзя использовать в обычном
SQL. Подробнее они описаны в Разделе 53.4.
1292Логическое декодирование
Для управления логическим декодированием по соединению потоковой репликации можно при-
менять программу pg_recvlogical. (Внутри неё используются эти команды.)
49.4. Интерфейс логического декодирования на уров-
не SQL
Подробнее API уровня SQL для взаимодействия с механизмом логическим декодированием описан
в Подразделе 9.26.6.
Синхронная репликация (см. Подраздел  26.2.8) поддерживается только для слотов репликации,
которые используются через интерфейс потоковой репликации. Интерфейс функций и дополни-
тельные, не системные интерфейсы не поддерживают синхронную репликацию.
49.5. Системные каталоги, связанные с логическим де-
кодированием
Информацию о текущем состоянии слотов репликации и соединений потоковой репликации отоб-
ражают представления pg_replication_slots и pg_stat_replication, соответственно. Эти пред-
ставления относятся и к физической, и к логической репликации.
49.6. Модули вывода логического декодирования
Пример модуля вывода можно найти в подкаталоге contrib/test_decoding в дереве исходного
кода PostgreSQL.
49.6.1. Функция инициализации
Модуль вывода загружается в результате динамической загрузки разделяемой библиотеки
(при этом в качестве имени библиотеки задаётся имя модуля). Для нахождения библиоте-
ки применяется обычный путь поиска библиотек. В этой библиотеке должна быть функция
_PG_output_plugin_init, которая показывает, что библиотека на самом деле представляет собой
модуль вывода, и устанавливает требуемые обработчики модуля вывода. Этой функции передаёт-
ся структура, в которой должны быть заполнены указатели на функции-обработчики отдельных
действий.
typedef struct OutputPluginCallbacks
{
LogicalDecodeStartupCB startup_cb;
LogicalDecodeBeginCB begin_cb;
LogicalDecodeChangeCB change_cb;
LogicalDecodeTruncateCB truncate_cb;
LogicalDecodeCommitCB commit_cb;
LogicalDecodeMessageCB message_cb;
LogicalDecodeFilterByOriginCB filter_by_origin_cb;
LogicalDecodeShutdownCB shutdown_cb;
} OutputPluginCallbacks;
typedef void (<em>LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);
Обработчики begin_cb, change_cb и commit_cb должны устанавливаться обязательно, а
startup_cb, filter_by_origin_cb, truncate_cb и shutdown_cb могут отсутствовать. Если
truncate_cb не установлен, но потребуется декодировать операцию TRUNCATE, она будет проигно-
рирована.
49.6.2. Возможности
Для декодирования, форматирования и вывода изменений модули вывода могут использовать
практически всю обычную инфраструктуру сервера, включая вызов функций вывода типов. К от-
ношениям разрешается доступ только на чтение, если только эти отношения были созданы про-
1293Логическое декодирование
граммой initdb в схеме pg_catalog, либо помечены как пользовательские таблицы каталогов ко-
мандами
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
Любые действия, которые требуют присвоения идентификатора транзакции, запрещаются. В
частности, к этим действиям относятся операции записи в таблицы, изменения DDL и вызов
txid_current().
49.6.3. Режимы вывода
Обработчики в модуле вывода могут передавать данные потребителю в практически любых фор-
матах. Для некоторых вариантов использования, например, просмотра изменений через SQL,
вывод информации в типах, которые могут содержать произвольные данные (например, bytea),
может быть неудобоваримым. Если модуль вывода выводит только текстовые данные в коди-
ровке сервера, он может объявить это, установив в OutputPluginOptions.output_type значение
OUTPUT_PLUGIN_TEXTUAL_OUTPUT вместо OUTPUT_PLUGIN_BINARY_OUTPUT в обработчике запуска. В
этом случае все данные должны быть в кодировке сервера, чтобы их можно было передать в зна-
чении типа text. Это контролируется в сборках с включёнными проверочными утверждениями.
49.6.4. Обработчики в модуле вывода
Модуль вывода уведомляется о происходящих изменениях через различные обработчики, которые
он должен установить.
Параллельные транзакции декодируются в порядке фиксирования, при этом только изменения,
относящиеся к определённой транзакции, декодируются между вызовами обработчиков begin и
commit. Транзакции, отменённые явно или неявно, никогда не декодируются. Успешные точки со-
хранения заворачиваются в транзакцию, содержащую их, в том порядке, в како они выполнялись
в этой транзакции.
Примечание
Декодироваться будут только те транзакции, которые уже успешно сброшены на диск.
Вследствие этого, COMMIT может не декодироваться в следующем сразу за ним вызове
pg_logical_slot_get_changes(), когда synchronous_commit имеет значение off.
49.6.4.1. Обработчик запуска
Необязательный обработчик startup_cb вызывается, когда слот репликации создаётся или через
него запрашивается передача изменений, независимо от того, в каком количестве изменения го-
товы к передаче.
typedef void (</em>LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
OutputPluginOptions *options,
bool is_init);
Параметр is_init будет равен true, когда слот репликации создаётся, и false в противном случае.
Параметр options указывает на структуру параметров, которые могут устанавливать модули вы-
вода:
typedef struct OutputPluginOptions
{
OutputPluginOutputType output_type;
bool
receive_rewrites;
} OutputPluginOptions;
В
поле
output_type
должно
быть
значение
OUTPUT_PLUGIN_TEXTUAL_OUTPUT
или
OUTPUT_PLUGIN_BINARY_OUTPUT. См. также Подраздел  49.6.3. Если поле receive_rewrites равно
1294Логическое декодирование
true, модуль вывода также будет вызываться для изменений, связанных с перезаписью кучи при
определённых операциях DDL. Эти изменения представляют интерес для модулей, осуществляю-
щих репликацию DDL, но для их обработки может потребоваться особый подход.
Обработчик
запуска
должен
проверить
параметры,
представленные
в
ctx-</p>
<blockquote>
  <p>output_plugin_options. Если модулю вывода требуется поддерживать состояние, он может со-
хранить его в ctx-&gt;output_plugin_private.
49.6.4.2. Обработчик выключения
Необязательный обработчик shutdown_cb вызывается, когда ранее активный слот репликации пе-
рестаёт использоваться, так что ресурсы, занятые модулем вывода, можно освободить. При этом
слот не обязательно удаляется, прекращается только потоковая передача через него.
typedef void (<em>LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);
49.6.4.3. Обработчик начала транзакции
Обязательный обработчик begin_cb вызывается, когда декодируется начало зафиксированной
транзакции. Прерванные транзакции и их содержимое никогда не декодируется.
typedef void (</em>LogicalDecodeBeginCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn);
Параметр txn содержит метаинформацию о транзакции, в частности её идентификатор и время
её фиксирования.
49.6.4.4. Обработчик завершения транзакции
Обязательный обработчик commit_cb вызывается, когда декодируется фиксирование транзакции.
Перед этим обработчиком будет вызываться обработчик change_cb для всех изменённых строк
(если строки были изменены).
typedef void (</em>LogicalDecodeCommitCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn,
XLogRecPtr commit_lsn);
49.6.4.5. Обработчик изменения
Обязательный обработчик change_cb вызывается для каждого отдельного изменения строки в
транзакции, производимого командами INSERT, UPDATE или DELETE. Даже если команда изменила
несколько строк сразу, этот обработчик будет вызываться для каждой отдельной строки.
typedef void (</em>LogicalDecodeChangeCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn,
Relation relation,
ReorderBufferChange *change);
Параметры ctx и txn имеют то же содержимое, что и для обработчиков begin_cb и commit_cb; до-
полнительный дескриптор отношения relation указывает на отношение, к которому принадлежит
строка, а структура change описывает передаваемое изменение строки.
Примечание
В процессе логического декодирования могут быть обработаны изменения только в
таблицах, не являющихся нежурналируемыми (см. описание UNLOGGED) или временны-
ми (см. описание TEMPORARY или TEMP).
49.6.4.6. Обработчик опустошения
Обработчик truncate_cb вызывается для команды TRUNCATE.
1295Логическое декодирование
typedef void (</em>LogicalDecodeTruncateCB) (struct LogicalDecodingContext <em>ctx,
ReorderBufferTXN *txn,
int nrelations,
Relation relations[],
ReorderBufferChange *change);
Он получает те же параметры, что и change_cb. Но так как операции TRUNCATE в таблицах, свя-
занных внешними ключами, должны выполняться одновременно, данный обработчик получает на
вход не одно отношение, а массив отношений. За подробностями обратитесь к описанию операто-
ра TRUNCATE.
49.6.4.7. Обработчик фильтрации источника
Необязательный обработчик filter_by_origin_cb вызывается, чтобы отметить, интересуют ли мо-
дуль вывода изменения, воспроизводимые из указанного источника (origin_id).
typedef bool (</em>LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext <em>ctx,
RepOriginId origin_id);
В параметре ctx передаётся та же информация, что и для других обработчиков. Чтобы отметить,
что изменения, поступающие из переданного узла, не представляют интереса, модуль должен вер-
нуть true, вследствие чего эти изменения будут фильтроваться; в противном случае он должен вер-
нуть false. Другие обработчики для фильтруемых транзакций и изменений вызываться не будут.
Это полезно при реализации каскадной или разнонаправленной репликации. Фильтрация по ис-
точнику в таких конфигурациях позволяет предотвратить передачу взад-вперёд одних и тех же
изменений. Хотя информацию об источнике можно также извлечь из транзакций и изменений,
фильтрация с помощью этого обработчика гораздо более эффективна.
49.6.4.8. Обработчик произвольных сообщений
Необязательный обработчик message_cb вызывается при получении сообщения логического деко-
дирования.
typedef void (</em>LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,
ReorderBufferTXN *txn,
XLogRecPtr message_lsn,
bool transactional,
const char *prefix,
Size message_size,
const char *message);
Параметр txn содержит метаинформацию о транзакции, включая время её фиксации и её XID. За-
метьте, однако, что в нём может передаваться NULL, когда сообщение нетранзакционное и тран-
закции, в которой было выдано сообщение, ещё не назначен XID. В параметре lsn отмечается по-
зиция сообщения в WAL. Параметр transactional показывает, было ли сообщение передано как
транзакционное. В параметре prefix передаётся некоторый префикс (завершающийся нулём), по
которому текущий модуль может выделять интересующие его сообщения. И наконец, параметр
message содержит само сообщение размером message_size байт.
Необходимо дополнительно позаботиться о том, чтобы префикс, определяющий интересующие мо-
дуль вывода сообщения, был уникальным. Удачным выбором обычно будет имя расширения или
самого модуля вывода.
49.6.5. Функции для формирования вывода
Чтобы действительно вывести данные, модули вывода могут записывать их в буфер StringInfo че-
рез ctx-&gt;out, внутри обработчиков begin_cb, commit_cb или change_cb. Прежде чем записывать
данные в этот буфер, необходимо вызвать OutputPluginPrepareWrite(ctx, last_write), а завер-
шив запись в буфер, нужно вызвать OutputPluginWrite(ctx, last_write), чтобы собственно про-
извести запись. Параметр last_write указывает, была ли эта определённая операция записи по-
следней в данном обработчике.
1296Логическое декодирование
Следующий пример показывает, как вывести данные для потребителя модуля вывода:
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx-&gt;out, “BEGIN %u”, txn-&gt;xid);
OutputPluginWrite(ctx, true);
49.7. Запись вывода логического декодирования
Архитектура сервера позволяет добавлять другие методы вывода для логического декодирования.
За подробностями обратитесь к коду src/backend/replication/logical/logicalfuncs.c. По сути,
необходимо реализовать три функции: одну для чтения WAL, другую для подготовки к записи, и
третью для записи вывода (см. Подраздел 49.6.5).
49.8. Поддержка синхронной репликации для логиче-
ского декодирования
Логическое декодирование может использоваться для реализации синхронной репликации с тем
же внешним интерфейсом, что и синхронная репликация поверх потоковой репликации. Для это-
го потоковая передача данных должна происходить через интерфейс потоковой репликации (см.
Раздел 49.3). Клиенты такой репликации должны посылать сообщения Обновление состояния ре-
зервного сервера (F) (см. Раздел 53.4), как и клиенты потоковой репликации.
Примечание
Синхронная реплика, получающая изменения через логическое декодирование, будет
работать в рамках одной базы данных. Так как synchronous_standby_names в настоящее
время, напротив, устанавливается на уровне сервера, это означает, что этот подход не
будет работать корректно при использовании нескольких баз данных.
1297</p>
</blockquote>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-049/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-049/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-049/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-048/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
