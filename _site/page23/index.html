<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page23/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page23/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-012/" title="Глава 12. Полнотекстовый поиск"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 12. Полнотекстовый поиск"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-012/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~63 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-012/" rel="bookmark" title="Глава 12. Полнотекстовый поиск" itemprop="url">Глава 12. Полнотекстовый поиск</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 12. Полнотекстовый поиск</p>

<p>12.1. Введение
Полнотекстовый поиск (или просто поиск текста) — это возможность находить документы на
естественном языке, соответствующие запросу, и, возможно, дополнительно сортировать их по
релевантности для этого запроса. Наиболее распространённая задача — найти все документы,
содержащие слова запроса, и выдать их отсортированными по степени соответствия запросу.
Понятия запроса и соответствия довольно расплывчаты и зависят от конкретного приложения.
В самом простом случае запросом считается набор слов, а соответствие определяется частотой
слов в документе.
Операторы текстового поиска существуют в СУБД уже многие годы. В PostgreSQL для текстовых
типов данных есть операторы ~, ~*, LIKE и ILIKE, но им не хватает очень важных вещей, которые
требуются сегодня от информационных систем:
• Нет поддержки лингвистического функционала, даже для английского языка. Возможности
регулярных выражений ограничены — они не рассчитаны на работу со словоформами, напри-
мер, подходят и подходить. С ними вы можете пропустить документы, которые содержат под-
ходят, но, вероятно, и они представляют интерес при поиске по ключевому слову подходить.
Конечно, можно попытаться перечислить в регулярном выражении все варианты слова, но
это будет очень трудоёмко и чревато ошибками (некоторые слова могут иметь десятки слово-
форм).
• Они не позволяют упорядочивать результаты поиска (по релевантности), а без этого поиск
неэффективен, когда находятся сотни подходящих документов.
• Они обычно выполняются медленно из-за отсутствия индексов, так как при каждом поиске
приходится просматривать все документы.
Полнотекстовая индексация заключается в предварительной обработке документов и сохране-
нии индекса для последующего быстрого поиска. Предварительная обработка включает следую-
щие операции:
Разбор документов на фрагменты. При этом полезно выделить различные классы фрагмен-
тов, например, числа, слова, словосочетания, почтовые адреса и т. д., которые будут обраба-
тываться по-разному. В принципе классы фрагментов могут зависеть от приложения, но для
большинства применений вполне подойдёт предопределённый набор классов. Эту операцию в
PostgreSQL выполняет анализатор (parser). Вы можете использовать как стандартный анали-
затор, так и создавать свои, узкоспециализированные.
Преобразование фрагментов в лексемы. Лексема — это нормализованный фрагмент, в кото-
ром разные словоформы приведены к одной. Например, при нормализации буквы верхнего ре-
гистра приводятся к нижнему, а из слов обычно убираются окончания (в частности, s или es в
английском). Благодаря этому можно находить разные формы одного слова, не вводя вручную
все возможные варианты. Кроме того, на данном шаге обычно исключаются стоп-слова, то
есть слова, настолько распространённые, что искать их нет смысла. (Другими словами, фраг-
менты представляют собой просто подстроки текста документа, а лексемы — это слова, имею-
щие ценность для индексации и поиска.) Для выполнения этого шага в PostgreSQL использу-
ются словари. Набор существующих стандартных словарей при необходимости можно расши-
рять, создавая свои собственные.
Хранение документов в форме, подготовленной для поиска. Например, каждый документ мо-
жет быть представлен в виде сортированного массива нормализованных лексем. Помимо лек-
сем часто желательно хранить информацию об их положении для ранжирования по близо-
сти, чтобы документ, в котором слова запроса расположены «плотнее», получал более высо-
кий ранг, чем документ с разбросанными словами.
Словари позволяют управлять нормализацией фрагментов с большой гибкостью. Создавая слова-
ри, можно:
• Определять стоп-слова, которые не будут индексироваться.
370Полнотекстовый поиск
•
•
•
•
Сопоставлять
Сопоставлять
Сопоставлять
Сопоставлять
Snowball.
синонимы с одним словом, используя Ispell.
словосочетания с одним словом, используя тезаурус.
различные склонения слова с канонической формой, используя словарь Ispell.
различные склонения слова с канонической формой, используя стеммер
Для хранения подготовленных документов в PostgreSQL предназначен тип данных tsvector, а для
представления обработанных запросов — тип tsquery (Раздел 8.11). С этими типами данных ра-
ботают целый ряд функций и операторов (Раздел 9.13), и наиболее важный из них — оператор со-
ответствия @@, с которым мы познакомимся в Подразделе 12.1.2. Для ускорения полнотекстового
поиска могут применяться индексы (Раздел 12.9).
12.1.1. Что такое документ?
Документ — это единица обработки в системе полнотекстового поиска; например, журнальная
статья или почтовое сообщение. Система поиска текста должна уметь разбирать документы и со-
хранять связи лексем (ключевых слов) с содержащим их документом. Впоследствии эти связи мо-
гут использоваться для поиска документов с заданными ключевыми словами.
В контексте поиска в PostgreSQL документ — это обычно содержимое текстового поля в строке
таблицы или, возможно, сочетание (объединение) таких полей, которые могут храниться в разных
таблицах или формироваться динамически. Другими словами, документ для индексации может
создаваться из нескольких частей и не храниться где-либо как единое целое. Например:
SELECT title || ‘ ‘ ||
AS document
FROM messages
WHERE mid = 12;
author || ‘ ‘ ||
abstract || ‘ ‘ || body
SELECT m.title || ‘ ‘ || m.author || ‘ ‘ || m.abstract || ‘ ‘ || d.body
AS document
FROM messages m, docs d
WHERE mid = did AND mid = 12;
Примечание
На самом деле в этих примерах запросов следует использовать функцию coalesce, что-
бы значение NULL в каком-либо одном атрибуте не привело к тому, что результирую-
щим документом окажется NULL.
Документы также можно хранить в обычных текстовых файлах в файловой системе. В этом случае
база данных может быть просто хранилищем полнотекстового индекса и исполнителем запросов,
а найденные документы будут загружаться из файловой системы по некоторым уникальным иден-
тификаторам. Однако для загрузки внешних файлов требуются права суперпользователя или под-
держка специальных функций, так что это обычно менее удобно, чем хранить все данные внутри
БД PostgreSQL. Кроме того, когда всё хранится в базе данных, это упрощает доступ к метаданным
документов при индексации и выводе результатов.
Для нужд текстового поиска каждый документ должен быть сведён к специальному формату
tsvector. Поиск и ранжирование выполняется исключительно с этим представлением документа
— исходный текст потребуется извлечь, только когда документ будет отобран для вывода пользо-
вателю. Поэтому мы часто подразумеваем под tsvector документ, тогда как этот тип, конечно,
содержит только компактное представление всего документа.
12.1.2. Простое соответствие текста
Полнотекстовый поиск в PostgreSQL реализован на базе оператора соответствия @@, который воз-
вращает true, если tsvector (документ) соответствует tsquery (запросу). Для этого оператора не
важно, какой тип записан первым:
371Полнотекстовый поиск
SELECT ‘a fat cat sat on a mat and ate a fat rat’::tsvector @@
‘cat &amp; rat’::tsquery;
?column?
———-
t
SELECT ‘fat &amp; cow’::tsquery @@
‘a fat cat sat on a mat and ate a fat rat’::tsvector;
?column?
———-
f
Как можно догадаться из этого примера, tsquery — это не просто текст, как и tsvector. Значение
типа tsquery содержит искомые слова, это должны быть уже нормализованные лексемы, возможно
объединённые в выражение операторами И, ИЛИ, НЕ и ПРЕДШЕСТВУЕТ. (Подробнее синтаксис
описан в Подразделе 8.11.2.) Вы можете воспользоваться функциями to_tsquery, plainto_tsquery
и phraseto_tsquery, которые могут преобразовать заданный пользователем текст в значение
tsquery, прежде всего нормализуя слова в этом тексте. Функция to_tsvector подобным образом
может разобрать и нормализовать текстовое содержимое документа. Так что запрос с поиском
соответствия на практике выглядит скорее так:
SELECT to_tsvector(‘fat cats ate fat rats’) @@ to_tsquery(‘fat &amp; rat’);
?column?
———-
t
Заметьте, что соответствие не будет обнаружено, если запрос записан как
SELECT ‘fat cats ate fat rats’::tsvector @@ to_tsquery(‘fat &amp; rat’);
?column?
———-
f
так как слово rats не будет нормализовано. Элементами tsvector являются лексемы, предполо-
жительно уже нормализованные, так что rats считается не соответствующим rat.
Оператор @@ также может принимать типы text, позволяя опустить явные преобразования тексто-
вых строк в типы tsvector и tsquery в простых случаях. Всего есть четыре варианта этого опера-
тора:
tsvector @@ tsquery
tsquery @@ tsvector
text @@ tsquery
text @@ text
Первые два мы уже видели раньше. Форма text@@tsquery равнозначна выражению to_tsvector(x)
@@ y, а форма text@@text — выражению to_tsvector(x) @@ plainto_tsquery(y).
В значении tsquery оператор &amp; (И) указывает, что оба его операнда должны присутствовать в до-
кументе, чтобы он удовлетворял запросу. Подобным образом, оператор | (ИЛИ) указывает, что
в документе должен присутствовать минимум один из его операндов, тогда как оператор ! (НЕ)
указывает, что его операнд не должен присутствовать, чтобы условие удовлетворялось. Например,
запросу fat &amp; ! rat соответствуют документы, содержащие fat и не содержащие rat.
Фразовый поиск возможен с использованием оператора &lt;-&gt; (ПРЕДШЕСТВУЕТ) типа tsquery, ко-
торый находит соответствие, только если его операнды расположены рядом и в заданном порядке.
Например:
SELECT to_tsvector(‘fatal error’) @@ to_tsquery(‘fatal &lt;-&gt; error’);
?column?
———-
t
372Полнотекстовый поиск
SELECT to_tsvector(‘error is not fatal’) @@ to_tsquery(‘fatal &lt;-&gt; error’);
?column?
———-
f
Более общая версия оператора ПРЕДШЕСТВУЕТ имеет вид <N>, где N — целое число, выражающее
разность между позициями найденных лексем. Запись &lt;1&gt; равнозначна &lt;-&gt;, тогда как &lt;2&gt; допуска-
ет существование ровно одной лексемы между этими лексемами и т. д. Функция phraseto_tsquery
задействует этот оператор для конструирования tsquery, который может содержать многослов-
ную фразу, включающую в себя стоп-слова. Например:
SELECT phraseto_tsquery('cats ate rats');
phraseto_tsquery
-------------------------------
'cat' &lt;-&gt; 'ate' &lt;-&gt; 'rat'
SELECT phraseto_tsquery('the cats ate the rats');
phraseto_tsquery
-------------------------------
'cat' &lt;-&gt; 'ate' &lt;2&gt; 'rat'
Особый случай, который иногда бывает полезен, представляет собой запись &lt;0&gt;, требующая, чтобы
обоим лексемам соответствовало одно слово.
Сочетанием операторов tsquery можно управлять, применяя скобки. Без скобок операторы имеют
следующие приоритеты, в порядке возрастания: |, &amp;, &lt;-&gt; и самый приоритетный — !.
Стоит отметить, что операторы И/ИЛИ/НЕ имеют несколько другое значение, когда они приме-
няются в аргументах оператора ПРЕДШЕСТВУЕТ, так как в этом случае имеет значение точная
позиция совпадения. Например, обычному !x соответствуют только документы, не содержащие
x нигде. Но условию !x &lt;-&gt; y соответствует y, если оно не следует непосредственно за x; при
вхождении x в любом другом месте документа он не будет исключаться из рассмотрения. Другой
пример: для условия x &amp; y обычно требуется, чтобы и x, и y встречались в каком-то месте доку-
мента, но для выполнения условия (x &amp; y) &lt;-&gt; z требуется, чтобы x и y располагались в одном
месте, непосредственно перед z. Таким образом, этот запрос отличается от x &lt;-&gt; z &amp; y &lt;-&gt; z,
которому удовлетворяют документы, содержащие две отдельные последовательности x z и y z.
(Этот конкретный запрос в таком виде, как он записан, не имеет смысла, так как x и y не могут
находиться в одном месте; но в более сложных ситуациях, например, с шаблонами поиска по мас-
ке, запросы этого вида могут быть полезны.)
12.1.3. Конфигурации
До этого мы рассматривали очень простые примеры поиска текста. Как было упомянуто выше, весь
функционал текстового поиска позволяет делать гораздо больше: пропускать определённые сло-
ва (стоп-слова), обрабатывать синонимы и выполнять сложный анализ слов, например, выделять
фрагменты не только по пробелам. Все эти функции управляются конфигурациями текстового
поиска. В PostgreSQL есть набор предопределённых конфигураций для многих языков, но вы также
можете создавать собственные конфигурации. (Все доступные конфигурации можно просмотреть
с помощью команды \dF в psql.)
Подходящая конфигурация для данной среды выбирается во время установки и записывается в
параметре default_text_search_config в postgresql.conf. Если вы используете для всего кластера
одну конфигурацию текстового поиска, вам будет достаточно этого параметра в postgresql.conf.
Если же требуется использовать в кластере разные конфигурации, но для каждой базы данных
одну определённую, её можно задать командой ALTER DATABASE ... SET. В противном случае
конфигурацию можно выбрать в рамках сеанса, определив параметр default_text_search_config.
У каждой функции текстового поиска, зависящей от конфигурации, есть необязательный аргу-
мент regconfig, в котором можно явно указать конфигурацию для данной функции. Значение
default_text_search_config используется, только когда этот аргумент опущен.
373Полнотекстовый поиск
Для упрощения создания конфигураций текстового поиска они строятся из более простых объек-
тов. В PostgreSQL есть четыре типа таких объектов:
• Анализаторы текстового поиска разделяют документ на фрагменты и классифицируют их
(например, как слова или числа).
• Словари текстового поиска приводят фрагменты к нормализованной форме и отбрасывают
стоп-слова.
• Шаблоны текстового поиска предоставляют функции, образующие реализацию словарей.
(При создании словаря просто задаётся шаблон и набор параметров для него.)
• Конфигурации текстового поиска выбирают анализатор и набор словарей, который будет ис-
пользоваться для нормализации фрагментов, выданных анализатором.
Анализаторы и шаблоны текстового поиска строятся из низкоуровневых функций на языке C; что-
бы создать их, нужно программировать на C, а подключить их к базе данных может только супер-
пользователь. (В подкаталоге contrib/ инсталляции PostgreSQL можно найти примеры дополни-
тельных анализаторов и шаблонов.) Так как словари и конфигурации представляют собой просто
наборы параметров, связывающие анализаторы и шаблоны, их можно создавать, не имея админи-
стративных прав. Далее в этой главе будут приведены примеры их создания.
12.2. Таблицы и индексы
В предыдущем разделе приводились примеры, которые показывали, как можно выполнить сопо-
ставление с простыми текстовыми константами. В этом разделе показывается, как находить текст
в таблице, возможно с применением индексов.
12.2.1. Поиск в таблице
Полнотекстовый поиск можно выполнить, не применяя индекс. Следующий простой запрос выво-
дит заголовок (title) каждой строки, содержащей слово friend в поле body:
SELECT title
FROM pgweb
WHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');
При этом также будут найдены связанные слова, такие как friends и friendly, так как все они
сводятся к одной нормализованной лексеме.
В показанном выше примере для разбора и нормализации строки явно выбирается конфигурация
english. Хотя параметры, задающие конфигурацию, можно опустить:
SELECT title
FROM pgweb
WHERE to_tsvector(body) @@ to_tsquery('friend');
Такой запрос будет использовать конфигурацию, заданную в параметре default_text_search_config.
В следующем более сложном примере выбираются десять документов, изменённых последними,
со словами create и table в полях title или body:
SELECT title
FROM pgweb
WHERE to_tsvector(title || ' ' || body) @@ to_tsquery('create &amp; table')
ORDER BY last_mod_date DESC
LIMIT 10;
Чтобы найти строки, содержащие NULL в одном из полей, нужно воспользоваться функцией
coalesce, но здесь мы опустили её вызовы для краткости.
Хотя такие запросы будут работать и без индекса, для большинства приложений скорость будет
неприемлемой; этот подход рекомендуется только для нерегулярного поиска и динамического со-
держимого. Для практического применения полнотекстового поиска обычно создаются индексы.
374Полнотекстовый поиск
12.2.2. Создание индексов
Для ускорения текстового поиска мы можем создать индекс GIN (см. Раздел 12.9):
CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', body));
Заметьте, что здесь используется функция to_tsvector с двумя аргументами. В выражениях, опре-
деляющих индексы, можно использовать только функции, в которых явно задаётся имя конфигура-
ции текстового поиска (см. Раздел 11.7). Это объясняется тем, что содержимое индекса не должно
зависеть от значения параметра default_text_search_config. В противном случае содержимое ин-
декса может быть неактуальным, если разные его элементы tsvector будут создаваться с разными
конфигурациями текстового поиска и нельзя будет понять, какую именно использовать. Выгрузить
и восстановить такой индекс будет невозможно.
Так как при создании индекса использовалась версия to_tsvector с двумя аргументами, этот ин-
декс будет использоваться только в запросах, где to_tsvector вызывается с двумя аргументами и
во втором передаётся имя той же конфигурации. То есть, WHERE to_tsvector('english', body)
@@ 'a &amp; b' сможет использовать этот индекс, а WHERE to_tsvector(body) @@ 'a &amp; b' — нет. Это
гарантирует, что индекс будет использоваться только с той конфигурацией, с которой создавались
его элементы.
Индекс можно создать более сложным образом, определив для него имя конфигурации в другом
столбце таблицы, например:
CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector(config_name, body));
где config_name — имя столбца в таблице pgweb. Так можно сохранить имя конфигурации, связан-
ной с элементом индекса, и, таким образом, иметь в одном индексе элементы с разными конфигу-
рациями. Это может быть полезно, например, когда в коллекции документов хранятся документы
на разных языках. И в этом случае в запросах должен использоваться тот же индекс (с таким же
образом задаваемой конфигурацией), например, так: WHERE to_tsvector(config_name, body) @@
'a &amp; b'.
Индексы могут создаваться даже по объединению столбцов:
CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' ||
body));
Ещё один вариант — создать отдельный столбец tsvector, в котором сохранить результат
to_tsvector. Следующий пример показывает, как можно подготовить для индексации объединён-
ное содержимое столбцов title и body, применив функцию coalesce для получения желаемого
результата, даже когда один из столбцов NULL:
ALTER TABLE pgweb ADD COLUMN textsearchable_index_col tsvector;
UPDATE pgweb SET textsearchable_index_col =
to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''));
Затем мы создаём индекс GIN для ускорения поиска:
CREATE INDEX textsearch_idx ON pgweb USING GIN (textsearchable_index_col);
Теперь мы можем быстро выполнять полнотекстовый поиск:
SELECT title
FROM pgweb
WHERE textsearchable_index_col @@ to_tsquery('create &amp; table')
ORDER BY last_mod_date DESC
LIMIT 10;
Когда представление tsvector хранится в отдельном столбце, необходимо создать триггер, кото-
рый будет поддерживать столбец с tsvector в актуальном состоянии при любых изменениях title
или body. Как это сделать, рассказывается в Подразделе 12.4.3.
Хранение вычисленного выражения индекса в отдельном столбце даёт ряд преимуществ. Во-пер-
вых, для использования индекса в запросах не нужно явно указывать имя конфигурации тексто-
375Полнотекстовый поиск
вого поиска. Как показано в вышеприведённом примере, в этом случае запрос может зависеть от
default_text_search_config. Во-вторых, поиск выполняется быстрее, так как для проверки соот-
ветствия данных индексу не нужно повторно выполнять to_tsvector. (Это актуально больше для
индексов GiST, чем для GIN; см. Раздел 12.9.) С другой стороны, схему с индексом по выражению
проще реализовать и она позволяет сэкономить место на диске, так как представление tsvector
не хранится явно.
12.3. Управление текстовым поиском
Для реализации полнотекстового поиска необходимы функции, позволяющие создать tsvector из
документа и tsquery из запроса пользователя. Кроме того, результаты нужно выдавать в удобном
порядке, так что нам потребуется функция, оценивающая релевантность документа для данно-
го запроса. Важно также иметь возможность выводить найденный текст подходящим образом. В
PostgreSQL есть все необходимые для этого функции.
12.3.1. Разбор документов
Для преобразования документа в тип tsvector PostgreSQL предоставляет функцию to_tsvector.
to_tsvector([конфигурация regconfig,] документ text) returns tsvector
to_tsvector разбирает текстовый документ на фрагменты, сводит фрагменты к лексемам и воз-
вращает значение tsvector, в котором перечисляются лексемы и их позиции в документе. При
обработке документа используется указанная конфигурация текстового поиска или конфигурация
по умолчанию. Простой пример:
SELECT to_tsvector('english', 'a fat cat sat on a mat - it ate a fat rats');
to_tsvector
-----------------------------------------------------
'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4
В этом примере мы видим, что результирующий tsvector не содержит слова a, on и it, слово rats
превратилось rat, а знак препинания «-» был проигнорирован.
Функция to_tsvector внутри вызывает анализатор, который разбивает текст документа на фраг-
менты и классифицирует их. Для каждого фрагмента она проверяет список словарей (Раздел 12.6),
определяемый типом фрагмента. Первый же словарь, распознавший фрагмент, выдаёт одну или
несколько представляющих его лексем. Например, rats превращается в rat, так как один из сло-
варей понимает, что слово rats — это слово rat во множественном числе. Некоторое слова рас-
познаются как стоп-слова (Подраздел 12.6.1) и игнорируются как слова, фигурирующие в тексте
настолько часто, что искать их бессмысленно. В нашем примере это a, on и it. Если фрагмент не
воспринимается ни одним словарём из списка, он так же игнорируется. В данном примере это
происходит со знаком препинания -, так как с таким типом фрагмента (символы-разделители) не
связан никакой словарь и значит такие фрагменты никогда не будут индексироваться. Выбор ана-
лизатора, словарей и индексируемых типов фрагментов определяется конфигурацией текстового
поиска (Раздел 12.7). В одной базе данных можно использовать разные конфигурации, в том числе,
предопределённые конфигурации для разных языков. В нашем примере мы использовали конфи-
гурацию по умолчанию для английского языка — english.
Для назначения элементам tsvector разных весов используется функция setweight. Вес элемента
задаётся буквой A, B, C или D. Обычно это применяется для обозначения важности слов в разных
частях документа, например в заголовке или в теле документа. Затем эта информация может ис-
пользоваться при ранжировании результатов поиска.
Так как to_tsvector(NULL) вернёт NULL, мы советуем использовать coalesce везде, где соответству-
ющее поле может быть NULL. Создавать tsvector из структурированного документа рекоменду-
ется так:
UPDATE tt SET ti =
setweight(to_tsvector(coalesce(title,'')), 'A')
376
||Полнотекстовый поиск
setweight(to_tsvector(coalesce(keyword,'')), 'B') ||
setweight(to_tsvector(coalesce(abstract,'')), 'C') ||
setweight(to_tsvector(coalesce(body,'')), 'D');
Здесь мы использовали setweight для пометки происхождения каждой лексемы в сформирован-
ных значениях tsvector и объединили помеченные значения с помощью оператора конкатенации
типов tsvector ||. (Подробнее эти операции рассматриваются в Подразделе 12.4.1.)
12.3.2. Разбор запросов
PostgreSQL предоставляет функции to_tsquery, plainto_tsquery, phraseto_tsquery и
websearch_to_tsquery для приведения запроса к типу tsquery. Функция to_tsquery даёт больше
возможностей, чем plainto_tsquery или phraseto_tsquery, но более строга к входным данным.
Функция websearch_to_tsquery представляет собой упрощённую версию to_tsquery с альтерна-
тивным синтаксисом, подобным тому, что принят в поисковых системах в Интернете.
to_tsquery([конфигурация regconfig,] текст_запроса text) returns tsquery
to_tsquery создаёт значение tsquery из текста_запроса, который может состоять из простых
фрагментов, разделённых логическими операторами tsquery: &amp; (И), | (ИЛИ), ! (НЕ) и &lt;-&gt; (ПРЕД-
ШЕСТВУЕТ), возможно, сгруппированных скобками. Другими словами, входное значение для
to_tsquery должно уже соответствовать общим правилам для значений tsquery, описанным в Под-
разделе 8.11.2. Различие их состоит в том, что во вводимом в tsquery значении фрагменты вос-
принимаются буквально, тогда как to_tsquery нормализует фрагменты, приводя их к лексемам,
используя явно указанную или подразумеваемую конфигурацию, и отбрасывая стоп-слова. Напри-
мер:
SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');
to_tsquery
---------------
'fat' &amp; 'rat'
Как и при вводе значения tsquery, для каждой лексемы можно задать вес(а), чтобы при поиске
можно было выбрать из tsvector только лексемы с заданными весами. Например:
SELECT to_tsquery('english', 'Fat | Rats:AB');
to_tsquery
------------------
'fat' | 'rat':AB
К лексеме также можно добавить *, определив таким образом условие поиска по префиксу:
SELECT to_tsquery('supern:*A &amp; star:A*B');
to_tsquery
--------------------------
'supern':*A &amp; 'star':*AB
Такая лексема будет соответствовать любому слову в tsvector, начинающемуся с данной подстро-
ки.
to_tsquery может также принимать фразы в апострофах. Это полезно в основном когда конфигу-
рация включает тезаурус, который может обрабатывать такие фразы. В показанном ниже примере
предполагается, что тезаурус содержит правило supernovae stars : sn:
SELECT to_tsquery('''supernovae stars'' &amp; !crab');
to_tsquery
---------------
'sn' &amp; !'crab'
Если убрать эти апострофы, to_tsquery не примет фрагменты, не разделённые операторами И,
ИЛИ и ПРЕДШЕСТВУЕТ, и выдаст синтаксическую ошибку.
plainto_tsquery([конфигурация regconfig,] текст_запроса text) returns tsquery
377Полнотекстовый поиск
plainto_tsquery преобразует неформатированный текст_запроса в значение tsquery. Текст раз-
бирается и нормализуется подобно тому, как это делает to_tsvector, а затем между оставшимися
словами вставляются операторы &amp; (И) типа tsquery.
Пример:
SELECT plainto_tsquery('english', 'The Fat Rats');
plainto_tsquery
-----------------
'fat' &amp; 'rat'
Заметьте, что plainto_tsquery не распознает во входной строке операторы tsquery, метки весов
или обозначения префиксов:
SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');
plainto_tsquery
---------------------
'fat' &amp; 'rat' &amp; 'c'
В данном случае все знаки пунктуации были отброшены как символы-разделители.
phraseto_tsquery([конфигурация regconfig,] текст_запроса text) returns tsquery
phraseto_tsquery ведёт себя подобно plainto_tsquery, за исключением того, что она вставляет
между оставшимися словами оператор &lt;-&gt; (ПРЕДШЕСТВУЕТ) вместо оператора &amp; (И). Кроме того,
стоп-слова не просто отбрасываются, а подсчитываются, и вместо операторов &lt;-&gt; используются
операторы <N> с подсчитанным числом. Эта функция полезна при поиске точных последователь-
ностей лексем, так как операторы ПРЕДШЕСТВУЕТ проверяют не только наличие всех лексем, но
и их порядок.
Пример:
SELECT phraseto_tsquery('english', 'The Fat Rats');
phraseto_tsquery
------------------
'fat' &lt;-&gt; 'rat'
Как и plainto_tsquery, функция phraseto_tsquery не распознает во входной строке операторы
типа tsquery, метки весов или обозначения префиксов:
SELECT phraseto_tsquery('english', 'The Fat &amp; Rats:C');
phraseto_tsquery
-----------------------------
'fat' &lt;-&gt; 'rat' &lt;-&gt; 'c'
websearch_to_tsquery([конфигурация regconfig,] текст_запроса text) returns tsquery
Функция websearch_to_tsquery создаёт значение tsquery из текста_запроса, используя альтер-
нативный синтаксис, в котором запрос задаётся просто неформатированным текстом. В отличие
от plainto_tsquery и phraseto_tsquery, она также принимает определённые операторы. Более
того, эта функция не должна никогда выдавать синтаксические ошибки, что позволяет осуществ-
лять поиск по произвольному заданному пользователем запросу. Она поддерживает следующий
синтаксис:
• текст не в кавычках: текст, не заключённый в кавычки, который будет преобразован в слова,
разделяемые операторами &amp;, как его восприняла бы функция plainto_tsquery.
• "текст в кавычках": текст, заключённый в кавычки, будет преобразован в слова, разделяе-
мые операторами &lt;-&gt;, как его восприняла бы функция phraseto_tsquery.
• OR: логическая операция ИЛИ будет преобразована в оператор |.
• -: логическая операция НЕ, преобразуется в оператор !.
Примеры:
SELECT websearch_to_tsquery('english', 'The fat rats');
378Полнотекстовый поиск
websearch_to_tsquery
----------------------
'fat' &amp; 'rat'
(1 row)
SELECT websearch_to_tsquery('english', '"supernovae stars" -crab');
websearch_to_tsquery
----------------------------------
'supernova' &lt;-&gt; 'star' &amp; !'crab'
(1 row)
SELECT websearch_to_tsquery('english', '"sad cat" or "fat rat"');
websearch_to_tsquery
-----------------------------------
'sad' &lt;-&gt; 'cat' | 'fat' &lt;-&gt; 'rat'
(1 row)
SELECT websearch_to_tsquery('english', 'signal -"segmentation fault"');
websearch_to_tsquery
---------------------------------------
'signal' &amp; !( 'segment' &lt;-&gt; 'fault' )
(1 row)
SELECT websearch_to_tsquery('english', '""" )( dummy \\ query &lt;-&gt;');
websearch_to_tsquery
----------------------
'dummi' &amp; 'queri'
(1 row)
12.3.3. Ранжирование результатов поиска
Ранжирование документов можно представить как попытку оценить, насколько они релевантны
заданному запросу и отсортировать их так, чтобы наиболее релевантные выводились первыми. В
PostgreSQL встроены две функции ранжирования, принимающие во внимание лексическую, пози-
ционную и структурную информацию; то есть, они учитывают, насколько часто и насколько близ-
ко встречаются в документе ключевые слова и какова важность содержащей их части документа.
Однако само понятие релевантности довольно размытое и во многом определяется приложением.
Приложения могут использовать для ранжирования и другую информацию, например, время из-
менения документа. Встроенные функции ранжирования можно рассматривать лишь как примеры
реализации. Для своих конкретных задач вы можете разработать собственные функции ранжиро-
вания и/или учесть при обработке их результатов дополнительные факторы.
Ниже описаны две встроенные функции ранжирования:
ts_rank([веса float4[],] вектор tsvector, запрос tsquery [, нормализация integer]) returns
float4
Ранжирует векторы по частоте найденных лексем.
ts_rank_cd([веса float4[],] вектор tsvector, запрос tsquery [, нормализация integer])
returns float4
Эта функция вычисляет плотность покрытия для данного вектора документа и запроса, ис-
пользуя метод, разработанный Кларком, Кормаком и Тадхоуп и описанный в статье "Relevance
Ranking for One to Three Term Queries" в журнале "Information Processing and Management" в
1999 г. Плотность покрытия вычисляется подобно рангу ts_rank, но в расчёт берётся ещё и
близость соответствующих лексем друг к другу.
Для вычисления результата этой функции требуется информация о позиции лексем. Поэтому
она игнорируют «очищенные» от этой информации лексемы в tsvector. Если во входных дан-
379Полнотекстовый поиск
ных нет неочищенных лексем, результат будет равен нулю. (За дополнительными сведениями о
функции strip и позиционной информации в данных tsvector обратитесь к Подразделу 12.4.1.)
Для обеих этих функций аргумент веса позволяет придать больший или меньший вес словам, в
зависимости от их меток. В передаваемом массиве весов определяется, насколько весома каждая
категория слов, в следующем порядке:
{вес D, вес C, вес B, вес A}
Если этот аргумент опускается, подразумеваются следующие значения:
{0.1, 0.2, 0.4, 1.0}
Обычно весами выделяются слова из особых областей документа, например из заголовка или крат-
кого введения, с тем, чтобы эти слова считались более и менее значимыми, чем слова в основном
тексте документа.
Так как вероятность найти ключевые слова увеличивается с размером документа, при ранжиро-
вании имеет смысл учитывать его, чтобы, например, документ с сотней слов, содержащий пять
вхождений искомых слов, считался более релевантным, чем документ с тысячей слов и теми же
пятью вхождениями. Обе функции ранжирования принимают целочисленный параметр нормали-
зации, определяющий, как ранг документа будет зависеть от его размера. Этот параметр пред-
ставляет собой битовую маску и управляет несколькими режимами: вы можете включить сразу
несколько режимов, объединив значения оператором | (например так: 2|4).
•
•
•
•
0 (по умолчанию): длина документа не учитывается
1: ранг документа делится на 1 + логарифм длины документа
2: ранг документа делится на его длину
4: ранг документа делится на среднее гармоническое расстояние между блоками (это реали-
зовано только в ts_rank_cd)
• 8: ранг документа делится на число уникальных слов в документе
• 16: ранг документа делится на 1 + логарифм числа уникальных слов в документе
• 32: ранг делится своё же значение + 1
Если включены несколько флагов, соответствующие операции выполняются в показанном поряд-
ке.
Важно заметить, что функции ранжирования не используют никакую внешнюю информацию, так
что добиться нормализации до 1% или 100% невозможно, хотя иногда это желательно. Применив
параметр 32 (rank/(rank+1)), можно свести все ранги к диапазону 0..1, но это изменение будет
лишь косметическим, на порядке сортировки результатов это не отразится.
В данном примере выбираются десять найденных документов с максимальным рангом:
SELECT title, ts_rank_cd(textsearch, query) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
title
|
rank
-----------------------------------------------+----------
Neutrinos in the Sun
|
3.1
The Sudbury Neutrino Detector
|
2.4
A MACHO View of Galactic Dark Matter
| 2.01317
Hot Gas and Dark Matter
| 1.91171
The Virgo Cluster: Hot Plasma and Dark Matter | 1.90953
Rafting for Solar Neutrinos
|
1.9
NGC 4650A: Strange Galaxy and Dark Matter
| 1.85774
Hot Gas and Dark Matter
|
1.6123
Ice Fishing for Cosmic Neutrinos
|
1.6
Weak Lensing Distorts the Universe
| 0.818218
Тот же пример с нормализованным рангом:
380Полнотекстовый поиск
SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
title
|
rank
-----------------------------------------------+-------------------
Neutrinos in the Sun
| 0.756097569485493
The Sudbury Neutrino Detector
| 0.705882361190954
A MACHO View of Galactic Dark Matter
| 0.668123210574724
Hot Gas and Dark Matter
| 0.65655958650282
The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973
Rafting for Solar Neutrinos
| 0.655172410958162
NGC 4650A: Strange Galaxy and Dark Matter
| 0.650072921219637
Hot Gas and Dark Matter
| 0.617195790024749
Ice Fishing for Cosmic Neutrinos
| 0.615384618911517
Weak Lensing Distorts the Universe
| 0.450010798361481
Ранжирование может быть довольно дорогостоящей операцией, так как для вычисления ранга
необходимо прочитать tsvector каждого подходящего документа и это займёт значительное вре-
мя, если придётся обращаться к диску. К сожалению, избежать этого вряд ли возможно, так как
на практике по многим запросам выдаётся большое количество результатов.
12.3.4. Выделение результатов
Представляя результаты поиска, в идеале нужно выделять часть документа и показывать, как он
связан с запросом. Обычно поисковые системы показывают фрагменты документа с отмеченны-
ми искомыми словами. В PostgreSQL для реализации этой возможности представлена функция
ts_headline.
ts_headline([конфигурация regconfig,] документ text, запрос tsquery [, параметры text])
returns text
ts_headline принимает документ вместе с запросом и возвращает выдержку из документа, в
которой выделяются слова из запроса. Применяемую для разбора документа конфигурацию
можно указать в параметре config; если этот параметр опущен, применяется конфигурация
default_text_search_config.
Если в параметрах передаётся строка options, она должна состоять из списка разделённых запя-
тыми пар параметр=значение. Параметры могут быть следующими:
• StartSel, StopSel: строки, которые будут разграничивать слова запроса в документе, выделяя
их среди остальных. Если эти строки содержат пробелы или запятые, их нужно заключить в
кавычки.
• MaxWords, MinWords: эти числа определяет нижний и верхний предел размера выдержки.
• ShortWord: слова такой длины или короче в начале и конце выдержки будут отбрасываться.
Значение по умолчанию, равное 3, исключает распространённые английские артикли.
• HighlightAll: логический флаг; если он равен true, выдержкой будет весь документ и три
предыдущие параметра игнорируются.
• MaxFragments: максимальное число выводимых текстовых выдержек или фрагментов. Значе-
ние по умолчанию, равное 0, выбирает метод создания выдержки без фрагментов. При значе-
нии большем 0 выбирается метод с фрагментами, когда находятся все фрагменты, содержа-
щие как можно больше слов запроса, а затем они сжимаются до слов запроса. Такие фрагмен-
ты могут содержать какие-то ключевые слова в середине и ограничиваются двумя искомыми
словами. При этом фрагменты могут содержать не больше MaxWords слов, а в начале и конце
они будут очищены от слов длины ShortWord и меньше. Если в документе найдены не все сло-
ва запроса, выводится один фрагмент, включающий первые MinWords слов в документе.
• FragmentDelimiter: Когда выводятся несколько фрагментов, они будут разделяться этой стро-
кой.
381Полнотекстовый поиск
Имена этих параметров распознаются без учёта регистра. Явно не определённые параметры по-
лучают такие значения по умолчанию:
StartSel=<b>, StopSel=</b>,
MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,
MaxFragments=0, FragmentDelimiter=" ... "
Пример использования:
SELECT ts_headline('english',
'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
to_tsquery('query &amp; similarity'));
ts_headline
------------------------------------------------------------
containing given <b>query</b> terms
and return them in order of their <b>similarity</b> to the
<b>query</b>.
SELECT ts_headline('english',
'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
to_tsquery('query &amp; similarity'),
'StartSel = &lt;, StopSel = &gt;');
ts_headline
-------------------------------------------------------
containing given <query> terms
and return them in order of their <similarity> to the</similarity></query></N></N></p>
<query>.
Функция ts_headline работает с оригинальным документом, а не его сжатым представлением
tsvector, так что она может быть медленной и использовать её следует осмотрительно.
12.4. Дополнительные возможности
В этом разделе описываются дополнительные функции и операторы, которые могут быть полезны
при поиске текста.
12.4.1. Обработка документов
В Подразделе 12.3.1 показывалось, как обычные текстовые документы можно преобразовать в зна-
чения tsvector. PostgreSQL предлагает также набор функций и операторов для обработки доку-
ментов, уже представленных в формате tsvector.
tsvector || tsvector
Оператор конкатенации значений tsvector возвращает вектор, объединяющий лексемы и по-
зиционную информацию двух векторов, переданных ему в аргументах. В полученном результа-
те сохраняются позиции и метки весов. При этом позиции в векторе справа сдвигаются на мак-
симальное значение позиции в векторе слева, что почти равносильно применению to_tsvector
к результату конкатенации двух исходных строк документов. (Почти, потому что стоп-слова,
исключаемые в конце левого аргумента, при конкатенации исходных строк влияют на позиции
лексем в правой части, а при конкатенации tsvector — нет.)
Преимущество же конкатенации документов в векторной форме по сравнению с конкатенаци-
ей текста до вызова to_tsvector заключается в том, что так можно разбирать разные части
документа, применяя разные конфигурации. И так как функция setweight помечает все лексе-
382Полнотекстовый поиск
мы данного вектора одинаково, разбирать текст и выполнять setweight нужно до объединения
разных частей документа с подразумеваемым разным весом.
setweight(вектор tsvector, вес "char") returns tsvector
setweight возвращает копию входного вектора, помечая в ней каждую позицию заданным ве-
сом, меткой A, B, C или D. (Метка D по умолчанию назначается всем векторам, так что при выводе
она опускается.) Эти метки сохраняются при конкатенации векторов, что позволяет придавать
разные веса словам из разных частей документа и, как следствие, ранжировать их по-разному.
Заметьте, что веса назначаются позициям, а не лексемам. Если входной вектор очищен от
позиционной информации, setweight не делает ничего.
length(вектор tsvector) returns integer
Возвращает число лексем, сохранённых в векторе.
strip(вектор tsvector) returns tsvector
Возвращает вектор с теми же лексемами, что и в данном, но без информации о позиции и весе.
Очищенный вектор обычно оказывается намного меньше исходного, но при этом и менее по-
лезным. С очищенными векторами хуже работает ранжирование, а также оператор &lt;-&gt; (ПРЕД-
ШЕСТВУЕТ) типа tsquery никогда не найдёт соответствие в них, так как не сможет определить
расстояние между вхождениями лексем.
Полный список связанных с tsvector функций приведён в Таблице 9.41.
12.4.2. Обработка запросов
В Подразделе 12.3.2 показывалось, как обычные текстовые запросы можно преобразовывать в зна-
чения tsquery. PostgreSQL предлагает также набор функций и операторов для обработки запро-
сов, уже представленных в формате tsquery.
tsquery &amp;&amp; tsquery
Возвращает логическое произведение (AND) двух данных запросов.
tsquery || tsquery
Возвращает логическое объединение (OR) двух данных запросов.
!! tsquery
Возвращает логическое отрицание (NOT) данного запроса.
tsquery &lt;-&gt; tsquery
Возвращает запрос, который ищет соответствие первому данному запросу, за которым следует
соответствие второму данному запросу, с применением оператора &lt;-&gt; (ПРЕДШЕСТВУЕТ) типа
tsquery. Например:
SELECT to_tsquery('fat') &lt;-&gt; to_tsquery('cat | rat');
?column?
-----------------------------------
'fat' &lt;-&gt; 'cat' | 'fat' &lt;-&gt; 'rat'
tsquery_phrase(запрос1 tsquery, запрос2 tsquery [, расстояние integer ]) returns tsquery
Возвращает запрос, который ищет соответствие первому данному запросу, за которым следует
соответствие второму данному запросу (число лексем между ними задаётся параметром рас-
стояние), с применением оператора <N> типа tsquery. Например:
SELECT tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10);
tsquery_phrase
------------------
'fat' &lt;10&gt; 'cat'
383Полнотекстовый поиск
numnode(запрос tsquery) returns integer
Возвращает число узлов (лексем и операторов) в значении tsquery. Эта функция помогает
определить, имеет ли смысл запрос (тогда её результат &gt; 0) или он содержит только стоп-слова
(тогда она возвращает 0). Примеры:
SELECT numnode(plainto_tsquery('the any'));
ЗАМЕЧАНИЕ: запрос поиска текста игнорируется, так как содержит
только стоп-слова или не содержит лексем
numnode
---------
0
SELECT numnode('foo &amp; bar'::tsquery);
numnode
---------
3
querytree(запрос tsquery) returns text
Возвращает часть tsquery, которую можно использовать для поиска по индексу. Эта функция
помогает выявить неиндексируемые запросы, например, такие, которые содержат только стоп-
слова или условия отрицания. Например:
SELECT querytree(to_tsquery('!defined'));
querytree
-----------
12.4.2.1. Перезапись запросов
Семейство запросов ts_rewrite ищет в данном tsquery вхождения целевого подзапроса и заменя-
ет каждое вхождение указанной подстановкой. По сути эта операция похожа на замену подстроки
в строке, только рассчитана на работу с tsquery. Сочетание целевого подзапроса с подстановкой
можно считать правилом перезаписи запроса. Набор таких правил перезаписи может быть очень
полезен при поиске. Например, вы можете улучшить результаты, добавив синонимы (например,
big apple, nyc и gotham для new york) или сузить область поиска, чтобы нацелить пользователя на
некоторую область. Это в некотором смысле пересекается с функциональностью тезаурусов (Под-
раздел  12.6.4). Однако, при таком подходе вы можете изменять правила перезаписи «на лету»,
тогда как при обновлении тезауруса необходима переиндексация.
ts_rewrite (запрос tsquery, цель tsquery, замена tsquery) returns tsquery
Эта форма ts_rewrite просто применяет одно правило перезаписи: цель заменяется подста-
новкой везде, где она находится в запросе. Например:
SELECT ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'c'::tsquery);
ts_rewrite
------------
'b' &amp; 'c'
ts_rewrite (запрос tsquery, выборка text) returns tsquery
Эта форма ts_rewrite принимает начальный запрос и SQL-команду select, которая задаётся
текстовой строкой. Команда select должна выдавать два столбца типа tsquery. Для каждой
строки результата select вхождения первого столбца (цели) заменяются значениями второго
столбца (подстановкой) в тексте запроса. Например:
CREATE TABLE aliases (t tsquery PRIMARY KEY, s tsquery);
INSERT INTO aliases VALUES('a', 'c');
SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases');
ts_rewrite
384Полнотекстовый поиск
------------
'b' &amp; 'c'
Заметьте, что когда таким способом применяются несколько правил перезаписи, порядок их
применения может иметь значение, поэтому в исходном запросе следует добавить ORDER BY
по какому-либо ключу.
Давайте рассмотрим практический пример на тему астрономии. Мы развернём запрос supernovae,
используя правила перезаписи в таблице:
CREATE TABLE aliases (t tsquery primary key, s tsquery);
INSERT INTO aliases VALUES(to_tsquery('supernovae'),
to_tsquery('supernovae|sn'));
SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM aliases');
ts_rewrite
---------------------------------
'crab' &amp; ( 'supernova' | 'sn' )
Мы можем скорректировать правила перезаписи, просто изменив таблицу:
UPDATE aliases
SET s = to_tsquery('supernovae|sn &amp; !nebulae')
WHERE t = to_tsquery('supernovae');
SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM aliases');
ts_rewrite
---------------------------------------------
'crab' &amp; ( 'supernova' | 'sn' &amp; !'nebula' )
Перезапись может быть медленной, когда задано много правил перезаписи, так как соответствия
будут проверяться для каждого правила. Чтобы отфильтровать явно неподходящие правила, можно
использовать проверки включения для типа tsquery. В следующем примере выбираются только те
правила, которые могут соответствовать исходному запросу:
SELECT ts_rewrite('a &amp; b'::tsquery,
'SELECT t,s FROM aliases WHERE ''a &amp; b''::tsquery @&gt; t');
ts_rewrite
------------
'b' &amp; 'c'
12.4.3. Триггеры для автоматического обновления
Когда представление документа в формате tsvector хранится в отдельном столбце, необходимо
создать триггер, который будет обновлять его содержимое при изменении столбцов, из которых со-
ставляется исходный документ. Для этого можно использовать две встроенные триггерные функ-
ции или написать свои собственные.
tsvector_update_trigger(столбец_tsvector, имя_конфигурации, столбец_текста [, ...])
tsvector_update_trigger_column(столбец_tsvector, столбец_конфигурации,
столбец_текста [, ...])
Эти триггерные функции автоматически вычисляют значение для столбца tsvector из одного или
нескольких текстовых столбцов с параметрами, указанными в команде CREATE TRIGGER. Пример
их использования:
CREATE TABLE messages (
title
text,
body
text,
tsv
tsvector
);
385Полнотекстовый поиск
CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
ON messages FOR EACH ROW EXECUTE FUNCTION
tsvector_update_trigger(tsv, 'pg_catalog.english', title, body);
INSERT INTO messages VALUES('title here', 'the body text is here');
SELECT * FROM messages;
title
|
body
|
tsv
------------+-----------------------+----------------------------
title here | the body text is here | 'bodi':4 'text':5 'titl':1
SELECT title, body FROM messages WHERE tsv @@ to_tsquery('title &amp; body');
title
|
body
------------+-----------------------
title here | the body text is here
С таким триггером любое изменение в полях title или body будет автоматически отражаться в
содержимом tsv, так что приложению не придётся заниматься этим.
Первым аргументом этих функций должно быть имя столбца tsvector, содержимое которого будет
обновляться. Ещё один аргумент — конфигурация текстового поиска, которая будет использовать-
ся для преобразования. Для tsvector_update_trigger имя конфигурации передаётся просто как
второй аргумент триггера. Это имя должно быть определено полностью, чтобы поведение триггера
не менялось при изменениях в пути поиска (search_path). Для tsvector_update_trigger_column
во втором аргументе триггера передаётся имя другого столбца таблицы, который должен иметь
тип regconfig. Это позволяет использовать разные конфигурации для разных строк. В оставшихся
аргументах передаются имена текстовых столбцов (типа text, varchar или char). Их содержимое
будет включено в документ в заданном порядке. При этом значения NULL будут пропущены (а
другие столбцы будут индексироваться).
Ограничение этих встроенных триггеров заключается в том, что они обрабатывают все столбцы
одинаково. Чтобы столбцы обрабатывались по-разному, например для текста заголовка задавался
не тот же вес, что для тела документа, потребуется разработать свой триггер. К примеру, так это
можно сделать на языке PL/pgSQL:
CREATE FUNCTION messages_trigger() RETURNS trigger AS $$
begin
new.tsv :=
setweight(to_tsvector('pg_catalog.english', coalesce(new.title,'')), 'A') ||
setweight(to_tsvector('pg_catalog.english', coalesce(new.body,'')), 'D');
return new;
end
$$ LANGUAGE plpgsql;
CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
ON messages FOR EACH ROW EXECUTE FUNCTION messages_trigger();
Помните, что, создавая значения tsvector в триггерах, важно явно указывать имя конфигурации,
чтобы содержимое столбца не зависело от изменений default_text_search_config. В противном
случае могут возникнуть проблемы, например результаты поиска изменятся после выгрузки и вос-
становления данных.
12.4.4. Сбор статистики по документу
Функция ts_stat может быть полезна для проверки конфигурации и нахождения возможных стоп-
слов.
ts_stat(sql_запрос text, [веса text,]
OUT слово text, OUT число_док integer,
OUT число_вхожд integer) returns setof record
386Полнотекстовый поиск
Здесь sql_запрос — текстовая строка, содержащая SQL-запрос, который должен возвращать один
столбец tsvector. Функция ts_stat выполняет запрос и возвращает статистику по каждой отдель-
ной лексеме (слову), содержащейся в данных tsvector. Её результат представляется в столбцах
• слово text — значение лексемы
• число_док integer — число документов (значений tsvector), в которых встретилось слово
• число_вхожд integer — общее число вхождений слова
Если передаётся параметр weights, то подсчитываются только вхождения с указанными в нём
весами.
Например, найти десять наиболее часто используемых слов в коллекции документов можно так:
SELECT * FROM ts_stat('SELECT vector FROM apod')
ORDER BY nentry DESC, ndoc DESC, word
LIMIT 10;
Следующий запрос возвращает тоже десять слов, но при выборе их учитываются только вхождения
с весами A или B:
SELECT * FROM ts_stat('SELECT vector FROM apod', 'ab')
ORDER BY nentry DESC, ndoc DESC, word
LIMIT 10;
12.5. Анализаторы
Задача анализаторов текста — разделить текст документа на фрагменты и присвоить каждому
из них тип из набора, определённого в самом анализаторе. Заметьте, что анализаторы не меняют
текст — они просто выдают позиции предполагаемых слов. Вследствие такой ограниченности их
функций, собственные специфические анализаторы бывают нужны гораздо реже, чем собственные
словари. В настоящее время в PostgreSQL есть только один встроенный анализатор, который может
быть полезен для широкого круга приложений.
Этот встроенный анализатор называется pg_catalog.default. Он распознаёт 23 типа фрагментов,
перечисленные в Таблице 12.1.
Таблица 12.1. Типы фрагментов, выделяемых стандартным анализатором
Псевдоним Описание
Пример
asciiword Слово только из букв ASCII
elephant
word Слово из любых букв
mañana
numword Слово из букв и цифр
beta1
asciihword Слово только из букв ASCII с де- up-to-date
фисами
hword Слово из любых букв с дефиса- lógico-matemática
ми
numhword Слово из букв и цифр с дефиса- postgresql-beta1
ми
hword_asciipart Часть слова с дефисами, только postgresql в словосочетании
из букв ASCII
postgresql-beta1
hword_part Часть слова с дефисами, из лю- lógico или matemática в слово-
бых букв
сочетании lógico-matemática
hword_numpart Часть слова с дефисами, из букв beta1
в
словосочетании
и цифр
postgresql-beta1
email Адрес электронной почты
foo@example.com
protocol Префикс протокола
http://
387Полнотекстовый поиск
Псевдоним Описание Пример
url URL example.com/stuff/
index.html
host Имя узла example.com
url_path Путь в адресе URL /stuff/index.html, как часть
URL
file Путь или имя файла /usr/local/foo.txt, если не яв-
ляется частью URL
sfloat Научная запись числа -1.234e56
float Десятичная запись числа -1.234
int Целое со знаком -1234
uint Целое без знака 1234
version Номер версии 8.3.0
tag Тег XML &lt;a
"dictionaries.html"&gt;
entity Сущность XML &amp;
blank Символы-разделители (любые пробельные символы
или знаки препинания, не по-
павшие в другие категории)
href=
Примечание
Понятие «буквы» анализатор определяет исходя из локали, заданной для базы данных,
в частности параметра lc_ctype. Слова, содержащие только буквы из ASCII (латинские
буквы), распознаются как фрагменты отдельного типа, так как иногда бывает полезно
выделить их. Для многих европейских языков типы фрагментов word и asciiword мож-
но воспринимать как синонимы.
email принимает не все символы, которые считаются допустимыми по стандарту RFC
5322. В частности, имя почтового ящика помимо алфавитно-цифровых символов может
содержать только точку, минус и подчёркивание.
Анализатор может выделить в одном тексте несколько перекрывающихся фрагментов. Например,
слово с дефисом будет выдано как целое составное слово и по частям:
SELECT alias, description, token FROM ts_debug('foo-bar-beta1');
alias
|
description
|
token
-----------------+------------------------------------------+--------------
numhword
| Hyphenated word, letters and digits
| foo-bar-beta1
hword_asciipart | Hyphenated word part, all ASCII
| foo
blank
| Space symbols
| -
hword_asciipart | Hyphenated word part, all ASCII
| bar
blank
| Space symbols
| -
hword_numpart
| Hyphenated word part, letters and digits | beta1
Это поведение считается желательным, так как это позволяет находить при последующем поиске
и всё слово целиком, и его части. Ещё один показательный пример:
SELECT alias, description, token
FROM ts_debug('http://example.com/stuff/index.html');
alias
| description |
token
----------+---------------+------------------------------
protocol | Protocol head | http://
388Полнотекстовый поиск
url
| URL
host
| Host
url_path | URL path
| example.com/stuff/index.html
| example.com
| /stuff/index.html
12.6. Словари
Словари полнотекстового поиска предназначены для исключения стоп-слов (слов, которые не
должны учитываться при поиске) и нормализации слов, чтобы разные словоформы считались сов-
падающими. Успешно нормализованное слово называется лексемой. Нормализация и исключение
стоп-слов не только улучшает качество поиска, но и уменьшает размер представления документа в
формате tsvector, и, как следствие, увеличивает быстродействие. Нормализация не всегда имеет
лингвистический смысл, обычно она зависит от требований приложения.
Несколько примеров нормализации:
• Лингвистическая нормализация — словари Ispell пытаются свести слова на входе к нормали-
зованной форме, а стеммеры убирают окончания слов
• Адреса URL могут быть канонизированы, чтобы например следующие адреса считались оди-
наковыми:
• http://www.pgsql.ru/db/mw/index.html
• http://www.pgsql.ru/db/mw/
• http://www.pgsql.ru/db/../db/mw/index.html
• Названия цветов могут быть заменены их шестнадцатеричными значениями, например red,
green, blue, magenta -&gt; FF0000, 00FF00, 0000FF, FF00FF
• При индексировании чисел можно отбросить цифры в дробной части для сокращения множе-
ства всевозможных чисел, чтобы например 3.14159265359, 3.1415926 и 3.14 стали одинаковы-
ми после нормализации, при которой после точки останутся только две цифры.
Словарь — это программа, которая принимает на вход фрагмент и возвращает:
• массив лексем, если входной фрагмент известен в словаре (заметьте, один фрагмент может
породить несколько лексем)
• одну лексему с установленным флагом TSL_FILTER для замены исходного фрагмента новым,
чтобы следующие словари работали с новым вариантом (словарь, который делает это, называ-
ется фильтрующим словарём)
• пустой массив, если словарь воспринимает этот фрагмент, но считает его стоп-словом
• NULL, если словарь не воспринимает полученный фрагмент
В PostgreSQL встроены стандартные словари для многих языков. Есть также несколько предопре-
делённых шаблонов, на основании которых можно создавать новые словари с изменёнными пара-
метрами. Все эти шаблоны описаны ниже. Если же ни один из них не подходит, можно создать и
свои собственные шаблоны. Соответствующие примеры можно найти в каталоге contrib/ инстал-
ляции PostgreSQL.
Конфигурация текстового поиска связывает анализатор с набором словарей, которые будут обра-
батывать выделенные им фрагменты. Для каждого типа фрагментов, выданных анализатором, в
конфигурации задаётся отдельный список словарей. Найденный анализатором фрагмент проходит
через все словари по порядку, пока какой-либо словарь не увидит в нём знакомое для него слово.
Если он окажется стоп-словом или его не распознает ни один словарь, этот фрагмент не будет
учитываться при индексации и поиске. Обычно результат определяет первый же словарь, который
возвращает не NULL, и остальные словари уже не проверяются; однако фильтрующий словарь мо-
жет заменить полученное слово другим, которое и будет передано следующим словарям.
Общее правило настройки списка словарей заключается в том, чтобы поставить наиболее частные
и специфические словари в начале, затем перечислить более общие и закончить самым общим
словарём, например стеммером Snowball или словарём simple, который распознаёт всё. Напри-
мер, для поиска по теме астрономии (конфигурация astro_en) тип фрагментов asciiword (слово из
букв ASCII) можно связать со словарём синонимов астрономических терминов, затем с обычным
английским словарём и наконец со стеммером английских окончаний Snowball:
389Полнотекстовый поиск
ALTER TEXT SEARCH CONFIGURATION astro_en
ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;
Фильтрующий словарь можно включить в любом месте списка, кроме конца, где он будет бесполе-
зен. Фильтрующие словари бывают полезны для частичной нормализации слов и упрощения зада-
чи следующих словарей. Например, фильтрующий словарь может удалить из текста диакритиче-
ские знаки, как это делает модуль unaccent.
12.6.1. Стоп-слова
Стоп-словами называются слова, которые встречаются очень часто, практически в каждом доку-
менте, и поэтому не имеют различительной ценности. Таким образом, при полнотекстовом поиске
их можно игнорировать. Например, в каждом английском тексте содержатся артикли a и the, так
что хранить их в индексе бессмысленно. Однако стоп-слова влияют на позиции лексем в значении
tsvector, от чего, в свою очередь, зависит ранжирование:
SELECT to_tsvector('english','in the list of stop words');
to_tsvector
----------------------------
'list':3 'stop':5 'word':6
В результате отсутствуют позиции 1,2,4, потому что фрагменты в этих позициях оказались стоп-
словами. Ранги, вычисленные для документов со стоп-словами и без них, могут значительно раз-
личаться:
SELECT ts_rank_cd (to_tsvector('english','in the list of stop words'),
to_tsquery('list &amp; stop'));
ts_rank_cd
------------
0.05
SELECT ts_rank_cd (to_tsvector('english','list stop words'),
to_tsquery('list &amp; stop'));
ts_rank_cd
------------
0.1
Как именно обрабатывать стоп-слова, определяет сам словарь. Например, словари ispell снача-
ла нормализуют слова, а затем просматривают список стоп-слов, тогда как стеммеры Snowball
просматривают свой список стоп-слов в первую очередь. Это различие в поведении объясняется
стремлением уменьшить шум.
12.6.2. Простой словарь
Работа шаблона словарей simple сводится к преобразованию входного фрагмента в нижний ре-
гистр и проверки результата по файлу со списком стоп-слов. Если это слово находится в файле,
словарь возвращает пустой массив и фрагмент исключается из дальнейшего рассмотрения. В про-
тивном случае словарь возвращает в качестве нормализованной лексемы слово в нижнем регистре.
Этот словарь можно настроить и так, чтобы все слова, кроме стоп-слов, считались неопознанными
и передавались следующему словарю в списке.
Определить словарь на основе шаблона simple можно так:
CREATE TEXT SEARCH DICTIONARY public.simple_dict (
TEMPLATE = pg_catalog.simple,
STOPWORDS = english
);
Здесь english — базовое имя файла со стоп-словами. Полным именем файла будет $SHAREDIR/
tsearch_data/english.stop, где $SHAREDIR указывает на каталог с общими данными PostgreSQL,
часто это /usr/local/share/postgresql (точно узнать его можно с помощью команды pg_config
390Полнотекстовый поиск
--sharedir). Этот текстовый файл должен содержать просто список слов, по одному слову в строке.
Пустые строки и окружающие пробелы игнорируются, все символы переводятся в нижний регистр
и на этом обработка файла заканчивается.
Теперь мы можем проверить наш словарь:
SELECT ts_lexize('public.simple_dict','YeS');
ts_lexize
-----------
{yes}
SELECT ts_lexize('public.simple_dict','The');
ts_lexize
-----------
{}
Мы также можем настроить словарь так, чтобы он возвращал NULL вместо слова в нижнем реги-
стре, если оно не находится в файле стоп-слов. Для этого нужно присвоить параметру Accept зна-
чение false. Продолжая наш пример:
ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false );
SELECT ts_lexize('public.simple_dict','YeS');
ts_lexize
-----------
SELECT ts_lexize('public.simple_dict','The');
ts_lexize
-----------
{}
Со значением Accept = true (по умолчанию) словарь simple имеет смысл включать только в конце
списка словарей, так как он никогда не передаст фрагмент следующему словарю. И напротив,
Accept = false имеет смысл, только если за ним следует ещё минимум один словарь.
Внимание
Большинство словарей работают с дополнительными файлами, например, файлами
стоп-слов. Содержимое этих файлов должно иметь кодировку UTF-8. Если база данных
работает в другой кодировке, они будут переведены в неё, когда сервер будет загру-
жать их.
Внимание
Обычно в рамках одного сеанса дополнительный файл словаря загружается только
один раз, при первом использовании. Если же вы измените его и захотите, чтобы суще-
ствующие сеансы работали с новым содержимым, выполните для этого словаря коман-
ду ALTER TEXT SEARCH DICTIONARY. Это обновление словаря может быть «фиктивным»,
фактически не меняющим значения никаких параметров.
12.6.3. Словарь синонимов
Этот шаблон словарей используется для создания словарей, заменяющих слова синонимами. Сло-
восочетания такие словари не поддерживают (используйте для этого тезаурус (Подраздел 12.6.4)).
Словарь синонимов может помочь в преодолении лингвистических проблем, например, не дать
391Полнотекстовый поиск
стеммеру английского уменьшить слово «Paris» до «pari». Для этого достаточно поместить в сло-
варь синонимов строку Paris paris и поставить этот словарь перед словарём english_stem. На-
пример:
SELECT * FROM ts_debug('english', 'Paris');
alias |
description | token| dictionaries | dictionary | lexemes
----------+----------------+------+---------------+-------------+--------
asciiword| Word, all ASCII| Paris| {english_stem}| english_stem| {pari}
CREATE TEXT SEARCH DICTIONARY my_synonym (
TEMPLATE = synonym,
SYNONYMS = my_synonyms
);
ALTER TEXT SEARCH CONFIGURATION english
ALTER MAPPING FOR asciiword
WITH my_synonym, english_stem;
SELECT * FROM ts_debug('english', 'Paris');
alias |
description | token| dictionaries | dictionary| lexemes
----------+----------------+------+--------------+-----------+--------
asciiword| Word, all ASCII| Paris| {my_synonym, | my_synonym| {paris}
|
|
| english_stem}|
|
Шаблон synonym принимает единственный параметр, SYNONYMS, в котором задаётся базовое имя
его файла конфигурации — в данном примере это my_synonyms. Полным именем файла будет
$SHAREDIR/tsearch_data/my_synonyms.syn (где $SHAREDIR указывает на каталог общих данных
PostgreSQL). Содержимое этого файла должны составлять строки с двумя словами в каждой (пер-
вое — заменяемое слово, а второе — его синоним), разделёнными пробелами. Пустые строки и
окружающие пробелы при разборе этого файла игнорируются.
Шаблон synonym также принимает необязательный параметр CaseSensitive, который по умолча-
нию имеет значение false. Когда CaseSensitive равен false, слова в файле синонимов перево-
дятся в нижний регистр, вместе с проверяемыми фрагментами. Если же он не равен true, регистр
слов в файле и проверяемых фрагментов не меняются, они сравниваются «как есть».
В конце синонима в этом файле можно добавить звёздочку (*), тогда этот синоним будет рассмат-
риваться как префикс. Эта звёздочка будет игнорироваться в to_tsvector(), но to_tsquery() из-
менит результат, добавив в него маркер сопоставления префикса (см. Подраздел 12.3.2). Напри-
мер, предположим, что файл $SHAREDIR/tsearch_data/synonym_sample.syn имеет следующее со-
держание:
postgres
postgresql
postgre pgsql
gogle
googl
indices index*
pgsql
pgsql
С ним мы получим такие результаты:
mydb=# CREATE TEXT SEARCH DICTIONARY
syn (template=synonym, synonyms='synonym_sample');
mydb=# SELECT ts_lexize('syn','indices');
ts_lexize
-----------
{index}
(1 row)
mydb=# CREATE TEXT SEARCH CONFIGURATION tst (copy=simple);
mydb=# ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword
392Полнотекстовый поиск
WITH syn;
mydb=# SELECT to_tsvector('tst','indices');
to_tsvector
-------------
'index':1
(1 row)
mydb=# SELECT to_tsquery('tst','indices');
to_tsquery
------------
'index':*
(1 row)
mydb=# SELECT 'indexes are very useful'::tsvector;
tsvector
---------------------------------
'are' 'indexes' 'useful' 'very'
(1 row)
mydb=# SELECT 'indexes are very useful'::tsvector @@
to_tsquery('tst','indices');
?column?
----------
t
(1 row)
12.6.4. Тезаурус
Тезаурус (или сокращённо TZ) содержит набор слов и информацию о связях слов и словосочета-
ний, то есть более широкие понятия (Broader Terms, BT), более узкие понятия (Narrow Terms, NT),
предпочитаемые названия, исключаемые названия, связанные понятия и т. д.
В основном тезаурус заменяет исключаемые слова и словосочетания предпочитаемыми и может
также сохранить исходные слова для индексации. Текущая реализация тезауруса в PostgreSQL
представляет собой расширение словаря синонимов с поддержкой фраз. Конфигурация тезауруса
определяется файлом следующего формата:
# это комментарий
образец слов(а) : индексируемые слова
другой образец слов(а) : другие индексируемые слова
...
Здесь двоеточие (:) служит разделителем между исходной фразой и её заменой.
Прежде чем проверять соответствие фраз, тезаурус нормализует файл конфигурации, используя
внутренний словарь (который указывается в конфигурации словаря-тезауруса). Этот внутренний
словарь для тезауруса может быть только одним. Если он не сможет распознать какое-либо слово,
произойдёт ошибка. В этом случае необходимо либо исключить это слово, либо добавить его во
внутренний словарь. Также можно добавить звёздочку (*) перед индексируемыми словами, чтобы
они не проверялись по внутреннему словарю, но все слова-образцы должны быть известны внут-
реннему словарю.
Если входному фрагменту соответствуют несколько фраз в этом списке, тезаурус выберет самое
длинное определение, а если таких окажется несколько, самое последнее из них.
Выделить во фразе какие-то стоп-слова нельзя; вместо этого можно вставить ? в том месте, где
может оказаться стоп-слово. Например, в предположении, что a и the — стоп-слова по внутреннему
словарю:
? one ? two : swsw
393Полнотекстовый поиск
соответствует входным строкам a one the two и the one a two, так что обе эти строки будут
заменены на swsw.
Как и обычный словарь, тезаурус должен привязываться к лексемам определённых типов. Так как
тезаурус может распознавать фразы, он должен запоминать своё состояние и взаимодействовать с
анализатором. Учитывая свои привязки, он может либо обрабатывать следующий фрагмент, либо
прекратить накопление фразы. Поэтому настройка тезаурусов в системе требует особого внима-
ния. Например, если привязать тезаурус только к типу фрагментов asciiword, тогда определение
в тезаурусе one 7 не будет работать, так как этот тезаурус не связан с типом uint.
Внимание
Тезаурусы используются при индексации, поэтому при любом изменении параметров
или содержимого тезауруса необходима переиндексация. Для большинства других ти-
пов словарей при небольших изменениях, таких как удаление и добавление стоп-слов,
переиндексация не требуется.
12.6.4.1. Конфигурация тезауруса
Для создания нового словаря-тезауруса используется шаблон thesaurus. Например:
CREATE TEXT SEARCH DICTIONARY thesaurus_simple (
TEMPLATE = thesaurus,
DictFile = mythesaurus,
Dictionary = pg_catalog.english_stem
);
Здесь:
• thesaurus_simple — имя нового словаря
• mythesaurus — базовое имя файла конфигурации тезауруса. (Полным путём к файлу будет
$SHAREDIR/tsearch_data/mythesaurus.ths, где $SHAREDIR указывает на каталог общих данных
PostgreSQL.)
• pg_catalog.english_stem — внутренний словарь (в данном случае, это стеммер Snowball для
английского) для нормализации тезауруса. Заметьте, что внутренний словарь имеет собствен-
ную конфигурацию (например, список стоп-слов), но здесь она не рассматривается.
Теперь тезаурус thesaurus_simple можно связать с желаемыми типами фрагментов в конфигура-
ции, например так:
ALTER TEXT SEARCH CONFIGURATION english
ALTER MAPPING FOR asciiword, asciihword, hword_asciipart
WITH thesaurus_simple;
12.6.4.2. Пример тезауруса
Давайте рассмотрим простой астрономический тезаурус thesaurus_astro, содержащий несколько
астрономических терминов:
supernovae stars : sn
crab nebulae : crab
Ниже мы создадим словарь и привяжем некоторые типы фрагментов к астрономическому тезау-
русу и английскому стеммеру:
CREATE TEXT SEARCH DICTIONARY thesaurus_astro (
TEMPLATE = thesaurus,
DictFile = thesaurus_astro,
Dictionary = english_stem
);
ALTER TEXT SEARCH CONFIGURATION russian
394Полнотекстовый поиск
ALTER MAPPING FOR asciiword, asciihword, hword_asciipart
WITH thesaurus_astro, english_stem;
Теперь можно проверить, как он работает. Функция ts_lexize не очень полезна для проверки теза-
уруса, так как она обрабатывает входную строку как один фрагмент. Вместо неё мы можем исполь-
зовать функции plainto_tsquery и to_tsvector, которые разбивают входную строку на несколько
фрагментов:
SELECT plainto_tsquery('supernova star');
plainto_tsquery
-----------------
'sn'
SELECT to_tsvector('supernova star');
to_tsvector
-------------
'sn':1
В принципе так же можно использовать to_tsquery, если заключить аргумент в кавычки:
SELECT to_tsquery(' ''supernova star''');
to_tsquery
------------
'sn'
Заметьте, что supernova star совпадает с supernovae stars в thesaurus_astro, так как мы под-
ключили стеммер english_stem в определении тезауруса. Этот стеммер удалил конечные буквы
e и s.
Чтобы проиндексировать исходную фразу вместе с заменой, её нужно просто добавить в правую
часть соответствующего определения:
supernovae stars : sn supernovae stars
SELECT plainto_tsquery('supernova star');
plainto_tsquery
-----------------------------
'sn' &amp; 'supernova' &amp; 'star'
12.6.5. Словарь Ispell
Шаблон словарей Ispell поддерживает морфологические словари, которые могут сводить множе-
ство разных лингвистических форм слова к одной лексеме. Например, английский словарь Ispell
может связать вместе все склонения и спряжения ключевого слова bank: banking, banked, banks,
banks',bank's и т. п.
Стандартный дистрибутив PostgreSQL не включает файлы конфигурации Ispell. Загрузить словари
для множества языков можно со страницы Ispell. Кроме того, поддерживаются и другие современ-
ные форматы словарей: MySpell (OO &lt; 2.0.1) и Hunspell (OO &gt;= 2.0.2). Большой набор соответству-
ющих словарей можно найти на странице OpenOffice Wiki.
Чтобы создать словарь Ispell, выполните следующие действия:
• загрузите файлы конфигурации словаря. Пакет с дополнительным словарём OpenOffice имеет
расширение .oxt. Из него необходимо извлечь файлы .aff и .dic, и сменить их расширения
на .affix и .dict, соответственно. Для некоторых файлов словарей также необходимо преоб-
разовать символы в кодировку UTF-8 с помощью, например, таких команд (для норвежского
языка):
iconv -f ISO_8859-1 -t UTF-8 -o nn_no.affix nn_NO.aff
iconv -f ISO_8859-1 -t UTF-8 -o nn_no.dict nn_NO.dic
• скопируйте файлы в каталог $SHAREDIR/tsearch_data
395Полнотекстовый поиск
• загрузите эти файлы в PostgreSQL следующей командой:
CREATE TEXT SEARCH DICTIONARY english_hunspell (
TEMPLATE = ispell,
DictFile = en_us,
AffFile = en_us,
Stopwords = english);
Здесь параметры DictFile, AffFile и StopWords определяют базовые имена файлов словаря, аф-
фиксов и стоп-слов. Файл стоп-слов должен иметь тот же формат, что рассматривался выше в опи-
сании словаря simple. Формат других файлов здесь не рассматривается, но его можно узнать по
вышеуказанным веб-адресам.
Словари Ispell обычно воспринимают ограниченный набор слов, так что за ними следует подклю-
чить другой, более общий словарь, например, Snowball, который принимает всё.
Файл .affix для Ispell имеет такую структуру:
prefixes
flag *A:
.
suffixes
flag T:
E
[^AEIOU]Y
[AEIOU]Y
[^EY]
&gt; RE # As in enter &gt; reenter
&gt;
&gt;
&gt;
&gt; ST
-Y,IEST
EST
EST #
#
#
#
As
As
As
As
in
in
in
in
late &gt; latest
dirty &gt; dirtiest
gray &gt; grayest
small &gt; smallest
А файл .dict — такую:
lapse/ADGRS
lard/DGRS
large/PRTY
lark/MRS
Формат файла .dict следующий:
basic_form/affix_class_name
В файле .affix каждый флаг аффиксов описывается в следующем формате:
условие &gt; [-отсекаемые_буквы,] добавляемый_аффикс
Здесь условие записывается в формате, подобном формату регулярных выражений. В нём возмож-
но описать группы [...] и [^...]. Например, запись [AEIOU]Y означает, что последняя буква сло-
ва — "y", а предпоследней может быть "a", "e", "i", "o" или "u". Запись [^EY] означает, что по-
следняя буква не "e" и не "y".
Словари Ispell поддерживают разделение составных слов, что бывает полезно. Заметьте, что для
этого в файле аффиксов нужно пометить специальным оператором compoundwords controlled сло-
ва, которые могут участвовать в составных образованиях:
compoundwords
controlled z
Вот как это работает для норвежского языка:
SELECT ts_lexize('norwegian_ispell',
'overbuljongterningpakkmesterassistent');
{over,buljong,terning,pakk,mester,assistent}
SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk');
{sjokoladefabrikk,sjokolade,fabrikk}
Формат MySpell представляет собой подмножество формата Hunspell. Файл .affix словаря
Hunspell имеет следующую структуру:
396Полнотекстовый поиск
PFX
PFX
SFX
SFX
SFX
SFX
SFX
A Y 1
A
0
T N 4
T
0
T
y
T
0
T
0
re .
st
iest
est
est e
[^aeiou]y
[aeiou]y
[^ey]
Первая строка класса аффиксов — заголовок. Поля правил аффиксов указываются после заголов-
ка:
•
•
•
•
•
имя параметра (PFX или SFX)
флаг (имя класса аффиксов)
отсекаемые символы в начале (в префиксе) или в конце (в суффиксе) слова
добавляемый аффикс
условие в формате, подобном регулярным выражениям.
Файл .dict подобен файлу .dict словаря Ispell:
larder/M
lardy/RT
large/RSPMYT
largehearted
Примечание
Словарь MySpell не поддерживает составные слова. С другой стороны, Hunspell под-
держивает множество операции с ними, но в настоящее время PostgreSQL использует
только самые простые из этого множества.
12.6.6. Словарь Snowball
Шаблон словарей Snowball основан на проекте Мартина Потера, изобретателя популярного алго-
ритма стемминга для английского языка. Сейчас Snowball предлагает алгоритмы и для многих
других языков (за подробностями обратитесь на сайт Snowball). Каждый алгоритм знает, как для
данного языка свести распространённые словоформы к начальной форме. Для словаря Snowball
задаётся обязательный параметр language, определяющий, какой именно стеммер использовать,
и может задаваться параметр stopword, указывающий файл со списком исключаемых слов. (Стан-
дартные списки стоп-слов PostgreSQL используется также в и проекте Snowball.) Например, встро-
енное определение выглядит так
CREATE TEXT SEARCH DICTIONARY english_stem (
TEMPLATE = snowball,
Language = english,
StopWords = english
);
Формат файла стоп-слов не отличается от рассмотренного ранее.
Словарь Snowball распознаёт любые фрагменты, даже если он не может упростить слова, так что
он должен быть самым последним в списке словарей. Помещать его перед другими словарями нет
смысла, так как после него никакой фрагмент не будет передан следующему словарю.
12.7. Пример конфигурации
Конфигурация текстового поиска определяет всё, что необходимо для преобразования документа
в формат tsvector: анализатор, который будет разбивать текст на фрагменты, и словари, которые
будут преобразовывать фрагменты в лексемы. При каждом вызове to_tsvector или to_tsquery
обязательно используется конфигурация текстового поиска. В конфигурации сервера есть пара-
397Полнотекстовый поиск
метр default_text_search_config, задающий имя конфигурации текстового поиска по умолчанию,
которая будет использоваться, когда при вызове функций поиска соответствующий аргумент не
определён. Этот параметр можно задать в postgresql.conf или установить в рамках отдельного
сеанса с помощью команды SET.
В системе есть несколько встроенных конфигураций текстового поиска и вы можете легко допол-
нить их своими. Для удобства управления объектами текстового поиска в PostgreSQL реализованы
соответствующие SQL-команды и специальные команды в psql, выводящие информацию об этих
объектах (Раздел 12.10).
В качестве примера использования этих команд мы создадим конфигурацию pg, взяв за основу
встроенную конфигурацию english:
CREATE TEXT SEARCH CONFIGURATION public.pg ( COPY = pg_catalog.english );
Мы будем использовать список синонимов, связанных с PostgreSQL, в файле $SHAREDIR/
tsearch_data/pg_dict.syn. Этот файл содержит строки:
postgres
pgsql
postgresql
pg
pg
pg
Мы определим словарь синонимов следующим образом:
CREATE TEXT SEARCH DICTIONARY pg_dict (
TEMPLATE = synonym,
SYNONYMS = pg_dict
);
Затем мы зарегистрируем словарь Ispell english_ispell, у которого есть собственные файлы кон-
фигурации:
CREATE TEXT SEARCH DICTIONARY english_ispell (
TEMPLATE = ispell,
DictFile = english,
AffFile = english,
StopWords = english
);
Теперь мы можем настроить сопоставления для слов в конфигурации pg:
ALTER TEXT SEARCH CONFIGURATION pg
ALTER MAPPING FOR asciiword, asciihword, hword_asciipart,
word, hword, hword_part
WITH pg_dict, english_ispell, english_stem;
Мы решили не индексировать и не учитывать при поиске некоторые типы фрагментов, которые не
обрабатываются встроенной конфигурацией:
ALTER TEXT SEARCH CONFIGURATION pg
DROP MAPPING FOR email, url, url_path, sfloat, float;
Теперь мы можем протестировать нашу конфигурацию:
SELECT * FROM ts_debug('public.pg', '
PostgreSQL, the highly scalable, SQL compliant, open source
object-relational database management system, is now undergoing
beta testing of the next version of our software.
');
И наконец мы выбираем в текущем сеансе эту конфигурацию, созданную в схеме public:
=&gt; \dF
List of text search configurations
398Полнотекстовый поиск
Schema | Name | Description
---------+------+-------------
public | pg
|
SET default_text_search_config = 'public.pg';
SET
SHOW default_text_search_config;
default_text_search_config
----------------------------
public.pg
12.8. Тестирование и отладка текстового поиска
Поведение нестандартной конфигурации текстового поиска по мере её усложнения может стать
непонятным. В этом разделе описаны функции, полезные для тестирования объектов текстового
поиска. Вы можете тестировать конфигурацию как целиком, так и по частям, отлаживая анализа-
торы и словари по отдельности.
12.8.1. Тестирование конфигурации
Созданную конфигурацию текстового поиска можно легко протестировать с помощью функции
ts_debug.
ts_debug([конфигурация regconfig,] документ text,
OUT псевдоним text,
OUT описание text,
OUT фрагмент text,
OUT словари regdictionary[],
OUT словарь regdictionary,
OUT лексемы text[])
returns setof record
ts_debug выводит информацию обо всех фрагментах данного документа, которые были выданы
анализатором и обработаны настроенными словарями. Она использует конфигурацию, указанную
в аргументе config, или default_text_search_config, если этот аргумент опущен.
ts_debug возвращает по одной строке для каждого фрагмента, найденного в тексте анализатором.
Эта строка содержит следующие столбцы:
•
•
•
•
синоним text — краткое имя типа фрагмента
описание text — описание типа фрагмента
фрагмент text — текст фрагмента
словари regdictionary[] — словари, назначенные в конфигурации для фрагментов такого ти-
па
• словарь regdictionary — словарь, распознавший этот фрагмент, или NULL, если подходящего
словаря не нашлось
• лексемы text[] — лексемы, выданные словарём, распознавшим фрагмент, или NULL, если под-
ходящий словарь не нашёлся; может быть также пустым массивом ({}), если фрагмент распо-
знан как стоп-слово
Простой пример:
SELECT * FROM ts_debug('english',
'a fat cat sat on a mat - it ate a fat rats');
alias |
description | token| dictionaries | dictionary |lexemes
----------+----------------+------+---------------+-------------+-------
asciiword| Word, all ASCII| a
| {english_stem}| english_stem| {}
blank
| Space symbols |
| {}
|
|
399Полнотекстовый поиск
asciiword|
blank
|
asciiword|
blank
|
asciiword|
blank
|
asciiword|
blank
|
asciiword|
blank
|
asciiword|
blank
|
blank
|
asciiword|
blank
|
asciiword|
blank
|
asciiword|
blank
|
asciiword|
blank
|
asciiword|
Word,
Space
Word,
Space
Word,
Space
Word,
Space
Word,
Space
Word,
Space
Space
Word,
Space
Word,
Space
Word,
Space
Word,
Space
Word,
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
symbols |
all ASCII|
fat
|
|
cat |
|
sat |
|
on
|
|
a
|
|
mat |
|
-
|
it
|
|
ate |
|
a
|
|
fat |
|
rats |
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
{}
|
{english_stem}|
english_stem|
|
english_stem|
|
english_stem|
|
english_stem|
|
english_stem|
|
english_stem|
|
|
english_stem|
|
english_stem|
|
english_stem|
|
english_stem|
|
english_stem|
{fat}
{cat}
{sat}
{}
{}
{mat}
{}
{ate}
{}
{fat}
{rat}
Для более полной демонстрации мы сначала создадим конфигурацию public.english и словарь
Ispell для английского языка:
CREATE TEXT SEARCH CONFIGURATION public.english
( COPY = pg_catalog.english );
CREATE TEXT SEARCH DICTIONARY english_ispell (
TEMPLATE = ispell,
DictFile = english,
AffFile = english,
StopWords = english
);
ALTER TEXT SEARCH CONFIGURATION public.english
ALTER MAPPING FOR asciiword WITH english_ispell, english_stem;
SELECT * FROM ts_debug('public.english','The Brightest supernovaes');
alias | description |
token
| dictionaries |dictionary| lexemes
---------+-------------+-----------+----------- ---+----------+-----------
asciiword|Word,
|The
|{english_ispell|english_ |{}
| all ASCII
|
|,english_stem} |ispell
|
blank
|Space symbols|
|{}
|
|
|
|
|
|
|
asciiword|Word,
|Brightest |{english_ispell|english_ |{bright}
|all ASCII
|
|,english_stem} |ispell
|
blank
|Space symbols|
| {}
|
|
|
|
|
|
|
asciiword|Word,
|supernovaes|{english_ispell|english_ |{supernova}
|all ASCII
|
|,english_stem} |stem
|
В этом примере слово Brightest было воспринято анализатором как фрагмент ASCII word
(синоним asciiword). Для этого типа фрагментов список словарей включает english_ispell и
english_stem. Данное слово было распознано словарём english_ispell, который свёл его к bright.
Слово supernovaes оказалось незнакомо словарю english_ispell, так что оно было передано сле-
дующему словарю, который его благополучно распознал (на самом деле english_stem — это стем-
мер Snowball, который распознаёт всё, поэтому он включён в список словарей последним).
400Полнотекстовый поиск
Слово The было распознано словарём english_ispell как стоп-слово (см. Подраздел 12.6.1) и по-
этому не будет индексироваться. Пробелы тоже отбрасываются, так как в данной конфигурации
для них нет словарей.
Вы можете уменьшить ширину вывода, явно перечислив только те столбцы, которые вы хотите
видеть:
SELECT alias, token, dictionary, lexemes
FROM ts_debug('public.english','The Brightest supernovaes');
alias
|
token
|
dictionary
|
lexemes
-----------+-------------+----------------+-------------
asciiword | The
| english_ispell | {}
blank
|
|
|
asciiword | Brightest
| english_ispell | {bright}
blank
|
|
|
asciiword | supernovaes | english_stem
| {supernova}
12.8.2. Тестирование анализатора
Следующие функции позволяют непосредственно протестировать анализатор текстового поиска.
ts_parse(имя_анализатора text, документ text,
OUT код_фрагмента integer, OUT фрагмент text) returns setof record
ts_parse(oid_анализатора oid, документ text,
OUT код_фрагмента integer, OUT фрагмент text) returns setof record
ts_parse разбирает данный документ и возвращает набор записей, по одной для каждого извле-
чённого фрагмента. Каждая запись содержит код_фрагмента, код назначенного типа фрагмента,
и фрагмент, собственно текст фрагмента. Например:
SELECT * FROM ts_parse('default', '123 - a number');
tokid | token
-------+--------
22 | 123
12 |
12 | -
1 | a
12 |
1 | number
ts_token_type(имя_анализатора text, OUT код_фрагмента integer,
OUT псевдоним text, OUT описание text) returns setof record
ts_token_type(oid_анализатора oid, OUT код_фрагмента integer,
OUT псевдоним text, OUT описание text) returns setof record
ts_token_type возвращает таблицу, описывающую все типы фрагментов, которые может распо-
знать анализатор. Для каждого типа в этой таблице указывается его целочисленный код_фрагмен-
та, псевдоним , с которым этот тип фигурирует в командах, и краткое description. Например:
SELECT * FROM ts_token_type('default');
tokid |
alias
|
description
-------+-----------------+------------------------------------------
1 | asciiword
| Word, all ASCII
2 | word
| Word, all letters
3 | numword
| Word, letters and digits
4 | email
| Email address
5 | url
| URL
6 | host
| Host
7 | sfloat
| Scientific notation
8 | version
| Version number
401Полнотекстовый поиск
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
hword_numpart
hword_part
hword_asciipart
blank
tag
protocol
numhword
asciihword
hword
url_path
file
float
int
uint
entity
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
Hyphenated word part, letters and digits
Hyphenated word part, all letters
Hyphenated word part, all ASCII
Space symbols
XML tag
Protocol head
Hyphenated word, letters and digits
Hyphenated word, all ASCII
Hyphenated word, all letters
URL path
File or path name
Decimal notation
Signed integer
Unsigned integer
XML entity
12.8.3. Тестирование словаря
Для тестирования словаря предназначена функция ts_lexize.
ts_lexize(словарь regdictionary, фрагмент text) returns text[]
ts_lexize возвращает массив лексем, если входной фрагмент известен словарю, либо пустой мас-
сив, если этот фрагмент считается в словаре стоп-словом, либо NULL, если он не был распознан.
Примеры:
SELECT ts_lexize('english_stem', 'stars');
ts_lexize
-----------
{star}
SELECT ts_lexize('english_stem', 'a');
ts_lexize
-----------
{}
Примечание
Функция ts_lexize принимает одиночный фрагмент, а не просто текст. Вот пример
возможного заблуждения:
SELECT ts_lexize('thesaurus_astro','supernovae stars') is null;
?column?
----------
t
Хотя фраза supernovae stars есть в тезаурусе thesaurus_astro, ts_lexize не работа-
ет, так как она не разбирает входной текст, а воспринимает его как один фрагмент.
Поэтому для проверки тезаурусов следует использовать функции plainto_tsquery и
to_tsvector, например:
SELECT plainto_tsquery('supernovae stars');
plainto_tsquery
-----------------
'sn'
12.9. Типы индексов GIN и GiST
402Полнотекстовый поиск
Для ускорения полнотекстового поиска можно использовать индексы двух видов. Заметьте, что эти
индексы не требуются для поиска, но если по какому-то столбцу поиск выполняется регулярно,
обычно желательно её индексировать.
CREATE INDEX имя ON таблица USING GIN (столбец);
Создаёт индекс на базе GIN (Generalized Inverted Index, Обобщённый Инвертированный Ин-
декс). Столбец должен иметь тип tsvector.
CREATE INDEX имя ON таблица USING GIST (столбец);
Создаёт индекс на базе GiST (Generalized Search Tree, Обобщённое дерево поиска). Здесь стол-
бец может иметь тип tsvector или tsquery.
Более предпочтительными для текстового поиска являются индексы GIN. Будучи инвертирован-
ными индексами, они содержат записи для всех отдельных слов (лексем) с компактным списком
мест их вхождений. При поиске нескольких слов можно найти первое, а затем воспользоваться
индексом и исключить строки, в которых дополнительные слова отсутствуют. Индексы GIN хранят
только слова (лексемы) из значений tsvector, и теряют информацию об их весах. Таким образом
для выполнения запроса с весами потребуется перепроверить строки в таблице.
Индекс GiST допускает неточности, то есть он допускает ложные попадания и поэтому их нужно
исключать дополнительно, сверяя результат с фактическими данными таблицы. (PostgreSQL дела-
ет это автоматически.) Индексы GiST являются неточными, так как все документы в них представ-
ляются сигнатурой фиксированной длины. Эта сигнатура создаётся в результате представления
присутствия каждого слова как одного бита в строке из n-бит, а затем логического объединения
этих битовых строк. Если двум словам будет соответствовать одна битовая позиция, попадание
оказывается ложным. Если для всех слов оказались установлены соответствующие биты (в случае
фактического или ложного попадания), для проверки правильности предположения о совпадении
слов необходимо прочитать строку таблицы.
Неточность индекса приводит к снижению производительности из-за дополнительных обращений
к записям таблицы, для которых предположение о совпадении оказывается ложным. Так как про-
извольный доступ к таблице обычно не бывает быстрым, это ограничивает применимость индексов
GiST. Вероятность ложных попаданий зависит от ряда факторов, например от количества уникаль-
ных слов, так что его рекомендуется сокращать, применяя словари.
Заметьте, что построение индекса GIN часто можно ускорить, увеличив maintenance_work_mem,
тогда как время построения индекса GiST не зависит от этого параметра.
Правильно используя индексы GIN и GiST и разделяя большие коллекции документов на секции,
можно реализовать очень быстрый поиск с возможностью обновления «на лету». Секционировать
данные можно как на уровне базы, с использованием наследования таблиц, так и распределив до-
кументы по разным серверам и затем собирая внешние результаты, например, средствами доступа
к сторонним данным. Последний вариант возможен благодаря тому, что функции ранжирования
используют только локальную информацию.
12.10. Поддержка psql
Информацию об объектах конфигурации текстового поиска можно получить в psql с помощью сле-
дующего набора команд:
\dF{d,p,t}[+] [ШАБЛОН]
Необязательный + в этих командах включает более подробный вывод.
В необязательном параметре ШАБЛОН может указываться имя объекта текстового поиска, возможно
дополненное именем схемы. Если ШАБЛОН не указан, выводится информация обо всех видимых объ-
ектах. ШАБЛОН может содержать регулярное выражение с разными масками для схемы и объекта.
Это иллюстрируют следующие примеры:
=&gt; \dF *fulltext*
403Полнотекстовый поиск
List of text search configurations
Schema | Name
| Description
--------+--------------+-------------
public | fulltext_cfg |
=&gt; \dF *.fulltext*
List of text search configurations
Schema
| Name
| Description
----------+----------------------------
fulltext | fulltext_cfg |
public
| fulltext_cfg |
Возможны следующие команды:
\dF[+] [ШАБЛОН]
Список конфигураций текстового поиска (добавьте + для дополнительных сведений).
=&gt; \dF russian
List of text search configurations
Schema
| Name
|
Description
------------+---------+------------------------------------
pg_catalog | russian | configuration for russian language
=&gt; \dF+ russian
Text search configuration "pg_catalog.russian"
Parser: "pg_catalog.default"
Token
| Dictionaries
-----------------+--------------
asciihword
| english_stem
asciiword
| english_stem
email
| simple
file
| simple
float
| simple
host
| simple
hword
| russian_stem
hword_asciipart | english_stem
hword_numpart
| simple
hword_part
| russian_stem
int
| simple
numhword
| simple
numword
| simple
sfloat
| simple
uint
| simple
url
| simple
url_path
| simple
version
| simple
word
| russian_stem
\dFd[+] [ШАБЛОН]
Список словарей текстового поиска (добавьте + для дополнительных сведений).
=&gt; \dFd
List of text search dictionaries
Schema
|
Name
|
Description
-----------+----------------+-------------------------------------------
pg_catalog | danish_stem
| snowball stemmer for danish language
pg_catalog | dutch_stem
| snowball stemmer for dutch language
pg_catalog | english_stem
| snowball stemmer for english language
pg_catalog | finnish_stem
| snowball stemmer for finnish language
404Полнотекстовый поиск
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
pg_catalog
|
|
|
|
|
|
|
|
|
|
|
|
french_stem
|
german_stem
|
hungarian_stem |
italian_stem
|
norwegian_stem |
portuguese_stem|
romanian_stem |
russian_stem
|
simple
|
spanish_stem
|
swedish_stem
|
turkish_stem
|
snowball stemmer for french language
snowball stemmer for german language
snowball stemmer for hungarian language
snowball stemmer for italian language
snowball stemmer for norwegian language
snowball stemmer for portuguese language
snowball stemmer for romanian language
snowball stemmer for russian language
simple dictionary: just lower case and ...
snowball stemmer for spanish language
snowball stemmer for swedish language
snowball stemmer for turkish language
\dFp[+] [ШАБЛОН]
Список анализаторов текстового поиска (добавьте + для дополнительных сведений).
=&gt; \dFp
List of text search parsers
Schema
| Name
|
Description
------------+---------+---------------------
pg_catalog | default | default word parser
=&gt; \dFp+
Text search parser "pg_catalog.default"
Method
|
Function
| Description
-----------------+----------------+-------------
Start parse
| prsd_start
|
Get next token | prsd_nexttoken |
End parse
| prsd_end
|
Get headline
| prsd_headline |
Get token types | prsd_lextype
|
Token types for parser "pg_catalog.default"
Token name
|
Description
-----------------+------------------------------------------
asciihword
| Hyphenated word, all ASCII
asciiword
| Word, all ASCII
blank
| Space symbols
email
| Email address
entity
| XML entity
file
| File or path name
float
| Decimal notation
host
| Host
hword
| Hyphenated word, all letters
hword_asciipart | Hyphenated word part, all ASCII
hword_numpart
| Hyphenated word part, letters and digits
hword_part
| Hyphenated word part, all letters
int
| Signed integer
numhword
| Hyphenated word, letters and digits
numword
| Word, letters and digits
protocol
| Protocol head
sfloat
| Scientific notation
tag
| XML tag
uint
| Unsigned integer
url
| URL
url_path
| URL path
version
| Version number
word
| Word, all letters
(23 rows)
405Полнотекстовый поиск
\dFt[+] [ШАБЛОН]
Список шаблонов текстового поиска (добавьте + для дополнительных сведений).
=&gt; \dFt
List of text search templates
Schema | Name
|
Description
----------+---------+----------------------------------------------------
pg_catalog|ispell
|ispell dictionary
pg_catalog|simple
|simple dictionary: just lower case and check for ...
pg_catalog|snowball |snowball stemmer
pg_catalog|synonym |synonym dictionary: replace word by its synonym
pg_catalog|thesaurus|thesaurus dictionary: phrase by phrase substitution
12.11. Ограничения
Текущая реализация текстового поиска в PostgreSQL имеет следующие ограничения:
•
•
•
•
•
•
•
Длина лексемы не может превышать 2 килобайта
Длина значения tsvector (лексемы и их позиции) не может превышать 1 мегабайт
64
Число лексем должно быть меньше 2
Значения позиций в tsvector должны быть от 0 до 16383
Расстояние в операторе <N> (ПРЕДШЕСТВУЕТ) типа tsquery не может быть больше 16384
Не больше 256 позиций для одной лексемы
Число узлов (лексемы + операторы) в значении tsquery должно быть меньше 32768
Для сравнения, документация PostgreSQL 8.1 содержала 335 420 слов, из них 10 441 уникальных, а
наиболее часто употребляющееся в ней слово «postgresql» встречается 6 127 раз в 655 документах.
Другой пример — архивы списков рассылки PostgreSQL содержали 910  989 уникальных слов в
57 491 343 лексемах в 461 020 сообщениях.
</N></N></query>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-011/" title="Глава 11. Индексы"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 11. Индексы"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-011/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~32 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-011/" rel="bookmark" title="Глава 11. Индексы" itemprop="url">Глава 11. Индексы</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 11. Индексы</p>

<p>Индексы — это традиционное средство увеличения производительности БД. Используя индекс,
сервер баз данных может находить и извлекать нужные строки гораздо быстрее, чем без него.
Однако с индексами связана дополнительная нагрузка на СУБД в целом, поэтому применять их
следует обдуманно.
11.1. Введение
Предположим, что у нас есть такая таблица:
CREATE TABLE test1 (
id integer,
content varchar
);
и приложение выполняет много подобных запросов:
SELECT content FROM test1 WHERE id = константа;
Если система не будет заранее подготовлена, ей придётся сканировать всю таблицу test1, стро-
ку за строкой, чтобы найти все подходящие записи. Когда таблица test1 содержит большое коли-
чество записей, а этот запрос должен вернуть всего несколько (возможно, одну или ноль), такое
сканирование, очевидно, неэффективно. Но если создать в системе индекс по полю id, она смо-
жет находить строки гораздо быстрее. Возможно, для этого ей понадобится опуститься всего на
несколько уровней в дереве поиска.
Подобный подход часто используется в технической литературе: термины и понятия, которые мо-
гут представлять интерес, собираются в алфавитном указателе в конце книги. Читатель может
просмотреть этот указатель довольно быстро и затем перейти сразу к соответствующей странице,
вместо того, чтобы пролистывать всю книгу в поисках нужного материала. Так же, как задача ав-
тора предугадать, что именно будут искать в книге читатели, задача программиста баз данных —
заранее определить, какие индексы будут полезны.
Создать индекс для столбца id рассмотренной ранее таблицы можно с помощью следующей ко-
манды:
CREATE INDEX test1_id_index ON test1 (id);
Имя индекса test1_id_index может быть произвольным, главное, чтобы оно позволяло понять,
для чего этот индекс.
Для удаления индекса используется команда DROP INDEX. Добавлять и удалять индексы можно в
любое время.
Когда индекс создан, никакие дополнительные действия не требуются: система сама будет обнов-
лять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её
мнению, это будет эффективнее, чем сканирование всей таблицы. Вам, возможно, придётся только
периодически запускать команду ANALYZE для обновления статистических данных, на основе ко-
торых планировщик запросов принимает решения. В Главе 14 вы можете узнать, как определить,
используется ли определённый индекс и при каких условиях планировщик может решить не ис-
пользовать его.
Индексы могут быть полезны также при выполнении команд UPDATE и DELETE с условиями поиска.
Кроме того, они могут применяться в поиске с соединением. То есть, индекс, определённый для
столбца, участвующего в условии соединения, может значительно ускорить запросы с JOIN.
Создание индекса для большой таблицы может занимать много времени. По умолчанию
PostgreSQL позволяет параллельно с созданием индекса выполнять чтение (операторы SELECT)
таблицы, но операции записи (INSERT, UPDATE и DELETE) блокируются до окончания построения
индекса. Для производственной среды это ограничение часто бывает неприемлемым. Хотя есть
356Индексы
возможность разрешить запись параллельно с созданием индексов, при этом нужно учитывать ряд
оговорок — они описаны в подразделе «Неблокирующее построение индексов».
После создания индекса система должна поддерживать его в состоянии, соответствующем данным
таблицы. С этим связаны неизбежные накладные расходы при изменении данных. Таким образом,
индексы, которые используются в запросах редко или вообще никогда, должны быть удалены.
11.2. Типы индексов
PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для
разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы
запросов. По умолчанию команда CREATE INDEX создаёт индексы типа B-дерево, эффективные в
большинстве случаев.
B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые
можно отсортировать в некотором порядке. Точнее, планировщик запросов PostgreSQL может за-
действовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из сле-
дующих операторов:
&lt;
&lt;=
=</p>
<blockquote>
  <p>=</p>

  <p>При обработке конструкций, представимых как сочетание этих операторов, например BETWEEN и
IN, так же может выполняться поиск по индексу-B-дереву. Кроме того, такие индексы могут ис-
пользоваться и в условиях IS NULL и IS NOT NULL по индексированным столбцам.
Также оптимизатор может использовать эти индексы в запросах с операторами сравнения по шаб-
лону LIKE и ~, если этот шаблон определяется константой и он привязан к началу строки — на-
пример, col LIKE ‘foo%’ или col ~ ‘^foo’, но не col LIKE ‘%bar’. Но если ваша база данных
использует не локаль C, для поддержки индексирования запросов с шаблонами вам потребуется
создать индекс со специальным классом операторов; см. Раздел 11.9. Индексы-B-деревья можно
использовать и для ILIKE и ~*, но только если шаблон начинается не с алфавитных символов, то
есть символов, не подверженных преобразованию регистра.
B-деревья могут также применяться для получения данных, отсортированных по порядку. Это не
всегда быстрее простого сканирования и сортировки, но иногда бывает полезно.
Хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может
применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором
=. Создать такой индекс можно следующей командой:
CREATE INDEX имя ON таблица USING HASH (столбец);
GiST-индексы представляют собой не просто разновидность индексов, а инфраструктуру, позволя-
ющую реализовать много разных стратегий индексирования. Как следствие, GiST-индексы могут
применяться с разными операторами, в зависимости от стратегии индексирования (класса опера-
торов). Например, стандартный дистрибутив PostgreSQL включает классы операторов GiST для
нескольких двумерных типов геометрических данных, что позволяет применять индексы в запро-
сах с операторами:
«
&amp;&lt;
&amp;&gt;</p>
  <blockquote>

    <p>«|
&amp;&lt;|
|&amp;&gt;
357Индексы
|»
@&gt;
&lt;@
~=
&amp;&amp;
(Эти операторы описаны в Разделе 9.11.) Классы операторов GiST, включённые в стандартный дис-
трибутив, описаны в Таблице 64.1. В коллекции contrib можно найти и другие классы операторов
GiST, реализованные как отдельные проекты. За дополнительными сведениями обратитесь к Гла-
ве 64.
GiST-индексы также могут оптимизировать поиск «ближайшего соседа», например такой:
SELECT * FROM places ORDER BY location &lt;-&gt; point ‘(101,456)’ LIMIT 10;
который возвращает десять расположений, ближайших к заданной точке. Возможность такого
применения индекса опять же зависит от класса используемого оператора. Операторы, которые
можно использовать таким образом, перечислены в Таблице 64.1, в столбце «Операторы сортиров-
ки».
Индексы SP-GiST, как и GiST, предоставляют инфраструктуру, поддерживающие различные типы
поиска. SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры
данных, такие как деревья квадрантов, k-мерные и префиксные деревья. Например, стандартный
дистрибутив PostgreSQL включает классы операторов SP-GiST для точек в двумерном простран-
стве, что позволяет применять индексы в запросах с операторами:
«</p>

    <p>~=
&lt;@
&lt;^</p>
  </blockquote>
  <p>(Эти операторы описаны в Разделе 9.11.) Классы операторов SP-GiST, включённые в стандартный
дистрибутив, описаны в Таблице 65.1. За дополнительными сведениями обратитесь к Главе 65.
GIN-индексы представляют собой «инвертированные индексы», в которых могут содержаться зна-
чения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный
элемент для значения каждого компонента, и может эффективно работать в запросах, проверяю-
щих присутствие определённых значений компонентов.
Подобно GiST и SP-GiST, индексы GIN могут поддерживать различные определённые пользовате-
лем стратегии и в зависимости от них могут применяться с разными операторами. Например, стан-
дартный дистрибутив PostgreSQL включает класс операторов GIN для массивов, что позволяет
применять индексы в запросах с операторами:
&lt;@
@&gt;
=
&amp;&amp;
(Эти операторы описаны в Разделе 9.18.) Классы операторов GIN, включённые в стандартный дис-
трибутив, описаны в Таблице 66.1. В коллекции contrib и в отдельных проектах можно найти и
много других классов операторов GIN. За дополнительными сведениями обратитесь к Главе 66.
BRIN-индексы (сокращение от Block Range INdexes, Индексы зон блоков) хранят обобщённые све-
дения о значениях, находящихся в физически последовательно расположенных блоках таблицы.
Подобно GiST, SP-GiST и GIN, индексы BRIN могут поддерживать определённые пользователем
стратегии, и в зависимости от них применяться с разными операторами. Для типов данных, имею-
щих линейный порядок сортировки, записям в индексе соответствуют минимальные и максималь-
358Индексы
ные значения данных в столбце для каждой зоны блоков. Это позволяет поддерживать запросы со
следующими операторами:
&lt;
&lt;=
=
=</p>

  <p>Классы операторов BRIN, включённые в стандартный дистрибутив, описаны в Таблице  67.1. За
дополнительными сведениями обратитесь к Главе 67.
11.3. Составные индексы
Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица:
CREATE TABLE test2 (
major int,
minor int,
name varchar
);
(предположим, что вы поместили в неё содержимое каталога /dev) и вы часто выполняете запросы
вида:
SELECT name FROM test2 WHERE major = константа AND minor = константа;
тогда имеет смысл определить индекс, покрывающий оба столбца major и minor. Например:
CREATE INDEX test2_mm_idx ON test2 (major, minor);
В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Число
столбцов в индексе ограничивается 32. (Этот предел можно изменить при компиляции PostgreSQL;
см. файл pg_config_manual.h.)
Составной индекс-B-дерево может применяться в условиях с любым подмножеством столбцов ин-
декса, но наиболее эффективен он при ограничениях по ведущим (левым) столбцам. Точное прави-
ло состоит в том, что сканируемая область индекса определяется условиями равенства с ведущи-
ми столбцами и условиями неравенства с первым столбцом, не участвующим в условии равенства.
Ограничения столбцов правее них также проверяются по индексу, так что обращение к таблице
откладывается, но на размер сканируемой области индекса это уже не влияет. Например, если
есть индекс по столбцам (a, b, c) и условие WHERE a = 5 AND b &gt;= 42 AND c &lt; 77, индекс будет
сканироваться от первой записи a = 5 и b = 42 до последней с a = 5. Записи индекса, в которых
c &gt;= 77, не будут учитываться, но, тем не менее, будут просканированы. Этот индекс в принципе
может использоваться в запросах с ограничениями по b и/или c, без ограничений столбца a, но при
этом будет просканирован весь индекс, так что в большинстве случаев планировщик предпочтёт
использованию индекса полное сканирование таблицы.
Составной индекс GiST может применяться в условиях с любым подмножеством столбцов индек-
са. Условия с дополнительными столбцами ограничивают записи, возвращаемые индексом, но в
первую очередь сканируемая область индекса определяется ограничением первого столбца. GiST-
индекс будет относительно малоэффективен, когда первый его столбец содержит только несколь-
ко различающихся значений, даже если дополнительные столбцы дают множество различных зна-
чений.
Составной индекс GIN может применяться в условиях с любым подмножеством столбцов индекса.
В отличие от индексов GiST или B-деревьев, эффективность поиска по нему не меняется в зависи-
мости от того, какие из его столбцов используются в условиях запроса.
Составной индекс BRIN может применяться в условиях запроса с любым подмножеством столбцов
индекса. Подобно индексу GIN и в отличие от B-деревьев или GiST, эффективность поиска по нему
359Индексы
не меняется в зависимости от того, какие из его столбцов используются в условиях запроса. Един-
ственное, зачем в одной таблице могут потребоваться несколько индексов BRIN вместо одного со-
ставного индекса — это затем, чтобы применялись разные параметры хранения pages_per_range.
При этом, разумеется, каждый столбец должен использоваться с операторами, соответствующими
типу индекса; ограничения с другими операторами рассматриваться не будут.
Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному
столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чём
трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообраз-
но. Описание достоинств различных конфигураций индексов можно найти в Разделе 11.5 и Разде-
ле 11.11.
11.4. Индексы и предложения ORDER BY
Помимо простого поиска строк для выдачи в результате запроса, индексы также могут применять-
ся для сортировки строк в определённом порядке. Это позволяет учесть предложение ORDER BY
в запросе, не выполняя сортировку дополнительно. Из всех типов индексов, которые поддержива-
ет PostgreSQL, сортировать данные могут только B-деревья — индексы других типов возвращают
строки в неопределённом, зависящем от реализации порядке.
Планировщик может выполнить указание ORDER BY, либо просканировав существующий индекс,
подходящий этому указанию, либо просканировав таблицу в физическом порядке и выполнив сор-
тировку явно. Для запроса, требующего сканирования большой части таблицы, явная сортировка
скорее всего будет быстрее, чем применение индекса, так как при последовательном чтении она
потребует меньше операций ввода/вывода. Важный особый случай представляет ORDER BY в соче-
тании с LIMIT n: при явной сортировке системе потребуется обработать все данные, чтобы выбрать
первые n строк, но при наличии индекса, соответствующего столбцам в ORDER BY, первые n строк
можно получить сразу, не просматривая остальные вовсе.
По умолчанию элементы B-дерева хранятся в порядке возрастания, при этом значения NULL идут
в конце. Это означает, что при прямом сканировании индекса по столбцу x порядок оказывается
соответствующим указанию ORDER BY x (или точнее, ORDER BY x ASC NULLS LAST). Индекс также
может сканироваться в обратную сторону, и тогда порядок соответствует указанию ORDER BY x
DESC (или точнее, ORDER BY x DESC NULLS FIRST, так как для ORDER BY DESC подразумевается
NULLS FIRST).
Вы можете изменить порядок сортировки элементов B-дерева, добавив уточнения ASC, DESC, NULLS
FIRST и/или NULLS LAST при создании индекса; например:
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
Индекс, в котором элементы хранятся в порядке возрастания и значения NULL идут первыми,
может удовлетворять указаниям ORDER BY x ASC NULLS FIRST или ORDER BY x DESC NULLS LAST,
в зависимости от направления просмотра.
У вас может возникнуть вопрос, зачем нужны все четыре варианта при создании индексов, когда
и два варианта с учётом обратного просмотра покрывают все виды ORDER BY. Для индексов по
одному столбцу это и в самом деле излишне, но для индексов по многим столбцам это может быть
полезно. Рассмотрим индекс по двум столбцам (x, y): он может удовлетворять указанию ORDER BY
x, y при прямом сканировании или ORDER BY x DESC, y DESC при обратном. Но вполне возможно,
что приложение будет часто выполнять ORDER BY x ASC, y DESC. В этом случае получить такую
сортировку от простого индекса нельзя, но можно получить подходящий индекс, определив его
как (x ASC, y DESC) или (x DESC, y ASC).
Очевидно, что индексы с нестандартными правилами сортировки весьма специфичны, но иногда
они могут кардинально ускорить определённые запросы. Стоит ли вводить такие индексы, зависит
от того, как часто выполняются запросы с необычным порядком сортировки.
360Индексы
11.5. Объединение нескольких индексов
При простом сканировании индекса могут обрабатываться только те предложения в запросе, в
которых применяются операторы его класса и объединяет их AND. Например, для индекса (a, b)
условие запроса WHERE a = 5 AND b = 6 сможет использовать этот индекс, а запрос WHERE a =
5 OR b = 6 — нет.
К счастью, PostgreSQL способен соединять несколько индексов (и в том числе многократно при-
менять один индекс) и охватывать также случаи, когда сканирования одного индекса недостаточ-
но. Система может сформировать условия AND и OR за несколько проходов индекса. Например, за-
прос WHERE x = 42 OR x = 47 OR x = 53 OR x = 99 можно разбить на четыре сканирования
индекса по x, по сканированию для каждой части условия. Затем результаты этих сканирований
будут логически сложены (OR) вместе и дадут конечный результат. Другой пример — если у нас
есть отдельные индексы по x и y, запрос WHERE x = 5 AND y = 6 можно выполнить, применив
индексы для соответствующих частей запроса, а затем вычислив логическое произведение (AND)
для найденных строк, которое и станет конечным результатом.
Выполняя объединение нескольких индексов, система сканирует все необходимые индексы и со-
здаёт в памяти битовую карту расположения строк таблицы, которые удовлетворяют условиям
каждого индекса. Затем битовые карты объединяются операциями AND и OR, как того требуют
условия в запросе. Наконец система обращается к соответствующим отмеченным строкам табли-
цы и возвращает их данные. Строки таблицы просматриваются в физическом порядке, как они
представлены в битовой карте; это означает, что порядок сортировки индексов при этом теряется
и в запросах с предложением ORDER BY сортировка будет выполняться отдельно. По этой причине,
а также потому, что каждое сканирование индекса занимает дополнительное время, планировщик
иногда выбирает простое сканирование индекса, несмотря на то, что можно было бы подключить
и дополнительные индексы.
В большинстве приложений (кроме самых простых) полезными могут оказаться различные комби-
нации индексов, поэтому разработчик баз данных, определяя набор индексов, должен искать ком-
промиссное решение. Иногда оказываются хороши составные индексы, а иногда лучше создать
отдельные индексы и положиться на возможности объединения индексов. Например, если типич-
ную нагрузку составляют запросы иногда с условием только по столбцу x, иногда только по y, а
иногда по обоим столбцам, вы можете ограничиться двумя отдельными индексами по x и y, рас-
считывая на то, что при обработке условий с обоими столбцами эти индексы будут объединяться.
С другой стороны, вы можете создать один составной индекс по (x, y). Этот индекс скорее всего
будет работать эффективнее, чем объединение индексов, в запросах с двумя столбцами, но как го-
ворилось в Разделе 11.3, он будет практически бесполезен для запросов с ограничениями только
по y, так что одного этого индекса будет недостаточно. Выигрышным в этом случае может быть
сочетание составного индекса с отдельным индексом по y. В запросах, где задействуется только x,
может применяться составной индекс, хотя он будет больше и, следовательно, медленнее индекса
по одному x. Наконец, можно создать все три индекса, но это будет оправдано, только если данные
в таблице изменяются гораздо реже, чем выполняется поиск в таблице, при этом частота запросов
этих трёх типов примерно одинакова. Если запросы какого-то одного типа выполняются гораздо
реже других, возможно лучше будет оставить только два индекса, соответствующих наиболее ча-
стым запросам.
11.6. Уникальные индексы
Индексы также могут обеспечивать уникальность значения в столбце или уникальность сочетания
значений в нескольких столбцах.
CREATE UNIQUE INDEX имя ON таблица (столбец [, …])
[ INCLUDE (столбец [, …]) ];
В настоящее время обеспечение уникальности поддерживают только индексы-B-деревья.
Если индекс создаётся как уникальный, в таблицу нельзя будет добавить несколько строк с оди-
наковыми значениями ключа индекса. При этом значения NULL считаются не равными друг дру-
361Индексы
гу. Составной уникальный индекс не принимает только те строки, в которых все индексируемые
столбцы содержат одинаковые значения. Столбцы, включённые предложением INCLUDE, не учиты-
ваются при выявлении одинаковых записей индекса.
Когда для таблицы определяется ограничение уникальности или первичный ключ, PostgreSQL ав-
томатически создаёт уникальный индекс по всем столбцам, составляющим это ограничение или
первичный ключ (индекс может быть составным). Такой индекс и является механизмом, который
обеспечивает выполнение ограничения.
Примечание
Для уникальных столбцов не нужно вручную создавать отдельные индексы — они про-
сто продублируют индексы, созданные автоматически.
11.7. Индексы по выражениям
Индекс можно создать не только по столбцу нижележащей таблицы, но и по функции или скаляр-
ному выражению с одним или несколькими столбцами таблицы. Это позволяет быстро находить
данные в таблице по результатам вычислений.
Например, для сравнений без учёта регистра символов часто используется функция lower:
SELECT * FROM test1 WHERE lower(col1) = ‘value’;
Этот запрос сможет использовать индекс, определённый для результата функции lower(col1) так:
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
Если мы объявим этот индекс уникальным (UNIQUE), он не даст добавить строки, в которых значения
col1 различаются только регистром, как и те, в которых значения col1 действительно одинаковые.
Таким образом, индексы по выражениям можно использовать ещё и для обеспечения ограничений,
которые нельзя записать как простые ограничения уникальности.
Если же часто выполняются запросы вида:
SELECT * FROM people WHERE (first_name || ‘ ‘ || last_name) = ‘John Smith’;
тогда, возможно, стоит создать такой индекс:
CREATE INDEX people_names ON people ((first_name || ‘ ‘ || last_name));
Синтаксис команды CREATE INDEX обычно требует заключать индексные выражения в скобки, как
показано во втором примере. Если же выражение представляет собой просто вызов функции, как
в первом примере, дополнительные скобки можно опустить.
Поддержка индексируемых выражений обходится довольно дорого, так как эти выражения долж-
ны вычисляться при добавлении каждой строки и при каждом последующем изменении. Однако
при поиске по индексу индексируемое выражение не вычисляется повторно, так как его результат
уже сохранён в индексе. В рассмотренных выше случаях система видит запрос как WHERE столбе-
ц_индекса = ‘константа’ и поэтому поиск выполняется так же быстро, как и с простым индексом.
Таким образом, индексы по выражениям могут быть полезны, когда скорость извлечения данных
гораздо важнее скорости добавления и изменения.
11.8. Частичные индексы
Частичный индекс — это индекс, который строится по подмножеству строк таблицы, определяе-
мому условным выражением (оно называется предикатом частичного индекса). Такой индекс со-
держит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно спе-
цифичны, но в ряде ситуаций они могут быть очень полезны.
362Индексы
Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать индексирования
распространённых значений. Так как при поиске распространённого значения (такого, которое
содержится в значительном проценте всех строк) индекс всё равно не будет использоваться, хра-
нить эти строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его размер, а
значит и ускорить запросы, использующие этот индекс. Это также может ускорить операции из-
менения данных в таблице, так как индекс будет обновляться не всегда. Возможное применение
этой идеи проиллюстрировано в Примере 11.1.
Пример 11.1. Настройка частичного индекса, исключающего распространённые значения
Предположим, что вы храните в базе данных журнал обращений к корпоративному сайту. Большая
часть обращений будет происходить из диапазона IP-адресов вашей компании, а остальные могут
быть откуда угодно (например, к нему могут подключаться внешние сотрудники с динамическими
IP). Если при поиске по IP вас обычно интересуют внешние подключения, IP-диапазон внутренней
сети компании можно не включать в индекс.
Пусть у вас есть такая таблица:
CREATE TABLE access_log (
url varchar,
client_ip inet,
…
);
Создать частичный индекс для нашего примера можно так:
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet ‘192.168.100.0’ AND
client_ip &lt; inet ‘192.168.100.255’);
Так будет выглядеть типичный запрос, использующий этот индекс:
SELECT *
FROM access_log
WHERE url = ‘/index.html’ AND client_ip = inet ‘212.78.10.32’;
А следующий запрос не будет использовать этот индекс:
SELECT *
FROM access_log
WHERE client_ip = inet ‘192.168.100.23’;
Заметьте, что при таком определении частичного индекса необходимо, чтобы распространённые
значения были известны заранее, так что такие индексы лучше использовать, когда распределе-
ние данных не меняется. Хотя такие индексы можно пересоздавать время от времени, подстраи-
ваясь под новое распределение, это значительно усложняет поддержку.
Во-вторых, частичные индексы могут быть полезны тем, что позволяют исключить из индекса зна-
чения, которые обычно не представляют интереса; это проиллюстрировано в Примере 11.2. При
этом вы получаете те же преимущества, что и в предыдущем случае, но система не сможет извлечь
«неинтересные» значения по этому индексу, даже если сканирование индекса может быть эффек-
тивным. Очевидно, настройка частичных индексов в таких случаях требует тщательного анализа
и тестирования.
Пример 11.2. Настройка частичного индекса, исключающего неинтересные значения
Если у вас есть таблица, в которой хранятся и оплаченные, и неоплаченные счета, и при этом
неоплаченные счета составляют только небольшую часть всей таблицы, но представляют наиболь-
ший интерес, производительность запросов можно увеличить, создав индекс только по неоплачен-
ным счетам. Сделать это можно следующей командой:
CREATE INDEX orders_unbilled_index ON orders (order_nr)
WHERE billed is not true;
363Индексы
Этот индекс будет применяться, например в таком запросе:
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;
Однако он также может применяться в запросах, где order_nr вообще не используется, например:
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;
Конечно, он будет не так эффективен, как мог бы быть частичный индекс по столбцу amount, так
как системе придётся сканировать его целиком. Тем не менее, если неоплаченных счетов сравни-
тельно мало, выиграть при поиске неоплаченного счёта можно и с таким частичным индексом.
Заметьте, что в таком запросе этот индекс не будет использоваться:
SELECT * FROM orders WHERE order_nr = 3501;
Счёт с номером 3501 может оказаться, как в числе неоплаченных, так и оплаченных.
Пример 11.2 также показывает, что индексируемый столбец не обязательно должен совпадать со
столбцом, используемым в предикате. PostgreSQL поддерживает частичные индексы с произволь-
ными предикатами — главное, чтобы в них фигурировали только столбцы индексируемой табли-
цы. Однако не забывайте, что предикат должен соответствовать условиям запросов, для оптими-
зации которых предназначается данный индекс. Точнее, частичный индекс будет применяться в
запросе, только если система сможет понять, что условие WHERE данного запроса математически
сводится к предикату индекса. Но учтите, что PostgreSQL не умеет доказывать математические
утверждения об эквивалентности выражений, записанных в разных формах. (Составить програм-
му для таких доказательств крайне сложно, и если даже это удастся, скорость её будет непри-
емлема для применения на практике.) Система может выявить только самые простые следствия
с неравенствами; например, понять, что из «x &lt; 1» следует «x &lt; 2»; во всех остальных случаях
условие предиката должно точно совпадать с условием в предложении WHERE, иначе индекс будет
считаться неподходящим. Сопоставление условий происходит во время планирования запросов, а
не во время выполнения. Как следствие, запросы с параметрами не будут работать с частичными
индексами. Например, условие с параметром «x &lt; ?» в подготовленном запросе никогда не будет
сведено к «x &lt; 2» при всех возможных значениях параметра.
Третье возможное применение частичных индексов вообще не связано с использованием индекса
в запросах. Идея заключается в том, чтобы создать уникальный индекс по подмножеству строк
таблицы, как в Примере 11.3. Это обеспечит уникальность среди строк, удовлетворяющих условию
предиката, но никак не будет ограничивать остальные.
Пример 11.3. Настройка частичного уникального индекса
Предположим, что у нас есть таблица с результатами теста. Мы хотим, чтобы для каждого соче-
тания предмета и целевой темы была только одна запись об успешном результате, а неудачных
попыток могло быть много. Вот как можно этого добиться:
CREATE TABLE tests (
subject text,
target text,
success boolean,
…
);
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
WHERE success;
Это подход будет особенно эффективным, когда неудачных попыток будет намного больше, чем
удачных.
Наконец, с помощью частичных индексов можно также переопределять выбираемый системой
план запроса. Возможно, что для данных с неудачным распределением система решит использо-
вать индекс, тогда как на самом деле это неэффективно. В этом случае индекс можно настроить
так, чтобы в подобных запросах он не работал. Обычно PostgreSQL принимает разумные решения
относительно применения индексов (т. е. старается не использовать их для получения распростра-
364Индексы
нённых значений, так что частичный индекс в вышеприведённом примере помог только умень-
шить размер индекса, для отказа от использования индекса он не требовался), поэтому крайне
неэффективный план может быть поводом для сообщения об ошибке.
Помните, что настраивая частичный индекс, вы тем самым заявляете, что знаете о данных гораз-
до больше, чем планировщик запросов. В частности, вы знаете, когда такой индекс может быть
полезен. Это знание обязательно должно подкрепляться опытом и пониманием того, как работают
индексы в PostgreSQL. В большинстве случаев преимущества частичных индексов по сравнению
с обычными будут минимальными.
Узнать о частичных индексах больше можно в следующих источниках: ston89b, olson93 и
seshadri95.
11.9. Семейства и классы операторов
В определении индекса можно указать класс операторов для каждого столбца индекса.
CREATE INDEX имя ON таблица (столбец класс_операторов [параметры сортировки] [, …]);
Класс операторов определяет, какие операторы будет использовать индекс для этого столбца. На-
пример, индекс-B-дерево по столбцу int4 будет использовать класс int4_ops; этот класс операто-
ров включает операции со значениями типа int4. На практике часто достаточно принять класс
операторов, назначенный для типа столбца классом по умолчанию. Однако для некоторых типов
данных могут иметь смысл несколько разных вариантов индексирования и реализовать их как раз
позволяют разные классы операторов. Например, комплексные числа можно сортировать как по
вещественной части, так и по модулю. Получить два варианта индексов для них можно, определив
два класса операторов для данного типа и выбрав соответствующий класс при создании индекса.
Выбранный класс операторов задаст основной порядок сортировки данных (его можно уточнить,
добавив параметры COLLATE, ASC/DESC и/или NULLS FIRST/NULLS LAST).
Помимо классов операторов по умолчанию есть ещё несколько встроенных:
• Классы операторов text_pattern_ops, varchar_pattern_ops и bpchar_pattern_ops поддержи-
вают индексы-B-деревья для типов text, varchar и char, соответственно. От стандартных клас-
сов операторов они отличаются тем, что сравнивают значения по символам, не применяя пра-
вила сортировки, определённые локалью. Благодаря этому они подходят для запросов с по-
иском по шаблону (с LIKE и регулярными выражениями POSIX), когда локаль базы данных не
стандартная «C». Например, вы можете проиндексировать столбец varchar так:
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
Заметьте, что при этом также следует создать индекс с классом операторов по умолчанию, ес-
ли вы хотите ускорить запросы с обычными сравнениями &lt;, &lt;=, &gt; и &gt;= за счёт применения ин-
дексов. Классы операторов xxx_pattern_ops не подходят для таких сравнений. (Однако для
проверки равенств эти классы операторов вполне пригодны.) В подобных случаях для одного
столбца можно создать несколько индексов с разными классами операторов. Если же вы ис-
пользуете локаль C, классы операторов xxx_pattern_ops вам не нужны, так как для поиска по
шаблону в локали C будет достаточно индексов с классом операторов по умолчанию.
Следующий запрос выводит список всех существующих классов операторов:
SELECT am.amname AS index_method,
opc.opcname AS opclass_name,
opc.opcintype::regtype AS indexed_type,
opc.opcdefault AS is_default
FROM pg_am am, pg_opclass opc
WHERE opc.opcmethod = am.oid
ORDER BY index_method, opclass_name;
Класс операторов на самом деле является всего лишь подмножеством большой структуры, назы-
ваемой семейством операторов. В случаях, когда несколько типов данных ведут себя одинаково,
часто имеет смысл определить операторы так, чтобы они могли использоваться с индексами сразу
365Индексы
нескольких типов. Сделать это можно, сгруппировав классы операторов для этих типов в одном
семействе операторов. Такие многоцелевые операторы, являясь членами семейства, не будут свя-
заны с каким-либо одним его классом.
Расширенная версия предыдущего запроса показывает семью операторов, к которой принадлежит
каждый класс операторов:
SELECT am.amname AS index_method,
opc.opcname AS opclass_name,
opf.opfname AS opfamily_name,
opc.opcintype::regtype AS indexed_type,
opc.opcdefault AS is_default
FROM pg_am am, pg_opclass opc, pg_opfamily opf
WHERE opc.opcmethod = am.oid AND
opc.opcfamily = opf.oid
ORDER BY index_method, opclass_name;
Этот запрос выводит все существующие семейства операторов и все операторы, включённые в эти
семейства:
SELECT am.amname AS index_method,
opf.opfname AS opfamily_name,
amop.amopopr::regoperator AS opfamily_operator
FROM pg_am am, pg_opfamily opf, pg_amop amop
WHERE opf.opfmethod = am.oid AND
amop.amopfamily = opf.oid
ORDER BY index_method, opfamily_name, opfamily_operator;
11.10. Индексы и правила сортировки
Один индекс может поддерживать только одно правило сортировки для индексируемого столбца.
Поэтому при необходимости применять разные правила сортировки могут потребоваться несколь-
ко индексов.
Рассмотрим следующие операторы:
CREATE TABLE test1c (
id integer,
content varchar COLLATE “x”
);
CREATE INDEX test1c_content_index ON test1c (content);
Этот индекс автоматически использует правило сортировки нижележащего столбца. И запрос ви-
да
SELECT * FROM test1c WHERE content &gt; константа;
сможет использовать этот индекс, так как при сравнении по умолчанию будет действовать прави-
ло сортировки столбца. Однако этот индекс не поможет ускорить запросы с каким-либо другим
правилом сортировки. Поэтому, если интерес представляют также и запросы вроде
SELECT * FROM test1c WHERE content &gt; константа COLLATE “y”;
для них можно создать дополнительный индекс, поддерживающий правило сортировки “y”, при-
мерно так:
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE “y”);
11.11. Сканирование только индекса
Все индексы в PostgreSQL являются вторичными, что значит, что каждый индекс хранится вне
области основных данных таблицы (которая в терминологии PostgreSQL называется кучей табли-
366Индексы
цы). Это значит, что при обычном сканировании индекса для извлечения каждой строки необхо-
димо прочитать данные и из индекса, и из кучи. Более того, тогда как элементы индекса, соответ-
ствующие заданному условию WHERE, обычно находятся в индексе рядом, строки таблицы могут
располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по ин-
дексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево,
особенно на традиционных вращающихся носителях. (Как описано в Разделе 11.5, сканирование
по битовой карте пытается снизить стоимость этих операций, упорядочивая доступ к куче, но не
более того.)
Чтобы решить эту проблему с производительностью, PostgreSQL поддерживает сканирование
только индекса, при котором результат запроса может быть получен из самого индекса, без об-
ращения к куче. Основная идея такого сканирования в том, чтобы выдавать значения непосред-
ственно из элемента индекса, и не обращаться к соответствующей записи в куче. Для применения
этого метода есть два фундаментальных ограничения:</p>
  <ol>
    <li>Тип индекса должен поддерживать сканирование только индекса. Индексы-B-деревья поддер-
живают его всегда. Индексы GiST и SP-GiST могут поддерживать его с одними классами опе-
раторов и не поддерживать с другими. Другие индексы такое сканирование не поддерживают.
Суть нижележащего требования в том, что индекс должен физически хранить или каким-то об-
разом восстанавливать исходное значение данных для каждого элемента индекса. В качестве
контрпримера, индексы GIN неспособны поддерживать сканирование только индекса, так как в
элементах индекса обычно хранится только часть исходного значения данных.</li>
    <li>Запрос должен обращаться только к столбцам, сохранённым в индексе. Например, если в таб-
лице построен индекс по столбцам x и y, и в ней есть также столбец z, такие запросы будут
использовать сканирование только индекса:
SELECT x, y FROM tab WHERE x = ‘key’;
SELECT x FROM tab WHERE x = ‘key’ AND y &lt; 42;
А эти запросы не будут:
SELECT x, z FROM tab WHERE x = ‘key’;
SELECT x FROM tab WHERE x = ‘key’ AND z &lt; 42;
(Индексы по выражениям и частичные индексы усложняют это правило, как описано ниже.)
Если два этих фундаментальных ограничения выполняются, то все данные, требуемые для выпол-
нения запроса, содержатся в индексе, так что сканирование только по индексу физически воз-
можно. Но в PostgreSQL существует и ещё одно требование для сканирования таблицы: необхо-
димо убедиться, что все возвращаемые строки «видны» в снимке MVCC запроса, как описано в
Главе  13. Информация о видимости хранится не в элементах индекса, а только в куче; поэтому
на первый взгляд может показаться, что для получения данных каждой строки всё равно необхо-
димо обращаться к куче. И это в самом деле так, если в таблице недавно произошли изменения.
Однако для редко меняющихся данных есть возможность обойти эту проблему. PostgreSQL отсле-
живает для каждой страницы в куче таблицы, являются ли все строки в этой странице достаточно
старыми, чтобы их видели все текущие и будущие транзакции. Это отражается в битах в карте
видимости таблицы. Процедура сканирования только индекса, найдя потенциально подходящую
запись в индексе, проверяет бит в карте видимости для соответствующей страницы в куче. Если
он установлен, значит эта строка видна, и данные могут быть возвращены сразу. В противном слу-
чае придётся посетить запись строки в куче и проверить, видима ли она, так что никакого выиг-
рыша по сравнению с обычным сканированием индекса не будет. И даже в благоприятном случае
обращение к кучи не исключается совсем, а заменяется обращением к карте видимости; но так
как карта видимости на четыре порядка меньше соответствующей ей области кучи, для работы с
ней требуется много меньше операций физического ввода/вывода. В большинстве ситуаций карта
видимости просто всё время находится в памяти.
Таким образом, тогда как сканирование только по индексу возможно лишь при выполнении двух
фундаментальных требований, оно даст выигрыш, только если для значительной части страниц в
куче таблицы установлены биты полной видимости. Но таблицы, в которых меняется лишь неболь-
шая часть строк, встречаются достаточно часто, чтобы этот тип сканирования был весьма полезен
на практике.
367Индексы
Чтобы эффективно применять возможность сканирования только индекса, можно создать индек-
сы, в которых только первые столбцы будут соответствовать предложениям WHERE, а остальные
столбцы будут содержать полезные данные, возвращаемые запросом. Например, если вы часто
выполняете запросы вида:
SELECT y FROM tab WHERE x = ‘key’;
при традиционном подходе к ускорению таких запросов можно было бы создать индекс только
по x. Однако индекс по (x, y) дал бы возможность выполнения этого запроса со сканированием
только индекса. Как говорилось ранее, такой индекс был бы объёмнее и дороже в обслуживании,
чем индекс только по x, так что этот вариант предпочтителен, только для таблиц в основном ста-
тических. Заметьте, что в объявлении индекса важно указать столбцы (x, y), а не (y, x), так как
для большинства типов индексов (а именно, B-деревьев) поиск, при котором не ограничиваются
значения ведущих столбцов индекса, не будет эффективным.
В принципе сканирование только индекса может применяться и с индексами по выражениям. На-
пример, при наличии индекса по f(x), где x — столбец таблицы, должно быть возможно выполнить
SELECT f(x) FROM tab WHERE f(x) &lt; 1;
как сканирование только индекса; и это очень заманчиво, если f() — сложная для вычисления
функция. Однако планировщик PostgreSQL в настоящее время может вести себя не очень разум-
но. Он считает, что запрос может выполняться со сканированием только по индексу, только когда
из индекса могут быть получены все столбцы, требующиеся для запроса. В этом примере x фигу-
рирует только в контексте f(x), но планировщик не замечает этого и решает, что сканирование
только по индексу невозможно. Если сканирование только по индексу заслуживает того, эту про-
блему можно обойти, объявив индекс по (f(x), x), где второй столбец может не использоваться
на практике, но нужен для того, чтобы убедить планировщик, что сканирование только по индексу
возможно. Если это делается ради того, чтобы избежать вычислений f(x), надо также заметить,
что планировщик не обязательно свяжет с использованием индекса упоминания f(x), фигуриру-
ющие не в индексируемых предложениях WHERE со столбцом индекса. Обычно он это делает пра-
вильно в простых запросах, вроде показанного выше, но не в запросах с соединениями. Эти недо-
статки могут быть устранены в будущих версиях PostgreSQL.
С использованием частичных индексов при сканировании только по индексу тоже связаны инте-
ресные особенности. Предположим, что у нас есть частичный индекс, показанный в Примере 11.3:
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
WHERE success;
В принципе с ним мы можем произвести сканирование только по индексу при выполнении запроса
SELECT target FROM tests WHERE subject = ‘some-subject’ AND success;
Но есть одна проблема: предложение WHERE обращается к столбцу success, который отсутствует в
результирующих столбцах индекса. Тем не менее, сканирование только индекса возможно, так как
плану не нужно перепроверять эту часть предложения WHERE во время выполнения: у всех записей,
найденных в индексе, значение success = true, так что в плане его не нужно проверять явно.
PostgreSQL версий 9.6 и новее распознает такую ситуацию и сможет произвести сканирование
только по индексу, но старые версии неспособны на это.
11.12. Контроль использования индексов
Хотя индексы в PostgreSQL не требуют какого-либо обслуживания или настройки, это не избавляет
от необходимости проверять, как и какие индексы используются на самом деле в реальных усло-
виях. Узнать, как отдельный запрос использует индексы, можно с помощью команды EXPLAIN; её
применение для этих целей описывается в Разделе 14.1. Также возможно собрать общую стати-
стику об использовании индексов на работающем сервере, как описано в Разделе 28.2.
Вывести универсальную формулу, определяющую, какие индексы нужно создавать, довольно
сложно, если вообще возможно. В предыдущих разделах рассматривались некоторые типовые си-
туации, иллюстрирующие подходы к этому вопросу. Часто найти ответ на него помогают экспери-
менты. Ниже приведены ещё несколько советов:
368Индексы
• Всегда начинайте исследование с ANALYZE. Эта команда собирает статистические данные о
распределении значений в таблице, которые необходимы для оценивания числа строк, возвра-
щаемых запросов. А это число, в свою очередь, нужно планировщику, чтобы оценить реаль-
ные затраты для всевозможных планов выполнения запроса. Не имея реальной статистики,
планировщик будет вынужден принять некоторые значения по умолчанию, которые почти на-
верняка не будут соответствовать действительности. Поэтому понять, как индекс использует-
ся приложением без предварительного запуска ANALYZE, практически невозможно. Подробнее
это рассматривается в Подразделе 24.1.3 и Подразделе 24.1.6.
• Используйте в экспериментах реальные данные. Анализируя работу системы с тестовыми дан-
ными, вы поймёте, какие индексы нужны для тестовых данных, но не более того.
Особенно сильно искажают картину очень маленькие наборы тестовых данных. Тогда как для
извлечения 1000 строк из 100000 может быть применён индекс, для выбора 1 из 100 он вряд
ли потребуется, так как 100 строк скорее всего уместятся в одну страницу данных на диске и
никакой другой план не будет лучше обычного сканирования 1 страницы.
Тем не менее, пока приложение не эксплуатируется, создавать какие-то тестовые данные всё
равно нужно, и это нужно делать обдуманно. Если вы наполняете базу данных очень близки-
ми, или наоборот, случайными значениями, либо добавляете строки в отсортированном по-
рядке, вы получите совсем не ту статистику распределения, что дадут реальные данные.
• Когда индексы не используются, ради тестирования может быть полезно подключить их при-
нудительно. Для этого можно воспользоваться параметрами выполнения, позволяющими вы-
ключать различные типы планов (см. Подраздел 19.7.1). Например, выключив наиболее про-
стые планы: последовательное сканирование (enable_seqscan) и соединения с вложенными
циклами (enable_nestloop), вы сможете заставить систему выбрать другой план. Если же си-
стема продолжает выполнять сканирование или соединение с вложенными циклами, вероят-
но, у неё есть более серьёзная причина не использовать индекс; например, индекс может не
соответствовать условию запроса. (Какие индексы работают в запросах разных типов, обсуж-
далось в предыдущих разделах.)
• Если система начинает использовать индекс только под принуждением, тому может быть две
причины: либо система права и применять индекс в самом деле неэффективно, либо оценка
стоимости применения индекса не соответствует действительности. В этом случае вам следу-
ет замерить время выполнения запроса с индексами и без них. В анализе этой ситуации мо-
жет быть полезна команда EXPLAIN ANALYZE.
• Если выясняется, что оценка стоимости неверна, это может иметь тоже два объяснения. Об-
щая стоимость вычисляется как произведение цены каждого узла плана для одной строки и
оценки избирательности узла плана. Цены узлов при необходимости можно изменить пара-
метрами выполнения (описанными в Подразделе 19.7.2). С другой стороны, оценка избира-
тельности может быть неточной из-за некачественной статистики. Улучшить её можно, на-
строив параметры сбора статистики (см. ALTER TABLE).
Если ваши попытки скорректировать стоимость планов не увенчаются успехом, возможно
вам останется только явно заставить систему использовать нужный индекс. Вероятно, имеет
смысл также связаться с разработчиками PostgreSQL, чтобы прояснить ситуацию.</li>
  </ol>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-010/" title="Глава 10. Преобразование типов"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 10. Преобразование типов"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-010/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~23 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-010/" rel="bookmark" title="Глава 10. Преобразование типов" itemprop="url">Глава 10. Преобразование типов</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 10. Преобразование типов</p>

<p>SQL-операторы, намеренно или нет, требуют совмещать данные разных типов в одном выражении.
Для вычисления подобных выражений со смешанными типами PostgreSQL предоставляет широкий
набор возможностей.
Очень часто пользователю не нужно понимать все тонкости механизма преобразования. Однако
следует учитывать, что неявные преобразования, производимые PostgreSQL, могут влиять на ре-
зультат запроса. Поэтому при необходимости нужные результаты можно получить, применив яв-
ное преобразование типов.
В этой главе описываются общие механизмы преобразования типов и соглашения, принятые в
PostgreSQL. За дополнительной информацией о конкретных типах данных и разрешённых для них
функциях и операторах обратитесь к соответствующим разделам в Главе 8 и Главе 9.
10.1. Обзор
SQL — язык со строгой типизацией. То есть каждый элемент данных в нём имеет некоторый тип,
определяющий его поведение и допустимое использование. PostgreSQL наделён расширяемой си-
стемой типов, более универсальной и гибкой по сравнению с другими реализациями SQL. При этом
преобразования типов в PostgreSQL в основном подчиняются определённым общим правилам, для
их понимания не нужен эвристический анализ. Благодаря этому в выражениях со смешанными
типами можно использовать даже типы, определённые пользователями.
Анализатор выражений PostgreSQL разделяет их лексические элементы на пять основных кате-
горий: целые числа, другие числовые значения, текстовые строки, идентификаторы и ключевые
слова. Константы большинства не числовых типов сначала классифицируются как строки. В опре-
делении языка SQL допускается указывать имена типов в строках и это можно использовать в
PostgreSQL, чтобы направить анализатор по верному пути. Например, запрос:
SELECT text ‘Origin’ AS “label”, point ‘(0,0)’ AS “value”;
label | value
——–+——-
Origin | (0,0)
(1 row)
содержит две строковых константы, типа text и типа point. Если для такой константы не указан
тип, для неё первоначально предполагается тип unknown, который затем может быть уточнён, как
описано ниже.
В SQL есть четыре фундаментальных фактора, определяющих правила преобразования типов для
анализатора выражений PostgreSQL:
Вызовы функций
Система типов PostgreSQL во многом построена как дополнение к богатым возможностям функ-
ций. Функции могут иметь один или несколько аргументов, и при этом PostgreSQL разрешает
перегружать имена функций, так что имя функции само по себе не идентифицирует вызывае-
мую функцию; анализатор выбирает правильную функцию в зависимости от типов переданных
аргументов.
Операторы
PostgreSQL позволяет использовать в выражениях префиксные и постфиксные операторы с од-
ним аргументом, а также операторы с двумя аргументами. Как и функции, операторы можно
перегружать, так что и с ними существует проблема выбора правильного оператора.
Сохранение значений
SQL-операторы INSERT и UPDATE помещают результаты выражений в таблицы. При этом полу-
чаемые значения должны соответствовать типам целевых столбцов или, возможно, приводить-
ся к ним.
344Преобразование типов
UNION, CASE и связанные конструкции
Так как все результаты запроса объединяющего оператора SELECT должны оказаться в одном
наборе столбцов, результаты каждого подзапроса SELECT должны приводиться к одному набору
типов. Подобным образом, результирующие выражения конструкции CASE должны приводиться
к общему типу, так как выражение CASE в целом должно иметь определённый выходной тип. То
же справедливо в отношении конструкций ARRAY и функций GREATEST и LEAST.
Информация о существующих преобразованиях или приведениях типов, для каких типов они опре-
делены и как их выполнять, хранится в системных каталогах. Пользователь также может добавить
дополнительные преобразования с помощью команды CREATE CAST. (Обычно это делается, когда
определяются новые типы данных. Набор приведений для встроенных типов достаточно хорошо
проработан, так что его лучше не менять.)
Дополнительная логика анализа помогает выбрать оптимальное приведение в группах типов,
допускающих неявные преобразования. Для этого типы данных разделяются на несколько ба-
зовых категорий, которые включают: boolean, numeric, string, bitstring, datetime, timespan,
geometric, network и пользовательские типы. (Полный список категорий приведён в Таблице 52.63;
хотя его тоже можно расширить, определив свои категории.) В каждой категории могут быть вы-
браны один или несколько предпочитаемых типов, которые будут считаться наиболее подходя-
щими при рассмотрении нескольких вариантов. Аккуратно выбирая предпочитаемые типы и до-
пустимые неявные преобразования, можно добиться того, что выражения с неоднозначностями
(в которых возможны разные решения задачи преобразования) будут разрешаться наилучшим об-
разом.
Все правила преобразования типов разработаны с учётом следующих принципов:
• Результат неявных преобразованиях всегда должен быть предсказуемым и понятным.
• Если в неявном преобразовании нет нужды, анализатор и исполнитель запроса не должны
тратить лишнее время на это. То есть, если запрос хорошо сформулирован и типы значений
совпадают, он должен выполняться без дополнительной обработки в анализаторе и без лиш-
них вызовов неявных преобразований.
• Кроме того, если запрос изначально требовал неявного преобразования для функции, а поль-
зователь определил новую функцию с точно совпадающими типами аргументов, анализатор
должен переключиться на новую функцию и больше не выполнять преобразование для вызова
старой.
10.2. Операторы
При выборе конкретного оператора, задействованного в выражении, PostgreSQL следует описан-
ному ниже алгоритму. Заметьте, что на этот выбор могут неявно влиять приоритеты остальных
операторов в данном выражении, так как они определяют, какие подвыражения будут аргумента-
ми операторов. Подробнее об этом рассказывается в Подразделе 4.1.6.
Выбор оператора по типу
1.
Выбрать операторы для рассмотрения из системного каталога pg_operator. Если имя операто-
ра не дополнено именем схемы (обычно это так), будут рассматриваться все операторы с под-
ходящим именем и числом аргументов, видимые в текущем пути поиска (см. Подраздел 5.8.3).
Если имя оператора определено полностью, в рассмотрение принимаются только операторы
из указанной схемы.
•
2.
(Optional) Если в пути поиска оказывается несколько операторов с одинаковыми типами
аргументов, учитываются только те из них, которые находятся в пути раньше. Операторы
с разными типами аргументов рассматриваются на равных правах вне зависимости от их
положения в пути поиска.
Проверить, нет ли среди них оператора с точно совпадающими типами аргументов. Если такой
оператор есть (он может быть только одним в отобранном ранее наборе), использовать его.
345Преобразование типов
1
Отсутствие точного совпадения создаёт угрозу вызова с указанием полного имени (нетипич-
ным) любого оператора, который может оказаться в схеме, где могут создавать объекты недо-
веренные пользователи. В таких ситуациях приведите типы аргументов для получения точного
совпадения.
3.
a. (Optional) Если один аргумент при вызове бинарного оператора имеет тип unknown, для
данной проверки предполагается, что он имеет тот же тип, что и второй его аргумент. При
вызове бинарного оператора с двумя аргументами unknown или унарного с одним unknown,
оператор не будет выбран на этом шаге.
b. (Optional) Если один аргумент при вызове бинарного оператора имеет тип unknown, а другой
— домен, проверить, есть ли оператор, принимающий базовый тип домена с обеих сторон;
если таковой находится, использовать его.
Найти самый подходящий.
a. Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразо-
ваны (неявным образом) так, чтобы они совпали. В данном случае считается, что констан-
ты типа unknown можно преобразовать во что угодно. Если остаётся только один кандидат,
использовать его, в противном случае перейти к следующему шагу.
b. Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена.
Благодаря этому при поиске неоднозначно заданного оператора домены будут подобны
свои базовым типам.
c. Просмотреть все кандидаты и оставить только те, для которых точно совпадают как мож-
но больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
d. Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые
типы (из категории типов входных значений) в наибольшем числе позиций, где требуется
преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитае-
мые типы. Если остаётся только один кандидат, использовать его, в противном случае пе-
рейти к следующему шагу.
e. Если какие-либо значения имеют тип unknown, проверить категории типов, принимаемых
в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать
категорию string, если какой-либо кандидат принимает эту категорию. (Эта склонность
к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта
категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать
её; в противном случае констатировать неудачу — сделать правильный выбор без дополни-
тельных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы вы-
бранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из
этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для
данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
f. Если в списке аргументов есть аргументы и типа unknown, и известного типа, и этот из-
вестный тип один для всех аргументов, предположить, что аргументы типа unknown также
имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргу-
мента unknown. Если остаётся только один кандидат, использовать его, в противном случае
констатировать неудачу.
Ниже это проиллюстрировано на примерах.
1
Эта угроза неактуальна для имён без схемы, так как путь поиска, содержащий схемы, в которых недоверенные пользователи могут создавать объекты, не
соответствует шаблону безопасного использования схем.
346Преобразование типов
Пример 10.1. Разрешение оператора факториала
В стандартном каталоге определён только один оператор факториала (постфиксный !) и он при-
нимает аргумент типа bigint. При просмотре следующего выражения его аргументу изначально
назначается тип integer:
SELECT 40 ! AS “40 factorial”;
40 factorial
————————————————–
815915283247897734345611269596115894272000000000
(1 row)
Анализатор выполняет преобразование типа для этого операнда и запрос становится равносиль-
ным:
SELECT CAST(40 AS bigint) ! AS “40 factorial”;
Пример 10.2. Разрешение оператора конкатенации строк
Синтаксис текстовых строк используется как для записи строковых типов, так и для сложных ти-
пов расширений. Если тип не указан явно, такие строки сопоставляются по тому же алгоритму с
наиболее подходящими операторами.
Пример с одним неопределённым аргументом:
SELECT text ‘abc’ || ‘def’ AS “text and unknown”;
text and unknown
——————
abcdef
(1 row)
В этом случае анализатор смотрит, есть ли оператор, у которого оба аргумента имеют тип text.
Такой оператор находится, поэтому предполагается, что второй аргумент следует воспринимать
как аргумент типа text.
Конкатенация двух значений неопределённых типов:
SELECT ‘abc’ || ‘def’ AS “unspecified”;
unspecified
————-
abcdef
(1 row)
В данном случае нет подсказки для выбора типа, так как в данном запросе никакие типы не ука-
заны. Поэтому анализатор просматривает все возможные операторы и находит в них кандидаты,
принимающие аргументы категорий string и bit-string. Так как категория string является предпо-
чтительной, выбирается она, а затем для разрешения типа не типизированной константы выбира-
ется предпочтительный тип этой категории, text.
Пример 10.3. Разрешение оператора абсолютного значения и отрицания
В каталоге операторов PostgreSQL для префиксного оператора @ есть несколько записей, описы-
вающих операции получения абсолютного значения для различных числовых типов данных. Одна
из записей соответствует типу float8, предпочтительного в категории числовых типов. Таким об-
разом, столкнувшись со значением типа unknown, PostgreSQL выберет эту запись:
SELECT @ ‘-4.5’ AS “abs”;
abs
—–
347Преобразование типов
4.5
(1 row)
Здесь система неявно привела константу неизвестного типа к типу float8, прежде чем применять
выбранный оператор. Можно убедиться в том, что выбран именно тип float8, а не какой-то другой:
SELECT @ ‘-4.5e500’ AS “abs”;
ОШИБКА:
“-4.5e500” вне диапазона для типа double precision
С другой стороны, префиксный оператор ~ (побитовое отрицание) определён только для целочис-
ленных типов данных, но не для float8. Поэтому, если попытаться выполнить похожий запрос с
~, мы получаем:
SELECT ~ ‘20’ AS “negation”;
ОШИБКА: оператор не уникален: ~ “unknown”
ПОДСКАЗКА: Не удалось выбрать лучшую кандидатуру оператора. Возможно, вам следует
добавить явные преобразования типов.
Это происходит оттого, что система не может решить, какой оператор предпочесть из нескольких
возможных вариантов ~. Мы можем облегчить её задачу, добавив явное преобразование:
SELECT ~ CAST(‘20’ AS int8) AS “negation”;
negation
———-
-21
(1 row)
Пример 10.4. Разрешение оператора включения в массив
Ещё один пример разрешения оператора с одним аргументом известного типа и другим неизвест-
ного:
SELECT array[1,2] &lt;@ ‘{1,2,3}’ as “is subset”;
is subset
———–
t
(1 row)
В каталоге операторов PostgreSQL есть несколько записей для инфиксного оператора &lt;@, но
только два из них могут принять целочисленный массива слева: оператор включения массива
(anyarray&lt;@anyarray) и оператор включения диапазона (anyelement&lt;@anyrange). Так как ни один
из этих полиморфных псевдотипов (см. Раздел 8.21) не считается предпочтительным, анализатор
не может избавиться от неоднозначности на данном этапе. Однако, в Шаг 3.f говорится, что кон-
станта неизвестного типа должна рассматриваться как значение типа другого аргумента, в дан-
ном случае это целочисленный массив. После этого подходящим считается только один из двух
операторов, так что выбирается оператор с целочисленными массивами. (Если бы был выбран опе-
ратор включения диапазона, мы получили бы ошибку, так как значение в строке не соответствует
формату значений диапазона.)
Пример 10.5. Нестандартный оператор с доменом
Иногда пользователи пытаются ввести операторы, применимые только к определённому домену.
Это возможно, но вовсе не так полезно, как может показаться, ведь правила разрешения операто-
ров применяются к базовому типу домена. Взгляните на этот пример:
CREATE DOMAIN mytext AS text CHECK(…);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS …;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
348Преобразование типов
CREATE TABLE mytable (val mytext);
SELECT * FROM mytable WHERE val = ‘foo’;
В этом запросе не будет использоваться нововведённый оператор. При разборе запроса сначала
будет проверено, есть ли оператор mytext = mytext (см. Шаг 2.a), но это не так; затем будет рас-
смотрен базовый тип домена (text) и проверено наличие оператора text = text (см. Шаг 2.b), и
таковой действительно есть; в итоге строковое значение типа unknown будет воспринято как text
и будет применён оператор text = text. Единственный вариант задействовать нововведённый опе-
ратор — добавить явное приведение:
SELECT * FROM mytable WHERE val = text ‘foo’;
так, чтобы оператор mytext = text был найден сразу, согласно правилу точного совпадения. Ес-
ли дело доходит до правил наибольшего соответствия, они активно дискредитируют операторы
доменных типов. Если бы они этого не делали, с таким оператором возникало бы слишком много
ошибок разрешения операторов, потому что правила приведения всегда считают домен приводи-
мым к базовому типу и наоборот, так что доменный оператор применялся бы во всех случаях, где
применяется одноимённый оператор с базовым типом.
10.3. Функции
При выборе конкретной функции, задействованной в выражении, PostgreSQL следует описанному
ниже алгоритму.
Разрешение функции по типу
1.
Выбрать функции для рассмотрения из системного каталога pg_proc. Если имя функции не
дополнено именем схемы, будут рассматриваться все функции с подходящим именем и числом
аргументов, видимые в текущем пути поиска (см. Подраздел 5.8.3). Если имя функции опреде-
лено полностью, в рассмотрение принимаются только функции из указанной схемы.
a. (Optional) Если в пути поиска оказывается несколько функций с одинаковыми типами ар-
гументов, учитываются только те из них, которые находятся в пути раньше. Функции с раз-
ными типами аргументов рассматриваются на равных правах вне зависимости от их поло-
жения в пути поиска.
b. (Optional) Если в числе параметров функции есть массив VARIADIC и при вызове не указы-
вается ключевое слово VARIADIC, функция обрабатывается, как если бы этот параметр был
заменён одним или несколькими параметрами типа элементов массива, по числу аргумен-
тов при вызове. После такого расширения по фактическим типам аргументов она может
совпасть с некоторой функцией с постоянным числом аргументов. В этом случае исполь-
зуется функция, которая находится в пути раньше, а если они оказываются в одной схеме,
предпочитается вариант с постоянными аргументами.
2
Это создаёт угрозу безопасности при вызове с полным именем функции с переменным
числом аргументов, которая может оказаться в схеме, где могут создавать объекты недо-
веренные пользователи. Злонамеренный пользователь может перехватывать управление и
выполнять произвольные SQL-функции, как будто их выполняете вы. Запись вызова с клю-
чевым словом VARIADIC устраняет эту угрозу. Однако для вызовов с передачей параметров
VARIADIC “any” часто не существует необходимой формулировки с ключом VARIADIC. Чтобы
такие вызовы были безопасными, создание объектов в схеме функции должно разрешаться
только доверенным пользователям.
c.
(Optional) Функции, для которых определены значения параметров по умолчанию, счита-
ются совпадающими с вызовом, в котором опущено ноль или более параметров в соответ-
ствующих позициях. Если для вызова подходят несколько функций, используется та, что
обнаруживается в пути поиска раньше. Если в одной схеме оказываются несколько функ-
ций с одинаковыми типами в позициях обязательных параметров (что возможно, если в них
2
Эта угроза неактуальна для имён без схемы, так как путь поиска, содержащий схемы, в которых недоверенные пользователи могут создавать объекты, не
соответствует шаблону безопасного использования схем.
349Преобразование типов
определены разные наборы пропускаемых параметров), система не сможет выбрать опти-
мальную, и выдаст ошибку «неоднозначный вызов функции», если лучшее соответствие
для вызова не будет найдено.
2
Это создаёт угрозу при вызове с полным именем любой функции, которая может оказать-
ся в схеме, где могут создавать объекты недоверенные пользователи. Злонамеренный поль-
зователь может создать функцию с именем уже существующей, продублировав параметры
исходной и добавив дополнительные со значениями по умолчанию. В результате при по-
следующих вызовах будет выполняться не исходная функция. Для ликвидации этой угрозы
помещайте функции в схемы, в которых создавать объекты могут только доверенные объ-
екты.</p>
<ol>
  <li>Проверить, нет ли функции, принимающей в точности типы входных аргументов. Если такая
функция есть (она может быть только одной в отобранном ранее наборе), использовать её. От-
2
сутствие точного совпадения создаёт угрозу вызова с полным именем функции в схеме, где
могут создавать объекты недоверенные пользователи. В таких ситуациях приведите типы ар-
гументов для получения точного соответствия. (В случаях с unknown совпадения на этом этапе
не будет никогда.)</li>
  <li>Если точное совпадение не найдено, проверить, не похож ли вызов функции на особую форму
преобразования типов. Это имеет место, когда при вызове функции передаётся всего один ар-
гумент и имя функции совпадает с именем (внутренним) некоторого типа данных. Более того,
аргументом функции должна быть либо строка неопределённого типа, либо значение типа,
двоично-совместимого с указанным или приводимого к нему с помощью функций ввода/выво-
да типа (то есть, преобразований в стандартный строковый тип и обратно). Если эти условия
3
выполняются, вызов функции воспринимается как особая форма конструкции CAST.</li>
  <li>Найти самый подходящий.
a. Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразо-
ваны (неявным образом) так, чтобы они совпали. В данном случае считается, что констан-
ты типа unknown можно преобразовать во что угодно. Если остаётся только один кандидат,
использовать его, в противном случае перейти к следующему шагу.
b. Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена.
Благодаря этому при поиске неоднозначно заданной функции домены будут подобны свои
базовым типам.
c. Просмотреть все кандидаты и оставить только те, для которых точно совпадают как мож-
но больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
d. Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые
типы (из категории типов входных значений) в наибольшем числе позиций, где требуется
преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитае-
мые типы. Если остаётся только один кандидат, использовать его, в противном случае пе-
рейти к следующему шагу.
e. Если какие-либо значения имеют тип unknown, проверить категории типов, принимаемых
в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать
категорию string, если какой-либо кандидат принимает эту категорию. (Эта склонность
к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта
категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать
её; в противном случае констатировать неудачу — сделать правильный выбор без дополни-
тельных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы вы-
бранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из
этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для
данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если
3
Этот шаг нужен для поддержки приведений типов в стиле вызова функции, когда на самом деле соответствующей функции приведения нет. Если такая
функция приведения есть, она обычно называется именем выходного типа и необходимости в особом подходе нет. За дополнительными комментариями
обратитесь к CREATE CAST.
350Преобразование типов
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
f.
Если в списке аргументов есть аргументы и типа unknown, и известного типа, и этот из-
вестный тип один для всех аргументов, предположить, что аргументы типа unknown также
имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргу-
мента unknown. Если остаётся только один кандидат, использовать его, в противном случае
констатировать неудачу.
Заметьте, что для функций действуют те же правила «оптимального соответствия», что и для опе-
раторов. Они проиллюстрированы следующими примерами.
Пример 10.6. Разрешение функции округления по типам аргументов
В PostgreSQL есть только одна функция round, принимающая два аргумента: первый типа numeric,
а второй — integer. Поэтому в следующем запросе первый аргумент integer автоматически при-
водится к типу numeric:
SELECT round(4, 4);
round
——–
4.0000
(1 row)
Таким образом, анализатор преобразует этот запрос в:
SELECT round(CAST (4 AS numeric), 4);
Так как числовые константы с десятичными точками изначально относятся к типу numeric, для
следующего запроса преобразование типов не потребуется, так что он немного эффективнее:
SELECT round(4.0, 4);
Пример 10.7. Разрешение функций с переменными параметрами
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
LANGUAGE sql AS ‘SELECT 1’;
CREATE FUNCTION
Эта функция принимает в аргументах ключевое слово VARIADIC, но может вызываться и без него.
Ей можно передавать и целочисленные, и любые числовые аргументы:
SELECT public.variadic_example(0),
public.variadic_example(0.0),
public.variadic_example(VARIADIC array[0.0]);
variadic_example | variadic_example | variadic_example
——————+——————+——————
1 |
1 |
1
(1 row)
Однако для первого и второго вызова предпочтительнее окажутся специализированные функции,
если таковые есть:
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
LANGUAGE sql AS ‘SELECT 2’;
CREATE FUNCTION
CREATE FUNCTION public.variadic_example(int) RETURNS int
LANGUAGE sql AS ‘SELECT 3’;
CREATE FUNCTION
SELECT public.variadic_example(0),
public.variadic_example(0.0),
351Преобразование типов
public.variadic_example(VARIADIC array[0.0]);
variadic_example | variadic_example | variadic_example
——————+——————+——————
3 |
2 |
1
(1 row)
Если используется конфигурация по умолчанию и существует только первая функция, первый и
второй вызовы будут небезопасными. Любой пользователь может перехватить их, создав вторую
или третью функцию. Безопасным будет третий вызов, в котором тип аргумента соответствует в
точности и используется ключевое слово VARIADIC.
Пример 10.8. Разрешение функции извлечения подстроки
В PostgreSQL есть несколько вариантов функции substr, и один из них принимает аргументы типов
text и integer. Если эта функция вызывается со строковой константой неопределённого типа, си-
стема выбирает функцию, принимающую аргумент предпочитаемой категории string (а конкрет-
нее, типа text).
SELECT substr(‘1234’, 3);
substr
——–
34
(1 row)
Если текстовая строка имеет тип varchar, например когда данные поступают из таблицы, анали-
затор попытается привести её к типу text:
SELECT substr (varchar ‘1234’, 3);
substr
——–
34
(1 row)
Этот запрос анализатор фактически преобразует в:
SELECT substr(CAST (varchar ‘1234’ AS text), 3);
Примечание
Анализатор узнаёт из каталога pg_cast, что типы text и varchar двоично-совместимы,
что означает, что один тип можно передать функции, принимающей другой, не выпол-
няя физического преобразования. Таким образом, в данном случае операция преобра-
зования на самом не добавляется.
И если функция вызывается с аргументом типа integer, анализатор попытается преобразовать
его в тип text:
SELECT substr(1234, 3);
ОШИБКА: функция substr(integer, integer) не существует
ПОДСКАЗКА: Функция с данными именем и типами аргументов не найдена. Возможно, вам
следует добавить явные преобразования типов.
Этот вариант не работает, так как integer нельзя неявно преобразовать в text. Однако с явным
преобразованием запрос выполняется:
SELECT substr(CAST (1234 AS text), 3);
substr
——–
352Преобразование типов
34
(1 row)
10.4. Хранимое значение
Значения, вставляемые в таблицу, преобразуется в тип данных целевого столбца по следующему
алгоритму.
Преобразование по типу хранения</li>
  <li>Проверить точное совпадение с целевым типом.</li>
  <li>Если типы не совпадают, попытаться привести тип к целевому. Это возможно, если в каталоге
pg_cast (см. CREATE CAST) зарегистрировано приведение присваивания между двумя типами.
Если же результат выражения — строка неизвестного типа, содержимое этой строки будет
подано на вход процедуре ввода целевого типа.</li>
  <li>Проверить, не требуется ли приведение размера для целевого типа. Приведение размера — это
преобразование типа к такому же. Если это приведение описано в каталоге pg_cast, приме-
нить к его к результату выражения, прежде чем сохранить в целевом столбце. Функция, реали-
зующая такое приведение, всегда принимает дополнительный параметр типа integer, в кото-
ром передаётся значение atttypmod для целевого столбца (обычно это её объявленный размер,
хотя интерпретироваться значение atttypmod для разных типов данных может по-разному), и
третий параметр типа boolean, передающий признак явное/неявное преобразование. Функция
приведения отвечает за все операции с длиной, включая её проверку и усечение данных.
Пример 10.9. Преобразование для типа хранения character
Следующие запросы показывают, что сохраняемое значение подгоняется под размер целевого
столбца, объявленного как character(20):
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT ‘abc’ || ‘def’;
SELECT v, octet_length(v) FROM vv;
v
| octet_length
———————-+————–
abcdef
|
20
(1 row)
Суть происходящего здесь в том, что две константы неизвестного типа по умолчанию воспринима-
ются как значения text, что позволяет применить к ним оператор || как оператор конкатенации
значений text. Затем результат оператора, имеющий тип text, приводится к типу bpchar («blank-
padded char» (символы, дополненные пробелами), внутреннее имя типа character) в соответствии
с типом целевого столбца. (Так как типы text и bpchar двоично-совместимы, при этом преобразо-
вании реальный вызов функции не добавляется.) Наконец, в системном каталоге находится функ-
ция изменения размера bpchar(bpchar, integer, boolean) и применяется для результата опера-
тора и длины столбца. Эта связанная с типом функция проверяет длину данных и добавляет недо-
стающие пробелы.
10.5. UNION, CASE и связанные конструкции
SQL-конструкция UNION взаимодействует с системой типов, так как ей приходится объединять зна-
чения возможно различных типов в единый результирующий набор. Алгоритм разрешения типов
при этом применяется независимо к каждому отдельному столбцу запроса. Подобным образом
различные типы сопоставляются при выполнении INTERSECT и EXCEPT сопоставляют различные
типы подобно UNION. По такому же алгоритму сопоставляют типы выражений и определяют тип
своего результата конструкции CASE, ARRAY, VALUES, GREATEST и LEAST.
Разрешение типов для UNION, CASE и связанных конструкций
1.
Если все данные одного типа и это не тип unknown, выбрать его.
353Преобразование типов
4</li>
  <li>Если тип данных — домен, далее считать их типом базовый тип домена.</li>
  <li>Если все данные типа unknown, выбрать для результата тип text (предпочитаемый для катего-
рии string). В противном случае значения unknown для остальных правил игнорируются.</li>
  <li>Если известные типы входных данных оказываются не из одной категории, констатировать
неудачу.</li>
  <li>Выбрать первый известный предпочитаемый тип из этой категории, если такой есть.</li>
  <li>В противном случае выбрать последний известный тип, в который можно неявно преобразовать
все данные предшествующих известных типов. (Такой тип есть всегда, в крайнем случае этому
условию удовлетворяет первый тип.)</li>
  <li>Привести все данные к выбранном типу. Констатировать неудачу, если для каких-либо данных
преобразование в этот тип невозможно.
Ниже это проиллюстрировано на примерах.
Пример 10.10. Разрешение типов с частичным определением в Union
SELECT text ‘a’ AS “text” UNION SELECT ‘b’;
text
——
a
b
(2 rows)
В данном случае константа ‘b’ неизвестного типа будет преобразована в тип text.
Пример 10.11. Разрешение типов в простом объединении
SELECT 1.2 AS “numeric” UNION SELECT 1;
numeric
———
1
1.2
(2 rows)
Константа 1.2 имеет тип numeric и целочисленное значение 1 может быть неявно приведено к
типу numeric, так что используется этот тип.
Пример 10.12. Разрешение типов в противоположном объединении
SELECT 1 AS “real” UNION SELECT CAST(‘2.2’ AS REAL);
real
——
1
2.2
(2 rows)
Здесь значение типа real нельзя неявно привести к integer, но integer можно неявно привести
к real, поэтому типом результата объединения будет real.
Пример 10.13. Разрешение типов во вложенном объединении
SELECT NULL UNION SELECT NULL UNION SELECT 1;
ERROR:
UNION types text and integer cannot be matched
4
Так же, как домены воспринимаются при выборе операторов и функций, доменные типы могут сохраняться в конструкции UNION или подобной, если
пользователь позаботится о том, чтобы все входные данные приводились к этому типу явно или неявно. В противном случае предпочтение будет отдано
базовому типу домена.
354Преобразование типов
Эта ошибка возникает из-за того, что PostgreSQL воспринимает множественные UNION как пары с
вложенными операциями, то есть как запись
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
Внутренний UNION разрешается как выдающий тип text, согласно правилам, приведённым выше.
Затем внешний UNION получает на вход типы text и integer, что и приводит к показанной ошибке.
Эту проблему можно устранить, сделав так, чтобы у самого левого UNION минимум с одной стороны
были данные желаемого типа результата.
Операции INTERSECT и EXCEPT также разрешаются по парам. Однако остальные конструкции, опи-
санные в этом разделе, рассматривают все входные данные сразу.
10.6. Выходные столбцы SELECT
Правила, описанные в предыдущих разделах, распространяются на присвоение типов данных, кро-
ме unknown, во всех выражениях в запросах SQL, за исключением бестиповых буквальных значе-
ний, принимающих вид простых выходных столбцов команды SELECT. Например, в запросе
SELECT ‘Hello World’;
ничто не говорит о том, какой тип должно принимать строковое буквальное значение. В этой си-
туации PostgreSQL разрешит тип такого значения как text.
Когда SELECT является одной из ветвей конструкции UNION (или INTERSECT/EXCEPT) или когда он
находится внутри INSERT … SELECT, это правило не действует, так как более высокий приоритет
имеют правила, описанные в предыдущих разделах. В первом случае тип бестипового буквального
значения может быть получен из другой ветви UNION, а во втором — из целевого столбца.
Списки RETURNING в данном контексте воспринимаются так же, как выходные списки SELECT.
Примечание
До PostgreSQL 10 этого правила не было и бестиповые буквальные значения в выход-
ном списке SELECT оставались с типом unknown. Это имело различные негативные по-
следствия, так что было решено это изменить.</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page22/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page21/">21</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page22/">22</a></li>
      
    
      
        <li><strong class="current-page">23</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page24/">24</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page25/">25</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page24/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>