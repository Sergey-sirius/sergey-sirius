<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 25. Резервное копирование и восстановление &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 25. Резервное копирование и восстановление">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 25. Резервное копирование и восстановление">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-025/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-025/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 25. Резервное копирование и восстановление">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-025/" rel="bookmark" title="Глава 25. Резервное копирование и восстановление">Глава 25. Резервное копирование и восстановление</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~41 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 25. Резервное копирование и восстановление</p>

<p>Как и всё, что содержит важные данные, базы данных PostgreSQL следует регулярно сохранять
в резервной копии. Хотя эта процедура по существу проста, важно чётко понимать лежащие в её
основе приёмы и положения.
Существует три фундаментально разных подхода к резервному копированию данных в PostgreSQL:
• Выгрузка в SQL
• Копирование на уровне файлов
• Непрерывное архивирование
Каждый из них имеет свои сильные и слабые стороны; все они обсуждаются в следующих разделах.
25.1. Выгрузка в SQL
Идея, стоящая за этим методом, заключается в генерации текстового файла с командами SQL,
которые при выполнении на сервере пересоздадут базу данных в том же самом состоянии, в ко-
тором она была на момент выгрузки. PostgreSQL предоставляет для этой цели вспомогательную
программу pg_dump. Простейшее применение этой программы выглядит так:
pg_dump имя_базы &gt; файл_дампа
Как видите, pg_dump записывает результаты своей работы в устройство стандартного вывода. Да-
лее будет рассмотрено, чем это может быть полезно. В то время как вышеупомянутая команда
создаёт текстовый файл, pg_dump может создать файлы и в других форматах, которые допускают
параллельную обработку и более гибкое управление восстановлением объектов.
Программа pg_dump является для PostgreSQL обычным клиентским приложением (хотя и весьма
умным). Это означает, что вы можете выполнять процедуру резервного копирования с любого уда-
лённого компьютера, если имеете доступ к нужной базе данных. Но помните, что pg_dump не ис-
пользует для своей работы какие-то специальные привилегии. В частности, ей обычно требуется
доступ на чтение всех таблиц, которые вы хотите выгрузить, так что для копирования всей базы
данных практически всегда её нужно запускать с правами суперпользователя СУБД. (Если у вас
нет достаточных прав для резервного копирования всей базы данных, вы, тем не менее, можете
сделать резервную копию той части базы, доступ к которой у вас есть, используя такие параметры,
как -n схема или -t таблица.)
Указать, к какому серверу должна подключаться программа pg_dump, можно с помощью аргумен-
тов командной строки -h сервер и -p порт. По умолчанию в качестве сервера выбирается localhost
или значение, указанное в переменной окружения PGHOST. Подобным образом, по умолчанию ис-
пользуется порт, заданный в переменной окружения PGPORT, а если она не задана, то порт, ука-
занный по умолчанию при компиляции. (Для удобства при компиляции сервера обычно устанав-
ливается то же значение по умолчанию.)
Как и любое другое клиентское приложение PostgreSQL, pg_dump по умолчанию будет подклю-
чаться к базе данных с именем пользователя, совпадающим с именем текущего пользователя опе-
рационной системы. Чтобы переопределить имя, либо добавьте параметр -U, либо установите пе-
ременную окружения PGUSER. Помните, что pg_dump подключается к серверу через обычные ме-
ханизмы проверки подлинности клиента (которые описываются в Главе 20).
Важное преимущество pg_dump в сравнении с другими методами резервного копирования, опи-
санными далее, состоит в том, что вывод pg_dump обычно можно загрузить в более новые версии
PostgreSQL, в то время как резервная копия на уровне файловой системы и непрерывное архиви-
рование жёстко зависят от версии сервера. Также, только метод с применением pg_dump будет
работать при переносе базы данных на другую машинную архитектуру, например, при переносе
с 32-битной на 64-битную версию сервера.
629Резервное копирова-
ние и восстановление
Дампы, создаваемые pg_dump, являются внутренне согласованными, то есть, дамп представляет
собой снимок базы данных на момент начала запуска pg_dump. pg_dump не блокирует другие опе-
рации с базой данных во время своей работы. (Исключение составляют операции, которым нужна
исключительная блокировка, как например, большинство форм команды ALTER TABLE.)
25.1.1. Восстановление дампа
Текстовые файлы, созданные pg_dump, предназначаются для последующего чтения программой
psql. Общий вид команды для восстановления дампа:
psql имя_базы &lt; файл_дампа
где файл_дампа — это файл, содержащий вывод команды pg_dump. База данных, заданная пара-
метром имя_базы, не будет создана данной командой, так что вы должны создать её сами из базы
template0 перед запуском psql (например, с помощью команды createdb -T template0 имя_ба-
зы). Программа psql принимает параметры, указывающие сервер, к которому осуществляется под-
ключение, и имя пользователя, подобно pg_dump. За дополнительными сведениями обратитесь
к справке по psql. Дампы, выгруженные не в текстовом формате, восстанавливаются утилитой
pg_restore.
Перед восстановлением SQL-дампа все пользователи, которые владели объектами или имели пра-
ва на объекты в выгруженной базе данных, должны уже существовать. Если их нет, при восстанов-
лении будут ошибки пересоздания объектов с изначальными владельцами и/или правами. (Иногда
это желаемый результат, но обычно нет).
По умолчанию, если происходит ошибка SQL, программа psql продолжает выполнение. Если же
запустить psql с установленной переменной ON_ERROR_STOP, это поведение поменяется и psql за-
вершится с кодом 3 в случае возникновения ошибки SQL:
psql –set ON_ERROR_STOP=on имя_базы &lt; файл_дампа
В любом случае, вы получите только частично восстановленную базу данных. В качестве альтер-
нативы можно указать, что весь дамп должен быть восстановлен в одной транзакции, так что вос-
становление либо полностью выполнится, либо полностью отменится. Включить данный режим
можно, передав psql аргумент -1 или –single-transaction. Выбирая этот режим, учтите, что да-
же незначительная ошибка может привести к откату восстановления, которое могло продолжать-
ся несколько часов. Однако, это всё же может быть предпочтительней, чем вручную вычищать
сложную базу данных после частично восстановленного дампа.
Благодаря способности pg_dump и psql писать и читать каналы ввода/вывода, можно скопировать
базу данных непосредственно с одного сервера на другой, например:
pg_dump -h host1 имя_базы | psql -h host2 имя_базы
Важно
Дампы, которые выдаёт pg_dump, содержат определения относительно template0. Это
означает, что любые языки, процедуры и т. п., добавленные в базу через template1,
pg_dump также выгрузит в дамп. Как следствие, если при восстановлении вы ис-
пользуете модифицированный template1, вы должны создать пустую базу данных из
template0, как показано в примере выше.
После восстановления резервной копии имеет смысл запустить ANALYZE для каждой базы дан-
ных, чтобы оптимизатор запросов получил полезную статистику; за подробностями обратитесь к
Подразделу 24.1.3 и Подразделу 24.1.6. Другие советы по эффективной загрузке больших объёмов
данных в PostgreSQL вы можете найти в Разделе 14.4.
25.1.2. Использование pg_dumpall
Программа pg_dump выгружает только одну базу данных в один момент времени и не включает
в дамп информацию о ролях и табличных пространствах (так как это информация уровня класте-
630Резервное копирова-
ние и восстановление
ра, а не самой базы данных). Для удобства создания дампа всего содержимого кластера баз дан-
ных предоставляется программа pg_dumpall, которая делает резервную копию всех баз данных
кластера, а также сохраняет данные уровня кластера, такие как роли и определения табличных
пространств. Простое использование этой команды:
pg_dumpall &gt; файл_дампа
Полученную копию можно восстановить с помощью psql:
psql -f файл_дампа postgres
(В принципе, здесь в качестве начальной базы данных можно указать имя любой существующей
базы, но если вы загружаете дамп в пустой кластер, обычно нужно использовать postgres). Вос-
станавливать дамп, который выдала pg_dumpall, всегда необходимо с правами суперпользователя,
так как они требуются для восстановления информации о ролях и табличных пространствах. Если
вы используете табличные пространства, убедитесь, что пути к табличным пространствам в дампе
соответствуют новой среде.
pg_dumpall выдаёт команды, которые заново создают роли, табличные пространства и пустые базы
данных, а затем вызывает для каждой базы pg_dump. Таким образом, хотя каждая база данных
будет внутренне согласованной, состояние разных баз не будет синхронным.
Только глобальные данные кластера можно выгрузить, передав pg_dumpall ключ –globals-only.
Это необходимо, чтобы полностью скопировать кластер, когда pg_dump выполняется для отдель-
ных баз данных.
25.1.3. Управление большими базами данных
Некоторые операционные системы накладывают ограничение на максимальный размер файла, что
приводит к проблемам при создании больших файлов с помощью pg_dump. К счастью, pg_dump
может писать в стандартный вывод, так что вы можете использовать стандартные инструменты
Unix для того, чтобы избежать потенциальных проблем. Вот несколько возможных методов:
Используйте сжатые дампы.
например gzip:
Вы можете использовать предпочитаемую программу сжатия,
pg_dump имя_базы | gzip &gt; имя_файла.gz
Затем загрузить сжатый дамп можно командой:
gunzip -c имя_файла.gz | psql имя_базы
или:
cat имя_файла.gz | gunzip | psql имя_базы
Используйте split.  Команда split может разбивать выводимые данные на небольшие файлы,
размер которых удовлетворяет ограничению нижележащей файловой системы. Например, чтобы
получить части по 1 мегабайту:
pg_dump имя_базы | split -b 1m - имя_файла
Восстановить их можно так:
cat имя_файла* | psql имя_базы
Используйте специальный формат дампа pg_dump.  Если при сборке PostgreSQL была под-
ключена библиотека zlib, дамп в специальном формате будет записываться в файл в сжатом виде.
В таком формате размер файла дампа будет близок к размеру, полученному с применением gzip,
но он лучше тем, что позволяет восстанавливать таблицы выборочно. Следующая команда выгру-
жает базу данных в специальном формате:
pg_dump -Fc имя_базы &gt; имя_файла
Дамп в специальном формате не является скриптом для psql и должен восстанавливаться с помо-
щью команды pg_restore, например:
631Резервное копирова-
ние и восстановление
pg_restore -d имя_базы имя_файла
За подробностями обратитесь к справке по командам pg_dump и pg_restore.
Для очень больших баз данных может понадобиться сочетать split с одним из двух других методов.
Используйте возможность параллельной выгрузки в pg_dump.  Чтобы ускорить выгрузку
большой БД, вы можете использовать режим параллельной выгрузки в pg_dump. При этом одно-
временно будут выгружаться несколько таблиц. Управлять числом параллельных заданий позво-
ляет параметр -j. Параллельная выгрузка поддерживается только для формата архива в каталоге.
pg_dump -j число -F d -f выходной_каталог имя_базы
Вы также можете восстановить копию в параллельном режиме с помощью pg_restore -j. Это под-
держивается для любого архива в формате каталога или специальном формате, даже если архив
создавался не командой pg_dump -j.
25.2. Резервное копирование на уровне файлов
Альтернативной стратегией резервного копирования является непосредственное копирование
файлов, в которых PostgreSQL хранит содержимое базы данных; в Разделе 18.2 рассказывается,
где находятся эти файлы. Вы можете использовать любой способ копирования файлов по желанию,
например:
tar -cf backup.tar /usr/local/pgsql/data
Однако, существуют два ограничения, которые делают этот метод непрактичным или как минимум
менее предпочтительным по сравнению с pg_dump:</p>
<ol>
  <li>Чтобы полученная резервная копия была годной, сервер баз данных должен быть остановлен.
Такие полумеры, как запрещение всех подключений к серверу, работать не будут (отчасти пото-
му что tar и подобные средства не получают мгновенный снимок состояния файловой системы,
но ещё и потому, что в сервере есть внутренние буферы). Узнать о том, как остановить сервер,
можно в Разделе 18.5. Необходимо отметить, что сервер нужно будет остановить и перед вос-
становлением данных.</li>
  <li>Если вы ознакомились с внутренней организацией базы данных в файловой системе, у вас может
возникнуть соблазн скопировать или восстановить только отдельные таблицы или базы данных
в соответствующих файлах или каталогах. Это не будет работать, потому что информацию, со-
держащуюся в этих файлах, нельзя использовать без файлов журналов транзакций, pg_xact/*,
которые содержат состояние всех транзакций. Без этих данных файлы таблиц непригодны к ис-
пользованию. Разумеется также невозможно восстановить только одну таблицу и соответствую-
щие данные pg_xact, потому что в результате нерабочими станут все другие таблицы в кластере
баз данных. Таким образом, копирование на уровне файловой системы будет работать, только
если выполняется полное копирование и восстановление всего кластера баз данных.
Ещё один подход к резервному копированию файловой системы заключается в создании «целост-
ного снимка» каталога с данными, если это поддерживает файловая система (и вы склонны счи-
тать, что эта функциональность реализована корректно). Типичная процедура включает создание
«замороженного снимка» тома, содержащего базу данных, затем копирование всего каталога с
данными (а не его избранных частей, см. выше) из этого снимка на устройство резервного копи-
рования, и наконец освобождение замороженного снимка. При этом сервер базы данных может
не прекращать свою работу. Однако резервная копия, созданная таким способом, содержит фай-
лы базы данных в таком состоянии, как если бы сервер баз данных не был остановлен штатным
образом; таким образом, когда вы запустите сервер баз данных с сохранёнными данными, он будет
считать, что до этого процесс сервера был прерван аварийно, и будет накатывать журнал WAL. Это
не проблема, просто имейте это в виду (и обязательно включите файлы WAL в резервную копию).
Чтобы сократить время восстановления, можно выполнить команду CHECKPOINT перед созданием
снимка.
Если ваша база данных размещена в нескольких файловых системах, получить в точности одновре-
менно замороженные снимки всех томов может быть невозможно. Например, если файлы данных
632Резервное копирова-
ние и восстановление
и журналы WAL находятся на разных дисках или табличные пространства расположены в разных
файловых системах, резервное копирование со снимками может быть неприменимо, потому что
снимки должны быть одновременными. В таких ситуациях очень внимательно изучите докумен-
тацию по вашей файловой системе, прежде чем довериться технологии согласованных снимков.
Если одновременные снимки невозможны, остаётся вариант с остановкой сервера баз данных на
время, достаточное для получения всех замороженных снимков. Другое возможное решение — по-
лучить базовую копию путём непрерывного архивирования (см. Подраздел 25.3.2), такие резерв-
ные копии не могут пострадать от изменений файловой системы в процессе резервного копирова-
ния. Для этого требуется включить непрерывное архивирование только на время резервного ко-
пирования; для восстановления применяется процедура восстановления из непрерывного архива
(Подраздел 25.3.4).
Ещё один вариант — копировать содержимое файловой системы с помощью rsync. Для этого rsync
запускается сначала во время работы сервера баз данных, а затем сервер останавливается на вре-
мя, достаточное для запуска rsync –checksum. (Ключ –checksum необходим, потому что rsync
различает время только с точностью до секунд.) Во второй раз rsync отработает быстрее, чем в
первый, потому что скопировать надо будет относительно немного данных; и в итоге будет полу-
чен согласованный результат, так как сервер был остановлен. Данный метод позволяет получить
копию на уровне файловой системы с минимальным временем простоя.
Обратите внимание, что размер копии на уровне файлов обычно больше, чем дампа SQL. (Про-
грамме pg_dump не нужно, например, записывать содержимое индексов, достаточно команд для
их пересоздания). Однако копирование на уровне файлов может выполняться быстрее.
25.3. Непрерывное архивирование и восстановление
на момент времени (Point-in-Time Recovery, PITR)
Всё время в процессе работы PostgreSQL ведёт журнал предзаписи (WAL), который расположен в
подкаталоге pg_wal/ каталога с данными кластера баз данных. В этот журнал записываются все
изменения, вносимые в файлы данных. Прежде всего, журнал существует для безопасного восста-
новления после краха сервера: если происходит крах, целостность СУБД может быть восстановле-
на в результате «воспроизведения» записей, зафиксированных после последней контрольной точ-
ки. Однако наличие журнала делает возможным использование третьей стратегии копирования
баз данных: можно сочетать резервное копирование на уровне файловой системы с копированием
файлов WAL. Если потребуется восстановить данные, мы можем восстановить копию файлов, а за-
тем воспроизвести журнал из скопированных файлов WAL, и таким образом привести систему в
нужное состояние. Такой подход более сложен для администрирования, чем любой из описанных
выше, но он имеет значительные преимущества:
• В качестве начальной точки для восстановления необязательно иметь полностью согласован-
ную копию на уровне файлов. Внутренняя несогласованность копии будет исправлена при
воспроизведении журнала (практически то же самое происходит при восстановлении после
краха). Таким образом, согласованный снимок файловой системы не требуется, вполне можно
использовать tar или похожие средства архивации.
• Поскольку при воспроизведении можно обрабатывать неограниченную последовательность
файлов WAL, непрерывную резервную копию можно получить, просто продолжая архивиро-
вать файлы WAL. Это особенно ценно для больших баз данных, полные резервные копии кото-
рых делать как минимум неудобно.
• Воспроизводить все записи WAL до самого конца нет необходимости. Воспроизведение мож-
но остановить в любой точке и получить целостный снимок базы данных на этот момент вре-
мени. Таким образом, данная технология поддерживает восстановление на момент времени:
можно восстановить состояние базы данных на любое время с момента создания резервной
копии.
• Если непрерывно передавать последовательность файлов WAL другому серверу, получивше-
му данные из базовой копии того же кластера, получается система тёплого резерва: в любой
633Резервное копирова-
ние и восстановление
момент мы можем запустить второй сервер и он будет иметь практически текущую копию баз
данных.
Примечание
Программы pg_dump и pg_dumpall не создают копии на уровне файловой системы и не
могут применяться как часть решения по непрерывной архивации. Создаваемые ими
копии являются логическими и не содержат информации, необходимой для воспроиз-
ведения WAL.
Как и обычное резервное копирование файловой системы, этот метод позволяет восстанавливать
только весь кластер баз данных целиком, но не его части. Кроме того, для архивов требуется боль-
шое хранилище: базовая резервная копия может быть объёмной, а нагруженные системы будут
генерировать многие мегабайты трафика WAL, который необходимо архивировать. Тем не менее,
этот метод резервного копирования предпочитается во многих ситуациях, где необходима высокая
надёжность.
Для успешного восстановления с применением непрерывного архивирования (также называемого
«оперативным резервным копированием» многими разработчиками СУБД), вам необходима непре-
рывная последовательность заархивированных файлов WAL, начинающаяся не позже, чем с мо-
мента начала копирования. Так что для начала вы должны настроить и протестировать процедуру
архивирования файлов WAL до того, как получите первую базовую копию. Соответственно, сна-
чала мы обсудим механику архивирования файлов WAL.
25.3.1. Настройка архивирования WAL
В абстрактном смысле, запущенная СУБД PostgreSQL производит неограниченно длинную после-
довательность записей WAL. СУБД физически делит эту последовательность на файлы сегментов
WAL, которые обычно имеют размер 16 МиБ (хотя размер сегмента может быть изменён при initdb).
Файлы сегментов получают цифровые имена, которые отражают их позицию в абстрактной после-
довательности WAL. Когда архивирование WAL не применяется, система обычно создаёт только
несколько файлов сегментов и затем «перерабатывает» их, меняя номер в имени ставшего ненуж-
ным файла на больший. Предполагается, что файлы сегментов, содержимое которых предшеству-
ет последней контрольной точке, уже не представляют интереса и могут быть переработаны.
При архивировании данных WAL необходимо считывать содержимое каждого файла-сегмента, как
только он заполняется, и сохранять эти данные куда-то, прежде чем файл-сегмент будет перера-
ботан и использован повторно. В зависимости от применения и доступного аппаратного обеспече-
ния, возможны разные способы «сохранить данные куда-то»: можно скопировать файлы-сегменты
в смонтированный по NFS каталог на другую машину, записать их на ленту (убедившись, что у вас
есть способ идентифицировать исходное имя каждого файла) или собрать их в пакет и записать
на CD, либо какие-то совсем другие варианты. Чтобы у администратора баз данных была гибкость
в этом плане, PostgreSQL пытается не делать каких-либо предположений о том, как будет выпол-
няться архивация. Вместо этого, PostgreSQL позволяет администратору указать команду оболоч-
ки, которая будет запускаться для копирования завершённого файла-сегмента в нужное место.
Эта команда может быть простой как cp, а может вызывать сложный скрипт оболочки — это ре-
шать вам.
Чтобы включить архивирование WAL, установите в параметре конфигурации wal_level уровень
replica (или выше), в archive_mode — значение on, и задайте желаемую команду оболочки в па-
раметре archive_command. На практике эти параметры всегда задаются в файле postgresql.conf.
В archive_command символы %p заменяются полным путём к файлу, подлежащему архивации, а %f
заменяются только именем файла. (Путь задаётся относительно текущего рабочего каталога, т. е.
каталога данных кластера). Если в команду нужно включить сам символ %, запишите %%. Простей-
шая команда, которая может быть полезна:
archive_command = ‘test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/
%f’ # Unix
archive_command = ‘copy “%p” “C:\server\archivedir\%f”’ # Windows
634Резервное копирова-
ние и восстановление
Она будет копировать архивируемые сегменты WAL в каталог /mnt/server/archivedir. (Команда дана
как пример, а не как рекомендация, и может не работать на всех платформах.) После замены
параметров %p и %f фактически запускаемая команда может выглядеть так:
test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp
pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
Подобная команда будет генерироваться для каждого следующего архивируемого файла.
Команда архивирования будет запущена от имени того же пользователя, от имени которого рабо-
тает сервер PostgreSQL. Поскольку архивируемые последовательности файлов WAL фактически
содержат всё, что есть в вашей базе данных, вам нужно будет защитить архивируемые данные от
посторонних глаз; например, сохраните архив в каталог, чтение которого запрещено для группы
и остальных пользователей.
Важно, чтобы команда архивирования возвращала нулевой код завершения, если и только ес-
ли она завершилась успешно. Получив нулевой результат, PostgreSQL будет полагать, что файл
успешно заархивирован и удалит его или переработает. Однако, ненулевой код состояния скажет
PostgreSQL, что файл не заархивирован; попытки заархивировать его будут периодически повто-
ряться, пока это не удастся.
Команда архивирования обычно разрабатывается так, чтобы не допускать перезаписи любых су-
ществующих архивных файлов. Это важная мера безопасности, позволяющая сохранить целост-
ность архива в случае ошибки администратора (например, если архивируемые данные двух разных
серверов будут сохраняться в одном каталоге).
Рекомендуется протестировать команду архивирования, чтобы убедиться, что она действительно
не перезаписывает существующие файлы, и что она возвращает ненулевое состояние в этом
случае. В показанной выше команде для Unix для этого добавлен отдельный шаг test. На некото-
рых платформах Unix у cp есть ключ -i, который позволяет сделать то же, но менее явно; но не
проверив, какой код состояния при этом возвращается, полагаться на этот ключ не следует. (В
частности, GNU cp возвратит нулевой код состояния, если используется ключ -i и целевой файл
существует, а это не то, что нужно.)
Разрабатывая схему архивирования, подумайте, что произойдёт, если команда архивирования нач-
нёт постоянно выдавать ошибку, потому что требуется вмешательство оператора или для архиви-
рования не хватает места. Например, это может произойти, если вы записываете архивы на лен-
точное устройство без механизма автозамены; когда лента заполняется полностью, больше ниче-
го архивироваться не будет, пока вы не замените кассету. Вы должны убедиться, что любые воз-
никающие ошибки или обращения к человеку (оператору), обрабатываются так, чтобы проблема
решалась достаточно быстро. Пока она не разрешится, каталог pg_wal/ продолжит наполняться
файлами-сегментами WAL. (Если файловая система, в которой находится каталог pg_wal/ запол-
нится до конца, PostgreSQL завершит свою работу аварийно. Зафиксированные транзакции не по-
теряются, но база данных не будет работать, пока вы не освободите место.)
Не важно, с какой скоростью работает команда архивирования, если только она не ниже средней
скорости, с которой сервер генерирует записи WAL. Обычно работа продолжается, даже если про-
цесс архивирования немного отстаёт. Если же архивирование отстаёт значительно, это приводит
к увеличению объёма данных, которые могут быть потеряны в случае аварии. При этом каталог
pg_wal/ будет содержать большое количество ещё не заархивированных файлов-сегментов, кото-
рые в конце концов могут занять всё доступное дисковое пространство. Поэтому рекомендуется
контролировать процесс архивации и следить за тем, чтобы он выполнялся как задумано.
При написании команды архивирования вы должны иметь в виду, что имена файлов для архиви-
рования могут иметь длину до 64 символов и содержать любые комбинации из цифр, точек и букв
ASCII. Сохранять исходный относительный путь (%p) необязательно, но необходимо сохранять имя
файла (%f).
Обратите внимание, что хотя архивирование WAL позволяет сохранить любые изменения данных,
произведённые в базе данных PostgreSQL, оно не затрагивает изменения, внесённые в конфигура-
635Резервное копирова-
ние и восстановление
ционные файлы (такие как postgresql.conf, pg_hba.conf и pg_ident.conf), поскольку эти изме-
нения выполняются вручную, а не через SQL. Поэтому имеет смысл разместить конфигурацион-
ные файлы там, где они будут заархивированы обычными процедурами копирования файлов. Как
перемещать конфигурационные файлы, рассказывается в Разделе 19.2.
Команда архивирования вызывается, только когда сегмент WAL заполнен до конца. Таким обра-
зом, если сервер постоянно генерирует небольшой трафик WAL (или есть продолжительные пери-
оды, когда это происходит), между завершением транзакций и их безопасным сохранением в ар-
хиве может образоваться большая задержка. Чтобы ограничить время жизни неархивированных
данных, можно установить archive_timeout, чтобы сервер переключался на новый файл сегмента
WAL как минимум с заданной частотой. Заметьте, что неполные файлы, архивируемые досрочно
из-за принудительного переключения по тайм-ауту, будут иметь тот же размер, что и заполнен-
ные файлы. Таким образом, устанавливать очень маленький archive_timeout — неразумно; это
приведёт к неэффективному заполнению архива. Обычно подходящее значение archive_timeout
— минута или около того.
Также вы можете принудительно переключить сегмент WAL вручную с помощью pg_switch_wal,
если хотите, чтобы только что завершённая транзакция заархивировалась как можно скорее. Дру-
гие полезные функции, относящиеся к управлению WAL, перечисляются в Таблице 9.79.
Когда wal_level имеет значение minimal, некоторые команды SQL выполняются в обход журна-
ла WAL, как описывается в Подразделе  14.4.7. Если архивирование или потоковая репликация
были включены во время выполнения таких операторов, WAL не будет содержать информацию,
необходимую для восстановления. (На восстановление после краха это не распространяется). По-
этому wal_level можно изменить только при запуске сервера. Однако, чтобы изменить команду
archive_command, достаточно перезагрузить файл конфигурации. Если вы хотите на время остано-
вить архивирование, это можно сделать, например, задав в качестве значения archive_command
пустую строку (‘’). В результате файлы WAL будут накапливаться в каталоге pg_wal/, пока не будет
восстановлена действующая команда archive_command.
25.3.2. Создание базовой резервной копии
Проще всего получить базовую резервную копию, используя программу pg_basebackup. Эта про-
грамма сохраняет базовую копию в виде обычных файлов или в архиве tar. Если гибкости
pg_basebackup не хватает, вы также можете получить базовую резервную копию, используя низ-
коуровневый API (см. Подраздел 25.3.3).
Продолжительность создания резервной копии обычно не имеет большого значения. Однако, ес-
ли вы эксплуатируете сервер с отключённым режимом full_page_writes, вы можете заметить па-
дение производительности в процессе резервного копирования, так как режим full_page_writes
включается принудительно на время резервного копирования.
Чтобы резервной копией можно было пользоваться, нужно сохранить все файлы сегментов WAL,
сгенерированные во время и после копирования файлов. Для облегчения этой задачи, процесс
создания базовой резервной копии записывает файл истории резервного копирования, который
немедленно сохраняется в области архивации WAL. Данный файл получает имя по имени файла
первого сегмента WAL, который потребуется для восстановления скопированных файлов. Напри-
мер, если начальный файл WAL назывался 0000000100001234000055CD, файл истории резервного
копирования получит имя 0000000100001234000055CD.007C9330.backup. (Вторая часть имени фай-
ла обозначает точную позицию внутри файла WAL и обычно может быть проигнорирована.) Как
только вы заархивировали копии файлов данных и файлов сегментов WAL, полученных в процес-
се копирования (по сведениям в файле истории резервного копирования), все заархивированные
сегменты WAL с именами, меньшими по номеру, становятся ненужными для восстановления фай-
ловой копии и могут быть удалены. Но всё же рассмотрите возможность хранения нескольких на-
боров резервных копий, чтобы быть абсолютно уверенными, что вы сможете восстановить ваши
данные.
Файл истории резервного копирования — это просто небольшой текстовый файл. В него записы-
вается метка, которая была передана pg_basebackup, а также время и текущие сегменты WAL в
636Резервное копирова-
ние и восстановление
момент начала и завершения резервной копии. Если вы связали с данной меткой соответствующий
файл дампа, то заархивированного файла истории достаточно, чтобы найти файл дампа, нужный
для восстановления.
Поскольку необходимо хранить все заархивированные файлы WAL с момента последней базовой
резервной копии, интервал базового резервного копирования обычно выбирается в зависимости
от того, сколько места может быть выделено для архива файлов WAL. Также стоит отталкиваться
от того, сколько вы готовы ожидать восстановления, если оно понадобится — системе придётся
воспроизвести все эти сегменты WAL, а этот процесс может быть долгим, если с момента последней
базовой копии прошло много времени.
25.3.3. Создание базовой резервной копии через низкоуровневый
API
Процедура создания базовой резервной копии с использованием низкоуровневого API содержит
чуть больше шагов, чем метод pg_basebackup, но всё же относительно проста. Очень важно, чтобы
эти шаги выполнялись по порядку, и следующий шаг выполнялся, только если предыдущий успе-
шен.
Резервное копирование на низком уровне можно произвести в монопольном или немонопольном
режиме. Рекомендуется применять немонопольный метод, а монопольный считается устаревшим
и в конце концов будет ликвидирован.
25.3.3.1. Немонопольное резервное копирование на низком уровне
Немонопольное резервное копирование позволяет параллельно запускать другие процессы копи-
рования (используя тот же API или pg_basebackup).</li>
  <li>Убедитесь, что архивирование WAL включено и работает.</li>
  <li>Подключитесь к серверу (к любой базе данных) как пользователь с правами на выполнение
pg_start_backup (суперпользователь или пользователь, которому дано право EXECUTE для этой
функции) и выполните команду:
SELECT pg_start_backup(‘label’, false, false);
где label — любая метка, по которой можно однозначно идентифицировать данную операцию
резервного копирования. Соединение, через которое вызывается pg_start_backup, должно под-
держиваться до окончания резервного копирования, иначе этот процесс будет автоматически
прерван.
По умолчанию pg_start_backup может выполняться длительное время. Это объясняется тем,
что функция выполняет контрольную точку, а операции ввода/вывода, требуемые для этого, рас-
пределяются в интервале времени, по умолчанию равном половине интервала между контроль-
ными точками (см. параметр checkpoint_completion_target). Обычно это вполне приемлемо, так
как при этом минимизируется влияние на выполнение других запросов. Если же вы хотите на-
чать резервное копирование максимально быстро, передайте во втором параметре true. В этом
случае контрольная точка будет выполнена немедленно без ограничения объёма ввода/вывода.
Третий параметр, имеющий значение false, указывает pg_start_backup начать немонопольное
базовое копирование.</li>
  <li>Скопируйте файлы, используя любое удобное средство резервного копирования, например, tar
или cpio (не pg_dump или pg_dumpall). В процессе копирования останавливать работу базы дан-
ных не требуется, это ничего не даёт. В Подразделе 25.3.3.3 описано, что следует учитывать в
процессе копирования.</li>
  <li>Через то же подключение, что и раньше, выполните команду:
SELECT * FROM pg_stop_backup(false, true);
При этом сервер выйдет из режима резервного копирования. Ведущий сервер вместе с этим ав-
томатически переключится на следующий сегмент WAL. На ведомом автоматическое переклю-
637Резервное копирова-
ние и восстановление
чение сегментов WAL невозможно, поэтому вы можете выполнить pg_switch_wal на ведущем,
чтобы произвести переключение вручную. Такое переключение позволяет получить готовый к
архивированию последний сегмент WAL, записанный в процессе резервного копирования.
Функция pg_stop_backup возвратит одну строку с тремя значениями. Второе из них нужно за-
писать в файл backup_label в корневой каталог резервной копии. Третье значение, если оно не
пустое, должно быть записано в файл tablespace_map. Эти значения крайне важны для восста-
новления копии и должны записываться без изменений.</li>
  <li>После этого останется заархивировать файлы сегментов WAL, активных во время создания ре-
зервной копии, и процедура резервного копирования будет завершена. Функция pg_stop_backup
в первом значении результата указывает, какой последний сегмент требуется для форми-
рования полного набора файлов резервной копии. На ведущем сервере, если включён ре-
жим архивации (параметр archive_mode) и аргумент wait_for_archive равен true, функция
pg_stop_backup не завершится, пока не будет заархивирован последний сегмент. На ведомом
значением archive_mode должно быть always, чтобы pg_stop_backup ожидала архивации. Эти
файлы будут заархивированы автоматически, поскольку также должна быть настроена команда
archive_command. Чаще всего это происходит быстро, но мы советуем наблюдать за системой
архивации и проверять, не возникают ли задержки. Если архивирование остановится из-за оши-
бок команды архивации, попытки архивации будут продолжаться до успешного завершения, и
только тогда резервная копия будет завершена. Если вы хотите ограничить время выполнения
pg_stop_backup, установите соответствующее значение в statement_timeout, но заметьте, что в
случае прерывания pg_stop_backup по времени резервная копия может оказаться негодной.
Если в процедуре резервного копирования предусмотрено отслеживание и архивация всех фай-
лов сегментов WAL, необходимых для резервной копии, то в аргументе wait_for_archive (по
умолчанию равном true) можно передать false, чтобы функция pg_stop_backup завершилась
сразу, как только в WAL будет помещена запись о завершении копирования. По умолчанию
pg_stop_backup будет ждать окончания архивации всех файлов WAL, что может занять некото-
рое время. Использовать этот параметр следует с осторожностью: если архивация WAL не кон-
тролируется, в резервной копии могут оказаться не все необходимые файлы WAL и её нельзя
будет восстановить.
25.3.3.2. Монопольное резервное копирование на низком уровне
Монопольное резервное копирование во многом похоже на немонопольное, но имеет несколько
важных отличий. Такое копирование можно произвести только на ведущем сервере, и оно исклю-
чает одновременное выполнение других процессов копирования. До PostgreSQL 9.6 это был един-
ственный возможный метод низкоуровневого копирования, но сейчас пользователям рекоменду-
ется по возможности подкорректировать свои скрипты и перейти к использованию немонополь-
ного варианта.</li>
  <li>Убедитесь, что архивирование WAL включено и работает.</li>
  <li>Подключитесь к серверу (к любой базе данных) как пользователь с правами на выполнение
pg_start_backup (суперпользователь или пользователь, которому дано право EXECUTE для этой
функции) и выполните команду:
SELECT pg_start_backup(‘label’);
где label — любая метка, по которой можно однозначно идентифицировать данную операцию
резервного копирования. Функция pg_start_backup создаёт в каталоге кластера файл метки
резервного копирования, называемый backup_label, в который помещается информация о ре-
зервной копии, включающая время начала и строку метки. Эта функция также создаёт в ката-
логе кластера файл карты табличных пространств, называемый tablespace_map, с информа-
цией о символических ссылках табличных пространств в pg_tblspc/, если такие ссылки есть.
Оба файла важны для целостности резервных копии и понадобятся при восстановлении.
По умолчанию pg_start_backup может выполняться длительное время. Это объясняется тем,
что функция выполняет контрольную точку, а операции ввода/вывода, требуемые для этого, рас-
пределяются в интервале времени, по умолчанию равном половине интервала между контроль-
638Резервное копирова-
ние и восстановление
ными точками (см. параметр checkpoint_completion_target). Обычно это вполне приемлемо, так
как при этом минимизируется влияние на выполнение других запросов. Если же вы хотите на-
чать резервное копирование максимально быстро, выполните:
SELECT pg_start_backup(‘label’, true);
При этом контрольная точка будет выполнена как можно скорее.</li>
  <li>Скопируйте файлы, используя любое удобное средство резервного копирования, например, tar
или cpio (не pg_dump или pg_dumpall). В процессе копирования останавливать работу базы дан-
ных не требуется, это ничего не даёт. В Подразделе 25.3.3.3 описано, что следует учитывать в
процессе копирования.
Заметьте, что в случае сбоя сервера во время резервного копирования для успешного его пере-
запуска может потребоваться вручную удалить файл backup_label из каталога PGDATA.</li>
  <li>Снова подключитесь к базе данных как пользователь с правами на выполнение pg_stop_backup
(суперпользователь или пользователь, которому дано право EXECUTE для этой функции) и вы-
полните команду:
SELECT pg_stop_backup();
Эта функция завершит режим резервного копирования и автоматически переключится на сле-
дующий сегмент WAL. Это переключение выполняется для того, чтобы файл последнего сегмен-
та WAL, записанного во время копирования, был готов к архивации.</li>
  <li>После этого останется заархивировать файлы сегментов WAL, активных во время создания ре-
зервной копии, и процедура резервного копирования будет завершена. Функция pg_stop_backup
возвращает указание на файл последнего сегмента, который требуется для формирования пол-
ного набора файлов резервной копии. Если включён режим архивации (параметр archive_mode),
функция pg_stop_backup не завершится, пока не будет заархивирован последний сегмент. В
этом случае файлы будут заархивированы автоматически, поскольку также должна быть настро-
ена команда archive_command. Чаще всего это происходит быстро, но мы советуем наблюдать за
системой архивации и проверять, не возникают ли задержки. Если архивирование остановится
из-за ошибок команды архивации, попытки архивации будут продолжаться до успешного завер-
шения, и только тогда резервная копия будет завершена. Если вы хотите ограничить время вы-
полнения pg_stop_backup, установите соответствующее значение в statement_timeout, но за-
метьте, что в случае прерывания pg_stop_backup по времени резервная копия может оказаться
негодной.
25.3.3.3. Копирование каталога данных
Некоторые средства резервного копирования файлов выдают предупреждения или ошибки, если
файлы, которые они пытаются скопировать, изменяются в процессе копирования. При получении
базовой резервной копии активной базы данных это вполне нормально и не является ошибкой.
Однако, вам нужно знать, как отличить ошибки такого рода от реальных ошибок. Например, неко-
торые версии rsync возвращают отдельный код выхода для ситуации «исчезнувшие исходные фай-
лы», и вы можете написать управляющий скрипт, который примет этот код как не ошибочный.
Также некоторые версии GNU tar возвращают код выхода, неотличимый от кода фатальной ошиб-
ки, если файл был усечён, когда tar копировал его. К счастью, GNU tar версий 1.16 и более поздних
завершается с кодом 1, если файл был изменён во время копирования, и 2 в случае других ошибок.
С GNU tar версии 1.23 и более поздними, вы можете использовать следующие ключи –warning=no-
file-changed –warning=no-file-removed, чтобы скрыть соответствующие предупреждения.
Убедитесь, что ваша резервная копия включает все файлы из каталога кластера баз данных (на-
пример, /usr/local/pgsql/data). Если вы используете табличные пространства, которые находят-
ся не внутри этого каталога, не забудьте включить и их в резервную копию (также важно, что-
бы при создании резервной копии символьные ссылки сохранялись как ссылки, иначе табличные
пространства будут повреждены при восстановлении).
Однако следует исключить из резервной копии файлы в подкаталоге данных кластера pg_wal/. Эту
небольшую корректировку стоит внести для снижения риска ошибок при восстановлении. Это лег-
639Резервное копирова-
ние и восстановление
ко организовать, если pg_wal/ — символическая ссылка на каталог за пределами каталога данных
(так часто делают из соображений производительности). Также имеет смысл исключить файлы
postmaster.pid и postmaster.opts, содержащие информацию о работающем процессе postmaster
(а не о том процессе postmaster, который будет восстанавливать эту копию). (Эти файлы могут вве-
сти pg_ctl в заблуждение.)
Часто также стоит исключать из резервной копии каталог pg_replslot/ кластера, чтобы слоты
репликации, существующие на главном сервере, не попадали в копию. В противном случае, при
последующем восстановлении копии на резервном сервере может получиться так, что он будет
неограниченно долго сохранять файлы WAL, а главный не будет очищаться, если он следит за го-
рячим резервом, так как клиенты этих слотов репликации будут продолжать подключаться и из-
менять состояние слотов на главном, а не резервном сервере. Даже если резервная копия пред-
назначена только для создания нового главного сервера, копирование слотов репликации вряд ли
принесёт пользу, так как к моменту включения в работу этого нового сервера содержимое этих
слотов станет абсолютно неактуальным.
Содержимое каталогов pg_dynshmem/, pg_notify/, pg_serial/, pg_snapshots/, pg_stat_tmp/ и
pg_subtrans/ (но не сами эти каталоги) можно исключить из резервной копии, так как оно будет
инициализировано при запуске главного процесса. Если переменная stats_temp_directory установ-
лена и указывает на подкаталог внутри каталога данных, содержимое этого подкаталога также
можно не копировать.
Из резервной копии можно исключить и файлы и подкаталоги с именами, начинающимся с
pgsql_tmp. Эти файлы удаляются при запуске главного процесса, а каталоги создаются по мере
необходимости.
Из резервной копии могут быть исключены файлы pg_internal.init. Такие файлы содержат ке-
шируемые данные отношения и всегда перестраиваются при восстановлении.
В файл метки резервной копии записывается строка метки, заданная при вызове pg_start_backup,
время запуска функции pg_start_backup и имя начального файла WAL. Таким образом, в случае
сомнений можно заглянуть внутрь архива резервной копии и точно определить, в каком сеансе
резервного копирования он был создан. Файл карты табличных пространств содержит имена сим-
волических ссылок, как они существуют в каталоге pg_tblspc/, и полный путь каждой символи-
ческой ссылки. Эти файлы не только к вашему сведению; их существование и содержание важны
для правильного проведения процесса восстановления системы.
Вы также можете создать резервную копию, когда сервер остановлен. В этом случае, вы, очевид-
но, не сможете вызвать pg_start_backup или pg_stop_backup, и следовательно, вам надо будет
самостоятельно как-то идентифицировать резервные копии и понимать, какие файлы WAL долж-
ны быть заархивированы. Поэтому обычно всё-таки лучше следовать вышеописанной процедуре
непрерывного архивирования.
25.3.4. Восстановление непрерывной архивной копии
Допустим, худшее случилось и вам необходимо восстановить базу данных из резервной копии.
Порядок действий таков:</li>
  <li>Остановите сервер баз данных, если он запущен.</li>
  <li>Если у вас есть место для этого, скопируйте весь текущий каталог кластера баз данных и все таб-
личные пространства во временный каталог на случай, если они вам понадобятся. Учтите, что
эта мера предосторожности требует, чтобы свободного места на диске было достаточно для раз-
мещения двух копий существующих данных. Если места недостаточно, необходимо сохранить
как минимум содержимое подкаталога pg_wal каталога кластера, так как он может содержать
журналы, не попавшие в архив перед остановкой системы.</li>
  <li>Удалите все существующие файлы и подкаталоги из каталога кластера и из корневых каталогов
используемых табличных пространств.</li>
  <li>Восстановите файлы базы данных из архивной копии файлов. Важно, чтобы у восстановленных
файлов были правильные разрешения и правильный владелец (пользователь, запускающий сер-
640Резервное копирова-
ние и восстановление
вер, а не root!). Если вы используете табличные пространства, убедитесь также, что символьные
ссылки в pg_tblspc/ восстановились корректно.</li>
  <li>Удалите все файлы из pg_wal/; они восстановились из резервной копии файлов и поэтому, скорее
всего, будут старее текущих. Если вы вовсе не архивировали pg_wal/, создайте этот каталог с
правильными правами доступа, но если это была символьная ссылка, восстановите её.</li>
  <li>Если на шаге 2 вы сохранили незаархивированные файлы с сегментами WAL, скопируйте их в
pg_wal/. (Лучше всего именно копировать, а не перемещать их, чтобы у вас остались неизме-
нённые файлы на случай, если возникнет проблема и всё придётся начинать сначала.)</li>
  <li>Создайте командный файл восстановления recovery.conf в каталоге кластера баз данных (см.
Главу 27). Вы можете также временно изменить pg_hba.conf, чтобы обычные пользователи не
могли подключаться, пока вы не будете уверены, что восстановление завершилось успешно.</li>
  <li>Запустите сервер. Сервер запустится в режиме восстановления и начнёт считывать необходи-
мые ему архивные файлы WAL. Если восстановление будет прервано из-за внешней ошибки,
сервер можно просто перезапустить и он продолжит восстановление. По завершении процесса
восстановления сервер переименует файл recovery.conf в recovery.done (чтобы предотвратить
повторный запуск режима восстановления), а затем перейдёт к обычной работе с базой данных.</li>
  <li>Просмотрите содержимое базы данных, чтобы убедиться, что вы вернули её к желаемому состо-
янию. Если это не так, вернитесь к шагу 1. Если всё хорошо, разрешите пользователям подклю-
чаться к серверу, восстановив обычный файл pg_hba.conf.
Ключевой момент этой процедуры заключается в создании файла конфигурации восстановления,
описывающего, как будет выполняться восстановление и до какой точки. В качестве прототипа вы
можете использовать файл recovery.conf.sample (он обычно помещается в каталог share/ после
установки). Единственное, что совершенно необходимо указать в recovery.conf — это команду
restore_command, которая говорит PostgreSQL, как получать из архива файл-сегменты WAL. Как и
archive_command, это командная строка для оболочки. Она может содержать символы %f, которые
заменятся именем требующегося файла журнала, и %p, которые заменятся целевым путём для
копирования этого файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога
кластера данных.) Если вам нужно включить в команду сам символ %, напишите %%. Простейшая
команда, которая может быть полезна, такая:
restore_command = ‘cp /mnt/server/archivedir/%f %p’
Эта команда копирует заархивированные ранее сегменты WAL из каталога /mnt/server/
archivedir. Разумеется, вы можете использовать что-то более сложное, возможно, даже скрипт
оболочки, который укажет оператору установить соответствующую ленту.
Важно, чтобы данная команда возвращала ненулевой код возврата в случае ошибки. Эта команда
будет вызываться и с запросом файлов, отсутствующих в архиве; в этом случае она должна вер-
нуть ненулевое значение и это считается штатной ситуацией. В исключительной ситуации, когда
команда была прервана сигналом (кроме SIGTERM, который применяется в процессе остановки
сервера базы данных) или произошла ошибка оболочки (например, команда не найдена), восста-
новление будет прервано и сервер не запустится.
Не все запрашиваемые файлы будут сегментами WAL; следует также ожидать запросов файлов с
суффиксом .history. Также учтите, что базовое имя пути %p будет отличаться от %f; не думайте,
что они взаимозаменяемы.
Сегменты WAL, которые не найдутся в архиве, система будет искать в pg_wal/; благодаря этому
можно использовать последние незаархивированные сегменты. Однако файлы в pg_wal/ будут ме-
нее предпочтительными, если такие сегменты окажутся в архиве.
Обычно при восстановлении обрабатываются все доступные сегменты WAL и, таким образом, база
данных восстанавливается до последнего момента времени (или максимально близкого к нему, в
зависимости от наличия сегментов WAL). Таким образом, восстановление обычно завершается с
сообщением «файл не найден»; точный текст сообщения об ошибке зависит от того, что делает
restore_command. Вы также можете увидеть сообщение об ошибке в начале восстановления для
641Резервное копирова-
ние и восстановление
файла с именем типа 00000001.history. Это также нормально и обычно не говорит о какой-либо
проблеме при восстановлении в простых ситуациях; подробнее об этом рассказывается в Подраз-
деле 25.3.5.
Если вы хотите восстановить базу на какой-то момент времени (скажем, до момента, когда неопыт-
ный администратор базы данных удалил основную таблицу транзакций), просто укажите требуе-
мую точку остановки в recovery.conf. Вы можете задать точку останова, так называемую «цель
восстановления», по дате/времени, именованной точке восстановления или определённому иден-
тификатору транзакции. На момент написания этой документации полезными могут быть только
указания даты/времени или имени точки восстановления, пока нет никаких средств, позволяющих
точно определить, какой идентификатор транзакции нужно выбрать.
Примечание
Точка останова должна указывать на момент после окончания базового копирования,
т. е. после времени завершения pg_stop_backup. Использовать базовую резервную ко-
пию для восстановления на момент времени, когда она ещё только создавалась, нель-
зя. (Чтобы восстановить данные на этот момент времени, придётся вернуться к преды-
дущей базовой резервной копии и накатывать изменения с этой позиции.)
Если при восстановлении обнаруживаются повреждённые данные WAL, восстановление прерыва-
ется в этом месте и сервер не запускается. В этом случае процесс восстановления можно пере-
запустить с начала, указав «цель восстановления» до точки повреждения, чтобы восстановление
могло завершиться нормально. Если восстановление завершается ошибкой из-за внешней причи-
ны, например, из-за краха системы или недоступности архива WAL, его можно просто перезапу-
стить, и оно продолжится с того места, где было прервано. Перезапуск восстановления реализован
по тому же принципу, что и контрольные точки при обычной работе: сервер периодически сохра-
няет всё текущее состояние на диске и отражает это в файле pg_control, чтобы уже обработанные
данные WAL не приходилось сканировать снова.
25.3.5. Линии времени
Возможность восстановить базу данных на некий предыдущий момент времени создаёт некоторые
сложности, сродни научно-фантастическим историям о путешествиях во времени и параллельных
мирах. Например, предположим, что в начальной истории базы данных вы удалили важную табли-
цу в 17:15 во вторник, но осознали эту ошибку только в среду в полдень. Вы можете спокойно взять
резервную копию, восстановить данные на 17:14 во вторник и запустить сервер. В этой истории
мира базы данных вы никогда не удаляли вышеупомянутую таблицу. Но предположим, что позже
вы заметили, что это была не такая уж хорошая идея и захотели вернуться к утру среды в перво-
начальной истории базы данных. Вы не сможете сделать это, если в процессе работы базы данных
она успеет перезаписать какие-либо файлы-сегменты WAL, приводящие к моменту времени, к ко-
торому вы хотите вернуться теперь. Таким образом, для получения желаемого результата необ-
ходимо как-то отличать последовательности записей WAL, добавленные после восстановления на
какой-то момент времени от тех, что существовали в начальной истории базы данных.
Для решения этой проблемы в PostgreSQL есть такое понятие, как линия времени. Всякий раз,
когда завершается восстановление из архива, создаётся новая линия времени, позволяющая иден-
тифицировать последовательность записей WAL, добавленных после этого восстановления. Номер
линии времени включается в имя файлов-сегментов WAL, так что файлы новой линии времени не
перезаписывают файлы WAL, сгенерированные предыдущими линиями времени. Фактически это
позволяет архивировать много различных линий времени. Хотя это может показаться бесполезной
возможностью, на самом деле она часто бывает спасительной. Представьте, что вы не определи-
лись, какую точку времени выбрать для восстановления, и таким образом должны проводить вос-
становление методом проб и ошибок, пока не найдёте лучший момент для ответвления от старой
истории. Без линий времени этот процесс быстро стал бы очень запутанным. А благодаря линиям
времени, вы можете вернуться к любому предыдущему состоянию, включая состояния в ветках
линий времени, покинутых ранее.
642Резервное копирова-
ние и восстановление
Каждый раз, когда образуется новая линия времени, PostgreSQL создаёт файл «истории линии
времени», показывающий, от какой линии времени ответвилась данная и когда. Эти файлы исто-
рии нужны, чтобы система могла выбрать правильные файлы-сегменты WAL при восстановлении
из архива, содержащего несколько линий времени. Таким образом, они помещаются в область ар-
хивов WAL так же, как и файлы сегментов WAL. Файлы истории представляют собой небольшие
текстовые файлы, так что они не занимают много места и их вполне можно сохранять неограни-
ченно долго (в отличие от файлов сегментов, имеющих большой размер). Если хотите, вы можете
добавлять в файл истории комментарии, свои собственные заметки о том, как и почему была со-
здана эта конкретная линия времени. Такие комментарии будут особенно ценны, если в результа-
те экспериментов у вас образуется хитросплетение разных линий времени.
По умолчанию при восстановлении восстанавливается та же линия времени, которая была теку-
щей при создании базовой резервной копии. Если вы хотите восстановить состояние на какой-либо
дочерней линии времени, (то есть, хотите вернуться к некоторому состоянию, которое тоже было
получено в результате попытки восстановления), вам необходимо указать идентификатор целевой
линии времени в recovery.conf. Восстановить состояние в линии времени, ответвившейся раньше,
чем была сделана базовая резервная копия, нельзя.
25.3.6. Советы и примеры
Ниже мы дадим несколько советов по настройке непрерывного архивирования.
25.3.6.1. Обособленные горячие резервные копии
Средства резервного копирования PostgreSQL можно применять для создания обособленных горя-
чих копий. Эти копии нельзя использовать для восстановления на момент времени, но создаются
и восстанавливаются они обычно гораздо быстрее, чем дампы pg_dump. (Они также намного боль-
ше, чем дампы pg_dump, так что в некоторых случаях выигрыш в скорости может быть потерян.)
Как и базовые резервные копии, обособленную горячую копию проще всего получить, используя
программу pg_basebackup. Если вы вызовете эту программу с параметром -X, в эту копию авто-
матически будет включён весь журнал предзаписи, необходимый для её использования, так что
никакие особые действия для восстановления не потребуются.
Если нужна дополнительная гибкость в процессе копирования файлов, создавать обособленные
горячие копии можно также на более низком уровне. Чтобы подготовиться к получению такой ко-
пии на низком уровне, установите в wal_level уровень replica (или выше), в archive_mode значе-
ние on и настройте команду archive_command, которая будет выполнять архивацию, только когда
существует файл-переключатель. Например:
archive_command = ‘test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/
pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)’
Данная команда выполнит архивацию, если будет существовать файл /var/lib/pgsql/
backup_in_progress, а в противном случае просто вернёт нулевой код возврата (и тогда PostgreSQL
сможет переработать ненужный файл WAL).
После такой подготовки резервную копию можно создать, например таким скриптом:
touch /var/lib/pgsql/backup_in_progress
psql -c “select pg_start_backup(‘hot_backup’);”
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c “select pg_stop_backup();”
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
Сначала создаётся файл-переключатель /var/lib/pgsql/backup_in_progress, включающий архи-
вирование заполненных файлов WAL. По окончании резервного копирования файл-переключатель
удаляется. Затем заархивированные файлы WAL тоже добавляются в резервную копию, так что в
одном архиве tar оказывается и базовая резервная копия, и все требуемые файлы WAL. Пожалуй-
ста, не забудьте добавить в ваши скрипты резервного копирования обработку ошибок.
643Резервное копирова-
ние и восстановление
25.3.6.2. Сжатие журналов в архиве
Если размер архива имеет большое значение, можно воспользоваться gzip и сжимать архивные
файлы:
archive_command = ‘gzip &lt; %p &gt; /var/lib/pgsql/archive/%f’
При этом для восстановления придётся использовать gunzip:
restore_command = ‘gunzip &lt; /mnt/server/archivedir/%f &gt; %p’
25.3.6.3. Скрипты archive_command
Многие в качестве команды archive_command
postgresql.conf оказывается очень простой:
используют
скрипты,
так
что
запись
в
archive_command = ‘local_backup_script.sh “%p” “%f”’
Применять отдельный файла скрипта целесообразно всегда, когда вы хотите использовать в про-
цедуре архивирования несколько команд. Это позволяет управлять сложностью этой процедуры в
рамках одного скрипта, который можно написать на любом популярном языке скриптов, например
на bash или perl.
В частности, с помощью скриптов можно решить такие задачи:
• Копирование данных в безопасное внешнее хранилище
• Пакетная обработка файлов WAL, чтобы они передавались каждые три часа, а не по одному
• Взаимодействие с другими приложениями резервного копирования и восстановления
• Взаимодействие со средствами мониторинга, регистрация ошибок
Подсказка
Когда в archive_command используется скрипт, желательно включить logging_collector.
Тогда все сообщения, которые скрипт выведет в stderr, будут записываться в журнал
сервера баз данных, что позволит легко диагностировать ошибки в сложных конфигу-
рациях.
25.3.7. Ограничения
На момент написания документации методика непрерывного архивирования имеет несколько
ограничений. Они могут быть ликвидированы в будущих версиях:
• Если во время создания базовой резервной копии выполняется команда CREATE DATABASE, а
затем база-шаблон, задействованная в CREATE DATABASE, изменяется, пока продолжается ко-
пирование, возможно, что при восстановлении эти изменения распространятся также и на со-
зданную базу данных. Конечно, это нежелательно. Во избежание подобных рисков, лучше все-
го не изменять никакие базы-шаблоны во время получения базовой резервной копии.
• Команды CREATE TABLESPACE записываются в WAL с абсолютным путём и, таким образом,
при воспроизведении WAL будут выполнены с тем же абсолютным путём. Это может быть
нежелательно, если журнал воспроизводится на другой машине. Но опасность есть, даже ес-
ли журнал воспроизводится на той же машине, но в другом каталоге данных: при воспроизве-
дении будет так же перезаписано содержимое исходных табличных пространств. Чтобы избе-
жать потенциальных проблем такого рода, лучше всего делать новую базовую резервную ко-
пию после создания или удаления табличных пространств.
Также следует заметить, что стандартный формат WAL не очень компактный, так как включает
много снимков дисковых страниц. Эти снимки страниц предназначены для поддержки восстанов-
ления после сбоя, на случай, если понадобится исправить страницы, записанные на диск частич-
но. В зависимости от аппаратного и программного обеспечения вашей системы, риск частичной
644Резервное копирова-
ние и восстановление
записи может быть достаточно мал, так что его можно игнорировать, и в этом случае можно суще-
ственно уменьшить общий объём архивируемых журналов, выключив снимки страниц с помощью
параметра full_page_writes. (Прежде чем делать это, прочтите замечания и предупреждения в Гла-
ве 30.) Выключение снимков страниц не препятствует использованию журналов для восстановле-
ния PITR. Одним из направлений разработки в будущем является сжатие архивируемых данных
WAL, путём удаления ненужных копий страниц даже при включённом режиме full_page_writes.
Тем временем администраторы могут сократить количество снимков страниц, включаемых в WAL,
увеличив параметры интервала контрольных точек в разумных пределах.
645</li>
</ol>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-025/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-025/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-025/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-024/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Script_Mount_FTP_Folder/" title="Монтируем папку FTP в файловую систему Bash  SCRIPT">Монтируем папку FTP в файловую систему Bash  SCRIPT</a></h3>
      <p>Bash Монтируем папку FTP в файловую систему Bash  SCRIPT: <a href="http://localhost:4000/Script_Mount_FTP_Folder/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Script_bash-copy-ftp/" title="Копируем на FTP скриптом bash">Копируем на FTP скриптом bash</a></h4>
        <span>Published on January 17, 2019</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Work-Project-Manager/" title="Коротко - работа менеджера проектов">Коротко - работа менеджера проектов</a></h4>
        <span>Published on December 04, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
