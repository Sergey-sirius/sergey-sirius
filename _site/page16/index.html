<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page16/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page16/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-033/" title="Глава 33. Регрессионные тесты"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 33. Регрессионные тесты"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-033/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~15 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-033/" rel="bookmark" title="Глава 33. Регрессионные тесты" itemprop="url">Глава 33. Регрессионные тесты</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 33. Регрессионные тесты</p>

<p>Регрессионные тесты представляют собой полный набор проверок реализации SQL в PostgreSQL.
Они тестируют как стандартные SQL-операции, так и расширенные возможности PostgreSQL
33.1. Выполнение тестов
Регрессионное тестирование можно выполнять как на уже установленном и работающем серве-
ре, так и используя временную инсталляцию внутри дерева сборки. Более того, существуют «па-
раллельный» и «последовательный » режимы тестирования. Последовательный метод выполняет
каждый сценарий теста отдельно, тогда как параллельный метод запускает несколько процессов
на сервере с тем, чтобы выполнить определённый набор тестов параллельно. Параллельное тести-
рование позволяет с уверенностью утверждать, что межпроцессное взаимодействие и блокировки
работают корректно.
33.1.1. Запуск тестов на временной инсталляции
Чтобы запустить параллельное регрессионное тестирование после сборки, но до инсталляции, на-
берите:
make check
в каталоге верхнего уровня. (Или, как вариант, вы можете перейти в src/test/regress и выполнить
команду там.) По завершении процесса вы должны увидеть нечто вроде:
=======================
All 115 tests passed.
=======================
или список тестов, не пройденных успешно. Прочитайте Раздел 33.2, прежде чем делать вывод о
серьёзности выявленных «проблем».
Поскольку данный метод тестирования выполняется на временном сервере, он не будет работать,
если вы выполняете сборку под пользователем root, сервер просто не запустится из под root. Ре-
комендуется не делать сборку под пользователем root, если только вы не собираетесь проводить
тестирование после завершения инсталляции.
Если вы сконфигурировали PostgreSQL для инсталляции в месте, где уже установлена предыдущая
версия PostgreSQL, и вы выполняете make check до инсталляции новой версии, вы можете столк-
нуться с тем, что тестирование завершится со сбоем, поскольку новая программа будет пытаться
использовать уже установленные общие библиотеки. (Типичные симптомы - жалобы на неопреде-
лённые символы.) Если вы хотите провести тестирование до перезаписи старой инсталляции, вам
необходимо проводить построение с configure –disable-rpath. Однако этот вариант не рекомен-
дуется для окончательной инсталляции.
Параллельное регрессионное тестирование запускает довольно много процессов под вашим име-
нем пользователя. В настоящее время возможный максимум параллельной обработки составляет
двадцать параллельных тестовых сценариев, а это означает сорок процессов: это и серверный про-
цесс, и psql процесс для каждого тестового сценария. Поэтому если ваша система устанавливает
ограничения на количество процессов для каждого пользователя, имеет смысл уточнить, что ваш
лимит составляет не меньше пятидесяти процессов или около того. В противном случае вы столк-
нетесь с кажущимися случайными сбоями в параллельном тестировании. Если же вы не имеете
права увеличить свой лимит процессов, вы можете снизить степень параллелизма установкой па-
раметра MAX_CONNECTIONS. Например:
make MAX_CONNECTIONS=10 check
выполняет не больше десяти тестов параллельно.
745Регрессионные тесты
33.1.2. Запуск тестов для существующей инсталляции
Чтобы запустить тестирование после инсталляции (см. Главу 16), инициализируйте кластер баз
данных и запустите сервер, как показано в Главе 18, потом введите:
make installcheck
или для параллельного тестирования:
make installcheck-parallel
Тестовые сценарии будут соединяться с сервером на локальном компьютере с номером порта по
умолчанию, если иное не задано переменными среды PGHOST и PGPORT. Тестирование будет прове-
дено в базе данных regression; любая существующая база с таким именем будет удалена.
Также тесты будут создавать случайные объекты общие для кластера, такие как роли и пользо-
ватели. Имена этих объектов будут начинаться с regress_. Опасайтесь использования режима
installcheck там, где пользователи или табличные пространства могут иметь такие имена.
33.1.3. Дополнительные пакеты тестов
Команды make check и make installcheck запускают только «основные» регрессионные тесты,
которые проверяют встроенную функциональность сервера PostgreSQL. Исходный дистрибутив
также содержит дополнительные возможности тестирования, большая часть которых имеет дело с
дополнительной функциональностью, такой, как, например, дополнительные процедурные языки.
Чтобы запустить пакет тестов (включая основные) применительно к модулям, выбранным для по-
строения, наберите одну из этих команд в каталоге верхнего уровня дерева сборки:
make check-world
make installcheck-world
Эти команды запускают тестирование используя временный сервер или уже установленный сер-
вер, в соответствии с данным выше описанием для команд make check и make installcheck.
Остальные детали соответствуют ранее изложенным объяснениям для каждого метода. Необхо-
димо иметь в виду, что команда make check-world выстраивает отдельное дерево временной ин-
сталляции для каждого тестируемого модуля, а это требует гораздо больше времени и дискового
пространства, нежели команда make installcheck-world.
В качестве альтернативного пути можно запустить индивидуальный набор тестов, набрав make
check или make installcheck в подходящем подкаталоге дерева сборки. Имейте в виду, что make
installcheck предполагает, что вы уже установили соответствующие модули, а не только основ-
ной сервер.
Дополнительные тесты, которые можно активизировать таким способом:
• Регрессионные тесты для дополнительных процедурных языков (отличных от PL/pgSQL, кото-
рый тестируется в рамках основного тестирования). Эти тесты расположены в каталоге src/
pl.
• Регрессионные тесты для модулей contrib, расположенные в каталоге contrib. Не для всех
модулей из contrib существуют тесты.
• Регрессионные тесты для библиотеки ECPG, расположенные в src/interfaces/ecpg/test.
• Тесты, для проверки работы одновременного доступа параллельными сессиями, расположен-
ные в src/test/isolation.
• Тесты клиентских программ из src/bin. См. также Раздел 33.4.
При использовании режима installcheck эти тесты удалят все существующие базы дан-
ных с именами pl_regression, contrib_regression, isolation_regression, ecpg1_regression,
ecpg2_regression, а также regression.
746Регрессионные тесты
Тесты TAP выполняются только когда PostgreSQL был сконфигурирован с ключом –enable-tap-
tests. Это рекомендуется для разработки, но если подходящей инсталляции Perl нет, этот ключ
можно опустить.
Некоторые комплекты не запускаются по умолчанию — одни потому, что выполнять их в много-
пользовательской системе небезопасно, а другие потому, что им требуется специальное программ-
ное обеспечение. Эти комплекты тестов можно включить дополнительно, присвоив переменной
PG_TEST_EXTRA (это может быть переменная окружения или скрипта make) строку с их списком
через пробел, например:
make check-world PG_TEST_EXTRA=’kerberos ldap ssl’
В настоящее время поддерживаются следующие значения:
kerberos
Запускает комплект тестов в подкаталоге src/test/kerberos. Эти тесты требуют наличия ин-
сталляции MIT Kerberos и открывают сокеты TCP/IP для приёма соединений.
ldap
Запускает комплект тестов в подкаталоге src/test/ldap. Эти тесты требуют наличия инстал-
ляции OpenLDAP и открывают сокеты TCP/IP для приёма соединений.
ssl
Запускает комплект тестов в подкаталоге src/test/ssl. Эти тесты открывают сокеты TCP/IP
для приёма соединений.
Тесты функциональности, которая не поддерживается в текущей конфигурации сборки, не запус-
каются, даже если они указаны в PG_TEST_EXTRA.
33.1.4. Локаль и кодировка
По умолчанию, тесты, работающие на временной инсталляции, используют локаль, определённую
в текущей среде и кодировку базы данных, заданную при выполнении initdb. Для тестирования
различных локалей может оказаться полезным установить подходящие переменные среды, напри-
мер:
make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=ru_RU.utf8
Поддержка переменной LC_ALL в этом случае не реализована; все остальные переменные среды,
относящиеся к локали, работают.
При тестировании на существующей инсталляции, локаль определяется имеющимся кластером
базы данных и не может быть изменена для выполнения теста.
Вы можете задать кодировку базы данных в переменной ENCODING, например:
make check LANG=C ENCODING=EUC_JP
Установка кодировки базы данных таким образом имеет смысл только для локали C; в противном
случае кодировка определяется автоматически из локали, и установка кодировки, не соответству-
ющей локали, приведёт к ошибке.
Кодировка базы данных может быть установлена как для тестирования на временной, так и на
существующей инсталляции, хотя в последнем случае она должна быть совместимой с локалью
этой инсталляции.
33.1.5. Специальные тесты
Пакет основных регрессионных тестов содержит несколько тестовых файлов, которые не запуска-
ются по умолчанию, поскольку они могут зависеть от платформы или выполняться слишком долго.
747Регрессионные тесты
Вы можете запустить те или иные дополнительные тесты, задав переменную EXTRA_TESTS. Напри-
мер, запустить тест numeric_big:
make check EXTRA_TESTS=numeric_big
Запустить тесты сортировки:
make check EXTRA_TESTS=’collate.icu.utf8 collate.linux.utf8’ LANG=en_US.utf8
Тест collate.linux.utf8 работает только на платформе Linux/glibc. Тест collate.icu.utf8 рабо-
тает только в сборках с поддержкой ICU. Оба теста будут выполнены успешно только в базе данных
с кодировкой UTF-8.
33.1.6. Тестирование сервера горячего резерва
Исходный дистрибутив также содержит регрессионные тесты для статического поведения серве-
ра горячего резерва. Для выполнения тестов требуется работающий ведущий сервер и работаю-
щий резервный, принимающий новые записи WAL от ведущего (с использованием либо трансля-
ции файлов журналов, либо потоковой репликации). Эти серверы не создаются автоматически,
также как и настройка репликации здесь не описана. Пожалуйста, сверьтесь с соответствующими
разделами документации.
Для запуска тестов сервера горячего резерва необходимо создать базу данных regression на ве-
дущем сервере:
psql -h primary -c “CREATE DATABASE regression”
Затем, на ведущем сервере в базе данных regression запустите предварительный скрипт src/test/
regress/sql/hs_primary_setup.sql Например:
psql -h primary -f src/test/regress/sql/hs_primary_setup.sql regression
Убедитесь, что эти изменения распространились на резервный сервер.
Теперь, для выполнения теста, настройте, чтобы подключение по умолчанию выполнялось к ре-
зервному серверу (например, задав переменные среды PGHOST и PGPORT). И, наконец, запустите
make standbycheck в каталоге регрессионных тестов:
cd src/test/regress
make standbycheck
Чтобы протестировать работу резервного сервера в некоторых экстремальных условиях, эти
условия можно получить на главном, воспользовавшись скриптом src/test/regress/sql/
hs_primary_extremes.sql.
33.2. Оценка результатов тестирования
Некоторые правильно установленные и полностью функциональные PostgreSQL инсталляции мо-
гут «давать сбой» при прохождении некоторых регрессионных тестов из-за особенностей, при-
сущих той или иной платформе, таких как различное представление чисел с плавающей запя-
той и формулировкой сообщений. В настоящее время результаты тестов оцениваются простым
diff сравнением с выводом, сделанным в эталонной системе, поэтому результаты чувствительны
к небольшим отличиям между системами. Когда тест завершается со «сбоем», всегда исследуйте
разницу между ожидаемым и полученным результатом; возможно, вы обнаружите, что разница
не столь уж существенна. Тем не менее, мы стремимся поддерживать эталонные файлы на всех
поддерживаемых платформах, чтобы можно было ожидать прохождения всех тестов.
Актуальные итоговые результаты регрессионного тестирования хранятся в каталоге src/test/
regress/results. Тестовый скрипт использует команду diff, чтобы сравнить каждый итоговый
файл с ожидаемыми результатами, которые хранятся в каталоге src/test/regress/expected. Все
различия сохраняются в src/test/regress/regression.diffs для последующей проверки. (Если
проводился тест не из основного пакета, то его результаты появятся в соответствующем подката-
логе, а не в src/test/regress.)
748Регрессионные тесты
Если вам не нравится используемая по умолчанию команда diff, установите переменную среды
PG_REGRESS_DIFF_OPTS, например PG_REGRESS_DIFF_OPTS=’-u’. (Или, если хотите, запустите diff
самостоятельно.)
Если по какой-то причине какая-то конкретная платформа генерирует «сбой» для отдельного те-
ста, но изучение его результата убеждает вас, что результат правильный, вы можете добавить но-
вый файл сравнения, чтобы замаскировать отчёт об ошибке для последующего прохождения теста.
За подробностями обратитесь к Разделу 33.3.
33.2.1. Различия в сообщениях об ошибке
Некоторые регрессионные тесты подставляют заведомо неверные входные значения. Сообщения
об ошибке могут выдаваться как PostgreSQL, так и самой операционной системой. В последнем
случае, форма сообщений может отличаться в зависимости от платформы, но отражают они одну
и ту же информацию. Вот эта разница в сообщениях и приводит к «сбоям» регрессионного теста,
которые можно устранить при проверке.
33.2.2. Разница локалей
Если вы проводите тестирование на сервере, который был установлен с локалью, имеющей поря-
док сопоставления, отличный от С, вы можете столкнуться с различиями в порядке сортировки
и, как следствие, с последующими сбоями. Пакет регрессионных тестов решает эту проблему пу-
тём наличия альтернативных файлов результата, которые способны справиться с большим коли-
чеством локалей.
Если вы используете метод тестирования на временной инсталляции, то чтобы запустить тестиро-
вание на другой локали, используйте подходящую переменную среды, относящуюся к локали, в
командной строке make, например:
make check LANG=de_DE.utf8
(Драйвер регрессионного теста обнуляет LC_ALL, поэтому выбор локали посредством данной пере-
менной не работает.) Чтобы не использовать локаль, либо обнулите все переменные среды, отно-
сящиеся к локали, либо установите их в C) или используйте следующую специальную команду:
make check NO_LOCALE=1
Когда тест проходит на существующей инсталляции, установки локали определяются этой инстал-
ляцией. Чтобы это изменить, инициализируйте кластер базы данных с иной локалью, передав со-
ответствующие параметры initdb.
В целом, рекомендуется по возможности проводить регрессионные тесты при таких установках
локали, которые будут использованы в работе, тогда в результате тестирования будут проверены
актуальные участки кода, относящиеся к локали и кодировке. В зависимости от окружения опера-
ционной системы, вы можете столкнуться со сбоями, но вы хотя бы будете знать, какого поведения
локали можно ожидать при работе с реальными приложениями.
33.2.3. Разница в дате и времени
Большая часть результатов проверки даты и времени зависит от часового пояса окружения. Эта-
лонные файлы созданы для пояса PST8PDT (Беркли, Калифорния), поэтому если проводить тесты
не с этим часовым поясом, проявятся мнимые ошибки. Драйвер регрессионного теста задаёт пе-
ременную среды PGTZ как PST8PDT, что позволяет получить корректный результат.
33.2.4. Разница в числах с плавающей запятой
Некоторые тесты применяют 64-битное вычисление чисел с плавающей запятой (double
precision) из столбцов таблицы. Наблюдаются различия в результатах при использовании мате-
матических функций для столбцов double precision. Тесты float8 и geometry особенно чувстви-
тельны к небольшим различиям между платформами и даже режимами оптимизации компиля-
тора. Чтобы понять реальную значимость этих различий, нужно сравнить их глазами, поскольку
обычно они располагаются с десятого разряда справа от десятичной точки.
749Регрессионные тесты
Некоторые системы показывают минус ноль как -0, тогда как другие показывают просто 0.
Некоторые системы сигнализируют об ошибках в pow() и exp() не так, как ожидает текущий код
PostgreSQL.
33.2.5. Разница в сортировке строк
Иногда наблюдаются различия в том, что одни и те же строки выводятся в ином порядке, неже-
ли в контрольном файле. В большинстве случаев это не является, строго говоря, ошибкой. Основ-
ная часть скриптов регрессионных тестов не столь педантична, чтобы использовать ORDER BY для
каждого SELECT, и поэтому в результате порядок строк не гарантирован согласно спецификации
SQL. На практике мы видим, как одинаковые запросы, выполняемые для одних и тех же данных
на одном и том же программном обеспечении, выдают результаты в одинаковом порядке для всех
платформ, в связи с чем отсутствие ORDER BY не является проблемой. Однако некоторые запросы
выявляют межплатформенные различия в сортировке. Когда тестирование идет на уже установ-
ленном сервере, различия в сортировке могут быть следствием того, что локаль установлена в от-
личное от С значение, или некоторые параметры заданы не по умолчанию, такие как work_mem
или стоимостные параметры планировщика.
Поэтому, если вы видите различия в сортировке строк, не стоит волноваться, если только запрос
не использует ORDER BY. Тем не менее, сообщайте нам о таких случаях, чтобы мы могли добавить
ORDER BY в конкретный запрос, чтобы исключить возможность ошибки в будущих релизах.
Вы можете задать вопрос, почему мы явно не добавили ORDER BY во все запросы регрессионных
тестов, чтобы избавиться от таких ошибок раз и навсегда. Причина в том, что это снизит полез-
ность регрессионных тестов, поскольку они будут иметь тенденцию к проверке планов запросов
использующих сортировку, за счёт исключения запросов без сортировки.
33.2.6. Недостаточная глубина стека
Если ошибки
теста приводят к поломке сервера при выполнении команды select
infinite_recurse(), это означает, что предел платформы для размера стека меньше, чем показы-
вает параметр max_stack_depth. Проблема может быть решена запуском сервера с большим разме-
ром стека (рекомендованное значение max_stack_depth по умолчанию - 4 Мб). Если вы не можете
этого сделать, в качестве альтернативы уменьшите значение max_stack_depth.
На платформах, поддерживающих функцию getrlimit(), сервер должен автоматически выбирать
значение переменной max_stack_depth; поэтому, если вы не переписывали это значение вручную,
сбой такого типа — просто дефект, который нужно зарегистрировать.
33.2.7. Тест «случайных значений»
Тестовый скрипт random подразумевает получение случайных значений. В очень редких случаях
это приводит к сбоям в регрессионном тестировании. Выполнение
diff results/random.out expected/random.out
должно выводить одну или несколько строк различий. Нет причин для беспокойства, до тех пор
пока сбои в этом тесте не повторяются постоянно.
33.2.8. Параметры конфигурации
Когда тестирование проходит на существующей инсталляции, некоторые нестандартные значения
параметров могут привести к сбоям в тесте. Например, изменение таких параметров конфигура-
ции, как enable_seqscan или enable_indexscan могут привести к такому изменению системы, ко-
торое сможет воздействовать на результаты тестов, использующих EXPLAIN.
33.3. Вариативные сравнительные файлы
Поскольку некоторые тесты по сути выдают результаты, зависящие от окружения, мы предлагаем
несколько вариантов «ожидаемых» файлов результата. Каждый регрессионный тест может иметь
750Регрессионные тесты
несколько сравнительных файлов, показывающих возможные результаты на разных платформах.
Существует два независимых механизма для определения, какой именно сравнительный файл бу-
дет выбран для каждого теста.
Первый механизм позволяет выбирать сравнительный файл для конкретной платформы. Есть файл
сопоставления src/test/regress/resultmap, в котором определяется, какой сравнительный файл
выбирать для каждой платформы. Чтобы устранить ложные «сбои» тестирования для конкретной
платформы, для начала вы должны выбрать или создать вариант сравнительного файла, а потом
добавить строку в файл resultmap.
Каждая строка в файле сопоставления выглядит как
testname:output:platformpattern=comparisonfilename
Имя теста (testname) здесь - просто название конкретного модуля регрессионного теста. Значе-
ние output показывает, вывод какого файла проверять. Для стандартного регрессионного теста
это всегда out. Значение соответствует расширению выходного файла. platformpattern представ-
ляет собой шаблон в стиле Unix-утилиты expr (т. е. регулярное выражение с неявным ^ якорем
в начале). Этот шаблон сравнивается с именем платформы, которое выводится из config.guess.
comparisonfilename это имя сравнительного файла, который будет использован.
Например: некоторые системы интерпретируют очень маленькие числа с плавающей запятой как
ноль, а не как ошибку потери значимости. Это приводит к разночтениям в регрессионных тестах
для float8. Поэтому мы предлагаем вариант сравнительного файла float8-small-is-zero.out,
который включает в себя результат, ожидаемый для таких систем. Чтобы замаскировать сообще-
ние о ложном «сбое» на платформе OpenBSD, файл resultmap включает в себя:
float8:out:i.86-.<em>-openbsd=float8-small-is-zero.out
который сработает на любой машине, где выходное значение config.guess соответствует i.86-.</em>-
openbsd. Другие строки в resultmap выбирают вариант сравнительного файла для других плат-
форм, если это целесообразно.
Второй механизм выбора более автоматический: он просто выбирает «подходящую пару» из
нескольких предлагаемых сравнительных файлов. Драйвер скрипта регрессионного теста рас-
сматривает стандартный сравнительный файл для теста, testname.out, вариативный файл
testname_digit.out (где digit любое одиночное число от 0 до 9). Если какой-нибудь из этих фай-
лов полностью совпадает, тест считается пройденным. В противном случае, для отчёта об ошибке
выбирается файл с наименьшим различием. (Если resultmap включает вводные для конкретного
теста, то в этом случае testname подменное имя, взятое из файла resultmap.)
Например, для теста char сравнительный файл char.out содержит результаты, ожидаемые для
локалей C и POSIX, тогда как файл char_1.out содержит результаты, характерные для многих дру-
гих локалей.
Механизм “лучшей пары” был разработан, чтобы справляться с результатами, зависящими от ло-
кали, но он может применяться в любой ситуации, когда сложно предсказать результаты, исходя
только из названия платформы. Ограниченность этого метода проявляется лишь в том, что драй-
вер теста не может сказать, какой вариант правилен для данного окружения; просто выбирает-
ся вариант, который кажется наиболее подходящим. Поэтому безопаснее всего использовать этот
метод только для вариативных результатов, которые вы хотели бы видеть одинаково надёжными
для любого контекста.
33.4. Тесты TAP
Различные тесты, особенно тесты клиентских программ в src/bin, используют инструменты Perl
TAP и запускаются программой тестирования Perl prove. Вы можете передать аргументы команд-
ной строки команде prove, установив для make переменную PROVE_FLAGS, например:
make -C src/bin check PROVE_FLAGS=’–timer’
За дополнительными сведениями обратитесь к странице руководства по prove.
751Регрессионные тесты
В переменной PROVE_TESTS, которую воспринимает make, может быть указан список разделённых
пробелами путей, заданных относительно расположения Makefile, вызывающего prove. Этот спи-
сок определяет подмножество тестов для выполнения, вместо всех по умолчанию (t/*.pl). Напри-
мер:
make check PROVE_TESTS=’t/001_test1.pl t/003_test3.pl’
Тесты на базе TAP требуют модуля Perl IPC::Run. Этот модуль доступен из CPAN или операционной
системы.
33.5. Проверка покрытия теста
Исходный код PostgreSQL может быть скомпилирован с инструментарием для теста покрытия, так
что можно проверить, какие части кода покрывает регрессионное тестирование или любое другое
тестирование, запускаемое относительно кода. В настоящее время эта возможность поддержива-
ется в сочетании с компиляцией с GCC и требует наличия gcov и lcov программ.
Типичный рабочий процесс выглядит так:
./configure –enable-coverage … OTHER OPTIONS …
make
make check # или другой комплект тестов
make coverage-html
Затем откройте в своём HTML-браузере страницу coverage/index.html. Команды make работают
и в подкаталогах.
Если у вас нет программы lcov или вы предпочитаете HTML-отчёту текстовый формат, вы можете
также выполнить
make coverage
вместо make coverage-html и получить выходные файлы .gcov для каждого исходного файла, от-
носящегося к тесту. (Команды make coverage и make coverage-html перезаписывают файлы друг
друга, поэтому при одновременном их использовании может возникнуть путаница.)
Чтобы обнулить подсчёт выполнений между тестами, запустите:
make coverage-clean</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-032/" title="Глава 32. JIT-компиляция"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 32. JIT-компиляция"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-032/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~4 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-032/" rel="bookmark" title="Глава 32. JIT-компиляция" itemprop="url">Глава 32. JIT-компиляция</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 32. JIT-компиляция</p>

<p>В этой главе рассказывается о том, что такое JIT-компиляция, и как можно настроить её в
PostgreSQL.
32.1. Что такое JIT-компиляция?
JIT-компиляция (Just-In-Time compilation, Компиляция «точно в срок») — это производимая во вре-
мя выполнения процедура преобразования интерпретируемого варианта исполнения программы
в программу на языке процессора. Например, вместо использования универсального кода, способ-
ного вычислять произвольные SQL-выражения, для вычисления конкретного условия WHERE a.col
= 3 можно сгенерировать функцию, предназначенную именно для этого выражения, которую смо-
жет выполнять непосредственно процессор, так что она будет выполняться быстрее.
PostgreSQL поддерживает JIT-компиляцию с использованием LLVM, если сборка PostgreSQL про-
изводится с ключом –with-llvm.
Дополнительные подробности можно найти в файле src/backend/jit/README.
32.1.1. Операции, ускоряемые с применением JIT
В настоящее время реализация JIT в PostgreSQL поддерживает ускорение вычисления выражений
и преобразования кортежей. В будущем могут быть ускорены и некоторые другие операции.
Вычисление выражений производится при обработке предложений WHERE, целевых списков, агре-
гатов и проекций. Оно может быть ускорено в результате генерирования кода, предназначенного
для каждого конкретного случая.
Преобразование кортежей — процедура перевода кортежа с диска (см. Подраздел 68.6.1) в развёр-
нутое представление в памяти. Его можно ускорить, создав функции, предназначенные для опре-
делённой структуры таблицы и количества извлекаемых столбцов.
32.1.2. Встраивание
СУБД PostgreSQL очень гибка и позволяет определять новые типы данных, функции, операторы и
другие объекты базы данных; см. Главу 38. В действительности встроенные объекты реализуются
практически теми же механизмами. С этой гибкостью связаны некоторые издержки, например,
сопутствующие вызовам функций (см. Раздел 38.3). Для сокращения этих издержек JIT-компиля-
ция может встраивать тела маленьких функций в код выражений, использующих их. Это позволяет
соптимизировать значительный процент подобных издержек.
32.1.3. Оптимизация
В LLVM поддерживается оптимизация сгенерированного кода. Некоторые оптимизации обходятся
достаточно дёшево и могут выполняться при использовании JIT в любом случае, тогда как другие
оправданы только при длительных запросах. Подробнее об оптимизации рассказывается в https://
llvm.org/docs/Passes.html#transform-passes.
32.2. Когда применять JIT?
JIT-компиляция имеет смысл в первую очередь для длительных запросов, нагружающих процессор.
Например, такой характер обычно имеют аналитические запросы. Для быстрых запросов наклад-
ные расходы, связанные с выполнением JIT-компиляции, часто будут превышать выигрыш от их
ускорения.
Решение об использовании JIT-компиляции принимается на основании общей стоимости запроса
(см. Главу 70 и Подраздел 19.7.2). Стоимость запроса сравнивается со значением jit_above_cost,
и если она оказывается больше, производится JIT-компиляция. Затем принимаются ещё два реше-
742JIT-компиляция
ния. Во-первых, если его стоимость превышает и значение jit_inline_above_cost, тела небольших
функций и операторов, фигурирующих в запросе, будут встраиваться в вызывающий код. Во-вто-
рых, если стоимость запроса превышает значение jit_optimize_above_cost, при генерации кода за-
действуются дорогостоящие оптимизации для улучшения сгенерированного кода. Обе эти опера-
ции увеличивают накладные расходы JIT, но могут значительно сократить время выполнения за-
проса.
Эти решения принимаются на основе стоимости во время планирования, а не исполнения запроса.
Это означает, что в случае использования подготовленных операторов и общего плана (см. Раздел
«Замечания») принятие решений зависит от параметров конфигурации, действующих во время
подготовки запроса, а не во время выполнения.
Примечание
Если параметр jit имеет значение off или сервер не поддерживает JIT (например, по-
тому что он был скомпилирован без –with-llvm), JIT-компиляция выполняться не бу-
дет, даже если она была бы выгодна, исходя из описанных выше критериев. Присво-
енное параметру jit значение off учитывается и во время планирования, и во время
выполнения запросов.
EXPLAIN позволяет определить, используется ли JIT-компиляция. Например, так выглядит запрос,
не использующий JIT:
=# EXPLAIN ANALYZE SELECT SUM(relpages) FROM pg_class;
QUERY PLAN
——————————————————————————————–
Aggregate (cost=16.27..16.29 rows=1 width=8) (actual time=0.303..0.303 rows=1
loops=1)
-&gt; Seq Scan on pg_class (cost=0.00..15.42 rows=342 width=4) (actual
time=0.017..0.111 rows=356 loops=1)
Planning Time: 0.116 ms
Execution Time: 0.365 ms
(4 rows)
Учитывая стоимость планирования, отказ от использования JIT вполне обоснован, так как стои-
мость JIT-компиляции оказалась бы больше, чем выигрыш от оптимизации. Если уменьшить огра-
ничение стоимости, JIT будет использоваться:
=# SET jit_above_cost = 10;
SET
=# EXPLAIN ANALYZE SELECT SUM(relpages) FROM pg_class;
QUERY PLAN
——————————————————————————————–
Aggregate (cost=16.27..16.29 rows=1 width=8) (actual time=6.049..6.049 rows=1
loops=1)
-&gt; Seq Scan on pg_class (cost=0.00..15.42 rows=342 width=4) (actual
time=0.019..0.052 rows=356 loops=1)
Planning Time: 0.133 ms
JIT:
Functions: 3
Options: Inlining false, Optimization false, Expressions true, Deforming true
Timing: Generation 1.259 ms, Inlining 0.000 ms, Optimization 0.797 ms, Emission
5.048 ms, Total 7.104 ms
Execution Time: 7.416 ms
В данном случае видно, что JIT используется, но встраивание (Inlining) и дорогостоящие оптими-
зации (Optimization) не выполнялись. Чтобы их включить, помимо jit_above_cost нужно было также
уменьшить jit_inline_above_cost и jit_optimize_above_cost.
743JIT-компиляция
32.3. Конфигурация
Переменная конфигурации jit определяет, возможно ли использование JIT-компиляции. Если она
включена, переменные jit_above_cost, jit_inline_above_cost и jit_optimize_above_cost определяют, бу-
дет ли выполняться JIT-компиляция для запросов, и насколько ресурсоёмкой она может быть.
Параметр jit_provider определяет, какая реализация JIT-компиляции должна использоваться. Из-
менять его может потребоваться лишь в редких случаях. См. Подраздел 32.4.2.
Для целей отладки и разработки предназначен ряд дополнительных параметров конфигурации,
описанных в Разделе 19.17.
32.4. Расширяемость
32.4.1. Поддержка встраивания кода для расширений
Механизм JIT в PostgreSQL может встраивать в код реализации функций (типа C и internal), а
также операторов, использующих эти функции. Чтобы это встраивание выполнялось для функций
в расширениях, должно быть доступно определение этих функций. При сборке с использованием
PGXS расширения для сервера, скомпилированного с JIT-поддержкой LLVM, соответствующие фай-
лы будут собираться и устанавливаться автоматически.
Соответствующие файлы должны устанавливаться в $pkglibdir/bitcode/$extension/, а информа-
ция о них должна вноситься в $pkglibdir/bitcode/$extension.index.bc, где $pkglibdir — ката-
лог, который выдаёт команда pg_config –pkglibdir, а $extension — базовое имя разделяемой
библиотеки данного расширения.
Примечание
Для функций, встроенных в PostgreSQL, двоичный код устанавливается в $pkglibdir/
bitcode/postgres.
32.4.2. Подключаемые провайдеры JIT
PostgreSQL предоставляет реализацию JIT на базе LLVM. Интерфейс JIT предусматривает динами-
ческое подключение провайдера и позволяет менять провайдер без перекомпиляции (хотя в на-
стоящее время при сборке предоставляется поддержка встраивания только для LLVM). Провайдер
выбирается параметром jit_provider.
32.4.2.1. Интерфейс провайдера JIT
Провайдер JIT загружается путём динамической загрузки заданной разделяемой библиотеки. Для
поиска её используется обычный путь поиска библиотек. Чтобы предоставить требуемые функ-
ции-обработчики провайдера JIT и показать, что библиотека является реализацией провайдера JIT,
она должна содержать функцию, имеющую в C имя _PG_jit_provider_init. Этой функции пере-
даётся структура, которую нужно заполнить указателями на функции-обработчики определённых
действий.
struct JitProviderCallbacks
{
JitProviderResetAfterErrorCB reset_after_error;
JitProviderReleaseContextCB release_context;
JitProviderCompileExprCB compile_expr;
};
extern void _PG_jit_provider_init(JitProviderCallbacks *cb);
744</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-031/" title="Глава 31. Логическая репликация"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 31. Логическая репликация"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-031/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~12 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-031/" rel="bookmark" title="Глава 31. Логическая репликация" itemprop="url">Глава 31. Логическая репликация</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 31. Логическая репликация</p>

<p>Логическая репликация — это метод репликации объектов данных и изменений в них, использу-
ющий репликационные идентификаторы (обычно это первичный ключ). Мы называем такую ре-
пликацию «логической», в отличие от физической, которая построена на точных адресах блоков
и побайтовом копировании. PostgreSQL поддерживает оба механизма одновременно; см. Главу 26.
Логическая репликация позволяет более детально управлять репликацией данных и аспектами
безопасности.
В логической репликации используется модель публикаций/подписок с одним или несколькими
подписчиками, которые подписываются на одну или несколько публикаций на публикующем узле.
Подписчики получают данные из публикаций, на которые они подписаны, и могут затем повторно
опубликовать данные для организации каскадной репликации или более сложных конфигураций.
Логическая репликация таблицы обычно начинается с создания снимка данных в публикуемой
базе данных и копирования её подписчику. После этого изменения на стороне публикации пере-
даются подписчику в реальном времени, когда они происходят. Подписчик применяет изменения
в том же порядке, что и узел публикации, так что для публикаций в рамках одной подписки гаран-
тируется транзакционная целостность. Этот метод репликации данных иногда называется тран-
закционной репликацией.
Типичные сценарии использования логической репликации:
• Передача подписчикам инкрементальных изменений в одной базе данных или подмножестве
базы данных, когда они происходят.
• Срабатывание триггеров для отдельных изменений, когда их получает подписчик.
• Объединение нескольких баз данных в одну (например, для целей анализа).
• Репликация между разными основными версиями PostgreSQL.
• Репликация между экземплярами PostgreSQL на разных платформах (например, с Linux на
Windows)
• Предоставление доступа к реплицированным данным другим группам пользователей.
• Разделение подмножества базы данных между несколькими базами данных.
База данных подписчика функционирует так же, как и любой другой экземпляр базы PostgreSQL,
и может стать публикующей, если создать публикации в ней. Когда подписчик действует как ис-
ключительно читающее приложение, никаких конфликтов с одной подпиской не будет. Но они мо-
гут возникнуть, если в тот же набор таблиц производят запись какие-либо приложения или другие
подписчики.
31.1. Публикация
Публикация может быть определена на любом ведущем сервере физической репликации. Сервер,
на котором определяется публикация, называется публикующим. Публикация — это набор изме-
нений, выделяемых в таблице или в группе таблиц (он также может называться набором реплика-
ции). Публикация существует только в одной базе данных.
Публикации отличаются от схем и они никак не влияют на доступ к таблице. Если требуется, каж-
дую таблицу можно включить в несколько публикаций. В настоящее время публикации могут со-
держать только таблицы. Объекты в них нужно добавлять явным образом, если только публикация
не создана для всех таблиц (с указанием ALL TABLES).
Публикации могут ограничивать набор публикуемых изменений, выбирая любое сочетание опе-
раций из INSERT, UPDATE, DELETE и TRUNCATE, подобно тому как для разных типов событий могут
срабатывать триггеры. По умолчанию реплицируются все типы операций.
736Логическая репликация
Чтобы можно было реплицировать операции UPDATE и DELETE, в публикуемой таблице должен быть
настроен «репликационный идентификатор» для нахождения соответствующих строк для измене-
ния или удаления на стороне подписчика. По умолчанию это первичный ключ, если он создан.
Также репликационным идентификатором можно назначить другой уникальный индекс (с неко-
торыми дополнительными условиями). Если в таблице нет подходящего ключа, в качестве репли-
кационного идентификатора можно задать «full», что будет означать, что ключом будет вся стро-
ка. Это, однако, очень неэффективно и должно применяться как крайняя мера, если другого ре-
шения нет. Если на стороне публикации выбран репликационный идентификатор, отличный от
«full», то идентификатор, состоящий из того же или меньшего количества столбцов, также должен
быть определён на стороне подписчика. Подробнее о назначении репликационного идентифика-
тора рассказывается в REPLICA IDENTITY. Если в публикацию, в которой реплицируются операции
UPDATE и DELETE, добавляется таблица без репликационного идентификатора, то последующие ко-
манды UPDATE и DELETE на стороне публикации вызовут ошибку. Команды INSERT могут выполнять-
ся вне зависимости от такого идентификатора.
У каждой публикации может быть множество подписчиков.
Публикация создаётся командой CREATE PUBLICATION и может быть впоследствии изменена или
удалена с помощью соответствующих команд.
В публикации можно динамически добавлять или удалять отдельные таблицы, используя команду
ALTER PUBLICATION. Операции ADD TABLE и DROP TABLE являются транзакционными, так что ре-
пликация таблицы будет начата или закончена с определённым снимком только после фиксации
транзакции.
31.2. Подписка
Подписка — это принимающая сторона логической репликации. Узел, на котором определяется
подписка, называется подписчиком. В свойствах подписки определяется подключение к другой
базе данных и набор публикаций (из одной или нескольких), на которые подписчик хочет подпи-
саться.
База данных подписчика работает так же, как и экземпляр любой другой базы PostgreSQL, и может
быть публикующей для других баз, если в ней определены собственные подписки.
Узел подписчика может подписываться на несколько подписок, если требуется. В одной паре пуб-
ликующий сервер/подписчик могут быть определены несколько подписок, но при этом нужно по-
заботиться о том, чтобы публикуемые объекты в разных подписках не перекрывались.
Изменения в каждой подписке будут приходить через один слот репликации (см. Подраз-
дел 26.2.6). Дополнительные слоты репликации могут потребоваться для начальной синхрониза-
ции уже существующих данных таблиц.
Подписка логической репликации может представлять собой ведомый узел для синхронной ре-
пликации (см. Подраздел 26.2.8). В этом случае именем ведомого узла по умолчанию будет имя
подписки. Другое имя можно задать в свойстве application_name в строке подключения для дан-
ной подписки.
Подписки могут быть выгружены командой pg_dump, если её выполняет суперпользователь. В про-
тивном случае выдаётся предупреждение и подписки пропускаются, так как обычным пользова-
телям не разрешено читать всю информацию о подписках из каталога pg_subscription.
Подписки добавляются командой CREATE SUBSCRIPTION и могут быть остановлены/возобнов-
лены в любой момент командой ALTER SUBSCRIPTION, а также удалены командой DROP
SUBSCRIPTION.
Когда подписка удаляется и пересоздаётся, информация о синхронизации теряется. Это означает,
что после этого данные необходимо синхронизировать заново.
737Логическая репликация
Определения схемы не реплицируются, а публикуемые таблицы должны существовать в базе под-
писчика. Объектами репликации могут быть только обычные таблицы. Так, например, нельзя про-
извести репликацию в представление.
Таблицы публикации сопоставляются с таблицами подписчика по полностью заданным именам
таблиц. Репликация в таблицы с другими именами на стороне подписчика не поддерживается.
Столбцы таблиц также сопоставляются по именам. Другой порядок столбцов в целевой таблице
допускается, но типы столбцов должны совпадать. Целевая таблица может содержать дополни-
тельные столбцы, отсутствующие в публикуемой таблице. Они будут заполнены установленными
для них значениями по умолчанию.
31.2.1. Управление слотами репликации
Как было сказано ранее, каждая (активная) подписка получает изменения из слота репликации
на удалённой стороне (стороне публикации). Обычно удалённый слот репликации создаётся ав-
томатически, когда подписка создаётся командой CREATE SUBSCRIPTION, и удаляется автоматиче-
ски, когда она удаляется командой DROP SUBSCRIPTION. Однако в некоторых ситуациях может быть
полезно или необходимо манипулировать подпиской и нижележащим слотом по отдельности. На-
пример, возможны такие сценарии:
• При создании подписки слот репликации может уже существовать. В этом случае подписку
можно создать с параметром create_slot = false, чтобы она была связана с существующим
слотом.
• Про создании подписки удалённый узел может быть недоступен или находиться в нерабочем
состоянии. В этом случае подписку можно создать с указанием connect = false. При этом
подключение к удалённому узлу не будет устанавливаться. Этот вариант использует pg_dump.
Чтобы активировать такую подписку впоследствии, удалённый слот репликации нужно будет
создать вручную.
• При ликвидации публикации может потребоваться сохранить слот репликации. Например,
это полезно, когда нужно перенести базу данных подписчика на другой узел и активиро-
вать её там. В этом случае разорвите связь подписки со слотом, используя команду ALTER
SUBSCRIPTION, прежде чем удалять подписку.
• При ликвидации подписки удалённый узел может быть недоступен. В этом случае разорви-
те связь подписки со слотом, используя команду ALTER SUBSCRIPTION, прежде чем пытаться
удалять подписку. Если удалённый экземпляр базы данных прекратил существование, больше
никакие действия не требуются. Если же экземпляр удалённой базы данных просто оказался
недоступным, слот репликации нужно будет удалить вручную; в противном случае публикую-
щий сервер продолжит сохранять WAL и может в конце концов заполнить всё место на диске.
Такие случаи заслуживают самого серьёзного разбирательства.
31.3. Конфликты
Логическая репликация работает подобно обычным операциям DML в том смысле, что данные
будут изменены, даже если они независимо изменялись на стороне подписчика. Если входящие
данные нарушат какие-либо ограничения, репликация остановится. Эта ситуация называется кон-
фликтом. При репликации операций UPDATE или DELETE отсутствие данных не вызывает конфлик-
та, так что такие операции просто пропускаются.
В случае конфликта выдаётся ошибка и репликация останавливается; разрешить возникшую про-
блему пользователь должен вручную. Подробности конфликта можно найти в журнале серве-
ра-подписчика.
Разрешение может заключаться либо в изменении данных на стороне подписчика, что-
бы они не конфликтовали с приходящим изменением, либо в пропуске транзакции, кон-
фликтующей с существующими данными. Пропустить транзакцию можно, вызвав функцию
pg_replication_origin_advance(), которой передаётся в node_name соответствующее имя подпис-
738Логическая репликация
ки, а также позиция. Текущие позиции источников можно увидеть в системном представлении
pg_replication_origin_status.
31.4. Ограничения
Логическая репликация в настоящее время имеет ограничения и недостатки, описанные ниже.
Они могут быть устранены в будущих выпусках.
• Схема базы данных и команды DDL не реплицируются. Изначальную схему можно скопиро-
вать, воспользовавшись командой pg_dump –schema-only. Последующие изменения схемы
необходимо будет синхронизировать вручную. (Заметьте, однако, что схемы не обязательно
должны быть абсолютно идентичными на обеих сторонах репликации.) Если определения схе-
мы в исходной базе данных меняются, логическая репликация работает надёжно — когда дан-
ные после изменения схемы прибывают на сторону подписчика, но не вписываются в схему
его таблиц, выдаётся ошибка, требующая обновления схемы. Во многих случаях возникнове-
ние таких ошибок можно предупредить, сначала применяя дополняющие изменения на под-
писчике.
• Данные последовательностей не реплицируются. Данные в столбцах serial или столбцах иден-
тификации, выдаваемые последовательностями, конечно, будут реплицированы в составе таб-
лицы, но сама последовательность на подписчике будет сохранять стартовое значение. Ес-
ли подписчик используется в качестве базы только для чтения, обычно это не является про-
блемой. Если же, однако, предусматривается возможность переключения на базу подписчика
некоторым образом, текущие значения в этих последовательностях нужно будет обновить, ли-
бо скопировав текущие данные из базы публикации (вероятно, с применением pg_dump), либо
выбрав достаточно большие значения из самих таблиц.
• Репликация команд TRUNCATE поддерживается, но опустошение групп таблиц, соединённых
внешними ключами, стоит выполнять с осторожностью. При репликации действия TRUNCATE
подписчик опустошит ту же группу таблиц, которая была опустошена на публикующем сер-
вере (явным образом или в результате CASCADE), исключая таблицы, не входящие в подписку.
Данная операция завершится корректно, если все затронутые таблицы включены в одну и ту
же подписку. Если же некоторые таблицы, подлежащие опустошению на подписчике, связа-
ны по внешнему ключу с таблицами, не входящими в данную подписку, операция опустоше-
ния на сервере-подписчике завершится ошибкой.
• Большие объекты (см. Главу 35) не реплицируются. Это ограничение нельзя обойти никак,
кроме как хранить данные в обычных таблицах.
• Реплицировать данные возможно только из базовых таблиц в базовые таблицы. То есть табли-
цы на стороне публикации и на стороне подписки должны быть обычными, а не представлени-
ями, мат. представлениями, секционированными или сторонними таблицами. Это означает,
что вы можете реплицировать секции одну в одну, но реплицировать данные в таблицы, сек-
ционированные по-другому, нельзя. При попытке реплицировать таблицы, отличные от базо-
вых, будет выдана ошибка.
31.5. Архитектура
Логическая репликация начинается с копирования снимка данных в базе данных публикации. По
завершении этой операции изменения на стороне публикации передаются подписчику в реальном
времени, когда они происходят. Подписчик применяет изменения в том же порядке, в каком они
вносятся на узле публикации, так что для публикаций в рамках одной подписки гарантируется
транзакционная целостность.
Логическая репликация построена по схеме, подобной физической потоковой репликации (см.
Подраздел 26.2.5). Она реализуется процессами «walsender» (передачи WAL) и «apply» (примене-
ния). Процесс walsender запускает логическое декодирование (описанное в Главе 49) WAL и за-
гружает стандартный модуль логического декодирования (pgoutput). Этот модуль преобразует из-
менения, считываемые из WAL, в протокол логической репликации (см. Раздел 53.5) и отфильтро-
вывает данные согласно спецификации публикации. Затем данные последовательно передаются
739Логическая репликация
по протоколу логической репликации рабочему процессу применения изменений, который сопо-
ставляет данные с логическими таблицами и применяет отдельные изменения по мере их поступ-
ления, сохраняя транзакционный порядок.
Процесс применения изменений в базе данных подписчика всегда выполняется со значением
session_replication_role, равным replica, что влечёт соответствующие эффекты для триггеров
и ограничений.
Процесс применения логической репликации в настоящее время вызывает только триггеры уровня
строк, но не триггеры операторов. Однако начальная синхронизация таблицы реализована как
команда COPY и поэтому вызывает триггеры для INSERT и уровня строк, и уровня оператора.
31.5.1. Начальный снимок
Начальные данные существующих таблиц в подписке помещаются в снимок и копируются в парал-
лельном экземпляре процесса применения особого вида. Этот процесс создаёт собственный слот
репликации и производит копирование существующих данных. Когда существующие данные будут
скопированы, этот рабочий процесс переходит в режим синхронизации, в котором таблица при-
водится в синхронизированное состояние для основного процесса применения, то есть передаёт
все изменения, произошедшие во время начального копирования данных, используя стандартную
логическую репликацию. По завершении синхронизации управление репликацией этой таблицы
возвращается главному процессу, который продолжает репликацию в обычном режиме.
31.6. Мониторинг
Так как логическая репликация построена по схеме, подобной физической потоковой репликации,
мониторинг публикующего узла подобен мониторингу ведущего сервера при физической репли-
кации (см. Подраздел 26.2.5.2).
Информацию
о
подписке
для
мониторинга
можно
получить
в
представлении
pg_stat_subscription. Это представление содержит по одной строке для каждого рабочего про-
цесса подписчика. В зависимости от состояния подписки, с ней может быть связано ноль или бо-
лее активных рабочих процессов.
Обычно для включённой подписки работает только один процесс применения. Для отключённой
или нарушенной подписки это представление будет содержать ноль строк. Если выполняется на-
чальная синхронизация данных для каких-либо таблиц, для этих таблиц будут показаны дополни-
тельные рабочие процессы, производящие синхронизацию.
31.7. Безопасность
Роль, используемая для подключения репликации, должна иметь атрибут REPLICATION (или быть
суперпользователем). Доступ для этой роли должен быть настроен в pg_hba.conf, и эта роль также
должна иметь атрибут LOGIN.
Чтобы иметь возможность скопировать исходные данные таблицы, роль, используемая для соеди-
нения репликации, должна иметь право SELECT в публикуемой таблице (или быть суперпользова-
телем).
Чтобы создать публикацию, пользователь должен иметь право CREATE в базе данных.
Чтобы добавлять таблицы в публикацию, пользователь должен иметь права владельца для этих
таблиц. Создавать публикации, публикующие все таблицы автоматически, разрешено только су-
перпользователям.
Создавать подписки разрешено только суперпользователям.
Процесс применения изменений подписки будет выполняться в локальной базе с правами супер-
пользователя.
740Логическая репликация
Права проверяются только один раз при установлении подключения для репликации. Они не пе-
репроверяются при чтении каждой записи изменения с публикующего сервера и не перепроверя-
ются при применении каждого изменения.
31.8. Параметры конфигурации
Для осуществления логической репликации необходимо установить несколько параметров конфи-
гурации.
На публикующем сервере параметр wal_level должен иметь значение logical, а в
max_replication_slots должно быть задано число не меньше ожидаемого числа подписчиков
плюс некоторый резерв для синхронизации таблиц. А в max_wal_senders должно быть значение
как минимум равное max_replication_slots плюс число возможных физических реплик, работа-
ющих одновременно.
Также на стороне подписчика необходимо установить параметр max_replication_slots. В дан-
ном случае он должен быть не меньше числа подписок, на которые будет подписываться данный
подписчик. В max_logical_replication_workers необходимо установить минимум число подписок
плюс некоторый резерв для синхронизации таблиц. Кроме того, может потребоваться изменить
max_worker_processes, чтобы это число включало дополнительные рабочие процессы для репли-
кации (как минимум max_logical_replication_workers + 1). Заметьте, что некоторые расширения
и параллельные запросы также занимают слоты из числа max_worker_processes.
31.9. Быстрая настройка
Сначала установите параметры конфигурации в postgresql.conf:
wal_level = logical
Другие необходимые параметры по умолчанию имеют значения, подходящие для базовой настрой-
ки.
В файл pg_hba.conf необходимо внести изменения, чтобы разрешить репликацию (конкретные
значения будут зависеть от фактической конфигурации сети и имени пользователя, с которым вы
будете подключаться):
host
all
repuser
0.0.0.0/0
md5
Затем в базе данных публикации выполните:
CREATE PUBLICATION mypub FOR TABLE users, departments;
И в базе данных подписчика:
CREATE SUBSCRIPTION mysub CONNECTION ‘dbname=foo host=bar user=repuser’ PUBLICATION
mypub;
Показанная выше команда запустит процесс репликации, который вначале синхронизирует исход-
ное содержимого таблиц users и departments, а затем начнёт перенос инкрементальных измене-
ний в этих таблицах.
741</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page15/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page14/">14</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page15/">15</a></li>
      
    
      
        <li><strong class="current-page">16</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page17/">17</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page18/">18</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page17/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>