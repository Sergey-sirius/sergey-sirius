<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 41. Система правил &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 41. Система правил">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 41. Система правил">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-041/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-041/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 41. Система правил">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-041/" rel="bookmark" title="Глава 41. Система правил">Глава 41. Система правил</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~48 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 41. Система правил</p>

<p>В этой главе обсуждается система правил, реализованная в PostgreSQL. Промышленные системы
правил по сути довольно простые, но при их использовании приходится сталкиваться с множеством
неочевидных вещей.
В некоторых других базах данных определяются активные правила баз данных, которые обычно
реализуются в виде процедур и триггеров. Так же их можно реализовать и в PostgreSQL.
Система правил (точнее говоря, система правил перезаписи запросов) полностью отличается от
механизма хранимых процедур и триггеров. Она изменяет запросы по заданным правилам, а затем
передаёт модифицированный запрос планировщику для планирования и выполнения. Это очень
мощное средство, подходящее для решения множества задач, например, для определения пред-
ставлений и процедур на языке запросов или реализации версионности. Теоретические основы и
преимущества этой системы правил также описаны в ston90b и ong90 (на английском языке).
41.1. Дерево запроса
Чтобы понять, как работает система правил, нужно знать, когда она вызывается, что принимает
на вход и какой результат выдаёт.
Система правил внедрена между анализатором запросов и планировщиком. Она принимает разо-
бранный запрос, одно дерево запроса, и определённые пользователем правила перезаписи, тоже
представленные деревьями с некоторой дополнительной информацией, и создаёт некоторое коли-
чество деревьев запросов в результате. Таким образом, на входе и выходе этой системы оказыва-
ется то, что может сформировать анализатор запросов, и как следствие, всё, с чем работает эта
система, представимо в виде операторов SQL.
Так что же такое дерево запроса? Это внутреннее представление оператора SQL, в котором
все образующие его части хранятся отдельно. Эти деревья можно увидеть в журнале серве-
ра, если установить параметры конфигурации debug_print_parse, debug_print_rewritten или
debug_print_plan. Действия правил также хранятся в виде деревьев запросов, в системном ката-
логе pg_rewrite. Они не форматируются как при выводе в журнал, но содержат точно такую же
информацию.
Для прочтения неформатированного дерева требуется некоторый навык. Но так как представле-
ния дерева запросов в виде SQL достаточно, чтобы понять систему правил, в этой главе не будет
рассказываться, как их читать.
Читая SQL-представления деревьев запросов в этой главе, необходимо понимать, на какие части
разбивается оператор, когда он преобразуется в структуру дерева запроса. Дерево запроса состоит
из следующих частей:
тип команды
Это простое значение, говорящее, какая команда (SELECT, INSERT, UPDATE или DELETE) сгенери-
ровала дерево запросов.
список отношений
Список отношений представляет собой массив отношений, используемых в запросе. В запросе
SELECT он включает отношения, указанные после ключевого слова FROM.
Каждый элемент списка отношений представляет таблицу или представление и говорит, с ка-
ким именем они упоминаются в других частях запроса. В дереве запросов записываются номе-
ра элементов списка отношений, а не их имена, поэтому для него неактуальна проблема дуб-
лирования имён, как для оператора SQL. Такая проблема может возникнуть при объединении
списков отношений, образованных разными правилами. В этой главе данная ситуация рассмат-
риваться не будет.
1095Система правил
результирующее отношение
Индекс в списке отношений, указывающий на отношение, которое будет получать результаты
запроса.
В запросах SELECT результирующее отношение отсутствует. (Особый случай SELECT INTO прак-
тически равнозначен CREATE TABLE с последующим INSERT … SELECT и здесь отдельно не
рассматривается.)
Для команд INSERT, UPDATE и DELETE результирующим отношением будет таблица (или пред-
ставление!), в которой будут происходить изменения.
выходной список
Выходной список — это список выражений, определяющих результат запроса. В случае SELECT,
это выражения, которые образуют окончательный набор выходных данных. Они соответствуют
выражениям, записанным между ключевыми словами SELECT и FROM. (Указание * — это просто
краткое обозначение имён всех столбцов отношения. Анализатор разворачивает его в список
отдельных столбцов, так что система правил никогда не видит его.)
Командам DELETE не нужен обычный выходной список, так как они не выдают никакие результа-
ты. Вместо этого планировщик добавляет в пустой выходной список специальную запись CTID,
чтобы исполнитель мог найти удаляемую строку. (CTID добавляется, когда результирующее от-
ношение — обычная таблица. Если это представление, планировщиком добавляется перемен-
ная, содержащая всю строку, как рассказывается в Подразделе 41.2.4.)
Для команд INSERT выходной список описывает новые строки, которые должны попасть в ре-
зультирующее отношение. Он включает выражения в предложении VALUES или предложении
SELECT в INSERT … SELECT. На первом этапе процесс перезаписи добавляет элементы выход-
ного списка для столбцов, которым ничего не присвоила исходная команда, но имеющих зна-
чения по умолчанию. Все остальные столбцы (без заданного значения и значения по умолча-
нию) планировщик заполняет константой NULL.
Для команд UPDATE выходной список описывает новые строки, которые должны заменить ста-
рые. В системе правил он содержит только выражения из части SET столбец = выражение. Для
пропущенных столбцов планировщик вставляет выражения, копирующие значения из старой
строки в новую. Так же, как и с командой DELETE, при этом добавляется CTID или переменная
со всей строкой, чтобы исполнитель мог найти изменяемую старую строку.
Каждая запись в выходном списке содержит выражение, которое может быть константой, пе-
ременной, указывающей на столбец отношения в таблице отношений, параметром или деревом
выражений, образованным из констант, переменных, операторов, вызовов функций и т. д.
условие фильтра
Условие фильтра запроса — это выражение, во многом похожее на те, что содержатся в вы-
ходном списке. Результат этого выражения — логический, он говорит, должна ли выполнять-
ся операция (INSERT, UPDATE, DELETE или SELECT) для данной строки в результате. Оно соответ-
ствует предложению WHERE SQL-оператора.
дерево соединения
Дерево соединения запроса показывает структуру предложения FROM. Для простых запросов
вида SELECT … FROM a, b, c, дерево соединения — это просто список элементов FROM, так
как они могут соединяться в любом порядке. Но с выражениями JOIN, особенно с внешними
соединениями, приходится соединять отношения именно в заданном порядке. В этом случае
дерево соединения отражает структуру выражений JOIN. Ограничения, связанные с конкрет-
ными предложениями JOIN (из выражений ON или USING), тоже сохраняются в виде условных
выражений, добавленных к соответствующим узлам дерева соединения. Как оказалось, выра-
жение WHERE верхнего уровня тоже удобно хранить как условие, добавленное к элементу верх-
1096Система правил
него уровня дерева соединения. Поэтому в дереве соединения на самом деле представляются
оба предложения оператора SELECT — FROM и WHERE.
другие
Другие части дерева запроса, например, предложение ORDER BY, в данном контексте не пред-
ставляют интереса. Система правил выполняет в них некоторые подстановки, применяя пра-
вила, но это не имеет непосредственного отношения к основам системы правил.
41.2. Система правил и представления
Представления в PostgreSQL реализованы на основе системы правил. Фактически по сути нет ни-
какого отличия
CREATE VIEW myview AS SELECT * FROM mytab;
от следующих двух команд:
CREATE TABLE myview (same column list as mytab);
CREATE RULE “_RETURN” AS ON SELECT TO myview DO INSTEAD
SELECT * FROM mytab;
так как именно эти действия CREATE VIEW выполняет внутри. Это имеет некоторые побочные эф-
фекты. В частности, информация о представлениях в системных каталогах PostgreSQL ничем не
отличается от информации о таблицах. Поэтому при анализе запроса нет абсолютно никакой раз-
ницы между таблицами и представлениями. Они представляют собой одно и то же — отношения.
41.2.1. Как работают правила SELECT
Правила ON SELECT применяются ко всем запросам на последнем этапе, даже если это команда
INSERT, UPDATE или DELETE. Эти правила отличаются от правил других видов тем, что они моди-
фицируют непосредственно дерево запросов, а не создают новое. Поэтому мы начнём описание с
правил SELECT.
В настоящее время возможно только одно действие в правиле ON SELECT и это должно быть без-
условное действие SELECT, выполняемое в режиме INSTEAD. Это ограничение было введено, что-
бы сделать правила достаточно безопасными для применения обычными пользователями, так что
действие правил ON SELECT сводится к реализации представлений.
В примерах этой главы рассматриваются два представления с соединением, которые выполняют
некоторые вычисления, и которые, в свою очередь, используются другими представлениями. Пер-
вое из этих двух представлений затем модифицируется, к нему добавляются правила для операций
INSERT, UPDATE и DELETE, так что в итоге получается представление, которое работает как обычная
таблица с некоторыми необычными функциями. Это не самый простой пример для начала, поэто-
му понять некоторые вещи будет сложнее. Но лучше иметь один пример, поэтапно охватывающий
все обсуждаемые здесь темы, чем несколько различных, при восприятии которых в итоге может
возникнуть путаница.
Например, нам нужна простейшая функция min, которая возвратит минимальное из двух целых
чисел. Её можно создать так:
CREATE FUNCTION min(integer, integer) RETURNS integer AS <script type="math/tex">% <![CDATA[
SELECT CASE WHEN $1 < $2 THEN $1 ELSE $2 END %]]></script> LANGUAGE SQL STRICT;
Таблицы, которые понадобятся нам для описания системы правил, выглядят так:
CREATE TABLE shoe_data (
shoename
text,
sh_avail
integer,
slcolor
text,
slminlen
real,
–
–
–
–
первичный ключ
число имеющихся пар
предпочитаемый цвет шнурков
минимальная длина шнурков
1097Система правил
slmaxlen
slunit
real,
text
– максимальная длина шнурков
– единица длины
);
CREATE TABLE shoelace_data (
sl_name
text,
sl_avail
integer,
sl_color
text,
sl_len
real,
sl_unit
text
); –
–
–
–
–
CREATE TABLE unit (
un_name
text,
un_fact
real
); – первичный ключ
– коэффициент для перевода в см
первичный ключ
число имеющихся пар
цвет шнурков
длина шнурков
единица длины
Как можно догадаться, в них хранятся данные обувной фабрики.
Представления создаются так:
CREATE VIEW shoe AS
SELECT sh.shoename,
sh.sh_avail,
sh.slcolor,
sh.slminlen,
sh.slminlen * un.un_fact AS slminlen_cm,
sh.slmaxlen,
sh.slmaxlen * un.un_fact AS slmaxlen_cm,
sh.slunit
FROM shoe_data sh, unit un
WHERE sh.slunit = un.un_name;
CREATE VIEW shoelace AS
SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name;
CREATE VIEW shoe_ready AS
SELECT rsh.shoename,
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM shoe rsh, shoelace rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;
Команда CREATE VIEW для представления shoelace (самого простого из имеющихся) создаёт отно-
шение shoelace и запись в pg_rewrite о правиле перезаписи, которое должно применяться, когда
в запросе на выборку задействуется отношение shoelace. Для этого правила не задаются условия
применения (о них рассказывается ниже, в описании правил не для SELECT, так как правила SELECT
в настоящее бывают только безусловными) и оно действует в режиме INSTEAD. Заметьте, что усло-
вия применения отличаются от условий фильтра запроса, например, действие для нашего правила
1098Система правил
содержит условие фильтра. Действие правила выражается одним деревом запроса, которое явля-
ется копией оператора SELECT в команде, создающей представление.
Примечание
Два дополнительных элемента списка отношений NEW и OLD, которые можно увидеть в
соответствующей строке pg_rewrite, не представляют интереса для правил SELECT.
Сейчас мы наполним таблицы unit (единицы измерения), shoe_data (данные о туфлях) и
shoelace_data (данные о шнурках) и выполним простой запрос к представлению:
INSERT INTO unit VALUES (‘cm’, 1.0);
INSERT INTO unit VALUES (‘m’, 100.0);
INSERT INTO unit VALUES (‘inch’, 2.54);
INSERT
INSERT
INSERT
INSERT INTO
INTO
INTO
INTO shoe_data
shoe_data
shoe_data
shoe_data
VALUES
VALUES
VALUES
VALUES
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
(‘sh1’,
(‘sh2’,
(‘sh3’,
(‘sh4’,
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
2,
0,
4,
3,
‘black’,
‘black’,
‘brown’,
‘brown’,
(‘sl1’,
(‘sl2’,
(‘sl3’,
(‘sl4’,
(‘sl5’,
(‘sl6’,
(‘sl7’,
(‘sl8’,
5,
6,
0,
8,
4,
0,
7,
1,
70.0,
30.0,
50.0,
40.0,
‘black’,
‘black’,
‘black’,
‘black’,
‘brown’,
‘brown’,
‘brown’,
‘brown’,
90.0,
40.0,
65.0,
50.0,
‘cm’);
‘inch’);
‘cm’);
‘inch’);
80.0, ‘cm’);
100.0, ‘cm’);
35.0, ‘inch’);
40.0, ‘inch’);
1.0, ‘m’);
0.9, ‘m’);
60, ‘cm’);
40, ‘inch’);
SELECT * FROM shoelace;
sl_name
| sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———–+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
7 | brown
|
60 | cm
|
60
sl3
|
0 | black
|
35 | inch
|
88.9
sl4
|
8 | black
|
40 | inch
|
101.6
sl8
|
1 | brown
|
40 | inch
|
101.6
sl5
|
4 | brown
|
1 | m
|
100
sl6
|
0 | brown
|
0.9 | m
|
90
(8 rows)
Это самый простой запрос SELECT, который можно выполнить с нашими представлениями, и мы
воспользуемся этим, чтобы объяснить азы правил представлений. Запрос SELECT * FROM shoelace
интерпретируется анализатором запросов и преобразуется в дерево запроса:
SELECT shoelace.sl_name, shoelace.sl_avail,
shoelace.sl_color, shoelace.sl_len,
shoelace.sl_unit, shoelace.sl_len_cm
FROM shoelace shoelace;
Это дерево передаётся в систему правил, которая проходит по списку отношений и проверяет, есть
ли какие-либо правила для этих отношений. Обрабатывая элемент отношения shoelace (сейчас он
единственный), система правил находит правило _RETURN с деревом запроса:
SELECT s.sl_name, s.sl_avail,
s.sl_color, s.sl_len, s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
1099Система правил
FROM shoelace old, shoelace new,
shoelace_data s, unit u
WHERE s.sl_unit = u.un_name;
Чтобы развернуть представление, механизм перезаписи просто формирует новый элемент для
списка отношений — подзапрос, содержащий дерево действия правила, и подставляет этот эле-
мент вместо исходного, на который ссылалось представление. Получившееся перезаписанное де-
рево запроса будет почти таким как дерево запроса:
SELECT shoelace.sl_name, shoelace.sl_avail,
shoelace.sl_color, shoelace.sl_len,
shoelace.sl_unit, shoelace.sl_len_cm
FROM (SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name) shoelace;
Однако есть одно различие: в списке отношений подзапроса будут содержаться два дополнитель-
ных элемента: shoelace old и shoelace new. Эти элементы не принимают непосредственного уча-
стия в запросе, так как они не задействованы в дереве соединения подзапроса и в целевом списке.
Механизм перезаписи использует их для хранения информации о проверке прав доступа, которая
изначально хранилась в элементе, указывающем на представление. Таким образом, исполнитель
будет по-прежнему проверять, имеет ли пользователь необходимые права для доступа к представ-
лению, хотя в перезаписанном запросе это представление не фигурирует непосредственно.
Так было применено первое правило. Система правил продолжит проверку оставшихся элементов
списка отношений на верхнем уровне запроса (в данном случае таких элементов нет) и рекурсивно
проверит элементы списка отношений в добавленном подзапросе, не ссылаются ли они на пред-
ставления. (Но old и new разворачиваться не будут — иначе мы получили бы бесконечную рекур-
сию!) В этом примере для shoelace_data и unit нет правил перезаписи, так что перезапись завер-
шается и результат, полученный выше, передаётся планировщику.
Сейчас мы хотим написать запрос, который выбирает туфли из имеющихся в данный момент, для
которых есть подходящие шнурки (по цвету и длине) и число готовых пар больше или равно двум.
SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;
shoename | sh_avail | sl_name | sl_avail | total_avail
———-+———-+———+———-+————-
sh1
|
2 | sl1
|
5 |
2
sh3
|
4 | sl7
|
7 |
4
(2 rows)
На этот раз анализатор запроса выводит такое дерево:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM shoe_ready shoe_ready
WHERE shoe_ready.total_avail &gt;= 2;
Первое правило применяется к представлению shoe_ready и в результате получается дерево за-
проса:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM (SELECT rsh.shoename,
1100Система правил
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM shoe rsh, shoelace rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
WHERE shoe_ready.total_avail &gt;= 2;
Подобным образом, правила для shoe и shoelace подставляются в список отношений, что даёт
окончательное дерево запроса:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM (SELECT rsh.shoename,
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM (SELECT sh.shoename,
sh.sh_avail,
sh.slcolor,
sh.slminlen,
sh.slminlen * un.un_fact AS slminlen_cm,
sh.slmaxlen,
sh.slmaxlen * un.un_fact AS slmaxlen_cm,
sh.slunit
FROM shoe_data sh, unit un
WHERE sh.slunit = un.un_name) rsh,
(SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name) rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
WHERE shoe_ready.total_avail &gt; 2;
На практике планировщик будет сворачивать это дерево до двух уровней: команды нижнего уров-
ня SELECT будут «подняты» к среднему SELECT, так как обрабатывать их отдельно нет необходимо-
сти. Но средний оператор SELECT не будет совмещён с верхним, так как он содержит агрегатные
функции. Если поднять его выше, поведение самого верхнего SELECT изменится нежелательным
образом. В целом же, сворачивание дерева запросов — это оптимизация, которая не должна за-
трагивать работу механизма перезаписи.
41.2.2. Правила представлений не для SELECT
До этого в описании правил представлений не затрагивались два компонента дерева запросов —
тип команды и результирующее отношение. На самом деле, тип команды не важен для правил
представления, но результирующее отношение может повлиять на работу механизма перезаписи,
потому что если это представление, требуются дополнительные операции.
Есть только несколько отличий между деревом запроса для SELECT и деревом для другой команды.
Очевидно, у них различные типы команд, и для команды, отличной от SELECT, результирующее от-
1101Система правил
ношение указывает на элемент в списке отношений, куда должен попасть результат. Все осталь-
ные компоненты в точности те же. Поэтому, например, если взять таблицы t1 и t2 со столбцами
a и b, деревья запросов для этих операторов:
SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;
UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;
будут практически одинаковыми. В частности:
• Списки отношений содержат элементы для таблиц t1 и t2.
• Выходные списки содержат одну переменную, указывающую на столбец b элемента-отноше-
ния для таблицы t2.
• Выражения условий сравнивают столбцы a обоих элементов-отношений на равенство.
• Деревья соединений показывают простое соединение между t1 и t2.
Как следствие, для обоих деревьев строятся похожие планы выполнения, с соединением двух таб-
лиц. Для UPDATE планировщик добавляет в выходной список недостающие столбцы из t1 и оконча-
тельное дерево становится таким:
UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;
В результате исполнитель, обрабатывающий соединение, выдаёт тот же результат, что и запрос:
SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
Но с UPDATE есть маленькая проблема: часть плана исполнителя, в которой выполняется соедине-
ние, не представляет, для чего предназначены результаты соединения. Она просто выдаёт резуль-
тирующий набор строк. Фактически есть одна команда SELECT, а другая, UPDATE, обрабатывается
исполнителем выше, где он уже знает, что это команда UPDATE и что результат должен попасть в
таблицу t1. Но какие из строк таблицы должны заменяться новыми?
Для решения этой проблемы в выходной список операторов UPDATE (и DELETE) добавляется ещё
один элемент: идентификатор текущего кортежа (Current Tuple ID, CTID).Это системный столбец,
содержащий номер блока в файле и позицию строки в блоке. Зная таблицу, по CTID можно полу-
чить исходную строку в t1, подлежащую изменению. С добавленным в выходной список CTID за-
прос фактически выглядит так:
SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
Теперь мы перейдём ещё к одной особенности PostgreSQL. Старые строки таблицы не переписы-
ваются, поэтому ROLLBACK выполняется быстро. С командой UPDATE в таблицу вставляется новая
строка результата (без CTID) и в заголовке старой строки, на которую указывает CTID, в поля cmax
и xmax записываются текущий счётчик команд и идентификатор текущей транзакции. Таким об-
разом, старая строка оказывается скрытой и после фиксирования транзакции процесс очистки
может окончательно удалить неактуальную версию строки.
Зная всё это, мы можем применять правила представлений абсолютно таким же образом к любой
команде — никаких различий нет.
41.2.3. Преимущества представлений в PostgreSQL
Выше было показано, как система правил внедряет определения представлений в исходное дерево
запроса. Во втором примере простой запрос SELECT к одному представлению создал окончательное
дерево запроса, соединяющее 4 таблицы (таблица unit использовалась дважды с разными имена-
ми).
Преимущество реализации представлений через систему правил заключается в том, что плани-
ровщик получает в одном дереве запроса всю информацию о таблицах, которые нужно прочитать,
о том, как связаны эти таблицы, об условиях в представлениях, а также об условиях, заданных в
1102Система правил
исходном запросе. И всё это имеет место, когда сам исходный запрос представляет собой соеди-
нение представлений. Планировщик должен выбрать лучший способ выполнения запроса, и чем
больше информации он получит, тем лучше может быть его выбор. И то, как в PostgreSQL реали-
зована система правил, гарантирует, что ему поступает вся информация, собранная о запросе на
данный момент.
41.2.4. Изменение представления
Но что произойдёт, если записать имя представления в качестве целевого отношения команды
INSERT, UPDATE или DELETE? Если проделать подстановки, описанные выше, будет получено дерево
запроса, в котором результирующее отношение указывает на элемент-подзапрос, что не будет ра-
ботать. Однако PostgreSQL даёт ряд возможностей, чтобы сделать представления изменяемыми.
Если подзапрос выбирает данные из одного базового отношения и он достаточно прост, механизм
перезаписи может автоматически заменить его нижележащим базовым отношением, чтобы ко-
манды INSERT, UPDATE или DELETE обращались к базовому отношению. Представления, «достаточно
простые» для этого, называются автоматически изменяемыми. Подробнее виды представлений,
которые могут изменяться автоматически, описаны в CREATE VIEW.
Эту задачу также можно решить, создав триггер INSTEAD OF для представления. В этом случае пе-
резапись будет работать немного по-другому. Для INSERT механизм перезаписи не делает с пред-
ставлением ничего, оставляя его результирующим отношением запроса. Для UPDATE и DELETE ему
по-прежнему придётся разворачивать запрос представления, чтобы получить «старые» строки,
которые эта команда попытается изменить или удалить. Поэтому представление разворачивается
как обычно, но в запрос добавляется ещё один элемент списка отношений, указывающий на пред-
ставление в роли результирующего отношения.
При этом возникает проблема идентификации строк в представлении, подлежащих изменению.
Вспомните, что когда результирующее отношение является таблицей, в выходной список добавля-
ется специальное поле CTID, указывающее на физическое расположение изменяемых строк. Но
это не будет работать, когда результирующее отношение — представление, так как в представле-
ниях нет CTID, потому что их строки физически нигде не находятся. Вместо этого, для операций
UPDATE или DELETE в выходной список добавляется специальный элемент wholerow (вся строка),
который разворачивается в содержимое всех столбцов представления. Используя этот элемент,
исполнитель передаёт строку «old» в триггер INSTEAD OF. Какие именно строки должны изменять-
ся фактически, будет решать сам триггер, исходя из полученных значений старых и новых строк.
Кроме того, пользователь может определить правила INSTEAD, в которых задать действия замены
для команд INSERT, UPDATE и DELETE с представлением. Эти правила обычно преобразуют команду
в другую команду, изменяющую одну или несколько таблиц, а не представление. Эта тема осве-
щается в Разделе 41.4.
Заметьте, что такие правила вычисляются сначала, перезаписывая исходный запрос до того, как
он будет планироваться и выполняться. Поэтому, если для представления определены и триггеры
INSTEAD OF, и правила для INSERT, UPDATE или DELETE, сначала вычисляются правила, а в зависи-
мости от их действия, триггеры могут не вызываться вовсе.
Автоматическая перезапись запросов INSERT, UPDATE или DELETE с простыми представлениями все-
гда производится в последнюю очередь. Таким образом, если у представления есть правила или
триггеры, они переопределяют поведение автоматически изменяемых представлений.
Если для представления не определены правила INSTEAD или триггеры INSTEAD OF, и запрос не
удаётся автоматически переписать в виде обращения к нижележащему базовому отношению, воз-
никает ошибка, потому что исполнитель не сможет изменить такое представление.
41.3. Материализованные представления
Материализованные представления в PostgreSQL основаны на системе правил, как и представле-
ния, но их содержимое сохраняется как таблица. Основное отличие между:
1103Система правил
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;
и этой командой:
CREATE TABLE mymatview AS SELECT * FROM mytab;
состоит в том, что материализованное представление впоследствии нельзя будет изменить непо-
средственно, а запрос, создающий материализованное представление, сохраняется точно так же,
как запрос представления, и получить актуальные данные в материализованном представлении
можно так:
REFRESH MATERIALIZED VIEW mymatview;
Информация о материализованном представлении в системных каталогах PostgreSQL ничем не от-
личается от информации о таблице или представлении. Поэтому для анализатора запроса матери-
ализованное представление является просто отношением, как таблица или представление. Когда
запрос обращается к материализованному представлению, данные возвращаются непосредствен-
но из него, как из таблицы; правило применяется, только чтобы его наполнить.
Хотя обращение к данным в материализованном представлении часто выполняется гораздо быст-
рее, чем обращение к нижележащим таблицам напрямую или через представление, данные в нём
не всегда актуальные (но иногда это вполне приемлемо). Рассмотрим таблицу с данными продаж:
CREATE TABLE invoice (
invoice_no
integer
seller_no
integer,
invoice_date date,
invoice_amt
numeric(13,2)
);
PRIMARY KEY,
– идентификатор продавца
– дата продажи
– сумма продажи
Если пользователям нужно быстро обработать исторические данные, возможно их интересуют
только общие показатели, а полнота данных на текущий момент не важна:
CREATE MATERIALIZED VIEW sales_summary AS
SELECT
seller_no,
invoice_date,
sum(invoice_amt)::numeric(13,2) as sales_amt
FROM invoice
WHERE invoice_date &lt; CURRENT_DATE
GROUP BY
seller_no,
invoice_date
ORDER BY
seller_no,
invoice_date;
CREATE UNIQUE INDEX sales_summary_seller
ON sales_summary (seller_no, invoice_date);
Это материализованное представление может быть полезно для построения графика в информа-
ционной панели менеджеров по продажам. Для ежесуточного обновления статистики можно за-
планировать задание по расписанию, которое будет выполнять этот оператор:
REFRESH MATERIALIZED VIEW sales_summary;
Ещё одно применение материализованного представления — предоставить быстрый доступ к дан-
ным, получаемым с удалённой системы через обёртку сторонних данных. Ниже приведён простой
пример с обёрткой file_fdw, с замерами времени, но так как при этом использовался кеш локаль-
ной системы, выигрыш в производительности при обращении к удалённой системе обычно будет
гораздо больше, чем показано здесь. Заметьте, что мы также использовали возможность добавить
индекс в материализованное представление, тогда как file_fdw индексы не поддерживает; при
других видах доступа к сторонним данным такого преимущества может не быть.
1104Система правил
Подготовка:
CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
SERVER local_file
OPTIONS (filename ‘/usr/share/dict/words’);
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;
Теперь давайте проверим написание слова. Сначала непосредственно через обёртку file_fdw:
SELECT count(<em>) FROM words WHERE word = ‘caterpiler’;
count
——-
0
(1 row)
Выполнив EXPLAIN ANALYZE, мы получаем:
Aggregate (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181
rows=1 loops=1)
-&gt; Foreign Scan on words (cost=0.00..21761.41 rows=1032 width=0) (actual
time=188.177..188.177 rows=0 loops=1)
Filter: (word = ‘caterpiler’::text)
Rows Removed by Filter: 479829
Foreign File: /usr/share/dict/words
Foreign File Size: 4953699
Planning time: 0.118 ms
Execution time: 188.273 ms
Если же теперь обратиться к материализованному представлению, запрос выполнится гораздо
быстрее:
Aggregate (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
-&gt; Index Only Scan using wrd_word on wrd (cost=0.42..4.44 rows=1 width=0) (actual
time=0.039..0.039 rows=0 loops=1)
Index Cond: (word = ‘caterpiler’::text)
Heap Fetches: 0
Planning time: 0.164 ms
Execution time: 0.117 ms
В любом случае слово записано неправильно, поэтому давайте попробуем найти то, что имелось
в виду. Сначала опять через file_fdw:
SELECT word FROM words ORDER BY word &lt;-&gt; ‘caterpiler’ LIMIT 10;
word
—————
cater
caterpillar
Caterpillar
caterpillars
caterpillar’s
Caterpillar’s
caterer
caterer’s
caters
catered
1105Система правил
(10 rows)
Limit (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594
rows=10 loops=1)
-&gt; Sort (cost=11583.61..11804.76 rows=88459 width=32) (actual
time=1431.589..1431.591 rows=10 loops=1)
Sort Key: ((word &lt;-&gt; ‘caterpiler’::text))
Sort Method: top-N heapsort Memory: 25kB
-&gt; Foreign Scan on words (cost=0.00..9672.05 rows=88459 width=32) (actual
time=0.057..1286.455 rows=479829 loops=1)
Foreign File: /usr/share/dict/words
Foreign File Size: 4953699
Planning time: 0.128 ms
Execution time: 1431.679 ms
Затем через материализованное представление:
Limit (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10
loops=1)
-&gt; Index Scan using wrd_trgm on wrd (cost=0.29..37020.87 rows=479829 width=10)
(actual time=187.219..188.252 rows=10 loops=1)
Order By: (word &lt;-&gt; ‘caterpiler’::text)
Planning time: 0.196 ms
Execution time: 198.640 ms
Если периодическое обновление данных из другого источника в локальной базе данных вас устра-
ивает, этот подход может дать значительный выигрыш в скорости.
41.4. Правила для INSERT, UPDATE и DELETE
Правила, определяемые для команд INSERT, UPDATE и DELETE, значительно отличаются от правил
представлений, описанных в предыдущем разделе. Во-первых, команда CREATE RULE позволяет со-
здавать правила со следующими особенностями:
• Они могут не определять действия.
• Они могут определять несколько действий.
• Они могут действовать в режиме INSTEAD или ALSO (по умолчанию).
• Становятся полезными псевдоотношения NEW и OLD.
• Они могут иметь условия применения.
Во-вторых, они не модифицируют само исходное дерево запроса. Вместо этого они создают
несколько новых деревьев запросов и могут заменить исходное.
Внимание
Во многих случаях для задач, выполнимых с использованием правил для INSERT/UPDATE/
DELETE, лучше применять триггеры. Оформляются триггеры чуть сложнее, но понять
их смысл гораздо проще. К тому же с правилами могут быть получены неожиданные
результаты, когда исходный запрос содержит изменчивые функции: в процессе испол-
нения правил эти функции могут вызываться большее число раз, чем ожидается.
Кроме того, в некоторых случаях эти типы правил вообще нельзя применять; а имен-
но, с предложениями WITH в исходном запросе и с вложенными подзапросами SELECT
с множественным присваиванием в списке SET запросов UPDATE. Это объясняется тем,
что копирование этих конструкций в запрос правила привело бы к многократному вы-
числению вложенного запроса, что пошло бы в разрез с выраженными намерениями
автора запроса.
1106Система правил
41.4.1. Как работают правила для изменения
Запомните синтаксис:
CREATE [ OR REPLACE ] RULE имя AS ON событие
TO таблица [ WHERE условие ]
DO [ ALSO | INSTEAD ] { NOTHING | команда | ( команда ; команда … ) }
В дальнейшем, под правилами для изменения подразумеваются правила, определяемые для ко-
манд INSERT, UPDATE или DELETE.
Правила для изменения применяются системой правил, когда результирующее отношение и тип
команды в дереве запроса совпадает с объектом и событием, заданным в команде CREATE RULE. Для
такого правила система правил создаёт список деревьев запросов. Изначально этот список пуст.
С правилом может быть связано ноль (ключевое слово NOTHING), одно или несколько действий.
Простоты ради мы рассмотрим правило с одним действием. Правило может иметь, а может не
иметь условия применения, и действует в режиме INSTEAD или ALSO (по умолчанию).
Что такое условие применения правила? Это условие, которое говорит, когда нужно, а когда не
нужно применять действия правила. В этом условии можно обращаться к псевдоотношениям NEW
и/или OLD, которые представляют целевое отношение (но с особым значением).
Всего есть три варианта формирования деревьев запросов для правила с одним действием.
Без условия применения в режиме ALSO или INSTEAD
дерево запроса из действия правила с добавленным условием исходного дерева
С условием применения в режиме ALSO
дерево запроса из действия правила с условием применения правила и условием, добавленным
из исходного дерева
С условием применения в режиме INSTEAD
дерево запроса из действия правила с условием применения правила и условием из исходного
дерева; также добавляется исходное дерево запроса с условием, обратным условию примене-
ния правила
Наконец, для правил ALSO в список добавляется исходное дерево запроса без изменений. Так как
исходное дерево запроса также добавляют только правила INSTEAD с условиями применения, в
итоге для правила с одним действием мы можем получить только одно или два дерева запросов.
Для правил ON INSERT исходный запрос (если он не перекрывается режимом INSTEAD) выполняет-
ся перед действиями, добавленными правилами. Поэтому эти действия могут видеть вставленные
строки. Но для правил ON UPDATE и ON DELETE исходный запрос выполняется после действий, до-
бавленных правилами. При таком порядке эти действия будут видеть строки, подлежащие измене-
нию или удалению; иначе бы действия не работали, не найдя строк, соответствующих их условиям
применения (эти строки уже будут изменены или удалены).
Деревья запросов, полученные из действий правил, снова попадают в систему перезаписи, где мо-
гут примениться дополнительные правила, добавляющие или убирающие деревья запроса. Поэто-
му действия правила должны выполнять команды другого типа или работать с другим результиру-
ющим отношением, иначе возникнет бесконечная рекурсия. (Система выявляет подобное рекур-
сивное разворачивание правил и выдаёт ошибку.)
Деревья запросов, заданные для действий в системном каталоге pg_rewrite, представляют собой
только шаблоны. Так как они могут обращаться к элементам NEW и OLD в списке отношений, их
можно будет использовать только после некоторых подстановок. В случае ссылки на NEW соответ-
ствующий элемент ищется в целевом списке исходного запроса. Если он найден, ссылка заменя-
ется выражением этого элемента. В противном случае NEW означает то же самое, что и OLD (для
1107Система правил
команды UPDATE) или заменяется значением NULL (для команды INSERT). Любые ссылки на OLD
заменяются ссылкой на элемент результирующего отношения в списке отношений.
После того как система применит все правила для изменения, она применяет правила представ-
ления к полученному дереву (или деревьям) запроса. Представления не могут добавлять новые
действия для изменения, поэтому нет необходимости применять такие правила к результату пе-
резаписи представления.
41.4.1.1. Пошаговый разбор первого правила
Предположим, что нам нужно отслеживать изменения в столбце sl_avail таблицы shoelace_data.
Мы можем создать таблицу для ведения журнала и правило, которое будет добавлять в неё записи
по условию, когда для shoelace_data выполняется UPDATE.
CREATE TABLE shoelace_log (
sl_name
text,
sl_avail
integer,
log_who
text,
log_when
timestamp
);
–
–
–
–
шнурки, количество которых изменилось
новое количество
кто изменил
когда
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
DO INSERT INTO shoelace_log VALUES (
NEW.sl_name,
NEW.sl_avail,
current_user,
current_timestamp
);
Теперь, если кто-то выполнит:
UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = ‘sl7’;
мы увидим в таблице журнала:
SELECT * FROM shoelace_log;
sl_name | sl_avail | log_who | log_when
———+———-+———+———————————-
sl7
|
6 | Al
| Tue Oct 20 16:14:45 1998 MET DST
(1 row)
Именно это нам и нужно. При этом внутри происходит следующее. Анализатор запроса создаёт
дерево:
UPDATE shoelace_data SET sl_avail = 6
FROM shoelace_data shoelace_data
WHERE shoelace_data.sl_name = ‘sl7’;
В системном каталоге находится правило log_shoelace, настроенное на изменение (ON UPDATE) с
условием применения:
NEW.sl_avail &lt;&gt; OLD.sl_avail
и действием:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old;
(Это выглядит несколько странно, так как обычно нельзя написать INSERT … VALUES … FROM.
Предложение FROM здесь добавлено, просто чтобы показать, что в дереве запроса для ссылок new и
1108Система правил
old есть элементы в списке отношений. Они необходимы для того, чтобы к ним могли обращаться
переменные в дереве запроса команды INSERT.)
Так как это правило ALSO с условием применения, система правил должна выдать два дерева за-
просов: изменённое действие правила и исходное дерево запроса. На первом шаге список отноше-
ний исходного запроса вставляется в дерево действия правила и получается:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data;
На втором шаге в это дерево добавляется условие применения правила, так что результирующий
набор ограничивается строками, в которых меняется sl_avail:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE new.sl_avail &lt;&gt; old.sl_avail;
(Это выглядит ещё более странно, ведь в INSERT … VALUES не записывается и предложение WHERE,
но планировщик и исполнитель не испытывают затруднений с этим. Они всё равно должны под-
держивать эту функциональность для INSERT … SELECT.)
На третьем шаге добавляется условие исходного дерева, что ещё больше ограничивает результи-
рующий набор, оставляя в нём только строки, которые затронул бы исходный запрос:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE new.sl_avail &lt;&gt; old.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
На четвёртом шаге ссылки на NEW заменяются элементами выходного списка из исходного дерева
запроса или переменными из результирующего отношения:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE 6 &lt;&gt; old.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
На последнем, пятом шаге ссылки на OLD заменяются ссылками на результирующее отношение:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE 6 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
Вот и всё. Так как правило действует в режиме ALSO, мы также выводим исходное дерево запроса.
Таким образом, система правил выдаёт список с двумя деревьями запросов, соответствующими
этим операторам:
1109Система правил
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data
WHERE 6 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
UPDATE shoelace_data SET sl_avail = 6
WHERE sl_name = ‘sl7’;
Они выполняются в показанном порядке и именно это должно делать данное правило.
Благодаря заменам и добавленным условиям в журнал не добавится запись, например, при таком
исходном запросе:
UPDATE shoelace_data SET sl_color = ‘green’
WHERE sl_name = ‘sl7’;
В этом случае исходное дерево запроса не содержит элемент выходного списка для sl_avail, так
что NEW.sl_avail будет заменено переменной shoelace_data.sl_avail. Таким образом, дополни-
тельная команда, созданная правилом, будет такой:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, shoelace_data.sl_avail,
current_user, current_timestamp )
FROM shoelace_data
WHERE shoelace_data.sl_avail &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
Это условие применения не будет выполняться никогда.
Это также будет работать, если исходный запрос изменяет несколько строк. Так, если кто-то вы-
полнит команду:
UPDATE shoelace_data SET sl_avail = 0
WHERE sl_color = ‘black’;
фактически будут изменены четыре строки (sl1, sl2, sl3 и sl4). Но для sl3 значение sl_avail = 0.
В этом случае условие исходного дерева другое, так что это правило выдаёт такое дополнительное
дерево запроса:
INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
current_user, current_timestamp
FROM shoelace_data
WHERE 0 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_color = ‘black’;
. С таким деревом запроса в журнал определённо будут добавлены три записи. И это абсолютно
правильно.
Здесь мы видим, почему важно, чтобы исходное дерево запроса выполнялось в конце. Если бы
оператор UPDATE выполнился сначала, все строки уже получили бы нулевые значения, так что
записывающий в журнал INSERT не нашёл бы строк, в которых 0 &lt;&gt; shoelace_data.sl_avail.
41.4.2. Сочетание с представлениями
Есть один простой вариант защититься от ранее упомянутой возможности выполнять INSERT,
UPDATE или DELETE для представлений, когда это нежелательно — создать правила, просто отбра-
сывающие деревья этих запросов. В нашем случае они будут выглядеть так:
CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
1110Система правил
DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
DO INSTEAD NOTHING;
Если теперь кто-то попытается выполнить одну из этих операций с представлением shoe, система
правил применит эти правила. Так как это правила без действий в режиме INSTEAD, результирую-
щий список деревьев запроса будет пуст и весь запрос аннулируется, так что после работы систе-
мы правил будет нечего оптимизировать и выполнять.
Более сложный вариант — использовать систему правил для создания правил, преобразующих
дерево запроса в выполняющее нужную операцию с реальными таблицами. Чтобы реализовать это
с представлением shoelace, мы создадим следующие правила:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
DO INSTEAD
INSERT INTO shoelace_data VALUES (
NEW.sl_name,
NEW.sl_avail,
NEW.sl_color,
NEW.sl_len,
NEW.sl_unit
);
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
DO INSTEAD
UPDATE shoelace_data
SET sl_name = NEW.sl_name,
sl_avail = NEW.sl_avail,
sl_color = NEW.sl_color,
sl_len = NEW.sl_len,
sl_unit = NEW.sl_unit
WHERE sl_name = OLD.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace
DO INSTEAD
DELETE FROM shoelace_data
WHERE sl_name = OLD.sl_name;
Если вы хотите поддерживать также запросы к представлению с RETURNING, вам надо создать пра-
вила с предложениями RETURNING, которые будут вычислять строки представления. Это обычно
довольно тривиально для представлений с одной нижележащей таблицей, но несколько затрудни-
тельно для представлений с соединением, таких как shoelace. Например, для INSERT это будет
выглядеть так:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
DO INSTEAD
INSERT INTO shoelace_data VALUES (
NEW.sl_name,
NEW.sl_avail,
NEW.sl_color,
NEW.sl_len,
NEW.sl_unit
)
RETURNING
shoelace_data.</em>,
(SELECT shoelace_data.sl_len * u.un_fact
FROM unit u WHERE shoelace_data.sl_unit = u.un_name);
Заметьте, что это одно правило поддерживает запросы и INSERT, и INSERT RETURNING к этому пред-
ставлению — предложение RETURNING просто игнорируется при обычном INSERT.
1111Система правил
Теперь предположим, что на фабрику прибывает партия шнурков с объёмной сопроводительной
накладной. Но вы не хотите вручную вносить по одной записи в представление shoelace. Вместо
этого можно создать две маленькие таблицы: в первую вы будете вставлять записи из накладной,
а вторая пригодится для специального приёма. Для этого мы выполним следующие команды:
CREATE TABLE shoelace_arrive (
arr_name
text,
arr_quant
integer
);
CREATE TABLE shoelace_ok (
ok_name
text,
ok_quant
integer
);
CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
DO INSTEAD
UPDATE shoelace
SET sl_avail = sl_avail + NEW.ok_quant
WHERE sl_name = NEW.ok_name;
Теперь вы можете наполнить таблицу shoelace_arrive данными о поступивших шнурках из на-
кладной:
SELECT * FROM shoelace_arrive;
arr_name | arr_quant
———-+———–
sl3
|
10
sl6
|
20
sl8
|
20
(3 rows)
Взгляните на текущие данные:
SELECT * FROM shoelace;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———-+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
6 | brown
|
60 | cm
|
60
sl3
|
0 | black
|
35 | inch
|
88.9
sl4
|
8 | black
|
40 | inch
|
101.6
sl8
|
1 | brown
|
40 | inch
|
101.6
sl5
|
4 | brown
|
1 | m
|
100
sl6
|
0 | brown
|
0.9 | m
|
90
(8 rows)
Теперь переместите прибывшие шнурки во вторую таблицу:
INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
Проверьте, что получилось:
SELECT * FROM shoelace ORDER BY sl_name;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———-+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
6 | brown
|
60 | cm
|
60
sl4
|
8 | black
|
40 | inch
|
101.6
1112Система правил
sl3
sl8
sl5
sl6
(8 rows)
|
|
|
|
10
21
4
20
|
|
|
|
black
brown
brown
brown
|
|
|
|
35
40
1
0.9
|
|
|
|
inch
inch
m
m
|
|
|
|
88.9
101.6
100
90
SELECT * FROM shoelace_log;
sl_name | sl_avail | log_who| log_when
———+———-+——–+———————————-
sl7
|
6 | Al
| Tue Oct 20 19:14:45 1998 MET DST
sl3
|
10 | Al
| Tue Oct 20 19:25:16 1998 MET DST
sl6
|
20 | Al
| Tue Oct 20 19:25:16 1998 MET DST
sl8
|
21 | Al
| Tue Oct 20 19:25:16 1998 MET DST
(4 rows)
Чтобы получить эти результаты из одного INSERT … SELECT, была проделана большая работа.
Мы подробно опишем всё преобразование дерева запросов в продолжении этой главы. Начнём с
дерева, выданного анализатором запроса:
INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
Теперь применяется первое правило shoelace_ok_ins, создающее такое дерево:
UPDATE shoelace
SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace
WHERE shoelace.sl_name = shoelace_arrive.arr_name;
и отбрасывающее исходный INSERT в shoelace_ok. Этот переписанный запрос снова поступает в
систему правил и второе применяемое правило shoelace_upd выдаёт:
UPDATE shoelace_data
SET sl_name = shoelace.sl_name,
sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
sl_color = shoelace.sl_color,
sl_len = shoelace.sl_len,
sl_unit = shoelace.sl_unit
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
shoelace new, shoelace_data shoelace_data
WHERE shoelace.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = shoelace.sl_name;
Это тоже правило INSTEAD, так что предыдущее дерево запроса отбрасывается. Заметьте, что этот
запрос по-прежнему использует представление shoelace. Но система правил ещё не закончила
свою работу, она продолжает и применяет правило _RETURN, так что мы получаем:
UPDATE shoelace_data
SET sl_name = s.sl_name,
sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
sl_color = s.sl_color,
sl_len = s.sl_len,
sl_unit = s.sl_unit
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
1113Система правил
shoelace new, shoelace_data shoelace_data,
shoelace old, shoelace new,
shoelace_data s, unit u
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name;
Наконец, применяется правило log_shoelace и выдаётся дополнительное дерево запроса:
INSERT INTO shoelace_log
SELECT s.sl_name,
s.sl_avail + shoelace_arrive.arr_quant,
current_user,
current_timestamp
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
shoelace new, shoelace_data shoelace_data,
shoelace old, shoelace new,
shoelace_data s, unit u,
shoelace_data old, shoelace_data new
shoelace_log shoelace_log
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name
AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;
Теперь, обработав все правила, система правил выдаёт построенные деревья запросов.
В итоге мы получаем два дерева запросов, равнозначные следующим операторам SQL:
INSERT INTO shoelace_log
SELECT s.sl_name,
s.sl_avail + shoelace_arrive.arr_quant,
current_user,
current_timestamp
FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
shoelace_data s
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name
AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;
UPDATE shoelace_data
SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive,
shoelace_data shoelace_data,
shoelace_data s
WHERE s.sl_name = shoelace_arrive.sl_name
AND shoelace_data.sl_name = s.sl_name;
В результате вся операция, в ходе которой данные, поступающие из одного отношения, вставля-
ются в другое, вставка преобразуется в изменение третьего, что затем становится изменением
четвёртого, и запись об этом изменении добавляется в пятое, сводится к двум запросам.
Здесь можно заметить маленькую не очень красивую деталь. Как видно, в этих двух запросах таб-
лица shoelace_data фигурирует в списке отношений дважды, тогда как определённо достаточно и
одного вхождения. Планировщик не понимает этого и поэтому для дерева запроса INSERT, выдан-
ного системой правил, будет получен такой план:
Nested Loop
-&gt; Merge Join
-&gt; Seq Scan
-&gt; Sort
1114Система правил
-&gt; Seq Scan on s
Seq Scan
-&gt; Sort
-&gt; Seq Scan on shoelace_arrive
Seq Scan on shoelace_data
-&gt;
-&gt;
Тогда как без лишнего элемента в списке отношений мы получили бы:
Merge Join
-&gt; Seq Scan
-&gt; Sort
-&gt;
-&gt; Seq Scan
-&gt; Sort
-&gt;
Seq Scan on s
Seq Scan on shoelace_arrive
При этом в журнале оказались бы точно такие же записи. Таким образом, применение правил по-
влекло дополнительное сканирование таблицы shoelace_data, в котором не было никакой необхо-
димости. И такое же избыточное сканирование выполняется ещё раз в UPDATE. Отнеситесь к этому
с пониманием, ведь сделать всё это возможным в принципе было действительно сложно.
И наконец, ещё одна, завершающая демонстрация системы правил PostgreSQL и всей её мощи.
Предположим, что вы добавили в базу данных шнурки с экстраординарными цветами:
INSERT INTO shoelace VALUES (‘sl9’, 0, ‘pink’, 35.0, ‘inch’, 0.0);
INSERT INTO shoelace VALUES (‘sl10’, 1000, ‘magenta’, 40.0, ‘inch’, 0.0);
Давайте создадим представление, чтобы убедиться, что шнурки (записи в shoelace) не подходят
ни к каким туфлям. Оно будет определено так:
CREATE VIEW shoelace_mismatch AS
SELECT * FROM shoelace WHERE NOT EXISTS
(SELECT shoename FROM shoe WHERE slcolor = sl_color);
Через него мы получаем наши записи:
SELECT * FROM shoelace_mismatch;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———+———-+———-+——–+———+———–
sl9
|
0 | pink
|
35 | inch
|
88.9
sl10
|
1000 | magenta |
40 | inch
|
101.6
Теперь мы хотим, чтобы шнурки, которые ни к чему не подходят, удалялись из базы данных. Чтобы
немного усложнить задачу для PostgreSQL, мы не будем удалять их непосредственно из таблицы.
Вместо этого мы создадим ещё одно представление:
CREATE VIEW shoelace_can_delete AS
SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;
И удалим их так:
DELETE FROM shoelace WHERE EXISTS
(SELECT * FROM shoelace_can_delete
WHERE sl_name = shoelace.sl_name);
Вуаля:
SELECT * FROM shoelace;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
1115Система правил
sl7
sl4
sl3
sl8
sl10
sl5
sl6
(9 rows)
|
|
|
|
|
|
|
6
8
10
21
1000
4
20
|
|
|
|
|
|
|
brown
black
black
brown
magenta
brown
brown
|
|
|
|
|
|
|
60
40
35
40
40
1
0.9
|
|
|
|
|
|
|
cm
inch
inch
inch
inch
m
m
|
|
|
|
|
|
|
60
101.6
88.9
101.6
101.6
100
90
Так запрос DELETE для представления с ограничивающим условием-подзапросом, использующим в
совокупности 4 вложенных/соединённых представления, с одним из которых тоже связано условие
с подзапросом, задействующим представление, и где используются вычисляемые столбцы пред-
ставлений, переписывается и преобразуется в одно дерево запроса, которое удаляет требуемые
данные из реальной таблицы.
На практике ситуации, когда необходима такая сложная конструкция, встречаются довольно ред-
ко, но, тем не менее, приятно осознавать, что всё это возможно и работает.
41.5. Правила и права
В результате переписывания запросов системой правил PostgreSQL обращение может происходить
не к тем таблицам/представлениям, к которым обращался исходный запрос. С правилами для из-
менения возможна так же и запись в другие таблицы.
Правила перезаписи не имеют отдельного владельца — владельцем правил перезаписи, опреде-
лённых для отношения (таблицы или представления), автоматически считается владелец этого
отношения. Система правил PostgreSQL меняет поведение стандартного механизма управления
доступом. К отношениям, используемым вследствие применения правил, проверяется доступ вла-
дельца правила, но не пользователя, выполняющего запрос. Это значит, что пользователь должен
иметь права, необходимые только для обращения к таблицам/представлениям, которые он явно
упоминает в своих запросах.
Например, представим, что у пользователя есть список телефонных номеров, некоторые из ко-
торых личные, а некоторые должна знать его ассистентка. Он может построить следующую кон-
струкцию:
CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
SELECT person, CASE WHEN NOT private THEN phone END AS phone
FROM phone_data;
GRANT SELECT ON phone_number TO assistant;
Никто, кроме него (и суперпользователей базы данных) не сможет обратиться к таблице
phone_data. Но так как ассистентке было дано (GRANT) соответствующее право, она сможет
выполнить SELECT для представления phone_number. Система правил преобразует SELECT из
phone_number в SELECT из таблицы phone_data. Так как пользователь является владельцем
phone_number, он же считается владельцем правила, доступ на чтение phone_data проверяется для
него, и выполнение запроса разрешается. Проверка прав доступа к phone_number тоже выполня-
ется, но при этом проверяется пользователь, выполняющий запрос, так что обращаться к этому
представлению смогут только сам пользователь и его ассистентка.
Права проверяются правило за правилом. То есть, в данный момент только ассистентка может
видеть открытые телефонные номера. Но она может создать другое представление и дать доступ
к нему всем (роли public), после чего все смогут видеть данные phone_number через представле-
ние ассистентки. Что она не может сделать, так это создать представление, которое обращается
к phone_data напрямую. (Вообще она может это сделать, но такое представление не будет рабо-
тать, так как при любой попытке прочитать его доступ к таблице будет запрещён.) И как только
пользователь заметит, что ассистентка открыла доступ к своему представлению phone_number, он
может лишить её права чтения этого представления. В результате все сразу потеряют доступ и к
представлению ассистентки.
1116Система правил
Может показаться, что такая проверка «правило-за-правилом» представляет уязвимость, но это не
так. Если бы даже этот механизм не работал, ассистентка могла бы создать таблицу со столбцами
как в phone_number и регулярно копировать туда данные. Тогда это были бы её собственные данные
и она могла бы открывать доступ к ним кому угодно. Другими словами, команда GRANT означает «Я
доверяю тебе». Если кто-то, кому вы доверяете, проделывает такие операции, стоит задуматься и,
возможно, лишить его доступа к данным, применив REVOKE.
Хотя представления могут применяться для скрытия содержимого определённых столбцов, как
описано выше, с их помощью нельзя надёжно скрыть данные в невидимых строках, если только не
установлен флаг security_barrier. Например, следующее представление небезопасно:
CREATE VIEW phone_number AS
SELECT person, phone FROM phone_data WHERE phone NOT LIKE ‘412%’;
Может показаться, что всё в порядке, ведь система правил преобразует SELECT из phone_number в
SELECT из phone_data и добавит ограничивающее условие, чтобы выдавались только строки с полем
phone, начинающимся не с 412. Но если пользователь может создавать собственные функции, ему
будет не сложно заставить планировщик выполнять функцию пользователя перед выражением NOT
LIKE. Например:
CREATE FUNCTION tricky(text, text) RETURNS bool AS <script type="math/tex">BEGIN
RAISE NOTICE '% => %', $1, $2;
RETURN true;
END</script> LANGUAGE plpgsql COST 0.0000000000000000000001;
SELECT * FROM phone_number WHERE tricky(person, phone);
Так он сможет получить все имена и номера телефонов из таблицы phone_data через сообщения
NOTICE, так как планировщик решит, что лучше выполнить недорогую функцию tricky перед бо-
лее дорогой операцией NOT LIKE. И даже если пользователь не имеет права создавать новые функ-
ции, он может использовать для подобных атак встроенные функции. (Например, многие функции
приведения показывают входные значения в сообщениях об ошибках.)
Подобные соображения распространяются и на правила для изменения. Применительно к приме-
рам предыдущего раздела, владелец таблиц в базе данных может дать кому-нибудь другому для
представления shoelace права SELECT, INSERT, UPDATE и DELETE, а для shoelace_log только SELECT.
Действие правила, добавляющее записи в журнал, всё равно будет выполняться успешно, а этот
другой пользователь сможет видеть записи в журнале. Но он не сможет создавать поддельные
записи, равно как и модифицировать или удалять существующие. В этом случае нет никакой воз-
можности заставить планировщик изменить порядок операций, так как единственное правило, ко-
торое обращается к shoelace_log — это безусловный INSERT. В более сложных сценариях это мо-
жет быть не так.
Когда требуется, чтобы представление обеспечивало защиту на уровне строк, к нему нужно при-
менить атрибут security_barrier. Это предотвратит утечку содержимого строк из злонамеренно
выбранных функций и операторов до того, как строки будут отфильтрованы представлением. На-
пример, показанное выше представление будет безопасным, если создать его так:
CREATE VIEW phone_number WITH (security_barrier) AS
SELECT person, phone FROM phone_data WHERE phone NOT LIKE ‘412%’;
Представления, созданные с атрибутом security_barrier, могут работать гораздо медленнее, чем
обычные. И вообще говоря, это неизбежно: самый быстрый план должен быть отвергнут, если он
может скомпрометировать защиту. Поэтому данный атрибут по умолчанию не устанавливается.
Планировщик запросов имеет больше свободы, работая с функциями, лишёнными побочных эф-
фектов. Такие функции называются герметичными (LEAKPROOF) и включают только простые ча-
сто используемые операторы, например, операторы равенства. Планировщик запросов может без-
опасно вычислять такие функции в любой момент выполнения запроса, так как при вызове их для
1117Система правил
строк, невидимых пользователю, не просочится никакая информация об этих строках. Более того,
функции, которые не принимают аргументы или которым не передаются аргументы из представ-
ления с барьером безопасности, можно не помечать как LEAKPROOF, чтобы они вышли наружу, так
как они никогда не получат данные из представления. И напротив, функции, которые могут вы-
звать ошибку в зависимости от значений аргументов (например, в случае переполнения или деле-
ния на ноль), герметичными не являются, и могут выдать существенную информацию о невидимых
строках, если будут выполнены перед фильтрами строк.
Важно понимать, что даже представление, созданное с атрибутом security_barrier, остаётся без-
опасным только в том смысле, что содержимое невидимых строк не будет передаваться потенци-
ально небезопасным функциям. Но пользователь может собрать некоторые сведения о невидимых
данных и другими способами; например, он может проанализировать план запроса, полученный
с EXPLAIN, или замерить время выполнения запросов с этим представлением. Злоумышленник мо-
жет сделать определённые выводы об объёме невидимых данных или даже получить некоторую
информацию о распределении данных или наиболее частых значениях (так как всё это отражается
в статистике для оптимизатора и, как следствие, влияет на время выполнения плана или даже на
выбор плана). Если возможность атаки через скрытые каналы вызывает опасения, вероятно, будет
разумным не предоставлять никакой доступ к этим данным.
41.6. Правила и статус команд
Сервер PostgreSQL возвращает строку состояния команды, например, INSERT 149592 1, для каж-
дой получаемой команды. Это довольно прозрачно, когда не задействуются правила, но что про-
изойдёт, если правила перезапишут запрос?
Правила влияют на состояния команды следующим образом:
• Если с запросом не связано безусловное правило INSTEAD, то выполняется заданный исход-
ный запрос и его статус выдаётся как обычно. (Но если определены какие-то условные прави-
ла INSTEAD, к исходному запросу добавляется условие, обратное их условиям применения. Это
может повлиять на число обрабатываемых строк и выводимый статус команды.)
• Если с запросом связано безусловное правило INSTEAD, исходный запрос не выполняется во-
все. В этом случае сервер возвратит статус команды от последнего запроса, вставленного пра-
вилом INSTEAD (условным или безусловным), и тип команды исходного запроса (INSERT, UPDATE
или DELETE). Если правила не добавили подходящего запроса, в возвращённом статусе коман-
ды показывается исходный тип запроса и нули вместо количества строк и OID.
Программист может добиться, чтобы статус команды во втором случае устанавливало нужное пра-
вило INSTEAD, назначив ему имя, стоящее по алфавиту после других активных правил, чтобы это
правило применялось последним.
41.7. Сравнение правил и триггеров
Многие вещи, которые можно сделать с помощью триггеров, можно также реализовать, используя
систему правил PostgreSQL. Однако, используя правила, нельзя реализовать, например, некото-
рые типы ограничений, в частности, внешние ключи. Хотя можно определить правило с ограни-
чивающим условием, которое будет преобразовать команду в NOTHING, если значение ключа не
находится в другой таблице, но при этом неподходящие данные будут отбрасываться молча, а это
не самый лучший вариант. Также, если требуется проверить правильность значений и, обнаружив
неверное значение, выдать ошибку, это нужно делать в триггере.
В этой главе мы разберём использование правил для изменения представлений. Все правила, при-
ведённые в примерах этой главы, можно также заменить триггерами INSTEAD OF для представле-
ний. Написать такие триггеры часто бывает проще, чем разработать правила, особенно если для
изменений применяется сложная логика.
Для тех задач, которые можно решить обоими способами, лучший выбирается в зависимости от
характера использования базы данных. Следует учитывать, что триггер срабатывает для каждой
обрабатываемой строки, а правило изменяет существующий запрос или создаёт ещё один. Поэто-
1118Система правил
му, если один оператор обрабатывает сразу много строк, правило, добавляющее дополнительную
команду, скорее всего, будет работать быстрее, чем триггер, который вызывается для каждой оче-
редной строки и должен каждый раз определять, что с ней делать. Однако триггеры концептуаль-
но гораздо проще правил, и использовать их правильно новичкам гораздо проще.
Давайте рассмотрим пример, показывающий, как выбор в пользу правил вместо триггеров оказы-
вается выигрышным в определённой ситуации. Пусть у нас есть две таблицы:
CREATE TABLE computer (
hostname
text,
manufacturer
text
); – индексированное
– индексированное
CREATE TABLE software (
software
text,
hostname
text
); – индексированное
– индексированное
Обе таблицы содержат несколько тысяч строк, а индексы по полю hostname являются уникальны-
ми. Правило или триггер должны реализовать ограничение, которое удалит строки из таблицы
software, ссылающиеся на удаляемый компьютер. Триггер выполнял бы такую команду:
DELETE FROM software WHERE hostname = $1;
Так как триггер вызывается для каждой отдельной строки, удаляемой из таблицы computer, он
может подготовить и сохранить план этой команды, а затем передавать значение hostname подго-
товленному запросу в параметрах. Правило же можно записать так:
CREATE RULE computer_del AS ON DELETE TO computer
DO DELETE FROM software WHERE hostname = OLD.hostname;
Теперь давайте взглянем на разные варианты удаления. В этом случае:
DELETE FROM computer WHERE hostname = ‘mypc.local.net’;
таблица computer сканируется по индексу (быстро), и команда, выполняемая триггером, так же бу-
дет применять сканирование по индексу (тоже быстро). Дополнительной командой правила будет:
DELETE FROM software WHERE computer.hostname = ‘mypc.local.net’
AND software.hostname = computer.hostname;
Так как созданы все необходимые индексы, планировщик создаст план
Nestloop
-&gt; Index Scan using comp_hostidx on computer
-&gt; Index Scan using soft_hostidx on software
Таким образом, большого различия в скорости между реализациями с триггером и с правилом не
будет.
Теперь мы хотим избавиться от 2000 компьютеров, у которых hostname начинается с old. Это мож-
но сделать двумя командами. Первая:
DELETE FROM computer WHERE hostname &gt;= ‘old’
AND hostname &lt; ‘ole’
Правило преобразует её в:
DELETE FROM software WHERE computer.hostname &gt;= ‘old’ AND computer.hostname &lt; ‘ole’
AND software.hostname = computer.hostname;
с планом:
Hash Join
-&gt; Seq Scan on software
-&gt; Hash
1119Система правил
-&gt;
Index Scan using comp_hostidx on computer
С другой возможной командой:
DELETE FROM computer WHERE hostname ~ ‘^old’;
для запроса, преобразованного правилом, получается следующий план:
Nestloop
-&gt; Index Scan using comp_hostidx on computer
-&gt; Index Scan using soft_hostidx on software
Это показывает, что планировщик не понимает, что ограничение по hostname в computer можно
также использовать для сканирования по индексу в software, когда несколько условий объединя-
ются с помощью AND, что он успешно делает для варианта команды с регулярным выражением.
Триггер будет вызываться для каждой из 2000 удаляемых записей о старых компьютерах, и это
приведёт к одному сканированию индекса в таблице computer и 2000 сканированиям индекса в
таблице software. Реализация с правилом делает это двумя командами, применяющими индексы.
Будет ли правило быстрее при последовательном сканировании, зависит от общего размера таб-
лицы software. С другой стороны, выполнение 2000 команд из триггера через менеджер SPI всё
равно займёт время, даже если все блоки индекса вскоре окажутся в кеше.
В завершение взгляните на эту команду:
DELETE FROM computer WHERE manufacturer = ‘bim’;
Она также может привести к удалению множества строк из таблицы computer. Поэтому триггер
снова пропустит через исполнитель такое же множество команд. Правило же выдаст следующую
команду:
DELETE FROM software WHERE computer.manufacturer = ‘bim’
AND software.hostname = computer.hostname;
План для этой команды снова будет содержать вложенный цикл по двум сканированиям индекса,
но на этот раз с другим индексом таблицы computer:
Nestloop
-&gt; Index Scan using comp_manufidx on computer
-&gt; Index Scan using soft_hostidx on software
Во всех этих случаях дополнительные команды будут более-менее независимыми от числа затра-
гиваемых строк.
Таким образом, правила будут значительно медленнее триггеров, только если их действия приво-
дят к образованию больших и плохо связанных соединений, когда планировщик оказывается бес-
силен.
1120</p>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-041/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-041/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-041/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-040/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
