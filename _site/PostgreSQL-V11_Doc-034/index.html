<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 49. Логическое декодирование &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 49. Логическое декодирование">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 49. Логическое декодирование">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-034/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-034/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 49. Логическое декодирование">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-034/" rel="bookmark" title="Глава 49. Логическое декодирование">Глава 49. Логическое декодирование</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~135 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Часть IV. Клиентские интерфейсы
В этой части документации описываются клиентские программные интерфейсы, включённые в дис-
трибутив PostgreSQL. Все включённые в неё главы можно читать по отдельности. Заметьте, что су-
ществует множество других программных интерфейсов, со своей документацией (некоторые наибо-
лее популярные перечислены в Приложении H). Для изучения этой части нужно уметь работать с
базой данных, используя команды SQL (см. Часть II), и, конечно же, знать язык программирования,
на который ориентирован определённый интерфейс.</p>

<p>Глава 34. libpq — библиотека для языка C</p>

<p>libpq — это интерфейс PostgreSQL для программирования приложений на языке C. Библиотека
libpq содержит набор функций, используя которые клиентские программы могут передавать за-
просы серверу PostgreSQL и принимать результаты этих запросов.
libpq также является базовым механизмом для нескольких других прикладных интерфейсов
PostgreSQL, включая те, что написаны для C++, Perl, Python, Tcl и ECPG. Поэтому некоторые ас-
пекты поведения libpq будут важны для вас, если вы используете один из этих пакетов. В частно-
сти, Раздел 34.14, Раздел 34.15 и Раздел 34.18 описывают поведение, видимое пользователю лю-
бого приложения, использующего libpq.
В конце этой главы включены короткие программы (Раздел 34.21), показывающие, как писать про-
граммы, которые используют libpq. В каталоге src/test/examples дистрибутивного комплекта ис-
ходных текстов приведено несколько завершённых примеров приложений libpq.
Клиентские программы, которые используют libpq, должны включать заголовочный файл libpq-
fe.hи должны компоноваться с библиотекой libpq.</p>

<p>34.1. Функции управления подключением к базе данных</p>

<p>Следующие функции имеют дело с созданием подключения к серверу PostgreSQL. Прикладная
программа может иметь несколько подключений к серверу, открытых одновременно. (Одна из
причин этого заключается в необходимости доступа к более чем одной базе данных.) Каждое со-
единение представляется объектом PGconn, который можно получить от функций PQconnectdb,
PQconnectdbParams или PQsetdbLogin. Обратите внимание, что эти функции всегда возвратят нену-
левой указатель на объект, если только, возможно, не осталось слишком мало памяти даже для
того, чтобы выделить её для объекта PGconn. Прежде чем передавать запросы через объект под-
ключения, следует вызвать функцию PQstatus для проверки возвращаемого значения в случае
успешного подключения.
Предупреждение
Если к базе данных, которая не приведена в соответствие шаблону безопасного исполь-
зования схем, имеют доступ недоверенные пользователи, начинайте сеанс с удаления
доступных им для записи схем из пути поиска (search_path). Для этого можно присво-
ить параметру с ключом options значение -csearch_path=. Также можно выполнить
PQexec(соединение, “SELECT pg_catalog.set_config(‘search_path’, ‘’, false)”)
после подключения. Это касается не только psql, но и любых других интерфейсов для
выполнения произвольных SQL-команд.
Предупреждение
В системе Unix создание дочернего процесса на основе процесса, уже имеющего от-
крытые подключения с помощью libpq, может привести к непредсказуемым результа-
там, потому что родительский и дочерний процессы совместно используют одни и те
же сокеты и ресурсы операционной системы. По этой причине подобный подход не
рекомендуется. Однако использование системного вызова exec из дочернего процесса
для загрузки нового исполняемого файла является безопасным.
Примечание
В системе Windows существует способ повышения производительности, при котором
единственное соединение с базой данных повторно стартует и останавливается. На
754libpq — библиотека для языка C
внутреннем уровне libpq вызывает WSAStartup() и WSACleanup() для старта и оста-
новки соединения соответственно. WSAStartup() увеличивает на единицу внутренний
счётчик ссылок в библиотеке Windows, который уменьшается на единицу при вызове
WSACleanup(). Когда счётчик ссылок равен единице, вызов WSACleanup() освобождает
все ресурсы, и все библиотеки DLL выгружаются. Это дорогостоящая операция. Для
её избежания приложение может “вручную” вызвать WSAStartup(), чтобы ресурсы не
были освобождены, когда закрыто последнее соединение с базой данных.
PQconnectdbParams
Создаёт новое подключение к серверу баз данных.
PGconn <em>PQconnectdbParams(const char * const *keywords,
const char * const *values,
int expand_dbname);
Эта функция открывает новое соединение с базой данных, используя параметры, содержащи-
еся в двух массивах, завершающихся символом NULL. Первый из них, keywords, определяется
как массив строк, каждая из которых представляет собой ключевое слово. Второй, values, даёт
значение для каждого ключевого слова. В отличие от PQsetdbLogin, описываемой ниже, набор
параметров может быть расширен без изменения сигнатуры функции, поэтому использование
данной функции (или её неблокирующих аналогов PQconnectStartParams и PQconnectPoll) яв-
ляется предпочтительным при разработке новых приложений.
Ключевые слова-параметры, распознаваемые в настоящее время, приведены в Подразде-
ле 34.1.2.
Когда expand_dbname имеет ненулевое значение, тогда в качестве значения, соответствующего
ключевому слову dbname, может быть указана строка подключения. Только первый экземпляр
dbname расширяется таким образом, а все последующие значения dbname будут обработаны
как обычные имена базы данных. Дополнительные сведения о возможных форматах строки
подключения можно найти в Подразделе 34.1.1.
Передаваемые массивы могут быть пустыми. В этом случае используются все параметры по
умолчанию. Массивы могут также содержать один или более элементов и должны быть согла-
сованы по длине. Обработка прекращается, когда найден первый элемент со значением NULL
в массиве keywords.
Если какой-либо параметр имеет значение NULL или содержит пустую строку, проверяется зна-
чение соответствующей переменной окружения (см. Раздел 34.14). Если и переменная окру-
жения не установлена, используется встроенное значение по умолчанию.
В общем случае ключевые слова обрабатываются в индексном порядке, начиная с начала этих
массивов. Вследствие такого подхода, когда ключевые слова повторяются, сохраняется послед-
нее обработанное значение. Следовательно, за счёт соответствующего расположения ключе-
вого слова dbname можно регулировать, что может быть переопределено строкой conninfo, а
что не может.
PQconnectdb
Создаёт новое подключение к серверу баз данных.
PGconn *PQconnectdb(const char *conninfo);
Эта функция открывает новое соединение с базой данных, используя параметры, полученные
из строки conninfo.
Передаваемая строка может быть пустой. В этом случае используются все параметры по умол-
чанию. Она также может содержать одно или более значений параметров, разделённых про-
белами, или URI. За подробностями обратитесь к Подразделу 34.1.1.
755libpq — библиотека для языка C
PQsetdbLogin
Создаёт новое подключение к серверу баз данных.
PGconn *PQsetdbLogin(const
const
const
const
const
const
const
char
char
char
char
char
char
char
*pghost,
*pgport,
*pgoptions,
*pgtty,
*dbName,
*login,
*pwd);
Это предшественница функции PQconnectdb с фиксированным набором параметров. Она име-
ет такую же функциональность, за исключением того, что непереданные параметры всегда
принимают значения по умолчанию. Подставьте NULL или пустую строку в качестве любого из
фиксированных параметров, которые должны принять значения по умолчанию.
Если параметр dbName содержит знак = или имеет допустимый префикс URI для подключения,
то он воспринимается в качестве строки conninfo точно таким же образом, как если бы он был
передан функции PQconnectdb, а оставшиеся параметры затем применяются, как указано для
PQconnectdbParams.
PQsetdb
Создаёт новое подключение к серверу баз данных.
PGconn *PQsetdb(char
char
char
char
char
*pghost,
*pgport,
*pgoptions,
*pgtty,
*dbName);
Это макрос, который вызывает PQsetdbLogin с нулевыми указателями в качестве значений па-
раметров login и pwd. Обеспечивает обратную совместимость с очень старыми программами.
PQconnectStartParams
PQconnectStart
PQconnectPoll
Создают подключение к серверу баз данных неблокирующим способом.
PGconn *PQconnectStartParams(const char * const *keywords,
const char * const *values,
int expand_dbname);
PGconn *PQconnectStart(const char *conninfo);
PostgresPollingStatusType PQconnectPoll(PGconn *conn);
Три эти функции используются для того, чтобы открыть подключение к серверу баз данных
таким образом, чтобы поток исполнения вашего приложения не был заблокирован при выпол-
нении удалённой операции ввода/вывода в процессе подключения. Суть этого подхода в том,
чтобы ожидание завершения операций ввода/вывода могло происходить в главном цикле при-
ложения, а не в внутри функций PQconnectdbParams или PQconnectdb, с тем, чтобы приложение
могло управлять этой операцией параллельно с другой работой.
С помощью функции PQconnectStartParams подключение к базе данных выполняется, исполь-
зуя параметры, взятые из массивов keywords и values, а управление осуществляется с помо-
щью expand_dbname, как описано выше для PQconnectdbParams.
С помощью функции PQconnectStart подключение к базе данных выполняется, используя па-
раметры, взятые из строки conninfo, как описано выше для PQconnectdb.
756libpq — библиотека для языка C
Ни PQconnectStartParams, ни PQconnectStart, ни PQconnectPoll не заблокируются до тех пор,
пока выполняется ряд ограничений:
• Параметр hostaddr должен использоваться так, чтобы для разрешения заданного име-
ни не требовалось выполнять запросы DNS. Подробнее этот параметр описан в Подразде-
ле 34.1.2.
• Если вы вызываете PQtrace, обеспечьте, чтобы поток, в который выводится трассировоч-
ная информация, не заблокировался.
• Перед вызовом PQconnectPoll вы должны перевести сокет в соответствующее состояние,
как описано ниже.
Чтобы начать неблокирующий запрос на подключение, вызовите PQconnectStart или
PQconnectStartParams. Если результатом будет null, значит libpq не смогла выделить память
для новой структуры PGconn. В противном случае возвращается действительный указатель
PGconn (хотя он ещё не представляет установленное подключение к базе данных). Затем вызо-
вите PQstatus(conn). Если результатом будет CONNECTION_BAD, значит попытка подключения
уже не будет успешной, возможно, из-за неверных параметров.
Если вызов PQconnectStart или PQconnectStartParams оказался успешным, теперь нужно опро-
сить libpq для продолжения процедуры подключения. Вызовите PQsocket(conn) для получения
дескриптора нижележащего сокета, через который устанавливается соединение. (Внимание:
этот сокет может меняться от вызова к вызову PQconnectPoll.) Организуйте цикл таким об-
разом: если PQconnectPoll(conn) при последнем вызове возвращает PGRES_POLLING_READING,
ожидайте, пока сокет не окажется готовым для чтения (это покажет функция select(),
poll() или подобная системная функция). Затем снова вызовите PQconnectPoll(conn). Если
же PQconnectPoll(conn) при последнем вызове возвратила PGRES_POLLING_WRITING, дождитесь
готовности сокета к записи, а затем снова вызовите PQconnectPoll(conn). На первой итерации,
то есть когда вы ещё не вызывали PQconnectPoll, реализуйте то же поведение, что и после по-
лучения PGRES_POLLING_WRITING. Продолжайте этот цикл, пока PQconnectPoll(conn) не выдаст
значение PGRES_POLLING_FAILED, сигнализирующее об ошибке при установлении соединения,
или PGRES_POLLING_OK, показывающее, что соединение установлено успешно.
В любое время в процессе подключения его состояние можно проверить, вызвав PQstatus. Если
этот вызов возвратит CONNECTION_BAD, значит, процедура подключения завершилась сбоем; ес-
ли вызов возвратит CONNECTION_OK, значит, соединение готово. Оба эти состояния можно опре-
делить на основе возвращаемого значения функции PQconnectPoll, описанной выше. Другие
состояния могут также иметь место в течение (и только в течение) асинхронной процедуры
подключения. Они показывают текущую стадию процедуры подключения и могут быть полез-
ны, например, для предоставления обратной связи пользователю. Вот эти состояния:
CONNECTION_STARTED
Ожидание, пока соединение будет установлено.
CONNECTION_MADE
Соединение установлено; ожидание отправки.
CONNECTION_AWAITING_RESPONSE
Ожидание ответа от сервера.
CONNECTION_AUTH_OK
Аутентификация получена; ожидание завершения запуска серверной части.
CONNECTION_SSL_STARTUP
Согласование SSL-шифрования.
757libpq — библиотека для языка C
CONNECTION_SETENV
Согласование значений параметров, зависящих от программной среды.
CONNECTION_CHECK_WRITABLE
Проверка, можно ли через подключение выполнять пишущие транзакции.
CONNECTION_CONSUME
Прочтение всех оставшихся ответных сообщений через подключение.
Заметьте, что, хотя эти константы и сохранятся (для поддержания совместимости), приложе-
ние никогда не должно полагаться на то, что они появятся в каком-то конкретном порядке или
вообще появятся, а также на то, что состояние всегда примет одно из этих документированных
значений. Приложение может сделать что-то наподобие:
switch(PQstatus(conn))
{
case CONNECTION_STARTED:
feedback = “Подключение…”;
break;
case CONNECTION_MADE:
feedback = “Подключён к серверу…”;
break;
.
.
.
default:
feedback = “Подключение…”;
}
Параметр подключения connect_timeout игнорируется, когда используется PQconnectPoll;
именно приложение отвечает за принятие решения о том, является ли истекшее время чрез-
мерным. В противном случае вызов PQconnectStart с последующим вызовом PQconnectPoll в
цикле будут эквивалентны вызову PQconnectdb.
Заметьте, что если функция PQconnectStart или PQconnectStartParams возвращает ненулевой
указатель, вы должны вызвать PQfinish, закончив его использование, чтобы освободить полу-
ченную структуру и все связанные с ней блоки памяти. Это нужно сделать, даже если попытка
подключения не последует или окажется неуспешной.
PQconndefaults
Возвращает значения по умолчанию для параметров подключения.
PQconninfoOption *PQconndefaults(void);
typedef struct
{
char
*keyword;
char
*envvar;
char
*compiled;
компиляции */
char
*val;
char
*label;
char
*dispchar;
/</em> Ключевое слово для данного параметра <em>/
/</em> Имя альтернативной переменной окружения <em>/
/</em> Альтернативное значение по умолчанию, назначенное при
/* Текущее значение параметра или NULL <em>/
/</em> Обозначение этого поля в диалоге подключения <em>/
/</em> Показывает, как отображать это поле
в диалоге подключения. Значения следующие:
“”
Отображать введённое значение “как есть”
“<em>”
Поле пароля — скрывать значение
“D”
Параметр отладки — не показывать по умолчанию */
758libpq — библиотека для языка C
int
dispsize;
} PQconninfoOption;
/</em> Размер поля в символах для диалога */
Возвращает массив параметров подключения. Он может использоваться для определения всех
возможных параметров PQconnectdb и их текущих значений по умолчанию. Возвращаемое зна-
чение указывает на массив структур PQconninfoOption, который завершается элементом, име-
ющим нулевой указатель keyword. Если выделить память не удалось, то возвращается нулевой
указатель. Обратите внимание, что текущие значения по умолчанию (поля val) будут зависеть
от переменных среды и другого контекста. Отсутствующий или неверный сервисный файл бу-
дет молча проигнорирован. Вызывающие функции должны рассматривать данные параметров
по умолчанию как “только для чтения”.
После обработки массива параметров освободите память, передав его функции PQconninfoFree.
Если этого не делать, то при каждом вызове функции PQconndefaults будут происходить
небольшие “утечки” памяти.
PQconninfo
Возвращает параметры подключения, используемые действующим соединением.
PQconninfoOption *PQconninfo(PGconn *conn);
Возвращает массив параметров подключения. Он может использоваться для определения всех
возможных параметров PQconnectdb и значений, которые были использованы для подключения
к серверу. Возвращаемое значение указывает на массив структур PQconninfoOption, который
завершается элементом, имеющим нулевой указатель keyword. Все замечания, приведённые
выше для PQconndefaults, также справедливы и для результата PQconninfo.
PQconninfoParse
Возвращает разобранные параметры подключения, переданные в строке подключения.
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
Разбирает строку подключения и возвращает результирующие параметры в виде массива; воз-
вращает NULL, если возникают проблемы при разборе строки подключения. Эту функцию мож-
но использовать для извлечения параметров функции PQconnectdb из предоставленной строки
подключения. Возвращаемое значение указывает на массив структур PQconninfoOption, кото-
рый завершается элементом, имеющим нулевой указатель keyword.
Все разрешённые параметры будут присутствовать в результирующем массиве, но
PQconninfoOption для любого параметра, не присутствующего в строке подключения, будет
иметь значение NULL в поле val; значения по умолчанию не подставляются.
Если errmsg не равно NULL, тогда в случае успеха *errmsg присваивается NULL, а в противном
случае – адрес строки сообщения об ошибке, объясняющего проблему. Память для этой строки
выделяет функция malloc. (Также возможна ситуация, когда *errmsg будет установлено в NULL,
и при этом функция возвращает NULL. Это указывает на нехватку памяти.)
После обработки массива параметров освободите память, передав его функции PQconninfoFree.
Если этого не делать, тогда некоторое количество памяти будет утекать при каждом вызове
PQconninfoParse. И наоборот, если произошла ошибка и errmsg не равно NULL, обязательно
освободите память, занимаемую строкой сообщения об ошибке, используя PQfreemem.
PQfinish
Закрывает соединение с сервером. Также освобождает память, используемую объектом PGconn.
void PQfinish(PGconn *conn);
Обратите внимание, что даже если попытка подключения к серверу потерпела неудачу (как
показывает PQstatus), приложение все равно должно вызвать PQfinish, чтобы освободить па-
759libpq — библиотека для языка C
мять, используемую объектом PGconn. Указатель PGconn не должен использоваться повторно
после того, как была вызвана функция PQfinish.
PQreset
Переустанавливает канал связи с сервером.
void PQreset(PGconn *conn);
Эта функция закроет подключение к серверу, а потом попытается восстановить подключение к
тому же серверу, используя все те же параметры, которые использовались прежде. Это может
быть полезным для восстановления после ошибки, если работающее соединение оказалось по-
терянным.
PQresetStart
PQresetPoll
Переустанавливает канал связи с сервером неблокирующим способом.
int PQresetStart(PGconn *conn);
PostgresPollingStatusType PQresetPoll(PGconn *conn);
Эти функции закроют подключение к серверу, а потом попытаются восстановить подключе-
ние к тому же серверу, используя все те же параметры, которые использовались прежде. Это
может быть полезным для восстановления после ошибки, если работающее соединение ока-
залось потерянным. Они отличаются от PQreset (см. выше) тем, что действуют неблокирую-
щим способом. На эти функции налагаются те же ограничения, что и на PQconnectStartParams,
PQconnectStart и PQconnectPoll.
Чтобы приступить к переустановке подключения, вызовите PQresetStart. Если она возвратит
0, переустановка завершилась неудачно. Если она возвратит 1, опросите результат переуста-
новки, используя PQresetPoll, точно таким же образом, как если бы вы создавали подключе-
ние, используя PQconnectPoll.
PQpingParams
PQpingParams сообщает состояние сервера. Она принимает параметры подключения, иден-
тичные тем, что получает функция PQconnectdbParams, описанная выше. Нет необходимости
предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы получить со-
стояние сервера. Однако, если предоставлены некорректные значения, сервер занесёт в жур-
нал неудачную попытку подключения.
PGPing PQpingParams(const char * const *keywords,
const char * const *values,
int expand_dbname);
Функция возвращает одно из следующих значений:
PQPING_OK
Сервер работает и, по-видимому, принимает подключения.
PQPING_REJECT
Сервер работает, но находится в состоянии, которое запрещает подключения (запуск, за-
вершение работы или восстановление после аварийного отказа).
PQPING_NO_RESPONSE
Контакт с сервером не удался. Это может указывать на то, что сервер не запущен или что-то
не в порядке с параметрами данного подключения (например, неверный номер порта), или
имеет место проблема с возможностью соединения по сети (например, брандмауэр блоки-
рует запрос на подключение).
760libpq — библиотека для языка C
PQPING_NO_ATTEMPT
Никакой попытки установить контакт с сервером сделано не было, поскольку предоставлен-
ные параметры были явно некорректными, или имела место какая-то проблема на стороне
клиента (например, нехватка памяти).
PQping
PQping сообщает состояние сервера. Она принимает параметры подключения, идентичные тем,
что получает функция PQconnectdb, описанная выше. Нет необходимости предоставлять кор-
ректные имя пользователя, пароль или имя базы данных, чтобы получить состояние сервера.
Однако, если предоставлены некорректные значения, сервер занесёт в журнал неудачную по-
пытку подключения.
PGPing PQping(const char *conninfo);
Возвращаемые значения такие же, как и для PQpingParams.
34.1.1. Строки параметров подключения
Ряд функций libpq разбирают заданную пользователем строку для извлечения параметров под-
ключения. Есть два принятых формата этих строк: простой ключ = значение и URI. Строки URI в
основном соответствуют RFC 3986, но могут содержать также строки подключения с несколькими
узлами, как описано ниже.
34.1.1.1. Строки параметров подключения вида “ключ/значение”
Согласно первому формату, установка каждого параметра выполняется в форме keyword = value.
Пробелы вокруг знака равенства не являются обязательными. Для записи пустого значения или
значения, содержащего пробелы, заключите его в одинарные кавычки, например, keyword = ‘a
value’. Одинарные кавычки и символы обратной косой черты внутри значения нужно обязательно
экранировать с помощью символа обратной косой черты, т. е., ' и \.
Пример:
host=localhost port=5432 dbname=mydb connect_timeout=10
Ключевые слова-параметры, распознаваемые в настоящее время, приведены в Подразделе 34.1.2.
34.1.1.2. URI для подключения
Общая форма URI для подключения такова:
postgresql://[user[:password]@][netloc][:port][,…][/dbname][?param1=value1&amp;…]
В качестве обозначения схемы URI может использоваться либо postgresql://, либо postgres://.
Каждая из частей URI является необязательной. В следующих примерах показано правильное ис-
пользование синтаксиса URI:
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
Компоненты иерархической части URI можно также передавать в виде параметров. Например:
postgresql:///mydb?host=localhost&amp;port=5433
Для включения символов, имеющих специальное значение, в любой части URI можно применять
URL-кодирование (с использованием %), например заменить = на %3D.
761libpq — библиотека для языка C
Любые параметры соединения, не соответствующие ключевым словам, приведённым в Подразде-
ле 34.1.2, игнорируются, а предупреждающее сообщение об этом направляется на stderr.
Для улучшения совместимости с теми URI, которые служат для подключения через JDBC, все эк-
земпляры параметра ssl=true преобразуются в sslmode=require.
Сервер можно представить либо доменным именем, либо IP-адресом. При использовании протоко-
ла IPv6 нужно заключить адрес в квадратные скобки:
postgresql://[2001:db8::1234]/database
Компонент “host” интерпретируется в соответствии с описанием параметра host. В частности, если
этот компонент пуст или начинается с символа косой черты, выбирается соединение через Unix-
сокеты, а в противном случае инициируется соединение по TCP/IP. Обратите внимание, однако,
что символ косой черты в иерархической части URI является зарезервированным. Поэтому, чтобы
указать нестандартный каталог Unix-сокета, нужно поступить одним из двух способов: не задавать
сервер в URI и указать сервер в качестве параметра, либо закодировать путь в компоненте “host”
с процентами:
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
В одном URI можно задать несколько компонентов узлов, каждый с необязательным указанием
порта. URI вида postgresql://host1:port1,host2:port2,host3:port3/ равнозначно строке под-
ключения вида host=host1,host2,host3 port=port1,port2,port3. Эти узлы будут перебираться
по очереди, пока не будет установлено подключение.
34.1.1.3. Указание нескольких узлов
В строке подключения можно задать несколько узлов, к которым клиент будет пытаться подклю-
читься в заданном порядке. Параметры host, hostaddr и port в формате ключ/значение принима-
ют список значений, разделённых запятыми. В каждом параметре должно содержаться одинако-
вое число элементов, чтобы, например, первый элемент hostaddr соответствовал первому элемен-
ту host, второй — второму host и так далее. Исключение составляет port — если этот параметр
содержит только один элемент, он применяется ко всем узлам.
В формате URI внутри компонента host можно указать несколько пар host:port, разделённых
запятыми.
В любом формате одно имя узла может переводиться в несколько сетевых адресов. Например,
часто бывает, что один узел имеет и адрес IPv4, и адрес IPv6.
Когда задаются несколько узлов или когда одно имя узла переводится в несколько адресов, все
узлы и адреса перебираются по порядку, пока подключение не будет установлено. Если ни один
из адресов не будет доступен, произойдёт сбой подключения. Если подключение устанавливается
успешно, но происходит ошибка аутентификации, остальные узлы в списке не перебираются.
Если используется файл паролей, в нём можно задать разные пароли для разных узлов. Все осталь-
ные параметры подключения будут одинаковыми для всех узлов; например, нельзя задать для раз-
ных узлов различные имена пользователей.
34.1.2. Ключевые слова-параметры
Ключевые слова-параметры, распознаваемые в настоящее время, следующие:
host
Имя компьютера для подключения.Если это имя начинается с косой черты, оно выбирает под-
ключение через Unix-сокет, а не через TCP/IP, и задаёт имя каталога, содержащего файл со-
кета. По умолчанию, если параметр host отсутствует или пуст, выполняется подключение к
Unix-сокету в /tmp (или в том каталоге сокетов, который был задан при сборке PostgreSQL).
762libpq — библиотека для языка C
В системах, где Unix-сокеты не поддерживаются, по умолчанию выполняется подключение к
localhost.
Также принимается разделённый запятыми список имён узлов; при этом данные имена будут
перебираться по порядку. Для пустых элементов списка применяется поведение по умолчанию,
описанное выше. За подробностями обратитесь к Подразделу 34.1.1.3.
hostaddr
Числовой IP-адрес компьютера для подключения. Он должен быть представлен в стандартном
формате адресов IPv4, например, 172.28.40.9. Если ваша машина поддерживает IPv6, вы мо-
жете использовать и эти адреса. Связь по протоколу TCP/IP используется всегда, когда в каче-
стве этого параметра передана непустая строка.
Использование hostaddr вместо host позволяет приложению избежать поиска на сервере имён,
что может быть важно для приложений, имеющих ограничения по времени. Однако имя ком-
пьютера требуется для методов аутентификации GSSAPI или SSPI, а также для проверки полно-
мочий на основе SSL-сертификатов в режиме verify-full. Применяются следующие правила:
• Если адрес host задаётся без hostaddr, осуществляется разрешение имени. (При исполь-
зовании PQconnectPoll разрешение производится, когда PQconnectPoll рассматривает это
имя в первый раз, и может заблокировать PQconnectPoll на неопределённое время.)
• Если указан hostaddr, а host не указан, тогда значение hostaddr даёт сетевой адрес серве-
ра. Попытка подключения завершится неудачей, если метод аутентификации требует на-
личия имени компьютера.
• Если указаны как host, так и hostaddr, тогда значение hostaddr даёт сетевой адрес серве-
ра, а значение host игнорируется, если только метод аутентификации его не потребует. В
таком случае оно будет использоваться в качестве имени компьютера.
Заметьте, что аутентификация может завершится неудачей, если host не является именем сер-
вера с сетевым адресом hostaddr. Также заметьте, что когда указывается и host, и hostaddr,
соединение в файле паролей идентифицируется по значению host (см. Раздел 34.15).
Также принимается разделённый запятыми список значений hostaddr, при этом данные узлы
будут перебираться по порядку. Вместо пустого элемента в этом списке будет подставлено имя
соответствующего узла или, если и оно не определено, имя узла по умолчанию. За подробно-
стями обратитесь к Подразделу 34.1.1.3.
Если не указаны ни имя компьютера, ни его адрес, libpq будет производить подключение, ис-
пользуя локальный Unix-сокет; в системах, не поддерживающих Unix-сокеты, она будет пытать-
ся подключиться к localhost.
port
Номер порта, к которому нужно подключаться на сервере, либо расширение имени файла со-
кета для соединений через Unix-сокеты.Если в параметрах host или hostaddr задано несколько
серверов, в данном параметре может задаваться через запятую список портов такой же длины,
либо может указываться один номер порта для всех узлов. Пустая строка или пустой элемент
в списке через запятую воспринимается как номер порта по умолчанию, установленный при
сборке PostgreSQL.
dbname
Имя базы данных. По умолчанию оно совпадает с именем пользователя. В определённых
контекстах это значение проверяется на соответствие расширенным форматам; см. Подраз-
дел 34.1.1 для получения подробной информации.
user
Имя пользователя PostgreSQL, используемое для подключения. По умолчанию используется то
же имя, которое имеет в операционной системе пользователь, от лица которого выполняется
приложение.
763libpq — библиотека для языка C
password
Пароль, используемый в случае, когда сервер требует аутентификации по паролю.
passfile
Задаёт имя файла, в котором будут храниться пароли (см. Раздел  34.15). По умолчанию это
~/.pgpass или %APPDATA%\postgresql\pgpass.conf в Microsoft Windows. (Отсутствие этого фай-
ла не считается ошибкой.)
connect_timeout
Максимальное время ожидания подключения (задаётся десятичным целым числом, например:
10). При нуле, отрицательном или неопределённом значении ожидание будет бесконечным.
Минимальный допустимый тайм-аут равен 2 секундам; таким образом, значение 1 восприни-
мается как 2. Этот тайм-аут применяется для каждого отдельного IP-адреса или имени сервера.
Например, если вы зададите адреса двух серверов и значение connect_timeout будет равно 5,
тайм-аут при неудачной попытке подключения к каждому серверу произойдёт через 5 секунд,
а общее время ожидания подключения может достигать 10 секунд.
client_encoding
Этим устанавливается конфигурационный параметр client_encoding для данного подключе-
ния. В дополнение к значениям, которые принимает соответствующий параметр сервера, вы
можете использовать значение auto. В этом случае правильная кодировка определяется на ос-
нове текущей локали на стороне клиента (в системах Unix это переменная системного окруже-
ния LC_CTYPE).
options
Задаёт параметры командной строки, которые будут отправлены серверу при установлении со-
единения. Например, значение -c geqo=off установит для параметра сеанса geqo значение
off. Пробелы в этой строке считаются разделяющими аргументы командной строки, если толь-
ко перед ними не стоит обратная косая черта (); чтобы записать собственно обратную косую
черту, её нужно продублировать (\). Подробное описание возможных параметров можно най-
ти в Главе 19.
application_name
Устанавливает значение для конфигурационного параметра application_name.
fallback_application_name
Устанавливает альтернативное значение для конфигурационного параметра application_name.
Это значение будет использоваться, если для параметра application_name не было передано
никакого значения с помощью параметров подключения или переменной системного окруже-
ния PGAPPNAME. Задание альтернативного имени полезно для универсальных программ-утилит,
которые желают установить имя приложения по умолчанию, но позволяют пользователю из-
менить его.
keepalives
Управляет использованием сообщений keepalive протокола TCP на стороне клиента. Значение
по умолчанию равно 1, что означает использование сообщений. Вы можете изменить его на 0,
если эти сообщения не нужны. Для соединений, установленных через Unix-сокеты, этот пара-
метр игнорируется.
keepalives_idle
Управляет длительностью периода отсутствия активности, выраженного числом секунд, по ис-
течении которого TCP должен отправить сообщение keepalive серверу. При значении 0 дей-
ствует системное значение. Этот параметр игнорируется для соединений, установленных че-
764libpq — библиотека для языка C
рез Unix-сокеты, или если сообщения keepalive отключены. Он поддерживается только в систе-
мах, воспринимающих параметр сокета TCP_KEEPIDLE или равнозначный, и в Windows; в других
системах он не оказывает влияния.
keepalives_interval
Управляет количеством секунд, по прошествии которых сообщение keepalive протокола TCP,
получение которого не подтверждено сервером, должно быть отправлено повторно. При зна-
чении 0 действует системное значение. Этот параметр игнорируется для соединений, уста-
новленных через Unix-сокеты, или если сообщения keepalive отключены. Он поддерживается
только в системах, воспринимающих параметр сокета TCP_KEEPINTVL или равнозначный, и в
Windows; в других системах он не оказывает влияния.
keepalives_count
Управляет количеством сообщений keepalive протокола TCP, которые могут быть потеряны,
прежде чем соединение клиента с сервером будет признано неработающим. Нулевое значение
этого параметра указывает, что будет использоваться системное значение по умолчанию. Этот
параметр игнорируется для соединений, установленных через Unix-сокеты, или если сообще-
ния keepalive отключены. Он поддерживается только в системах, воспринимающих параметр
сокета TCP_KEEPCNT или равнозначный; в других системах он не оказывает влияния.
tty
Игнорируется (прежде он указывал, куда направить вывод отладочных сообщений сервера).
replication
Этот параметр определяет, должно ли подключение использовать протокол репликации вме-
сто обычного протокола. Этот вариант используют внутри механизмы репликации PostgreSQL
и такие средства, как pg_basebackup, но он может также применяться и сторонними приложе-
ниями. За подробным описанием протокола репликации обратитесь к Разделу 53.4.
Поддерживаются следующие значения этого параметра, без учёта регистра:
true, on, yes, 1
Подключение осуществляется в режиме физической репликации.
database
Подключение осуществляется в режиме логической репликации, целевая база данных за-
даётся параметром dbname.
false, off, no, 0
Подключение выполняется в обычном режиме; это поведение по умолчанию.
В режиме физической или логической репликации может использоваться только протокол про-
стых запросов.
sslmode
Этот параметр определяет, будет ли согласовываться с сервером защищённое SSL-соединение
по протоколу TCP/IP, и если да, то в какой очередности. Всего предусмотрено шесть режимов:
disable
следует пытаться установить только соединение без использования SSL
allow
сначала следует попытаться установить соединение без использования SSL; если попытка
будет неудачной, нужно попытаться установить SSL-соединение
765libpq — библиотека для языка C
prefer (по умолчанию)
сначала следует попытаться установить SSL-соединение; если попытка будет неудачной,
нужно попытаться установить соединение без использования SSL
require
следует попытаться установить только SSL-соединение. Если присутствует файл корневого
центра сертификации, то нужно верифицировать сертификат таким же способом, как будто
был указан параметр verify-ca
verify-ca
следует попытаться установить только SSL-соединение, при этом проконтролировать, чтобы
сертификат сервера был выпущен доверенным центром сертификации (CA)
verify-full
следует попытаться установить только SSL-соединение, при этом проконтролировать, чтобы
сертификат сервера был выпущен доверенным центром сертификации (CA) и чтобы имя
запрошенного сервера соответствовало имени в сертификате
В Разделе 34.18 приведено подробное описание работы этих режимов.
sslmode игнорируется при использовании Unix-сокетов. Если PostgreSQL скомпилирован без
поддержки SSL, использование параметров require, verify-ca или verify-full приведёт к
ошибке, в то время как параметры allow и prefer будут приняты, но libpq в действительности
не будет пытаться установить SSL-соединение.
requiressl
Использовать этот параметр не рекомендуется, в качестве замены предлагается установить
sslmode.
Если установлено значение 1, то требуется SSL-соединение с сервером (это эквивалентно
sslmode require). libpq в таком случае откажется подключаться, если сервер не принимает SSL-
соединений. Если установлено значение 0 (по умолчанию), тогда libpq будет согласовывать тип
подключения с сервером (эквивалентно sslmode prefer). Этот параметр доступен, если только
PostgreSQL скомпилирован с поддержкой SSL.
sslcompression
Если установлено значение 1, данные, передаваемые через SSL-соединения, будут сжиматься.
Если установлено значение 0 (по умолчанию), сжатие будет отключено. Этот параметр игно-
рируется, если установлено подключение без SSL.
Сжатие SSL в настоящее время считается небезопасным, и использовать его уже не рекомен-
дуется. В OpenSSL 1.1.0 сжатие отключено по умолчанию, к тому же во многих дистрибутивах
оно отключается и с более ранними версиями. А если сервер не поддерживает сжатие, включе-
ние этого параметра не окажет никакого влияния. С другой стороны, OpenSSL до версии 1.0.0
не поддерживал отключение сжатия, так что с такими версиями этот параметр игнорируется,
и использование сжатия зависит от сервера.
Если вопросы безопасности не стоят на первом месте, сжатие может ускорить передачу дан-
ных, когда узким местом является сеть. Отключение сжатия может улучшить время отклика и
пропускную способность, если ограничивающим фактором является производительность CPU.
sslcert
Этот параметр предписывает имя файла для SSL-сертификата клиента, заменяющего файл по
умолчанию ~/.postgresql/postgresql.crt. Этот параметр игнорируется, если SSL-подклю-
чение не выполнено.
766libpq — библиотека для языка C
sslkey
Этот параметр предписывает местоположение секретного ключа, используемого для сертифи-
ката клиента. Он может либо указывать имя файла, которое будет использоваться вместо име-
ни по умолчанию ~/.postgresql/postgresql.key, либо он может указывать ключ, полученный
от внешнего «криптомодуля» (криптомодули — это загружаемые модули OpenSSL). Специфи-
кация внешнего криптомодуля должна состоять из имени модуля и ключевого идентификато-
ра, зависящего от конкретного модуля, разделённых двоеточием. Этот параметр игнорируется,
если SSL-подключение не выполнено.
sslrootcert
Этот параметр указывает имя файла, содержащего SSL-сертификаты, выданные Центром сер-
тификации (CA). Если файл существует, сертификат сервера будет проверен на предмет его
подписания одним из этих центров. Имя по умолчанию — ~/.postgresql/root.crt.
sslcrl
Этот параметр указывает имя файла, содержащего список отозванных SSL-сертификатов (CRL).
Сертификаты, перечисленные в этом файле, если он существует, будут отвергаться при по-
пытке установить подлинность сертификата сервера. Имя по умолчанию такое ~/.postgresql/
root.crl.
requirepeer
Этот параметр указывает имя пользователя операционной системы, предназначенное для сер-
вера, например, requirepeer=postgres. При создании подключения через Unix-сокет, если этот
параметр установлен, клиент проверяет в самом начале процедуры подключения, что сервер-
ный процесс запущен от имени указанного пользователя; если это не так, соединение аварийно
прерывается с ошибкой. Этот параметр можно использовать, чтобы обеспечить аутентифика-
цию сервера, подобную той, которая доступна с помощью SSL-сертификатов при соединениях
по протоколу TCP/IP. (Заметьте, что если Unix-сокет находится в каталоге /tmp или в другом
каталоге, запись в который разрешена всем пользователям, тогда любой пользователь сможет
запустить сервер, прослушивающий сокет в том каталоге. Используйте этот параметр, чтобы
гарантировать, что вы подключены к серверу, запущенному доверенным пользователем.) Он
поддерживается только на платформах, для которых реализован метод аутентификации peer;
см. Раздел 20.9.
krbsrvname
Имя сервиса Kerberos, предназначенное для использования при аутентификации на основе
GSSAPI. Оно должно соответствовать имени сервиса, указанному в конфигурации сервера, что-
бы аутентификация на основе Kerberos прошла успешно. (См. также Раздел 20.6.)
gsslib
Библиотека GSS, предназначенная для использования при аутентификации на основе GSSAPI.
Используется только в системе Windows. Назначьте значение gssapi, чтобы заставить libpq ис-
пользовать для аутентификации библиотеку GSSAPI вместо SSPI, применяемого по умолчанию.
service
Имя сервиса, используемое для задания дополнительных параметров. Оно указывает имя сер-
виса в файле pg_service.conf, который содержит дополнительные параметры подключения.
Это позволяет приложениям указывать только имя сервиса, поскольку параметры подключе-
ния могут поддерживаться централизованно. См. Раздел 34.16.
target_session_attrs
Если этот параметр равен read-write, по умолчанию будут приемлемы только подключения,
допускающие транзакции на чтение/запись. При успешном подключении будет отправлен за-
прос SHOW transaction_read_only; если он вернёт on, соединение будет закрыто. Если в строке
подключения указано несколько серверов, будут перебираться остальные серверы, как и при
767libpq — библиотека для языка C
неудачной попытке подключения. Со значением по умолчанию (any) приемлемыми будут все
подключения.
34.2. Функции, описывающие текущее состояние под-
ключения
Эти функции могут использоваться для опроса состояния объекта, описывающего существующее
подключение к базе данных.
Подсказка
Разработчики приложений на основе libpq должны тщательно поддерживать абстрак-
цию PGconn. Следует использовать функции доступа, описанные ниже, для получения
содержимого PGconn. Обращение напрямую к внутренним полям PGconn, используя све-
дения из libpq-int.h, не рекомендуется, поскольку они могут измениться в будущем.
Следующие функции возвращают значения параметров, которые были установлены в момент под-
ключения. Эти значения не изменяются во время жизни соединения. Если используется строка
соединения с несколькими узлами, значения PQhost, PQport и PQpass могут меняться, если с тем
же объектом PGconn устанавливается новое соединение. Другие значения не меняются на протя-
жении жизни объекта PGconn.
PQdb
Возвращает имя базы данных, с которой установлено соединение.
char *PQdb(const PGconn *conn);
PQuser
Возвращает имя пользователя, который установил соединение.
char *PQuser(const PGconn *conn);
PQpass
Возвращает пароль, использованный для подключения.
char *PQpass(const PGconn *conn);
PQpass возвратит либо пароль, указанный в параметрах подключения, либо пароль, получен-
ный из файла паролей (в случае отсутствия первого). Во втором случае, если в параметрах под-
ключения было указано несколько узлов, полагаться на результат PQpass нельзя, пока соеди-
нение не будет установлено. Состояние подключения позволяет проверить функция PQstatus.
PQhost
Возвращает имя сервера для активного соединения. Это может быть имя компьютера, IP-адрес
или путь к каталогу, если подключение установлено через сокет Unix. (Признаком подключе-
ния к сокету будет абсолютный путь, который начинается с /.)
char *PQhost(const PGconn *conn);
Если в параметрах подключения был задан и host, и hostaddr, функция PQhost выдаст содер-
жимое host. Если был задан только hostaddr, возвращается это значение. Если в параметрах
подключения было задано несколько узлов, PQhost возвращает адрес узла, с которым факти-
чески установлено соединение.
PQhost возвращает NULL, если аргумент conn равен NULL. Иначе в случае ошибки при получении
информации об узле (это возможно, если соединение не установлено до конца или произошла
ошибка) она возвращает пустую строку.
768libpq — библиотека для языка C
Если в параметрах подключения указаны несколько узлов, на результат PQhost нельзя пола-
гаться, пока соединение не будет установлено. Проверить состояние соединения позволяет
функция PQstatus.
PQport
Возвращает номер порта активного соединения.
char *PQport(const PGconn *conn);
Если в параметрах подключения было задано несколько портов, PQport возвращает порт, с
которым фактически установлено соединение.
PQport возвращает NULL, если аргумент conn равен NULL. Иначе в случае ошибки при получении
информации о порте (это возможно, если соединение не установлено до конца или произошла
ошибка) она возвращает пустую строку.
Если в параметрах подключения указаны несколько портов, на результат PQport нельзя по-
лагаться, пока соединение не будет установлено. Проверить состояние соединения позволяет
функция PQstatus.
PQtty
Возвращает имя отладочного терминала (TTY), связанного с данным соединением. (Это уста-
ревшая функция, поскольку сервер более не обращает внимания на установку TTY, но она оста-
ётся для обеспечения обратной совместимости.)
char *PQtty(const PGconn *conn);
PQoptions
Возвращает параметры командной строки, переданные в запросе на подключение.
char *PQoptions(const PGconn *conn);
Следующие функции возвращают данные статуса, который может измениться в процессе выпол-
нения операций на объекте PGconn.
PQstatus
Возвращает состояние подключения.
ConnStatusType PQstatus(const PGconn *conn);
Статус может принимать одно из ряда значений. Однако, только два из них видны извне про-
цедуры асинхронного подключения: CONNECTION_OK и CONNECTION_BAD. Успешное подключение
к базе данных имеет статус CONNECTION_OK. О неудачной попытке подключения сигнализирует
статус CONNECTION_BAD. Обычно статус OK остаётся таковым до вызова PQfinish, но сбой в ком-
муникации может привести к тому, что статус изменится на CONNECTION_BAD преждевременно.
В таком случае приложение может попытаться восстановиться, вызвав PQreset.
См. статьи, посвященные PQconnectStartParams, PQconnectStart и PQconnectPoll, относитель-
но других кодов статуса, которые могут быть возвращены этими функциями.
PQtransactionStatus
Возвращает текущий статус сервера, отражающий процесс выполнения транзакций.
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
Статус может быть одним из PQTRANS_IDLE (в настоящее время не занят обработкой транзак-
ции), PQTRANS_ACTIVE (команда в процессе обработки), PQTRANS_INTRANS (не выполняет рабо-
ту, но находится в рамках действительной транзакции) или PQTRANS_INERROR (не выполняет ра-
боту, но находится в рамках транзакции, завершившейся сбоем). Статус принимает значение
PQTRANS_UNKNOWN, если соединение не работает. Статус принимает значение PQTRANS_ACTIVE
только тогда, когда запрос был отправлен серверу, но ещё не завершён.
769libpq — библиотека для языка C
PQparameterStatus
Отыскивает текущее значение параметра сервера.
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
Значения определённых параметров сервер сообщает автоматически в начале процедуры под-
ключения или тогда, когда их значения изменяются. PQparameterStatus можно использовать,
чтобы запросить эти значения. Функция возвращает текущее значение параметра, если оно
известно, или NULL, если параметр неизвестен.
Параметры, значения которых сообщает сервер, в текущей версии включают server_version,
server_encoding, client_encoding, application_name, is_superuser, session_authorization,
DateStyle, IntervalStyle, TimeZone, integer_datetimes и standard_conforming_strings. (Зна-
чения параметров server_encoding, TimeZone и integer_datetimes сервер до версии 8.0 не со-
общал; standard_conforming_strings сервер до версии 8.1 не сообщал; IntervalStyle сервер
до версии 8.4 не сообщал; application_name сервер до версии 9.0 не сообщал.) Учтите, что
server_version, server_encoding и integer_datetimes нельзя изменить после запуска.
Серверы, поддерживающие протокол только до версии 3.0, не могут сообщать
установки параметров, но libpq включает средства, чтобы получить значения для
server_version и client_encoding в любом случае. Поощряется использование в приложени-
ях PQparameterStatus, а не специально написанного (ad hoc) кода, для определения этих зна-
чений. (Примите к сведению, однако, что в соединениях, основанных на протоколе версии до
3.0, изменение client_encoding посредством команды SET после начала процедуры подключе-
ния не будет отражаться функцией PQparameterStatus.) Сведения о server_version приведены
также в описании функции PQserverVersion, возвращающей информацию в числовой форме, в
которой гораздо легче выполнять сравнение.
Если для standard_conforming_strings не передано никакого значения, то приложения могут
принять его равным off. Это означает, что символы обратной косой черты в строковых литера-
лах интерпретируются в качестве спецсимволов. Также, наличие этого параметра может рас-
сматриваться как указание на то, что синтаксис escape-строк (E’…’) является приемлемым.
Хотя возвращаемый указатель объявлен со спецификатором const, фактически он указывает
на изменяемое хранилище, связанное со структурой PGconn. Не стоит рассчитывать на то, что
указатель останется действительным при последующих запросах.
PQprotocolVersion
Запрашивает протокол, используемый между клиентом и сервером.
int PQprotocolVersion(const PGconn *conn);
Приложения могут использовать эту функцию, чтобы определить, поддерживаются ли опредё-
ленные функциональные возможности. В настоящее время возможными значениями являются
2 (протокол версии 2.0), 3 (протокол версии 3.0) или ноль (проблемы в подключении). Версия
протокола не будет изменяться после завершения процедуры подключения, но теоретически
она могла бы измениться в процессе переподключения. Версия протокола 3.0 обычно исполь-
зуется при взаимодействии с серверами PostgreSQL версии 7.4 или более поздними; серверы
до версии 7.4 поддерживают только протокол версии 2.0. (Протокол версии 1.0 является уста-
ревшим и не поддерживается библиотекой libpq.)
PQserverVersion
Возвращает целочисленное представление версии сервера.
int PQserverVersion(const PGconn *conn);
Приложения могут использовать эту функцию, чтобы определить версию сервера баз данных,
к которому они подключены. Возвращаемое ей число получается в результате умножения но-
мера основной версии на 10000 и добавления номера дополнительной версии. Например, для
770libpq — библиотека для языка C
версии 10.1 будет выдано число 100001, а для версии 11.0 — 110000. Если соединение не ра-
ботает, то возвращается ноль.
До версии 10, в PostgreSQL номера версий образовывались из трёх чисел, первые два из которых
представляли основную версию. Для таких версий PQserverVersion отводит на каждое число
по две цифры; например, для версии 9.1.5 будет выдано 90105, а для версии 9.2.0 — 90200.
Таким образом, чтобы получить логический номер версии для определения доступности функ-
ционала, приложения должны разделить результат PQserverVersion на 100, а не на 10000. Во
всех сериях номера дополнительных (корректирующих) выпусков различаются только в двух
последних цифрах.
PQerrorMessage
Возвращает сообщение об ошибке, наиболее недавно сгенерированное операцией, выполнен-
ной в рамках текущего подключения.
char *PQerrorMessage(const PGconn *conn);
Почти все функции библиотеки libpq в случае сбоя сформируют сообщение для PQerrorMessage.
Обратите внимание, что по соглашениям, принятым в libpq, непустой результат функции
PQerrorMessage может состоять из нескольких строк и будет включать завершающий символ
новой строки. Вызывающая функция не должна освобождать память, на которую указывает
возвращаемое значение, напрямую. Она будет освобождена, когда связанный с ней дескрип-
тор PGconn будет передан функции PQfinish. Не стоит ожидать, что результирующая строка
останется той же самой при выполнении нескольких операций со структурой PGconn.
PQsocket
Получает номер файлового дескриптора для сокета соединения с сервером. Действительный
дескриптор будет больше или равен 0; значение -1 показывает, что в данный момент не открыто
ни одного соединения с сервером. (Значение не изменится во время обычной работы, но может
измениться во время установки или переустановки подключения.)
int PQsocket(const PGconn *conn);
PQbackendPID
Возвращает ID (PID)серверного процесса, обрабатывающего это подключение.
int PQbackendPID(const PGconn *conn);
PID серверного процесса полезен для отладочных целей и для сопоставления с сообщениями
команды NOTIFY (которые включают PID уведомляющего серверного процесса). Примите к све-
дению, что PID принадлежит процессу, выполняющемуся на компьютере сервера баз данных,
а не на локальном компьютере.
PQconnectionNeedsPassword
Возвращает true (1), если метод аутентификации соединения требовал пароля, однако он не
был предоставлен. Возвращает false (0), если пароль не требовался.
int PQconnectionNeedsPassword(const PGconn *conn);
Эту функцию можно применить после неудачной попытки подключения, чтобы решить, нужно
ли предлагать пользователю ввести пароль.
PQconnectionUsedPassword
Возвращает true (1), если метод аутентификации соединения использовал пароль. Возвращает
false (0) в противном случае.
int PQconnectionUsedPassword(const PGconn *conn);
Эту функцию можно применить как после неудачной, так и после успешной попытки подклю-
чения, чтобы определить, требовал ли сервер предоставления пароля.
771libpq — библиотека для языка C
Следующие функции возвращают информацию, относящуюся к SSL. Эта информация обычно не
меняется после того, как подключение установлено.
PQsslInUse
Возвращает true (1), если для текущего подключения используется SSL, и false (0) в противном
случае.
int PQsslInUse(const PGconn *conn);
PQsslAttribute
Возвращает связанную с SSL информацию о соединении.
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
Список доступных атрибутов зависит от применяемой библиотеки SSL и типа подключения.
Если атрибут недоступен, возвращается NULL.
Обычно доступны следующие атрибуты:
library
Имя используемой реализации SSL. (В настоящее время поддерживается только “OpenSSL”)
protocol
Применяемая версия SSL/TLS. Наиболее распространены варианты “TLSv1”, “TLSv1.1” и
“TLSv1.2”, но реализация может возвращать и другие строки, если применяется какой-то
другой протокол.
key_bits
Число бит в ключе, используемом алгоритмом шифрования.
cipher
Краткое имя применяемого комплекта шифров, например: “DHE-RSA-DES-CBC3-SHA”. Эти
имена могут быть разными в разных реализациях SSL.
compression
Если применяется сжатие SSL, возвращает имя алгоритма сжатия, либо “on”, если сжатие
используется, но его алгоритм неизвестен. Если сжатие не применяется, возвращает “off”.
PQsslAttributeNames
Возвращает массив имён доступных атрибутов SSL. Завершается массив указателем NULL.
const char * const * PQsslAttributeNames(const PGconn *conn);
PQsslStruct
Возвращает указатель на специфичный для реализации SSL объект, описывающий подключе-
ние.
void *PQsslStruct(const PGconn *conn, const char *struct_name);
Доступная структура (или структуры) зависит от того, какая реализация SSL применяется. Для
OpenSSL выдаётся одна структура под именем “OpenSSL”, и эта структура, на которую указы-
вает возвращённый указатель, имеет тип SSL (определённый в OpenSSL). Для обращения к этой
функции можно воспользоваться кодом в следующих строках:
#include <libpq-fe.h>
#include &lt;openssl/ssl.h&gt;
...
772libpq — библиотека для языка C
SSL *ssl;
dbconn = PQconnectdb(...);
...
ssl = PQsslStruct(dbconn, "OpenSSL");
if (ssl)
{
/* use OpenSSL functions to access ssl */
}
Эта структура может использоваться, чтобы сличить уровни шифрования, проверить сертифи-
каты сервера и т. д. За информацией об этой структуре обратитесь к документации по OpenSSL.
PQgetssl
Возвращает структуру SSL, использовавшуюся в соединении, или null, если SSL не использу-
ется.
void *PQgetssl(const PGconn *conn);
Эта функция равнозначна PQsslStruct(conn, "OpenSSL"). Её не следует применять в новых
приложениях, так как возвращаемая структура специфична для OpenSSL и её нельзя будет
получить с другой реализацией SSL. Чтобы проверить, использует ли подключение SSL, лучше
вызвать PQsslInUse, а чтобы получить свойства подключения — PQsslAttribute.
34.3. Функции для исполнения команд
После того как соединение с сервером было успешно установлено, функции, описанные в этом
разделе, используются для выполнения SQL-запросов и команд.
34.3.1. Главные функции
PQexec
Передаёт команду серверу и ожидает результата.
PGresult *PQexec(PGconn *conn, const char *command);
Возвращает указатель на PGresult или, возможно, пустой указатель (null). Как правило, возвра-
щается непустой указатель, исключением являются ситуации нехватки памяти или серьёзные
ошибки, такие, как невозможность отправки команды серверу. Для проверки возвращаемого
значения на наличие ошибок следует вызывать функцию PQresultStatus (в случае нулевого
указателя она возвратит PGRES_FATAL_ERROR). Для получения дополнительной информации о
таких ошибках используйте функцию PQerrorMessage.
Строка команды может включать в себя более одной SQL-команды (которые разделяются точкой с
запятой). Несколько запросов, отправленных с помощью одного вызова PQexec, обрабатываются в
рамках одной транзакции, если только команды BEGIN/COMMIT не включены явно в строку запроса,
чтобы разделить его на несколько транзакций. (Подробнее о том, как сервер обрабатывает строки,
включающие несколько команд, рассказывается в Подразделе 53.2.2.1.) Однако обратите внима-
ние, что возвращаемая структура PGresult описывает только результат последней из выполнен-
ных команд, содержащихся в строке запроса. Если одна из команд завершается сбоем, то обработ-
ка строки запроса на этом останавливается, и возвращённая структура PGresult описывает состо-
яние ошибки.
PQexecParams
Отправляет команду серверу и ожидает результата. Имеет возможность передать параметры
отдельно от текста SQL-команды.
773libpq — библиотека для языка C
PGresult *PQexecParams(PGconn *conn,
const char *command,
int nParams,
const Oid *paramTypes,
const char * const *paramValues,
const int *paramLengths,
const int *paramFormats,
int resultFormat);
PQexecParams подобна PQexec, но предлагает дополнительную функциональность: значения па-
раметров могут быть указаны отдельно от самой строки-команды, а результаты запроса могут
быть затребованы либо в текстовом, либо в двоичном формате. PQexecParams поддерживается
только при подключениях по протоколу версии 3.0 или более поздних версий. Её вызов завер-
шится сбоем при использовании протокола версии 2.0.
Параметры функции следующие:
conn
Объект, описывающий подключение, через которое пересылается команда.
command
Строка SQL-команды, которая должна быть выполнена. Если используются параметры, то
в строке команды на них ссылаются, как $1, $2 и т. д.
nParams
Число предоставляемых параметров. Оно равно длине массивов paramTypes[],
paramValues[], paramLengths[] и paramFormats[]. (Указатели на массивы могут быть равны
NULL, когда nParams равно нулю.)
paramTypes[]
Предписывает, посредством OID, типы данных, которые должны быть назначены парамет-
рам. Если значение paramTypes равно NULL или какой-либо отдельный элемент в массиве
равен нулю, тогда сервер самостоятельно определит тип данных для параметра точно таким
же образом, как он сделал бы для литеральной строки, тип которой не указан.
paramValues[]
Указывает фактические значения параметров. Нулевой указатель в этом массиве означает,
что соответствующий параметр равен null; в противном случае указатель указывает на тек-
стовую строку, завершающуюся нулевым символом (для текстового формата), или на дво-
ичные данные в формате, которого ожидает сервер (для двоичного формата).
paramLengths[]
Указывает фактические длины данных для параметров, представленных в двоичном форма-
те. Он игнорируется для параметров, имеющих значение null, и для параметров, представ-
ленных в текстовом формате. Указатель на массив может быть нулевым, когда нет двоичных
параметров.
paramFormats[]
Указывает, являются ли параметры текстовыми (поместите нуль в элемент массива, соот-
ветствующий такому параметру) или двоичными (поместите единицу в элемент массива,
соответствующий такому параметру). Если указатель на массив является нулевым, тогда
все параметры считаются текстовыми строками.
Значения, переданные в двоичном формате, требуют знания внутреннего представле-
ния, которого ожидает сервер. Например, целые числа должны передаваться с исполь-
зованием сетевого порядка байтов. Передача значений типа numeric требует знания то-
774libpq — библиотека для языка C
го формата, в котором их хранит сервер, как это реализовано в src/backend/utils/adt/
numeric.c::numeric_send() и src/backend/utils/adt/numeric.c::numeric_recv().
resultFormat
Требует указать ноль, чтобы получить результаты в текстовом формате, или единицу, чтобы
получить результаты в двоичном формате. (В настоящее время нет возможности получить
различные столбцы результата в разных форматах, хотя это и возможно на уровне протоко-
ла, лежащего в основе подключений.)
Важнейшим преимуществом PQexecParams над PQexec является то, что значения параметров мо-
гут быть отделены от строки-команды. Это позволяет избежать использования кавычек и экрани-
рующих символов, что является трудоёмким методом, часто приводящим к ошибкам.
В отличие от PQexec, PQexecParams позволяет включать не более одной SQL-команды в строку за-
проса. (В ней могут содержаться точки с запятой, однако может присутствовать не более одной
непустой команды.) Это ограничение накладывается базовым протоколом, но оно приносит и неко-
торую пользу в качестве дополнительной защиты от атак методом SQL-инъекций.
Подсказка
Указание типов параметров с помощью OID является трудоёмким, особенно если вы
предпочитаете не указывать явно значений OID в вашей программе. Однако, вы можете
избежать этого даже в случаях, когда сервер самостоятельно не может определить тип
параметра или выбирает не тот тип, который вы хотите. В строке SQL-команды добавьте
явное приведение типа для этого параметра, чтобы показать, какой тип данных вы
будете отправлять. Например:
SELECT * FROM mytable WHERE x = $1::bigint;
Это приведёт к тому, что параметр $1 будет считаться имеющим тип bigint, в то время
как по умолчанию ему был бы назначен тот же самый тип, что и x. Такое явное приня-
тие решения о типе параметра либо с помощью описанного метода, либо путём зада-
ния числового OID строго рекомендуется, когда значения параметров отправляются
в двоичном формате, поскольку двоичный формат имеет меньшую избыточность, чем
текстовый, и поэтому гораздо менее вероятно, что сервер обнаружит ошибку несоот-
ветствия типов, допущенную вами.
PQprepare
Отправляет запрос, чтобы создать подготовленный оператор с конкретными параметрами, и
ожидает завершения.
PGresult *PQprepare(PGconn *conn,
const char *stmtName,
const char *query,
int nParams,
const Oid *paramTypes);
PQprepare создаёт подготовленный оператор для последующего исполнения с помощью
PQexecPrepared. Благодаря этому, команды, которые будут выполняться многократно, не по-
требуется разбирать и планировать каждый раз; за подробностями обратитесь к PREPARE.
PQprepare поддерживается только с подключениями по протоколу 3.0 и новее; с протоколом
2.0 эта функция работать не будет.
Функция создаёт подготовленный оператор с именем stmtName из строки query, которая долж-
на содержать единственную SQL-команду. stmtName может быть пустой строкой "", тогда будет
создан неименованный оператор (в таком случае любой уже существующий неименованный
оператор будет автоматически заменён), в противном случае, если имя оператора уже опреде-
775libpq — библиотека для языка C
лено в текущем сеансе работы, будет ошибка. Если используются параметры, то в запросе к ним
обращаются таким образом: $1, $2 и т. д. nParams представляет число параметров, типы данных
для которых указаны в массиве paramTypes[]. (Указатель на массив может быть равен NULL,
когда значение nParams равно нулю.) paramTypes[] указывает, посредством OID, типы данных,
которые будут назначены параметрам. Если paramTypes равен NULL или какой-либо элемент в
этом массиве равен нулю, то сервер назначает тип данных соответствующему параметру точ-
но таким же способом, как он сделал бы для литеральной строки, не имеющей типа. Также в
запросе можно использовать параметры с номерами, большими, чем nParams; типы данных для
них сервер также сможет подобрать. (См. описание PQdescribePrepared, где сказано, какие
существуют средства, чтобы определить, какие типы данных были подобраны).
Как и при вызове PQexec, результатом является объект PGresult, содержимое которого пока-
зывает успех или сбой на стороне сервера. Нулевой указатель означает нехватку памяти или
невозможность вообще отправить команду. Для получения дополнительной информации о та-
ких ошибках используйте PQerrorMessage.
Подготовленные операторы для использования с PQexecPrepared можно также создать путём
исполнения SQL-команд PREPARE. Также, хотя никакой функции libpq для удаления подго-
товленного оператора не предусмотрено, для этой цели можно воспользоваться SQL-командой
DEALLOCATE.
PQexecPrepared
Отправляет запрос на исполнение подготовленного оператора с данными параметрами и ожи-
дает результата.
PGresult *PQexecPrepared(PGconn *conn,
const char *stmtName,
int nParams,
const char * const *paramValues,
const int *paramLengths,
const int *paramFormats,
int resultFormat);
PQexecPrepared подобна PQexecParams, но команда, подлежащая исполнению, указывается пу-
тём передачи имени предварительно подготовленного оператора вместо передачи строки за-
проса. Эта возможность позволяет командам, которые вызываются многократно, подвергаться
разбору и планированию только один раз, а не при каждом их исполнении. Оператор должен
быть подготовлен предварительно в рамках текущего сеанса работы. PQexecPrepared поддер-
живается только в соединениях по протоколу версии 3.0 или более поздних версий. При ис-
пользовании протокола версии 2.0 функция завершится сбоем.
Параметры идентичны PQexecParams, за исключением того, что вместо строки запроса пере-
даётся имя подготовленного оператора, и отсутствует параметр paramTypes[] (он не нужен,
поскольку типы данных для параметров подготовленного оператора были определены при его
создании).
PQdescribePrepared
Передаёт запрос на получение информации об указанном подготовленном операторе и ожида-
ет завершения.
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
PQdescribePrepared позволяет приложению получить информацию о предварительно подго-
товленном операторе. PQdescribePrepared поддерживается только в соединениях по протоко-
лу версии 3.0 или более поздних версий. При использовании протокола версии 2.0 функция
завершится сбоем.
Для ссылки на неименованный оператор значение stmtName может быть пустой строкой "" или
NULL, в противном случае оно должно быть именем существующего подготовленного оператора.
776libpq — библиотека для языка C
В случае успешного выполнения возвращается PGresult со статусом PGRES_COMMAND_OK. Функ-
ции PQnparams и PQparamtype позволяют извлечь из PGresult информацию о параметрах под-
готовленного оператора, а функции PQnfields, PQfname, PQftype и т. п. предоставляют инфор-
мацию о результирующих столбцах (если они есть) данного оператора.
PQdescribePortal
Передаёт запрос на получение информации об указанном портале и ожидает завершения.
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
PQdescribePortal позволяет приложению получить информацию о предварительно созданном
портале. (libpq не предоставляет прямого доступа к порталам, но вы можете использовать
эту функцию для ознакомления со свойствами курсора, созданного с помощью SQL-команды
DECLARE CURSOR.) PQdescribePortal поддерживается только в соединениях по протоколу версии
3.0 или более поздних версий. При использовании протокола версии 2.0 функция завершится
сбоем.
Для ссылки на неименованный портал значение portalName может быть пустой строкой "" или
NULL, в противном случае оно должно быть именем существующего портала. В случае успеш-
ного завершения возвращается PGresult со статусом PGRES_COMMAND_OK. С помощью функций
PQnfields, PQfname, PQftype и т. д. можно извлечь из PGresult информацию о результирующих
столбцах (если они есть) данного портала.
Структура PGresultсодержит результат, возвращённый сервером. Разработчики приложений libpq
должны тщательно поддерживать абстракцию PGresult. Для получения доступа к содержимому
PGresult используйте функции доступа, описанные ниже. Избегайте непосредственного обраще-
ния к полям структуры PGresult, поскольку они могут измениться в будущем.
PQresultStatus
Возвращает статус результата выполнения команды.
ExecStatusType PQresultStatus(const PGresult *res);
PQresultStatus может возвращать одно из следующих значений:
PGRES_EMPTY_QUERY
Строка, отправленная серверу, была пустой.
PGRES_COMMAND_OK
Успешное завершение команды, не возвращающей никаких данных.
PGRES_TUPLES_OK
Успешное завершение команды, возвращающей данные (такой, как SELECT или SHOW).
PGRES_COPY_OUT
Начат перенос данных Copy Out (с сервера).
PGRES_COPY_IN
Начат перенос данных Copy In (на сервер).
PGRES_BAD_RESPONSE
Ответ сервера не был распознан.
PGRES_NONFATAL_ERROR
Произошла не фатальная ошибка (уведомление или предупреждение).
777libpq — библиотека для языка C
PGRES_FATAL_ERROR
Произошла фатальная ошибка.
PGRES_COPY_BOTH
Начат перенос данных Copy In/Out (на сервер и с сервера). Эта функция в настоящее вре-
мя используется только для потоковой репликации, поэтому такой статус не должен иметь
место в обычных приложениях.
PGRES_SINGLE_TUPLE
Структура PGresult содержит только одну результирующую строку, возвращённую текущей
командой. Этот статус имеет место только тогда, когда для данного запроса был выбран
режим построчного вывода (см. Раздел 34.5).
Если статус результата PGRES_TUPLES_OK или PGRES_SINGLE_TUPLE, тогда для извлечения строк,
возвращённых запросом, можно использовать функции, описанные ниже. Обратите внима-
ние, что команда SELECT, даже когда она не извлекает ни одной строки, всё же показыва-
ет PGRES_TUPLES_OK. PGRES_COMMAND_OK предназначен для команд, которые никогда не возвра-
щают строки (INSERT или UPDATE без использования предложения RETURNING и др.). Ответ
PGRES_EMPTY_QUERY может указывать на наличие ошибки в клиентском программном обеспе-
чении.
Результат со статусом PGRES_NONFATAL_ERROR никогда не будет возвращён напрямую функцией
PQexec или другими функциями исполнения запросов; вместо этого результаты такого вида
передаются обработчику уведомлений (см. Раздел 34.12).
PQresStatus
Преобразует значение перечислимого типа, возвращённое функцией PQresultStatus, в стро-
ковую константу, описывающую код статуса. Вызывающая функция не должна освобождать
память, на которую указывает возвращаемый указатель.
char *PQresStatus(ExecStatusType status);
PQresultErrorMessage
Возвращает сообщение об ошибке, связанное с командой, или пустую строку, если ошибки не
произошло.
char *PQresultErrorMessage(const PGresult *res);
Если произошла ошибка, то возвращённая строка будет включать завершающий символ новой
строки. Вызывающая функция не должна напрямую освобождать память, на которую указывает
возвращаемый указатель. Она будет освобождена, когда соответствующий указатель PGresult
будет передан функции PQclear.
Если непосредственно после вызова PQexec или PQgetResult вызвать функцию PQerrorMessage
(для данного подключения), то она возвратит ту же самую строку, что и PQresultErrorMessage
(для данного результата). Однако, PGresult сохранит своё сообщение об ошибке до тех пор,
пока не будет уничтожен, в то время, как сообщение об ошибке, связанное с данным подклю-
чением, будет изменяться при выполнении последующих операций. Воспользуйтесь функци-
ей PQresultErrorMessage, когда вы хотите узнать статус, связанный с конкретной структурой
PGresult; используйте функцию PQerrorMessage, когда вы хотите узнать статус выполнения
самой последней операции на данном соединении.
PQresultVerboseErrorMessage
Возвращает переформатированную версию сообщения об ошибке, связанного с объектом
PGresult.
char *PQresultVerboseErrorMessage(const PGresult *res,
PGVerbosity verbosity,
PGContextVisibility show_context);
778libpq — библиотека для языка C
В некоторых ситуациях клиент может захотеть получить более подробную вер-
сию ранее выданного сообщения об ошибке. Эту потребность удовлетворяет функция
PQresultVerboseErrorMessage, формируя сообщение, которое было бы выдано функцией
PQresultErrorMessage, если бы заданный уровень детализации был текущим для соединения
в момент заполнения PGresult. Если же в PGresult не содержится ошибка, вместо этого выда-
ётся сообщение «PGresult is not an error result» (PGresult — не результат с ошибкой). Возвра-
щаемое этой функцией сообщение завершается переводом строки.
В отличие от многих других функций, извлекающих данные из PGresult, результат этой функ-
ции — новая размещённая в памяти строка. Когда эта строка будет не нужна, вызывающий код
должен освободить её место, вызвав PQfreemem().
При нехватке памяти может быть возвращёно NULL.
PQresultErrorField
Возвращает индивидуальное поле из отчёта об ошибке.
char *PQresultErrorField(const PGresult *res, int fieldcode);
fieldcode это идентификатор поля ошибки; см. символические константы, перечисленные ни-
же. Если PGresult не содержит ошибки или предупреждения или не включает указанное поле,
то возвращается NULL. Значения полей обычно не включают завершающий символ новой стро-
ки. Вызывающая функция не должна напрямую освобождать память, на которую указывает
возвращаемый указатель. Она будет освобождена, когда соответствующий указатель PGresult
будет передан функции PQclear.
Доступны следующие коды полей:
PG_DIAG_SEVERITY
Серьёзность; поле может содержать ERROR, FATAL или PANIC (в сообщении об ошибке) либо
WARNING, NOTICE, DEBUG, INFO или LOG (в сообщении-уведомлении) либо локализованный пе-
ревод одного из этих значений. Присутствует всегда.
PG_DIAG_SEVERITY_NONLOCALIZED
Серьёзность; поле может содержать ERROR, FATAL или PANIC (в сообщении об ошибке) ли-
бо WARNING, NOTICE, DEBUG, INFO или LOG (в сообщении-уведомлении). Это поле подобно
PG_DIAG_SEVERITY, но его содержимое никогда не переводится. Присутствует только в от-
чётах, выдаваемых PostgreSQL версии 9.6 и новее.
PG_DIAG_SQLSTATE
Код ошибки в соответствии с соглашением о кодах SQLSTATE. Код SQLSTATE идентифици-
рует тип случившейся ошибки; он может использоваться клиентскими приложениями, что-
бы выполнять конкретные операции (такие, как обработка ошибок) в ответ на конкретную
ошибку базы данных. Список возможных кодов SQLSTATE приведён в Приложении A. Это
поле не подлежит локализации. Оно всегда присутствует.
PG_DIAG_MESSAGE_PRIMARY
Главное сообщение об ошибке, предназначенное для прочтения пользователем. Как прави-
ло составляет всего одну строку. Это поле всегда присутствует.
PG_DIAG_MESSAGE_DETAIL
Необязательное дополнительное сообщение об ошибке, передающее более детальную ин-
формацию о проблеме. Может занимать несколько строк.
PG_DIAG_MESSAGE_HINT
Подсказка: необязательное предположение о том, что можно сделать в данной проблемной
ситуации. Оно должно отличаться от детальной информации в том смысле, что оно пред-
779libpq — библиотека для языка C
лагает совет (возможно, и неподходящий), а не просто факты. Может занимать несколько
строк.
PG_DIAG_STATEMENT_POSITION
Строка, содержащая десятичное целое число, указывающее позицию расположения ошиб-
ки в качестве индекса в оригинальной строке оператора. Первый символ имеет позицию 1,
при этом позиции измеряются в символах а не в байтах.
PG_DIAG_INTERNAL_POSITION
Это поле определяется точно так же, как и поле PG_DIAG_STATEMENT_POSITION, но оно ис-
пользуется, когда позиция местонахождения ошибки относится к команде, сгенерирован-
ной внутренними модулями, а не к команде, представленной клиентом. Когда появляется
это поле, то всегда появляется и поле PG_DIAG_INTERNAL_QUERY.
PG_DIAG_INTERNAL_QUERY
Текст команды, сгенерированной внутренними модулями, завершившейся сбоем. Это мог
бы быть, например, SQL-запрос, выданный функцией на языке PL/pgSQL.
PG_DIAG_CONTEXT
Характеристика контекста, в котором произошла ошибка. В настоящее время она включает
вывод стека вызовов активных функций процедурного языка и запросов, сгенерированных
внутренними модулями. Стек выводится по одному элементу в строке, при этом первым
идет самый последний из элементов (самый недавний вызов).
PG_DIAG_SCHEMA_NAME
Если ошибка была связана с конкретным объектом базы данных, то в это поле будет запи-
сано имя схемы, содержащей данный объект.
PG_DIAG_TABLE_NAME
Если ошибка была связана с конкретной таблицей, то в это поле будет записано имя таб-
лицы. (Для получения имени схемы для данной таблицы обратитесь к полю, содержащему
имя схемы.)
PG_DIAG_COLUMN_NAME
Если ошибка была связана с конкретным столбцом таблицы, то в это поле будет записано
имя столбца. (Чтобы идентифицировать таблицу, обратитесь к полям, содержащим имена
схемы и таблицы.)
PG_DIAG_DATATYPE_NAME
Если ошибка была связана с конкретным типом данных, то в это поле будет записано имя
типа данных. (Чтобы получить имя схемы, которой принадлежит этот тип данных, обрати-
тесь к полю, содержащему имя схемы.)
PG_DIAG_CONSTRAINT_NAME
Если ошибка была связана с конкретным ограничением, то в это поле будет записано имя
ограничения. Чтобы получить имя таблицы или домена, связанных с этим ограничением,
обратитесь к полям, перечисленным выше. (С этой целью индексы рассматриваются как
ограничения, даже если они и не были созданы с помощью синтаксиса для создания огра-
ничений.)
PG_DIAG_SOURCE_FILE
Имя файла, содержащего позицию в исходном коде, для которой было выдано сообщение
об ошибка.
780libpq — библиотека для языка C
PG_DIAG_SOURCE_LINE
Номер строки той позиции в исходном коде, для которой было выдано сообщение об ошибке.
PG_DIAG_SOURCE_FUNCTION
Имя функции в исходном коде, сообщающей об ошибке.
Примечание
Поля для имени схемы, имени таблицы, имени столбца, имени типа данных и имени
ограничения предоставляются лишь для ограниченного числа типов ошибок; см.
Приложение A. Не рассчитывайте на то, что присутствие любого из этих полей га-
рантирует и присутствие какого-то другого поля. Базовые источники ошибок при-
держиваются взаимосвязей, описанных выше, но функции, определённые пользо-
вателем, могут использовать эти поля другими способами. Аналогично, не рассчи-
тывайте на то, что эти поля обозначают объекты, существующие в текущей базе
данных в настоящий момент.
Клиент отвечает за форматирование отображаемой информации в соответствии с его нужда-
ми; в частности, он должен разбивать длинные строки, как требуется. Символы новой строки,
встречающиеся в полях сообщения об ошибке, должны обрабатываться, как разрывы абзацев,
а не строк.
Ошибки, сгенерированные внутренними модулями libpq, будут иметь поля серьёзности ошибки
и основного сообщения, но, как правило, никаких других полей. Ошибки, возвращаемые серве-
ром, работающим по протоколу версии ниже 3.0, будут включать поля серьёзности ошибки и
основного сообщения, а также иногда детальное сообщение, но больше никаких полей.
Заметьте, что поля ошибки доступны только из объектов PGresult, а не из объектов PGconn. Не
существует функции PQerrorField.
PQclear
Освобождает область памяти, связанную с PGresult. Результат выполнения каждой команды
должен быть освобождён с помощью PQclear, когда он больше не нужен.
void PQclear(PGresult *res);
Вы можете держать объект PGresult под рукой до тех пор, пока он вам нужен; он не исчезает,
ни когда вы выдаёте новую команду, ни даже если вы закрываете соединение. Чтобы от него
избавиться, вы должны вызвать PQclear. Если этого не делать, то в результате будут иметь
место утечки памяти в вашем приложении.
34.3.2. Извлечение информации, связанной с результатом запроса
Эти функции служат для извлечения информации из объекта PGresult, который представля-
ет результат успешного запроса (то есть такого, который имеет статус PGRES_TUPLES_OK или
PGRES_SINGLE_TUPLE). Их также можно использовать для извлечения информации об успешной
операции DESCRIBE: результат этой операции содержит всю ту же самую информацию о столбцах,
которая была бы получена при реальном исполнении запроса, но не содержит ни одной строки.
Для объектов, имеющих другие значения статуса, эти функции будут действовать таким образом,
как будто результат не содержит ни одной строки и ни одного столбца.
PQntuples
Возвращает число строк (кортежей) в полученной выборке. (Заметьте, что объекты PGresult
не могут содержать более чем INT_MAX строк, так что для результата достаточно типа int.)
int PQntuples(const PGresult *res);
781libpq — библиотека для языка C
PQnfields
Возвращает число столбцов (полей) в каждой строке полученной выборки.
int PQnfields(const PGresult *res);
PQfname
Возвращает имя столбца, соответствующего данному номеру столбца. Номера столбцов начи-
наются с 0. Вызывающая функция не должна напрямую освобождать память, на которую ука-
зывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на
PGresult будет передан функции PQclear.
char *PQfname(const PGresult *res,
int column_number);
Если номер столбца выходит за пределы допустимого диапазона, то возвращается NULL.
PQfnumber
Возвращает номер столбца, соответствующий данному имени столбца.
int PQfnumber(const PGresult *res,
const char *column_name);
Если данное имя не совпадает с именем ни одного из столбцов, то возвращается -1.
Данное имя интерпретируется, как идентификатор в SQL-команде. Это означает, что оно пере-
водится в нижний регистр, если только оно не заключено в двойные кавычки. Например, для
выборки, сгенерированной с помощью такой SQL-команды:
SELECT 1 AS FOO, 2 AS "BAR";
мы получили бы следующие результаты:
PQfname(res, 0)
PQfname(res, 1)
PQfnumber(res, "FOO")
PQfnumber(res, "foo")
PQfnumber(res, "BAR")
PQfnumber(res, "\"BAR\"")
foo
BAR
0
0
-1
1
PQftable
Возвращает OID таблицы, из которой был получен данный столбец. Номера столбцов начина-
ются с 0.
Oid PQftable(const PGresult *res,
int column_number);
В следующих случаях возвращается InvalidOid: если номер столбца выходит за пределы до-
пустимого диапазона; если указанный столбец не является простой ссылкой на столбец табли-
цы; когда используется протокол версии более ранней, чем 3.0. Вы можете сделать запрос к
системной таблице pg_class, чтобы точно определить, к какой таблице было произведено об-
ращение.
Тип данных Oid и константа InvalidOid будут определены, когда вы включите заголовочный
файл для libpq. Они будут принадлежать к одному из целочисленных типов.
PQftablecol
Возвращает номер столбца (в пределах его таблицы) для указанного столбца в полученной вы-
борке. Номера столбцов в полученной выборке начинаются с 0, но столбцы в таблице имеют
ненулевые номера.
int PQftablecol(const PGresult *res,
782libpq — библиотека для языка C
int column_number);
В следующих случаях возвращается ноль: если номер столбца выходит за пределы допустимого
диапазона; если указанный столбец не является простой ссылкой на столбец таблицы; когда
используется протокол версии более ранней, чем 3.0.
PQfformat
Возвращает код формата, показывающий формат данного столбца. Номера столбцов начина-
ются с 0.
int PQfformat(const PGresult *res,
int column_number);
Значение кода формата, равное нулю, указывает на текстовое представление данных, в то вре-
мя, как значение, равное единице, означает двоичное представление. (Другие значения кодов
зарезервированы для определения в будущем.)
PQftype
Возвращает тип данных, соответствующий данному номеру столбца. Возвращаемое целое зна-
чение является внутренним номером OID для этого типа. Номера столбцов начинаются с 0.
Oid PQftype(const PGresult *res,
int column_number);
Вы может сделать запрос к системной таблице pg_type, чтобы получить имена и свойства раз-
личных типов данных. Значения OID для встроенных типов данных определены в файле src/
include/catalog/pg_type_d.h в дереве исходных кодов.
PQfmod
Возвращает модификатор типа для столбца, соответствующего данному номеру. Номера столб-
цов начинаются с 0.
int PQfmod(const PGresult *res,
int column_number);
Интерпретация значений модификатора зависит от типа; они обычно показывают точность или
предельные размеры. Значение -1 используется, чтобы показать «нет доступной информации».
Большинство типов данных не используют модификаторов, в таком случае значение всегда
будет -1.
PQfsize
Возвращает размер в байтах для столбца, соответствующего данному номеру. Номера столбцов
начинаются с 0.
int PQfsize(const PGresult *res,
int column_number);
PQfsize возвращает размер пространства, выделенного для этого столбца в строке базы дан-
ных, другими словами, это размер внутреннего представления этого типа данных на сервере.
(Следовательно, эта информация не является по-настоящему полезной для клиентов.) Отрица-
тельное значение говорит о том, что тип данных имеет переменную длину.
PQbinaryTuples
Возвращает 1, если PGresult содержит двоичные данные, или 0, если данные текстовые.
int PQbinaryTuples(const PGresult *res);
Эта функция не рекомендуется к использованию (за исключением применения в связи с коман-
дой COPY), поскольку один и тот же PGresult может содержать в некоторых столбцах текстовые
783libpq — библиотека для языка C
данные, а в остальных — двоичные. Предпочтительнее использовать PQfformat. PQbinaryTuples
возвращает 1, только если все столбцы в выборке являются двоичными (код формата 1).
PQgetvalue
Возвращает значение одного поля из одной строки, содержащейся в PGresult. Номера строк и
столбцов начинаются с 0. Вызывающая функция не должна напрямую освобождать память, на
которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий
указатель на PGresult будет передан функции PQclear.
char *PQgetvalue(const PGresult *res,
int row_number,
int column_number);
Для данных в текстовом формате значение, возвращаемое функцией PQgetvalue, является зна-
чением поля, представленным в виде символьной строки с завершающим нулевым символом.
Для данных в двоичном формате используется двоичное представление значения. Оно опреде-
ляется функциями typsend и typreceive для конкретного типа данных. (В этом случае к значе-
нию также добавляется нулевой байт, но обычно это не приносит пользы, поскольку вероятно,
что значение уже содержит нулевые байты.)
Пустая строка возвращается в том случае, когда значение поля отсутствует (null). См.
PQgetisnull, чтобы отличать отсутствие значения (null) от значения, равного пустой строке.
Указатель, возвращаемый функцией PQgetvalue, указывает на область хранения, которая яв-
ляется частью структуры PGresult. Не следует модифицировать данные, на которые указывает
этот указатель, а нужно явно скопировать данные в другую область хранения, если предпола-
гается их использовать за пределами времени жизни самой структуры PGresult.
PQgetisnull
Проверяет поле на предмет отсутствия значения (null). Номера строк и столбцов начинаются
с 0.
int PQgetisnull(const PGresult *res,
int row_number,
int column_number);
Эта функция возвращает 1, если значение в поле отсутствует (null), и 0, если поле содержит
непустое (non-null) значение. (Обратите внимание, что PQgetvalue возвратит пустую строку, а
не нулевой указатель, если значение в поле отсутствует.)
PQgetlength
Возвращает фактическую длину значения поля в байтах. Номера строк и столбцов начинаются
с 0.
int PQgetlength(const PGresult *res,
int row_number,
int column_number);
Это фактическая длина данных для конкретного значения данных, то есть размер объекта, на
который указывает PQgetvalue. Для текстового формата данных это то же самое, что strlen().
Для двоичного же формата это существенная информация. Обратите внимание, что не следует
полагаться на PQfsize, чтобы получить фактическую длину данных.
PQnparams
Возвращает число параметров подготовленного оператора.
int PQnparams(const PGresult *res);
Эта
функция
полезна
только
при
исследовании
результата
PQdescribePrepared. Для других типов запросов она возвратит ноль.
784
работы
функцииlibpq — библиотека для языка C
PQparamtype
Возвращает тип данных для указанного параметра оператора. Номера параметров начинаются
с 0.
Oid PQparamtype(const PGresult *res, int param_number);
Эта
функция
полезна
только
при
исследовании
результата
PQdescribePrepared. Для других типов запросов она возвратит ноль.
работы
функции
PQprint
Выводит все строки и, по выбору, имена столбцов в указанный поток вывода.
void PQprint(FILE *fout,
/* поток вывода */
const PGresult *res,
const PQprintOpt *po);
typedef struct
{
pqbool header;
/* печатать заголовки полей и счётчик строк */
pqbool align;
/* выравнивать поля */
pqbool standard;
/* старый формат */
pqbool html3;
/* выводить HTML-таблицы */
pqbool expanded;
/* расширять таблицы */
pqbool pager;
/* использовать программу для постраничного просмотра, если
нужно */
char
*fieldSep;
/* разделитель полей */
char
*tableOpt;
/* атрибуты для HTML-таблицы */
char
*caption;
/* заголовок HTML-таблицы */
char
**fieldName; /* массив заменителей для имён полей, завершающийся нулевым
символом */
} PQprintOpt;
Эту функцию прежде использовала утилита psql для вывода результатов запроса, но больше
она её не использует. Обратите внимание, предполагается, что все данные представлены в
текстовом формате.
34.3.3. Получение другой информации о результате
Эти функции используются для получения остальной информации из объектов PGresult.
PQcmdStatus
Возвращает дескриптор статуса для SQL-команды, которая сгенерировала PGresult.
char *PQcmdStatus(PGresult *res);
Как правило, это просто имя команды, но могут быть включены и дополнительные сведения,
такие, как число обработанных строк. Вызывающая функция не должна напрямую освобождать
память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соот-
ветствующий указатель на PGresult будет передан функции PQclear.
PQcmdTuples
Возвращает число строк, которые затронула SQL-команда.
char *PQcmdTuples(PGresult *res);
Эта функция возвращает строковое значение, содержащее число строк, которые затронул SQL-
оператор, сгенерировавший данный PGresult. Эту функцию можно использовать только сразу
после выполнения команд SELECT, CREATE TABLE AS, INSERT, UPDATE, DELETE, MOVE, FETCH или
COPY, а также после оператора EXECUTE, выполнившего подготовленный запрос, содержащий
785libpq — библиотека для языка C
команды INSERT, UPDATE или DELETE. Если команда, которая сгенерировала PGresult, была ка-
кой-то иной, то PQcmdTuples возвращает пустую строку. Вызывающая функция не должна на-
прямую освобождать память, на которую указывает возвращаемый указатель. Она будет осво-
бождена, когда соответствующий указатель на PGresult будет передан функции PQclear.
PQoidValue
Возвращает OIDвставленной строки, если SQL-команда была командой INSERT, которая встави-
ла ровно одну строку в таблицу, имеющую идентификаторы OID, или командой EXECUTE, кото-
рая выполнила подготовленный запрос, содержащий соответствующий оператор INSERT. В про-
тивном случае эта функция возвращает InvalidOid. Эта функция также возвратит InvalidOid,
если таблица, затронутая командой INSERT, не содержит идентификаторов OID.
Oid PQoidValue(const PGresult *res);
PQoidStatus
Эта функция считается не рекомендуемой к использованию (в качестве замены служит
PQoidValue), а также она не отвечает требованиям потоковой безопасности. Она возвращает
строковое значение, содержащее OID вставленной строки, в то время как PQoidValue возвра-
щает значение OID.
char *PQoidStatus(const PGresult *res);
34.3.4. Экранирование строковых значений для включения в SQL-
команды
PQescapeLiteral
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
PQescapeLiteral экранирует строковое значение для использования внутри SQL-команды. Это
полезно при вставке в SQL-команды значений данных в виде литеральных констант. Опреде-
лённые символы (такие, как кавычки и символы обратной косой черты) должны экранировать-
ся, чтобы предотвратить их специальную интерпретацию синтаксическим анализатором языка
SQL. PQescapeLiteral выполняет эту операцию.
PQescapeLiteral возвращает экранированную версию параметра str, размещённую в области
памяти, распределённой с помощью функции malloc(). Эту память нужно освобождать с помо-
щью функции PQfreemem(), когда возвращённое значение больше не требуется. Завершающий
нулевой байт не нужен и не должен учитываться в параметре length. (Если завершающий ну-
левой байт был найден до того, как были обработаны length байтов, то PQescapeLiteral оста-
навливает работу на нулевом байте; таким образом, поведение функции напоминает strncpy.)
В возвращённой строке все специальные символы заменены таким образом, что синтаксиче-
ский анализатор строковых литералов PostgreSQL может обработать их должным образом. За-
вершающий нулевой байт также будет добавлен. Одинарные кавычки, которые должны окру-
жать строковые литералы PostgreSQL, включаются в результирующую строку.
В случае ошибки PQescapeLiteral возвращает NULL, и в объект conn помещается соответству-
ющее сообщение.
Подсказка
Особенно важно выполнять надлежащее экранирование при обработке строк, по-
лученных из ненадёжных источников. В противном случае ваша безопасность под-
вергается риску из-за уязвимости в отношении атак с использованием «SQL-инъек-
ций», с помощью которых нежелательные SQL-команды направляются в вашу базу
данных.
786libpq — библиотека для языка C
Обратите внимание, что нет необходимости (и это будет даже некорректно) экранировать зна-
чения данных, передаваемых в виде отдельных параметров в функцию PQexecParams или род-
ственные ей функции.
PQescapeIdentifier
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
PQescapeIdentifier экранирует строку, предназначенную для использования в качестве иден-
тификатора SQL, такого, как таблица, столбец или имя функции. Это полезно, когда идентифи-
катор, выбранный пользователем, может содержать специальные символы, которые в против-
ном случае не интерпретировались бы синтаксическим анализатором SQL, как часть иденти-
фикатора, или когда идентификатор может содержать символы верхнего регистра, и этот ре-
гистр требуется сохранить.
PQescapeIdentifier возвращает версию параметра str, экранированную как SQL-идентифика-
тор, и размещённую в области памяти, распределённой с помощью функции malloc(). Эту па-
мять нужно освобождать с помощью функции PQfreemem(), когда возвращённое значение боль-
ше не требуется. Завершающий нулевой байт не нужен и не должен учитываться в параметре
length. (Если завершающий нулевой байт был найден до того, как были обработаны length
байтов, то PQescapeIdentifier останавливает работу на нулевом байте; таким образом, пове-
дение функции напоминает strncpy.) В возвращённой строке все специальные символы заме-
нены таким образом, что она будет надлежащим образом обработана, как SQL-идентификатор.
Завершающий нулевой байт также будет добавлен. Возвращённая строка также будет заклю-
чена в двойные кавычки.
В случае ошибки PQescapeIdentifier возвращает NULL, и в объект conn помещается соответ-
ствующее сообщение.
Подсказка
Как и в случае со строковыми литералами, для того чтобы предотвратить атаки с
помощью SQL-инъекций, SQL-идентификаторы должны экранироваться, когда они
получены из ненадёжного источника.
PQescapeStringConn
size_t PQescapeStringConn(PGconn *conn,
char *to, const char *from, size_t length,
int *error);
PQescapeStringConn экранирует строковые литералы наподобие PQescapeLiteral. Но, в отли-
чие от PQescapeLiteral, за предоставление буфера надлежащего размера отвечает вызываю-
щая функция. Более того, PQescapeStringConn не добавляет одинарные кавычки, которые долж-
ны окружать строковые литералы PostgreSQL; они должны быть включены в SQL-команду, в ко-
торую вставляется результирующая строка. Параметр from указывает на первый символ стро-
ки, которая должна экранироваться, а параметр length задаёт число байтов в этой строке.
Завершающий нулевой байт не требуется и не должен учитываться в параметре length. (Ес-
ли завершающий нулевой байт был найден до того, как были обработаны length байтов, то
PQescapeStringConn останавливает работу на нулевом байте; таким образом, поведение функ-
ции напоминает strncpy.) Параметр to должен указывать на буфер, который сможет вместить
как минимум на один байт больше, чем предписывает удвоенное значение параметра length, в
противном случае поведение функции не определено. Поведение будет также не определено,
если строки to и from перекрываются.
Если параметр error не равен NULL, тогда значение *error устанавливается равным нулю в
случае успешной работы и не равным нулю в случае ошибки. В настоящее время единственным
возможным условием возникновения ошибки является неверная мультибайтовая кодировка в
787libpq — библиотека для языка C
исходной строке. Выходная строка формируется даже при наличии ошибки, но можно ожидать,
что сервер отвергнет её как неверно сформированную. В случае ошибки в объект conn запи-
сывается соответствующее сообщение независимо от того, равно ли NULL значение параметра
error.
PQescapeStringConn возвращает число байтов, записанных по адресу to, не включая заверша-
ющий нулевой байт.
PQescapeString
PQescapeString является более старой, не рекомендованной к использованию версией функции
PQescapeStringConn.
size_t PQescapeString (char *to, const char *from, size_t length);
Единственное отличие от PQescapeStringConn состоит в том, что функция PQescapeString не
принимает PGconn или error в качестве параметров. Из-за этого она не может скорректиро-
вать своё поведение в зависимости от свойств подключения (таких, как кодировка символов)
и, следовательно, она может выдавать неверные результаты. Также она не имеет способа
сообщить об ошибках.
PQescapeString может безопасно использоваться в клиентских программах, которые работают
лишь с одним подключением к PostgreSQL за один раз (в этом случае функция может найти то,
что ей нужно знать, «за кулисами»). В других контекстах её использование несёт в себе угрозу
безопасности и его следует избегать в пользу применения функции PQescapeStringConn.
PQescapeByteaConn
Экранирует двоичные данные для их использования внутри SQL-команды с типом данных
bytea. Как и в случае с PQescapeStringConn, эта функция применяется только тогда, когда дан-
ные вставляются непосредственно в строку SQL-команды.
unsigned char *PQescapeByteaConn(PGconn *conn,
const unsigned char *from,
size_t from_length,
size_t *to_length);
Байты, имеющие определённые значения, должны экранироваться, когда они используются в
качестве составной части литерала, имеющего тип bytea, в SQL-операторе. PQescapeByteaConn
экранирует байты, используя либо hex-кодирование, либо экранирование с помощью обратной
косой черты. См. Раздел 8.4 для получения дополнительной информации.
Параметр from указывает на первый байт строки, которая должна экранироваться, а параметр
from_length задаёт число байтов в этой двоичной строке. (Завершающий нулевой байт не ну-
жен и не учитывается.) Параметр to_length указывает на переменную, которая будет содер-
жать длину результирующей экранированной строки. Эта длина включает завершающий нуле-
вой байт результирующей строки.
PQescapeByteaConn возвращает экранированную версию двоичной строки, на которую указы-
вает параметр from, и размещает её в памяти, распределённой с помощью malloc(). Эта па-
мять должна быть освобождена с помощью функции PQfreemem(), когда результирующая стро-
ка больше не нужна. В возвращаемой строке все специальные символы заменены так, чтобы
синтаксический анализатор литеральных строк PostgreSQL и функция ввода для типа bytea
могли обработать их надлежащим образом. Завершающий нулевой байт также добавляется.
Одинарные кавычки, которые должны окружать строковые литералы PostgreSQL, не являются
частью результирующей строки.
В случае ошибки возвращается нулевой указатель, и соответствующее сообщение об ошибке
записывается в объект conn. В настоящее время единственной возможной ошибкой может быть
нехватка памяти для результирующей строки.
788libpq — библиотека для языка C
PQescapeBytea
PQescapeBytea является более старой, не рекомендуемой к использованию версией функции
PQescapeByteaConn.
unsigned char *PQescapeBytea(const unsigned char *from,
size_t from_length,
size_t *to_length);
Единственное отличие от PQescapeByteaConn состоит в том, что функция PQescapeBytea не при-
нимает PGconn в качестве параметра. Из-за этого PQescapeBytea может безопасно использо-
ваться в клиентских программах, которые работают лишь с одним подключением к PostgreSQL
за один раз (в этом случае функция может найти то, что ей нужно знать, «за кулисами»). Она мо-
жет выдавать неверные результаты при использовании в программах, которые формируют
множественные подключения к базе данных (в таких случаях используйте PQescapeByteaConn).
PQunescapeBytea
Преобразует строковое представление двоичных данных в двоичные данные — является обрат-
ной функцией к функции PQescapeBytea. Она нужна, когда данные типа bytea извлекаются в
текстовом формате, но не когда они извлекаются в двоичном формате.
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
Параметр from указывает на строку, такую, какую могла бы возвратить функция PQgetvalue,
применённая к столбцу типа bytea. PQunescapeBytea преобразует это строковое представле-
ние в его двоичное представление. Она возвращает указатель на буфер, распределённый с
помощью функции malloc() (или NULL в случае ошибки) и помещает размер буфера по ад-
ресу to_length. Когда результат не будет нужен, необходимо освободить его память, вызвав
PQfreemem.
Это преобразование не является точной инверсией для PQescapeBytea, поскольку ожидается,
что строка, полученная от PQgetvalue, не будет «экранированной». В частности, это означает,
что учитывать режим спецпоследовательностей не нужно, и поэтому в параметре нет необхо-
димости PGconn.
34.4. Асинхронная обработка команд
Функция PQexec хорошо подходит для отправки команд серверу в нормальных, синхронных прило-
жениях. Однако, она имеет ряд недостатков, которые могут иметь значение для некоторых поль-
зователей:
• PQexec ожидает завершения выполнения команды. Приложение может иметь и другую рабо-
ту, которую нужно делать (такую, как поддержание пользовательского интерфейса), в таком
случае оно не захочет блокироваться, ожидая ответа.
• Поскольку выполнение клиентского приложения приостанавливается, пока оно ожидает ре-
зультата, то приложению трудно решить, что оно хотело бы попытаться отменить выполняю-
щуюся команду. (Это можно сделать из обработчика сигнала, но никак иначе.)
• PQexec может возвратить только одну структуру PGresult. Если отправленная серверу стро-
ка-команда содержит множественные SQL-команды, то все структуры PGresult, кроме послед-
ней, отбрасываются функцией PQexec.
• PQexec всегда собирает все результаты выполнения команды, буферизуя их в единственной
структуре PGresult. В то время как для приложения это упрощает логику обработки ошибок,
это может быть непрактично, когда результат содержит много строк.
Приложения, которым эти ограничения не подходят, могут вместо PQexec использовать базовые
функции, на основе которых и построена функция PQexec: PQsendQuery и PQgetResult. Есть также
функции PQsendQueryParams, PQsendPrepare, PQsendQueryPrepared, PQsendDescribePrepared и
PQsendDescribePortal, которые можно использовать совместно с PQgetResult, чтобы продуб-
789libpq — библиотека для языка C
лировать функциональность PQexecParams, PQprepare, PQexecPrepared, PQdescribePrepared и
PQdescribePortal соответственно.
PQsendQuery
Отправляет команду серверу, не ожидая получения результата. Если команда была отправлена
успешно, то функция возвратит значение 1, в противном случае она возвратит 0 (тогда нуж-
но воспользоваться функцией PQerrorMessage для получения дополнительной информации о
сбое).
int PQsendQuery(PGconn *conn, const char *command);
После успешного вызова PQsendQuery вызовите PQgetResult один или несколько раз, чтобы по-
лучить результат. Функцию PQsendQuery нельзя вызвать повторно (на том же самом соедине-
нии) до тех пор, пока PQgetResult не вернёт нулевой указатель, означающий, что выполнение
команды завершено.
PQsendQueryParams
Отправляет серверу команду и обособленные параметры, не ожидая получения результатов.
int PQsendQueryParams(PGconn *conn,
const char *command,
int nParams,
const Oid *paramTypes,
const char * const *paramValues,
const int *paramLengths,
const int *paramFormats,
int resultFormat);
Эта функция эквивалентна функции PQsendQuery, за исключением того, что параметры запроса
можно указать отдельно от самой строки запроса. Эта функция обрабатывает свои параметры
точно так же, как и функция PQexecParams. Аналогично функции PQexecParams, данная функция
не будет работать при подключениях по протоколу версии 2.0, также она позволяет включить
только одну команду в строку запроса.
PQsendPrepare
Посылает запрос на создание подготовленного оператора с данными параметрами и не дожи-
дается завершения его выполнения.
int PQsendPrepare(PGconn *conn,
const char *stmtName,
const char *query,
int nParams,
const Oid *paramTypes);
Это асинхронная версия функции PQprepare. Она возвращает 1, если ей удалось отпра-
вить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию
PQgetResult, чтобы определить, успешно ли создал сервер подготовленный оператор. Эта функ-
ция обрабатывает свои параметры точно так же, как и функция PQprepare. Аналогично функ-
ции PQprepare, данная функция не будет работать при подключениях по протоколу версии 2.0.
PQsendQueryPrepared
Посылает запрос на выполнение подготовленного оператора с данными параметрами, не ожи-
дая получения результата.
int PQsendQueryPrepared(PGconn *conn,
const char *stmtName,
int nParams,
const char * const *paramValues,
const int *paramLengths,
const int *paramFormats,
int resultFormat);
790libpq — библиотека для языка C
Эта функция подобна функции PQsendQueryParams, но команда, которая должна быть выпол-
нена, задаётся путём указания предварительно подготовленного оператора, вместо задания
строки запроса. Эта функция обрабатывает свои параметры точно так же, как и функция
PQexecPrepared. Аналогично функции PQexecPrepared, данная функция не будет работать при
подключениях по протоколу версии 2.0.
PQsendDescribePrepared
Отправляет запрос на получение информации об указанном подготовленном операторе и не
дожидается завершения выполнения запроса.
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
Это асинхронная версия функции PQdescribePrepared. Она возвращает 1, если ей удалось от-
править запрос, и 0 в противном случае. После её успешного вызова следует вызвать функ-
цию PQgetResult для получения результата. Эта функция обрабатывает свои параметры точно
так же, как и функция PQdescribePrepared. Аналогично функции PQdescribePrepared, данная
функция не будет работать при подключениях по протоколу версии 2.0.
PQsendDescribePortal
Отправляет запрос на получение информации об указанном портале и не дожидается завер-
шения выполнения запроса.
int PQsendDescribePortal(PGconn *conn, const char *portalName);
Это асинхронная версия функции PQdescribePortal. Она возвращает 1, если ей удалось отпра-
вить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию
PQgetResult для получения результата. Эта функция обрабатывает свои параметры точно так
же, как и функция PQdescribePortal. Аналогично функции PQdescribePortal, данная функция
не будет работать при подключениях по протоколу версии 2.0.
PQgetResult
Ожидает получения следующего результата после предшествующего вызова PQsendQuery,
PQsendQueryParams, PQsendPrepare, PQsendQueryPrepared, PQsendDescribePrepared или
PQsendDescribePortal и возвращает его. Когда команда завершена и результатов больше не
будет, тогда возвращается нулевой указатель.
PGresult *PQgetResult(PGconn *conn);
Функция PQgetResult должна вызываться повторно до тех пор, пока она не вернёт нулевой ука-
затель, означающий, что команда завершена. (Если она вызвана, когда нет ни одной активной
команды, тогда PQgetResult просто возвратит нулевой указатель сразу же.) Каждый ненулевой
результат, полученный от PQgetResult, должен обрабатываться с помощью тех же самых функ-
ций доступа к структуре PGresult, которые были описаны выше. Не забывайте освобождать
память, занимаемую каждым результирующим объектом, с помощью функции PQclear, когда
работа с этим объектом закончена. Обратите внимание, что PQgetResult заблокируется, толь-
ко если какая-либо команда активна, а необходимые ответные данные ещё не были прочитаны
функцией PQconsumeInput.
Примечание
Даже когда PQresultStatus показывает фатальную ошибку, все равно следует вы-
зывать функцию PQgetResult до тех пор, пока она не возвратит нулевой указатель,
чтобы позволить libpq полностью обработать информацию об ошибке.
Использование PQsendQuery и PQgetResult решает одну из проблем PQexec: если строка команды
содержит несколько SQL-команд, то результаты каждой из них можно получить индивидуально.
(Между прочим, это позволяет организовать частичное совмещение обработки: клиент может об-
791libpq — библиотека для языка C
рабатывать результаты одной команды, в то время как сервер ещё работает с более поздними за-
просами, содержащимися в той же самой строке-команде.)
Ещё одной часто требующейся функциональной возможностью, которую можно получить с помо-
щью PQsendQuery и PQgetResult, является извлечение больших выборок по одной строке за раз.
Это обсуждается в Разделе 34.5.
Сам по себе вызов PQgetResult всё же заставит клиента заблокироваться до те пор, пока сервер не
завершит выполнение следующей SQL-команды. Этого можно избежать с помощью надлежащего
использования ещё двух функций:
PQconsumeInput
Если сервер готов передать данные, принять их.
int PQconsumeInput(PGconn *conn);
PQconsumeInput обычно возвращает 1, показывая, что «ошибки нет», но возвращает 0, если име-
ла место какая-либо проблема (в таком случае можно обратиться к функции PQerrorMessage
за уточнением). Обратите внимание, что результат не говорит, были ли какие-либо входные
данные фактически собраны. После вызова функции PQconsumeInput приложение может про-
верить PQisBusy и/или PQnotifies, чтобы посмотреть, не изменилось ли их состояние.
PQconsumeInput можно вызвать, даже если приложение ещё не готово иметь дело с результатом
или уведомлением. Функция прочитает доступные данные и сохранит их в буфере, при этом об-
рабатывая условие готовности к чтению функции select(). Таким образом, приложение может
использовать PQconsumeInput, чтобы немедленно обработать это состояние select(), а изучать
результаты позже.
PQisBusy
Возвращает 1, если команда занята работой, то есть функция PQgetResult была бы заблокиро-
вана в ожидании ввода. Возвращаемое значение 0 показывает, что функция PQgetResult при
её вызове гарантированно не будет заблокирована.
int PQisBusy(PGconn *conn);
Функция PQisBusy сама не будет пытаться прочитать данные с сервера; следовательно, сначала
нужно вызвать PQconsumeInput, иначе состояние занятости никогда не прекратится.
В типичном приложении, использующем эти функции, будет главный цикл, в котором функции
select() или poll() служат для организации ожидания наступления всех условий, на которые
цикл должен отвечать. Одним из условий будет наличие ввода, доступного от сервера, что в тер-
минах функции select() означает наличие данных, готовых для чтения на файловом дескрипто-
ре, идентифицируемом с помощью PQsocket. Когда главный цикл обнаруживает ввод, готовый для
чтения, он должен вызвать PQconsumeInput, чтобы прочитать этот ввод. Затем он может вызвать
PQisBusy, а после неё уже PQgetResult, если PQisBusy возвратит "ложь" (0). Главный цикл может
также вызвать PQnotifies, чтобы обнаружить сообщения NOTIFY (см. Раздел 34.8).
Клиент, который использует PQsendQuery/PQgetResult, может также попытаться отменить коман-
ду, которая всё ещё обрабатывается сервером; см. Раздел 34.6. Но, независимо от возвращаемого
значения функции PQcancel, приложение должно продолжать обычную последовательность опе-
раций чтения результатов запроса, используя PQgetResult. Успешная отмена просто заставит ко-
манду завершиться раньше, чем она сделала бы в противном случае.
Используя функции, описанные выше, можно избежать блокирования, ожидая ввода от сервера
баз данных. Однако, всё же возможно, что приложение будет заблокировано в ожидании отправ-
ки вывода на сервер. Это бывает относительно нечасто, но может иметь место, если отправлены
очень длинные SQL-команды или значения данных. (Однако, это значительно более вероятно, если
приложение отправляет данные через команду COPY IN.) Чтобы предотвратить эту возможность
и достичь совершенно неблокирующего режима работы с базой данных, можно использовать сле-
дующие дополнительные функции.
792libpq — библиотека для языка C
PQsetnonblocking
Устанавливает неблокирующий статус подключения.
int PQsetnonblocking(PGconn *conn, int arg);
Устанавливает состояние подключения как неблокирующее, если arg равен 1, или блокирую-
щее, если arg равен 0. Возвращает 0 в случае успешного завершения и -1 в случае ошибки.
В неблокирующем состоянии вызовы PQsendQuery, PQputline, PQputnbytes, PQputCopyData и
PQendcopy не будут блокироваться, а вместо этого возвратят ошибку, если вызов должен быть
повторным.
Обратите внимание, что функция PQexec не соблюдает неблокирующий режим. Если она вызы-
вается, она всё равно работает в блокирующем режиме.
PQisnonblocking
Возвращает режим блокирования для подключения базы данных.
int PQisnonblocking(const PGconn *conn);
Возвращает 1, если подключение установлено в неблокирующем режиме, и 0, если режим бло-
кирующий.
PQflush
Пытается сбросить любые выходные данные, стоящие в очереди, на сервер. Возвращает 0 в
случае успеха (или если очередь на отправку пуста), -1 в случае сбоя по какой-либо причине или
1, если она ещё не смогла отправить все данные, находящиеся в очереди (этот случай может
иметь место, только если соединение неблокирующее).
int PQflush(PGconn *conn);
После отправки любой команды или данных через неблокирующее подключение следует вызвать
функцию PQflush. Если она возвратит 1, подождите, пока сокет станет готовым к чтению или за-
писи. Если он станет готовым к записи, то вызовите PQflush снова. Если он станет готовым к чте-
нию, то вызовите PQconsumeInput, а затем вызовите PQflush снова. Повторяйте до тех пор, пока
PQflush не возвратит 0. (Необходимо выполнять проверку на состояние готовности к чтению и
забирать входные данные с помощью PQconsumeInput, потому что сервер может заблокироваться,
пытаясь отправить нам данные, например, сообщения NOTICE, и не будет читать наши данные до
тех пор, пока мы не прочитаем его.) Как только PQflush возвратит 0, подождите, пока сокет не
станет готовым к чтению, а затем прочитайте ответ, как описано выше.
34.5. Построчное извлечение результатов запроса
Обычно libpq собирает весь результат выполнения SQL-команды и возвращает его приложению в
виде единственной структуры PGresult. Это может оказаться неприемлемым для команд, которые
возвращают большое число строк. В таких случаях приложение может воспользоваться функция-
ми PQsendQuery и PQgetResult в однострочном режиме. В этом режиме результирующие строки
передаются приложению по одной за один раз, по мере того, как они принимаются от сервера.
Для того чтобы войти в однострочный режим, вызовите PQsetSingleRowMode сразу же после успеш-
ного вызова функции PQsendQuery (или родственной функции). Выбор этого режима действителен
только для текущего исполняющегося запроса. Затем повторно вызывайте функцию PQgetResult
до тех пор, пока она не возвратит null, как описано в Раздел 34.4. Если запрос возвращает какое-то
число строк, то они возвращаются в виде индивидуальных объектов PGresult, которые выглядят,
как обычные выборки, за исключением того, что их код статуса будет PGRES_SINGLE_TUPLE вместо
PGRES_TUPLES_OK. После последней строки (или сразу же, если запрос не возвращает ни одной стро-
ки) будет возвращён объект, не содержащий ни одной строки и имеющий статус PGRES_TUPLES_OK;
это сигнал о том, что строк больше не будет. (Но обратите внимание, что всё же необходимо про-
должать вызывать функцию PQgetResult, пока она не возвратит значение null.) Все эти объекты
793libpq — библиотека для языка C
PGresult будут содержать те же самые описательные данные (имена столбцов, типы и т. д.), кото-
рые имел бы обычный объект PGresult. Память, занимаемую каждым объектом, нужно освобож-
дать с помощью PQclear, как обычно.
PQsetSingleRowMode
Выбирает однострочный режим для текущего выполняющегося запроса.
int PQsetSingleRowMode(PGconn *conn);
Эту функцию можно вызывать только непосредственно после функции PQsendQuery или одной
из её родственных функций, до выполнения любой другой операции на этом подключении, та-
кой, как PQconsumeInput или PQgetResult. Будучи вызванной своевременно, функция активи-
рует однострочный режим для текущего запроса и возвращает 1. В противном случае режим
остаётся не изменённым, а функция возвращает 0. В любом случае режим возвращается в нор-
мальное состояние после завершения текущего запроса.
Внимание
В процессе обработки запроса сервер может возвратить некоторое количество строк,
а затем столкнуться с ошибкой, вынуждающей его аварийно завершить запрос. Обыч-
но libpq отбрасывает такие строки и сообщает только об ошибке. Но в однострочном
режиме эти строки уже будут возвращены приложению. Следовательно, приложение
увидит ряд объектов PGresult, имеющих статус PGRES_SINGLE_TUPLE, за которыми по-
следует объект со статусом PGRES_FATAL_ERROR. Для обеспечения надлежащего пове-
дения транзакций приложение должно быть спроектировано таким образом, чтобы от-
брасывать или отменять все операции, проведённые с уже обработанными строками,
если запрос в конечном итоге завершается сбоем.
34.6. Отмена запросов в процессе выполнения
Клиентское приложение может запросить отмену команды, которая ещё обрабатывается серве-
ром, используя функции, описанные в этом разделе.
PQgetCancel
Создаёт структуру данных, содержащую информацию, необходимую для отмены команды, за-
пущенной через конкретное подключение к базе данных.
PGcancel *PQgetCancel(PGconn *conn);
Функция PQgetCancel создаёт объект PGcancel, получив объект PGconn, описывающий подклю-
чение. Она возвратит NULL, если данный параметр conn равен NULL или представляет собой
недействительное подключения. Объект PGcancel является непрозрачной структурой, которая
не предназначена для того, чтобы приложение обращалось к ней напрямую; её можно только
передавать функции PQcancel или PQfreeCancel.
PQfreeCancel
Освобождает память, занимаемую структурой данных, созданной функцией PQgetCancel.
void PQfreeCancel(PGcancel *cancel);
PQfreeCancel освобождает память, занимаемую объектом, предварительно созданным функци-
ей PQgetCancel.
PQcancel
Требует, чтобы сервер прекратил обработку текущей команды.
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
794libpq — библиотека для языка C
Возвращаемое значение равно 1, если запрос на отмену был успешно отправлен, и 0 в против-
ном случае. В случае неудачной отправки errbuf заполняется пояснительным сообщением об
ошибке. errbuf должен быть массивом символов, имеющим размер errbufsize (рекомендуе-
мый размер составляет 256 байтов).
Успешная отправка ещё не является гарантией того, что запрос будет иметь какой-то эффект.
Если отмена сработала, текущая команда завершится досрочно и возвратит в качестве резуль-
тата ошибку. Если же отмена не получится (например, потому, что сервер уже завершил обра-
ботку команды), тогда вообще не будет видимого результата.
PQcancel можно безопасно вызывать из обработчика сигнала, если errbuf является локальной
переменной в обработчике сигнала. Объект PGcancel доступен только в режиме чтения, пока
речь идёт о функции PQcancel, поэтому её можно также вызывать из потока, отдельного от
того, который управляет объектом PGconn.
PQrequestCancel
PQrequestCancel является нерекомендуемым вариантом функции PQcancel.
int PQrequestCancel(PGconn *conn);
Выдаёт запрос на то, чтобы сервер прекратил обработку текущей команды. Функция работает
напрямую с объектом PGconn и в случае сбоя сохраняет сообщение об ошибке в объекте PGconn
(откуда его можно извлечь с помощью PQerrorMessage). Хотя функциональность та же самая,
этот подход создаёт риски для многопоточных программ и обработчиков сигналов, поскольку
возможно, что перезапись сообщения об ошибке, хранящегося в объекте PGconn, внесёт пута-
ницу в текущую операцию, выполняемую на данном подключении.
34.7. Интерфейс быстрого пути
PostgreSQL предоставляет интерфейс для передачи серверу простых вызовов функций по быстрому
пути.
Подсказка
Этот интерфейс несколько устарел, поскольку можно достичь подобной производи-
тельности и большей функциональности путём создания подготовленного оператора,
определяющего вызов функции. Последующее выполнение этого оператора с переда-
чей параметров и результатов в двоичном виде можно считать заменой вызову по быст-
рому пути.
Функция PQfnзапрашивает выполнение серверной функции посредством интерфейса быстрого до-
ступа:
PGresult *PQfn(PGconn *conn,
int fnid,
int *result_buf,
int *result_len,
int result_is_int,
const PQArgBlock *args,
int nargs);
typedef struct
{
int len;
int isint;
union
{
795libpq — библиотека для языка C
int *ptr;
int integer;
} u;
} PQArgBlock;
Аргумент fnid представляет собой OID функции, которая подлежит выполнению. args и nargs
определяют параметры, которые должны быть переданы этой функции; они должны соответство-
вать списку аргументов объявленной функции. Когда поле isint структуры, передаваемой в каче-
стве параметра, имеет значение "истина", тогда значение u.integer передаётся серверу в виде
целого числа указанной длины (это должно быть 2 или 4 байта); при этом устанавливается нуж-
ный порядок байтов. Когда isint имеет значение "ложь", тогда указанное число байтов по адре-
су *u.ptr отправляется без какой-либо обработки; данные должны быть представлены в формате,
которого ожидает сервер для передачи в двоичном виде данных того типа, что и аргументы функ-
ции. (Объявление поля u.ptr, как имеющего тип int *, является историческим; было бы лучше
рассматривать его как тип void *.) result_buf указывает на буфер, в который должно быть поме-
щено возвращаемое значение функции. Вызывающий код должен выделить достаточное место для
сохранения возвращаемого значения. (Это никак не проверяется!) Фактическая длина результи-
рующего значения в байтах будет возвращена в переменной целого типа, на которую указывает
result_len. Если ожидается получение двух- или четырёхбайтового целочисленного результата,
то присвойте параметру result_is_int значение 1, в противном случае назначьте ему 0. Когда
параметр result_is_int равен 1, libpq переставляет байты в передаваемом значении, если это
необходимо, так, чтобы оно было доставлено на клиентскую машину в виде правильного значения
типа int; обратите внимание, что по адресу *result_buf доставляется четырёхбайтовое целое для
любого допустимого размера результата. Когда result_is_int равен 0, тогда строка байтов в дво-
ичном формате, отправленная сервером, будет возвращена немодифицированной. (В этом случае
лучше рассматривать result_buf как имеющий тип void *.)
PQfn всегда возвращает действительный указатель на объект PGresult. Перед использованием ре-
зультата нужно сначала проверить его статус. Вызывающая функция отвечает за освобождение
памяти, занимаемой объектом PGresult, когда он больше не нужен, с помощью PQclear.
Обратите внимание, что при использовании этого интерфейса невозможно обработать NULL в ар-
гументах и результате, а также множества значений в результате.
34.8. Асинхронное уведомление
PostgreSQL предлагает асинхронное уведомление посредством команд LISTEN и NOTIFY. Клиент-
ский сеанс работы регистрирует свою заинтересованность в конкретном канале уведомлений с
помощью команды LISTEN (и может остановить прослушивание с помощью команды UNLISTEN). Все
сеансы, прослушивающие конкретный канал, будут уведомляться в асинхронном режиме, когда в
рамках любого сеанса команда NOTIFY выполняется с параметром, указывающим имя этого кана-
ла. Для передачи дополнительных данных прослушивающим сеансам может использоваться стро-
ка «payload».
Приложения, использующие libpq, отправляют серверу команды LISTEN, UNLISTEN и NOTIFY, как
обычные SQL-команды. Прибытие сообщений от команды NOTIFY можно впоследствии обнаружить
с помощью вызова функции PQnotifies.
Функция PQnotifies возвращает следующее уведомление из списка необработанных уведомитель-
ных сообщений, полученных от сервера. Она возвращает нулевой указатель, если нет уведомле-
ний, ожидающих обработки. Как только уведомление возвращено из функции PQnotifies, оно счи-
тается обработанным и будет удалено из списка уведомлений.
PGnotify *PQnotifies(PGconn *conn);
typedef struct pgNotify
{
char *relname;
int be_pid;
/* имя канала уведомлений */
/* ID серверного процесса, посылающего уведомление */
796libpq — библиотека для языка C
char *extra;
} PGnotify;
/* строка сообщения в уведомлении */
После обработки объекта PGnotify, возвращённого функцией PQnotifies, обязательно освободи-
те память, занимаемую им, с помощью функции PQfreemem. Достаточно освободить указатель на
PGnotify; поля relname и extra не представляют отдельных областей памяти. (Имена этих полей
являются таковыми по историческим причинам; в частности, имена каналов не обязаны иметь
ничего общего с именами реляционных отношений.)
Пример  34.2 представляет пример программы, иллюстрирующей использование асинхронного
уведомления.
Функция PQnotifies в действительности не читает данные с сервера; она просто возвращает сооб-
щения, предварительно собранные другой функцией библиотеки libpq. В очень старых выпусках
libpq обеспечить своевременное получения сообщений от команды NOTIFY можно было только од-
ним способом — постоянно отправлять команды, пусть даже пустые, а затем проверять PQnotifies
после каждого вызова PQexec. Хотя этот метод всё ещё работает, он считается устаревшим ввиду
неэффективного использования процессора.
Более хорошим способом проверки наличия сообщений от команды NOTIFY, когда у вас нет полез-
ных команд для выполнения, является вызов функции PQconsumeInput с последующей проверкой
PQnotifies. Вы можете использовать select(), чтобы подождать прибытия данных с сервера, тем
самым не используя мощности CPU, если нет полезной работы. (См. PQsocket насчёт получения
номера файлового дескриптора для использования его с select().) Обратите внимание, что это
будет хорошо работать, независимо от того, отправляете ли вы команды с помощью PQsendQuery/
PQgetResult или просто используете PQexec. Следует, однако, не забывать проверять PQnotifies
после каждого вызова PQgetResult или PQexec, чтобы увидеть, не прибыли ли какие-либо уведом-
ления в процессе обработки команды.
34.9. Функции, связанные с командой COPY
Команда COPY в PostgreSQL имеет возможность читать и записывать данные через сетевое под-
ключение, установленное libpq. Описанные в этом разделе функции позволяют приложениям вос-
пользоваться этой возможностью для передачи или приёма копируемых данных.
Общая процедура такова: сначала приложение выдаёт SQL-команду COPY, вызывая PQexec или од-
ну из подобных функций. В ответ оно должно получить (если не возникла ошибка) объект PGresult
с кодом состояния PGRES_COPY_OUT или PGRES_COPY_IN (в зависимости от направления копирова-
ния). Затем приложение должно использовать функции, описанные в этом разделе, и принимать
или передавать строки данных. По завершении передачи возвращается ещё один объект PGresult,
сообщающий о состоянии завершения передачи. В случае успеха он содержит код состояния
PGRES_COMMAND_OK, а если возникает какая-то проблема — PGRES_FATAL_ERROR. После этого можно
продолжать выполнять SQL-команды через PQexec. (Пока операция COPY не завершена, выполнять
другие SQL-команды через то же подключение нельзя.)
Если команда COPY была выполнена через PQexec в строке, содержащей дополнительные коман-
ды, приложение должно продолжить получать результаты через PQgetResult после завершения
последовательности COPY. Только когда PQgetResult возвращает NULL, можно с уверенностью счи-
тать, что командная строка PQexec выполнена полностью, и безопасно передавать другие команды.
Функции, описанные в этом разделе, должны выполняться только после получения кода состояния
PGRES_COPY_OUT или PGRES_COPY_IN от функции PQexec или PQgetResult.
Объект PGresult с таким кодом состояния содержит дополнительные данные о начавшейся опе-
рации COPY. Эти данные можно получить функциями, также применяющимися при обработке ре-
зультатов запроса:
PQnfields
Возвращает число копируемых столбцов (полей).
797libpq — библиотека для языка C
PQbinaryTuples
Значение 0 указывает, что для всей операции копирования применяется текстовый формат
(строки разделяются символами новой строки, столбцы разделяются символами-разделителя-
ми и т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный
формат. За дополнительными сведениями обратитесь к COPY.
PQfformat
Возвращает код формата (0 — текстовый, 1 — двоичный), связанный с каждым копируемым
столбцом. Коды форматов столбцов всегда будут нулевыми, если общий формат копирования —
текстовый, но с двоичным форматом поддерживаются и текстовые, и двоичные столбцы. (Од-
нако в текущей реализации COPY при двоичном копировании столбцы могут быть только двоич-
ными, так что форматы столбцов должны всегда соответствовать общему формату.)
Примечание
Эти дополнительные значения данных доступны только при использовании протокола
3.0. С протоколом 2.0 все эти функции возвращают 0.
34.9.1. Функции для передачи данных COPY
Эти функции применяются для передачи данных при операции COPY FROM STDIN. Они не будут
работать, если подключение находится не в состоянии COPY_IN.
PQputCopyData
Отправляет данные на сервер, когда активно состояние COPY_IN.
int PQputCopyData(PGconn *conn,
const char *buffer,
int nbytes);
Передаёт серверу данные COPY из указанного буфера (buffer), длиной nbytes байт. Она возвра-
щает 1, если данные были переданы, 0, если они не попали в очередь, так как буферы были
заполнены (это возможно только в неблокирующем режиме), или -1, если произошла ошибка.
(Если возвращено -1, подробности ошибки можно узнать, вызвав PQerrorMessage. Если получен
0, дождитесь состояния готовности к записи и повторите попытку.)
Приложение может разделять поток данных COPY на буферизуемые блоки любого удобного раз-
мера. Границы буфера не имеют семантического значения при передаче. Содержимое потока
данных должно соответствовать формату данных, ожидаемому командой COPY; за подробностя-
ми обратитесь к COPY.
PQputCopyEnd
Отправляет признак конца данных на сервер, когда активно состояние COPY_IN.
int PQputCopyEnd(PGconn *conn,
const char *errormsg);
Завершает операцию COPY_IN с успешным результатом, если в errormsg передаётся NULL. Если
errormsg не NULL, команда COPY будет завершена с ошибкой, а сообщением об ошибке будет
строка, переданная в errormsg. (Однако не следует полагать, что именно это сообщение будет
получено от сервера назад, так как сервер мог уже прервать операцию COPY по своим причинам.
Также заметьте, что принудительный вызов ошибки не работает с соединениями по протоколу
версии до 3.0.)
Эта функция возвращает 1, если сообщение завершения было передано; в неблокирующем ре-
жиме это означает только, что сообщение завершения успешно поставлено в очередь. (Чтобы
798libpq — библиотека для языка C
удостовериться, что данные были успешно отправлены в неблокирующем режиме, следует до-
ждаться готовности к записи и вызывать PQflush в цикле, пока она не вернёт ноль.) Нулевой ре-
зультат означает, что функция не смогла поставить сообщение завершения в очередь по причи-
не заполнения буферов; это возможно только в неблокирующем режиме. (В этом случае нужно
дождаться готовности к записи и попытаться вызвать PQputCopyEnd снова.) Если действительно
происходит ошибка, возвращается -1; получить её подробности можно, вызвав PQerrorMessage.
После успешного вызова PQputCopyEnd вызовите PQgetResult, чтобы узнать окончательный ре-
зультат команды COPY. Ожидать появления этого результата можно обычным образом. Затем
вернитесь к обычным операциям.
34.9.2. Функции для приёма данных COPY
Эти функции применяются для получения данных при операции COPY TO STDOUT. Они не будут
работать, если подключение находится не в состоянии COPY_OUT.
PQgetCopyData
Принимает данные от сервера, когда активно состояние COPY_OUT.
int PQgetCopyData(PGconn *conn,
char **buffer,
int async);
Запрашивает следующую строку данных с сервера в процессе операции COPY. Данные всегда
возвращаются строка за строкой; если поступила только часть строки, она не возвращается.
Успешное получение строки данных подразумевает выделение блока памяти для этих данных.
В параметре buffer ей передаётся указатель, отличный от NULL. По адресу *buffer записыва-
ется указатель на выделенную память, либо NULL, когда буфер не возвращается. Если буфер ре-
зультата отличен от NULL, его следует освободить, когда он станет не нужен, вызвав PQfreemem.
Когда строка получена успешно, возвращается число байт данных в этой строке (это число
всегда больше нуля). Возвращаемое строковое значение всегда завершается нулём, хотя это
полезно, вероятно, только для текстовой COPY. Нулевой результат означает, что операция COPY
продолжает выполняться, но строка ещё не готова (это возможно, только когда параметр async
равен true). Возвращённое значение -1 означает, что команда COPY завершена, а -2 показывает,
что произошла ошибка (её причину можно узнать с помощью PQerrorMessage).
Когда параметр async равен true (отличен от нуля), функция PQgetCopyData не будет блокиро-
ваться, ожидая данных; она возвратит ноль, если выполнение COPY продолжается, но полная
строка ещё не получена. (В этом случае нужно дождаться готовности к чтению и затем вызвать
PQconsumeInput, прежде чем вызывать PQgetCopyData ещё раз.) Когда async равен false (нулю),
PQgetCopyData будет заблокирована до поступления данных или окончания операции.
Когда PQgetCopyData возвращает -1, вызовите PQgetResult, чтобы узнать окончательный ре-
зультат команды COPY. Ожидать появления этого результата можно обычным образом. Затем
вернитесь к обычным операциям.
34.9.3. Устаревшие функции для COPY
Эти функции представляют старые методы выполнения операции COPY. Хотя они продолжают ра-
ботать, они признаны устаревшими из-за плохой обработки ошибок, неудобных способов обнару-
жения конца данных и отсутствия поддержки двоичных или неблокирующих передач.
PQgetline
Читает передаваемую сервером строку символов, завершающуюся символом новой строки, в
буфер (buffer) размера length.
int PQgetline(PGconn *conn,
char *buffer,
799libpq — библиотека для языка C
int length);
Эта функция копирует length-1 символов в буфер и преобразует символ конца строки в нулевой
байт. PQgetline возвращает EOF в конце ввода, 0, если была прочитана вся строка, и 1, если
буфер заполнен, но завершающий символ конца строки ещё не прочитан.
Заметьте, что приложение должно проверить, не состоит ли новая строка в точности из двух
символов \., что будет означать, что сервер завершил передачу результатов команды COPY. Ес-
ли приложение может принимать строки длиннее length-1 символов, необходимо позаботить-
ся о том, чтобы оно корректно распознавало строку \. (а не воспринимало, например, конец
длинной строки данных как завершающую строку).
PQgetlineAsync
Читает передаваемую сервером строку данных COPY в буфер без блокировки.
int PQgetlineAsync(PGconn *conn,
char *buffer,
int bufsize);
Эта функция похожа на PQgetline, но может применяться в приложениях, которые должны
читать данные COPY асинхронно, то есть, без блокировки. Запустив команду COPY и получив
ответ PGRES_COPY_OUT, приложение должно вызывать PQconsumeInput и PQgetlineAsync, пока
не будет получен сигнал конца данных.
В отличие от PQgetline, эта функция сама отвечает за обнаружение конца данных.
При каждом вызове PQgetlineAsync будет возвращать данные, если во входном буфере libpq
оказывается полная строка данных. В противном случае никакие данные не возвращаются до
поступления остального содержимого строки. Эта функция возвращает -1, если обнаружива-
ется признак завершения копирования, или 0, если данные не получены, или положительное
количество возвращённых байт данных. Если возвращается -1, вызывающий код должен затем
вызвать PQendcopy и после этого перейти в обычный режим работы.
Возвращаемые данные не будут пересекать границы строк данных. При этом может быть воз-
вращена одна строка целиком. Но если буфер, выделенный вызывающим кодом, оказывается
слишком мал для строки, передаваемой сервером, возвращена будет часть строки. Когда пере-
даются текстовые данные, это можно выявить, проверив, содержит ли последний возвращае-
мый байт символ \n. (Для COPY в двоичном формате потребуется собственно разобрать формат
данных COPY, чтобы выявить подобную ситуацию.) Возвращаемая строка не завершается нулём.
(Если вы хотите получить строку с нулём в конце, передайте в bufsize число на единицу мень-
ше фактического размера блока.)
PQputline
Передаёт серверу строку, завершённую нулём. Возвращает 0 в случае успеха, либо EOF, если
передать строку не удаётся.
int PQputline(PGconn *conn,
const char *string);
Поток данных COPY, передаваемых последовательностью вызовов PQputline, имеет тот же фор-
мат, что возвращает PQgetlineAsync, за исключением того, что приложения не обязательно
должны передавать по одной строке данных за вызов PQputline; они могут посылать части
строк или сразу несколько строк.
Примечание
До версии 3.0 протокола PostgreSQL приложение должно было явно отправлять два
символа \. последней строкой, чтобы сообщить серверу, что оно закончило переда-
800libpq — библиотека для языка C
чу данных COPY. Хотя это по-прежнему работает, такое поведение считается уста-
ревшим и ожидается, что особое значение \. будет исключено в будущих версиях.
Передав собственно данные, сейчас достаточно вызвать PQendcopy.
PQputnbytes
Передаёт серверу строку, не завершённую нулём. Возвращает 0 в случае успеха, либо EOF, если
передать строку не удаётся.
int PQputnbytes(PGconn *conn,
const char *buffer,
int nbytes);
Поведение этой функции не отличается от PQputline, но её буфер данных не должен содержать
завершающий ноль, так как для неё число передаваемых байт задаётся непосредственно. Ис-
пользуйте эту функцию для передачи двоичных данных.
PQendcopy
Производит синхронизацию с сервером.
int PQendcopy(PGconn *conn);
Эта функция ожидает завершения копирования сервером. Её следует вызывать, либо когда
серверу была передана последняя строка функцией PQputline, либо когда от сервера была
получена последняя строка функцией PGgetline. Если её не вызвать, сервер «потеряет син-
хронизацию» с клиентом. После завершения этой функции сервер готов принимать следую-
щую команду SQL. В случае успешного завершения возвращается 0, в противном случае —
ненулевое значение. (Чтобы получить подробности ошибки при ненулевом значении, вызовите
PQerrorMessage.)
Вызывая PQgetResult, приложение должно обрабатывать результат PGRES_COPY_OUT, в цикле
выполняя PQgetline, а обнаружив завершающую строку, вызвать PQendcopy. Затем оно долж-
но вернуться к циклу PQgetResult, и выйти из него, когда PQgetResult возвратит нулевой
указатель. Подобным образом, получив результат PGRES_COPY_IN, приложение должно выпол-
нить серию вызовов PQputline, завершить её, вызвав PQendcopy, а затем вернуться к циклу
PQgetResult. При такой организации обработки команда COPY будет корректно выполняться и
в составе последовательности команд SQL.
Старые приложения обычно передают команду COPY через PQexec и рассчитывают, что тран-
закция будет завершена после PQendcopy. Это будет работать, только если команда COPY явля-
ется единственной SQL-командой в строке команд.
34.10. Функции управления
Эти функции управляют различными аспектами поведения libpq.
PQclientEncoding
Возвращает кодировку клиента.
int PQclientEncoding(const PGconn *conn);
Заметьте, что она возвращает идентификатор кодировки, а не символьную строку вида EUC_JP.
В случае ошибки она возвращает -1. Преобразовать идентификатор кодировки в имя можно,
воспользовавшись следующей функцией:
char *pg_encoding_to_char(int encoding_id);
PQsetClientEncoding
Устанавливает кодировку клиента.
801libpq — библиотека для языка C
int PQsetClientEncoding(PGconn *conn, const char *encoding);
В conn передаётся соединение с сервером, а в encoding — имя требуемой кодировки. Ес-
ли функция устанавливает кодировку успешно, она возвращает 0, или -1 в противном слу-
чае. Определить текущую кодировку для соединения можно, воспользовавшись функцией
PQclientEncoding.
PQsetErrorVerbosity
Определяет уровень детализации сообщений, возвращаемых функциями PQerrorMessage и
PQresultErrorMessage.
typedef enum
{
PQERRORS_TERSE,
PQERRORS_DEFAULT,
PQERRORS_VERBOSE
} PGVerbosity;
PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
PQsetErrorVerbosity устанавливает уровень детализации и возвращает предыдущее значение
для соединения. В «лаконичном» режиме (TERSE) возвращаемые сообщения содержат только
уровень серьёзности, основной текст и позицию; всё это обычно умещается в одной строке. В
режиме по умолчанию выдаваемые сообщения дополнительно содержат поля подробного опи-
сания, подсказки или контекста (они могут занимать несколько строк). В «многословном» ре-
жиме (VERBOSE) передаются все доступные поля сообщения. Изменение уровня детализации
не влияет на сообщения, уже сформированные в существующих объектах PGresult, а затрагива-
ет только последующие сообщения. (Но можно воспользоваться PQresultVerboseErrorMessage,
чтобы получить предыдущую ошибку с другим уровнем детализации.)
PQsetErrorContextVisibility
Определяет вариант обработки полей КОНТЕКСТ в сообщениях, возвращаемых функциями
PQerrorMessage и PQresultErrorMessage.
typedef enum
{
PQSHOW_CONTEXT_NEVER,
PQSHOW_CONTEXT_ERRORS,
PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;
PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility
show_context);
PQsetErrorContextVisibility устанавливает режим вывода контекста сообщений и возвраща-
ет предыдущее значение. В зависимости от этого режима, поле КОНТЕКСТ может включаться
в сообщения или нет (если только не выбран уровень детализации TERSE, при котором КОН-
ТЕКСТ не выводится никогда). В режиме NEVER поле КОНТЕКСТ не выводится никогда, а в ре-
жиме ALWAYS, выводится всегда (если оно имеется). В режиме ERRORS (по умолчанию), поля
CONTEXT включаются только в сообщения об ошибках, но не в уведомления или предупрежде-
ния. Изменение этого уровня не влияет на сообщения, уже сформированные в существующих
объектах PGresult, а затрагивает только последующие сообщения. (Но можно воспользоваться
PQresultVerboseErrorMessage, чтобы получить предыдущую ошибку с другим режимом вывода
контекста.)
PQtrace
Включает трассировку клиент-серверного взаимодействия с выводом в поток отладочных со-
общений.
802libpq — библиотека для языка C
void PQtrace(PGconn *conn, FILE *stream);
Примечание
В Windows, если библиотека libpq и приложение скомпилированы с разными фла-
гами, эта функция может вызвать крах приложения из-за различий внутреннего
представления указателей FILE. В частности, флаги многопоточной/однопоточной,
выпускаемой/отладочной или статической/динамической сборки должны быть оди-
наковыми для библиотеки и всех использующих её приложений.
PQuntrace
Выключает трассировку, запущенную функцией PQtrace.
void PQuntrace(PGconn *conn);
34.11. Функции разного назначения
Как всегда, находятся функции, которые не попадают ни в одну из категорий.
PQfreemem
Освобождает память, которую выделила libpq.
void PQfreemem(void *ptr);
Освобождает память, выделенную библиотекой libpq, а именно функциями PQescapeByteaConn,
PQescapeBytea, PQunescapeBytea и PQnotifies. Особенно важно использовать именно эту функ-
цию, а не free(), в Microsoft Windows. Это связано с тем, что выделение памяти в DLL и осво-
бождение её в приложении будет работать, только если флаги многопоточной/однопоточной,
выпускаемой/отладочной или статической/динамической сборки для DLL и приложения пол-
ностью совпадают. На других платформах эта функция действует так же, как стандартная биб-
лиотечная функция free().
PQconninfoFree
Освобождает структуры данных, выделенные функциями PQconndefaults и PQconninfoParse.
void PQconninfoFree(PQconninfoOption *connOptions);
Простая функция PQfreemem не подойдёт для этого, так как эти структуры содержат ссылки на
подчинённые строки.
PQencryptPasswordConn
Подготавливает зашифрованную форму пароля PostgreSQL.
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user,
const char *algorithm);
Эта функция предназначена для клиентских приложений, желающих передавать команды ви-
да ALTER USER joe PASSWORD 'pwd'. В такой команде лучше не передавать исходный пароль
открытым текстом, так как он может появиться в журналах команд, мониторе активности и т. д.
Вместо этого воспользуйтесь данной функцией и переведите пароль в зашифрованную форму.
В аргументах passwd и user задаётся пароль в открытом виде и SQL-имя пользователя, для
которого он задаётся. В аргументе algorithm задаётся алгоритм для шифрования пароля. В
настоящее время поддерживаются алгоритмы md5 и scram-sha-256 (в качестве альтернатив-
ных обозначений md5 для совместимости со старыми версиями сервера поддерживаются зна-
чения on и off). Заметьте, что поддержка scram-sha-256 появилась в PostgreSQL версии 10 и
803libpq — библиотека для языка C
со старыми версиями серверов этот вариант работать не будет. Если algorithm равен NULL, эта
функция запросит у сервера текущее значение параметра password_encryption. При этом воз-
можна блокировка и отказ при выполнении функции, если текущая транзакция прерывается
или если в текущем соединении выполняется другой запрос. Если вы хотите использовать ал-
горитм по умолчанию для данного сервера, но при этом избежать блокировки, получите значе-
ние password_encryption самостоятельно до вызова PQencryptPasswordConn, и передайте его
в параметре algorithm.
Эта функция возвращает строку, выделенную функцией malloc. Вызывающий код может рас-
считывать на то, что эта строка не содержит никаких спецсимволов, требующих экранирова-
ния. Закончив работу с ней, освободите память, вызвав PQfreemem. В случае ошибки эта функ-
ция возвращает NULL, а соответствующее сообщение помещается в объект соединения.
PQencryptPassword
Подготавливает зашифрованную md5 форму пароля PostgreSQL.
char *PQencryptPassword(const char *passwd, const char *user);
PQencryptPassword — старая, подлежащая ликвидации версия PQencryptPasswodConn. Отличие
состоит в том, что для PQencryptPassword не требуется объект соединения, а в качестве алго-
ритма шифрования всегда используется md5.
PQmakeEmptyPGresult
Конструирует пустой объект PGresult с указанным состоянием.
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
Это внутренняя функция libpq, выделяющая память и инициализирующая пустой объект
PGresult. Эта функция возвращает NULL, если не может выделить память. Она сделана экспор-
тируемой, так как некоторые приложения находят полезным создавать объекты результатов
(в частности, объекты с состоянием ошибки) самостоятельно. Если в conn передаётся не null и
status указывает на ошибку, в PGresult копируется текущее сообщение об ошибке для задан-
ного соединения. Также, если в conn передаётся не null, в PGresult копируются все процедуры
событий, зарегистрированные для этого соединения. (При этом вызовы PGEVT_RESULTCREATE не
выполняются; см. описание PQfireResultCreateEvents.) Заметьте, что в конце для этого объ-
екта следует вызвать PQclear, как и для объекта PGresult, возвращённого самой библиотекой
libpq.
PQfireResultCreateEvents
Вызывает событие PGEVT_RESULTCREATE (см. Раздел 34.13) для каждой процедуры событий, за-
регистрированной в объекте PGresult. Возвращает ненулевое значение в случае успеха или
ноль в случае ошибки в одной из процедур.
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
Аргумент conn передаётся процедурам событий, но непосредственно не используется. Он мо-
жет быть равен NULL, если он не нужен процедурам событий.
Процедуры событий, уже получившие событие PGEVT_RESULTCREATE или PGEVT_RESULTCOPY для
этого объекта, больше не вызываются.
Основная причина отделения этой функции от PQmakeEmptyPGresult в том, что часто требуется
создать объект PGresult и наполнить его данными, прежде чем вызывать процедуры событий.
PQcopyResult
Создаёт копию объекта PGresult. Эта копия никак не связана с исходным результатом и поэто-
му, когда она становится не нужна, необходимо вызвать PQclear. Если функция завершается
ошибкой, она возвращает NULL.
804libpq — библиотека для языка C
PGresult *PQcopyResult(const PGresult *src, int flags);
Создаваемая копия не будет точной. В возвращаемый результат всегда помещается состо-
яние PGRES_TUPLES_OK и в него не копируются никакие сообщения об ошибках из исходно-
го объекта. (Однако в него копируется строка состояния команды.) Что ещё в него будет
копироваться, определяет аргумент flags, в котором складываются несколько флагов. Флаг
PG_COPYRES_ATTRS включает копирование атрибутов исходного объекта (определений столб-
цов), а флаг PG_COPYRES_TUPLES включает копирование кортежей из исходного объекта (при
этом также копируются и атрибуты.) Флаг PG_COPYRES_NOTICEHOOKS включает копирование об-
работчиков замечаний, а флаг PG_COPYRES_EVENTS — событий из исходного объекта результата.
(Но любые данные, связанные с экземпляром исходного объекта, не копируются.)
PQsetResultAttrs
Устанавливает атрибуты объекта PGresult.
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
Предоставленная структура attDescs копируется в результат. Если указатель attDescs равен
NULL или numAttributes меньше одного, запрос игнорируется и функция выполняется без ошиб-
ки. Если res уже содержит атрибуты, функция завершается ошибкой. В случае ошибки функ-
ция возвращает ноль, а в обратном случае — ненулевое значение.
PQsetvalue
Устанавливает значение поля кортежа в объекте PGresult.
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
Эта функция автоматически увеличивает внутренний массив кортежей при необходимости. Од-
нако значение tup_num должно быть меньше или равно PQntuples, что означает, что эта функ-
ция может увеличивать массив кортежей только на один кортеж. Но в существующем кортеже
любые поля могут изменяться в любом порядке. Если значение в поле с номером field_num уже
существует, оно будет перезаписано. Если len равно -1 или value равно NULL, в поле будет за-
писано значение SQL NULL. Устанавливаемое значение (value) копируется в закрытую область
объекта результата, так что от него можно избавиться после завершения функции. Если функ-
ция завершается ошибкой, она возвращает ноль, а в обратном случае — ненулевое значение.
PQresultAlloc
Выделяет подчинённую область памяти для объекта PGresult.
void *PQresultAlloc(PGresult *res, size_t nBytes);
Любая память, выделенная этой функцией, будет освобождена при очистке объекта res. В слу-
чае ошибки эта функция возвращает NULL. Результат гарантированно выравнивается должным
образом для любого типа данных, как и при malloc.
PQlibVersion
Возвращает версию используемой библиотеки libpq.
int PQlibVersion(void);
По результату этой функции можно во время выполнения определить, предоставляется ли
определённая функциональность загруженной в данный момент версией libpq. Эта функция
может использоваться, например, чтобы понять, какие параметры соединения может принять
PQconnectdb.
Это число формируется в результате умножения номера основной версии библиотеки на 10000
и добавления номера дополнительной версии. Например, для версии 10.1 будет выдано 100001,
а для версии 11.0 — 110000.
805libpq — библиотека для языка C
До версии 10, в PostgreSQL номера версий образовывались из трёх чисел, первые два из которых
представляли основную версию. Для таких версий PQlibVersion отводит на каждое число по
две цифры; например, для версии 9.1.5 будет выдано 90105, а для версии 9.2.0 — 90200.
Таким образом, чтобы получить логический номер версии для определения доступности функ-
ционала, приложения должны разделить результат PQlibVersion на 100, а не на 10000. Во
всех сериях номера дополнительных (корректирующих) выпусков различаются только в двух
последних цифрах.
Примечание
Эта функция появилась в PostgreSQL версии 9.1, поэтому с её помощью нельзя про-
верить функциональность предыдущих версий, так как при вызове её будет создана
зависимость от версии 9.1 или новее.
34.12. Обработка замечаний
Сообщения с замечаниями и предупреждениями, выдаваемые сервером, не возвращаются функ-
циями, выполняющими запросы, так как они не свидетельствуют об ошибке в запросе. Вместо
этого они передаются функции обработки замечаний и после завершения этой функции выполне-
ние продолжается как обычно. Стандартная функция обработки замечаний выводит сообщение в
stderr, но приложение может переопределить это поведение, предоставив собственный обработ-
чик.
По историческим причинам обработка замечаний выполняется на двух уровнях, приёмником за-
мечаний и обработчиком замечаний. По умолчанию приёмник замечаний форматирует замечание
и передаёт сформированную строку обработчику замечаний для вывода. Однако приложения, ко-
торые реализуют свой приёмник замечаний, обычно просто игнорируют слой обработчика и вы-
полняют все действия в коде приёмника.
Функция PQsetNoticeReceiver устанавливает или возвращает текущий приёмник замечаний для
объекта соединения. Подобным образом, PQsetNoticeProcessor устанавливает или возвращает те-
кущий обработчик замечаний.
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);
PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
PQnoticeReceiver proc,
void *arg);
typedef void (*PQnoticeProcessor) (void *arg, const char *message);
PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
PQnoticeProcessor proc,
void *arg);
Каждая из этих функций возвращает указатель на ранее установленный приёмник или обработчик
замечаний и устанавливает новый указатель. Если ей передаётся нулевой указатель, она ничего
не делает, только возвращает текущий указатель.
Когда сообщение с замечанием или предупреждением поступает от сервера, либо выдаётся самой
библиотекой libpq, вызывается функция приёмника замечания. Сообщение передаётся ей в виде
состояния PGRES_NONFATAL_ERROR объекта PGresult. (Это позволяет приёмнику извлечь из него от-
дельные поля, используя PQresultErrorField, либо получить полное готовое сообщение, вызвав
PQresultErrorMessage или PQresultVerboseErrorMessage.) Ей также передаётся тот же неопреде-
806libpq — библиотека для языка C
лённый указатель, что был передан функции PQsetNoticeReceiver. (Этот указатель может приго-
диться для обращения к внутреннему состоянию приложения при необходимости.)
Стандартный приёмник замечаний просто извлекает сообщение (вызывая PQresultErrorMessage)
и передаёт его обработчику замечаний.
Обработчик замечаний отвечает за обработку сообщения с замечанием или предупреждением в
текстовом виде. Ему передаётся строка с текстом сообщения (включающая завершающий символ
новой строки) и неопределённый указатель, который был передан функции PQsetNoticeProcessor.
(Этот указатель может пригодиться для обращения к внутреннему состоянию приложения при
необходимости.)
Стандартный обработчик замечаний прост:
static void
defaultNoticeProcessor(void *arg, const char *message)
{
fprintf(stderr, "%s", message);
}
Установив приёмник или обработчик замечаний, вы можете ожидать, что эта функция будет вы-
зываться, пока будут существовать объект PGconn или объекты PGresult, созданные с ней. Когда
создаётся PGresult, указатели текущих обработчиков замечаний, установленные в PGconn, копи-
руются в PGresult для возможного использования функциями вроде PQgetvalue.
34.13. Система событий
Система событий libpq разработана для уведомления функций-обработчиков об интересных собы-
тиях libpq, например, о создании и уничтожении объектов PGconn и PGresult. Основное их предна-
значение в том, чтобы позволить приложениям связать собственные данные с объектами PGconn
и PGresult и обеспечить их освобождение в нужное время.
Каждый зарегистрированный обработчик событий связывается с двумя элементами данных, ко-
торые известны libpq только как скрытые указатели void *. Первый сквозной указатель пере-
даётся приложением, когда обработчик событий регистрируется в PGconn. Этот указатель ни-
когда не меняется на протяжении жизни PGconn и все объекты PGresult создаются с ним; по-
этому, если он используется, он должен указывать на долгоживущие данные. В дополнение
к нему имеется указатель данных экземпляра, который изначально равен NULL во всех объек-
тах PGconn и PGresult. Этим указателем можно управлять с помощью функций PQinstanceData,
PQsetInstanceData, PQresultInstanceData и PQsetResultInstanceData. Заметьте, что в отличие
от сквозного указателя, данные экземпляра PGconn автоматически не наследуются объектами
PGresult, создаваемыми из него. Библиотека libpq не знает, на что указывают сквозной указатель
и указатель данных экземпляра (если они ненулевые) и никогда не будет пытаться освобождать
их — за это отвечает обработчик событий.
34.13.1. Типы событий
Перечисление PGEventId описывает типы событий, обрабатываемых системой событий. Имена
всех их значений начинаются с PGEVT. Для каждого типа событий имеется соответствующая струк-
тура информации о событии, содержащая параметры, передаваемые обработчикам событий. Опре-
делены следующие типы событий:
PGEVT_REGISTER
Событие регистрации происходит, когда вызывается PQregisterEventProc. Это идеальное вре-
мя для инициализации данных экземпляра (instanceData), которые могут понадобиться проце-
дуре событий. Для каждого обработчика событий в рамках соединения будет выдаваться только
одно событие регистрации. Если обработка события завершается ошибкой, регистрация пре-
рывается.
807libpq — библиотека для языка C
typedef struct
{
PGconn *conn;
} PGEventRegister;
При поступлении события PGEVT_REGISTER указатель evtInfo следует привести к
PGEventRegister *. Эта структура содержит объект PGconn, который должен быть в состоянии
CONNECTION_OK; это гарантируется, если PQregisterEventProc вызывается сразу после получе-
ния рабочего объекта PGconn. В случае выдачи кода ошибки всю очистку необходимо провести
самостоятельно, так как событие PGEVT_CONNDESTROY не поступит.
PGEVT_CONNRESET
Событие сброса соединения происходит при завершении PQreset или PQresetPoll. В обоих слу-
чаях это событие вызывается, только если сброс был успешным. Если обработка события завер-
шается ошибкой, происходит сбой всей операции сброса соединения; объект PGconn переходит
в состояние CONNECTION_BAD и PQresetPoll возвращает PGRES_POLLING_FAILED.
typedef struct
{
PGconn *conn;
} PGEventConnReset;
При поступлении события PGEVT_CONNRESET указатель evtInfo следует привести к
PGEventConnReset *. Хотя переданный объект PGconn был только что сброшен, все дан-
ные события остаются неизменными. При поступлении этого события должны быть сбро-
шены/перезагружены/вновь запрошены все сопутствующие данные instanceData. Заметьте,
что даже если обработчик события выдаст ошибку при обработке PGEVT_CONNRESET, событие
PGEVT_CONNDESTROY всё равно поступит при закрытии соединения.
PGEVT_CONNDESTROY
Событие уничтожения соединения вызывается в ответ на вызов PQfinish. Обработчик этого
события отвечает за корректную очистку своих данных событий, так как libpq не может управ-
лять его памятью. Невыполнение очистки должным образом приведёт к утечкам памяти.
typedef struct
{
PGconn *conn;
} PGEventConnDestroy;
При поступлении события PGEVT_CONNDESTROY указатель evtInfo следует привести к
PGEventConnDestroy *. Это событие происходит перед тем, как PQfinish производит всю
остальную очистку. Значение, возвращаемое обработчиком событий, игнорируется, так как из
PQfinish никак нельзя сообщить об ошибке. Кроме того, ошибка в обработчике событий не
должна прерывать процесс очистки ставшей ненужной памяти.
PGEVT_RESULTCREATE
Событие создания объекта результата происходит при завершении любой функции, выполня-
ющей запрос и получающей результат, включая PQgetResult. Это событие происходит только
после того, как результат был успешно получен.
typedef struct
{
PGconn *conn;
PGresult *result;
} PGEventResultCreate;
При поступлении события PGEVT_RESULTCREATE указатель evtInfo следует привести к
PGEventResultCreate *. В conn передаётся соединение, для которого сформирован результат.
Это идеальное место для инициализации любых данных instanceData, которые нужно связать
808libpq — библиотека для языка C
с результатом. В случае сбоя обработчика объект результата очищается и ошибка распростра-
няется дальше. Обработчик события не должен пытаться выполнять PQclear для объекта ре-
зультата самостоятельно. Возвращая ошибку, необходимо выполнить очистку данных, так как
событие PGEVT_RESULTDESTROY для этого объекта не поступит.
PGEVT_RESULTCOPY
Событие копирования объекта результата происходит при выполнении функции PQcopyResult.
Это событие происходит только после того, как копирование будет завершено. Только
те обработчики событий, которые успешно обработали событие PGEVT_RESULTCREATE или
PGEVT_RESULTCOPY для исходного объекта, получат событие PGEVT_RESULTCOPY.
typedef struct
{
const PGresult *src;
PGresult *dest;
} PGEventResultCopy;
При поступлении события PGEVT_RESULTCOPY указатель evtInfo следует привести к
PGEventResultCopy *. Поле src указывает на объект результата, который копируется, а dest
— на целевой объект. Это событие может применяться для реализации внутреннего копирова-
ния instanceData, так как сама функция PQcopyResult не может это сделать. В случае сбоя
обработчика вся операция копирования прерывается и объект результата в dest очищается.
Возвращая ошибку, необходимо выполнить очистку данных целевого объекта, так как событие
PGEVT_RESULTDESTROY для него не поступит.
PGEVT_RESULTDESTROY
Событие уничтожения объекта результата происходит при выполнении PQclear. Обработчик
этого события отвечает за корректную очистку своих данных событий, так как libpq не может
управлять его памятью. Невыполнение очистки должным образом приведёт к утечкам памяти.
typedef struct
{
PGresult *result;
} PGEventResultDestroy;
При поступлении события PGEVT_RESULTDESTROY указатель evtInfo следует привести к
PGEventResultDestroy *. Это событие происходит перед тем, как PQclear производит всю
остальную очистку. Значение, возвращаемое обработчиком событий, игнорируется, так как
из PQclear никак нельзя сообщить об ошибке. Кроме того, ошибка в обработчике событий не
должна прерывать процесс очистки ставшей ненужной памяти.
34.13.2. Процедура обработки событий
PGEventProc
PGEventProc — это определение типа для указателя на обработчик событий, то есть функцию
обратного вызова, получающую события от libpq. Обработчик событий должен иметь такую
сигнатуру:
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
Параметр evtId говорит, какое событие PGEVT произошло. Указатель evtInfo должен приво-
диться к типу определённой структуры для получения дополнительной информации о событии.
В параметре passThrough передаётся сквозной указатель, поступивший в PQregisterEventProc
при регистрации обработчика события. Эта функция должна вернуть ненулевое значение в
случае успеха или ноль в противном случае.
Обработчик определённого события может быть зарегистрирован в любом PGconn только раз.
Это связано с тем, что адрес обработчика используется как ключ для выбора связанных данных
экземпляра.
809libpq — библиотека для языка C
Внимание
В Windows функции могут иметь два разных адреса: один, видимый снаружи DLL, и
второй, видимый внутри DLL. Учитывая это, надо позаботиться о том, чтобы только
один из адресов использовался с функциями обработки событий libpq, иначе воз-
никнет путаница. Самый простой способ написать код, который будет работать —
всегда помечать обработчик событий как static. Если адрес обработчика нужно
получить вне его исходного файла, экспортируйте отдельную функцию, которая бу-
дет возвращать этот адрес.
34.13.3. Функции поддержки событий
PQregisterEventProc
Регистрирует обработчик событий в libpq.
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
const char *name, void *passThrough);
Обработчик событий должен быть зарегистрирован один раз для каждого соединения PGconn,
события которого представляют интерес. Число обработчиков событий, которые можно заре-
гистрировать для соединения, не ограничивается ничем, кроме объёма памяти. Эта функция
возвращает ненулевое значение в случае успеха или ноль в противном случае.
Процедура, переданная в аргументе proc, будет вызываться, когда произойдёт событие libpq.
Её адрес в памяти также применяется для поиска данных instanceData. Аргумент name исполь-
зуется при упоминании обработчика событий в сообщениях об ошибках. Это значение не мо-
жет быть равно NULL или указывать на строку нулевой длины. Эта строка имени копируется в
PGconn, так что переданная строка может быть временной. Сквозной указатель (passThrough)
будет передаваться обработчику proc при каждом вызове события. Этот аргумент может рав-
няться NULL.
PQsetInstanceData
Устанавливает для подключения conn указатель instanceData для обработчика proc равным
data. Эта функция возвращает ненулевое значение в случае успеха или ноль в противном слу-
чае. (Ошибка возможна, только если обработчик proc не был корректно зарегистрирован для
соединения conn.)
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
PQinstanceData
Возвращает для соединения conn указатель на instanceData, связанный с обработчиком proc,
либо NULL, если такого обработчика нет.
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
PQresultSetInstanceData
Устанавливает для объекта результата (res) указатель instanceData для обработчика proc рав-
ным data. Эта функция возвращает ненулевое значение в случае успеха или ноль в противном
случае. (Ошибка возможна, только если обработчик proc не был корректно зарегистрирован
для объекта результата.)
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
PQresultInstanceData
Возвращает для объекта результата (res) указатель на instanceData, связанный с обработчи-
ком proc, либо NULL, если такого обработчика нет.
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
810libpq — библиотека для языка C
34.13.4. Пример обработки событий
Ниже показан схематичный пример управления внутренними данными, связанными с подключе-
ниями и результатами libpq.
/* required header for libpq events (note: includes libpq-fe.h) */
#include <libpq-events.h>
/* The instanceData */
typedef struct
{
int n;
char *str;
} mydata;
/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);
int
main(void)
{
mydata *data;
PGresult *res;
PGconn *conn =
PQconnectdb("dbname=postgres options=-csearch_path=");
if (PQstatus(conn) != CONNECTION_OK)
{
fprintf(stderr, "Connection to database failed: %s",
PQerrorMessage(conn));
PQfinish(conn);
return 1;
}
/* called once on any connection that should receive events.</libpq-events.h></libpq-fe.h></p>
<ul>
  <li>Sends a PGEVT_REGISTER to myEventProc.
<em>/
if (!PQregisterEventProc(conn, myEventProc, “mydata_proc”, NULL))
{
fprintf(stderr, “Cannot register PGEventProc\n”);
PQfinish(conn);
return 1;
}
/</em> conn instanceData is available <em>/
data = PQinstanceData(conn, myEventProc);
/</em> Sends a PGEVT_RESULTCREATE to myEventProc <em>/
res = PQexec(conn, “SELECT 1 + 1”);
/</em> result instanceData is available <em>/
data = PQresultInstanceData(res, myEventProc);
/</em> If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc <em>/
res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);
/</em> result instanceData is available if PG_COPYRES_EVENTS was
811libpq — библиотека для языка C</li>
  <li>used during the PQcopyResult call.
<em>/
data = PQresultInstanceData(res_copy, myEventProc);
/</em> Both clears send a PGEVT_RESULTDESTROY to myEventProc <em>/
PQclear(res);
PQclear(res_copy);
/</em> Sends a PGEVT_CONNDESTROY to myEventProc <em>/
PQfinish(conn);
return 0;
}
static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
switch (evtId)
{
case PGEVT_REGISTER:
{
PGEventRegister *e = (PGEventRegister *)evtInfo;
mydata *data = get_mydata(e-&gt;conn);
/</em> associate app specific data with connection <em>/
PQsetInstanceData(e-&gt;conn, myEventProc, data);
break;
}
case PGEVT_CONNRESET:
{
PGEventConnReset *e = (PGEventConnReset *)evtInfo;
mydata *data = PQinstanceData(e-&gt;conn, myEventProc);
if (data)
memset(data, 0, sizeof(mydata));
break;
}
case PGEVT_CONNDESTROY:
{
PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
mydata *data = PQinstanceData(e-&gt;conn, myEventProc);
/</em> free instance data because the conn is being destroyed <em>/
if (data)
free_mydata(data);
break;
}
case PGEVT_RESULTCREATE:
{
PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
mydata *conn_data = PQinstanceData(e-&gt;conn, myEventProc);
mydata *res_data = dup_mydata(conn_data);
/</em> associate app specific data with result (copy it from conn) <em>/
PQsetResultInstanceData(e-&gt;result, myEventProc, res_data);
812libpq — библиотека для языка C
break;
}
case PGEVT_RESULTCOPY:
{
PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
mydata *src_data = PQresultInstanceData(e-&gt;src, myEventProc);
mydata *dest_data = dup_mydata(src_data);
/</em> associate app specific data with result (copy it from a result) <em>/
PQsetResultInstanceData(e-&gt;dest, myEventProc, dest_data);
break;
}
case PGEVT_RESULTDESTROY:
{
PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
mydata *data = PQresultInstanceData(e-&gt;result, myEventProc);
/</em> free instance data because the result is being destroyed <em>/
if (data)
free_mydata(data);
break;
}
/</em> unknown event ID, just return true. <em>/
default:
break;
}
return true; /</em> event processing succeeded */
}
34.14. Переменные окружения
Воспользовавшись следующими переменными окружения, можно задать значения параметров со-
единения по умолчанию, которые будут использоваться функциями PQconnectdb, PQsetdbLogin и
PQsetdb, если никакое значение не будет задано вызывающим кодом. В частности, используя их,
можно обойтись без жёсткого задания параметров соединения в простых клиентских приложени-
ях.
• PGHOST действует так же, как параметр соединения host.
• PGHOSTADDR действует так же, как параметр соединения hostaddr. Эту переменную можно за-
дать вместо или вместе с PGHOST для предотвращения поиска адреса в DNS.
• PGPORT действует так же, как параметр соединения port.
• PGDATABASE действует так же, как параметр соединения dbname.
• PGUSER действует так же, как параметр соединения user.
• PGPASSWORD действует так же, как параметр соединения password. Использовать эту перемен-
ную окружения не рекомендуется по соображениям безопасности, так как в некоторых опера-
ционных системах непривилегированные пользователи могут видеть переменные окружения
процессов в выводе ps; вместо этого лучше использовать файл паролей (см. Раздел 34.15).
• PGPASSFILE действует так же, как параметр соединения passfile.
• PGSERVICE действует так же, как параметр соединения service.
• PGSERVICEFILE задаёт имя личного файла пользователя с параметрами подключения к служ-
бам. По умолчанию применяется имя файла ~/.pg_service.conf (см. Раздел 34.16).
813libpq — библиотека для языка C
• PGOPTIONS действует так же, как параметр соединения options.
• PGAPPNAME действует так же, как параметр соединения application_name.
• PGSSLMODE действует так же, как параметр соединения sslmode.
• PGREQUIRESSL действует так же, как параметр соединения requiressl. Эта переменная окруже-
ния утратила актуальность с появлением переменной PGSSLMODE; если установить обе пере-
менные, значение данной не возымеет эффекта.
• PGSSLCOMPRESSION действует так же, как параметр соединения sslcompression.
• PGSSLCERT действует так же, как параметр соединения sslcert.
• PGSSLKEY действует так же, как параметр соединения sslkey.
• PGSSLROOTCERT действует так же, как параметр соединения sslrootcert.
• PGSSLCRL действует так же, как параметр соединения sslcrl.
• PGREQUIREPEER действует так же, как параметр соединения requirepeer.
• PGKRBSRVNAME действует так же, как параметр соединения krbsrvname.
• PGGSSLIB действует так же, как параметр соединения gsslib.
• PGCONNECT_TIMEOUT действует так же, как параметр соединения connect_timeout.
• PGCLIENTENCODING действует так же, как параметр соединения client_encoding.
• PGTARGETSESSIONATTRS действует так же, как параметр соединения target_session_attrs.
Следующие переменные окружения позволяют задать поведение по умолчанию для каждого от-
дельного сеанса PostgreSQL. (См. также описание команд ALTER ROLE и ALTER DATABASE, позво-
ляющих установить поведение по умолчанию для отдельного пользователя или отдельной базы.)
• PGDATESTYLE устанавливает стиль представления даты/времени по умолчанию. (Равносильно
SET datestyle TO ….)
• PGTZ устанавливает часовой пояс по умолчанию. (Равносильно SET timezone TO ….)
• PGGEQO устанавливает режим по умолчанию для генетического оптимизатора запросов. (Рав-
носильно SET geqo TO ….)
Информацию о корректных значениях этих переменных окружения можно найти в описании SQL-
команды SET.
Следующие переменные среды определяют внутреннее поведение libpq; они переопределяют
встроенные значения.
• PGSYSCONFDIR задаёт каталог, в котором содержится файл pg_service.conf, а в будущем он
может содержать и другие общесистемные файлы конфигурации.
• PGLOCALEDIR задаёт каталог, содержащий файлы locale, предназначенные для перевода сооб-
щений.
34.15. Файл паролей
Файл .pgpass в домашнем каталоге пользователя может содержать пароли, которые будут ис-
пользоваться, если для подключения требуется пароль (и пароль не задаётся другим способом).
В Microsoft Windows этот файл называется %APPDATA%\postgresql\pgpass.conf (где %APPDATA%
обозначает каталог данных приложений (Application Data) в профиле пользователя). Имя файла
паролей также можно задать в параметре подключения passfile или в переменной окружения
PGPASSFILE.
Этот файл должен содержать строки следующего формата:
сервер:порт:база_данных:имя_пользователя:пароль
(Вы можете вставить в этот файл комментарий-памятку, скопировав показанную строку в него и
добавив в начало #.) Первые четыре поля могут содержать строковые значения, либо знак *, со-
ответствующий всему. Применяться будет пароль, указанный в первой из строк, значения полей
814libpq — библиотека для языка C
в которой соответствуют текущему соединению. (Поэтому, если вы используете звёздочки, поме-
стите более конкретные записи первыми.) Если запись должна содержать символ : или \, добавьте
перед ним . Поле с именем узла сопоставляется с параметром подключения host (если он указан)
или с параметром hostaddr (если указан он); в случае отсутствия обоих параметров подразумева-
ется имя localhost. Имя узла localhost также подразумевается, когда соединение устанавлива-
ется через Unix-сокет и параметр host соответствует установленному в libpq каталогу сокетов по
умолчанию. На ведомом сервере имя базы данных replication соответствует подключениям к ве-
дущему серверу, которые применяются для потоковой репликации. Поле база_данных имеет огра-
ниченную ценность, так как пользователи используют один пароль для всех баз данных в кластере.
В системах Unix разрешения для файла паролей должны запрещать любой доступ к нему всем и
группе; этого можно добиться командой chmod 0600 ~/.pgpass. Если разрешения будут менее
строгими, этот файл будет игнорироваться. В Microsoft Windows предполагается, что файл хранит-
ся в безопасном месте, и никакие дополнительные проверки не производятся.
34.16. Файл соединений служб
Файл соединений служб позволяет связать параметры соединений libpq с одним именем службы.
Затем это имя службы можно задать при подключении через libpq и будут применены все свя-
занные с ним параметры. Это позволяет модифицировать параметры соединений, обходясь без
перекомпиляции приложения libpq. Имя службы можно также задать в переменной окружения
PGSERVICE.
Файл соединений служб может быть личным файлом пользователя с путём ~/.pg_service.conf
или задаваться переменной окружения PGSERVICEFILE, либо это может быть системный файл с пу-
тём <code class="highlighter-rouge">pg_config --sysconfdir</code>/pg_service.conf или в каталоге, задаваемом переменной окруже-
ния PGSYSCONFDIR. Если для одного имени службы существует определение и в системном файле,
и в файле пользователя, определение пользователя имеет приоритет.
В этом файле используется формат «INI-файлов», в котором имя раздела задаёт имя службы, а
параметры внутри — параметры соединения; их список приведён в Подразделе 34.1.2. Например:
    <h1 id="комментарий">комментарий</h1>
    <p>[mydb]
host=somehost
port=5433
user=admin
Пример такого файла можно найти в share/pg_service.conf.sample.
34.17. Получение параметров соединения через LDAP
Если библиотека libpq была собрана с поддержка LDAP (configure передавался ключ –with-ldap),
такие параметры соединения, как host и dbname, можно получить через LDAP с центрального сер-
вера. Преимущество такого подхода в том, что при изменении параметров подключения к базе
данных свойства соединения не придётся изменять на всех клиентских компьютерах.
Для получения параметров соединений через LDAP используется файл соединений служб
pg_service.conf (см. Раздел 34.16). Строка в pg_service.conf, начинающаяся с указания прото-
кола ldap://, будет воспринята как URL в LDAP и выполнится как запрос к LDAP. Результатом за-
проса должен быть список пар keyword = value, которые и будут задавать параметры соединений.
Заданный URL должен соответствовать RFC 1959 и иметь следующий вид:
ldap://[имя_сервера[:порт]]/база_поиска?атрибут?область_поиска?фильтр
; по умолчанию имя_сервера — localhost, а порт — 389.
Обработка pg_service.conf прекращается после удачного поиска в LDAP, но если с сервером LDAP
связаться не удаётся, обрабатываются следующие строки этого файла. Так сделано для того, чтобы
можно было реализовать запасные варианты, добавив дополнительные строки с URL LDAP, указы-
вающими на другие серверы LDAP, или классические пары keyword = value, либо используя пара-
815libpq — библиотека для языка C
метры соединений по умолчанию. Если же вы хотите получить ошибку в этой ситуации, добавьте
после строки с URL-адресом LDAP синтаксически некорректную строку.
Простую запись LDAP, созданную из такого файла LDIF
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
можно запросить из каталога LDAP, указав следующий URL:
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
Также возможно сочетать обычные записи в файле служб с поиском в LDAP. Полный пример опи-
сания службы в pg_service.conf может быть таким:</p>
    <h1 id="в-ldap-хранится-только-имя-и-порт-сервера-имя-базы-и-пользователя-нужно-задать-явно">в LDAP хранится только имя и порт сервера; имя базы и пользователя нужно задать явно</h1>
    <p>[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=<em>)
34.18. Поддержка SSL
PostgreSQL реализует собственную поддержку SSL-подключений для шифрования клиент-сервер-
ного взаимодействия в качестве меры безопасности. Подробнее функциональность SSL на стороне
сервера описывается в Разделе 18.9.
Библиотека libpq читает системный файл конфигурации OpenSSL. По умолчанию этот файл назы-
вается openssl.cnf и находится в каталоге, который сообщает команда openssl version -d. Ес-
ли требуется указать другое расположение файла конфигурации, его можно задать в переменной
окружения OPENSSL_CONF.
34.18.1. Проверка сертификатов сервера на стороне клиента
По умолчанию PostgreSQL не выполняет никакие проверки сертификата сервера. Это означает,
что клиента можно ввести в заблуждение, подменив сервер (например, изменив запись в DNS или
заняв его IP-адрес). Чтобы защититься от такой подмены, клиент должен иметь возможность про-
верять подлинность сервера по цепочке доверия. Для создания цепочки доверия нужно устано-
вить корневой (самоподписанный) сертификат центра сертификации (ЦС) на одном компьютере,
а конечный сертификат, подписанный корневым, на другом. В цепочке может использоваться и
«промежуточный» сертификат, который подписывается корневым сертификатом и подписывает
подчинённые сертификаты.
Чтобы клиент мог проверить подлинность сервера, установите на клиенте корневой сертификат, а
на сервере установите конечный сертификат, подписанный этим корневым. Чтобы сервер мог про-
верить подлинность клиента, установите на сервере корневой сертификат, а на клиенте конечный
сертификат, подписанный данным корневым. Конечный сертификат также может связываться с
корневым через один или несколько промежуточных сертификатов (они обычно хранятся вместе
с конечным сертификатом).
Когда цепочка доверия присутствует, клиент может проверить конечный сертификат, переданный
сервером, двумя способами. Если параметр sslmode имеет значение verify-ca, libpq будет прове-
рять подлинность сервера, проверяя цепочку доверия до корневого сертификата, установленного
816libpq — библиотека для языка C
на клиенте. Если в sslmode выбран режим verify-full, libpq будет также проверять соответствие
имени узла сервера имени, записанному в сертификате. SSL-подключение не будет установлено,
если проверить сертификат сервера не удастся. Режим verify-full рекомендуется для большин-
ства окружений, где важна безопасность.
В режиме verify-full имя компьютера сверяется с атрибутом (или атрибутами) Subject Alternative
Name (Альтернативное имя субъекта) в сертификате или с атрибутом Common Name (Общее имя),
если в сертификате отсутствует атрибут Subject Alternative Name типа dNSName. Если атрибут име-
ни сертификата начинается со звёздочки (</em>), звёздочка воспринимается как подстановочный знак
и ей будут соответствовать все символы, кроме точки (.). Это означает, что такой сертификат не
будет соответствовать поддоменам. Если подключение устанавливается по IP-адресу, а не по име-
ни компьютера, проверяться будет IP-адрес (без поиска в DNS).
Чтобы настроить проверку сертификата сервера, необходимо поместить один или несколько корне-
вых сертификатов в файл ~/.postgresql/root.crt в домашнем каталоге пользователя. (В Microsoft
Windows этот файл называется %APPDATA%\postgresql\root.crt.) Также следует добавлять в этот
файл промежуточные сертификаты, если они нужны для связывания цепочки сертификатов, пе-
реданных сервером, с корневыми сертификатами, установленными на клиенте.
Если существует файл ~/.postgresql/root.crl (или %APPDATA%\postgresql\root.crl в Microsoft
Windows), при проверке также учитывается содержащийся в нём список отозванных сертификатов
(CRL, Certificate Revocation List).
Размещение файла корневых сертификатов и CRL можно поменять, задав параметры соединения
sslrootcert и sslcrl или переменные окружения PGSSLROOTCERT и PGSSLCRL, соответственно.
Примечание
Для обратной совместимости с предыдущими версиями PostgreSQL, при наличии фай-
ла с сертификатами корневых ЦС поведение режима sslmode=require не отличается
от режима verify-ca, то есть сертификат сервера будет проверяться по сертификату
ЦС. Полагаться на это поведение не рекомендуется — приложения, которым нужно
проверять сертификат, должны всегда выбирать режим verify-ca или verify-full.
34.18.2. Клиентские сертификаты
Если сервер попытается проверить подлинность клиента, запрашивая конечный сертификат кли-
ента, libpq будет передавать сертификаты, сохранённые в файле ~/.postgresql/postgresql.crt
в домашнем каталоге пользователя. Эти сертификаты должны связываться по цепочке с кор-
невым сертификатом, которому доверяет сервер. Также должен присутствовать соответству-
ющий закрытый ключ ~/.postgresql/postgresql.key. К этому файлу закрытого ключа дол-
жен быть запрещён доступ всех и группы; такой режим доступа устанавливает команда chmod
0600 ~/.postgresql/postgresql.key. В Microsoft Windows эти файлы называются %APPDATA%
\postgresql\postgresql.crt и %APPDATA%\postgresql\postgresql.key, а права доступа не прове-
ряются, так как этот каталог считается защищённым. Размещение файлов сертификатов и закры-
того ключа можно переопределить с помощью параметров подключения sslcert и sslkey либо
переменных окружения PGSSLCERT и PGSSLKEY.
Первым сертификатом в postgresql.crt должен быть сертификат клиента, так как он должен со-
ответствовать закрытому ключу клиента. Дополнительно в этот файл могут быть добавлены «про-
межуточные» сертификаты — это позволит избежать хранения всех промежуточных сертификатов
на сервере (см. ssl_ca_file).
За инструкциями по созданию сертификатов обратитесь к Подразделу 18.9.5.
34.18.3. Защита, обеспечиваемая в различных режимах
Разные значения параметра sslmode обеспечивают разные уровни защиты. SSL позволяет защи-
титься от следующих типов атак:
817libpq — библиотека для языка C
Прослушивание
Если третья сторона может прослушивать сетевой трафик между клиентом и сервером, она
может получить как информацию соединения (включая имя пользователя и пароль), так и пе-
редаваемые данные. Чтобы защититься от этого, SSL шифрует трафик.
Посредник (MITM)
Если третья сторона может модифицировать данные, передаваемые между клиентом и серве-
ром, она может представиться сервером и, таким образом, сможет видеть и модифицировать
данные, даже если они зашифрованы. Третья сторона затем может воспроизводить характе-
ристики соединения и данные для подлинного сервера, что сделает невозможным обнаруже-
ние этой атаки. Векторами такой атаки может быть «отравление» DNS и подмена адресов, в
результате чего клиент будет обращаться не к тому серверу, к которому нужно. Также есть
несколько других вариантов реализации этой атаки. Для защиты в SSL применяется проверка
сертификатов, в результате которой сервер доказывает свою подлинность клиенту.
Олицетворение
Если третья сторона может представляться авторизованным клиентом, она может просто об-
ращаться к данным, к которым не должна иметь доступа. Обычно это происходит вследствие
небезопасного управления паролями. В SSL для предотвращения этой угрозы используются
клиентские сертификаты, гарантирующие, что к серверу могут обращаться только владельцы
действительных сертификатов.
Чтобы соединение было гарантированно безопасным, SSL должен быть настроен на клиенте и
на сервере, прежде чем будет установлено соединение. Если он настроен только на сервере, кли-
ент может начать передавать важную информацию (например, пароли), до того как поймёт, что
сервер требует высокого уровня безопасности. В libpq для установления безопасных соединений
нужно задать для параметра sslmode значение verify-full или verify-ca и предоставить системе
корневой сертификат для проверки. В качестве аналогии можно привести использование адреса
с https для безопасного просмотра веб-содержимого.
Когда подлинность сервера подтверждена, клиент может передавать конфиденциальные данные.
Это значит, что до этого момента клиенту не нужно знать, применяются ли сертификаты для аутен-
тификации, так что настройка использования сертификатов только на стороне сервера не угрожа-
ет безопасности.
Все варианты использования SSL подразумевают издержки шифрования и обмена ключами, что
порождает необходимость выбора между производительностью и безопасностью. В Таблице 34.1
описываются риски, от которых защищают различные варианты sslmode, и приводятся утвержде-
ния относительно защиты и издержек.
Таблица 34.1. Описания режимов SSL
sslmode Защита от прослуши- Защита от MITM
вания Утверждение
disable Нет Нет Мне не важна безопас-
ность и я не приемлю
издержки, связанные с
шифрованием.
allow Возможно Нет Мне не важна безопас-
ность, но я приемлю
издержки, связанные с
шифрованием, если на
этом настаивает сер-
вер.
prefer Возможно Нет Мне не важна безопас-
ность, но я предпо-
читаю шифрование (и
приемлю связанные из-
818libpq — библиотека для языка C
Защита от прослуши- Защита от MITM
вания Утверждение
require Да Нет Я хочу, чтобы мои дан-
ные шифровались, и
я приемлю сопутству-
ющие издержки. Я до-
веряю сети в том, что
она обеспечивает под-
ключение к нужному
серверу.
verify-ca Да Зависит
ЦС verify-full Да Да
sslmode
от
держки), если это под-
держивает сервер.
политики Я хочу, чтобы мои дан-
ные шифровались, и
я приемлю сопутству-
ющие издержки. Мне
нужна уверенность в
том, что я подключаюсь
к доверенному серверу.
Я хочу, чтобы мои дан-
ные шифровались, и
я приемлю сопутству-
ющие издержки. Мне
нужна уверенность в
том, что я подключаюсь
к доверенному серверу
и это именно указан-
ный мной сервер.
Различие вариантов verify-ca и verify-full зависит от характера корневого ЦС. Если использу-
ется публичный ЦС, режим verify-ca допускает подключение к серверу с сертификатом, который
получил кто угодно в этом ЦС. В такой ситуации нужно всегда использовать режим verify-full.
Если же используется локальный ЦС или даже самоподписанный сертификат, режим verify-ca
обычно обеспечивает достаточную защиту.
По умолчанию параметр sslmode имеет значение prefer. Как показано в таблице, оно неэффек-
тивно с точки зрения безопасности и может только привносить дополнительные издержки. Оно
выбрано по умолчанию исключительно для обратной совместимости и не рекомендуется для за-
щищённых окружений.
34.18.4. Файлы, используемые клиентом SSL
В Таблице 34.2 перечислены файлы, имеющие отношение к настройке SSL на стороне клиента.
Таблица 34.2. Файлы, используемые клиентом SSL/libpq
Файл
Содержимое
Назначение
~/.postgresql/postgresql.crt сертификат клиента запрашивается сервером
~/.postgresql/postgresql.key закрытый ключ клиента подтверждает клиентский сер-
тификат, передаваемый вла-
дельцем; не гарантирует, что
владелец сертификата заслужи-
вает доверия
~/.postgresql/root.crt
сертификаты доверенных ЦС
819
позволяет проверить, что серти-
фикат сервера подписан дове-
ренным центром сертификацииlibpq — библиотека для языка C
Файл Содержимое
Назначение
~/.postgresql/root.crl сертификаты, отозванные цен- сертификат сервера должен от-
трами сертификации
сутствовать в этом списке
34.18.5. Инициализация библиотеки SSL
Если ваше приложение инициализирует библиотеку libssl и/или libcrypto, и libpq собрана с под-
держкой SSL, вы должны вызвать PQinitOpenSSL, чтобы сообщить libpq, что библиотека libssl и/
или libcrypto уже инициализированы вашим приложением, чтобы libpq не пыталась ещё раз ини-
циализировать их. Более подробно API SSL описывается на странице http://h41379.www4.hpe.com/
doc/83final/ba554_90007/ch04.html.
PQinitOpenSSL
Позволяет приложениям выбрать, какие библиотеки безопасности нужно инициализировать.
void PQinitOpenSSL(int do_ssl, int do_crypto);
Когда параметр do_ssl отличен от нуля, libpq будет инициализировать библиотеку OpenSSL
перед первым подключением к базе данных. Когда параметр do_crypto не равен нулю, будет
инициализироваться библиотека libcrypto. По умолчанию (если функция PQinitOpenSSL не
вызывается) инициализируются обе библиотеки. Если поддержка SSL не была скомпилирова-
на, эта функция присутствует, но ничего не делает.
Если ваше приложение использует и инициализирует библиотеку OpenSSL или её нижележа-
щую библиотеку libcrypto, вы должны вызвать эту функцию, передав нули в соответствующих
параметрах, перед первым подключением к базе данных. Собственно инициализацию также
важно произвести перед установлением подключения.
PQinitSSL
Позволяет приложениям выбрать, какие библиотеки безопасности нужно инициализировать.
void PQinitSSL(int do_ssl);
Эта функция равнозначна вызову PQinitOpenSSL(do_ssl, do_ssl). Приложениям достаточно
инициализировать или не инициализировать обе библиотеки OpenSSL и libcrypto одновремен-
но.
Функция PQinitSSL существует со времён PostgreSQL 8.0, тогда как PQinitOpenSSL появилась
в PostgreSQL 8.4, так что PQinitSSL может быть предпочтительней для приложений, которым
нужно работать с более старыми версиями libpq.
34.19. Поведение в многопоточных программах
Библиотека libpq по умолчанию поддерживает повторные вызовы и многопоточность. Для соот-
ветствующего варианта сборки вашего приложения вам может понадобиться передать компиля-
тору специальные параметры командной строки. Чтобы узнать, как собрать многопоточное при-
ложение, обратитесь к документации вашей системы или поищите в файле src/Makefile.global
значения PTHREAD_CFLAGS и PTHREAD_LIBS. Эта функция позволяет узнать, поддерживает ли libpq
многопоточность:
PQisthreadsafe
Возвращает состояние потокобезопасности в библиотеке libpq.
int PQisthreadsafe();
Возвращает 1, если библиотека libpq потокобезопасная, или 0 в противном случае.
Реализация многопоточности не лишена ограничений: два потока не должны пытаться одновре-
менно работать с одним объектом PGconn. В частности, не допускается параллельное выполнение
команд из разных потоков через один объект соединения. (Если вам нужно выполнять команды
одновременно, используйте несколько соединений.)
820libpq — библиотека для языка C
Объекты PGresult после создания обычно доступны только для чтения, и поэтому их можно сво-
бодно передавать между потоками. Однако, если вы используете какую-либо из функций, изменя-
ющих PGresult, описанных в Разделе 34.11 или Разделе 34.13, вы должны также избегать одно-
временных обращений к одному объекту PGresult.
Устаревшие функции PQrequestCancel и PQoidStatus не являются потокобезопасными и не долж-
ны применяться в многопоточных программах. Вместо PQrequestCancel можно использовать
PQcancel, а вместо PQoidStatus — PQoidValue.
Если вы применяете Kerberos в своём приложении (помимо возможного использования внутри
libpq), вы должны обеспечить блокировку вокруг вызовов Kerberos, так как функции Kerberos не
являются потокобезопасными. Обратите внимание на функцию PQregisterThreadLock в исходном
коде libpq, позволяющую организовать совместные блокировки между libpq и вашим приложени-
ем.
Если вы сталкиваетесь с проблемами многопоточности в приложениях, запустите программу src/
tools/thread, чтобы понять, есть ли в вашей системе небезопасные при многопоточности функ-
ции. Эта программа запускается скриптом configure, но если вы устанавливаете двоичный пакет,
ваши библиотеки могут не соответствовать тем, что использовались при сборке.
34.20. Сборка программ с libpq
Чтобы собрать (то есть, скомпилировать и скомпоновать) программу, использующую libpq, вы
должны проделать следующие действия:
• Включите заголовочный файл libpq-fe.h:
#include <libpq-fe.h>
Если вы не сделаете этого, обычно вас ждут примерно такие сообщения об ошибках от компи-
лятора:
foo.c: In
foo.c:34:
foo.c:35:
foo.c:54:
foo.c:68:
foo.c:95:
function `main':
`PGconn' undeclared (first use in this function)
`PGresult' undeclared (first use in this function)
`CONNECTION_BAD' undeclared (first use in this function)
`PGRES_COMMAND_OK' undeclared (first use in this function)
`PGRES_TUPLES_OK' undeclared (first use in this function)
• Сообщите вашему компилятору каталог, в котором установлены заголовочные файлы
PostgreSQL, передав ему параметр -Iкаталог. (В некоторых случаях компилятор сам может
обращаться к нужному каталогу, так что этот параметр можно опустить.) Например, ваша ко-
манда компиляции может быть такой:
cc -c -I/usr/local/pgsql/include testprog.c
Если вы используете скрипты сборки Makefile, добавьте этот параметр в переменную
CPPFLAGS:
CPPFLAGS += -I/usr/local/pgsql/include
Если существует возможность, что вашу программу будут компилировать другие пользова-
тели, то путь к каталогу не следует жёстко задавать таким образом. Вместо этого вы можете
воспользоваться утилитой pg_configи узнать, где в локальной системе находятся заголовоч-
ные файлы, следующим образом:
$ pg_config --includedir
/usr/local/include
Если у вас установлена программа pkg-config, вместо этого вы можете выполнить:
$ pkg-config --cflags libpq
-I/usr/local/include
Заметьте, что при этом перед путём сразу будет добавлен ключ -I.
821libpq — библиотека для языка C
Если требуемый параметр не будет передан компилятору, вы получите примерно такое сооб-
щение об ошибке:
testlibpq.c:8:22: libpq-fe.h: No such file or directory
• При компоновке окончательной программы добавьте параметр -lpq, чтобы была подключена
библиотека libpq, а также параметр -Lкаталог, указывающий на каталог, в котором находит-
ся libpq. (Опять же, компилятор будет просматривать определённые каталоги по умолчанию.)
Для максимальной переносимости указывайте ключ -L перед параметром -lpq. Например:
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
Каталог с библиотекой можно узнать, так же используя pg_config:
$ pg_config --libdir
/usr/local/pgsql/lib
Или с помощью той же программы pkg-config:
$ pkg-config --libs libpq
-L/usr/local/pgsql/lib -lpq
Заметьте, что и в этом случае выводится полностью сформированный параметр, а не только
путь.
В случае проблем в этой области возможны примерно такие сообщения об ошибках:
testlibpq.o: In function
testlibpq.o(.text+0x60):
testlibpq.o(.text+0x71):
testlibpq.o(.text+0xa4):
`main':
undefined reference to `PQsetdbLogin'
undefined reference to `PQstatus'
undefined reference to `PQerrorMessage'
Они означают, что вы забыли добавить параметр -lpq.
/usr/bin/ld: cannot find -lpq
Такая ошибка означает, что вы забыли добавить ключ -L или не указали правильный каталог.
34.21. Примеры программ
Эти и другие примеры можно найти в каталоге src/test/examples в дистрибутиве исходного кода.
Пример 34.1. Первая программа, демонстрирующая использование libpq
/*</libpq-fe.h></p>
  </li>
  <li>src/test/examples/testlibpq.c
*
*</li>
  <li>testlibpq.c
*
*
Test the C version of libpq, the PostgreSQL frontend library.
*/
#include <stdio.h>
#include <stdlib.h>
#include "libpq-fe.h"
static void
exit_nicely(PGconn *conn)
{
PQfinish(conn);
exit(1);
}
822libpq — библиотека для языка C
int
main(int argc,
{
const char
PGconn
PGresult
int
int
char **argv)
*conninfo;
*conn;
*res;
nFields;
i,
j;
/*</stdlib.h></stdio.h></li>
  <li>If the user supplies a parameter on the command line, use it as the</li>
  <li>conninfo string; otherwise default to setting dbname=postgres and using</li>
  <li>environment variables or defaults for all other connection parameters.
<em>/
if (argc &gt; 1)
conninfo = argv[1];
else
conninfo = “dbname = postgres”;
/</em> Make a connection to the database <em>/
conn = PQconnectdb(conninfo);
/</em> Check to see that the backend connection was successfully made <em>/
if (PQstatus(conn) != CONNECTION_OK)
{
fprintf(stderr, “Connection to database failed: %s”,
PQerrorMessage(conn));
exit_nicely(conn);
}
/</em> Set always-secure search path, so malicious users can’t take control. <em>/
res = PQexec(conn,
“SELECT pg_catalog.set_config(‘search_path’, ‘’, false)”);
if (PQresultStatus(res) != PGRES_TUPLES_OK)
{
fprintf(stderr, “SET failed: %s”, PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
/</em></li>
  <li>Should PQclear PGresult whenever it is no longer needed to avoid memory</li>
  <li>leaks
<em>/
PQclear(res);
/</em></li>
  <li>Our test case here involves using a cursor, for which we must be inside</li>
  <li>a transaction block. We could do the whole thing with a single</li>
  <li>PQexec() of “select * from pg_database”, but that’s too trivial to make</li>
  <li>a good example.
<em>/
/</em> Start a transaction block <em>/
res = PQexec(conn, “BEGIN”);
if (PQresultStatus(res) != PGRES_COMMAND_OK)
{
823libpq — библиотека для языка C
fprintf(stderr, “BEGIN command failed: %s”, PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
PQclear(res);
/</em></li>
  <li>Fetch rows from pg_database, the system catalog of databases
<em>/
res = PQexec(conn, “DECLARE myportal CURSOR FOR select * from pg_database”);
if (PQresultStatus(res) != PGRES_COMMAND_OK)
{
fprintf(stderr, “DECLARE CURSOR failed: %s”, PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
PQclear(res);
res = PQexec(conn, “FETCH ALL in myportal”);
if (PQresultStatus(res) != PGRES_TUPLES_OK)
{
fprintf(stderr, “FETCH ALL failed: %s”, PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
/</em> first, print out the attribute names <em>/
nFields = PQnfields(res);
for (i = 0; i &lt; nFields; i++)
printf(“%-15s”, PQfname(res, i));
printf(“\n\n”);
/</em> next, print out the rows <em>/
for (i = 0; i &lt; PQntuples(res); i++)
{
for (j = 0; j &lt; nFields; j++)
printf(“%-15s”, PQgetvalue(res, i, j));
printf(“\n”);
}
PQclear(res);
/</em> close the portal … we don’t bother to check for errors … <em>/
res = PQexec(conn, “CLOSE myportal”);
PQclear(res);
/</em> end the transaction <em>/
res = PQexec(conn, “END”);
PQclear(res);
/</em> close the connection to the database and cleanup <em>/
PQfinish(conn);
return 0;
}
824libpq — библиотека для языка C
Пример 34.2. Вторая программа, демонстрирующая использование libpq
/</em></li>
  <li>src/test/examples/testlibpq2.c
*
*</li>
  <li>testlibpq2.c
*
Test of the asynchronous notification interface
*</li>
  <li>Start this program, then from psql in another window do
*
NOTIFY TBL2;</li>
  <li>Repeat four times to get this program to exit.
*</li>
  <li>Or, if you want to get fancy, try this:</li>
  <li>populate a database with the following commands</li>
  <li>(provided in src/test/examples/testlibpq2.sql):
*
*
CREATE SCHEMA TESTLIBPQ2;
*
SET search_path = TESTLIBPQ2;
*
CREATE TABLE TBL1 (i int4);
*
CREATE TABLE TBL2 (i int4);
*
CREATE RULE r1 AS ON INSERT TO TBL1 DO
*
(INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
*</li>
  <li>Start this program, then from psql do this four times:
*
*
INSERT INTO TESTLIBPQ2.TBL1 VALUES (10);
*/
#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#ifdef HAVE_SYS_SELECT_H
#include &lt;sys/select.h&gt;
#endif
#include "libpq-fe.h"
static void
exit_nicely(PGconn *conn)
{
PQfinish(conn);
exit(1);
}
int
main(int argc,
{
const char
PGconn
PGresult
char **argv)
*conninfo;
*conn;
*res;
825libpq — библиотека для языка C
PGnotify
int
*notify;
nnotifies;
/*</errno.h></string.h></stdlib.h></stdio.h></windows.h></li>
  <li>If the user supplies a parameter on the command line, use it as the</li>
  <li>conninfo string; otherwise default to setting dbname=postgres and using</li>
  <li>environment variables or defaults for all other connection parameters.
<em>/
if (argc &gt; 1)
conninfo = argv[1];
else
conninfo = “dbname = postgres”;
/</em> Make a connection to the database <em>/
conn = PQconnectdb(conninfo);
/</em> Check to see that the backend connection was successfully made <em>/
if (PQstatus(conn) != CONNECTION_OK)
{
fprintf(stderr, “Connection to database failed: %s”,
PQerrorMessage(conn));
exit_nicely(conn);
}
/</em> Set always-secure search path, so malicious users can’t take control. <em>/
res = PQexec(conn,
“SELECT pg_catalog.set_config(‘search_path’, ‘’, false)”);
if (PQresultStatus(res) != PGRES_TUPLES_OK)
{
fprintf(stderr, “SET failed: %s”, PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
/</em></li>
  <li>Should PQclear PGresult whenever it is no longer needed to avoid memory</li>
  <li>leaks
<em>/
PQclear(res);
/</em></li>
  <li>Issue LISTEN command to enable notifications from the rule’s NOTIFY.
<em>/
res = PQexec(conn, “LISTEN TBL2”);
if (PQresultStatus(res) != PGRES_COMMAND_OK)
{
fprintf(stderr, “LISTEN command failed: %s”, PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
PQclear(res);
/</em> Quit after four notifies are received. <em>/
nnotifies = 0;
while (nnotifies &lt; 4)
{
/</em></li>
  <li>Sleep until something happens on the connection.
826
We use select(2)libpq — библиотека для языка C</li>
  <li>to wait for input, but you could also use poll() or similar</li>
  <li>facilities.
<em>/
int
sock;
fd_set
input_mask;
sock = PQsocket(conn);
if (sock &lt; 0)
break;
/</em> shouldn’t happen <em>/
FD_ZERO(&amp;input_mask);
FD_SET(sock, &amp;input_mask);
if (select(sock + 1, &amp;input_mask, NULL, NULL, NULL) &lt; 0)
{
fprintf(stderr, “select() failed: %s\n”, strerror(errno));
exit_nicely(conn);
}
/</em> Now check for input <em>/
PQconsumeInput(conn);
while ((notify = PQnotifies(conn)) != NULL)
{
fprintf(stderr,
“ASYNC NOTIFY of ‘%s’ received from backend PID %d\n”,
notify-&gt;relname, notify-&gt;be_pid);
PQfreemem(notify);
nnotifies++;
PQconsumeInput(conn);
}
}
fprintf(stderr, “Done.\n”);
/</em> close the connection to the database and cleanup <em>/
PQfinish(conn);
return 0;
}
Пример 34.3. Третья программа, демонстрирующая использование libpq
/</em>
*
*
*
*
*
*
*
*
*
*
*
*
*
src/test/examples/testlibpq3.c
testlibpq3.c
Test out-of-line parameters and binary I/O.
Before running this, populate a database with the following commands
(provided in src/test/examples/testlibpq3.sql):
CREATE SCHEMA testlibpq3;
SET search_path = testlibpq3;
CREATE TABLE test1 (i int4, t text, b bytea);
INSERT INTO test1 values (1, ‘joe’’s place’, ‘\000\001\002\003\004’);
827libpq — библиотека для языка C</li>
  <li>INSERT INTO test1 values (2, ‘ho there’, ‘\004\003\002\001\000’);
*</li>
  <li>The expected output is:
*</li>
  <li>tuple 0: got</li>
  <li>i = (4 bytes) 1</li>
  <li>t = (11 bytes) ‘joe’s place’</li>
  <li>b = (5 bytes) \000\001\002\003\004
*</li>
  <li>tuple 0: got</li>
  <li>i = (4 bytes) 2</li>
  <li>t = (8 bytes) ‘ho there’</li>
  <li>b = (5 bytes) \004\003\002\001\000
*/
#ifdef WIN32
#include <windows.h>
#endif
#include
#include
#include
#include
#include
#include</windows.h></li>
</ul>
<stdio.h>
<stdlib.h>
<stdint.h>
<string.h>
&lt;sys/types.h&gt;
"libpq-fe.h"
/* for ntohl/htonl */
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
static void
exit_nicely(PGconn *conn)
{
PQfinish(conn);
exit(1);
}
/*
* This function prints a query result that is a binary-format fetch from
* a table defined as in the comment above. We split it out because the
* main() function uses it twice.
*/
static void
show_binary_results(PGresult *res)
{
int
i,
j;
int
i_fnum,
t_fnum,
b_fnum;
/* Use
i_fnum
t_fnum
b_fnum
PQfnumber to avoid assumptions about field order in result */
= PQfnumber(res, "i");
= PQfnumber(res, "t");
= PQfnumber(res, "b");
for (i = 0; i &lt; PQntuples(res); i++)
828libpq — библиотека для языка C
{
char
char
char
int
int
/* Get
iptr =
tptr =
bptr =
*iptr;
*tptr;
*bptr;
blen;
ival;
the field values (we ignore possibility they are null!) */
PQgetvalue(res, i, i_fnum);
PQgetvalue(res, i, t_fnum);
PQgetvalue(res, i, b_fnum);
/*
* The binary representation of INT4 is in network byte order, which
* we'd better coerce to the local byte order.
*/
ival = ntohl(*((uint32_t *) iptr));
/*
* The binary representation of TEXT is, well, text, and since libpq
* was nice enough to append a zero byte to it, it'll work just fine
* as a C string.
*
* The binary representation of BYTEA is a bunch of bytes, which could
* include embedded nulls so we have to pay attention to field length.
*/
blen = PQgetlength(res, i, b_fnum);
printf("tuple %d: got\n", i);
printf(" i = (%d bytes) %d\n",
PQgetlength(res, i, i_fnum), ival);
printf(" t = (%d bytes) '%s'\n",
PQgetlength(res, i, t_fnum), tptr);
printf(" b = (%d bytes) ", blen);
for (j = 0; j &lt; blen; j++)
printf("\\%03o", bptr[j]);
printf("\n\n");
}
}
int
main(int argc,
{
const char
PGconn
PGresult
const char
int
int
uint32_t
char **argv)
*conninfo;
*conn;
*res;
*paramValues[1];
paramLengths[1];
paramFormats[1];
binaryIntVal;
/*
* If the user supplies a parameter on the command line, use it as the
* conninfo string; otherwise default to setting dbname=postgres and using
* environment variables or defaults for all other connection parameters.
*/
if (argc &gt; 1)
conninfo = argv[1];
829libpq — библиотека для языка C
else
conninfo = "dbname = postgres";
/* Make a connection to the database */
conn = PQconnectdb(conninfo);
/* Check to see that the backend connection was successfully made */
if (PQstatus(conn) != CONNECTION_OK)
{
fprintf(stderr, "Connection to database failed: %s",
PQerrorMessage(conn));
exit_nicely(conn);
}
/* Set always-secure search path, so malicious users can't take control. */
res = PQexec(conn, "SET search_path = testlibpq3");
if (PQresultStatus(res) != PGRES_COMMAND_OK)
{
fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
PQclear(res);
/*
* The point of this program is to illustrate use of PQexecParams() with
* out-of-line parameters, as well as binary transmission of data.
*
* This first example transmits the parameters as text, but receives the
* results in binary format. By using out-of-line parameters we can avoid
* a lot of tedious mucking about with quoting and escaping, even though
* the data is text. Notice how we don't have to do anything special with
* the quote mark in the parameter value.
*/
/* Here is our out-of-line parameter value */
paramValues[0] = "joe's place";
res = PQexecParams(conn,
"SELECT * FROM test1 WHERE t = $1",
1,
/* one param */
NULL,
/* let the backend deduce param type */
paramValues,
NULL,
/* don't need param lengths since text */
NULL,
/* default to all text params */
1);
/* ask for binary results */
if (PQresultStatus(res) != PGRES_TUPLES_OK)
{
fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
show_binary_results(res);
PQclear(res);
830libpq — библиотека для языка C
/*
* In this second example we transmit an integer parameter in binary form,
* and again retrieve the results in binary form.
*
* Although we tell PQexecParams we are letting the backend deduce
* parameter type, we really force the decision by casting the parameter
* symbol in the query text. This is a good safety measure when sending
* binary parameters.
*/
/* Convert integer value "2" to network byte order */
binaryIntVal = htonl((uint32_t) 2);
/* Set up parameter arrays for PQexecParams */
paramValues[0] = (char *) &binaryIntVal;
paramLengths[0] = sizeof(binaryIntVal);
paramFormats[0] = 1;
/* binary */
res = PQexecParams(conn,
"SELECT * FROM test1 WHERE i = $1::int4",
1,
/* one param */
NULL,
/* let the backend deduce param type */
paramValues,
paramLengths,
paramFormats,
1);
/* ask for binary results */
if (PQresultStatus(res) != PGRES_TUPLES_OK)
{
fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
PQclear(res);
exit_nicely(conn);
}
show_binary_results(res);
PQclear(res);
/* close the connection to the database and cleanup */
PQfinish(conn);
return 0;
}
831
</string.h></stdint.h></stdlib.h></stdio.h>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-034/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-034/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-034/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-033/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Mount_new_HardDisk/" title="Монтирование новых жестких дисков в системе Ubuntu">Монтирование новых жестких дисков в системе Ubuntu</a></h3>
      <p>Подключаем новые диски в систему Ubuntu <a href="http://localhost:4000/Mount_new_HardDisk/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Installed_Docker_Ubuntu/" title="Установка Docker">Установка Docker</a></h4>
        <span>Published on January 20, 2019</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Entered_in_to_Docker/" title="Как Войти В Docker-Контейнер">Как Войти В Docker-Контейнер</a></h4>
        <span>Published on January 20, 2019</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
