<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page12/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page12/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" title="Глава 46. PL/Python — процедурный язык Python"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 46. PL/Python — процедурный язык Python"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-046/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" rel="bookmark" title="Глава 46. PL/Python — процедурный язык Python" itemprop="url">Глава 46. PL/Python — процедурный язык Python</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 46. PL/Python — процедурный язык Python</p>

<p>Процедурный язык PL/Python позволяет писать функции PostgreSQL на языке Python.
Чтобы установить PL/Python в определённую базу данных, выполните команду CREATE EXTENSION
plpythonu (но смотрите также Раздел 46.1).
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
PL/Python представлен только в виде «недоверенного» языка, что означает, что он никаким спо-
собом не ограничивает действия пользователей, и поэтому он называется plpythonu. Доверенная
вариация plpython может появиться в будущем, если в Python будет разработан безопасный меха-
низм выполнения. Автор функции на недоверенном языке PL/Python должен позаботиться о том,
чтобы эту функцию нельзя было использовать не по назначению, так как она может делать всё, что
может пользователь с правами администратора баз данных. Создавать функции на недоверенных
языках, таких как plpythonu, разрешено только суперпользователям.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Python в процессе установки. (За дополнительными сведениями обратитесь к инструк-
циям по установке.) Пользователи двоичных пакетов могут найти PL/Python в отдель-
ном модуле.
46.1. Python 2 и Python 3
PL/Python поддерживает две вариации языка: Python 2 и Python 3. (Более точная информация о
поддерживаемых второстепенных версиях Python может содержаться в инструкциях по установке
PostgreSQL.) Так как языки Python 2 и Python 3 несовместимы в некоторых важных аспектах, во
избежание смешения их в PL/Python применяется следующая схема именования:
• Язык PostgreSQL с именем plpython2u представляет реализацию PL/Python, основанную на ва-
риации языка Python 2.
• Язык PostgreSQL с именем plpython3u представляет реализацию PL/Python, основанную на ва-
риации языка Python 3.
• Язык с именем plpythonu представляет реализацию PL/Python, основанную на версии Python
по умолчанию, в данный момент это Python 2. (Этот выбор по умолчанию не зависит от того,
какая версия считается локальной версией «по умолчанию», например, на какую версию ука-
зывает /usr/bin/python.) Выбор по умолчанию в отдалённом будущем выпуске PostgreSQL
может быть сменён на Python 3, в зависимости от того, как будет происходить переход на
Python 3 в сообществе Python.
Эта схема аналогична рекомендациям, данным в PEP 394, по выбору имени команды python и
переходу с версии на версию.
Будет ли доступен PL/Python для Python 2 или для Python 3, либо сразу для обеих версий, зависит
от конфигурации сборки или установленных пакетов.
1210PL/Python — проце-
дурный язык Python
Подсказка
Какая вариация будет собрана, зависит от того, как версия Python будет найдена при
установке или будет задана в переменной окружения PYTHON; см. Раздел 16.4. Чтобы в
одной инсталляции присутствовали обе вариации PL/Python, необходимо сконфигури-
ровать и настроить дерево исходного кода дважды.
В результате формируется такая стратегия использования и смены определённой версии:
• Существующие пользователи и пользователи, которым в настоящее время неинтересен Python
3, могут выбрать имя языка plpythonu и им не придётся ничего менять в обозримом будущем.
Чтобы упростить миграцию на Python 3, которая произойдёт в конце концов, рекомендуется
постепенно проверять «готовность к будущему» кода, обновляя его до версий Python 2.6/2.7.
На практике многие функции PL/Python можно мигрировать на Python 3 с минимальными из-
менениями или вовсе без изменений.
• Пользователи, знающие, что их код очень сильно зависит от Python 2, и не планирующие ко-
гда-либо менять его, могут использовать имя языка plpython2u. Это будет работать ещё очень
и очень долго, пока в PostgreSQL не будет полностью ликвидирована поддержка Python 2.
• Пользователи, желающие погрузиться в Python 3, могут выбрать имя языка plpython3u, и их
код будет работать всегда, по сегодняшним стандартам. В отдалённом будущем, когда верси-
ей по умолчанию может стать Python 3, цифру «3» из имени языка можно будет убрать из эс-
тетических соображений.
• Смельчаки, желающие уже сегодня получить операционное окружение только с Python 3, мо-
гут модифицировать pg_pltemplate, чтобы имя plpythonu было равнозначно plpython3u, отда-
вая себе отчёт в том, что такая инсталляция будет несовместима с остальным миром.
Дополнительную информацию о переходе на Python 3 можно также найти в описании Что нового
в Python 3.0.
Использовать PL/Python на базе Python 2 и PL/Python на базе Python 3 в одном сеансе нельзя, так
как это приведёт к конфликту символов в динамических модулях, что может повлечь сбой сервер-
ного процесса PostgreSQL. В системе есть проверка, предотвращающая смешение основных вер-
сий Python в одном сеансе, которая прервёт сеанс при выявлении расхождения. Однако использо-
вать обе вариации в одной базе данных всё же возможно, обращаясь к ним в разных сеансах.
46.2. Функции на PL/Python
Функции на PL/Python объявляются стандартным образом с помощью команды CREATE FUNCTION:
CREATE FUNCTION funcname (argument-list)
RETURNS return-type
AS $$</p>
<h1 id="Тело-функции-на-plpython">Тело функции на PL/Python</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Тело функции содержит просто скрипт на языке Python. Когда вызывается функция, её аргументы
передаются в виде элементов списка args; именованные аргументы также передаются скрипту
Python как обычные переменные. С именованными аргументами скрипт обычно лучше читается.
Результат из кода Python возвращается обычным способом: командой return или yield (в случае
функции, возвращающей множество). Если возвращаемое значение не определено, Python возвра-
щает None. Исполнитель PL/Python преобразует None языка Python в значение NULL языка SQL.
В процедуре код Python должен возвращать None (обычно для этого процедура завершается без
оператора return или используется оператор return без аргумента); в противном случае выдаётся
ошибка.
Например, функцию, возвращающее большее из двух целых чисел, можно определить так:
1211PL/Python — проце-
дурный язык Python
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS</script>
if a &gt; b:
return a
return b
<script type="math/tex">LANGUAGE plpythonu;
Код на Python, заданный в качестве тела объявляемой функции, становится телом функции Python.
Например, для показанного выше объявления получается функция:
def __plpython_procedure_pymax_23456():
if a > b:
return a
return b
Здесь 23456 — это OID, который PostgreSQL присвоил данной функции.
Значения аргументов задаются в глобальных переменных. Согласно правилам видимости в Python,
тонким следствием этого является то, что переменной аргумента нельзя присвоить внутри функ-
ции выражение, включающее имя самой этой переменной, если только эта переменная не объяв-
лена глобальной в текущем блоке. Например, следующий код не будет работать:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS</script>
x = x.strip() # ошибка
return x
<script type="math/tex">LANGUAGE plpythonu;
так как присвоение x значения делает x локальной переменной для всего блока, и при этом x
в правой части присваивания оказывается ещё не определённой локальной переменной x, а не
параметром функции PL/Python. Добавив оператор global, это можно исправить:
CREATE FUNCTION pystrip(x text)
RETURNS text
AS</script>
global x
x = x.strip() # теперь всё в порядке
return x
<script type="math/tex">LANGUAGE plpythonu;
Однако рекомендуется не полагаться на такие особенности реализации PL/Python, а принять, что
параметры функции предназначены только для чтения.
46.3. Значения данных
Вообще говоря, цель исполнителя PL/Python — обеспечить «естественное» соответствие между
мирами PostgreSQL и Python. Этим объясняется выбор правил сопоставления данных, описанных
ниже.
46.3.1. Сопоставление типов данных
Когда вызывается функция PL/Python, её аргументы преобразуются из типа PostgreSQL в соответ-
ствующий тип Python по таким правилам:
• Тип PostgreSQL boolean преобразуется в bool языка Python.
• Типы PostgreSQL smallint и int преобразуются в тип int языка Python. Типы PostgreSQL
bigint и oid становятся типами long в Python 2 и int в Python 3.
• Типы PostgreSQL real и double преобразуются в тип float языка Python.
• Тип PostgreSQL numeric преобразуется в Decimal среды Python. Этот тип импортируется из
пакета cdecimal, при его наличии. В противном случае используется decimal.Decimal из
1212PL/Python — проце-
дурный язык Python
стандартной библиотеки. Тип cdecimal работает значительно быстрее, чем decimal. Однако
в Python версии 3.3 и выше тип cdecimal включается в стандартную библиотеку под именем
decimal, так что теперь этого различия нет.
• Тип PostgreSQL bytea становится типом str в Python 2 и bytes в Python 3. В Python 2 такую
строку следует воспринимать как последовательность байт без какой-либо определённой ко-
дировки символов.
• Все другие типы данных, включая типы символьных строк PostgreSQL, преобразуются в тип
str языка Python. В Python 2 эта строка будет передаваться в кодировке сервера PostgreSQL; в
Python 3 это будет строка в Unicode, как и все строки.
• Информация о нескалярных типах данных приведена ниже.
При завершении функции PL/Python её значение результата преобразуется в тип данных, объяв-
ленный как тип результата в PostgreSQL, следующим образом:
• Когда тип результата функции в PostgreSQL — boolean, возвращаемое значение приводится к
логическому типу по правилам, принятым в Python. То есть false будет возвращено для 0 и пу-
стой строки, но, обратите внимание, для 'f' будет возвращено true.
• Когда тип результата функции PostgreSQL — bytea, возвращаемое значение будет преобразо-
вано в строку (Python 2) или набор байт (Python 3), используя встроенные средства Python, а
затем будет приведено к типу bytea.
• Для всех других типов результата PostgreSQL возвращаемое значение преобразуется в строку
с помощью встроенной в Python функции str, и полученная строка передаётся функции ввода
типа данных PostgreSQL. (Если значение в Python имеет тип float, оно преобразуется встро-
енной функцией repr, а не str, для недопущения потери точности.)
Из кода Python 2 строки должны передаваться в PostgreSQL в кодировке сервера PostgreSQL.
При передаче строки, неприемлемой для текущей кодировки сервера, возникает ошибка, но
не все несоответствия кодировки могут быть выявлены, так что с некорректной кодировкой
всё же могут быть получены нечитаемые строки. Строки Unicode переводятся в нужную коди-
ровку автоматически, так что использовать их может быть безопаснее и удобнее. В Python 3
все строки имеют кодировку Unicode.
• Информация о нескалярных типах данных приведена ниже.
Заметьте, что логические несоответствия между объявленным в PostgreSQL типом результата и
типом фактически возвращаемого объекта Python игнорируются — значение преобразуется в лю-
бом случае.
46.3.2. Null, None
Если функции передаётся значение SQL NULL, в Python значением этого аргумента будет None.
Например, функция pymax, определённая как показано в Раздел 46.2, возвратит неверный ответ,
получив аргументы NULL. Мы могли бы добавить указание STRICT в определение функции, чтобы
PostgreSQL поступал немного разумнее: при передаче значения NULL функция вовсе не будет
вызываться, будет сразу возвращён результат NULL. С другой стороны, мы могли бы проверить
аргументы на NULL в теле функции:
CREATE FUNCTION pymax (a integer, b integer)
RETURNS integer
AS</script>
if (a is None) or (b is None):
return None
if a &gt; b:
return a
return b
<script type="math/tex">LANGUAGE plpythonu;
Как показано выше, чтобы выдать из функции PL/Python значение SQL NULL, нужно вернуть зна-
чение None. Это можно сделать и в строгой, и в нестрогой функции.
1213PL/Python — проце-
дурный язык Python
46.3.3. Массивы, списки
Значения массивов SQL передаются в PL/Python в виде списка Python. Чтобы вернуть значение
массива SQL из функции PL/Python, возвратите список Python:
CREATE FUNCTION return_arr()
RETURNS int[]
AS</script>
return [1, 2, 3, 4, 5]
<script type="math/tex">LANGUAGE plpythonu;
SELECT return_arr();
return_arr
-------------
(1,2,3,4,5)
(1 row)
Многомерные массивы передаются в PL/Python в виде вложенных списков Python. Например, двух-
мерный массив представляется как список списков. При передаче многомерного массива SQL из
функции PL/Python необходимо, чтобы все внутренние списки на каждом уровне имели одинако-
вый размер. Например:
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS</script>
plpy.info(x, type(x))
return x
<script type="math/tex">% <![CDATA[
LANGUAGE plpythonu;
SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO: ([[1, 2, 3], [4, 5, 6]], <type 'list'>)
test_type_conversion_array_int4
---------------------------------
((1,2,3),(4,5,6))
(1 row)
Другие последовательности Python, например кортежи, тоже принимаются для обратной совме-
стимости с PostgreSQL версии 9.6 и ниже (где многомерные массивы не поддерживались). Однако
они всегда воспринимаются как одномерные массивы, чтобы не возникало неоднозначности с со-
ставными типами. По этой же причине когда в многомерном массиве используется составной тип,
он должен представляться как кортеж, а не список.
Учтите, что в Python и строки являются последовательностями, что может давать неожиданные
эффекты, хорошо знакомые тем, кто программирует на Python:
CREATE FUNCTION return_str_arr()
RETURNS varchar[]
AS %]]></script>
return “hello”
<script type="math/tex">LANGUAGE plpythonu;
SELECT return_str_arr();
return_str_arr
----------------
(h,e,l,l,o)
(1 row)
46.3.4. Составные типы
Аргументы составного типа передаются функции в виде сопоставлений Python. Именами элемен-
тов сопоставления являются атрибуты составного типа. Если атрибут в переданной строке имеет
значение NULL, он передаётся в сопоставлении значением None. Пример работы с составным ти-
пом:
1214PL/Python — проце-
дурный язык Python
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid (e employee)
RETURNS boolean
AS</script>
if e[“salary”] &gt; 200000:
return True
if (e[“age”] &lt; 30) and (e[“salary”] &gt; 100000):
return True
return False
<script type="math/tex">LANGUAGE plpythonu;
Возвратить составной тип или строку таблицы из функции Python можно несколькими способами.
В следующих примерах предполагается, что у нас объявлен тип:
CREATE TYPE named_value AS (
name
text,
value integer
);
Результат этого типа можно вернуть как:
Последовательность (кортеж или список, но не множество, так как оно не индексируется)
В возвращаемых объектах последовательностей должно быть столько элементов, сколько полей
в составном типе результата. Элемент с индексом 0 присваивается первому полю составного
типа, с индексом 1 — второму и т. д. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
return ( name, value )</p>
<h1 id="или-альтернативный-вариант-в-виде-кортежа-return--name-value-">или альтернативный вариант, в виде кортежа: return [ name, value ]</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте в соответствующую позицию None.
Когда возвращается массив составных значений, его нельзя представить в виде списка, так как
невозможно однозначно определить, представляет ли список Python составной тип или ещё
одну размерность массива.
Сопоставление (словарь)
Значение столбца результата получается из сопоставления, в котором ключом является имя
столбца. Например:
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
return ( “name”: name, “value”: value )
<script type="math/tex">LANGUAGE plpythonu;
Любые дополнительные пары ключ/значение в словаре игнорируются, а отсутствие нужных
ключей считается ошибкой. Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте None
с именем соответствующего столбца в качестве ключа.
Объект (любой объект с методом __getattr__)
Объект передаётся аналогично сопоставлению. Пример:
1215PL/Python — проце-
дурный язык Python
CREATE FUNCTION make_pair (name text, value integer)
RETURNS named_value
AS</script>
class named_value:
def <strong>init</strong> (self, n, v):
self.name = n
self.value = v
return named_value(name, value)</p>
<h1 id="или-просто">или просто</h1>
<p>class nv: pass
nv.name = name
nv.value = value
return nv
<script type="math/tex">LANGUAGE plpythonu;
Также поддерживаются функции с параметрами OUT (выходными). Например:
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS</script>
return (1, 2)
<script type="math/tex">LANGUAGE plpythonu;
SELECT * FROM multiout_simple();
Выходные параметры процедуры выдаются таким же образом. Например:
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS</script>
return (a * 3, b * 3)
<script type="math/tex">LANGUAGE plpythonu;
CALL python_triple(5, 10);
46.3.5. Функции, возвращающие множества
Функция PL/Python также может возвращать множества, содержащие скалярные и составные ти-
пы. Это можно осуществить разными способами, так как возвращаемый объект внутри превраща-
ется в итератор. В следующих примерах предполагается, что у нас есть составной тип:
CREATE TYPE greeting AS (
how text,
who text
);
Множество в качестве результата можно возвратить, применив:
Последовательность (кортеж, список, множество)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script></p>
<h1 id="возвращает-кортеж-содержащий-списки-в-качестве-составных-типов">возвращает кортеж, содержащий списки в качестве составных типов</h1>
<h1 id="также-будут-работать-и-остальные-комбинации">также будут работать и остальные комбинации</h1>
<p>return ( [ how, “World” ], [ how, “PostgreSQL” ], [ how, “PL/Python” ] )
<script type="math/tex">LANGUAGE plpythonu;
Итератор (любой объект, реализующий методы __iter__ и next)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script>
class producer:
def <strong>init</strong> (self, how, who):
1216PL/Python — проце-
дурный язык Python
self.how = how
self.who = who
self.ndx = -1
def <strong>iter</strong> (self):
return self
def next (self):
self.ndx += 1
if self.ndx == len(self.who):
raise StopIteration
return ( self.how, self.who[self.ndx] )
return producer(how, [ “World”, “PostgreSQL”, “PL/Python” ])
<script type="math/tex">LANGUAGE plpythonu;
Генератор (yield)
CREATE FUNCTION greet (how text)
RETURNS SETOF greeting
AS</script>
for who in [ “World”, “PostgreSQL”, “PL/Python” ]:
yield ( how, who )
<script type="math/tex">LANGUAGE plpythonu;
Также поддерживаются функции, возвращающие множества, с параметрами OUT (объявленные с
RETURNS SETOF record). Например:
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS
SETOF record AS</script>
return [(1, 2)] * n
<script type="math/tex">LANGUAGE plpythonu;
SELECT * FROM multiout_simple_setof(3);
46.4. Совместное использование данных
Для сохранения внутренних данных при повторных вызовах одной и той же функции предусмотрен
глобальный словарь SD. Для размещения публичных данных предназначен глобальный словарь GD,
доступный всем функциям на Python в сеансе; используйте его с осторожностью.
Каждая функция получает собственную среду выполнения в интерпретаторе Python, так что гло-
бальные данные и аргументы функции, например myfunc, не будут доступны в myfunc2. Исключе-
ние составляют данные в словаре GD, как сказано выше.
46.5. Анонимные блоки кода
PL/Python также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO</script></p>
<h1 id="Код-на-plpython">Код на PL/Python</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
46.6. Триггерные функции
Когда функция используется как триггер, словарь TD содержит значения, связанные с работой
триггера:
1217PL/Python — проце-
дурный язык Python
TD["event"]
содержит название события в виде строки: INSERT, UPDATE, DELETE или TRUNCATE.
TD["when"]
содержит одну из строк: BEFORE, AFTER или INSTEAD OF.
TD["level"]
содержит ROW или STATEMENT.
TD["new"]
TD["old"]
Для триггера уровня строки одно или оба этих поля содержат соответствующие строки тригге-
ра, в зависимости от события триггера.
TD["name"]
содержит имя триггера.
TD["table_name"]
содержит имя таблицы, для которой сработал триггер.
TD["table_schema"]
содержит схему таблицы, для которой сработал триггер.
TD["relid"]
содержит OID таблицы, для которой сработал триггер.
TD["args"]
Если в команде CREATE TRIGGER задавались аргументы, их можно получить как элементы мас-
сива с TD["args"][0] по TD["args"][n-1].
Если в TD["when"] передано BEFORE или INSTEAD OF, а в TD["level"] — ROW, вы можете вернуть
значение None или "OK" из функции Python, чтобы показать, что строка не была изменена, значение
"SKIP", чтобы прервать событие, либо, если в TD["event"] передана команда INSERT или UPDATE,
вы можете вернуть "MODIFY", чтобы показать, что новая строка была изменена. Во всех других
случаях возвращаемое значение игнорируется.
46.7. Обращение к базе данных
Исполнитель языка PL/Python автоматически импортирует модуль Python с именем plpy. Вы в сво-
ём коде можете использовать функции и константы, объявленные в этом модуле, обращаясь к ним
по именам вида plpy.имя.
46.7.1. Функции обращения к базе данных
Модуль plpy содержит различные функции для выполнения команд в базе данных:
plpy.execute(запрос [, макс-строк])
При вызове plpy.execute со строкой запроса и необязательным аргументом, ограничивающим
число строк, выполняется заданный запрос, а то, что он выдаёт, возвращается в виде объекта
результата.
Объект результата имитирует список или словарь. Получить из него данные можно по номеру
строки и имени столбца. Например, команда:
rv = plpy.execute("SELECT * FROM my_table", 5)
1218PL/Python — проце-
дурный язык Python
вернёт не более 5 строк из отношения my_table. Если в my_table есть столбец my_column, к
нему можно обратиться так:
foo = rv[i]["my_column"]
Число возвращённых в этом объекте строк можно получить, воспользовавшись встроенной
функцией len.
Для объекта результата определены следующие дополнительные методы:
nrows()
Возвращает число строк, обработанных командой. Заметьте, что это число не обязательно
будет равно числу возвращённых строк. Например, команда UPDATE устанавливает это зна-
чение, но не возвращает строк (без указания RETURNING).
status()
Значение состояния, возвращённое SPI_execute().
colnames()
coltypes()
coltypmods()
Возвращают список имён столбцов, список OID типов столбцов и список модификаторов
типа этих столбцов, соответственно.
Эти методы вызывают исключение, когда им передаётся объект, полученный от команды, не
возвращающей результирующий набор, например, UPDATE без RETURNING, либо DROP TABLE.
Но эти методы вполне можно использовать с результатом, содержащим ноль строк.
__str__()
Стандартный метод __str__ определён так, чтобы можно было, например, вывести отладоч-
ное сообщение с результатами запроса, вызвав plpy.debug(rv).
Объект результата может быть изменён.
Заметьте, что при вызове plpy.execute весь набор результатов будет прочитан в память. Эту
функцию следует использовать, только если вы знаете, что набор будет относительно неболь-
шим. Если вы хотите исключить риск переполнения памяти при выборке результатов большого
объёма, используйте plpy.cursor вместо plpy.execute.
plpy.prepare(запрос [, типы_аргументов])
plpy.execute(план [, аргументы [, макс-строк]])
Функция plpy.prepare подготавливает план выполнения для запроса. Она вызывается со стро-
кой запроса и списком типов параметров (если в запросе есть параметры). Например:
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1",
["text"])
Здесь text представляет переменную, передаваемую в качестве параметра $1. Второй аргумент
необязателен, если запросу не нужно передавать никакие параметры.
Чтобы запустить подготовленный оператор на выполнение, используйте вариацию функции
plpy.execute:
rv = plpy.execute(plan, ["name"], 5)
Передайте план в первом аргументе (вместо строки запроса), а список значений, которые будут
подставлены в запрос, — во втором. Второй аргумент можно опустить, если запрос не прини-
мает никакие параметры. Третий аргумент, как и раньше, задаёт необязательное ограничение
максимального числа строк.
1219PL/Python — проце-
дурный язык Python
Вы также можете вызвать метод execute объекта плана:
rv = plan.execute(["name"], 5)
Параметры запросов и поля строк результата преобразуются между типами данных PostgreSQL
и Python как описано в Разделе 46.3.
Когда вы подготавливаете план, используя модуль PL/Python, он сохраняется автоматически.
Что это означает, вы можете узнать в документации SPI (Глава 47). Чтобы эффективно исполь-
зовать это в нескольких вызовах функции, может потребоваться применить словарь постоянно-
го хранения SD или GD (см. Раздел 46.4). Например:
CREATE FUNCTION usesavedplan() RETURNS trigger AS</script>
if “plan” in SD:
plan = SD[“plan”]
else:
plan = plpy.prepare(“SELECT 1”)
SD[“plan”] = plan</p>
<h1 id="остальной-код-функции">остальной код функции</h1>
<p><script type="math/tex">LANGUAGE plpythonu;
plpy.cursor(запрос)
plpy.cursor(план [, аргументы])
Функция plpy.cursor принимает те же аргументы, что и plpy.execute (кроме ограничения
строк) и возвращает объект курсора, который позволяет обрабатывать объёмные наборы ре-
зультатов небольшими порциями. Как и plpy.execute, этой функции можно передать строку
запроса или объект плана со списком аргументов, а можно вызывать функцию cursor как ме-
тод объекта плана.
Объект курсора реализует метод fetch, который принимает целочисленный параметр и воз-
вращает объект результата. При каждом следующем вызове fetch возвращаемый объект будет
содержать следующий набор строк, в количестве, не превышающем значение параметра. Ко-
гда строки закончатся, fetch начнёт возвращать пустой объект результата. Объекты курсора
также предоставляют интерфейс итератора, выдающий по строке за один раз, пока не будут
выданы все строки. Данные, выбираемые таким образом, возвращаются не как объекты резуль-
тата, а как словари (одной строке результата соответствует один словарь).
Следующий пример демонстрирует обработку содержимого большой таблицы двумя способа-
ми:
CREATE FUNCTION count_odd_iterator() RETURNS integer AS</script>
odd = 0
for row in plpy.cursor(“select num from largetable”):
if row[‘num’] % 2:
odd += 1
return odd
<script type="math/tex">LANGUAGE plpythonu;
CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS</script>
odd = 0
cursor = plpy.cursor(“select num from largetable”)
while True:
rows = cursor.fetch(batch_size)
if not rows:
break
for row in rows:
if row[‘num’] % 2:
odd += 1
return odd
<script type="math/tex">LANGUAGE plpythonu;
1220PL/Python — проце-
дурный язык Python
CREATE FUNCTION count_odd_prepared() RETURNS integer AS</script>
odd = 0
plan = plpy.prepare(“select num from largetable where num % $1 &lt;&gt; 0”, [“integer”])
rows = list(plpy.cursor(plan, [2])) # или: = list(plan.cursor([2]))
return len(rows)
<script type="math/tex">LANGUAGE plpythonu;
Курсоры ликвидируются автоматически. Но если вы хотите явно освободить все ресурсы, за-
нятые курсором, вызовите метод close. Продолжать получать данные через курсор, который
был закрыт, нельзя.
Подсказка
Не путайте объекты, создаваемые функцией plpy.cursor, с курсорами DB-API, опре-
делёнными в спецификации API для работы с базами данных в Python. Они не име-
ют ничего общего, кроме имени.
46.7.2. Обработка ошибок
Функции, обращающиеся к базе данных, могут сталкиваться с ошибками, в результате которых
они будут прерываться и вызывать исключение. Обе функции plpy.execute и plpy.prepare могут
вызывать экземпляр подкласса исключения plpy.SPIError, которое по умолчание прекращает вы-
полнение функции. Эту ошибку можно обработать, как и любое другое исключение в Python, при-
менив конструкцию try/except. Например:
CREATE FUNCTION try_adding_joe() RETURNS text AS</script>
try:
plpy.execute(“INSERT INTO users(username) VALUES (‘joe’)”)
except plpy.SPIError:
return “something went wrong”
else:
return “Joe added”
<script type="math/tex">LANGUAGE plpythonu;
Фактический класс вызываемого исключения соответствует определённому условию возник-
новения ошибки. Список всех возможных условий приведён в Таблице  A.1. В модуле
plpy.spiexceptions определяются классы исключений для каждого условия PostgreSQL, с име-
нами, производными от имён условий. Например, имя division_by_zero становится именем
DivisionByZero, unique_violation — именем UniqueViolation, fdw_error — именем FdwError и т.
д. Все эти классы исключений наследуются от SPIError. Такое разделение на классы упрощает
обработку определённых ошибок, например:
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS</script>
from plpy import spiexceptions
try:
plan = plpy.prepare(“INSERT INTO fractions (frac) VALUES ($1 / $2)”, [“int”,
“int”])
plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
return “denominator cannot equal zero”
except spiexceptions.UniqueViolation:
return “already have that fraction”
except plpy.SPIError, e:
return “other error, SQLSTATE %s” % e.sqlstate
else:
return “fraction inserted”
1221PL/Python — проце-
дурный язык Python
<script type="math/tex">LANGUAGE plpythonu;
Заметьте, что так как все исключения из модуля plpy.spiexceptions наследуются от исключения
SPIError, команда except, обрабатывающая это исключение, будет перехватывать все ошибки при
обращении к базе данных.
В качестве другого варианта обработки различных условий ошибок, вы можете перехватывать ис-
ключение SPIError и определять конкретное условие ошибки внутри блока except по значению ат-
рибута sqlstate объекта исключения. Этот атрибут содержит строку с кодом ошибки «SQLSTATE».
Конечный результат при таком подходе примерно тот же.
46.8. Явные подтранзакции
Перехват ошибок, произошедших при обращении к базе данных, как описано в Подразделе 46.7.2,
может привести к нежелательной ситуации, когда часть операций будет успешно выполнена,
прежде чем произойдёт сбой. Данные останутся в несогласованном состоянии после обработки
такой ошибки. PL/Python предлагает решение этой проблемы в форме явных подтранзакций.
46.8.1. Менеджеры контекста подтранзакций
Рассмотрим функцию, осуществляющую перевод средств между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS</script>
try:
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
Если при выполнении второго оператора UPDATE произойдёт исключение, эта функция сообщит
об ошибке, но результат первого UPDATE будет, тем не менее, зафиксирован. Другими словами,
средства будут списаны со счёта Джо, но не зачислятся на счёт Мэри.
Во избежание таких проблем вы можете завернуть вызовы plpy.execute в явную подтранзакцию.
Модуль plpy предоставляет вспомогательный объект для управления явными подтранзакциями,
создаваемый функцией plpy.subtransaction(). Объекты, созданные этой функцией, реализуют
интерфейс менеджера контекста. Используя явные подтранзакции, мы можем переписать нашу
функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS</script>
try:
with plpy.subtransaction():
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
1222PL/Python — проце-
дурный язык Python
Заметьте, что конструкция try/catch по-прежнему нужна. Без неё исключение распространится
вверх по стеку Python и приведёт к прерыванию всей функции с ошибкой PostgreSQL, так что в
таблицу operations запись не добавится. Менеджер контекста подтранзакции не перехватывает
ошибки, он только гарантирует, что все операции с базой данных в его области действия будут
атомарно зафиксированы или отменены. Откат блока подтранзакции происходит при исключении
любого вида, а не только исключения, вызванного ошибками при обращении к базе данных. Обыч-
ное исключение Python, вызванное внутри блока явной подтранзакции, также приведёт к откату
этой подтранзакции.
46.8.2. Старые версии Python
Синтаксис использования менеджеров контекста с ключевым словом with по умолчанию поддер-
живается в Python 2.6. В PL/Python с более старой версией Python тоже возможно использовать
явные подтранзакции, хотя и не так прозрачно. При этом вы можете вызывать методы __enter__
и __exit__ менеджера контекста по удобным псевдонимам enter и exit. Для такого случая функ-
цию перечисления средств можно переписать так:
CREATE FUNCTION transfer_funds_old() RETURNS void AS</script>
try:
subxact = plpy.subtransaction()
subxact.enter()
try:
plpy.execute(“UPDATE accounts SET balance = balance - 100 WHERE account_name =
‘joe’”)
plpy.execute(“UPDATE accounts SET balance = balance + 100 WHERE account_name =
‘mary’”)
except:
import sys
subxact.exit(*sys.exc_info())
raise
else:
subxact.exit(None, None, None)
except plpy.SPIError, e:
result = “error transferring funds: %s” % e.args
else:
result = “funds transferred correctly”
plan = plpy.prepare(“INSERT INTO operations (result) VALUES ($1)”, [“text”])
plpy.execute(plan, [result])
<script type="math/tex">LANGUAGE plpythonu;
Примечание
Хотя менеджеры контекста были реализованы в 2.5, для использования синтаксиса
with в этой версии нужно применить «будущий оператор». Однако по техническим
причинам «будущие операторы» в функциях PL/Python использовать нельзя.
46.9. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в ко-
манде DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, вызови-
те plpy.commit(), а чтобы откатить — plpy.rollback(). (Заметьте, что выполнить SQL-команды
COMMIT или ROLLBACK через plpy.execute или подобную функцию нельзя. Соответствующие опера-
ции могут выполняться только данными функциями.) После завершения одной транзакции следу-
ющая начинается автоматически, отдельной функции для этого нет.
Пример:
1223PL/Python — проце-
дурный язык Python
CREATE PROCEDURE transaction_test1()
LANGUAGE plpythonu
AS</script>
for i in range(0, 10):
plpy.execute(“INSERT INTO test1 (a) VALUES (%d)” % i)
if i % 2 == 0:
plpy.commit()
else:
plpy.rollback()
<script type="math/tex">;
CALL transaction_test1();
Транзакцию нельзя завершить в случае существования открытой явной подтранзакции.
46.10. Вспомогательные функции
Модуль plpy также предоставляет функции
plpy.debug( msg, **kwargs )
plpy.log( msg, **kwargs )
plpy.info( msg, **kwargs )
plpy.notice( msg, **kwargs )
plpy.warning( msg, **kwargs )
plpy.error( msg, **kwargs )
plpy.fatal( msg, **kwargs )
Функции plpy.error и plpy.fatal на самом деле выдают исключение Python, которое, если его
не перехватить, распространяется в вызывающий запрос, что приводит к прерыванию текущей
транзакции или подтранзакции. Команды raise plpy.Error(msg) и raise plpy.Fatal(msg) рав-
нозначны вызовам plpy.error(msg) и plpy.fatal(msg), соответственно, но форма raise не позво-
ляет передавать аргументы с ключами. Другие функции просто выдают сообщения разных уров-
ней важности. Будут ли сообщения определённого уровня передаваться клиентам и/или записы-
ваться в журнал сервера, определяется конфигурационными переменными log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
Аргумент msg задаётся как позиционный. Для обратной совместимости может быть передано
несколько позиционных аргументов. В этом случае сообщением для клиента становится строковое
представление кортежа позиционных аргументов.
Дополнительно только по ключам принимаются следующие аргументы:
detail
hint
sqlstate
schema_name
table_name
column_name
datatype_name
constraint_name
Строковое представление объектов, передаваемых в аргументах по ключам, позволяет выдать кли-
енту более богатую информацию. Например:
CREATE FUNCTION raise_custom_exception() RETURNS void AS</script>
plpy.error(“custom exception message”,
detail=”some info about exception”,
hint=”hint for users”)
$$ LANGUAGE plpythonu;
1224PL/Python — проце-
дурный язык Python
=# SELECT raise_custom_exception();
ERROR: plpy.Error: custom exception message
DETAIL: some info about exception
HINT: hint for users
CONTEXT: Traceback (most recent call last):
PL/Python function “raise_custom_exception”, line 4, in <module>
hint="hint for users")
PL/Python function "raise_custom_exception"
Ещё
один
набор
вспомогательных
функций
образуют
plpy.quote_literal(строка),
plpy.quote_nullable(строка) и plpy.quote_ident(строка). Они равнозначны встроенным функ-
циям заключения в кавычки, описанным в Разделе 9.4. Они полезны при конструировании свобод-
но составляемых запросов. На PL/Python динамический SQL, показанный в Примере 43.1, форми-
руется так:
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
plpy.quote_ident(colname),
plpy.quote_nullable(newvalue),
plpy.quote_literal(keyvalue)))
46.11. Переменные окружения
Некоторые переменные окружения, воспринимаемые интерпретатором Python, тоже могут влиять
на поведение PL/Python. При необходимости их нужно установить в среде основного серверного
процесса PostgreSQL, например, в скрипте запуска. Множество доступных переменных окружения
зависит от версии Python; за подробностями обратитесь к документации Python. На момент напи-
сания этой документации, на поведение PL/Python влияли следующие переменные окружения, при
наличии подходящей версии Python:
• PYTHONHOME
• PYTHONPATH
• PYTHONY2K
• PYTHONOPTIMIZE
• PYTHONDEBUG
• PYTHONVERBOSE
• PYTHONCASEOK
• PYTHONDONTWRITEBYTECODE
• PYTHONIOENCODING
• PYTHONUSERBASE
• PYTHONHASHSEED
(Похоже, что вследствие тонкостей реализации Python, не зависящих от исполнителя PL/Python,
некоторые переменные окружения, перечисленные на странице руководства man python, действу-
ют только в интерпретаторе для командной строки, но не во встраиваемом интерпретаторе Python.)
1225</module></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-045/" title="Глава 45. PL/Perl — процедурный язык Perl"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 45. PL/Perl — процедурный язык Perl"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-045/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~10 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-045/" rel="bookmark" title="Глава 45. PL/Perl — процедурный язык Perl" itemprop="url">Глава 45. PL/Perl — процедурный язык Perl</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 45. PL/Perl — процедурный язык Perl</p>

<p>PL/Perl — это загружаемый процедурный язык, позволяющий реализовывать функции PostgreSQL
на языке программирования Perl.
Основным преимуществом PL/Perl является то, что он позволяет применять в сохранённых функци-
ях множество функций и операторов «перемалывания строк», имеющихся в Perl. Разобрать слож-
ные строки на языке Perl может быть гораздо проще, чем используя строковые функции и управ-
ляющие структуры в PL/pgSQL.
Чтобы установить PL/Perl в определённую базу данных, выполните команду CREATE EXTENSION
plperl.
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Perl в процессе установки. (За дополнительными сведениями обратитесь к Главе 16.)
Пользователи двоичных пакетов могут найти PL/Perl в отдельном модуле.
45.1. Функции на PL/Perl и их аргументы
Чтобы создать функцию на языке PL/Perl, используйте стандартный синтаксис CREATE FUNCTION:
CREATE FUNCTION имя_функции (типы-аргументов) RETURNS тип-результата AS $$</p>
<h1 id="Тело-функции-на-plperl">Тело функции на PL/Perl</h1>
<p><script type="math/tex">LANGUAGE plperl;
Тело функции содержит обычный код Perl. Фактически, код обвязки PL/Perl помещает этот код
в подпрограмму Perl. Функция PL/Perl вызывается в скалярном контексте, так что она не может
вернуть список. Не скалярные значения (массивы, записи и множества) можно вернуть по ссылке,
как описывается ниже.
В процедуре PL/Perl возвращаемое из кода Perl значение игнорируется.
PL/Perl также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO</script></p>
<h1 id="Код-plperl">Код PL/Perl</h1>
<p><script type="math/tex">LANGUAGE plperl;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
Примечание
Использовать вложенные именованные подпрограммы в Perl опасно, особенно если они
обращаются к лексическим переменным в окружающей области. Так как функция PL/
Perl оборачивается в подпрограмму, любая именованная функция внутри неё будет вло-
женной. Вообще гораздо безопаснее создавать анонимные подпрограммы и вызывать
их по ссылке на код. Дополнительную информацию вы можете получить на странице
руководства man perldiag, в описании ошибок Variable "%s" will not stay shared
(Переменная "%s" не останется разделяемой) и Variable "%s" is not available (Пе-
1195PL/Perl — процедурный язык Perl
ременная "%s" недоступна), либо найти в Интернете по ключевым словам «perl nested
named subroutine» (perl вложенная именованная подпрограмма).
Синтаксис команды CREATE FUNCTION требует, чтобы тело функции было записано как строковая
константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. Под-
раздел 4.1.2.4). Если вы решите применять синтаксис спецпоследовательностей E'', вам придётся
дублировать апострофы (') и обратную косую черту (\) в теле функции (см. Подраздел 4.1.2.1).
Аргументы и результат обрабатываются как и в любой другой подпрограмме на Perl: аргументы
передаются в @_, а результирующим значением будет указанное в return или полученное в по-
следнем выражении, вычисленном в функции.
Например, функцию, возвращающую большее из двух целых чисел, можно определить так:
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS</script>
if ($<em>[0] &gt; $</em>[1]) { return $<em>[0]; }
return $</em>[1];
<script type="math/tex">LANGUAGE plperl;
Примечание
Аргументы будут преобразованы из кодировки базы данных в UTF-8 для использования
в PL/Perl, а при выходе снова будут преобразованы из UTF-8 в кодировку базы данных.
Если функции передаётся NULL-значение SQL, значением аргумента в Perl станет «undefined».
Показанное выше определение функции будет не очень хорошо обрабатывать значения NULL (в
действительности они будут восприняты как нули). Мы могли бы добавить указание STRICT в это
определение, чтобы PostgreSQL поступал немного разумнее: при передаче значения NULL функ-
ция вовсе не будет вызываться, будет сразу возвращён результат NULL. С другой стороны, мы
могли бы проверить значения undefined в теле функции. Например, предположим, что нам нужна
функция perl_max, которая с одним аргументом NULL и вторым аргументом не NULL должна воз-
вращать не NULL, а второй аргумент:
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS</script>
my ($x, $y) = @_;
if (not defined $x) {
return undef if not defined $y;
return $y;
}
return $x if not defined $y;
return $x if $x &gt; $y;
return $y;
<script type="math/tex">LANGUAGE plperl;
Как показано выше, чтобы выдать значение SQL NULL, нужно вернуть значение undefined. Это
можно сделать и в строгой, и в нестрогой функции.
Всё в аргументах функции, что не является ссылкой, является строкой, то есть стандартным для
PostgreSQL внешним текстовым представлением соответствующего типа данных. В случае с обыч-
ными числовыми или текстовыми типами, Perl просто воспринимает их должным образом, и про-
граммист, как правило, может об этом не думать. Однако в более сложных случаях может потре-
боваться преобразовать аргумент в форму, подходящую для использования в Perl. Например, для
преобразования типа bytea в двоичное значение можно использовать функцию decode_bytea.
Аналогично, значения, передаваемые в PostgreSQL, должны быть в формате внешнего текстового
представления. Например, для подготовки двоичных данных к возврату в значении bytea можно
воспользоваться функцией encode_bytea.
Perl может возвращать массивы PostgreSQL как ссылки на массивы Perl. Например, так:
1196PL/Perl — процедурный язык Perl
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS</script>
return [[‘a”b’,’c,d’],[‘e\f’,’g’]];
<script type="math/tex">LANGUAGE plperl;
select returns_array();
Perl передаёт массивы PostgreSQL как объект, сопоставленный с PostgreSQL::InServer::ARRAY. С
этим объектом можно работать как со ссылкой на массив или строкой, что допускает обратную
совместимость с кодом Perl, написанным для PostgreSQL версии до 9.1. Например:
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS</script>
my $arg = shift;
my $result = “”;
return undef if (!defined $arg);</p>
<h1 id="в-качестве-ссылки-на-массив">в качестве ссылки на массив</h1>
<p>for (@$arg) {
$result .= $_;
}</p>
<h1 id="также-работает-со-строкой">также работает со строкой</h1>
<p>$result .= $arg;
return $result;
<script type="math/tex">LANGUAGE plperl;
SELECT concat_array_elements(ARRAY['PL','/','Perl']);
Примечание
Многомерные массивы представляются как ссылки на массивы меньшей размерности
со ссылками — этот способ хорошо знаком каждому программисту на Perl.
Аргументы составного типа передаются функции как ссылки на хеши. Ключами хеша являются
имена атрибутов составного типа. Например:
CREATE TABLE employee (
name text,
basesalary integer,
bonus integer
);
CREATE FUNCTION empcomp(employee) RETURNS integer AS</script>
my ($emp) = @<em>;
return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
<script type="math/tex">LANGUAGE plperl;
SELECT name, empcomp(employee.*) FROM employee;
Функция на PL/Perl может вернуть результат составного типа, применяя тот же подход: возвратить
ссылку на хеш с требуемыми атрибутами. Например, так:
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);
CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS</script>
return {f2 =&gt; ‘hello’, f1 =&gt; 1, f3 =&gt; ‘world’};
<script type="math/tex">LANGUAGE plperl;
1197PL/Perl — процедурный язык Perl
SELECT * FROM perl_row();
Столбцы объявленного типа результата, отсутствующие в хеше, будут возвращены как значения
NULL.
Подобным образом в виде ссылки на хеш могут быть возвращены выходные аргументы процедуры:
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS</script>
my ($a, $b) = @</em>;
return {a =&gt; $a * 3, b =&gt; $b * 3};
<script type="math/tex">LANGUAGE plperl;
CALL perl_triple(5, 10);
Функции на PL/Perl могут также возвращать множества со скалярными или составными типами.
Обычно желательно возвращать результат по одной строке, чтобы сократить время подготовки
с одной стороны, и чтобы не потребовалось накапливать весь набор данных в памяти, с другой.
Это можно реализовать с помощью функции return_next, как показано ниже. Заметьте, что после
последнего вызова return_next, нужно поместить return или (что лучше) return undef.
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS</script>
foreach (0..$<em>[0]) {
return_next($</em>);
}
return undef;
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set_int(5);
CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS</script>
return_next({ f1 =&gt; 1, f2 =&gt; ‘Hello’, f3 =&gt; ‘World’ });
return_next({ f1 =&gt; 2, f2 =&gt; ‘Hello’, f3 =&gt; ‘PostgreSQL’ });
return_next({ f1 =&gt; 3, f2 =&gt; ‘Hello’, f3 =&gt; ‘PL/Perl’ });
return undef;
<script type="math/tex">LANGUAGE plperl;
Для небольших наборов данных можно также вернуть ссылку на массив, содержащий скаляры,
ссылки на массивы, либо ссылки на хеши для простых типов, типов массивов и составных типов,
соответственно. Ниже приведена пара простых примеров, показывающих, как возвратить весь на-
бор данных в виде ссылки на массив:
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS</script>
return [0..$<em>[0]];
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set_int(5);
CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS</script>
return [
{ f1 =&gt; 1, f2 =&gt; ‘Hello’, f3 =&gt; ‘World’ },
{ f1 =&gt; 2, f2 =&gt; ‘Hello’, f3 =&gt; ‘PostgreSQL’ },
{ f1 =&gt; 3, f2 =&gt; ‘Hello’, f3 =&gt; ‘PL/Perl’ }
];
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set();
Если вы хотите использовать в своём коде strict, у вас есть несколько вариантов. Для временного
глобального использования вы можете задать для plperl.use_strict значение true командой SET.
1198PL/Perl — процедурный язык Perl
Это повлияет на компилируемые впоследствии функции PL/Perl, но не на функции, уже скомпили-
рованные в текущем сеансе. Для постоянного глобального использования вы можете присвоить
параметру plperl.use_strict значение true в файле postgresql.conf.
Для постоянного использования strict в опредёлённых функциях вы можете просто написать:
use strict;
в начале тела этих функций.
Вы также можете использовать указания feature в use, если используете Perl версии 5.10.0 или
новее.
45.2. Значения в PL/Perl
Значения аргументов, передаваемые в код функции PL/Perl, представляют собой просто входные
аргументы, преобразованные в текстовый вид (так же, как при выводе оператором SELECT). И на-
оборот, команды return и return_next могут принять любую строку, соответствующую формату
ввода для объявленного типа результата функции.
45.3. Встроенные функции
45.3.1. Обращение к базе данных из PL/Perl
Обращаться к самой базе данных из кода Perl можно, используя следующие функции:
spi_exec_query(запрос [, макс-строк])
spi_exec_query выполняет команду SQL и возвращает весь набор строк в виде ссылки на мас-
сив хешей. Эту функцию следует использовать, только если вы знаете, что набор будет
относительно небольшим. Так выглядит пример запроса (SELECT) с дополнительно заданным
максимальным числом строк:
$rv = spi_exec_query('SELECT * FROM my_table', 5);
Этот запрос возвращает не больше 5 строк из таблицы my_table. Если в my_table есть столбец
my_column, получить его значение из строки $i результата можно следующим образом:
$foo = $rv->{rows}[$i]->{my_column};
Общее число строк, возвращённых запросом SELECT, можно получить так:
$nrows = $rv->{processed}
Так можно выполнить команду другого типа:
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
Затем можно получить статус команды (например, SPI_OK_INSERT) следующим образом:
$res = $rv->{status};
Чтобы получить число затронутых строк, выполните:
$nrows = $rv->{processed};
Полный пример:
CREATE TABLE test (
i int,
v varchar
);
1199PL/Perl — процедурный язык Perl
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
test
test
test
test
(i,
(i,
(i,
(i,
v)
v)
v)
v)
VALUES
VALUES
VALUES
VALUES
(1,
(2,
(3,
(4,
'first line');
'second line');
'third line');
'immortal');
CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS</script>
my $rv = spi_exec_query(‘select i, v from test;’);
my $status = $rv-&gt;{status};
my $nrows = $rv-&gt;{processed};
foreach my $rn (0 .. $nrows - 1) {
my $row = $rv-&gt;{rows}[$rn];
$row-&gt;{i} += 200 if defined($row-&gt;{i});
$row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
return_next($row);
}
return undef;
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM test_munge();
spi_query(команда)
spi_fetchrow(cursor)
spi_cursor_close(cursor)
Функции spi_query и spi_fetchrow применяются в паре, когда набор строк может быть очень
большим или когда нужно возвращать строки по мере их поступления. Функция spi_fetchrow
работает только с spi_query. Следующий пример показывает, как использовать их вместе:
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);
CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS</script>
use Digest::MD5 qw(md5_hex);
my $file = ‘/usr/share/dict/words’;
my $t = localtime;
elog(NOTICE, “opening file $file at $t” );
open my $fh, ‘&lt;’, $file # здесь мы обращаемся к файлу!
or elog(ERROR, “cannot open $file for reading: $!”);
my @words = &lt;$fh&gt;;
close $fh;
$t = localtime;
elog(NOTICE, “closed file $file at $t”);
chomp(@words);
my $row;
my $sth = spi_query(“SELECT * FROM generate_series(1,$</em>[0]) AS b(a)”);
while (defined ($row = spi_fetchrow($sth))) {
return_next({
the_num =&gt; $row-&gt;{a},
the_text =&gt; md5<em>hex($words[rand @words])
});
}
return;
<script type="math/tex">LANGUAGE plperlu;
SELECT * from lotsa_md5(500);
Обычно вызов spi_fetchrow нужно повторять, пока не будет получен результат undef, показы-
вающий, что все строки уже прочитаны. Курсор, возвращаемый функцией spi_query, автома-
тически освобождается, когда spi_fetchrow возвращает undef. Если вы не хотите читать все
строки, освободите курсор, выполнив spi_cursor_close, чтобы не допустить утечки памяти.
1200PL/Perl — процедурный язык Perl
spi_prepare(команда, типы аргументов)
spi_query_prepared(план, аргументы)
spi_exec_prepared(план [, атрибуты], аргументы)
spi_freeplan(план)
Функции spi_prepare, spi_query_prepared, spi_exec_prepared и spi_freeplan реализуют ту
же функциональность, но для подготовленных запросов. Функция spi_prepare принимает стро-
ку запроса с нумерованными местозаполнителями аргументов ($1, $2 и т. д.) и список строк
с типами аргументов:
$plan = spi_prepare('SELECT * FROM test WHERE id > $1 AND name = $2',
'INTEGER', 'TEXT');
План запроса, подготовленный вызовом spi_prepare, можно использовать вместо строки за-
проса либо в spi_exec_prepared, возвращающей тот же результат, что и spi_exec_query, ли-
бо в spi_query_prepared, возвращающей курсор так же, как spi_query, который затем можно
передать в spi_fetchrow. В необязательном втором параметре spi_exec_prepared можно пере-
дать хеш с атрибутами; в настоящее время поддерживается только атрибут limit, задающий
максимальное число строк, которое может вернуть запрос.
Подготовленные запросы хороши тем, что позволяют использовать единожды подготовленный
план для неоднократного выполнения запроса. Когда план оказывается не нужен, его можно
освободить, вызвав spi_freeplan:
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS</script>
$_SHARED{my_plan} = spi_prepare(‘SELECT (now() + $1)::date AS now’,
‘INTERVAL’);
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS</script>
return spi_exec_prepared(
$_SHARED{my_plan},
$</em>[0]
)-&gt;{rows}-&gt;[0]-&gt;{now};
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION done() RETURNS VOID AS</script>
spi_freeplan( $<em>SHARED{my_plan});
undef $_SHARED{my_plan};
<script type="math/tex">LANGUAGE plperl;
SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();
add_time | add_time | add_time
------------+------------+------------
2005-12-10 | 2005-12-11 | 2005-12-12
Заметьте, что параметры для spi_prepare обозначаются как $1, $2, $3 и т. д., так что по воз-
можности не записывайте строки запросов в двойных кавычках, чтобы не спровоцировать труд-
ноуловимые ошибки.
Ещё
один
пример,
spi_exec_prepared:
иллюстрирующий
использование
необязательного
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
FROM generate_series(1,3) AS id;
CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS</script>
$_SHARED{plan} = spi_prepare(‘SELECT * FROM hosts
1201
параметраPL/Perl — процедурный язык Perl
WHERE address « $1’, ‘inet’);
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS</script>
return spi_exec_prepared(
$_SHARED{plan},
{limit =&gt; 2},
$</em>[0]
)-&gt;{rows};
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS</script>
spi_freeplan($<em>SHARED{plan});
undef $_SHARED{plan};
<script type="math/tex">LANGUAGE plperl;
SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();
query_hosts
-----------------
(1,192.168.1.1)
(2,192.168.1.2)
(2 rows)
spi_commit()
spi_rollback()
Эти функции фиксируют или откатывают текущую транзакцию. Они могут вызываться только в
процедурах или в анонимных блоках кода (в команде DO), вызываемых из кода верхнего уровня.
(Заметьте, что выполнить SQL-команды COMMIT или ROLLBACK через spi_exec_query или подоб-
ную функцию нельзя. Соответствующие операции могут выполняться только данными функци-
ями.) После завершения одной транзакции следующая начинается автоматически, отдельной
функции для этого нет.
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS</script>
foreach my $i (0..9) {
spi_exec_query(“INSERT INTO test1 (a) VALUES ($i)”);
if ($i % 2 == 0) {
spi_commit();
} else {
spi_rollback();
}
}
<script type="math/tex">;
CALL transaction_test1();
45.3.2. Вспомогательные функции в PL/Perl
elog(уровень, сообщение)
Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни сообщений: DEBUG
(ОТЛАДКА), LOG (СООБЩЕНИЕ), INFO (ИНФОРМАЦИЯ), NOTICE (ЗАМЕЧАНИЕ), WARNING (ПРЕ-
ДУПРЕЖДЕНИЕ) и ERROR (ОШИБКА). С уровнем ERROR выдаётся ошибка; если она не перехва-
1202PL/Perl — процедурный язык Perl
тывается окружающим кодом Perl, она распространяется в вызывающий запрос, что приводит к
прерыванию текущей транзакции или подтранзакции. По сути то же самое делает команда die
языка Perl. При использовании других уровней происходит просто вывод сообщения с задан-
ным уровнем важности. Будут ли сообщения определённого уровня передаваться клиенту и/или
записываться в журнал, определяется конфигурационными параметрами log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
quote_literal(строка)
Оформляет переданную строку для использования в качестве текстовой строки в SQL-опера-
торе. Включённые в неё апострофы и обратная косая черта при этом дублируются. Заметьте,
что quote_literal возвращает undef, когда получает аргумент undef; если такие аргументы
возможны, часто лучше использовать quote_nullable.
quote_nullable(строка)
Оформляет переданную строку для использования в качестве текстовой строки в SQL-операто-
ре; либо, если поступает аргумент undef, возвращает строку "NULL" (без кавычек). Символы
апостроф и обратная косая черта дублируются должным образом.
quote_ident(строка)
Оформляет переданную строку для использования в качестве идентификатора в SQL-операто-
ре. При необходимости идентификатор заключается в кавычки (например, если он содержит
символы, недопустимые в открытом виде, или буквы в разном регистре). Если переданная стро-
ка содержит кавычки, они дублируются.
decode_bytea(строка)
Возвращает неформатированные двоичные данные, представленные содержимым заданной
строки, которая должна быть закодирована как bytea.
encode_bytea(строка)
Возвращает закодированные в виде bytea двоичные данные, содержащиеся в переданной стро-
ке.
encode_array_literal(массив)
encode_array_literal(массив, разделитель)
Возвращает содержимое указанного массива в виде строки в формате массива (см. Подраз-
дел 8.15.2). Возвращает значение аргумента неизменённым, если это не ссылка не массив. Раз-
делитель элементов в строке массива по умолчанию — ", " (если разделитель не определён
или undef).
encode_typed_literal(значение, имя_типа)
Преобразует переменную Perl в значение типа данных, указанного во втором аргументе, и воз-
вращает строковое представление этого значения. Корректно обрабатывает вложенные масси-
вы и значения составных типов.
encode_array_constructor(массив)
Возвращает содержимое переданного массива в виде строки в формате конструктора массива
(см. Подраздел 4.2.12). Отдельные значения заключаются в кавычки функцией quote_nullable.
Возвращает значение аргумента, заключённое в кавычки функцией quote_nullable, если ар-
гумент — не ссылка на массив.
looks_like_number(строка)
Возвращает значение true, если содержимое переданной строки похоже на число, по правилам
Perl, и false в обратном случае. Возвращает undef для аргумента undef. Ведущие и замыкающие
1203PL/Perl — процедурный язык Perl
пробелы игнорируются. Строки Inf и Infinity считаются представляющими число (бесконеч-
ность).
is_array_ref(аргумент)
Возвращает значение true, если переданный аргумент можно воспринять как ссылку на массив,
то есть это ссылка на ARRAY или PostgreSQL::InServer::ARRAY. В противном случае возвращает
false.
45.4. Глобальные значения в PL/Perl
Вы можете использовать для хранения данных, включая ссылки на код, глобальный хеш %_SHARED.
Эти данные будут сохраняться между вызовами функции на протяжении всего текущего сеанса.
Простой пример работы с разделяемыми данными:
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS</script>
if ($_SHARED{$</em>[0]} = $<em>[1]) {
return ‘ok’;
} else {
return “cannot set shared variable $</em>[0] to $<em>[1]”;
}
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS</script>
return $_SHARED{$</em>[0]};
<script type="math/tex">LANGUAGE plperl;
SELECT set_var('sample', 'Hello, PL/Perl!
SELECT get_var('sample');
How''s tricks?');
Это чуть более сложный пример, в котором используется ссылка на код:
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS</script>
$_SHARED{myquote} = sub {
my $arg = shift;
$arg =~ s/([’\])/\$1/g;
return “‘$arg’”;
};
<script type="math/tex">LANGUAGE plperl;
SELECT myfuncs(); /* инициализация функции */
/* Определение функции, использующей функцию заключения в кавычки */
CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS</script>
my $text_to_quote = shift;
my $qfunc = $_SHARED{myquote};
return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
(Код выше можно было бы упростить до однострочной команды return</p>
<blockquote>
  <p>($_[0]); в ущерб читаемости.)
$_SHARED{myquote}-
По соображениям безопасности, PL/Perl выполняет функции, вызываемые некоторой ролью SQL,
в отдельном интерпретаторе Perl, выделенном для этой роли. Это предотвращает случайное или
злонамеренное влияние одного пользователя на поведение функций PL/Perl другого пользователя.
В каждом интерпретаторе будет своё значение переменной %_SHARED и собственное глобальное
состояние. Таким образом, две функции PL/Perl будут разделять одно значение %_SHARED, только
если они выполняются одной ролью SQL. В приложении, выполняющем код в одном сеансе с раз-
1204PL/Perl — процедурный язык Perl
ными ролями SQL (вызывающем функции SECURITY DEFINER, использующем команду SET ROLE и т.
д.) может понадобиться явно предпринять дополнительные меры, чтобы функции на PL/Perl могли
разделять данные через %_SHARED. Для этого сначала установите для функций, которые должны
взаимодействовать, одного владельца, а затем задайте для них свойство SECURITY DEFINER. Разу-
меется, при этом нужно позаботиться о том, чтобы эти функции не могли сделать ничего непреду-
смотренного.
45.5. Доверенный и недоверенный PL/Perl
Обычно PL/Perl устанавливается в базу данных как «доверенный» язык программирования с име-
нем plperl. При этом в целях безопасности определённые операции в Perl запрещаются. Вообще
говоря, запрещаются все операции, взаимодействующие с окружением. В том числе, это опера-
ции с файлами, require и use (для внешних модулей). Поэтому функции на PL/Perl, в отличие от
функций на C, никаким образом не могут взаимодействовать с внутренними механизмами сервера
баз данных или обращаться к операционной системе с правами серверного процесса. Вследствие
этого, использовать этот язык можно разрешить любому непривилегированному пользователю баз
данных.
В следующем примере показана функция, которая не будет работать, потому что операции с фай-
ловой системы запрещены по соображениям безопасности:
CREATE FUNCTION badfunc() RETURNS integer AS <script type="math/tex">my $tmpfile = "/tmp/badfile";
open my $fh, '>', $tmpfile
or elog(ERROR, qq{could not open the file "$tmpfile": $!});
print $fh "Testing writing to a file\n";
close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
return 1;</script> LANGUAGE plperl;
Создать эту функцию не удастся, так как при проверке её правильности будет обнаружено исполь-
зование запрещённого оператора.
Иногда возникает желание написать на Perl код, функциональность которого не будет ограничи-
ваться. Например, может потребоваться функция на Perl, которая будет посылать почту. Для таких
потребностей PL/Perl также можно установить как «недоверенный» язык (обычно его называют
PL/PerlU). В этом случае будут доступны все возможности языка Perl. Устанавливая язык, укажите
имя plperlu, чтобы выбрать недоверенную вариацию PL/Perl.
Автор функции на PL/PerlU должен позаботиться о том, чтобы эту функцию нельзя было использо-
вать не по назначению, так как она может делать всё, что может пользователь с правами админи-
стратора баз данных. Заметьте, что СУБД позволяет создавать функции на недоверенных языках
только суперпользователям базы данных.
Если показанная выше функция будет создана суперпользователем, и при этом будет выбран язык
plperlu, она выполнится успешно.
Таким же образом, в анонимном блоке кода на Perl разрешены абсолютно любые операции, если
в качестве языка вместо plperl выбирается plperlu, но выполнять этот код должен суперпользо-
ватель.
Примечание
Тогда как функции на PL/Perl исполняются отдельными интерпретаторами Perl для
каждой роли SQL, все функции на PL/PerlU, вызываемые в рамках сеанса, исполняются
в одном интерпретаторе Perl (отличном от тех, что исполняют функции PL/Perl). Бла-
годаря этому, функции PL/PerlU могут свободно разделять общие данные, но между
функциями PL/Perl и PL/PerlU взаимодействие невозможно.
1205PL/Perl — процедурный язык Perl
Примечание
Perl поддерживает работу нескольких интерпретаторов в одном процессе, только если
он был собран с нужными флагами, а именно, с флагом usemultiplicity или с флагом
useithreads. (В отсутствие веских причин использовать потоки предпочтительным яв-
ляется вариант usemultiplicity. Дополнительную информацию вы можете получить
на странице man perlembed.) При использовании PL/Perl с версией Perl, собранной без
этих флагов, в рамках сеанса можно будет запустить только один интерпретатор Perl,
так что в сеансе будет возможно выполнять либо функции PL/PerlU, либо функции PL/
Perl (и вызывать их должна одна роль SQL).
45.6. Триггеры на PL/Perl
PL/Perl можно использовать для написания триггерных функций. В триггерной функции хеш-мас-
сив $_TD содержит информацию о произошедшем событии триггера. $_TD — глобальная перемен-
ная, которая получает нужное локальное значение при каждом вызове триггера. Хеш-массив $_TD
содержит следующие поля:
$_TD-&gt;{new}{foo}
Новое значение столбца foo
$_TD-&gt;{old}{foo}
Старое значение столбца foo
$_TD-&gt;{name}
Имя вызываемого триггера
$_TD-&gt;{event}
Событие триггера: INSERT, UPDATE, DELETE, TRUNCATE или UNKNOWN
$_TD-&gt;{when}
Когда вызывается триггер: BEFORE (ДО), AFTER (ПОСЛЕ), INSTEAD OF (ВМЕСТО) или UNKNOWN
(НЕИЗВЕСТНО)
$_TD-&gt;{level}
Уровень триггера: ROW (СТРОКА), STATEMENT (ОПЕРАТОР) или UNKNOWN (НЕИЗВЕСТНЫЙ)
$_TD-&gt;{relid}
OID таблицы, для которой сработал триггер
$_TD-&gt;{table_name}
Имя таблицы, для которой сработал триггер
$_TD-&gt;{relname}
Имя таблицы, для которой сработал триггер. Это обращение устарело и может быть ликвиди-
ровано в будущем выпуске. Используйте вместо него $_TD-&gt;{table_name}.
$_TD-&gt;{table_schema}
Имя схемы, содержащей таблицу, для которой сработал триггер
$_TD-&gt;{argc}
Число аргументов в триггерной функции
1206PL/Perl — процедурный язык Perl
@{$_TD-&gt;{args}}
Аргументы триггерной функции. Не определено, если $_TD-&gt;{argc} равно 0.
В триггерах уровня строки возможны следующие варианты возврата:
return;
Выполнить операцию
“SKIP”
Не выполнять операцию
“MODIFY”
Указывает, что строка NEW была изменена триггерной функцией
Следующий пример триггерной функции иллюстрирует описанные выше варианты:
CREATE TABLE test (
i int,
v varchar
);
CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
return “SKIP”;</p>
  <h1 id="пропустить-команду-insertupdate">пропустить команду INSERT/UPDATE</h1>
  <p>} elsif ($_TD-&gt;{new}{v} ne “immortal”) {
$_TD-&gt;{new}{v} .= “(modified by trigger)”;
return “MODIFY”; # изменить строку и выполнить команду INSERT/UPDATE
} else {
return;</p>
  <h1 id="выполнить-команду-insertupdate">выполнить команду INSERT/UPDATE</h1>
  <p>}
<script type="math/tex">LANGUAGE plperl;
CREATE TRIGGER test_valid_id_trig
BEFORE INSERT OR UPDATE ON test
FOR EACH ROW EXECUTE FUNCTION valid_id();
45.7. Событийные триггеры на PL/Perl
PL/Perl можно использовать для написания функций событийных триггеров. В функции событий-
ного триггера хеш-массив $_TD содержит информацию о произошедшем событии триггера. $_TD —
глобальная переменная, которая получает нужное локальное значение при каждом вызове триг-
гера. Хеш-массив $_TD содержит следующие поля:
$_TD->{event}
Имя события, при котором срабатывает этот триггер.
$_TD->{tag}
Тег команды, для которой срабатывает этот триггер.
Возвращаемое значение триггерной функции игнорируется.
Следующий пример функции событийного триггера иллюстрирует описанное выше:
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS</script>
elog(NOTICE, “perlsnitch: “ . $_TD-&gt;{event} . “ “ . $_TD-&gt;{tag} . “ “);
$$ LANGUAGE plperl;
CREATE EVENT TRIGGER perl_a_snitch
1207PL/Perl — процедурный язык Perl
ON ddl_command_start
EXECUTE FUNCTION perlsnitch();
45.8. Внутренние особенности PL/Perl
45.8.1. Конфигурирование
В этом разделе описываются параметры конфигурации, влияющие на работу PL/Perl.
plperl.on_init (string)
Задаёт код Perl, который будет выполняться при первой инициализации интерпретатора Perl, до
того, как он получает специализацию plperl или plperlu. Когда этот код выполняется, функ-
ции SPI ещё не доступны. Если выполнение кода завершается ошибкой, инициализация интер-
претатора прерывается и ошибка распространяется в вызывающий запрос, в результате чего
текущая транзакция или подтранзакция прерывается.
Размер этого кода ограничивается одной строкой. Более объёмный код можно поместить в мо-
дуль и загрузить этот модуль в строке on_init. Например:
plperl.on_init = ‘require “plperlinit.pl”’
plperl.on_init = ‘use lib “/my/app”; use MyApp::PgInit;’
Любые модули, загруженные в plperl.on_init, явно или неявно, будут доступны для исполь-
зования в коде на языке plperl. Это может создать угрозу безопасности. Чтобы определить,
какие модули были загружены, можно выполнить:
DO ‘elog(WARNING, join “, “, sort keys %INC)’ LANGUAGE plperl;
Если библиотека plperl включена в shared_preload_libraries, инициализация произойдёт в глав-
ном процессе (postmaster) и в этом случае необходимо очень серьёзно оценить риск наруше-
ния работоспособности этого процесса. Основной смысл использовать эту возможность в том,
чтобы модули Perl, подключаемые в plperl.on_init, загружались только при запуске главно-
го процесса, и это исключало бы издержки загрузки для отдельных сеансов. Однако, имейте
в виду, что эти издержки исключаются только при загрузке в сеансе первого интерпретатора
Perl — будь то PL/PerlU или PL/Perl для первой SQL-роли, вызывающей функцию на PL/Perl. Лю-
бые дополнительные интерпретаторы Perl, создаваемые в сеансе базы данных, должны будут
выполнять plperl.on_init заново. Также учтите, что в Windows предварительная загрузка не
даёт никакого выигрыша, так как интерпретатор Perl, созданный в главном процессе, не пере-
даётся дочерним процессам.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
plperl.on_plperl_init (string)
plperl.on_plperlu_init (string)
В этих параметрах задаётся код Perl, который будет выполняться в момент, когда интерпрета-
тор Perl получает специализацию plperl или plperlu, соответственно. Это произойдёт, когда в
рамках сеанса будет первый раз вызвана функция на PL/Perl или PL/PerlU, либо когда потребу-
ется дополнительный интерпретатор при использовании другого языка или при вызове функ-
ции PL/Perl новой SQL-ролью. Этот код выполняется после инициализации, произведённой в
plperl.on_init. Однако функции SPI в момент исполнения этого кода ещё не доступны. Код в
plperl.on_plperl_init запускается после того, как интерпретатор «помещается под замок»,
так что в нём разрешаются только доверенные операции.
Если этот код завершается ошибкой, инициализация прерывается и ошибка распространяется
в вызывающий запрос, что приводит к прерыванию текущей транзакции или подтранзакции.
При этом любые действия, уже произведённые в Perl, не будут отменены; однако использовать-
ся этот интерпретатор больше не будет. При следующей попытке использовать этот язык си-
стема попытается заново инициализировать свежий интерпретатор Perl.
1208PL/Perl — процедурный язык Perl
Изменять эти параметры разрешено только суперпользователям. Хотя изменить их можно в
рамках сеанса, такие изменения не повлияют на работу интерпретаторов Perl, задействованных
для выполнения функций ранее.
plperl.use_strict (boolean)
При значении, равном true, последующая компиляция функций PL/Perl будет выполняться с
включённым указанием strict. Этот параметр не влияет на функции, уже скомпилированные
в текущем сеансе.
45.8.2. Ограничения и недостающие возможности
Следующие возможности в настоящее время в PL/Perl отсутствуют, но их реализация будет желан-
ной доработкой.
• Функции на PL/Perl не могут напрямую вызывать друг друга.
• SPI ещё не полностью реализован.
• Если вы выбираете очень большие наборы данных, используя spi_exec_query, вы должны по-
нимать, что все эти данные загружаются в память. Вы можете избежать этого, используя пару
функций spi_query/spi_fetchrow, как показано ранее.
Похожая проблема возникает, если функция, возвращающая множество, передаёт в
PostgreSQL большое число строк, выполняя return. Этой проблемы так же можно избежать,
выполняя для каждой возвращаемой строки return_next, как показано ранее.
• Когда сеанс завершается штатно, не по причине критической ошибки, в Perl выполняются все
блоки END, которые были определены. Никакие другие действия в настоящее время не выпол-
няются. В частности, буферы файлов автоматически не сбрасываются и объекты автоматиче-
ски не уничтожаются.
1209</p>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-044/" title="Глава 44. PL/Tcl — процедурный язык Tcl"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 44. PL/Tcl — процедурный язык Tcl"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-044/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-044/" rel="bookmark" title="Глава 44. PL/Tcl — процедурный язык Tcl" itemprop="url">Глава 44. PL/Tcl — процедурный язык Tcl</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 44. PL/Tcl — процедурный язык Tcl</p>

<p>PL/Tcl — это загружаемый процедурный язык для СУБД PostgreSQL, позволяющий использовать
язык Tcl для написания функций PostgreSQL.
44.1. Обзор
PL/Tcl предоставляет большинство возможностей, которые имеет разработчик функций на C, с
небольшими ограничениями, и позволяет применять мощные библиотеки обработки строк, суще-
ствующие для Tcl.
Одним убедительным хорошим ограничением является то, что весь код выполняется в контексте
безопасности интерпретатора Tcl. Помимо ограниченного набора команд безопасного Tcl, разре-
шены только несколько команд для обращения к базе данных через SPI и вызовы elog() для вы-
дачи сообщений. PL/Tcl не даёт возможности взаимодействовать с внутренним механизмом серве-
ра баз данных или обращаться к ОС с правами серверного процесса PostgreSQL, что возможно в
функциях на C. Таким образом, использование этого языка можно доверить непривилегированным
пользователям; это не даст им неограниченные полномочия.
Ещё одно существенное ограничение заключается в том, что функции на Tcl нельзя использовать
для создания функций ввода/вывода для новых типов данных.
Иногда возникает желание написать функцию на Tcl, которая не будут ограничена безопасным
Tcl. Например, может потребоваться функция, которая будет посылать сообщения по почте. Для
этих случаев есть вариация PL/Tcl, названная PL/TclU (название подразумевает «untrusted Tcl»,
недоверенный Tcl). Это тот же язык, за исключением того, что для него используется полноцен-
ный интерпретатор Tcl. Если применяется PL/TclU, он должен быть установлен как недоверен-
ный процедурный язык, чтобы только суперпользователи могли создавать функции на нём. Автор
функции на PL/TclU должен позаботиться о том, чтобы эту функцию нельзя было использовать не
по назначению, так как она может делать всё, что может пользователь с правами администратора
баз данных.
Разделяемый объектный код для обработчиков вызова PL/Tcl и PL/TclU собирается автоматически
и устанавливается в каталог библиотек PostgreSQL, если поддержка Tcl включена на этапе кон-
фигурирования процедуры установки. Чтобы установить PL/Tcl и/или PL/TclU в конкретную базу
данных, воспользуйтесь командой CREATE EXTENSION, например, так: CREATE EXTENSION pltcl или
CREATE EXTENSION pltclu.
44.2. Функции на PL/Tcl и их аргументы
Чтобы создать функцию на языке PL/Tcl, используйте стандартный синтаксис CREATE FUNCTION:
CREATE FUNCTION имя_функции (типы_аргументов) RETURNS тип_результата AS $$</p>
<h1 id="Тело-функции-на-pltcl">Тело функции на PL/Tcl</h1>
<p><script type="math/tex">LANGUAGE pltcl;
С PL/TclU команда та же, но в качестве языка должно быть указано pltclu.
Тело функции содержит просто скрипт на Tcl. Когда вызывается функция, значения аргументов
передаются скрипту Tcl в виде переменных с именами 1 ... n. Результат из кода Tcl возвращается
как обычно, оператором return. В процедуре значение, возвращаемое из кода Tcl, игнорируется.
Например, функцию, возвращающую большее из двух целых чисел, можно определить так:
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS</script>
if {$1 &gt; $2} {return $1}
return $2
<script type="math/tex">LANGUAGE pltcl STRICT;
Обратите внимание на предложение STRICT, которое избавляет нас от необходимости думать о
входящих значениях NULL: если при вызове передаётся значение NULL, функция не будет выпол-
няться вовсе, будет сразу возвращён результат NULL.
1184PL/Tcl — процедурный язык Tcl
В нестрогой функции, если фактическое значение аргумента — NULL, соответствующей перемен-
ной $n будет присвоена пустая строка. Чтобы определить, был ли передан NULL в определённом
аргументе, используйте функцию argisnull. Например, предположим, что нам нужна функция
tcl_max, которая с одним аргументом NULL и вторым аргументом не NULL должна возвращать не
NULL, а второй аргумент:
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS</script>
if {[argisnull 1]} {
if {[argisnull 2]} { return_null }
return $2
}
if {[argisnull 2]} { return $1 }
if {$1 &gt; $2} {return $1}
return $2
<script type="math/tex">LANGUAGE pltcl;
Как показано выше, чтобы вернуть значение NULL из функции PL/Tcl, нужно выполнить
return_null. Это можно сделать и в строгой, и в нестрогой функции.
Аргументы составного типа передаются функции в виде массивов Tcl. Именами элементов массива
являются имена атрибутов составного типа. Если атрибут в переданной строке имеет значение
NULL, он будет отсутствовать в данном массиве. Например:
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid(employee) RETURNS boolean AS</script>
if {200000.0 &lt; $1(salary)} {
return “t”
}
if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
return “t”
}
return “f”
<script type="math/tex">LANGUAGE pltcl;
Функции PL/Tcl могут возвращать и результаты составного типа. Для этого код на Tcl должен вер-
нуть список пар имя/значение столбца, соответствующий ожидаемому типу результата. Столбцы,
имена которых в этом списке отсутствуют, получат значения NULL, а если в списке указано имя
несуществующего столбца, возникнет ошибка. Например:
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS</script>
return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
<script type="math/tex">LANGUAGE pltcl;
Выходные аргументы процедур возвращаются таким же образом. Например:
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS</script>
return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
<script type="math/tex">LANGUAGE pltcl;
CALL tcl_triple(5, 10);
Подсказка
Список результатов можно создать из желаемого кортежа, представленного в виде
массива, с помощью команды array get языка Tcl. Например:
1185PL/Tcl — процедурный язык Tcl
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS</script>
set 1(salary) [expr {$1(salary) + $2}]
return [array get 1]
<script type="math/tex">LANGUAGE pltcl;
Функции PL/Tcl могут возвращать наборы результатов. Для этого код на Tcl должен вызывать
return_next для каждой возвращаемой строки, передавая ей соответствующее значение, когда
возвращается скалярный тип, или список пар имя/значение столбца, когда возвращается состав-
ной тип. Пример с результатом скалярного типа:
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS</script>
for {set i $1} {$i &lt; $2} {incr i} {
return_next $i
}
<script type="math/tex">LANGUAGE pltcl;
и с результатом составного:
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS</script>
for {set i $1} {$i &lt; $2} {incr i} {
return_next [list x $i x2 [expr {$i * $i}]]
}
<script type="math/tex">LANGUAGE pltcl;
44.3. Значения данных в PL/Tcl
Значения аргументов, передаваемые в код функции PL/Tcl, представляют собой просто входные
аргументы, преобразованные в текстовый вид (так же, как при выводе оператором SELECT). И на-
оборот, команды return и return_next примут любую строку, соответствующую формату ввода для
объявленного типа результата функции или заданного столбца в результате составного типа.
44.4. Глобальные данные в PL/Tcl
Иногда полезно иметь некоторые глобальные данные, сохраняемые между двумя вызовами функ-
ции или совместно используемые разными функциями. Это легко сделать в PL/Tcl, но есть некото-
рые ограничения, которые необходимо понимать.
По соображениям безопасности, PL/Tcl выполняет функции, вызываемые некоторой ролью SQL в
отдельном интерпретаторе Tcl, выделенном для этой роли. Это предотвращает случайное или зло-
намеренное влияние одного пользователя на поведение функций PL/Tcl другого пользователя. В
каждом интерпретаторе будут свои значения всех «глобальных» переменных Tcl. Таким образом,
в двух функциях PL/Tcl будут общие глобальные переменные, только если они выполняются одной
ролью SQL. В приложении, выполняющем код в одном сеансе с разными ролями SQL (вызывающем
функции SECURITY DEFINER, использующем команду SET ROLE и т. д.) может понадобиться явно
предпринять дополнительные меры, чтобы функции могли разделять свои данные. Для этого сна-
чала установите для функций, которые должны взаимодействовать, одного владельца, а затем за-
дайте для них свойство SECURITY DEFINER. Разумеется, при этом нужно позаботиться о том, чтобы
эти функции не могли сделать ничего непредусмотренного.
Все функции PL/TclU, вызываемые в одном сеансе, выполняются одним интерпретатором Tcl, ко-
торый, конечно, отличается от интерпретатора(ов), используемого для функций PL/Tcl. Поэтому
глобальные данные функций PL/TclU автоматически становятся общими. Это не считается угро-
зой безопасности, так как все функции PL/TclU выполняются на одном уровне доверия, а именно
уровне суперпользователя базы данных.
Чтобы защитить функции PL/Tcl от непреднамеренного влияния друг на друга, каждой из них
предоставляется глобальная переменная-массив через команду upvar. Глобальным именем этой
переменной является внутреннее имя функции, а в качестве локального выбрано GD. Переменную
GD рекомендуется использовать для постоянных внутренних данных функции. Обычные глобаль-
1186PL/Tcl — процедурный язык Tcl
ные переменные Tcl следует использовать только для значений, которые предназначены имен-
но для совместного использования несколькими функциями. (Заметьте, что массивы GD являются
глобальными только для конкретного интерпретатора, так что они не нарушают ограничения без-
опасности, описанные выше.)
Использование GD демонстрируется в примере spi_execp, приведённом ниже.
44.5. Обращение к базе данных из PL/Tcl
Для обращения к базе данных из тела функции на PL/Tcl предназначены следующие команды:
spi_exec ?-count n? ?-array имя? команда ?тело-цикла?
Выполняет команду SQL, заданную в виде строки. В случае ошибки в этой команде выдаётся
ошибка в Tcl. В противном случае spi_exec возвращает число обработанных командой строк
(выбранных, добавленных, изменённых или удалённых), либо ноль, если эта команда — служеб-
ный оператор. Кроме того, если команда — оператор SELECT, значения выбранных столбцов
помещаются в переменные Tcl, как описано ниже.
Необязательное значение -count задаёт для spi_exec максимальное число строк, которое
должно быть обработано в команде. Его действие можно представить как выполнение FETCH n
для курсора, предварительно подготовленного для команды.
Если в качестве команды выполняется оператор SELECT, значения результирующих столбцов
помещаются в переменные Tcl, названные по именам столбцов. Если передаётся -array, зна-
чения столбцов вместо этого становятся элементами названного ассоциативного массива, ин-
дексами в котором становятся имена столбцов. Кроме того, в элементе с именем «.tupno» со-
храняется номер текущей строки в результирующем наборе (отсчитывая от нуля), если только
это имя не занято одним из столбцов результата.
Если в качестве команды выполняется SELECT без указания скрипта тело-цикла, в переменных
Tcl или элементах массива сохраняется только первая строка результатов; оставшиеся строки
(если они есть), игнорируются. Если запрос не возвращает строки, не сохраняется ничего. (Этот
случай можно отследить, проверив результат spi_exec.) Например, команда:
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
присвоит переменной $cnt в Tcl число строк, содержащихся в системном каталоге pg_proc.
Если передаётся необязательный аргумент тело-цикла, заданный в нём блок скрипта Tcl будет
выполняться для каждой строки результата запроса. (Аргумент тело-цикла игнорируется, если
целевая команда — не SELECT.) При этом значения столбцов текущей строки сохраняются в
переменных Tcl или элементах массива перед каждой итерацией этого цикла. Например, код:
spi_exec -array C "SELECT * FROM pg_class" {
elog DEBUG "have table $C(relname)"
}
будет выводить в журнал сообщение для каждой строки pg_class. Это работает подобно другим
конструкциям циклов в Tcl; в частности, команды continue и break в теле цикла будут действо-
вать обычным образом.
Если в столбце результата запроса выдаётся NULL, целевая переменная для неё не устанавли-
вается, и оказывается «неустановленной».
spi_prepare запрос список-типов
Подготавливает и сохраняет план запроса для последующего выполнения. Сохранённый план
будет продолжать существование до завершения текущего сеанса.
Запрос может принимать параметры, то есть местозаполнители для значений, которые будут
передаваться, когда план будет собственно выполняться. В строке запроса эти параметры обо-
значаются как $1 ... $n. Если в запросе используются параметры, нужно задать имена типов
1187PL/Tcl — процедурный язык Tcl
этих параметров в виде списка Tcl. (Если параметры отсутствуют, задайте пустой список_ти-
пов.)
Функция spi_prepare возвращает идентификатор запроса, который может использоваться в
последующих вызовах spi_execp. Пример приведён в описании spi_execp.
spi_execp ?-count n? ?-array имя? ?-nulls строка? ид-запроса ?список-значений? ?тело-цик-
ла?
Выполняет запрос, ранее подготовленный функцией spi_prepare. В качестве ид_запроса пере-
даётся идентификатор, возвращённый функцией spi_prepare. Если в запросе задействуются
параметры, необходимо указать список-значений. Это должен быть принятый в Tcl список па-
раметров. Он должен иметь ту же длину, что и список типов параметров, ранее переданный
spi_prepare. Опустите список-значений, если у запроса нет параметров.
Необязательный аргумент -nulls принимает строку из пробелов и символов 'n', которые от-
мечают, в каких параметрах spi_execp передаются значения NULL. Если присутствует, эта
строка должна иметь ту же длину, что и список-значений. В случае её отсутствия значения
всех параметров считаются отличными от NULL.
Не считая отличий в способе передачи запроса и параметров, spi_execp работает так же, как
spi_exec. Параметры -count, -array и тело-цикла задаются так же, и так же передаётся воз-
вращаемое значение.
Взгляните на пример функции на PL/Tcl, использующей подготовленный план:
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS</script>
if {![ info exists GD(plan) ]} {</p>
<h1 id="подготовить-сохранённый-план-при-первом-вызове">подготовить сохранённый план при первом вызове</h1>
<p>set GD(plan) [ spi_prepare \
“SELECT count(*) AS cnt FROM t1 WHERE num &gt;= $1 AND num &lt;= $2” \
[ list int4 int4 ] ]
}
spi_execp -count 1 $GD(plan) [ list $1 $2 ]
return $cnt
<script type="math/tex">LANGUAGE pltcl;
Обратные косые черты внутри строки запроса, передаваемой функции spi_prepare, нужны для
того, чтобы маркеры $n передавались функции spi_prepare как есть, а не заменялись при под-
становке переменных Tcl.
spi_lastoid
Возвращает OID строки, вставленной последней командой spi_exec или spi_execp, если этой
командой был оператор INSERT с одной строкой и изменяемая таблица содержит OID. (В про-
тивном случае вы получите ноль.)
subtransaction команда
Скрипт Tcl, который содержит команда, выполняется в подтранзакции SQL. Если этот скрипт
возвращает ошибку, вся подтранзакция откатывается назад, а затем в окружающий код Tcl воз-
вращается ошибка. За дополнительными подробностями и примером обратитесь к Разделу 44.9.
quote строка
Дублирует все вхождения апострофа и обратной косой черты в заданной строке. Это можно
использовать для защиты строк, которые будут вставляться в команды SQL, передаваемые в
spi_exec или spi_prepare. Например, представьте, что при выполнении такой команды SQL:
"SELECT '$val' AS ret"
переменная языка Tcl val содержит doesn't. Это приведёт к формированию такой окончатель-
ной строки команды:
1188PL/Tcl — процедурный язык Tcl
SELECT 'doesn't' AS ret
при разборе которой в процессе spi_exec или spi_prepare возникнет ошибка. Чтобы этот за-
прос работал правильно, итоговая команда должна выглядеть так:
SELECT 'doesn''t' AS ret
Получить её в PL/Tcl можно так:
"SELECT '[ quote $val ]' AS ret"
Преимуществом spi_execp является то, что для неё заключать значения параметров в кавыч-
ки подобным образом не нужно, так как параметры никогда не разбираются в составе строки
команды SQL.
elog уровень сообщение
Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни сообщений: DEBUG
(ОТЛАДКА), LOG (СООБЩЕНИЕ), INFO (ИНФОРМАЦИЯ), NOTICE (ЗАМЕЧАНИЕ), WARNING (ПРЕ-
ДУПРЕЖДЕНИЕ), ERROR (ОШИБКА) и FATAL (ВАЖНО). С уровнем ERROR выдаётся ошибка; ес-
ли она не перехватывается окружающим кодом Tcl, она распространяется в вызывающий за-
прос, что приводит к прерыванию текущей транзакции или подтранзакции. По сути то же са-
мое делает команда error языка Tcl. Сообщение уровня FATAL прерывает транзакцию и приво-
дит к завершению текущего сеанса. (Вероятно, нет обоснованной причины использовать этот
уровень ошибок в функциях PL/Tcl, но он поддерживается для полноты.) При использовании
других уровней происходит просто вывод сообщения с заданным уровнем важности. Будут ли
сообщения определённого уровня передаваться клиенту и/или записываться в журнал, опреде-
ляется конфигурационными переменными log_min_messages и client_min_messages. За допол-
нительными сведениями обратитесь к Главе 19 и Разделу 44.8.
44.6. Триггерные функции на PL/Tcl
На PL/Tcl можно написать триггерные функции. PostgreSQL требует, чтобы функция, которая бу-
дет вызываться как триггерная, была объявлена как функция без аргументов и возвращала тип
trigger.
Информация от менеджера триггеров передаётся в тело функции в следующих переменных:
$TG_name
Имя триггера из оператора CREATE TRIGGER.
$TG_relid
Идентификатор объекта таблицы, для которой будет вызываться триггерная функция.
$TG_table_name
Имя таблицы, для которой будет вызываться триггерная функция.
$TG_table_schema
Схема таблицы, для которой будет вызываться триггерная функция.
$TG_relatts
Список языка Tcl, содержащий имена столбцов таблицы. В начало списка добавлен пустой эле-
мент, поэтому при поиске в этом списке имени столбца с помощью стандартной в Tcl коман-
ды lsearch будет возвращён номер элемента, начиная с 1, так же, как нумеруются столбцы
в PostgreSQL. (В позициях удалённых столбцов также содержатся пустые элементы, так что
нумерация следующих за ними атрибутов не нарушается.)
$TG_when
Строка BEFORE, AFTER или INSTEAD OF, в зависимости от типа события триггера.
1189PL/Tcl — процедурный язык Tcl
$TG_level
Строка ROW или STATEMENT, в зависимости от уровня события триггера.
$TG_op
Строка INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от действия события триггера.
$NEW
Ассоциативный массив, содержащий значения новой строки таблицы для действий INSERT или
UPDATE, либо пустой массив для DELETE. Индексами в массиве являются имена столбцов. Столб-
цы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора этот массив не
определяется.
$OLD
Ассоциативный массив, содержащий значения старой строки таблицы для действий UPDATE или
DELETE, либо пустой массив для INSERT. Индексами в массиве являются имена столбцов. Столб-
цы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора этот массив не
определяется.
$args
Список на языке Tcl аргументов функции, заданных в операторе CREATE TRIGGER. Эти аргументы
также доступны под обозначениями $1 ... $n в теле функции.
Возвращаемым значением триггерной функции может быть строка OK или SKIP либо список пар
имя столбца/значение. Если возвращается значение OK, операция (INSERT/UPDATE/DELETE), которая
привела к срабатыванию триггера, выполняется нормально. Значение SKIP указывает менеджеру
триггеров просто пропустить эту операцию с текущей строкой данных. Если возвращается список,
через него PL/Tcl передаёт менеджеру триггеров изменённую строку; содержимое изменённой
строки задаётся именами и значениями столбцов в списке. Все столбцы, не перечисленные в этом
списке, получают значения NULL. Возвращать изменённую строку имеет смысл только для триг-
геров уровня строки с порядком BEFORE команд INSERT и UPDATE, в которых вместо заданной в $NEW
будет записываться изменённая строка; либо с порядком INSTEAD OF команд INSERT и UPDATE, в ко-
торых возвращаемая строка служит исходными данными для предложений INSERT RETURNING или
UPDATE RETURNING. В триггерах уровня строки с порядком BEFORE или INSTEAD OF команды DELETE
возврат изменённой строки воспринимается так же, как и возврат значения OK, то есть операция
выполняется. Для всех остальных типов триггеров возвращаемое значение игнорируется.
Подсказка
Список результатов можно создать из изменённого кортежа, представленного в виде
массива, с помощью команды array get языка Tcl.
Следующий небольшой пример показывает триггерную функцию, которая ведёт в таблице цело-
численный счётчик числа изменений, выполненных в строке. Для новых строк счётчик инициали-
зируется нулевым значением, а затем увеличивается на единицу при каждом изменении.
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS</script>
switch $TG_op {
INSERT {
set NEW($1) 0
}
UPDATE {
set NEW($1) $OLD($1)
incr NEW($1)
}
default {
1190PL/Tcl — процедурный язык Tcl
return OK
}
}
return [array get NEW]
<script type="math/tex">LANGUAGE pltcl;
CREATE TABLE mytab (num integer, description text, modcnt integer);
CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
Заметьте, что сама триггерная функция не знает имени столбца; оно передаётся в аргументах
триггера. Это позволяет применять эту функцию для различных таблиц.
44.7. Функции событийных триггеров в PL/Tcl
На PL/Tcl можно написать функции событийных триггеров. PostgreSQL требует, чтобы функция,
которая будет вызываться как событийный триггер, была объявлена как функция без аргументов
и возвращала тип event_trigger.
Информация от менеджера триггеров передаётся в тело функции в следующих переменных:
$TG_event
Имя события, при котором срабатывает этот триггер.
$TG_tag
Тег команды, для которой срабатывает этот триггер.
Возвращаемое значение триггерной функции игнорируется.
В этом примере мини-функция событийного триггера просто выдаёт замечание (NOTICE) при каж-
дом выполнении поддерживаемой команды:
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS</script>
elog NOTICE “tclsnitch: $TG_event $TG_tag”
$$ LANGUAGE pltcl;
CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
44.8. Обработка ошибок в PL/Tcl
Tcl-код, содержащийся или вызываемый из функции PL/Tcl, может выдавать ошибку либо выполняя
недопустимую операцию, либо генерируя ошибку с помощью команды error языка Tcl или коман-
ды elog языка PL/Tcl. Такие ошибки могут быть перехвачены в среде Tcl с помощью команды Tcl
catch. Если ошибка не перехватывается, а распространяется выше уровня выполнения функций
PL/Tcl, она передаётся в запрос, вызвавший функцию, как ошибка SQL.
И напротив, ошибки СУБД, возникающие внутри команд spi_exec, spi_prepare и spi_execp в сре-
де PL/Tcl, выдаются как ошибки Tcl, так что их можно перехватить командой Tcl catch. (Каждая
из этих команд PL/Tcl выполняет SQL-операцию в подтранзакции, которая откатывается в слу-
чае ошибки, так что для частично завершённых операций производится автоматическая очистка.)
Опять же, если ошибка не перехватывается и распространяется выше верхнего уровня, она стано-
вится ошибкой SQL.
В Tcl имеется переменная errorCode, представляющая дополнительную информацию об ошибке
в виде, удобном для обработки в программах на Tcl. Эта информация передаётся в формате спис-
ка Tcl, первое слово в котором указывает на подсистему или библиотеку, выдающую ошибку; по-
следующее содержимое определяется в зависимости от подсистемы или библиотеки. Для ошибок
СУБД, возникающих в командах PL/Tcl, первым словом будет POSTGRES, вторым — номер версии
PostgreSQL, а дополнительные слова представляют пары имя/значения, передающие подробную
1191PL/Tcl — процедурный язык Tcl
информацию об ошибке. В этих парах всегда передаются поля SQLSTATE, condition и message (пер-
вые два представляют код ошибки и имя условия, как описано в Приложении  A). Также могут
передаваться поля detail, hint, context, schema, table, column, datatype, constraint, statement,
cursor_position, filename, lineno и funcname.
С информацией в переменной errorCode среды PL/Tcl удобно работать, загрузив переменную в
массив, чтобы имена полей стали индексами в массиве. Пример такого кода:
if {[catch { spi_exec $sql_command }]} {
if {[lindex $::errorCode 0] == “POSTGRES”} {
array set errorArray $::errorCode
if {$errorArray(condition) == “undefined_table”} {</p>
<h1 id="разобраться-с-отсутствием-таблицы">разобраться с отсутствием таблицы</h1>
<p>} else {</p>
<h1 id="разобраться-с-другими-типами-ошибок-sql">разобраться с другими типами ошибок SQL</h1>
<p>}
}
}
(Двойные двоеточия явно указывают, что переменная errorCode является глобальной.)
44.9. Явные подтранзакции в PL/Tcl
Перехват ошибок, произошедших при обращении к базе данных, как описано в Разделе 44.8, может
привести к нежелательной ситуации, когда часть операций будет успешно выполнена, прежде чем
произойдёт сбой. Данные останутся в несогласованном состоянии после обработки такой ошибки.
PL/Tcl предлагает решение этой проблемы в форме явных подтранзакций.
Рассмотрите функцию, реализующую перевод денег между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS <script type="math/tex">if [catch {
spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'"
spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'"
} errormsg] {
set result [format "error transferring funds: %s" $errormsg]
} else {
set result "funds transferred successfully"
}
spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"</script> LANGUAGE pltcl;
Если второй оператор UPDATE выдаст исключение, эта функция запишет в журнал сообщение об
ошибке, но результат первого UPDATE будет тем не менее зафиксирован. Другими словами, денеж-
ные средства будут списаны со счёта Джо, но не поступят на счёт Мери. Это происходит потому,
что каждый вызов spi_exec выполняется в отдельной подтранзакции, а откатывается только одна
из подтранзакций.
В таких случаях вы можете обернуть несколько операций с базой данных в одну явную подтран-
закцию, которая будет выполнена успешно или отменена как единое целое. Для этого в PL/Tcl есть
команда subtransaction. С ней мы можем переписать нашу функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS <script type="math/tex">if [catch {
subtransaction {
spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'"
spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'"
1192PL/Tcl — процедурный язык Tcl
}
} errormsg] {
set result [format "error transferring funds: %s" $errormsg]
} else {
set result "funds transferred successfully"
}
spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"</script> LANGUAGE pltcl;
Заметьте, что и в этом случае нужно использовать catch. В противном случае ошибка распростра-
нится на верхний уровень функции, что не даст произвести желаемое добавление записи в табли-
цу operations. Команда subtransaction не перехватывает ошибки, она только обеспечивает откат
всех операций с базой данных в своей области действия в случае ошибки.
Откат явной подтранзакции происходит в случае любых ошибок, сгенерированных вложенным ко-
дом Tcl, а не только ошибок, возникающих при обращении к базе данных. Таким образом, обычное
исключение Tcl, возникшее внутри команды subtransaction, также приведёт к откату подтран-
закции. Однако при выходе из вложенного кода Tcl без ошибки (например, с помощью команды
return) откат не производится.
44.10. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в команде
DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, выполните ко-
манду commit, а чтобы откатить — rollback. (Заметьте, что выполнить SQL-команды COMMIT или
ROLLBACK через spi_exec или подобную функцию нельзя. Соответствующие операции могут выпол-
няться только данными функциями.) После завершения одной транзакции следующая начинается
автоматически, отдельной функции для этого нет.
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS <script type="math/tex">% <![CDATA[
for {set i 0} {$i < 10} {incr i} {
spi_exec "INSERT INTO test1 (a) VALUES ($i)"
if {$i % 2 == 0} {
commit
} else {
rollback
}
} %]]></script>;
CALL transaction_test1();
Транзакции не могут завершаться, когда имеется открытая явная подтранзакция.
44.11. Конфигурация PL/Tcl
В этом разделе описываются параметры конфигурации, влияющие на работу PL/Tcl.
pltcl.start_proc (string)
В этом параметре, если он не пуст, задаётся имя (возможно, дополненное схемой) функции на
языке PL/Tcl без параметров, которая будет выполняться, когда для PL/Tcl будет создаваться
новый экземпляр Tcl. Такая функция может выполнять инициализацию в рамках сеанса, напри-
мер, загружать дополнительный код Tcl. Новый интерпретатор Tcl создаётся при первом выпол-
нении какой-либо функции PL/Tcl в сеансе базы данных или когда требуется дополнительный
интерпретатор из-за того, что функция PL/Tcl была вызвана новой ролью SQL.
1193PL/Tcl — процедурный язык Tcl
Указанная функция должна быть написана на языке pltcl и не должна иметь свойство SECURITY
DEFINER. (Благодаря этим ограничениям эта функция будет запускаться в интерпретаторе, ко-
торый она должна инициализировать.) Текущий пользователь должен иметь право и на её вы-
полнение тоже.
Если эта функция завершится ошибкой, эта ошибка прервёт вызов функции, которой потребо-
вался новый интерпретатор, и распространится в вызывающий запрос, приводя к прерыванию
текущей транзакции или подтранзакции. Любые действия, уже произведённые в среде Tcl, от-
менены не будут; однако этот интерпретатор более не будет использоваться. При следующей
попытке использования этого языка последует повторная попытка инициализации со свежим
интерпретатором Tcl.
Изменять этот параметр разрешено только суперпользователям. Хотя изменить его можно в
рамках сеанса, такие изменения не повлияют на работу интерпретаторов Tcl, созданных ранее.
pltclu.start_proc (string)
Это параметр полностью аналогичен pltcl.start_proc, но применяется к PL/TclU. Указанная
функция должна быть написана на языке pltclu.
44.12. Имена процедур Tcl
В PostgreSQL одно имя функции может использоваться разными определениями функций, если
они имеют разное число и типы аргументов. Tcl, однако, требует, чтобы имена всех процедур раз-
личались. PL/Tcl решает эту проблему, устанавливая такие внутренние имена процедур Tcl, чтобы
они включали в свой состав OID функции из системной таблицы pg_proc. Таким образом, функци-
ям PostgreSQL с одним именем и разными типами аргументов так же будут соответствовать раз-
личные процедуры Tcl. Это обычно остаётся незамеченным для программиста PL/Tcl, но может
проявиться при отладке.
1194</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page11/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page10/">10</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page11/">11</a></li>
      
    
      
        <li><strong class="current-page">12</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page13/">13</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page14/">14</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page13/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>