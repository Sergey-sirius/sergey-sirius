<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page12/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page12/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-045/" title="Глава 45. PL/Perl — процедурный язык Perl"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 45. PL/Perl — процедурный язык Perl"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-045/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~10 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-045/" rel="bookmark" title="Глава 45. PL/Perl — процедурный язык Perl" itemprop="url">Глава 45. PL/Perl — процедурный язык Perl</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 45. PL/Perl — процедурный язык Perl</p>

<p>PL/Perl — это загружаемый процедурный язык, позволяющий реализовывать функции PostgreSQL
на языке программирования Perl.
Основным преимуществом PL/Perl является то, что он позволяет применять в сохранённых функци-
ях множество функций и операторов «перемалывания строк», имеющихся в Perl. Разобрать слож-
ные строки на языке Perl может быть гораздо проще, чем используя строковые функции и управ-
ляющие структуры в PL/pgSQL.
Чтобы установить PL/Perl в определённую базу данных, выполните команду CREATE EXTENSION
plperl.
Подсказка
Если язык устанавливается в template1, он будет автоматически установлен во все
создаваемые впоследствии базы данных.
Примечание
Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/
Perl в процессе установки. (За дополнительными сведениями обратитесь к Главе 16.)
Пользователи двоичных пакетов могут найти PL/Perl в отдельном модуле.
45.1. Функции на PL/Perl и их аргументы
Чтобы создать функцию на языке PL/Perl, используйте стандартный синтаксис CREATE FUNCTION:
CREATE FUNCTION имя_функции (типы-аргументов) RETURNS тип-результата AS $$</p>
<h1 id="Тело-функции-на-plperl">Тело функции на PL/Perl</h1>
<p><script type="math/tex">LANGUAGE plperl;
Тело функции содержит обычный код Perl. Фактически, код обвязки PL/Perl помещает этот код
в подпрограмму Perl. Функция PL/Perl вызывается в скалярном контексте, так что она не может
вернуть список. Не скалярные значения (массивы, записи и множества) можно вернуть по ссылке,
как описывается ниже.
В процедуре PL/Perl возвращаемое из кода Perl значение игнорируется.
PL/Perl также поддерживает анонимные блоки кода, которые выполняются оператором DO:
DO</script></p>
<h1 id="Код-plperl">Код PL/Perl</h1>
<p><script type="math/tex">LANGUAGE plperl;
Анонимный блок кода не принимает аргументы, а любое значение, которое он мог бы вернуть,
отбрасывается. В остальном он работает подобно коду функции.
Примечание
Использовать вложенные именованные подпрограммы в Perl опасно, особенно если они
обращаются к лексическим переменным в окружающей области. Так как функция PL/
Perl оборачивается в подпрограмму, любая именованная функция внутри неё будет вло-
женной. Вообще гораздо безопаснее создавать анонимные подпрограммы и вызывать
их по ссылке на код. Дополнительную информацию вы можете получить на странице
руководства man perldiag, в описании ошибок Variable "%s" will not stay shared
(Переменная "%s" не останется разделяемой) и Variable "%s" is not available (Пе-
1195PL/Perl — процедурный язык Perl
ременная "%s" недоступна), либо найти в Интернете по ключевым словам «perl nested
named subroutine» (perl вложенная именованная подпрограмма).
Синтаксис команды CREATE FUNCTION требует, чтобы тело функции было записано как строковая
константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. Под-
раздел 4.1.2.4). Если вы решите применять синтаксис спецпоследовательностей E'', вам придётся
дублировать апострофы (') и обратную косую черту (\) в теле функции (см. Подраздел 4.1.2.1).
Аргументы и результат обрабатываются как и в любой другой подпрограмме на Perl: аргументы
передаются в @_, а результирующим значением будет указанное в return или полученное в по-
следнем выражении, вычисленном в функции.
Например, функцию, возвращающую большее из двух целых чисел, можно определить так:
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS</script>
if ($<em>[0] &gt; $</em>[1]) { return $<em>[0]; }
return $</em>[1];
<script type="math/tex">LANGUAGE plperl;
Примечание
Аргументы будут преобразованы из кодировки базы данных в UTF-8 для использования
в PL/Perl, а при выходе снова будут преобразованы из UTF-8 в кодировку базы данных.
Если функции передаётся NULL-значение SQL, значением аргумента в Perl станет «undefined».
Показанное выше определение функции будет не очень хорошо обрабатывать значения NULL (в
действительности они будут восприняты как нули). Мы могли бы добавить указание STRICT в это
определение, чтобы PostgreSQL поступал немного разумнее: при передаче значения NULL функ-
ция вовсе не будет вызываться, будет сразу возвращён результат NULL. С другой стороны, мы
могли бы проверить значения undefined в теле функции. Например, предположим, что нам нужна
функция perl_max, которая с одним аргументом NULL и вторым аргументом не NULL должна воз-
вращать не NULL, а второй аргумент:
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS</script>
my ($x, $y) = @_;
if (not defined $x) {
return undef if not defined $y;
return $y;
}
return $x if not defined $y;
return $x if $x &gt; $y;
return $y;
<script type="math/tex">LANGUAGE plperl;
Как показано выше, чтобы выдать значение SQL NULL, нужно вернуть значение undefined. Это
можно сделать и в строгой, и в нестрогой функции.
Всё в аргументах функции, что не является ссылкой, является строкой, то есть стандартным для
PostgreSQL внешним текстовым представлением соответствующего типа данных. В случае с обыч-
ными числовыми или текстовыми типами, Perl просто воспринимает их должным образом, и про-
граммист, как правило, может об этом не думать. Однако в более сложных случаях может потре-
боваться преобразовать аргумент в форму, подходящую для использования в Perl. Например, для
преобразования типа bytea в двоичное значение можно использовать функцию decode_bytea.
Аналогично, значения, передаваемые в PostgreSQL, должны быть в формате внешнего текстового
представления. Например, для подготовки двоичных данных к возврату в значении bytea можно
воспользоваться функцией encode_bytea.
Perl может возвращать массивы PostgreSQL как ссылки на массивы Perl. Например, так:
1196PL/Perl — процедурный язык Perl
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS</script>
return [[‘a”b’,’c,d’],[‘e\f’,’g’]];
<script type="math/tex">LANGUAGE plperl;
select returns_array();
Perl передаёт массивы PostgreSQL как объект, сопоставленный с PostgreSQL::InServer::ARRAY. С
этим объектом можно работать как со ссылкой на массив или строкой, что допускает обратную
совместимость с кодом Perl, написанным для PostgreSQL версии до 9.1. Например:
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS</script>
my $arg = shift;
my $result = “”;
return undef if (!defined $arg);</p>
<h1 id="в-качестве-ссылки-на-массив">в качестве ссылки на массив</h1>
<p>for (@$arg) {
$result .= $_;
}</p>
<h1 id="также-работает-со-строкой">также работает со строкой</h1>
<p>$result .= $arg;
return $result;
<script type="math/tex">LANGUAGE plperl;
SELECT concat_array_elements(ARRAY['PL','/','Perl']);
Примечание
Многомерные массивы представляются как ссылки на массивы меньшей размерности
со ссылками — этот способ хорошо знаком каждому программисту на Perl.
Аргументы составного типа передаются функции как ссылки на хеши. Ключами хеша являются
имена атрибутов составного типа. Например:
CREATE TABLE employee (
name text,
basesalary integer,
bonus integer
);
CREATE FUNCTION empcomp(employee) RETURNS integer AS</script>
my ($emp) = @<em>;
return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
<script type="math/tex">LANGUAGE plperl;
SELECT name, empcomp(employee.*) FROM employee;
Функция на PL/Perl может вернуть результат составного типа, применяя тот же подход: возвратить
ссылку на хеш с требуемыми атрибутами. Например, так:
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);
CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS</script>
return {f2 =&gt; ‘hello’, f1 =&gt; 1, f3 =&gt; ‘world’};
<script type="math/tex">LANGUAGE plperl;
1197PL/Perl — процедурный язык Perl
SELECT * FROM perl_row();
Столбцы объявленного типа результата, отсутствующие в хеше, будут возвращены как значения
NULL.
Подобным образом в виде ссылки на хеш могут быть возвращены выходные аргументы процедуры:
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS</script>
my ($a, $b) = @</em>;
return {a =&gt; $a * 3, b =&gt; $b * 3};
<script type="math/tex">LANGUAGE plperl;
CALL perl_triple(5, 10);
Функции на PL/Perl могут также возвращать множества со скалярными или составными типами.
Обычно желательно возвращать результат по одной строке, чтобы сократить время подготовки
с одной стороны, и чтобы не потребовалось накапливать весь набор данных в памяти, с другой.
Это можно реализовать с помощью функции return_next, как показано ниже. Заметьте, что после
последнего вызова return_next, нужно поместить return или (что лучше) return undef.
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS</script>
foreach (0..$<em>[0]) {
return_next($</em>);
}
return undef;
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set_int(5);
CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS</script>
return_next({ f1 =&gt; 1, f2 =&gt; ‘Hello’, f3 =&gt; ‘World’ });
return_next({ f1 =&gt; 2, f2 =&gt; ‘Hello’, f3 =&gt; ‘PostgreSQL’ });
return_next({ f1 =&gt; 3, f2 =&gt; ‘Hello’, f3 =&gt; ‘PL/Perl’ });
return undef;
<script type="math/tex">LANGUAGE plperl;
Для небольших наборов данных можно также вернуть ссылку на массив, содержащий скаляры,
ссылки на массивы, либо ссылки на хеши для простых типов, типов массивов и составных типов,
соответственно. Ниже приведена пара простых примеров, показывающих, как возвратить весь на-
бор данных в виде ссылки на массив:
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS</script>
return [0..$<em>[0]];
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set_int(5);
CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS</script>
return [
{ f1 =&gt; 1, f2 =&gt; ‘Hello’, f3 =&gt; ‘World’ },
{ f1 =&gt; 2, f2 =&gt; ‘Hello’, f3 =&gt; ‘PostgreSQL’ },
{ f1 =&gt; 3, f2 =&gt; ‘Hello’, f3 =&gt; ‘PL/Perl’ }
];
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM perl_set();
Если вы хотите использовать в своём коде strict, у вас есть несколько вариантов. Для временного
глобального использования вы можете задать для plperl.use_strict значение true командой SET.
1198PL/Perl — процедурный язык Perl
Это повлияет на компилируемые впоследствии функции PL/Perl, но не на функции, уже скомпили-
рованные в текущем сеансе. Для постоянного глобального использования вы можете присвоить
параметру plperl.use_strict значение true в файле postgresql.conf.
Для постоянного использования strict в опредёлённых функциях вы можете просто написать:
use strict;
в начале тела этих функций.
Вы также можете использовать указания feature в use, если используете Perl версии 5.10.0 или
новее.
45.2. Значения в PL/Perl
Значения аргументов, передаваемые в код функции PL/Perl, представляют собой просто входные
аргументы, преобразованные в текстовый вид (так же, как при выводе оператором SELECT). И на-
оборот, команды return и return_next могут принять любую строку, соответствующую формату
ввода для объявленного типа результата функции.
45.3. Встроенные функции
45.3.1. Обращение к базе данных из PL/Perl
Обращаться к самой базе данных из кода Perl можно, используя следующие функции:
spi_exec_query(запрос [, макс-строк])
spi_exec_query выполняет команду SQL и возвращает весь набор строк в виде ссылки на мас-
сив хешей. Эту функцию следует использовать, только если вы знаете, что набор будет
относительно небольшим. Так выглядит пример запроса (SELECT) с дополнительно заданным
максимальным числом строк:
$rv = spi_exec_query('SELECT * FROM my_table', 5);
Этот запрос возвращает не больше 5 строк из таблицы my_table. Если в my_table есть столбец
my_column, получить его значение из строки $i результата можно следующим образом:
$foo = $rv->{rows}[$i]->{my_column};
Общее число строк, возвращённых запросом SELECT, можно получить так:
$nrows = $rv->{processed}
Так можно выполнить команду другого типа:
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
Затем можно получить статус команды (например, SPI_OK_INSERT) следующим образом:
$res = $rv->{status};
Чтобы получить число затронутых строк, выполните:
$nrows = $rv->{processed};
Полный пример:
CREATE TABLE test (
i int,
v varchar
);
1199PL/Perl — процедурный язык Perl
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
test
test
test
test
(i,
(i,
(i,
(i,
v)
v)
v)
v)
VALUES
VALUES
VALUES
VALUES
(1,
(2,
(3,
(4,
'first line');
'second line');
'third line');
'immortal');
CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS</script>
my $rv = spi_exec_query(‘select i, v from test;’);
my $status = $rv-&gt;{status};
my $nrows = $rv-&gt;{processed};
foreach my $rn (0 .. $nrows - 1) {
my $row = $rv-&gt;{rows}[$rn];
$row-&gt;{i} += 200 if defined($row-&gt;{i});
$row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
return_next($row);
}
return undef;
<script type="math/tex">LANGUAGE plperl;
SELECT * FROM test_munge();
spi_query(команда)
spi_fetchrow(cursor)
spi_cursor_close(cursor)
Функции spi_query и spi_fetchrow применяются в паре, когда набор строк может быть очень
большим или когда нужно возвращать строки по мере их поступления. Функция spi_fetchrow
работает только с spi_query. Следующий пример показывает, как использовать их вместе:
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);
CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS</script>
use Digest::MD5 qw(md5_hex);
my $file = ‘/usr/share/dict/words’;
my $t = localtime;
elog(NOTICE, “opening file $file at $t” );
open my $fh, ‘&lt;’, $file # здесь мы обращаемся к файлу!
or elog(ERROR, “cannot open $file for reading: $!”);
my @words = &lt;$fh&gt;;
close $fh;
$t = localtime;
elog(NOTICE, “closed file $file at $t”);
chomp(@words);
my $row;
my $sth = spi_query(“SELECT * FROM generate_series(1,$</em>[0]) AS b(a)”);
while (defined ($row = spi_fetchrow($sth))) {
return_next({
the_num =&gt; $row-&gt;{a},
the_text =&gt; md5<em>hex($words[rand @words])
});
}
return;
<script type="math/tex">LANGUAGE plperlu;
SELECT * from lotsa_md5(500);
Обычно вызов spi_fetchrow нужно повторять, пока не будет получен результат undef, показы-
вающий, что все строки уже прочитаны. Курсор, возвращаемый функцией spi_query, автома-
тически освобождается, когда spi_fetchrow возвращает undef. Если вы не хотите читать все
строки, освободите курсор, выполнив spi_cursor_close, чтобы не допустить утечки памяти.
1200PL/Perl — процедурный язык Perl
spi_prepare(команда, типы аргументов)
spi_query_prepared(план, аргументы)
spi_exec_prepared(план [, атрибуты], аргументы)
spi_freeplan(план)
Функции spi_prepare, spi_query_prepared, spi_exec_prepared и spi_freeplan реализуют ту
же функциональность, но для подготовленных запросов. Функция spi_prepare принимает стро-
ку запроса с нумерованными местозаполнителями аргументов ($1, $2 и т. д.) и список строк
с типами аргументов:
$plan = spi_prepare('SELECT * FROM test WHERE id > $1 AND name = $2',
'INTEGER', 'TEXT');
План запроса, подготовленный вызовом spi_prepare, можно использовать вместо строки за-
проса либо в spi_exec_prepared, возвращающей тот же результат, что и spi_exec_query, ли-
бо в spi_query_prepared, возвращающей курсор так же, как spi_query, который затем можно
передать в spi_fetchrow. В необязательном втором параметре spi_exec_prepared можно пере-
дать хеш с атрибутами; в настоящее время поддерживается только атрибут limit, задающий
максимальное число строк, которое может вернуть запрос.
Подготовленные запросы хороши тем, что позволяют использовать единожды подготовленный
план для неоднократного выполнения запроса. Когда план оказывается не нужен, его можно
освободить, вызвав spi_freeplan:
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS</script>
$_SHARED{my_plan} = spi_prepare(‘SELECT (now() + $1)::date AS now’,
‘INTERVAL’);
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS</script>
return spi_exec_prepared(
$_SHARED{my_plan},
$</em>[0]
)-&gt;{rows}-&gt;[0]-&gt;{now};
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION done() RETURNS VOID AS</script>
spi_freeplan( $<em>SHARED{my_plan});
undef $_SHARED{my_plan};
<script type="math/tex">LANGUAGE plperl;
SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();
add_time | add_time | add_time
------------+------------+------------
2005-12-10 | 2005-12-11 | 2005-12-12
Заметьте, что параметры для spi_prepare обозначаются как $1, $2, $3 и т. д., так что по воз-
можности не записывайте строки запросов в двойных кавычках, чтобы не спровоцировать труд-
ноуловимые ошибки.
Ещё
один
пример,
spi_exec_prepared:
иллюстрирующий
использование
необязательного
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
FROM generate_series(1,3) AS id;
CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS</script>
$_SHARED{plan} = spi_prepare(‘SELECT * FROM hosts
1201
параметраPL/Perl — процедурный язык Perl
WHERE address « $1’, ‘inet’);
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS</script>
return spi_exec_prepared(
$_SHARED{plan},
{limit =&gt; 2},
$</em>[0]
)-&gt;{rows};
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS</script>
spi_freeplan($<em>SHARED{plan});
undef $_SHARED{plan};
<script type="math/tex">LANGUAGE plperl;
SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();
query_hosts
-----------------
(1,192.168.1.1)
(2,192.168.1.2)
(2 rows)
spi_commit()
spi_rollback()
Эти функции фиксируют или откатывают текущую транзакцию. Они могут вызываться только в
процедурах или в анонимных блоках кода (в команде DO), вызываемых из кода верхнего уровня.
(Заметьте, что выполнить SQL-команды COMMIT или ROLLBACK через spi_exec_query или подоб-
ную функцию нельзя. Соответствующие операции могут выполняться только данными функци-
ями.) После завершения одной транзакции следующая начинается автоматически, отдельной
функции для этого нет.
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS</script>
foreach my $i (0..9) {
spi_exec_query(“INSERT INTO test1 (a) VALUES ($i)”);
if ($i % 2 == 0) {
spi_commit();
} else {
spi_rollback();
}
}
<script type="math/tex">;
CALL transaction_test1();
45.3.2. Вспомогательные функции в PL/Perl
elog(уровень, сообщение)
Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни сообщений: DEBUG
(ОТЛАДКА), LOG (СООБЩЕНИЕ), INFO (ИНФОРМАЦИЯ), NOTICE (ЗАМЕЧАНИЕ), WARNING (ПРЕ-
ДУПРЕЖДЕНИЕ) и ERROR (ОШИБКА). С уровнем ERROR выдаётся ошибка; если она не перехва-
1202PL/Perl — процедурный язык Perl
тывается окружающим кодом Perl, она распространяется в вызывающий запрос, что приводит к
прерыванию текущей транзакции или подтранзакции. По сути то же самое делает команда die
языка Perl. При использовании других уровней происходит просто вывод сообщения с задан-
ным уровнем важности. Будут ли сообщения определённого уровня передаваться клиенту и/или
записываться в журнал, определяется конфигурационными параметрами log_min_messages и
client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
quote_literal(строка)
Оформляет переданную строку для использования в качестве текстовой строки в SQL-опера-
торе. Включённые в неё апострофы и обратная косая черта при этом дублируются. Заметьте,
что quote_literal возвращает undef, когда получает аргумент undef; если такие аргументы
возможны, часто лучше использовать quote_nullable.
quote_nullable(строка)
Оформляет переданную строку для использования в качестве текстовой строки в SQL-операто-
ре; либо, если поступает аргумент undef, возвращает строку "NULL" (без кавычек). Символы
апостроф и обратная косая черта дублируются должным образом.
quote_ident(строка)
Оформляет переданную строку для использования в качестве идентификатора в SQL-операто-
ре. При необходимости идентификатор заключается в кавычки (например, если он содержит
символы, недопустимые в открытом виде, или буквы в разном регистре). Если переданная стро-
ка содержит кавычки, они дублируются.
decode_bytea(строка)
Возвращает неформатированные двоичные данные, представленные содержимым заданной
строки, которая должна быть закодирована как bytea.
encode_bytea(строка)
Возвращает закодированные в виде bytea двоичные данные, содержащиеся в переданной стро-
ке.
encode_array_literal(массив)
encode_array_literal(массив, разделитель)
Возвращает содержимое указанного массива в виде строки в формате массива (см. Подраз-
дел 8.15.2). Возвращает значение аргумента неизменённым, если это не ссылка не массив. Раз-
делитель элементов в строке массива по умолчанию — ", " (если разделитель не определён
или undef).
encode_typed_literal(значение, имя_типа)
Преобразует переменную Perl в значение типа данных, указанного во втором аргументе, и воз-
вращает строковое представление этого значения. Корректно обрабатывает вложенные масси-
вы и значения составных типов.
encode_array_constructor(массив)
Возвращает содержимое переданного массива в виде строки в формате конструктора массива
(см. Подраздел 4.2.12). Отдельные значения заключаются в кавычки функцией quote_nullable.
Возвращает значение аргумента, заключённое в кавычки функцией quote_nullable, если ар-
гумент — не ссылка на массив.
looks_like_number(строка)
Возвращает значение true, если содержимое переданной строки похоже на число, по правилам
Perl, и false в обратном случае. Возвращает undef для аргумента undef. Ведущие и замыкающие
1203PL/Perl — процедурный язык Perl
пробелы игнорируются. Строки Inf и Infinity считаются представляющими число (бесконеч-
ность).
is_array_ref(аргумент)
Возвращает значение true, если переданный аргумент можно воспринять как ссылку на массив,
то есть это ссылка на ARRAY или PostgreSQL::InServer::ARRAY. В противном случае возвращает
false.
45.4. Глобальные значения в PL/Perl
Вы можете использовать для хранения данных, включая ссылки на код, глобальный хеш %_SHARED.
Эти данные будут сохраняться между вызовами функции на протяжении всего текущего сеанса.
Простой пример работы с разделяемыми данными:
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS</script>
if ($_SHARED{$</em>[0]} = $<em>[1]) {
return ‘ok’;
} else {
return “cannot set shared variable $</em>[0] to $<em>[1]”;
}
<script type="math/tex">LANGUAGE plperl;
CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS</script>
return $_SHARED{$</em>[0]};
<script type="math/tex">LANGUAGE plperl;
SELECT set_var('sample', 'Hello, PL/Perl!
SELECT get_var('sample');
How''s tricks?');
Это чуть более сложный пример, в котором используется ссылка на код:
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS</script>
$_SHARED{myquote} = sub {
my $arg = shift;
$arg =~ s/([’\])/\$1/g;
return “‘$arg’”;
};
<script type="math/tex">LANGUAGE plperl;
SELECT myfuncs(); /* инициализация функции */
/* Определение функции, использующей функцию заключения в кавычки */
CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS</script>
my $text_to_quote = shift;
my $qfunc = $_SHARED{myquote};
return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
(Код выше можно было бы упростить до однострочной команды return</p>
<blockquote>
  <p>($_[0]); в ущерб читаемости.)
$_SHARED{myquote}-
По соображениям безопасности, PL/Perl выполняет функции, вызываемые некоторой ролью SQL,
в отдельном интерпретаторе Perl, выделенном для этой роли. Это предотвращает случайное или
злонамеренное влияние одного пользователя на поведение функций PL/Perl другого пользователя.
В каждом интерпретаторе будет своё значение переменной %_SHARED и собственное глобальное
состояние. Таким образом, две функции PL/Perl будут разделять одно значение %_SHARED, только
если они выполняются одной ролью SQL. В приложении, выполняющем код в одном сеансе с раз-
1204PL/Perl — процедурный язык Perl
ными ролями SQL (вызывающем функции SECURITY DEFINER, использующем команду SET ROLE и т.
д.) может понадобиться явно предпринять дополнительные меры, чтобы функции на PL/Perl могли
разделять данные через %_SHARED. Для этого сначала установите для функций, которые должны
взаимодействовать, одного владельца, а затем задайте для них свойство SECURITY DEFINER. Разу-
меется, при этом нужно позаботиться о том, чтобы эти функции не могли сделать ничего непреду-
смотренного.
45.5. Доверенный и недоверенный PL/Perl
Обычно PL/Perl устанавливается в базу данных как «доверенный» язык программирования с име-
нем plperl. При этом в целях безопасности определённые операции в Perl запрещаются. Вообще
говоря, запрещаются все операции, взаимодействующие с окружением. В том числе, это опера-
ции с файлами, require и use (для внешних модулей). Поэтому функции на PL/Perl, в отличие от
функций на C, никаким образом не могут взаимодействовать с внутренними механизмами сервера
баз данных или обращаться к операционной системе с правами серверного процесса. Вследствие
этого, использовать этот язык можно разрешить любому непривилегированному пользователю баз
данных.
В следующем примере показана функция, которая не будет работать, потому что операции с фай-
ловой системы запрещены по соображениям безопасности:
CREATE FUNCTION badfunc() RETURNS integer AS <script type="math/tex">my $tmpfile = "/tmp/badfile";
open my $fh, '>', $tmpfile
or elog(ERROR, qq{could not open the file "$tmpfile": $!});
print $fh "Testing writing to a file\n";
close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
return 1;</script> LANGUAGE plperl;
Создать эту функцию не удастся, так как при проверке её правильности будет обнаружено исполь-
зование запрещённого оператора.
Иногда возникает желание написать на Perl код, функциональность которого не будет ограничи-
ваться. Например, может потребоваться функция на Perl, которая будет посылать почту. Для таких
потребностей PL/Perl также можно установить как «недоверенный» язык (обычно его называют
PL/PerlU). В этом случае будут доступны все возможности языка Perl. Устанавливая язык, укажите
имя plperlu, чтобы выбрать недоверенную вариацию PL/Perl.
Автор функции на PL/PerlU должен позаботиться о том, чтобы эту функцию нельзя было использо-
вать не по назначению, так как она может делать всё, что может пользователь с правами админи-
стратора баз данных. Заметьте, что СУБД позволяет создавать функции на недоверенных языках
только суперпользователям базы данных.
Если показанная выше функция будет создана суперпользователем, и при этом будет выбран язык
plperlu, она выполнится успешно.
Таким же образом, в анонимном блоке кода на Perl разрешены абсолютно любые операции, если
в качестве языка вместо plperl выбирается plperlu, но выполнять этот код должен суперпользо-
ватель.
Примечание
Тогда как функции на PL/Perl исполняются отдельными интерпретаторами Perl для
каждой роли SQL, все функции на PL/PerlU, вызываемые в рамках сеанса, исполняются
в одном интерпретаторе Perl (отличном от тех, что исполняют функции PL/Perl). Бла-
годаря этому, функции PL/PerlU могут свободно разделять общие данные, но между
функциями PL/Perl и PL/PerlU взаимодействие невозможно.
1205PL/Perl — процедурный язык Perl
Примечание
Perl поддерживает работу нескольких интерпретаторов в одном процессе, только если
он был собран с нужными флагами, а именно, с флагом usemultiplicity или с флагом
useithreads. (В отсутствие веских причин использовать потоки предпочтительным яв-
ляется вариант usemultiplicity. Дополнительную информацию вы можете получить
на странице man perlembed.) При использовании PL/Perl с версией Perl, собранной без
этих флагов, в рамках сеанса можно будет запустить только один интерпретатор Perl,
так что в сеансе будет возможно выполнять либо функции PL/PerlU, либо функции PL/
Perl (и вызывать их должна одна роль SQL).
45.6. Триггеры на PL/Perl
PL/Perl можно использовать для написания триггерных функций. В триггерной функции хеш-мас-
сив $_TD содержит информацию о произошедшем событии триггера. $_TD — глобальная перемен-
ная, которая получает нужное локальное значение при каждом вызове триггера. Хеш-массив $_TD
содержит следующие поля:
$_TD-&gt;{new}{foo}
Новое значение столбца foo
$_TD-&gt;{old}{foo}
Старое значение столбца foo
$_TD-&gt;{name}
Имя вызываемого триггера
$_TD-&gt;{event}
Событие триггера: INSERT, UPDATE, DELETE, TRUNCATE или UNKNOWN
$_TD-&gt;{when}
Когда вызывается триггер: BEFORE (ДО), AFTER (ПОСЛЕ), INSTEAD OF (ВМЕСТО) или UNKNOWN
(НЕИЗВЕСТНО)
$_TD-&gt;{level}
Уровень триггера: ROW (СТРОКА), STATEMENT (ОПЕРАТОР) или UNKNOWN (НЕИЗВЕСТНЫЙ)
$_TD-&gt;{relid}
OID таблицы, для которой сработал триггер
$_TD-&gt;{table_name}
Имя таблицы, для которой сработал триггер
$_TD-&gt;{relname}
Имя таблицы, для которой сработал триггер. Это обращение устарело и может быть ликвиди-
ровано в будущем выпуске. Используйте вместо него $_TD-&gt;{table_name}.
$_TD-&gt;{table_schema}
Имя схемы, содержащей таблицу, для которой сработал триггер
$_TD-&gt;{argc}
Число аргументов в триггерной функции
1206PL/Perl — процедурный язык Perl
@{$_TD-&gt;{args}}
Аргументы триггерной функции. Не определено, если $_TD-&gt;{argc} равно 0.
В триггерах уровня строки возможны следующие варианты возврата:
return;
Выполнить операцию
“SKIP”
Не выполнять операцию
“MODIFY”
Указывает, что строка NEW была изменена триггерной функцией
Следующий пример триггерной функции иллюстрирует описанные выше варианты:
CREATE TABLE test (
i int,
v varchar
);
CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
return “SKIP”;</p>
  <h1 id="пропустить-команду-insertupdate">пропустить команду INSERT/UPDATE</h1>
  <p>} elsif ($_TD-&gt;{new}{v} ne “immortal”) {
$_TD-&gt;{new}{v} .= “(modified by trigger)”;
return “MODIFY”; # изменить строку и выполнить команду INSERT/UPDATE
} else {
return;</p>
  <h1 id="выполнить-команду-insertupdate">выполнить команду INSERT/UPDATE</h1>
  <p>}
<script type="math/tex">LANGUAGE plperl;
CREATE TRIGGER test_valid_id_trig
BEFORE INSERT OR UPDATE ON test
FOR EACH ROW EXECUTE FUNCTION valid_id();
45.7. Событийные триггеры на PL/Perl
PL/Perl можно использовать для написания функций событийных триггеров. В функции событий-
ного триггера хеш-массив $_TD содержит информацию о произошедшем событии триггера. $_TD —
глобальная переменная, которая получает нужное локальное значение при каждом вызове триг-
гера. Хеш-массив $_TD содержит следующие поля:
$_TD->{event}
Имя события, при котором срабатывает этот триггер.
$_TD->{tag}
Тег команды, для которой срабатывает этот триггер.
Возвращаемое значение триггерной функции игнорируется.
Следующий пример функции событийного триггера иллюстрирует описанное выше:
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS</script>
elog(NOTICE, “perlsnitch: “ . $_TD-&gt;{event} . “ “ . $_TD-&gt;{tag} . “ “);
$$ LANGUAGE plperl;
CREATE EVENT TRIGGER perl_a_snitch
1207PL/Perl — процедурный язык Perl
ON ddl_command_start
EXECUTE FUNCTION perlsnitch();
45.8. Внутренние особенности PL/Perl
45.8.1. Конфигурирование
В этом разделе описываются параметры конфигурации, влияющие на работу PL/Perl.
plperl.on_init (string)
Задаёт код Perl, который будет выполняться при первой инициализации интерпретатора Perl, до
того, как он получает специализацию plperl или plperlu. Когда этот код выполняется, функ-
ции SPI ещё не доступны. Если выполнение кода завершается ошибкой, инициализация интер-
претатора прерывается и ошибка распространяется в вызывающий запрос, в результате чего
текущая транзакция или подтранзакция прерывается.
Размер этого кода ограничивается одной строкой. Более объёмный код можно поместить в мо-
дуль и загрузить этот модуль в строке on_init. Например:
plperl.on_init = ‘require “plperlinit.pl”’
plperl.on_init = ‘use lib “/my/app”; use MyApp::PgInit;’
Любые модули, загруженные в plperl.on_init, явно или неявно, будут доступны для исполь-
зования в коде на языке plperl. Это может создать угрозу безопасности. Чтобы определить,
какие модули были загружены, можно выполнить:
DO ‘elog(WARNING, join “, “, sort keys %INC)’ LANGUAGE plperl;
Если библиотека plperl включена в shared_preload_libraries, инициализация произойдёт в глав-
ном процессе (postmaster) и в этом случае необходимо очень серьёзно оценить риск наруше-
ния работоспособности этого процесса. Основной смысл использовать эту возможность в том,
чтобы модули Perl, подключаемые в plperl.on_init, загружались только при запуске главно-
го процесса, и это исключало бы издержки загрузки для отдельных сеансов. Однако, имейте
в виду, что эти издержки исключаются только при загрузке в сеансе первого интерпретатора
Perl — будь то PL/PerlU или PL/Perl для первой SQL-роли, вызывающей функцию на PL/Perl. Лю-
бые дополнительные интерпретаторы Perl, создаваемые в сеансе базы данных, должны будут
выполнять plperl.on_init заново. Также учтите, что в Windows предварительная загрузка не
даёт никакого выигрыша, так как интерпретатор Perl, созданный в главном процессе, не пере-
даётся дочерним процессам.
Задать этот параметр можно только в postgresql.conf или в командной строке при запуске
сервера.
plperl.on_plperl_init (string)
plperl.on_plperlu_init (string)
В этих параметрах задаётся код Perl, который будет выполняться в момент, когда интерпрета-
тор Perl получает специализацию plperl или plperlu, соответственно. Это произойдёт, когда в
рамках сеанса будет первый раз вызвана функция на PL/Perl или PL/PerlU, либо когда потребу-
ется дополнительный интерпретатор при использовании другого языка или при вызове функ-
ции PL/Perl новой SQL-ролью. Этот код выполняется после инициализации, произведённой в
plperl.on_init. Однако функции SPI в момент исполнения этого кода ещё не доступны. Код в
plperl.on_plperl_init запускается после того, как интерпретатор «помещается под замок»,
так что в нём разрешаются только доверенные операции.
Если этот код завершается ошибкой, инициализация прерывается и ошибка распространяется
в вызывающий запрос, что приводит к прерыванию текущей транзакции или подтранзакции.
При этом любые действия, уже произведённые в Perl, не будут отменены; однако использовать-
ся этот интерпретатор больше не будет. При следующей попытке использовать этот язык си-
стема попытается заново инициализировать свежий интерпретатор Perl.
1208PL/Perl — процедурный язык Perl
Изменять эти параметры разрешено только суперпользователям. Хотя изменить их можно в
рамках сеанса, такие изменения не повлияют на работу интерпретаторов Perl, задействованных
для выполнения функций ранее.
plperl.use_strict (boolean)
При значении, равном true, последующая компиляция функций PL/Perl будет выполняться с
включённым указанием strict. Этот параметр не влияет на функции, уже скомпилированные
в текущем сеансе.
45.8.2. Ограничения и недостающие возможности
Следующие возможности в настоящее время в PL/Perl отсутствуют, но их реализация будет желан-
ной доработкой.
• Функции на PL/Perl не могут напрямую вызывать друг друга.
• SPI ещё не полностью реализован.
• Если вы выбираете очень большие наборы данных, используя spi_exec_query, вы должны по-
нимать, что все эти данные загружаются в память. Вы можете избежать этого, используя пару
функций spi_query/spi_fetchrow, как показано ранее.
Похожая проблема возникает, если функция, возвращающая множество, передаёт в
PostgreSQL большое число строк, выполняя return. Этой проблемы так же можно избежать,
выполняя для каждой возвращаемой строки return_next, как показано ранее.
• Когда сеанс завершается штатно, не по причине критической ошибки, в Perl выполняются все
блоки END, которые были определены. Никакие другие действия в настоящее время не выпол-
няются. В частности, буферы файлов автоматически не сбрасываются и объекты автоматиче-
ски не уничтожаются.
1209</p>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-044/" title="Глава 44. PL/Tcl — процедурный язык Tcl"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 44. PL/Tcl — процедурный язык Tcl"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-044/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-044/" rel="bookmark" title="Глава 44. PL/Tcl — процедурный язык Tcl" itemprop="url">Глава 44. PL/Tcl — процедурный язык Tcl</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 44. PL/Tcl — процедурный язык Tcl</p>

<p>PL/Tcl — это загружаемый процедурный язык для СУБД PostgreSQL, позволяющий использовать
язык Tcl для написания функций PostgreSQL.
44.1. Обзор
PL/Tcl предоставляет большинство возможностей, которые имеет разработчик функций на C, с
небольшими ограничениями, и позволяет применять мощные библиотеки обработки строк, суще-
ствующие для Tcl.
Одним убедительным хорошим ограничением является то, что весь код выполняется в контексте
безопасности интерпретатора Tcl. Помимо ограниченного набора команд безопасного Tcl, разре-
шены только несколько команд для обращения к базе данных через SPI и вызовы elog() для вы-
дачи сообщений. PL/Tcl не даёт возможности взаимодействовать с внутренним механизмом серве-
ра баз данных или обращаться к ОС с правами серверного процесса PostgreSQL, что возможно в
функциях на C. Таким образом, использование этого языка можно доверить непривилегированным
пользователям; это не даст им неограниченные полномочия.
Ещё одно существенное ограничение заключается в том, что функции на Tcl нельзя использовать
для создания функций ввода/вывода для новых типов данных.
Иногда возникает желание написать функцию на Tcl, которая не будут ограничена безопасным
Tcl. Например, может потребоваться функция, которая будет посылать сообщения по почте. Для
этих случаев есть вариация PL/Tcl, названная PL/TclU (название подразумевает «untrusted Tcl»,
недоверенный Tcl). Это тот же язык, за исключением того, что для него используется полноцен-
ный интерпретатор Tcl. Если применяется PL/TclU, он должен быть установлен как недоверен-
ный процедурный язык, чтобы только суперпользователи могли создавать функции на нём. Автор
функции на PL/TclU должен позаботиться о том, чтобы эту функцию нельзя было использовать не
по назначению, так как она может делать всё, что может пользователь с правами администратора
баз данных.
Разделяемый объектный код для обработчиков вызова PL/Tcl и PL/TclU собирается автоматически
и устанавливается в каталог библиотек PostgreSQL, если поддержка Tcl включена на этапе кон-
фигурирования процедуры установки. Чтобы установить PL/Tcl и/или PL/TclU в конкретную базу
данных, воспользуйтесь командой CREATE EXTENSION, например, так: CREATE EXTENSION pltcl или
CREATE EXTENSION pltclu.
44.2. Функции на PL/Tcl и их аргументы
Чтобы создать функцию на языке PL/Tcl, используйте стандартный синтаксис CREATE FUNCTION:
CREATE FUNCTION имя_функции (типы_аргументов) RETURNS тип_результата AS $$</p>
<h1 id="Тело-функции-на-pltcl">Тело функции на PL/Tcl</h1>
<p><script type="math/tex">LANGUAGE pltcl;
С PL/TclU команда та же, но в качестве языка должно быть указано pltclu.
Тело функции содержит просто скрипт на Tcl. Когда вызывается функция, значения аргументов
передаются скрипту Tcl в виде переменных с именами 1 ... n. Результат из кода Tcl возвращается
как обычно, оператором return. В процедуре значение, возвращаемое из кода Tcl, игнорируется.
Например, функцию, возвращающую большее из двух целых чисел, можно определить так:
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS</script>
if {$1 &gt; $2} {return $1}
return $2
<script type="math/tex">LANGUAGE pltcl STRICT;
Обратите внимание на предложение STRICT, которое избавляет нас от необходимости думать о
входящих значениях NULL: если при вызове передаётся значение NULL, функция не будет выпол-
няться вовсе, будет сразу возвращён результат NULL.
1184PL/Tcl — процедурный язык Tcl
В нестрогой функции, если фактическое значение аргумента — NULL, соответствующей перемен-
ной $n будет присвоена пустая строка. Чтобы определить, был ли передан NULL в определённом
аргументе, используйте функцию argisnull. Например, предположим, что нам нужна функция
tcl_max, которая с одним аргументом NULL и вторым аргументом не NULL должна возвращать не
NULL, а второй аргумент:
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS</script>
if {[argisnull 1]} {
if {[argisnull 2]} { return_null }
return $2
}
if {[argisnull 2]} { return $1 }
if {$1 &gt; $2} {return $1}
return $2
<script type="math/tex">LANGUAGE pltcl;
Как показано выше, чтобы вернуть значение NULL из функции PL/Tcl, нужно выполнить
return_null. Это можно сделать и в строгой, и в нестрогой функции.
Аргументы составного типа передаются функции в виде массивов Tcl. Именами элементов массива
являются имена атрибутов составного типа. Если атрибут в переданной строке имеет значение
NULL, он будет отсутствовать в данном массиве. Например:
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid(employee) RETURNS boolean AS</script>
if {200000.0 &lt; $1(salary)} {
return “t”
}
if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
return “t”
}
return “f”
<script type="math/tex">LANGUAGE pltcl;
Функции PL/Tcl могут возвращать и результаты составного типа. Для этого код на Tcl должен вер-
нуть список пар имя/значение столбца, соответствующий ожидаемому типу результата. Столбцы,
имена которых в этом списке отсутствуют, получат значения NULL, а если в списке указано имя
несуществующего столбца, возникнет ошибка. Например:
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS</script>
return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
<script type="math/tex">LANGUAGE pltcl;
Выходные аргументы процедур возвращаются таким же образом. Например:
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS</script>
return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
<script type="math/tex">LANGUAGE pltcl;
CALL tcl_triple(5, 10);
Подсказка
Список результатов можно создать из желаемого кортежа, представленного в виде
массива, с помощью команды array get языка Tcl. Например:
1185PL/Tcl — процедурный язык Tcl
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS</script>
set 1(salary) [expr {$1(salary) + $2}]
return [array get 1]
<script type="math/tex">LANGUAGE pltcl;
Функции PL/Tcl могут возвращать наборы результатов. Для этого код на Tcl должен вызывать
return_next для каждой возвращаемой строки, передавая ей соответствующее значение, когда
возвращается скалярный тип, или список пар имя/значение столбца, когда возвращается состав-
ной тип. Пример с результатом скалярного типа:
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS</script>
for {set i $1} {$i &lt; $2} {incr i} {
return_next $i
}
<script type="math/tex">LANGUAGE pltcl;
и с результатом составного:
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS</script>
for {set i $1} {$i &lt; $2} {incr i} {
return_next [list x $i x2 [expr {$i * $i}]]
}
<script type="math/tex">LANGUAGE pltcl;
44.3. Значения данных в PL/Tcl
Значения аргументов, передаваемые в код функции PL/Tcl, представляют собой просто входные
аргументы, преобразованные в текстовый вид (так же, как при выводе оператором SELECT). И на-
оборот, команды return и return_next примут любую строку, соответствующую формату ввода для
объявленного типа результата функции или заданного столбца в результате составного типа.
44.4. Глобальные данные в PL/Tcl
Иногда полезно иметь некоторые глобальные данные, сохраняемые между двумя вызовами функ-
ции или совместно используемые разными функциями. Это легко сделать в PL/Tcl, но есть некото-
рые ограничения, которые необходимо понимать.
По соображениям безопасности, PL/Tcl выполняет функции, вызываемые некоторой ролью SQL в
отдельном интерпретаторе Tcl, выделенном для этой роли. Это предотвращает случайное или зло-
намеренное влияние одного пользователя на поведение функций PL/Tcl другого пользователя. В
каждом интерпретаторе будут свои значения всех «глобальных» переменных Tcl. Таким образом,
в двух функциях PL/Tcl будут общие глобальные переменные, только если они выполняются одной
ролью SQL. В приложении, выполняющем код в одном сеансе с разными ролями SQL (вызывающем
функции SECURITY DEFINER, использующем команду SET ROLE и т. д.) может понадобиться явно
предпринять дополнительные меры, чтобы функции могли разделять свои данные. Для этого сна-
чала установите для функций, которые должны взаимодействовать, одного владельца, а затем за-
дайте для них свойство SECURITY DEFINER. Разумеется, при этом нужно позаботиться о том, чтобы
эти функции не могли сделать ничего непредусмотренного.
Все функции PL/TclU, вызываемые в одном сеансе, выполняются одним интерпретатором Tcl, ко-
торый, конечно, отличается от интерпретатора(ов), используемого для функций PL/Tcl. Поэтому
глобальные данные функций PL/TclU автоматически становятся общими. Это не считается угро-
зой безопасности, так как все функции PL/TclU выполняются на одном уровне доверия, а именно
уровне суперпользователя базы данных.
Чтобы защитить функции PL/Tcl от непреднамеренного влияния друг на друга, каждой из них
предоставляется глобальная переменная-массив через команду upvar. Глобальным именем этой
переменной является внутреннее имя функции, а в качестве локального выбрано GD. Переменную
GD рекомендуется использовать для постоянных внутренних данных функции. Обычные глобаль-
1186PL/Tcl — процедурный язык Tcl
ные переменные Tcl следует использовать только для значений, которые предназначены имен-
но для совместного использования несколькими функциями. (Заметьте, что массивы GD являются
глобальными только для конкретного интерпретатора, так что они не нарушают ограничения без-
опасности, описанные выше.)
Использование GD демонстрируется в примере spi_execp, приведённом ниже.
44.5. Обращение к базе данных из PL/Tcl
Для обращения к базе данных из тела функции на PL/Tcl предназначены следующие команды:
spi_exec ?-count n? ?-array имя? команда ?тело-цикла?
Выполняет команду SQL, заданную в виде строки. В случае ошибки в этой команде выдаётся
ошибка в Tcl. В противном случае spi_exec возвращает число обработанных командой строк
(выбранных, добавленных, изменённых или удалённых), либо ноль, если эта команда — служеб-
ный оператор. Кроме того, если команда — оператор SELECT, значения выбранных столбцов
помещаются в переменные Tcl, как описано ниже.
Необязательное значение -count задаёт для spi_exec максимальное число строк, которое
должно быть обработано в команде. Его действие можно представить как выполнение FETCH n
для курсора, предварительно подготовленного для команды.
Если в качестве команды выполняется оператор SELECT, значения результирующих столбцов
помещаются в переменные Tcl, названные по именам столбцов. Если передаётся -array, зна-
чения столбцов вместо этого становятся элементами названного ассоциативного массива, ин-
дексами в котором становятся имена столбцов. Кроме того, в элементе с именем «.tupno» со-
храняется номер текущей строки в результирующем наборе (отсчитывая от нуля), если только
это имя не занято одним из столбцов результата.
Если в качестве команды выполняется SELECT без указания скрипта тело-цикла, в переменных
Tcl или элементах массива сохраняется только первая строка результатов; оставшиеся строки
(если они есть), игнорируются. Если запрос не возвращает строки, не сохраняется ничего. (Этот
случай можно отследить, проверив результат spi_exec.) Например, команда:
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
присвоит переменной $cnt в Tcl число строк, содержащихся в системном каталоге pg_proc.
Если передаётся необязательный аргумент тело-цикла, заданный в нём блок скрипта Tcl будет
выполняться для каждой строки результата запроса. (Аргумент тело-цикла игнорируется, если
целевая команда — не SELECT.) При этом значения столбцов текущей строки сохраняются в
переменных Tcl или элементах массива перед каждой итерацией этого цикла. Например, код:
spi_exec -array C "SELECT * FROM pg_class" {
elog DEBUG "have table $C(relname)"
}
будет выводить в журнал сообщение для каждой строки pg_class. Это работает подобно другим
конструкциям циклов в Tcl; в частности, команды continue и break в теле цикла будут действо-
вать обычным образом.
Если в столбце результата запроса выдаётся NULL, целевая переменная для неё не устанавли-
вается, и оказывается «неустановленной».
spi_prepare запрос список-типов
Подготавливает и сохраняет план запроса для последующего выполнения. Сохранённый план
будет продолжать существование до завершения текущего сеанса.
Запрос может принимать параметры, то есть местозаполнители для значений, которые будут
передаваться, когда план будет собственно выполняться. В строке запроса эти параметры обо-
значаются как $1 ... $n. Если в запросе используются параметры, нужно задать имена типов
1187PL/Tcl — процедурный язык Tcl
этих параметров в виде списка Tcl. (Если параметры отсутствуют, задайте пустой список_ти-
пов.)
Функция spi_prepare возвращает идентификатор запроса, который может использоваться в
последующих вызовах spi_execp. Пример приведён в описании spi_execp.
spi_execp ?-count n? ?-array имя? ?-nulls строка? ид-запроса ?список-значений? ?тело-цик-
ла?
Выполняет запрос, ранее подготовленный функцией spi_prepare. В качестве ид_запроса пере-
даётся идентификатор, возвращённый функцией spi_prepare. Если в запросе задействуются
параметры, необходимо указать список-значений. Это должен быть принятый в Tcl список па-
раметров. Он должен иметь ту же длину, что и список типов параметров, ранее переданный
spi_prepare. Опустите список-значений, если у запроса нет параметров.
Необязательный аргумент -nulls принимает строку из пробелов и символов 'n', которые от-
мечают, в каких параметрах spi_execp передаются значения NULL. Если присутствует, эта
строка должна иметь ту же длину, что и список-значений. В случае её отсутствия значения
всех параметров считаются отличными от NULL.
Не считая отличий в способе передачи запроса и параметров, spi_execp работает так же, как
spi_exec. Параметры -count, -array и тело-цикла задаются так же, и так же передаётся воз-
вращаемое значение.
Взгляните на пример функции на PL/Tcl, использующей подготовленный план:
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS</script>
if {![ info exists GD(plan) ]} {</p>
<h1 id="подготовить-сохранённый-план-при-первом-вызове">подготовить сохранённый план при первом вызове</h1>
<p>set GD(plan) [ spi_prepare \
“SELECT count(*) AS cnt FROM t1 WHERE num &gt;= $1 AND num &lt;= $2” \
[ list int4 int4 ] ]
}
spi_execp -count 1 $GD(plan) [ list $1 $2 ]
return $cnt
<script type="math/tex">LANGUAGE pltcl;
Обратные косые черты внутри строки запроса, передаваемой функции spi_prepare, нужны для
того, чтобы маркеры $n передавались функции spi_prepare как есть, а не заменялись при под-
становке переменных Tcl.
spi_lastoid
Возвращает OID строки, вставленной последней командой spi_exec или spi_execp, если этой
командой был оператор INSERT с одной строкой и изменяемая таблица содержит OID. (В про-
тивном случае вы получите ноль.)
subtransaction команда
Скрипт Tcl, который содержит команда, выполняется в подтранзакции SQL. Если этот скрипт
возвращает ошибку, вся подтранзакция откатывается назад, а затем в окружающий код Tcl воз-
вращается ошибка. За дополнительными подробностями и примером обратитесь к Разделу 44.9.
quote строка
Дублирует все вхождения апострофа и обратной косой черты в заданной строке. Это можно
использовать для защиты строк, которые будут вставляться в команды SQL, передаваемые в
spi_exec или spi_prepare. Например, представьте, что при выполнении такой команды SQL:
"SELECT '$val' AS ret"
переменная языка Tcl val содержит doesn't. Это приведёт к формированию такой окончатель-
ной строки команды:
1188PL/Tcl — процедурный язык Tcl
SELECT 'doesn't' AS ret
при разборе которой в процессе spi_exec или spi_prepare возникнет ошибка. Чтобы этот за-
прос работал правильно, итоговая команда должна выглядеть так:
SELECT 'doesn''t' AS ret
Получить её в PL/Tcl можно так:
"SELECT '[ quote $val ]' AS ret"
Преимуществом spi_execp является то, что для неё заключать значения параметров в кавыч-
ки подобным образом не нужно, так как параметры никогда не разбираются в составе строки
команды SQL.
elog уровень сообщение
Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни сообщений: DEBUG
(ОТЛАДКА), LOG (СООБЩЕНИЕ), INFO (ИНФОРМАЦИЯ), NOTICE (ЗАМЕЧАНИЕ), WARNING (ПРЕ-
ДУПРЕЖДЕНИЕ), ERROR (ОШИБКА) и FATAL (ВАЖНО). С уровнем ERROR выдаётся ошибка; ес-
ли она не перехватывается окружающим кодом Tcl, она распространяется в вызывающий за-
прос, что приводит к прерыванию текущей транзакции или подтранзакции. По сути то же са-
мое делает команда error языка Tcl. Сообщение уровня FATAL прерывает транзакцию и приво-
дит к завершению текущего сеанса. (Вероятно, нет обоснованной причины использовать этот
уровень ошибок в функциях PL/Tcl, но он поддерживается для полноты.) При использовании
других уровней происходит просто вывод сообщения с заданным уровнем важности. Будут ли
сообщения определённого уровня передаваться клиенту и/или записываться в журнал, опреде-
ляется конфигурационными переменными log_min_messages и client_min_messages. За допол-
нительными сведениями обратитесь к Главе 19 и Разделу 44.8.
44.6. Триггерные функции на PL/Tcl
На PL/Tcl можно написать триггерные функции. PostgreSQL требует, чтобы функция, которая бу-
дет вызываться как триггерная, была объявлена как функция без аргументов и возвращала тип
trigger.
Информация от менеджера триггеров передаётся в тело функции в следующих переменных:
$TG_name
Имя триггера из оператора CREATE TRIGGER.
$TG_relid
Идентификатор объекта таблицы, для которой будет вызываться триггерная функция.
$TG_table_name
Имя таблицы, для которой будет вызываться триггерная функция.
$TG_table_schema
Схема таблицы, для которой будет вызываться триггерная функция.
$TG_relatts
Список языка Tcl, содержащий имена столбцов таблицы. В начало списка добавлен пустой эле-
мент, поэтому при поиске в этом списке имени столбца с помощью стандартной в Tcl коман-
ды lsearch будет возвращён номер элемента, начиная с 1, так же, как нумеруются столбцы
в PostgreSQL. (В позициях удалённых столбцов также содержатся пустые элементы, так что
нумерация следующих за ними атрибутов не нарушается.)
$TG_when
Строка BEFORE, AFTER или INSTEAD OF, в зависимости от типа события триггера.
1189PL/Tcl — процедурный язык Tcl
$TG_level
Строка ROW или STATEMENT, в зависимости от уровня события триггера.
$TG_op
Строка INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от действия события триггера.
$NEW
Ассоциативный массив, содержащий значения новой строки таблицы для действий INSERT или
UPDATE, либо пустой массив для DELETE. Индексами в массиве являются имена столбцов. Столб-
цы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора этот массив не
определяется.
$OLD
Ассоциативный массив, содержащий значения старой строки таблицы для действий UPDATE или
DELETE, либо пустой массив для INSERT. Индексами в массиве являются имена столбцов. Столб-
цы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора этот массив не
определяется.
$args
Список на языке Tcl аргументов функции, заданных в операторе CREATE TRIGGER. Эти аргументы
также доступны под обозначениями $1 ... $n в теле функции.
Возвращаемым значением триггерной функции может быть строка OK или SKIP либо список пар
имя столбца/значение. Если возвращается значение OK, операция (INSERT/UPDATE/DELETE), которая
привела к срабатыванию триггера, выполняется нормально. Значение SKIP указывает менеджеру
триггеров просто пропустить эту операцию с текущей строкой данных. Если возвращается список,
через него PL/Tcl передаёт менеджеру триггеров изменённую строку; содержимое изменённой
строки задаётся именами и значениями столбцов в списке. Все столбцы, не перечисленные в этом
списке, получают значения NULL. Возвращать изменённую строку имеет смысл только для триг-
геров уровня строки с порядком BEFORE команд INSERT и UPDATE, в которых вместо заданной в $NEW
будет записываться изменённая строка; либо с порядком INSTEAD OF команд INSERT и UPDATE, в ко-
торых возвращаемая строка служит исходными данными для предложений INSERT RETURNING или
UPDATE RETURNING. В триггерах уровня строки с порядком BEFORE или INSTEAD OF команды DELETE
возврат изменённой строки воспринимается так же, как и возврат значения OK, то есть операция
выполняется. Для всех остальных типов триггеров возвращаемое значение игнорируется.
Подсказка
Список результатов можно создать из изменённого кортежа, представленного в виде
массива, с помощью команды array get языка Tcl.
Следующий небольшой пример показывает триггерную функцию, которая ведёт в таблице цело-
численный счётчик числа изменений, выполненных в строке. Для новых строк счётчик инициали-
зируется нулевым значением, а затем увеличивается на единицу при каждом изменении.
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS</script>
switch $TG_op {
INSERT {
set NEW($1) 0
}
UPDATE {
set NEW($1) $OLD($1)
incr NEW($1)
}
default {
1190PL/Tcl — процедурный язык Tcl
return OK
}
}
return [array get NEW]
<script type="math/tex">LANGUAGE pltcl;
CREATE TABLE mytab (num integer, description text, modcnt integer);
CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
Заметьте, что сама триггерная функция не знает имени столбца; оно передаётся в аргументах
триггера. Это позволяет применять эту функцию для различных таблиц.
44.7. Функции событийных триггеров в PL/Tcl
На PL/Tcl можно написать функции событийных триггеров. PostgreSQL требует, чтобы функция,
которая будет вызываться как событийный триггер, была объявлена как функция без аргументов
и возвращала тип event_trigger.
Информация от менеджера триггеров передаётся в тело функции в следующих переменных:
$TG_event
Имя события, при котором срабатывает этот триггер.
$TG_tag
Тег команды, для которой срабатывает этот триггер.
Возвращаемое значение триггерной функции игнорируется.
В этом примере мини-функция событийного триггера просто выдаёт замечание (NOTICE) при каж-
дом выполнении поддерживаемой команды:
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS</script>
elog NOTICE “tclsnitch: $TG_event $TG_tag”
$$ LANGUAGE pltcl;
CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
44.8. Обработка ошибок в PL/Tcl
Tcl-код, содержащийся или вызываемый из функции PL/Tcl, может выдавать ошибку либо выполняя
недопустимую операцию, либо генерируя ошибку с помощью команды error языка Tcl или коман-
ды elog языка PL/Tcl. Такие ошибки могут быть перехвачены в среде Tcl с помощью команды Tcl
catch. Если ошибка не перехватывается, а распространяется выше уровня выполнения функций
PL/Tcl, она передаётся в запрос, вызвавший функцию, как ошибка SQL.
И напротив, ошибки СУБД, возникающие внутри команд spi_exec, spi_prepare и spi_execp в сре-
де PL/Tcl, выдаются как ошибки Tcl, так что их можно перехватить командой Tcl catch. (Каждая
из этих команд PL/Tcl выполняет SQL-операцию в подтранзакции, которая откатывается в слу-
чае ошибки, так что для частично завершённых операций производится автоматическая очистка.)
Опять же, если ошибка не перехватывается и распространяется выше верхнего уровня, она стано-
вится ошибкой SQL.
В Tcl имеется переменная errorCode, представляющая дополнительную информацию об ошибке
в виде, удобном для обработки в программах на Tcl. Эта информация передаётся в формате спис-
ка Tcl, первое слово в котором указывает на подсистему или библиотеку, выдающую ошибку; по-
следующее содержимое определяется в зависимости от подсистемы или библиотеки. Для ошибок
СУБД, возникающих в командах PL/Tcl, первым словом будет POSTGRES, вторым — номер версии
PostgreSQL, а дополнительные слова представляют пары имя/значения, передающие подробную
1191PL/Tcl — процедурный язык Tcl
информацию об ошибке. В этих парах всегда передаются поля SQLSTATE, condition и message (пер-
вые два представляют код ошибки и имя условия, как описано в Приложении  A). Также могут
передаваться поля detail, hint, context, schema, table, column, datatype, constraint, statement,
cursor_position, filename, lineno и funcname.
С информацией в переменной errorCode среды PL/Tcl удобно работать, загрузив переменную в
массив, чтобы имена полей стали индексами в массиве. Пример такого кода:
if {[catch { spi_exec $sql_command }]} {
if {[lindex $::errorCode 0] == “POSTGRES”} {
array set errorArray $::errorCode
if {$errorArray(condition) == “undefined_table”} {</p>
<h1 id="разобраться-с-отсутствием-таблицы">разобраться с отсутствием таблицы</h1>
<p>} else {</p>
<h1 id="разобраться-с-другими-типами-ошибок-sql">разобраться с другими типами ошибок SQL</h1>
<p>}
}
}
(Двойные двоеточия явно указывают, что переменная errorCode является глобальной.)
44.9. Явные подтранзакции в PL/Tcl
Перехват ошибок, произошедших при обращении к базе данных, как описано в Разделе 44.8, может
привести к нежелательной ситуации, когда часть операций будет успешно выполнена, прежде чем
произойдёт сбой. Данные останутся в несогласованном состоянии после обработки такой ошибки.
PL/Tcl предлагает решение этой проблемы в форме явных подтранзакций.
Рассмотрите функцию, реализующую перевод денег между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS <script type="math/tex">if [catch {
spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'"
spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'"
} errormsg] {
set result [format "error transferring funds: %s" $errormsg]
} else {
set result "funds transferred successfully"
}
spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"</script> LANGUAGE pltcl;
Если второй оператор UPDATE выдаст исключение, эта функция запишет в журнал сообщение об
ошибке, но результат первого UPDATE будет тем не менее зафиксирован. Другими словами, денеж-
ные средства будут списаны со счёта Джо, но не поступят на счёт Мери. Это происходит потому,
что каждый вызов spi_exec выполняется в отдельной подтранзакции, а откатывается только одна
из подтранзакций.
В таких случаях вы можете обернуть несколько операций с базой данных в одну явную подтран-
закцию, которая будет выполнена успешно или отменена как единое целое. Для этого в PL/Tcl есть
команда subtransaction. С ней мы можем переписать нашу функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS <script type="math/tex">if [catch {
subtransaction {
spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'"
spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'"
1192PL/Tcl — процедурный язык Tcl
}
} errormsg] {
set result [format "error transferring funds: %s" $errormsg]
} else {
set result "funds transferred successfully"
}
spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"</script> LANGUAGE pltcl;
Заметьте, что и в этом случае нужно использовать catch. В противном случае ошибка распростра-
нится на верхний уровень функции, что не даст произвести желаемое добавление записи в табли-
цу operations. Команда subtransaction не перехватывает ошибки, она только обеспечивает откат
всех операций с базой данных в своей области действия в случае ошибки.
Откат явной подтранзакции происходит в случае любых ошибок, сгенерированных вложенным ко-
дом Tcl, а не только ошибок, возникающих при обращении к базе данных. Таким образом, обычное
исключение Tcl, возникшее внутри команды subtransaction, также приведёт к откату подтран-
закции. Однако при выходе из вложенного кода Tcl без ошибки (например, с помощью команды
return) откат не производится.
44.10. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в команде
DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, выполните ко-
манду commit, а чтобы откатить — rollback. (Заметьте, что выполнить SQL-команды COMMIT или
ROLLBACK через spi_exec или подобную функцию нельзя. Соответствующие операции могут выпол-
няться только данными функциями.) После завершения одной транзакции следующая начинается
автоматически, отдельной функции для этого нет.
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS <script type="math/tex">% <![CDATA[
for {set i 0} {$i < 10} {incr i} {
spi_exec "INSERT INTO test1 (a) VALUES ($i)"
if {$i % 2 == 0} {
commit
} else {
rollback
}
} %]]></script>;
CALL transaction_test1();
Транзакции не могут завершаться, когда имеется открытая явная подтранзакция.
44.11. Конфигурация PL/Tcl
В этом разделе описываются параметры конфигурации, влияющие на работу PL/Tcl.
pltcl.start_proc (string)
В этом параметре, если он не пуст, задаётся имя (возможно, дополненное схемой) функции на
языке PL/Tcl без параметров, которая будет выполняться, когда для PL/Tcl будет создаваться
новый экземпляр Tcl. Такая функция может выполнять инициализацию в рамках сеанса, напри-
мер, загружать дополнительный код Tcl. Новый интерпретатор Tcl создаётся при первом выпол-
нении какой-либо функции PL/Tcl в сеансе базы данных или когда требуется дополнительный
интерпретатор из-за того, что функция PL/Tcl была вызвана новой ролью SQL.
1193PL/Tcl — процедурный язык Tcl
Указанная функция должна быть написана на языке pltcl и не должна иметь свойство SECURITY
DEFINER. (Благодаря этим ограничениям эта функция будет запускаться в интерпретаторе, ко-
торый она должна инициализировать.) Текущий пользователь должен иметь право и на её вы-
полнение тоже.
Если эта функция завершится ошибкой, эта ошибка прервёт вызов функции, которой потребо-
вался новый интерпретатор, и распространится в вызывающий запрос, приводя к прерыванию
текущей транзакции или подтранзакции. Любые действия, уже произведённые в среде Tcl, от-
менены не будут; однако этот интерпретатор более не будет использоваться. При следующей
попытке использования этого языка последует повторная попытка инициализации со свежим
интерпретатором Tcl.
Изменять этот параметр разрешено только суперпользователям. Хотя изменить его можно в
рамках сеанса, такие изменения не повлияют на работу интерпретаторов Tcl, созданных ранее.
pltclu.start_proc (string)
Это параметр полностью аналогичен pltcl.start_proc, но применяется к PL/TclU. Указанная
функция должна быть написана на языке pltclu.
44.12. Имена процедур Tcl
В PostgreSQL одно имя функции может использоваться разными определениями функций, если
они имеют разное число и типы аргументов. Tcl, однако, требует, чтобы имена всех процедур раз-
личались. PL/Tcl решает эту проблему, устанавливая такие внутренние имена процедур Tcl, чтобы
они включали в свой состав OID функции из системной таблицы pg_proc. Таким образом, функци-
ям PostgreSQL с одним именем и разными типами аргументов так же будут соответствовать раз-
личные процедуры Tcl. Это обычно остаётся незамеченным для программиста PL/Tcl, но может
проявиться при отладке.
1194</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-043/" title="Глава 43. PL/pgSQL — процедурный язык SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 43. PL/pgSQL — процедурный язык SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-043/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~84 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-043/" rel="bookmark" title="Глава 43. PL/pgSQL — процедурный язык SQL" itemprop="url">Глава 43. PL/pgSQL — процедурный язык SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 43. PL/pgSQL — процедурный язык SQL</p>

<p>43.1. Обзор
PL/pgSQL это процедурный язык для СУБД PostgreSQL. Целью проектирования PL/pgSQL было
создание загружаемого процедурного языка, который:
• используется для создания функций и триггеров,
• добавляет управляющие структуры к языку SQL,
• может выполнять сложные вычисления,
• наследует все пользовательские типы, функции и операторы,
• может быть определён как доверенный язык,
• прост в использовании.
Функции PL/pgSQL могут использоваться везде, где допустимы встроенные функции. Например,
можно создать функции со сложными вычислениями и условной логикой, а затем использовать их
при определении операторов или в индексных выражениях.
В версии PostgreSQL 9.0 и выше, PL/pgSQL устанавливается по умолчанию. Тем не менее, это по-
прежнему загружаемый модуль и администраторы, особо заботящиеся о безопасности, могут уда-
лить его при необходимости.
43.1.1. Преимущества использования PL/pgSQL
PostgreSQL и большинство других СУБД используют SQL в качестве языка запросов. SQL хорошо
переносим и прост в изучении. Однако каждый оператор SQL выполняется индивидуально на сер-
вере базы данных.
Это значит, что ваше клиентское приложение должно каждый запрос отправлять на сервер, ждать
пока он будет обработан, получать результат, делать некоторые вычисления, затем отправлять
последующие запросы на сервер. Всё это требует межпроцессного взаимодействия, а также несёт
нагрузку на сеть, если клиент и сервер базы данных расположены на разных компьютерах.
PL/pgSQL позволяет сгруппировать блок вычислений и последовательность запросов внутри сер-
вера базы данных, таким образом, мы получаем силу процедурного языка и простоту использова-
ния SQL при значительной экономии накладных расходов на клиент-серверное взаимодействие.
• Исключаются дополнительные обращения между клиентом и сервером
• Промежуточные ненужные результаты не передаются между сервером и клиентом
• Есть возможность избежать многочисленных разборов одного запроса
В результате это приводит к значительному увеличению производительности по сравнению с при-
ложением, которое не использует хранимых функций.
Кроме того, PL/pgSQL позволяет использовать все типы данных, операторы и функции SQL.
43.1.2. Поддерживаемые типы данных аргументов и возвращае-
мых значений
Функции на PL/pgSQL могут принимать в качестве аргументов все поддерживаемые сервером ска-
лярные типы данных или массивы и возвращать в качестве результата любой из этих типов. Они
могут принимать и возвращать именованные составные типы (типы строк таблицы). Также есть
возможность объявить функцию на PL/pgSQL как принимающую record, то есть ей может быть
передан любой составной тип, или как возвращающую record, то есть её результатом будет стро-
ковый тип, столбцы которого определит спецификация вызывающего запроса, как описано в Под-
разделе 7.2.1.4.
1124PL/pgSQL — проце-
дурный язык SQL
Использование маркера VARIADIC позволяет объявлять функции на PL/pgSQL с переменным чис-
лом аргументов. Это работает точно так же, как и для функций на SQL, как описано в Подразде-
ле 38.5.5.
Функции на PL/pgSQL могут принимать и возвращать полиморфные типы anyelement, anyarray,
anynonarray, anyenum и anyrange. В таких случаях фактические типы данных могут меняться от
вызова к вызову, как описано в Подраздел 38.2.5. Пример показан в Подразделе 43.3.1.
Функции на PL/pgSQL могут возвращать «множества» (или таблицы) любого типа, которые могут
быть возвращены в виде одного объекта. Такие функции генерируют вывод, выполняя команду
RETURN NEXT для каждого элемента результирующего набора или RETURN QUERY для вывода резуль-
тата запроса.
Наконец, при отсутствии полезного возвращаемого значения функция на PL/pgSQL может возвра-
щать void. (С другой стороны, её также можно оформить в виде процедуры.)
Функции на PL/pgSQL можно объявить с выходными параметрами вместо явного задания типа воз-
вращаемого значения. Это не добавляет никаких фундаментальных возможностей языку, но часто
бывает удобно, особенно для возвращения нескольких значений. Нотация RETURNS TABLE может
использоваться вместо RETURNS SETOF.
Конкретные примеры рассматриваются в Подразделе 43.3.1 и Подразделе 43.6.1.
43.2. Структура PL/pgSQL
Функции, написанные на PL/pgSQL, определяются на сервере командами CREATE FUNCTION. Та-
кая команда обычно выглядит, например, так:
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS ‘тело функции’
LANGUAGE plpgsql;
Если рассматривать CREATE FUNCTION, тело функции представляет собой просто текстовую стро-
ку. Часто для написания тела функции удобнее заключать эту строку в доллары (см. Подраз-
дел 4.1.2.4), а не в обычные апострофы. Если не применять заключение в доллары, все апострофы
или обратные косые черты в теле функции придётся экранировать, дублируя их. Почти во всех
примерах в этой главе тело функций заключается в доллары.
PL/pgSQL это блочно-структурированный язык. Текст тела функции должен быть блоком. Струк-
тура блока:
[ «метка» ]
[ DECLARE
объявления ]
BEGIN
операторы
END [ метка ];
Каждое объявление и каждый оператор в блоке должны завершаться символом “;”(точка с запя-
той). Блок, вложенный в другой блок, должен иметь точку с запятой после END, как показано выше.
Однако финальный END, завершающий тело функции, не требует точки с запятой.
Подсказка
Распространённой ошибкой является добавление точки с запятой сразу после BEGIN.
Это неправильно и приведёт к синтаксической ошибке.
Метка требуется только тогда, когда нужно идентифицировать блок в операторе EXIT, или допол-
нить имена переменных, объявленных в этом блоке. Если метка указана после END, то она должна
совпадать с меткой в начале блока.
1125PL/pgSQL — проце-
дурный язык SQL
Ключевые слова не чувствительны к регистру символов. Как и в обычных SQL-командах, иденти-
фикаторы неявно преобразуются к нижнему регистру, если они не взяты в двойные кавычки.
Комментарии в PL/pgSQL коде работают так же, как и в обычном SQL. Двойное тире (–) начина-
ет комментарий, который завершается в конце строки. Блочный комментарий начинается с /* и
завершается <em>/. Блочные комментарии могут быть вложенными.
Любой оператор в выполняемой секции блока может быть вложенным блоком. Вложенные блоки
используются для логической группировки нескольких операторов или локализации области дей-
ствия переменных для группы операторов. Во время выполнения вложенного блока переменные,
объявленные в нём, скрывают переменные внешних блоков с такими же именами. Чтобы получить
доступ к внешним переменным, нужно дополнить их имена меткой блока. Например:
CREATE FUNCTION somefunc() RETURNS integer AS <script type="math/tex">% <![CDATA[
<< outerblock >>
DECLARE
quantity integer := 30;
BEGIN
RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 30
quantity := 50;
--
-- Вложенный блок
--
DECLARE
quantity integer := 80;
BEGIN
RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 80
RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;
Выводится 50
END;
RAISE NOTICE 'Сейчас quantity = %', quantity;
--
-- Выводится 50
RETURN quantity;
END; %]]></script> LANGUAGE plpgsql;
Примечание
Существует скрытый «внешний блок», окружающий тело каждой функции на PL/
pgSQL. Этот блок содержит объявления параметров функции (если они есть), а также
некоторые специальные переменные, такие как FOUND (см. Подраздел 43.5.5). Этот блок
имеет метку, совпадающую с именем функции, таким образом, параметры и специаль-
ные переменные могут быть дополнены именем функции.
Важно не путать использование BEGIN/END для группировки операторов в PL/pgSQL с одноимённы-
ми SQL-командами для управления транзакциями. BEGIN/END в PL/pgSQL служат только для груп-
пировки предложений; они не начинают и не заканчивают транзакции. Управление транзакция-
ми в PL/pgSQL описывается в Разделе 43.8. Кроме того, блок с предложением EXCEPTION по сути
создаёт вложенную транзакцию, которую можно отменить, не затрагивая внешнюю транзакцию.
Подробнее это описано в Подразделе 43.6.8.
43.3. Объявления
Все переменные, используемые в блоке, должны быть определены в секции объявления. (За ис-
ключением переменной-счётчика цикла FOR, которая объявляется автоматически. Для цикла по
диапазону чисел автоматически объявляется целочисленная переменная, а для цикла по резуль-
татам курсора - переменная типа record.)
1126PL/pgSQL — проце-
дурный язык SQL
Переменные PL/pgSQL могут иметь любой тип данных SQL, такой как integer, varchar, char.
Примеры объявления переменных:
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
Общий синтаксис объявления переменной:
имя [ CONSTANT ] тип [ COLLATE имя_правила_сортировки ] [ NOT NULL ] [ { DEFAULT | := |
= } выражение ];
Предложение DEFAULT, если присутствует, задаёт начальное значение, которое присваивается пе-
ременной при входе в блок. Если отсутствует, то переменная инициализируется SQL-значением
NULL. Указание CONSTANT предотвращает изменение значения переменной после инициализации,
таким образом, значение остаётся постоянным в течение всего блока. Параметр COLLATE определя-
ет правило сортировки, которое будет использоваться для этой переменной (см. Подраздел 43.3.6).
Если указано NOT NULL, то попытка присвоить NULL во время выполнения приведёт к ошибке. Все
переменные, объявленные как NOT NULL, должны иметь непустые значения по умолчанию. Можно
использовать знак равенства (=) вместо совместимого с PL/SQL :=.
Значение по умолчанию вычисляется и присваивается переменной каждый раз при входе в блок
(не только при первом вызове функции). Так, например, если переменная типа timestamp имеет
функцию now() в качестве значения по умолчанию, это приведёт к тому, что переменная всегда
будет содержать время текущего вызова функции, а не время, когда функция была предварительно
скомпилирована.
Примеры:
quantity integer DEFAULT 32;
url varchar := ‘http://mysite.com’;
user_id CONSTANT integer := 10;
43.3.1. Объявление параметров функции
Переданные в функцию параметры именуются идентификаторами $1, $2 и т. д. Дополнительно, для
улучшения читаемости, можно объявить псевдонимы для параметров $n. Либо псевдоним, либо
цифровой идентификатор используются для обозначения параметра.
Создать псевдоним можно двумя способами. Предпочтительный способ это дать имя параметру в
команде CREATE FUNCTION, например:
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS <script type="math/tex">BEGIN
RETURN subtotal * 0.06;
END;</script> LANGUAGE plpgsql;
Другой способ это явное объявление псевдонима при помощи синтаксиса:
имя ALIAS FOR $n;
Предыдущий пример для этого стиля выглядит так:
CREATE FUNCTION sales_tax(real) RETURNS real AS <script type="math/tex">DECLARE
subtotal ALIAS FOR $1;
BEGIN
RETURN subtotal * 0.06;
END;
1127PL/pgSQL — проце-
дурный язык SQL</script> LANGUAGE plpgsql;
Примечание
Эти два примера не полностью эквивалентны. В первом случае, на subtotal можно
ссылаться как sales_tax.subtotal, а во втором случае такая ссылка невозможна. (Ес-
ли бы к внутреннему блоку была добавлена метка, то subtotal можно было бы допол-
нить этой меткой.)
Ещё несколько примеров:
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS <script type="math/tex">DECLARE
v_string ALIAS FOR $1;
index ALIAS FOR $2;
BEGIN
-- вычисления, использующие v_string и index
END;</script> LANGUAGE plpgsql;
CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS <script type="math/tex">BEGIN
RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;</script> LANGUAGE plpgsql;
Когда функция на PL/pgSQL объявляется с выходными параметрами, им выдаются цифровые иден-
тификаторы $n и для них можно создавать псевдонимы точно таким же способом, как и для обыч-
ных входных параметров. Выходной параметр это фактически переменная, стартующая с NULL
и которой присваивается значение во время выполнения функции. Возвращается последнее при-
своенное значение. Например, функция sales_tax может быть переписана так:
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS <script type="math/tex">BEGIN
tax := subtotal * 0.06;
END;</script> LANGUAGE plpgsql;
Обратите внимание, что мы опустили RETURNS real — хотя можно было и включить, но это было
бы излишним.
Выходные параметры наиболее полезны для возвращения нескольких значений. Простейший при-
мер:
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS <script type="math/tex">BEGIN
sum := x + y;
prod := x * y;
END;</script> LANGUAGE plpgsql;
Как обсуждалось в Подразделе 38.5.4, здесь фактически создаётся анонимный тип record для воз-
вращения результата функции. Если используется предложение RETURNS, то оно должна выглядеть
как RETURNS record.
Есть ещё способ объявить функцию на PL/pgSQL с использованием RETURNS TABLE, например:
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS <script type="math/tex">1128PL/pgSQL — проце-
дурный язык SQL
BEGIN
RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s
WHERE s.itemno = p_itemno;
END;</script> LANGUAGE plpgsql;
Это в точности соответствует объявлению одного или нескольких параметров OUT и указанию
RETURNS SETOF некий_тип.
Для функции на PL/pgSQL, возвращающей полиморфный тип (anyelement, anyarray, anynonarray,
anyenum, anyrange), создаётся специальный параметр $0. Его тип данных соответствует типу, фак-
тически возвращаемому функцией, и который устанавливается на основании фактических типов
входных параметров (см. Подраздел 38.2.5). Это позволяет функции получить доступ к фактически
возвращаемому типу данных, как показано в Подразделе 43.3.3. Параметр $0 инициализируется в
NULL и его можно изменять внутри функции. Таким образом, его можно использовать для хранения
возвращаемого значения, хотя это необязательно. Параметру $0 можно дать псевдоним. В следу-
ющем примере функция работает с любым типом данных, поддерживающим оператор +:
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS <script type="math/tex">DECLARE
result ALIAS FOR $0;
BEGIN
result := v1 + v2 + v3;
RETURN result;
END;</script> LANGUAGE plpgsql;
Такой же эффект получается при объявлении одного или нескольких выходных параметров поли-
морфного типа. При этом $0 не создаётся; выходные параметры сами используются для этой цели.
Например:
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
OUT sum anyelement)
AS <script type="math/tex">BEGIN
sum := v1 + v2 + v3;
END;</script> LANGUAGE plpgsql;
43.3.2. ALIAS
новое_имя ALIAS FOR старое_имя;
Синтаксис ALIAS более общий, чем предполагалось в предыдущем разделе: псевдонимы можно
объявлять для любых переменных, а не только для параметров функции. Основная практическая
польза в том, чтобы назначить другие имена переменным с предопределёнными названиями, та-
ким как NEW или OLD в триггерной функции.
Примеры:
DECLARE
prior ALIAS FOR old;
updated ALIAS FOR new;
Поскольку ALIAS даёт два различных способа именования одних и тех же объектов, то его неогра-
ниченное использование может привести к путанице. Лучше всего использовать ALIAS для пере-
именования предопределённых имён.
43.3.3. Наследование типов данных
переменная%TYPE
1129PL/pgSQL — проце-
дурный язык SQL
Конструкция %TYPE предоставляет тип данных переменной или столбца таблицы. Её можно исполь-
зовать для объявления переменных, содержащих значения из базы данных. Например, для объяв-
ления переменной с таким же типом, как и столбец user_id в таблице users нужно написать:
user_id users.user_id%TYPE;
Используя %TYPE, не нужно знать тип данных структуры, на которую вы ссылаетесь. И самое глав-
ное, если в будущем тип данных изменится (например: тип данных для user_id поменяется с
integer на real), то вам может не понадобиться изменять определение функции.
Использование %TYPE особенно полезно в полиморфных функциях, поскольку типы данных, необ-
ходимые для внутренних переменных, могут меняться от одного вызова к другому. Соответствую-
щие переменные могут быть созданы с применением %TYPE к аргументам и возвращаемому значе-
нию функции.
43.3.4. Типы кортежей
имя имя_таблицы%ROWTYPE;
имя имя_составного_типа;
Переменная составного типа называется строковой переменной (или переменной типа строки).
Значением такой переменной может быть целая строка, полученная в результате выполнения за-
проса SELECT или FOR, при условии, что набор столбцов запроса соответствует заявленному типу
переменной. Доступ к отдельным значениям полей строковой переменной осуществляется, как
обычно, через точку, например rowvar.field.
Строковая переменная может быть объявлена с таким же типом, как и строка в существующей
таблице или представлении, используя нотацию имя_таблицы%ROWTYPE; или с именем составного
типа. (Поскольку каждая таблица имеет соответствующий составной тип с таким же именем, то
на самом деле в PostgreSQL не имеет значения, пишете ли вы %ROWTYPE или нет. Но использование
%ROWTYPE более переносимо.)
Параметры функции могут быть составного типа (строки таблицы). В этом случае соответствую-
щий идентификатор $n будет строковой переменной, поля которой можно выбирать, например
$1.user_id.
Ниже приведён пример использования составных типов. table1 и table2 это существующие таб-
лицы, имеющие, по меньшей мере, перечисленные столбцы:
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS <script type="math/tex">DECLARE
t2_row table2%ROWTYPE;
BEGIN
SELECT * INTO t2_row FROM table2 WHERE ... ;
RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;</script> LANGUAGE plpgsql;
SELECT merge_fields(t.</em>) FROM table1 t WHERE … ;
43.3.5. Тип record
имя RECORD;
Переменные типа record похожи на переменные строкового типа, но они не имеют предопреде-
лённой структуры. Они приобретают фактическую структуру от строки, которая им присваивается
командами SELECT или FOR. Структура переменной типа record может меняться каждый раз при
присвоении значения. Следствием этого является то, что пока значение не присвоено первый раз,
переменная типа record не имеет структуры и любая попытка получить доступ к отдельному полю
приведёт к ошибке во время исполнения.
1130PL/pgSQL — проце-
дурный язык SQL
Обратите внимание, что RECORD это не подлинный тип данных, а только лишь заполнитель. Также
следует понимать, что функция на PL/pgSQL, имеющая тип возвращаемого значения record, это
не то же самое, что и переменная типа record, хотя такая функция может использовать перемен-
ную типа record для хранения своего результата. В обоих случаях фактическая структура стро-
ки неизвестна во время создания функции, но для функции, возвращающей record, фактическая
структура определяется во время разбора вызывающего запроса, в то время как переменная типа
record может менять свою структуру на лету.
43.3.6. Упорядочение переменных PL/pgSQL
Когда функция на PL/pgSQL имеет один или несколько параметров сортируемых типов данных,
правило сортировки определяется при каждом вызове функции в зависимости от правил сортиров-
ки фактических аргументов, как описано в Разделе 23.2. Если оно определено успешно (т. е. сре-
ди аргументов нет конфликтов между неявными правилами сортировки), то все соответствующие
параметры неявно трактуются как имеющее это правило сортировки. Внутри функции это будет
влиять на поведение операторов, зависящих от используемого правила сортировки. Рассмотрим
пример:
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS <script type="math/tex">% <![CDATA[
BEGIN
RETURN a < b;
END; %]]></script> LANGUAGE plpgsql;
SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE “C”) FROM table1;
В первом случае less_than будет использовать для сравнения общее правило сортировки для
text_field_1 и text_field_2, в то время как во втором случае будет использоваться правило C.
Кроме того, определённое для вызова функции правило сортировки также будет использоваться
для любых локальных переменных соответствующего типа. Таким образом, функция не станет ра-
ботать по-другому, если её переписать так:
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS <script type="math/tex">% <![CDATA[
DECLARE
local_a text := a;
local_b text := b;
BEGIN
RETURN local_a < local_b;
END; %]]></script> LANGUAGE plpgsql;
Если параметров с типами данных, поддерживающими сортировку, нет, или для параметров невоз-
можно определить общее правило сортировки, тогда для параметров и локальных переменных
применяются правила, принятые для их типа данных по умолчанию (которые обычно совпадают
с правилами сортировки по умолчанию, принятыми для базы данных, но могут отличаться для пе-
ременных доменных типов).
Локальная переменная может иметь правило сортировки, отличное от правила по умолчанию. Для
этого используется параметр COLLATE в объявлении переменной, например:
DECLARE
local_a text COLLATE “en_US”;
Этот параметр переопределяет правило сортировки, которое получила бы переменная в соответ-
ствии с вышеуказанными правилами.
И, конечно же, можно явно указывать параметр COLLATE для конкретных операций внутри функ-
ции, если к ним требуется применить конкретное правило сортировки. Например:
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS <script type="math/tex">% <![CDATA[
1131PL/pgSQL — проце-
дурный язык SQL
BEGIN
RETURN a < b COLLATE "C";
END; %]]></script> LANGUAGE plpgsql;
Как и в обычной SQL-команде, это переопределяет правила сортировки, связанные с полями таб-
лицы, параметрами и локальными переменными, которые используются в данном выражении.
43.4. Выражения
Все выражения, используемые в операторах PL/pgSQL, обрабатываются основным исполнителем
SQL-сервера. Например, для вычисления такого выражения:
IF выражение THEN …
PL/pgSQL отправит следующий запрос исполнителю SQL:
SELECT выражение
При формировании команды SELECT все вхождения имён переменных PL/pgSQL заменяются пара-
метрами, как подробно описано в Подразделе 43.11.1. Это позволяет один раз подготовить план
выполнения команды SELECT и повторно использовать его в последующих вычислениях с различ-
ными значениями переменных. Таким образом, при первом использовании выражения, по сути
происходит выполнение команды PREPARE. Например, если мы объявили две целочисленные пере-
менные x и y, и написали:
IF x &lt; y THEN …
то, что реально происходит за сценой, эквивалентно:
PREPARE имя_оператора(integer, integer) AS SELECT $1 &lt; $2;
и затем, эта подготовленная команда исполняется (EXECUTE) для каждого оператора IF с текущими
значениями переменных PL/pgSQL, переданных как значения параметров. Обычно эти детали не
важны для пользователей PL/pgSQL, но их полезно знать при диагностировании проблем. Более
подробно об этом рассказывается в Подразделе 43.11.2.
43.5. Основные операторы
В этом и последующих разделах описаны все типы операторов, которые понимает PL/pgSQL. Все,
что не признается в качестве одного из этих типов операторов, считается командой SQL и отправ-
ляется для исполнения в основную машину базы данных, как описано в Подразделе 43.5.2 и Под-
разделе 43.5.3.
43.5.1. Присваивания
Присвоение значения переменной PL/pgSQL записывается в виде:
переменная { := | = } выражение;
Как описывалось ранее, выражение в таком операторе вычисляется с помощью SQL-команды
SELECT, посылаемой в основную машину базы данных. Выражение должно получить одно значение
(возможно, значение строки, если переменная строкового типа или типа record). Целевая пере-
менная может быть простой переменной (возможно, дополненной именем блока), полем в пере-
менной строкового типа или записи; или элементом массива, который является простой перемен-
ной или полем. Для присвоения можно использовать знак равенства (=) вместо совместимого с PL/
SQL :=.
Если тип данных результата выражения не соответствует типу данных переменной, это значе-
ние будет преобразовано к нужному типу с использованием приведения присваивания (см. Раз-
дел 10.4). В случае отсутствия приведения присваивания для этой пары типов, интерпретатор PL/
pgSQL попытается преобразовать значение результата через текстовый формат, то есть применив
функцию вывода типа результата, а за ней функцию ввода типа переменной. Заметьте, что при
1132PL/pgSQL — проце-
дурный язык SQL
этом функция ввода может выдавать ошибки времени выполнения, если не воспримет строковое
представление значения результата.
Примеры:
tax := subtotal * 0.06;
my_record.user_id := 20;
43.5.2. Выполнение команды, не возвращающей результат
В функции на PL/pgSQL можно выполнить любую команду SQL, не возвращающую строк, просто
написав эту команду (например, INSERT без предложения RETURNING).
Имя любой переменной PL/pgSQL в тексте команды рассматривается как параметр, а затем теку-
щее значение переменной подставляется в качестве значения параметра во время выполнения.
Это в точности совпадает с описанной ранее обработкой для выражений; за подробностями обра-
титесь к Подразделу 43.11.1.
При выполнении SQL-команды таким образом, PL/pgSQL может кешировать и повторно использо-
вать план выполнения команды, как обсуждается в Подразделе 43.11.2.
Иногда бывает полезно вычислить значение выражения или запроса SELECT, но отказаться от ре-
зультата, например, при вызове функции, у которой есть побочные эффекты, но нет полезного ре-
зультата. Для этого в PL/pgSQL, используется оператор PERFORM:
PERFORM запрос;
Эта команда выполняет запрос и отбрасывает результат. Запросы пишутся таким же образом, как
и в команде SQL SELECT, но ключевое слово SELECT заменяется на PERFORM. Для запросов WITH по-
сле PERFORM нужно поместить запрос в скобки. (В этом случае запрос может вернуть только одну
строку.) Переменные PL/pgSQL будут подставлены в запрос так же, как и в команду, не возвра-
щающую результат, план запроса также кешируется. Кроме того, специальная переменная FOUND
устанавливается в истину, если запрос возвращает, по крайней мере, одну строку, или ложь, если
не возвращает ни одной строки (см. Подраздел 43.5.5).
Примечание
Можно предположить, что такой же результат получается непосредственно командой
SELECT, но в настоящее время использование PERFORM является единственным спосо-
бом. Команда SQL, которая может возвращать строки, например SELECT, будет откло-
нена с ошибкой, если не имеет предложения INTO, как описано в следующем разделе.
Пример:
PERFORM create_mv(‘cs_session_page_requests_mv’, my_query);
43.5.3. Выполнение запроса, возвращающего одну строку
Результат SQL-команды, возвращающей одну строку (возможно из нескольких столбцов), может
быть присвоен переменной типа record, переменной строкового типа или списку скалярных пере-
менных. Для этого нужно к основной команде SQL добавить предложение INTO. Так, например:
SELECT
INSERT
UPDATE
DELETE
выражения_select INTO [STRICT] цель FROM …;
… RETURNING выражения INTO [STRICT] цель;
… RETURNING выражения INTO [STRICT] цель;
… RETURNING выражения INTO [STRICT] цель;
где цель может быть переменной типа record, строковой переменной или разделённым запяты-
ми списком скалярных переменных, полей записи/строки. Переменные PL/pgSQL подставляются
1133PL/pgSQL — проце-
дурный язык SQL
в оставшуюся часть запроса, план выполнения кешируется, так же, как было описано выше для
команд, не возвращающих строки. Это работает для команд SELECT, INSERT/UPDATE/DELETE с пред-
ложением RETURNING и утилит, возвращающих результат в виде набора строк (таких, как EXPLAIN).
За исключением предложения INTO, это те же SQL-команды, как их можно написать вне PL/pgSQL.
Подсказка
Обратите внимание, что данная интерпретация SELECT с INTO полностью отличается от
PostgreSQL команды SELECT INTO, где в INTO указывается вновь создаваемая таблица.
Если вы хотите в функции на PL/pgSQL создать таблицу, основанную на результате
команды SELECT, используйте синтаксис CREATE TABLE … AS SELECT.
Если результат запроса присваивается переменной строкового типа или списку переменных, то
они должны в точности соответствовать по количеству и типам данных столбцам результата, ина-
че произойдёт ошибка во время выполнения. Если используется переменная типа record, то она
автоматически приводится к строковому типу результата запроса.
Предложение INTO может появиться практически в любом месте SQL-команды. Обычно его запи-
сывают непосредственно перед или сразу после списка выражения_select в SELECT или в конце
команды для команд других типов. Рекомендуется следовать этому соглашению на случай, если
правила разбора PL/pgSQL ужесточатся в будущих версиях.
Если указание STRICT отсутствует в предложении INTO, то цели присваивается первая строка, воз-
вращённая запросом; или NULL, если запрос не вернул строк. (Заметим, что понятие «первая стро-
ка» определяется неоднозначно без ORDER BY.) Все остальные строки результата после первой
отбрасываются. Можно проверить специальную переменную FOUND (см. Подраздел 43.5.5), чтобы
определить, была ли возвращена запись:
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
RAISE EXCEPTION ‘Сотрудник % не найден’, myname;
END IF;
Если добавлено указание STRICT, то запрос должен вернуть ровно одну строку или произойдёт
ошибка во время выполнения: либо NO_DATA_FOUND (нет строк), либо TOO_MANY_ROWS (более одной
строки). Можно использовать секцию исключений в блоке для обработки ошибок, например:
BEGIN
SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
EXCEPTION
WHEN NO_DATA_FOUND THEN
RAISE EXCEPTION ‘Сотрудник % не найден’, myname;
WHEN TOO_MANY_ROWS THEN
RAISE EXCEPTION ‘Сотрудник % уже существует’, myname;
END;
После успешного выполнения команды с указанием STRICT, значение переменной FOUND всегда
устанавливается в истину.
Для INSERT/UPDATE/DELETE с RETURNING, PL/pgSQL возвращает ошибку, если выбрано более одной
строки, даже в том случае, когда указание STRICT отсутствует. Так происходит потому, что у этих
команд нет возможности, типа ORDER BY, указать какая из задействованных строк должна быть
возвращена.
Если для функции включён режим print_strict_params, то при возникновении ошибки, связанной
с нарушением условия STRICT, в детальную (DETAIL) часть сообщения об ошибке будет включена
информация о параметрах, переданных запросу. Изменить значение print_strict_params можно
установкой параметра plpgsql.print_strict_params. Но это повлияет только на функции, ском-
1134PL/pgSQL — проце-
дурный язык SQL
пилированные после изменения. Для конкретной функции можно использовать указание компи-
лятора, например:
CREATE FUNCTION get_userid(username text) RETURNS int
AS <script type="math/tex">#print_strict_params on
DECLARE
userid int;
BEGIN
SELECT users.userid INTO STRICT userid
FROM users WHERE users.username = get_userid.username;
RETURN userid;
END</script> LANGUAGE plpgsql;
В случае сбоя будет сформировано примерно такое сообщение об ошибке
ERROR: query returned no rows
DETAIL: parameters: $1 = ‘nosuchuser’
CONTEXT: PL/pgSQL function get_userid(text) line 6 at SQL statement
Примечание
С указанием STRICT поведение SELECT INTO и связанных операторов соответствует при-
нятому в Oracle PL/SQL.
Как действовать в случаях, когда требуется обработать несколько строк результата, описано в
Подразделе 43.6.6.
43.5.4. Выполнение динамически формируемых команд
Часто требуется динамически формировать команды внутри функций на PL/pgSQL, то есть такие
команды, в которых при каждом выполнении могут использоваться разные таблицы или типы дан-
ных. Обычно PL/pgSQL кеширует планы выполнения (как описано в Подразделе 43.11.2), но в слу-
чае с динамическими командами это не будет работать. Для исполнения динамических команд
предусмотрен оператор EXECUTE:
EXECUTE строка-команды [ INTO [STRICT] цель ] [ USING выражение [, … ] ];
где строка-команды это выражение, формирующее строку (типа text) с текстом команды, которую
нужно выполнить. Необязательная цель — это переменная-запись, переменная-кортеж или раз-
делённый запятыми список простых переменных и полей записи/кортежа, куда будут помещены
результаты команды. Необязательные выражения в USING формируют значения, которые будут
вставлены в команду.
В сформированном тексте команды замена имён переменных PL/pgSQL на их значения проводить-
ся не будет. Все необходимые значения переменных должны быть вставлены в командную строку
при её построении, либо нужно использовать параметры, как описано ниже.
Также, нет никакого плана кеширования для команд, выполняемых с помощью EXECUTE. Вместо
этого план создаётся каждый раз при выполнении. Таким образом, строка команды может дина-
мически создаваться внутри функции для выполнения действий с различными таблицами и столб-
цами.
Предложение INTO указывает, куда должны быть помещены результаты SQL-команды, возвращаю-
щей строки. Если используется переменная строкового типа или список переменных, то они долж-
ны в точности соответствовать структуре результата запроса (когда используется переменная ти-
па record, она автоматически приводится к строковому типу результата запроса). Если возвраща-
ется несколько строк, то только первая будет присвоена переменной(ым) в INTO. Если не возвра-
1135PL/pgSQL — проце-
дурный язык SQL
щается ни одной строки, то присваивается NULL. Без предложения INTO результаты запроса от-
брасываются.
С указанием STRICT запрос должен вернуть ровно одну строку, иначе выдаётся сообщение об ошиб-
ке.
В тексте команды можно использовать значения параметров, ссылки на параметры обозначаются
как $1, $2 и т. д. Эти символы указывают на значения, находящиеся в предложении USING. Такой
метод зачастую предпочтительнее, чем вставка значений в команду в виде текста: он позволяет
исключить во время исполнения дополнительные расходы на преобразования значений в текст и
обратно, и не открывает возможности для SQL-инъекций, не требуя применять экранирование или
кавычки для спецсимволов. Пример:
EXECUTE ‘SELECT count(<em>) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2’
INTO c
USING checked_user, checked_date;
Обратите внимание, что символы параметров можно использовать только вместо значений дан-
ных. Если же требуется динамически формировать имена таблиц или столбцов, их необходимо
вставлять в виде текста. Например, если в предыдущем запросе необходимо динамически задавать
имя таблицы, можно сделать следующее:
EXECUTE ‘SELECT count(</em>) FROM ‘
|| quote_ident(tabname)
|| ‘ WHERE inserted_by = $1 AND inserted &lt;= $2’
INTO c
USING checked_user, checked_date;
В качестве более аккуратного решения, вместо имени таблиц или столбцов можно использовать
указание формата %I с функцией format() (текст, разделённый символами новой строки, соеди-
няется вместе):
EXECUTE format(‘SELECT count(*) FROM %I ‘
‘WHERE inserted_by = $1 AND inserted &lt;= $2’, tabname)
INTO c
USING checked_user, checked_date;
Ещё одно ограничение состоит в том, что символы параметров могут использоваться только в ко-
мандах SELECT, INSERT, UPDATE и DELETE. В операторы других типов (обычно называемые служеб-
ными) значения нужно вставлять в текстовом виде, даже если это просто значения данных.
Команда EXECUTE c неизменяемым текстом и параметрами USING (как в первом примере выше),
функционально эквивалентна команде, записанной напрямую в PL/pgSQL, в которой переменные
PL/pgSQL автоматически заменяются значениями. Важное отличие в том, что EXECUTE при каж-
дом исполнении заново строит план команды с учётом текущих значений параметров, тогда как
PL/pgSQL строит общий план выполнения и кеширует его при повторном использовании. В тех
случаях, когда наилучший план выполнения сильно зависит от значений параметров, может быть
полезно использовать EXECUTE для гарантии того, что не будет выбран общий план.
В настоящее время команда SELECT INTO не поддерживается в EXECUTE, вместо этого нужно вы-
полнять обычный SELECT и указать INTO для самой команды EXECUTE.
Примечание
Оператор EXECUTE в PL/pgSQL не имеет отношения к одноимённому SQL-оператору сер-
вера PostgreSQL. Серверный EXECUTE не может напрямую использоваться в функциях
на PL/pgSQL (и в этом нет необходимости).
Пример 43.1. Использование кавычек в динамических запросах
1136PL/pgSQL — проце-
дурный язык SQL
При работе с динамическими командами часто приходится иметь дело с экранированием одинар-
ных кавычек. Рекомендуемым методом для взятия текста в кавычки в теле функции является экра-
нирование знаками доллара. (Если имеется унаследованный код, не использующий этот метод,
пожалуйста, обратитесь к обзору в Подразделе 43.12.1, это поможет сэкономить усилия при пере-
воде кода к более приемлемому виду.)
Динамические значения требуют особого внимания, так как они могут содержать апострофы. На-
пример, можно использовать функцию format() (предполагается, что тело функции заключается
в доллары, так что апострофы дублировать не нужно):
EXECUTE format(‘UPDATE tbl SET %I = $1 ‘
‘WHERE key = $2’, colname) USING newvalue, keyvalue;
Также можно напрямую вызывать функции заключения в кавычки:
EXECUTE ‘UPDATE tbl SET ‘
|| quote_ident(colname)
|| ‘ = ‘
|| quote_literal(newvalue)
|| ‘ WHERE key = ‘
|| quote_literal(keyvalue);
Этот пример демонстрирует использование функций quote_ident и quote_literal (см. Раздел 9.4).
Для надёжности, выражения, содержащие идентификаторы столбцов и таблиц должны использо-
вать функцию quote_ident при добавлении в текст запроса. А для выражений со значениями, ко-
торые должны быть обычными строками, используется функция quote_literal. Эти функции вы-
полняют соответствующие шаги, чтобы вернуть текст, по ситуации заключённый в двойные или
одинарные кавычки и с правильно экранированными специальными символами.
Так как функция quote_literal помечена как STRICT, то она всегда возвращает NULL, если пе-
реданный ей аргумент имеет значение NULL. В приведённом выше примере, если newvalue или
keyvalue были NULL, вся строка с текстом запроса станет NULL, что приведёт к ошибке в EXECUTE.
Для предотвращения этой проблемы используйте функцию quote_nullable, которая работает так
же, как quote_literal за исключением того, что при вызове с пустым аргументом возвращает
строку ‘NULL’. Например:
EXECUTE ‘UPDATE tbl SET ‘
|| quote_ident(colname)
|| ‘ = ‘
|| quote_nullable(newvalue)
|| ‘ WHERE key = ‘
|| quote_nullable(keyvalue);
Если вы имеете дело со значениями, которые могут быть пустыми, то, как правило, нужно исполь-
зовать quote_nullable вместо quote_literal.
Как обычно, необходимо убедиться, что значения NULL в запросе не принесут неожиданных ре-
зультатов. Например, следующее условие WHERE
‘WHERE key = ‘ || quote_nullable(keyvalue)
никогда не выполнится, если keyvalue — NULL, так как применение = с операндом, имеющим зна-
чение NULL, всегда даёт NULL. Если требуется, чтобы NULL обрабатывалось как обычное значе-
ние, то условие выше нужно переписать так:
‘WHERE key IS NOT DISTINCT FROM ‘ || quote_nullable(keyvalue)
(В настоящее время IS NOT DISTINCT FROM работает менее эффективно, чем =, так что исполь-
зуйте этот способ, только если это действительно необходимо. Подробнее особенности NULL и IS
DISTINCT описаны в Разделе 9.2.)
Обратите внимание, что использование знака $ полезно только для взятия в кавычки фиксирован-
ного текста. Плохая идея написать этот пример так:
1137PL/pgSQL — проце-
дурный язык SQL
EXECUTE ‘UPDATE tbl SET ‘
|| quote_ident(colname)
|| ‘ = <script type="math/tex">'
|| newvalue
|| '</script> WHERE key = ‘
|| quote_literal(keyvalue);
потому что newvalue может также содержать <script type="math/tex">% <![CDATA[
. Эта же проблема может возникнуть и с любым
другим разделителем, используемым после знака $. Поэтому, чтобы безопасно заключить зара-
нее неизвестный текст в кавычки, нужно использовать соответствующие функции: quote_literal,
quote_nullable, или quote_ident.
Динамические операторы SQL также можно безопасно сформировать, используя функцию format
(см. Раздел 9.4). Например:
EXECUTE format('UPDATE tbl SET %I = %L '
'WHERE key = %L', colname, newvalue, keyvalue);
Указание %I равнозначно вызову quote_ident, а %L — вызову quote_nullable. Функция format мо-
жет применяться в сочетании с предложением USING:
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
USING newvalue, keyvalue;
Эта форма лучше, так как с ней переменные обрабатываются в их собственном формате данных,
а не преобразуются безусловно в текст, чтобы затем выводиться с использованием %L. Она также
и более эффективна.
Более объёмный пример использования динамической команды и EXECUTE можно увидеть в При-
мере 43.10. В нём создаётся и динамически выполняется команда CREATE FUNCTION для определе-
ния новой функции.
43.5.5. Статус выполнения команды
Определить результат команды можно несколькими способами. Во-первых, можно воспользовать-
ся командой GET DIAGNOSTICS, имеющей форму:
GET [ CURRENT ] DIAGNOSTICS переменная { = | := } элемент [ , ... ];
Эта команда позволяет получить системные индикаторы состояния. Слово CURRENT не несёт смыс-
ловой нагрузки (но см. также описание GET STACKED DIAGNOSTICS в Подразделе  43.6.8.1). Каж-
дый элемент представляется ключевым словом, указывающим, какое значение состояния нужно
присвоить заданной переменной (она должна иметь подходящий тип данных, чтобы принять его).
Доступные в настоящее время элементы состояния показаны в Таблице 43.1. Вместо принятого в
стандарте SQL присваивания (=) можно применять присваивание с двоеточием (:=). Например:
GET DIAGNOSTICS integer_var = ROW_COUNT;
Таблица 43.1. Доступные элементы диагностики
Имя Тип Описание
ROW_COUNT bigint число строк, обработанных по-
следней командой SQL
RESULT_OID oid OID последней строки, встав-
ленной предыдущей командой
SQL (полезен только после ко-
манды INSERT для таблицы, со-
держащей OID)
PG_CONTEXT text строки текста, описывающие
текущий стек вызовов (см. Под-
раздел 43.6.9)
1138PL/pgSQL — проце-
дурный язык SQL
Второй способ определения статуса выполнения команды заключается в проверке значения спе-
циальной переменной FOUND, имеющей тип boolean. При вызове функции на PL/pgSQL, перемен-
ная FOUND инициализируется в ложь. Далее, значение переменной изменяется следующими опе-
раторами:
• SELECT INTO записывает в FOUND true, если строка присвоена, или false, если строки не были
получены.
• PERFORM записывает в FOUND true, если строки выбраны (и отброшены) или false, если строки
не выбраны.
• UPDATE, INSERT и DELETE записывают в FOUND true, если при их выполнении была задействована
хотя бы одна строка, или false, если ни одна строка не была задействована.
• FETCH записывают в FOUND true, если команда вернула строку, или false, если строка не выбра-
на.
• MOVE записывают в FOUND true при успешном перемещении курсора, в противном случае —
false.
• FOR, как и FOREACH, записывает в FOUND true, если была произведена хотя бы одна итерация
цикла, в противном случае — false. При этом значение FOUND будет установлено только после
выхода из цикла. Пока цикл выполняется, оператор цикла не изменяет значение переменной.
Но другие операторы внутри цикла могут менять значение FOUND.
• RETURN QUERY и RETURN QUERY EXECUTE записывают в FOUND true, если запрос вернул хотя бы
одну строку, или false, если строки не выбраны.
Другие операторы PL/pgSQL не меняют значение FOUND. Помните в частности, что EXECUTE изме-
няет вывод GET DIAGNOSTICS, но не меняет FOUND.
FOUND является локальной переменной в каждой функции PL/pgSQL и любые её изменения, влияют
только на текущую функцию.
43.5.6. Не делать ничего
Иногда бывает полезен оператор, который не делает ничего. Например, он может показывать, что
одна из ветвей if/then/else сознательно оставлена пустой. Для этих целей используется NULL:
NULL;
В следующем примере два фрагмента кода эквивалентны:
BEGIN
y := x / 0;
EXCEPTION
WHEN division_by_zero THEN
NULL; -- ошибка игнорируется
END;
BEGIN
y := x / 0;
EXCEPTION
WHEN division_by_zero THEN
END;
-- ошибка игнорируется
Какой вариант выбрать — дело вкуса.
Примечание
В Oracle PL/SQL не допускаются пустые списки операторов, поэтому NULL обязателен
в подобных ситуациях. В PL/pgSQL разрешается не писать ничего.
1139PL/pgSQL — проце-
дурный язык SQL
43.6. Управляющие структуры
Управляющие структуры, вероятно, наиболее полезная и важная часть PL/pgSQL. С их помощью
можно очень гибко и эффективно манипулировать данными PostgreSQL.
43.6.1. Команды для возврата значения из функции
Две команды позволяют вернуть данные из функции: RETURN и RETURN NEXT.
43.6.1.1. RETURN
RETURN выражение;
RETURN с последующим выражением прекращает выполнение функции и возвращает значение вы-
ражения в вызывающую программу. Эта форма используется для функций PL/pgSQL, которые не
возвращают набор строк.
В функции, возвращающей скалярный тип, результирующее выражение автоматически приводит-
ся к типу возвращаемого значения. Однако, чтобы вернуть составной тип (строку), возвращаемое
выражение должно в точности содержать требуемый набор столбцов. При этом может потребо-
ваться явное приведение типов.
Для функции с выходными параметрами просто используйте RETURN без выражения. Будут возвра-
щены текущие значения выходных параметров.
Для функции, возвращающей void, RETURN можно использовать в любом месте, но без выражения
после RETURN.
Возвращаемое значение функции не может остаться не определённым. Если достигнут конец бло-
ка верхнего уровня, а оператор RETURN так и не встретился, происходит ошибка времени исполне-
ния. Это не касается функций с выходными параметрами и функций, возвращающих void. Для них
оператор RETURN выполняется автоматически по окончании блока верхнего уровня.
Несколько примеров:
-- Функции, возвращающие скалярный тип данных
RETURN 1 + 2;
RETURN scalar_var;
-- Функции, возвращающие составной тип данных
RETURN composite_type_var;
RETURN (1, 2, 'three'::text); -- требуется приведение типов
43.6.1.2. RETURN NEXT и RETURN QUERY
RETURN NEXT выражение;
RETURN QUERY запрос;
RETURN QUERY EXECUTE строка-команды [USING выражение [, ...]];
Для функций на PL/pgSQL, возвращающих SETOF некий_тип, нужно действовать несколько по-
иному. Отдельные элементы возвращаемого значения формируются командами RETURN NEXT или
RETURN QUERY, а финальная команда RETURN без аргументов завершает выполнение функции. RETURN
NEXT используется как со скалярными, так и с составными типами данных. Для составного типа
результат функции возвращается в виде таблицы. RETURN QUERY добавляет результат выполнения
запроса к результату функции. RETURN NEXT и RETURN QUERY можно свободно смешивать в теле
функции, в этом случае их результаты будут объединены.
RETURN NEXT и RETURN QUERY не выполняют возврат из функции. Они просто добавляют строки в
результирующее множество. Затем выполнение продолжается со следующего оператора в функ-
ции. Успешное выполнение RETURN NEXT и RETURN QUERY формирует множество строк результата.
1140PL/pgSQL — проце-
дурный язык SQL
Для выхода из функции используется RETURN, обязательно без аргументов (или можно просто до-
ждаться окончания выполнения функции).
RETURN QUERY имеет разновидность RETURN QUERY EXECUTE, предназначенную для динамического
выполнения запроса. В текст запроса можно добавить параметры, используя USING, также как и
с командой EXECUTE.
Для функции с выходными параметрами просто используйте RETURN NEXT без аргументов. При
каждом исполнении RETURN NEXT текущие значения выходных параметров сохраняются для после-
дующего возврата в качестве строки результата. Обратите внимание, что если функция с выход-
ными параметрами должна возвращать множество значений, то при объявлении нужно указывать
RETURNS SETOF. При этом если выходных параметров несколько, то используется RETURNS SETOF
record, а если только один с типом некий_тип, то RETURNS SETOF некий_тип.
Пример использования RETURN NEXT:
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');
CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
r foo%rowtype;
BEGIN
FOR r IN
SELECT * FROM foo WHERE fooid > 0
LOOP
-- здесь возможна обработка данных
RETURN NEXT r; -- возвращается текущая строка запроса
END LOOP;
RETURN;
END
$BODY$
LANGUAGE plpgsql;
SELECT * FROM get_all_foo();
Пример использования RETURN QUERY:
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
RETURN QUERY SELECT flightid
FROM flight
WHERE flightdate >= $1
AND flightdate < ($1 + 1);
-- Так как выполнение ещё не закончено, можно проверить, были ли возвращены строки,
-- и если нет, выдать исключение.
IF NOT FOUND THEN
RAISE EXCEPTION 'Нет рейсов на дату: %.', $1;
END IF;
RETURN;
END
$BODY$
LANGUAGE plpgsql;
1141PL/pgSQL — проце-
дурный язык SQL
-- Возвращает доступные рейсы либо вызывает исключение, если таковых нет.
SELECT * FROM get_available_flightid(CURRENT_DATE);
Примечание
В текущей реализации RETURN NEXT и RETURN QUERY результирующее множество накап-
ливается целиком, прежде чем будет возвращено из функции. Если множество очень
большое, то это может отрицательно сказаться на производительности, так как при
нехватке оперативной памяти данные записываются на диск. В следующих версиях PL/
pgSQL это ограничение будет снято. В настоящее время управлять количеством опера-
тивной памяти в подобных случаях можно параметром конфигурации work_mem. При
наличии свободной памяти администраторы должны рассмотреть возможность увели-
чения значения данного параметра.
43.6.2. Завершение процедуры
Процедура не возвращает никакого значения, поэтому она может завершаться без оператора
RETURN. Если вы хотите досрочно завершить выполнение кода оператором RETURN, напишите про-
сто RETURN без возвращаемого выражения.
Если у процедуры есть выходные параметры, конечные значения соответствующих им переменных
будут выданы вызывающему коду.
43.6.3. Вызов процедуры
Функция, процедура или блок DO в PL/pgSQL может вызвать процедуру, используя оператор CALL.
Выходные параметры при этом обрабатываются не так, как это делает CALL в обычном SQL. Каж-
дому параметру INOUT для процедуры должна соответствовать переменная в операторе CALL, и
этой переменной по завершении процедуры будет присвоено возвращаемое процедурой значение.
Например:
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS %]]></script>
BEGIN
x := x * 3;
END;
<script type="math/tex">;
DO</script>
DECLARE myvar int := 5;
BEGIN
CALL triple(myvar);
RAISE NOTICE ‘myvar = %’, myvar;
END
$$;
– выводится 15
43.6.4. Условные операторы
Операторы IF и CASE позволяют выполнять команды в зависимости от определённых условий. PL/
pgSQL поддерживает три формы IF:
• IF … THEN … END IF
• IF … THEN … ELSE … END IF
• IF … THEN … ELSIF … THEN … ELSE … END IF
и две формы CASE:
• CASE … WHEN … THEN … ELSE … END CASE
1142PL/pgSQL — проце-
дурный язык SQL
• CASE WHEN … THEN … ELSE … END CASE
43.6.4.1. IF-THEN
IF логическое-выражение THEN
операторы
END IF;
IF-THEN это простейшая форма IF. Операторы между THEN и END IF выполняются, если условие
(логическое-выражение) истинно. В противном случае они опускаются.
Пример:
IF v_user_id &lt;&gt; 0 THEN
UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
43.6.4.2. IF-THEN-ELSE
IF логическое-выражение THEN
операторы
ELSE
операторы
END IF;
IF-THEN-ELSE добавляет к IF-THEN возможность указать альтернативный набор операторов, кото-
рые будут выполнены, если условие не истинно (в том числе, если условие NULL).
Примеры:
IF parentid IS NULL OR parentid = ‘’
THEN
RETURN fullname;
ELSE
RETURN hp_true_filename(parentid) || ‘/’ || fullname;
END IF;
IF v_count
INSERT
RETURN
ELSE
RETURN
END IF;</p>
<blockquote>
  <p>0 THEN
INTO users_count (count) VALUES (v_count);
‘t’;
‘f’;
43.6.4.3. IF-THEN-ELSIF
IF логическое-выражение THEN
операторы
[ELSIF логическое-выражение THEN операторы [ELSIF логическое-выражение THEN операторы
…]]
[ELSE операторы]
END IF;
В некоторых случаях двух альтернатив недостаточно. IF-THEN-ELSIF обеспечивает удобный способ
проверки нескольких вариантов по очереди. Условия в IF последовательно проверяются до тех пор,
пока не будет найдено первое истинное. После этого операторы, относящиеся к этому условию,
выполняются, и управление переходит к следующей после END IF команде. (Все последующие
условия не проверяются.) Если ни одно из условий IF не является истинным, то выполняется блок
ELSE (если присутствует).
Пример:
IF number = 0 THEN
result := ‘zero’;
1143PL/pgSQL — проце-
дурный язык SQL
ELSIF number &gt; 0 THEN
result := ‘positive’;
ELSIF number &lt; 0 THEN
result := ‘negative’;
ELSE
– остаётся только один вариант: number имеет значение NULL
result := ‘NULL’;
END IF;
Вместо ключевого слова ELSIF можно использовать ELSEIF.
Другой вариант сделать то же самое, это использование вложенных операторов IF-THEN-ELSE, как
в следующем примере:
IF demo_row.sex = ‘m’ THEN
pretty_sex := ‘man’;
ELSE
IF demo_row.sex = ‘f’ THEN
pretty_sex := ‘woman’;
END IF;
END IF;
Однако это требует написания соответствующих END IF для каждого IF, что при наличии несколь-
ких альтернатив делает код более громоздким, чем использование ELSIF.
43.6.4.4. Простой CASE
CASE выражение-поиска
WHEN выражение [, выражение […]] THEN
операторы
[WHEN выражение [, выражение […]] THEN операторы …]
[ELSE операторы]
END CASE;
Простая форма CASE реализует условное выполнение на основе сравнения операндов. Выраже-
ние-поиска вычисляется (один раз) и последовательно сравнивается с каждым выражением в усло-
виях WHEN. Если совпадение найдено, то выполняются соответствующие операторы и управление
переходит к следующей после END CASE команде. (Все последующие выражения WHEN не проверя-
ются.) Если совпадение не было найдено, то выполняются операторы в ELSE. Но если ELSE нет, то
вызывается исключение CASE_NOT_FOUND.
Пример:
CASE x
WHEN 1, 2 THEN
msg := ‘один или два’;
ELSE
msg := ‘значение, отличное от один или два’;
END CASE;
43.6.4.5. CASE с перебором условий
CASE
WHEN логическое-выражение THEN
операторы
[WHEN логическое-выражение THEN операторы …]
[ELSE операторы]
END CASE;
Эта форма CASE реализует условное выполнение, основываясь на истинности логических условий.
Каждое логическое-выражение в предложении WHEN вычисляется по порядку до тех пор, пока не
1144PL/pgSQL — проце-
дурный язык SQL
будет найдено истинное. Затем выполняются соответствующие операторы и управление переходит
к следующей после END CASE команде. (Все последующие выражения WHEN не проверяются.) Если
ни одно из условий не окажется истинным, то выполняются операторы в ELSE. Но если ELSE нет,
то вызывается исключение CASE_NOT_FOUND.
Пример:
CASE
WHEN x BETWEEN 0 AND 10 THEN
msg := ‘значение в диапазоне между 0 и 10’;
WHEN x BETWEEN 11 AND 20 THEN
msg := ‘значение в диапазоне между 11 и 20’;
END CASE;
Эта форма CASE полностью эквивалента IF-THEN-ELSIF, за исключением того, что при невыполне-
нии всех условий и отсутствии ELSE, IF-THEN-ELSIF ничего не делает, а CASE вызывает ошибку.
43.6.5. Простые циклы
Операторы LOOP, EXIT, CONTINUE, WHILE, FOR и FOREACH позволяют повторить серию команд в функ-
ции на PL/pgSQL.
43.6.5.1. LOOP
[«метка»]
LOOP
операторы
END LOOP [ метка ];
LOOP организует безусловный цикл, который повторяется до бесконечности, пока не будет прекра-
щён операторами EXIT или RETURN. Для вложенных циклов можно использовать метку в операторах
EXIT и CONTINUE, чтобы указать, к какому циклу эти операторы относятся.
43.6.5.2. EXIT
EXIT [ метка ] [WHEN логическое-выражение];
Если метка не указана, то завершается самый внутренний цикл, далее выполняется оператор, сле-
дующий за END LOOP. Если метка указана, то она должна относиться к текущему или внешнему
циклу, или это может быть метка блока. При этом в именованном цикле/блоке выполнение пре-
кращается, а управление переходит к следующему оператору после соответствующего END.
При наличии WHEN цикл прекращается, только если логическое-выражение истинно. В противном
случае управление переходит к оператору, следующему за EXIT.
EXIT можно использовать со всеми типами циклов, не только с безусловным.
Когда EXIT используется для выхода из блока, управление переходит к следующему оператору по-
сле окончания блока. Обратите внимание, что для выхода из блока нужно обязательно указывать
метку. EXIT без метки не позволяет прекратить работу блока. (Это изменение по сравнению с вер-
сиями PostgreSQL до 8.4, в которых разрешалось использовать EXIT без метки для прекращения
работы текущего блока.)
Примеры:
LOOP
– здесь производятся вычисления
IF count &gt; 0 THEN
EXIT; – выход из цикла
END IF;
END LOOP;
1145PL/pgSQL — проце-
дурный язык SQL
LOOP
– здесь производятся вычисления
EXIT WHEN count &gt; 0; – аналогично предыдущему примеру
END LOOP;
«ablock»
BEGIN
– здесь производятся вычисления
IF stocks &gt; 100000 THEN
EXIT ablock; – выход из блока BEGIN
END IF;
– вычисления не будут выполнены, если stocks &gt; 100000
END;
43.6.5.3. CONTINUE
CONTINUE [ метка ] [WHEN логическое-выражение];
Если метка не указана, то начинается следующая итерация самого внутреннего цикла. То есть все
оставшиеся в цикле операторы пропускаются, и управление переходит к управляющему выраже-
нию цикла (если есть) для определения, нужна ли ещё одна итерация цикла. Если метка присут-
ствует, то она указывает на метку цикла, выполнение которого будет продолжено.
При наличии WHEN следующая итерация цикла начинается только тогда, когда логическое-выра-
жение истинно. В противном случае управление переходит к оператору, следующему за CONTINUE.
CONTINUE можно использовать со всеми типами циклов, не только с безусловным.
Примеры:
LOOP
– здесь производятся вычисления
EXIT WHEN count &gt; 100;
CONTINUE WHEN count &lt; 50;
– вычисления для count в диапазоне 50 .. 100
END LOOP;
43.6.5.4. WHILE
[«метка»]
WHILE логическое-выражение LOOP
операторы
END LOOP [ метка ];
WHILE выполняет серию команд до тех пор, пока истинно логическое-выражение. Выражение про-
веряется непосредственно перед каждым входом в тело цикла.
Пример:
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
– здесь производятся вычисления
END LOOP;
WHILE NOT done LOOP
– здесь производятся вычисления
END LOOP;
43.6.5.5. FOR (целочисленный вариант)
[«метка»]
FOR имя IN [REVERSE] выражение .. выражение [BY выражение] LOOP
операторы
1146PL/pgSQL — проце-
дурный язык SQL
END LOOP [ метка ];
В этой форме цикла FOR итерации выполняются по диапазону целых чисел. Переменная имя авто-
матически определяется с типом integer и существует только внутри цикла (если уже существует
переменная с таким именем, то внутри цикла она будет игнорироваться). Выражения для нижней
и верхней границы диапазона чисел вычисляются один раз при входе в цикл. Если не указано BY,
то шаг итерации 1, в противном случае используется значение в BY, которое вычисляется, опять
же, один раз при входе в цикл. Если указано REVERSE, то после каждой итерации величина шага
вычитается, а не добавляется.
Примеры целочисленного FOR:
FOR i IN 1..10 LOOP
– внутри цикла переменная i будет иметь значения 1,2,3,4,5,6,7,8,9,10
END LOOP;
FOR i IN REVERSE 10..1 LOOP
– внутри цикла переменная i будет иметь значения 10,9,8,7,6,5,4,3,2,1
END LOOP;
FOR i IN REVERSE 10..1 BY 2 LOOP
– внутри цикла переменная i будет иметь значения 10,8,6,4,2
END LOOP;
Если нижняя граница цикла больше верхней границы (или меньше, в случае REVERSE), то тело
цикла не выполняется вообще. При этом ошибка не возникает.
Если с циклом FOR связана метка, к целочисленной переменной цикла можно обращаться по имени,
указывая эту метку.
43.6.6. Цикл по результатам запроса
Другой вариант FOR позволяет организовать цикл по результатам запроса. Синтаксис:
[ «метка» ]
FOR цель IN запрос LOOP
операторы
END LOOP [ метка ];
Переменная цель может быть строковой переменной, переменной типа record или разделённым
запятыми списком скалярных переменных. Переменной цель последовательно присваиваются
строки результата запроса, и для каждой строки выполняется тело цикла. Пример:
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS <script type="math/tex">DECLARE
mviews RECORD;
BEGIN
RAISE NOTICE 'Refreshing materialized views...';
FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP
-- Здесь "mviews" содержит одну запись из cs_materialized_views
RAISE NOTICE 'Refreshing materialized view %s ...',
quote_ident(mviews.mv_name);
EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
END LOOP;
RAISE NOTICE 'Done refreshing materialized views.';
RETURN 1;
1147PL/pgSQL — проце-
дурный язык SQL
END;</script> LANGUAGE plpgsql;
Если цикл завершается по команде EXIT, то последняя присвоенная строка доступна и после цикла.
В качестве запроса в этом типе оператора FOR может задаваться любая команда SQL, возвраща-
ющая строки. Чаще всего это SELECT, но также можно использовать и INSERT, UPDATE или DELETE
с предложением RETURNING. Кроме того, возможно применение и некоторых служебных команд,
например EXPLAIN.
Для переменных PL/pgSQL в тексте запроса выполняется подстановка значений, план запроса ке-
шируется для возможного повторного использования, как подробно описано в Подразделе 43.11.1
и Подразделе 43.11.2.
Ещё одна разновидность этого типа цикла FOR-IN-EXECUTE:
[ «метка» ]
FOR цель IN EXECUTE выражение_проверки [ USING выражение [, … ] ] LOOP
операторы
END LOOP [ метка ];
Она похожа на предыдущую форму, за исключением того, что текст запроса указывается в виде
строкового выражения. Текст запроса формируется и для него строится план выполнения при
каждом входе в цикл. Это даёт программисту выбор между скоростью предварительно разобран-
ного запроса и гибкостью динамического запроса, так же, как и в случае с обычным оператором
EXECUTE. Как и в EXECUTE, значения параметров могут быть добавлены в команду с использованием
USING.
Ещё один способ организовать цикл по результатам запроса это объявить курсор. Описание в Под-
разделе 43.7.4.
43.6.7. Цикл по элементам массива
Цикл FOREACH очень похож на FOR. Отличие в том, что вместо перебора строк SQL-запроса проис-
ходит перебор элементов массива. (В целом, FOREACH предназначен для перебора выражений со-
ставного типа. Варианты реализации цикла для работы с прочими составными выражениями по-
мимо массивов могут быть добавлены в будущем.) Синтаксис цикла FOREACH:
[ «метка» ]
FOREACH цель [ SLICE число ] IN ARRAY выражение LOOP
операторы
END LOOP [ метка ];
Без указания SLICE, или если SLICE равен 0, цикл выполняется по всем элементам массива, полу-
ченного из выражения. Переменной цель последовательно присваивается каждый элемент массива
и для него выполняется тело цикла. Пример цикла по элементам целочисленного массива:
CREATE FUNCTION sum(int[]) RETURNS int8 AS <script type="math/tex">DECLARE
s int8 := 0;
x int;
BEGIN
FOREACH x IN ARRAY $1
LOOP
s := s + x;
END LOOP;
RETURN s;
END;</script> LANGUAGE plpgsql;
Обход элементов проводится в том порядке, в котором они сохранялись, независимо от размерно-
сти массива. Как правило, цель это одиночная переменная, но может быть и списком переменных,
1148PL/pgSQL — проце-
дурный язык SQL
когда элементы массива имеют составной тип (записи). В этом случае переменным присваиваются
значения из последовательных столбцов составного элемента массива.
При положительном значении SLICE FOREACH выполняет итерации по срезам массива, а не по от-
дельным элементам. Значение SLICE должно быть целым числом, не превышающим размерности
массива. Переменная цель должна быть массивом, который получает последовательные срезы ис-
ходного массива, где размерность каждого среза задаётся значением SLICE. Пример цикла по од-
номерным срезам:
CREATE FUNCTION scan_rows(int[]) RETURNS void AS <script type="math/tex">DECLARE
x int[];
BEGIN
FOREACH x SLICE 1 IN ARRAY $1
LOOP
RAISE NOTICE 'row = %', x;
END LOOP;
END;</script> LANGUAGE plpgsql;
SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);
NOTICE:
NOTICE:
NOTICE:
NOTICE:
row
row
row
row
=
=
=
=
{1,2,3}
{4,5,6}
{7,8,9}
{10,11,12}
43.6.8. Обработка ошибок
По умолчанию любая возникающая ошибка прерывает выполнение функции на PL/pgSQL, а также
транзакцию, относящуюся к этой функции. Использование в блоке секции EXCEPTION позволяет
перехватывать и обрабатывать ошибки. Синтаксис секции EXCEPTION расширяет синтаксис обыч-
ного блока:
[ «метка» ]
[ DECLARE
объявления ]
BEGIN
операторы
EXCEPTION
WHEN условие [ OR условие … ] THEN
операторы_обработчика
[ WHEN условие [ OR условие … ] THEN
операторы_обработчика
… ]
END;
Если ошибок не было, то выполняются все операторы блока и управление переходит к следую-
щему оператору после END. Но если при выполнении оператора происходит ошибка, то дальней-
шая обработка прекращается и управление переходит к списку исключений в секции EXCEPTION. В
этом списке ищется первое исключение, условие которого соответствует ошибке. Если исключе-
ние найдено, то выполняются соответствующие операторы_обработчика и управление переходит
к следующему оператору после END. Если исключение не найдено, то ошибка передаётся наружу,
как будто секции EXCEPTION не было. При этом ошибку можно перехватить в секции EXCEPTION
внешнего блока. Если ошибка так и не была перехвачена, то обработка функции прекращается.
В качестве условия может задаваться одно из имён, перечисленных в Приложении A. Если задаёт-
ся имя категории, ему соответствуют все ошибки в данной категории. Специальному имени усло-
вия OTHERS (другие) соответствуют все типы ошибок, кроме QUERY_CANCELED и ASSERT_FAILURE. (И
эти два типа ошибок можно перехватить по имени, но часто это неразумно.) Имена условий вос-
1149PL/pgSQL — проце-
дурный язык SQL
принимаются без учёта регистра. Условие ошибки также можно задать кодом SQLSTATE; например,
эти два варианта равнозначны:
WHEN division_by_zero THEN …
WHEN SQLSTATE ‘22012’ THEN …
Если при выполнении операторов_обработчика возникнет новая ошибка, то она не может быть пе-
рехвачена в этой секции EXCEPTION. Ошибка передаётся наружу и её можно перехватить в секции
EXCEPTION внешнего блока.
При выполнении команд в секции EXCEPTION локальные переменные функции на PL/pgSQL сохра-
няют те значения, которые были на момент возникновения ошибки. Однако, будут отменены все
изменения в базе данных, выполненные в блоке. В качестве примера рассмотрим следующий фраг-
мент:
INSERT INTO mytab(firstname, lastname) VALUES(‘Tom’, ‘Jones’);
BEGIN
UPDATE mytab SET firstname = ‘Joe’ WHERE lastname = ‘Jones’;
x := x + 1;
y := x / 0;
EXCEPTION
WHEN division_by_zero THEN
RAISE NOTICE ‘перехватили ошибку division_by_zero’;
RETURN x;
END;
При присвоении значения переменной y произойдёт ошибка division_by_zero. Она будет пере-
хвачена в секции EXCEPTION. Оператор RETURN вернёт значение x, увеличенное на единицу, но из-
менения сделанные командой UPDATE будут отменены. Изменения, выполненные командой INSERT,
которая предшествует блоку, не будут отменены. В результате, база данных будет содержать Tom
Jones, а не Joe Jones.
Подсказка
Наличие секции EXCEPTION значительно увеличивает накладные расходы на вход/выход
из блока, поэтому не используйте EXCEPTION без надобности.
Пример 43.2. Обработка исключений для команд UPDATE/INSERT
В этом примере обработка исключений помогает выполнить либо команду UPDATE, либо INSERT, в
зависимости от ситуации. Однако в современных приложениях вместо этого приёма рекомендует-
ся использовать INSERT с ON CONFLICT DO UPDATE. Данный пример предназначен в первую очередь
для демонстрации управления выполнением PL/pgSQL:
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);
CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
<script type="math/tex">BEGIN
LOOP
-- сначала попытаться изменить запись по ключу
UPDATE db SET b = data WHERE a = key;
IF found THEN
RETURN;
END IF;
-- записи с таким ключом нет, поэтому её нужно добавить
-- если параллельно будет вставлена запись с таким же ключом,
-- произойдёт ошибка уникальности
BEGIN
1150PL/pgSQL — проце-
дурный язык SQL
INSERT INTO db(a,b) VALUES (key, data);
RETURN;
EXCEPTION WHEN unique_violation THEN
-- здесь не нужно ничего делать,
-- просто продолжить цикл, чтобы повторить UPDATE.
END;
END LOOP;
END;</script>
LANGUAGE plpgsql;
SELECT merge_db(1, ‘david’);
SELECT merge_db(1, ‘dennis’);
В этом коде предполагается, что ошибка unique_violation вызывается самой командой INSERT, а
не, скажем, внутренним оператором INSERT в функции триггера для этой таблицы. Некорректное
поведение также возможно, если в таблице будет несколько уникальных индексов; тогда операция
будет повторяться вне зависимости от того, нарушение какого индекса вызвало ошибку. Используя
средства, рассмотренные далее, можно сделать код более надёжным, проверяя, что перехвачена
именно ожидаемая ошибка.
43.6.8.1. Получение информации об ошибке
При обработке исключений часто бывает необходимым получить детальную информацию о про-
изошедшей ошибке. Для этого в PL/pgSQL есть два способа: использование специальных перемен-
ных и команда GET STACKED DIAGNOSTICS.
Внутри секции EXCEPTION специальная переменная SQLSTATE содержит код ошибки, для которой
было вызвано исключение (список возможных кодов ошибок приведён в Таблице A.1). Специальная
переменная SQLERRM содержит сообщение об ошибке, связанное с исключением. Эти переменные
являются неопределёнными вне секции EXCEPTION.
Также в обработчике исключения можно получить информацию о текущем исключении командой
GET STACKED DIAGNOSTICS, которая имеет вид:
GET STACKED DIAGNOSTICS переменная { = | := } элемент [ , … ];
Каждый элемент представляется ключевым словом, указывающим, какое значение состояния нуж-
но присвоить заданной переменной (она должна иметь подходящий тип данных, чтобы принять
его). Доступные в настоящее время элементы состояния показаны в Таблице 43.2.
Таблица 43.2. Элементы диагностики ошибок
Имя Тип Описание
RETURNED_SQLSTATE text код исключения,
мый SQLSTATE
COLUMN_NAME text имя столбца, относящегося к
исключению
CONSTRAINT_NAME text имя ограничения целостности,
относящегося к исключению
PG_DATATYPE_NAME text имя типа данных, относящегося
к исключению
MESSAGE_TEXT text текст основного сообщения ис-
ключения
TABLE_NAME text имя таблицы, относящейся к ис-
ключению
SCHEMA_NAME text имя схемы, относящейся к ис-
ключению
1151
возвращае-PL/pgSQL — проце-
дурный язык SQL
Имя Тип Описание
PG_EXCEPTION_DETAIL text текст детального сообщения ис-
ключения (если есть)
PG_EXCEPTION_HINT text текст подсказки к исключению
(если есть)
PG_EXCEPTION_CONTEXT text строки текста, описывающие
стек вызовов в момент исключе-
ния (см. Подраздел 43.6.9)
Если исключение не устанавливает значение для идентификатора, то возвращается пустая строка.
Пример:
DECLARE
text_var1 text;
text_var2 text;
text_var3 text;
BEGIN
– здесь происходит обработка, которая может вызвать исключение
…
EXCEPTION WHEN OTHERS THEN
GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
text_var2 = PG_EXCEPTION_DETAIL,
text_var3 = PG_EXCEPTION_HINT;
END;
43.6.9. Получение информации о месте выполнения
Команда GET DIAGNOSTICS, ранее описанная в Подразделе 43.5.5, получает информацию о текущем
состоянии выполнения кода (тогда как команда GET STACKED DIAGNOSTICS, рассмотренная ранее,
выдаёт информацию о состоянии выполнения в момент предыдущей ошибки). Её элемент состо-
яния PG_CONTEXT позволяет определить текущее место выполнения кода. PG_CONTEXT возвращает
текст с несколькими строками, описывающий стек вызова. В первой строке отмечается текущая
функция и выполняемая в данный момент команда GET DIAGNOSTICS, а во второй и последующих
строках отмечаются функции выше по стеку вызовов. Например:
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS <script type="math/tex">BEGIN
RETURN inner_func();
END;</script> LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS <script type="math/tex">DECLARE
stack text;
BEGIN
GET DIAGNOSTICS stack = PG_CONTEXT;
RAISE NOTICE E'--- Стек вызова ---\n%', stack;
RETURN 1;
END;</script> LANGUAGE plpgsql;
SELECT outer_func();
NOTICE: — Стек вызова —
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT: PL/pgSQL function outer_func() line 3 at RETURN
1152PL/pgSQL — проце-
дурный язык SQL
outer_func
————
1
(1 row)
GET STACKED DIAGNOSTICS … PG_EXCEPTION_CONTEXT возвращает похожий стек вызовов, но опи-
сывает не текущее место, а место, в котором произошла ошибка.
43.7. Курсоры
Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить курсор, инкапсули-
рующий запрос, и затем получать результат запроса по нескольку строк за раз. Одна из причин
так делать заключается в том, чтобы избежать переполнения памяти, когда результат содержит
большое количество строк. (Пользователям PL/pgSQL не нужно об этом беспокоиться, так как цик-
лы FOR автоматически используют курсоры, чтобы избежать проблем с памятью.) Более интерес-
ным вариантом использования является возврат из функции ссылки на курсор, что позволяет вы-
зывающему получать строки запроса. Это эффективный способ получать большие наборы строк
из функций.
43.7.1. Объявление курсорных переменных
Доступ к курсорам в PL/pgSQL осуществляется через курсорные переменные, которые всегда име-
ют специальный тип данных refcursor. Один из способов создать курсорную переменную, просто
объявить её как переменную типа refcursor. Другой способ заключается в использовании синтак-
сиса объявления курсора, который в общем виде выглядит так:
имя [ [ NO ] SCROLL ] CURSOR [ ( аргументы ) ] FOR запрос;
(Для совместимости с Oracle, FOR можно заменять на IS.) С указанием SCROLL курсор можно будет
прокручивать назад. При NO SCROLL прокрутка назад не разрешается. Если ничего не указано, то
возможность прокрутки назад зависит от запроса. Если указаны аргументы, то они должны пред-
ставлять собой пары имя тип_данных, разделённые через запятую. Эти пары определяют имена,
которые будут заменены значениями параметров в данном запросе. Фактические значения для
замены этих имён появятся позже, при открытии курсора.
Примеры:
DECLARE
curs1 refcursor;
curs2 CURSOR FOR SELECT * FROM tenk1;
curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
Все три переменные имеют тип данных refcursor. Первая может быть использована с любым за-
просом, вторая связана (bound) с полностью сформированным запросом, а последняя связана с
параметризованным запросом. (key будет заменён целочисленным значением параметра при от-
крытии курсора.) Про переменную curs1 говорят, что она является несвязанной (unbound), так как
к ней не привязан никакой запрос.
43.7.2. Открытие курсора
Прежде чем получать строки из курсора, его нужно открыть. (Это эквивалентно действию SQL-
команды DECLARE CURSOR.) В PL/pgSQL есть три формы оператора OPEN, две из которых использу-
ются для несвязанных курсорных переменных, а третья для связанных.
Примечание
Связанные курсорные переменные можно использовать с циклом FOR без явного от-
крытия курсора, как описано в Подразделе 43.7.4.
1153PL/pgSQL — проце-
дурный язык SQL
43.7.2.1. OPEN FOR запрос
OPEN несвязанная_переменная_курсора [[NO] SCROLL] FOR запрос;
Курсорная переменная открывается и получает конкретный запрос для выполнения. Курсор не
может уже быть открытым, а курсорная переменная обязана быть несвязанной (то есть просто
переменной типа refcursor). Запрос должен быть командой SELECT или любой другой, которая
возвращает строки (к примеру EXPLAIN). Запрос обрабатывается так же, как и другие команды SQL
в PL/pgSQL: имена переменных PL/pgSQL заменяются на значения, план запроса кешируется для
повторного использования. Подстановка значений переменных PL/pgSQL проводится при откры-
тии курсора командой OPEN, последующие изменения значений переменных не влияют на работу
курсора. SCROLL и NO SCROLL имеют тот же смысл, что и для связанного курсора.
Пример:
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
43.7.2.2. OPEN FOR EXECUTE
OPEN несвязанная_переменная_курсора [[NO] SCROLL] FOR EXECUTE строка_запроса
[USING выражение [, …]];
Переменная курсора открывается и получает конкретный запрос для выполнения. Курсор не мо-
жет быть уже открыт и он должен быть объявлен как несвязанная переменная курсора (то есть,
как просто переменная refcursor). Запрос задаётся строковым выражением, так же, как в команде
EXECUTE. Как обычно, это даёт возможность гибко менять план запроса от раза к разу (см. Подраз-
дел 43.11.2). Это также означает, что замена переменных происходит не в самой строке команды.
Как и с EXECUTE, значения параметров вставляются в динамическую команду, используя format()
и USING. Параметры SCROLL и NO SCROLL здесь действуют так же, как и со связанным курсором.
Пример:
OPEN curs1 FOR EXECUTE format(‘SELECT * FROM %I WHERE col1 = $1’,tabname) USING
keyvalue;
В этом примере в текст запроса вставляется имя таблицы с применением format(). Значение,
сравниваемое с col1, вставляется посредством параметра USING, так что заключать его в апостро-
фы не нужно.
43.7.2.3. Открытие связанного курсора
OPEN связанная_переменная_курсора [( [имя_аргумента :=] значение_аргумента [, …] )];
Эта форма OPEN используется для открытия курсорной переменной, которая была связана с запро-
сом при объявлении. Курсор не может уже быть открытым. Список фактических значений аргу-
ментов должен присутствовать только в том случае, если курсор объявлялся с параметрами. Эти
значения будут подставлены в запрос.
План запроса для связанного курсора всегда считается кешируемым. В этом случае, нет эквива-
лента EXECUTE. Обратите внимание, что SCROLL и NO SCROLL не могут быть указаны в этой форме
OPEN, возможность прокрутки назад была определена при объявлении курсора.
При передаче значений аргументов можно использовать позиционную или именную нотацию. В
позиционной нотации все аргументы указываются по порядку. В именной нотации имя каждого
аргумента отделяется от выражения аргумента с помощью :=. Это подобно вызову функций, опи-
санному в Разделе 4.3. Также разрешается смешивать позиционную и именную нотации.
Примеры (здесь используются ранее объявленные курсоры):
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
1154PL/pgSQL — проце-
дурный язык SQL
Так как для связанного курсора выполняется подстановка значений переменных, то, на самом
деле, существует два способа передать значения в курсор. Либо использовать явные аргументы
в OPEN, либо неявно, ссылаясь на переменные PL/pgSQL в запросе. В связанном курсоре можно
ссылаться только на те переменные, которые были объявлены до самого курсора. В любом случае,
значение переменной для подстановки в запрос будет определяться на момент выполнения OPEN.
Вот ещё один способ получить тот же результат с curs3, как в примере выше:
DECLARE
key integer;
curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
key := 42;
OPEN curs4;
43.7.3. Использование курсоров
После того как курсор будет открыт, с ним можно работать при помощи описанных здесь опера-
торов.
Работать с курсором необязательно в той же функции, где он был открыт. Из функции можно
вернуть значение с типом refcursor, что позволит вызывающему продолжить работу с курсором.
(Внутри refcursor представляет собой обычное строковое имя так называемого портала, содер-
жащего активный запрос курсора. Это имя можно передавать, присваивать другим переменным с
типом refcursor и так далее, при этом портал не нарушается.)
Все порталы неявно закрываются в конце транзакции, поэтому значение refcursor можно исполь-
зовать для ссылки на открытый курсор только до конца транзакции.
43.7.3.1. FETCH
FETCH [направление { FROM | IN }] курсор INTO цель;
FETCH извлекает следующую строку из курсора в цель. В качестве цели может быть строковая пе-
ременная, переменная типа record, или разделённый запятыми список простых переменных, как
и в SELECT INTO. Если следующей строки нет, цели присваивается NULL. Как и в SELECT INTO,
проверить, была ли получена запись, можно при помощи специальной переменной FOUND.
Здесь направление может быть любым допустимым в SQL-команде FETCH вариантом, кроме тех,
что извлекают более одной строки. А именно: NEXT, PRIOR, FIRST, LAST, ABSOLUTE число, RELATIVE
число, FORWARD или BACKWARD. Без указания направления подразумевается вариант NEXT. Везде, где
используется число, оно может определяться любым целочисленным выражением (в отличие от
SQL-команды FETCH, допускающей только целочисленные константы). Значения направления, ко-
торые требуют перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт
с указанием SCROLL.
курсор это переменная с типом refcursor, которая ссылается на открытый портал курсора.
Примеры:
FETCH
FETCH
FETCH
FETCH
curs1 INTO rowvar;
curs2 INTO foo, bar, baz;
LAST FROM curs3 INTO x, y;
RELATIVE -2 FROM curs4 INTO x;
43.7.3.2. MOVE
MOVE [направление { FROM | IN }] курсор;
MOVE перемещает курсор без извлечения данных. MOVE работает точно также как и FETCH, но при
этом только перемещает курсор и не извлекает строку, к которой переместился. Как и в SELECT
INTO, проверить успешность перемещения можно с помощью специальной переменной FOUND.
1155PL/pgSQL — проце-
дурный язык SQL
Примеры:
MOVE
MOVE
MOVE
MOVE
curs1;
LAST FROM curs3;
RELATIVE -2 FROM curs4;
FORWARD 2 FROM curs4;
43.7.3.3. UPDATE/DELETE WHERE CURRENT OF
UPDATE таблица SET … WHERE CURRENT OF курсор;
DELETE FROM таблица WHERE CURRENT OF курсор;
Когда курсор позиционирован на строку таблицы, эту строку можно изменить или удалить при по-
мощи курсора. Есть ограничения на то, каким может быть запрос курсора (в частности, не должно
быть группировок), и крайне желательно использовать указание FOR UPDATE. За дополнительными
сведениями обратитесь к странице справки DECLARE.
Пример:
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
43.7.3.4. CLOSE
CLOSE курсор;
CLOSE закрывает связанный с курсором портал. Используется для того, чтобы освободить ресурсы
раньше, чем закончится транзакция, или чтобы освободить курсорную переменную для повторно-
го открытия.
Пример:
CLOSE curs1;
43.7.3.5. Возврат курсора из функции
Курсоры можно возвращать из функции на PL/pgSQL. Это полезно, когда нужно вернуть множество
строк и столбцов, особенно если выборки очень большие. Для этого, в функции открывается кур-
сор и его имя возвращается вызывающему (или просто открывается курсор, используя указанное
имя портала, каким-либо образом известное вызывающему). Вызывающий затем может извлекать
строки из курсора. Курсор может быть закрыт вызывающим или он будет автоматически закрыт
при завершении транзакции.
Имя портала, используемое для курсора, может быть указано разработчиком или будет генериро-
ваться автоматически. Чтобы указать имя портала, нужно просто присвоить строку в переменную
refcursor перед его открытием. Значение строки переменной refcursor будет использоваться ко-
мандой OPEN как имя портала. Однако, если переменная refcursor имеет значение NULL, OPEN
автоматически генерирует имя, которое не конфликтует с любым существующим порталом и при-
сваивает его переменной refcursor.
Примечание
Связанная курсорная переменная инициализируется в строковое значение, представ-
ляющее собой имя самой переменной. Таким образом, имя портала совпадает с именем
курсорной переменной, кроме случаев, когда разработчик переопределил имя, при-
своив новое значение перед открытием курсора. Несвязанная курсорная переменная
инициализируется в NULL и получит автоматически сгенерированное уникальное имя,
если не будет переопределена.
Следующий пример показывает один из способов передачи имени курсора вызывающему:
CREATE TABLE test (col text);
INSERT INTO test VALUES (‘123’);
1156PL/pgSQL — проце-
дурный язык SQL
CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS ‘
BEGIN
OPEN $1 FOR SELECT col FROM test;
RETURN $1;
END;
‘ LANGUAGE plpgsql;
BEGIN;
SELECT reffunc(‘funccursor’);
FETCH ALL IN funccursor;
COMMIT;
В следующем примере используется автоматическая генерация имени курсора:
CREATE FUNCTION reffunc2() RETURNS refcursor AS ‘
DECLARE
ref refcursor;
BEGIN
OPEN ref FOR SELECT col FROM test;
RETURN ref;
END;
‘ LANGUAGE plpgsql;
– для использования курсоров, необходимо начать транзакцию
BEGIN;
SELECT reffunc2();
reffunc2
——————–</p>
</blockquote>
<p>&lt;unnamed cursor 1&gt;
(1 row)
FETCH ALL IN “&lt;unnamed cursor 1&gt;”;
COMMIT;
В следующем примере показан один из способов вернуть несколько курсоров из одной функции:
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS <script type="math/tex">BEGIN
OPEN $1 FOR SELECT * FROM table_1;
RETURN NEXT $1;
OPEN $2 FOR SELECT * FROM table_2;
RETURN NEXT $2;
END;</script> LANGUAGE plpgsql;
– для использования курсоров необходимо начать транзакцию
BEGIN;
SELECT * FROM myfunc(‘a’, ‘b’);
FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
43.7.4. Обработка курсора в цикле
Один из вариантов цикла FOR позволяет перебирать строки, возвращённые курсором. Вот его син-
таксис:
1157PL/pgSQL — проце-
дурный язык SQL
[ «метка» ]
FOR переменная-запись IN связанная_переменная_курсора [ ( [ имя_аргумента
:= ] значение_аргумента [, …] ) ] LOOP
операторы
END LOOP [ метка ];
Курсорная переменная должна быть связана с запросом при объявлении. Курсор не может быть
открытым. Команда FOR автоматически открывает курсор и автоматически закрывает при завер-
шении цикла. Список фактических значений аргументов должен присутствовать только в том слу-
чае, если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос, также как
и при выполнении OPEN (см. Подраздел 43.7.2.3).
Данная переменная-запись автоматически определяется как переменная типа record и существу-
ет только внутри цикла (другие объявленные переменные с таким именем игнорируется в цикле).
Каждая возвращаемая курсором строка последовательно присваивается этой переменной и вы-
полняется тело цикла.
43.8. Управление транзакциями
В процедурах, вызываемых командой CALL, а также в анонимных блоках кода (в команде DO) мож-
но завершать транзакции, выполняя COMMIT и ROLLBACK. После завершения транзакции этими ко-
мандами новая будет начата автоматически, поэтому отдельной команды START TRANSACTION нет.
(Заметьте, что команды BEGIN и END в PL/pgSQL имеют другой смысл.)
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS <script type="math/tex">BEGIN
FOR i IN 0..9 LOOP
INSERT INTO test1 (a) VALUES (i);
IF i % 2 = 0 THEN
COMMIT;
ELSE
ROLLBACK;
END IF;
END LOOP;
END</script>;
CALL transaction_test1();
Управление транзакциями возможно только в вызовах CALL или DO в коде верхнего уровня или
во вложенных CALL или DO без других промежуточных команд. Например, в стеке вызовов CALL
proc1() → CALL proc2() → CALL proc3() вторая и третья процедуры могут управлять транзакциями.
Но в стеке CALL proc1() → SELECT func2() → CALL proc3() последняя процедура лишена этой
возможности из-за промежуточного SELECT.
Циклам с курсорами присущи некоторые особенности. Рассмотрите этот пример:
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS <script type="math/tex">DECLARE
r RECORD;
BEGIN
FOR r IN SELECT * FROM test2 ORDER BY x LOOP
INSERT INTO test1 (a) VALUES (r.x);
1158PL/pgSQL — проце-
дурный язык SQL
COMMIT;
END LOOP;
END;</script>;
CALL transaction_test2();
Обычно курсоры автоматически закрываются при фиксировании транзакции. Однако курсор, со-
здаваемый внутри цикла подобным образом, автоматически преобразуется в удерживаемый кур-
сор первой командой COMMIT или ROLLBACK. Это означает, что курсор полностью вычисляется при
выполнении первой команды COMMIT или ROLLBACK, а не для каждой очередной строки. При этом он
автоматически удаляется после цикла, так что это происходит практически незаметно для поль-
зователя.
Команды управления транзакциями не допускаются в циклах с курсором, которыми управляют
запросы, производящие не только чтение, но и модификацию данных (например, UPDATE …
RETURNING).
Транзакция не может завершаться внутри блока с обработчиками исключений.
43.9. Сообщения и ошибки
43.9.1. Вывод сообщений и ошибок
Команда RAISE предназначена для вывода сообщений и вызова ошибок.
RAISE [
[, …
RAISE [
RAISE [
RAISE [
RAISE ;
уровень
] ];
уровень
уровень
уровень
] ‘формат’ [, выражение [, … ]] [ USING параметр = значение
] имя_условия [ USING параметр = выражение [, … ] ];
] SQLSTATE ‘sqlstate’ [ USING параметр = выражение [, … ] ];
] USING параметр = выражение [, … ];
уровень задаёт уровень важности ошибки. Возможные значения: DEBUG, LOG, INFO, NOTICE, WARNING
и EXCEPTION. По умолчанию используется EXCEPTION. EXCEPTION вызывает ошибку (что обычно пре-
рывает текущую транзакцию), остальные значения уровня только генерируют сообщения с раз-
личными уровнями приоритета. Будут ли сообщения конкретного приоритета переданы клиенту
или записаны в журнал сервера, или и то, и другое, зависит от конфигурационных переменных
log_min_messages и client_min_messages. За дополнительными сведениями обратитесь к Главе 19.
После указания уровня, если оно есть, можно задать формат (это должна быть простая строковая
константа, не выражение). Строка формата определяет вид текста об ошибке, который будет вы-
дан. За строкой формата могут следовать необязательные выражения аргументов, которые будут
вставлены в сообщение. Внутри строки формата знак % заменяется строковым представлением
значения очередного аргумента. Чтобы выдать символ % буквально, продублируйте его (как %%).
Число аргументов должно совпадать с числом местозаполнителей % в строке формата, иначе при
компиляции функции возникнет ошибка.
В следующем примере символ % будет заменён на значение v_job_id:
RAISE NOTICE ‘Вызов функции cs_create_job(%)’, v_job_id;
При помощи USING и последующих элементов параметр = выражение можно добавить дополнитель-
ную информацию к отчёту об ошибке. Все выражения представляют собой строковые выражения.
Возможные ключевые слова для параметра следующие:
MESSAGE
Устанавливает текст сообщения об ошибке. Этот параметр не может использоваться, если в
команде RAISE присутствует формат перед USING.
1159PL/pgSQL — проце-
дурный язык SQL
DETAIL
Предоставляет детальное сообщение об ошибке.
HINT
Предоставляет подсказку по вызванной ошибке.
ERRCODE
Устанавливает код ошибки (SQLSTATE). Код ошибки задаётся либо по имени, как показано в
Приложении A, или напрямую, пятисимвольный код SQLSTATE.
COLUMN
CONSTRAINT
DATATYPE
TABLE
SCHEMA
Предоставляет имя соответствующего объекта, связанного с ошибкой.
Этот пример прерывает транзакцию и устанавливает сообщение об ошибке с подсказкой:
RAISE EXCEPTION ‘Несуществующий ID –&gt; %’, user_id
USING HINT = ‘Проверьте ваш пользовательский ID’;
Следующие два примера демонстрируют эквивалентные способы задания SQLSTATE:
RAISE ‘Duplicate user ID: %’, user_id USING ERRCODE = ‘unique_violation’;
RAISE ‘Duplicate user ID: %’, user_id USING ERRCODE = ‘23505’;
У команды RAISE есть и другой синтаксис, в котором в качестве главного аргумента используется
имя или код SQLSTATE ошибки. Например:
RAISE division_by_zero;
RAISE SQLSTATE ‘22012’;
Предложение USING в этом синтаксисе можно использовать для того, чтобы переопределить стан-
дартное сообщение об ошибке, детальное сообщение, подсказку. Ещё один вариант предыдущего
примера:
RAISE unique_violation USING MESSAGE = ‘ID пользователя уже существует: ‘ || user_id;
Ещё один вариант — использовать RAISE USING или RAISE уровень USING, а всё остальное записать
в списке USING.
И заключительный вариант, в котором RAISE не имеет параметров вообще. Эта форма может ис-
пользоваться только в секции EXCEPTION блока и предназначена для того, чтобы повторно вызвать
ошибку, которая сейчас перехвачена и обрабатывается.
Примечание
До версии PostgreSQL 9.1 команда RAISE без параметров всегда вызывала ошибку с
выходом из блока, содержащего активную секцию EXCEPTION. Эту ошибку нельзя было
перехватить, даже если RAISE в секции EXCEPTION поместить во вложенный блок со
своей секцией EXCEPTION. Это было сочтено удивительным и не совместимым с Oracle
PL/SQL.
Если в команде RAISE EXCEPTION не задано ни имя, ни SQLSTATE код, то по умолчанию используются
RAISE_EXCEPTION (P0001). В качестве текста сообщения об ошибке (если не задан) используется
имя или SQLSTATE код.
1160PL/pgSQL — проце-
дурный язык SQL
Примечание
При задании SQLSTATE кода необязательно использовать только список предопределён-
ных кодов ошибок. В качестве кода ошибки может быть любое пятисимвольное значе-
ние, состоящее из цифр и/или ASCII символов в верхнем регистре, кроме 00000. Не ре-
комендуется использовать коды ошибок, которые заканчиваются на 000, потому что
так обозначаются коды категорий. И чтобы их перехватить, нужно перехватывать це-
лую категорию.
43.9.2. Проверка утверждений
Оператор ASSERT представляет удобное средство вставлять отладочные проверки в функции PL/
pgSQL.
ASSERT условие [ , сообщение ];
Здесь условие — это булевское выражение, которое, как ожидается, должно быть всегда истин-
ным; если это так, оператор ASSERT больше ничего не делает. Если же оно возвращает ложь или
NULL, этот оператор выдаёт исключение ASSERT_FAILURE. (Если ошибка происходит при вычисле-
нии условия, она выдаётся как обычная ошибка.)
Если в нём задаётся необязательное сообщение, результат этого выражения (если он не NULL) за-
меняет сообщение об ошибке по умолчанию «assertion failed» (нарушение истинности), в случае,
если условие не выполняется. В обычном случае, когда условие утверждения выполняется, выра-
жение сообщения не вычисляется.
Проверку утверждений можно включить или отключить с помощью конфигурационного парамет-
ра plpgsql.check_asserts, принимающего булевское значение; по умолчанию она включена (on).
Если этот параметр отключён (off), операторы ASSERT ничего не делают.
Учтите, что оператор ASSERT предназначен для выявления программных дефектов, а не для вывода
обычных ошибок (для этого используется оператор RAISE, описанный выше).
43.10. Триггерные функции
В PL/pgSQL можно создавать триггерные функции, которые будут вызываться при изменениях
данных или событиях в базе данных. Триггерная функция создаётся командой CREATE FUNCTION,
при этом у функции не должно быть аргументов, а типом возвращаемого значения должен быть
trigger (для триггеров, срабатывающих при изменениях данных) или event_trigger (для тригге-
ров, срабатывающих при событиях в базе). Для триггеров автоматически определяются специаль-
ные локальные переменные с именами вида TG_имя, описывающие условие, повлёкшее вызов триг-
гера.
43.10.1. Триггеры при изменении данных
Триггер при изменении данных объявляется как функция без аргументов и с типом результата
trigger. Заметьте, что эта функция должна объявляться без аргументов, даже если ожидается,
что она будет получать аргументы, заданные в команде CREATE TRIGGER — такие аргументы пере-
даются через TG_ARGV, как описано ниже.
Когда функция на PL/pgSQL срабатывает как триггер, в блоке верхнего уровня автоматически со-
здаются несколько специальных переменных:
NEW
Тип данных RECORD. Переменная содержит новую строку базы данных для команд INSERT/UPDATE
в триггерах уровня строки. В триггерах уровня оператора и для команды DELETE этой перемен-
ной значение не присваивается.
1161PL/pgSQL — проце-
дурный язык SQL
OLD
Тип данных RECORD. Переменная содержит старую строку базы данных для команд UPDATE/
DELETE в триггерах уровня строки. В триггерах уровня оператора и для команды INSERT этой
переменной значение не присваивается.
TG_NAME
Тип данных name. Переменная содержит имя сработавшего триггера.
TG_WHEN
Тип данных text. Строка, содержащая BEFORE, AFTER или INSTEAD OF, в зависимости от опреде-
ления триггера.
TG_LEVEL
Тип данных text. Строка, содержащая ROW или STATEMENT, в зависимости от определения триг-
гера.
TG_OP
Тип данных text. Строка, содержащая INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от
того, для какой операции сработал триггер.
TG_RELID
Тип данных oid. OID таблицы, для которой сработал триггер.
TG_RELNAME
Тип данных name. Имя таблицы, для которой сработал триггер. Эта переменная устарела и мо-
жет стать недоступной в будущих релизах. Вместо неё нужно использовать TG_TABLE_NAME.
TG_TABLE_NAME
Тип данных name. Имя таблицы, для которой сработал триггер.
TG_TABLE_SCHEMA
Тип данных name. Имя схемы, содержащей таблицу, для которой сработал триггер.
TG_NARGS
Тип данных integer. Число аргументов в команде CREATE TRIGGER, которые передаются в триг-
герную функцию.
TG_ARGV[]
Тип данных массив text. Аргументы от оператора CREATE TRIGGER. Индекс массива начинается
с 0. Для недопустимых значений индекса ( &lt; 0 или &gt;= tg_nargs) возвращается NULL.
Триггерная функция должна вернуть либо NULL, либо запись/строку, соответствующую структуре
таблице, для которой сработал триггер.
Если BEFORE триггер уровня строки возвращает NULL, то все дальнейшие действия с этой строкой
прекращаются (т. е. не срабатывают последующие триггеры, команда INSERT/UPDATE/DELETE для
этой строки не выполняется). Если возвращается не NULL, то дальнейшая обработка продолжается
именно с этой строкой. Возвращение строки отличной от начальной NEW, изменяет строку, которая
будет вставлена или изменена. Поэтому, если в триггерной функции нужно выполнить некоторые
действия и не менять саму строку, то нужно возвратить переменную NEW (или её эквивалент). Для
того чтобы изменить сохраняемую строку, можно поменять отдельные значения в переменной NEW
и затем её вернуть. Либо создать и вернуть полностью новую переменную. В случае строчного
триггера BEFORE для команды DELETE само возвращаемое значение не имеет прямого эффекта, но
оно должно быть отличным от NULL, чтобы не прерывать обработку строки. Обратите внимание,
что переменная NEW всегда NULL в триггерах на DELETE, поэтому возвращать её не имеет смысла.
Традиционной идиомой для триггеров DELETE является возврат переменной OLD.
1162PL/pgSQL — проце-
дурный язык SQL
Триггеры INSTEAD OF (это всегда триггеры уровня строк и они могут применяться только с пред-
ставлениями) могут возвращать NULL, чтобы показать, что они не выполняли никаких изменений,
так что обработку этой строки можно не продолжать (то есть, не вызывать последующие триггеры
и не считать строку в числе обработанных строк для окружающих команд INSERT/UPDATE/DELETE).
В противном случае должно быть возвращено значение, отличное от NULL, показывающее, что
триггер выполнил запрошенную операцию. Для операций INSERT и UPDATE возвращаемым значе-
нием должно быть NEW, которое триггерная функция может модифицировать для поддержки пред-
ложений INSERT RETURNING и UPDATE RETURNING (это также повлияет на значение строки, переда-
ваемое последующим триггерам, или доступное под специальным псевдонимом EXCLUDED в опера-
торе INSERT с предложением ON CONFLICT DO UPDATE). Для операций DELETE возвращаемым значе-
нием должно быть OLD.
Возвращаемое значение для строчного триггера AFTER и триггеров уровня оператора (BEFORE
или AFTER) всегда игнорируется. Это может быть и NULL. Однако, в этих триггерах по-прежнему
можно прервать вызвавшую их команду, для этого нужно явно вызвать ошибку.
Пример 43.3 показывает пример триггерной функции в PL/pgSQL.
Пример 43.3. Триггерная функция на PL/pgSQL
Триггер, показанный в этом примере, при любом добавлении или изменении строки в таблице
сохраняет в этой строке информацию о текущем пользователе и отметку времени. Кроме того, он
требует, чтобы было указано имя сотрудника и зарплата задавалась положительным числом.
CREATE TABLE emp (
empname text,
salary integer,
last_date timestamp,
last_user text
);
CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
BEGIN
– Проверить, что указаны имя сотрудника и зарплата
IF NEW.empname IS NULL THEN
RAISE EXCEPTION ‘empname cannot be null’;
END IF;
IF NEW.salary IS NULL THEN
RAISE EXCEPTION ‘% cannot have null salary’, NEW.empname;
END IF;
– Кто будет работать, если за это надо будет платить?
IF NEW.salary &lt; 0 THEN
RAISE EXCEPTION ‘% cannot have a negative salary’, NEW.empname;
END IF;
– Запомнить, кто и когда изменил запись
NEW.last_date := current_timestamp;
NEW.last_user := current_user;
RETURN NEW;
END;
$emp_stamp$ LANGUAGE plpgsql;
CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW EXECUTE FUNCTION emp_stamp();
Другой вариант ведения журнала изменений для таблицы предполагает создание новой таблицы,
которая будет содержать отдельную запись для каждой выполненной команды INSERT, UPDATE,
1163PL/pgSQL — проце-
дурный язык SQL
DELETE. Этот подход можно рассматривать как протоколирование изменений таблицы для аудита.
Пример 43.4 показывает реализацию соответствующей триггерной функции в PL/pgSQL.
Пример 43.4. Триггерная функция для аудита в PL/pgSQL
Показанный в этом примере триггер гарантирует, что любое добавление, изменение или удаление
строки в таблице emp будет зафиксировано в таблице emp_audit (для аудита). Также он фиксирует
текущее время, имя пользователя и тип выполняемой операции.
CREATE TABLE emp (
empname
salary
);
text NOT NULL,
integer
CREATE TABLE emp_audit(
operation
char(1)
stamp
timestamp
userid
text
empname
text
salary integer
);
NOT
NOT
NOT
NOT
NULL,
NULL,
NULL,
NULL,
CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
BEGIN
–
– Добавление строки в emp_audit, которая отражает операцию, выполняемую в emp;
– для определения типа операции применяется специальная переменная TG_OP.
–
IF (TG_OP = ‘DELETE’) THEN
INSERT INTO emp_audit SELECT ‘D’, now(), user, OLD.<em>;
ELSIF (TG_OP = ‘UPDATE’) THEN
INSERT INTO emp_audit SELECT ‘U’, now(), user, NEW.</em>;
ELSIF (TG_OP = ‘INSERT’) THEN
INSERT INTO emp_audit SELECT ‘I’, now(), user, NEW.*;
END IF;
RETURN NULL; – возвращаемое значение для триггера AFTER игнорируется
END;
$emp_audit$ LANGUAGE plpgsql;
CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
У предыдущего примера есть разновидность, которая использует представление, соединяющее ос-
новную таблицу и таблицу аудита, для отображения даты последнего изменения каждой строки.
При этом подходе по-прежнему ведётся полный журнал аудита в отдельной таблице, но также
имеется представление с упрощенным аудиторским следом. Это представление содержит времен-
ную метку, которая вычисляется для каждой строки из данных аудиторской таблицы. Пример 43.5
показывает пример триггера на представление для аудита в PL/pgSQL.
Пример 43.5. Триггерная функция на PL/pgSQL для аудита в представлении
В этом примере триггер, связанный с представлением, делает это представление изменяемым и
гарантирует, что любая команда на добавление, изменение или удаление строки в представлении
будет записана для аудита в таблицу emp_audit. Также записываются временная метка, имя поль-
зователя и тип выполняемой операции. Представление показывает дату последнего изменения
для каждой строки.
CREATE TABLE emp (
empname
salary
text PRIMARY KEY,
integer
1164PL/pgSQL — проце-
дурный язык SQL
);
CREATE TABLE emp_audit(
operation
char(1)
userid
text
empname
text
salary
integer,
stamp
timestamp
);
NOT NULL,
NOT NULL,
NOT NULL,
NOT NULL
CREATE VIEW emp_view AS
SELECT e.empname,
e.salary,
max(ea.stamp) AS last_updated
FROM emp e
LEFT JOIN emp_audit ea ON ea.empname = e.empname
GROUP BY 1, 2;
CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS <script type="math/tex">BEGIN
--
-- Выполнить требуемую операцию в emp и добавить в emp_audit строку,
-- отражающую эту операцию.
--
IF (TG_OP = 'DELETE') THEN
DELETE FROM emp WHERE empname = OLD.empname;
IF NOT FOUND THEN RETURN NULL; END IF;
OLD.last_updated = now();
INSERT INTO emp_audit VALUES('D', user, OLD.*);
RETURN OLD;
ELSIF (TG_OP = 'UPDATE') THEN
UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
IF NOT FOUND THEN RETURN NULL; END IF;
NEW.last_updated = now();
INSERT INTO emp_audit VALUES('U', user, NEW.*);
RETURN NEW;
ELSIF (TG_OP = 'INSERT') THEN
INSERT INTO emp VALUES(NEW.empname, NEW.salary);
NEW.last_updated = now();
INSERT INTO emp_audit VALUES('I', user, NEW.*);
RETURN NEW;
END IF;
END;</script> LANGUAGE plpgsql;
CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
FOR EACH ROW EXECUTE FUNCTION update_emp_view();
Один из вариантов использования триггеров это поддержание в актуальном состоянии отдельной
таблицы итогов для некоторой таблицы. В некоторых случаях отдельная таблица с итогами мо-
жет использоваться в запросах вместо основной таблицы. При этом зачастую время выполнения
запросов значительно сокращается. Эта техника широко используется в хранилищах данных, где
таблицы фактов могут быть очень большими. Пример 43.6 демонстрирует триггерную функцию на
PL/pgSQL, которая поддерживает таблицу итогов для таблицы фактов в хранилище данных.
1165PL/pgSQL — проце-
дурный язык SQL
Пример 43.6. Триггерная функция на PL/pgSQL для ведения таблицы итогов
Представленная здесь схема данных частично основана на примере Grocery Store из книги The
Data Warehouse Toolkit (автор Ralph Kimball).
–
– Основные таблицы: таблица временных периодов и таблица фактов продаж
–
CREATE TABLE time_dimension (
time_key
integer NOT NULL,
day_of_week
integer NOT NULL,
day_of_month
integer NOT NULL,
month
integer NOT NULL,
quarter
integer NOT NULL,
year
integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);
CREATE TABLE sales_fact (
time_key
product_key
store_key
amount_sold
units_sold
amount_cost
);
CREATE INDEX sales_fact_time ON
integer NOT NULL,
integer NOT NULL,
integer NOT NULL,
numeric(12,2) NOT NULL,
integer NOT NULL,
numeric(12,2) NOT NULL
sales_fact(time_key);
–
– Таблица с итогами продаж по периодам
–
CREATE TABLE sales_summary_bytime (
time_key
integer NOT NULL,
amount_sold
numeric(15,2) NOT NULL,
units_sold
numeric(12) NOT NULL,
amount_cost
numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);
–
– Функция и триггер для пересчёта столбцов итогов при выполнении
– команд INSERT, UPDATE, DELETE
–
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
DECLARE
delta_time_key
integer;
delta_amount_sold
numeric(15,2);
delta_units_sold
numeric(12);
delta_amount_cost
numeric(15,2);
BEGIN
– Вычислить изменение количества/суммы.
IF (TG_OP = ‘DELETE’) THEN
delta_time_key = OLD.time_key;
delta_amount_sold = -1 * OLD.amount_sold;
delta_units_sold = -1 * OLD.units_sold;
delta_amount_cost = -1 * OLD.amount_cost;
1166PL/pgSQL — проце-
дурный язык SQL
ELSIF (TG_OP = ‘UPDATE’) THEN
–
–
–
IF
Запретить изменение time_key -
(это ограничение не должно вызвать неудобств, так как
в основном изменения будут выполняться по схеме DELETE + INSERT).
( OLD.time_key != NEW.time_key) THEN
RAISE EXCEPTION ‘Update of time_key : % -&gt; % not allowed’,
OLD.time_key, NEW.time_key;
END IF;
delta_time_key = OLD.time_key;
delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
delta_units_sold = NEW.units_sold - OLD.units_sold;
delta_amount_cost = NEW.amount_cost - OLD.amount_cost;
ELSIF (TG_OP = ‘INSERT’) THEN
delta_time_key = NEW.time_key;
delta_amount_sold = NEW.amount_sold;
delta_units_sold = NEW.units_sold;
delta_amount_cost = NEW.amount_cost;
END IF;
– Внести новые значения в существующую строку итогов или
– добавить новую.
«insert_update»
LOOP
UPDATE sales_summary_bytime
SET amount_sold = amount_sold + delta_amount_sold,
units_sold = units_sold + delta_units_sold,
amount_cost = amount_cost + delta_amount_cost
WHERE time_key = delta_time_key;
EXIT insert_update WHEN found;
BEGIN
INSERT INTO sales_summary_bytime (
time_key,
amount_sold,
units_sold,
amount_cost)
VALUES (
delta_time_key,
delta_amount_sold,
delta_units_sold,
delta_amount_cost
);
EXIT insert_update;
EXCEPTION
WHEN UNIQUE_VIOLATION THEN
– ничего не делать
END;
END LOOP insert_update;
1167PL/pgSQL — проце-
дурный язык SQL
RETURN NULL;
END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;
CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();
INSERT
INSERT
INSERT
INSERT
SELECT
DELETE
SELECT
UPDATE
SELECT
INTO sales_fact VALUES(1,1,1,10,3,15);
INTO sales_fact VALUES(1,2,1,20,5,35);
INTO sales_fact VALUES(2,2,1,40,15,135);
INTO sales_fact VALUES(2,3,1,10,1,13);</p>
<ul>
  <li>FROM sales_summary_bytime;
FROM sales_fact WHERE product_key = 1;</li>
  <li>FROM sales_summary_bytime;
sales_fact SET units_sold = units_sold * 2;</li>
  <li>FROM sales_summary_bytime;
Триггеры AFTER также могут использовать переходные таблицы для просмотра всего набора
строк, изменённых оператором, вызвавшим триггер. Команда CREATE TRIGGER назначает имена
одной или обеим переходным таблицам, а затем функция может по этим именам обращаться к ним
как к временным таблицам только для чтения. Это иллюстрирует Пример 43.7.
Пример 43.7. Организация аудита с переходными таблицами
В данном примере достигается тот же результат, что и в Пример 43.4, но вместо триггера, сраба-
тывающего для каждой строки, в нём используется триггер, срабатывающий единожды для опера-
тора и получающий нужные ему данные в переходной таблице. Это может быть гораздо быстрее,
чем вариант с построчным триггером, когда целевой оператор изменяет сразу множество строк.
Заметьте, что мы должны объявить отдельные триггеры для каждого вида события, так как предло-
жения REFERENCING в каждом случае будут разными. Но это не мешает при желании использовать
одну триггерную функцию. (На практике может быть лучше использовать три отдельные функции
и не проверять TG_OP во время выполнения.)
CREATE TABLE emp (
empname
salary
);
text NOT NULL,
integer
CREATE TABLE emp_audit(
operation
char(1)
stamp
timestamp
userid
text
empname
text
salary integer
);
NOT
NOT
NOT
NOT
NULL,
NULL,
NULL,
NULL,
CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
BEGIN
–
– Добавление строк в emp_audit, которые отражают операции, выполняемые в emp;
– для определения типа операций применяется специальная переменная TG_OP.
–
IF (TG_OP = ‘DELETE’) THEN
INSERT INTO emp_audit
SELECT ‘D’, now(), user, o.* FROM old_table o;
1168PL/pgSQL — проце-
дурный язык SQL
ELSIF (TG_OP = ‘UPDATE’) THEN
INSERT INTO emp_audit
SELECT ‘U’, now(), user, n.* FROM new_table n;
ELSIF (TG_OP = ‘INSERT’) THEN
INSERT INTO emp_audit
SELECT ‘I’, now(), user, n.* FROM new_table n;
END IF;
RETURN NULL; – возвращаемое значение для триггера AFTER игнорируется
END;
$emp_audit$ LANGUAGE plpgsql;
CREATE TRIGGER emp_audit_ins
AFTER INSERT ON emp
REFERENCING NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
AFTER UPDATE ON emp
REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
AFTER DELETE ON emp
REFERENCING OLD TABLE AS old_table
FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
43.10.2. Триггеры событий
В PL/pgSQL можно создавать событийные триггеры. PostgreSQL требует, чтобы функция, которая
вызывается как событийный триггер, объявлялась без аргументов и типом возвращаемого значе-
ния был event_trigger.
Когда функция на PL/pgSQL вызывается как событийный триггер, в блоке верхнего уровня авто-
матически создаются несколько специальных переменных:
TG_EVENT
Тип данных text. Строка, содержащая событие, для которого сработал триггер.
TG_TAG
Тип данных text. Переменная, содержащая тег команды, для которой сработал триггер.
Пример 43.8 демонстрирует реализацию функции событийного триггера на PL/pgSQL.
Пример 43.8. Функция событийного триггера на PL/pgSQL
Триггер в этом примере просто выдаёт сообщение NOTICE каждый раз, когда выполняется поддер-
живаемая команда.
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS <script type="math/tex">BEGIN
RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;</script> LANGUAGE plpgsql;
CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
43.11. PL/pgSQL изнутри
В этом разделе обсуждаются некоторые детали реализации, которые пользователям PL/pgSQL
важно знать.
1169PL/pgSQL — проце-
дурный язык SQL
43.11.1. Подстановка переменных
SQL-операторы и выражения внутри функции на PL/pgSQL могут ссылаться на переменные и пара-
метры этой функции. За кулисами PL/pgSQL заменяет параметры запросов для таких ссылок. Па-
раметры будут заменены только в местах, где параметр или ссылка на столбец синтаксически до-
пустимы. Как крайний случай, рассмотрим следующий пример плохого стиля программирования:
INSERT INTO foo (foo) VALUES (foo);
Первый раз foo появляется на том месте, где синтаксически должно быть имя таблицы, поэтому
замены не будет, даже если функция имеет переменную foo. Второй раз foo встречается там, где
должно быть имя столбца таблицы, поэтому замены не будет и здесь. Только третье вхождение foo
является кандидатом на то, чтобы быть ссылкой на переменную функции.
Примечание
Версии PostgreSQL до 9.0 пытаются заменить переменную во всех трёх случаях, что
приводит к синтаксической ошибке.
Если имена переменных синтаксически не отличаются от названий столбцов таблицы, то возмож-
на двусмысленность и в ссылках на таблицы. Является ли данное имя ссылкой на столбец таблицы
или ссылкой на переменную? Изменим предыдущий пример:
INSERT INTO dest (col) SELECT foo + bar FROM src;
Здесь dest и src должны быть именами таблиц, col должен быть столбцом dest. Однако, foo и bar
могут быть как переменными функции, так и столбцами src.
По умолчанию, PL/pgSQL выдаст ошибку, если имя в операторе SQL может относиться как к пере-
менной, так и к столбцу таблицы. Ситуацию можно исправить переименованием переменной, пе-
реименованием столбца, точной квалификацией неоднозначной ссылки или указанием PL/pgSQL
машине, какую интерпретацию предпочесть.
Самое простое решение — переименовать переменную или столбец. Общее правило кодирования
предполагает использование различных соглашений о наименовании для переменных PL/pgSQL
и столбцов таблиц. Например, если имена переменных всегда имеют вид v_имя, а имена столбцов
никогда не начинаются на v_, то конфликты исключены.
В качестве альтернативы можно дополнить имена неоднозначных ссылок, чтобы сделать их точ-
ными. В приведённом выше примере src.foo однозначно бы определялась, как ссылка на столбец
таблицы. Чтобы сделать однозначной ссылку на переменную, переменная должна быть объявлена
в блоке с меткой, и далее нужно использовать эту метку (см. Раздел 43.2). Например:
«block»
DECLARE
foo int;
BEGIN
foo := …;
INSERT INTO dest (col) SELECT block.foo + bar FROM src;
Здесь block.foo ссылается на переменную, даже если в таблице src есть столбец foo. Парамет-
ры функции, а также специальные переменные, такие как FOUND, могут быть дополнены именем
функции, потому что они неявно объявлены во внешнем блоке, метка которого совпадает с именем
функции.
Иногда может быть не очень практичным исправлять таким способом все неоднозначные ссылки
в большом куске PL/pgSQL кода. В таких случаях можно указать, чтобы PL/pgSQL разрешал неод-
нозначные ссылки в пользу переменных (это совместимо с PL/pgSQL до версии PostgreSQL 9.0),
или в пользу столбцов таблицы (совместимо с некоторыми другими системами, такими как Oracle).
1170PL/pgSQL — проце-
дурный язык SQL
На уровне всей системы поведение PL/pgSQL регулируется установкой конфигурационного па-
раметра plpgsql.variable_conflict, имеющего значения: error, use_variable или use_column
(error устанавливается по умолчанию при установке системы). Изменение этого параметра вли-
яет на все последующие компиляции операторов в функциях на PL/pgSQL, но не на операторы
уже скомпилированные в текущей сессии. Так как изменение этого параметра может привести
к неожиданным изменениям в поведении функций на PL/pgSQL, он может быть изменён только
суперпользователем.
Поведение PL/pgSQL можно изменять для каждой отдельной функции, если добавить в начало
функции одну из этих специальных команд:
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
Эти команды влияют только на функцию, в которой они записаны и перекрывают действие
plpgsql.variable_conflict. Пример:
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS <script type="math/tex">#variable_conflict use_variable
DECLARE
curtime timestamp := now();
BEGIN
UPDATE users SET last_modified = curtime, comment = comment
WHERE users.id = id;
END;</script> LANGUAGE plpgsql;
В команде UPDATE, curtime, comment и id будут ссылаться на переменные и параметры функции вне
зависимости от того, есть ли столбцы с такими именами в таблице users. Обратите внимание, что
нужно дополнить именем таблицы ссылку на users.id в предложении WHERE, чтобы она ссылалась
на столбец таблицы. При этом необязательно дополнять ссылку на comment в левой части списка
UPDATE, так как синтаксически в этом месте должно быть имя столбца таблицы users. Эту функцию
можно было бы записать и без зависимости от значения variable_conflict:
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS <script type="math/tex">% <![CDATA[
<<fn>>
DECLARE
curtime timestamp := now();
BEGIN
UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
WHERE users.id = stamp_user.id;
END; %]]></script> LANGUAGE plpgsql;
Замена переменных не происходит в строке, исполняемой командой EXECUTE или её вариантом.
Если нужно вставлять изменяющиеся значения в такую команду, то это делается либо при постро-
ении самой командной строки или с использованием USING, как показано в Подразделе 43.5.4.
Замена переменных в настоящее время работает только в командах SELECT, INSERT, UPDATE и
DELETE, потому что основная SQL машина допускает использование параметров запроса только в
этих командах. Чтобы использовать изменяемые имена или значения в других типах операторов
(обычно называются утилиты), необходимо построить текст команды в виде строки и выполнить
её в EXECUTE.
43.11.2. Кеширование плана
Интерпретатор PL/pgSQL анализирует исходный текст функции и строит внутреннее бинарное де-
рево инструкций при первом вызове функции (для каждой сессии). В дерево инструкций полностью
переводится вся структура операторов PL/pgSQL, но для выражений и команд SQL, используемых
в функции, это происходит не сразу.
1171PL/pgSQL — проце-
дурный язык SQL
При первом выполнении в функции каждого выражения или команды SQL интерпретатор PL/
pgSQL разбирает и анализирует команду для создания подготовленного к выполнению оператора с
помощью функции SPI_prepare менеджера интерфейса программирования сервера. Последующие
обращения к этому выражению или команде повторно используют подготовленный к выполнению
оператор. Таким образом, SQL-команды, находящиеся в редко посещаемой ветке кода условного
оператора, не несут накладных расходов на разбор команд, если они так и не будут выполнены в
текущей сессии. Здесь есть недостаток, заключающийся в том, что ошибки в определённом выра-
жении или команде не могут быть обнаружены, пока выполнение не дойдёт до этой части функции.
(Тривиальные синтаксические ошибки обнаружатся в ходе первоначального разбора, но ничего
более серьёзного не будет обнаружено до исполнения.)
Кроме того, PL/pgSQL (точнее, менеджер интерфейса программирования сервера) будет пытаться
кешировать план выполнения для любого подготовленного к исполнению оператора. При каждом
вызове оператора, если не используется план из кеша, генерируется новый план выполнения, и
текущие значения параметров (то есть значения переменных PL/pgSQL) могут быть использованы
для оптимизации нового плана. Если оператор не имеет параметров или выполняется много раз,
менеджер интерфейса программирования сервера рассмотрит вопрос о создании и кешировании
(для повторного использования) общего плана, не зависящего от значений параметров. Как пра-
вило, это происходит в тех случаях, когда план выполнения не очень чувствителен к имеющим-
ся ссылкам на значения переменных PL/pgSQL. В противном случае, выгоднее каждый раз фор-
мировать новый план. Более подробно поведение подготовленных операторов рассматривается в
PREPARE.
Чтобы PL/pgSQL мог сохранять подготовленные операторы и планы выполнения, команды SQL в
коде PL/pgSQL, должны использовать одни и те же таблицы и столбцы при каждом исполнении.
А это значит, что в SQL-командах нельзя использовать названия таблиц и столбцов в качестве па-
раметров. Чтобы обойти это ограничение, нужно построить динамическую команду для операто-
ра PL/pgSQL EXECUTE — ценой будет разбор и построение нового плана выполнения при каждом
вызове.
Изменчивая природа переменных типа record представляет ещё одну проблему в этой связи. Ко-
гда поля переменной типа record используются в выражениях или операторах, типы данных по-
лей не должны меняться от одного вызова функции к другому, так как при анализе каждого вы-
ражения будет использоваться тот тип данных, который присутствовал при первом вызове. При
необходимости можно использовать EXECUTE для решения этой проблемы.
Если функция используется в качестве триггера более чем для одной таблицы, PL/pgSQL незави-
симо подготавливает и кеширует операторы для каждой такой таблицы. То есть создаётся кеш
для каждой комбинации триггерная функция + таблица, а не только для каждой функции. Это
устраняет некоторые проблемы, связанные с различными типами данных. Например, триггерная
функция сможет успешно работать со столбцом key, даже если в разных таблицах этот столбец
имеет разные типы данных.
Таким же образом, функции с полиморфными типами аргументов имеют отдельный кеш для каж-
дой комбинации фактических типов аргументов, так что различия типов данных не вызывают
неожиданных сбоев.
Кеширование операторов иногда приводит к неожиданным эффектам при интерпретации чувстви-
тельных ко времени значений. Например, есть разница между тем, что делают эти две функции:
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS <script type="math/tex">BEGIN
INSERT INTO logtable VALUES (logtxt, 'now');
END;</script> LANGUAGE plpgsql;
и
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS <script type="math/tex">DECLARE
curtime timestamp;
1172PL/pgSQL — проце-
дурный язык SQL
BEGIN
curtime := 'now';
INSERT INTO logtable VALUES (logtxt, curtime);
END;</script> LANGUAGE plpgsql;
В случае logfunc1, при анализе INSERT, основной анализатор PostgreSQL знает, что строку ‘now’
следует толковать как timestamp, потому что целевой столбец таблицы logtable имеет такой тип
данных. Таким образом, ‘now’ будет преобразовано в константу timestamp при анализе INSERT, а
затем эта константа будет использоваться в последующих вызовах logfunc1 в течение всей сессии.
Разумеется, это не то, что хотел программист. Лучше было бы использовать функцию now() или
current_timestamp.
В случае logfunc2, основной анализатор PostgreSQL не знает, какого типа будет ‘now’ и поэтому
возвращает значение типа text, содержащее строку now. При последующем присвоении локаль-
ной переменной curtime интерпретатор PL/pgSQL приводит эту строку к типу timestamp, вызывая
функции text_out и timestamp_in. Таким образом, метка времени будет обновляться при каждом
выполнении, как и ожидается программистом. И хотя всё работает как ожидалось, это ужасно
неэффективно, поэтому использование функции now() по-прежнему значительно лучше.
43.12. Советы по разработке на PL/pgSQL
Хороший способ разрабатывать на PL/pgSQL заключается в том, чтобы в одном окне с текстовым
редактором по выбору создавать тексты функций, а в другом окне с psql загружать и тестировать
эти функции. В таком случае удобно записывать функцию, используя CREATE OR REPLACE FUNCTION.
Таким образом, можно легко загрузить файл для обновления определения функции. Например:
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS <script type="math/tex">....</script> LANGUAGE plpgsql;
В psql, можно загрузить или перезагрузить такой файл определения функции, выполнив:
\i filename.sql
а затем сразу выполнять команды SQL для тестирования функции.
Ещё один хороший способ разрабатывать на PL/pgSQL связан с использованием GUI инструментов,
облегчающих разработку на процедурном языке. Один из примеров такого инструмента pgAdmin,
хотя есть и другие. Такие инструменты часто предоставляют удобные возможности, такие как
экранирование одинарных кавычек, отладка и повторное создание функций.
43.12.1. Обработка кавычек
Код функции на PL/pgSQL указывается в команде CREATE FUNCTION в виде строки. Если писать стро-
ку в обычном порядке, внутри одинарных кавычек, то любой символ одинарной кавычки должен
быть удвоен, также как и должен быть удвоен каждый знак обратной косой черты (если использу-
ется синтаксис с экранированием в строках). Удвоение кавычек в лучшем случае утомительно, а
в более сложных случаях код может стать совершенно непонятным, так как легко может потребо-
ваться полудюжина или более кавычек идущих подряд. Вместо этого при создании тела функции
рекомендуется использовать знаки доллара в качестве кавычек (см. Подраздел 4.1.2.4). При та-
ком подходе никогда не потребуется дублировать кавычки, но придётся позаботиться о том, что-
бы иметь разные долларовые разделители для каждого уровня вложенности. Например, команду
CREATE FUNCTION можно записать так:
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
….
$PROC$ LANGUAGE plpgsql;
Внутри можно использовать кавычки для простых текстовых строк и <script type="math/tex">для разграничения фраг-
ментов SQL-команды, собираемой из отдельных строк. Если нужно взять в кавычки текст, который
включает</script>, можно использовать $Q$, и так далее.
1173PL/pgSQL — проце-
дурный язык SQL
Следующая таблица показывает, как применяются знаки кавычек, если не используется экрани-
рование долларами. Это может быть полезно при переводе кода, не использующего экранирование
знаками доллара, в нечто более понятное.
1 кавычка
В начале и конце тела функции, например:
CREATE FUNCTION foo() RETURNS integer AS ‘
….
‘ LANGUAGE plpgsql;
Внутри такой функции любая кавычка должна дублироваться.
2 кавычки
Для строковых литералов внутри тела функции, например:
a_output := ‘‘Blah’’;
SELECT * FROM users WHERE f_name=’‘foobar’’;
При использовании знаков доллара можно просто написать:
a_output := ‘Blah’;
SELECT * FROM users WHERE f_name=’foobar’;
и именно это увидит исполнитель PL/pgSQL в обоих случаях.
4 кавычки
Когда нужны одинарные кавычки в строковой константе внутри тела функции, например:
a_output := a_output || ‘’ AND name LIKE ‘’'’foobar’’’’ AND xyz’’
К a_output будет добавлено: AND name LIKE ‘foobar’ AND xyz
При использовании знаков доллара это записывается так:
a_output := a_output || <script type="math/tex">AND name LIKE 'foobar' AND xyz</script>
будьте внимательны, при этом не должно быть внешнего долларового разделителя <script type="math/tex">.
6 кавычек
Когда нужны одинарные кавычки в строковой константе внутри тела функции, при этом кавыч-
ки находятся в конце строковой константы. Например:
a_output := a_output || '' AND name LIKE ''''foobar''''''
К a_output будет добавлено: AND name LIKE 'foobar'.
При использовании знаков доллара это записывается так:
a_output := a_output ||</script> AND name LIKE ‘foobar’<script type="math/tex">10 кавычек
Когда нужны две одиночные кавычки в строковой константе (это уже 8 кавычек), примыкаю-
щие к концу строковой константы (ещё 2). Вероятно, такое может понадобиться при разработ-
ке функции, которая генерирует другие функции, как показано в Примере 43.10. Например:
a_output := a_output || '' if v_'' ||
referrer_keys.kind || '' like ''''''''''
|| referrer_keys.key_string || ''''''''''
then return '''''' || referrer_keys.referrer_type
|| ''''''; end if;'';
1174PL/pgSQL — проце-
дурный язык SQL
Значение a_output затем будет:
if v_... like ''...'' then return ''...''; end if;
При использовании знаков доллара:
a_output := a_output ||</script> if v_<script type="math/tex">|| referrer_keys.kind ||</script> like ‘<script type="math/tex">|| referrer_keys.key_string ||</script>’
then return ‘<script type="math/tex">|| referrer_keys.referrer_type
||</script>’; end if;<script type="math/tex">;
где предполагается, что нужны только одиночные кавычки в a_output, так как потребуется
повторное взятие в кавычки перед использованием.
43.12.2. Дополнительные проверки во время компиляции
Чтобы помочь найти и предупредить простые, но часто встречающиеся проблемы, PL/PgSQL предо-
ставляет дополнительные проверки. Если они включены в конфигурации, то во время компиляции
функций будут выдаваться дополнительные сообщения WARNING или ошибки ERROR. Функция, при
компиляции которой выдавалось WARNING, при последующем выполнении не будет выдавать это
сообщение и её можно протестировать в отдельной среде разработки.
Для включения этих проверок используются параметры конфигурации plpgsql.extra_warnings
для предупреждений и plpgsql.extra_errors для ошибок. Каждому из параметров можно присво-
ить список значений, разделённый через запятую, значение "none" или "all". По умолчанию ис-
пользуется "none". В настоящий момент доступна только одна проверка:
shadowed_variables
Проверяет, что объявление новой переменной не скрывает ранее объявленную переменную.
Следующий пример показывает эффект от установки plpgsql.extra_warnings в значение
shadowed_variables:
SET plpgsql.extra_warnings TO 'shadowed_variables';
CREATE FUNCTION foo(f1 int) RETURNS int AS</script>
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING: variable “f1” shadows a previously defined variable
LINE 3: f1 int;</li>
</ul>
<p>CREATE FUNCTION
43.13. Портирование из Oracle PL/SQL
В этом разделе рассматриваются различия между языками PostgreSQL PL/pgSQL и Oracle PL/SQL,
чтобы помочь разработчикам, переносящим приложения из Oracle® в PostgreSQL.
PL/pgSQL во многих аспектах похож на PL/SQL . Это блочно-структурированный, императивный
язык, в котором все переменные должны объявляться. Присвоения, циклы, условные операторы в
обоих языках похожи. Основные отличия, которые необходимо иметь в виду при портировании с
PL/SQL в PL/pgSQL, следующие:
• Если имя, используемое в SQL-команде, может быть как именем столбца таблицы, так и ссыл-
кой на переменную функции, то PL/SQL считает, что это имя столбца таблицы. Это соответ-
ствует поведению PL/pgSQL при plpgsql.variable_conflict = use_column, что не является
значением по умолчанию, как описано в Подразделе 43.11.1. В первую очередь, было бы пра-
1175PL/pgSQL — проце-
дурный язык SQL
вильно избегать таких двусмысленностей, но если требуется портировать большое количество
кода, зависящее от данного поведения, то установка переменной variable_conflict может
быть лучшим решением.
• В PostgreSQL тело функции должно быть записано в виде строки. Поэтому нужно использо-
вать знак доллара в качестве кавычек или экранировать одиночные кавычки в теле функции.
(См. Подраздел 43.12.1.)
• Имена типов данных часто требуют корректировки. Например, в Oracle строковые значения
часто объявляются с типом varchar2, не являющимся стандартным типом SQL. В PostgreSQL
вместо него нужно использовать varchar или text. Подобным образом, тип number нужно за-
менять на numeric или другой числовой тип, если найдётся более подходящий.
• Для группировки функций вместо пакетов используются схемы.
• Так как пакетов нет, нет и пакетных переменных. Это несколько раздражает. Вместо этого
можно хранить состояние каждого сеанса во временных таблицах.
• Целочисленные циклы FOR с указанием REVERSE работают по-разному. В PL/SQL значение
счётчика уменьшается от второго числа к первому, в то время как в PL/pgSQL счётчик умень-
шается от первого ко второму. Поэтому при портировании нужно менять местами границы
цикла. Это печально, но вряд ли будет изменено. (См. Подраздел 43.6.5.5.)
• Циклы FOR по запросам (не курсорам) также работают по-разному. Переменная цикла долж-
на быть объявлена, в то время как в PL/SQL она объявляется неявно. Преимущество в том, что
значения переменных доступны и после выхода из цикла.
• Существуют некоторые отличия в нотации при использовании курсорных переменных.
43.13.1. Примеры портирования
Пример 43.9 показывает, как портировать простую функцию из PL/SQL в PL/pgSQL.
Пример 43.9. Портирование простой функции из PL/SQL в PL/pgSQL
Функция Oracle PL/SQL:
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
v_version varchar2)
RETURN varchar2 IS
BEGIN
IF v_version IS NULL THEN
RETURN v_name;
END IF;
RETURN v_name || ‘/’ || v_version;
END;
/
show errors;
Пройдемся по этой функции и посмотрим различия по сравнению с PL/pgSQL:
• Имя типа varchar2 нужно сменить на varchar или text. В примерах данного раздела мы бу-
дем использовать varchar, но обычно лучше выбрать text, если не требуется ограничивать
длину строк.
• Ключевое слово RETURN в прототипе функции (не в теле функции) заменяется на RETURNS в
PostgreSQL. Кроме того, IS становится AS, и нужно добавить предложение LANGUAGE, потому
что PL/pgSQL — не единственный возможный язык.
• В PostgreSQL тело функции является строкой, поэтому нужно использовать кавычки или зна-
ки доллара. Это заменяет завершающий / в подходе Oracle.
• Команда show errors не существует в PostgreSQL и не требуется, так как ошибки будут выво-
диться автоматически.
1176PL/pgSQL — проце-
дурный язык SQL
Вот как эта функция будет выглядеть после портирования в PostgreSQL:
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
v_version varchar)
RETURNS varchar AS <script type="math/tex">BEGIN
IF v_version IS NULL THEN
RETURN v_name;
END IF;
RETURN v_name || '/' || v_version;
END;</script> LANGUAGE plpgsql;
Пример 43.10 показывает, как портировать функцию, которая создаёт другую функцию, и как об-
рабатывать проблемы с кавычками.
Пример 43.10. Портирование функции, создающей другую функцию, из PL/SQL в PL/pgSQL
Следующая процедура получает строки из SELECT и строит большую функцию, в целях эффектив-
ности возвращающую результат в операторах IF.
Версия Oracle:
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
CURSOR referrer_keys IS
SELECT * FROM cs_referrer_keys
ORDER BY try_order;
func_cmd VARCHAR(4000);
BEGIN
func_cmd := ‘CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN’;
FOR referrer_key IN referrer_keys LOOP
func_cmd := func_cmd ||
‘ IF v_’ || referrer_key.kind
|| ‘ LIKE ‘’’ || referrer_key.key_string
|| ‘’’ THEN RETURN ‘’’ || referrer_key.referrer_type
|| ‘’’; END IF;’;
END LOOP;
func_cmd := func_cmd || ‘ RETURN NULL; END;’;
EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
В конечном итоге в PostgreSQL эта функция может выглядеть так:
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() AS $func$
DECLARE
referrer_keys CURSOR IS
SELECT * FROM cs_referrer_keys
ORDER BY try_order;
func_body text;
func_cmd text;
BEGIN
func_body := ‘BEGIN’;
FOR referrer_key IN referrer_keys LOOP
func_body := func_body ||
1177PL/pgSQL — проце-
дурный язык SQL
‘ IF v_’ || referrer_key.kind
|| ‘ LIKE ‘ || quote_literal(referrer_key.key_string)
|| ‘ THEN RETURN ‘ || quote_literal(referrer_key.referrer_type)
|| ‘; END IF;’ ;
END LOOP;
func_body := func_body || ‘ RETURN NULL; END;’;
func_cmd :=
‘CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
v_domain varchar,
v_url varchar)
RETURNS varchar AS ‘
|| quote_literal(func_body)
|| ‘ LANGUAGE plpgsql;’ ;
EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
Обратите внимание, что тело функции строится отдельно, с использованием quote_literal для
удвоения кавычек. Эта техника необходима, потому что мы не можем безопасно использовать зна-
ки доллара при определении новой функции: мы не знаем наверняка, какие строки будут встав-
лены из referrer_key.key_string. (Мы предполагаем, что referrer_key.kind всегда имеет зна-
чение из списка: host, domain или url, но referrer_key.key_string может быть чем угодно, в
частности, может содержать знаки доллара.) На самом деле, в этой функций есть улучшение по
сравнению с оригиналом Oracle, потому что не будет генерироваться неправильный код, когда
referrer_key.key_string или referrer_key.referrer_type содержат кавычки.
Пример 43.11 показывает, как портировать функцию с выходными параметрами (OUT) и манипули-
рующую строками. В PostgreSQL нет встроенной функции instr, но её можно создать, используя
комбинацию других функций. В Подраздел 43.13.3 приведена реализации instr на PL/pgSQL, ко-
торая может быть полезна вам при портировании ваших функций.
Пример 43.11. Портирование из PL/SQL в PL/pgSQL процедуры, которая манипулирует
строками и содержит OUT параметры
Следующая процедура на языке Oracle PL/SQL разбирает URL и возвращает составляющие его
элементы (сервер, путь и запрос).
Версия Oracle:
CREATE OR REPLACE PROCEDURE cs_parse_url(
v_url IN VARCHAR2,
v_host OUT VARCHAR2, – Возвращается как результат
v_path OUT VARCHAR2, – И это тоже
v_query OUT VARCHAR2) – И это
IS
a_pos1 INTEGER;
a_pos2 INTEGER;
BEGIN
v_host := NULL;
v_path := NULL;
v_query := NULL;
a_pos1 := instr(v_url, ‘//’);
IF a_pos1 = 0 THEN
RETURN;
END IF;
a_pos2 := instr(v_url, ‘/’, a_pos1 + 2);
1178PL/pgSQL — проце-
дурный язык SQL
IF a_pos2 = 0 THEN
v_host := substr(v_url, a_pos1 + 2);
v_path := ‘/’;
RETURN;
END IF;
v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
a_pos1 := instr(v_url, ‘?’, a_pos2 + 1);
IF a_pos1 = 0 THEN
v_path := substr(v_url, a_pos2);
RETURN;
END IF;
v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
Вот возможная трансляция в PL/pgSQL:
CREATE OR REPLACE FUNCTION cs_parse_url(
v_url IN VARCHAR,
v_host OUT VARCHAR, – Возвращается как результат
v_path OUT VARCHAR, – И это тоже
v_query OUT VARCHAR) – И это
AS <script type="math/tex">DECLARE
a_pos1 INTEGER;
a_pos2 INTEGER;
BEGIN
v_host := NULL;
v_path := NULL;
v_query := NULL;
a_pos1 := instr(v_url, '//');
IF a_pos1 = 0 THEN
RETURN;
END IF;
a_pos2 := instr(v_url, '/', a_pos1 + 2);
IF a_pos2 = 0 THEN
v_host := substr(v_url, a_pos1 + 2);
v_path := '/';
RETURN;
END IF;
v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
a_pos1 := instr(v_url, '?', a_pos2 + 1);
IF a_pos1 = 0 THEN
v_path := substr(v_url, a_pos2);
RETURN;
END IF;
v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
v_query := substr(v_url, a_pos1 + 1);
END;</script> LANGUAGE plpgsql;
1179PL/pgSQL — проце-
дурный язык SQL
Эту функцию можно использовать так:
SELECT * FROM cs_parse_url(‘http://foobar.com/query.cgi?baz’);
Пример 43.12 показывает, как портировать процедуру, использующую большое количество специ-
фических для Oracle возможностей.
Пример 43.12. Портирование процедуры из PL/SQL в PL/pgSQL
Версия Oracle:
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
a_running_job_count INTEGER;
BEGIN
LOCK TABLE cs_jobs IN EXCLUSIVE MODE;
SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;
IF a_running_job_count &gt; 0 THEN
COMMIT; – освободить блокировку
raise_application_error(-20000,
‘Unable to create a new job: a job is currently running.’);
END IF;
DELETE FROM cs_active_job;
INSERT INTO cs_active_job(job_id) VALUES (v_job_id);
BEGIN
INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
EXCEPTION
WHEN dup_val_on_index THEN NULL; – ничего не делать, если задание уже есть
END;
COMMIT;
END;
/
show errors
Вот как эту процедуру можно переписать на PL/pgSQL:
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) AS <script type="math/tex">DECLARE
a_running_job_count integer;
BEGIN
LOCK TABLE cs_jobs IN EXCLUSIVE MODE;
SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;
IF a_running_job_count > 0 THEN
COMMIT; -- освободить блокировку
RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; --
END IF;
DELETE FROM cs_active_job;
INSERT INTO cs_active_job(job_id) VALUES (v_job_id);
BEGIN
INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
EXCEPTION
WHEN unique_violation THEN -- 2
-- ничего не делать, если задание уже есть
END;
1180
1PL/pgSQL — проце-
дурный язык SQL
COMMIT;
END;</script> LANGUAGE plpgsql;
1
2
Синтаксис RAISE существенно отличается от Oracle, хотя основной вариант RAISE имя_исклю-
чения работает похоже.
Имена исключений, поддерживаемые PL/pgSQL, отличаются от исключений в Oracle. Количе-
ство встроенных имён исключений значительно больше (см. Приложение A). В настоящее вре-
мя нет способа задать пользовательское имя исключения, хотя вместо этого можно вызывать
ошибку с заданным пользователем значением SQLSTATE.
43.13.2. На что ещё обратить внимание
В этом разделе рассматриваются ещё несколько вещей, на которые нужно обращать внимание при
портировании функций из Oracle PL/SQL в PostgreSQL.
43.13.2.1. Неявный откат изменений после возникновения исключения
В PL/pgSQL при перехвате исключения в секции EXCEPTION все изменения в базе данных с начала
блока автоматически откатываются. В Oracle это эквивалентно следующему:
BEGIN
SAVEPOINT s1;
… здесь код …
EXCEPTION
WHEN … THEN
ROLLBACK TO s1;
… здесь код …
WHEN … THEN
ROLLBACK TO s1;
… здесь код …
END;
При портировании процедуры Oracle, которая использует SAVEPOINT и ROLLBACK TO в таком же
стиле, задача простая: достаточно убрать операторы SAVEPOINT и ROLLBACK TO. Если же SAVEPOINT
и ROLLBACK TO используются по-другому, то придётся подумать.
43.13.2.2. EXECUTE
PL/pgSQL версия EXECUTE работает аналогично версии в PL/SQL, но нужно помнить об использова-
нии quote_literal и quote_ident, как описано в Подразделе 43.5.4. Без использования этих функ-
ций конструкции типа EXECUTE ‘SELECT * FROM $1’; будут работать ненадёжно.
43.13.2.3. Оптимизация функций на PL/pgSQL
Для оптимизации исполнения PostgreSQL предоставляет два модификатора при создании функ-
ции: «изменчивость» (будет ли функция всегда возвращать тот же результат при тех же аргумен-
тах) и «строгость» (возвращает ли функция NULL, если хотя бы один из аргументов NULL). Для
получения подробной информации обратитесь к справочной странице CREATE FUNCTION.
При использовании этих атрибутов оптимизации оператор CREATE FUNCTION может выглядеть при-
мерно так:
CREATE FUNCTION foo(…) RETURNS integer AS <script type="math/tex">...</script> LANGUAGE plpgsql STRICT IMMUTABLE;
43.13.3. Приложение
Этот раздел содержит код для совместимых с Oracle функций instr, которые можно использовать
для упрощения портирования.
1181PL/pgSQL — проце-
дурный язык SQL
–
–
–
–
–
–
–
–
–
–
–
–
instr functions that mimic Oracle’s counterpart
Syntax: instr(string1, string2 [, n [, m]])
where [] denotes optional parameters.
Search string1, beginning at the nth character, for the mth occurrence
of string2. If n is negative, search backwards, starting at the abs(n)’th
character from the end of string1.
If n is not passed, assume 1 (search starts at first character).
If m is not passed, assume 1 (find first occurrence).
Returns starting index of string2 in string1, or 0 if string2 is not found.
CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS <script type="math/tex">BEGIN
RETURN instr($1, $2, 1);
END;</script> LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
beg_index integer)
RETURNS integer AS <script type="math/tex">% <![CDATA[
DECLARE
pos integer NOT NULL DEFAULT 0;
temp_str varchar;
beg integer;
length integer;
ss_length integer;
BEGIN
IF beg_index > 0 THEN
temp_str := substring(string FROM beg_index);
pos := position(string_to_search_for IN temp_str);
IF pos = 0 THEN
RETURN 0;
ELSE
RETURN pos + beg_index - 1;
END IF;
ELSIF beg_index < 0 THEN
ss_length := char_length(string_to_search_for);
length := char_length(string);
beg := length + 1 + beg_index;
WHILE beg > 0 LOOP
temp_str := substring(string FROM beg FOR ss_length);
IF string_to_search_for = temp_str THEN
RETURN beg;
END IF;
beg := beg - 1;
END LOOP;
RETURN 0;
ELSE
RETURN 0;
END IF;
1182PL/pgSQL — проце-
дурный язык SQL
END; %]]></script> LANGUAGE plpgsql STRICT IMMUTABLE;
CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
beg_index integer, occur_index integer)
RETURNS integer AS <script type="math/tex">% <![CDATA[
DECLARE
pos integer NOT NULL DEFAULT 0;
occur_number integer NOT NULL DEFAULT 0;
temp_str varchar;
beg integer;
i integer;
length integer;
ss_length integer;
BEGIN
IF occur_index <= 0 THEN
RAISE 'argument ''%'' is out of range', occur_index
USING ERRCODE = '22003';
END IF;
IF beg_index > 0 THEN
beg := beg_index - 1;
FOR i IN 1..occur_index LOOP
temp_str := substring(string FROM beg + 1);
pos := position(string_to_search_for IN temp_str);
IF pos = 0 THEN
RETURN 0;
END IF;
beg := beg + pos;
END LOOP;
RETURN beg;
ELSIF beg_index < 0 THEN
ss_length := char_length(string_to_search_for);
length := char_length(string);
beg := length + 1 + beg_index;
WHILE beg > 0 LOOP
temp_str := substring(string FROM beg FOR ss_length);
IF string_to_search_for = temp_str THEN
occur_number := occur_number + 1;
IF occur_number = occur_index THEN
RETURN beg;
END IF;
END IF;
beg := beg - 1;
END LOOP;
RETURN 0;
ELSE
RETURN 0;
END IF;
END; %]]></script> LANGUAGE plpgsql STRICT IMMUTABLE;
1183</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page11/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page10/">10</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page11/">11</a></li>
      
    
      
        <li><strong class="current-page">12</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page13/">13</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page14/">14</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page13/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>