<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 38. Расширение SQL &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 38. Расширение SQL">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 38. Расширение SQL">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-038/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-038/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 38. Расширение SQL">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-038/" rel="bookmark" title="Глава 38. Расширение SQL">Глава 38. Расширение SQL</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~152 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Часть V. Серверное программирование</p>

<p>Эта часть документации посвящена расширению функциональности сервера путём реализации соб-
ственных функций, типов данных, триггеров и т. д. Это довольно сложные темы, для освоения кото-
рых рекомендуется предварительно изучить и понять всю остальную документацию для пользовате-
лей PostgreSQL. В последних главах этой части описываются языки программирования на стороне
сервера, поддерживаемые дистрибутивом PostgreSQL, и рассматриваются общие вопросы, связан-
ные с программированием на стороне сервера. Но прежде чем погружаться в этот материал, важно
изучить предыдущие разделы Главы 38 (где освещаются функции).</p>

<p>Глава 38. Расширение SQL</p>

<p>В следующих разделах мы обсудим, как в PostgreSQL можно расширять язык запросов SQL, добав-
ляя собственные:
•
•
•
•
•
•
функции (начиная с Раздела 38.3)
агрегатные функции (начиная с Раздела 38.11)
типы данных (начиная с Раздела 38.12)
операторы (начиная с Раздела 38.13)
классы операторов для индексов (начиная с Раздела 38.15)
пакеты связанных объектов (начиная с Раздела 38.16)
38.1. Как реализована расширяемость
PostgreSQL является расширяемым благодаря тому, что его работа управляется каталогами. Ес-
ли вы знакомы с традиционными реляционными системами баз данных, вы знаете, что они хра-
нят информацию о базах, таблицах, столбцах и т. д., в структурах, которые обычно называются си-
стемными каталогами. (В некоторых системах они называются словарями данных.) Эти каталоги
представляются пользователю в виде таблиц, подобных любым другим, но СУБД ведёт в них свои
внутренние записи. Ключевое отличие PostgreSQL от обычных реляционных СУБД состоит в том,
что PostgreSQL хранит в этих каталогах намного больше информации: информацию не только о
таблицах и столбцах, но также о типах данных, функциях, методах доступа и т. д. Эти таблицы
могут быть изменены пользователями, а так как PostgreSQL в своих действиях руководствуется
этими таблицами, это означает, что пользователи могут расширять PostgreSQL. Обычные же СУБД
можно расширять, только модифицируя жёстко запрограммированные процедуры в исходном ко-
де или загружая модули, специально разработанные производителем СУБД.
Кроме того, сервер PostgreSQL может динамически загружать в свой процесс код, написанный
пользователем. То есть, пользователь может подключить файл с объектным кодом (например, раз-
деляемую библиотеку), который реализует новый тип или функцию, а PostgreSQL загрузит его по
мере надобности. Код, написанный на SQL, добавляется на сервер ещё проще. Эта способность
менять своё поведение «на лету» делает PostgreSQL исключительно подходящим для быстрого
прототипирования новых приложений и структур хранения.
38.2. Система типов PostgreSQL
Типы данных PostgreSQL делятся на базовые, типы-контейнеры, составные, доменные и псевдоти-
пы.
38.2.1. Базовые типы
Базовые типы — это типы, такие как integer, которые реализуются ниже уровня языка SQL (обыч-
но на низкоуровневом языке, например C). В общих чертах они соответствуют так называемым
абстрактным типам данных. PostgreSQL может работать с такими типами только через функции,
предоставленные пользователем, и понимать их поведение только в той степени, в какой его опи-
шет пользователь. Встроенные базовые типы описываются в Главе 8.
Типы-перечисления (enum) можно считать подкатегорией базовых типов. Они отличаются от дру-
гих типов тем, что их можно создавать просто командами SQL, обходясь без низкоуровневого про-
граммирования. За подробностями обратитесь к Разделу 8.7.
38.2.2. Типы-контейнеры
В PostgreSQL есть три вида «типов-контейнеров», то есть типов, которые могут содержать в себе
несколько значений других типов. Это массивы, составные типы и диапазоны.
Массивы могут содержать множество значений, имеющих один тип. Тип массива автоматически
создаётся для каждого базового и составного типа, диапазона и домена, но не для массивов —
996Расширение SQL
массивы массивов не существуют. Для системы типов многомерные массивы не отличаются от
одномерных. За дополнительными сведениями обратитесь к Разделу 8.15.
Составные типы, или типы строк, образуются при создании любой таблицы. С помощью команды
CREATE TYPE также можно определить «независимый» составной тип, не связанный с таблицей.
Составной тип представляет собой просто список типов с определёнными именами полей. Значе-
нием составного типа является строка таблицы или запись из значений полей. За дополнительны-
ми сведениями обратитесь к Разделу 8.16.
Диапазонный тип может содержать два значения одного типа, которые определяют нижнюю и
верхнюю границу диапазона. Диапазонные типы создаются пользователем, хотя существует и
несколько встроенных. За дополнительными сведениями обратитесь к Разделу 8.17.
38.2.3. Домены
Домен основывается на определённом нижележащем типе и во многих аспектах взаимозаменяем
с ним. Однако домен может иметь ограничения, уменьшающие множество допустимых для него
значений относительно нижележащего типа. Домены создаются SQL-командой CREATE DOMAIN.
За дополнительными сведениями обратитесь к Разделу 8.18.
38.2.4. Псевдотипы
Для специальных целей существует также несколько «псевдотипов». Псевдотипы нельзя задей-
ствовать в столбцах таблицы или в типах-контейнерах, но их можно использовать в объявлениях
аргументов и результатов функций. Это даёт возможность выделить в системе типов специальные
классы функций. Все существующие псевдотипы перечислены в Таблице 8.25.
38.2.5. Полиморфные типы
Особый интерес представляют пять псевдотипов: anyelement, anyarray, anynonarray, anyenum и
anyrange, которые называются полиморфными типами. Функция, в объявлении которой использу-
ются эти типы, называется полиморфной. Полиморфная функция может работать со множеством
различных типов данных; конкретный тип определяется в зависимости от значения, переданного
при вызове.
Полиморфные аргументы и результаты связываются друг с другом и сводятся к определённому
типу данных при разборе запроса, вызывающего полиморфную функцию. В каждой позиции (в ар-
гументах или возвращаемом значении), объявленной как anyelement, может передаваться любой
фактический тип данных, но в каждом конкретном вызове все эти фактические типы должны быть
одинаковыми. Аналогичным образом, в каждой позиции, объявленной как anyarray, может пере-
даваться любой тип данных массива, но все фактические типы массивов должны совпадать. Так же
и во всех позициях, объявленных как anyrange, должен передаваться одинаковый тип-диапазон.
Более того, если некоторые позиции объявлены как anyarray, а другие как anyelement, то фактиче-
ским типом в позициях anyarray должен быть массив, элементы которого имеют тот же тип, что и
значения в позициях anyelement. Подобным образом, если одни позиции объявлены как anyrange,
а другие как anyelement, фактическим типом в позициях anyrange должен быть диапазон, подтип
которого совпадает с типом, передаваемым в позициях anyelement. Псевдотип anynonarray обра-
батывается так же, как anyelement, но с дополнительным ограничением — фактический тип не
должен быть типом массива. Псевдотип anyenum тоже обрабатывается как anyelement, но его фак-
тические типы ограничиваются перечислениями.
Таким образом, когда с полиморфным типом объявлено несколько аргументов, в итоге допускают-
ся только определённые комбинации фактических типов. Например, функция, объявленная как
equal(anyelement, anyelement), примет в аргументах любые два значения, но только если их ти-
пы данных совпадают.
Когда с полиморфным типом объявлено возвращаемое значение функции, так же полиморф-
ным должен быть минимум один аргумент, и фактический тип результата при конкретном вы-
997Расширение SQL
зове определится по типу фактически переданного аргумента. Например, если бы отсутствовал
механизм обращения к элементам массива, его можно было бы реализовать, создав функцию
subscript(anyarray, integer) returns anyelement. С таким объявлением первым фактическим
аргументом должен быть массив, и из него будет выведен правильный тип результата при разборе
запроса. В качестве другого примера можно привести функцию f(anyarray) returns anyenum,
которая будет принимать только массивы перечислений.
Заметьте, что anynonarray и anyenum представляют не отдельные типы переменных; это те же
типы, что и anyelement, но с дополнительными ограничениями. Например, объявление функции
f(anyelement, anyenum) равнозначно объявлению f(anyenum, anyenum): оба фактических аргу-
мента должны быть одинаковыми типами-перечислениями.
Функции с переменным числом аргументом (описанные в Подразделе 38.5.5) тоже могут быть по-
лиморфными: для этого их последний параметр описывается как VARIADIC anyarray. Для целей
сопоставления аргументов и определения фактического типа результата такая функция представ-
ляется так же, как если бы в ней явно объявлялось нужное число параметров anynonarray.
38.3. Пользовательские функции
В PostgreSQL представлены функции четырёх видов:
• функции на языке запросов (функции, написанные на SQL) (Раздел 38.5)
• функции на процедурных языках (функции, написанные, например, на PL/pgSQL или PL/Tcl)
(Раздел 38.8)
• внутренние функции (Раздел 38.9)
• функции на языке C (Раздел 38.10)
Функции любых видов могут принимать в качестве аргументов (параметров) базовые типы, состав-
ные типы или их сочетания. Кроме того, любые функции могут возвращать значения базового или
составного типа. Также можно определить функции, возвращающие наборы базовых или состав-
ных значений.
Функции многих видов могут также принимать или возвращать определённые псевдотипы (напри-
мер, полиморфные типы), но доступные средства для работы с ними различаются. За подробно-
стями обратитесь к описанию конкретного вида функций.
Проще всего определить функции на языке SQL, поэтому сначала мы рассмотрим их. Многие кон-
цепции, касающиеся функций на SQL, затем распространятся и на другие виды функций.
Изучая эту главу, будет полезно обращаться к странице справки по команде CREATE FUNCTION,
чтобы лучше понимать примеры. Некоторые примеры из этой главы можно найти в файлах
funcs.sql и funcs.c в каталоге src/tutorial исходного кода PostgreSQL.
38.4. Пользовательские процедуры
Процедура представляет собой объект базы данных, подобный функции. Отличие состоит в том,
что процедура не возвращает значение, и поэтому для неё не определяется возвращаемый тип.
Тогда как функция вызывается в составе запроса или команды DML, процедура вызывается явно,
оператором CALL.
Всё, что говорится в продолжении данной главы о создании пользовательских функций, приме-
нимо и к процедурам, за исключением того, что для процедур используется команда CREATE
PROCEDURE, не определяется тип результата, и к ним не относятся некоторые свойства, напри-
мер, строгость.
Функции и процедуры в совокупности также называются подпрограммами. Существуют коман-
ды, такие как ALTER ROUTINE и DROP ROUTINE, которые способны работать и с функциями, и
998Расширение SQL
с процедурами, не требуя указания точного вида объекта. Однако заметьте, что команды CREATE
ROUTINE нет.
38.5. Функции на языке запросов (SQL)
SQL-функции выполняют произвольный список операторов SQL и возвращают результат последне-
го запроса в списке. В простом случае (не с множеством) будет возвращена первая строка резуль-
тата последнего запроса. (Помните, что понятие «первая строка» в наборе результатов с несколь-
кими строками определено точно, только если присутствует ORDER BY.) Если последний запрос
вообще не вернёт строки, будет возвращено значение NULL.
Кроме того, можно объявить SQL-функцию как возвращающую множество (то есть, несколько
строк), указав в качестве возвращаемого типа функции SETOF некий_тип, либо объявив её с указа-
нием RETURNS TABLE(столбцы). В этом случае будут возвращены все строки результата последнего
запроса. Подробнее это описывается ниже.
Тело SQL-функции должно представлять собой список SQL-операторов, разделённых точкой с за-
пятой. Точка с запятой после последнего оператора может отсутствовать. Если только функция
не объявлена как возвращающая void, последним оператором должен быть SELECT, либо INSERT,
UPDATE или DELETE с предложением RETURNING.
Любой набор команд на языке SQL можно скомпоновать вместе и обозначить как функцию. Поми-
мо запросов SELECT, эти команды могут включать запросы, изменяющие данные (INSERT, UPDATE и
DELETE), а также другие SQL-команды. (В SQL-функциях нельзя использовать команды управления
транзакциями, например COMMIT, SAVEPOINT, и некоторые вспомогательные команды, в частности
VACUUM.) Однако последней командой должна быть SELECT или команда с предложением RETURNING,
возвращающая результат с типом возврата функции. Если же вы хотите определить функцию SQL,
выполняющую действия, но не возвращающую полезное значение, вы можете объявить её как воз-
вращающую тип void. Например, эта функция удаляет строки с отрицательным жалованьем из
таблицы emp:
CREATE FUNCTION clean_emp() RETURNS void AS ‘
DELETE FROM emp
WHERE salary &lt; 0;
‘ LANGUAGE SQL;
SELECT clean_emp();
clean_emp
———–
(1 row)
Примечание
Прежде чем начинается выполнение команд, разбирается всё тело SQL-функции. Ко-
гда SQL-функция содержит команды, модифицирующие системные каталоги (напри-
мер, CREATE TABLE), действие таких команд не будет проявляться на стадии анализа
последующих команд этой функции. Так, например, команды CREATE TABLE foo (…);
INSERT INTO foo VALUES(…); не будут работать, как ожидается, если их упаковать
в одну SQL-функцию, так как foo не будет существовать к моменту разбору команды
INSERT. В подобных ситуациях вместо SQL-функции рекомендуется использовать PL/
pgSQL.
Синтаксис команды CREATE FUNCTION требует, чтобы тело функции было записано как строковая
константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. Подраз-
999Расширение SQL
дел 4.1.2.4). Если вы решите использовать обычный синтаксис с заключением строки в апострофы,
вам придётся дублировать апострофы (‘) и обратную косую черту () (предполагается синтаксис
спецпоследовательностей) в теле функции (см. Подраздел 4.1.2.1).
38.5.1. Аргументы SQL-функций
К аргументам SQL-функции можно обращаться в теле функции по именам или номерам. Ниже
приведены примеры обоих вариантов.
Чтобы использовать имя, объявите аргумент функции как именованный, а затем просто пишите
это имя в теле функции. Если имя аргумента совпадает с именем какого-либо столбца в текущей
SQL-команде внутри функции, имя столбца будет иметь приоритет. Чтобы всё же перекрыть имя
столбца, дополните имя аргумента именем самой функции, то есть запишите его в виде имя_функ-
ции.имя_аргумента. (Если и это имя будет конфликтовать с полным именем столбца, снова выиг-
рает имя столбца. Неоднозначности в этом случае вы можете избежать, выбрав другой псевдоним
для таблицы в SQL-команде.)
Старый подход с нумерацией позволяет обращаться к аргументам, применяя запись $n: $1 обозна-
чает первый аргумент, $2 — второй и т. д. Это будет работать и в том случае, если данному аргу-
менту назначено имя.
Если аргумент имеет составной тип, то для обращения к его атрибутам можно использовать за-
пись с точкой, например: аргумент.поле или $1.поле. И опять же, при этом может потребоваться
дополнить имя аргумента именем функции, чтобы сделать имя аргумента однозначным.
Аргументы SQL-функции могут использоваться только как значения данных, но не как идентифи-
каторы. Например, это приемлемо:
INSERT INTO mytable VALUES ($1);
а это не будет работать:
INSERT INTO $1 VALUES (42);
Примечание
Возможность обращаться к аргументам SQL-функций по именам появилась в
PostgreSQL 9.2. В функциях, которые должны работать со старыми серверами, необхо-
димо применять запись $n.
38.5.2. Функции SQL с базовыми типами
Простейшая возможная функция SQL не имеет аргументов и просто возвращает базовый тип, на-
пример integer:
CREATE FUNCTION one() RETURNS integer AS <script type="math/tex">SELECT 1 AS result;</script> LANGUAGE SQL;
– Альтернативная запись строковой константы:
CREATE FUNCTION one() RETURNS integer AS ‘
SELECT 1 AS result;
‘ LANGUAGE SQL;
SELECT one();
one
—–
1000Расширение SQL
1
Заметьте, что мы определили псевдоним столбца в теле функции для её результата (дали ему имя
result), но этот псевдоним не виден снаружи функции. Вследствие этого, столбец результата по-
лучил имя one, а не result.
Практически так же легко определяются функции SQL, которые принимают в аргументах базовые
типы:
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS <script type="math/tex">SELECT x + y;</script> LANGUAGE SQL;
SELECT add_em(1, 2) AS answer;
answer
——–
3
Мы также можем отказаться от имён аргументов и обращаться к ним по номерам:
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS <script type="math/tex">SELECT $1 + $2;</script> LANGUAGE SQL;
SELECT add_em(1, 2) AS answer;
answer
——–
3
Вот более полезная функция, которую можно использовать, чтобы дебетовать банковский счёт:
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS <script type="math/tex">UPDATE bank
SET balance = balance - debit
WHERE accountno = tf1.accountno;
SELECT 1;</script> LANGUAGE SQL;
Пользователь может выполнить эту функцию, чтобы дебетовать счёт 17 на 100 долларов, так:
SELECT tf1(17, 100.0);
В этом примере мы выбрали имя accountno для первого аргумента, но это же имя имеет столбец
в таблице bank. В команде UPDATE имя accountno относится к столбцу bank.accountno, так для
обращения к аргументу нужно записать tf1.accountno. Конечно, мы могли бы избежать этого,
выбрав другое имя для аргумента.
На практике обычно желательно получать от функции более полезный результат, чем константу
1, поэтому более реалистично такое определение:
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS <script type="math/tex">UPDATE bank
SET balance = balance - debit
WHERE accountno = tf1.accountno;
SELECT balance FROM bank WHERE accountno = tf1.accountno;</script> LANGUAGE SQL;
Эта функция изменяет баланс и возвращает полученное значение. То же самое можно сделать в
одной команде, применив RETURNING:
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS <script type="math/tex">1001Расширение SQL
UPDATE bank
SET balance = balance - debit
WHERE accountno = tf1.accountno
RETURNING balance;</script> LANGUAGE SQL;
Функция SQL должна возвращать в точности объявленный тип результата. Для этого может потре-
боваться добавить явное приведение. Например, предположим, что мы захотели изменить возвра-
щаемый тип в предыдущей функции на float8. Этот вариант не будет работать:
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS <script type="math/tex">SELECT $1 + $2;</script> LANGUAGE SQL;
несмотря на то, что в других контекстах PostgreSQL выполнил бы неявное приведение для преоб-
разования integer в float8. Правильный вариант выглядит так:
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS <script type="math/tex">SELECT ($1 + $2)::float8;</script> LANGUAGE SQL;
38.5.3. Функции SQL со сложными типами
В функциях с аргументами составных типов мы должны указывать не только, какой аргумент, но
и какой атрибут (поле) этого аргумента нам нужен. Например, предположим, что emp — таблица,
содержащая данные работников, и это же имя составного типа, представляющего каждую строку
таблицы. Следующая функция double_salary вычисляет, каким было бы чьё-либо жалование в
случае увеличения вдвое:
CREATE TABLE emp (
name
text,
salary
numeric,
age
integer,
cubicle
point
);
INSERT INTO emp VALUES (‘Bill’, 4200, 45, ‘(2,1)’);
CREATE FUNCTION double_salary(emp) RETURNS numeric AS <script type="math/tex">SELECT $1.salary * 2 AS salary;</script> LANGUAGE SQL;
SELECT name, double_salary(emp.<em>) AS dream
FROM emp
WHERE emp.cubicle ~= point ‘(2,1)’;
name | dream
——+——-
Bill | 8400
Обратите внимание на запись $1.salary позволяющую выбрать одно поле из значения строки ар-
гумента. Также заметьте, что в вызывающей команде SELECT указание имя_таблицы.</em> выбирает
всю текущую строку таблицы как составное значение. На строку таблицы можно сослаться и про-
сто по имени таблицы, например так:
SELECT name, double_salary(emp) AS dream
FROM emp
WHERE emp.cubicle ~= point ‘(2,1)’;
Однако это использование считается устаревшим, так как провоцирует путаницу. (Подробнее эти
две записи составных значений строки таблицы описаны в Подразделе 8.16.5.)
1002Расширение SQL
Иногда бывает удобно образовать составное значение аргумента на лету. Это позволяет сделать
конструкция ROW. Например, так можно изменить данные, передаваемые функции:
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
FROM emp;
Также возможно создать функцию, возвращающую составной тип. Например, эта функция возвра-
щает одну строку emp:
CREATE FUNCTION new_emp() RETURNS emp AS <script type="math/tex">SELECT text 'None' AS name,
1000.0 AS salary,
25 AS age,
point '(2,2)' AS cubicle;</script> LANGUAGE SQL;
В этом примере мы задали для каждого атрибута постоянное значение, но вместо этих констант
можно подставить любые вычисления.
Учтите два важных требования относительно определения функции:
• Порядок в списке выборки внутреннего запроса должен в точности совпадать с порядком сле-
дования столбцов в таблице, связанной с составным типом. (Имена столбцов, как показывает
пример выше, для системы значения не имеют.)
• Необходимо сделать так, чтобы каждое выражение имело тот же тип, что и соответствующий
столбец составного типа, при необходимости добавив приведение. В противном случае вы по-
лучите такие ошибки:
ERROR:
function declared to return emp returns varchar instead of text at column 1
(ОШИБКА: функция, объявленная как возвращающая emp, возвращает varchar вместо text в
столбце 1) Как и в случае с базовыми типами, автоматически никакие приведения в функцию
не добавляются.
Ту же функцию можно определить другим способом:
CREATE FUNCTION new_emp() RETURNS emp AS <script type="math/tex">SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;</script> LANGUAGE SQL;
Здесь мы записали SELECT, который возвращает один столбец нужного составного типа. В данной
ситуации этот вариант на самом деле не лучше, но в некоторых случаях он может быть удобной
альтернативой — например, если нам нужно вычислить результат, вызывая другую функцию, ко-
торая возвращает нужное составное значение. Этот вариант полезен и в случае, когда мы хотим
написать функцию, которая возвращает не обычный составной тип, а домен, определённый поверх
составного типа; тогда она в любом случае должна определяться как возвращающая единственный
столбец, так как никаким другим образом получить значение именно доменного типа нельзя.
Мы можем вызывать эту функцию напрямую, либо указав её в выражении значения:
SELECT new_emp();
new_emp
————————–
(None,1000.0,25,”(2,2)”)
либо обратившись к ней, как к табличной функции:
SELECT * FROM new_emp();
name | salary | age | cubicle
1003Расширение SQL
——+——–+—–+———
None | 1000.0 | 25 | (2,2)
Второй способ более подробно описан в Подразделе 38.5.7.
Когда используется функция, возвращающая составной тип, может возникнуть желание получить
из её результата только одно поле (атрибут). Это можно сделать, применяя такую запись:
SELECT (new_emp()).name;
name
——
None
Дополнительные скобки необходимы во избежание неоднозначности при разборе запроса. Если
вы попытаетесь выполнить запрос без них, вы получите ошибку:
SELECT new_emp().name;
ERROR: syntax error at or near “.”
LINE 1: SELECT new_emp().name;</p>
<p>(ОШИБКА: синтаксическая ошибка (примерное положение: “.”))
Функциональную запись также можно использовать и для извлечения атрибутов:
SELECT name(new_emp());
name
——
None
Как рассказывалось в Подразделе 8.16.5, запись с указанием поля и функциональная запись явля-
ются равнозначными.
Ещё один вариант использования функции, возвращающей составной тип, заключается в передаче
её результата другой функции, которая принимает этот тип строки на вход:
CREATE FUNCTION getname(emp) RETURNS text AS <script type="math/tex">SELECT $1.name;</script> LANGUAGE SQL;
SELECT getname(new_emp());
getname
———
None
(1 row)
38.5.4. Функции SQL с выходными параметрами
Альтернативный способ описать результаты функции — определить её с выходными параметрами,
как в этом примере:
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS ‘SELECT x + y’
LANGUAGE SQL;
SELECT add_em(3,7);
add_em
——–
10
(1 row)
1004Расширение SQL
Это по сути не отличается от версии add_em, показанной в Подразделе  38.5.2. Действительная
ценность выходных параметров в том, что они позволяют удобным способом определить функции,
возвращающие несколько столбцов. Например:
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS ‘SELECT x + y, x * y’
LANGUAGE SQL;
SELECT * FROM sum_n_product(11,42);
sum | product
—–+———
53 |
462
(1 row)
Фактически здесь мы определили анонимный составной тип для результата функции. Показанный
выше пример даёт тот же конечный результат, что и команды:
CREATE TYPE sum_prod AS (sum int, product int);
CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS ‘SELECT $1 + $2, $1 * $2’
LANGUAGE SQL;
Но предыдущий вариант зачастую удобнее, так как он не требует отдельно заниматься определе-
нием составного типа. Заметьте, что имена, назначаемые выходным параметрам, не просто деко-
ративные, а определяют имена столбцов анонимного составного типа. (Если вы опустите имя вы-
ходного параметра, система выберет имя сама.)
Заметьте, что выходные параметры не включаются в список аргументов при вызове такой функции
из SQL. Это объясняется тем, что PostgreSQL определяет сигнатуру вызова функции, рассматривая
только входные параметры. Это также значит, что при таких операциях, как удаление функции, в
ссылках на функцию учитываются только типы входных параметров. Таким образом, удалить эту
конкретную функцию можно любой из этих команд:
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
Параметры функции могут быть объявлены как IN (по умолчанию), OUT, INOUT или VARIADIC. Пара-
метр INOUT действует как входной (является частью списка аргументов при вызове) и как выход-
ной (часть типа записи результата). Параметры VARIADIC являются входными, но обрабатывается
специальным образом, как описано далее.
38.5.5. Функции SQL с переменным числом аргументов
Функции SQL могут быть объявлены как принимающие переменное число аргументов, с условием,
что все «необязательные» аргументы имеют один тип данных. Необязательные аргументы будут
переданы такой функции в виде массива. Для этого в объявлении функции последний параметр
помечается как VARIADIC; при этом он должен иметь тип массива. Например:
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS <script type="math/tex">SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);</script> LANGUAGE SQL;
SELECT mleast(10, -1, 5, 4.4);
mleast
——–
-1
(1 row)
По сути, все фактические аргументы, начиная с позиции VARIADIC, собираются в одномерный мас-
сив, как если бы вы написали
1005Расширение SQL
SELECT mleast(ARRAY[10, -1, 5, 4.4]);
– это не будет работать
На самом деле так вызвать эту функцию нельзя, или, по крайней мере, это не будет соответствовать
определению функции. Параметру VARIADIC соответствуют одно или несколько вхождений типа
его элемента, но не его собственного типа.
Но иногда бывает полезно передать функции с переменными параметрами уже подготовленный
массив; особенно когда одна функция с переменными параметрами хочет передавать свой массив
параметров другой. Также это более безопасный способ вызывать такую функцию, существующую
в схеме, где могут создавать объекты недоверенные пользователи; см. Раздел  10.3. Это можно
сделать, добавив VARIADIC в вызов:
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
Это предотвращает разворачивание переменного множества параметров функции в базовый тип,
что позволяет сопоставить с ним значение типа массива. VARIADIC можно добавить только к по-
следнему фактическому аргументу вызова функции.
Также указание VARIADIC даёт единственную возможность передать пустой массив функции с пе-
ременными параметрами, например, так:
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
Простой вызов SELECT mleast() не будет работать, так как переменным параметрам должен соот-
ветствовать минимум один фактический аргумент. (Можно определить вторую функцию с таким
же именем mleast, но без параметров, если вы хотите выполнять такие вызовы.)
Элементы массива, создаваемые из переменных параметров, считаются не имеющими собствен-
ных имён. Это означает, что передать функции с переменными параметрами именованные аргу-
менты нельзя (см. Раздел 4.3), если только при вызове не добавлено VARIADIC. Например, этот ва-
риант будет работать:
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
А эти варианты нет:
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
38.5.6. Функции SQL со значениями аргументов по умолчанию
Функции могут быть объявлены со значениями по умолчанию для некоторых или всех входных
аргументов. Значения по умолчанию подставляются, когда функция вызывается с недостаточным
количеством фактических аргументов. Так как аргументы можно опускать только с конца спис-
ка фактических аргументов, все параметры после параметра со значением по умолчанию также
получат значения по умолчанию. (Хотя запись с именованными аргументами могла бы ослабить
это ограничение, оно всё же остаётся в силе, чтобы позиционные ссылки на аргументы остава-
лись действительными.) Независимо от того, используете вы эту возможность или нет, она требует
осторожности при вызове функций в базах данных, где одни пользователи не доверяют другим;
см. Раздел 10.3.
Например:
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS <script type="math/tex">SELECT $1 + $2 + $3;</script>;
SELECT foo(10, 20, 30);
1006Расширение SQL
foo
—–
60
(1 row)
SELECT foo(10, 20);
foo
—–
33
(1 row)
SELECT foo(10);
foo
—–
15
(1 row)
SELECT foo(); – не работает из-за отсутствия значения по умолчанию для первого
аргумента
ERROR: function foo() does not exist
(ОШИБКА: функция foo() не существует) Вместо ключевого слова DEFAULT можно использовать
знак =.
38.5.7. Функции SQL, порождающие таблицы
Все функции SQL можно использовать в предложении FROM запросов, но наиболее полезно это для
функций, возвращающих составные типы. Если функция объявлена как возвращающая базовый
тип, она возвращает таблицу с одним столбцом. Если же функция объявлена как возвращающая
составной тип, она возвращает таблицу со столбцами для каждого атрибута составного типа.
Например:
CREATE
INSERT
INSERT
INSERT
TABLE foo (fooid int, foosubid int, fooname text);
INTO foo VALUES (1, 1, ‘Joe’);
INTO foo VALUES (1, 2, ‘Ed’);
INTO foo VALUES (2, 1, ‘Mary’);
CREATE FUNCTION getfoo(int) RETURNS foo AS <script type="math/tex">SELECT * FROM foo WHERE fooid = $1;</script> LANGUAGE SQL;
SELECT *, upper(fooname) FROM getfoo(1) AS t1;
fooid | foosubid | fooname | upper
——-+———-+———+——-
1 |
1 | Joe
| JOE
(1 row)
Как показывает этот пример, мы можем работать со столбцами результата функции так же, как
если бы это были столбцы обычной таблицы.
Заметьте, что мы получаем из данной функции только одну строку. Это объясняется тем, что мы
не использовали указание SETOF. Оно описывается в следующем разделе.
38.5.8. Функции SQL, возвращающие множества
Когда SQL-функция объявляется как возвращающая SETOF некий_тип, конечный запрос функции
выполняется до завершения и каждая строка выводится как элемент результирующего множества.
1007Расширение SQL
Это обычно используется, когда функция вызывается в предложении FROM. В этом случае каждая
строка, возвращаемая функцией, становится строкой таблицы, появляющейся в запросе. Напри-
мер, в предположении, что таблица foo имеет то же содержимое, что и раньше, мы выполняем:
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS <script type="math/tex">SELECT * FROM foo WHERE fooid = $1;</script> LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
Тогда в ответ мы получим:
fooid | foosubid | fooname
——-+———-+———
1 |
1 | Joe
1 |
2 | Ed
(2 rows)
Также возможно выдать несколько строк со столбцами, определяемыми выходными параметрами,
следующим образом:
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);
CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS <script type="math/tex">SELECT $1 + tab.y, $1 * tab.y FROM tab;</script> LANGUAGE SQL;
SELECT * FROM sum_n_product_with_tab(10);
sum | product
—–+———
11 |
10
13 |
30
15 |
50
17 |
70
(4 rows)
Здесь ключевая особенность заключается в записи RETURNS SETOF record, показывающей, что
функция возвращает множество строк вместо одной. Если существует только один выходной пара-
метр, укажите тип этого параметра вместо record.
Часто бывает полезно сконструировать результат запроса, вызывая функцию, возвращающую мно-
жество, несколько раз, передавая при каждом вызове параметры из очередных строк таблицы или
подзапроса. Для этого рекомендуется применить ключевое слово LATERAL, описываемое в Подраз-
деле 7.2.1.5. Ниже приведён пример использования функции, возвращающей множество, для пе-
речисления элементов древовидной структуры:
SELECT * FROM nodes;
name
| parent
———–+——–
Top
|
Child1
| Top
Child2
| Top
Child3
| Top
SubChild1 | Child1
SubChild2 | Child1
(6 rows)
CREATE FUNCTION listchildren(text) RETURNS SETOF text AS <script type="math/tex">1008Расширение SQL
SELECT name FROM nodes WHERE parent = $1</script> LANGUAGE SQL STABLE;
SELECT * FROM listchildren(‘Top’);
listchildren
————–
Child1
Child2
Child3
(3 rows)
SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
name |
child
——–+———–
Top
| Child1
Top
| Child2
Top
| Child3
Child1 | SubChild1
Child1 | SubChild2
(5 rows)
В этом примере не делается ничего такого, что мы не могли бы сделать, применив простое соеди-
нение, но для более сложных вычислений возможность поместить некоторую логику в функцию
может быть весьма удобной.
Функции, возвращающие множества, могут также вызываться в списке выборки запроса. Для каж-
дой строки, которая генерируется самим запросом, вызывается функция, возвращающая множе-
ство, и для каждого элемента набора её результатов генерируется отдельная строка. Предыдущий
пример можно было бы также переписать с применением запросов следующим образом:
SELECT listchildren(‘Top’);
listchildren
————–
Child1
Child2
Child3
(3 rows)
SELECT name, listchildren(name) FROM nodes;
name | listchildren
——–+————–
Top
| Child1
Top
| Child2
Top
| Child3
Child1 | SubChild1
Child1 | SubChild2
(5 rows)
Заметьте, что в последней команде SELECT для Child2, Child3 и т. д. строки не выдаются. Это
происходит потому, что listchildren возвращает пустое множество для этих аргументов, так что
строки результата не генерируются. Это же поведение мы получаем при внутреннем соединении
с результатом функции с применением LATERAL.
Поведение PostgreSQL с функциями, возвращающими множества, в списке выборки запроса прак-
тически не отличается от поведения с такими функциями, помещёнными в предложение LATERAL
FROM. Например, запрос:
SELECT x, generate_series(1,5) AS g FROM tab;
почти равнозначен
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
1009Расширение SQL
Он мог быть полностью идентичным, но в данном конкретном примере планировщик может ре-
шить перенести g во внешнюю сторону соединения, так как g не имеет фактической зависимости
по времени вычисления от tab. Такое решение привело бы к изменению порядка строк. Функции,
возвращающие множества, в списке выборки всегда вычисляются так, как они вычислялись бы
внутри соединения с вложенным циклом с остальным предложением FROM, так что эти функции
выполняются до завершения прежде чем начинается рассмотрение следующей строки из предло-
жения FROM.
Если в списке выборки запроса используются несколько функций, возвращающих запросы, они
вычисляются примерно так же, как если бы они были помещены в один элемент LATERAL ROWS
FROM( … ) предложения FROM. Для каждой строки из нижележащего запроса выдаётся строка
с первым результатом каждой функции, а затем строка со вторым результатом и так далее. Если
какие-либо из функций, возвращающих множества, выдают меньше результатов, чем другие, то
вместо недостающих данных подставляются значения NULL, так что общее число строк, выдава-
емых для одной нижележащей строки, равно числу строк, которое выдаёт функция с наибольшим
количеством строк в возвращаемом множестве. Таким образом, функции, возвращающие множе-
ства, выполняются совместно, пока все их множества не будут исчерпаны, а затем выполнение
продолжается со следующей нижележащей строкой.
Функции, возвращающие множества, могут быть вложенными в списке выборки, но это не допус-
кается в элементах предложения FROM. В таких случаях каждый уровень вложенности обрабаты-
вается отдельно, как если бы это был отдельный элемент LATERAL ROWS FROM( … ). Например, в
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
возвращающие множества функции srf2, srf3 и srf5 будут выполняться совместно для каждой
строки tab, а затем srf1 и srf4 будут совместно применяться к каждой строке, произведённой
нижними функциями.
Функции, возвращающие множества, нельзя использовать в конструкциях, вычисляемых по усло-
вию, например, CASE или COALESCE. Например, рассмотрите запрос
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
Может показаться, что он должен выдать пять экземпляров входных строк, в которых x &gt; 0, и по
одному экземпляру остальных строк; но на деле, так как generate_series(1, 5) будет выполнять-
ся в неявном элементе LATERAL FROM до того, как выражение CASE вообще будет рассматриваться,
должно было бы выдаваться пять экземпляров абсолютно всех выходных строк. Во избежание пу-
таницы в таких случаях выдаётся ошибка при разборе запроса.
Примечание
Если последняя команда функции — INSERT, UPDATE или DELETE с RETURNING, эта ко-
манда будет всегда выполняться до завершения, даже если функция не объявлена с
указанием SETOF или вызывающий запрос не выбирает все строки результата. Все до-
полнительные строки, выданные предложением RETURNING, просто игнорируются, но
соответствующие изменения в таблице всё равно произойдут (и будут завершены до
выхода из функции).
Примечание
В PostgreSQL до версии 10 при помещении нескольких функций, возвращающих мно-
жества, в один список выборки поведение было не очень разумным, если они возвра-
щали не одинаковое число строк. В таких случаях число выходных строк равнялось
наименьшему общему множителю количеств строк, возвращаемых этими функциями.
Также и вложенные функции, возвращающие множества, работали не так, как описа-
но выше; у такой функции мог быть максимум один аргумент, возвращающий множе-
1010Расширение SQL
ство, и каждая вложенность вычислялась независимо. Кроме того, ранее допускалось
и условное выполнение (вычисление таких функций внутри CASE и т. п.), что ещё боль-
ше всё усложняло. При написании запросов, которые должны работать и со старыми
версиями PostgreSQL, рекомендуется использовать синтаксис LATERAL, так как это га-
рантирует одинаковый результат с разными версиями. Если в вашем запросе использу-
ется условное вычисление функции, возвращающей множество, его можно исправить,
переместив проверку условия в специально созданную функцию, возвращающую мно-
жество. Например:
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
можно заменить на
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
RETURNS SETOF int AS <script type="math/tex">BEGIN
IF cond THEN
RETURN QUERY SELECT generate_series(start, fin);
ELSE
RETURN QUERY SELECT els;
END IF;
END</script> LANGUAGE plpgsql;
SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
Это будет работать одинаково во всех версиях PostgreSQL.
38.5.9. Функции SQL, возвращающие таблицы (TABLE)
Есть ещё один способ объявить функцию, возвращающую множества, — использовать синтаксис
RETURNS TABLE(столбцы). Это равнозначно использованию одного или нескольких параметров OUT
с объявлением функции как возвращающей SETOF record (или SETOF тип единственного параметра,
если это применимо). Этот синтаксис описан в последних версиях стандарта SQL, так что этот
вариант может быть более портируемым, чем SETOF.
Например, предыдущий пример с суммой и произведением можно также переписать так:
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS <script type="math/tex">SELECT $1 + tab.y, $1 * tab.y FROM tab;</script> LANGUAGE SQL;
Запись RETURNS TABLE не позволяет явно указывать OUT и INOUT для параметров — все выходные
столбцы необходимо записать в списке TABLE.
38.5.10. Полиморфные функции SQL
Функции SQL могут быть объявлены как принимающие и возвращающие полиморфные типы
anyelement, anyarray, anynonarray, anyenum и anyrange. За более подробным объяснением поли-
морфизма функций обратитесь к Подразделу 38.2.5. В следующем примере полиморфная функция
make_array создаёт массив из двух элементов произвольных типов:
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS <script type="math/tex">SELECT ARRAY[$1, $2];</script> LANGUAGE SQL;
SELECT make_array(1, 2) AS intarray, make_array(‘a’::text, ‘b’) AS textarray;
intarray | textarray
———-+———–
{1,2}
| {a,b}
1011Расширение SQL
(1 row)
Обратите внимание на приведение типа ‘a’::text, определяющее, что аргумент имеет тип text.
Оно необходимо, если аргумент задаётся просто строковой константой, так как иначе он будет
воспринят как имеющий тип unknown, а массив типов unknown является недопустимым. Без этого
приведения вы получите такую ошибку:
ERROR:
could not determine polymorphic type because input has type “unknown”
(ОШИБКА: не удалось определить полиморфный тип, так как входные аргументы имеют тип
“unknown”)
Функция с полиморфными аргументами может иметь фиксированный тип результата, однако об-
ратное не допускается. Например:
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS <script type="math/tex">SELECT $1 > $2;</script> LANGUAGE SQL;
SELECT is_greater(1, 2);
is_greater
————
f
(1 row)
CREATE FUNCTION invalid_func() RETURNS anyelement AS <script type="math/tex">SELECT 1;</script> LANGUAGE SQL;
ERROR: cannot determine result data type
DETAIL: A function returning a polymorphic type must have at least one polymorphic
argument.
(ОШИБКА: не удалось определить тип результата; ПОДРОБНОСТИ: Функция, возвращающая по-
лиморфный тип, должна иметь минимум один полиморфный аргумент.)
Полиморфизм можно применять и с функциями, имеющими выходные аргументы. Например:
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS ‘select $1, array[$1,$1]’ LANGUAGE SQL;
SELECT * FROM dup(22);
f2 |
f3
—-+———
22 | {22,22}
(1 row)
Полиморфизм также можно применять с функциями с переменными параметрами. Например:
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS <script type="math/tex">SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);</script> LANGUAGE SQL;
SELECT anyleast(10, -1, 5, 4);
anyleast
———-
-1
(1 row)
SELECT anyleast(‘abc’::text, ‘def’);
1012Расширение SQL
anyleast
———-
abc
(1 row)
CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS <script type="math/tex">SELECT array_to_string($2, $1);</script> LANGUAGE SQL;
SELECT concat_values(‘|’, 1, 4, 2);
concat_values
—————
1|4|2
(1 row)
38.5.11. Функции SQL с правилами сортировки
Когда функция SQL принимает один или несколько параметров сортируемых типов данных, пра-
вило сортировки определяется при каждом вызове функции, в зависимости от правил сортировки,
связанных с фактическими аргументами, как описано в Разделе 23.2. Если правило сортировки
определено успешно (то есть не возникло конфликтов между неявно установленными правилами
сортировки аргументов), оно неявно назначается для всех сортируемых параметров. Выбранное
правило будет определять поведение операций, связанных с сортировкой, в данной функции. На-
пример, для показанной выше функции anyleast, результат
SELECT anyleast(‘abc’::text, ‘ABC’);
будет зависеть от правила сортировки по умолчанию, заданного в базе данных. С локалью C ре-
зультатом будет строка ABC, но со многими другими локалями это будет abc. Нужное правило сор-
тировки можно установить принудительно, добавив предложение COLLATE к одному из аргументов
функции, например:
SELECT anyleast(‘abc’::text, ‘ABC’ COLLATE “C”);
С другой стороны, если вы хотите, чтобы функция работала с определённым правилом сортировки,
вне зависимости от того, с каким она была вызвана, вставьте предложения COLLATE где требуется
в определении функции. Эта версия anyleast всегда будет сравнивать строки по правилам локали
en_US:
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS <script type="math/tex">SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);</script> LANGUAGE SQL;
Но заметьте, что при попытке применить правило к несортируемому типу данных, возникнет ошиб-
ка.
Если для фактических аргументов не удаётся определить общее правило сортировки, функция SQL
считает, что им назначено правило сортировки по умолчанию для их типа данных (обычно это
то же правило сортировки, что определено по умолчанию для базы данных, но оно может быть и
другим для параметров доменных типов).
Поведение сортируемых параметров можно воспринимать как ограниченную форму полиморфиз-
ма, применимую только к текстовым типам данных.
38.6. Перегрузка функций
Вы можете определить несколько функций с одним именем SQL, если эти функции будут прини-
мать разные аргументы. Другими словами, имена функций можно перегружать. Независимо от
того, используете вы эту возможность или нет, она требует предосторожности при вызове функций
в базах данных, где одни пользователи не доверяют другим; см. Раздел 10.3. Когда выполняется
запрос, сервер определяет, какую именно функцию вызывать, по количеству и типам представлен-
1013Расширение SQL
ных аргументов. Перегрузка может быть полезна для имитации функций с переменным количе-
ством аргументов, до какого-то конечного числа.
Создавая семейство перегруженных функций, необходимо не допускать неоднозначности. Напри-
мер, если созданы функции:
CREATE FUNCTION test(int, real) RETURNS …
CREATE FUNCTION test(smallint, double precision) RETURNS …
не вполне понятно, какая функция будет вызвана с довольно простыми аргументами вроде test(1,
1.5). Реализованные в данный момент правила разрешения типов описаны в Главе 10, но разра-
батывать систему, которая будет незаметно полагаться на такие особенности, неразумно.
Функции, принимающей один аргумент составного типа, обычно не следует давать имя, совпада-
ющее с именем какого-либо атрибута (поля) этого типа. Вспомните, что запись атрибут(табли-
ца) считается равнозначной таблица.атрибут. В случае, когда возникает неоднозначность между
функцией, принимающей составной тип, и атрибутом составного типа, всегда будет выбираться
атрибут. Этот выбор можно переопределить, дополнив имя функции схемой (то есть, записав схе-
ма.функция(таблица) ), но лучше избежать этой проблемы, подобрав разные имена.
Другой тип конфликта возможен между обычными функциями и функциями с переменными па-
раметрами. Например, можно создать функции foo(numeric) и foo(VARIADIC numeric[]). В этом
случае будет непонятно, какая функция должна выбираться при передаче одного числового аргу-
мента, например foo(10.1). При разрешении этого конфликта предпочтение отдаётся функции,
найденной первой по пути поиска, либо, если две функции находятся в одной схеме, выбирается
функция с постоянными аргументами.
При перегрузке функций на языке C есть дополнительное ограничение: имя уровня C каждой
функции в семействе перегруженных функций должно отличаться от имён уровня C всех других
функций, как внутренних, так и загружаемых динамически. Если это правило нарушается, пове-
дение зависит от среды. Вы можете получить ошибку компоновщика во время выполнения, либо
будет вызвана не та функция (обычно внутренняя). Альтернативная форма предложения AS для
SQL-команды CREATE FUNCTION позволяет отвязать имя SQL-функции от имени, определённого в
исходном коде на C. Например:
CREATE FUNCTION test(int) RETURNS int
AS ‘имя_файла’, ‘test_1arg’
LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
AS ‘имя_файла’, ‘test_2arg’
LANGUAGE C;
Имена функций на C здесь следуют одному из множества возможных соглашений.
38.7. Категории изменчивости функций
Для каждой функции определяется характеристика изменчивости, с возможными вариантами:
VOLATILE, STABLE и IMMUTABLE. Если эта характеристика не задаётся явно в команде CREATE
FUNCTION, по умолчанию подразумевается VOLATILE. Категория изменчивости представляет со-
бой обещание некоторого поведения функции для оптимизатора:
• Изменчивая функция (VOLATILE) может делать всё, что угодно, в том числе, модифицировать
базу данных. Она может возвращать различные результаты при нескольких вызовах с оди-
наковыми аргументами. Оптимизатор не делает никаких предположений о поведении таких
функций. В запросе, использующем изменчивую функцию, она будет вычисляться заново для
каждой строки, когда потребуется её результат.
• Стабильная функция (STABLE) не может модифицировать базу данных и гарантированно воз-
вращает одинаковый результат, получая одинаковые аргументы, для всех строк в одном опе-
раторе. Эта характеристика позволяет оптимизатору заменить множество вызовов этой функ-
ции одним. В частности, выражение, содержащее такую функцию, можно безопасно исполь-
1014Расширение SQL
зовать в условии поиска по индексу. (Так как при поиске по индексу целевое значение вычис-
ляется только один раз, а не для каждой строки, использовать функцию с характеристикой
VOLATILE в условии поиска по индексу нельзя.)
• Постоянная функция (IMMUTABLE) не может модифицировать базу данных и гарантированно
всегда возвращает одинаковые результаты для одних и тех же аргументов. Эта характеристи-
ка позволяет оптимизатору предварительно вычислить функцию, когда она вызывается в за-
просе с постоянными аргументами. Например, запрос вида SELECT … WHERE x = 2 + 2 мож-
но упростить до SELECT … WHERE x = 4, так как нижележащая функция оператора сложе-
ния помечена как IMMUTABLE.
Для наилучших результатов оптимизации, функции следует назначать самую строгую характери-
стику изменчивости, которой она соответствует.
Любая функция с побочными эффектами должна быть помечена как VOLATILE, чтобы обращения к
ней не исключались при оптимизации. Даже если функция не имеет побочных эффектов, её нужно
пометить как VOLATILE, если её значение может меняться при выполнении одного запроса; таковы
функции random(), currval() и timeofday().
Другой важный пример представляет семейство функций current_timestamp, которые имеют ха-
рактеристику STABLE, потому что их значения не меняются в рамках одной транзакции.
Характеристики STABLE и IMMUTABLE мало различаются, когда речь идёт о простых интерактивных
запросах, которые планируются и сразу же выполняются; не имеет большого значения, будет ли
функция выполнена однократно на этапе планирования или в начале выполнения. Существенное
различие проявляется, когда план сохраняется и многократно используется позже. Если функция
помечена как IMMUTABLE, тогда как на самом деле она не является постоянной, она может быть
сведена к константе во время планирования, так что при последующих выполнениях плана вместо
неё будет использоваться неактуальное значение. Это опасно при использовании подготовленных
операторов или языков функций, кеширующих планы (например, PL/pgSQL).
У функций, написанных на SQL или на любом другом стандартном процедурном языке, есть ещё
одно важное свойство, определяемое характеристикой изменчивости, а именно видимость изме-
нений, произведённых командой SQL, которая вызывает эту функцию. Функция VOLATILE будет
видеть такие изменения, тогда как STABLE и IMMUTABLE — нет. Это поведение реализуется посред-
ством снимков в MVCC (см. Главу 13): STABLE и IMMUTABLE используют снимок, полученный в нача-
ле вызывающего запроса, тогда как функции VOLATILE получают свежий снимок в начале каждого
запроса, который они выполняют.
Примечание
Функции, написанные на C, могут работать со снимками как угодно, но обычно лучше
сделать так, чтобы они действовали аналогично.
Вследствие такой организации работы со снимками, функцию, содержащую только команды
SELECT, можно безопасно пометить как STABLE, даже если она выбирает данные из таблиц, которые
могут быть изменены параллельными запросами. PostgreSQL выполнит все команды в функции
STABLE со снимком, полученным для вызывающего запроса, так что они будут видеть одно пред-
ставление базы данных на протяжении всего запроса.
То же самое поведение со снимками распространяется на команды SELECT в функциях IMMUTABLE.
Вообще в функциях IMMUTABLE обычно неразумно выбирать данные из таблиц, так как «постоян-
ство» функции будет нарушено, если содержимое таблиц изменится. Однако PostgreSQL не при-
нуждает вас явно отказаться от этого.
Одна из распространённых ошибок — помечать функцию как IMMUTABLE, при том, что её резуль-
таты зависят от параметра конфигурации. Например, функция, работающая с временем, может
1015Расширение SQL
выдавать результаты, зависящие от параметра TimeZone. Для надёжности такие функции следует
помечать как STABLE.
Примечание
PostgreSQL требует, чтобы функции STABLE и IMMUTABLE не содержали SQL-команд, кро-
ме SELECT, для предотвращения модификации данных. (Это не совсем непробиваемое
ограничение, так как эти функции всё же могут вызывать функции VOLATILE, способ-
ные модифицировать базу данных. Если вы реализуете такую схему, вы увидите, что
функция STABLE и IMMUTABLE не замечает изменений в базе данных, произведённых вы-
званной функцией, так как они не проявляются в её снимке данных.)
38.8. Функции на процедурных языках
PostgreSQL позволяет разрабатывать собственные функции и на языках, отличных от SQL и C.
Эти другие языки в целом обычно называются процедурными языками (PL, Procedural Languages).
Процедурные языки не встроены в сервер PostgreSQL; они предлагаются загружаемыми модулями.
За дополнительной информацией обратитесь к Главе 42 и следующим главам.
38.9. Внутренние функции
Внутренние функции — это функции, написанные на языке C, и статически скомпонованные в
исполняемый код сервера PostgreSQL. В «теле» определения функции задаётся имя функции на
уровне C, которое не обязательно должно совпадать с именем, объявленным для использования в
SQL. (Обратной совместимости ради, тело функции может быть пустым, что будет означать, что
имя функции на уровне C совпадает с именем в SQL.)
Обычно все внутренние функции, представленные на сервере, объявляются в ходе инициализации
кластера баз данных (см. Раздел 18.2), но пользователь может воспользоваться командой CREATE
FUNCTION и добавить дополнительные псевдонимы для внутренней функции. Внутренние функции
объявляются в CREATE FUNCTION с именем языка internal. Например, так можно создать псевдоним
для функции sqrt:
CREATE FUNCTION square_root(double precision) RETURNS double precision
AS ‘dsqrt’
LANGUAGE internal
STRICT;
(Большинство внутренних функций должны объявляться как «strict».)
Примечание
Не все «предопределённые» функции являются «внутренними» в вышеописанном
смысле. Некоторые предопределённые функции написаны на SQL.
38.10. Функции на языке C
Пользовательские функции могут быть написаны на C (или на языке, который может быть совме-
стим с C, например C++). Такие функции компилируются в динамически загружаемые объекты
(также называемые разделяемыми библиотеками) и загружаются сервером по требованию. Имен-
но метод динамической загрузки отличает функции «на языке C» от «внутренних» функций —
правила написания кода по сути одни и те же. (Собственно, поэтому стандартная библиотека внут-
ренних функций может быть богатым источником примеров для написания собственных функций
на языке C.)
1016Расширение SQL
В настоящее время для функций на C применяется только одно соглашение о вызовах
(«версии 1»). Поддержка этого соглашения обозначается объявлением функции с макросом
(PG_FUNCTION_INFO_V1), как показано ниже.
38.10.1. Динамическая загрузка
В первый раз, когда в сеансе вызывается пользовательская функция в определённом внешнем объ-
ектном файле, загрузчик динамических модулей загружает этот файл в память, чтобы можно бы-
ло вызвать эту функцию. Таким образом, в команде CREATE FUNCTION, объявляющей пользователь-
скую функцию на языке C, необходимо определить две сущности для функции: имя загружаемого
объектного файла и имя уровня C (символ для компоновки) заданной функции в этом объектном
файле. Если имя уровня C не указано явно, предполагается, что оно совпадает с именем функции
в SQL.
Для нахождения разделяемого объектного файла по имени, заданному в команде CREATE FUNCTION,
применяется следующий алгоритм:</p>
<ol>
  <li>Если имя задаётся абсолютным путём, загружается заданный файл.</li>
  <li>Если имя начинается со строки $libdir, эта часть пути заменяется путём к каталогу библиотек
PostgreSQL, который определяется во время сборки.</li>
  <li>Если в имени не указывается каталог, поиск файла производится по пути, заданному конфигу-
рационной переменной dynamic_library_path.</li>
  <li>В противном случае (файл не был найден в пути поиска, или в его имени указывается не аб-
солютный путь к каталогу), загрузчик попытается принять имя как есть, что, скорее всего, не
увенчается успехом. (Полагаться на текущий рабочий каталог ненадёжно.)
Если эта последовательность не даёт положительный результат, к данному имени добавляется
принятое на данной платформе расширение файлов библиотек (часто .so) и последовательность
повторяется снова. Если и это не приводит к успеху, происходит сбой загрузки.
Для поиска разделяемых библиотек рекомендуется задавать либо путь относительно $libdir, ли-
бо путь динамических библиотек. Это упрощает обновление версии при перемещении новой ин-
сталляции в другое место. Какой именно каталог подразумевается под $libdir, можно узнать с
помощью команды pg_config –pkglibdir.
Пользователь, от имени которого работает сервер PostgreSQL, должен иметь возможность пройти
путь к файлу, который требуется загрузить. Очень распространённая ошибка — когда сам файл
или каталог верхнего уровня оказывается недоступным для чтения и/или исполнения для пользо-
вателя postgres.
В любом случае, имя файла, заданное в команде CREATE FUNCTION, записывается в системные ка-
талоги буквально, так что если этот файл потребуется загрузить ещё раз, та же процедура будет
проделана снова.
Примечание
PostgreSQL не будет компилировать функцию на C автоматически, поэтому прежде чем
ссылаться на объектный файл в команде CREATE FUNCTION, его нужно скомпилировать.
За дополнительными сведениями обратитесь к Подразделу 38.10.5.
Чтобы гарантировать, что динамически загружаемый объектный файл не будет загружен несовме-
стимым сервером, PostgreSQL проверяет, содержит ли этот файл «отличительный блок» с требу-
емым содержимым. Благодаря этому сервер может выявить очевидную несовместимость, напри-
мер, когда код скомпилирован для другой старшей версии PostgreSQL. Чтобы включить его в свой
модуль, напишите это в одном (и только одном) из исходных файлов модуля, после включения за-
головочного файла fmgr.h:
1017Расширение SQL
PG_MODULE_MAGIC;
После того как он был использован первый раз, динамически загружаемый объектный файл со-
храняется в памяти. Следующие обращения в том же сеансе к функциям в этом файле повлекут
только небольшие издержки, связанные с поиском в таблице символов. Если вам нужно принуди-
тельно перезагрузить объектный файл, например, после перекомпиляции, начните новый сеанс.
Динамически загружаемый файл может дополнительно содержать функции инициализации и за-
вершения работы библиотеки. Если в файле находится функция с именем _PG_init, эта функция
будет вызвана сразу после загрузки файла. Эта функция не принимает параметры и не должна
ничего возвращать. Если в файле находится функция _PG_fini, эта функция будет вызвана непо-
средственно перед выгрузкой файла. Эта функция так же не принимает параметры и не должна
ничего возвращать. Заметьте, что _PG_fini будет вызываться только при выгрузке файла, но не
при завершении процесса. (В настоящее время выгрузка отключена и не происходит никогда, но
в будущем это может измениться.)
38.10.2. Базовые типы в функциях на языке C
Чтобы понимать, как написать функцию на языке C, вы должны знать, как внутри PostgreSQL пред-
ставляются базовые типы данных и как их могут принимать и передавать функции. PostgreSQL
внутри воспринимает базовые типы как «блоки памяти». Пользовательские функции, устанавли-
ваемые для типов, в свою очередь, определяют, как PostgreSQL может работать с этими типами.
То есть, PostgreSQL только сохраняет и загружает данные с диска, а для ввода, обработки и вывода
данных он использует определяемые вами функции.
Базовые типы могут иметь один из трёх внутренних форматов:
• передаётся по значению, фиксированной длины
• передаётся по ссылке, фиксированной длины
• передаётся по ссылке, переменной длины
Типы, передаваемые по значению, могут иметь размер только 1, 2 или 4 байта (и 8 байт, если
sizeof(Datum) равен 8 на вашей машине). Определяя собственные типы, следует позаботиться о
том, чтобы они имели одинаковый размер (в байтах) во всех архитектурах. Например, тип long
опасен, так как он имеет размер 4 байта на одних машинах, и 8 байт на других, тогда как тип
int состоит из 4 байт в большинстве систем Unix. Поэтому разумной реализацией типа int4 на
платформе Unix может быть такая:
/* 4-байтное целое, передаётся по значению <em>/
typedef int int4;
(В коде собственно PostgreSQL этот тип называется int32, так как в C принято соглашение, что
intXX подразумевает XX бит. Заметьте, что вследствие этого тип int8 в C имеет размер 1 байт.
Тип int8, принятый в SQL, в C называется int64. См. также Таблицу 38.1.)
С другой стороны, типы фиксированной длины любого размера можно передавать по ссылке. На-
пример, взгляните на пример реализации типа PostgreSQL:
/</em> 16-байтная структура, передаётся по ссылке <em>/
typedef struct
{
double x, y;
} Point;
В функции PostgreSQL и из них могут передаваться только указатели на такие типы. Чтобы вернуть
значение такого типа, выделите для него нужное количество памяти функцией palloc, заполните
выделенную память и верните указатель на неё. (Если вы захотите просто вернуть то же значение,
что было получено во входном аргументе этого же типа данных, вы можете пропустить дополни-
тельный вызов palloc и просто вернуть указатель на это поступившее значение.)
1018Расширение SQL
Наконец, все типы переменной длины также должны передаваться по ссылке. Все типы перемен-
ной длины должны начинаться с обязательного поля длины размером ровно 4 байта, которая бу-
дет задаваться макросом SET_VARSIZE; никогда не устанавливайте это поле вручную! Все данные,
которые будут храниться в этом типе, должны размещаться в памяти непосредственно за этим
полем длины. Поле длины содержит полную длину структуры, то есть включает размер самого
поля длины.
Ещё один важный момент — старайтесь не оставлять неинициализированных байт в значениях
данных; например, обнуляйте все возможные байты выравнивания, которые могут присутствовать
в структурах. Если этого не делать, логически равные значения ваших данных могут представ-
ляться неравными планировщику, что приведёт к построению неэффективных (хотя и корректных)
планов.
Предупреждение
Никогда не изменяйте содержимое, передаваемое на вход по ссылке. Если вы сделаете
это, вы скорее всего испортите данные на диске, так как полученный вами указатель
указывает непосредственно на место в дисковом буфере. Единственное исключение из
этого правила освещается в Разделе 38.11.
В качестве примера мы можем определить тип text так:
typedef struct {
int32 length;
char data[FLEXIBLE_ARRAY_MEMBER];
} text;
Запись [FLEXIBLE_ARRAY_MEMBER] означает, что действительная длина массива данных в этом объ-
явлении не указывается.
Работая с типами переменной длины, мы должны аккуратно выделить нужный объём памяти и
записать его размер в поле длины. Например, если нужно сохранить 40 байт в структуре text,
можно применить такой код:
#include “postgres.h”
…
char buffer[40]; /</em> our source data <em>/
…
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination-&gt;data, buffer, 40);
…
VARHDRSZ совпадает с sizeof(int32), но для получения размера заголовка типа переменной длины
хорошим стилем считается применять макрос VARHDRSZ. Кроме того, поле длины должно устанав-
ливаться макросом SET_VARSIZE, а не простым присваиванием.
В Таблице 38.1 указано, какие типы языка C соответствуют типам SQL при написании функций
на C с использованием встроенных типов PostgreSQL. В столбце «Определён в» указывается, ка-
кой заголовочный файл необходимо подключить, чтобы получить определение типа. (Фактическое
определение может быть в другом файле, который подключается из указанного, однако рекомен-
дуется придерживаться обозначенного интерфейса.) Заметьте, что в любом исходном файле всегда
необходимо первым включать postgres.h, так как в нём объявляется ряд вещей, которые нужны
в любом случае.
Таблица 38.1. Типы C, эквивалентные встроенным типам SQL
Тип SQL Тип C Определён в
abstime AbsoluteTime utils/nabstime.h
1019Расширение SQL
Тип SQL Тип C Определён в
bigint (int8) int64 postgres.h
boolean bool postgres.h (может быть встро-
ен в компиляторе)
box BOX</em> utils/geo_decls.h
bytea bytea* postgres.h
“char” char (встроен в компиляторе)
character BpChar* postgres.h
cid CommandId postgres.h
date DateADT utils/date.h
smallint (int2) int16 postgres.h
int2vector int2vector* postgres.h
integer (int4) int32 postgres.h
real (float4) float4* postgres.h
double precision (float8) float8* postgres.h
interval Interval* datatype/timestamp.h
lseg LSEG* utils/geo_decls.h
name Name postgres.h
oid Oid postgres.h
oidvector oidvector* postgres.h
path PATH* utils/geo_decls.h
point POINT* utils/geo_decls.h
regproc regproc postgres.h
reltime RelativeTime utils/nabstime.h
text text* postgres.h
tid ItemPointer storage/itemptr.h
time TimeADT utils/date.h
time with time zone TimeTzADT utils/date.h
timestamp Timestamp* datatype/timestamp.h
tinterval TimeInterval utils/nabstime.h
varchar VarChar* postgres.h
xid TransactionId postgres.h
Теперь, когда мы рассмотрели все возможные структуры для базовых типов, мы можем перейти
к примерам реальных функций.
38.10.3. Соглашение о вызовах версии 1
Соглашение о вызовах версии 1 полагается на макросы, скрывающие основную долю сложностей,
связанных с передачей аргументов и результатов. По соглашению версии 1 функция на C должна
всегда определяться так:
Datum funcname(PG_FUNCTION_ARGS)
В дополнение к этому, в том же исходном файле должен присутствовать вызов макроса:
PG_FUNCTION_INFO_V1(funcname);
1020Расширение SQL
(Обычно его принято записывать непосредственно перед функцией.) Этот вызов макроса не нужен
для функций internal, так как PostgreSQL предполагает, что все внутренние функции используют
соглашении версии 1. Однако для функций, загружаемых динамически, этот макрос необходим.
В функции версии 1 каждый аргумент выбирается макросом PG_GETARG_xxx(), который соответ-
ствует типу данных аргумента. В нестрогих функциях этому вызову должна предшествовать про-
верка на NULL в аргументе с использованием PG_ARGNULL_xxx(). Результат возвращается макро-
сом PG_RETURN_xxx() для возвращаемого типа. PG_GETARG_xxx() принимает в качестве параметра
номер выбираемого аргумента функции (нумерация начинается с 0). PG_RETURN_xxx() принимает
фактическое значение, которое нужно возвратить.
Несколько примеров использования соглашения о вызовах версии 1:
#include
#include
#include
#include
“postgres.h”</li>
</ol>
<string.h>
"fmgr.h"
"utils/geo_decls.h"
PG_MODULE_MAGIC;
/* by value */
PG_FUNCTION_INFO_V1(add_one);
Datum
add_one(PG_FUNCTION_ARGS)
{
int32
arg = PG_GETARG_INT32(0);
PG_RETURN_INT32(arg + 1);
}
/* by reference, fixed length */
PG_FUNCTION_INFO_V1(add_one_float8);
Datum
add_one_float8(PG_FUNCTION_ARGS)
{
/* The macros for FLOAT8 hide its pass-by-reference nature. */
float8
arg = PG_GETARG_FLOAT8(0);
PG_RETURN_FLOAT8(arg + 1.0);
}
PG_FUNCTION_INFO_V1(makepoint);
Datum
makepoint(PG_FUNCTION_ARGS)
{
/* Here, the pass-by-reference nature of Point is not hidden. */
Point
*pointx = PG_GETARG_POINT_P(0);
Point
*pointy = PG_GETARG_POINT_P(1);
Point
*new_point = (Point *) palloc(sizeof(Point));
new_point-&gt;x = pointx-&gt;x;
new_point-&gt;y = pointy-&gt;y;
1021Расширение SQL
PG_RETURN_POINT_P(new_point);
}
/* by reference, variable length */
PG_FUNCTION_INFO_V1(copytext);
Datum
copytext(PG_FUNCTION_ARGS)
{
text
*t = PG_GETARG_TEXT_PP(0);
/*
* VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
* VARHDRSZ or VARHDRSZ_SHORT of its header. Construct the copy with a
* full-length header.
*/
text
*new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
/*
* VARDATA is a pointer to the data region of the new struct. The source
* could be a short datum, so retrieve its data through VARDATA_ANY.
*/
memcpy((void *) VARDATA(new_t), /* destination */
(void *) VARDATA_ANY(t), /* source */
VARSIZE_ANY_EXHDR(t));
/* how many bytes */
PG_RETURN_TEXT_P(new_t);
}
PG_FUNCTION_INFO_V1(concat_text);
Datum
concat_text(PG_FUNCTION_ARGS)
{
text *arg1 = PG_GETARG_TEXT_PP(0);
text *arg2 = PG_GETARG_TEXT_PP(1);
int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
text *new_text = (text *) palloc(new_text_size);
SET_VARSIZE(new_text, new_text_size);
memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
PG_RETURN_TEXT_P(new_text);
}
В предположении, что приведённый выше код был подготовлен в файле funcs.c и скомпилирован
в разделяемый объект, мы можем объявить эти функции в PostgreSQL следующими командами:
CREATE FUNCTION add_one(integer) RETURNS integer
AS 'КАТАЛОГ/funcs', 'add_one'
LANGUAGE C STRICT;
-- обратите внимание — это перегрузка SQL-функции "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
AS 'КАТАЛОГ/funcs', 'add_one_float8'
1022Расширение SQL
LANGUAGE C STRICT;
CREATE FUNCTION makepoint(point, point) RETURNS point
AS 'КАТАЛОГ/funcs', 'makepoint'
LANGUAGE C STRICT;
CREATE FUNCTION copytext(text) RETURNS text
AS 'КАТАЛОГ/funcs', 'copytext'
LANGUAGE C STRICT;
CREATE FUNCTION concat_text(text, text) RETURNS text
AS 'КАТАЛОГ/funcs', 'concat_text'
LANGUAGE C STRICT;
Здесь КАТАЛОГ — это путь к каталогу, в который помещён разделяемый библиотечный файл (на-
пример, каталог учебных материалов (tutorial) в исходном коде PostgreSQL, содержащий код при-
меров, использованных в этом разделе). (Лучше было бы просто написать 'funcs' в предложении
AS, предварительно добавив КАТАЛОГ в путь поиска. В любом случае, мы можем опустить принятое
в системе расширение файлов разделяемых библиотек, обычно .so.)
Заметьте, что мы объявили эти функции как «strict» (строгие) — это означает, что система бу-
дет автоматически подразумевать результат NULL, если в одном из входных значений передаётся
NULL. Благодаря этому, мы избегаем необходимости проверять входные значения на NULL в коде
функции. Без такого объявления нам пришлось бы явно проверять параметры на NULL, используя
PG_ARGISNULL().
На первый взгляд соглашения о вызовах версии 1 могут показаться всего лишь бессмысленным
мракобесием, по сравнению с соглашениями простого C. Однако они позволяют работать с аргу-
ментами и возвращаемыми значениями, в которых может передаваться NULL, а также со значени-
ями в формате TOAST (сжатыми или хранимыми отдельно).
Макрос PG_ARGISNULL(n) позволяет функции проверить на NULL каждый из её аргументов. (Ра-
зумеется, это нужно делать только в функциях, объявленных без характеристики «strict».) Как и
с макросом PG_GETARG_xxx(), входные аргументы нумеруются, начиная с нуля. Заметьте, что не
следует обращаться к макросу PG_GETARG_xxx(), не убедившись, что соответствующий аргумент не
NULL. Чтобы возвратить NULL в качестве результата, воспользуйтесь макросом PG_RETURN_NULL();
это работает и со строгими, и с нестрогими функциями.
Кроме того, в интерфейсе версии 1 появились две вариации макроса PG_GETARG_xxx(). Пер-
вая вариация, PG_GETARG_xxx_COPY(), гарантированно возвращает копию указанного аргумен-
та, которую можно безопасно модифицировать. (Обычный макрос иногда возвращает указатель
на значение, которое физически хранится в таблице, в которую нельзя писать. С макросом
PG_GETARG_xxx_COPY() гарантированно получается результат, доступный для записи.) Вторая ва-
риация представлена макросом PG_GETARG_xxx_SLICE(), принимающим три параметра. В первом
передаётся номер аргумента функции (как и раньше). Во втором и третьем передаётся смещение и
длина сегмента, который должен быть возвращён. Смещение отсчитывается с нуля, а отрицатель-
ная длина указывает, что запрашивается оставшаяся часть значения. Эти макросы дают более эф-
фективный доступ к частям больших значений, имеющим тип хранения «external». (Тип хранения
столбца может задаваться командой ALTER TABLE имя_таблицы ALTER COLUMN имя_столбца SET
STORAGE тип_хранения, где тип_хранения: plain, external, extended или main.)
Наконец соглашения о вызовах версии 1 позволяют возвращать множества (Подраздел 38.10.8) и
реализовывать триггерные функции (Глава 39) и обработчики вызовов процедурных языков (Гла-
ва 56). Дополнительные подробности можно найти в src/backend/utils/fmgr/README в пакете ис-
ходного кода.
38.10.4. Написание кода
Прежде чем перейти к более сложным темам, мы должны обсудить некоторые правила написания
кода функций на языке C для PostgreSQL. Хотя принципиально можно загружать в PostgreSQL
1023Расширение SQL
функции, написанные на языках, отличных от C, обычно это довольно сложно (когда вообще воз-
можно), так как другие языки, например C++, FORTRAN или Pascal часто не следуют соглашени-
ям, принятым в C. То есть другие языки могут передавать аргументы и возвращаемые значения
между функциями разными способами. Поэтому далее предполагается, что ваши функции на язы-
ке C действительно написаны на C.
Основные правила написания и компиляции функций на C таковы:
• Чтобы выяснить, где находятся заголовочные файлы сервера PostgreSQL, установленные в ва-
шей системе (или в системе, с которой будут работать ваши пользователи), воспользуйтесь ко-
мандой pg_config --includedir-server.
• Для компиляции и компоновки кода, который можно будет динамически загрузить в
PostgreSQL, требуется указать специальные флаги. Чтобы конкретнее узнать, как это сделать
в вашей конкретной операционной системе, обратитесь к Подразделу 38.10.5.
• Не забудьте определить «отличительный блок» для вашей разделяемой библиотеки, как опи-
сано в Подразделе 38.10.1.
• Для выделения памяти используйте функцию PostgreSQL palloc, а для освобождения pfree,
вместо соответствующих функций библиотеки C malloc и free. Память, выделяемая функцией
palloc, будет автоматически освобождаться в конце каждой транзакции, во избежание утечек
памяти.
• Всегда обнуляйте байты ваших структур, применяя memset (или сразу выделяйте память функ-
цией palloc0). Даже если вы присвоите значение каждому полю структуры, в ней могут оста-
ваться байты выравнивания (пустоты в структуре), содержащие случайные значения. Если ис-
ключить это требование, будет сложно поддерживать индексы или соединение по хешу, так
как для вычисления хеша придётся выбирать только значащие биты из вашей структуры дан-
ных. Планировщик также иногда полагается на побитовое сравнение констант, так что ре-
зультаты планирования могут оказаться неожиданными, если логически равные значения
окажутся неравными на битовом уровне.
• Большинство внутренних типов PostgreSQL объявлены в postgres.h, тогда как интерфейс ме-
неджера функций (PG_FUNCTION_ARGS и т. д.) определён в fmgr.h, так что потребуется под-
ключить как минимум два этих файла. По соображениям портируемости, лучше включить
postgres.h первым, до каких-либо других системных или пользовательских файлов заго-
ловков. При подключении postgres.h автоматически также будут подключены elog.h и
palloc.h.
• Имена символов, определённые в объектных файлах, не должны конфликтовать друг с другом
или с именами других символов, определённых в исполняемых файлах сервера PostgreSQL.
Если вы столкнётесь с ошибками, вызванными таким конфликтом, вам придётся переимено-
вать ваши функции или переменные.
38.10.5. Компиляция и компоновка динамически загружаемых
функций
Прежде чем вы сможете использовать ваши написанные на C функции, расширяющие возможно-
сти PostgreSQL, их необходимо скомпилировать и скомпоновать особым образом, чтобы сервер мог
динамически загрузить полученный файл. Точнее говоря, вам необходимо создать разделяемую
библиотеку.
За подробной информацией, дополняющей и поясняющей то, что описано в этом разделе, вам сле-
дует обратиться к документации вашей операционной системы, в частности, к страницам руковод-
ства компилятора C, cc, и компоновщика, ld. Кроме того, ряд рабочих примеров можно найти в
каталоге contrib исходного кода PostgreSQL. Однако, если вы непосредственно воспользуйтесь
этими примерами, ваши модули окажутся зависимыми от наличия исходного кода PostgreSQL.
Создание разделяемых библиотек в принципе не отличается от сборки исполняемых файлов: сна-
чала исходные файлы компилируются в объектные, а затем объектные связываются вместе. Объ-
ектные файлы должны создаваться так, чтобы они содержали позиционно-независимый код (PIC,
1024Расширение SQL
position-independent code), что означает, что при загрузке для выполнения этот код может быть по-
мещён в любое место в памяти. (Объектные файлы, предназначенные для сборки непосредствен-
но исполняемых файлов, обычно собираются не так.) Команда для компоновки разделяемой биб-
лиотеки принимает специальные флаги, что отличают её от компоновки исполняемого файла (по
крайней мере в теории — в некоторых системах реальность не так прекрасна).
В следующих примерах предполагается, что исходный код находится в файле foo.c и мы будем
создавать разделяемую библиотеку foo.so. Промежуточный объектный файл будет называться
foo.o, если не отмечено другое. Разделяемая библиотека может включать больше одного объект-
ного файла, но здесь мы ограничимся одним.
FreeBSD
Для создания кода PIC компилятору передаётся флаг -fPIC. Чтобы создать разделяемую биб-
лиотеку, используется флаг компилятора -shared.
gcc -fPIC -c foo.c
gcc -shared -o foo.so foo.o
Это применимо как минимум к FreeBSD версии 3.0.
HP-UX
Для создания кода PIC системному компилятору передаётся флаг +z, а компилятору GCC —
флаг -fPIC. Чтобы создать разделяемые библиотеки, используется флаг компоновщика -b. Та-
ким образом, нужно выполнить:
cc +z -c foo.c
или:
gcc -fPIC -c foo.c
а затем:
ld -b -o foo.sl foo.o
В HP-UX, в отличие от многих других систем, для разделяемых библиотек выбрано расширение
.sl.
Linux
Для создания кода PIC компилятору передаётся флаг -fPIC. Для создания разделяемой биб-
лиотеки компилятору передаётся флаг -shared. Полный пример будет выглядеть так:
cc -fPIC -c foo.c
cc -shared -o foo.so foo.o
macOS
Следующий пример показывает нужные команды, в предположении, что установлены инстру-
менты разработчика.
cc -c foo.c
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o
NetBSD
Для создания кода PIC компилятору передаётся флаг -fPIC. Для компоновки разделяемых биб-
лиотек в системах ELF компилятору передаётся флаг -shared, а в старых системах, не поддер-
живающих ELF, применяется команда ld -Bshareable.
gcc -fPIC -c foo.c
gcc -shared -o foo.so foo.o
OpenBSD
Для создания кода PIC компилятору передаётся флаг -fPIC, а для компоновки разделяемых
библиотек применяется команда ld -Bshareable.
1025Расширение SQL
gcc -fPIC -c foo.c
ld -Bshareable -o foo.so foo.o
Solaris
Для создания кода PIC компилятору Sun передаётся флаг -KPIC, а компилятору GCC — флаг -
fPIC. Для компоновки разделяемой библиотеки можно передать обоим компиляторам флаг -G
либо передать флаг -shared компилятору GCC.
cc -KPIC -c foo.c
cc -G -o foo.so foo.o
или
gcc -fPIC -c foo.c
gcc -G -o foo.so foo.o
Подсказка
Если это слишком сложно для вас, попробуйте использовать средство GNU Libtool, ко-
торое скрывает различия платформ за единым интерфейсом.
Полученную разделяемую библиотеку можно будет затем загрузить в PostgreSQL. Когда команде
CREATE FUNCTION передаётся имя файла, это должно быть имя файла разделяемой библиотеки,
а не промежуточного объектного файла. Заметьте, что принятое в системе расширение файлов
библиотек (как правило, .so или .sl) в команде CREATE FUNCTION можно опустить, и так обычно
следует делать для лучшей портируемости.
Чтобы уточнить, где сервер будет искать файлы разделяемых библиотек, вернитесь к Подразде-
лу 38.10.1.
38.10.6. Аргументы составного типа
Составные типы не имеют фиксированного макета данных, как структуры C. В частности, экзем-
пляры составного типа могут содержать поля NULL. Кроме того, в контексте наследования состав-
ные типы могут иметь разные поля для разных членов в одной иерархии наследования. Поэтому
PostgreSQL предоставляет функциям специальный интерфейс для обращения к полям составных
типов из C.
Предположим, что мы хотим написать функцию, отвечающую на запрос:
SELECT name, c_overpaid(emp, 1500) AS overpaid
FROM emp
WHERE name = 'Bill' OR name = 'Sam';
С соглашениями о вызовах версии 1 мы можем определить функцию c_overpaid так:
#include "postgres.h"
#include "executor/executor.h"
/* for GetAttributeByName() */
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(c_overpaid);
Datum
c_overpaid(PG_FUNCTION_ARGS)
{
HeapTupleHeader t = PG_GETARG_HEAPTUPLEHEADER(0);
int32
limit = PG_GETARG_INT32(1);
bool isnull;
Datum salary;
1026Расширение SQL
salary = GetAttributeByName(t, "salary", &amp;isnull);
if (isnull)
PG_RETURN_BOOL(false);
/* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */
PG_RETURN_BOOL(DatumGetInt32(salary) &gt; limit);
}
GetAttributeByName — это системная функция PostgreSQL, которая возвращает атрибуты указан-
ной строки. Она принимает три параметра: аргумент типа HeapTupleHeader, имя нужного атрибу-
та и выходной параметр, устанавливаемый, если значение атрибута — NULL. GetAttributeByName
возвращает значение Datum, которое вы можете привести к подходящему типу данных, используя
соответствующий макрос DatumGetXXX(). Заметьте, что возвращаемое значение недействительно,
если установлен флаг null; всегда проверяйте этот флаг, прежде чем что-либо делать с результа-
том.
Есть также функция GetAttributeByNum, которая выбирает целевой атрибут не по имени, а по но-
меру столбца.
Следующая команда объявляет функцию c_overpaid в SQL:
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
AS 'КАТАЛОГ/funcs', 'c_overpaid'
LANGUAGE C STRICT;
Заметьте, что мы использовали STRICT, чтобы нам не пришлось проверять входные аргументы на
равенство NULL.
38.10.7. Возврат строк (составных типов)
Чтобы вернуть строку или значение составного типа из функции на языке C, можно использовать
специальный API, предоставляющий макросы и функции, скрывающие основную сложность фор-
мирования составных типов данных. Для использования этого API необходимо включить в исход-
ный файл:
#include "funcapi.h"
Сформировать значение составного типа (далее «кортеж») можно двумя способами: его можно
построить из массива значений Datum, или из массива строк C, которые будут переданы функциям
преобразования ввода для типов столбцов кортежа. В любом случае, сначала нужно получить или
сконструировать дескриптор TupleDesc для структуры кортежа. Работая со значениями Datum,
вы передаёте TupleDesc функции BlessTupleDesc, а затем вызываете heap_form_tuple для каждой
строки. Работая со строками C, вы передаёте TupleDesc функции TupleDescGetAttInMetadata, а
затем для каждой строки вызываете BuildTupleFromCStrings. В случае функции, возвращающей
множество кортежей, все подготовительные действия можно выполнить один раз при первом вы-
зове функции.
Для получения требуемого дескриптора TupleDesc предлагается несколько дополнительных функ-
ций. Рекомендованный способ возврата составных значений заключается в вызове функции:
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
Oid *resultTypeId,
TupleDesc *resultTupleDesc)
При этом в fcinfo должна передаваться та же структура, что была передана самой вызываю-
щей функции. (Для этого, конечно, необходимо использовать соглашения о вызовах версии 1.) В
resultTypeId можно передать NULL или адрес локальной переменной, в которую будет записан
OID типа результата функции. В resultTupleDesc должен передаваться адрес локальной перемен-
ной TupleDesc. Убедить, что функция возвратила результат TYPEFUNC_COMPOSITE; в этом случае, в
resultTupleDesc оказывается требуемая структура TupleDesc. (Если получен другой результат, вы
1027Расширение SQL
можете выдать ошибку с сообщением «функция, возвращающая запись, вызвана в контексте, не
допускающем этот тип».)
Подсказка
get_call_result_type позволяет получить фактический тип результата полиморфной
функции, так что она полезна и в функциях, возвращающих скалярные полиморфные
результаты, не только в функциях, возвращающих составные типы. Выходной параметр
resultTypeId полезен в первую очередь для полиморфных скалярных функций.
Примечание
В дополнение к get_call_result_type есть схожая функция get_expr_result_type,
позволяющая получить ожидаемый тип результата для вызова функции, представлен-
ного деревом выражения. Её можно использовать, когда тип результата нужно опреде-
лить извне самой функции. Есть также функция get_func_result_type, которую мож-
но применять, когда известен только OID функции. Однако эти две функции неспособ-
ны выдать тип результата функций, возвращающих record, а get_func_result_type
неспособна разрешать полиморфные типы, так что вместо них лучше использовать
get_call_result_type.
Ранее для получения TupleDesc использовались теперь уже устаревшие функции:
TupleDesc RelationNameGetTupleDesc(const char *relname)
(возвращает TupleDesc для типа строк указанного отношения) и:
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
(возвращает TupleDesc для типа, задаваемого по OID). Применяя её, можно получить TupleDesc
для базового или составного типа. Однако она не подойдёт для функции, возвращающей тип
record, и не сможет разрешить полиморфные типы.
Получив TupleDesc, вызовите:
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
если вы планируете работать со структурами Datum, либо:
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
если планируете работать со строками C. Если вы разрабатываете функцию, возвращающую на-
бор данных, вы можете сохранить результаты этих функций в структуре FuncCallContext, в поле
tuple_desc или attinmeta, соответственно.
Если вы работаете со структурами Datum, воспользуйтесь функцией:
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
Она формирует HeapTuple из переданных ей данных в форме Datum.
Если вы работаете со строками C, воспользуйтесь функцией:
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
Она формирует HeapTuple из переданных ей данных в виде строк C. В параметре values ей переда-
ётся массив строк C, по одной для каждого атрибута выходной строки. Каждая из этих строк долж-
на иметь формат, принимаемый функцией ввода типа данных атрибута. Чтобы задать значение
NULL для одного из этих атрибутов, вместо соответствующего указателя в массиве values нужно
передать NULL. Эту функцию нужно вызывать для каждой строки, которую вы будете возвращать.
Получив кортеж, который вы будете возвращать из вашей функции, вы должны преобразовать его
в тип Datum. Чтобы преобразовать HeapTuple в Datum, воспользуйтесь функцией:
1028Расширение SQL
HeapTupleGetDatum(HeapTuple tuple)
Полученный тип Datum можно вернуть непосредственно, если должна возвращаться только одна
строка, либо использовать как текущее выдаваемое значение в функции, возвращающей набор
строк.
Пример приведён в следующем разделе.
38.10.8. Возврат множеств
Есть также специальный интерфейс, который позволяет функциям на C возвращать множества
(несколько строк). Функции, возвращающие множества, должны следовать соглашению о вызовах
версии 1. Кроме того, соответствующие исходные файлы должны включать funcapi.h, как пока-
зано выше.
Функция, возвращающая множество (SRF, Set-Returning Function), вызывается каждый раз для оче-
редной записи. Таким образом, SRF должна сохранять достаточно информации о состоянии, что-
бы понимать, что она делает, и выдать очередную запись при следующем вызове. Для облегче-
ния управления этим процессом представлена структура FuncCallContext. Для кода функции ука-
затель на эту структуру FuncCallContext сохраняется между вызовами в поле fcinfo-&gt;flinfo-
&gt;fn_extra.
typedef struct FuncCallContext
{
/*
* Счётчик числа ранее выполненных вызовов
*
* call_cntr сбрасывается в 0 макросом SRF_FIRSTCALL_INIT() и
* увеличивается на 1 каждый раз, когда вызывается SRF_RETURN_NEXT().
*/
uint64 call_cntr;
/*
* Максимальное число вызовов (может не использоваться)
*
* max_calls не является обязательным и присутствует здесь только для удобства.
* Если это значение не задано, вы должны предоставить другую возможность
определить,
* когда функция завершила свою работу.
*/
uint64 max_calls;
/*
* Указатель на слот результата (может не использоваться)
*
* Это поле устарело и представлено только для обратной совместимости, а именно,
* для пользовательских SRF, использующих устаревшую TupleDescGetSlot().
*/
TupleTableSlot *slot;
/*
* Указатель на разнообразную контекстную информацию,
* представленную пользователем; (может не использоваться)
*
* user_fctx используется как указатель на ваши собственные данные,
* позволяющий сохранить контекстную информацию между вызовами функции.
*/
void *user_fctx;
1029Расширение SQL
/*
* Указатель на структуру, содержащую метаданные ввода типа атрибута
* (может не использоваться)
*
* attinmeta задействуется, когда возвращаются кортежи (т. е. составные типы
данных),
* и не применяется для возврата базовых типов. Он нужен, только если
* вы планируете использовать BuildTupleFromCStrings() для формирования
возвращаемого
* кортежа.
*/
AttInMetadata *attinmeta;
/*
* Контекст памяти, нужный для структур, которые должны сохраняться при нескольких
вызовах
*
* Поле multi_call_memory_ctx заполняется в SRF_FIRSTCALL_INIT() и используется
* в SRF_RETURN_DONE() для очистки. Это наиболее подходящий контекст
* для любых блоков памяти, которые должны многократно использоваться при
* повторных вызовах SRF.
*/
MemoryContext multi_call_memory_ctx;
/*
* Указатель на структуру, содержащую описание кортежа (может не использоваться)
*
* tuple_desc задействуется, когда возвращаются кортежи (т. е. составные типы),
* и нужен только, если вы планируете формировать кортежи с помощью функции
* heap_form_tuple(), а не BuildTupleFromCStrings(). Заметьте, что сохраняемый
* здесь указатель TupleDesc обычно должен сначала пройти через вызов
* BlessTupleDesc().
*/
TupleDesc tuple_desc;
} FuncCallContext;
В SRF применяются различные функции и макросы, автоматически манипулирующие структурой
FuncCallContext (они обращаются к ней через fn_extra). В частности, чтобы определить, была ли
функция вызвана в первый или последующий раз, используйте:
SRF_IS_FIRSTCALL()
Чтобы инициализировать FuncCallContext при первом вызове (и только), используйте:
SRF_FIRSTCALL_INIT()
Чтобы подготовиться к использованию FuncCallContext и очистить все ранее возвращённые дан-
ные, оставшиеся после предыдущего прохода, при каждом вызове функции, в том числе, первом,
выполните:
SRF_PERCALL_SETUP()
Если у вашей функции есть данные, которые нужно возвратить, выполните:
SRF_RETURN_NEXT(funcctx, result)
для того, чтобы выдать их вызывающему. (Переменная result должна быть типа Datum, либо одним
значением, либо кортежем, подготовленным как описано выше.) Наконец, когда ваша функция
закончила возвращать данные, выполните:
SRF_RETURN_DONE(funcctx)
1030Расширение SQL
для того, чтобы провести очистку и завершить SRF.
Контекст памяти, в котором вызывается SRF, временный, он будет очищаться между вызовами.
Это значит, что вам не нужно вызывать pfree для всех блоков памяти, которые вы получили через
palloc; они всё равно будут освобождены. Однако, если вы хотите выделить структуры данных и
сохранить их между вызовами, вам нужно разместить их где-то в другом месте. Для размещения
таких данных, которые не должны уничтожаться, пока SRF не закончит работу, подходит контекст
памяти, на который указывает multi_call_memory_ctx. В большинстве случаев это означает, что
вы должны переключиться в контекст multi_call_memory_ctx в коде подготовки при первом вы-
зове.
Предупреждение
Тогда как фактические аргументы такой функции не меняются от вызова к вызову,
если вы распаковываете значения аргументов (что обычно прозрачно делают мак-
росы PG_GETARG_xxx) во временном контексте, распакованные копии будут освобож-
даться при каждом вызове. Соответственно, если вы сохраните ссылки на такие зна-
чения в своём контексте user_fctx, вы должны либо скопировать эти значения в
multi_call_memory_ctx после распаковки, либо распаковывать значения только в этом
контексте.
Полный пример с псевдокодом будет выглядеть так:
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
FuncCallContext *funcctx;
Datum
result;
другие необходимые объявления
if (SRF_IS_FIRSTCALL())
{
MemoryContext oldcontext;
funcctx = SRF_FIRSTCALL_INIT();
oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
/* Здесь размещается код подготовки при первом вызове: */
некоторый код
если возвращается составной тип
получить TupleDesc и, возможно, AttInMetadata
конец ветвления для составного типа
некоторый код
MemoryContextSwitchTo(oldcontext);
}
/* Здесь размещается код подготовки для каждого вызова: */
некоторый код
funcctx = SRF_PERCALL_SETUP();
некоторый код
/* это только один способ определить, не пора ли закончить работу: */
if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
{
/* Здесь мы хотим вернуть следующий результат: */
некоторый код
получить результирующий Datum
SRF_RETURN_NEXT(funcctx, result);
1031Расширение SQL
}
else
{
/* Здесь мы заканчиваем выдавать результаты и нам нужно провести очистку: */
некоторый код
SRF_RETURN_DONE(funcctx);
}
}
Полный пример простой SRF-функции, возвращающей составной тип, выглядит так:
PG_FUNCTION_INFO_V1(retcomposite);
Datum
retcomposite(PG_FUNCTION_ARGS)
{
FuncCallContext
*funcctx;
int
call_cntr;
int
max_calls;
TupleDesc
tupdesc;
AttInMetadata
*attinmeta;
/* stuff done only on the first call of the function */
if (SRF_IS_FIRSTCALL())
{
MemoryContext
oldcontext;
/* create a function context for cross-call persistence */
funcctx = SRF_FIRSTCALL_INIT();
/* switch to memory context appropriate for multiple function calls */
oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
/* total number of tuples to be returned */
funcctx-&gt;max_calls = PG_GETARG_UINT32(0);
/* Build a tuple descriptor for our result type */
if (get_call_result_type(fcinfo, NULL, &amp;tupdesc) != TYPEFUNC_COMPOSITE)
ereport(ERROR,
(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
errmsg("function returning record called in context "
"that cannot accept type record")));
/*
* generate attribute metadata needed later to produce tuples from raw
* C strings
*/
attinmeta = TupleDescGetAttInMetadata(tupdesc);
funcctx-&gt;attinmeta = attinmeta;
MemoryContextSwitchTo(oldcontext);
}
/* stuff done on every call of the function */
funcctx = SRF_PERCALL_SETUP();
call_cntr = funcctx-&gt;call_cntr;
max_calls = funcctx-&gt;max_calls;
attinmeta = funcctx-&gt;attinmeta;
1032Расширение SQL
if (call_cntr &lt; max_calls)
{
char
**values;
HeapTuple
tuple;
Datum
result;
/* do when there is more left to send */
/*
* Prepare a values array for building the returned tuple.
* This should be an array of C strings which will
* be processed later by the type input functions.
*/
values = (char **) palloc(3 * sizeof(char *));
values[0] = (char *) palloc(16 * sizeof(char));
values[1] = (char *) palloc(16 * sizeof(char));
values[2] = (char *) palloc(16 * sizeof(char));
snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));
/* build a tuple */
tuple = BuildTupleFromCStrings(attinmeta, values);
/* make the tuple into a datum */
result = HeapTupleGetDatum(tuple);
/* clean up (this is not really necessary) */
pfree(values[0]);
pfree(values[1]);
pfree(values[2]);
pfree(values);
SRF_RETURN_NEXT(funcctx, result);
}
else
{
/* do when there is no more left */
SRF_RETURN_DONE(funcctx);
}
}
В SQL её можно объявить следующим образом:
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);
CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
RETURNS SETOF __retcomposite
AS 'имя_файла', 'retcomposite'
LANGUAGE C IMMUTABLE STRICT;
Также её можно объявить с параметрами OUT:
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
OUT f1 integer, OUT f2 integer, OUT f3 integer)
RETURNS SETOF record
AS 'имя_файла', 'retcomposite'
LANGUAGE C IMMUTABLE STRICT;
Заметьте, что при таком подходе выходным типом функции формально является анонимный тип
record.
1033Расширение SQL
Каталог contrib/tablefunc в пакете исходного кода содержит дополнительные примеры функций,
возвращающих множества.
38.10.9. Полиморфные типы аргументов и результата
Функции на языке C могут быть объявлены как принимающие и возвращающие полиморфные
типы anyelement, anyarray, anynonarray, anyenum и anyrange. За более подробным объяснени-
ем полиморфных функций обратитесь к Подразделу  38.2.5. Когда типы аргументов или резуль-
тат определены как полиморфные, автор функции не может заранее знать, с какими типами
данных она будет вызываться и какой возвращать. Чтобы функция на C в стиле версии 1 мог-
ла определить фактические типы данных своих аргументов и тип, который она должна вернуть,
в fmgr.h предлагаются две функции. Они называются get_fn_expr_rettype(FmgrInfo *flinfo)
и get_fn_expr_argtype(FmgrInfo *flinfo, int argnum) и возвращают соответственно OID ти-
па результата и аргумента, либо InvalidOid, если информация о типе отсутствует. Структуру
flinfo обычно можно получить по ссылке fcinfo-&gt;flinfo. Номер аргумента argnum задаётся, на-
чиная с нуля. В качестве альтернативы get_fn_expr_rettype также можно использовать функ-
ции get_call_result_type. Кроме того, есть функция get_fn_expr_variadic, позволяющая опре-
делить, были ли переменные аргументы объединены в массив. Это полезно в основном для функ-
ций VARIADIC "any", так как такое объединение всегда имеет место для функций с переменными
аргументами, принимающих обычные типы.
Например, предположим, что нам нужно написать функцию, принимающую один элемент любого
типа и возвращающую одномерный массив этого типа:
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
ArrayType *result;
Oid
element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
Datum
element;
bool
isnull;
int16
typlen;
bool
typbyval;
char
typalign;
int
ndims;
int
dims[MAXDIM];
int
lbs[MAXDIM];
if (!OidIsValid(element_type))
elog(ERROR, "could not determine data type of input");
/* получить переданный элемент, учитывая, что это может быть NULL */
isnull = PG_ARGISNULL(0);
if (isnull)
element = (Datum) 0;
else
element = PG_GETARG_DATUM(0);
/* мы имеем дело с одной размерностью */
ndims = 1;
/* и одним элементом */
dims[0] = 1;
/* с нижней границей, равной 1 */
lbs[0] = 1;
/* получить требуемую информацию о типе элемента */
get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);
1034Расширение SQL
/* теперь создать массив */
result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
element_type, typlen, typbyval, typalign);
PG_RETURN_ARRAYTYPE_P(result);
}
Следующая команда объявляет функцию make_array в SQL:
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
AS 'КАТАЛОГ/funcs', 'make_array'
LANGUAGE C IMMUTABLE;
Существует один вариант полиморфизма, которым могут пользоваться только функции на языке
C: их можно объявить с параметрами типа "any". (Заметьте, что имя этого типа нужно заключать
в двойные кавычки, так как это также зарезервированное слово в SQL.) Он работает так же, как
anyelement, за исключением того, что он не требует, чтобы аргументы "any" имели одинаковый
тип, и не помогает определить тип результата функции. Функцию на языке C можно также объ-
явить с последним параметром VARIADIC "any". Ему будут соответствовать один или более факти-
ческих аргументов любого типа (не обязательно одинакового). Эти аргументы не будут собираться
в массив, как это происходит с обычными функциями с переменными аргументами; они просто бу-
дут переданы функции по отдельности. Если применяется этот вариант, то чтобы определить число
фактических аргументов и их типы, нужно использовать макрос PG_NARGS() и функции, описанные
выше. Пользователи такой функции также могут пожелать использовать ключевое слово VARIADIC
в вызове функции, ожидая, что функция обработает элементы массива как отдельные аргументы.
При необходимости соответствующее поведение должна реализовывать сама функция, определив
с помощью get_fn_expr_variadic, был ли фактический аргумент передан с указанием VARIADIC.
38.10.10. Функции преобразования
Некоторые вызовы функций можно упростить на стадии планирования, в зависимости от особых
свойств функции. Например, функцию умножения (int4mul(n, 1)) можно упростить просто до n.
Чтобы определить такую оптимизацию, нужно написать функцию преобразования и поместить её
OID в поле protransform записи основной функции в pg_proc. Функция преобразования должна
иметь в SQL сигнатуру protransform(internal) RETURNS internal. В аргументе, фактически име-
ющем тип FuncExpr *, передаётся фиктивный узел, представляющий вызов основной функции. Ес-
ли анализ дерева выражения в функции преобразования показывает, что вместо всех возможных
конкретных вызовов может быть подставлено дерево упрощённого выражения, эта функция долж-
на построить и вернуть это упрощённое выражение. В противном случае нужно вернуть указатель
NULL (не NULL языка SQL).
Мы не гарантируем, что PostgreSQL никогда не будет вызывать основную функцию во всех случаях,
когда функция преобразования может её упростить, поэтому важно, чтобы упрощённое выражение
строго соответствовало реальному вызову основной функции.
В настоящее время эта функциональность не предоставляется пользователям на уровне SQL из
соображений безопасности, так что на практике это можно использовать только для оптимизации
встроенных функций.
38.10.11. Разделяемая память и лёгкие блокировки
Модули расширений могут резервировать лёгкие блокировки и область в разделяемой памяти при
запуске сервера. Чтобы библиотека модуля предварительно загружалась на этапе запуска сервера,
нужно указать её в shared_preload_libraries. Чтобы зарезервировать разделяемую память, вызовите
из вашей функции _PG_init функцию:
void RequestAddinShmemSpace(int size)
Чтобы зарезервировать лёгкие блокировки, из _PG_init нужно вызвать:
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
1035Расширение SQL
В результате будет сформирован массив из num_lwlocks лёгких блокировок под име-
нем tranche_name. Чтобы получить указатель на этот массив, воспользуйтесь функцией
GetNamedLWLockTranche.
Во избежание возможных условий гонки каждый обслуживающий процесс должен вызывать
AddinShmemInitLock в момент подключения и при инициализации разделяемой памяти, как пока-
зано здесь:
static mystruct *ptr = NULL;
if (!ptr)
{
bool
*/
found;
LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
ptr = ShmemInitStruct("my struct name", size, &amp;found);
if (!found)
{
/* инициализировать содержимое области разделяемой памяти; */
/* получить все требуемые блокировки LWLocks:
ptr-&gt;locks = GetNamedLWLockTranche("my tranche name");
}
LWLockRelease(AddinShmemInitLock);
}
38.10.12. Использование C++ для расширяемости
Хотя код сервера PostgreSQL написан на C, расширения для него можно писать и на C++, если
соблюдать эти правила:
• Все функции, к которым будет обращаться сервер, должны предоставлять ему интерфейс C;
эти функции на C затем могут вызывать функции на языке C++. В частности, для функций,
доступных серверу, необходимо указать extern C. Это также необходимо для всех функций,
указатели на которые передаются между кодом сервера и подключаемым кодом на C++.
• Освобождайте память, применяя для этого подходящий метод. Например, память сервера в
основном выделяется функцией palloc(), так что освобождать её нужно, вызывая pfree().
Попытка использовать в таких случаях принятую в C++ операцию delete приведёт к ошибке.
• Не допускайте распространения исключений в код C (добавляйте блок, перехватывающий все
исключения, на верхнем уровне функций extern C). Это необходимо, даже если код на C++
не генерирует исключения явно, потому что исключения могут возникать, например, и при
нехватке памяти. Все исключения должны перехватываться, и в интерфейс C должны переда-
ваться соответствующие ошибки. Если возможно, скомпилируйте код C++ с указанием -fno-
exceptions, чтобы полностью отключить исключения; в таких случаях вы должны будете вы-
являть исключительные ситуации в коде C++, например, проверять на NULL адрес, возвра-
щённый new().
• Вызывая серверные функции из кода C++, убедитесь, что в стеке вызова C++ содержатся
только простые структуры данных. Это необходимо, потому что в случае ошибки сервера вы-
полняется функция longjmp(), а она не отматывает стек вызовов C++ должным образом для
объектов, отличных от простых структур.
Резюмируя, лучше всего поместить код C++ за ограду из функций extern C, которые будут до-
ступны серверу и смогут защитить от исключений, а также потери стека вызовов и утечки памяти.
38.11. Пользовательские агрегатные функции
Агрегатные функции в PostgreSQL определяются в терминах значений состояния и функций пе-
рехода состояния. То есть агрегатная функция работает со значением состояния, которое меня-
ется при обработке каждой последующей строки. Чтобы определить агрегатную функцию, нужно
1036Расширение SQL
выбрать тип данных для значения состояния, начальное значение состояния и функцию перехода
состояния. Функция перехода состояния принимает предыдущее значение состояния и входное
агрегируемое значение для текущей строки и возвращает новое значение состояния. Также мож-
но указать функцию завершения, на случай, если ожидаемый результат агрегатной функции от-
личается от данных, которые сохраняются в изменяющемся значении состояния. Функция завер-
шения принимает конечное значение состояния и возвращает то, что она хочет вернуть в виде ре-
зультата агрегирования. В принципе, функции перехода и завершения представляют собой просто
обычные функции, которые также могут применяться вне контекста агрегирования. (На практике
для большей производительности часто создаются специализированные функции перехода, кото-
рые работают, только когда вызываются при агрегировании.)
Таким образом, помимо типов данных аргументов и результата, с которыми имеет дело пользо-
ватель агрегатной функции, есть также тип данных внутреннего состояния, который может отли-
чаться от этих типов.
Если мы определяем агрегат, не использующий функцию завершения, наш агрегат будет вычис-
лять бегущее значение функции по столбцам каждой строки. Примером такой агрегатной функ-
ции является sum. Вычисление sum начинается с нуля, а затем к накапливаемой сумме всегда при-
бавляется значение из текущей строки. Например, если мы хотим сделать агрегатную функцию
sum для комплексных чисел, нам потребуется только функция сложения для такого типа данных.
Такая агрегатная функция может быть определена так:
CREATE AGGREGATE sum (complex)
(
sfunc = complex_add,
stype = complex,
initcond = '(0,0)'
);
Использовать её можно будет так:
SELECT sum(a) FROM test_complex;
sum
-----------
(34,53.9)
(Заметьте, что мы задействуем перегрузку функций: в системе есть несколько агрегатных функций
с именем sum, но PostgreSQL может определить, какая именно из них применима к столбцу типа
complex.)
Определённая выше функция sum вернёт ноль (начальное значение состояния), если в наборе дан-
ных не окажется значений, отличных от NULL. У нас может возникнуть желание вернуть NULL
в этом случае — стандарт SQL требует, чтобы sum работала так. Мы можем добиться этого, про-
сто опустив фразу initcond, так что начальным значением состояния будет NULL. Обычно это
будет означать, что в sfunc придётся проверять входное значение состояния на NULL. Но для sum
и некоторых других простых агрегатных функций, как max и min, достаточно вставить в перемен-
ную состояния первое входное значение не NULL, а затем начать применять функцию перехода со
следующего значения не NULL. PostgreSQL сделает это автоматически, если начальное значение
состояние равно NULL и функция перехода помечена как «strict» (то есть не должна вызываться
для аргументов NULL).
Ещё одна особенность поведения по умолчанию «строгой» функции перехода — предыдущее зна-
чение состояния остаётся без изменений, когда встречается значение NULL. Другими словами,
значения NULL игнорируются. Если вам нужно другое поведение для входных значений NULL, не
объявляйте свою функцию перехода строгой (strict); вместо этого, проверьте в ней поступающие
значения на NULL и обработайте их, как требуется.
Функция avg (вычисляющая среднее арифметическое) представляет собой более сложный пример
агрегатной функции. Ей необходимы два компонента текущего состояния: сумма входных значе-
ний и их количество. Окончательный результат получается как частное этих величин. При реали-
1037Расширение SQL
зации этой функции для значения состояния обычно используется массив. Например, встроенная
реализация avg(float8) выглядит так:
CREATE AGGREGATE avg (float8)
(
sfunc = float8_accum,
stype = float8[],
finalfunc = float8_avg,
initcond = '{0,0,0}'
);
Примечание
Функция float8_accum принимает массив из трёх, а не двух элементов, так как в до-
полнение к количеству и сумме значений она подсчитывает ещё сумму их квадратов.
Это сделано для того, чтобы её можно было применять для avg и для некоторых других
агрегатных функций.
Вызовы агрегатных функций SQL допускают указания DISTINCT и ORDER BY, которые определяют,
какие строки и в каком порядке будут поступать в функцию перехода агрегата. Это реализовано
на заднем плане и непосредственно не затрагивает функции, поддерживающие работу агрегата.
За дополнительными подробностями обратитесь к описанию CREATE AGGREGATE.
38.11.1. Режим движущегося агрегата
Агрегатные функции могут дополнительно поддерживать режим движущегося агрегата, который
позволяет значительно быстрее выполнять агрегатные функции в окнах со сдвигающимся нача-
лом рамки. (За информацией об использовании агрегатных функций в качестве оконных обрати-
тесь к Разделу 3.5 и Подразделу 4.2.8.) Основная идея состоит в том, что помимо добавления обыч-
ной функции перехода «вперёд», для агрегатной функции задаётся функция обратного перехода,
которая позволяет убирать строки из накапливаемого значения состояния, когда они покидают
рамку окна. Например, для sum в качестве функции прямого перехода выполняется сложение, а в
качестве функции обратного перехода выполняется вычитание. Без функции обратного перехода
механизм оконных функций вынужден вычислять агрегат заново при каждом перемещении нача-
ла рамки, в результате чего время обработки оказывается пропорциональным количеству входных
строк, помноженному на средний размер рамки. С функцией обратного перехода это время про-
порционально только количеству входных строк.
Функции обратного перехода передаётся текущее значение состояния и агрегируемое входное зна-
чение(я) для строки, ранее учтённой в текущем состоянии. Она должна восстановить то значение
состояния, которое было бы получено, если бы эта строка не агрегировалась, но агрегировались
все последующие. Иногда для этого нужно, чтобы функция обратного перехода сохраняла боль-
ше информации о состоянии, чем это требуется для простого режима агрегирования. Таким обра-
зом, для режима движущегося агрегата используется реализация, отличная от простого режима:
для него определяется отдельный тип данных, отдельная функция прямого перехода и отдельная
функция завершения, при необходимости. Они могут совпадать с типом данных и аналогичными
функциями обычного режима, если в дополнительном состоянии необходимости нет.
В качестве примера мы можем доработать показанную выше агрегатную функцию sum, чтобы она
поддерживала режим движущегося агрегата так:
CREATE AGGREGATE sum (complex)
(
sfunc = complex_add,
stype = complex,
initcond = '(0,0)',
msfunc = complex_add,
minvfunc = complex_sub,
mstype = complex,
1038Расширение SQL
minitcond = '(0,0)'
);
Параметры, имена которых начинаются с m, определяют реализацию для движущегося агрегата.
За исключением функции обратного перехода, minvfunc, они соответствуют параметрам обычного
агрегата без m.
Функции прямого перехода в режиме движущегося агрегата не разрешено возвращать NULL в ка-
честве нового значения состояния. Если функция обратного перехода возвращает NULL, это вос-
принимается как признак того, что она не может восстановить предыдущее состояние для полу-
ченных данных, и значит, агрегатное вычисление нужно производить заново с текущей позиции
начала рамки. Это соглашение позволяет применять режим движущегося агрегата и в ситуациях,
когда прокручивать назад значение состояния непрактично. Функция обратного перехода может
«спасовать» в таких случаях, но включаться в работу, насколько это возможно в большинстве слу-
чаев. Например, агрегатная функция, работающая с числами с плавающей точкой, может спасо-
вать, когда от неё потребуется убрать значение NaN (не число, not a number) из текущего значения
состояния.
Разрабатывая функции, реализующие режим движущегося агрегата, важно, чтобы функция обрат-
ного перехода могла восстановить в точности требуемое значение состояния. В противном случае,
в результатах могут проявляться различия, в зависимости от того, использовался ли режим дви-
жущегося агрегата. Например, на первый взгляд может показаться, что легко добавить функцию
обратного перехода для сложения, но заявленное требование не будет выполняться для sum с ти-
пом float4 или float8. Наивное объявление sum(float8) может быть таким:
CREATE AGGREGATE unsafe_sum (float8)
(
stype = float8,
sfunc = float8pl,
mstype = float8,
msfunc = float8pl,
minvfunc = float8mi
);
Однако такой агрегат может выдавать результаты, радикально отличающиеся от тех, что он выда-
вал бы без функции обратного перехода. Например, рассмотрите запрос
SELECT
unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
(2, 1.0::float8)) AS v (n,x);
Он возвращает 0 в качестве второго результата, а не ожидаемое значение 1. Это связано с огра-
ниченной точностью значений с плавающей точкой: при добавлении 1 к 1e20 снова получается
1e20, а при вычитании 1e20 из результата получается 0, а не 1. Заметьте, что это принципиальное
ограничение арифметики чисел с плавающей точкой, а не недостаток PostgreSQL.
38.11.2. Агрегатные функции с полиморфными и переменными
аргументами
Агрегатная функция может использовать полиморфные функции перехода состояния или функции
завершения, так что эти функции могут применяться для реализации нескольких агрегатов. За
объяснением полиморфных функций обратитесь к Подразделу 38.2.5. Более того, сама агрегатная
функция может описываться с полиморфными типами входных данных и состояния, так что одно
определение агрегатной функции может служить для использования с разными типами данных.
Пример полиморфного агрегата:
CREATE AGGREGATE array_accum (anyelement)
(
sfunc = array_append,
stype = anyarray,
initcond = '{}'
1039Расширение SQL
);
Здесь фактическим типом состояния для любого конкретного агрегатного вызова будет массив,
элементы которого будут иметь тип входных данных. Действие данного агрегата заключается в
накоплении всех входных значений в массиве этого типа. (К вашему сведению: встроенная агре-
гатная функция array_agg обеспечивает подобную функциональность, но работает быстрее, чем
могла бы функция с приведённым определением.)
Так будут выглядеть результаты с аргументами двух различных типов:
SELECT attrelid::regclass, array_accum(attname)
FROM pg_attribute
WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
GROUP BY attrelid;
attrelid
|
array_accum
---------------+---------------------------------------
pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)
SELECT attrelid::regclass, array_accum(atttypid::regtype)
FROM pg_attribute
WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
GROUP BY attrelid;
attrelid
|
array_accum
---------------+---------------------------
pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)
Обычно агрегатная функция с полиморфным типом результата имеет и полиморфный тип состоя-
ния, как в предыдущем примере. Это необходимо, так как иначе нельзя будет объявить функцию
завершения: она должна будет иметь полиморфный тип результата, но не будет иметь полиморф-
ного аргумента, что команда CREATE FUNCTION не примет на основании того, что тип результата
нельзя будет определить при вызове. Но иметь полиморфный тип состояния не всегда удобно. Ча-
ще всего эта проблема возникает, когда функции реализации агрегата пишутся на C и тип состоя-
ния должен объявляться как internal, так как для него нет соответствующего типа на уровне SQL.
Чтобы решить эту проблему, можно объявить функцию завершения как принимающую дополни-
тельные фиктивные аргументы, соответствующие входным аргументам агрегата. В этих фиктив-
ных аргументах всегда передаются значения NULL, так как при вызове функции завершения ка-
кое-либо определённое значение отсутствует. Единственное их предназначение — позволить свя-
зать тип результата полиморфной функции завершения с типом входных данных агрегата. Напри-
мер, определение встроенного агрегата array_agg выглядит так:
CREATE FUNCTION array_agg_transfn(internal, anynonarray)
RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anynonarray)
RETURNS anyarray ...;
CREATE AGGREGATE array_agg (anynonarray)
(
sfunc = array_agg_transfn,
stype = internal,
finalfunc = array_agg_finalfn,
finalfunc_extra
);
Здесь параметр finalfunc_extra указывает, что функция завершения помимо значения состояния
получит дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата.
Дополнительный аргумент anynonarray позволяет сделать объявление array_agg_finalfn допу-
стимым.
1040Расширение SQL
Агрегатную функцию можно сделать принимающей переменное число аргументов, объявив её по-
следний аргумент как массив VARIADIC, в том же ключе, как и обычную функцию; см. Подраз-
дел 38.5.5. При этом у функций перехода агрегата их последний аргумент должен иметь тот же
тип массива. Такие функции обычно также объявляются как VARIADIC, но строго это не требуется.
Примечание
Агрегатные функции с переменными аргументами легко допускают ошибочное исполь-
зование в сочетании с указанием ORDER BY (см. Подраздел 4.2.7), так как анализатор
запроса не может определить, было ли передано нужное количество фактических па-
раметров в такой комбинации. Помните, что всё, находящееся справа от ORDER BY, яв-
ляется ключом сортировки, а не аргументом агрегатной функции. Например, в
SELECT myaggregate(a ORDER BY a, b, c) FROM ...
анализатор запроса увидит один агрегатный аргумент функции и три ключа сортиров-
ки. Однако пользователь мог подразумевать и следующее:
SELECT myaggregate(a, b, c ORDER BY a) FROM ...
Если функция myaggregate принимает переменные аргументы, оба эти вызова будут
вполне допустимы.
По этой же причине, стоит подумать дважды, прежде чем создавать агрегатные функ-
ции с одинаковыми именами, но разным числом обычных аргументов.
38.11.3. Сортирующие агрегатные функции
Описанные выше агрегатные функции были «обычными» агрегатами. Но PostgreSQL также под-
держивает сортирующие агрегатные функции, которые имеют два отличия от обычных. Во-пер-
вых, в дополнение к обычным агрегируемым аргументам, вычисляемых для каждой входной стро-
ки, сортирующий агрегат может иметь «непосредственные» аргументы, которые должны вычис-
ляться в операции агрегирования только один раз. Во-вторых, для обычных агрегируемых аргу-
ментов порядок их сортировки задаётся явно, а сортирующий агрегат обычно выполняет вычисле-
ния, зависящие от конкретного порядка строк, например, вычисляет ранг или процентиль, так что
порядок сортировки критичен для каждого вызова. Например, встроенное определение функции
percentile_disc равнозначно следующему:
CREATE FUNCTION ordered_set_transition(internal, anyelement)
RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
RETURNS anyelement ...;
CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
sfunc = ordered_set_transition,
stype = internal,
finalfunc = percentile_disc_final,
finalfunc_extra
);
Этот агрегат принимает непосредственный аргумент float8 (дробь процентиля) и агрегируемые
данные, которые могут быть любого упорядочиваемого типа. Используя его, можно рассчитать
средний семейный доход следующим образом:
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
percentile_disc
-----------------
50489
В данном случае, 0.5 — это непосредственный аргумент; если бы дробь процентиля менялась от
строки к строке, это не имело бы смысла.
1041Расширение SQL
В отличие от случая с обычными агрегатами, сортировка входных строк для сортирующего агрега-
та не выполняется на заднем плане, а является задачей функций, реализующих агрегат. Типичная
реализация такого агрегата заключается в сохранении ссылки на объект «tuplesort» в значении
состояния агрегата, загрузке поступающих строк в этот объект, и собственно окончании сортиров-
ки и выдачи данных в функции завершения. При такой организации обработки функция заверше-
ния может выполнять специальные операции, в частности, вставлять дополнительные «гипотети-
ческие» строки в сортируемые данные. Тогда как обычные агрегаты часто реализуются функци-
ями, написанными на PL/pgSQL или другом процедурном языке, сортирующие агрегатные функ-
ции, как правило, должны быть написаны на C, так как их значение состояния нельзя выразить
каким-либо типом данных SQL. (Обратите внимание, что в приведённом выше примере значение
состояния объявлено как имеющее тип internal — это типичный вариант.) И вследствие того,
что сортировку выполняет функция завершения, нельзя возобновить добавление входных строк,
продолжая вызывать функцию перехода. Это означает, что функция завершения не может иметь
характеристику READ_ONLY; она должна объявляться командой CREATE AGGREGATE с характери-
стикой READ_WRITE или SHAREABLE (если она позволяет при последующих вызовах функции завер-
шения использовать уже отсортированное состояние).
Функция перехода состояния для сортирующего агрегата получает значение текущего состояния
плюс агрегируемые входные данные для каждой строки и возвращает изменённое значение со-
стояния. Это определение распространяется и на обычные агрегаты, но заметьте, что непосред-
ственные аргументы (если они есть) при этом не передаются. Функция завершения же получает
последнее значение состояния и значения непосредственных аргументов (если они есть), а также
(если присутствует указание finalfunc_extra) значения NULL, соответствующие агрегируемым
данным. С обычными агрегатами указание finalfunc_extra действительно полезно, только если
агрегат полиморфный; тогда дополнительные фиктивные аргументы необходимы, чтобы связать
тип результата функции завершения с типом(ами) входных данных агрегата.
В настоящее время сортирующие агрегаты не могут использоваться в качестве оконных функций,
поэтому от них поддержка режима движущегося агрегата не требуется.
38.11.4. Частичное агрегирование
Дополнительно агрегатная функция может поддерживать частичное агрегирование. Идея такого
агрегирования в том, чтобы вызывать функции перехода состояния для различных подмножеств
входных данных независимо, а затем комбинировать значения состояния, вычисленные по этим
подмножествам, и получать тот же результат, что был бы получен при сканировании сразу всех
входных данных. Этот режим может применяться для параллельного агрегирования, когда разные
рабочие процессы сканируют различные части таблицы. При этом каждый рабочий процесс вы-
даёт частичное значение состояния, а в конце эти значения комбинируются вместе и получается
окончательное значение состояния. (В будущем этот режим может также применяться, например
для комбинированного агрегирования локальных и удалённых таблиц, но пока это не реализовано.)
Для поддержки частичного агрегирования в определении агрегатной функции должна задаваться
комбинирующая функция, принимающая два значения типа состояния агрегата (представляющие
результаты агрегирования по двум подмножествам входных строк) и выдающая новое значение
типа состояния, представляющее то состояние, которое было бы получено при агрегировании со-
вокупности этих подмножеств строк. При этом относительный порядок входных строк в этих двух
множествах не оговаривается. Это значит, что для агрегатных функций, зависящих от порядка
входных строк, обычно невозможно определить осмысленную комбинирующую функцию.
В качестве простого примера, частичное агрегирование могут поддерживать функции MAX и MIN,
если задать в качестве комбинирующей соответственно функцию сравнения значений большее-из-
двух или меньшее-из-двух, ту же, что они используют и как функцию перехода. Для SUM комбини-
рующей функцией будет просто функция сложения. (И это опять же функция перехода, если толь-
ко значение состояния не выходит за рамки типа входных данных.)
Комбинирующая функция задействуется практически так же, как функция перехода, но прини-
мает в качестве второго аргумента значение типа состояния, а не нижележащего входного типа.
В частности, на неё распространяются те же правила строгости функции и передачи значений
NULL. Также учтите, что если в определении агрегатной функции задаётся отличное от NULL зна-
1042Расширение SQL
чение initcond, оно будет задавать начальное состояние не только для каждого прохода частич-
ного агрегирования, но также и начальное состояние для комбинирующей функции, которая будет
вызываться для комбинирования каждого частичного результата в этом состоянии.
Если типом состояния агрегатной функции выбран internal, комбинирующая функция отвечает
за то, чтобы её результат был помещён в контекст памяти, подходящий для значений агрегатного
состояния. В частности это значит, что, получив в первом аргументе NULL, нельзя просто возвра-
тить второй аргумент, так как это значение окажется в неверном контексте и не просуществует
достаточное время.
Когда типом состояния агрегатной функции выбран internal, обычно в определении агрегатной
функции также уместно задать функцию сериализации и функцию десериализации, которые поз-
воляют копировать значение состояния из одного процесса в другой. Без этих функций параллель-
ное агрегирование невозможно, а также вероятно не будут работать такие будущие приложения,
как локальное/удалённое агрегирование.
Функция сериализации должна принимать один аргумент типа internal и возвращать результат
типа bytea, представляющий значение состояния, упакованное в плоский набор байтов. Функция
десериализации, напротив, обращает это преобразование. Она должна принимать два аргумента
типов bytea и internal и возвращать результат типа internal. (Второй её аргумент не использу-
ется и всегда равен нулю, но он требуется из соображений типобезопасности.) Результат функции
десериализации следует просто разместить в текущем контексте памяти, так как в отличие от ре-
зультата комбинирующей функции он недолговечен.
Также стоит заметить, что для выполнения агрегатной функции в параллельном режиме она долж-
на иметь характеристику PARALLEL SAFE (безопасная для распараллеливания). Характеристики
допустимости распараллеливания её опорных функций значения не имеют.
38.11.5. Вспомогательные функции для агрегатов
Функция, написанная на C, может определить, была ли она вызвана как вспомогательная функция
агрегирования, вызвав AggCheckCallContext, например, так:
if (AggCheckCallContext(fcinfo, NULL))
Смысл такой проверки в том, что в случае положительного её результата первым входным аргу-
ментом является временное значение состояния, которое можно безопасно модифицировать на
месте, не создавая новую копию. Пример вы можете увидеть в функции int8inc(). (Хотя агре-
гатные функции перехода всегда могут изменить непосредственно переходное значение, агрегат-
ные функции завершения должны избегать этого; если они это делают, такое поведение долж-
но отмечаться при создании агрегата. За дополнительными подробностями обратитесь к CREATE
AGGREGATE.)
Второй аргумент AggCheckCallContext можно использовать, чтобы получить контекст памяти, в
котором содержатся значения агрегатного состояния. Это полезно для функций перехода, кото-
рые желают использовать «развёрнутые» объёкты (см. Подраздел  38.12.1) в качестве значений
состояния. При первом вызове такая функция перехода должна возвратить развёрнутый объект
в контексте памяти, относящемся к контексту состояния агрегата, а затем продолжать возвра-
щать тот же объект при последующих вызовах. Например, эту логику можно увидеть в функции
array_append(). (Функция array_append() не используется в качестве перехода никаким встроен-
ным агрегатом, но она написана так, чтобы работать эффективно в таком качестве в дополнитель-
ном агрегате.)
Ещё одна вспомогательная подпрограмма, предназначенная для агрегатных функций, написан-
ных на C, называется AggGetAggref. Эта функция возвращает узел разбора Aggref, описывающий
вызов агрегата. Это в основном полезно для сортирующих агрегатов, которые могут исследовать
структуру узла Aggref и выяснить, какой порядок сортировки они должны реализовать. Примеры
использования можно найти в orderedsetaggs.c в исходном коде PostgreSQL.
38.12. Пользовательские типы
1043Расширение SQL
Как описывалось в Разделе 38.2, PostgreSQL может расширяться и поддерживать новые типы дан-
ных. В этом разделе описывается, как определить новые базовые типы, то есть типы данных, опи-
санные ниже уровня языка SQL. Для создания нового базового типа необходимо реализовать функ-
ции, работающие с этим типом, на языке низкого уровня, обычно C.
Примеры, рассматриваемые в этой главе, можно найти в complex.sql и в complex.c в каталоге src/
tutorial пакета с исходным кодом. Инструкции по запуску этих примеров можно найти в файле
README в том же каталоге.
Пользовательский тип должен всегда иметь функции ввода и вывода. Эти функции определяют,
как тип будет выглядеть в строковом виде (при вводе и выводе для пользователя) и как этот тип
размещается в памяти. Функция ввода принимает в качестве аргумента строку символов, закан-
чивающуюся нулём, и возвращает внутреннее представление типа (в памяти). Функция вывода
принимает в качестве аргумента внутреннее представление типа и возвращает строку символов,
заканчивающуюся нулём. Если мы хотим не просто сохранить тип, но делать с ним нечто большее,
мы должны предоставить дополнительные функции, реализующие все операции, которые мы хо-
тели бы иметь для этого типа.
Предположим, что нам нужен тип complex, представляющий комплексные числа. Естественным
образом комплексное число можно представить в памяти в виде следующей структуры C:
typedef struct Complex {
double
x;
double
y;
} Complex;
Нам нужно будет передавать этот тип по ссылке, так как он слишком велик, чтобы уместиться в
одном значении Datum.
В качестве внешнего строкового представления типа мы выберем строку вида (x,y).
Функции ввода и вывода обычно несложно написать, особенно функцию вывода. Но определяя
внешнее строковое представление типа, помните, что в конце концов вам придётся реализовать
законченный и надёжный метод разбора этого представления в функции ввода. Например, так:
PG_FUNCTION_INFO_V1(complex_in);
Datum
complex_in(PG_FUNCTION_ARGS)
{
char
*str = PG_GETARG_CSTRING(0);
double
x,
y;
Complex
*result;
if (sscanf(str, " ( %lf , %lf )", &amp;x, &amp;y) != 2)
ereport(ERROR,
(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
errmsg("invalid input syntax for complex: \"%s\"",
str)));
result = (Complex *) palloc(sizeof(Complex));
result-&gt;x = x;
result-&gt;y = y;
PG_RETURN_POINTER(result);
}
Функция вывода может быть простой:
PG_FUNCTION_INFO_V1(complex_out);
1044Расширение SQL
Datum
complex_out(PG_FUNCTION_ARGS)
{
Complex
*complex = (Complex *) PG_GETARG_POINTER(0);
char
*result;
result = psprintf("(%g,%g)", complex-&gt;x, complex-&gt;y);
PG_RETURN_CSTRING(result);
}
Вам нужно позаботиться о том, чтобы функции ввода и вывода были обратными друг к другу. В
противном случае вы столкнётесь с проблемами, когда вам потребуется выгрузить данные в файл,
а затем прочитать их. Это особенно распространённая проблема, когда дело касается чисел с пла-
вающей точкой.
Дополнительно пользовательский тип может предоставлять функции для ввода и вывода в двоич-
ном виде. Двоичный ввод/вывод обычно работает быстрее, но хуже портируется, чем текстовый.
Как и с текстовым представлением, выбор, каким будет двоичное представление, остаётся за вами.
Многие встроенные типы данных стараются обеспечить двоичное представление, независимое от
машинной архитектуры. Для типа complex мы воспользуемся функциями двоичного ввода/вывода
типа float8:
PG_FUNCTION_INFO_V1(complex_recv);
Datum
complex_recv(PG_FUNCTION_ARGS)
{
StringInfo buf = (StringInfo) PG_GETARG_POINTER(0);
Complex
*result;
result = (Complex *) palloc(sizeof(Complex));
result-&gt;x = pq_getmsgfloat8(buf);
result-&gt;y = pq_getmsgfloat8(buf);
PG_RETURN_POINTER(result);
}
PG_FUNCTION_INFO_V1(complex_send);
Datum
complex_send(PG_FUNCTION_ARGS)
{
Complex
*complex = (Complex *) PG_GETARG_POINTER(0);
StringInfoData buf;
pq_begintypsend(&amp;buf);
pq_sendfloat8(&amp;buf, complex-&gt;x);
pq_sendfloat8(&amp;buf, complex-&gt;y);
PG_RETURN_BYTEA_P(pq_endtypsend(&amp;buf));
}
Написав функции ввода/вывода и скомпилировав их в разделяемую библиотеку, мы можем опре-
делить тип complex в SQL. Сначала мы объявим его как тип-пустышку:
CREATE TYPE complex;
Это позволит нам ссылаться на этот тип, определяя для него функции ввода/вывода. Теперь мы
определим функции ввода/вывода:
CREATE FUNCTION complex_in(cstring)
1045Расширение SQL
RETURNS complex
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION complex_out(complex)
RETURNS cstring
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION complex_recv(internal)
RETURNS complex
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION complex_send(complex)
RETURNS bytea
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
Наконец, мы можем предоставить полное определение типа данных:
CREATE TYPE complex (
internallength = 16,
input = complex_in,
output = complex_out,
receive = complex_recv,
send = complex_send,
alignment = double
);
Когда определяется новый базовый тип, PostgreSQL автоматически обеспечивает поддержку мас-
сивов с элементами такого типа. Тип массива обычно получает имя по имени базового типа с до-
бавленным спереди символом подчёркивания (_).
Когда тип данных определён, мы можем объявить дополнительные функции для выполнения по-
лезных операций с этим типом. Затем поверх этих функций могут быть определены операторы, а
если потребуется, и классы операторов, для поддержки индексации этого типа. Эти дополнитель-
ные уровни обсуждаются в следующих разделах.
Если внутреннее представление типа данных имеет переменную длину, оно должно соответство-
вать стандартной схеме данных переменной длины: первые четыре байта должно занимать по-
ле char[4], к которому никогда не следует обращаться напрямую (по обыкновению названное
vl_len_). Чтобы сохранить в этом поле размер элемента (включая длину самого поля), вы долж-
ны использовать макрос SET_VARSIZE(), а чтобы получить его — макрос VARSIZE(). (Эти макросы
нужны, потому что поле длины может кодироваться по-разному на разных платформах.)
За дополнительными подробностями обратитесь к команде CREATE TYPE.
38.12.1. Особенности TOAST
Если значения вашего типа данных могут быть разного размера (во внутренней форме), обычно
для такого типа желательно реализовать поддержку TOAST (см. Раздел 68.2). Это следует делать,
даже если значения слишком малы для сжатия или внешнего хранения, так как TOAST позволяет
сэкономить пространство и с данными маленького размера, сокращая издержки в заголовке.
Для поддержки хранения TOAST функции на C, работающие с таким типом данных, должны
позаботиться о распаковке поступивших им данных, используя макрос PG_DETOAST_DATUM. (Эту
внутреннюю особенность обычно скрывает дополнительный, определяемый для типа макрос
GETARG_DATATYPE_P.) Затем, выполняя команду CREATE TYPE, укажите в качестве внутренней длины
variable и выберите подходящий вариант хранения (не plain).
1046Расширение SQL
Если выравнивание данных не имеет значения (либо только для некоторой функции, либо по-
тому что для типа данных в любом случае применяется выравнивание по байтам), некото-
рых издержек, связанных с макросом PG_DETOAST_DATUM, можно избежать. Вместо него можно
использовать PG_DETOAST_DATUM_PACKED (его обычно скрывает определяемый для типа макрос
GETARG_DATATYPE_PP) и воспользоваться макросами VARSIZE_ANY_EXHDR и VARDATA_ANY для обраще-
ния к потенциально сжатым данным. Стоит ещё раз отметить, что данные, возвращаемые этими
макросами, не выравниваются, даже если выравнивание задано в определении типа. Если вырав-
нивание важно, вы должны задействовать обычный интерфейс PG_DETOAST_DATUM.
Примечание
В старом коде поле vl_len_ часто объявлялось как int32, а не char[4]. Это ничем не
чревато до той поры, пока в определении структуры имеются другие поля с выравни-
ванием как минимум int32. Но с потенциально невыровненными данными такое опре-
деление структуры опасно; компилятор может воспринять его как право полагать, что
данные выровнены, что может привести к аварийным сбоям в архитектурах, строгих
к выравниванию.
Поддержка TOAST даёт также возможность иметь развёрнутое представление данных в памяти,
работать с которым будет удобнее, чем с форматом хранения на диске. Обычный или «плоский»
формат хранения varlena в конце концов представляет собой просто набор байт; он не может со-
держать указатели, так как эти байты могут быть скопированы в другие адреса. Для сложных ти-
пов данных работать с плоским форматом данных может быть довольно дорого, так что PostgreSQL
даёт возможность «развернуть» плоский формат в представление, более подходящее для вычис-
лений, и затем передавать эту структуру в памяти функциям, работающим с этим типом.
Для использования развёрнутого хранения тип данных должен определять развёрнутый формат по
правилам, описанным в src/include/utils/expandeddatum.h, и предоставлять функции для «раз-
ворачивания» плоского значения в этот формат, а также для «заворачивания» этого формата опять
в обычное представление varlena. Затем надо добиться, чтобы все функции на C могли принимать
любое представление, возможно выполняя преобразование одного в другое непосредственно при
получении. Для этого не требуется исправлять сразу все существующие функции для этого ти-
па данных, так как имеющийся стандартный макрос PG_DETOAST_DATUM способен преобразовывать
развёрнутые входные данные в обычный плоский формат. Таким образом, все существующие функ-
ции, работающие с плоским форматом varlena продолжат работать, хотя и не очень эффективно, с
развёрнутыми входными данными; их необязательно переделывать, пока не потребуется оптими-
зировать производительность.
Функции на C, умеющие работать с развёрнутым представлением, обычно делятся на две катего-
рии: те, что могут работать с развёрнутым форматом, и те, что могут принимать и развёрнутые, и
плоские данные varlena. Первые проще написать, но они могут быть менее эффективными в целом,
так как преобразование плоского значения в развёрнутую форму для использования только одной
функцией может стоить больше, чем сэкономится при обработке данных в развёрнутом формате.
Когда нужно работать только с развёрнутым форматом, преобразование плоских значений в раз-
вёрнутую форму можно скрыть в макросе, извлекающем аргументы, чтобы функция была не слож-
нее, чем работающая с традиционными входными данными varlena. Чтобы принимать оба вариан-
та входных значений, напишите функцию извлечения аргументов, которая будет распаковывать
значения с сокращённым заголовком, а также внешние и сжатые, но не развёрнутые данные. Та-
кую функцию можно определить как возвращающую указатель на объединение плоского форма-
та varlena и развёрнутого формата. Какой формат получен фактически, вызывающий код может
определить, вызвав макрос VARATT_IS_EXPANDED_HEADER().
Инфраструктура TOAST позволяет не только отличить обычные значения varlena от развёрнутых
значений, но и различить указатели «для чтения/записи» и «только для чтения» на развёрнутые
значения. Функции на C, которым нужно читать развёрнутое значение, или которые будут менять
его безопасным и невидимым извне образом, могут не обращать внимания на тип полученного
указателя. Если же функции на C выдают изменённую версию входного значения, они могут из-
1047Расширение SQL
менять развёрнутые входные данные на месте, только когда получают указатель для чтения/запи-
си, но не когда получен указатель только для чтения. В последнем случае они должны сначала
скопировать значение и получить новое значение, допускающее изменение. Функция на C, созда-
ющая новое развёрнутое значение, должна всегда возвращать указатель на него для чтения/запи-
си. Кроме того, функция, изменяющая развёрнутое значение непосредственно по указателю для
чтения/записи должна позаботиться о том, чтобы это значение осталось в приемлемом состоянии,
если она отработает не полностью.
Примеры работы с развёрнутыми значениями можно найти в стандартной инфраструктуре масси-
вов, в частности в src/backend/utils/adt/array_expanded.c.
38.13. Пользовательские операторы
Любой оператор представляет собой «синтаксический сахар» для вызова нижележащей функции,
выполняющей реальную работу; поэтому прежде чем вы сможете создать оператор, необходимо
создать нижележащую функцию. Однако оператор — не исключительно синтаксический сахар,
так как он несёт и дополнительную информацию, помогающую планировщику запросов оптими-
зировать запросы с этим оператором. Рассмотрению этой дополнительной информации будет по-
свящён следующий раздел.
PostgreSQL поддерживает левые унарные, правые унарные и бинарные операторы. Операторы мо-
гут быть перегружены;то есть одно имя оператора могут иметь различные операторы с разным
количеством и типами операндов. Когда выполняется запрос, система определяет, какой оператор
вызвать, по количеству и типам предоставленных операндов.
В следующем примере создаётся оператор сложения двух комплексных чисел. Предполагается,
что мы уже создали определение типа complex (см. Раздел 38.12). Сначала нам нужна функция,
собственно выполняющая операцию, а затем мы сможем определить оператор:
CREATE FUNCTION complex_add(complex, complex)
RETURNS complex
AS 'имя_файла', 'complex_add'
LANGUAGE C IMMUTABLE STRICT;
CREATE OPERATOR + (
leftarg = complex,
rightarg = complex,
function = complex_add,
commutator = +
);
Теперь мы можем выполнить такой запрос:
SELECT (a + b) AS c FROM test_complex;
c
-----------------
(5.2,6.05)
(133.42,144.95)
Мы продемонстрировали создание бинарного оператора. Чтобы создать унарный оператор, просто
опустите leftarg (для левого унарного) или rightarg (для правого унарного). Обязательными в
CREATE OPERATOR являются только предложение function и объявления аргументов. Предложение
commutator, добавленное в данном примере, представляет необязательную подсказку для оптими-
затора запросов. Подробнее о commutator и других подсказках для оптимизатора рассказывается
в следующем разделе.
38.14. Информация для оптимизации операторов
Определение оператора в PostgreSQL может включать различные дополнительные предложения,
которые сообщают системе полезные сведения о поведении оператора. Старайтесь задавать эти
1048Расширение SQL
предложения при возможности, так как они могут значительно ускорить выполнение запросов,
использующих данный оператор. Но если вы задаёте их, убедитесь, что они корректны! Непра-
вильное применение предложений оптимизации может привести к замедлению запросов, неоче-
видным ошибочным результатам и другим неприятностям. Если вы не уверены в правильности
предложения оптимизации, лучше вовсе не использовать его; единственным последствием будет
то, что запросы будут работать медленнее, чем могли бы.
В будущих версиях PostgreSQL могут быть добавлены и другие предложения. Здесь описываются
те, что поддерживаются версией 11.1.
38.14.1. COMMUTATOR
Предложение COMMUTATOR, если представлено, задаёт оператор, коммутирующий для определяе-
мого. Оператор A является коммутирующим для оператора B, если (x A y) равняется (y B x) для
всех возможных значений x, y. Заметьте, что B также будет коммутирующим для A. Например, опе-
раторы &lt; и &gt; для конкретного типа данных обычно являются коммутирующими друг для друга, а
оператор + — коммутирующий для себя. Но традиционный оператор - коммутирующего не имеет.
Тип левого операнда оператора должен совпадать с типом правого операнда коммутирующего для
него оператора, и наоборот. Поэтому имя коммутирующего оператора — это всё, что PostgreSQL
должен знать, чтобы найти коммутатор, и всё, что нужно указать в предложении COMMUTATOR.
Информация о коммутирующих операторах крайне важна для операторов, которые будут приме-
няться в индексах и условиях соединения, так как, используя её, оптимизатор запросов может
«переворачивать» такие выражения и получать формы, необходимые для разных типов планов.
Например, рассмотрим запрос с предложением WHERE tab1.x = tab2.y, где tab1.x и tab2.y име-
ют пользовательский тип, и предположим, что у нас есть индекс по столбцу tab2.y. Оптимизатор
сможет задействовать сканирование по индексу, только если ему удастся перевернуть выражение
tab2.y = tab1.x, так как механизм сканирования по индексу ожидает, что индексируемый стол-
бец находится слева от оператора. PostgreSQL сам по себе не будет полагать, что такое преобра-
зование возможно — это должен определить создатель оператора =, добавив информацию о ком-
мутирующем операторе.
Когда вы определяете оператор, коммутирующий сам для себя, вы делаете именно это. Если же вы
определяете пару коммутирующих операторов, возникает небольшое затруднение: как оператор,
определяемый первым, может ссылаться на другой, ещё не определённый? Есть два решения этой
проблемы:
• Во-первых, можно опустить предложение COMMUTATOR для первого оператора, который вы
определяете, а затем добавить его в определении второго. Так как PostgreSQL знает, что ком-
мутирующие операторы связаны парами, встречая второе определение, он автоматически воз-
вращается к первому и добавляет в него недостающее предложение COMMUTATOR.
• Во-вторых, можно добавить предложение COMMUTATOR в оба определения. Когда PostgreSQL об-
рабатывает первое определение и видит, что COMMUTATOR ссылается на несуществующий опе-
ратор, в системном каталоге создаётся фиктивная запись для этого оператора. В этой фиктив-
ной записи актуальны будут только имя оператора, типы левого и правого операндов, а также
тип результата, так как это всё, что PostgreSQL может определить в этот момент. Запись пер-
вого оператора будет связана с этой фиктивной записью. Затем, когда вы определите второй
оператор, система внесёт в эту фиктивную запись дополнительную информацию из второго
определения. Если вы попытаетесь применить фиктивный оператор, прежде чем он будет пол-
ностью определён, вы просто получите сообщение об ошибке.
38.14.2. NEGATOR
Предложение NEGATOR, если присутствует, задаёт оператор, обратный к определяемому. Оператор
A является обратным к оператору B, если они оба возвращают булевский результат и (x A y) равня-
ется NOT (x B y) для всех возможных x, y. Заметьте, что B так же является обратным к A. Например,
операторы &lt; и &gt;= составляют пару обратных друг к другу для большинства типов данных. Никакой
оператор не может быть обратным к себе же.
1049Расширение SQL
В отличие от коммутирующих операторов, два унарных оператора вполне могут быть обратными
к друг другу; это будет означать, что (A x) равняется NOT (B x) для всех x (и для правых унарных
операторов аналогично).
У оператора, обратного данному, типы левого и/или правого операнда должны соответствовать
типам данного оператора, так же как и с предложением COMMUTATOR; отличие только в том, что
имя оператора задаётся в предложении NEGATOR.
Указание обратного оператора очень полезно для оптимизатора запросов, так как это позволяет
упростить выражение вида NOT (x = y) до x &lt;&gt; y. Такие выражения не так редки, как может
показаться, так как операции NOT могут добавляться автоматически в результате реорганизаций
выражений.
Пару обратных операторов можно определить теми же способами, что были описаны ранее для
пары коммутирующих.
38.14.3. RESTRICT
Предложение RESTRICT, если представлено, определяет функцию оценки избирательности ограни-
чения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения
RESTRICT имеют смысл только для бинарных операторов, возвращающих boolean. Идея оценки из-
бирательности ограничения заключается в том, чтобы определить, какой процент строк в таблице
будет удовлетворять условию WHERE вида:
column OP constant
для текущего оператора и определённого значения константы. Это помогает оптимизатору при-
мерно определить, сколько строк будет исключено предложениями WHERE такого вида. (ВЫ спро-
сите, а что если константа находится слева? Ну, собственно для таких случаев и задаётся
COMMUTATOR...)
Рамки данной главы не позволяют описать разработку новых функций оценки избирательности
ограничения, но обычно можно использовать один из стандартных системных оценщиков для боль-
шинства дополнительных операторов. Стандартные оценщики ограничений следующие:
eqsel для =
neqsel для &lt;&gt;
scalarltsel для
scalarlesel для
scalargtsel для
scalargesel для
&lt;
&lt;=
&gt;
&gt;=
Часто вы можете обойтись функциями eqsel и neqsel для операторов с очень высокой или низкой
избирательностью, даже если это не операторы собственно равенства или неравенства. Например,
геометрические операторы приблизительного равенства используют eqsel в предположении, что
соответствующие (равные) элементы будут составлять только небольшой процент от всех записей
таблицы.
Функции scalarltsel, scalarlesel, scalargtsel и scalargesel можно использовать для сравне-
ний с типами данных, которые могут быть каким-либо осмысленным образом преобразованы в чис-
ловые скалярные значения для сравнения диапазонов. Если возможно, добавьте свой тип данных
в число типов, которые понимает функция convert_to_scalar(), реализованная в src/backend/
utils/adt/selfuncs.c. (Когда-нибудь на смену ей придут специализированные функции, кото-
рые будут устанавливаться для конкретных типов в определённом столбце системного каталога
pg_type; но пока этого не произошло.) Если вы этого не сделаете, всё будет работать, но оценки
оптимизатора будут не так хороши, как могли бы быть.
Для геометрических операторов разработаны дополнительные функции оценки избирательности
в src/backend/utils/adt/geo_selfuncs.c: areasel, positionsel и contsel. На момент написания
документации это просто заглушки, но вы, тем не менее, вполне можете использовать (или ещё
лучше, доработать) их.
1050Расширение SQL
38.14.4. JOIN
Предложение JOIN, если представлено, определяет функцию оценки избирательности соединения
для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения JOIN
имеют смысл только для бинарных операторов, возвращающих boolean. Идея оценки избиратель-
ности соединения заключается в том, чтобы угадать, какой процент строк в паре таблиц будет
удовлетворять условию WHERE следующего вида:
table1.column1 OP table2.column2
для текущего оператора. Как и RESTRICT, это предложение очень помогает оптимизатору, позволяя
ему выяснить, какой из возможных вариантов соединения скорее всего окажется выгоднее.
Как и ранее, в этой главе мы не будем пытаться рассказать, как написать функцию оценивания
избирательности соединения, а просто отметим, что вы можете использовать один из подходящих
стандартных оценщиков:
eqjoinsel для =
neqjoinsel для &lt;&gt;
scalarltjoinsel для &lt;
scalarlejoinsel для &lt;=
scalargtjoinsel для &gt;
scalargejoinsel для &gt;=
areajoinsel для сравнений областей в плоскости
positionjoinsel для сравнения положений в плоскости
contjoinsel для проверки на включение в плоскости
38.14.5. HASHES
Предложение HASHES, если присутствует, говорит системе, что для соединений с применением
этого оператора допустимо использовать метод соединения по хешу. HASHES имеет смысл только
для бинарного оператора, который возвращает boolean, и на практике этот оператор должен вы-
ражать равенство значений некоторого типа данных или пары типов данных.
Соединение по хешу базируется на том предположении, что оператор соединения возвращает ис-
тину только для таких пар значений слева и справа, для которых получается одинаковый хеш. Если
два значения оказываются в разных ячейках хеша, операция соединения никогда не будет срав-
нивать их, неявно подразумевая, что результат оператора соединения в этом случае должен быть
ложным. Поэтому не имеет никакого смысла указывать HASHES для операторов, которые не пред-
ставляют какую-любо форму равенства. В большинстве случаев практический смысл в поддержке
хеширования есть только для операторов, принимающих один тип данных с обеих сторон. Однако
иногда возможно разработать хеш-функции, совместимые сразу с несколькими типами данных; то
есть, функции, которые будут выдавать одинаковые хеш-коды для «равных» значений, несмотря на
то, что эти значения будут представлены по-разному. Например, довольно легко функции с такой
особенностью реализуются для хеширования целых чисел различного размера.
Чтобы оператор соединения имел характеристику HASHES, он должен входить в семейство опера-
торов индексирования по хешу. Это требование откладывается, когда оператор только создаётся,
ведь нужное семейство операторов, разумеется, ещё не может существовать. Но при попытке ис-
пользовать такой оператор для соединения по хешу, возникнет ошибка во время выполнения, ес-
ли такого семейства не окажется. Системе необходимо знать семейство операторов, чтобы найти
функции для хеширования типа(ов) входных данных оператора. Конечно, вы должны также опре-
делить подходящие функции хеширования, прежде чем сможете создать семейство операторов.
При подготовке функции хеширования обязательно позаботьтесь о том, чтобы она всегда выдавала
нужный результат, вне зависимости от особенностей машинной архитектуры. Например, если ваш
тип данных представлен в структуре, в которой есть незначащие дополняющие биты, нельзя про-
сто передать всю структуру функции hash_any. (Это возможно, только если все ваши операторы и
функции гарантированно очищают незначащие биты, что является рекомендуемой стратегией.) В
качестве другого примера можно привести типы с плавающей точкой в стандарте IEEE, в которых
отрицательный ноль и положительный ноль — различные значения (отличаются на уровне битов),
1051Расширение SQL
но при сравнении они считаются равными. Если значение с плавающей точкой может содержать
отрицательный ноль, требуются дополнительные действия, чтобы для него выдавался тот же хеш,
что и для положительного нуля.
Оператор соединения по хешу должен иметь коммутирующий (это может быть тот же оператор,
если у него два операнда одного типа, либо связанный оператор равенства, в противном случае),
относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использова-
ния оператора возможны ошибки планировщика. Также желательно (хотя это строго не требует-
ся), чтобы в семействе операторов хеширования, поддерживающем несколько типов данных, опре-
делялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей
оптимизации.
Примечание
Функция, реализующая оператор соединения по хешу, должна быть постоянной
(IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE),
система никогда не будет применять этот оператор для соединения по хешу.
Примечание
Если оператор соединения по хешу реализуется строгой функцией (STRICT), эта функ-
ция также должна быть полной: то есть она должна возвращать true или false, но не
NULL, для любых двух аргументов, отличных от NULL. Если это правило не соблюда-
ется, оптимизация операций IN с хешем может приводить к неверным результатам.
(В частности, выражение IN может вернуть false, когда правильным ответом, согласно
стандарту, должен быть NULL, либо выдать ошибку с сообщением о том, что оно не
готов к результату NULL.)
38.14.6. MERGES
Предложение MERGES, если присутствует, говорит системе, что для соединений с применением
этого оператора допустимо использовать метод соединения слиянием. MERGES имеет смысл только
для бинарного оператора, который возвращает boolean, и на практике этот оператор должен вы-
ражать равенство значений некоторого типа данных или пары типов данных.
Идея объединения слиянием заключается в упорядочивании таблиц слева и справа и затем парал-
лельном сканировании их. Поэтому оба типа данных должны поддерживать сортировку в полном
объёме, а оператор соединения должен давать положительный результат только для пар значений,
оказавшихся в «одном месте» при определённом порядке сортировки. На практике это означает,
что оператор соединения должен работать как проверка на равенство. Но при этом возможно объ-
единить слиянием два различных типа данных, если они совместимы логически. Например, опе-
ратор проверки равенства smallint и integer может применяться для соединений слиянием; по-
надобятся только операторы сортировки, приводящие оба типа данных в логически совместимые
последовательности.
Чтобы оператор соединения имел характеристику MERGES, он должен являться членом семейства
операторов индекса btree, реализующим равенство. Это требование откладывается, когда опера-
тор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать.
Но этот оператор не будет фактически применяться для соединений слиянием, пока не будет най-
дено соответствующее семейство операторов. Таким образом, флаг MERGES только подсказывает
планировщику, что стоит обратиться к соответствующему семейству.
Оператор соединения слиянием должен иметь коммутирующий (это может быть тот же оператор,
если у него два операнда одного типа, либо связанный оператор равенства, в противном случае),
относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использо-
вания оператора возможны ошибки планировщика. Также желательно (хотя это строго не требу-
1052Расширение SQL
ется), чтобы в семействе операторов btree, поддерживающем несколько типов данных, определя-
лись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оп-
тимизации.
Примечание
Функция, реализующая оператор соединения слиянием, должна быть постоянной
(IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE),
система никогда не будет применять этот оператор для соединения слиянием.
38.15. Интерфейсы расширений для индексов
Описанные до этого процедуры позволяли определять новые типы, функции и операторы. Однако,
мы ещё не можем определить индекс по столбцу нового типа данных. Для этого нам потребуется
создать класс операторов для нового типа данных. Далее в этом разделе мы продемонстрируем
эту концепцию на примере: мы создадим новый класс операторов для метода индекса-B-дерева,
в котором будут храниться комплексные числа и сортироваться по возрастанию абсолютного зна-
чения.
Классы операторов могут объединяться в семейства операторов, выражающие зависимости меж-
ду семантически совместимыми классами. Когда вводится один тип данных, достаточно класса
операторов, так что мы начнём с него, а к семействам операторов вернёмся позже.
38.15.1. Методы индексов и классы операторов
В системном каталоге есть таблица pg_am, содержащая записи для каждого метода индекса
(внутри называемого методом доступа). Поддержка обычного доступа к таблицам встроена в
PostgreSQL, но все методы доступа описываются в pg_am. Система позволяет добавлять новые ме-
тоды доступа — для этого нужно написать необходимый код, а затем добавить запись в pg_am, но
это выходит за рамки данной главы (см. Главу 61).
Процедуры метода индекса непосредственно ничего не знают о типах данных, с которыми будет
применяться этот метод. Вместо этого, набор операций, которые нужны методу индекса для рабо-
ты с конкретным типом данных, определяется классом операторов. Классы операторов называ-
ются так потому, что они определяют множество операторов в предложении WHERE, которые могут
использоваться с индексом (т. е. могут быть сведены к сканированию индекса). В классе опера-
торов могут также определяться некоторые опорные функции, необходимые для внутренних опе-
раций метода индекса, но они не соответствуют напрямую каким-либо операторам предложения
WHERE, которые могут обрабатываться с индексом.
Для одного типа данных и метода индекса можно определить несколько классов операторов. Бла-
годаря этому, для одного типа данных можно использовать несколько семантически разных ва-
риантов индексирования. Например, индекс-B-дерево требует, чтобы для каждого типа данных, с
которым он работает, определялся порядок сортировки. Для типа комплексных чисел может быть
полезен класс операторов B-дерева, сортирующий данные по модулю комплексного числа, и ещё
один, сортирующий по вещественной части, и т. п. Обычно предполагается, что один из классов
операторов будет применяться чаще других, и тогда он помечается как класс по умолчанию для
данного типа и метода индекса.
Одно и то же имя класса операторов может использоваться для разных методов индекса (напри-
мер, для методов индекса-B-дерева или хеш-индекса применяются классы операторов int4_ops),
но все такие классы являются независимыми и должны определяться отдельно.
38.15.2. Стратегии методов индексов
Операторам, которые связываются с классом операторов, назначаются «номера стратегий», опре-
деляющие роль каждого оператора в контексте его класса. Например, в B-дереве должен быть
строгий порядок ключей с отношениями меньше/больше, так что в данном контексте представля-
1053Расширение SQL
ют интерес операторы «меньше» и «больше или равно». Так как PostgreSQL позволяет пользова-
телям определять операторы произвольным образом, PostgreSQL не может просто посмотреть на
имя оператора (&lt; или &gt;=) и сказать, какое сравнение он выполняет. Вместо этого для метода ин-
декса определяется набор «стратегий», которые можно считать обобщёнными операторами. Каж-
дый класс операторов устанавливает, какие фактические операторы соответствуют стратегиям
для определённого типа данных и интерпретации семантики индекса.
Для метода индекса-B-дерева определены пять стратегий, описанных в Таблице 38.2.
Таблица 38.2. Стратегии B-дерева
Операция Номер стратегии
меньше 1
меньше или равно 2
равно 3
больше или равно 4
больше 5
Индексы по хешу поддерживают только сравнение на равенство, так что они используют только
одну стратегию, показанную в Таблице 38.3.
Таблица 38.3. Стратегии хеша
Операция Номер стратегии
равно 1
Индексы GiST более гибкие: для них вообще нет фиксированного набора стратегий. Вместо этого
опорная процедура «согласованности» каждого конкретного класса операторов GiST интерпрети-
рует номера стратегий как ей угодно. Например, некоторые из встроенных классов операторов
для индексов GiST индексируют двумерные геометрические объекты, и реализуют стратегии «R-
дерева», показанные в Таблице 38.4. Четыре из них являются истинно двумерными проверками
(overlaps, same, contains, contained by); другие четыре учитывают только ординаты, а ещё четыре
проводят же проверки только с абсциссами.
Таблица 38.4. Стратегии двумерного «R-дерева» индекса GiST
Операция Номер стратегии
строго слева от 1
не простирается правее 2
пересекается с 3
не простирается левее 4
строго справа от 5
одинаковы 6
содержит 7
содержится в 8
не простирается выше 9
строго ниже 10
строго выше 11
не простирается ниже 12
Индексы SP-GiST такие же гибкие, как и индексы GiST: для них не задаётся фиксированный набор
стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера
стратегий в соответствии с определением класса операторов. В качестве примера, в Таблице 38.5
приведены номера стратегий, установленные для встроенных классов операторов для точек.
1054Расширение SQL
Таблица 38.5. Стратегии SP-GiST для точек
Операция Номер стратегии
строго слева от 1
строго справа от 5
одинаковы 6
содержится в 8
строго ниже 10
строго выше 11
Индексы GIN такие же гибкие, как и индексы GiST и SP-GiST: для них не задаётся фиксированный
набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют
номера стратегий в соответствии с определением класса операторов. В качестве примера, в Таб-
лице  38.6 приведены номера стратегий, установленные для встроенного класса операторов для
массивов.
Таблица 38.6. Стратегии GIN для массивов
Операция Номер стратегии
пересекается с 1
содержит 2
содержится в 3
равно 4
Индексы BRIN такие же гибкие, как и индексы GiST, SP-GiST и GIN: для них не задаётся фиксиро-
ванный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпре-
тируют номера стратегий в соответствии с определением класса операторов. В качестве приме-
ра, в Таблице 38.7 приведены номера стратегий, используемые встроенными классами операторов
Minmax.
Таблица 38.7. Стратегии BRIN Minmax
Операция Номер стратегии
меньше 1
меньше или равно 2
равно 3
больше или равно 4
больше 5
Заметьте, что все вышеперечисленные операторы возвращают булевы значения. На практике все
операторы, определённые как операторы поиска для метода индекса, должны возвращать тип
boolean, так как они должны находиться на верхнем уровне предложения WHERE, чтобы для них
применялся индекс. (Некоторые методы доступа по индексу также поддерживают операторы
упорядочивания, которые обычно не возвращают булевы значения; это обсуждается в Подразде-
ле 38.15.7.)
38.15.3. Опорные процедуры метода индекса
Стратегии обычно не дают системе достаточно информации, чтобы понять, как использовать ин-
декс. На практике, чтобы методы индекса работали, необходимы дополнительные опорные проце-
дуры. Например, метод индекса-B-дерева должен уметь сравнивать два ключа и определять, боль-
ше, равен или меньше ли первый второго. Аналогично, метод индекса по хешу должен уметь срав-
нивать хеш-коды значений ключа. Эти операции не соответствуют операторам, которые применя-
ются в условиях в командах SQL; это внутрисистемные подпрограммы, используемые методами
индекса.
1055Расширение SQL
Так же, как и со стратегиями, класс операторов определяет, какие конкретные функции должны
играть каждую из ролей для определённого типа данных и интерпретации семантики индекса.
Для метода индекса определяется набор нужных ему функций, а класс оператора выбирает нуж-
ные функции для применения, назначая им «номера опорных функций», определяемые методом
индекса.
Для B-деревьев требуется опорная функция сравнения и могут предоставляться две дополнитель-
ные опорные функции по выбору разработчика класса операторов, описанные в Таблице 38.8. Тре-
бования к этим опорным функциям подробно рассматриваются в Разделе 63.3.
Таблица 38.8. Опорные функции B-деревьев
Функция
Номер опорной функции
Сравнивает два ключа и возвращает целое мень- 1
ше нуля, ноль или целое больше нуля, показыва-
ющее, что первый ключ меньше, равен или боль-
ше второго
Возвращает адреса вызываемых из C опорных 2
функций (или функции) сортировки (необяза-
тельная)
Сравнивает проверяемое значение с базовым 3
плюс/минус смещение и возвращает true или
false в зависимости от результата сравнения (
необязательная)
Для хеш-индексов требуется одна опорная функция, и ещё одна может задаваться по выбору раз-
работчика класса операторов, как показано в Таблице 38.9.
Таблица 38.9. Опорные функции хеша
Функция
Номер опорной функции
Вычисляет 32-битное значение хеша для ключа 1
Вычисляет 64-битное значение хеша для ключа 2
с заданной 64-битной солью; если значение со-
ли равно 0, младшие 32 бита результата должны
соответствовать значению, которое было бы вы-
числено функцией 1 (необязательная)
Для индексов GiST требуются девять опорных функций, две из которых необязательны; они опи-
саны в Таблице 38.10. (За дополнительными сведениями обратитесь к Главе 64.)
Таблица 38.10. Опорные функции GiST
Функция Описание
Номер опорной функции
consistent определяет, удовлетворяет ли 1
ключ условию запроса
union вычисляет объединение набора 2
ключей
compress вычисляет сжатое представле- 3
ние ключа или индексируемого
значения
decompress вычисляет развёрнутое пред- 4
ставление сжатого ключа
penalty вычисляет стоимость добавле- 5
ния нового ключа в поддерево с
заданным ключом
1056Расширение SQL
Функция Описание
Номер опорной функции
picksplit определяет, какие записи стра- 6
ницы должны быть перемещены
в новую страницу, и вычисляет
ключи объединения для резуль-
тирующих страниц
equal сравнивает два ключа и возвра- 7
щает true, если они равны
distance определяет дистанцию от клю- 8
ча до искомого значения (
необязательная)
fetch вычисляет исходное представ- 9
ление сжатого ключа для ска-
нирования только по индексу (
необязательная)
Для индексов SP-GiST требуются пять опорных функций, описанных в Таблице 38.11. (За дополни-
тельными сведениями обратитесь к Главе 65.)
Таблица 38.11. Опорные функции SP-GiST
Функция Описание
Номер опорной функции
config предоставляет основную ин- 1
формацию о классе операторов
choose определяет, как вставить новое 2
значение во внутренний эле-
мент
picksplit определяет, как разделить мно- 3
жество значений
inner_consistent определяет, в каких внутренних 4
ветвях нужно искать заданное
значение
leaf_consistent определяет, удовлетворяет ли 5
ключ условию запроса
Для индексов GIN требуются шесть опорных функций, три из которых необязательны; они описаны
в Таблице 38.12. (За дополнительными сведениями обратитесь к Главе 66.)
Таблица 38.12. Опорные функции GIN
Функция Описание
Номер опорной функции
compare сравнивает два ключа и возвра- 1
щает целое меньше нуля, ноль
или целое больше нуля, показы-
вающее, что первый ключ мень-
ше, равен или больше второго
extractValue извлекает ключи из индексиру- 2
емого значения
extractQuery извлекает ключи из условия за- 3
проса
consistent определяет, соответствует ли 4
значение условию запроса (бу-
левская вариация) (не требует-
ся, если присутствует опорная
функция 6)
1057Расширение SQL
Функция Описание
Номер опорной функции
comparePartial сравнивает частичный ключ из 5
запроса с ключом из индекса и
возвращает целое число мень-
ше нуля, ноль или больше нуля,
показывающее, что GIN должен
игнорировать эту запись индек-
са, принять её как соответству-
ющую или прекратить скани-
рование индекса (необязатель-
ная)
triConsistent определяет, соответствует ли 6
значение условию запроса (тро-
ичная вариация) (не требует-
ся, если присутствует опорная
функция 4)
Для индексов BRIN требуются четыре базовые опорные функции, перечисленные в Таблице 38.13;
для этих базовых функций может потребоваться предоставить дополнительные опорные функции.
(За дополнительными сведениями обратитесь к Разделу 67.3.)
Таблица 38.13. Опорные функции BRIN
Функция Описание
Номер опорной функции
opcInfo возвращает внутреннюю инфор- 1
мацию, описывающую сводные
данные по индексированным
столбцам
add_value добавляет новое значение в су- 2
ществующий сводный кортеж
индекса
consistent определяет, удовлетворяет ли 3
значение условию запроса
union вычисляет объединение
обобщающих кортежей
двух 4
В отличие от операторов поиска, опорные функции возвращают тот тип данных, который ожидает
конкретный метод индекса; например, функция сравнения для B-деревьев возвращает знаковое
целое. Количество и типы аргументов для каждой опорной функции так же зависят от метода
индекса. Для методов B-дерева и хеша функции сравнения и хеширования принимают те же типы
данных, что и операторы, включённые в класс операторов, но для большинства опорных функций
GiST, SP-GiST, GIN и BRIN это не так.
38.15.4. Пример
Теперь, когда мы познакомились с основными идеями, мы можем перейти к обещанному примеру
создания нового класса операторов. (Рабочую копию этого примера можно найти в src/tutorial/
complex.c и src/tutorial/complex.sql в пакете исходного кода.) Класс операторов включает опе-
раторы, сортирующие комплексные числа по порядку абсолютных значений, поэтому мы выбрали
для него имя complex_abs_ops. Во-первых, нам понадобится набор операторов. Процедура опреде-
ления операторов была рассмотрена в Разделе 38.13. Для класса операторов B-деревьев нам по-
надобятся операторы:
•
•
•
•
•
абсолютное-значение
абсолютное-значение
абсолютное-значение
абсолютное-значение
абсолютное-значение
меньше (стратегия 1)
меньше-или-равно (стратегия 2)
равно (стратегия 3)
больше-или-равно (стратегия 4)
больше (стратегия 5)
1058Расширение SQL
Чтобы не провоцировать ошибки при определении связанного набора операторов сравнения, луч-
ше всего сначала написать вспомогательную функцию сравнения для B-дерева, а затем написать
другие функции как однострочные оболочки этой вспомогательной функции. Это уменьшит веро-
ятность получения несогласованных результатов в исключительных случаях. Следуя этому подхо-
ду, мы сначала напишем:
#define Mag(c)
((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)
static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
double
amag = Mag(a),
bmag = Mag(b);
if (amag &lt;
return
if (amag &gt;
return
return 0;
bmag)
-1;
bmag)
1;
}
Теперь функция «меньше» будет выглядеть так:
PG_FUNCTION_INFO_V1(complex_abs_lt);
Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
Complex
*a = (Complex *) PG_GETARG_POINTER(0);
Complex
*b = (Complex *) PG_GETARG_POINTER(1);
PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}
Остальные четыре функции отличаются от неё только тем, как сравнивают результат внутренней
функции с нулём.
Затем мы объявим в SQL функции и операторы на основе этих функций:
CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
AS 'имя_файла', 'complex_abs_lt'
LANGUAGE C IMMUTABLE STRICT;
CREATE OPERATOR &lt; (
leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
commutator = &gt; , negator = &gt;= ,
restrict = scalarltsel, join = scalarltjoinsel
);
Важно правильно определить обратные и коммутирующие операторы, а также подходящие функ-
ции избирательности ограничения и соединения; иначе оптимизатор не сможет использовать наш
индекс эффективно.
Здесь также стоит обратить внимание на следующее:
• Учтите, что может быть только один оператор с именем, например, =, который будет прини-
мать тип complex с двух сторон. В этом случае у нас не будет другого оператора = для complex,
но если мы создаём практически полезный тип данных, вероятно, мы захотим, чтобы опера-
тор = проверял обычное равенство двух комплексных чисел (а не равенство их абсолютных
значений). В этом случае, для complex_abs_eq нужно выбрать какое-то другое имя оператора.
1059Расширение SQL
• Хотя в PostgreSQL разные функции могут иметь одинаковые имена SQL, если у них различные
типы аргументов, в C только одна глобальная функция может иметь заданное имя. Поэтому не
следует давать функции на C имя вроде abs_eq. Во избежание конфликтов с функциями для
других типов данных, в имя функции на C обычно включается имя конкретного типа данных.
• Мы могли быть дать нашей функции имя abs_eq в SQL, рассчитывая на то, что PostgreSQL от-
личит её от любых других одноимённых функций SQL по типам аргументов. Но в данном слу-
чае для упрощения примера мы дали ей одинаковые имена на уровне C и уровне SQL.
На следующем этапе регистрируется опорная процедура, необходимая для B-деревьев. В нашем
примере код C, реализующий её, находится в том же файле, что и функции операторов. Мы объ-
являем эту процедуру так:
CREATE FUNCTION complex_abs_cmp(complex, complex)
RETURNS integer
AS 'имя_файла'
LANGUAGE C IMMUTABLE STRICT;
Теперь, когда мы объявили требуемые операторы и опорную функцию, мы наконец можем создать
класс операторов:
CREATE OPERATOR CLASS complex_abs_ops
DEFAULT FOR TYPE complex USING btree AS
OPERATOR
1
&lt; ,
OPERATOR
2
&lt;= ,
OPERATOR
3
= ,
OPERATOR
4
&gt;= ,
OPERATOR
5
&gt; ,
FUNCTION
1
complex_abs_cmp(complex, complex);
Вот и всё! Теперь должно быть возможно создавать и использовать индексы-B-деревья по столбцам
complex.
Операторы можно было записать более многословно, например, так:
OPERATOR
1
&lt; (complex, complex) ,
но в этом необходимости, так как эти операторы принимают тот же тип данных, для которого
определяется класс операторов.
В приведённом примере предполагается, что этот класс операторов будет классом операторов B-
дерева по умолчанию для типа complex. Если вам это не нужно, просто опустите слово DEFAULT.
38.15.5. Семейства и классы операторов
До этого мы неявно полагали, что класс операторов работает только с одним типом данных. Хотя
в конкретном индексируемом столбце, определённо, может быть только один тип данных, часто
бывает полезно индексировать операции, сравнивающие значение столбца со значением другого
типа. Также, если в сочетании с классом операторов возможно применение оператора, работаю-
щего с двумя типами, для другого типа данных обычно тоже создаётся собственный класс. В таких
случаях полезно установить явную связь между связанными классами, так как это поможет пла-
нировщику оптимизировать SQL-запросы (особенно для классов операторов B-дерева, потому что
планировщик хорошо знает, как работать с ними).
Для удовлетворения этих потребностей в PostgreSQL введена концепция семейства операторов.
Семейство операторов содержит один или несколько классов операторов и может также содержать
индексируемые операторы и соответствующие опорные функции, принадлежащие к семейству в
целом, но не к какому-то одному классу в нём. Мы называем такую связь операторов и функций с
семейством «слабой», в отличие от обычной связи с определённым классом. Как правило, классы
содержат операторы с операндами одного типа, тогда как межтиповые операторы слабо связыва-
ются с семейством.
1060Расширение SQL
Все операторы и функции в семействе операторов должны иметь совместимую семантику; требо-
вания к совместимости устанавливаются методом индекса. Вы можете спросить, зачем в таком
случае вообще выделять конкретные подмножества семейства в виде классов операторов; и на са-
мом деле во многих случаях деление на классы не имеет значения, важно только связывание с се-
мейством. Смысл классов операторов в том, что они определяют, какая часть семейства необходи-
ма для поддержки некоторого индекса. Если существует индекс, использующий класс операторов,
этот класс нельзя будет удалить, не удалив индекс — но другие части семейства, а именно, дру-
гие классы операторов и слабосвязанные операторы, удалить можно. Таким образом, класс опера-
торов должен определяться так, чтобы он содержал минимальный набор операторов и функций,
обоснованно требующихся для работы с индексом по определённому типу данных, а связанные,
но не существенные операторы могут добавляться в качестве слабосвязанных членов в семейство
операторов.
В качестве примера, в PostgreSQL есть встроенное семейство операторов B-дерева integer_ops,
включающее классы операторов int8_ops, int4_ops и int2_ops для индексов по столбцам bigint
(int8), integer (int4) и smallint (int2), соответственно. В этом семействе также содержатся опе-
раторы межтипового сравнения, позволяющие сравнивать значения любых двух этих типов, так
что индексом по любому из этих типов можно пользоваться, выполняя сравнение с другим типом.
Это семейство можно представить такими определениями:
CREATE OPERATOR FAMILY integer_ops USING btree;
CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
-- standard int8 comparisons
OPERATOR 1 &lt; ,
OPERATOR 2 &lt;= ,
OPERATOR 3 = ,
OPERATOR 4 &gt;= ,
OPERATOR 5 &gt; ,
FUNCTION 1 btint8cmp(int8, int8) ,
FUNCTION 2 btint8sortsupport(internal) ,
FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ;
CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
-- standard int4 comparisons
OPERATOR 1 &lt; ,
OPERATOR 2 &lt;= ,
OPERATOR 3 = ,
OPERATOR 4 &gt;= ,
OPERATOR 5 &gt; ,
FUNCTION 1 btint4cmp(int4, int4) ,
FUNCTION 2 btint4sortsupport(internal) ,
FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ;
CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
-- standard int2 comparisons
OPERATOR 1 &lt; ,
OPERATOR 2 &lt;= ,
OPERATOR 3 = ,
OPERATOR 4 &gt;= ,
OPERATOR 5 &gt; ,
FUNCTION 1 btint2cmp(int2, int2) ,
FUNCTION 2 btint2sortsupport(internal) ,
FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ;
ALTER OPERATOR FAMILY integer_ops USING btree ADD
1061Расширение SQL
-- cross-type comparisons int8 vs int2
OPERATOR 1 &lt; (int8, int2) ,
OPERATOR 2 &lt;= (int8, int2) ,
OPERATOR 3 = (int8, int2) ,
OPERATOR 4 &gt;= (int8, int2) ,
OPERATOR 5 &gt; (int8, int2) ,
FUNCTION 1 btint82cmp(int8, int2) ,
-- cross-type comparisons int8 vs int4
OPERATOR 1 &lt; (int8, int4) ,
OPERATOR 2 &lt;= (int8, int4) ,
OPERATOR 3 = (int8, int4) ,
OPERATOR 4 &gt;= (int8, int4) ,
OPERATOR 5 &gt; (int8, int4) ,
FUNCTION 1 btint84cmp(int8, int4) ,
-- cross-type comparisons int4 vs int2
OPERATOR 1 &lt; (int4, int2) ,
OPERATOR 2 &lt;= (int4, int2) ,
OPERATOR 3 = (int4, int2) ,
OPERATOR 4 &gt;= (int4, int2) ,
OPERATOR 5 &gt; (int4, int2) ,
FUNCTION 1 btint42cmp(int4, int2) ,
-- cross-type comparisons int4 vs int8
OPERATOR 1 &lt; (int4, int8) ,
OPERATOR 2 &lt;= (int4, int8) ,
OPERATOR 3 = (int4, int8) ,
OPERATOR 4 &gt;= (int4, int8) ,
OPERATOR 5 &gt; (int4, int8) ,
FUNCTION 1 btint48cmp(int4, int8) ,
-- cross-type comparisons int2 vs int8
OPERATOR 1 &lt; (int2, int8) ,
OPERATOR 2 &lt;= (int2, int8) ,
OPERATOR 3 = (int2, int8) ,
OPERATOR 4 &gt;= (int2, int8) ,
OPERATOR 5 &gt; (int2, int8) ,
FUNCTION 1 btint28cmp(int2, int8) ,
-- cross-type comparisons int2 vs int4
OPERATOR 1 &lt; (int2, int4) ,
OPERATOR 2 &lt;= (int2, int4) ,
OPERATOR 3 = (int2, int4) ,
OPERATOR 4 &gt;= (int2, int4) ,
OPERATOR 5 &gt; (int2, int4) ,
FUNCTION 1 btint24cmp(int2, int4) ,
-- cross-type in_range functions
FUNCTION 3 in_range(int4, int4, int8,
FUNCTION 3 in_range(int4, int4, int2,
FUNCTION 3 in_range(int2, int2, int8,
FUNCTION 3 in_range(int2, int2, int4,
boolean,
boolean,
boolean,
boolean,
boolean)
boolean)
boolean)
boolean)
,
,
,
;
Заметьте, что в определении семейства «перегружаются» номера стратегий операторов и опорных
функций: каждый номер фигурирует в семействе неоднократно. Это допускается, если для каж-
дого экземпляра определённого номера задаются свои типы данных. Экземпляры, у которых оба
1062Расширение SQL
входных типа совпадают с входным типом класса операторов, являются первичными операторами
и опорными функциями для этого класса, и в большинстве случаев они должны объявляться в со-
ставе класса операторов, а не быть слабосвязанными членами семейства.
В семействе операторов B-дерева все операторы должны быть совместимыми в контексте сорти-
ровки; это подробно описано в Разделе  63.2. Для каждого оператора в семействе должна суще-
ствовать опорная функция, принимающая на вход те же два типа, что и оператор. Семейство ре-
комендуется делать полным, то есть включать в него все операторы для каждого сочетания типов
данных. В классы операторов следует включать только однотиповые операторы и опорные функ-
ции для определённого типа данных.
Чтобы создать семейство операторов хеширования для нескольких типов данных, необходимо со-
здать совместимые функции поддержки хеша для каждого типа данных, который будет поддержи-
вать семейство. Здесь под совместимостью понимается гарантия получения одного хеш-кода для
любых двух значений, которые операторы сравнения в этом семействе считают равными, даже ес-
ли они имеют разные типы. Обычно это сложно осуществить, когда типы имеют разное физическое
представление, но в некоторых случаях всё же возможно. Более того, преобразование значения
одного типа данных, представленного в семействе операторов, к другому типу, также представ-
ленному в этом семействе, путём неявного или двоичного сведения не должно менять значение
вычисляемого хеша. Заметьте, что единственная опорная функция задаётся для типа данных, а не
для оператора равенства. Семейство рекомендуется делать полным, то есть включить в него опе-
ратор равенства для всех сочетаний типов данных. В классы операторов следует включать только
однотиповый оператор равенства и опорную функция для определённого типа данных.
В индексах GiST, SP-GiST и GIN межтиповые операции явно не выражены. Множество поддержи-
ваемых операторов определяется только теми операциями, которые могут выполнять основные
опорные функции заданного класса операторов.
В BRIN требования зависят от инфраструктуры, предоставляющей классы операторов. Для клас-
сов операторов, построенных на инфраструктуре minmax, требуется то же поведение, что и для се-
мейств операторов B-дерева: все операторы в семействе должны поддерживать совместимый по-
рядок, а приведения не должны влиять на установленный порядок сортировки.
Примечание
До версии 8.3 в PostgreSQL не было понятия семейства операторов, поэтому любые
межтиповые операторы, предназначенные для применения с индексом, должны бы-
ли привязываться непосредственно к классу оператора индекса. Хотя этот подход по-
прежнему работает, он считается устаревшим, потому что он создаёт слишком много
зависимостей для индекса, а также потому, что планировщик может выполнять межти-
повые сравнения более эффективно, когда для обоих типов данных определены опера-
торы в одном семействе.
38.15.6. Системные зависимости от классов операторов
PostgreSQL использует классы операторов для наделения операторов такими свойствами, которые
могут быть полезны не только для индексов. Поэтому классы операторов могут быть полезны, даже
если вы не намерены индексировать столбцы со значениями определённого вами типа.
В частности, это касается SQL-конструкций ORDER BY и DISTINCT, для которых требуется сравни-
вать и упорядочивать значения. Чтобы эти конструкции работали с определённым пользователем
типом данных, PostgreSQL задействует класс операторов B-дерева по умолчанию для этого типа.
Член «равно» этого класса определяет, как система будет понимать равенство значений для GROUP
BY и DISTINCT, а порядок сортировки, задаваемый классом операторов, определяет порядок ORDER
BY по умолчанию.
Если класс операторов B-дерева по умолчанию для типа данных не определён, система будет ис-
кать класс операторов хеширования по умолчанию. Но так как подобный класс поддерживает толь-
ко равенство, с ним будет возможна только группировка, но не сортировка.
1063Расширение SQL
Если для типа не определён класс операторов по умолчанию, попытавшись использовать эти кон-
струкции SQL с данным типом, вы получите ошибку вида «не удалось найти оператор сортировки».
Примечание
До версии PostgreSQL 7.4, в операциях сортировки и группировки неявно использова-
лись операторы с именами =, &lt; и &gt;. С новым подходом, опирающимся на классы опера-
торов по умолчанию, система не делает никаких предположений о поведении опера-
торов по их именам.
Сортировка с нестандартным классом операторов B-дерева возможна, если указать в предложении
USING оператор «меньше или равно» в данном классе:
SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;
Также возможно выполнить сортировку в порядке по убыванию, если указать в USING оператор
«больше или равно».
Сравнение массивов пользовательских типов также производится в зависимости от семантики,
определённой классом операторов B-дерева. Если класс операторов B-дерева по умолчанию для
данного типа не определён, но имеется класс операторов хеширования, то будет поддерживаться
сравнение массивов, но не упорядочивание.
Ещё одна возможность языка SQL, которая требует дополнительных знаний о типе данных — это
указание RANGE смещение PRECEDING/FOLLOWING для оконных функций (см. Подраздел  4.2.8). Для
запроса вида
SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
FROM mytable;
недостаточно знать, как упорядочить x; база данных должна также понимать, как «вычесть 5» или
«прибавить 10» к значению x в текущей строке для определения рамок текущего окна. Сравнивать
результирующие границы со значениями x в других строках можно используя операторы сравне-
ния, предоставленные классом операторов B-дерева, которые задают упорядочивание ORDER BY, но
операторы сложения и вычитания не входят в этот класс операторов. Так какие же использовать в
этом случае? Жёстко зафиксировать операторы в коде было бы нежелательно, так как при различ-
ных порядках сортировки (с различными классами операторов B-дерева) поведение может менять-
ся. Поэтому класс операторов B-дерева позволяет задать опорную функцию in_range, осуществля-
ющую сложение и вычитание в соответствии с порядком сортировки. Опорных функций in_range
может быть даже несколько, если в качестве смещения в предложениях RANGE имеет смысл пере-
давать данные разных типов. Если в классе операторов B-дерева, связанном с указанным для окна
предложением ORDER BY, нет подходящей опорной функции in_range, то указание RANGE смещение
PRECEDING/FOLLOWING не поддерживается.
Также важно отметить, что оператор равенства, указанный в семействе операторов хеширования,
является кандидатом для применения при слиянии и агрегации по хешу, а также при связанной
оптимизации. Семейство операторов хеширования играет в данном случае определяющую роль,
так как именно в нём задаётся функция хеширования.
38.15.7. Операторы упорядочивания
Некоторые методы доступа индексов (в настоящее время только GiST) поддерживают концепцию
операторов упорядочивания. Операторы, которые мы обсуждали до этого, были операторами по-
иска. Оператором поиска называется такой оператор, для которого можно выполнить поиск по
индексу и найти все строки, удовлетворяющие условию WHERE индексированный_столбец оператор
константа. Заметьте, что при этом ничего не говорится о порядке, в котором будут возвращены
подходящие строки. Оператор упорядочивания, напротив, не ограничивает набор возвращаемых
строк, но определяет их порядок. С таким оператором, просканировав индекс, можно получить
строки в порядке, заданным указанием ORDER BY индексированный_столбец оператор константа.
1064Расширение SQL
Такое определение объясняется тем, что оно поддерживает поиск ближайшего соседа, если этот
оператор вычисляет расстояние. Например, запрос
SELECT * FROM places ORDER BY location &lt;-&gt; point '(101,456)' LIMIT 10;
находит десять ближайших к заданной точке мест. Индекс GiST по столбцу location может сделать
это эффективно, так как &lt;-&gt; — это оператор упорядочивания.
Тогда как операторы поиска должны возвращать булевские результаты, операторы упорядочива-
ния обычно возвращают другой тип, например, float или numeric для расстояний. Этот тип, как
правило, отличается от типа индексируемых данных. Чтобы избежать жёстко запрограммирован-
ных предположений о поведении различных типов данных, при объявлении оператора упорядо-
чивания должно указываться семейство операторов B-дерева, определяющее порядок сортировки
результирующего типа данных. Как было отмечено в предыдущем разделе, семейства операторов
B-дерева определяют понятие упорядочивания для PostgreSQL, так что такое объявление оказы-
вается естественным. Так как оператор &lt;-&gt; для точек возвращает float8, его можно включить в
команду создания класса операторов так:
OPERATOR 15
&lt;-&gt; (point, point) FOR ORDER BY float_ops
где float_ops — встроенное семейство операторов, включающее операции с float8. Это объявле-
ние означает, что индекс может возвращать строки в порядке увеличения значений оператора &lt;-&gt;.
38.15.8. Особенности классов операторов
Есть ещё две особенности классов операторов, которые мы до этого не обсуждали, в первую оче-
редь потому, что они не востребованы для наиболее часто применяемых методов индексов.
Обычно объявление оператора в качестве члена класса операторов (или семейства) означает, что
метод индекса может получить точно набор строк, который удовлетворяет условию WHERE с этим
оператором. Например, запрос:
SELECT * FROM table WHERE integer_column &lt; 4;
может быть удовлетворён в точности индексом-B-деревом по целочисленному столбцу. Но быва-
ют случаи, когда индекс полезен как приблизительный указатель на соответствующие строки. На-
пример, если индекс GiST хранит только прямоугольники, описанные вокруг геометрических объ-
ектов, он не может точно удовлетворить условие WHERE, которое проверяет пересечение не пря-
моугольных объектов, а например, многоугольников. Однако этот индекс можно применить, что-
бы найти объекты, для которых описанные вокруг прямоугольники пересекаются с прямоугольни-
ком, описанным вокруг целевого объекта, а затем провести точную проверку пересечения только
для найденных по индексу объектов. Если это имеет место, такой индекс называется «неточным»
для оператора. Для реализации поиска по неточному индексу метод индекса возвращает флаг
recheck (перепроверить), когда строка может действительно удовлетворять, а может не удовлетво-
рять условию запроса. Затем исполнитель запроса перепроверяет полученную строку по исход-
ному условию запроса и определяет, должна ли она выдаваться как действительно соответствую-
щая ему. Этот подход работает, если индекс гарантированно выдаёт все требуемые строки плюс,
возможно, дополнительные строки, которые можно исключить, вызвав первоначальный оператор.
Методы индексов, поддерживающие неточный поиск (в настоящее время, GiST, SP-GiST и GIN),
позволяют устанавливать флаг recheck опорным функциям отдельных классов операторов, так что
по сути это особенность класса операторов.
Вернёмся к ситуации, когда мы храним в индексе только прямоугольник, описанный вокруг слож-
ного объекта, такого как многоугольник. В этом случае нет большого смысла хранить в элементе
индекса весь многоугольник — мы можем с тем же успехом хранить более простой объект типа
box. Это отклонение выражается указанием STORAGE в команде CREATE OPERATOR CLASS, которое
записывается примерно так:
CREATE OPERATOR CLASS polygon_ops
DEFAULT FOR TYPE polygon USING gist AS
1065Расширение SQL
...
STORAGE box;
В настоящее время, только методы индексов GiST, GIN и BRIN позволяют задать в STORAGE тип,
отличный от типа данных столбца. В GiST преобразованием данных, связанным с использовани-
ем STORAGE, должны заниматься опорные процедуры compress и decompress. В GIN тип STORAGE
определяет тип значений «ключа», который обычно отличается от типа индексируемого столбца
— например, в классе операторов для столбцов с целочисленным массивом ключами могут быть
просто целые числа. За извлечение ключей из индексированных значений в GIN отвечают опор-
ные функции extractValue и extractQuery. BRIN похож на GIN: в нём тип STORAGE определяет тип
хранимых обобщённых значений, а опорные процедуры классов операторов отвечают за правиль-
ное прочтение этих значений.
38.16. Упаковывание связанных объектов в расшире-
ние
Полезное расширение PostgreSQL обычно включает несколько объектов SQL; например, с появле-
нием нового типа данных могут потребоваться новые функции, новые операторы и новые классы
операторов. Все эти объекты удобно собрать в один пакет, с тем чтобы упростить управление базой
данных. В PostgreSQL такие пакеты называются расширениями. Чтобы определить расширение,
вам понадобится как минимум файл скрипта с командами SQL, создающими объекты расширения,
и управляющий файл, в котором определяются несколько базовых свойств самого расширения.
Если расширение написано на C, в него обычно также включается файл разделяемой библиотеки,
содержащий скомпилированный код. Обеспечив наличие этих файлов, загрузить их в базу данных
можно простой командой CREATE EXTENSION.
Основное преимущество расширений по сравнению с обычным SQL-скриптом, загружающим мно-
жество «разрозненных» объектов в базу данных, состоит в том, что PostgreSQL будет понимать,
что объекты расширения связаны вместе. Вы можете удалить все объекты одной командой DROP
EXTENSION (разрабатывать отдельный скрипт «uninstall» не требуется). Ещё полезнее то, что ути-
лита pg_dump знает, что не нужно выгружать отдельные объекты, составляющие расширение —
вместо этого она просто включит в архивный файл команду CREATE EXTENSION. Это кардинально
упрощает миграцию на новую версию расширения, которая может содержать новые или другие
объекты по сравнению с предыдущей версией. Заметьте, однако, что при загрузке такого архива в
базу данных обязательно наличие скрипта, управляющего файла и других файлов расширения.
PostgreSQL не позволит удалить отдельный объект, содержащийся в расширении, кроме как при
удалении всего расширения. Также имейте в виду, что вы можете изменить определение объекта,
относящегося к расширению (например, командой CREATE OR REPLACE FUNCTION для функции), но
изменённое определение не будет выгружено утилитой pg_dump. Такие изменения обычно разум-
ны, только если они параллельно отражаются в файле скрипта расширения. (Для таблиц, содер-
жащих конфигурационные данные, предусмотрены специальные средства; см. Подраздел 38.16.4.)
В производственной среде обычно лучше создавать скрипт обновления расширения, который бу-
дет изменять относящиеся к расширению объекты.
Скрипт расширения может устанавливать права доступа для объектов, являющихся частью рас-
ширения, выполняя команды GRANT и REVOKE. Окончательный набор прав для каждого объекта (ес-
ли они заданы) будет сохранён в системном каталоге pg_init_privs. При использовании pg_dump
в выгружаемый скрипт будет выведена команда CREATE EXTENSION с последующими операторами
GRANT и REVOKE, которые установят права, имевшие место в момент выгрузки.
PostgreSQL в настоящее время не поддерживает скрипты расширений, выполняющие операторы
CREATE POLICY или SECURITY LABEL. Ожидается, что такие команды будут выполняться после того,
как расширение будет создано. Выгружая данные, pg_dump будет также включать в вывод все
политики RLS и метки безопасности.
Механизм расширений также предоставляет средства для поддержки дополнительных скриптов,
призванных изменять определение объектов SQL, содержащихся в расширении. Например, если
1066Расширение SQL
версия расширения 1.1, по сравнению с версией 1.0, добавляет одну функцию и изменяет тело
другой функции, автор расширения может предоставить скрипт обновления, который произведёт
именно эти два изменения. Затем, воспользовавшись командой ALTER EXTENSION UPDATE, можно
будет применить эти изменения и отследить, какая версия расширения фактически установлена
в заданной базе данных.
Типы SQL-объектов, которые могут быть членами расширения, перечислены в описании ALTER
EXTENSION. Не могут быть его членами, в частности, объекты уровня кластера, такие как базы
данных, роли и табличные пространства, так как расширение существует только в рамках одной
базы данных. (Скрипту расширения не запрещается создавать такие объекты, но если он сделает
это, они не будут считаться частью расширения.) Также заметьте, что несмотря на то, что таблица
может быть членом расширения, её подчинённые объекты, такие как индексы, непосредственны-
ми членами расширения считаться не будут. Ещё один важный момент — схемы могут принадле-
жать расширениям, но не наоборот; поэтому расширение имеет неполное имя и не существует
«внутри» какой-либо схемы. Однако объекты-члены расширения, будут относиться к схемам, если
это уместно для их типов. Сами расширения могут иметь, а могут не иметь основания владеть схе-
мами, к которым относятся объекты-члены расширения.
Если скрипт расширения создаёт какие-либо временные объекты (например, временные таблицы),
эти объекты будут считаться членами расширения до конца текущего сеанса, но удалятся автома-
тически в конце сеанса, как и должны временные объекты. Это является исключением из правила,
запрещающего удаление объектов-членов расширения без удаления всего расширения.
38.16.1. Определение объектов расширения
В широко распространяемых расширениях должны закладываться минимальные предположения
о базе данных, которую они занимают. В частности, пока не выполнена команда SET search_path
= pg_temp, можно считать, что каждое неполное имя может быть разрешено в объект, созданный
злонамеренным пользователем. Опасайтесь конструкций, явно зависящих от search_path: IN и
CASE выражение WHEN всегда выбирают оператор по пути поиска. Вместо них следует использовать
OPERATOR(схема.=) ANY и CASE WHEN выражение.
38.16.2. Файлы расширений
Команда CREATE EXTENSION задействует управляющий файл расширения, который должен на-
зываться по имени расширения, с суффиксом .control, и должен быть помещён в каталог сервера
SHAREDIR/extension. Должен быть также ещё минимум один SQL-скрипт, с именем, соответствую-
щим шаблону расширение--версия.sql (например, foo--1.0.sql для версии 1.0 расширения foo).
По умолчанию скрипт(ы) также помещается в каталог SHAREDIR/extension; но в управляющем
файле можно задать и другой каталог.
Формат управляющего файла расширения не отличается от формата postgresql.conf, а именно
представляет собой список присвоений имя_параметра = значение, по одному в строке. В нём также
допускаются пустые строки и комментарии, начинающиеся с #. Все значения, отличные от един-
ственного слова или числа, в нём должны заключаться в кавычки.
В управляющем файле могут устанавливаться следующие параметры:
directory (string)
Каталог, содержащий SQL-скрипт(ы) расширения. Если только не задан абсолютный путь, это
имя рассматривается относительно каталога сервера SHAREDIR. По умолчанию подразумевает-
ся указание directory = 'extension'.
default_version (string)
Версия расширения по умолчанию (та, которая будет установлена, если в CREATE EXTENSION не
будет указана никакая версия). Хотя этот параметр можно опустить, это приведёт к ошибке в
CREATE EXTENSION без явного указания VERSION, что вряд ли будет желаемым поведением.
1067Расширение SQL
comment (string)
Комментарий (произвольная строка) к расширению. Комментарий применяется при изначаль-
ном создании расширения, но не при обновлениях расширения (так как при этом мог бы за-
меняться комментарий, заданный пользователем). Комментарий расширения также можно за-
дать посредством команды COMMENT в файле скрипта.
encoding (string)
Кодировка символов, используемая в файлах скриптов. Её следует указать, если эти файлы
содержат символы не из набора ASCII. По умолчанию предполагается, что эти файлы содержат
текст в кодировке базы данных.
module_pathname (string)
Значение этого параметра будет подставляться вместо каждого вхождения MODULE_PATHNAME
в скриптах. Если этот параметр не задан, подстановка не производится. Обычно для этого па-
раметра устанавливается значение $libdir/имя_разделяемой_библиотеки, а затем в командах
CREATE FUNCTION для функций на языке C указывается MODULE_PATHNAME, чтобы в скриптах не
приходилось жёстко задавать имя разделяемой библиотеки.
requires (string)
Список имён расширений, от которых зависит данное, например, requires = 'foo, bar'. Эти
расширения должны быть уже установлены, прежде чем можно будет установить данное.
superuser (boolean)
Если этот параметр имеет значение true (по умолчанию), только суперпользователи смогут
создать это расширение или обновить его до новой версии. Если он равен false, для этого будет
достаточно прав, необходимых для выполнения команд в установочном скрипте или скрипте
обновления.
relocatable (boolean)
Расширение является перемещаемым, если относящиеся к нему объекты после создания рас-
ширения можно переместить в другую схему. По умолчанию подразумевается false, то есть
расширение не считается перемещаемым. Подробнее об этом рассказывается в Подразде-
ле 38.16.3.
schema (string)
Этот параметр может задаваться только для неперемещаемых расширений. Если он задан, рас-
ширение можно будет загрузить только в указанную схему и не в какую другую. Подробнее
об этом рассказывается ниже. Параметр schema учитывается только при изначальном созда-
нии расширения, но не при его обновлении. Подробнее об этом рассказывается в Подразде-
ле 38.16.3.
Помимо главного управляющего файла расширение.control, расширение может включать допол-
нительные управляющие файлы с именами вида расширение--версия.control. Если они присут-
ствуют, они должны находиться в том же каталоге, что и основной скрипт. Дополнительные управ-
ляющие файлы имеют тот же формат, что и основной. Любые параметры, заданные в дополни-
тельном управляющем файле, переопределяют параметры основного файла, когда выполняет-
ся установка этой версии расширения или обновление до неё. Однако параметры directory и
default_version в дополнительных управляющих файлах задать нельзя.
SQL-скрипты расширений могут содержать любые команды SQL, за исключением команд управ-
ления транзакциями (BEGIN, COMMIT и т. д.) и команд, которые не могут выполняться внутри бло-
ка транзакции (например, VACUUM). Это объясняется тем, что эти скрипты неявно выполняются в
блоке транзакции.
SQL-скрипты расширений также могут содержать строки, начинающиеся с \echo, и они будут иг-
норироваться (восприниматься как комментарии) механизмом расширений. Это часто использу-
1068Расширение SQL
ется для вывода ошибки в случае, если этот скрипт выполняется в psql, а не загружается командой
CREATE EXTENSION (см. пример скрипта в Подразделе 38.16.7). Если такое выполнение не предот-
вратить, пользователи могут случайно загрузить содержимое расширения как «разрозненные»
объекты, а не как собственно расширение, и получить состояние, которое довольно сложно испра-
вить.
Тогда как файлы скриптов могут содержать любые символы, допустимые в указанной кодировке,
управляющие файлы могут содержать только ASCII-символы, так как указать кодировку этих фай-
лов в PostgreSQL нет никакой возможности. На практике это представляет проблему, только если
вы хотите использовать символы не из набора ASCII в комментарии расширения. В таких случаях
рекомендуется не использовать параметр comment в управляющем файле, а вместо этого задать
комментарий командой COMMENT ON EXTENSION в файле скрипта.
38.16.3. Перемещаемость расширений
У пользователей часто возникает желание загрузить объекты, содержащиеся в расширении, в схе-
му, отличную от той, что выбрал автор расширения. Насколько это поддерживает расширение,
описывается одним из трёх уровней:
• Полностью перемещаемое расширение может быть перемещено в другую схему в любое вре-
мя, даже после того, как оно загружено в базу данных. Это осуществляется командой ALTER
EXTENSION SET SCHEMA, которая автоматически переименовывает все объекты-члены расшире-
ния, перенося их в новую схему. Обычно это возможно, только если в расширении нет ника-
ких внутренних предположений о том, в какой схеме находятся все его объекты. Кроме того,
все объекты расширения должны находиться в одной исходной схеме (за исключением объек-
тов, не принадлежащих схемам, как например, процедурные языки). Чтобы пометить расши-
рение как полностью перемещаемое, установите relocatable = true в его управляющем фай-
ле.
• Расширение может быть перемещаемым в момент установки, но не после. Обычно это имеет
место, когда скрипту расширения необходимо явно ссылаться на целевую схему, например,
устанавливая свойства search_path для функций SQL. Для такого расширения нужно задать
relocatable = false в его управляющем файле и обращаться к целевой схеме в скрипте по
псевдоимени @extschema@. Все вхождения этого псевдоимени будут заменены именем выбран-
ной целевой схемы перед выполнением скрипта. Пользователь может выбрать целевую схему
в указании SCHEMA команды CREATE EXTENSION.
• Если расширение вовсе не поддерживает перемещение, установите в его управляющем фай-
ле relocatable = false, и также задайте в параметре schema имя предполагаемой целевой
схемы. Это предотвратит использование указания SCHEMA команды CREATE EXTENSION, если
только оно задаёт не то же имя, что определёно в управляющем файле. Этот выбор обыч-
но необходим, если в расширении делаются внутренние предположения об именах схемы,
которые нельзя свести к использованию псевдоимени @extschema@. Механизм подстановки
@extschema@ будет работать и в этом случае, хотя польза от него будет ограниченной, так как
имя схемы определяется управляющим файлом.
В любом случае, при выполнении файла скрипта параметр search_path изначально будет указывать
на целевую схему; то есть, CREATE EXTENSION делает то же, что и:
SET LOCAL search_path TO @extschema@;
Это позволяет направить объекты, создаваемые скриптом, в целевую схему. Скрипт может изме-
нить search_path, если пожелает, но обычно это нежелательно. Параметр search_path восстанав-
ливает предыдущее значение по завершении CREATE EXTENSION.
Целевая схема определяется параметром schema (если он задан) в управляющем файле, либо указа-
нием SCHEMA команды CREATE EXTENSION (если оно присутствует), а в противном случае выбирается
текущая схема для создания объектов по умолчанию (первая указанная в параметре search_path
вызывающего). Когда используется параметр управляющего файла schema, целевая схема будет
создана, если она ещё не существует, но в двух других случаях она должна уже существовать.
1069Расширение SQL
Если в параметре requires в файле управления указаны какие-либо расширения, необходимые для
данного, их целевые схемы добавляются к начальному значению search_path. Благодаря этому,
их объекты видны для скрипта нового расширения.
Хотя неперемещаемое расширение может содержать объекты, распределяемые по нескольким
схемам, обычно желательно поместить все объекты, предназначенные для внешнего использова-
ния, в одну схему, назначенную целевой схемой расширения. Такой порядок будет хорошо согла-
совываться со значением search_path по умолчанию в процессе создания зависимых расширений.
38.16.4. Конфигурационные таблицы расширений
Некоторые расширения включают конфигурационные таблицы, содержащие данные, которые мо-
гут быть добавлены или изменены пользователем после установки расширения. Обычно, если таб-
лица является частью расширения, ни определение таблицы, ни её содержимое не будет выгру-
жаться утилитой pg_dump. Но это поведение нежелательно для конфигурационных таблиц — из-
менения, внесённые в них пользователем, должны выгружаться; в противном случае расширение
будет вести себя по-другому, когда будет загружено вновь.
Чтобы решить эту проблему, скрипт расширения может пометить созданную им таблицу или по-
следовательность как конфигурационное отношение, в результате чего pg_dump включит в выгру-
жаемые данные содержимое (но не определение) этой таблицы или последовательности. Для это-
го нужно вызвать функцию pg_extension_config_dump(regclass, text) после создания таблицы
или последовательности, например так:
CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;
SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');
Так можно пометить любое число таблиц или последовательностей, в том числе последовательно-
сти, связанные со столбцами serial или bigserial.
Когда второй аргумент pg_extension_config_dump — пустая строка, pg_dump выгружает всё со-
держимое таблицы. Обычно это правильно, только если после создания скриптом расширения эта
таблица изначально пуста. Если же в таблице оказывается смесь начальных данных и данных,
добавленных пользователем, во втором аргументе pg_extension_config_dump передаётся условие
WHERE, которое отфильтровывает данные, подлежащие выгрузке. Например, имея таблицу, создан-
ную таким образом:
CREATE TABLE my_config (key text, value text, standard_entry boolean);
SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
можно сделать так, чтобы поле standard_entry содержало true только для строк, создаваемых
скриптом расширения.
Для последовательностей второй аргумент функции pg_extension_config_dump не имеет значе-
ния.
В более сложных ситуациях, когда пользователи могут модифицировать и изначально существо-
вавшие строки, можно создать триггеры для конфигурационной таблицы, которые корректно по-
метят изменённые строки.
Условие фильтра, связанное с конфигурационной таблицей, можно изменить, повторно вызвав
pg_extension_config_dump. (Обычно это находит применение в скрипте обновления расширения.)
Единственный способ обозначить, что некоторая таблица более не является конфигурационной —
разорвать её связь с расширением командой ALTER EXTENSION ... DROP TABLE.
Заметьте, что отношения внешних ключей между таблицами определяют порядок, в котором эти
таблицы будет выгружать pg_dump. В частности, pg_dump попытается выгрузить сначала основ-
1070Расширение SQL
ную таблицу, а затем подчинённую. Так как отношения внешних ключей устанавливаются во вре-
мя выполнения CREATE EXTENSION (до загрузки данных в таблицы), циклические зависимости
не поддерживаются. Когда образуются циклические зависимости, данные, тем не менее, будут
выгружены, но полученный архив нельзя будет восстановить обычным образом, потребуется вме-
шательство пользователя.
Последовательности, связанные со столбцами serial или bigserial, не обязательно помечать
непосредственно, чтобы их состояние было сохранено. Для этой цели достаточно пометить только
их родительское отношение.
38.16.5. Обновление расширений
Один из плюсов механизма расширений заключается в том, что он предоставляет удобные спо-
собы управления обновлениями SQL-команд, определяющих объекты расширения. В частности,
каждой выпускаемой версии установочного скрипта расширения назначается имя или номер вер-
сии. Кроме того, если вы хотите, чтобы пользователи могли динамически обновлять одну вер-
сию расширения до другой, вы должны предоставить скрипты обновления, которые внесут необ-
ходимые изменения для перехода от старой версии к новой. Скриптам обновлений назначают-
ся имена, соответствующие шаблону расширение--старая_версия--новая_версия.sql (например,
foo--1.0--1.1.sql будет содержать команды, меняющие версию 1.0 расширения foo на версию
1.1).
С условием, что имеется подходящий скрипт расширения, команда ALTER EXTENSION UPDATE об-
новит установленное расширение до указанной новой версии. Скрипт обновления запускается в
том же окружении, которое организует команда CREATE EXTENSION для установочных скриптов: в
частности, search_path устанавливается таким же образом, а любые новые объекты, созданные
скриптом, автоматически добавляются в расширение. И если скрипт решит удалить объекты-чле-
ны расширения, они будут автоматически исключены из его состава.
Если у расширения есть дополнительные управляющие файлы, для скрипта обновления применя-
ются те параметры, которые связаны с целевой (новой) версией скрипта.
Механизм обновления может использоваться для решения важной особой задачи: преобразование
«разрозненной» коллекции объектов в расширение. До того как механизм расширений появился
в PostgreSQL (в версии 9.1), многие писали модули разрешений, которые просто создавали мно-
жество неупакованных объектов. Но если у нас уже есть база данных с такими объектами, как их
можно преобразовать в правильно упакованное расширение? Один из вариантов — удалить их и
затем выполнить простую команду CREATE EXTENSION, но это нежелательно, если у объектов есть
зависимости (например, если в таблицах есть столбцы типа данных, созданного расширением).
Чтобы исправить эту ситуацию, можно создать пустое расширение, затем с помощью команды
ALTER EXTENSION ADD добавить в него каждый существующий объект, и наконец, создать все новые
объекты, которые есть в текущей версии расширения, но отсутствуют в неупакованном вариан-
те. CREATE EXTENSION поддерживает этот сценарий предложением FROM старая_версия, с которым
она не будет запускать обычный установочный скрипт для целевой версии, а запустит вместо это-
го скрипт обновления с именем расширение--старая_версия--новая_версия.sql. В качестве име-
ни старая_версия автор расширения может выбрать любое фиктивное имя, но обычно задаётся
unpackaged. Если у вас несколько предыдущих версий, которые нужно привести к стилю расшире-
ния, выберите разные фиктивные имена версий, чтобы различить их.
ALTER EXTENSION также может выполнять последовательности скриптов обновления для по-
лучения запрошенной версии. Например, если имеются только скрипты foo--1.0--1.1.sql и
foo--1.1--2.0.sql, ALTER EXTENSION будет применять их по порядку, если при установленной вер-
сии 1.0 запрошено обновлении до версии 2.0.
PostgreSQL не делает никаких предположений о свойствах имён версий: например, он не знает,
следует ли версия 1.1 за 1.0. Он просто сопоставляет имена имеющихся версий и следует пути,
который требует применить как можно меньше скриптов обновлений. (Именем версии на самом
деле может быть любая строка, которая не содержит -- и при этом не начинается и не заканчи-
вается символом -.)
1071Расширение SQL
Иногда бывают полезны скрипты «понижения версии», например, foo--1.1--1.0.sql, которые
позволяют откатить изменения, связанные с версией 1.1. Если вы применяете их, учтите, что есть
вероятность неожиданного выполнения такого скрипта, если он окажется в кратчайшем пути. Рис-
кованная ситуация возникает при наличии скрипта обновления по «короткому пути», который пе-
репрыгивает через несколько версий, и скрипта понижения версии до начальной точки первого
скрипта. В результате может получиться так, что понижение версии с последующим обновлением
по короткому пути окажется на несколько шагов короче, чем последовательное повышение вер-
сии. Если скрипт понижения версии удаляет какие-либо незаменимые объекты, это может приве-
сти к нежелательным результатам.
Чтобы убедиться, что при обновлении не будет выбран нежелательный путь, воспользуйтесь этой
командой:
SELECT * FROM pg_extension_update_paths('имя_расширения');
Она показывает каждую пару различных известных имён версий для указанного расшире-
ния, вместе с последовательностью обновления, которая будет выбрана для перехода от од-
ной версии к другой, либо NULL, если путь обновления не находится. Путь выводится в тексто-
вом виде с разделителями --. Если вы предпочитаете формат массива, вы можете применить
regexp_split_to_array(path,'--').
38.16.6. Установка расширений скриптами обновления
Расширение, существующее некоторое время, вероятно, будет иметь несколько версий, для ко-
торых автору надо будет писать скрипты обновления. Например, если вы выпустили расшире-
ние foo версий 1.0, 1.1 и 1.2, у вас должны быть скрипты обновления foo--1.0--1.1.sql и
foo--1.1--1.2.sql. До PostgreSQL версии 10 необходимо было также создавать файлы скриптов
foo--1.1.sql и foo--1.2.sql, которые устанавливают непосредственно новые версии скриптов; в
противном случае их можно было установить, только установив 1.0 и произведя обновление. Это
было утомительно и неэффективно, но теперь такой необходимости нет, так как команда CREATE
EXTENSION может сама построить цепочку обновлений. Например, если имеются только файлы
скриптов foo--1.0.sql, foo--1.0--1.1.sql и foo--1.1--1.2.sql, то запрос на установку версии
1.2 удовлетворяется запуском этих трёх скриптов по очереди. Это не будет отличаться от установ-
ки версии 1.0 с последующим обновлением до 1.2. (Как и с командой ALTER EXTENSION UPDATE,
при наличии нескольких путей выбирается самый короткий.) Организация скриптов расширения
по такой схеме может упростить сопровождение небольших обновлений.
Если вы используете дополнительные (ориентированные на версию) управляющие файлы для рас-
ширения, поддерживаемого по такой схеме, имейте в виду, что управляющий файл нужен для
каждой версии, даже если для неё нет отдельного скрипта установки, так как этот файл бу-
дет определять, как произвести неявное обновление до этой версии. Например, если в файле
foo--1.0.control задаётся requires = 'bar', а в других управляющих файлах foo — нет, зависи-
мость расширения от bar будет удалена при обновлении с версии 1.0 до другой.
38.16.7. Пример расширения
Здесь представлен полный пример расширения, в котором средствами исключительно SQL реа-
лизуется составной тип с двумя элементами, который может сохранить в своих слотах значения
любого типа, названные «k» и «v». Для хранения все значения переводятся в текстовый формат
(если они имеют другой формат).
Файл скрипта pair--1.0.sql выглядит так:
-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit
CREATE TYPE pair AS ( k text, v text );
CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';
1072Расширение SQL
CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);
-- "SET search_path" is easy to get right, but qualified names perform better.
CREATE OR REPLACE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;
CREATE OR REPLACE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
$1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';
Управляющий файл pair.control выглядит так:
# расширение pair
comment = 'Тип данных для пары ключ/значение'
default_version = '1.0'
relocatable = false
Хотя вам вряд ли понадобится сборочный файл, только для того, чтобы установить эти два файла
в нужный каталог, вы можете использовать Makefile следующего содержания:
EXTENSION = pair
DATA = pair--1.0.sql
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
Этот Makefile опирается на инфраструктуру PGXS, которая описывается в Разделе  38.17. С ним
команда make install установит управляющий файл и скрипт в правильный каталог, который
определит pg_config.
Когда эти файлы будут установлены, выполните команду CREATE EXTENSION, чтобы загрузить
объекты в определённую базу данных.
38.17. Инфраструктура сборки расширений
Если вы задумываетесь о распространении ваших модулей расширения PostgreSQL, знайте, что ор-
ганизовать для них портируемую систему сборки может быть довольно сложно. Поэтому инсталля-
ция PostgreSQL включает инфраструктуру сборки расширений, названную PGXS, так что неслож-
ные модули расширений можно собрать просто в среде установленного сервера. PGXS предназна-
чена в первую очередь для расширений, написанных на C, хотя её можно применять и для рас-
ширения на чистом SQL. Заметьте, что PGXS не претендует на роль универсальной инфраструк-
туры сборки, способной собрать любой программный объект, взаимодействующий с PostgreSQL;
она просто автоматизирует общие правила для сборки простых модулей расширения сервера. Для
более сложных пакетов вам придётся разработать собственную систему сборки.
Чтобы использовать инфраструктуру PGXS для вашего расширения, вы должны написать простой
сборочный файл. В нём вы должны установить нужные переменные и подключить глобальный сбо-
рочный файл PGXS. Следующий пример собирает модуль расширения с именем isbn_issn, кото-
рый включает разделяемую библиотеку, написанную на C, управляющий файл расширения, SQL-
скрипт, текстовый файл документации и заголовочный файл (он нужен, только если другие модули
будут вызывать функции данного расширения напрямую, без использования SQL):
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
1073Расширение SQL
DOCS = README.isbn_issn
HEADERS_isbn_issn = isbn_issn.h
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
Последние три строки всегда должны быть такими. Выше в файле вы определяете переменные или
добавляете собственные правила для make.
Установите одну из этих трёх переменных, чтобы указать, что будет собрано:
MODULES
список объектов разделяемых библиотек, которые должны быть собраны из исходных файлов
с одной основой (суффиксы библиотек в этом списке не указываются)
MODULE_big
разделяемая библиотека, которая должна быть собрана из нескольких исходных файлов (объ-
ектные файлы перечисляются в OBJS)
PROGRAM
исполняемая программа, которая должна быть собрана (объектные файлы перечисляются в
OBJS)
Также можно установить следующие переменные:
EXTENSION
имена расширений(я); для каждого имени вы должны предоставить файл расширение.control,
который будет установлен в префикс/share/extension
MODULEDIR
подкаталог в каталоге префикс/share, в который должны устанавливаться файлы DATA и DOCS
(если не задан, подразумевается extension, если установлена переменная EXTENSION, или
contrib в противном случае)
DATA
произвольные файлы, которые должны быть установлены в префикс/share/$MODULEDIR
DATA_built
произвольные файлы, которые должны быть сначала собраны, а затем установлены в префикс/
share/$MODULEDIR
DATA_TSEARCH
произвольные файлы, которые должны быть установлены в префикс/share/tsearch_data
DOCS
произвольные файлы, которые должны быть установлены в префикс/doc/$MODULEDIR
HEADERS
HEADERS_built
Файлы, которые будут устанавливаться (и, возможно, собираться) в префикс/include/server/
$MODULEDIR/$MODULE_big.
В отличие от файлов DATA_built, файлы в HEADERS_built не удаляются при выполнении цели
clean; если вы хотите удалять их, добавьте их в EXTRA_CLEAN или напишите собственные пра-
вила для этого.
1074Расширение SQL
HEADERS_$MODULE
HEADERS_built_$MODULE
Файлы, которые будут устанавливаться (если требуется, после сборки) в префикс/include/
server/$MODULEDIR/$MODULE, где в качестве $MODULE должно задаваться имя модуля, фигуриру-
ющее в MODULES или MODULE_big.
В отличие от файлов DATA_built, файлы в HEADERS_built_$MODULE не удаляются при выполне-
нии цели clean; если вы хотите удалять их, добавьте их в EXTRA_CLEAN или напишите собствен-
ные правила для этого.
Для одного модуля вполне можно использовать обе переменные в любом сочетании, если
только в вашем списке MODULES не присутствуют два имени, отличающиеся только префиксом
built_, что приводит к неоднозначности. В этом (очень маловероятном) случае следует исполь-
зовать только переменные HEADERS_built_$MODULE.
SCRIPTS
скрипты (не двоичные файлы), которые должны быть установлены в префикс/bin
SCRIPTS_built
скрипты (не двоичные файлы), которые должны быть сначала собраны, а затем установлены
в префикс/bin
REGRESS
список тестов регрессий (без суффикса), см. ниже
REGRESS_OPTS
дополнительные параметры, передаваемые pg_regress
NO_INSTALLCHECK
не определять цель installcheck; это полезно, если тестам требуется особая конфигурация
или pg_regress не используется
EXTRA_CLEAN
дополнительные файлы, которые должны быть удалены при make clean
PG_CPPFLAGS
флаги, добавляемые в CPPFLAGS
PG_LIBS
будет добавлено в строку компоновки PROGRAM
SHLIB_LINK
будет добавлено в строку компоновки MODULE_big
PG_CONFIG
путь к программе pg_config в инсталляции PostgreSQL, с которой будет выполняться сборка
(обычно указывается просто pg_config, и используется первый экземпляр, найденный по пути
в PATH)
Поместите этот сборочный файл под именем Makefile в каталог, где находится ваше расшире-
ние. После этого выполните make, чтобы скомпилировать, а затем make install, чтобы установить
ваш модуль. По умолчанию расширение компилируется и устанавливается для той инсталляции
PostgreSQL, которая соответствует экземпляру pg_config, найденному первым при поиске по пути
1075Расширение SQL
в PATH. Чтобы использовать другую инсталляцию, вы можете задать в PG_CONFIG путь к её экзем-
пляру pg_config либо внутри сборочного файла, либо в командном файле make.
Вы также можете запустить make в каталоге вне каталога исходного дерева вашего расширения,
если хотите отделить каталог сборки. Эта процедура называется сборкой с VPATH и выполняется
так:
mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install
Также вы можете подготовить каталог для сборки с VPATH таким же образом, как это делает-
ся в коде ядра сервера. Как один из вариантов, для этого можно воспользоваться скриптом ядра
config/prep_buildtree. Затем вы сможете выполнить сборку, установив переменную VPATH для
make таким образом:
make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install
Эта процедура поддерживает самые разные расположения каталогов.
Скрипты, перечисленные в переменной REGRESS, используются для тестирования регрессии в ва-
шем модуле, и вызвать их можно командой make installcheck после make install. Для проведе-
ния тестов необходим работающий сервер PostgreSQL. Файлы скриптов, перечисленные в REGRESS,
должны размещаться в подкаталоге sql/ каталога расширения. Эти файлы должны иметь рас-
ширение .sql, но указывать его в списке REGRESS в сборочном файле не нужно. Для каждого те-
ста также должен создаваться файл с ожидаемым выводом в подкаталоге expected/, с тем же ба-
зовым именем и расширением .out. Команда make installcheck выполнит каждый тест в psql
и сравнит полученный вывод с ожидаемым. Все выявленные различия будут записаны в файл
regression.diffs в формате команды diff -c. Заметьте, что при попытке запустить тест без файла
ожидаемого вывода этот тест будет отмечен как «проблемный», поэтому убедитесь, что все такие
файлы присутствуют.
Подсказка
Проще всего для этого создать пустые файлы ожидаемого вывода, а затем выполнить
тест (при этом конечно будут выявлены несоответствия). Изучите полученные файлы
результатов, сохранённые в каталоге results/, и, если они соответствуют вашим ожи-
даниям от теста, скопируйте их в expected/.
</string.h>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-038/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-038/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-038/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-037/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Script_bash-copy-ftp/" title="Копируем на FTP скриптом bash">Копируем на FTP скриптом bash</a></h3>
      <p>Bash FTP script copy <a href="http://localhost:4000/Script_bash-copy-ftp/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Work-Project-Manager/" title="Коротко - работа менеджера проектов">Коротко - работа менеджера проектов</a></h4>
        <span>Published on December 04, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
