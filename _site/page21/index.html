<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page21/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page21/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-018/" title="Глава 18. Подготовка к работе и сопровождение сервера"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 18. Подготовка к работе и сопровождение сервера"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-018/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~52 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-018/" rel="bookmark" title="Глава 18. Подготовка к работе и сопровождение сервера" itemprop="url">Глава 18. Подготовка к работе и сопровождение сервера</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 18. Подготовка к работе и сопровождение сервера</p>

<p>В этой главе рассказывается, как организовать работу сервера баз данных и его взаимодействие с
операционной системой, а также о некоторых задачах сопровождения.
18.1. Учётная запись пользователя PostgreSQL
Как и любую другую службу, доступную для внешнего мира, PostgreSQL рекомендуется запускать
под именем отдельного пользователя. Эта учётная запись должна владеть только данными, кото-
рыми управляет сервер, и разделять её с другими службами не следует. (Например, не стоит ис-
пользовать для этого пользователя nobody.) Также рекомендуется не устанавливать под именем
этого пользователя исполняемые файлы, чтобы их нельзя было подменить в случае компромета-
ции системы.
Для создания пользователя в Unix-подобной системе следует искать команду useradd или adduser.
В качестве имени пользователя часто используется postgres, и именно это имя предполагается в
данной документации, но вы можете выбрать и другое, если захотите.
18.2. Создание кластера баз данных
Прежде чем вы сможете работать с базами данных, вы должны проинициализировать область хра-
нения баз данных на диске. Мы называем это хранилище кластером баз данных. (В SQL приме-
няется термин «кластер каталога».) Кластер баз данных представляет собой набор баз, управля-
емых одним экземпляром работающего сервера. После инициализации кластер будет содержать
базу данных с именем postgres, предназначенную для использования по умолчанию утилитами,
пользователями и сторонними приложениями. Сам сервер баз данных не требует наличия базы
postgres, но многие внешние вспомогательные программы рассчитывают на её существование.
При инициализации в каждом кластере создаётся ещё одна база, с именем template1. Как мож-
но понять из имени, она применяется впоследствии в качестве шаблона создаваемых баз данных;
использовать её в качестве рабочей не следует. (За информацией о создании новых баз данных в
кластере обратитесь к Главе 22.)
С точки зрения файловой системы, кластер баз данных представляет собой один каталог, в кото-
ром будут храниться все данные. Мы называем его каталогом данных или областью данных. Где
именно хранить данные, вы абсолютно свободно можете выбирать сами. Какого-либо стандартно-
го пути не существует, но часто данные размещаются в /usr/local/pgsql/data или в /var/lib/
pgsql/data. Для инициализации кластера баз данных применяется команда initdb,которая уста-
навливается в составе PostgreSQL. Расположение кластера базы данных в файловой системе зада-
ётся параметром -D, например:
$ initdb -D /usr/local/pgsql/data
Заметьте, что эту команду нужно выполнять от имени учётной записи PostgreSQL, о которой гово-
рится в предыдущем разделе.
Подсказка
В качестве альтернативы параметра -D можно установить переменную окружения
PGDATA.
Также можно запустить команду initdb, воспользовавшись программой pg_ctl , примерно так:
$ pg_ctl -D /usr/local/pgsql/data initdb
Этот вариант может быть удобнее, если вы используете pg_ctl для запуска и остановки сервера
(см. Раздел  18.3), так как pg_ctl будет единственной командой, с помощью которой вы будете
управлять экземпляром сервера баз данных.
478Подготовка к работе и
сопровождение сервера
Команда initdb попытается создать указанный вами каталог, если он не существует. Конечно,
она не сможет это сделать, если initdb не будет разрешено записывать в родительский каталог.
Вообще рекомендуется, чтобы пользователь PostgreSQL был владельцем не только каталога дан-
ных, но и родительского каталога, так что такой проблемы быть не должно. Если же и нужный
родительский каталог не существует, вам нужно будет сначала создать его, используя права root,
если вышестоящий каталог защищён от записи. Таким образом, процедура может быть такой:
root# mkdir /usr/local/pgsql
root# chown postgres /usr/local/pgsql
root# su postgres
postgres$ initdb -D /usr/local/pgsql/data
Команда initdb не будет работать, если указанный каталог данных уже существует и содержит
файлы; это мера предохранения от случайной перезаписи существующей инсталляции.
Так как каталог данных содержит все данные базы, очень важно защитить его от неавторизованно-
го доступа. Для этого initdb лишает прав доступа к нему всех пользователей, кроме пользователя
PostgreSQL и, возможно, его группы. Если группе разрешается доступ, то только для чтения. Это
позволяет непривилегированному пользователю, входящему в одну группу с владельцем кластера,
делать резервные копии данных кластера или выполнять другие операции, для которых достаточ-
но доступа только для чтения.
Заметьте, чтобы корректно разрешить или запретить доступ группы к данным существующего кла-
стера, необходимо выключить кластер и установить соответствующий режим для всех каталогов и
файлов до запуска PostgreSQL. В противном случае в каталоге данных возможно смешение режи-
мов. Для кластеров, к которым имеет доступ только владелец, требуется установить режим 0700
для каталогов и 0600 для файлов, а для кластеров, в которых также разрешается чтение группой,
режим 0750 для каталогов и 0640 для файлов.
Однако, даже когда содержимое каталога защищено, если проверка подлинности клиентов на-
строена по умолчанию, любой локальный пользователь может подключиться к базе данных и да-
же стать суперпользователем. Если вы не доверяете другим локальным пользователям, мы реко-
мендуем использовать один из параметров команды initdb: -W, –pwprompt или –pwfile и назна-
чить пароль суперпользователя баз данных. Кроме того, воспользуйтесь параметром -A md5 или -A
password и отключите разрешённый по умолчанию режим аутентификации trust; либо измените
сгенерированный файл pg_hba.conf после выполнения initdb, но перед тем, как запустить сервер
в первый раз. (Возможны и другие разумные подходы — применить режим проверки подлинности
peer или ограничить подключения на уровне файловой системы. За дополнительными сведениями
обратитесь к Главе 20.)
Команда initdb также устанавливает для кластера баз данных локаль по умолчанию. Обычно она
просто берёт параметры локали из текущего окружения и применяет их к инициализируемой базе
данных. Однако можно выбрать и другую локаль для базы данных; за дополнительной информа-
цией обратитесь к Разделу  23.1. Команда initdb задаёт порядок сортировки по умолчанию для
применения в определённом кластере баз данных, и хотя новые базы данных могут создаваться
с иным порядком сортировки, порядок в базах-шаблонах, создаваемых initdb, можно изменить,
только если удалить и пересоздать их. Также учтите, что при использовании локалей, отличных
от C и POSIX, возможно снижение производительности. Поэтому важно правильно выбрать локаль
с самого начала.
Команда initdb также задаёт кодировку символов по умолчанию для кластера баз данных. Обычно
она должна соответствовать кодировке локали. За подробностями обратитесь к Разделу 23.3.
Для локалей, отличных от C и POSIX, порядок сортировки символов зависит от системной библио-
теки локализации, а он, в свою очередь, влияет на порядок ключей в индексах. Поэтому кластер
нельзя перевести на несовместимую версию библиотеки ни путём восстановления снимка, ни че-
рез двоичную репликацию, ни перейдя на другую операционную систему или обновив её версию.
18.2.1. Использование дополнительных файловых систем
479Подготовка к работе и
сопровождение сервера
Во многих инсталляциях кластеры баз данных создаются не в «корневом» томе, а в отдельных
файловых системах (томах). Если вы решите сделать так же, то не следует выбирать в качестве ка-
талога данных самый верхний каталог дополнительного тома (точку монтирования). Лучше всего
создать внутри каталога точки монтирования каталог, принадлежащий пользователю PostgreSQL,
а затем создать внутри него каталог данных. Это исключит проблемы с разрешениями, особенно
для таких операций, как pg_upgrade, и при этом гарантирует чистое поведение в случае, если до-
полнительный том окажется отключён.
18.2.2. Использование сетевых файловых систем
Во многих инсталляциях кластеры баз данных создаются в сетевых файловых ресурсах. Иногда
это реализуется с применением сетевой файловой системы (NFS, Network File System) или сете-
вых хранилищ (NAS, Network Attached Storage), использующих NFS внутри. PostgreSQL не делает
ничего специфического с файловыми системами NFS, то есть он предполагает, что NFS работает
точно так же, как и локально подключённые диски. Но если реализация клиента или сервера NFS
не обеспечивает стандартное поведение файловой системы, это чревато нестабильной работой (см.
https://www.time-travellers.org/shane/papers/NFS_considered_harmful.html). В частности, возможно
разрушение данных при отложенной (асинхронной) записи на сервер NFS. Поэтому, по возможно-
сти, во избежание таких проблем монтируйте файловые системы NFS в синхронном режиме (без
кеширования). Кроме того, не рекомендуется применять мягкое монтирование файловой системы
NFS.
В сетях хранения данных (SAN, Storage Area Networks) обычно используются собственные прото-
колы, не NFS, и они могут быть не подвержены (а могут быть и подвержены) этим рискам. По во-
просам гарантии согласованности данных обратитесь к документации производителя. PostgreSQL
не может быть надёжнее файловой системы, которую он использует.
18.3. Запуск сервера баз данных
Чтобы кто-либо смог обратиться к базе данных, необходимо сначала запустить сервер баз данных.
Программа сервера называется postgres.Для работы программа postgres должна знать, где найти
данные, которые она будет использовать. Указать это местоположение позволяет параметр -D.
Таким образом, проще всего запустить сервер, выполнив команду:
$ postgres -D /usr/local/pgsql/data
в результате которой сервер продолжит работу в качестве процесса переднего плана. Запускать
эту команду следует под именем учётной записи PostgreSQL. Без параметра -D сервер попытается
использовать каталог данных, указанный в переменной окружения PGDATA. Если и эта переменная
не определена, сервер не будет запущен.
Однако обычно лучше запускать postgres в фоновом режиме. Для этого можно применить обыч-
ный синтаксис, принятый в оболочке Unix:
$ postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;
Важно где-либо сохранять информацию, которую выводит сервер в каналы stdout и stderr, как по-
казано выше. Это полезно и для целей аудита, и для диагностики проблем. (Более глубоко работа
с файлами журналов рассматривается в Разделе 24.3.)
Программа postgres также принимает несколько других параметров командной строки. За допол-
нительными сведениями обратитесь к справочной странице postgres и к следующей Главе 19.
Такой вариант запуска довольно быстро может оказаться неудобным. Поэтому для упрощения по-
добных задач предлагается вспомогательная программа pg_ctl. Например:
pg_ctl start -l logfile
запустит сервер в фоновом режиме и направит выводимые сообщения сервера в указанный файл
журнала. Параметр -D для неё имеет то же значение, что и для программы postgres. С помощью
pg_ctl также можно остановить сервер.
Обычно возникает желание, чтобы сервер баз данных сам запускался при загрузке операционной
системы.Скрипты автозапуска для разных систем разные, но в составе PostgreSQL предлагается
480Подготовка к работе и
сопровождение сервера
несколько типовых скриптов в каталоге contrib/start-scripts. Для установки такого скрипта в
систему требуются права root.
В различных системах приняты разные соглашения о порядке запуска служб в процессе загрузки.
Во многих системах для этого используется файл /etc/rc.local или /etc/rc.d/rc.local. В других
применяются каталоги init.d или rc.d. Однако при любом варианте запускаться сервер должен
от имени пользователя PostgreSQL, но не root или какого-либо другого пользователя. Поэтому ко-
манду запуска обычно следует записывать в форме su postgres -c ‘…’. Например:
su postgres -c ‘pg_ctl start -D /usr/local/pgsql/data -l serverlog’
Ниже приведены более конкретные предложения для нескольких основных ОС. (Вместо указан-
ных нами шаблонных значений необходимо подставить правильный путь к каталогу данных и фак-
тическое имя пользователя.)
• Для запуска во FreeBSD воспользуйтесь файлом contrib/start-scripts/freebsd в дереве ис-
ходного кода PostgreSQL.
• В OpenBSD, добавьте в файл /etc/rc.local следующие строки:
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
su -l postgres -c ‘/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -
D /usr/local/pgsql/data’
echo -n ‘ postgresql’
fi
• В системах Linux вы можете либо добавить
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
в /etc/rc.d/rc.local или в /etc/rc.local, либо воспользоваться файлом contrib/start-
scripts/linux в дереве исходного кода PostgreSQL.
Используя systemd, вы можете применить следующий файл описания службы (например, /
etc/systemd/system/postgresql.service):
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)
[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0
[Install]
WantedBy=multi-user.target
Для использования Type=notify требуется, чтобы сервер был скомпилирован с указанием
configure –with-systemd.
Особого внимания заслуживает значение тайм-аута. На момент написания этой документации
по умолчанию в systemd принят тайм-аут 90 секунд, так что процесс, не сообщивший о своей
готовности за это время, будет уничтожен. Но серверу PostgreSQL при запуске может потре-
боваться выполнить восстановление после сбоя, так что переход в состояние готовности мо-
жет занять гораздо больше времени. Предлагаемое значение 0 отключает логику тайм-аута.
• В NetBSD можно использовать скрипт запуска для FreeBSD или для Linux, в зависимости от
предпочтений.
481Подготовка к работе и
сопровождение сервера
• В Solaris, создайте файл с именем /etc/init.d/postgresql, содержащий следующую стоку:
su - postgres -c “/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/
data”
Затем создайте символическую ссылку на него в каталоге /etc/rc3.d с именем
S99postgresql.
Когда сервер работает, идентификатор его процесса (PID) сохраняется в файле postmaster.pid в
каталоге данных. Это позволяет исключить запуск нескольких экземпляров сервера с одним ката-
логом данных, а также может быть полезно для выключения сервера.
18.3.1. Сбои при запуске сервера
Есть несколько распространённых причин, по которым сервер может не запуститься. Чтобы по-
нять, чем вызван сбой, просмотрите файл журнала сервера или запустите сервер вручную (не пе-
ренаправляя его потоки стандартного вывода и ошибок) и проанализируйте выводимые сообще-
ния. Ниже мы рассмотрим некоторые из наиболее частых сообщений об ошибках более подробно.
LOG: could not bind IPv4 address “127.0.0.1”: Address already in use
HINT: Is another postmaster already running on port 5432? If not, wait a few seconds
and retry.
FATAL: could not create any TCP/IP sockets
Это обычно означает именно то, что написано: вы пытаетесь запустить сервер на том же порту,
на котором уже работает другой. Однако, если сообщение ядра не Address already in use или
подобное, возможна и другая проблема. Например, при попытке запустить сервер с номером за-
резервированного порта будут выданы такие сообщения:
$ postgres -p 666
LOG: could not bind IPv4 address “127.0.0.1”: Permission denied
HINT: Is another postmaster already running on port 666? If not, wait a few seconds
and retry.
FATAL: could not create any TCP/IP sockets
Следующее сообщение:
FATAL: could not create shared memory segment: Invalid argument
DETAIL: Failed system call was shmget(key=5440001, size=4011376640, 03600).
может означать, что установленный для вашего ядра предельный размер разделяемой памяти
слишком мал для рабочей области, которую пытается создать PostgreSQL (в данном примере
4011376640 байт). Возможно также, что в вашем ядре вообще отсутствует поддержка разделяемой
памяти в стиле System-V. В качестве временного решения можно попытаться запустить сервер с
меньшим числом буферов (shared_buffers), но в итоге вам, скорее всего, придётся переконфигури-
ровать ядро и увеличить допустимый размер разделяемой памяти. Вы также можете увидеть это
сообщение при попытке запустить несколько серверов на одном компьютере, если запрошенный
ими объём разделяемой памяти в сумме превышает этот предел.
Сообщение:
FATAL: could not create semaphores: No space left on device
DETAIL: Failed system call was semget(5440126, 17, 03600).
не означает, что у вас закончилось место на диске. Это значит, что установленное в вашем ядре
предельное число семафоров System V меньше, чем количество семафоров, которое пытается со-
здать PostgreSQL. Как и в предыдущем случае, можно попытаться обойти эту проблему, запустив
сервер с меньшим числом допустимых подключений (max_connections), но в конце концов вам при-
дётся увеличить этот предел в ядре.
Если вы получаете ошибку «illegal system call» (неверный системный вызов), то, вероятнее всего,
ваше ядро вовсе не поддерживает разделяемую память или семафоры. В этом случае, вам остаётся
только переконфигурировать ядро и включить их поддержку.
Настройка средств IPC в стиле System V описывается в Подразделе 18.4.1.
482Подготовка к работе и
сопровождение сервера
18.3.2. Проблемы с подключениями клиентов
Хотя ошибки подключений, возможные на стороне клиента, довольно разнообразны и зависят от
приложений, всё же несколько проблем могут быть связаны непосредственно с тем, как был за-
пущен сервер. Описание ошибок, отличных от описанных ниже, следует искать в документации
соответствующего клиентского приложения.
psql: could not connect to server: Connection refused
Is the server running on host “server.joe.com” and accepting
TCP/IP connections on port 5432?
Это общая проблема «я не могу найти сервер и начать взаимодействие с ним». Показанное выше
сообщение говорит о попытке установить подключение по TCP/IP. Очень часто объясняется это
тем, что сервер просто забыли настроить для работы по протоколу TCP/IP.
Кроме того, при попытке установить подключение к локальному серверу через Unix-сокет можно
получить такое сообщение:
psql: could not connect to server: No such file or directory
Is the server running locally and accepting
connections on Unix domain socket “/tmp/.s.PGSQL.5432”?
Путь в последней строке помогает понять, к правильному ли адресу пытается подключиться кли-
ент. Если сервер на самом деле не принимает подключения по этому адресу, обычно выдаётся
сообщение ядра Connection refused (В соединении отказано) или No such file or directory
(Нет такого файла или каталога), приведённое выше. (Важно понимать, что Connection refused
в данном контексте не означает, что сервер получил запрос на подключение и отверг его. В этом
случае были бы выданы другие сообщения, например, показанные в Разделе 20.15.) Другие сооб-
щения об ошибках, например Connection timed out (Тайм-аут соединения) могут сигнализировать
о более фундаментальных проблемах, например, о нарушениях сетевых соединений.
18.4. Управление ресурсами ядра
PostgreSQL иногда может исчерпывать некоторые ресурсы операционной системы до предела, осо-
бенно при запуске нескольких копий сервера в одной системе или при работе с очень большими
базами. В этом разделе описываются ресурсы ядра, которые использует PostgreSQL, и подходы к
решению проблем, связанных с ограниченностью этих ресурсов.
18.4.1. Разделяемая память и семафоры
PostgreSQL требует, чтобы операционная система предоставляла средства межпроцессного взаи-
модействия (IPC), в частности, разделяемую память и семафоры. Системы семейства Unix обычно
предоставляют функции IPC в стиле «System V» или функции IPC в стиле «POSIX» или и те, и дру-
гие. В Windows эти механизмы реализованы по-другому, но здесь это не рассматривается.
Если эти механизмы полностью отсутствуют в системе, при запуске сервера обычно выдаётся
ошибка «Illegal system call» (Неверный системный вызов). В этом случае единственный способ ре-
шить проблему — переконфигурировать ядро системы. Без них PostgreSQL просто не будет рабо-
тать. Это довольно редкая ситуация, особенно с современными операционными системами.
При запуске сервера PostgreSQL обычно запрашивает очень небольшой объём разделяемой памя-
ти System V и намного больший объём памяти POSIX (mmap). Помимо этого при запуске создаётся
значительное количество семафоров (в стиле System V или POSIX). В настоящее время семафоры
POSIX используются в системах Linux и FreeBSD, а на других платформах используются семафоры
System V.
Примечание
PostgreSQL до версии 9.3 использовал только разделяемую память System V, поэтому
необходимый для запуска сервера объём разделяемой памяти System V был гораздо
483Подготовка к работе и
сопровождение сервера
больше. Если вы используете более раннюю версию сервера, обратитесь к документа-
ции по вашей версии.
Функции IPC в стиле System V обычно сталкиваются с лимитами на уровне системы. Когда
PostgreSQL превышает один из этих лимитов, сервер отказывается запускаться, но должен выдать
полезное сообщение, говорящее об ошибке и о том, что с ней делать. (См. также Подраздел 18.3.1.)
Соответствующие параметры ядра в разных системах называются аналогично (они перечислены
в Таблице 18.1), но устанавливаются по-разному. Ниже предлагаются способы их изменения для
некоторых систем.
Таблица 18.1. Параметры IPC в стиле System V
Имя Описание
Значения, необходимые для
запуска одного экземпляра
PostgreSQL
SHMMAX Максимальный размер сегмен- как минимум 1 КБ, но значение
та разделяемой памяти (в бай- по умолчанию обычно гораздо
тах)
больше
SHMMIN Минимальный размер сегмента 1
разделяемой памяти (в байтах)
SHMALL Общий объём доступной разде- если в байтах, то же, что
ляемой памяти (в байтах или и SHMMAX; если в страницах,
страницах)
то ceil(SHMMAX/PAGE_SIZE) ,
плюс потребность других при-
ложений
SHMSEG Максимальное число сегментов требуется только 1 сегмент, но
разделяемой памяти для про- значение по умолчанию гораз-
цесса
до больше
SHMMNI Максимальное число сегментов как SHMSEG плюс потребность
разделяемой памяти для всей других приложений
системы
SEMMNI Максимальное число идентифи- как
минимум
ceil((max_
каторов семафоров (т. е., их на- connections + autovacuum_
боров)
max_workers + max_worker_
processes + 5) / 16) плюс по-
требность других приложений
SEMMNS Максимальное число семафо- ceil((max_connections
+
ров для всей системы
autovacuum_max_workers
+
max_worker_processes + 5) /
16) * 17 плюс потребность дру-
гих приложений
SEMMSL Максимальное число семафо- не меньше 17
ров в наборе
SEMMAP Число записей в карте семафо- см. текст
ров
SEMVMX Максимальное значение сема- не меньше 1000 (по умолчанию
фора
оно обычно равно 32767; без
необходимости менять его не
следует)
PostgreSQL запрашивает небольшой блок разделяемой памяти System V (обычно 48 байт на 64-
битной платформе) для каждой копии сервера. В большинстве современных операционных систем
такой объём выделяется без проблем. Однако, если запускать много копий сервера или разделяе-
484Подготовка к работе и
сопровождение сервера
мую память System V занимают и другие приложения, может понадобиться увеличить значение
SHMALL, задающее общий объём разделяемой памяти System V, доступный для всей системы. За-
метьте, что SHMALL во многих системах задаётся в страницах, а не в байтах.
Менее вероятны проблемы с минимальным размером сегментов разделяемой памяти (SHMMIN), ко-
торый для PostgreSQL не должен превышать примерно 32 байт (обычно это всего 1 байт). Макси-
мальное число сегментов для всей системы (SHMMNI) или для одного процесса (SHMSEG) тоже обыч-
но не влияет на работоспособность сервера, если только это число не равно нулю.
Когда PostgreSQL использует семафоры System V, он занимает по одному семафору на одно
разрешённое подключение (max_connections), на разрешённый рабочий процесс автоочистки
(autovacuum_max_workers) и фоновый процесс (max_worker_processes), в наборах по 16. В каждом
таком наборе есть также 17-ый семафор, содержащий «магическое число», позволяющий обнару-
живать коллизии с наборами семафоров других приложений. Максимальное число семафоров в си-
стеме задаётся параметром SEMMNS, который, следовательно, должен быть равен как минимум сум-
ме max_connections, autovacuum_max_workers и max_worker_processes, плюс один дополнитель-
ный на каждые 16 семафоров подключений и рабочих процессов (см. формулу в Таблице  18.1).
Параметр SEMMNI определяет максимальное число наборов семафоров, которые могут существо-
вать в системе в один момент времени. Таким образом, этот параметр должен быть не меньше
ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16). В ка-
честве временного решения проблем, которые вызваны этими ограничениями, но обычно сопро-
вождаются некорректными сообщениями, например, «No space left on device» (На устройстве не
осталось места) от функции semget, можно уменьшить число разрешённых соединений
В некоторых случаях может потребоваться увеличить SEMMAP как минимум до уровня SEMMNS. Этот
параметр определяет размер карты ресурсов семафоров, в которой выделяется запись для каж-
дого непрерывного блока семафоров. Когда набор семафоров освобождается, эта запись либо до-
бавляется к существующей соседней записи, либо регистрируется как новая запись в карте. Ес-
ли карта переполняется, освобождаемые семафоры теряются (до перезагрузки). Таким образом,
фрагментация пространства семафоров может со времени привести к уменьшению числа доступ-
ных семафоров.
Другие параметры, связанные с «аннулированием операций» с семафорами, например, SEMMNU и
SEMUME, на работу PostgreSQL не влияют.
При использовании семафоров POSIX требуемое их количество не отличается от количества
для System V, то есть по одному семафору на разрешённое подключение (max_connections),
на разрешённый рабочий процесс автоочистки (autovacuum_max_workers) и фоновый процесс
(max_worker_processes). На платформах, где предпочитается этот вариант, отсутствует определён-
ный лимит ядра на количество семафоров POSIX.
AIX
Как минимум с версии 5.1, для таких параметров, как SHMMAX, никакая дополнительная на-
стройка не должна требоваться, так как система, похоже, позволяет использовать всю память
в качестве разделяемой. Подобная конфигурация требуется обычно и для других баз данных,
например, для DB/2.
Однако может понадобиться изменить глобальные параметры ulimit в /etc/security/limits,
так как стандартные жёсткие ограничения на размер (fsize) и количество файлов (nofiles)
могут быть недостаточно большими.
FreeBSD
Значения по умолчанию можно изменить, используя возможности sysctl или loader. С помо-
щью sysctl можно задать следующие параметры:</p>
<h1 id="sysctl-kernipcshmall32768">sysctl kern.ipc.shmall=32768</h1>
<h1 id="sysctl-kernipcshmmax134217728">sysctl kern.ipc.shmmax=134217728</h1>
<p>Чтобы эти изменения сохранялись после перезагрузки, измените /etc/sysctl.conf.
485Подготовка к работе и
сопровождение сервера
Эти параметры, связанные с семафорами, sysctl менять не позволяет, но их можно задать в
/boot/loader.conf:
kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256
Чтобы изменённые таким образом параметры вступили в силу, требуется перезагрузить си-
стему. (Заметьте, что во FreeBSD нет параметра SEMMAP. В старых версиях значение для
kern.ipc.semmap принималось, но игнорировалось; новые версии его не принимают.)
Возможно, вы захотите настроить ядро так, чтобы разделяемая память всегда находилась в ОЗУ
и никогда не выгружалась в пространство подкачки. Это можно сделать, установив с помощью
sysctl параметр kern.ipc.shm_use_phys.
Если
вы
используете
«камеры»
FreeBSD,
включив
в
sysctl
параметр
security.jail.sysvipc_allowed, главные процессы postmaster, работающие в разных камерах,
должны запускаться разными пользователями операционной системы. Это усиливает защи-
ту, так как не позволяет обычным пользователям обращаться к разделяемой памяти или се-
мафорам в разных камерах, и при этом способствует корректной работе кода очистки IPC в
PostgreSQL. (Во FreeBSD 6.0 и более поздних версиях код очистки IPC не может корректно вы-
явить процессы в других камерах, что не позволяет запускать процессы postmaster на одном
порту в разных камерах.)
До версии 4.0 система FreeBSD работала так же, как сейчас OpenBSD (см. ниже).
NetBSD
В NetBSD, начиная с версии 5.0, параметры IPC можно изменить, воспользовавшись командой
sysctl, например:
$ sysctl -w kern.ipc.shmmax=16777216
Чтобы эти параметры сохранялись после перезагрузки, измените /etc/sysctl.conf.
Возможно, вы захотите настроить ядро так, чтобы разделяемая память всегда находилась в ОЗУ
и никогда не выгружалась в пространство подкачки. Это можно сделать, установив с помощью
sysctl параметр kern.ipc.shm_use_phys.
До версии 5.0 система NetBSD работала так же, как сейчас OpenBSD (см. ниже), за исключе-
нием того, что параметры устанавливаются с указанием options, а не option.
OpenBSD
При компиляции ядра должны быть включены механизмы SYSVSHM и SYSVSEM. (По умолча-
нию они включены.) Максимальный размер разделяемой памяти определяется параметром
SHMMAXPGS (в страницах). Ниже показан пример, как установить следующие параметры:
option
option
option SYSVSHM
SHMMAXPGS=4096
SHMSEG=256
option
option
option
option SYSVSEM
SEMMNI=256
SEMMNS=512
SEMMNU=256
HP-UX
Значения по умолчанию обычно вполне удовлетворяют средним потребностям. В HP-UX 10 па-
раметр SEMMNS по умолчанию имеет значение 128, что может быть недостаточно для больших
баз данных.
486Подготовка к работе и
сопровождение сервера
Параметры IPC можно установить в менеджере системного администрирования (System
Administration Manager, SAM) в разделе Kernel Configuration (Настройка ядра) → Configurable
Parameters (Настраиваемые параметры). Установив нужные параметры, выполните операцию
Create A New Kernel (Создать ядро).
Linux
По умолчанию максимальный размер сегмента равен 32 МБ, а максимальный общий размер
составляет 2097152 страниц. Страница почти всегда содержит 4096 байт, за исключением
нестандартных конфигураций ядра с поддержкой «огромных страниц» (точно узнать размер
страницы можно, выполнив getconf PAGE_SIZE).
Параметры размера разделяемой памяти можно изменить, воспользовавшись командой
sysctl. Например, так можно выделить 16 ГБ для разделяемой памяти:
$ sysctl -w kernel.shmmax=17179869184
$ sysctl -w kernel.shmall=4194304
Чтобы сохранить эти изменения после перезагрузки, их также можно записать в файл /etc/
sysctl.conf (это настоятельно рекомендуется).
В некоторых старых дистрибутивах может не оказаться программы sysctl, но те же изменения
можно произвести, обратившись к файловой системе /proc:
$ echo 17179869184 &gt;/proc/sys/kernel/shmmax
$ echo 4194304 &gt;/proc/sys/kernel/shmall
Остальные параметры имеют вполне подходящие значения, так что их обычно менять не нуж-
но.
macOS
Для настройки разделяемой памяти в macOS рекомендуется создать файл /etc/sysctl.conf и
записать в него присвоения переменных следующим образом:
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
Заметьте, что в некоторых версиях macOS, все пять параметров разделяемой памяти должны
быть установлены в /etc/sysctl.conf, иначе их значения будут проигнорированы.
Имейте в виду, что последние версии macOS игнорируют попытки задать для SHMMAX значение,
не кратное 4096.
SHMALL на этой платформе измеряется в страницах (по 4 КБ).
В старых версиях macOS, чтобы изменения параметров разделяемой памяти вступили в силу,
требовалась перезагрузка. Начиная с версии 10.5, все параметры, кроме SHMMNI можно изме-
нить «на лету», воспользовавшись командой sysctl. Но, тем не менее, лучше задавать выбран-
ные вами значения в /etc/sysctl.conf, чтобы они сохранялись после перезагрузки.
Файл /etc/sysctl.conf обрабатывается только начиная с macOS версии 10.3.9. Если вы ис-
пользуете предыдущий выпуск 10.3.x, необходимо отредактировать файл /etc/rc и задать зна-
чения следующими командами:
sysctl
sysctl
sysctl
sysctl
-w
-w
-w
-w
kern.sysv.shmmax
kern.sysv.shmmin
kern.sysv.shmmni
kern.sysv.shmseg
487Подготовка к работе и
сопровождение сервера
sysctl -w kern.sysv.shmall
Заметьте, что /etc/rc обычно заменяется при обновлении системы macOS, так что следует
ожидать, что вам придётся повторять эти изменения после каждого обновления.
В macOS 10.2 и более ранних версиях вместо этого надо записать эти команды в файле /System/
Library/StartupItems/SystemTuning/SystemTuning.
Solaris версии с 2.6 по 2.9 (Solaris 6 .. Solaris 9)
Соответствующие параметры можно изменить в /etc/system, например так:
set
set
set
set shmsys:shminfo_shmmax=0x2000000
shmsys:shminfo_shmmin=1
shmsys:shminfo_shmmni=256
shmsys:shminfo_shmseg=256
set
set
set
set semsys:seminfo_semmap=256
semsys:seminfo_semmni=512
semsys:seminfo_semmns=512
semsys:seminfo_semmsl=32
Чтобы изменения вступили в силу, потребуется перегрузить систему. Информацию о разделя-
емой памяти в более старых версиях Solaris можно найти по ссылке http://sunsite.uakom.sk/
sunworldonline/swol-09-1997/swol-09-insidesolaris.html.
Solaris 2.10 (Solaris 10) и более поздние версии
OpenSolaris
В Solaris 10 и новее, а также в OpenSolaris, стандартные параметры разделяемой памяти и се-
мафоров достаточно хороши для большинства применений PostgreSQL. По умолчанию Solaris
теперь устанавливает в SHMMAX четверть объёма ОЗУ. Чтобы изменить этот параметр, восполь-
зуйтесь возможностью задать параметр проекта, связанного с пользователем postgres. Напри-
мер, выполните от имени root такую команду:
projadd -c “PostgreSQL DB User” -K “project.max-shm-memory=(privileged,8GB,deny)” -U
postgres -G postgres user.postgres
Эта команда создаёт проект user.postgres и устанавливает максимальный объём разделяемой
памяти для пользователя postgres равным 8 ГБ. Это изменение вступает в силу при следую-
щем входе этого пользователя или при перезапуске PostgreSQL (не перезагрузке конфигура-
ции). При этом подразумевается, что PostgreSQL выполняется пользователем postgres в груп-
пе postgres. Перезагружать систему после этой команды не нужно.
Для серверов баз данных, рассчитанных на большое количество подключений, рекомендуется
также изменить следующие параметры:
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
Кроме того, если PostgreSQL у вас выполняется внутри зоны, может понадобиться также
увеличить лимиты на использование ресурсов зоны. Получить дополнительную информацию
о проектах и команде prctl можно в Руководстве системного администратора (System
Administrator’s Guide), «Главе 2: Проекты и задачи» (Chapter2: Projects and Tasks).
18.4.2. RemoveIPC в systemd
Если используется systemd, необходимо позаботиться о том, чтобы ресурсы IPC (общая память и
семафоры) не освобождались преждевременно операционной системой. Это особенно актуально
при сборке и установке PostgreSQL из исходного кода. Пользователей дистрибутивных пакетов
PostgreSQL это касается в меньшей степени, так как пользователь postgres обычно создаётся как
системный пользователь.
488Подготовка к работе и
сопровождение сервера
Параметр RemoveIPC в logind.conf определяет, должны ли объекты IPC удаляться при полном вы-
ходе пользователя из системы. На системных пользователей это не распространяется. Этот пара-
метр по умолчанию включён в стандартной сборке systemd, но в некоторых дистрибутивах опера-
ционных систем он по умолчанию отключён.
Обычно нежелательный эффект этого включённого параметра проявляется в том, что объекты
семафоров, используемые сервером PostgreSQL, удаляются без видимых причин, что приводит к
отказу сервера с сообщениями вида:
LOG: semctl(1234567890, 0, IPC_RMID, …) failed: Invalid argument
Различные типы объектов IPC (разделяемая память/семафоры, System V/POSIX) обрабатываются
в systemd несколько по-разному, поэтому могут наблюдаться ситуации, когда некоторые ресурсы
IPC не удаляются так, как другие. Однако полагаться на эти тонкие различия не рекомендуется.
Событие «выхода пользователя из системы» может произойти при выполнении задачи обслужи-
вания или если администратор войдёт под именем postgres, а затем выйдет, либо случится что-
то подобное, так что предотвратить это довольно сложно.
Какой пользователь является «системным», определяется во время компиляции systemd, исходя
из значения SYS_UID_MAX в /etc/login.defs.
Скрипт упаковывания и развёртывания сервера должен предусмотрительно создавать пользовате-
ля postgres как системного пользователя, используя команды useradd -r, adduser –system или
равнозначные.
Если же учётная запись пользователя была создана некорректно и изменить её невозможно, ре-
комендуется задать
RemoveIPC=no
в /etc/systemd/logind.conf или другом подходящем файле конфигурации.
Внимание
Необходимо предпринять минимум одно из этих двух действий, иначе сервер
PostgreSQL будет очень нестабильным.
18.4.3. Ограничения ресурсов
В Unix-подобных операционных системах существуют различные типы ограничений ресурсов, ко-
торые могут влиять на работу сервера PostgreSQL. Особенно важны ограничения на число про-
цессов для пользователя, число открытых файлов и объём памяти для каждого процесса. Каждое
из этих ограничений имеет «жёсткий» и «мягкий» предел. Мягкий предел действительно ограни-
чивает использование ресурса, но пользователь может увеличить его значение до жёсткого пре-
дела. Изменить жёсткий предел может только пользователь root. За изменение этих параметров
отвечает системный вызов setrlimit. Управлять этими ресурсами в командной строке позволяет
встроенная команда ulimit (в оболочках Bourne) и limit (csh). В системах семейства BSD различ-
ными ограничениями ресурсов, устанавливаемыми при входе пользователя, управляет файл /etc/
login.conf. За подробностями обратитесь к документации операционной системы. Для PostgreSQL
интерес представляют параметры maxproc, openfiles и datasize. Они могут задаваться, например
так:
default:\
…
:datasize-cur=256M:\
:maxproc-cur=256:\
:openfiles-cur=256:\
…
489Подготовка к работе и
сопровождение сервера
(Здесь -cur обозначает мягкий предел. Чтобы задать жёсткий предел, нужно заменить это окон-
чание на -max.)
Ядро также может устанавливать общесистемные ограничения на использование некоторых ре-
сурсов.
• В Linux максимальное число открытых файлов, которое поддерживает ядро, определяется в
спецфайле /proc/sys/fs/file-max. Изменить этот предел можно, записав другое число в этот
файл, либо добавив присваивание в файл /etc/sysctl.conf. Максимальное число файлов для
одного процесса задаётся при компиляции ядра; за дополнительными сведения обратитесь к /
usr/src/linux/Documentation/proc.txt.
Сервер PostgreSQL использует для обслуживания каждого подключения отдельный процесс, так
что возможное число процессов должно быть не меньше числа разрешённых соединений плюс
число процессов, требуемых для остальной системы. Это обычно не проблема, но когда в одной
системе работает множество серверов, предел может быть достигнут.
В качестве максимального числа открытых файлов по умолчанию обычно выбираются «социаль-
но-ориентированные» значения, позволяющие использовать одну систему нескольким пользова-
телям так, чтобы ни один из них не потреблял слишком много системных ресурсов. Если вы запус-
каете в системе несколько серверов, это должно вполне устраивать, но на выделенных машинах
может возникнуть желание увеличить этот предел.
С другой стороны, некоторые системы позволяют отдельным процессам открывать очень много
файлов и если это делают сразу несколько процессов, они могут легко исчерпать общесистемный
предел. Если вы столкнётесь с такой ситуацией, но не захотите менять общесистемное ограниче-
ние, вы можете ограничить использование открытых файлов сервером PostgreSQL, установив па-
раметр конфигурации max_files_per_process.
18.4.4. Чрезмерное выделение памяти в Linux
В Linux 2.4 и новее механизм виртуальной памяти по умолчанию работает не оптимально для
PostgreSQL. Вследствие того, что ядро выделяет память в чрезмерном объёме, оно может уничто-
жить главный управляющий процесс PostgreSQL (postmaster), если при выделении памяти процес-
су PostgreSQL или другому процессу виртуальная память будет исчерпана.
Когда это происходит, вы можете получить примерно такое сообщение ядра (где именно искать
это сообщение, можно узнать в документации вашей системы):
Out of Memory: Killed process 12345 (postgres).
Это сообщение говорит о том, что процесс postgres был уничтожен из-за нехватки памяти. Хотя
существующие подключения к базе данных будут работать по-прежнему, новые подключения при-
ниматься не будут. Чтобы восстановить работу сервера, PostgreSQL придётся перезапустить.
Один из способов обойти эту проблему — запускать PostgreSQL на компьютере, где никакие другие
процессы не займут всю память. Если физической памяти недостаточно, решить проблему также
можно, увеличив объём пространства подкачки, так как уничтожение процессов при нехватке па-
мяти происходит только когда заканчивается и физическая память, и место в пространстве под-
качки.
Если памяти не хватает по вине самого PostgreSQL, эту проблему можно решить, изменив конфи-
гурацию сервера. В некоторых случаях может помочь уменьшение конфигурационных парамет-
ров, связанных с памятью, а именно shared_buffers и work_mem. В других случаях проблема может
возникать, потому что разрешено слишком много подключений к самому серверу баз данных. Ча-
ще всего в такой ситуации стоит уменьшить число подключений max_connections и организовать
внешний пул соединений.
В Linux 2.6 и новее «чрезмерное выделение» памяти можно предотвратить, изменив поведение
ядра. Хотя при этом OOM killer (уничтожение процессов при нехватке памяти) всё равно может
вызываться, вероятность такого уничтожения значительно уменьшается, а значит поведение си-
490Подготовка к работе и
сопровождение сервера
стемы становится более стабильным. Для этого нужно включить режим строгого выделения памя-
ти, воспользовавшись sysctl:
sysctl -w vm.overcommit_memory=2
либо поместив соответствующую запись в /etc/sysctl.conf. Возможно, вы также захотите изме-
нить связанный параметр vm.overcommit_ratio. За подробностями обратитесь к документации яд-
ра https://www.kernel.org/doc/Documentation/vm/overcommit-accounting.
Другой
подход,
который
можно
применить
(возможно,
вместе
с
изменением
vm.overcommit_memory), заключается в исключении процесса postmaster из числа возможных
жертв при нехватке памяти. Для этого нужно задать для свойства поправка очков OOM этого про-
цесса значение -1000. Проще всего это можно сделать, выполнив
echo -1000 &gt; /proc/self/oom_score_adj
в скрипте запуска управляющего процесса непосредственно перед тем, как запускать postmaster.
Заметьте, что делать это надо под именем root, иначе ничего не изменится; поэтому проще всего
вставить эту команду в стартовый скрипт, принадлежащий пользователю root. Если вы делаете
это, вы также должны установить в данном скрипте эти переменные окружения перед запуском
главного процесса:
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
С такими параметрами дочерние процессы главного будут запускаться с обычной, нулевой поправ-
кой очков OOM, так что при необходимости механизм OOM сможет уничтожать их. Вы можете за-
дать и другое значение для PG_OOM_ADJUST_VALUE, если хотите, чтобы дочерние процессы исполня-
лись с другой поправкой OOM. (PG_OOM_ADJUST_VALUE также можно опустить, в этом случае подра-
зумевается нулевое значение.) Если вы не установите PG_OOM_ADJUST_FILE, дочерние процессы бу-
дут работать с той же поправкой очков OOM, которая задана для главного процесса, что неразум-
но, так всё это делается как раз для того, чтобы главный процесс оказался на особом положении.
В старых ядрах Linux /proc/self/oom_score_adj отсутствует, но та же функциональность может
быть доступна через /proc/self/oom_adj. Эта переменная процесса работает так же, только зна-
чение, исключающее уничтожение процесса, равно -17, а не -1000.
Примечание
Некоторые дистрибутивы с ядрами Linux 2.4 содержат предварительную реализацию
механизма sysctl overcommit, появившегося официально в 2.6. Однако, если устано-
вить для vm.overcommit_memory значение 2 в ядре 2.4, ситуация не улучшится, а толь-
ко ухудшится. Прежде чем модифицировать этот параметр в ядре 2.4, рекомендуется
проанализировать исходный код вашего ядра (см. функцию vm_enough_memory в файле
mm/mmap.c) и убедиться, что ядро поддерживает именно нужный вам режим. Наличие
файла документации overcommit-accounting не следует считать признаком того, что
он действительно поддерживается. В случае сомнений, обратитесь к эксперту по ядру
или поставщику вашей системы.
18.4.5. Огромные страницы в Linux
Использование огромных страниц снижает накладные расходы при работе с большими непре-
рывными блоками памяти, что характерно для PostgreSQL, особенно при большом объёме
shared_buffers. Чтобы такие страницы можно было задействовать в PostgreSQL, ядро должно быть
собрано с параметрами CONFIG_HUGETLBFS=y и CONFIG_HUGETLB_PAGE=y. Также вам понадобится на-
строить параметр ядра vm.nr_hugepages. Чтобы оценить требуемое количество огромных страниц,
запустите PostgreSQL без поддержки огромных страниц и определите размер сегмента анонимной
разделяемой памяти процесса postmaster, а также узнайте размер огромной страницы, воспользо-
вавшись файловой системой /proc. Например, вы можете получить:
491Подготовка к работе и
сопровождение сервера
$ head -1 $PGDATA/postmaster.pid
4170
$ pmap 4170 | awk ‘/rw-s/ &amp;&amp; /zero/ {print $2}’
6490428K
$ grep ^Hugepagesize /proc/meminfo
Hugepagesize:
2048 kB
В данном случае 6490428 / 2048 даёт примерно 3169.154, так что нам потребуется минимум 3170
огромных страниц, и мы можем задать это значение так:
$ sysctl -w vm.nr_hugepages=3170
Большее значение стоит указать, если огромные страницы будут использоваться и другими про-
граммами в этой системе. Не забудьте добавить этот параметр в /etc/sysctl.conf, чтобы он дей-
ствовал и после перезагрузки.
Иногда ядро не может выделить запрошенное количество огромных страниц сразу, поэтому может
потребоваться повторить эту команду или перезагрузить систему. (Немедленно после перезагруз-
ки должен быть свободен больший объём памяти для преобразования в огромные страницы.) Что-
бы проверить текущую ситуацию с размещением огромных страниц, выполните:
$ grep Huge /proc/meminfo
Также может потребоваться дать пользователю операционной системы, запускающему сервер БД,
право использовать огромные страницы, установив его группу в vm.hugetlb_shm_group с помощью
sysctl, и/или разрешить блокировать память, выполнив ulimit -l.
По умолчанию PostgreSQL использует огромные страницы, когда считает это возможным, а в про-
тивном случае переходит к обычным страницам. Чтобы задействовать огромные страницы прину-
дительно, можно установить для huge_pages значение on в postgresql.conf. Заметьте, что с таким
значением PostgreSQL не сможет запуститься, если не получит достаточного количества огром-
ных страниц.
Более подробно о механизме огромных страниц в Linux можно узнать в документации ядра: https://
www.kernel.org/doc/Documentation/vm/hugetlbpage.txt.
18.5. Выключение сервера
Сервер баз данных можно отключить несколькими способами. Вы выбираете тот или иной вариант
отключения, посылая разные сигналы главному процессу postgres.
SIGTERM
Запускает так называемое умное выключение. Получив SIGTERM, сервер перестаёт принимать
новые подключения, но позволяет всем существующим сеансам закончить работу в штатном
режиме. Сервер будет отключён только после завершения всех сеансов. Если сервер находится
в режиме архивации, сервер дополнительно ожидает выхода из этого режима. При этом в дан-
ном случае сервер позволяет устанавливать новые подключения, но только для суперпользо-
вателей (это исключение позволяет суперпользователю подключиться и прервать архивацию).
Если получая этот сигнал, сервер находится в процессе восстановления, восстановление и по-
токовая репликация будут прерваны только после завершения всех обычных сеансов.
SIGINT
Запускает быстрое выключение. Сервер запрещает новые подключения и посылает всем ра-
ботающим серверным процессам сигнал SIGTERM, в результате чего их транзакции прерыва-
ются и сами процессы завершаются. Управляющий процесс ждёт, пока будут завершены все
эти процессы и затем завершается сам. Если сервер находится в режиме архивации, архивация
прерывается, так что архив оказывается неполным.
SIGQUIT
Запускает немедленное выключение. Сервер отправляет всем дочерним процессам сигнал
SIGQUIT и ждёт их завершения. Если какие-либо из них не завершаются в течение 5 секунд,
492Подготовка к работе и
сопровождение сервера
им посылается SIGKILL. Главный процесс сервера завершается, как только будут завершены
все дочерние процессы, не выполняя обычную процедуру остановки БД. В результате при по-
следующем запуске будет запущен процесс восстановления (воспроизведения изменений из
журнала). Такой вариант выключения рекомендуется только в экстренных ситуациях.
Удобную возможность отправлять эти сигналы, отключающие сервер, предоставляет программа
pg_ctl. Кроме того, в системах, отличных от Windows, соответствующий сигнал можно отправить
с помощью команды kill. PID основного процесса postgres можно узнать, воспользовавшись про-
граммой ps, либо прочитав файл postmaster.pid в каталоге данных. Например, можно выполнить
быстрое выключение так:
$ kill -INT <code class="highlighter-rouge">head -1 /usr/local/pgsql/data/postmaster.pid</code>
Важно
Для выключения сервера не следует использовать сигнал SIGKILL. При таком выклю-
чении сервер не сможет освободить разделяемую память и семафоры, и, возможно, это
придётся делать вручную, чтобы сервер мог запуститься снова. Кроме того, при уни-
чтожении главного процесса postgres сигналом SIGKILL, он не успеет передать этот
сигнал своим дочерним процессам, так что может потребоваться завершать их так же
вручную.
Чтобы завершить отдельный сеанс, не прерывая работу других сеансов, воспользуйтесь функцией
pg_terminate_backend() (см. Таблицу 9.78) или отправьте сигнал SIGTERM дочернему процессу,
обслуживающему этот сеанс.
18.6. Обновление кластера PostgreSQL
В этом разделе рассказывается, как обновить ваш кластер базы данных с одной версии PostgreSQL
на другую.
Текущие номера версий PostgreSQL состоят из номеров основной и корректирующей (дополни-
тельной) версии. Например, в номере версии 10.1 число 10 обозначает основную версию, а 1 — до-
полнительную. Для выпусков PostgreSQL до версии 10.0 номера состояли из трёх чисел (например,
9.5.3). Тогда основная версия образовывалась группой их двух чисел (например, 9.5), а дополни-
тельная задавалась третьим числом (например, 3, что означало, что это третий корректирующий
выпуск основной версии 9.5).
В корректирующих выпусках никогда не меняется внутренний формат хранения и они всегда сов-
местимы с предыдущими и последующими выпусками той же основной версии. Например, версия
10.1 совместима с версией 10.0 и версией 10.6. Подобным образом, например, версия 9.5.3 совме-
стима с 9.5.0, 9.5.1 и 9.5.6. Для обновления версии на совместимую достаточно просто заменить
исполняемые файлы при выключенном сервере и затем запустить сервер. Каталог данных при
этом не затрагивается, так что обновить корректирующую версию довольно просто.
При обновлении основных версий PostgreSQL внутренний формат данных может меняться, что
усложняет процедуру обновления. Традиционный способ переноса данных в новую основную вер-
сию — выгрузить данные из старой версии, а затем загрузить их в новую (это не самый быстрый
вариант). Выполнить обновление быстрее позволяет pg_upgrade. Также для обновления можно ис-
пользовать репликацию, как описано ниже.
Изменения основной версии обычно приносят какие-либо видимые пользователю несовместимо-
сти, которые могут требовать доработки приложений. Все подобные изменения описываются в за-
мечаниях к выпуску (Приложение E); обращайте особое внимание на раздел «Migration» (Мигра-
ция). Если при обновлении вы пропускаете несколько основных версий, обязательно прочитайте
замечания к выпуску, в том числе и для каждой пропускаемой версии.
Осторожные пользователи обычно тестируют свои клиентские приложения с новой версией,
прежде чем переходить на неё полностью; поэтому часто имеет смысл установить рядом старую
493Подготовка к работе и
сопровождение сервера
и новую версии. При тестировании обновления основной версии PostgreSQL изучите следующие
области возможных изменений:
Администрирование
Средства и функции, предоставляемые администраторам для наблюдения и управления серве-
ром, часто меняются и совершенствуются в каждой новой версии.
SQL
В этой области чаще наблюдается появление новых возможностей команд SQL, чем изменение
поведения существующих, если только об этом не говорится в замечаниях к выпуску.
API библиотек
Обычно библиотеки типа libpq только расширяют свою функциональность, если об обратном
так же не говорится в замечаниях к выпуску.
Системные каталоги
Изменения в системных каталогах обычно влияют только на средства управления базами дан-
ных.
API сервера для кода на C
Сюда относятся изменения в API серверных функций, которые написаны на языке программи-
рования C. Такие изменения затрагивают код, обращающийся к служебным функциям глубоко
внутри сервера.
18.6.1. Обновление данных с применением pg_dumpall
Один из вариантов обновления заключается в выгрузке данных из одной основной версии
PostgreSQL и загрузке их в другую — для этого необходимо использовать средство логического ко-
пирования, например pg_dumpall; копирование на уровне файловой системы не подходит. (В самом
сервере есть проверки, которые не дадут использовать каталог данных от несовместимой версии
PostgreSQL, так что если попытаться запустить с существующим каталогом данных неправильную
версию сервера, никакого вреда не будет.)
Для создания копии рекомендуется применять программы pg_dump и pg_dumpall от новой версии
PostgreSQL, чтобы воспользоваться улучшенными функциями, которые могли в них появиться. Те-
кущие версии этих программ способны читать данные любой версии сервера, начиная с 7.0.
В следующих указаниях предполагается, что сервер установлен в каталоге /usr/local/pgsql, а
данные находятся в /usr/local/pgsql/data. Вам нужно подставить свои пути.
1.
При запуске резервного копирования убедитесь в том, что в базе данных не производятся из-
менения. Изменения не повлияют на целостность полученной копии, но изменённые данные,
само собой, в неё не попадут. Если потребуется, измените разрешения в файле /usr/local/
pgsql/data/pg_hba.conf (или подобном), чтобы подключиться к серверу могли только вы. За
дополнительными сведениями об управлении доступом обратитесь к Главе 20.
Чтобы получить копию всех ваших данных, введите:
pg_dumpall &gt; выходной_файл
Для создания резервной копии вы можете воспользоваться программой pg_dumpall от теку-
щей версии сервера; за подробностями обратитесь к Подразделу 25.1.2. Однако для лучшего
результата стоит попробовать pg_dumpall из PostgreSQL 11.1, так как в эту версию вошли ис-
правления ошибок и усовершенствования, по сравнению с предыдущими версиями. Хотя этот
совет может показаться абсурдным, ведь новая версия ещё не установлена, ему стоит после-
довать, если вы планируете установить новую версию рядом со старой. В этом случае вы смо-
жете выполнить установку как обычно, а перенести данные позже. Это также сократит время
обновления.
2.
Остановите старый сервер:
494Подготовка к работе и
сопровождение сервера
pg_ctl stop
В системах, где PostgreSQL запускается при загрузке, должен быть скрипт запуска, с которым
можно сделать то же самое. Например, в Red Hat Linux может сработать такой вариант:
/etc/rc.d/init.d/postgresql stop
Подробнее запуск и остановка сервера описаны в Главе 18.
3.
При восстановлении из резервной копии удалите или переименуйте старый каталог, где был
установлен сервер, если его имя не привязано к версии. Разумнее будет переименовать ката-
лог, а не удалять его, чтобы его можно было восстановить в случае проблем. Однако учтите,
что этот каталог может занимать много места на диске. Переименовать каталог можно, на-
пример так:
mv /usr/local/pgsql /usr/local/pgsql.old
(Этот каталог нужно переименовывать (перемещать) как единое целое, чтобы относительные
пути в нём не изменились.)</p>
<ol>
  <li>Установите новую версию PostgreSQL как описано в Разделе 16.4.</li>
  <li>При необходимости создайте новый кластер баз данных. Помните, что следующие команды
нужно выполнять под именем специального пользователя БД (вы уже действуете под этим
именем, если производите обновление).
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</li>
  <li>Перенесите изменения, внесённые в предыдущие версии pg_hba.conf и postgresql.conf.</li>
  <li>Запустите сервер баз данных, так же применяя учётную запись специального пользователя БД:
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
8.
Наконец, восстановите данные из резервной копии, выполнив:
/usr/local/pgsql/bin/psql -d postgres -f выходной_файл
(При этом будет использоваться новый psql.)
Минимизировать время отключения сервера можно, установив новый сервер в другой каталог и
запустив параллельно оба сервера, старый и новый, с разными портами. Затем можно будет пере-
нести данные примерно так:
pg_dumpall -p 5432 | psql -d postgres -p 5433
18.6.2. Обновление данных с применением pg_upgrade
Модуль pg_upgrade позволяет обновить инсталляцию PostgreSQL с одной основной версии на дру-
гую непосредственно на месте. Такое обновление может выполняться за считанные минуты, осо-
бенно в режиме –link. Для него требуются примерно те же подготовительные действия, что и для
варианта с pg_dumpall: запустить/остановить сервер, выполнить initdb. Все эти действия описаны
в документации pg_upgrade.
18.6.3. Обновление данных с применением репликации
Методы логической репликации также могут применяться для создания резервного сервера с об-
новлённой версией PostgreSQL. Это возможно благодаря тому, что логическая репликация под-
держивается между разными основными версиями PostgreSQL. Резервный сервер может распола-
гаться как на том же компьютере, так и на другом. Как только синхронизация с главным сервером
(где работает старая версия PostgreSQL) будет завершена, можно сделать главным новый сервер, а
старый экземпляр базы данных просто отключить. При таком переключении обновление возмож-
но осуществить, прервав работу сервера всего на несколько секунд.
Этот вариант обновления можно осуществить, используя как встроенные средства логической ре-
пликации, так и внешние системы логической репликации, такие как pglogical, Slony, Londiste и
Bucardo.
495Подготовка к работе и
сопровождение сервера
18.7. Защита от подмены сервера
Когда сервер работает, злонамеренный пользователь не может подставить свой сервер вместо
него. Однако, если сервер отключён, локальный пользователь может подменить нормальный сер-
вер, запустив свой собственный. Поддельный сервер сможет читать пароли и запросы клиентов,
хотя не сможет вернуть никакие данные, так как каталог PGDATA будет защищён от чтения посто-
ронними пользователями. Такая подмена возможна потому, что любой пользователь может запу-
стить сервер баз данных; клиент, со своей стороны, не может обнаружить подмену, если его не
настроить дополнительно.
Один из способов предотвратить подмену для локальных подключений — использовать каталог
Unix-сокетов (unix_socket_directories), в который сможет писать только проверенный локальный
пользователь. Это не позволит злонамеренному пользователю создать в этом каталоге свой файл
сокета. Если вас беспокоит, что некоторые приложения при этом могут обращаться к файлу со-
кета в /tmp и, таким образом, всё же будут уязвимыми, создайте при загрузке операционной си-
стемы символическую ссылку /tmp/.s.PGSQL.5432, указывающую на перемещённый файл сокета.
Возможно, вам также придётся изменить скрипт очистки /tmp, чтобы он не удалял эту ссылку.
Также клиенты могут защитить локальные подключения, установив в параметре requirepeer имя
пользователя, который должен владеть серверным процессом, подключённым к сокету.
Лучший способ защиты от подмены для соединений TCP — использовать сертификаты SSL и до-
биться, чтобы клиенты проверяли сертификат сервера. Для этого надо настроить сервер, чтобы он
принимал только подключения hostssl (см. Раздел 20.1) и имел ключ и сертификаты SSL (см. Раз-
дел 18.9). Тогда TCP-клиент должен будет подключаться к серверу с параметром sslmode=verify-
ca или verify-full и у него должен быть установлен соответствующий корневой сертификат (см.
Подраздел 34.18.1).
18.8. Возможности шифрования
PostgreSQL обеспечивает шифрование на разных уровнях и даёт гибкость в выборе средств защиты
данных в случае кражи сервера, от недобросовестных администраторов или в небезопасных сетях.
Шифрование может также требоваться для защиты конфиденциальных данных, например, меди-
цинских сведений или финансовых транзакций.
Шифрование паролей
Пароли пользователей базы данных хранятся в виде хешей (алгоритм хеширования определя-
ется параметром password_encryption), так что администратор не может узнать, какой именно
пароль имеет пользователь. Если шифрование SCRAM или MD5 применяется и при проверке
подлинности, пароль не присутствует на сервере в открытом виде даже кратковременно, так
как клиент шифрует его перед тем как передавать по сети. Предпочтительным методом явля-
ется SCRAM, так как это стандарт, принятый в Интернете, и он более безопасен, чем собствен-
ный протокол проверки MD5 в PostgreSQL.
Шифрование избранных столбцов
Модуль pgcrypto позволяет хранить в зашифрованном виде избранные поля. Это полезно, если
ценность представляют только некоторые данные. Чтобы прочитать эти поля, клиент передаёт
дешифрующий ключ, сервер расшифровывает данные и выдаёт их клиенту.
Расшифрованные данные и ключ дешифрования находятся на сервере в процессе расшифро-
вывания и передачи данных. Именно в этот момент данные и ключи могут быть перехвачены
тем, кто имеет полный доступ к серверу баз данных, например, системным администратором.
Шифрование раздела данных
Шифрование хранилища данных можно реализовать на уровне файловой системы или на уров-
не блоков. В Linux можно воспользоваться шифрованными файловыми системами eCryptfs и
EncFS, а во FreeBSD есть PEFS. Шифрование всего диска на блочном уровне в Linux можно
496Подготовка к работе и
сопровождение сервера
организовать, используя dm-crypt + LUKS, а во FreeBSD — модули GEOM, geli и gbde. Подобные
возможности есть и во многих других операционных системах, включая Windows.
Этот механизм не позволяет читать незашифрованные данные с дисков в случае кражи дис-
ков или всего компьютера. При этом он не защищает данные от чтения, когда эта файловая
система смонтирована, так как на смонтированном устройстве операционная система видит
все данные в незашифрованном виде. Однако, чтобы смонтировать файловую систему, нужно
передать операционной системе ключ (иногда он хранится где-то на компьютере, который вы-
полняет монтирование).
Шифрование данных при передаче по сети
SSL-соединения шифруют все данные, передаваемые по сети: пароль, запросы и возвращаемые
данные. Файл pg_hba.conf позволяет администраторам указать, для каких узлов будут разре-
шены незашифрованные соединения (host), а для каких будет требоваться SSL (hostssl). Кро-
ме того, и на стороне клиента можно разрешить подключения к серверам только с SSL. Для
шифрования трафика также можно применять stunnel и SSH.
Проверка подлинности сервера SSL
И клиент, и сервер могут проверять подлинность друг друга по сертификатам SSL. Это требует
дополнительной настройки на каждой стороне, но даёт более надёжную гарантию подлинно-
сти, чем обычные пароли. С такой защитой подставной компьютер не сможет представлять из
себя сервер с целью получить пароли клиентов. Она также предотвращает атаки с посредником
(«man in the middle»), когда компьютер между клиентом и сервером представляется сервером
и незаметно передаёт все запросы и данные между клиентом и подлинным сервером.
Шифрование на стороне клиента
Если системный администратор сервера, где работает база данных, не является доверенным,
клиент должен сам шифровать данные; тогда незашифрованные данные никогда не появятся
на этом сервере. В этом случае клиент шифрует данные, прежде чем передавать их серверу, а
получив из базы данных результаты, он расшифровывает их для использования.
18.9. Защита соединений TCP/IP с применением SSL
В PostgreSQL встроена поддержка SSL для шифрования трафика между клиентом и сервером,
что повышает уровень безопасности системы. Для использования этой возможности необходимо,
чтобы и на сервере, и на клиенте был установлен OpenSSL, и поддержка SSL была разрешена в
PostgreSQL при сборке (см. Главу 16).
18.9.1. Базовая настройка
Когда в установленном сервере PostgreSQL разрешена поддержка SSL, его можно запустить с
включённым механизмом SSL, задав в postgresql.conf для параметра ssl значение on. Запущен-
ный сервер будет принимать, как обычные, так и SSL-подключения в одном порту TCP и будет со-
гласовывать использование SSL с каждым клиентом. По умолчанию клиент выбирает режим под-
ключения сам; как настроить сервер, чтобы он требовал использовать только SSL для всех или
некоторых подключений, вы можете узнать в Разделе 20.1.
Чтобы сервер мог работать в режиме SSL, ему необходимы файлы с сертификатом сервера и за-
крытым ключом. По умолчанию это должны быть файлы server.crt и server.key, соответствен-
но, расположенные в каталоге данных, но можно использовать и другие имена и местоположения
файлов, задав их в конфигурационных параметрах ssl_cert_file и ssl_key_file.
В Unix-подобных системах к файлу server.key должен быть запрещён любой доступ группы и всех
остальных; чтобы установить такое ограничение, выполните chmod 0600 server.key. Возможен и
другой вариант, когда этим файлом владеет root, а группа имеет доступ на чтение (то есть, маска
разрешений 0640). Данный вариант предназначен для систем, в которых файлами сертификатов и
ключей управляет сама операционная система. В этом случае пользователь, запускающий сервер
497Подготовка к работе и
сопровождение сервера
PostgreSQL, должен быть членом группы, имеющей доступ к указанным файлам сертификата и
ключа.
Если к каталогу данных разрешён доступ группы, файлы сертификатов должны размещаться вне
этого каталога для удовлетворения озвученных выше требований безопасности. Вообще говоря,
доступ группы разрешается для того, чтобы непривилегированный пользователь мог производить
резервное копирование базы данных, и в этом случае средство резервного копирования не сможет
прочитать файлы сертификатов, что скорее всего приведёт к ошибке.
Если закрытый ключ защищён паролем, сервер спросит этот пароль и не будет запускаться, пока
он не будет введён. Использование такого пароля лишает возможности изменять конфигурацию
SSL без перезагрузки сервера. Более того, закрытые ключи, защищённые паролям, не годятся для
использования в Windows.
Первым сертификатом в server.crt должен быть сертификат сервера, так как он должен соответ-
ствовать закрытому ключу сервера. В этот файл также могут быть добавлены сертификаты «про-
межуточных» центров сертификации. Это избавляет от необходимости хранить все промежуточ-
ные сертификаты на клиентах, при условии, что корневой и промежуточные сертификаты были
созданы с расширениями v3_ca. Это также упрощает управление промежуточными сертификата-
ми с истекающим сроком.
Добавлять корневой сертификат в server.crt нет необходимости. Вместо этого клиенты должны
иметь этот сертификат в цепочке сертификатов сервера.
18.9.2. Конфигурация OpenSSL
PostgreSQL читает системный файл конфигурации OpenSSL. По умолчанию этот файл называется
openssl.cnf и находится в каталоге, который сообщает команда openssl version -d. Если требу-
ется указать другое расположение файла конфигурации, его можно задать в переменной окруже-
ния OPENSSL_CONF.
OpenSSL предоставляет широкий выбор шифров и алгоритмов аутентификации разной защищён-
ности. Хотя список шифров может быть задан непосредственно в файле конфигурации OpenSSL,
можно задать отдельные шифры именно для сервера баз данных, указав их в параметре ssl_ciphers
в postgresql.conf.
Примечание
Накладные расходы, связанные с шифрованием, в принципе можно исключить, огра-
ничившись только проверкой подлинности, то есть применяя шифр NULL-SHA или NULL-
MD5. Однако в этом случае посредник сможет пропускать через себя и читать весь тра-
фик между клиентом и сервером. Кроме того, шифрование привносит минимальную
дополнительную нагрузку по сравнению с проверкой подлинности. По этим причинам
использовать шифры NULL не рекомендуется.
18.9.3. Использование клиентских сертификатов
Чтобы клиенты должны были предоставлять серверу доверенные сертификаты, поместите серти-
фикаты корневых центров сертификации (ЦС), которым вы доверяете, в файл в каталоге данных,
укажите в параметре ssl_ca_file в postgresql.conf имя этого файла и добавьте параметр аутенти-
фикации clientcert=1 в соответствующие строки hostssl в pg_hba.conf. В результате от клиен-
та в процессе установления SSL-подключения будет затребован сертификат. (Как настроить сер-
тификаты на стороне клиента, описывается в Разделе 34.18.) Получив сертификат, сервер будет
проверять, подписан ли этот сертификат одним из доверенным центром сертификации.
Промежуточные сертификаты, которые составляют цепочку с существующими корневыми серти-
фикатами, можно также включить в файл ssl_ca_file, если вы не хотите хранить их на клиентах
(предполагается, что корневой и промежуточный сертификаты были созданы с расширениями
498Подготовка к работе и
сопровождение сервера
v3_ca). Если установлен параметр ssl_crl_file, также проверяются списки отзыва сертификатов
(Certificate Revocation List, CRL). (Диаграммы, иллюстрирующие использование сертификатов SSL,
можно найти на странице http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html.)
Параметр аутентификации clientcert можно использовать с любым методом проверки подлинно-
сти, но только в строках pg_hba.conf типа hostssl. Когда clientcert не задан или равен 0, сервер,
тем не менее, будет проверять все представленные клиентские сертификаты по своему файлу со
списком ЦС (если он настроен) — но позволит подключаться клиентам без сертификата.
Если вы используете клиентские сертификаты, вы можете также применить метод аутентифика-
ции cert, чтобы сертификаты обеспечивали не только защиту соединений, но и проверку подлин-
ности пользователей. За подробностями обратитесь к Разделу 20.12. (Устанавливать clientcert=1
явно при использовании метода аутентификации cert не требуется.)
18.9.4. Файлы, используемые SSL-сервером
В Таблице 18.2 кратко описаны все файлы, имеющие отношение к настройке SSL на сервере. (Здесь
приведены стандартные имена файлов. В конкретной системе они могут быть другими.)
Таблица 18.2. Файлы, используемые SSL-сервером
Файл
Содержимое
Назначение
ssl_cert_file
server.crt) ($PGDATA/ сертификат сервера отправляется клиенту для иден-
тификации сервера
ssl_key_file
server.key) ($PGDATA/ закрытый ключ сервера подтверждает, что сертификат
сервера был передан его вла-
дельцем; не гарантирует, что
его владельцу можно доверять
ssl_ca_file сертификаты доверенных ЦС
позволяет проверить, что серти-
фикат клиента подписан дове-
ренным центром сертификации
ssl_crl_file сертификаты, отозванные цен- сертификат клиента должен от-
трами сертификации
сутствовать в этом списке
Сервер читает эти файлы при запуске или при перезагрузке конфигурации. В системах Windows
они также считываются заново, когда для нового клиентского подключения запускается новый
обслуживающий процесс.
Если в этих файлах при запуске сервера обнаружится ошибка, сервер откажется запускаться. Но
если ошибка обнаруживается при перезагрузке конфигурации, эти файлы игнорируются и продол-
жает использоваться старая конфигурация SSL. В системах Windows, если в одном из этих файлов
обнаруживается ошибка при запуске обслуживающего процесса, этот процесс не сможет устанав-
ливать SSL-соединения. Во всех таких случаях в журнал событий сервера выводится сообщение
об ошибке.
18.9.5. Создание сертификатов
Чтобы создать простой самоподписанный сертификат для сервера, действующий 365 дней, выпол-
ните следующую команду OpenSSL, заменив dbhost.yourdomain.com именем компьютера, где раз-
мещён сервер:
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
-keyout server.key -subj “/CN=dbhost.yourdomain.com”
Затем выполните:
chmod og-rwx server.key
так как сервер не примет этот файл, если разрешения будут более либеральными, чем показанные.
За дополнительными сведениями относительно создания закрытого ключа и сертификата сервера
обратитесь к документации OpenSSL.
499Подготовка к работе и
сопровождение сервера
Хотя самоподписанный сертификат может успешно применяться при тестировании, в произ-
водственной среде следует использовать сертификат, подписанный центром сертификации (ЦС)
(обычно это корневой ЦС предприятия).
Чтобы создать сертификат сервера, подлинность которого смогут проверять клиенты, сначала со-
здайте запрос на получение сертификата (CSR) и файлы открытого/закрытого ключа:
openssl req -new -nodes -text -out root.csr \
-keyout root.key -subj “/CN=root.yourdomain.com”
chmod og-rwx root.key
Затем подпишите запрос ключом, чтобы создать корневой центр сертификации (с файлом конфи-
гурации OpenSSL, помещённым в Linux в расположение по умолчанию):
openssl x509 -req -in root.csr -text -days 3650 \
-extfile /etc/ssl/openssl.cnf -extensions v3_ca \
-signkey root.key -out root.crt
Наконец, создайте сертификат сервера, подписанный новым корневым центром сертификации:
openssl req -new -nodes -text -out server.csr \
-keyout server.key -subj “/CN=dbhost.yourdomain.com”
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
-CA root.crt -CAkey root.key -CAcreateserial \
-out server.crt
server.crt и server.key должны быть сохранены на сервере, а root.crt — на клиенте, чтобы кли-
ент мог убедиться в том, что конечный сертификат сервера подписан центром сертификации, ко-
торому он доверяет. Файл root.key следует хранить в изолированном месте для создания серти-
фикатов в будущем.
Также возможно создать цепочку доверия, включающую промежуточные сертификаты:
    <h1 id="корневой-сертификат">корневой сертификат</h1>
    <p>openssl req -new -nodes -text -out root.csr \
-keyout root.key -subj “/CN=root.yourdomain.com”
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
-extfile /etc/ssl/openssl.cnf -extensions v3_ca \
-signkey root.key -out root.crt</p>
    <h1 id="промежуточный">промежуточный</h1>
    <p>openssl req -new -nodes -text -out intermediate.csr \
-keyout intermediate.key -subj “/CN=intermediate.yourdomain.com”
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
-extfile /etc/ssl/openssl.cnf -extensions v3_ca \
-CA root.crt -CAkey root.key -CAcreateserial \
-out intermediate.crt</p>
    <h1 id="конечный">конечный</h1>
    <p>openssl req -new -nodes -text -out server.csr \
-keyout server.key -subj “/CN=dbhost.yourdomain.com”
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
-CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
-out server.crt
server.crt и intermediate.crt следует сложить вместе в пакет сертификатов и сохранить на сер-
вере. Также на сервере следует сохранить server.key. Файл root.crt нужно сохранить на клиен-
500Подготовка к работе и
сопровождение сервера
те, чтобы клиент мог убедиться в том, что конечный сертификат сервера был подписан по цепоч-
ке сертификатов, связанных с корневым сертификатом, которому он доверяет. Файлы root.key и
intermediate.key следует хранить в изолированном месте для создания сертификатов в будущем.
18.10. Защита соединений TCP/IP с применением тун-
нелей SSH
Для защиты сетевых соединений клиентов с сервером PostgreSQL можно применить SSH. При
правильном подходе это позволяет обеспечить должный уровень защиты сетевого трафика, даже
для клиентов, не поддерживающих SSL.
Прежде всего, убедитесь, что на компьютере с сервером PostgreSQL также работает сервер SSH
и вы можете подключиться к нему через ssh каким-нибудь пользователем. Затем вы можете уста-
новить защищённый тоннель с клиентской машины следующим образом:
ssh -L 63333:localhost:5432 joe@foo.com
Первое число в аргументе -L, 63333 — это номер порта с вашей стороны туннеля; это может быть
номер любого свободного порта. (IANA резервирует порты с 49152 по 65535 для частного исполь-
зования.) Второе число, 5432 — порт с удалённой стороны туннеля, порт вашего сервера. Имя или
IP-адрес между этими номерами портов идентифицирует целевой компьютер (где работает сервер
баз данных, к которому вы будете подключаться), с точки зрения компьютера, с которого выпол-
няется подключение (в данном примере, foo.com). Чтобы подключиться к этому серверу через со-
зданный тоннель, вы можете подключиться к порту 63333 на локальном компьютере:
psql -h localhost -p 63333 postgres
Для сервера баз данных это будет выглядеть так, как будто вы действительно пользователь joe
компьютера foo.com, подключающийся к localhost в этом контексте, и он будет применять ту
процедуру проверки подлинности, которая установлена для подключений данного пользователя с
этого компьютера. Заметьте, что сервер не будет считать такое соединение защищённым SSL, так
как на самом деле трафик между сервером SSH и сервером PostgreSQL не защищён. Это не должно
нести какие-то дополнительные риски, так как эти серверы работают на одном компьютере.
Чтобы настроенный таким образом туннель работал, вы должны иметь возможность подключаться
к компьютеру через ssh под именем joe@foo.com, так же, как это происходит при установлении
терминального подключения с помощью ssh.
Вы также можете настроить перенаправление портов примерно так:
ssh -L 63333:foo.com:5432 joe@foo.com
Но в этом случае для сервера баз данных подключение будет приходить с его интерфейса foo.com,
а этот интерфейс по умолчанию не прослушивается (вследствие указания listen_addresses =
‘localhost’). Обычно требуется другое поведение.
Если вам нужно «перейти» к серверу баз данных через некоторый шлюз, это можно организовать
примерно так:
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
Заметьте, что в этом случае трафик между shell.foo.com и db.foo.com не будет защищён тунне-
лем SSH. SSH предлагает довольно много вариантов конфигурации, что позволяет организовывать
защиту сети разными способами. За подробностями обратитесь к документации SSH.
Подсказка
Существуют и другие приложения, которые могут создавать безопасные туннели, при-
меняя по сути тот же подход, что был описан выше.
501Подготовка к работе и
сопровождение сервера
18.11. Регистрация журнала событий в Windows
Чтобы зарегистрировать библиотеку журнала событий в Windows, выполните следующую команду:
regsvr32 каталог_библиотек_pgsql/pgevent.dll
При этом в реестре будут созданы необходимые записи для средства просмотра событий, относя-
щиеся к источнику событий по умолчанию с именем PostgreSQL.
Чтобы задать другое имя источника событий (см. event_source), укажите ключи /n и /i:
regsvr32 /n /i:имя_источника_событий каталог_библиотек_pgsql/pgevent.dll
Чтобы разрегистрировать библиотеку журнала событий в операционной системе, выполните ко-
манду:
regsvr32 /u [/i:имя_источника_событий] каталог_библиотек_pgsql/pgevent.dll
Примечание
Чтобы сервер баз данных записывал сообщения в журнал событий, добавьте eventlog
в параметр log_destination в postgresql.conf.</p>
  </li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-017/" title="Глава 17. Установка из исходного кода в Windows"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 17. Установка из исходного кода в Windows"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-017/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~9 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-017/" rel="bookmark" title="Глава 17. Установка из исходного кода в Windows" itemprop="url">Глава 17. Установка из исходного кода в Windows</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 17. Установка из исходного кода в Windows</p>

<p>Для большинства пользователей рекомендуется просто загрузить дистрибутив для Windows с
сайта PostgreSQL. Компиляция из исходного кода описана только для разработчиков сервера
PostgreSQL или его расширений.
Существует несколько различных способов сборки PostgreSQL для Windows. Самый простой спо-
соб сборки с применением инструментов Microsoft — установить Visual Studio Express 2017 для
Windows Desktop и использовать входящий в её состав компилятор. Также возможна сборка с по-
мощью полной версии Microsoft Visual C++ 2005—2017. В некоторых случаях помимо компилятора
требуется установить Windows SDK.
Также возможно собрать PostgreSQL с помощью средств компиляции GNU, используя среду
MinGW, либо с помощью Cygwin для более старых версий Windows.
При компиляции с помощью MinGW или Cygwin сборка производится как обычно, см. Главу 16 и
дополнительные замечания в Подразделе 16.7.5 и Подразделе 16.7.2. Чтобы получить в этих окру-
жениях «родные» 64-битные двоичные файлы, используйте инструменты из MinGW-w64. Данные
инструменты также могут быть использованы для кросс-компиляции для 32- и 64-битной Windows
в других системах, например в Linux и macOS. Cygwin не рекомендуется применять в производ-
ственной среде, его следует использовать только для запуска в старых версиях Windows, где «род-
ная» сборка невозможна, таких как Windows 98. Официальные двоичные файлы собираются с ис-
пользованием Visual Studio.
«Родные» сборки psql не поддерживают редактирование командной строки. Однако сборка в
Cygwin это поддерживает, так что следует выбрать её, когда необходимо интерактивно использо-
вать psql в Windows.
17.1. Сборка с помощью Visual C++ или Microsoft
Windows SDK
PostgreSQL может быть собран с помощью компилятора Visual C++ от Microsoft. Этот компилятор
есть в пакетах Visual Studio, Visual Studio Express или в некоторых версиях Microsoft Windows SDK.
Если у вас ещё не установлена среда Visual Studio, проще всего будет использовать компиляторы
из Visual Studio Express 2017 для Windows Desktop или из Windows SDK 8.1, которые Microsoft
распространяет бесплатно.
С применением инструментария Microsoft Compiler возможна и 32-, и 64-битная сборка. 32-битную
сборку PostgreSQL можно произвести с использованием Visual Studio, версии с Visual Studio 2005
по Visual Studio 2017 (включая редакции Express), а также отдельных выпусков Windows SDK вер-
сии с 6.0 по 8.1. 64-битная сборка PostgreSQL также поддерживается с Microsoft Windows SDK вер-
сии с 6.0a по 8.1 или с Visual Studio 2008 и новее. Компиляция для систем, начиная с Windows XP и
Windows Server 2003, поддерживается при использовании Visual Studio 2005 — Visual Studio 2013.
При сборке с Visual Studio 2015 поддерживаются системы, начиная с Windows Vista и Windows
Server 2008. При сборке с Visual Studio 2017 поддерживаются системы, начиная с Windows 7 SP1
и Windows Server 2008 R2 SP1.
Инструменты для компиляции с помощью Visual C++ или Platform SDK находятся в каталоге src/
tools/msvc. При сборке убедитесь, что в системном пути PATH не подключаются инструменты из
набора MinGW или Cygwin. Также убедитесь, что в пути PATH указаны каталоги всех необходимых
инструментов Visual C++. Если вы используете Visual Studio, запустите Visual Studio Command
Prompt. Если вы хотите собрать 64-битную версию, вы должны выбрать 64-битную версию данной
оболочки, и наоборот. Если вы используете Microsoft Windows SDK, запустите через стартовое ме-
ню, подменю SDK оболочку CMD shell. В последних версиях SDK можно изменить целевую архи-
тектуру процессора, вариант сборки и целевую ОС с помощью команды setenv, например после
setenv /x86 /release /xp будет получена выпускаемая 32-битная сборка для Windows XP. О дру-
473Установка из исход-
ного кода в Windows
гих параметрах setenv можно узнать с ключом /?. Все команды должны запускаться из каталога
src\tools\msvc.
До начала сборки может потребоваться отредактировать файл config.pl и изменить в нём желае-
мые параметры конфигурации или пути к сторонним библиотекам, которые будут использоваться.
Для получения конфигурации сначала считывается и разбирается файл config_default.pl, а за-
тем применяются все изменения из config.pl. Например, чтобы указать, куда установлен Python,
следует добавить в config.pl:
$config-&gt;{python} = ‘c:\python26’;
Вам нужно задать только те параметры, которые отличаются от заданных в config_default.pl.
Если вам необходимо установить какие-либо другие переменные окружения, создайте файл с име-
нем buildenv.pl и поместите в него требуемые команды. Например, чтобы добавить путь к bison,
которого нет в PATH, создайте файл следующего содержания:
$ENV{PATH}=$ENV{PATH} . ‘;c:\some\where\bison\bin’;
Передать дополнительные аргументы командной строки команде сборки Visual Studio (msbuild или
vcbuild) можно так:
$ENV{MSBFLAGS}=”/m”;
17.1.1. Требования
Для сборки PostgreSQL требуется следующее дополнительное ПО. Укажите каталоги, в которых
находятся соответствующие библиотеки, в файле конфигурации config.pl.
Microsoft Windows SDK
Если с вашим инструментарием для разработки не поставляется поддерживаемая версия
Microsoft Windows SDK, рекомендуется установить последнюю версию SDK (в настоящее время
7.1), которую можно загрузить с https://www.microsoft.com/download/.
Устанавливая SDK, вы всегда должны выбирать для установки пункт Windows Headers and
Libraries (Заголовочные файлы и библиотеки Windows). Если вы установили Windows SDK,
включая Visual C++ Compilers, Visual Studio для сборки вам не нужна. Обратите внимание, что
с версии 8.0a в SDK для Windows не включается полное окружение для сборки в командной
строке.
ActiveState Perl
ActiveState Perl требуется для запуска скриптов, управляющих сборкой. Perl из MinGW или
Cygwin работать не будет. ActiveState Perl также должен находиться по пути в PATH. Готовый
двоичный пакет можно загрузить с https://www.activestate.com. Заметьте, что требуется вер-
сия 5.8.3 или выше, при этом достаточно бесплатного стандартного дистрибутива (Standard
Distribution).
Следующее дополнительное ПО не требуется для базовой сборки, но требуется для сборки полно-
го пакета. Укажите каталоги, в которых находятся соответствующие библиотеки, в файле конфи-
гурации config.pl.
ActiveState TCL
Требуется для компиляции PL/Tcl (Заметьте, что требуется версия 8.4 или выше, при этом до-
статочно бесплатного стандартного дистрибутива (Standard Distribution)).
Bison и Flex
Для компиляции из Git требуются Bison и Flex, хотя они не нужны для компиляции из дистри-
бутивного пакета исходного кода. Bison должен быть версии 1.875 или 2.2, либо новее, а Flex
— версии 2.5.31 или новее.
И Bison, и Flex входят в комплект утилит msys, который можно загрузить с http://www.mingw.org/
wiki/MSYS в качестве компонента набора MinGW.
474Установка из исход-
ного кода в Windows
Вам потребуется добавить каталог, содержащий flex.exe и bison.exe, в путь, задаваемый пе-
ременной PATH, в buildenv.pl, если она его ещё не включает. В случае с MinGW, это будет
подкаталог \msys\1.0\bin в каталоге вашей инсталляции MinGW.
Примечание
Bison, поставляемый в составе GnuWin32, может работать некорректно, когда он
установлен в каталог с именем, содержащим пробелы, например, C:\Program Files
\GnuWin32 (целевой каталог по умолчанию в англоязычной системе). В таком слу-
чае, возможно, стоит установить его в C:\GnuWin32 или задать в переменной окру-
жения PATH короткий путь NTFS к GnuWin32 (например, C:\PROGRA~1\GnuWin32).
Примечание
Старые программы winflex, которые раньше размещались на FTP-сайте PostgreSQL
и упоминались в старой документации, не будут работать в 64-битной Windows,
выдавая ошибку «flex: fatal internal error, exec failed». Используйте Flex из набора
MSYS.
Diff
Diff требуется для запуска
gnuwin32.sourceforge.net.
регрессионных
тестов,
его
можно
загрузить
с
http://
Gettext
Gettext требуется для сборки с поддержкой NLS, его можно загрузить с http://
gnuwin32.sourceforge.net. Заметьте, что для сборки потребуются и исполняемые файлы, и за-
висимости, и файлы для разработки.
MIT Kerberos
Требуется для поддержки проверки подлинности GSSAPI. MIT Kerberos можно загрузить с
http://web.mit.edu/Kerberos/dist/index.html.
libxml2 и libxslt
Требуется для поддержки XML. Двоичный пакет можно загрузить с http://zlatkovic.com/pub/
libxml, а исходный код с http://xmlsoft.org. Учтите, что для libxml2 требуется iconv, который
можно загрузить там же.
OpenSSL
Требуется для поддержки SSL. Двоичные пакеты можно загрузить с https://www.slproweb.com/
products/Win32OpenSSL.html, а исходный код с https://www.openssl.org.
ossp-uuid
Требуется для поддержки UUID-OSSP (только для contrib). Исходный код можно загрузить с
http://www.ossp.org/pkg/lib/uuid/.
Python
Требуется для сборки PL/Python. Двоичные пакеты можно загрузить с https://www.python.org.
zlib
Требуется для поддержки сжатия в pg_dump и pg_restore. Двоичные пакеты можно загрузить
с http://www.zlib.net.
475Установка из исход-
ного кода в Windows
17.1.2. Специальные замечания для 64-битной Windows
PostgreSQL для архитектуры x64 можно собрать только в 64-битной Windows, процессоры Itanium
не поддерживаются.
Совместная сборка 32- и 64-битных версий в одном дереве не поддерживается. Система сборки
автоматически определит, в каком окружении (32- или 64-битном) она запущена, и соберёт соот-
ветствующий вариант PostgreSQL. Поэтому перед сборкой важно запустить требуемую версию ко-
мандного интерпретатора.
Для использования на стороне сервера сторонних библиотек, таких как python или OpenSSL,
эти библиотеки также должны быть 64-битными. 64-битный сервер не поддерживает загруз-
ку 32-битных библиотек. Некоторые библиотеки сторонних разработчиков, предназначенные для
PostgreSQL, могут быть доступны только в 32-битных версиях и в таком случае их нельзя будет
использовать с 64-битной версией PostgreSQL.
17.1.3. Сборка
Чтобы собрать весь PostgreSQL в конфигурации выпуска (по умолчанию), запустите команду:
build
Чтобы собрать весь PostgreSQL в конфигурации отладки, запустите команду:
build DEBUG
Для сборки отдельного проекта, например psql, выполните, соответственно:
build psql
build DEBUG psql
Чтобы сменить конфигурацию по умолчанию на отладочную, поместите в файл buildenv.pl сле-
дующую строку:
$ENV{CONFIG}=”Debug”;
Также возможна сборка из графической среды Visual Studio. В этом случае вам нужно запустить
в командной строке:
perl mkvcbuild.pl
и затем открыть в Visual Studio полученный pgsql.sln в корневом каталоге дерева исходных кодов.
17.1.4. Очистка и установка
В большинстве случаев за изменением файлов будет следить автоматическая система отслежива-
ния зависимостей в Visual Studio. Но если изменений было слишком много, может понадобиться
очистка установки. Чтобы её выполнить, просто запустите команду clean.bat, которая автомати-
чески очистит все сгенерированные файлы. Вы также можете запустить эту команду с параметром
dist, в этом случае она отработает подобно make distclean и удалит также выходные файлы flex/
bison.
По умолчанию все файлы сохраняются в подкаталогах debug или release. Чтобы установить эти
файлы стандартным образом, а также сгенерировать файлы, требуемые для инициализации и ис-
пользования базы данных, запустите команду:
install c:\destination\directory
Если вы хотите установить только клиентские приложения и интерфейсные библиотеки, выполни-
те команду:
install c:\destination\directory client
17.1.5. Запуск регрессионных тестов
Чтобы запустить регрессионные тесты, важно сначала собрать все необходимые для них компо-
ненты. Также убедитесь, что в системном пути могут быть найдены все DLL, требуемые для загруз-
476Установка из исход-
ного кода в Windows
ки всех подсистем СУБД (например, DLL Perl и Python для процедурных языков). Если их каталоги
в пути поиска отсутствуют, задайте их в файле buildenv.pl. Чтобы запустить тесты, выполните
одну из следующих команд в каталоге src\tools\msvc:
vcregress
vcregress
vcregress
vcregress
vcregress
vcregress
vcregress
vcregress
vcregress
vcregress
check
installcheck
plcheck
contribcheck
modulescheck
ecpgcheck
isolationcheck
bincheck
recoverycheck
upgradecheck
Чтобы выбрать другой планировщик выполнения тестов (по умолчанию выбран параллельный),
укажите его в командной строке, например:
vcregress check serial
За дополнительными сведениями о регрессионных тестах обратитесь к Главе 33.
Для запуска регрессионных тестов клиентских программ с применением команды vcregress
bincheck или тестов восстановления, с применением vcregress recoverycheck, должен быть уста-
новлен дополнительный модуль Perl:
IPC::Run
На момент написания документации модуль IPC::Run не включается ни в инсталляцию Perl
ActiveState, ни в библиотеку ActiveState PPM (Perl Package Manager, Менеджер пакетов Perl).
Чтобы установить его, загрузите архив исходного кода IPC-Run-<version>.tar.gz из CPAN, по
адресу https://metacpan.org/release/IPC-Run, и распакуйте его. Откройте файл buildenv.pl и до-
бавьте в него переменную PERL5LIB, указывающую на подкаталог lib из извлечённого архива.
Например:
$ENV{PERL5LIB}=$ENV{PERL5LIB} . ';c:\IPC-Run-0.94\lib';
17.1.6. Сборка документации
Для сборки документации PostgreSQL в формате HTML требуются дополнительные инструменты
и файлы. Создайте общий каталог для всех этих файлов и сохраните их в названные подкаталоги.
OpenJade 1.3.1-2
Загрузите архив https://sourceforge.net/projects/openjade/files/openjade/1.3.1/openjade-1_3_1-2-
bin.zip/download и распакуйте его в подкаталог openjade-1.3.1.
DocBook DTD 4.2
Загрузите архив с https://www.oasis-open.org/docbook/sgml/4.2/docbook-4.2.zip и распакуйте его
в подкаталог docbook.
Сущности символов ISO
Загрузите архив с https://www.oasis-open.org/cover/ISOEnts.zip и распакуйте его в подкаталог
docbook.
Добавьте в buildenv.pl переменную, задающую местоположение ранее созданного общего ката-
лога, например:
$ENV{DOCROOT}='c:\docbook';
Чтобы собрать документацию, запустите builddoc.bat. Обратите внимание, что при этом сбор-
ка фактически будет запущена дважды; это нужно для построения индексов. Сгенерированные
HTML-файлы окажутся в каталоге doc\src\sgml.</version></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-016/" title="Глава 16. Установка из исходного кода"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 16. Установка из исходного кода"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-016/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~43 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-016/" rel="bookmark" title="Глава 16. Установка из исходного кода" itemprop="url">Глава 16. Установка из исходного кода</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Часть III. Администрирование сервера</p>

<p>В этой части документации освещаются темы, представляющие интерес для администратора баз
данных PostgreSQL. В частности, здесь рассматривается установка программного обеспечения,
установка и настройка сервера, управление пользователями и базами данных, а также задачи об-
служивания. С этими темами следует ознакомиться всем, кто эксплуатирует сервер PostgreSQL (да-
же для личных целей, а тем более в производственной среде).
Материал этой части даётся примерно в том порядке, в каком его следует читать начинающему
пользователю. При этом её главы самодостаточны и при желании могут быть прочитаны по отдель-
ности. Информация в этой части книги представлена в повествовательном стиле и разделена по те-
мам. Если же вас интересует формальное и полное описание определённой команды, см. Часть VI.
Первые несколько глав написаны так, чтобы их можно было понять без предварительных знаний, так
что начинающие пользователи, которым нужно установить свой собственный сервер, могут начать
свой путь с них. Остальные главы части посвящены настройке сервера и управлению им; в этом
материале подразумевается, что читатель знаком с основными принципами использования СУБД
PostgreSQL. За дополнительной информацией мы рекомендуем читателям обратиться к Части I и
Части II.</p>

<p>Глава 16. Установка из исходного кода</p>

<p>В этой главе описывается установка PostgreSQL из дистрибутивного пакета исходного кода. (Если
вы устанавливаете собранный двоичный пакет, например RPM или Debian, вам нужно прочитать
инструкции по установке пакета, а не эту главу.)
16.1. Краткий вариант
./configure
make
su
make install
adduser postgres
mkdir /usr/local/pgsql/data
chown postgres /usr/local/pgsql/data
su - postgres
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;
/usr/local/pgsql/bin/createdb test
/usr/local/pgsql/bin/psql test
Развёрнутый вариант представлен в продолжении этой главы.
16.2. Требования
В принципе, запустить PostgreSQL должно быть возможно на любой современной Unix-совмести-
мой платформе. Платформы, прошедшие специальную проверку на совместимость к моменту вы-
пуска версии, перечислены далее в Разделе 16.6. В подкаталоге doc дистрибутива PostgreSQL вы
можете найти несколько документов FAQ по разным платформам, к которым следует обратиться
в случае затруднений.
Для сборки PostgreSQL требуются следующие программные пакеты:
• Требуется GNU make версии 3.80 или новее; другие программы make или ранние версии GNU
make работать не будут. (Иногда GNU make устанавливается под именем gmake.) Чтобы прове-
рить наличие и версию GNU make, введите:
make –version
• Вам потребуется компилятор C, соответствующий ISO/ANSI (как минимум, совместимый с
C89). Рекомендуется использовать последние версии GCC, но известно, что PostgreSQL соби-
рается самыми разными компиляторами и других производителей.
• Для распаковки пакета исходного кода необходим tar, а также gzip или bzip2.
• По умолчанию при сборке используется библиотека GNU Readline. Она позволяет запоминать
все вводимые команды в psql (SQL-интерпретатор командной строки для PostgreSQL) и затем,
пользуясь клавишами-стрелками, возвращаться к ним и редактировать их. Это очень удоб-
но и мы настоятельно рекомендуем пользоваться этим. Если вы не желаете использовать эту
возможность, вы должны добавить указание –without-readline для configure. В качестве
альтернативы часто можно использовать библиотеку libedit с лицензией BSD, изначально
разработанную для NetBSD. Библиотека libedit совместима с GNU Readline и подключает-
ся, если libreadline не найдена, или когда configure передаётся указание –with-libedit-
preferred. Если вы используете систему на базе Linux с пакетами, учтите, что вам потребуют-
ся два пакета: readline и readline-devel, если в вашем дистрибутиве они разделены.
• По умолчанию для сжатия данных используется библиотека zlib. Если вы не хотите её исполь-
зовать, вы должны передать configure указание –without-zlib. Это указание отключает
поддержку сжатых архивов в pg_dump и pg_restore.
Следующие пакеты не являются обязательными. Они не требуются в стандартной конфигурации,
но они необходимы для определённых вариантов сборки, описанных ниже:
450Установка из исходного кода
• Чтобы собрать поддержку языка программирования PL/Perl, вам потребуется полная инстал-
ляция Perl, включая библиотеку libperl и заголовочные файлы. Версия Perl должна быть не
старее 5.8.3. Так как PL/Perl будет разделяемой библиотекой, библиотека libperl тоже долж-
на быть разделяемой для большинства платформ. В последних версиях Perl это вариант по
умолчанию, но в ранних версиях это было не так, и в любом случае это выбирает тот, кто уста-
навливает Perl в вашей системе. Скрипт configure выдаст ошибку, если не сможет найти раз-
деляемую libperl, когда выбрана сборка PL/Perl. В этом случае, чтобы собрать PL/Perl, вам
придётся пересобрать и переустановить Perl. В процессе конфигурирования Perl выберите
сборку разделяемой библиотеки.
Если вы планируете отвести PL/Perl не второстепенную роль, следует убедиться в том, что ин-
сталляция Perl была собрана с флагом usemultiplicity (так ли это, может показать команда
perl -V).
• Чтобы собрать сервер с поддержкой языка программирования PL/Python, вам потребуется ин-
сталляция Python с заголовочными файлами и модулем distutils. Версия Python должна быть
не меньше 2.4. Python 3 поддерживается, начиная с версии 3.1; но используя Python 3, следуй-
те написанному в Раздел 46.1.
Так как PL/Python будет разделяемой библиотекой, библиотека libpython тоже должна быть
разделяемой для большинства платформ. По умолчанию при сборке инсталляции Python из
пакета исходного кода это не так, но во многих дистрибутивах имеется нужная разделяемая
библиотека. Скрипт configure выдаст ошибку, если не сможет найти разделяемую libpython,
когда выбрана сборка PL/Python. Это может означать, что вам нужно либо установить допол-
нительные пакеты, либо пересобрать (частично) вашу инсталляцию Python, чтобы получить
эту библиотеку. При сборке Python из исходного кода выполните configure с флагом –enable-
shared.
• Чтобы собрать поддержку процедурного языка PL/Tcl, вам конечно потребуется инсталляция
Tcl. Версия Tcl должна быть не старее 8.4.
• Чтобы включить поддержку национальных языков (NLS, Native Language Support), то есть воз-
можность выводить сообщения программы не только на английском языке, вам потребуется
реализация API Gettext. В некоторых системах эта реализация встроена (например, в Linux,
NetBSD, Solaris), а для других вы можете получить дополнительный пакет по адресу http://
www.gnu.org/software/gettext/. Если вы используете реализацию Gettext в библиотеке GNU,
вам понадобится ещё пакет GNU Gettext для некоторых утилит. Для любых других реализаций
он не требуется.
• Если вам нужна поддержка зашифрованных клиентских соединений, вам потребуется
OpenSSL, версии не ниже 0.9.8.
• Вам могут понадобиться пакеты Kerberos, OpenLDAP и/или PAM, если вам нужна поддержка
аутентификации, которую они обеспечивают.
• Для сборки документации PostgreSQL предъявляется отдельный набор требований; см. Раз-
дел J.2.
Если вы хотите скомпилировать код из дерева Git, а не из специального пакета исходного кода,
либо вы хотите работать с этим кодом, вам также понадобятся следующие пакеты:
• Flex и Bison потребуются для сборки из содержимого Git или если вы меняете собственно фай-
лы определений анализа и разбора. Если они вам понадобятся, то версия Flex должна быть не
меньше 2.5.31, а Bison — не меньше 1.875. Другие программы lex и yacc работать не будут.
• Perl 5.8.3 или новее потребуется для сборки из содержимого Git, либо если вы меняете ис-
ходные файлы этапов сборки, построенных на скриптах Perl. Если вы выполняете сборку в
Windows, вам потребуется Perl в любом случае. Perl также требуется для выполнения некото-
рых комплектов тестов.
Если вам понадобится какой-либо пакет GNU, вы можете найти его на вашем локальном зеркале
GNU (список зеркал: https://www.gnu.org/prep/ftp) или на сайте ftp://ftp.gnu.org/gnu/.
451Установка из исходного кода
Также проверьте, достаточно ли места на диске. Вам потребуется около 100 Мб для исходного
кода в процессе компиляции и около 20 Мб для каталога инсталляции. Пустой кластер баз данных
занимает около 35 Мб; базы данных занимают примерно в пять раз больше места, чем те же дан-
ные в обычном текстовом файле. Если вы планируете запускать регрессионные тесты, вам может
временно понадобиться ещё около 150 Мб. Проверить наличие свободного места можно с помо-
щью команды df.
16.3. Получение исходного кода
Исходные коды PostgreSQL 11.1 можно загрузить из соответствующего раздела нашего сай-
та: https://www.postgresql.org/download/. Вам следует выбрать файл postgresql-11.1.tar.gz или
postgresql-11.1.tar.bz2. Получив этот файл, распакуйте его:
gunzip postgresql-11.1.tar.gz
tar xf postgresql-11.1.tar
(Если вы выбрали файл .bz2, используйте bunzip2 вместо gunzip.) При этом в текущем каталоге
будет создан подкаталог postgresql-11.1 с исходными кодами PostgreSQL. Перейдите в этот под-
каталог для продолжения процедуры установки.
Вы также можете получить исходный код непосредственно из репозитория системы управления
версиями (см. Приложение I).
16.4. Процедура установки
1.
Конфигурирование
На первом шаге установки требуется сконфигурировать дерево установки для вашей системы
и выбрать желаемые параметры сборки. Для этого нужно запустить скрипт configure. Чтобы
выполнить стандартную сборку, просто введите:
./configure
Этот скрипт проведёт несколько проверок с целью определить значения для различных пе-
ременных, зависящих от системы, и выявить любые странности вашей ОС, а затем создаст
несколько файлов в дереве сборки, в которых отразит полученные результаты. Вы также мо-
жете выполнить configure вне дерева исходного кода, если хотите сохранить каталог сборки
отдельно. Эта процедура также называется сборкой с VPATH. Выполняется она так:
mkdir build_dir
cd build_dir
/путь/к/каталогу/исходного/кода/configure [параметры]
make
В стандартной конфигурации собираются сервер и утилиты, а также клиентские приложения
и интерфейсы, которым требуется только компилятор C. Все файлы по умолчанию устанавли-
ваются в /usr/local/pgsql.
Вы можете настроить процесс сборки и установки, передав configure один или несколько сле-
дующих параметров командной строки:
–prefix=ПРЕФИКС
Разместить все файлы внутри каталога ПРЕФИКС, а не в /usr/local/pgsql. Собственно фай-
лы будут установлены в различные подкаталоги этого каталога; в самом каталоге ПРЕФИКС
никакие файлы не размещаются.
Если у вас есть особые требования, вы также можете изменить отдельные подкаталоги,
определив следующие параметры. Однако, если вы оставите для них значения по умолча-
нию, инсталляция будет перемещаемой, то есть вы сможете переместить каталог после
установки. (Это не распространяется на каталоги man и doc.)
452Установка из исходного кода
Для перемещаемых инсталляций можно передать configure указание –disable-rpath.
Кроме того, вы должны будете сказать операционной системе, как найти разделяемые биб-
лиотеки.
–exec-prefix=ИСП-ПРЕФИКС
Вы можете установить архитектурно-зависимые файлы в размещение с другим префиксом,
ИСП-ПРЕФИКС, отличным от ПРЕФИКС. Это бывает полезно для совместного использования та-
ких файлов несколькими системами. По умолчанию ИСП-ПРЕФИКС считается равным ПРЕФИКС
и все файлы, архитектурно-зависимые и независимые, устанавливаются в одно дерево ка-
талогов, что вам скорее всего и нужно.
–bindir=КАТАЛОГ
Задаёт каталог для исполняемых двоичных программ. По умолчанию это ИСП-ПРЕФИКС/bin,
что обычно означает /usr/local/pgsql/bin.
–sysconfdir=КАТАЛОГ
Задаёт каталог для различных файлов конфигурации, ПРЕФИКС/etc по умолчанию.
–libdir=КАТАЛОГ
Задаёт каталог для установки библиотек и динамически загружаемых модулей. Значение
по умолчанию — ИСП-ПРЕФИКС/lib.
–includedir=КАТАЛОГ
Задаёт каталог для установки заголовочных файлов C и C++. Значение по умолчанию —
ПРЕФИКС/include.
–datarootdir=КАТАЛОГ
Задаёт корневой каталог для разного рода статических файлов. Этот параметр определяет
только базу для некоторых из следующих параметров. Значение по умолчанию — ПРЕФИКС/
share.
–datadir=КАТАЛОГ
Задаёт каталог для статических файлов данных, используемых установленными програм-
мами. Значение по умолчанию — DATAROOTDIR. Заметьте, что это совсем не тот каталог, в
котором будут размещены файлы базы данных.
–localedir=КАТАЛОГ
Задаёт каталог для установки данных локализации, в частности, каталогов перевода сооб-
щений. Значение по умолчанию — DATAROOTDIR/locale.
–mandir=КАТАЛОГ
Страницы man, поставляемые в составе PostgreSQL, будут установлены в этот каталог, в
соответствующие подкаталоги manx. Значение по умолчанию — DATAROOTDIR/man.
–docdir=КАТАЛОГ
Задаёт корневой каталог для установки файлов документации, кроме страниц «man». Этот
параметр только определяет базу для следующих параметров. Значение по умолчанию —
DATAROOTDIR/doc/postgresql.
–htmldir=КАТАЛОГ
В этот каталог будет помещена документация PostgreSQL в формате HTML. Значение по
умолчанию — DATAROOTDIR.
453Установка из исходного кода
Примечание
Чтобы PostgreSQL можно было установить в стандартные системные размещения
(например, в /usr/local/include), не затрагивая пространство имён остальной си-
стемы, приняты определённые меры. Во-первых, к путям datadir, sysconfdir и
docdir автоматически добавляется строка «/postgresql», если только полный раз-
вёрнутый путь каталога уже не содержит строку «postgres» или «pgsql». Так, ес-
ли вы выберете в качестве префикса /usr/local, документация будет установлена
в /usr/local/doc/postgresql, но с префиксом /opt/postgres она будет помещена
в /opt/postgres/doc. Внешние заголовочные файлы C для клиентских интерфей-
сов устанавливаются в includedir, не загрязняя пространство имён. Внутренние
и серверные заголовочные файлы устанавливаются в частные подкаталоги внутри
includedir. Чтобы узнать, как обращаться к заголовочным файлам того или иного
интерфейса, обратитесь к документации этого интерфейса. Наконец, для динами-
чески загружаемых модулей, если требуется, будет также создан частный подка-
талог внутри libdir.
–with-extra-version=СТРОКА
Заданная СТРОКА добавляется к номеру версии PostgreSQL. Это можно использовать, на-
пример, чтобы двоичные файлы, собранные из промежуточных снимков Git или кода с до-
полнительными правками, отличались от стандартных дополнительной строкой в версии,
например, содержащей идентификатор git describe или номер выпуска дистрибутивного
пакета.
–with-includes=КАТАЛОГИ
Значение КАТАЛОГИ представляет список каталогов через двоеточие, которые будут про-
смотрены компилятором при поиске заголовочных файлов. Если дополнительные пакеты
(например, GNU Readline) установлены у вас в нестандартное расположение, вам придётся
использовать этот параметр и, возможно, также добавить соответствующий параметр –
with-libraries.
Пример: –with-includes=/opt/gnu/include:/usr/sup/include.
–with-libraries=КАТАЛОГИ
Значение КАТАЛОГИ представляет список каталогов через двоеточие, в котором следует ис-
кать библиотеки. Возможно, вам потребуется использовать этот параметр (и соответству-
ющий –with-includes), если какие-то пакеты установлены у вас в нестандартное разме-
щение.
Пример: –with-libraries=/opt/gnu/lib:/usr/sup/lib.
–enable-nls[=ЯЗЫКИ]
Включает поддержку национальных языков (NLS, Native Language Support), то есть воз-
можность выводить сообщения программы не только на английском языке. Значение ЯЗЫКИ
представляет необязательный список кодов языков через пробел, поддержка которых вам
нужна, например: –enable-nls=’de fr ru’. (Пересечение заданного вами списка и мно-
жества действительно доступных переводов будет вычислено автоматически.) Если список
не задаётся, устанавливаются все доступные переводы.
Для использования этой возможности вам потребуется реализация API Gettext; см. выше.
454Установка из исходного кода
–with-pgport=НОМЕР
Задаёт НОМЕР порта по умолчанию для сервера и клиентов. Стандартное значение — 5432.
Этот порт всегда можно изменить позже, но если вы укажете другой номер здесь, и сервер,
и клиенты будут скомпилированы с одним значением, что очень удобно. Обычно менять
это значение имеет смысл, только если вы намерены запускать в одной системе несколько
серверов PostgreSQL.
–with-perl
Включает поддержку языка PL/Perl на стороне сервера.
–with-python
Включает поддержку языка PL/Python на стороне сервера.
–with-tcl
Включает поддержку языка PL/Tcl на стороне сервера.
–with-tclconfig=КАТАЛОГ
Tcl устанавливает файл tclConfig.sh, содержащий конфигурационные данные, необходи-
мые для сборки модулей, взаимодействующих с Tcl. Этот файл обычно находится автома-
тически в известном размещении, но если вы хотите использовать другую версию Tcl, вы
должны указать каталог, где искать этот файл.
–with-gssapi
Включает поддержку аутентификации GSSAPI. На многих платформах подсистема GSSAPI
(обычно входящая в состав Kerberos) устанавливается не в то размещение, которое просмат-
ривается по умолчанию (например, /usr/include, /usr/lib), так что помимо этого парамет-
ра вам придётся задать параметры –with-includes и –with-libraries. Скрипт configure
проверит наличие необходимых заголовочных файлов и библиотек, чтобы убедиться в це-
лостности инсталляции GSSAPI, прежде чем продолжить.
–with-krb-srvnam=ИМЯ
Задаёт имя по умолчанию для субъекта-службы Kerberos, используемое GSSAPI (по умолча-
нию это postgres). Обычно менять его имеет смысл только в среде Windows, где оно должно
быть задано в верхнем регистре (POSTGRES).
–with-llvm
Включает поддержку JIT-компиляции (см. Главу 32) на базе LLVM. Для этого должна быть
установлена библиотека LLVM. В настоящее время требуется версия LLVM не ниже 3.9.
Программа llvm-configбудет использоваться для выяснения требуемых параметров ком-
пиляции. Поиск её будет выполняться в путях PATH по имени llvm-config, а затем llvm-
config-$major-$minor для всех поддерживаемых версий. Если нужный экземпляр програм-
мы найти таким образом не удастся, воспользуйтесь переменной LLVM_CONFIG и укажите
путь к корректному llvm-config. Например:
./configure … –with-llvm LLVM_CONFIG=’/path/to/llvm/bin/llvm-config’
Для поддержки LLVM требуется совместимый компилятор clang (указываемый, если это
требуется, в переменной окружения CLANG) и работающий компилятор C++ (указываемый,
если требуется, в переменной окружения CXX).
–with-icu
Включает поддержку библиотеки ICU. Для этого должен быть установлен пакет ICU4C. В
настоящее время требуется ICU4C версии не ниже 4.2.
455Установка из исходного кода
По умолчанию для определения нужных параметров компиляции будет использоваться
pkg-config. Этот вариант работает для ICU4C версии 4.6 и новее. Для более старых версий
или в отсутствие pkg-config соответствующие параметры для configure можно задать в пе-
ременных ICU_CFLAGS и ICU_LIBS, как в этом примере:
./configure … –with-icu ICU_CFLAGS=’-I/путь/include’ ICU_LIBS=’-L/путь/lib -
licui18n -licuuc -licudata’
(Даже если ICU4C находится в пути поиска, который использует компилятор, тем не ме-
нее нужно задать непустое значение, чтобы избежать обращения к pkg-config, например,
ICU_CFLAGS=’ ‘.)
–with-openssl
Включает поддержку соединений SSL (зашифрованных). Для этого необходимо установить
пакет OpenSSL. Скрипт configure проверит наличие необходимых заголовочных файлов и
библиотек, чтобы убедиться в целостности инсталляции OpenSSL, прежде чем продолжить.
–with-pam
Включает поддержку PAM(Pluggable Authentication Modules, подключаемых модулей аутен-
тификации).
–with-bsd-auth
Включает поддержку аутентификации BSD. (Инфраструктура аутентификации BSD в насто-
ящее время доступна только в OpenBSD.)
–with-ldap
Включает поддержку LDAPдля проверки подлинности и получения параметров соединения
(за дополнительными сведениями обратитесь к Разделу 34.17 и Разделу 20.10). В Unix для
этого нужно установить пакет OpenLDAP. В Windows используется стандартная библиотека
WinLDAP. Скрипт configure проверит наличие необходимых заголовочных файлов и биб-
лиотек, чтобы убедиться в целостности инсталляции OpenLDAP, прежде чем продолжить.
–with-systemd
Включает поддержку служебных уведомлений для systemd. Это улучшает интеграцию с си-
стемой, когда процесс сервера запускается под управлением systemd, и не оказывает ни-
какого влияния в противном случае; за дополнительными сведениями обратитесь к Разде-
лу 18.3. Для использования этой поддержки в системе должна быть установлена libsystemd
с сопутствующими заголовочными файлами.
–without-readline
Запрещает использование библиотеки Readline (а также libedit). При этом отключается ре-
дактирование командной строки и история в psql, так что этот вариант не рекомендуется.
–with-libedit-preferred
Отдаёт предпочтение библиотеке libedit с лицензией BSD, а не Readline (GPL). Этот пара-
метр имеет значение, только если установлены обе библиотеки; по умолчанию в этом слу-
чае используется Readline.
–with-bonjour
Включает поддержку Bonjour. Для этого Bonjour должен поддерживаться самой операци-
онной системой. Рекомендуется для macOS.
456Установка из исходного кода
–with-uuid=БИБЛИОТЕКА
Собрать модуль uuid-ossp (предоставляющий функции для генерирования UUID), используя
заданную библиотеку UUID.БИБЛИОТЕКА может быть следующей:
• bsd, чтобы использовались функции получения UUID, имеющиеся во FreeBSD, NetBSD
и некоторых других системах на базе BSD
• e2fs, чтобы использовалась библиотека получения UUID, созданная в рамках проекта
e2fsprogs; эта библиотека присутствует в большинстве систем Linux и macOS, также
её можно найти и для других платформ.
• ossp, чтобы использовалась библиотека OSSP UUID
–with-ossp-uuid
Устаревший вариант указания –with-uuid=ossp.
–with-libxml
Собрать с libxml (включает поддержку SQL/XML). Для этого требуется libxml версии 2.6.23
или новее.
В составе libxml устанавливается программа xml2-config, с помощью которой можно полу-
чить требуемые параметры компилятора и компоновщика. PostgreSQL будет использовать
её автоматически, если найдёт. Чтобы указать нестандартное размещение libxml, вы мо-
жете воспользоваться переменной окружения XML2<em>CONFIG и указать в ней путь к програм-
ме xml2-config нужной инсталляции, либо задать параметры –with-includes и –with-
libraries.
–with-libxslt
Использовать libxslt при сборке модуля xml2. Библиотека xml2 задействует её для выпол-
нения XSL-преобразований XML.
–disable-float4-byval
Запрещает передачу типа float4 «по значению», чтобы он передавался «по ссылке». Это
снижает быстродействие, но может быть необходимо для совместимости со старыми поль-
зовательскими функциями на языке C, которые используют соглашение о вызовах «версии
0». В качестве более долгосрочного решения лучше модернизировать такие функции, что-
бы они использовали соглашение «версии 1».
–disable-float8-byval
Запрещает передачу типа float8 «по значению», чтобы он передавался «по ссылке». Это
снижает быстродействие, но может быть необходимо для совместимости со старыми поль-
зовательскими функциями на языке C, которые используют соглашение о вызовах «версии
0». В качестве более долгосрочного решения лучше модернизировать такие функции, что-
бы они использовали соглашение «версии 1». Заметьте, что этот параметр влияет не только
на float8, но и на int8, а также некоторые другие типы, например timestamp. На 32-битных
платформах параметр –disable-float8-byval действует по умолчанию и задать –enable-
float8-byval нельзя.
–with-segsize=РАЗМЕР_СЕГМЕНТА
Задаёт размер сегмента (в гигабайтах). Сервер делит большие таблицы на несколько фай-
лов в файловой системе, ограничивая размер каждого данным размером сегмента. Это поз-
воляет обойти ограничения на размер файлов, существующие на многих платформах. Раз-
мер сегмента по умолчанию, 1 гигабайт, безопасен для всех поддерживаемых платформ. Ес-
ли же ваша операционная система поддерживает «большие файлы» (а сегодня это поддер-
живают почти все), вы можете установить больший размер сегмента. Это позволит умень-
457Установка из исходного кода
шить число файловых дескрипторов, используемых при работе с очень большими таблица-
ми. Но будьте осторожны, чтобы выбранное значение не превысило максимум, поддержи-
ваемый вашей платформой и файловыми системами, которые вы будете применять. Воз-
можно, допустимый размер файла будет ограничиваться и другими утилитами, которые вы
захотите использовать, например tar. Рекомендуется, хотя и не требуется, чтобы это значе-
ние было степенью 2. Заметьте, что при изменении значения требуется выполнить initdb.
–with-blocksize=РАЗМЕР_БЛОКА
Задаёт размер блока (в килобайтах). Эта величина будет единицей хранения и ввода/вывода
данных таблиц. Значение по умолчанию, 8 килобайт, достаточно универсально; но в особых
случаях может быть оправдан другой размер блока. Это значение должно быть степенью
2 от 1 до 32 (в килобайтах). Заметьте, что при изменении значения требуется выполнить
initdb.
–with-wal-blocksize=РАЗМЕР_БЛОКА
Задаёт размер блока WAL (в килобайтах) Эта величина будет единицей хранения и вво-
да/вывода записей WAL. Значение по умолчанию, 8 килобайт, достаточно универсально; но
в особых случаях может быть оправдан другой размер блока. Это значение должно быть
степенью 2 от 1 до 64 (в килобайтах). Заметьте, что при изменении значения требуется
выполнить initdb.
–disable-spinlocks
Позволяет провести сборку, если PostgreSQL не может воспользоваться циклическими бло-
кировками CPU на данной платформе. Отсутствие таких блокировок приводит к снижению
производительности, поэтому использовать этот вариант следует, только если сборка пре-
рывается и выдаётся сообщение, что ваша платформа эти блокировки не поддерживает.
Если вы не можете собрать PostgreSQL на вашей платформе без этого указания, сообщите
о данной проблеме разработчикам PostgreSQL.
–disable-strong-random
Разрешает производить сборку, даже если в PostgreSQL отсутствует поддержка генериро-
вания криптографически стойких случайных ключей на данной платформе. Источник слу-
чайных чисел необходим для некоторых протоколов аутентификации, а также некоторых
функций в модуле pgcrypto. Ключ –disable-strong-random отключает функциональность,
требующую криптографически стойкие случайные числа, и задействует для получения со-
ли и ключей отмены запросов слабый генератор псевдослучайных чисел. Это может сде-
лать аутентификацию менее безопасной.
–disable-thread-safety
Отключает потокобезопасное поведение клиентских библиотек. При этом параллельные
потоки программ на базе libpq и ECPG не будут безопасно контролировать собственные
дескрипторы соединений.
–with-system-tzdata=КАТАЛОГ
В PostgreSQL включена собственная база данных часовых поясов, необходимая для опера-
ций с датой и временем. На самом деле эта база данных совместима с базой часовых поясов
IANA, поставляемой в составе многих операционных систем FreeBSD, Linux, Solaris, поэто-
му устанавливать её дополнительно может быть излишне. С этим параметром вместо базы
данных, включённой в пакет исходного кода PostgreSQL, будет использоваться системная
база данных часовых поясов, находящаяся в заданном КАТАЛОГЕ. КАТАЛОГ должен задавать-
ся абсолютным путём (в ряде операционных систем принят путь /usr/share/zoneinfo). За-
метьте, что процедура установки не будет проверять несоответствия или ошибки в данных
часовых поясов. Поэтому, используя этот параметр, рекомендуется выполнить регрессион-
ные тесты, чтобы убедиться, что выбранная вами база данных часовых поясов работает кор-
ректно с PostgreSQL.
458Установка из исходного кода
Этот параметр в основном предназначен для тех, кто собирает двоичные пакеты для дис-
трибутивов и хорошо знает свою операционную систему. Основной плюс от использова-
ния системных данных в том, что пакет PostgreSQL не придётся обновлять при изменени-
ях местных определений часовых поясов. Ещё один плюс заключается в упрощении кросс-
компиляции, так как при инсталляции не требуется собирать базу данных часовых поясов.
–without-zlib
Запрещает использование библиотеки Zlib. При этом отключается поддержка сжатых ар-
хивов утилитами pg_dump и pg_restore. Этот параметр предназначен только для тех редких
систем, в которых нет этой библиотеки.
–enable-debug
Включает компиляцию всех программ и библиотек с отладочными символами. Это значит,
что вы сможете запускать программы в отладчике для анализа проблем. При такой компи-
ляции размер установленных исполняемых файлов значительно увеличивается, а компи-
ляторы, кроме GCC, обычно отключают оптимизацию, что снижает быстродействие. Одна-
ко, наличие отладочных символов очень полезно при решении возможных проблем любой
сложности. В настоящее время рекомендуется использовать этот параметр для производ-
ственной среды, только если применяется компилятор GCC. Но если вы занимаетесь раз-
работкой или испытываете бета-версию, его следует использовать всегда.
–enable-coverage
При использовании GCC все программы и библиотеки компилируются с инструментарием,
оценивающим покрытие кода тестами. Если его запустить, в каталоге сборки будут сфор-
мированы файлы с метриками покрытия кода. За дополнительными сведениями обратитесь
к Разделу 33.5. Этот параметр предназначен только для GCC и только для использования
в процессе разработки.
–enable-profiling
При использовании GCC все программы и библиотеки компилируются так, чтобы их можно
было профилировать. В результате по завершении серверного процесса будет создаваться
подкаталог с файлом gmon.out для профилирования. Этот параметр предназначен только
для GCC и только для тех, кто занимается разработкой.
–enable-cassert
Включает для сервера проверочные утверждения, проверяющие множество условий, ко-
торые «не должны происходить». Это бесценно в процессе разработке кода, но эти проверки
могут значительно замедлить работу сервера. Кроме того, включение этих проверок не обя-
зательно увеличит стабильность вашего сервера! Проверочные утверждения не категори-
зируются по важности, поэтому относительно безвредная ошибка может привести к пере-
запуску сервера, если утверждение не выполнится. Применять это следует, только если вы
занимаетесь разработкой или испытываете бета-версию, но не в производственной среде.
–enable-depend
Включает автоматическое отслеживание зависимостей. С этим параметром скрипты
Makefile настраиваются так, чтобы при изменении любого заголовочного файла пересоби-
рались все зависимые объектные файлы. Это полезно в процессе разработки, но если вам
нужно только скомпилировать и установить сервер, это будет лишней тратой времени. В
настоящее время это работает только с GCC.
–enable-dtrace
Включает при компиляции PostgreSQL поддержку средства динамической трассировки
DTrace. За дополнительными сведениями обратитесь к Разделу 28.5.
459Установка из исходного кода
Задать расположение программы dtrace можно в переменной окружения DTRACE. Часто
это необходимо, потому что dtrace обычно устанавливается в каталог /usr/sbin, который
может отсутствовать в пути поиска.
Дополнительные параметры командной строки для dtrace можно задать в переменной
окружения DTRACEFLAGS. В Solaris, чтобы включить поддержку DTrace для 64-битной сбор-
ки, необходимо передать configure параметр DTRACEFLAGS=”-64”. Например, с компилято-
ром GCC:
./configure CC=’gcc -m64’ –enable-dtrace DTRACEFLAGS=’-64’ …
С компилятором Sun:
./configure CC=’/opt/SUNWspro/bin/cc -xtarget=native64’ –enable-dtrace
DTRACEFLAGS=’-64’ …
–enable-tap-tests
Включает тесты по технологии Perl TAP. Для этого у вас должен быть установлен Perl и
модуль IPC::Run. За дополнительными сведениями обратитесь к Разделу 33.4.
Если вы предпочитаете компилятор C, отличный от выбираемого скриптом configure, укажи-
те его в переменной CC. По умолчанию configure выбирает gcc (если он находится) или стан-
дартный компилятор платформы (обычно cc). Подобным образом, при необходимости можно
переопределить флаги компилятора по умолчанию с помощью переменной CFLAGS.
Вы можете задать переменные окружения в командной строке configure, например, так:
./configure CC=/opt/bin/gcc CFLAGS=’-O2 -pipe’
Ниже приведён список значимых переменных, которые можно установить таким образом:
BISON
Программа Bison
CC
компилятор C
CFLAGS
параметры, передаваемые компилятору C
CLANG
путь к программе clang, которая будет подготавливать исходный код для встраивания при
компиляции с ключом –with-llvm
CPP
препроцессор C
CPPFLAGS
параметры, передаваемые препроцессору C
CXX
компилятор C++
CXXFLAGS
параметры, передаваемые компилятору C++
460Установка из исходного кода
DTRACE
расположение программы dtrace
DTRACEFLAGS
параметры, передаваемые программе dtrace
FLEX
программа Flex
LDFLAGS
параметры, которые должны использоваться при компоновке исполняемых программ или
разделяемых библиотек
LDFLAGS_EX
дополнительные параметры для компоновки только исполняемых программ
LDFLAGS_SL
дополнительные параметры для компоновки только разделяемых библиотек
LLVM_CONFIG
Программа llvm-config помогает найти инсталляцию LLVM.
MSGFMT
расположение программы msgfmt для поддержки национальных языков
PERL
Полный путь к интерпретатору Perl. Он помогает определить зависимости для сборки PL/
Perl.
PYTHON
Полный путь к интерпретатору Python. Он помогает определить зависимости для сборки
PL/Python. Кроме того, выбранная таким образом (или неявно как-то ещё) версия Python, 2
или 3, определяет вариацию языка PL/Python, которая будет доступна. За дополнительными
сведениями обратитесь к Разделу 46.1.
TCLSH
Полный путь к интерпретатору Tcl. Он помогает определить зависимости для сборки PL/Tcl
и будет подставляться в скрипты Tcl.
XML2_CONFIG
Программа xml2-config помогает найти инсталляцию libxml.
Иногда может быть полезно добавить флаги компилятора к набору флагов, ранее заданному
на этапе configure. В частности, эта потребность объясняется тем, что параметр gcc -Werror
нельзя указать в переменной CFLAGS, передаваемой configure, так как в результате сломаются
многие встроенные тесты configure. Чтобы добавить такие флаги, задайте их в переменной
среды COPT при запуске make. Содержимое COPT будет добавлено в параметры CFLAGS и LDFLAGS,
заданные скриптом configure. Например, вы можете выполнить:
make COPT=’-Werror’
или
export COPT=’-Werror’
461Установка из исходного кода
make
Примечание
Разрабатывая внутренний код сервера, рекомендуется использовать указания
configure –enable-cassert (которое включает множество проверок во время вы-
полнения) и –enable-debug (которое упрощает использование средств отладки).
Используя GCC, лучше выполнять сборку с уровнем оптимизации не ниже -O1, так
как без оптимизации (-O0) отключаются некоторые важные предупреждения ком-
пилятора (например, об использовании неинициализированных переменных). Од-
нако оптимизация ненулевого уровня может затруднить отладку, так как при по-
шаговом выполнении скомпилированный код обычно не соответствует в точности
строкам исходного кода. При возникновении сложностей с отладкой оптимизиро-
ванного кода, перекомпилируйте интересующие вас файлы с ключом -O0. Это мож-
но сделать, просто передав соответствующий параметр make: make PROFILE=-O0
file.o.
На самом деле переменные окружения COPT и PROFILE обрабатываются сборочны-
ми файлами Makefile PostgreSQL одинаково. Поэтому выбор одной из этих перемен-
ных — дело вкуса, но обычно разработчики используют PROFILE для одноразовых
корректив флагов, а содержимое COPT сохраняют постоянным.
2.
Сборка
Чтобы запустить сборку, введите одну из двух команд:
make
make all
(Помните, что нужно использовать GNU make.) Сборка займёт несколько минут, в зависимости
от мощности вашего компьютера. В конце должно появиться сообщение:
All of PostgreSQL successfully made. Ready to install.
(Весь PostgreSQL собран успешно и готов к установке.)
Если вы хотите собрать всё, что может быть собрано, включая документацию (страницы HTML
и man) и дополнительные модули (contrib), введите:
make world
В конце должно появиться сообщение:
PostgreSQL, contrib and documentation successfully made. Ready to install.
(PostgreSQL, contrib и документация собраны успешно и готовы к установке.)
Если вы хотите вызывать сборку из другого сборочного файла, а не вручную, вы должны сбро-
сить переменную MAKELEVEL или присвоить ей 0, например так:
build-postgresql:
$(MAKE) -C postgresql MAKELEVEL=0 all
Если этого не сделать, могут выдаваться странные ошибки, обычно с сообщениями о недоста-
ющих заголовочных файлах.
3.
Регрессионные тесты
Если вы хотите протестировать только что собранный сервер, прежде чем устанавливать его,
на этом этапе вы можете запустить регрессионные тесты. Регрессионные тесты — это комплек-
тов тестов, проверяющих, что PostgreSQL работает на вашем компьютере так, как задумано
разработчиками. Введите:
462Установка из исходного кода
make check
(Это должен выполнять обычный пользователь, не root.) Как интерпретировать результаты про-
верки, подробно описывается в Главе 33. Вы можете повторить эту проверку позже в любой
момент, выполнив ту же команду.
4.
Установка файлов
Примечание
Если вы обновляете существующую систему, обязательно прочитайте инструкции
по обновлению кластера, приведённые в Раздел 18.6.
Чтобы установить PostgreSQL, введите:
make install
При этом файлы будут установлены в каталоги, заданные в Шаг 1. Убедитесь в том, что у вас
есть соответствующие разрешения для записи туда. Обычно это действие нужно выполнять от
имени root. Также возможно заранее создать целевые каталоги и дать требуемый доступ к ним.
Чтобы установить документацию (HTML и страницы man), введите:
make install-docs
Если вы собирали цель world, введите вместо этого:
make install-world
При этом также будет установлена документация.
Вы можете запустить make install-strip вместо make install, чтобы убрать лишнее из уста-
навливаемых исполняемых файлов и библиотек. Это позволит сэкономить немного места. Если
вы выполняете сборку для отладки, при этом фактически вырежется поддержка отладки, по-
этому этот вариант подходит только если отладка больше не планируется. Процедура install-
strip пытается оптимизировать объём разумными способами, но не рассчитывайте, что она
способна удалить каждый ненужный байт из исполняемого файла. Если вы хотите освободить
как можно больше места, вам придётся проделать это вручную.
При стандартной установке в систему устанавливаются все заголовочные файлы для разработ-
ки клиентских приложений, а также программ на стороне сервера, в частности, собственных
функций или типов данных, реализованных на C. (До PostgreSQL 8.0 для этого требовалось вы-
полнить make install-all-headers, но сейчас это включено в стандартную установку.)
Установка только клиентской части:  Если вы хотите установить только клиентские при-
ложения и интерфейсные библиотеки, можно выполнить эти команды:
make
make
make
make
-C
-C
-C
-C
src/bin install
src/include install
src/interfaces install
doc install
В src/bin есть несколько программ, применимых только на сервере, но они очень малы.
Удаление:  Чтобы отменить установку, воспользуйтесь командой make uninstall. Однако со-
зданные каталоги при этом удалены не будут.
Очистка:  После установки вы можете освободить место на диске, удалив файлы сборки из дере-
ва исходного кода, выполнив make clean. При этом файлы, созданные программой configure, бу-
дут сохранены, так что позже вы сможете пересобрать всё заново, выполнив make. Чтобы сбросить
дерево исходного кода к состоянию, в котором оно распространяется, выполните make distclean.
Если вы намерены выполнять сборку одного дерева исходного кода для нескольких платформ, вам
463Установка из исходного кода
придётся делать это и переконфигурировать сборочную среду для каждой. (Также можно исполь-
зовать отдельное дерево сборки для каждой платформы, чтобы дерево исходного кода оставалось
неизменным.)
Если в процессе сборки вы обнаружите, что заданные вами параметры configure оказались оши-
бочными, либо вы изменили что-то, от чего зависит работа configure (например, обновили паке-
ты), стоит выполнить make distclean, прежде чем переконфигурировать и пересобирать всё за-
ново. Если этого не сделать, ваши изменения в конфигурации могут распространиться не везде,
где они важны.
16.5. Действия после установки
16.5.1. Разделяемые библиотеки
В некоторых системах с разделяемыми библиотеками необходимо указать системе, как найти
недавно установленные разделяемые библиотеки. К числу систем, где это не требуется, относятся
FreeBSD, HP-UX, Linux, NetBSD, OpenBSD и Solaris.
Путь поиска разделяемых библиотек на разных платформах может устанавливаться по-разному,
но наиболее распространённый способ — установить переменную окружения LD_LIBRARY_PATH,
например так: в оболочках Bourne (sh, ksh, bash, zsh):
LD_LIBRARY_PATH=/usr/local/pgsql/lib
export LD_LIBRARY_PATH
или в csh, tcsh:
setenv LD_LIBRARY_PATH /usr/local/pgsql/lib
Замените /usr/local/pgsql/lib значением, переданным Шаг 1 в –libdir. Эти команды следу-
ет поместить в стартовый файл оболочки, например, в /etc/profile или ~/.bash_profile. Полез-
ные предостережения об использовании этого метода приведены на странице http://xahlee.info/
UnixResource_dir/</em>/ldpath.html.
В некоторых системах предпочтительнее установить переменную окружения LD_RUN_PATH до сбор-
ки.
В Cygwin добавьте каталог с библиотеками в PATH или переместите файлы .dll в каталог bin.
В случае сомнений обратитесь к страницам руководства по вашей системе (возможно, к справке
по ld.so или rld). Если вы позже получаете сообщение:
psql: error in loading shared libraries
libpq.so.2.1: cannot open shared object file: No such file or directory
(psql: ошибка при загрузке разделяемых библиотек libpq.so.2.1: не удалось открыть разделяемый
объектный файл: Нет такого файла или каталога), значит этот шаг был необходим. Тогда вам про-
сто нужно вернуться к нему.
Если вы используете Linux и имеете права root, вы можете запустить:
/sbin/ldconfig /usr/local/pgsql/lib
(возможно, с другим каталогом) после установки, чтобы механизм связывания во время выполне-
ния мог найти разделяемые библиотеки быстрее. За дополнительными сведениями обратитесь к
странице руководства по ldconfig. Во FreeBSD, NetBSD и OpenBSD команда будет такой:
/sbin/ldconfig -m /usr/local/pgsql/lib
В других системах подобной команды может не быть.
16.5.2. Переменные окружения
Если целевым каталогом был выбран /usr/local/pgsql или какой-то другой, по умолчанию отсут-
ствующий в пути поиска, вам следует добавить /usr/local/pgsql/bin (или другой путь, передан-
464Установка из исходного кода
ный Шаг 1 в указании –bindir) в вашу переменную PATH. Строго говоря, это не обязательно, но
при этом использовать PostgreSQL будет гораздо удобнее.
Для этого добавьте в ваш скрипт запуска оболочки, например ~/.bash_profile (или в /etc/
profile, если это нужно всем пользователям):
PATH=/usr/local/pgsql/bin:$PATH
export PATH
Для оболочек csh или tcsh команда должна быть такой:
set path = ( /usr/local/pgsql/bin $path )
Чтобы ваша система могла найти документацию man, вам нужно добавить в скрипт запуска обо-
лочки примерно следующие строки, если только она не установлена в размещение, просматрива-
емое по умолчанию:
MANPATH=/usr/local/pgsql/share/man:$MANPATH
export MANPATH
Переменные окружения PGHOST и PGPORT задают для клиентских приложений адрес компьютера
и порт сервера базы данных, переопределяя стандартные значения. Если планируется запускать
клиентские приложения удалённо, пользователям, которые будут использовать определённый сер-
вер, будет удобно, если они установят PGHOST. Однако это не обязательно, так как большинство
клиентских программ могут принять эти параметры через аргументы командной строки.
16.6. Поддерживаемые платформы
Платформа (то есть комбинация архитектуры процессора и операционной системы) считается под-
держиваемой сообществом разработчиков PostgreSQL, если код адаптирован для работы на этой
платформе, и он в настоящее время успешно собирается и проходит регрессионные тесты на ней.
В настоящее время тестирование совместимости в основном выполняется автоматически в Ферме
сборки PostgreSQL. Если вы заинтересованы в использовании PostgreSQL на платформе, ещё не
представленной в ферме сборки, но уверены, что код на ней работает или может работать, мы
очень хотели бы, чтобы вы включили в ферму сборки свой компьютер с этой платформой для по-
стоянной гарантии совместимости.
Вообще следует ожидать, что PostgreSQL будет работать на процессорах следующих архитектур:
x86, x86_64, IA64, PowerPC, PowerPC 64, S/390, S/390x, Sparc, Sparc 64, ARM, MIPS, MIPSEL и PA-
RISC. Есть также код для поддержки M68K, M32R и VAX, но неизвестно, проверялась ли его ра-
бота в последнее время. Часто сервер можно собрать для неподдерживаемого типа процессора,
сконфигурировав сборку с указанием –disable-spinlocks, но производительность при этом бу-
дет неудовлетворительной.
Также следует ожидать, что сервер PostgreSQL будет работать в следующих операционных си-
стемах: Linux (все последние дистрибутивы), Windows (Win2000 SP4 и новее), FreeBSD, OpenBSD,
NetBSD, macOS, AIX, HP/UX и Solaris. Возможна также работа в других Unix-подобных системах,
но в настоящее время она не проверяется. При этом в большинстве случаев он будет работать на
процессорах всех архитектур, поддерживаемых данной операционной системой. Перейдите к Раз-
делу 16.7 и проверьте, нет ли там замечаний, относящихся именно к вашей операционной системе,
особенно если вы используете не самую новую систему.
Если вы столкнулись с проблемами установки на платформе, которая считается поддерживаемой
согласно последним результатам сборки в нашей ферме, пожалуйста, сообщите о них по адресу
<a href="mailto:pgsql-bugs@postgresql.org">pgsql-bugs@postgresql.org</a>. Если вы заинтересованы в переносе PostgreSQL на новую платфор-
му, обсудить это можно в рассылке <a href="mailto:pgsql-hackers@postgresql.org">pgsql-hackers@postgresql.org</a>.
16.7. Замечания по отдельным платформам
В этом разделе приведены дополнительные замечания по отдельным платформам, связанные с
установкой и подготовкой к работе PostgreSQL. Обязательно изучите ещё инструкции по установ-
465Установка из исходного кода
ке, в частности Раздел 16.2. Также обратитесь к Главе 33, где рассказывается, как прочитать ре-
зультаты регрессионных тестов.
Если какие-то платформы здесь не упоминаются, значит каких-либо известных особенностей уста-
новки в них нет.
16.7.1. AIX
PostgreSQL работает в AIX, но установить его правильно может быть непростой задачей. Поддер-
живаемыми считаются версии AIX с 4.3.3 до 6.1. Для сборки вы можете применить GCC или соб-
ственный компилятор IBM xlc. Вообще говоря, полезно использовать последние версии AIX и
PostgreSQL. Получить актуальную информацию о версиях AIX, работа в которых проверена на дан-
ный момент, можно на сайте фермы сборки.
Минимальные рекомендуемые уровни исправлений для поддерживаемых версий AIX:
AIX 4.3.3
Эксплуатационный уровень (ML) 11 + пакет исправлений после ML11
AIX 5.1
Эксплуатационный уровень (ML) 9 + пакет исправлений после ML9
AIX 5.2
Технологический уровень (TL) 10, Пакет обновлений (SP) 3
AIX 5.3
Технологический уровень (TL) 7
AIX 6.1
Базовый уровень
Чтобы проверить ваш текущий уровень исправлений, выполните oslevel -r в AIX версии с 4.3.3
по 5.2 ML 7, либо oslevel -s в более поздних версиях.
Если Readline или libz у вас установлены не в /usr/local, передайте configure следующие ключи
в дополнение к вашим: –with-includes=/usr/local/include –with-libraries=/usr/local/lib.
16.7.1.1. Особенности использования GCC
В AIX 5.3 наблюдались проблемы с компиляцией и запуском PostgreSQL с использованием GCC.
Для успешной сборки вам потребуется GCC версии новее 3.3.2, особенно, если вы используете
версию из системного пакета. Мы добивались успеха с 4.0.1. Проблемы с предыдущими версиями,
судя по всему, были связаны больше с тем, как IBM упаковала GCC, а не собственно с GCC, поэтому
если вы скомпилируете GCC самостоятельно, положительный исход возможен и с ранней версией
GCC.
16.7.1.2. Неработающие Unix-сокеты
В AIX 5.3 была проблема с размером структуры sockaddr_storage. В версии 5.3 IBM увеличила
размер sockaddr_un, структуры адреса для Unix-сокетов, но не увеличила соответственно размер
sockaddr_storage. В итоге при попытке PostgreSQL использовать Unix-сокеты происходило пере-
полнение этой структуры в libpq. Подключение через TCP/IP устанавливается корректно, а через
Unix-сокеты — нет, и в результате регрессионные тесты не проходят.
Об этой проблеме было сообщено IBM, она зафиксирована в отчёте об ошибке PMR29657. Если вы
обновите систему до эксплуатационного уровня 5300-03 или новее, она получит соответствующее
исправление. В качестве временного решения можно присвоить _SS_MAXSIZE значение 1025 в /
usr/include/sys/socket.h. В любом случае, после исправления этого заголовочного файла пере-
компилируйте PostgreSQL.
466Установка из исходного кода
16.7.1.3. Проблемы с сетевыми адресами
PostgreSQL пользуется системной функцией getaddrinfo для разбора IP-адресов, указанных в па-
раметре listen_addresses, файле pg_hba.conf и т. д. В старых версиях AIX эта функция работала
некорректно. Если вы столкнулись с проблемами в этой области, обновление до уровня исправле-
ний AIX, обозначенного выше, должно решить их.
Один пользователь сообщает:
Используя PostgreSQL версии 8.1 в AIX 5.3, мы периодически сталкивались с тем, что сборщик
статистики «загадочным образом» не запускается. Кажется, это результат незапланированного
поведения реализации IPv6. Похоже, что PostgreSQL и IPv6 не дружат в AIX 5.3.
Для «решения» проблемы можно выполнить одно из следующих действий.
• Удалите адрес IPv6 для localhost:
(от имени root)</p>
<h1 id="ifconfig-lo0-inet6-10-delete">ifconfig lo0 inet6 ::1/0 delete</h1>
<p>• Удалите IPv6 из сетевых сервисов. Файл /etc/netsvc.conf в AIX примерно соответствует фай-
лу /etc/nsswitch.conf в Solaris/Linux. По умолчанию в AIX он выглядит так:
hosts=local,bind
Чтобы отключить поиск адресов IPv6, замените его содержимое следующим:
hosts=local4,bind4
Предупреждение
К этим временным решениям приходилось прибегать из-за проблем, связанных с сырой
реализацией IPv6, которая заметно улучшилась в последующих выпусках AIX 5.3. Эти
решения работали в AIX версии 5.3, но они конечно далеки от идеальных. Кроме того,
сообщалось, что они не только не требуются, но и приводят к другим проблемам в AIX
6.1, где поддержка IPv6 стала более зрелой.
16.7.1.4. Управление памятью
Иногда управление памятью в AIX может работать несколько странно. В системе может быть сво-
бодно несколько гигабайт ОЗУ, но при запуске приложений всё равно возможны ошибки, связан-
ные с адресным пространством или нехваткой памяти. В частности, необычные ошибки могут воз-
никать при загрузке расширений. Например, при выполнении от имени владельца инсталляции
PostgreSQL:
=# CREATE EXTENSION plperl;
ERROR: could not load library “/opt/dbs/pgsql/lib/plperl.so”: A memory address is not
in the address space for the process.
(ОШИБКА: не удалось загрузить библиотеку “/opt/dbs/pgsql/lib/plperl.so”: Адрес памяти находит-
ся не в адресном пространстве процесса.) При выполнении от имени не владельца, а члена груп-
пы-владельца инсталляции PostgreSQL:
=# CREATE EXTENSION plperl;
ERROR: could not load library “/opt/dbs/pgsql/lib/plperl.so”: Bad address
(ОШИБКА: не удалось загрузить библиотеку “/opt/dbs/pgsql/lib/plperl.so”: Неверный адрес) Также
сообщения о нехватке могут появляться в журнале PostgreSQL при попытке выделить блок памяти
размером около 256 МиБ или больше.
Общая причина всех этих проблем связана с битностью и моделью памяти серверного процесса.
По умолчанию все исполняемые файлы для AIX собираются как 32-битные, вне зависимости от
того, какой тип оборудования или ядра используется. Такие 32-битные процессы ограничиваются
467Установка из исходного кода
общим пространством в 4 ГиБ, разделённым на сегменты по 256 МиБ, по одной из нескольких
моделей. По умолчанию в куче можно выделить меньше 256 МиБ, так как она разделяет один
сегмент со стеком.
В ситуации с показанным выше примером plperl проверьте umask и разрешения, назначенные
для двоичных файлов в вашей инсталляции PostgreSQL. Задействованные в данном примере дво-
ичные файлы были 32-битными и установились с режимом 750 вместо 755. Из-за таких разреше-
ний только владелец или член группы-владельца могли загрузить требуемую библиотеку. Так как
она недоступна для чтения всем, загрузчик помещал этот объект в область кучи процесса, а не в
сегменты разделяемых библиотек, где он должен находиться.
В «идеале» эту проблему можно решить, если использовать 64-битную сборку PostgreSQL, но это не
всегда практично, так как с 32-битным процессором нельзя будет запустить 64-битный код (можно
только собрать).
При желании использовать 32-битную версию сервера установите в LDR_CNTRL значение
MAXDATA=0xn0000000, где 1 &lt;= n &lt;= 8, до запуска PostgreSQL, и попробуйте подобрать подходя-
щее значение и параметры postgresql.conf. Переменная окружения LDR_CNTRL говорит AIX, что
вы хотите, чтобы сервер получил MAXDATA байт для области кучи, в сегментах по 256 МиБ. Подо-
брав рабочее значение, можно воспользоваться ldedit и модифицировать двоичные файлы, чтобы
они использовали такой размер кучи по умолчанию. Тот же эффект можно получить, пересобрав
PostgreSQL с указанием configure LDFLAGS=”-Wl,-bmaxdata:0xn0000000”.
Для 64-битной сборки определите переменную OBJECT_MODE со значением 64 и передайте
configure указания CC=”gcc -maix64” и LDFLAGS=”-Wl,-bbigtoc”. (Для xlc параметры могут быть
другими.) Если нужное значение OBJECT_MODE не будет экспортировано, при сборке могут произой-
ти ошибки на стадии компоновки. Когда переменная OBJECT_MODE установлена, она говорит сбо-
рочным утилитам AIX, таким как ar, as и ld, какие типы объектов обрабатывать по умолчанию.
По умолчанию система может чрезмерно выделять память в пространстве подкачки. Хотя нам не
приходилось с этим сталкиваться, AIX уничтожает процессы при попытке обращения к чрезмерно
выделенной памяти, когда её фактически не хватает. Наиболее близкое, что мы наблюдали, была
ошибка порождения процесса из-за того, что система решала, что для него не хватает памяти. Как
и многие другие компоненты AIX, механизмы распределения пространства подкачки и уничтоже-
ния процессов при нехватке памяти можно настроить на уровне системы или процесса, если воз-
никают подобные проблемы.
Ссылки и ресурсы
«Large Program Support». Документация AIX: Общие концепции программирования: Написание и
отладка программ.
«Program Address Space Overview». Документация AIX: Общие концепции программирования: На-
писание и отладка программ.
«Performance Overview of the Virtual Memory Manager (VMM)». Документация AIX: Руководство по
управлению производительностью.
«Page Space Allocation». Документация AIX: Руководство по управлению производительностью.
«Paging-space thresholds tuning». Документация AIX: Руководство по управлению производитель-
ностью.
Developing and Porting C and C++ Applications on AIX. Красная книга IBM.
16.7.2. Cygwin
PostgreSQL можно собрать с применением Cygwin, Linux-подобной среды для Windows, но сейчас
этому методу предпочитается обычная сборка в Windows (см. Главу 17), и запускать сервер в среде
Cygwin более не рекомендуется.
468Установка из исходного кода
Выполняя сборку, следуйте обычной процедуре установки (т. е., ./configure; make; и т. д.), с
учётом следующих особенностей Cygwin:
• Настройте путь поиска так, чтобы каталог bin в Cygwin стоял перед каталогами утилит
Windows. Это поможет избавиться от проблем при компиляции.
• Команда adduser не поддерживается; воспользуйтесь соответствующим средством управле-
ния пользователями для Windows NT, 2000 или XP. Либо просто пропустите этот шаг.
• Команда su не поддерживается; для эмуляции su в Windows NT, 2000 или XP воспользуйтесь
ssh. Либо пропустите этот шаг.
• OpenSSL не поддерживается.
• Запустите cygserver для поддержки разделяемой памяти. Для этого введите команду /usr/
sbin/cygserver &amp;. Эта программа должна работать всегда при запуске сервера PostgreSQL
или инициализации кластера баз данных (initdb). Возможно, вам придётся настроить конфи-
гурацию cygserver (например, увеличить SEMMNS), чтобы PostgreSQL мог получить требуемые
системные ресурсы.
• Сборка может завершиться ошибкой в некоторых системах, где используется локаль, отлич-
ная от C. Чтобы исправить это, выберите локаль C, выполнив export LANG=C.utf8 до сборки, а
затем восстановите предыдущее значение после установки PostgreSQL.
• Параллельные регрессионные тесты (make check) могут выдавать ложные ошибки тестиро-
вания при переполнении очереди listen(), из-за чего подключения могут не устанавливать-
ся или зависать. Вы можете ограничить число подключений, определив переменную make
MAX_CONNECTIONS так:
make MAX_CONNECTIONS=5 check
(В некоторых системах поддерживается до 10 одновременных подключений).
Сервер PostgreSQL и cygserver можно запустить в виде служб Windows NT. Как это сделать, рас-
сказывается в описании README, включённом в двоичный пакет PostgreSQL для Cygwin. Оно уста-
навливается в каталог /usr/share/doc/Cygwin.
16.7.3. HP-UX
PostgreSQL 7.3+ должен работать на машинах Series 700/800 PA-RISC под управлением HP-UX 10.X
или 11.X, с подходящими уровнями системных исправлений и средствами сборки. Как минимум
один разработчик регулярно тестирует сборку в HP-UX 10.20, и мы получали сообщения об успеш-
ных установках в HP-UX 11.00 и 11.11.
Помимо пакета исходного кода PostgreSQL, вам потребуется GNU make (HP make не подойдёт) и
GCC или полный компилятор ANSI C от HP. Если вы намерены выполнить сборку не из дистрибутив-
ного пакета исходного кода, а из Git, вам также потребуется Flex (GNU lex) и Bison (GNU yacc). Мы
также рекомендуем убедиться, что у вас установлены довольно свежие исправления HP. Для сбор-
ки 64-битного кода в HP-UX 11.11 вам потребуется PHSS_30966 (11.11) или более новое исправле-
ние, без него initdb может зависать. Как правило, для сборки нужно иметь текущие исправления
libc и ld/dld, а также компилятора (если вы используете компилятор HP). Получить эти исправле-
ния бесплатно можно на сайтах поддержки HP (например здесь: ftp://us-ffs.external.hp.com/).
Если вы проводите сборку на машине PA-RISC 2.0 и хотите получить 64-битный исполняемый код,
вы должны использовать 64-битную версию GCC.
Если вы проводите сборку на машине PA-RISC 2.0 и хотите, чтобы скомпилированный код запус-
кался на машинах PA-RISC 1.1, также потребуется указать +DAportable в CFLAGS.
Если вы проводите сборку на машине HP-UX Itanium, вам потребуется последний компилятор ANSI
C от HP с соответствующим исправлением или более новыми:
PHSS_30848 s700_800 HP C Compiler (A.05.57)
469Установка из исходного кода
PHSS_30849 s700_800 u2comp/be/plugin library Patch
Если вы используете компилятор HP C и GCC, может потребоваться явно выбрать предпочитаемый
компилятор при запуске configure:
./configure CC=cc
для использования компилятора C от HP, либо
./configure CC=gcc
для выбора GCC. При отсутствии явного указания configure выберет gcc, если есть такая возмож-
ность.
По умолчанию целевой каталог установки — /usr/local/pgsql, но вы, возможно, захотите его
изменить на другой, внутри /opt. В этом случае передайте его configure с ключом –prefix.
В регрессионных тестах возможны отклонения при геометрических проверках, в наименее знача-
щих цифрах, в зависимости от применяемого компилятора и математической библиотеки. Любые
другие ошибки заслуживают внимания.
16.7.4. macOS
В последних версиях macOS необходимо включать путь «sysroot» во флаги include, позволяющие
найти некоторые системные заголовочные файлы. Как результат, вывод скрипта configure может
меняться в зависимости от того, какая версия SDK использовалась в процессе configure. Это не
должно создавать никаких проблем в простых сценариях, но если вы попытаетесь, например, со-
брать расширение не на той машине, где был собран серверный код, то может потребоваться явно
указать другой путь sysroot. В этом случае установите PG_SYSROOT, например, так:
make PG_SYSROOT=/требуемый/путь all
Чтобы узнать правильный путь на вашей машине, выполните:
xcodebuild -version -sdk macosx Path
Заметьте, что собирать расширения с версией sysroot, отличной от той, с которой собиралось ядро
сервера, не рекомендуется; в худшем случае это приведёт к труднодиагностируемым несогласо-
ванностям ABI.
Также при конфигурировании вы можете задать sysroot, отличный от подразумеваемого по умол-
чанию, передав PG_SYSROOT скрипту configure:
./configure … PG_SYSROOT=/требуемый/путь
Функциональность «Защита целостности системы» (System Integrity Protection, SIP) в macOS нару-
шает работу make check, так как она не позволяет передавать нужное значение DYLD_LIBRARY_PATH
тестируемым исполняемым файлам. Обойти эту проблему можно, выполнив make install перед
make check. Однако большинство разработчиков Postgres просто отключают SIP.
16.7.5. MinGW/Собственная сборка Windows
PostgreSQL для Windows можно собрать с использованием MinGW, Unix-подобной среды сборки для
операционных систем Microsoft, либо используя набор средств разработки Microsoft Visual C++.
При использовании MinGW применяется обычная система сборки, описанная в этой главе; сборка
Visual C++ выполняется по-другому, как описано в Главе 17. Это полностью естественная сборка
для Windows, для которой не требуется дополнительное ПО вроде MinGW. Готовый инсталлятор
для Windows можно найти на сайте PostgreSQL.
PostgreSQL, портированный в Windows, будет работать в 32- или 64-битной версии Windows 2000
или новее. В предыдущих операционных системах нет достаточной инфраструктуры (но там мож-
но использовать Cygwin). MinGW, Unix-подобные средства сборки, и MSYS, набор утилит Unix, тре-
буемых для исполнения скриптов типа configure, можно загрузить с сайта http://www.mingw.org/.
470Установка из исходного кода
Эти дополнительные программы нужны только для сборки, для запуска полученных исполняемых
файлов они не требуются.
Чтобы собрать 64-битную версию с использованием MinGW, установите набор 64-битных утилит с
https://mingw-w64.org/, добавьте путь к его каталогу bin в PATH и запустите configure с параметром
–host=x86_64-w64-mingw32.
Когда вы всё установите, запускать psql предлагается из CMD.EXE, так как в консоли MSYS есть
проблемы с буферизацией.
16.7.5.1. Сбор аварийных дампов в Windows
В случае аварии PostgreSQL в Windows он может сгенерировать минидамп памяти, который по-
могает выяснить причину аварии, подобно дампам памяти в Unix. Проанализировать эти дампы
можно, используя Windows Debugger Tools (Средства отладки Windows) или Visual Studio. Чтобы в
Windows получить дамп в случае аварии, создайте подкаталог crashdumps в каталоге данных кла-
стера. Дампы будут записываться в этот каталог с уникальным именем, составленным из иденти-
фикатора процесса, давшего сбой, и времени сбоя.
16.7.6. Solaris
PostgreSQL хорошо поддерживается в Solaris. Чем новее операционная система, тем меньше за-
труднений будет; подробнее об этом ниже.
16.7.6.1. Требуемые инструменты
Вы можете выполнить сборку с GCC или с набором компиляторов Sun. Для лучшей оптимизации
кода на архитектуре SPARC настоятельно рекомендуется использовать компилятор Sun. Мы слы-
шали о проблемах с GCC 2.95.1, поэтому рекомендуется использовать GCC 2.95.3 или новее. Если
вы решили применить компилятор Sun, не выберите по ошибке /usr/ucb/cc; правильный путь —
/opt/SUNWspro/bin/cc.
Sun Studio вы можете загрузить с сайта https://www.oracle.com/technetwork/server-storage/
solarisstudio/downloads/. Средства GNU по большей части интегрированы в Solaris 10, либо пред-
ставлены на сопутствующем CD. Если вам нужны пакеты для старых версий Solaris, вы можете
найти их на сайте http://www.sunfreeware.com. Если вы предпочитаете исходный код, обратитесь
к https://www.gnu.org/prep/ftp.
16.7.6.2. Процедура configure сообщает о сбое тестовой программы
Если configure сообщает о сбое тестовой программы, это может быть вызвано тем, что при связы-
вании во время выполнения не удаётся найти некоторую библиотеку, вероятно, libz, libreadline или
какую-то другую нестандартную, например, libssl. Чтобы указать правильное размещение библио-
теки, задайте переменную окружения LDFLAGS в командной строке configure, например так:
configure … LDFLAGS=”-R /usr/sfw/lib:/opt/sfw/lib:/usr/local/lib”
За дополнительными сведениями обратитесь к странице man ld.
16.7.6.3. Периодические сбои 64-битной сборки
В Solaris 7 и старее 64-битная версия libc содержала бракованную функцию vsnprintf, которая
могла вызывать непредсказуемые сбои PostgreSQL. Самое простое известное решение — сделать,
чтобы PostgreSQL использовал собственную версию vsnprintf вместо библиотечной версии. Для
этого, выполнив configure, отредактируйте полученный в результате configure файл. В src/
Makefile.global поменяйте строку
LIBOBJS =
на такую
LIBOBJS = snprintf.o
471Установка из исходного кода
(В этой переменной уже также могут быть перечислены и другие файлы.) Затем продолжите сбор-
ку как обычно.
16.7.6.4. Компиляция для максимальной производительности
Для архитектуры SPARC настоятельно рекомендуется проводить компиляцию с использованием
Sun Studio. Добавив флаг -xO5, вы можете получить исполняемый код, который будет работать
значительно быстрее. Но не добавляйте никакие флаги, влияющие на вычисления с плавающей
точкой или обработку errno (например, -fast). С такими флагами PostgreSQL может вести себя
нестандартно, например, выполняя операции с датами/временем.
Если у вас нет причины использовать 64-битные программы в архитектуре SPARC, собирайте 32-
битную версию, так как 64-битные операции, а значит и 64-битные программы, выполняются мед-
леннее 32-битных. С другой стороны, 32-битный код для процессоров семейства AMD64 не явля-
ется «родным», поэтому на таких процессорах значительно медленнее работает 32-битный код.
16.7.6.5. Применение DTrace для трассировки PostgreSQL
Да, вы можете использовать DTrace. За дополнительными сведениями обратитесь к Разделу 28.5.
Если компоновка исполняемого файла postgres прерывается с таким сообщением об ошибке:
Undefined
first referenced
symbol
in file
AbortTransaction
utils/probes.o
CommitTransaction
utils/probes.o
ld: fatal: Symbol referencing errors. No output written to postgres
collect2: ld returned 1 exit status
make: *** [postgres] Error 1
Это означает, что ваша инсталляция DTrace слишком стара и неспособна работать с пробами в
статических функциях. В этом случае вам нужна версия Solaris 10u4 или новее.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page20/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page19/">19</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page20/">20</a></li>
      
    
      
        <li><strong class="current-page">21</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page22/">22</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page23/">23</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page22/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>