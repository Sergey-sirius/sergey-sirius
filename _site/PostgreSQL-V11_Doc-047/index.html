<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 47. Интерфейс программирования сервера &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL, PostgreSQL_Book_11">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 47. Интерфейс программирования сервера">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 47. Интерфейс программирования сервера">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-047/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-047/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 47. Интерфейс программирования сервера">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-047/" rel="bookmark" title="Глава 47. Интерфейс программирования сервера">Глава 47. Интерфейс программирования сервера</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~40 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 47. Интерфейс программирования сервера</p>

<p>Интерфейс программирования сервера (SPI, Server Programming Interface) даёт разработчикам
пользовательских функций на C возможность запускать команды SQL из своих функций. SPI пред-
ставляет собой набор интерфейсных функций, упрощающих доступ к анализатору, планировщику
и исполнителю запросов. В SPI есть также функции для управления памятью.
Примечание
Доступные процедурные языки предоставляют различные средства для выполнения
SQL-команд из функций. Большинство этих средств основаны на SPI, так что эта доку-
ментация будет полезна и тем, кто использует эти языки.
Учтите, что если команда, вызванная через SPI, прерывается ошибкой, управление не возвраща-
ется в вашу функцию на C. Вместо этого происходит откат транзакции или подтранзакции, из ко-
торой вызывалась ваша функция. (Это может показаться удивительным, с учётом того, что для
большинства функций SPI описаны соглашения по возврату ошибок. Однако эти соглашения при-
менимы только к ошибкам, выявляемым в самих функциях SPI.) Получить управление после ошиб-
ки можно, только организовав собственную подтранзакцию, окружающую вызовы SPI, в которых
возможна ошибка.
Функции SPI выдают неотрицательный результат в случае успеха (либо через возвращаемое це-
лочисленное значение, либо в глобальной переменной SPI_result, как описано ниже). В случае
ошибки выдаётся отрицательный результат или NULL.
Файлы исходного кода, использующие SPI, должны включать заголовочный файл executor/spi.h.
47.1. Интерфейсные функции
1226Интерфейс програм-
мирования сервера
SPI_connect
SPI_connect, SPI_connect_ext — подключить функцию на C к менеджеру SPI
Синтаксис
int SPI_connect(void)
int SPI_connect_ext(int options)
Описание
SPI_connect устанавливает подключение вызова функции на C к менеджеру SPI. Данную функцию
необходимо использовать, если вы хотите выполнять команды через SPI. Некоторые вспомогатель-
ные функции SPI могут вызываться из неподключённых функций.
SPI_connect_ext делает то же самое, но принимает один аргумент, через который можно передать
дополнительные флаги. В настоящее время поддерживаются следующие флаги:
SPI_OPT_NONATOMIC
Переводит подключение SPI в неатомарный режим, в котором разрешаются вызовы функций
управления транзакциями SPI_commit, SPI_rollback и SPI_start_transaction. В обычном ре-
жиме вызов этих функций приводит к немедленной ошибке.
Вызов SPI_connect() равнозначен SPI_connect_ext(0).
Возвращаемое значение
SPI_OK_CONNECT
при успехе
SPI_ERROR_CONNECT
при ошибке
1227Интерфейс програм-
мирования сервера
SPI_finish
SPI_finish — отключить функцию на C от менеджера SPI
Синтаксис
int SPI_finish(void)
Описание
SPI_finish закрывает текущее соединение с менеджером SPI. Эту функцию необходимо вызывать
после завершения операций SPI, которые должны выполняться в текущем вызове функции на C.
Однако если вы прерываете транзакцию, выполняя elog(ERROR), о закрытии соединения можно не
беспокоиться. В этом случае SPI произведёт очистку автоматически.
Возвращаемое значение
SPI_OK_FINISH
если отключение выполнено корректно
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
1228Интерфейс програм-
мирования сервера
SPI_execute
SPI_execute — выполнить команду
Синтаксис
int SPI_execute(const char * command, bool read_only, long count)
Описание
SPI_execute выполняет заданную команду SQL для получения строк в количестве, ограниченном
count. С параметром read_only, равным true, команда должна только читать данные; это несколь-
ко сокращает издержки на её выполнение.
Эту функцию можно вызывать только из подключённой функции на C.
Если count равен 0, команда выполняется для всех строк, к которым она применима. Если count
больше нуля, будет получено не более чем count строк; выполнение команды остановится при
достижении этого предела, практически так же, как и с предложением LIMIT в запросе. Например,
команда:
SPI_execute(“SELECT * FROM foo”, true, 5);
получит из таблицы не более 5 строк. Заметьте, что это ограничение действует, только когда ко-
манда действительно возвращает строки. Например, эта команда:
SPI_execute(“INSERT INTO foo SELECT * FROM bar”, false, 5);
вставляет все строки из bar, игнорируя параметр count. Однако команда
SPI_execute(“INSERT INTO foo SELECT * FROM bar RETURNING <em>”, false, 5);
вставит не более 5 строк, так как её выполнение будет остановлено после получения пятой строки,
выданной предложением RETURNING.
В одной строке можно передать несколько команд; SPI_execute возвращает результат команды,
выполненной последней. Параметр count при этом будет применяться к каждой команде по от-
дельности (несмотря даже на то, что возвращён будет только последний результат). Это ограни-
чение не будет распространяться на скрытые команды, генерируемые правилами.
Когда параметр read_only равен false, SPI_execute увеличивает счётчик команд и получает но-
вый снимок перед выполнением каждой очередной команды в строке. Этот снимок фактически
не меняется при текущем уровне изоляции транзакций SERIALIZABLE или REPEATABLE READ, но в
режиме READ COMMITTED после обновления снимка очередная команда может видеть результаты
только что зафиксированных транзакций из других сеансов. Это важно для согласованного пове-
дения, когда команды модифицируют базу данных.
Когда параметр read_only равен true, SPI_execute не обновляет снимок и не увеличивает счётчик
команд, и допускает в строке команд только SELECT. Заданные команды выполняются со снимком,
ранее полученным для окружающего запроса. Этот режим выполнения несколько быстрее режима
чтения/записи вследствие исключения издержек, связанных с отдельными командами. Он также
позволяет создавать подлинно стабильные функции: так как последующие вызовы в транзакции
будут использовать один снимок, результаты команд не изменятся.
Смешивать команды, только читающие, с командами, читающими и пишущими, в одной процедуре,
использующей SPI, обычно неразумно; запросы только на чтение не увидят результатов изменений
в базе данных, произведённых пишущими запросами.
Число строк, которые были фактически обработаны командой (последней), возвращается в гло-
бальной переменной SPI_processed. Если эта функция возвращает значение SPI_OK_SELECT,
SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING или SPI_OK_UPDATE_RETURNING, вы можете об-
1229Интерфейс програм-
мирования сервера
ратиться по глобальному указателю SPITupleTable *SPI_tuptable и прочитать строки резуль-
тата. Некоторые служебные команды (например, EXPLAIN) также возвращают наборы строк, и
SPI_tuptable будет содержать их результаты и в этих случаях. Другие вспомогательные команды
(COPY, CREATE TABLE AS) не возвращают набор строк, так что указатель SPI_tuptable равен NULL,
но они так же возвращают число обработанных строк в SPI_processed.
Структура SPITupleTable определена так:
typedef struct
{
MemoryContext tuptabcxt;
uint64
alloced;
uint64
free;
TupleDesc
tupdesc;
HeapTuple *vals;
} SPITupleTable;
/</em>
/*
/*
/*
/*
контекст таблицы результатов в памяти <em>/
число занятых значений */
число свободных значений */
дескриптор строки */
данные строк */
vals представляет собой массив указателей на строки. (Число записей в нём указывается в
SPI_processed.) Поле tupdesc содержит дескриптор строки, который вы сможете передать функ-
циям SPI, работающими со строками. Поля tuptabcxt, alloced и free предназначены для внутрен-
него использования, а не для процедур, работающих с SPI.
SPI_finish освобождает все структуры SPITupleTable, размещённые в памяти для текущей функ-
ции на C. Вы можете освободить структуру конкретной результирующей таблицы, если она вам не
нужна, вызвав SPI_freetuptable.
Аргументы
const char * command
строка с командой, которая должна быть выполнена
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Если команда была выполнена успешно, возвращается одно из следующих (неотрицательных) зна-
чений:
SPI_OK_SELECT
если выполнялась команда SELECT (но не SELECT INTO)
SPI_OK_SELINTO
если выполнялась команда SELECT INTO
SPI_OK_INSERT
если выполнялась команда INSERT
SPI_OK_DELETE
если выполнялась команда DELETE
SPI_OK_UPDATE
если выполнялась команда UPDATE
1230Интерфейс програм-
мирования сервера
SPI_OK_INSERT_RETURNING
если выполнялась команда INSERT RETURNING
SPI_OK_DELETE_RETURNING
если выполнялась команда DELETE RETURNING
SPI_OK_UPDATE_RETURNING
если выполнялась команда UPDATE RETURNING
SPI_OK_UTILITY
если выполнялась служебная команда (например, CREATE TABLE)
SPI_OK_REWRITTEN
если команда была преобразована правилом в команду другого вида (например, UPDATE стал
командой INSERT).
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в качестве command передан NULL или count меньше 0
SPI_ERROR_COPY
при попытке выполнить COPY TO stdout или COPY FROM stdin
SPI_ERROR_TRANSACTION
при попытке выполнить команду управления транзакциями (BEGIN, COMMIT, ROLLBACK,
SAVEPOINT, PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED или любую их вариацию)
SPI_ERROR_OPUNKNOWN
если тип команды неизвестен (такого быть не должно)
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Все функции SPI, выполняющие запросы, заполняют и SPI_processed, и SPI_tuptable (только ука-
затель, но не содержимое структуры). Сохраните эти две глобальные переменные в локальных пе-
ременных функции на C, если хотите обращаться к таблице результата SPI_execute или другой
функции, выполняющей запрос, в нескольких вызовах процедуры.
1231Интерфейс програм-
мирования сервера
SPI_exec
SPI_exec — выполнить команду чтения/записи
Синтаксис
int SPI_exec(const char * command, long count)
Описание
SPI_exec действует подобно SPI_execute, но ей не передаётся параметр read_only (всегда подра-
зумевается false).
Аргументы
const char * command
строка с командой, которая должна быть выполнена
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute.
1232Интерфейс програм-
мирования сервера
SPI_execute_with_args
SPI_execute_with_args — выполнить команду с выделенными параметрами
Синтаксис
int SPI_execute_with_args(const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, long count)
Описание
SPI_execute_with_args выполняет команду, которая может включать ссылки на параметры, пере-
даваемые извне. В тексте команды параметры обозначаются символами $n, а в вызове указывают-
ся типы данных и значения для каждого такого символа. Параметры read_only и count имеют тот
же смысл, что и в SPI_execute.
Основное преимущество этой функции по сравнению с SPI_execute в том, что она позволяет пе-
редавать в команду значения данных, не требуя кропотливой подготовки строк, и таким образом
сокращает риск атак с SQL-инъекцией.
Подобного результата можно достичь, вызвав SPI_prepare и затем SPI_execute_plan; однако с
данной функцией план запроса всегда подстраивается под переданные конкретные значения па-
раметров. Поэтому для разового выполнения запроса рекомендуется применять эту функцию. Ес-
ли же одна и та же команда должна выполняться с самыми разными параметрами, какой вариант
окажется быстрее, будет зависеть от стоимости повторного планирования и выигрыша от выбора
специализированных планов.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_execute_with_args считает, что ни один из параметров не
равен NULL. В противном случае элемент массива nulls должен содержать ‘ ‘, если значение
соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1233Интерфейс програм-
мирования сервера
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1234Интерфейс програм-
мирования сервера
SPI_prepare
SPI_prepare — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare(const char * command, int nargs, Oid * argtypes)
Описание
SPI_prepare создаёт и возвращает подготовленный оператор для заданной команды. Подготовлен-
ный оператор может быть затем неоднократно выполнен функцией SPI_execute_plan.
Когда одна и та же или похожие команды выполняются неоднократно, обычно выгоднее произве-
сти анализ запроса только раз, а ещё выгоднее может быть повторно использовать план выполне-
ния команды. SPI_prepare преобразует строку команды в подготовленный оператор, включающий
в себя результаты анализа запроса. Подготовленный оператор также оставляет место для кеши-
рования плана выполнения, если выбор специализированного плана для каждого выполнения не
принесёт пользы.
Подготавливаемую команду можно сделать более общей, записав параметры ($1, $2, etc.) вместо
значений, задаваемыми константами в обычной команде. Фактические значения параметров в
этом случае будут задаваться при вызове SPI_execute_plan. Это позволяет применять подготов-
ленную команду в более широком круге ситуаций, чем это возможно без параметров.
Оператор, возвращаемый функцией SPI_prepare, может использоваться только в текущем вызове
функции на C, так как SPI_finish освобождает память, выделенную для такого оператора. Но этот
оператор может быть сохранён на будущее с помощью функций SPI_keepplan или SPI_saveplan.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
Возвращаемое значение
SPI_prepare возвращает ненулевой указатель на SPIPlan, скрытую структуру, представляющую
подготовленный оператор. В случае ошибки возвращается NULL, а в SPI_result устанавлива-
ется один из кодов ошибок, определённых для SPI_execute, за исключением того, что код
SPI_ERROR_ARGUMENT устанавливается, когда command — NULL, когда nargs меньше 0 или когда nargs
больше 0, а argtypes — NULL.
Замечания
Если параметры не определены, при первом использовании SPI_execute_plan создаётся общий
план, который затем будет применяться при последующих вызовах. Если же присутствуют пара-
метры, SPI_execute_plan будет создавать специализированные планы для конкретных значений
параметров. После достаточного количества использований полученного подготовленного опера-
тора, функция SPI_execute_plan построит общий план, и если он не будет значительно дороже
специализированных, она начнёт использовать его, а не будет строить план заново. Если это пове-
дение по умолчанию не устраивает, его можно изменить, передав флаг CURSOR_OPT_GENERIC_PLAN
1235Интерфейс програм-
мирования сервера
или CURSOR_OPT_CUSTOM_PLAN в SPI_prepare_cursor, чтобы ограничиться использованием только
общего или специализированных планов, соответственно.
Хотя основной смысл подготовленного оператора в том, чтобы избежать повторного разбора и пла-
нирования запроса, PostgreSQL всё же будет принудительно повторять разбор и планирование за-
проса перед его выполнением, если со времени предыдущего использования подготовленного опе-
ратора произойдут изменения определений (DDL) объектов базы, задействованных в этом запросе.
Также, если перед очередным использованием было изменено значение search_path, запрос будет
разобран заново с новым значением search_path. (Последняя особенность появилась в PostgreSQL
9.3.) Чтобы узнать о поведении подготовленных операторов больше, обратитесь к PREPARE.
Эту функцию следует вызывать только из подключённой функции на C.
SPIPlanPtr объявлен в spi.h как указатель на скрытую структуру. Пытаться обращаться к её со-
держимому напрямую не стоит, так как ваш код скорее всего сломается при выходе новых версий
PostgreSQL.
Имя SPIPlanPtr объясняется отчасти историческими причинами, так как теперь эта структура
может не содержать собственно план выполнения.
1236Интерфейс програм-
мирования сервера
SPI_prepare_cursor
SPI_prepare_cursor — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_cursor(const char * command, int nargs,
Oid * argtypes, int cursorOptions)
Описание
Функция SPI_prepare_cursor равнозначна SPI_prepare, за исключением того, что ей можно пере-
дать «параметры курсора». Эти параметры задаются битовой маской со значениями, определён-
ными в nodes/parsenodes.h для поля options структуры DeclareCursorStmt. SPI_prepare подра-
зумевает, что эти параметры всегда нулевые.
Аргументы
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
указатель на массив, содержащий OID типов параметров
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_cursor возвращает результат по тем же соглашениям, что и SPI_prepare.
Замечания
К
числу
полезных
бит,
которые
можно
задать
в
cursorOptions,
относятся
CURSOR_OPT_SCROLL, CURSOR_OPT_NO_SCROLL, CURSOR_OPT_FAST_PLAN, CURSOR_OPT_GENERIC_PLAN и
CURSOR_OPT_CUSTOM_PLAN. Заметьте, что параметр CURSOR_OPT_HOLD игнорируется.
1237Интерфейс програм-
мирования сервера
SPI_prepare_params
SPI_prepare_params — подготовить оператор, но пока не выполнять его
Синтаксис
SPIPlanPtr SPI_prepare_params(const char * command,
ParserSetupHook parserSetup,
void * parserSetupArg,
int cursorOptions)
Описание
SPI_prepare_params создаёт и возвращает подготовленный оператор для заданной команды, но не
выполняет саму команду. Эта функция равнозначна SPI_prepare_cursor, но позволяет вызываю-
щему дополнительно установить функции-обработчики для управления разбором ссылок на внеш-
ние параметры.
Аргументы
const char * command
строка команды
ParserSetupHook parserSetup
Функция настройки обработчиков разбора
void * parserSetupArg
аргумент для сквозной передачи в parserSetup
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
SPI_prepare_params возвращает результат по тем же соглашениям, что и SPI_prepare.
1238Интерфейс програм-
мирования сервера
SPI_getargcount
SPI_getargcount — получить число аргументов, требующихся оператору, подготовленному функ-
цией SPI_prepare
Синтаксис
int SPI_getargcount(SPIPlanPtr plan)
Описание
SPI_getargcount возвращает число аргументов, требующихся для выполнения оператора, подго-
товленного функцией SPI_prepare.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Число аргументов, которое ожидает план, заданный параметром plan. Если значение plan невер-
ное или NULL, в SPI_result устанавливается код SPI_ERROR_ARGUMENT, а функция возвращает -1.
1239Интерфейс програм-
мирования сервера
SPI_getargtypeid
SPI_getargtypeid — получить OID типа аргумента для оператора, подготовленного функцией
SPI_prepare
Синтаксис
Oid SPI_getargtypeid(SPIPlanPtr plan, int argIndex)
Описание
SPI_getargtypeid возвращает OID, представляющий тип аргумента под номером argIndex опера-
тора, подготовленного функцией SPI_prepare. Первый аргумент идёт под номером ноль.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
int argIndex
индекс аргумента, начиная с нуля
Возвращаемое значение
OID типа аргумента с заданным индексом. Если значение plan неверное или NULL, либо argIndex
меньше 0 или не меньше числа аргументов, объявленных при подготовке плана (передаваемого в
plan), в SPI_result устанавливается SPI_ERROR_ARGUMENT и возвращается InvalidOid.
1240Интерфейс програм-
мирования сервера
SPI_is_cursor_plan
SPI_is_cursor_plan — выдать true, если оператор, подготовленный функцией SPI_prepare, можно
использовать с SPI_cursor_open
Синтаксис
bool SPI_is_cursor_plan(SPIPlanPtr plan)
Описание
SPI_is_cursor_plan возвращает true, если оператор, подготовленный функцией SPI_prepare,
можно передать в качестве аргумента SPI_cursor_open, или false в противном случае. Для поло-
жительного ответа в plan должна быть представлена одна команда, и эта команда должна возвра-
щать кортежи; например, SELECT может быть подходящей командой, если он не содержит предло-
жения INTO, а UPDATE подходит, только если он содержит предложение RETURNING.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Возвращаемое значение
Значение true или false, показывающее, можно ли для подготовленного оператора, заданного
параметром plan, получить курсор, при SPI_result равном нулю. Если дать ответ невозможно
(например, если значение plan неверное или NULL, либо вызывающий не подключён к SPI), в
SPI_result устанавливается соответствующий код ошибки и возвращается false.
1241Интерфейс програм-
мирования сервера
SPI_execute_plan
SPI_execute_plan — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan(SPIPlanPtr plan, Datum * values, const char * nulls,
bool read_only, long count)
Описание
SPI_execute_plan выполняет оператор, подготовленный функцией SPI_prepare или родственными
ей. Параметры read_only и count имеют тот же смысл, что и в SPI_execute.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execute_plan считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute, со следующими дополнительными вариантами
ошибок (отрицательных результатов):
SPI_ERROR_ARGUMENT
Если plan неверный или NULL, либо count меньше 0
SPI_ERROR_PARAM
Если в values передан NULL и plan был подготовлен с другими параметрами
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1242Интерфейс програм-
мирования сервера
SPI_execute_plan_with_paramlist
SPI_execute_plan_with_paramlist — выполнить оператор, подготовленный функцией SPI_prepare
Синтаксис
int SPI_execute_plan_with_paramlist(SPIPlanPtr plan,
ParamListInfo params,
bool read_only,
long count)
Описание
SPI_execute_plan_with_paramlist выполняет оператор, подготовленный функцией SPI_prepare.
Данная функция равнозначна SPI_execute_plan, не считая того, что информация о значениях па-
раметров, передаваемых запросу, представляется по-другому. Представление ParamListInfo мо-
жет быть удобным для передачи значений, уже имеющих нужный формат. Эта функция также под-
держивает динамические наборы параметров, которые реализуются через функции-обработчики,
устанавливаемые в ParamListInfo.
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
Возвращаемые значения те же, что и у SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute_plan, если вызов
был успешным.
1243Интерфейс програм-
мирования сервера
SPI_execp
SPI_execp — выполнить оператор в режиме чтения/записи
Синтаксис
int SPI_execp(SPIPlanPtr plan, Datum * values, const char * nulls, long count)
Описание
SPI_execp действует подобно SPI_execute_plan, но ей не передаётся параметр read_only (всегда
подразумевается false).
Аргументы
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_execp считает, что ни один из параметров не равен NULL. В
противном случае элемент массива nulls должен содержать ‘ ‘, если значение соответствую-
щего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем случае значение,
переданное в соответствующем элементе values, не учитывается.) Заметьте, что nulls — это
не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
long count
максимальное число строк, которое должно быть возвращено; с 0 ограничения нет
Возвращаемое значение
См. SPI_execute_plan.
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
1244Интерфейс програм-
мирования сервера
SPI_cursor_open
SPI_cursor_open — открыть курсор для оператора, созданного функцией SPI_prepare
Синтаксис
Portal SPI_cursor_open(const char * name, SPIPlanPtr plan,
Datum * values, const char * nulls,
bool read_only)
Описание
SPI_cursor_open открывает курсор (внутри называемый порталом), через который будет выпол-
няться оператор, подготовленный функцией SPI_prepare. Параметры этой функции имеют тот же
смысл, что и соответствующие параметры SPI_execute_plan.
Применение курсора по сравнению с непосредственным выполнением оператора даёт двойную
выгоду. Во-первых, строки результата можно получать в небольших количествах, без риска исчер-
пать всю память при выполнении запросов, возвращающих много строк. Во-вторых, портал может
существовать и после завершения текущей функции на C (на самом деле он может просущество-
вать до конца текущей транзакции). Возвратив имя портала в код, вызывающий функцию на C,
можно организовать выдачу результата в виде набора строк.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
Datum * values
Массив фактических значений параметров. Его размер должен равняться числу аргументов
оператора.
const char * nulls
Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь размер, равный
числу аргументов оператора.
Если в nulls передаётся NULL, SPI_cursor_open считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1245Интерфейс програм-
мирования сервера
SPI_cursor_open_with_args
SPI_cursor_open_with_args — открывает курсор для запроса с параметрами
Синтаксис
Portal SPI_cursor_open_with_args(const char *name,
const char *command,
int nargs, Oid *argtypes,
Datum *values, const char *nulls,
bool read_only, int cursorOptions)
Описание
SPI_cursor_open_with_args открывает курсор (внутри называемый порталом) для выполнения за-
данного запроса. Большинство параметров имеют тот же смысл, что и соответствующие парамет-
ры функций SPI_prepare_cursor и SPI_cursor_open.
Для разового выполнения запроса эту функцию следует предпочесть SPI_prepare_cursor с после-
дующей SPI_cursor_open. Если же одна и та же команда должна выполняться с самыми разными
параметрами, какой вариант окажется быстрее, будет зависеть от стоимости повторного планиро-
вания и выигрыша от выбора специализированных планов.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
const char * command
строка команды
int nargs
число входных параметров ($1, $2 и т. д.)
Oid * argtypes
массив размера nargs, содержащий OID типов параметров
Datum * values
массив размера nargs, содержащий фактические значения параметров
const char * nulls
массив размера nargs, описывающий, в каких параметрах передаётся NULL
Если в nulls передаётся NULL, SPI_cursor_open_with_args считает, что ни один из параметров
не равен NULL. В противном случае, элемент массива nulls должен содержать ‘ ‘, если значе-
ние соответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем
случае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте,
что nulls — это не текстовая строка, а просто массив: ноль (‘\0’) в конце не нужен.
bool read_only
true для режима выполнения «только чтение»
1246Интерфейс програм-
мирования сервера
int cursorOptions
битовая маска параметров курсора; 0 выбирает поведение по умолчанию
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1247Интерфейс програм-
мирования сервера
SPI_cursor_open_with_paramlist
SPI_cursor_open_with_paramlist — открыть курсор с параметрами
Синтаксис
Portal SPI_cursor_open_with_paramlist(const char *name,
SPIPlanPtr plan,
ParamListInfo params,
bool read_only)
Описание
SPI_cursor_open_with_paramlist открывает курсор (внутри называемый порталом) для вы-
полнения оператора, подготовленного функцией SPI_prepare. Эта функция равнозначна
SPI_cursor_open, не считая того, что информация о значениях параметров, передаваемых запро-
су, представляется по-другому. Представление ParamListInfo может быть удобным для передачи
значений, уже имеющих нужный формат. Эта функция также поддерживает динамические набо-
ры параметров через функции-обработчики, устанавливаемые в ParamListInfo.
Переданные значения параметров копируются в портал курсора, так что их можно освободить и
во время существования курсора.
Аргументы
const char * name
имя портала, либо NULL, чтобы имя выбрала система
SPIPlanPtr plan
подготовленный оператор (возвращаемый функцией SPI_prepare)
ParamListInfo params
структура данных, содержащая типы и значения параметров; NULL, если их нет
bool read_only
true для режима выполнения «только чтение»
Возвращаемое значение
Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате ошибок отсутству-
ет; все ошибки выдаются через elog.
1248Интерфейс програм-
мирования сервера
SPI_cursor_find
SPI_cursor_find — найти существующий курсор по имени
Синтаксис
Portal SPI_cursor_find(const char * name)
Описание
SPI_cursor_find находит существующий портал по имени. В основном это полезно для разреше-
ния имени курсора, возвращённого в текстовом виде какой-то другой функцией.
Аргументы
const char * name
имя портала
Возвращаемое значение
указатель на портал с заданным именем или NULL, если такой портал не найден
1249Интерфейс програм-
мирования сервера
SPI_cursor_fetch
SPI_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_cursor_fetch(Portal portal, bool forward, long count)
Описание
SPI_cursor_fetch выбирает некоторое количество строк через курсор. Эта функция реализует
подмножество возможностей SQL-команды FETCH (расширенную функциональность предоставля-
ет SPI_scroll_cursor_fetch).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для выборки с перемещением вперёд, false — назад
long count
максимальное число строк, которое нужно выбрать
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Выборка назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1250Интерфейс програм-
мирования сервера
SPI_cursor_move
SPI_cursor_move — переместить курсор
Синтаксис
void SPI_cursor_move(Portal portal, bool forward, long count)
Описание
SPI_cursor_move перемещает курсор на несколько строк. Эта функция реализует подмно-
жество возможностей SQL-команды MOVE (расширенную функциональность предоставляет
SPI_scroll_cursor_move).
Аргументы
Portal portal
портал, содержащий курсор
bool forward
true для перемещения вперёд, false — назад
long count
максимальное число строк, на какое возможно перемещение
Замечания
Перемещение назад может не поддерживаться, если план курсора был создан без параметра
CURSOR_OPT_SCROLL.
1251Интерфейс програм-
мирования сервера
SPI_scroll_cursor_fetch
SPI_scroll_cursor_fetch — выбрать строки через курсор
Синтаксис
void SPI_scroll_cursor_fetch(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_fetch выбирает некоторое количество строк через курсор. Её функциональ-
ность равнозначна FETCH в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, выбираемых с направлением FETCH_FORWARD или FETCH_BACKWARD; абсолютный но-
мер выбираемой строки с вариантом FETCH_ABSOLUTE; либо относительный номер выбираемой
строки с вариантом FETCH_RELATIVE
Возвращаемое значение
Переменные SPI_processed и SPI_tuptable устанавливаются как в SPI_execute, если вызов был
успешным.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1252Интерфейс програм-
мирования сервера
SPI_scroll_cursor_move
SPI_scroll_cursor_move — переместить курсор
Синтаксис
void SPI_scroll_cursor_move(Portal portal, FetchDirection direction,
long count)
Описание
SPI_scroll_cursor_move перемещает курсор на несколько строк. Её функциональность равнознач-
на MOVE в SQL.
Аргументы
Portal portal
портал, содержащий курсор
FetchDirection direction
один из вариантов: FETCH_FORWARD, FETCH_BACKWARD, FETCH_ABSOLUTE или FETCH_RELATIVE
long count
число строк, на которое сдвигается курсор, с направлением FETCH_FORWARD или FETCH_BACKWARD;
абсолютный номер строки, к которой переходит курсор, с направлением FETCH_ABSOLUTE; либо
относительный номер строки, к которой переходит курсор, с направлением FETCH_RELATIVE
Возвращаемое значение
В случае успеха переменная SPI_processed устанавливается как в SPI_execute. В SPI_tuptable
оказывается NULL, так как эта функция не возвращает никакие строки.
Замечания
Подробнее о параметрах direction и count рассказывается в описании SQL-команды FETCH.
Варианты направления, отличные от FETCH_FORWARD, могут не поддерживаться, если план курсора
был создан без параметра CURSOR_OPT_SCROLL.
1253Интерфейс програм-
мирования сервера
SPI_cursor_close
SPI_cursor_close — закрыть курсор
Синтаксис
void SPI_cursor_close(Portal portal)
Описание
SPI_cursor_close закрывает ранее созданный курсор и освобождает память, занятую его порта-
лом.
Все открытые курсоры закрываются автоматически в конце транзакции. Вызывать
SPI_cursor_close может потребоваться, только если возникает желание освободить ресурсы ско-
рее.
Аргументы
Portal portal
портал, содержащий курсор
1254Интерфейс програм-
мирования сервера
SPI_keepplan
SPI_keepplan — сохранить подготовленный оператор
Синтаксис
int SPI_keepplan(SPIPlanPtr plan)
Описание
SPI_keepplan закрепляет переданный оператор (подготовленный функцией SPI_prepare), чтобы
он не был ликвидирован функцией SPI_finish или диспетчером транзакций. Это даёт возможность
повторно использовать подготовленные операторы при последующих вызовах вашей функции на
C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
Замечания
Переданный оператор перемещается в постоянное хранилище путём смены указателя (копировать
данные не требуется). Если позже вы захотите удалить его, выполните для него SPI_freeplan.
1255Интерфейс програм-
мирования сервера
SPI_saveplan
SPI_saveplan — сохранить подготовленный оператор
Синтаксис
SPIPlanPtr SPI_saveplan(SPIPlanPtr plan)
Описание
SPI_saveplan копирует переданный оператор (подготовленный функцией SPI_prepare) в память,
чтобы он не был ликвидирован функцией SPI_finish или менеджером транзакций, и возвращает
указатель на скопированный оператор. Это даёт возможность повторно использовать подготовлен-
ные операторы при последующих вызовах вашей функции на C в текущем сеансе.
Аргументы
SPIPlanPtr plan
подготовленный оператор, который нужно сохранить
Возвращаемое значение
Указатель на скопированный оператор, либо NULL в случае ошибки. При ошибке SPI_result при-
нимает одно из этих значений:
SPI_ERROR_ARGUMENT
если plan неверный или NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
Замечания
Изначально переданный оператор не освобождается, поэтому вы можете выполнить SPI_freeplan
для него, чтобы высвободить память до SPI_finish.
В большинстве случаев SPI_keepplan предпочтительнее данной функции, так как она даёт при-
мерно тот же результат, но обходится без физического копирования структур данных подготов-
ленного оператора.
1256Интерфейс програм-
мирования сервера
SPI_register_relation
SPI_register_relation — сделать эфемерное именованное отношение доступным по имени в запросах
SPI
Синтаксис
int SPI_register_relation(EphemeralNamedRelation enr)
Описание
SPI_register_relation делает эфемерное именованное отношение (со связанной информацией)
доступным в запросах, планируемых и выполняемых через текущее подключение SPI.
Аргументы
EphemeralNamedRelation enr
запись эфемерного именованного отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_REGISTER
если отношение было успешно зарегистрировано по имени
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если NULL передан в enr или в поле name
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя, заданное в поле name структуры enr, уже зарегистрировано для этого отношения
1257Интерфейс програм-
мирования сервера
SPI_unregister_relation
SPI_unregister_relation — удалить эфемерное именованное отношение из реестра
Синтаксис
int SPI_unregister_relation(const char * name)
Описание
SPI_unregister_relation удаляет эфемерное именованное отношение из реестра для текущего
подключения.
Аргументы
const char * name
имя записи отношения в реестре
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_REL_UNREGISTER
если совокупность кортежей была успешно удалена из реестра
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в name передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_NOT_FOUND
если name не находится в реестре для текущего подключения
1258Интерфейс програм-
мирования сервера
SPI_register_trigger_data
SPI_register_trigger_data — сделать эфемерные данные триггера доступными в запросах SPI
Синтаксис
int SPI_register_trigger_data(TriggerData *tdata)
Описание
SPI_register_trigger_data делает эфемерные отношения, которые перехватывает триггер, до-
ступными для запросов, планируемых и выполняемых через текущее подключение SPI. В настоя-
щее время это переходные таблицы, перехватываемые триггером AFTER, определённым с предло-
жением REFERENCING OLD/NEW TABLE AS. Эта функция должна вызываться функцией, реализующей
триггер на языке программирования, после подключения.
Аргументы
TriggerData *tdata
объект TriggerData, передаваемый функцией, реализующей триггер, через fcinfo-&gt;context
Возвращаемое значение
Если команда была выполнена успешно, возвращается следующее (неотрицательное) значение:
SPI_OK_TD_REGISTER
если перехваченные данные триггера (при наличии) были успешно зарегистрированы
В случае ошибки возвращается одно из следующих отрицательных значений:
SPI_ERROR_ARGUMENT
если в tdata передан NULL
SPI_ERROR_UNCONNECTED
если вызывается из неподключённой функции на C
SPI_ERROR_REL_DUPLICATE
если имя в любом из переходных отношений в данных триггера уже зарегистрировано для этого
подключения
47.2. Вспомогательные интерфейсные функции
Функции, описанные здесь, предоставляют возможности для извлечения информации из наборов
результатов, возвращаемых SPI_execute и другими функциями SPI.
Все функции, описанные в этом разделе, могут использоваться и в подключённых, и в неподклю-
чённых функциях на C.
1259Интерфейс програм-
мирования сервера
SPI_fname
SPI_fname — определить имя столбца с заданным номером
Синтаксис
char * SPI_fname(TupleDesc rowdesc, int colnumber)
Описание
SPI_fname возвращает копию имени столбца с заданным номером. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя столбца; NULL, если colnumber вне допустимого диапазона. В случае ошибки в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1260Интерфейс програм-
мирования сервера
SPI_fnumber
SPI_fnumber — определить номер столбца с заданным именем
Синтаксис
int SPI_fnumber(TupleDesc rowdesc, const char * colname)
Описание
SPI_fnumber возвращает номер столбца, имеющего заданное имя.
Если colname ссылается на системный столбец (например, oid), возвращается соответствующий
отрицательный номер столбца. Вызывающий должен проверять, не была ли возвращена ошибка,
сравнивая значение результата именно с SPI_ERROR_NOATTRIBUTE; проверка результата по условию
меньше или равно нулю не будет корректной, если только системные столбцы не должны исклю-
чаться.
Аргументы
TupleDesc rowdesc
описание строк
const char * colname
имя столбца
Возвращаемое значение
Номер
столбца
(начиная
с
1
для
столбцов,
создаваемых
SPI_ERROR_NOATTRIBUTE, если столбец с заданным именем не найден.
1261
пользователем),
либоИнтерфейс програм-
мирования сервера
SPI_getvalue
SPI_getvalue — получить строковое значение указанного столбца
Синтаксис
char * SPI_getvalue(HeapTuple row, TupleDesc rowdesc, int colnumber)
Описание
SPI_getvalue возвращает строковое представление значения указанного столбца.
Результат возвращается в памяти, размещённой функцией palloc. (Когда он будет не нужен, эту
память можно освободить с помощью pfree.)
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Значение столбца, либо NULL, если столбец содержит NULL, colnumber вне допустимого диапазона
(в SPI_result при этом устанавливается SPI_ERROR_NOATTRIBUTE) или если отсутствует функция
вывода (в SPI_result устанавливается SPI_ERROR_NOOUTFUNC).
1262Интерфейс програм-
мирования сервера
SPI_getbinval
SPI_getbinval — получить двоичное значение указанного столбца
Синтаксис
Datum SPI_getbinval(HeapTuple row, TupleDesc rowdesc, int colnumber,
bool * isnull)
Описание
SPI_getbinval возвращает значение указанного столбца во внутренней форме (в структуре Datum).
Эта функция не выделяет новый блок памяти для данных. В случае с типом, передаваемым по
ссылке, возвращаемым значением будет указатель на переданную строку данных.
Аргументы
HeapTuple row
строка с нужными данными
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
bool * isnull
признак того, что столбец содержит NULL
Возвращаемое значение
Возвращается двоичное значение столбца. Если этот столбец содержит NULL, переменной, на ко-
торую указывает isnull, присваивается true; в противном случае — false.
При ошибке в SPI_result устанавливается SPI_ERROR_NOATTRIBUTE.
1263Интерфейс програм-
мирования сервера
SPI_gettype
SPI_gettype — получить имя типа данных указанного столбца
Синтаксис
char * SPI_gettype(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettype возвращает копию имени типа данных указанного столбца. (Когда эта копия имени
будет не нужна, её можно освободить с помощью pfree.)
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
Имя типа данных указанного столбца, либо NULL в случае ошибки. При ошибке в SPI_result уста-
навливается SPI_ERROR_NOATTRIBUTE.
1264Интерфейс програм-
мирования сервера
SPI_gettypeid
SPI_gettypeid — получить OID типа данных указанного столбца
Синтаксис
Oid SPI_gettypeid(TupleDesc rowdesc, int colnumber)
Описание
SPI_gettypeid возвращает OID типа данных указанного столбца.
Аргументы
TupleDesc rowdesc
описание строк
int colnumber
номер столбца (начиная с 1)
Возвращаемое значение
OID типа данных указанного столбца, либо InvalidOid в случае ошибки. При ошибке в SPI_result
устанавливается SPI_ERROR_NOATTRIBUTE.
1265Интерфейс програм-
мирования сервера
SPI_getrelname
SPI_getrelname — возвращает имя указанного отношения
Синтаксис
char * SPI_getrelname(Relation rel)
Описание
SPI_getrelname возвращает копию имени указанного отношения. (Когда эта копия имени будет
не нужна, её можно освободить с помощью pfree.)
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя указанного отношения.
1266Интерфейс програм-
мирования сервера
SPI_getnspname
SPI_getnspname — возвращает пространство имён указанного отношения
Синтаксис
char * SPI_getnspname(Relation rel)
Описание
SPI_getnspname возвращает копию имени пространства имён, к которому принадлежит указанное
отношение (Relation). Пространство имён по-другому называется схемой отношения. Когда зна-
чение, возвращённое этой функцией, будет не нужно, освободите его с помощью pfree.
Аргументы
Relation rel
целевое отношение
Возвращаемое значение
Имя пространства имён указанного отношения.
1267Интерфейс програм-
мирования сервера
SPI_result_code_string
SPI_result_code_string — возвращает код ошибки в виде строки
Синтаксис
const char * SPI_result_code_string(int code);
Описание
SPI_result_code_string выдаёт строковое представление для кода результата, который возвра-
щается различными функциями SPI или находится в SPI_result.
Аргументы
int code
код результата
Возвращаемое значение
Строковое представление кода результата.
47.3. Управление памятью
PostgreSQL выделяет память в контекстах памяти, и тем самым реализует удобный способ управ-
ления выделением памяти в различных местах, с разными сроками жизни выделенной памяти.
При уничтожении контекста освобождается вся выделенная в нём память. Таким образом, нет
необходимости контролировать каждый отдельный объект во избежание утечек памяти; вместо
этого достаточно управлять только небольшим числом контекстов. Функция palloc и родственные
ей освобождают память из «текущего» контекста.
SPI_connect создаёт новый контекст памяти и делает его текущим. SPI_finish восстанавли-
вает контекст, который был текущим до этого, и уничтожает контекст, созданный функцией
SPI_connect. Эти действия обеспечивают при выходе из вашей функции на C освобождение вре-
менной памяти, выделенной внутри этой функции, во избежание утечки памяти.
Однако если ваша функция на C должна вернуть объект в выделенной памяти (как значение ти-
па, передаваемого по ссылке), эту память нельзя выделять через palloc, как минимум пока уста-
новлено подключение к SPI. Если вы попытаетесь это сделать, объект будет освобождён при вы-
зове SPI_finish и ваша функция не будет работать надёжно. Для решения этой проблемы выде-
ляйте память для возвращаемого объекта, используя SPI_palloc. SPI_palloc выделяет память в
«верхнем контексте исполнителя», то есть, в контексте памяти, который был текущим при вызо-
ве SPI_connect; именно этот контекст подходит для значения, возвращаемого из функции на C.
Некоторые из вспомогательных функций, описанных в этом разделе, также возвращают объекты,
созданные в верхнем контексте исполнителя.
Когда вызывается SPI_connect, текущим контекстом становится частный контекст функции на C,
создаваемый в SPI_connect. Все операции выделения памяти, выполняемые функциями palloc,
repalloc или служебными функциями SPI (кроме описанных в этом разделе исключений), произво-
дятся в этом контексте. Когда функция на C отключается от менеджера SPI (выполняя SPI_finish),
текущим контекстом снова становится верхний контекст исполнителя, а вся память, выделенная
в контексте этой функции, освобождается, так что использовать её дальше нельзя.
1268Интерфейс програм-
мирования сервера
SPI_palloc
SPI_palloc — выделить память в верхнем контексте исполнителя
Синтаксис
void * SPI_palloc(Size size)
Описание
SPI_palloc выделяет память в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она выдаёт ошибку.
Аргументы
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на выделенный блок памяти заданного размера
1269Интерфейс програм-
мирования сервера
SPI_repalloc
SPI_repalloc — поменять блок памяти в верхнем контексте исполнителя
Синтаксис
void * SPI_repalloc(void * pointer, Size size)
Описание
SPI_repalloc изменяет размер блока памяти, ранее выделенного функцией SPI_palloc.
Эта функция теперь не отличается от простой repalloc. Она сохранена только для обратной сов-
местимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий изменению
Size size
размер выделяемой памяти, в байтах
Возвращаемое значение
указатель на новый блок памяти указанного размера, в который скопировано содержимое преж-
него блока
1270Интерфейс програм-
мирования сервера
SPI_pfree
SPI_pfree — освободить память в верхнем контексте исполнителя
Синтаксис
void SPI_pfree(void * pointer)
Описание
SPI_pfree освобождает память, ранее выделенную функцией SPI_palloc или SPI_repalloc.
Эта функция теперь не отличается от простой pfree. Она сохранена только для обратной совме-
стимости с существующим кодом.
Аргументы
void * pointer
указатель на существующий блок памяти, подлежащий освобождению
1271Интерфейс програм-
мирования сервера
SPI_copytuple
SPI_copytuple — скопировать строку в верхнем контексте исполнителя
Синтаксис
HeapTuple SPI_copytuple(HeapTuple row)
Описание
SPI_copytuple делает копию строки в верхнем контексте исполнителя. Обычно это применяется,
когда нужно вернуть изменённую строку из триггера. В функции, которая должна возвращать со-
ставной тип, нужно использовать SPI_returntuple.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
HeapTuple row
строка, подлежащая копированию
Возвращаемое значение
скопированная строка либо NULL в случае ошибки (SPI_result содержит код ошибки)
1272Интерфейс програм-
мирования сервера
SPI_returntuple
SPI_returntuple — подготовить строку для возврата в виде Datum
Синтаксис
HeapTupleHeader SPI_returntuple(HeapTuple row, TupleDesc rowdesc)
Описание
SPI_returntuple делает копию строки в верхнем контексте исполнителя и возвращает её в форме
типа Datum. Чтобы выдать результат, полученный указатель остаётся только преобразовать в Datum
функцией PointerGetDatum.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Заметьте, что эту операцию следует применять в функциях, объявленных как возвращающие со-
ставные типы. В триггерах она не применяется; чтобы вернуть изменённую строку из триггера,
используйте SPI_copytuple.
Аргументы
HeapTuple row
строка, подлежащая копированию
TupleDesc rowdesc
дескриптор строки (передавайте каждый раз один дескриптор для более эффективного кеши-
рования)
Возвращаемое значение
HeapTupleHeader, указывающий на скопированную строку, или NULL в случае ошибки (SPI_result
содержит код ошибки)
1273Интерфейс програм-
мирования сервера
SPI_modifytuple
SPI_modifytuple — создать строку, заменяя отдельные поля в данной
Синтаксис
HeapTuple SPI_modifytuple(Relation rel, HeapTuple row, int ncols,
int * colnum, Datum * values, const char * nulls)
Описание
SPI_modifytuple создаёт новую строку, подставляя новые значения для указанных столбцов и ко-
пируя исходное содержимое остальных столбцов. Исходная строка не изменяется. Новая строка
возвращается в верхнем контексте исполнителя.
Эту функцию можно использовать только когда установлено подключение к SPI. В противном слу-
чае она возвращает NULL и устанавливает в SPI_result значение SPI_ERROR_UNCONNECTED.
Аргументы
Relation rel
Используется только в качестве дескриптора строки. (Передача отношения вместо собственно
дескриптора строки — нехорошая особенность.)
HeapTuple row
строка, подлежащая изменению
int ncols
число изменяемых столбцов
int * colnum
массив длины ncols, содержащий номера изменяемых столбцов (начиная с 1)
Datum * values
массив длины ncols, содержащий новые значения указанных столбцов
const char * nulls
массив длины ncols, описывающий, в каких столбцах передаётся NULL
Если в nulls передаётся NULL, SPI_modifytuple считает, что ни один из параметров не равен
NULL. В противном случае элемент массива nulls должен содержать ‘  ‘, если значение со-
ответствующего параметра не NULL, либо ‘n’, если это значение — NULL. (В последнем слу-
чае значение, переданное в соответствующем элементе values, не учитывается.) Заметьте, что
nulls — это не текстовая строка, а просто массив: ноль ‘\0’ в конце не нужен.
Возвращаемое значение
новая строка с изменениями, размещённая в верхнем контексте исполнителя, или NULL при ошибке
(SPI_result содержит код ошибки)
В случае ошибки в SPI_result устанавливается:
SPI_ERROR_ARGUMENT
если rel — NULL, либо row — NULL, либо ncols меньше или равно 0, либо colnum — NULL, либо
values — NULL
1274Интерфейс програм-
мирования сервера
SPI_ERROR_NOATTRIBUTE
если colnum содержит недопустимый номер столбца (меньше или равен 0, либо больше числа
столбцов в строке row)
SPI_ERROR_UNCONNECTED
если SPI неактивен
1275Интерфейс програм-
мирования сервера
SPI_freetuple
SPI_freetuple — освободить строку, размещённую в верхнем контексте исполнителя
Синтаксис
void SPI_freetuple(HeapTuple row)
Описание
SPI_freetuple освобождает строку, ранее размещённую в верхнем контексте исполнителя.
Эта функция теперь не отличается от простой heap_freetuple. Она сохранена только для обратной
совместимости с существующим кодом.
Аргументы
HeapTuple row
строка, подлежащая освобождению
1276Интерфейс програм-
мирования сервера
SPI_freetuptable
SPI_freetuptable — освободить набор строк, созданный SPI_execute или подобной функцией
Синтаксис
void SPI_freetuptable(SPITupleTable * tuptable)
Описание
SPI_freetuptable освобождает набор строк, созданных предыдущей функцией SPI выполнения ко-
манд, например SPI_execute. Таким образом, при вызове этой функции в качестве аргумента часто
передаётся глобальная переменная SPI_tuptable.
Эта функция полезна, когда функция на C, использующая SPI, должна выполнить несколько ко-
манд, но не хочет сохранять результаты предыдущих команд до завершения. Заметьте, что любые
не освобождённые таким образом наборы строк будут всё равно освобождены при выполнении
SPI_finish. Кроме того, если была запущена подтранзакция, а затем она прервалась в ходе выпол-
нения использующей SPI функции, все наборы строк, созданные в рамках подтранзакции, будут
автоматически освобождены.
Начиная с PostgreSQL версии 9.3, SPI_freetuptable содержит защитную логику, отфильтровыва-
ющую повторные запросы на удаление одного и того же набора строк. В предыдущих версиях по-
вторное удаление могло приводить к сбоям.
Аргументы
SPITupleTable * tuptable
указатель на набор строк, который нужно освободить (если NULL, ничего не происходит)
1277Интерфейс програм-
мирования сервера
SPI_freeplan
SPI_freeplan — освободить ранее сохранённый подготовленный оператор
Синтаксис
int SPI_freeplan(SPIPlanPtr plan)
Описание
SPI_freeplan освобождает подготовленный оператор, до этого выданный функцией SPI_prepare
или сохранённый функциями SPI_keepplan и SPI_saveplan.
Аргументы
SPIPlanPtr plan
указатель на оператор, подлежащий освобождению
Возвращаемое значение
0 в случае успеха; SPI_ERROR_ARGUMENT, если plan неверный или NULL
47.4. Управление транзакциями
Выполнять команды управления транзакциями (в частности, COMMIT и ROLLBACK) через функции
SPI, такие как SPI_execute, нельзя. Однако имеются отдельные интерфейсные функции, которые
предназначены для управления транзакциями через SPI.
Вообще говоря, не всегда безопасно и разумно начинать и заканчивать транзакции в произволь-
ных определяемых пользователями функциях, вызываемых из SQL, не принимая во внимание кон-
текст их вызова. Например, завершение транзакции в середине функции, вызванной в сложном
SQL-выражении внутри некоторой SQL-команды, скорее всего приведёт к странным внутренним
ошибкам или сбоям. Представленные здесь интерфейсные функции прежде всего предназначены
для использования реализациями процедурных языков с целью управления транзакциями в про-
цедурах уровня SQL, вызываемых командой CALL (при этом учитывается её контекст). Та же логи-
ка может быть реализована в процедурах на C, использующих SPI, но подробное освещение этой
темы выходит за рамки данной документации.
1278Интерфейс програм-
мирования сервера
SPI_commit
SPI_commit — зафиксировать текущую транзакцию
Синтаксис
void SPI_commit(void)
Описание
SPI_commit фиксирует текущую транзакцию. Это примерно равносильно выполнению SQL-коман-
ды COMMIT. После того как транзакция зафиксирована, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1279Интерфейс програм-
мирования сервера
SPI_rollback
SPI_rollback — прервать текущую транзакцию
Синтаксис
void SPI_rollback(void)
Описание
SPI_rollback откатывает текущую транзакцию. Это примерно равносильно выполнению SQL-ко-
манды ROLLBACK. После того как транзакция отменена, для выполнения дальнейших действий в
базе данных необходимо начать новую, вызвав SPI_start_transaction.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
1280Интерфейс програм-
мирования сервера
SPI_start_transaction
SPI_start_transaction — начать новую транзакцию
Синтаксис
void SPI_start_transaction(void)
Описание
Функция SPI_start_transaction начинает новую транзакцию. Она может вызываться только по-
сле SPI_commit или SPI_rollback, когда нет активной транзакции. Обычно, когда вызывается про-
цедура, использующая SPI, транзакция уже выполняется, поэтому при попытке начать ещё одну
до завершения текущей возникнет ошибка.
Эта функцию можно выполнить, только если SPI-подключение переведено в неатомарный режим
в результате вызова SPI_connect_ext.
47.5. Видимость изменений в данных
Видимость изменений в данных, которые производятся функциями, использующими SPI, (или лю-
быми другими функциями на C), описывается следующими правилами:
• В процессе выполнения SQL-команды любые произведённые ей изменения не видны для неё
самой. Например, в команде:
INSERT INTO a SELECT * FROM a;
вставляемые строки не видны в части SELECT.
• Изменения, произведённые командой К, видны во всех командах, запущенных после К, неза-
висимо от того, были ли эти команды запущены из К (во время выполнения К) или после за-
вершения К.
• Команды, выполняемые через SPI внутри функции, вызванной SQL-командой (будь то обычная
функция или триггер), следуют одному или другому из вышеприведённых правил в зависи-
мости флага чтения/записи, переданного SPI. Команды, выполняемые в режиме «только чте-
ние», следует первому правилу: они не видят изменений, произведённых вызывающей коман-
дой. Команды, выполняемые в режиме «чтение-запись», следуют второму правилу: они могут
видеть все произведённые к этому времени изменения.
• Все стандартные процедурные языки устанавливают режим чтения-записи в SPI в зависимо-
сти от атрибута изменчивости функции. Команды функций STABLE и IMMUTABLE выполняются в
режиме «только чтение», тогда как команды функций VOLATILE — в режиме «чтение-запись».
Хотя авторы функций на C могут нарушить это соглашение, вряд ли это будет хорошей идеей.
В следующем разделе приводится пример, иллюстрирующий применение этих правил.
47.6. Примеры
Этот раздел содержит очень простой пример использования SPI. Функция execq принимает в ка-
честве первого аргумента команду SQL, а в качестве второго число строк, выполняет команду, вы-
зывая SPI_exec, и возвращает число строк, обработанных этой командой. Более сложные примеры
работы с SPI вы можете найти в src/test/regress/regress.c в дереве исходного кода, а также в
модуле spi.
#include “postgres.h”
1281Интерфейс програм-
мирования сервера
#include “executor/spi.h”
#include “utils/builtins.h”
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(execq);
Datum
execq(PG_FUNCTION_ARGS)
{
char *command;
int cnt;
int ret;
uint64 proc;
/</em> Преобразовать данный текстовый объект в строку C <em>/
command = text_to_cstring(PG_GETARG_TEXT_PP(1));
cnt = PG_GETARG_INT32(2);
SPI_connect();
ret = SPI_exec(command, cnt);
proc = SPI_processed;
/</em></p>
<ul>
  <li>Если были выбраны какие-то строки, вывести их через elog(INFO).
*/
if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
{
TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
SPITupleTable *tuptable = SPI_tuptable;
char buf[8192];
uint64 j;
for (j = 0; j &lt; proc; j++)
{
HeapTuple tuple = tuptable-&gt;vals[j];
int i;
for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), “ %s%s”,
SPI_getvalue(tuple, tupdesc, i),
(i == tupdesc-&gt;natts) ? “ “ : “ |”);
elog(INFO, “EXECQ: %s”, buf);
}
}
SPI_finish();
pfree(command);
PG_RETURN_INT64(proc);
}
Так эта функция будет объявляться после того, как она будет скомпилирована в разделяемую биб-
лиотеку (подробности в Подразделе 38.10.5):
CREATE FUNCTION execq(text, integer) RETURNS int8
AS ‘имя_файла’
LANGUAGE C STRICT;
1282Интерфейс програм-
мирования сервера
Демонстрация использования:
=&gt; SELECT execq(‘CREATE TABLE a (x integer)’, 0);
execq
——-
0
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘INSERT INTO a VALUES (0)’, 0));
INSERT 0 1
=&gt; SELECT execq(‘SELECT * FROM a’, 0);
INFO: EXECQ: 0
– вставлено функцией execq
INFO: EXECQ: 1
– возвращено функцией execq и вставлено командой INSERT
execq
——-
2
(1 row)
=&gt; SELECT execq(‘INSERT INTO a SELECT x + 2 FROM a’, 1);
execq
——-
1
(1 row)
=&gt; SELECT execq(‘SELECT * FROM a’, 10);
INFO: EXECQ: 0
INFO: EXECQ: 1
INFO: EXECQ: 2
– 0 + 2, вставлена только одна строка - как указано
execq
——-
3
(1 row)
– 10 — только максимальное значение, 3 — реальное число строк
=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
– нет строк в a (0) + 1
(1 row)
=&gt; INSERT INTO a VALUES (execq(‘SELECT * FROM a’, 0) + 1);
INFO: EXECQ: 1
INSERT 0 1
=&gt; SELECT * FROM a;
x
—
1
2
– была одна строка в a + 1
(2 rows)
– Этот пример демонстрирует правило видимости изменений в данных:
=&gt; INSERT INTO a SELECT execq(‘SELECT * FROM a’, 0) * x FROM a;
1283Интерфейс програм-
мирования сервера
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 1
INFO: EXECQ: 2
INFO: EXECQ: 2
INSERT 0 2
=&gt; SELECT * FROM a;
x
—
1
2
2
– 2 строки * 1 (x в первой в строке)
6
– 3 строки (2 + 1 только вставленная) * 2 (x во второй строке)
(4 rows)
^^^^^^
строки, видимые в execq() при разных вызовах
1284</li>
</ul>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a><a href="http://localhost:4000/tags/#PostgreSQL_Book_11" title="Pages tagged PostgreSQL_Book_11" class="tag"><span class="term">PostgreSQL_Book_11</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-047/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-047/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-047/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-046/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/Script_bash-copy-ftp/" title="Копируем на FTP скриптом bash">Копируем на FTP скриптом bash</a></h3>
      <p>Bash FTP script copy <a href="http://localhost:4000/Script_bash-copy-ftp/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/Work-Project-Manager/" title="Коротко - работа менеджера проектов">Коротко - работа менеджера проектов</a></h4>
        <span>Published on December 04, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


	        

</body>
</html>
