<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page25/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page25/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-007/" title="Глава 7. Запросы"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 7. Запросы"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-007/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~44 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-007/" rel="bookmark" title="Глава 7. Запросы" itemprop="url">Глава 7. Запросы</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 7. Запросы</p>

<p>В предыдущих главах рассказывалось, как создать таблицы, как заполнить их данными и как из-
менить эти данные. Теперь мы наконец обсудим, как получить данные из базы данных.</p>

<p>7.1. Обзор</p>

<p>Процесс или команда получения данных из базы данных называется запросом. В SQL запросы
формулируются с помощью команды SELECT. В общем виде команда SELECT записывается так:
[WITH запросы_with] SELECT список_выборки FROM табличное_выражение
[определение_сортировки]
В следующих разделах подробно описываются список выборки, табличное выражение и определе-
ние сортировки. Запросы WITH являются расширенной возможностью PostgreSQL и будут рассмот-
рены в последнюю очередь.
Простой запрос выглядит так:
SELECT * FROM table1;
Если предположить, что в базе данных есть таблица table1, эта команда получит все строки с
содержимым всех столбцов из table1. (Метод выдачи результата определяет клиентское прило-
жение. Например, программа psql выведет на экране ASCII-таблицу, хотя клиентские библиотеки
позволяют извлекать отдельные значения из результата запроса.) Здесь список выборки задан как
*, это означает, что запрос должен вернуть все столбцы табличного выражения. В списке выборки
можно также указать подмножество доступных столбцов или составить выражения с этими столб-
цами. Например, если в table1 есть столбцы a, b и c (и возможно, другие), вы можете выполнить
следующий запрос:
SELECT a, b + c FROM table1;
(в предположении, что столбцы b и c имеют числовой тип данных). Подробнее это описано в Раз-
деле 7.3.
FROM table1 — это простейший тип табличного выражения, в котором просто читается одна таб-
лица. Вообще табличные выражения могут быть сложными конструкциями из базовых таблиц, со-
единений и подзапросов. А можно и вовсе опустить табличное выражение и использовать команду
SELECT как калькулятор:
SELECT 3 * 4;
В этом может быть больше смысла, когда выражения в списке выборки возвращают меняющиеся
результаты. Например, можно вызвать функцию так:
SELECT random();
7.2. Табличные выражения
Табличное выражение вычисляет таблицу. Это выражение содержит предложение FROM, за кото-
рым могут следовать предложения WHERE, GROUP BY и HAVING. Тривиальные табличные выражения
просто ссылаются на физическую таблицу, её называют также базовой, но в более сложных выра-
жениях такие таблицы можно преобразовывать и комбинировать самыми разными способами.
Необязательные предложения WHERE, GROUP BY и HAVING в табличном выражении определяют по-
следовательность преобразований, осуществляемых с данными таблицы, полученной в предложе-
нии FROM. В результате этих преобразований образуется виртуальная таблица, строки которой пе-
редаются списку выборки, вычисляющему выходные строки запроса.
7.2.1. Предложение FROM
«Предложение FROM» образует таблицу из одной или нескольких ссылок на таблицы, разделённых
запятыми.
93Запросы
FROM табличная_ссылка [, табличная_ссылка [, …]]
Здесь табличной ссылкой может быть имя таблицы (возможно, с именем схемы), производная таб-
лица, например подзапрос, соединение таблиц или сложная комбинация этих вариантов. Если в
предложении FROM перечисляются несколько ссылок, для них применяется перекрёстное соеди-
нение (то есть декартово произведение их строк; см. ниже). Список FROM преобразуется в проме-
жуточную виртуальную таблицу, которая может пройти через преобразования WHERE, GROUP BY и
HAVING, и в итоге определит результат табличного выражения.
Когда в табличной ссылке указывается таблица, являющаяся родительской в иерархии наследова-
ния, в результате будут получены строки не только этой таблицы, но и всех её дочерних таблиц.
Чтобы выбрать строки только одной родительской таблицы, перед её именем нужно добавить клю-
чевое слово ONLY. Учтите, что при этом будут получены только столбцы указанной таблицы — до-
полнительные столбцы дочерних таблиц не попадут в результат.
Если же вы не добавляете ONLY перед именем таблицы, вы можете дописать после него *, тем са-
мым указав, что должны обрабатываться и все дочерние таблицы. Практических причин исполь-
зовать этот синтаксис больше нет, так как поиск в дочерних таблицах теперь производится по
умолчанию. Однако эта запись поддерживается для совместимости со старыми версиями.
7.2.1.1. Соединённые таблицы
Соединённая таблица — это таблица, полученная из двух других (реальных или производных от
них) таблиц в соответствии с правилами соединения конкретного типа. Общий синтаксис описания
соединённой таблицы:
T1 тип_соединения T2 [ условие_соединения ]
Соединения любых типов могут вкладываются друг в друга или объединяться: и T1, и T2 могут быть
результатами соединения. Для однозначного определения порядка соединений предложения JOIN
можно заключать в скобки. Если скобки отсутствуют, предложения JOIN обрабатываются слева
направо.
Типы соединений
Перекрёстное соединение
T1 CROSS JOIN T2
Соединённую таблицу образуют все возможные сочетания строк из T1 и T2 (т. е. их декарто-
во произведение), а набор её столбцов объединяет в себе столбцы T1 со следующими за ними
столбцами T2. Если таблицы содержат N и M строк, соединённая таблица будет содержать N</p>
<ul>
  <li>M строк.
FROM T1 CROSS JOIN T2 эквивалентно FROM T1 INNER JOIN T2 ON TRUE (см. ниже). Эта запись
также эквивалентна FROM T1, T2.
Примечание
Последняя запись не полностью эквивалентна первым при указании более чем двух
таблиц, так как JOIN связывает таблицы сильнее, чем запятая. Например, FROM T1
CROSS JOIN T2 INNER JOIN T3 ON условие не равнозначно FROM T1, T2 INNER
JOIN T3 ON условие, так как условие может ссылаться на T1 в первом случае, но
не во втором.
Соединения с сопоставлениями строк
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
ON логическое_выражение
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
USING ( список столбцов соединения )
94Запросы
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
Слова INNER и OUTER необязательны во всех формах. По умолчанию подразумевается INNER
(внутреннее соединение), а при указании LEFT, RIGHT и FULL — внешнее соединение.
Условие соединения указывается в предложении ON или USING, либо неявно задаётся ключе-
вым словом NATURAL. Это условие определяет, какие строки двух исходных таблиц считаются
«соответствующими» друг другу (это подробно рассматривается ниже).
Возможные типы соединений с сопоставлениями строк:
INNER JOIN
Для каждой строки R1 из T1 в результирующей таблице содержится строка для каждой
строки в T2, удовлетворяющей условию соединения с R1.
LEFT OUTER JOIN
Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляют-
ся все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений
столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет
минимум одна строка для каждой строки из T1.
RIGHT OUTER JOIN
Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляют-
ся все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений
столбцов T1 вставляются NULL. Это соединение является обратным к левому (LEFT JOIN):
в результирующей таблице всегда будет минимум одна строка для каждой строки из T2.
FULL OUTER JOIN
Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из
T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставля-
ются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют
никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.
Предложение ON определяет наиболее общую форму условия соединения: в нём указываются
выражения логического типа, подобные тем, что используются в предложении WHERE. Пара
строк из T1 и T2 соответствуют друг другу, если выражение ON возвращает для них true.
USING — это сокращённая запись условия, полезная в ситуации, когда с обеих сторон соедине-
ния столбцы имеют одинаковые имена. Она принимает список общих имён столбцов через за-
пятую и формирует условие соединения с равенством этих столбцов. Например, запись соеди-
нения T1 и T2 с USING (a, b) формирует условие ON T1.a = T2.a AND T1.b = T2.b.
Более того, при выводе JOIN USING исключаются избыточные столбцы: оба сопоставленных
столбца выводить не нужно, так как они содержат одинаковые значения. Тогда как JOIN ON
выдаёт все столбцы из T1, а за ними все столбцы из T2, JOIN USING выводит один столбец для
каждой пары (в указанном порядке), за ними все оставшиеся столбцы из T1 и, наконец, все
оставшиеся столбцы T2.
Наконец, NATURAL — сокращённая форма USING: она образует список USING из всех имён столб-
цов, существующих в обеих входных таблицах. Как и с USING, эти столбцы оказываются в выход-
ной таблице в единственном экземпляре. Если столбцов с одинаковыми именами не находится,
NATURAL JOIN действует как JOIN … ON TRUE и выдаёт декартово произведение строк.
Примечание
Предложение USING разумно защищено от изменений в соединяемых отношениях,
так как оно связывает только явно перечисленные столбцы. NATURAL считается бо-
лее рискованным, так как при любом изменении схемы в одном или другом отноше-
95Запросы
нии, когда появляются столбцы с совпадающими именами, при соединении будут
связываться и эти новые столбцы.
Для наглядности предположим, что у нас есть таблицы t1:
num | name
—–+——
1 | a
2 | b
3 | c
и t2:
num | value
—–+——-
1 | xxx
3 | yyy
5 | zzz
С ними для разных типов соединений мы получим следующие результаты:
=&gt; SELECT * FROM t1 CROSS JOIN t2;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
1 | a
|
3 | yyy
1 | a
|
5 | zzz
2 | b
|
1 | xxx
2 | b
|
3 | yyy
2 | b
|
5 | zzz
3 | c
|
1 | xxx
3 | c
|
3 | yyy
3 | c
|
5 | zzz
(9 rows)
=&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
3 | c
|
3 | yyy
(2 rows)
=&gt; SELECT * FROM t1 INNER JOIN t2 USING (num);
num | name | value
—–+——+——-
1 | a
| xxx
3 | c
| yyy
(2 rows)
=&gt; SELECT * FROM t1 NATURAL INNER JOIN t2;
num | name | value
—–+——+——-
1 | a
| xxx
3 | c
| yyy
(2 rows)
=&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
96Запросы
2 | b
3 | c
(3 rows)
|
|
|
3 | yyy
=&gt; SELECT * FROM t1 LEFT JOIN t2 USING (num);
num | name | value
—–+——+——-
1 | a
| xxx
2 | b
|
3 | c
| yyy
(3 rows)
=&gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
3 | c
|
3 | yyy
|
|
5 | zzz
(3 rows)
=&gt; SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
2 | b
|
|
3 | c
|
3 | yyy
|
|
5 | zzz
(4 rows)
Условие соединения в предложении ON может также содержать выражения, не связанные непо-
средственно с соединением. Это может быть полезно в некоторых запросах, но не следует исполь-
зовать это необдуманно. Рассмотрите следующий запрос:
=&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = ‘xxx’;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
2 | b
|
|
3 | c
|
|
(3 rows)
Заметьте, что если поместить ограничение в предложение WHERE, вы получите другой результат:
=&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = ‘xxx’;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
(1 row)
Это связано с тем, что ограничение, помещённое в предложение ON, обрабатывается до операции
соединения, тогда как ограничение в WHERE — после. Это не имеет значения при внутренних со-
единениях, но важно при внешних.
7.2.1.2. Псевдонимы таблиц и столбцов
Таблицам и ссылкам на сложные таблицы в запросе можно дать временное имя, по которому к ним
можно будет обращаться в рамках запроса. Такое имя называется псевдонимом таблицы.
Определить псевдоним таблицы можно, написав
FROM табличная_ссылка AS псевдоним
97Запросы
или
FROM табличная_ссылка псевдоним
Ключевое слово AS является необязательным. Вместо псевдоним здесь может быть любой иденти-
фикатор.
Псевдонимы часто применяются для назначения коротких идентификаторов длинным именам таб-
лиц с целью улучшения читаемости запросов. Например:
SELECT * FROM “очень_длинное_имя_таблицы” s JOIN “другое_длинное_имя” a
ON s.id = a.num;
Псевдоним становится новым именем таблицы в рамках текущего запроса, т. е. после назначения
псевдонима использовать исходное имя таблицы в другом месте запроса нельзя. Таким образом,
следующий запрос недопустим:
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;
– неправильно
Хотя в основном псевдонимы используются для удобства, они бывают необходимы, когда таблица
соединяется сама с собой, например:
SELECT * FROM people AS mother JOIN people AS child
ON mother.id = child.mother_id;
Кроме того, псевдонимы обязательно нужно назначать подзапросам (см. Подраздел 7.2.1.3).
В случае неоднозначности определения псевдонимов можно использовать скобки. В следующем
примере первый оператор назначает псевдоним b второму экземпляру my_table, а второй оператор
назначает псевдоним результату соединения:
SELECT * FROM my_table AS a CROSS JOIN my_table AS b …
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b …
В другой форме назначения псевдонима временные имена даются не только таблицам, но и её
столбцам:
FROM табличная_ссылка [AS] псевдоним ( столбец1 [, столбец2 [, …]] )
Если псевдонимов столбцов оказывается меньше, чем фактически столбцов в таблице, остальные
столбцы сохраняют свои исходные имена. Эта запись особенно полезна для замкнутых соединений
или подзапросов.
Когда псевдоним применяется к результату JOIN, он скрывает оригинальные имена таблиц внутри
JOIN. Например, это допустимый SQL-запрос:
SELECT a.* FROM my_table AS a JOIN your_table AS b ON …
а запрос:
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON …) AS c
ошибочный, так как псевдоним таблицы a не виден снаружи определения псевдонима c.
7.2.1.3. Подзапросы
Подзапросы, образующие таблицы, должны заключаться в скобки и им обязательно должны на-
значаться псевдонимы (как описано в Подразделе 7.2.1.2). Например:
FROM (SELECT * FROM table1) AS псевдоним
Этот пример равносилен записи FROM table1 AS псевдоним. Более интересные ситуации, которые
нельзя свести к простому соединению, возникают, когда в подзапросе используются агрегирую-
щие функции или группировка.
Подзапросом может также быть список VALUES:
FROM (VALUES (‘anne’, ‘smith’), (‘bob’, ‘jones’), (‘joe’, ‘blow’))
98Запросы
AS names(first, last)
Такому подзапросу тоже требуется псевдоним. Назначать псевдонимы столбцам списка VALUES не
требуется, но вообще это хороший приём. Подробнее это описано в Разделе 7.7.
7.2.1.4. Табличные функции
Табличные функции — это функции, выдающие набор строк, содержащих либо базовые типы дан-
ных (скалярных типов), либо составные типы (табличные строки). Они применяются в запросах как
таблицы, представления или подзапросы в предложении FROM. Столбцы, возвращённые табличны-
ми функциями, можно включить в выражения SELECT, JOIN или WHERE так же, как столбцы таблиц,
представлений или подзапросов.
Табличные функции можно также скомбинировать, используя запись ROWS FROM. Результаты функ-
ций будут возвращены в параллельных столбцах; число строк в этом случае будет наибольшим из
результатов всех функций, а результаты функций с меньшим количеством строк будут дополнены
значениями NULL.
вызов_функции [WITH ORDINALITY] [[AS] псевдоним_таблицы [(псевдоним_столбца [, …])]]
ROWS FROM( вызов_функции [, …] ) [WITH ORDINALITY] [[AS] псевдоним_таблицы
[(псевдоним_столбца [, …])]]
Если указано предложение WITH ORDINALITY, к столбцам результатов функций будет добавлен ещё
один, с типом bigint. В этом столбце нумеруются строки результирующего набора, начиная с 1.
(Это обобщение стандартного SQL-синтаксиса UNNEST … WITH ORDINALITY.) По умолчанию, этот
столбец называется ordinality, но ему можно присвоить и другое имя с помощью указания AS.
Специальную табличную функцию UNNEST можно вызвать с любым числом параметров-массивов, а
возвращает она соответствующее число столбцов, как если бы UNNEST (Раздел 9.18) вызывалась для
каждого параметра в отдельности, а результаты объединялись с помощью конструкции ROWS FROM.
UNNEST( выражение_массива [, …] ) [WITH ORDINALITY] [[AS] псевдоним_таблицы
[(псевдоним_столбца [, …])]]
Если псевдоним_таблицы не указан, в качестве имени таблицы используется имя функции; в случае
с конструкцией ROWS FROM() — имя первой функции.
Если псевдонимы столбцов не указаны, то для функции, возвращающей базовый тип данных, име-
нем столбца будет имя функции. Для функций, возвращающих составной тип, имена результиру-
ющих столбцов определяются индивидуальными атрибутами типа.
Несколько примеров:
CREATE TABLE foo (fooid int, foosubid int, fooname text);
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS <script type="math/tex">SELECT * FROM foo WHERE fooid = $1;</script> LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
SELECT * FROM foo
WHERE foosubid IN (
SELECT foosubid
FROM getfoo(foo.fooid) z
WHERE z.fooid = foo.fooid
);
CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
99Запросы
В некоторых случаях бывает удобно определить табличную функцию, возвращающую различные
наборы столбцов при разных вариантах вызова. Для этого нужно указать, что она возвращает псев-
дотип record. Используя такую функцию, ожидаемую структуру строк нужно описать в самом за-
просе, чтобы система знала, как разобрать запрос и составить его план. Записывается это так:
вызов_функции [AS] псевдоним (определение_столбца [, …])
вызов_функции AS [псевдоним] (определение_столбца [, …])
ROWS FROM( … вызов_функции AS (определение_столбца [, …]) [, …] )
Без ROWS FROM() список определения_столбцов заменяет список псевдонимов, который можно
также добавить в предложении FROM; имена в определениях столбцов служат псевдонимами. С ROWS
FROM() список определения_столбцов можно добавить к каждой функции отдельно, либо в случае с
одной функцией и без предложения WITH ORDINALITY, список определения_столбцов можно запи-
сать вместо списка с псевдонимами столбцов после ROWS FROM().
Взгляните на этот пример:
SELECT *
FROM dblink(‘dbname=mydb’, ‘SELECT proname, prosrc FROM pg_proc’)
AS t1(proname name, prosrc text)
WHERE proname LIKE ‘bytea%’;
Здесь функция dblink (из модуля dblink) выполняет удалённый запрос. Она объявлена как функция,
возвращающая тип record, так как он подойдёт для запроса любого типа. В этом случае фактиче-
ский набор столбцов функции необходимо описать в вызывающем её запросе, чтобы анализатор
запроса знал, например, как преобразовать <em>.
7.2.1.5. Подзапросы LATERAL
Перед подзапросами в предложении FROM можно добавить ключевое слово LATERAL. Это позволит
ссылаться в них на столбцы предшествующих элементов списка FROM. (Без LATERAL каждый подза-
прос выполняется независимо и поэтому не может обращаться к другим элементам FROM.)
Перед табличными функциями в предложении FROM также можно указать LATERAL, но для них это
ключевое слово необязательно; в аргументах функций в любом случае можно обращаться к столб-
цам в предыдущих элементах FROM.
Элемент LATERAL может находиться на верхнем уровне списка FROM или в дереве JOIN. В последнем
случае он может также ссылаться на любые элементы в левой части JOIN, справа от которого он
находится.
Когда элемент FROM содержит ссылки LATERAL, запрос выполняется следующим образом: сначала
для строки элемента FROM с целевыми столбцами, или набора строк из нескольких элементов FROM,
содержащих целевые столбцы, вычисляется элемент LATERAL со значениями этих столбцов. Затем
результирующие строки обычным образом соединяются со строками, из которых они были вычис-
лены. Эта процедура повторяется для всех строк исходных таблиц.
LATERAL можно использовать так:
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
Здесь это не очень полезно, так как тот же результат можно получить более простым и привычным
способом:
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
Применять LATERAL имеет смысл в основном, когда для вычисления соединяемых строк необ-
ходимо обратиться к столбцам других таблиц. В частности, это полезно, когда нужно пе-
редать значение функции, возвращающей набор данных. Например, если предположить, что
vertices(polygon) возвращает набор вершин многоугольника, близкие вершины многоугольников
из таблицы polygons можно получить так:
SELECT p1.id, p2.id, v1, v2
100Запросы
FROM polygons p1, polygons p2,
LATERAL vertices(p1.poly) v1,
LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
Этот запрос можно записать и так:
SELECT p1.id,
FROM polygons
polygons
WHERE (v1 &lt;-&gt;
p2.id, v1, v2
p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
p2 CROSS JOIN LATERAL vertices(p2.poly) v2
v2) &lt; 10 AND p1.id != p2.id;
или переформулировать другими способами. (Как уже упоминалось, в данном примере ключевое
слово LATERAL не требуется, но мы добавили его для ясности.)
Особенно полезно бывает использовать LEFT JOIN с подзапросом LATERAL, чтобы исходные стро-
ки оказывались в результате, даже если подзапрос LATERAL не возвращает строк. Например, ес-
ли функция get_product_names() выдаёт названия продуктов, выпущенных определённым произ-
водителем, но о продукции некоторых производителей информации нет, мы можем найти, каких
именно, примерно так:
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
7.2.2. Предложение WHERE
«Предложение WHERE» записывается так:
WHERE условие_ограничения
где условие_ограничения — любое выражение значения (см. Раздел 4.2), выдающее результат типа
boolean.
После обработки предложения FROM каждая строка полученной виртуальной таблицы проходит
проверку по условию ограничения. Если результат условия равен true, эта строка остаётся в вы-
ходной таблице, а иначе (если результат равен false или NULL) отбрасывается. В условии ограни-
чения, как правило, задействуется минимум один столбец из таблицы, полученной на выходе FROM.
Хотя строго говоря, это не требуется, но в противном случае предложение WHERE будет бессмыс-
ленным.
Примечание
Условие для внутреннего соединения можно записать как в предложении WHERE, так и
в предложении JOIN. Например, это выражение:
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
равнозначно этому:
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
и возможно, даже этому:
FROM a NATURAL JOIN b WHERE b.val &gt; 5
Какой вариант выбрать, в основном дело вкуса и стиля. Вариант с JOIN внутри пред-
ложения FROM, возможно, не лучший с точки зрения совместимости с другими СУБД,
хотя он и описан в стандарте SQL. Но для внешних соединений других вариантов нет:
их можно записывать только во FROM. Предложения ON и USING во внешних соединениях
не равнозначны условию WHERE, так как они могут добавлять строки (для входных строк
без соответствия), а также удалять их из конечного результата.
Несколько примеров запросов с WHERE:
101Запросы
SELECT … FROM fdt WHERE c1 &gt; 5
SELECT … FROM fdt WHERE c1 IN (1, 2, 3)
SELECT … FROM fdt WHERE c1 IN (SELECT c1 FROM t2)
SELECT … FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)
SELECT … FROM fdt WHERE c1 BETWEEN
(SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100
SELECT … FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
fdt — название таблицы, порождённой в предложении FROM. Строки, которые не соответствуют
условию WHERE, исключаются из fdt. Обратите внимание, как в качестве выражений значения ис-
пользуются скалярные подзапросы. Как и любые другие запросы, подзапросы могут содержать
сложные табличные выражения. Заметьте также, что fdt используется в подзапросах. Дополне-
ние имени c1 в виде fdt.c1 необходимо только, если в порождённой таблице в подзапросе также
оказывается столбец c1. Полное имя придаёт ясность даже там, где без него можно обойтись. Этот
пример показывает, как область именования столбцов внешнего запроса распространяется на все
вложенные в него внутренние запросы.
7.2.3. Предложения GROUP BY и HAVING
Строки порождённой входной таблицы, прошедшие фильтр WHERE, можно сгруппировать с помо-
щью предложения GROUP BY, а затем оставить в результате только нужные группы строк, исполь-
зуя предложение HAVING.
SELECT список_выборки
FROM …
[WHERE …]
GROUP BY группирующий_столбец [, группирующий_столбец]…
«Предложение GROUP BY» группирует строки таблицы, объединяя их в одну группу при совпадении
значений во всех перечисленных столбцах. Порядок, в котором указаны столбцы, не имеет значе-
ния. В результате наборы строк с одинаковыми значениями преобразуются в отдельные строки,
представляющие все строки группы. Это может быть полезно для устранения избыточности выход-
ных данных и/или для вычисления агрегатных функций, применённых к этим группам. Например:
=&gt; SELECT * FROM test1;
x | y
—+—
a | 3
c | 2
b | 5
a | 1
(4 rows)
=&gt; SELECT x FROM test1 GROUP BY x;
x
—
a
b
c
(3 rows)
Во втором запросе мы не могли написать SELECT * FROM test1 GROUP BY x, так как для столбца
y нет единого значения, связанного с каждой группой. Однако столбцы, по которым выполняется
группировка, можно использовать в списке выборки, так как они имеют единственное значение
в каждой группе.
102Запросы
Вообще говоря, в группированной таблице столбцы, не включённые в список GROUP BY, можно
использовать только в агрегатных выражениях. Пример такого агрегатного выражения:
=&gt; SELECT x, sum(y) FROM test1 GROUP BY x;
x | sum
—+—–
a |
4
b |
5
c |
2
(3 rows)
Здесь sum — агрегатная функция, вычисляющая единственное значение для всей группы. Подроб-
ную информацию о существующих агрегатных функциях можно найти в Разделе 9.20.
Подсказка
Группировка без агрегатных выражений по сути выдаёт набор различающихся значе-
ний столбцов. Этот же результат можно получить с помощью предложения DISTINCT
(см. Подраздел 7.3.3).
Взгляните на следующий пример: в нём вычисляется общая сумма продаж по каждому продукту
(а не общая сумма по всем продуктам):
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
FROM products p LEFT JOIN sales s USING (product_id)
GROUP BY product_id, p.name, p.price;
В этом примере столбцы product_id, p.name и p.price должны присутствовать в списке GROUP BY,
так как они используются в списке выборки. Столбец s.units может отсутствовать в списке GROUP
BY, так как он используется только в агрегатном выражении (sum(…)), вычисляющем сумму про-
даж. Для каждого продукта этот запрос возвращает строку с итоговой суммой по всем продажам
данного продукта.
Если бы в таблице products по столбцу product_id был создан первичный ключ, тогда в данном
примере было бы достаточно сгруппировать строки по product_id, так как название и цена про-
дукта функционально зависят от кода продукта и можно однозначно определить, какое название
и цену возвращать для каждой группы по ID.
В стандарте SQL GROUP BY может группировать только по столбцам исходной таблицы, но расши-
рение PostgreSQL позволяет использовать в GROUP BY столбцы из списка выборки. Также возможна
группировка по выражениям, а не просто именам столбцов.
Если таблица была сгруппирована с помощью GROUP BY, но интерес представляют только неко-
торые группы, отфильтровать их можно с помощью предложения HAVING, действующего подобно
WHERE. Записывается это так:
SELECT список_выборки FROM … [WHERE …] GROUP BY …
HAVING логическое_выражение
В предложении HAVING могут использоваться и группирующие выражения, и выражения, не участ-
вующие в группировке (в этом случае это должны быть агрегирующие функции).
Пример:
=&gt; SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;
x | sum
—+—–
a |
4
b |
5
103Запросы
(2 rows)
=&gt; SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; ‘c’;
x | sum
—+—–
a |
4
b |
5
(2 rows)
И ещё один более реалистичный пример:
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
FROM products p LEFT JOIN sales s USING (product_id)
WHERE s.date &gt; CURRENT_DATE - INTERVAL ‘4 weeks’
GROUP BY product_id, p.name, p.price, p.cost
HAVING sum(p.price * s.units) &gt; 5000;
В данном примере предложение WHERE выбирает строки по столбцу, не включённому в группировку
(выражение истинно только для продаж за последние четыре недели), тогда как предложение
HAVING отфильтровывает группы с общей суммой продаж больше 5000. Заметьте, что агрегатные
выражения не обязательно должны быть одинаковыми во всех частях запроса.
Если в запросе есть вызовы агрегатных функций, но нет предложения GROUP BY, строки всё равно
будут группироваться: в результате окажется одна строка группы (или возможно, ни одной строки,
если эта строка будет отброшена предложением HAVING). Это справедливо и для запросов, которые
содержат только предложение HAVING, но не содержат вызовы агрегатных функций и предложение
GROUP BY.
7.2.4. GROUPING SETS, CUBE и ROLLUP
Более сложные, чем описанные выше, операции группировки возможны с концепцией наборов
группирования. Данные, выбранные предложениями FROM и WHERE, группируются отдельно для
каждого заданного набора группирования, затем для каждой группы вычисляются агрегатные
функции как для простых предложений GROUP BY, и в конце возвращаются результаты. Например:
=&gt; SELECT * FROM items_sold;
brand | size | sales
——-+——+——-
Foo
| L
| 10
Foo
| M
| 20
Bar
| M
| 15
Bar
| L
| 5
(4 rows)
=&gt; SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand),
(size), ());
brand | size | sum
——-+——+—–
Foo
|
| 30
Bar
|
| 20
| L
| 15
| M
| 35
|
| 50
(5 rows)
В каждом внутреннем списке GROUPING SETS могут задаваться ноль или более столбцов или выра-
жений, которые воспринимаются так же, как если бы они были непосредственно записаны в пред-
ложении GROUP BY. Пустой набор группировки означает, что все строки сводятся к одной группе
(которая выводится, даже если входных строк нет), как описано выше для агрегатных функций без
предложения GROUP BY.
104Запросы
Ссылки на группирующие столбцы или выражения заменяются в результирующих строках значе-
ниями NULL для тех группирующих наборов, в которых эти столбцы отсутствуют. Чтобы можно
было понять, результатом какого группирования стала конкретная выходная строка, предназна-
чена функция, описанная в Таблице 9.56.
Для указания двух распространённых видов наборов группирования предусмотрена краткая за-
пись. Предложение формы
ROLLUP ( e1, e2, e3, … )
представляет заданный список выражений и всех префиксов списка, включая пустой список; то
есть оно равнозначно записи
GROUPING SETS (
( e1, e2, e3, … ),
…
( e1, e2 ),
( e1 ),
( )
)
Оно часто применяется для анализа иерархических данных, например, для суммирования зарпла-
ты по отделам, подразделениям и компании в целом.
Предложение формы
CUBE ( e1, e2, … )
представляет заданный список и все его возможные подмножества (степень множества). Таким
образом, запись
CUBE ( a, b, c )
равнозначна
GROUPING
( a,
( a,
( a,
( a
(
(
(
(
)
SETS
b, c
b
c
(
),
),
),
),
b, c ),
b
),
c ),
)
Элементами предложений CUBE и ROLLUP могут быть либо отдельные выражения, либо вложенные
списки элементов в скобках. Вложенные списки обрабатываются как атомарные единицы, с кото-
рыми формируются отдельные наборы группирования. Например:
CUBE ( (a, b), (c, d) )
равнозначно
GROUPING SETS (
( a, b, c, d
( a, b
(
c, d
(
)
),
),
),
)
и
ROLLUP ( a, (b, c), d )
равнозначно
GROUPING SETS (
105Запросы
( a, b, c, d ),
( a, b, c
),
( a
),
(
)
)
Конструкции CUBE и ROLLUP могут применяться либо непосредственно в предложении GROUP BY,
либо вкладываться внутрь предложения GROUPING SETS. Если одно предложение GROUPING SETS
вкладывается внутрь другого, результат будет таким же, как если бы все элементы внутреннего
предложения были записаны непосредственно во внешнем.
Если в одном предложении GROUP BY задаётся несколько элементов группирования, окончатель-
ный список наборов группирования образуется как прямое произведение этих элементов. Напри-
мер:
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
равнозначно
GROUP BY GROUPING
(a, b, c, d),
(a, b, d),
(a, c, d),
(a, d),
)
SETS (
(a, b, c, e),
(a, b, e),
(a, c, e),
(a, e)
Примечание
Конструкция (a, b) обычно воспринимается в выражениях как конструктор строки.
Однако в предложении GROUP BY на верхнем уровне выражений запись (a, b) воспри-
нимается как список выражений, как описано выше. Если вам по какой-либо причине
нужен именно конструктор строки в выражении группирования, используйте запись
ROW(a, b).
7.2.5. Обработка оконных функций
Если запрос содержит оконные функции (см. Раздел 3.5, Раздел 9.21 и Подраздел 4.2.8), эти функ-
ции вычисляются после каждой группировки, агрегатных выражений и фильтрации HAVING. Дру-
гими словами, если в запросе есть агрегатные функции, предложения GROUP BY или HAVING, окон-
ные функции видят не исходные строки, полученные из FROM/WHERE, а сгруппированные.
Когда используются несколько оконных функций, все оконные функции, имеющие в своих опре-
делениях синтаксически равнозначные предложения PARTITION BY и ORDER BY, гарантированно
обрабатывают данные за один проход. Таким образом, они увидят один порядок сортировки, да-
же если ORDER BY не определяет порядок однозначно. Однако относительно функций с разными
формулировками PARTITION BY и ORDER BY никаких гарантий не даётся. (В таких случаях между
проходами вычислений оконных функций обычно требуется дополнительный этап сортировки и
эта сортировка может не сохранять порядок строк, равнозначный с точки зрения ORDER BY.)
В настоящее время оконные функции всегда требуют предварительно отсортированных данных,
так что результат запроса будет отсортирован согласно тому или иному предложению PARTITION
BY/ORDER BY оконных функций. Однако полагаться на это не следует. Если вы хотите, чтобы ре-
зультаты сортировались определённым образом, явно добавьте предложение ORDER BY на верхнем
уровне запроса.
7.3. Списки выборки
Как говорилось в предыдущем разделе, табличное выражение в SELECT создаёт промежуточную
виртуальную таблицу, возможно объединяя таблицы, представления, группируя и исключая лиш-
106Запросы
ние строки и т. д. Полученная таблица передаётся для обработки в список выборки. Этот список
выбирает, какие столбцы промежуточной таблицы должны выводиться в результате и как именно.
7.3.1. Элементы списка выборки
Простейший список выборки образует элемент *, который выбирает все столбцы из полученного
табличного выражения. Список выборки также может содержать список выражений значения че-
рез запятую (как определено в Разделе 4.2). Например, это может быть список имён столбцов:
SELECT a, b, c FROM …
Имена столбцов a, b и c представляют либо фактические имена столбцов таблиц, перечисленных
в предложении FROM, либо их псевдонимы, определённые как описано в Подразделе 7.2.1.2. Про-
странство имён в списке выборки то же, что и в предложении WHERE, если не используется груп-
пировка. В противном случае оно совпадает с пространством имён предложения HAVING.
Если столбец с заданным именем есть в нескольких таблицах, необходимо также указать имя таб-
лицы, например так:
SELECT tbl1.a, tbl2.a, tbl1.b FROM …
Обращаясь к нескольким таблицам, бывает удобно получить сразу все столбцы одной из таблиц:
SELECT tbl1.</em>, tbl2.a FROM …
Подробнее запись имя_таблицы.* описывается в Подразделе 8.16.5.
Если в списке выборки используется обычное выражение значения, по сути при этом в возвраща-
емую таблицу добавляется новый виртуальный столбец. Выражение значения вычисляется один
раз для каждой строки результата со значениями столбцов в данной строке. Хотя выражения в
списке выборки не обязательно должны обращаться к столбцам табличного выражения из пред-
ложения FROM; они могут содержать, например и простые арифметические выражения.
7.3.2. Метки столбцов
Элементам в списке выборки можно назначить имена для последующей обработки, например, для
указания в предложении ORDER BY или для вывода в клиентском приложении. Например:
SELECT a AS value, b + c AS sum FROM …
Если выходное имя столбца не определено (с помощью AS), система назначает имя сама. Для про-
стых ссылок на столбцы этим именем становится имя целевого столбца, а для вызовов функций
это имя функции. Для сложных выражений система генерирует некоторое подходящее имя.
Слово AS можно опустить, но только если имя нового столбца не является ключевым словом
PostgreSQL (см. Приложение C). Во избежание случайного совпадения имени с ключевым словом
это имя можно заключить в кавычки. Например, VALUE — ключевое слово, поэтому такой вариант
не будет работать:
SELECT a value, b + c AS sum FROM …
а такой будет:
SELECT a “value”, b + c AS sum FROM …
Для предотвращения конфликта с ключевыми словами, которые могут появиться в будущем, ре-
комендуется всегда писать AS или заключать метки выходных столбцов в кавычки.
Примечание
Именование выходных столбцов отличается от того, что происходит в предложении
FROM (см. Подраздел 7.2.1.2). Один столбец можно переименовать дважды, но на выходе
окажется имя, назначенное в списке выборки.
107Запросы
7.3.3. DISTINCT
После обработки списка выборки в результирующей таблице можно дополнительно исключить
дублирующиеся строки. Для этого сразу после SELECT добавляется ключевое слово DISTINCT:
SELECT DISTINCT список_выборки …
(Чтобы явно включить поведение по умолчанию, когда возвращаются все строки, вместо DISTINCT
можно указать ключевое слово ALL.)
Две строки считаются разными, если они содержат различные значения минимум в одном столбце.
При этом значения NULL полагаются равными.
Кроме того, можно явно определить, какие строки будут считаться различными, следующим об-
разом:
SELECT DISTINCT ON (выражение [, выражение …]) список_выборки …
Здесь выражение — обычное выражение значения, вычисляемое для всех строк. Строки, для кото-
рых перечисленные выражения дают один результат, считаются дублирующимися и возвращается
только первая строка из такого набора. Заметьте, что «первая строка» набора может быть любой,
если только запрос не включает сортировку, гарантирующую однозначный порядок строк, посту-
пающих в фильтр DISTINCT. (Обработка DISTINCT ON производится после сортировки ORDER BY.)
Предложение DISTINCT ON не описано в стандарте SQL и иногда его применение считается плохим
стилем из-за возможной неопределённости в результатах. При разумном использовании GROUP BY
и подзапросов во FROM можно обойтись без этой конструкции, но часто она бывает удобнее.
7.4. Сочетание запросов
Результаты двух запросов можно обработать, используя операции над множествами: объединение,
пересечение и вычитание. Эти операции записываются соответственно так:
запрос1 UNION [ALL] запрос2
запрос1 INTERSECT [ALL] запрос2
запрос1 EXCEPT [ALL] запрос2
Здесь запрос1 и запрос2 — это запросы, в которых могут использоваться все возможности, рас-
смотренные до этого. Операции над множествами тоже можно вкладывать и соединять, например:
запрос1 UNION запрос2 UNION запрос3
Этот сложный запрос выполняется так:
(запрос1 UNION запрос2) UNION запрос3
UNION по сути добавляет результаты второго запроса к результатам первого (хотя никакой порядок
возвращаемых строк при этом не гарантируется). Более того, эта операция убирает дублирующи-
еся строки из результата так же, как это делает DISTINCT, если только не указано UNION ALL.
INTERSECT возвращает все строки, содержащиеся в результате и первого, и второго запроса. Дуб-
лирующиеся строки отфильтровываются, если не указано ALL.
EXCEPT возвращает все строки, которые есть в результате первого запроса, но отсутствуют в ре-
зультате второго. (Иногда это называют разницей двух запросов.) И здесь дублирующиеся строки
отфильтровываются, если не указано ALL.
Чтобы можно было вычислить объединение, пересечение или разницу результатов двух запросов,
эти запросы должны быть «совместимыми для объединения», что означает, что они должны иметь
одинаковое число столбцов и соответствующие столбцы должны быть совместимых типов, как опи-
сывается в Разделе 10.5.
7.5. Сортировка строк
108Запросы
После того как запрос выдал таблицу результатов (после обработки списка выборки), её можно от-
сортировать. Если сортировка не задана, строки возвращаются в неопределённом порядке. Факти-
ческий порядок строк в этом случае будет зависеть от плана соединения и сканирования, а также
от порядка данных на диске, поэтому полагаться на него нельзя. Определённый порядок выводи-
мых строк гарантируется, только если этап сортировки задан явно.
Порядок сортировки определяет предложение ORDER BY:
SELECT список_выборки
FROM табличное_выражение
ORDER BY выражение_сортировки1 [ASC | DESC] [NULLS { FIRST | LAST }]
[, выражение_сортировки2 [ASC | DESC] [NULLS { FIRST | LAST }] …]
Выражениями сортировки могут быть любые выражения, допустимые в списке выборки запроса.
Например:
SELECT a, b FROM table1 ORDER BY a + b, c;
Когда указывается несколько выражений, последующие значения позволяют отсортировать стро-
ки, в которых совпали все предыдущие значения. Каждое выражение можно дополнить ключевы-
ми словами ASC или DESC, которые выбирают сортировку соответственно по возрастанию или убы-
ванию. По умолчанию принят порядок по возрастанию (ASC). При сортировке по возрастанию сна-
чала идут меньшие значения, где понятие «меньше» определяется оператором &lt;. Подобным обра-
1
зом, сортировка по возрастанию определяется оператором &gt;.
Для определения места значений NULL можно использовать указания NULLS FIRST и NULLS LAST,
которые помещают значения NULL соответственно до или после значений не NULL. По умолча-
нию значения NULL считаются больше любых других, то есть подразумевается NULLS FIRST для
порядка DESC и NULLS LAST в противном случае.
Заметьте, что порядки сортировки определяются независимо для каждого столбца. Например,
ORDER BY x, y DESC означает ORDER BY x ASC, y DESC, и это не то же самое, что ORDER BY x
DESC, y DESC.
Здесь выражение_сортировки может быть меткой столбца или номером выводимого столбца, как в
данном примере:
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
Оба эти запроса сортируют результат по первому столбцу. Заметьте, что имя выводимого столбца
должно оставаться само по себе, его нельзя использовать в выражении. Например, это ошибка:
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;
– неправильно
Это ограничение позволяет уменьшить неоднозначность. Тем не менее неоднозначность возмож-
на, когда в ORDER BY указано простое имя, но оно соответствует и имени выходного столбца, и
столбцу из табличного выражения. В этом случае используется выходной столбец. Эта ситуация
может возникнуть, только когда с помощью AS выходному столбцу назначается то же имя, что
имеет столбец в другой таблице.
ORDER BY можно применить к результату комбинации UNION, INTERSECT и EXCEPT, но в этом случае
возможна сортировка только по номерам или именам столбцов, но не по выражениям.
7.6. LIMIT и OFFSET
Указания LIMIT и OFFSET позволяют получить только часть строк из тех, что выдал остальной за-
прос:
1
На деле PostgreSQL определяет порядок сортировки для ASC и DESC по классу оператора B-дерева по умолчанию для типа данных выражения. Обычно
типы данных создаются так, что этому порядку соответствуют операторы &lt; и &gt;, но возможно разработать собственный тип данных, который будет вести
себя по-другому.
109Запросы
SELECT список_выборки
FROM табличное_выражение
[ ORDER BY … ]
[ LIMIT { число | ALL } ] [ OFFSET число ]
Если указывается число LIMIT, в результате возвращается не больше заданного числа строк (мень-
ше может быть, если сам запрос выдал меньшее количество строк). LIMIT ALL равносильно отсут-
ствию указания LIMIT, как и LIMIT с аргументом NULL.
OFFSET указывает пропустить указанное число строк, прежде чем начать выдавать строки. OFFSET
0 равносильно отсутствию указания OFFSET, как и OFFSET с аргументом NULL.
Если указано и OFFSET, и LIMIT, сначала система пропускает OFFSET строк, а затем начинает под-
считывать строки для ограничения LIMIT.
Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата вы-
давались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества
строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду?
Порядок будет неизвестен, если не добавить ORDER BY.
Оптимизатор запроса учитывает ограничение LIMIT, строя планы выполнения запросов, поэтому
вероятнее всего планы (а значит и порядок строк) будут меняться при разных LIMIT и OFFSET. Та-
ким образом, различные значения LIMIT/OFFSET, выбирающие разные подмножества результатов
запроса, приведут к несогласованности результатов, если не установить предсказуемую сорти-
ровку с помощью ORDER BY. Это не ошибка, а неизбежное следствие того, что SQL не гарантирует
вывод результатов запроса в некотором порядке, если порядок не определён явно предложением
ORDER BY.
Строки, пропускаемые согласно предложению OFFSET, тем не менее должны вычисляться на сер-
вере. Таким образом, при больших значениях OFFSET работает неэффективно.
7.7. Списки VALUES
Предложение VALUES позволяет создать «постоянную таблицу», которую можно использовать в
запросе, не создавая и не наполняя таблицу в БД. Синтаксис предложения:
VALUES ( выражение [, …] ) [, …]
Для каждого списка выражений в скобках создаётся строка таблицы. Все списки должны иметь
одинаковое число элементов (т. е. число столбцов в таблице) и соответствующие элементы во всех
списках должны иметь совместимые типы данных. Фактический тип данных столбцов результата
определяется по тем же правилам, что и для UNION (см. Раздел 10.5).
Как пример:
VALUES (1, ‘one’), (2, ‘two’), (3, ‘three’);
вернёт таблицу из двух столбцов и трёх строк. Это равносильно такому запросу:
SELECT 1 AS column1, ‘one’ AS column2
UNION ALL
SELECT 2, ‘two’
UNION ALL
SELECT 3, ‘three’;
По умолчанию PostgreSQL назначает столбцам таблицы VALUES имена column1, column2 и т. д. Име-
на столбцов не определены в стандарте SQL и в другой СУБД они могут быть другими, поэтому
обычно лучше переопределить имена списком псевдонимов, например так:
=&gt; SELECT * FROM (VALUES (1, ‘one’), (2, ‘two’), (3, ‘three’)) AS t (num,letter);
num | letter
—–+——–
110Запросы
1 | one
2 | two
3 | three
(3 rows)
Синтаксически список VALUES с набором выражений равнозначен:
SELECT список_выборки FROM табличное_выражение
и допускается везде, где допустим SELECT. Например, вы можете использовать его в составе UNION
или добавить к нему определение_сортировки (ORDER BY, LIMIT и/или OFFSET). VALUES чаще всего
используется как источник данных для команды INSERT, а также как подзапрос.
За дополнительными сведениями обратитесь к справке VALUES.
7.8. Запросы WITH (Общие табличные выражения)
WITH предоставляет способ записывать дополнительные операторы для применения в больших за-
просах. Эти операторы, которые также называют общими табличными выражениями (Common
Table Expressions, CTE), можно представить как определения временных таблиц, существующих
только для одного запроса. Дополнительным оператором в предложении WITH может быть SELECT,
INSERT, UPDATE или DELETE, а само предложение WITH присоединяется к основному оператору, ко-
торым также может быть SELECT, INSERT, UPDATE или DELETE.
7.8.1. SELECT в WITH
Основное предназначение SELECT в предложении WITH заключается в разбиении сложных запросов
на простые части. Например, запрос:
WITH regional_sales AS (
SELECT region, SUM(amount) AS total_sales
FROM orders
GROUP BY region
), top_regions AS (
SELECT region
FROM regional_sales
WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
product,
SUM(quantity) AS product_units,
SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
выводит итоги по продажам только для передовых регионов. Предложение WITH определяет два
дополнительных оператора regional_sales и top_regions так, что результат regional_sales ис-
пользуется в top_regions, а результат top_regions используется в основном запросе SELECT. Этот
пример можно было бы переписать без WITH, но тогда нам понадобятся два уровня вложенных под-
запросов SELECT. Показанным выше способом это можно сделать немного проще.
Необязательное указание RECURSIVE превращает WITH из просто удобной синтаксической кон-
струкции в средство реализации того, что невозможно в стандартном SQL. Используя RECURSIVE,
запрос WITH может обращаться к собственному результату. Очень простой пример, суммирующий
числа от 1 до 100:
WITH RECURSIVE t(n) AS (
VALUES (1)
UNION ALL
SELECT n+1 FROM t WHERE n &lt; 100
111Запросы
)
SELECT sum(n) FROM t;
В общем виде рекурсивный запрос WITH всегда записывается как не рекурсивная часть, потом
UNION (или UNION ALL), а затем рекурсивная часть, где только в рекурсивной части можно обра-
титься к результату запроса. Такой запрос выполняется следующим образом:
Вычисление рекурсивного запроса
    <ol>
      <li>Вычисляется не рекурсивная часть. Для UNION (но не UNION ALL) отбрасываются дублирующи-
еся строки. Все оставшиеся строки включаются в результат рекурсивного запроса и также по-
мещаются во временную рабочую таблицу.</li>
      <li>Пока рабочая таблица не пуста, повторяются следующие действия:
a. Вычисляется рекурсивная часть так, что рекурсивная ссылка на сам запрос обращается
к текущему содержимому рабочей таблицы. Для UNION (но не UNION ALL) отбрасываются
дублирующиеся строки и строки, дублирующие ранее полученные. Все оставшиеся строки
включаются в результат рекурсивного запроса и также помещаются во временную проме-
жуточную таблицу.
b. Содержимое рабочей таблицы заменяется содержимым промежуточной таблицы, а затем
промежуточная таблица очищается.
Примечание
Строго говоря, этот процесс является итерационным, а не рекурсивным, но комитетом
по стандартам SQL был выбран термин RECURSIVE.
В показанном выше примере в рабочей таблице на каждом этапе содержится всего одна строка и
в ней последовательно накапливаются значения от 1 до 100. На сотом шаге, благодаря условию
WHERE, не возвращается ничего, так что вычисление запроса завершается.
Рекурсивные запросы обычно применяются для работы с иерархическими или древовидными
структурами данных. В качестве полезного примера можно привести запрос, находящий все непо-
средственные и косвенные составные части продукта, используя только таблицу с прямыми свя-
зями:
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
SELECT sub_part, part, quantity FROM parts WHERE part = ‘our_product’
UNION ALL
SELECT p.sub_part, p.part, p.quantity
FROM included_parts pr, parts p
WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
Работая с рекурсивными запросами, важно обеспечить, чтобы рекурсивная часть запроса в конце
концов не выдала никаких кортежей (строк), в противном случае цикл будет бесконечным. Иногда
для этого достаточно применять UNION вместо UNION ALL, так как при этом будут отбрасываться
строки, которые уже есть в результате. Однако часто в цикле выдаются строки, не совпадающие
полностью с предыдущими: в таких случаях может иметь смысл проверить одно или несколько по-
лей, чтобы определить, не была ли текущая точка достигнута раньше. Стандартный способ реше-
ния подобных задач — вычислить массив с уже обработанными значениями. Например, рассмот-
рите следующий запрос, просматривающий таблицу graph по полю link:
WITH RECURSIVE search_graph(id, link, data, depth) AS (
SELECT g.id, g.link, g.data, 1
112Запросы
FROM graph g
UNION ALL
SELECT g.id, g.link, g.data, sg.depth + 1
FROM graph g, search_graph sg
WHERE g.id = sg.link
)
SELECT * FROM search_graph;
Этот запрос зациклится, если связи link содержат циклы. Так как нам нужно получать в резуль-
тате «depth», одно лишь изменение UNION ALL на UNION не позволит избежать зацикливания. Вме-
сто этого мы должны как-то определить, что уже достигали текущей строки, пройдя некоторый
путь. Для этого мы добавляем два столбца path и cycle и получаем запрос, защищённый от зацик-
ливания:
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
SELECT g.id, g.link, g.data, 1,
ARRAY[g.id],
false
FROM graph g
UNION ALL
SELECT g.id, g.link, g.data, sg.depth + 1,
path || g.id,
g.id = ANY(path)
FROM graph g, search_graph sg
WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
Помимо предотвращения циклов, значения массива часто бывают полезны сами по себе для пред-
ставления «пути», приведшего к определённой строке.
В общем случае, когда для выявления цикла нужно проверять несколько полей, следует использо-
вать массив строк. Например, если нужно сравнить поля f1 и f2:
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
SELECT g.id, g.link, g.data, 1,
ARRAY[ROW(g.f1, g.f2)],
false
FROM graph g
UNION ALL
SELECT g.id, g.link, g.data, sg.depth + 1,
path || ROW(g.f1, g.f2),
ROW(g.f1, g.f2) = ANY(path)
FROM graph g, search_graph sg
WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
Подсказка
Часто для распознавания цикла достаточного одного поля и тогда ROW() можно опу-
стить. При этом будет использоваться не массив данных составного типа, а простой
массив, что более эффективно.
Подсказка
Этот алгоритм рекурсивного вычисления запроса выдаёт в результате узлы, упорядо-
ченные по пути погружения. Чтобы получить результаты, отсортированные по глуби-
113Запросы
не, можно добавить во внешний запрос ORDER BY по столбцу «path», полученному, как
показано выше.
Для тестирования запросов, которые могут зацикливаться, есть хороший приём — добавить LIMIT
в родительский запрос. Например, следующий запрос зациклится, если не добавить предложение
LIMIT:
WITH RECURSIVE t(n) AS (
SELECT 1
UNION ALL
SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
Но в данном случае этого не происходит, так как в PostgreSQL запрос WITH выдаёт столько строк,
сколько фактически принимает родительский запрос. В производственной среде использовать этот
приём не рекомендуется, так как другие системы могут вести себя по-другому. Кроме того, это не
будет работать, если внешний запрос сортирует результаты рекурсивного запроса или соединяет
их с другой таблицей, так как в подобных случаях внешний запрос обычно всё равно выбирает
результат запроса WITH полностью.
Запросы WITH имеют полезное свойство — они вычисляются только раз для всего родительского
запроса, даже если этот запрос или соседние запросы WITH обращаются к ним неоднократно. Та-
ким образом, сложные вычисления, результаты которых нужны в нескольких местах, можно выно-
сить в запросы WITH в целях оптимизации. Кроме того, такие запросы позволяют избежать неже-
лательных вычислений функций с побочными эффектами. Однако есть и обратная сторона — оп-
тимизатор не может распространить ограничения родительского запроса на запрос WITH так, как
он делает это для обычного подзапроса. Запрос WITH обычно выполняется буквально и возвращает
все строки, включая те, что потом может отбросить родительский запрос. (Но как было сказано
выше, вычисление может остановиться раньше, если в ссылке на этот запрос затребуется только
ограниченное число строк.)
Примеры выше показывают только предложение WITH с SELECT, но таким же образом его можно
использовать с командами INSERT, UPDATE и DELETE. В каждом случае он по сути создаёт временную
таблицу, к которой можно обратиться в основной команде.
7.8.2. Изменение данных в WITH
В предложении WITH можно также использовать операторы, изменяющие данные (INSERT, UPDATE
или DELETE). Это позволяет выполнять в одном запросе сразу несколько разных операций. Напри-
мер:
WITH moved_rows AS (
DELETE FROM products
WHERE
“date” &gt;= ‘2010-10-01’ AND
“date” &lt; ‘2010-11-01’
RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
Этот запрос фактически перемещает строки из products в products_log. Оператор DELETE в WITH
удаляет указанные строки из products и возвращает их содержимое в предложении RETURNING; а
затем главный запрос читает это содержимое и вставляет в таблицу products_log.
Следует заметить, что предложение WITH в данном случае присоединяется к оператору INSERT,
а не к SELECT, вложенному в INSERT. Это необходимо, так как WITH может содержать операторы,
изменяющие данные, только на верхнем уровне запроса. Однако при этом применяются обычные
114Запросы
правила видимости WITH, так что к результату WITH можно обратиться и из вложенного оператора
SELECT.
Операторы, изменяющие данные, в WITH обычно дополняются предложением RETURNING (см. Раз-
дел 6.4), как показано в этом примере. Важно понимать, что временная таблица, которую можно
будет использовать в остальном запросе, создаётся из результата RETURNING, а не целевой табли-
цы оператора. Если оператор, изменяющий данные, в WITH не дополнен предложением RETURNING,
временная таблица не создаётся и обращаться к ней в остальном запросе нельзя. Однако такой
запрос всё равно будет выполнен. Например, допустим следующий не очень практичный запрос:
WITH t AS (
DELETE FROM foo
)
DELETE FROM bar;
Он удалит все строки из таблиц foo и bar. При этом число задействованных строк, которое получит
клиент, будет подсчитываться только по строкам, удалённым из bar.
Рекурсивные ссылки в операторах, изменяющих данные, не допускаются. В некоторых случаях это
ограничение можно обойти, обратившись к конечному результату рекурсивного WITH, например
так:
WITH RECURSIVE included_parts(sub_part, part) AS (
SELECT sub_part, part FROM parts WHERE part = ‘our_product’
UNION ALL
SELECT p.sub_part, p.part
FROM included_parts pr, parts p
WHERE p.part = pr.sub_part
)
DELETE FROM parts
WHERE part IN (SELECT part FROM included_parts);
Этот запрос удаляет все непосредственные и косвенные составные части продукта.
Операторы, изменяющие данные в WITH, выполняются только один раз и всегда полностью, вне
зависимости от того, принимает ли их результат основной запрос. Заметьте, что это отличается
от поведения SELECT в WITH: как говорилось в предыдущем разделе, SELECT выполняется только до
тех пор, пока его результаты востребованы основным запросом.
Вложенные операторы в WITH выполняются одновременно друг с другом и с основным запросом.
Таким образом, порядок, в котором операторы в WITH будут фактически изменять данные, непред-
сказуем. Все эти операторы выполняются с одним снимком данных (см. Главу 13), так что они не
могут «видеть», как каждый из них меняет целевые таблицы. Это уменьшает эффект непредсказу-
емости фактического порядка изменения строк и означает, что RETURNING — единственный вари-
ант передачи изменений от вложенных операторов WITH основному запросу. Например, в данном
случае:
WITH t AS (
UPDATE products SET price = price * 1.05
RETURNING *
)
SELECT * FROM products;
внешний оператор SELECT выдаст цены, которые были до действия UPDATE, тогда как в запросе
WITH t AS (
UPDATE products SET price = price * 1.05
RETURNING *
)
SELECT * FROM t;
внешний SELECT выдаст изменённые данные.
115Запросы
Неоднократное изменение одной и той же строки в рамках одного оператора не поддерживается.
Иметь место будет только одно из нескольких изменений и надёжно определить, какое именно,
часто довольно сложно (а иногда и вовсе невозможно). Это так же касается случая, когда строка
удаляется и изменяется в том же операторе: в результате может быть выполнено только обновле-
ние. Поэтому в общем случае следует избегать подобного наложения операций. В частности, из-
бегайте подзапросов WITH, которые могут повлиять на строки, изменяемые основным оператором
или операторами, вложенные в него. Результат действия таких запросов будет непредсказуемым.
В настоящее время, для оператора, изменяющего данные в WITH, в качестве целевой нельзя ис-
пользовать таблицу, для которой определено условное правило или правило ALSO или INSTEAD, ес-
ли оно состоит из нескольких операторов.
11</li>
    </ol>
  </li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-006/" title="Глава 6. Модификация данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 6. Модификация данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-006/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~6 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-006/" rel="bookmark" title="Глава 6. Модификация данных" itemprop="url">Глава 6. Модификация данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 6. Модификация данных</p>

<p>В предыдущей главе мы обсуждали, как создавать таблицы и другие структуры для хранения дан-
ных. Теперь пришло время заполнить таблицы данными. В этой главе мы расскажем, как добав-
лять, изменять и удалять данные из таблиц. А из следующей главы вы наконец узнаете, как извле-
кать нужные вам данные из базы данных.
6.1. Добавление данных
Сразу после создания таблицы она не содержит никаких данных. Поэтому, чтобы она была полез-
на, в неё прежде всего нужно добавить данные. По сути данные добавляются в таблицу по одной
строке. И хотя вы конечно можете добавить в таблицу несколько строк, добавить в неё меньше,
чем строку, невозможно. Даже если вы указываете значения только некоторых столбцов, создаёт-
ся полная строка.
Чтобы создать строку, вы будете использовать команду INSERT. В этой команде необходимо ука-
зать имя таблицы и значения столбцов. Например, рассмотрим таблицу товаров из Главы 5:
CREATE TABLE products (
product_no integer,
name text,
price numeric
);
Добавить в неё строку можно было бы так:
INSERT INTO products VALUES (1, ‘Cheese’, 9.99);
Значения данных перечисляются в порядке столбцов в таблице и разделяются запятыми. Обычно
в качестве значений указываются константы, но это могут быть и скалярные выражения.
Показанная выше запись имеет один недостаток — вам необходимо знать порядок столбцов в таб-
лице. Чтобы избежать этого, можно перечислить столбцы явно. Например, следующие две коман-
ды дадут тот же результат, что и показанная выше:
INSERT INTO products (product_no, name, price) VALUES (1, ‘Cheese’, 9.99);
INSERT INTO products (name, price, product_no) VALUES (‘Cheese’, 9.99, 1);
Многие считают, что лучше всегда явно указывать имена столбцов.
Если значения определяются не для всех столбцов, лишние столбцы можно опустить. В таком
случае эти столбцы получат значения по умолчанию. Например:
INSERT INTO products (product_no, name) VALUES (1, ‘Cheese’);
INSERT INTO products VALUES (1, ‘Cheese’);
Вторая форма является расширением PostgreSQL. Она заполняет столбцы слева по числу передан-
ных значений, а все остальные столбцы принимают значения по умолчанию.
Для ясности можно также явно указать значения по умолчанию для отдельных столбцов или всей
строки:
INSERT INTO products (product_no, name, price) VALUES (1, ‘Cheese’, DEFAULT);
INSERT INTO products DEFAULT VALUES;
Одна команда может вставить сразу несколько строк:
INSERT INTO products (product_no, name, price) VALUES
(1, ‘Cheese’, 9.99),
(2, ‘Bread’, 1.99),
(3, ‘Milk’, 2.99);
Также возможно вставить результат запроса (который может не содержать строк либо содержать
одну или несколько):
89Модификация данных
INSERT INTO products (product_no, name, price)
SELECT product_no, name, price FROM new_products
WHERE release_date = ‘today’;
Это позволяет использовать все возможности механизма запросов SQL (см. Главу 7) для вычисле-
ния вставляемых строк.
Подсказка
Когда нужно добавить сразу множество строк, возможно будет лучше использовать ко-
манду COPY. Она не такая гибкая, как INSERT, но гораздо эффективнее. Дополнитель-
но об ускорении массовой загрузки данных можно узнать в Разделе 14.4.
6.2. Изменение данных
Модификация данных, уже сохранённых в БД, называется изменением. Изменить можно все стро-
ки таблицы, либо подмножество всех строк, либо только избранные строки. Каждый столбец при
этом можно изменять независимо от других.
Для изменения данных в существующих строках используется команда UPDATE. Ей требуется сле-
дующая информация:</p>
<ol>
  <li>Имя таблицы и изменяемого столбца</li>
  <li>Новое значение столбца</li>
  <li>Критерий отбора изменяемых строк
Если вы помните, в Главе 5 говорилось, что в SQL в принципе нет уникального идентификатора
строк. Таким образом, не всегда возможно явно указать на строку, которую требуется изменить.
Поэтому необходимо указать условия, каким должны соответствовать требуемая строка. Только
если в таблице есть первичный ключ (вне зависимости от того, объявляли вы его или нет), можно
однозначно адресовать отдельные строки, определив условие по первичному ключу. Этим пользу-
ются графические инструменты для работы с базой данных, дающие возможность редактировать
данные по строкам.
Например, следующая команда увеличивает цену всех товаров, имевших до этого цену 5, до 10:
UPDATE products SET price = 10 WHERE price = 5;
В результате может измениться ноль, одна или множество строк. И если этому запросу не будет
удовлетворять ни одна строка, это не будет ошибкой.
Давайте рассмотрим эту команду подробнее. Она начинается с ключевого слова UPDATE, за кото-
рым идёт имя таблицы. Как обычно, имя таблицы может быть записано в полной форме, в против-
ном случае она будет найдена по пути. Затем идёт ключевое слово SET, за которым следует имя
столбца, знак равенства и новое значение столбца. Этим значением может быть любое скалярное
выражение, а не только константа. Например, если вы захотите поднять цену всех товаров на 10%,
это можно сделать так:
UPDATE products SET price = price * 1.10;
Как видно из этого примера, выражение нового значения может ссылаться на существующие зна-
чения столбцов в строке. Мы также опустили в нём предложение WHERE. Это означает, что будут
изменены все строки в таблице. Если же это предложение присутствует, изменяются только стро-
ки, которые соответствуют условию WHERE. Заметьте, что хотя знак равенства в предложении SET
обозначает операцию присваивания, а такой же знак в предложении WHERE используется для срав-
нения, это не приводит к неоднозначности. И конечно, в условии WHERE не обязательно должна
быть проверка равенства, а могут применяться и другие операторы (см. Главу 9). Необходимо толь-
ко, чтобы это выражение возвращало логический результат.
В команде UPDATE можно изменить значения сразу нескольких столбцов, перечислив их в предло-
жении SET. Например:
90Модификация данных
UPDATE mytable SET a = 5, b = 3, c = 1 WHERE a &gt; 0;
6.3. Удаление данных
Мы рассказали о том, как добавлять данные в таблицы и как изменять их. Теперь вам осталось
узнать, как удалить данные, которые оказались не нужны. Так же, как добавлять данные можно
только целыми строками, удалять их можно только по строкам. В предыдущем разделе мы отмети-
ли, что в SQL нет возможности напрямую адресовать отдельные строки, так что удалить избранные
строки можно, только сформулировав для них подходящие условия. Но если в таблице есть пер-
вичный ключ, с его помощью можно однозначно выделить определённую строку. При этом можно
так же удалить группы строк, соответствующие условию, либо сразу все строки таблицы.
Для удаления строк используется команда DELETE; её синтаксис очень похож на синтаксис ко-
манды UPDATE. Например, удалить все строки из таблицы с товарами, имеющими цену 10, можно
так:
DELETE FROM products WHERE price = 10;
Если вы напишете просто:
DELETE FROM products;
будут удалены все строки таблицы! Будьте осторожны!
6.4. Возврат данных из изменённых строк
Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это
возможно с использованием предложения RETURNING, которое можно задать для команд INSERT,
UPDATE и DELETE. Применение RETURNING позволяет обойтись без дополнительного запроса к базе
для сбора данных и это особенно ценно, когда как-то иначе трудно получить изменённые строки
надёжным образом.
В предложении RETURNING допускается то же содержимое, что и в выходном списке команды
SELECT (см. Раздел 7.3). Оно может содержать имена столбцов целевой таблицы команды или зна-
чения выражений с этими столбцами. Также часто применяется краткая запись RETURNING *, вы-
бирающая все столбцы целевой таблицы по порядку.
В команде INSERT данные, выдаваемые в RETURNING, образуются из строки в том виде, в каком она
была вставлена. Это не очень полезно при простом добавлении, так как в результате будут полу-
чены те же данные, что были переданы клиентом. Но это может быть очень удобно при исполь-
зовании вычисляемых значений по умолчанию. Например, если в таблице есть столбец serial, в
котором генерируются уникальные идентификаторы, команда RETURNING может возвратить иден-
тификатор, назначенный новой строке:
CREATE TABLE users (firstname text, lastname text, id serial primary key);
INSERT INTO users (firstname, lastname) VALUES (‘Joe’, ‘Cool’) RETURNING id;
Предложение RETURNING также очень полезно с INSERT … SELECT.
В команде UPDATE данные, выдаваемые в RETURNING, образуются новым содержимым изменённой
строки. Например:
UPDATE products SET price = price * 1.10
WHERE price &lt;= 99.99
RETURNING name, price AS new_price;
В команде DELETE данные, выдаваемые в RETURNING, образуются содержимым удалённой строки.
Например:
DELETE FROM products
WHERE obsoletion_date = ‘today’
91Модификация данных
RETURNING *;
Если для целевой таблицы заданы триггеры (см. Главу 39), в RETURNING выдаются данные из стро-
ки, изменённой триггерами. Таким образом, RETURNING часто применяется и для того, чтобы про-
верить содержимое столбцов, изменяемых триггерами.</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-005/" title="Глава 5. Определение данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 5. Определение данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-005/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~80 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-005/" rel="bookmark" title="Глава 5. Определение данных" itemprop="url">Глава 5. Определение данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 5. Определение данных</p>

<p>Эта глава рассказывает, как создавать структуры базы данных, в которых будут храниться данные.
В реляционной базе данных данные хранятся в таблицах, так что большая часть этой главы будет
посвящена созданию и изменению таблиц, а также средствам управления данными в них. Затем
мы обсудим, как таблицы можно объединять в схемы и как ограничивать доступ к ним. Наконец,
мы кратко рассмотрим другие возможности, связанные с хранением данных, в частности наследо-
вание, секционирование таблиц, представления, функции и триггеры.
5.1. Основы таблиц
Таблица в реляционной базе данных похожа на таблицу на бумаге: она так же состоит из строк
и столбцов. Число и порядок столбцов фиксированы, а каждый столбец имеет имя. Число строк
переменно — оно отражает текущее количество находящихся в ней данных. SQL не даёт никаких
гарантий относительно порядка строк таблицы. При чтении таблицы строки выводятся в произ-
вольном порядке, если только явно не требуется сортировка. Подробнее это рассматривается в
Главе 7. Более того, SQL не назначает строкам уникальные идентификаторы, так что можно иметь
в таблице несколько полностью идентичных строк. Это вытекает из математической модели, кото-
рую реализует SQL, но обычно такое дублирование нежелательно. Позже в этой главе мы увидим,
как его избежать.
Каждому столбцу сопоставлен тип данных. Тип данных ограничивает набор допустимых значений,
которые можно присвоить столбцу, и определяет смысловое значение данных для вычислений.
Например, в столбец числового типа нельзя записать обычные текстовые строки, но зато его дан-
ные можно использовать в математических вычислениях. И наоборот, если столбец имеет тип тек-
стовой строки, для него допустимы практически любые данные, но он непригоден для математи-
ческих действий (хотя другие операции, например конкатенация строк, возможны).
В PostgreSQL есть внушительный набор встроенных типов данных, удовлетворяющий большин-
ство приложений. Пользователи также могут определять собственные типы данных. Большинство
встроенных типов данных имеют понятные имена и семантику, так что мы отложим их подробное
рассмотрение до Главы 8. Наиболее часто применяются следующие типы данных: integer для це-
лых чисел, numeric для чисел, которые могут быть дробными, text для текстовых строк, date для
дат, time для времени и timestamp для значений, включающих дату и время.
Для создания таблицы используется команда CREATE TABLE. В этой команде вы должны указать
как минимум имя новой таблицы и имена и типы данных каждого столбца. Например:
CREATE TABLE my_first_table (
first_column text,
second_column integer
);
Так вы создадите таблицу my_first_table с двумя столбцами. Первый столбец называется
first_column и имеет тип данных text; второй столбец называется second_column и имеет тип
integer. Имена таблицы и столбцов соответствуют синтаксису идентификаторов, описанному в
Подразделе 4.1.1. Имена типов также являются идентификаторами, хотя есть некоторые исключе-
ния. Заметьте, что список столбцов заключается в скобки, а его элементы разделяются запятыми.
Конечно, предыдущий пример ненатурален. Обычно в именах таблиц и столбцов отражается, ка-
кие данные они будут содержать. Поэтому давайте взглянем на более реалистичный пример:
CREATE TABLE products (
product_no integer,
name text,
price numeric
);
(Тип numeric может хранить дробные числа, в которых обычно выражаются денежные суммы.)
48Определение данных
Подсказка
Когда вы создаёте много взаимосвязанных таблиц, имеет смысл заранее выбрать еди-
ный шаблон именования таблиц и столбцов. Например, решить, будут ли в именах таб-
лиц использоваться существительные во множественном или в единственном числе
(есть соображения в пользу каждого варианта).
Число столбцов в таблице не может быть бесконечным. Это число ограничивается максимумом
в пределах от 250 до 1600, в зависимости от типов столбцов. Однако создавать таблицы с таким
большим числом столбцов обычно не требуется, а если такая потребность возникает, это скорее
признак сомнительного дизайна.
Если таблица вам больше не нужна, вы можете удалить её, выполнив команду DROP TABLE. На-
пример:
DROP TABLE my_first_table;
DROP TABLE products;
Попытка удаления несуществующей таблицы считается ошибкой. Тем не менее в SQL-скриптах
часто применяют безусловное удаление таблиц перед созданием, игнорируя все сообщения об
ошибках, так что они выполняют свою задачу независимо от того, существовали таблицы или нет.
(Если вы хотите избежать таких ошибок, можно использовать вариант DROP TABLE IF EXISTS, но
это не будет соответствовать стандарту SQL.)
Как изменить существующую таблицу, будет рассмотрено в этой главе позже, в Разделе 5.5.
Имея средства, которые мы обсудили, вы уже можете создавать полностью функциональные табли-
цы. В продолжении этой главы рассматриваются дополнительные возможности, призванные обес-
печить целостность данных, безопасность и удобство. Если вам не терпится наполнить свои таб-
лицы данными, вы можете вернуться к этой главе позже, а сейчас перейти к Главе 6.
5.2. Значения по умолчанию
Столбцу можно назначить значение по умолчанию. Когда добавляется новая строка и каким-то
её столбцам не присваиваются значения, эти столбцы принимают значения по умолчанию. Также
команда управления данными может явно указать, что столбцу должно быть присвоено значение
по умолчанию, не зная его. (Подробнее команды управления данными описаны в Главе 6.)
Если значение по умолчанию не объявлено явно, им считается значение NULL. Обычно это имеет
смысл, так как можно считать, что NULL представляет неизвестные данные.
В определении таблицы значения по умолчанию указываются после типа данных столбца. Напри-
мер:
CREATE TABLE products (
product_no integer,
name text,
price numeric DEFAULT 9.99
);
Значение по умолчанию может быть выражением, которое в этом случае вычисляется в мо-
мент присваивания значения по умолчанию (а не когда создаётся таблица). Например, столбцу
timestamp в качестве значения по умолчания часто присваивается CURRENT_TIMESTAMP, чтобы в
момент добавления строки в нём оказалось текущее время. Ещё один распространённый пример
— генерация «последовательных номеров» для всех строк. В PostgreSQL это обычно делается при-
мерно так:
CREATE TABLE products (
product_no integer DEFAULT nextval(‘products_product_no_seq’),
49Определение данных
…
);
здесь функция nextval() выбирает очередное значение из последовательности (см. Раздел 9.16).
Это употребление настолько распространено, что для него есть специальная короткая запись:
CREATE TABLE products (
product_no SERIAL,
…
);
SERIAL обсуждается позже в Подразделе 8.1.4.
5.3. Ограничения
Типы данных сами по себе ограничивают множество данных, которые можно сохранить в таблице.
Однако для многих приложений такие ограничения слишком грубые. Например, столбец, содер-
жащий цену продукта, должен, вероятно, принимать только положительные значения. Но такого
стандартного типа данных нет. Возможно, вы также захотите ограничить данные столбца по от-
ношению к другим столбцам или строкам. Например, в таблице с информацией о товаре должна
быть только одна строка с определённым кодом товара.
Для решения подобных задач SQL позволяет вам определять ограничения для столбцов и таб-
лиц. Ограничения дают вам возможность управлять данными в таблицах так, как вы захотите. Ес-
ли пользователь попытается сохранить в столбце значение, нарушающее ограничения, возникнет
ошибка. Ограничения будут действовать, даже если это значение по умолчанию.
5.3.1. Ограничения-проверки
Ограничение-проверка — наиболее общий тип ограничений. В его определении вы можете ука-
зать, что значение данного столбца должно удовлетворять логическому выражению (проверке ис-
тинности). Например, цену товара можно ограничить положительными значениями так:
CREATE TABLE products (
product_no integer,
name text,
price numeric CHECK (price &gt; 0)
);
Как вы видите, ограничение определяется после типа данных, как и значение по умолчанию. Зна-
чения по умолчанию и ограничения могут указываться в любом порядке. Ограничение-проверка
состоит из ключевого слова CHECK, за которым идёт выражение в скобках. Это выражение должно
включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла.
Вы можете также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и
позволит вам ссылаться на это ограничение, когда вам понадобится изменить его. Сделать это
можно так:
CREATE TABLE products (
product_no integer,
name text,
price numeric CONSTRAINT positive_price CHECK (price &gt; 0)
);
То есть, чтобы создать именованное ограничение, напишите ключевое слово CONSTRAINT, а за ним
идентификатор и собственно определение ограничения. (Если вы не определите имя ограничения
таким образом, система выберет для него имя за вас.)
Ограничение-проверка может также ссылаться на несколько столбцов. Например, если вы храните
обычную цену и цену со скидкой, так вы можете гарантировать, что цена со скидкой будет всегда
меньше обычной:
50Определение данных
CREATE TABLE products (
product_no integer,
name text,
price numeric CHECK (price &gt; 0),
discounted_price numeric CHECK (discounted_price &gt; 0),
CHECK (price &gt; discounted_price)
);
Первые два ограничения определяются похожим образом, но для третьего используется новый
синтаксис. Оно не связано с определённым столбцом, а представлено отдельным элементом в спис-
ке. Определения столбцов и такие определения ограничений можно переставлять в произвольном
порядке.
Про первые два ограничения можно сказать, что это ограничения столбцов, тогда как третье яв-
ляется ограничением таблицы, так как оно написано отдельно от определений столбцов. Ограни-
чения столбцов также можно записать в виде ограничений таблицы, тогда как обратное не все-
гда возможно, так как подразумевается, что ограничение столбца ссылается только на связанный
столбец. (Хотя PostgreSQL этого не требует, но для совместимости с другими СУБД лучше следо-
вать это правилу.) Ранее приведённый пример можно переписать и так:
CREATE TABLE products (
product_no integer,
name text,
price numeric,
CHECK (price &gt; 0),
discounted_price numeric,
CHECK (discounted_price &gt; 0),
CHECK (price &gt; discounted_price)
);
Или даже так:
CREATE TABLE products (
product_no integer,
name text,
price numeric CHECK (price &gt; 0),
discounted_price numeric,
CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
Это дело вкуса.
Ограничениям таблицы можно присваивать имена так же, как и ограничениям столбцов:
CREATE TABLE products (
product_no integer,
name text,
price numeric,
CHECK (price &gt; 0),
discounted_price numeric,
CHECK (discounted_price &gt; 0),
CONSTRAINT valid_discount CHECK (price &gt; discounted_price)
);
Следует заметить, что ограничение-проверка удовлетворяется, если выражение принимает зна-
чение true или NULL. Так как результатом многих выражений с операндами NULL будет значе-
ние NULL, такие ограничения не будут препятствовать записи NULL в связанные столбцы. Чтобы
гарантировать, что столбец не содержит значения NULL, можно использовать ограничение NOT
NULL, описанное в следующем разделе.
5.3.2. Ограничения NOT NULL
51Определение данных
Ограничение NOT NULL просто указывает, что столбцу нельзя присваивать значение NULL. При-
мер синтаксиса:
CREATE TABLE products (
product_no integer NOT NULL,
name text NOT NULL,
price numeric
);
Ограничение NOT NULL всегда записывается как ограничение столбца и функционально эквива-
лентно ограничению CHECK (имя_столбца IS NOT NULL), но в PostgreSQL явное ограничение NOT
NULL работает более эффективно. Хотя у такой записи есть недостаток — назначить имя таким
ограничениям нельзя.
Естественно, для столбца можно определить больше одного ограничения. Для этого их нужно про-
сто указать одно за другим:
CREATE TABLE products (
product_no integer NOT NULL,
name text NOT NULL,
price numeric NOT NULL CHECK (price &gt; 0)
);
Порядок здесь не имеет значения, он не обязательно соответствует порядку проверки ограниче-
ний.
Для ограничения NOT NULL есть и обратное: ограничение NULL. Оно не означает, что столбец дол-
жен иметь только значение NULL, что конечно было бы бессмысленно. Суть же его в простом ука-
зании, что столбец может иметь значение NULL (это поведение по умолчанию). Ограничение NULL
отсутствует в стандарте SQL и использовать его в переносимых приложениях не следует. (Оно бы-
ло добавлено в PostgreSQL только для совместимости с некоторыми другими СУБД.) Однако неко-
торые пользователи любят его использовать, так как оно позволяет легко переключать ограниче-
ния в скрипте. Например, вы можете начать с:
CREATE TABLE products (
product_no integer NULL,
name text NULL,
price numeric NULL
);
и затем вставить ключевое слово NOT, где потребуется.
Подсказка
При проектировании баз данных чаще всего большинство столбцов должны быть по-
мечены как NOT NULL.
5.3.3. Ограничения уникальности
Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов
уникальны среди всех строк таблицы. Ограничение записывается так:
CREATE TABLE products (
product_no integer UNIQUE,
name text,
price numeric
);
в виде ограничения столбца и так:
52Определение данных
CREATE TABLE products (
product_no integer,
name text,
price numeric,
UNIQUE (product_no)
);
в виде ограничения таблицы.
Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограни-
чения таблицы, перечислив имена столбцов через запятую:
CREATE TABLE example (
a integer,
b integer,
c integer,
UNIQUE (a, c)
);
Такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уни-
кально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и
обычно не будут) уникальными.
Вы можете назначить уникальному ограничению имя обычным образом:
CREATE TABLE products (
product_no integer CONSTRAINT must_be_different UNIQUE,
name text,
price numeric
);
При добавлении ограничения уникальности будет автоматически создан уникальный индекс-B-
дерево для столбца или группы столбцов, перечисленных в ограничении. Условие уникальности,
распространяющееся только на некоторые строки, нельзя записать в виде ограничения уникаль-
ности, однако такое условие можно установить, создав уникальный частичный индекс.
Вообще говоря, ограничение уникальности нарушается, если в таблице оказывается несколько
строк, у которых совпадают значения всех столбцов, включённых в ограничение. Однако два зна-
чения NULL при сравнении никогда не считаются равными. Это означает, что даже при наличии
ограничения уникальности в таблице можно сохранить строки с дублирующимися значениями,
если они содержат NULL в одном или нескольких столбцах ограничения. Это поведение соответ-
ствует стандарту SQL, но мы слышали о СУБД, которые ведут себя по-другому. Имейте в виду эту
особенность, разрабатывая переносимые приложения.
5.3.4. Первичные ключи
Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может
быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были
одновременно уникальными и отличными от NULL. Таким образом, таблицы со следующими двумя
определениями будут принимать одинаковые данные:
CREATE TABLE products (
product_no integer UNIQUE NOT NULL,
name text,
price numeric
);
CREATE TABLE products (
product_no integer PRIMARY KEY,
name text,
price numeric
53Определение данных
);
Первичные ключи могут включать несколько столбцов; синтаксис похож на запись ограничений
уникальности:
CREATE TABLE example (
a integer,
b integer,
c integer,
PRIMARY KEY (a, c)
);
При добавлении первичного ключа автоматически создаётся уникальный индекс-B-дерево для
столбца или группы столбцов, перечисленных в первичном ключе, и данные столбцы помечаются
как NOT NULL.
Таблица может иметь максимум один первичный ключ. (Ограничений уникальности и ограни-
чений NOT NULL, которые функционально почти равнозначны первичным ключам, может быть
сколько угодно, но назначить ограничением первичного ключа можно только одно.) Теория реля-
ционных баз данных говорит, что первичный ключ должен быть в каждой таблице. В PostgreSQL
такого жёсткого требования нет, но обычно лучше ему следовать.
Первичные ключи полезны и для документирования, и для клиентских приложений. Например,
графическому приложению с возможностями редактирования содержимого таблицы, вероятно,
потребуется знать первичный ключ таблицы, чтобы однозначно идентифицировать её строки. Пер-
вичные ключи находят и другое применение в СУБД; в частности, первичный ключ в таблице опре-
деляет целевые столбцы по умолчанию для сторонних ключей, ссылающихся на эту таблицу.
5.3.5. Внешние ключи
Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны со-
ответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целост-
ностью двух связанных таблиц.
Пусть у вас уже есть таблица продуктов, которую мы неоднократно использовали ранее:
CREATE TABLE products (
product_no integer PRIMARY KEY,
name text,
price numeric
);
Давайте предположим, что у вас есть таблица с заказами этих продуктов. Мы хотим, чтобы в таб-
лице заказов содержались только заказы действительно существующих продуктов. Поэтому мы
определим в ней ограничение внешнего ключа, ссылающееся на таблицу продуктов:
CREATE TABLE orders (
order_id integer PRIMARY KEY,
product_no integer REFERENCES products (product_no),
quantity integer
);
С таким ограничением создать заказ со значением product_no, отсутствующим в таблице products
(и не равным NULL), будет невозможно.
В такой схеме таблицу orders называют подчинённой таблицей, а products — главной. Соответ-
ственно, столбцы называют так же подчинённым и главным (или ссылающимся и целевым).
Предыдущую команду можно сократить так:
CREATE TABLE orders (
order_id integer PRIMARY KEY,
54Определение данных
product_no integer REFERENCES products,
quantity integer
);
то есть, если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом
главной таблицы.
Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в
виде обычного ограничения таблицы. Например:
CREATE TABLE t1 (
a integer PRIMARY KEY,
b integer,
c integer,
FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
Естественно, число и типы столбцов в ограничении должны соответствовать числу и типам целе-
вых столбцов.
Ограничению внешнего ключа можно назначить имя стандартным способом.
Таблица может содержать несколько ограничений внешнего ключа. Это полезно для связи таблиц
в отношении многие-ко-многим. Скажем, у вас есть таблицы продуктов и заказов, но вы хотите,
чтобы один заказ мог содержать несколько продуктов (что невозможно в предыдущей схеме). Для
этого вы можете использовать такую схему:
CREATE TABLE products (
product_no integer PRIMARY KEY,
name text,
price numeric
);
CREATE TABLE orders (
order_id integer PRIMARY KEY,
shipping_address text,
…
);
CREATE TABLE order_items (
product_no integer REFERENCES products,
order_id integer REFERENCES orders,
quantity integer,
PRIMARY KEY (product_no, order_id)
);
Заметьте, что в последней таблице первичный ключ покрывает внешние ключи.
Мы знаем, что внешние ключи запрещают создание заказов, не относящихся ни к одному продук-
ту. Но что делать, если после создания заказов с определённым продуктом мы захотим удалить
его? SQL справится с этой ситуацией. Интуиция подсказывает следующие варианты поведения:
• Запретить удаление продукта
• Удалить также связанные заказы
• Что-то ещё?
Для иллюстрации давайте реализуем следующее поведение в вышеприведённом примере: при по-
пытке удаления продукта, на который ссылаются заказы (через таблицу order_items), мы запре-
щаем эту операцию. Если же кто-то попытается удалить заказ, то удалится и его содержимое:
CREATE TABLE products (
product_no integer PRIMARY KEY,
55Определение данных
name text,
price numeric
);
CREATE TABLE orders (
order_id integer PRIMARY KEY,
shipping_address text,
…
);
CREATE TABLE order_items (
product_no integer REFERENCES products ON DELETE RESTRICT,
order_id integer REFERENCES orders ON DELETE CASCADE,
quantity integer,
PRIMARY KEY (product_no, order_id)
);
Ограничивающие и каскадные удаления — два наиболее распространённых варианта. RESTRICT
предотвращает удаление связанной строки. NO ACTION означает, что если зависимые строки про-
должают существовать при проверке ограничения, возникает ошибка (это поведение по умолча-
нию). (Главным отличием этих двух вариантов является то, что NO ACTION позволяет отложить про-
верку в процессе транзакции, а RESTRICT — нет.) CASCADE указывает, что при удалении связанных
строк зависимые от них будут так же автоматически удалены. Есть ещё два варианта: SET NULL
и SET DEFAULT. При удалении связанных строк они назначают зависимым столбцам в подчинён-
ной таблице значения NULL или значения по умолчанию, соответственно. Заметьте, что это не
будет основанием для нарушения ограничений. Например, если в качестве действия задано SET
DEFAULT, но значение по умолчанию не удовлетворяет ограничению внешнего ключа, операция
закончится ошибкой.
Аналогично указанию ON DELETE существует ON UPDATE, которое срабатывает при изменении за-
данного столбца. При этом возможные действия те же, а CASCADE в данном случае означает, что
изменённые значения связанных столбцов будут скопированы в зависимые строки.
Обычно зависимая строка не должна удовлетворять ограничению внешнего ключа, если один из
связанных столбцов содержит NULL. Если в объявление внешнего ключа добавлено MATCH FULL,
строка будет удовлетворять ограничению, только если все связанные столбцы равны NULL (то
есть при разных значениях (NULL и не NULL) гарантируется невыполнение ограничения MATCH
FULL). Если вы хотите, чтобы зависимые строки не могли избежать и этого ограничения, объявите
связанные столбцы как NOT NULL.
Внешний ключ должен ссылаться на столбцы, образующие первичный ключ или ограничение уни-
кальности. Таким образом, для связанных столбцов всегда будет существовать индекс (определён-
ный соответствующим первичным ключом или ограничением), а значит проверки соответствия
связанной строки будут выполняться эффективно. Так как команды DELETE для строк главной таб-
лицы или UPDATE для зависимых столбцов потребуют просканировать подчинённую таблицу и най-
ти строки, ссылающиеся на старые значения, полезно будет иметь индекс и для подчинённых
столбцов. Но это нужно не всегда, и создать соответствующий индекс можно по-разному, поэтому
объявление внешнего ключа не создаёт автоматически индекс по связанным столбцам.
Подробнее об изменении и удалении данных рассказывается в Главе 6. Вы также можете подроб-
нее узнать о синтаксисе ограничений внешнего ключа в справке CREATE TABLE.
5.3.6. Ограничения-исключения
Ограничения-исключения гарантируют, что при сравнении любых двух строк по указанным столб-
цам или выражениям с помощью заданных операторов, минимум одно из этих сравнений возвра-
тит false или NULL. Записывается это так:
CREATE TABLE circles (
56Определение данных
c circle,
EXCLUDE USING gist (c WITH &amp;&amp;)
);
Подробнее об этом см. CREATE TABLE … CONSTRAINT … EXCLUDE.
При добавлении ограничения-исключения будет автоматически создан индекс того типа, который
указан в объявлении ограничения.
5.4. Системные столбцы
В каждой таблице есть несколько системных столбцов, неявно определённых системой. Как след-
ствие, их имена нельзя использовать в качестве имён пользовательских столбцов. (Заметьте, что
это не зависит от того, является ли имя ключевым словом или нет; заключение имени в кавычки
не поможет избежать этого ограничения.) Эти столбцы не должны вас беспокоить, вам лишь до-
статочно знать об их существовании.
oid
Идентификатор объекта (object ID) для строки. Этот столбец присутствует, только если таблица
была создана с указанием WITH OIDS, или если в момент её создания была установлена пере-
менная конфигурации default_with_oids. Этот столбец имеет тип oid (с тем же именем, что и
сам столбец); подробнее об этом типе см. Раздел 8.19.
tableoid
Идентификатор объекта для таблицы, содержащей строку. Этот столбец особенно полезен для
запросов, имеющих дело с иерархией наследования (см. Раздел  5.9), так как без него слож-
но определить, из какой таблицы выбрана строка. Связав tableoid со столбцом oid в таблице
pg_class, можно будет получить имя таблицы.
xmin
Идентификатор (код) транзакции, добавившей строку этой версии. (Версия строки — это её
индивидуальное состояние; при каждом изменении создаётся новая версия одной и той же
логической строки.)
cmin
Номер команды (начиная с нуля) внутри транзакции, добавившей строку.
xmax
Идентификатор транзакции, удалившей строку, или 0 для неудалённой версии строки. Значе-
ние этого столбца может быть ненулевым и для видимой версии строки. Это обычно означает,
что удаляющая транзакция ещё не была зафиксирована, или удаление было отменено.
cmax
Номер команды в удаляющей транзакции или ноль.
ctid
Физическое расположение данной версии строки в таблице. Заметьте, что хотя по ctid можно
очень быстро найти версию строки, значение ctid изменится при выполнении VACUUM FULL.
Таким образом, ctid нельзя применять в качестве долгосрочного идентификатора строки. Для
идентификации логических строк лучше использовать OID или даже дополнительный последо-
вательный номер.
Коды OID представляют собой 32-битные значения и выбираются из единого для всей СУБД счёт-
чика. В больших или долгоживущих базах данных этот счётчик может пойти по кругу. Таким об-
57Определение данных
разом, не рекомендуется рассчитывать на уникальность OID, если только вы не обеспечите её до-
полнительно. Если вам нужно идентифицировать строки таблицы, настоятельно рекомендуется
использовать последовательности. Однако можно использовать и коды OID, при выполнении сле-
дующих условий:
• Когда для идентификации строк таблиц применяется OID, в каждой такой таблице должно со-
здаваться ограничение уникальности для столбца OID. Когда такое ограничение уникально-
сти (или уникальный индекс) существует, система позаботится о том, чтобы OID новой строки
32
не совпал с уже существующими. (Конечно, это возможно, только если в таблице меньше 2
(4 миллиардов) строк, а на практике таблицы должны быть гораздо меньше, иначе может по-
страдать производительность системы.)
• Никогда не следует рассчитывать, что OID будут уникальны среди всех таблиц; в качестве
глобального идентификатора в рамках базы данных используйте комбинацию tableoid и OID
строки.
• Конечно, все эти таблицы должны быть созданы с указанием WITH OIDS. В PostgreSQL 8.1 и
новее по умолчанию подразумевается WITHOUT OIDS.
Идентификаторы транзакций также являются 32-битными. В долгоживущей базе данных они мо-
гут пойти по кругу. Это не критично при правильном обслуживании БД; подробнее об этом см.
Главу 24. Однако полагаться на уникальность кодов транзакций в течение длительного времени
(при более чем миллиарде транзакций) не следует.
32
Идентификаторы команд также 32-битные. Это создаёт жёсткий лимит на 2 (4 миллиарда) ко-
манд SQL в одной транзакции. На практике это не проблема — заметьте, что это лимит числа ко-
манд SQL, а не количества обрабатываемых строк. Кроме того, идентификатор получают только
те команды, которые фактически изменяют содержимое базы данных.
5.5. Изменение таблиц
Если вы создали таблицы, а затем поняли, что допустили ошибку, или изменились требования
вашего приложения, вы можете удалить её и создать заново. Но это будет неудобно, если табли-
ца уже заполнена данными, или если на неё ссылаются другие объекты базы данных (например,
по внешнему ключу). Поэтому PostgreSQL предоставляет набор команд для модификации таблиц.
Заметьте, что это по сути отличается от изменения данных, содержащихся в таблице: здесь мы
обсуждаем модификацию определения, или структуры, таблицы.
Вы можете:
•
•
•
•
•
•
•
•
Добавлять столбцы
Удалять столбцы
Добавлять ограничения
Удалять ограничения
Изменять значения по умолчанию
Изменять типы столбцов
Переименовывать столбцы
Переименовывать таблицы
Все эти действия выполняются с помощью команды ALTER TABLE; подробнее о ней вы можете
узнать в её справке.
5.5.1. Добавление столбца
Добавить столбец вы можете так:
ALTER TABLE products ADD COLUMN description text;
Новый столбец заполняется заданным для него значением по умолчанию (или значением NULL,
если вы не добавите указание DEFAULT).
58Определение данных
При этом вы можете сразу определить ограничения столбца, используя обычный синтаксис:
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; ‘’);
На самом деле здесь можно использовать все конструкции, допустимые в определении столбца в
команде CREATE TABLE. Помните однако, что значение по умолчанию должно удовлетворять дан-
ным ограничениям, чтобы операция ADD выполнилась успешно. Вы также можете сначала запол-
нить столбец правильно, а затем добавить ограничения (см. ниже).
Подсказка
Добавление столбца со значением по умолчанию приводит к изменению всех строк
таблицы (в них будет сохранено новое значение). Однако, если значение по умолчанию
не указано, PostgreSQL может обойтись без физического изменения. Поэтому, если вы
планируете заполнить столбец в основном не значениями по умолчанию, лучше будет
добавить столбец без значения по умолчанию, затем вставить требуемые значения с
помощью UPDATE, а потом определить значение по умолчанию, как описано ниже.
5.5.2. Удаление столбца
Удалить столбец можно так:
ALTER TABLE products DROP COLUMN description;
Данные, которые были в этом столбце, исчезают. Вместе со столбцом удаляются и включающие его
ограничения таблицы. Однако, если на столбец ссылается ограничение внешнего ключа другой
таблицы, PostgreSQL не удалит это ограничение неявно. Разрешить удаление всех зависящих от
этого столбца объектов можно, добавив указание CASCADE:
ALTER TABLE products DROP COLUMN description CASCADE;
Общий механизм, стоящий за этим, описывается в Разделе 5.13.
5.5.3. Добавление ограничения
Для добавления ограничения используется синтаксис ограничения таблицы. Например:
ALTER TABLE products ADD CHECK (name &lt;&gt; ‘’);
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id)
REFERENCES product_groups;
Чтобы добавить ограничение NOT NULL, которое нельзя записать в виде ограничения таблицы,
используйте такой синтаксис:
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
Ограничение проходит проверку автоматически и будет добавлено, только если ему удовлетворя-
ют данные таблицы.
5.5.4. Удаление ограничения
Для удаления ограничения вы должны знать его имя. Если вы не присваивали ему имя, это неявно
сделала система, и вы должны выяснить его. Здесь может быть полезна команда psql \d имя_таб-
лицы (или другие программы, показывающие подробную информацию о таблицах). Зная имя, вы
можете использовать команду:
ALTER TABLE products DROP CONSTRAINT some_name;
(Если вы имеете дело с именем ограничения вида $2, не забудьте заключить его в кавычки, чтобы
это был допустимый идентификатор.)
59Определение данных
Как и при удалении столбца, если вы хотите удалить ограничение с зависимыми объектами, до-
бавьте указание CASCADE. Примером такой зависимости может быть ограничение внешнего ключа,
связанное со столбцами ограничения первичного ключа.
Так можно удалить ограничения любых типов, кроме NOT NULL. Чтобы удалить ограничение NOT
NULL, используйте команду:
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
(Вспомните, что у ограничений NOT NULL нет имён.)
5.5.5. Изменение значения по умолчанию
Назначить столбцу новое значение по умолчанию можно так:
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
Заметьте, что это никак не влияет на существующие строки таблицы, а просто задаёт значение по
умолчанию для последующих команд INSERT.
Чтобы удалить значение по умолчанию, выполните:
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
При этом по сути значению по умолчанию просто присваивается NULL. Как следствие, ошибки
не будет, если вы попытаетесь удалить значение по умолчанию, не определённое явно, так как
неявно оно существует и равно NULL.
5.5.6. Изменение типа данных столбца
Чтобы преобразовать столбец в другой тип данных, используйте команду:
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
Она будет успешна, только если все существующие значения в столбце могут быть неявно приве-
дены к новому типу. Если требуется более сложное преобразование, вы можете добавить указание
USING, определяющее, как получить новые значения из старых.
PostgreSQL попытается также преобразовать к новому типу значение столбца по умолчанию (ес-
ли оно определено) и все связанные с этим столбцом ограничения. Но преобразование может ока-
заться неправильным, и тогда вы получите неожиданные результаты. Поэтому обычно лучше уда-
лить все ограничения столбца, перед тем как менять его тип, а затем воссоздать модифицирован-
ные должным образом ограничения.
5.5.7. Переименование столбца
Чтобы переименовать столбец, выполните:
ALTER TABLE products RENAME COLUMN product_no TO product_number;
5.5.8. Переименование таблицы
Таблицу можно переименовать так:
ALTER TABLE products RENAME TO items;
5.6. Права
Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится
роль, с которой был выполнен оператор создания. Для большинства типов объектов в исходном со-
стоянии только владелец (или суперпользователь) может делать с объектом всё, что угодно. Чтобы
разрешить использовать его другим ролям, нужно дать им права.
Существует несколько типов прав: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER,
CREATE, CONNECT, TEMPORARY, EXECUTE и USAGE. Набор прав, применимых к определённому объекту,
60Определение данных
зависит от типа объекта (таблица, функция и т. д.) Полную информацию о различных типах прав,
поддерживаемых PostgreSQL, вы найдете на странице справки GRANT. Вы также увидите, как при-
меняются эти права, в следующих разделах и главах.
Неотъемлемое право изменять или удалять объект имеет только владелец объекта.
Объекту можно назначить нового владельца с помощью команды ALTER для соответствующего типа
объекта, например ALTER TABLE. Суперпользователь может делать это без ограничений, а обыч-
ный пользователь, только если он является одновременно текущим владельцем объекта (или чле-
ном роли владельца) и членом новой роли.
Для назначения прав применяется команда GRANT. Например, если в базе данных есть роль joe и
таблица accounts, право на изменение таблицы можно дать этой роли так:
GRANT UPDATE ON accounts TO joe;
Если вместо конкретного права написать ALL, роль получит все права, применимые для объекта
этого типа.
Для назначения права всем ролям в системе можно использовать специальное имя «роли»: PUBLIC.
Также для упрощения управления ролями, когда в базе данных есть множество пользователей,
можно настроить «групповые» роли; подробнее об этом см. Главу 21.
Чтобы лишить пользователей прав, используйте команду REVOKE:
REVOKE ALL ON accounts FROM PUBLIC;
Особые права владельца объекта (то есть права на выполнение DROP, GRANT, REVOKE и т. д.) всегда
неявно закреплены за владельцем и их нельзя назначить или отобрать. Но владелец объекта может
лишить себя обычных прав, например, разрешить всем, включая себя, только чтение таблицы.
Обычно распоряжаться правами может только владелец объекта (или суперпользователь). Однако
возможно дать право доступа к объекту «с правом передачи», что позволит получившему такое
право назначать его другим. Если такое право передачи впоследствии будет отозвано, то все, кто
получил данное право доступа (непосредственно или по цепочке передачи), потеряют его. Подроб-
нее об этом см. справку GRANT и REVOKE.
5.7. Политики защиты строк
В дополнение к стандартной системе прав SQL, управляемой командой GRANT, на уровне таблиц
можно определить политики защиты строк, ограничивающие для пользователей наборы строк,
которые могут быть возвращены обычными запросами или добавлены, изменены и удалены коман-
дами, изменяющими данные. Это называется также защитой на уровне строк (RLS, Row-Level
Security). По умолчанию таблицы не имеют политик, так что если система прав SQL разрешает
пользователю доступ к таблице, все строки в ней одинаково доступны для чтения или изменения.
Когда для таблицы включается защита строк (с помощью команды ALTER TABLE … ENABLE ROW
LEVEL SECURITY), все обычные запросы к таблице на выборку или модификацию строк должны
разрешаться политикой защиты строк. (Однако на владельца таблицы такие политики обычно не
действуют.) Если политика для таблицы не определена, применяется политика запрета по умол-
чанию, так что никакие строки в этой таблице нельзя увидеть или модифицировать. На операции
с таблицей в целом, такие как TRUNCATE и REFERENCES, защита строк не распространяется.
Политики защиты строк могут применяться к определённым командам и/или ролям. Политику
можно определить как применяемую к командам ALL (всем), либо SELECT, INSERT, UPDATE и DELETE.
Кроме того, политику можно связать с несколькими ролями, при этом действуют обычные правила
членства и наследования.
Чтобы определить, какие строки будут видимыми или могут изменяться в таблице, для политики
задаётся выражение, возвращающее логический результат. Это выражение будет вычисляться для
каждой строки перед другими условиями или функциями, поступающими из запроса пользовате-
ля. (Единственным исключением из этого правила являются герметичные функции, которые гаран-
61Определение данных
тированно не допускают утечки информации; оптимизатор может решить выполнить эти функции
до проверок защиты строк.) Строки, для которых это выражение возвращает не true, обрабаты-
ваться не будут. Чтобы независимо управлять набором строк, которые можно видеть, и набором
строк, которые можно модифицировать, в политике можно задать отдельные выражения. Выраже-
ния политик обрабатываются в составе запроса с правами исполняющего его пользователя, но для
обращения к данным, недоступным этому пользователю, в этих выражениях могут применяться
функции, определяющие контекст безопасности.
Суперпользователи и роли с атрибутом BYPASSRLS всегда обращаются к таблице, минуя систему
защиты строк. На владельца таблицы защита строк тоже не действует, хотя он может включить её
для себя принудительно, выполнив команду ALTER TABLE … FORCE ROW LEVEL SECURITY.
Неотъемлемое право включать или отключать защиту строк, а также определять политики для
таблицы, имеет только её владелец.
Для создания политик предназначена команда CREATE POLICY, для изменения — ALTER POLICY,
а для удаления — DROP POLICY. Чтобы включить или отключить защиту строк для определённой
таблицы, воспользуйтесь командой ALTER TABLE.
Каждой политике назначается имя, при этом для одной таблицы можно определить несколько
политик. Так как политики привязаны к таблицам, каждая политика для таблицы должна иметь
уникальное имя. В разных таблицах политики могут иметь одинаковые имена.
Когда к определённому запросу применяются несколько политик, они объединяются либо логиче-
ским сложением (если политики разрешительные (по умолчанию)), либо умножением (если поли-
тики ограничительные). Это подобно тому, как некоторая роль получает права всех ролей, в кото-
рые она включена. Разрешительные и ограничительные политики рассматриваются ниже.
В качестве простого примера, создать политику для отношения account, позволяющую только чле-
нам роли managers обращаться к строкам отношения и при этом только к своим, можно так:
CREATE TABLE accounts (manager text, company text, contact_email text);
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
CREATE POLICY account_managers ON accounts TO managers
USING (manager = current_user);
Эта политика неявно подразумевает и предложение WITH CHECK, идентичное предложению USING,
поэтому указанное ограничение применяется и к строкам, выбираемым командой (так что один
менеджер не может выполнить SELECT, UPDATE или DELETE для существующих строк, принадлежа-
щих другому), и к строкам, изменяемым командой (так что командами INSERT и UPDATE нельзя со-
здать строки, принадлежащие другому менеджеру).
Если роль не задана, либо задано специальное имя пользователя PUBLIC, политика применяется
ко всем пользователям в данной системе. Чтобы все пользователи могли обратиться только к соб-
ственной строке в таблице users, можно применить простую политику:
CREATE POLICY user_policy ON users
USING (user_name = current_user);
Это работает подобно предыдущему примеру.
Чтобы определить для строк, добавляемых в таблицу, отдельную политику, отличную от политики,
ограничивающей видимые строки, можно скомбинировать несколько политик. Следующая пара
политик позволит всем пользователям видеть все строки в таблице users, но изменять только свою
собственную:
CREATE POLICY user_sel_policy ON users
FOR SELECT
USING (true);
62Определение данных
CREATE POLICY user_mod_policy ON users
USING (user_name = current_user);
Для команды SELECT эти две политики объединяются операцией OR, так что в итоге это позволяет
выбирать все строки. Для команд других типов применяется только вторая политика, и эффект тот
же, что и раньше.
Защиту строк можно отключить так же командой ALTER TABLE. При отключении защиты, политики,
определённые для таблицы, не удаляются, а просто игнорируются. В результате в таблице будут
видны и могут модифицироваться все строки, с учётом ограничений стандартной системы прав
SQL.
Ниже показан развёрнутый пример того, как этот механизм защиты можно применять в производ-
ственной среде. Таблица passwd имитирует файл паролей в Unix:
– Простой пример на базе файла passwd
CREATE TABLE passwd (
user_name
text UNIQUE NOT NULL,
pwhash
text,
uid
int PRIMARY KEY,
gid
int NOT NULL,
real_name
text NOT NULL,
home_phone
text,
extra_info
text,
home_dir
text NOT NULL,
shell
text NOT NULL
);
CREATE ROLE admin;
CREATE ROLE bob;
CREATE ROLE alice;
– Администратор
– Обычный пользователь
– Обычный пользователь
– Наполнение таблицы
INSERT INTO passwd VALUES
(‘admin’,’xxx’,0,0,’Admin’,’111-222-3333’,null,’/root’,’/bin/dash’);
INSERT INTO passwd VALUES
(‘bob’,’xxx’,1,1,’Bob’,’123-456-7890’,null,’/home/bob’,’/bin/zsh’);
INSERT INTO passwd VALUES
(‘alice’,’xxx’,2,1,’Alice’,’098-765-4321’,null,’/home/alice’,’/bin/zsh’);
– Необходимо включить для этой таблицы защиту на уровне строк
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
– Создание политик
– Администратор может видеть и добавлять любые строки
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
– Обычные пользователи могут видеть все строки
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
– Обычные пользователи могут изменять собственные данные, но
– не могут задать произвольную оболочку входа
CREATE POLICY user_mod ON passwd FOR UPDATE
USING (current_user = user_name)
WITH CHECK (
current_user = user_name AND
shell IN (‘/bin/bash’,’/bin/sh’,’/bin/dash’,’/bin/zsh’,’/bin/tcsh’)
);
– Администраторы получают все обычные права
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
63Определение данных
– Пользователям разрешается чтение только общедоступных столбцов
GRANT SELECT
(user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
ON passwd TO public;
– Пользователям разрешается изменение определённых столбцов
GRANT UPDATE
(pwhash, real_name, home_phone, extra_info, shell)
ON passwd TO public;
Как и любые средства защиты, важно проверить политики, и убедиться в том, что они работают
ожидаемым образом. Применительно к предыдущему примеру, эти команды показывают, что си-
стема разрешений работает корректно.
– Администратор может видеть все строки и поля
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir
|
shell
———–+——–+—–+—–+———–+————–+————+————-
+———–
admin
| xxx
|
0 |
0 | Admin
| 111-222-3333 |
| /root
| /bin/dash
bob
| xxx
|
1 |
1 | Bob
| 123-456-7890 |
| /home/bob
| /bin/zsh
alice
| xxx
|
2 |
1 | Alice
| 098-765-4321 |
| /home/alice
| /bin/zsh
(3 rows)
– Проверим, что может делать Алиса
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR: permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
user_name | real_name | home_phone | extra_info | home_dir
|
shell
———–+———–+————–+————+————-+———–
admin
| Admin
| 111-222-3333 |
| /root
| /bin/dash
bob
| Bob
| 123-456-7890 |
| /home/bob
| /bin/zsh
alice
| Alice
| 098-765-4321 |
| /home/alice | /bin/zsh
(3 rows)
postgres=&gt; update passwd set user_name = ‘joe’;
ERROR: permission denied for relation passwd
– Алиса может изменить своё имя (поле real_name), но не имя кого-либо другого
postgres=&gt; update passwd set real_name = ‘Alice Doe’;
UPDATE 1
postgres=&gt; update passwd set real_name = ‘John Doe’ where user_name = ‘admin’;
UPDATE 0
postgres=&gt; update passwd set shell = ‘/bin/xx’;
ERROR: new row violates WITH CHECK OPTION for “passwd”
postgres=&gt; delete from passwd;
ERROR: permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values (‘xxx’);
ERROR: permission denied for relation passwd
– Алиса может изменить собственный пароль; попытки поменять другие пароли RLS просто
игнорирует
postgres=&gt; update passwd set pwhash = ‘abc’;
UPDATE 1
64Определение данных
Все политики, создаваемые до этого, были разрешительными, что значит, что при применении
нескольких политик они объединялись логическим оператором «ИЛИ». Хотя можно создать такие
разрешительные политики, которые будут только разрешать доступ к строкам при определённых
условиях, может быть проще скомбинировать разрешительные политики с ограничительными (ко-
торым должны удовлетворять записи и которые объединяются логическим оператором «И»). В
развитие предыдущего примера мы добавим ограничительную политику, разрешающую админи-
стратору, подключённому через локальный сокет Unix, обращаться к записям таблицы passwd:
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
USING (pg_catalog.inet_client_addr() IS NULL);
Затем мы можем убедиться, что администратор, подключённый по сети, не увидит никаких запи-
сей, благодаря этой ограничительной политике:
=&gt; SELECT current_user;
current_user
————–
admin
(1 row)
=&gt; select inet_client_addr();
inet_client_addr
——————
127.0.0.1
(1 row)
=&gt; SELECT current_user;
current_user
————–
admin
(1 row)
=&gt; TABLE passwd;
user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir |
shell
———–+——–+—–+—–+———–+————+————+———-
+——-
(0 rows)
=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
На проверки ссылочной целостности, например, на ограничения уникальности и внешние ключи,
защита строк никогда не распространяется, чтобы не нарушалась целостность данных. Поэтому
организацию и политики защиты на уровне строк необходимо тщательно прорабатывать, чтобы не
возникли «скрытые каналы» утечки информации через эти проверки.
В некоторых случаях важно, чтобы защита на уровне строк, наоборот, не действовала. Например,
резервное копирование может оказаться провальным, если механизм защиты на уровне строк мол-
ча не даст скопировать какие-либо строки. В таком случае вы можете установить для параметра
конфигурации row_security значение off. Это само по себе не отключит защиту строк; при этом
просто будет выдана ошибка, если результаты запроса отфильтруются политикой, с тем чтобы
можно было изучить причину ошибки и устранить её.
В приведённых выше примерах выражения политики учитывали только текущие значения в за-
прашиваемой или изменяемой строке. Это самый простой и наиболее эффективный по скорости
вариант; по возможности реализацию защиты строк следует проектировать именно так. Если же
для принятия решения о доступе необходимо обращаться к другим строкам или другим таблицам,
это можно осуществить, применяя в выражениях политик вложенные SELECT или функции, содер-
жащие SELECT. Однако учтите, что при такой реализации возможны условия гонки, что чревато
65Определение данных
утечкой информации, если не принять меры предосторожности. Например, рассмотрим следую-
щую конструкцию таблиц:
– определение групп привилегий
CREATE TABLE groups (group_id int PRIMARY KEY,
group_name text NOT NULL);
INSERT INTO groups VALUES
(1, ‘low’),
(2, ‘medium’),
(5, ‘high’);
GRANT ALL ON groups TO alice; – alice является администратором
GRANT SELECT ON groups TO public;
– определение уровней привилегий для пользователей
CREATE TABLE users (user_name text PRIMARY KEY,
group_id int NOT NULL REFERENCES groups);
INSERT INTO users VALUES
(‘alice’, 5),
(‘bob’, 2),
(‘mallory’, 2);
GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;
– таблица, содержащая защищаемую информацию
CREATE TABLE information (info text,
group_id int NOT NULL REFERENCES groups);
INSERT INTO information VALUES
(‘barely secret’, 1),
(‘slightly secret’, 2),
(‘very secret’, 5);
ALTER TABLE information ENABLE ROW LEVEL SECURITY;
– строка должна быть доступна для чтения/изменения пользователям с group_id,
– большим или равным group_id данной строки
CREATE POLICY fp_s ON information FOR SELECT
USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
– мы защищаем таблицу с информацией, полагаясь только на RLS
GRANT ALL ON information TO public;
Теперь предположим, что Алиса (роль alice) желает записать «слегка секретную» информацию,
но при этом не хочет давать mallory доступ к ней. Она делает следующее:
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = ‘mallory’;
UPDATE information SET info = ‘secret from mallory’ WHERE group_id = 2;
COMMIT;
На первый взгляд всё нормально; mallory ни при каких условиях не должна увидеть строку «secret
from mallory». Однако здесь возможно условие гонки. Если Мэллори (роль mallory) параллельно
выполняет, скажем:
66Определение данных
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
и её транзакция в режиме READ COMMITTED, она сможет увидеть «secret from mallory». Это произой-
дёт, если её транзакция дойдёт до строки information сразу после того, как эту строку изменит
Алиса (роль alice). Она заблокируется, ожидая фиксирования транзакции Алисы, а затем прочи-
тает изменённое содержимое строки благодаря предложению FOR UPDATE. Однако при этом из-
менённое содержимое users не будет прочитано неявным запросом SELECT, так как этот вложен-
ный SELECT выполняется без указания FOR UPDATE; вместо этого строка users читается из снимка,
полученного в начале запроса. Таким образом, выражение политики проверяет старое значение
уровня привилегий пользователя mallory и позволяет ей видеть изменённую строку.
Обойти эту проблему можно несколькими способами. Первое простое решение заключается в ис-
пользовании SELECT … FOR SHARE во вложенных запросах SELECT в политиках защиты строк.
Однако для этого потребуется давать затронутым пользователям право UPDATE в целевой таблице
(здесь users), что может быть нежелательно. (Хотя можно применить ещё одну политику защиты
строк, чтобы они не могли практически воспользоваться этим правилом; либо поместить вложен-
ный SELECT в функцию, определяющую контекст безопасности.) Кроме этого, активное использо-
вание блокировок строк в целевой таблице может повлечь проблемы с производительностью, осо-
бенно при частых изменениях. Другое решение, практичное, если целевая таблица изменяется
нечасто, заключается в исключительной блокировке целевой таблицы при изменении, чтобы ни-
какие параллельные транзакции не видели старые значения строк. Либо можно просто дождаться
завершения всех параллельных транзакций после изменения в целевой таблице, прежде чем вно-
сить изменения, рассчитанные на новые условия безопасности.
За дополнительными подробностями обратитесь к CREATE POLICY и ALTER TABLE.
5.8. Схемы
Кластер баз данных PostgreSQL содержит один или несколько именованных экземпляров баз. На
уровне кластера создаются пользователи и группы, но данные могут относиться только к базам
данных. При этом в рамках одного подключения к серверу можно обращаться к данным только
одной базы данных, указанной при установлении соединения.
Примечание
Пользователи кластера не обязательно будут иметь доступ ко всем базам данных этого
кластера. То, что пользователи создаются на уровне кластера, означает только, что в
нём не может быть двух пользователей joe в разных базах данных, хотя система поз-
воляет ограничить доступ joe только некоторыми базами данных.
База данных содержит одну или несколько именованных схем, которые в свою очередь содержат
таблицы. Схемы также содержат именованные объекты других видов, включая типы данных, функ-
ции и операторы. Одно и то же имя объекта можно свободно использовать в разных схемах, напри-
мер и schema1, и myschema могут содержать таблицы с именем mytable. В отличие от баз данных,
схемы не ограничивают доступ к данным: пользователи могут обращаться к объектам в любой схе-
ме текущей базы данных, если им назначены соответствующие права.
Есть несколько возможных объяснений, для чего стоит применять схемы:
• Чтобы одну базу данных могли использовать несколько пользователей, независимо друг от
друга.
• Чтобы объединить объекты базы данных в логические группы для облегчения управления
ими.
• Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов
имён.
Схемы в некоторым смысле подобны каталогам в операционной системе, но они не могут быть
вложенными.
67Определение данных
5.8.1. Создание схемы
Для создания схемы используется команда CREATE SCHEMA. При этом вы определяете имя схемы
по своему выбору, например так:
CREATE SCHEMA myschema;
Чтобы создать объекты в схеме или обратиться к ним, указывайте полное имя, состоящее из имён
схемы и объекта, разделённых точкой:
схема.таблица
Этот синтаксис работает везде, где ожидается имя таблицы, включая команды модификации таб-
лицы и команды обработки данных, обсуждаемые в следующих главах. (Для краткости мы будем
говорить только о таблицах, но всё это распространяется и на другие типы именованных объектов,
например, типы и функции.)
Есть ещё более общий синтаксис
база_данных.схема.таблица
но в настоящее время он поддерживается только для формального соответствия стандарту SQL.
Если вы указываете базу данных, это может быть только база данных, к которой вы подключены.
Таким образом, создать таблицу в новой схеме можно так:
CREATE TABLE myschema.mytable (
…
);
Чтобы удалить пустую схему (не содержащую объектов), выполните:
DROP SCHEMA myschema;
Удалить схему со всеми содержащимися в ней объектами можно так:
DROP SCHEMA myschema CASCADE;
Стоящий за этим общий механизм описан в Разделе 5.13.
Часто бывает нужно создать схему, владельцем которой будет другой пользователь (это один из
способов ограничения пользователей пространствами имён). Сделать это можно так:
CREATE SCHEMA имя_схемы AUTHORIZATION имя_пользователя;
Вы даже можете опустить имя схемы, в этом случае именем схемы станет имя пользователя. Как
это можно применять, описано в Подразделе 5.8.6.
Схемы с именами, начинающимися с pg_, являются системными; пользователям не разрешено
использовать такие имена.
5.8.2. Схема public
До этого мы создавали таблицы, не указывая никакие имена схем. По умолчанию такие таблицы
(и другие объекты) автоматически помещаются в схему «public». Она содержится во всех создава-
емых базах данных. Таким образом, команда:
CREATE TABLE products ( … );
эквивалентна:
CREATE TABLE public.products ( … );
5.8.3. Путь поиска схемы
Везде писать полные имена утомительно, и часто всё равно лучше не привязывать приложения
к конкретной схеме. Поэтому к таблицам обычно обращаются по неполному имени, состоящему
просто из имени таблицы. Система определяет, какая именно таблица подразумевается, исполь-
68Определение данных
зуя путь поиска, который представляет собой список просматриваемых схем. Подразумеваемой
таблицей считается первая подходящая таблица, найденная в схемах пути. Если подходящая таб-
лица не найдена, возникает ошибка, даже если таблица с таким именем есть в других схемах базы
данных.
Возможность создавать одноимённые объекты в разных схемах усложняет написание запросов,
которые должны всегда обращаться к конкретным объектам. Это также потенциально позволяет
пользователям влиять на поведение запросов других пользователей, злонамеренно или случайно.
Ввиду преобладания неполных имён в запросах и их использования внутри PostgreSQL, добавить
схему в search_path — по сути значит доверять всем пользователям, имеющим право CREATE в
этой схеме. Когда вы выполняете обычный запрос, злонамеренный пользователь может создать
объекты в схеме, включённой в ваш путь поиска, и таким образом перехватывать управление и
выполнять произвольные функции SQL как если бы их выполняли вы.
Первая схема в пути поиска называется текущей. Эта схема будет использоваться не только при
поиске, но и при создании объектов — она будет включать таблицы, созданные командой CREATE
TABLE без указания схемы.
Чтобы узнать текущий тип поиска, выполните следующую команду:
SHOW search_path;
В конфигурации по умолчанию она возвращает:
search_path
————–
“$user”, public
Первый элемент ссылается на схему с именем текущего пользователя. Если такой схемы не суще-
ствует, ссылка на неё игнорируется. Второй элемент ссылается на схему public, которую мы уже
видели.
Первая существующая схема в пути поиска также считается схемой по умолчанию для новых объ-
ектов. Именно поэтому по умолчанию объекты создаются в схеме public. При указании неполной
ссылки на объект в любом контексте (при модификации таблиц, изменении данных или в запросах)
система просматривает путь поиска, пока не найдёт соответствующий объект. Таким образом, в
конфигурации по умолчанию неполные имена могут относиться только к объектам в схеме public.
Чтобы добавить в путь нашу новую схему, мы выполняем:
SET search_path TO myschema,public;
(Мы опускаем компонент $user, так как здесь в нём нет необходимости.) Теперь мы можем обра-
щаться к таблице без указания схемы:
DROP TABLE mytable;
И так как myschema — первый элемент в пути, новые объекты будут по умолчанию создаваться в
этой схеме.
Мы можем также написать:
SET search_path TO myschema;
Тогда мы больше не сможем обращаться к схеме public, не написав полное имя объекта. Един-
ственное, что отличает схему public от других, это то, что она существует по умолчанию, хотя её
так же можно удалить.
В Разделе 9.25 вы узнаете, как ещё можно манипулировать путём поиска схем.
Как и для имён таблиц, путь поиска аналогично работает для имён типов данных, имён функций
и имён операторов. Имена типов данных и функций можно записать в полном виде так же, как
и имена таблиц. Если же вам нужно использовать в выражении полное имя оператора, для этого
есть специальный способ — вы должны написать:
69Определение данных
OPERATOR(схема.оператор)
Такая запись необходима для избежания синтаксической неоднозначности. Пример такого выра-
жения:
SELECT 3 OPERATOR(pg_catalog.+) 4;
На практике пользователи часто полагаются на путь поиска, чтобы не приходилось писать такие
замысловатые конструкции.
5.8.4. Схемы и права
По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить
это, владелец схемы должен дать пользователю право USAGE для данной схемы. Чтобы пользовате-
ли могли использовать объекты схемы, может понадобиться назначить дополнительные права на
уровне объектов.
Пользователю также можно разрешить создавать объекты в схеме, не принадлежащей ему. Для
этого ему нужно дать право CREATE в требуемой схеме. Заметьте, что по умолчанию все имеют
права CREATE и USAGE в схеме public. Благодаря этому все пользователи могут подключаться к
заданной базе данных и создавать объекты в её схеме public. Некоторые шаблоны использования
требуют запретить это:
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
(Первое слово «public» обозначает схему, а второе означает «каждый пользователь». В первом слу-
чае это идентификатор, а во втором — ключевое слово, поэтому они написаны в разном регистре;
вспомните указания из Подраздела 4.1.1.)
5.8.5. Схема системного каталога
В дополнение к схеме public и схемам, создаваемым пользователями, любая база данных содер-
жит схему pg_catalog, в которой находятся системные таблицы и все встроенные типы данных,
функции и операторы. pg_catalog фактически всегда является частью пути поиска. Если даже эта
схема не добавлена в путь явно, она неявно просматривается до всех схем, указанных в пути. Так
обеспечивается доступность встроенных имён при любых условиях. Однако вы можете явным об-
разом поместить pg_catalog в конец пути поиска, если вам нужно, чтобы пользовательские имена
переопределяли встроенные.
Так как имена системных таблиц начинаются с pg_, такие имена лучше не использовать во избе-
жание конфликта имён, возможного при появлении в будущем системной таблицы с тем же име-
нем, что и ваша. (С путём поиска по умолчанию неполная ссылка будет воспринята как обращение
к системной таблице.) Системные таблицы будут и дальше содержать в имени приставку pg_, так
что они не будут конфликтовать с неполными именами пользовательских таблиц, если пользова-
тели со своей стороны не будут использовать приставку pg_.
5.8.6. Шаблоны использования
Схемам можно найти множество применений. Хотя есть несколько шаблонов использования, легко
поддерживаемых стандартной конфигурацией, только один из них достаточно безопасен, когда
одни пользователи базы данных не доверяют другим:
• Ограничить обычных пользователей личными схемами. Для реализации этого подхода выпол-
ните REVOKE CREATE ON SCHEMA public FROM PUBLIC и создайте для каждого пользователя схе-
му с его именем. Если затрагиваемые пользователи подключались к базе ранее, проведите
аудит схемы на предмет наличия таких же имён, как в схеме pg_catalog. Вспомните, что путь
поиска по умолчанию начинается со значения $user, которое разрешается в имя пользовате-
ля. Таким образом, если у всех пользователей будет отдельная схема, они по умолчанию будут
обращаться к собственным схемам.
• Удалить схему public из пути поиска по умолчанию для каждого пользователя с помощью ко-
манды ALTER ROLE пользователь SET search_path = “$user”. Все сохранят возможность со-
здавать объекты в общедоступной схеме, но обращаться к ним будут только по полным име-
70Определение данных
нам. Хотя обращение к таблицам по полным именам вполне безопасно, вызовы функций в схе-
ме public будут небезопасными или ненадёжными. Кроме того, пользователь, имеющий пра-
во CREATEROLE, может отменить это назначение и выполнять произвольные запросы от имени
пользователей, полагающихся на этот путь. Если вы создаёте функции или расширения в схе-
ме public или даёте пользователям право CREATEROLE, но не хотите, чтобы они стали практиче-
ски суперпользователями, вам нужно использовать первый шаблон.
• Удалить схему public из пути поиска search_path в postgresql.conf. Это будет иметь такое
же влияние на пользователей, что и предыдущий шаблон. В дополнение к его особенностям
относительно функций и права CREATEROLE, данный шаблон подразумевает также доверие к
владельцам базам данных, как к имеющим право CREATEROLE. Если вы создаёте функции или
расширения в схеме public, даёте пользователям права CREATEROLE, CREATEDB или делаете их
владельцами отдельных баз данных, но не хотите, чтобы они стали практически суперпользо-
вателями, вам нужно использовать первый шаблон.
• Сохранить поведение по умолчанию. Все пользователи неявно обращаются к схеме public. Тем
самым имитируется ситуация с полным отсутствием схем, что позволяет осуществить плав-
ный переход из среды без схем. Однако при этом любой пользователь может выполнять произ-
вольные запросы от имени любого пользователя, который не позаботится о своей защите спе-
циально. Этот шаблон подходит, только если в базе данных имеется всего один или несколько
взаимно доверяющих пользователей.
При любом подходе, устанавливая совместно используемые приложения (таблицы, которые нужны
всем, дополнительные функции сторонних разработчиков и т. д.), помещайте их в отдельные схемы.
Не забудьте дать другим пользователям права для доступа к этим схемам. Тогда пользователи
смогут обращаться к этим дополнительным объектам по полному имени или при желании добавят
эти схемы в свои пути поиска.
5.8.7. Переносимость
Стандарт SQL не поддерживает обращение в одной схеме к разным объектам, принадлежащим
разным пользователям. Более того, в ряде реализаций СУБД нельзя создавать схемы с именем, от-
личным от имени владельца. На практике, в СУБД, реализующих только базовую поддержку схем
согласно стандарту, концепции пользователя и схемы очень близки. Таким образом, многие поль-
зователи полагают, что полное имя на самом деле образуется как имя_пользователя.имя_таблицы.
И именно так будет вести себя PostgreSQL, если вы создадите схемы для каждого пользователя.
В стандарте SQL нет и понятия схемы public. Для максимального соответствия стандарту исполь-
зовать схему public не следует.
Конечно, есть СУБД, в которых вообще не реализованы схемы или пространства имён поддержива-
ют (возможно, с ограничениями) обращения к другим базам данных. Если вам потребуется рабо-
тать с этими системами, максимальной переносимости вы достигнете, вообще не используя схемы.
5.9. Наследование
PostgreSQL реализует наследование таблиц, что может быть полезно для проектировщиков баз
данных. (Стандарт SQL:1999 и более поздние версии определяют возможность наследования ти-
пов, но это во многом отличается от того, что описано здесь.)
Давайте начнём со следующего примера: предположим, что мы создаём модель данных для горо-
дов. В каждом штате есть множество городов, но лишь одна столица. Мы хотим иметь возможность
быстро получать город-столицу для любого штата. Это можно сделать, создав две таблицы: одну
для столиц штатов, а другую для городов, не являющихся столицами. Однако, что делать, если нам
нужно получить информацию о любом городе, будь то столица штата или нет? В решении этой
проблемы может помочь наследование. Мы определим таблицу capitals как наследника cities:
CREATE TABLE cities
name
population
altitude
(
text,
float,
int
– в футах
71Определение данных
);
CREATE TABLE capitals (
state
char(2)
) INHERITS (cities);
В этом случае таблица capitals наследует все столбцы своей родительской таблицы, cities. Сто-
лицы штатов также имеют дополнительный столбец state, в котором будет указан штат.
В PostgreSQL таблица может наследоваться от нуля или нескольких других таблиц, а запросы могут
выбирать все строки родительской таблицы или все строки родительской и всех дочерних таблиц.
По умолчанию принят последний вариант. Например, следующий запрос найдёт названия всех
городов, включая столицы штатов, расположенных выше 500 футов:
SELECT name, altitude
FROM cities
WHERE altitude &gt; 500;
Для данных из введения (см. Раздел 2.1) он выдаст:
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Madison
|
845
А следующий запрос находит все города, которые не являются столицами штатов, но также нахо-
дятся на высоте выше 500 футов:
SELECT name, altitude
FROM ONLY cities
WHERE altitude &gt; 500;
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Здесь ключевое слово ONLY указывает, что запрос должен применяться только к таблице cities,
но не к таблицам, расположенным ниже cities в иерархии наследования. Многие операторы, ко-
торые мы уже обсудили, — SELECT, UPDATE и DELETE — поддерживают ключевое слово ONLY.
Вы также можете добавить после имени таблицы <em>, чтобы явно указать, что должны включаться
и дочерние таблицы:
SELECT name, altitude
FROM cities</em>
WHERE altitude &gt; 500;
Указывать * не обязательно, так как теперь это поведение всегда подразумевается по умолчанию.
Однако такая запись всё ещё поддерживается для совместимости со старыми версиями, где пове-
дение по умолчанию могло быть изменено.
В некоторых ситуациях бывает необходимо узнать, из какой таблицы выбрана конкретная строка.
Для этого вы можете воспользоваться системным столбцом tableoid, присутствующим в каждой
таблице:
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
этот запрос выдаст:
tableoid |
name
| altitude
72Определение данных
———-+———–+———-
139793 | Las Vegas |
2174
139793 | Mariposa |
1953
139798 | Madison
|
845
(Если вы попытаетесь выполнить его у себя, скорее всего вы получите другие значения OID.) Соб-
ственно имена таблиц вы можете получить, обратившись к pg_class:
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;
в результате вы получите:
relname |
name
| altitude
———-+———–+———-
cities
| Las Vegas |
2174
cities
| Mariposa |
1953
capitals | Madison
|
845
Тот же эффект можно получить другим способом, используя альтернативный тип regclass; при
этом OID таблицы выводится в символьном виде:
SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
Механизм наследования не способен автоматически распределять данные команд INSERT или COPY
по таблицам в иерархии наследования. Поэтому в нашем примере этот оператор INSERT не выпол-
нится:
INSERT INTO cities (name, population, altitude, state)
VALUES (‘Albany’, NULL, NULL, ‘NY’);
Мы могли надеяться на то, что данные каким-то образом попадут в таблицу capitals, но этого не
происходит: INSERT всегда вставляет данные непосредственно в указанную таблицу. В некоторых
случаях добавляемые данные можно перенаправлять, используя правила (см. Главу 41). Однако в
нашем случае это не поможет, так как таблица cities не содержит столбца state и команда будет
отвергнута до применения правила.
Дочерние таблицы автоматически наследуют от родительской таблицы ограничения-проверки и
ограничения NOT NULL (если только для них не задано явно NO INHERIT). Все остальные ограни-
чения (уникальности, первичный ключ и внешние ключи) не наследуются.
Таблица может наследоваться от нескольких родительских таблиц, в этом случае она будет объ-
единять в себе все столбцы этих таблиц, а также столбцы, описанные непосредственно в её опре-
делении. Если в определениях родительских и дочерней таблиц встретятся столбцы с одним име-
нем, эти столбцы будут «объединены», так что в дочерней таблице окажется только один столбец.
Чтобы такое объединение было возможно, столбцы должны иметь одинаковый тип данных, в про-
тивном случае произойдёт ошибка. Наследуемые ограничения-проверки и ограничения NOT NULL
объединяются подобным образом. Так, например, объединяемый столбец получит свойство NOT
NULL, если какое-либо из порождающих его определений имеет свойство NOT NULL. Ограниче-
ния-проверки объединяются, если они имеют одинаковые имена; но если их условия различаются,
происходит ошибка.
Отношение наследования между таблицами обычно устанавливается при создании дочерней таб-
лицы с использованием предложения INHERITS оператора CREATE TABLE. Другой способ добавить
такое отношение для таблицы, определённой подходящим образом — использовать INHERIT с опе-
ратором ALTER TABLE. Для этого будущая дочерняя таблица должна уже включать те же столбцы
(с совпадающими именами и типами), что и родительская таблица. Также она должна включать
аналогичные ограничения-проверки (с теми же именами и выражениями). Удалить отношение на-
следования можно с помощью указания NO INHERIT оператора ALTER TABLE. Динамическое добав-
73Определение данных
ление и удаление отношений наследования может быть полезно при реализации секционирования
таблиц (см. Раздел 5.10).
Для создания таблицы, которая затем может стать наследником другой, удобно воспользоваться
предложением LIKE оператора CREATE TABLE. Такая команда создаст новую таблицу с теми же
столбцами, что имеются в исходной. Если в исходной таблицы определены ограничения CHECK,
для создания полностью совместимой таблицы их тоже нужно скопировать, и это можно сделать,
добавив к предложению LIKE параметр INCLUDING CONSTRAINTS.
Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. При этом в дочер-
них таблицах нельзя удалять или модифицировать столбцы или ограничения-проверки, унаследо-
ванные от родительских таблиц. Если вы хотите удалить таблицу вместе со всеми её потомками,
это легко сделать, добавив в команду удаления родительской таблицы параметр CASCADE (см. Раз-
дел 5.13).
При изменениях определений и ограничений столбцов команда ALTER TABLE распространяет эти
изменения вниз в иерархии наследования. Однако удалить столбцы, унаследованные дочерними
таблицами, можно только с помощью параметра CASCADE. При создании отношений наследова-
ния команда ALTER TABLE следует тем же правилам объединения дублирующихся столбцов, что
и CREATE TABLE.
В запросах с наследуемыми таблицами проверка прав доступа выполняется только в родительской
таблице. Так, например, наличие разрешения UPDATE для таблицы cities подразумевает право на
изменение строк также в таблице capitals, когда к ним происходит обращение через таблицу
cities. Это сохраняет видимость того, что эти данные (также) находятся в родительской табли-
це. Но изменить таблицу capitals напрямую без дополнительного разрешения нельзя. Подобным
образом, политики безопасности на уровне строк (см. Раздел 5.7) для родительской таблицы при-
меняются к строкам, получаемым из дочерних таблиц при выполнении запроса с наследованием.
Политики же дочерних таблиц, если они определены, действуют только когда такие таблицы яв-
но задействуются в запросе; в этом случае все политики, связанные с родительскими таблицами,
игнорируются.
Сторонние таблицы (см. Раздел 5.11) могут также входить в иерархию наследования как родитель-
ские или дочерние таблицы, так же, как и обычные. Если в иерархию наследования входит сторон-
няя таблица, все операции, не поддерживаемые ей, не будут поддерживаться иерархией в целом.
5.9.1. Ограничения
Заметьте, что не все SQL-команды могут работать с иерархиями наследования. Команды, выпол-
няющие выборку данных, изменение данных или модификацию схемы (например SELECT, UPDATE,
DELETE, большинство вариантов ALTER TABLE, но не INSERT и ALTER TABLE … RENAME), обычно
по умолчанию обрабатывают данные дочерних таблиц и могут исключать их, если поддерживают
указание ONLY. Команды для обслуживания и настройки базы данных (например REINDEX и VACUUM)
обычно работают только с отдельными физическими таблицами и не поддерживают рекурсивную
обработку отношений наследования. Соответствующее поведение каждой команды описано в её
справке (Команды SQL).
Возможности наследования серьёзно ограничены тем, что индексы (включая ограничения уни-
кальности) и ограничения внешних ключей относятся только к отдельным таблицам, но не к их по-
томкам. Это касается обеих сторон ограничений внешних ключей. Таким образом, применительно
к нашему примеру:
• Если мы объявим cities.name с ограничением UNIQUE или PRIMARY KEY, это не помешает доба-
вить в таблицу capitals строки с названиями городов, уже существующими в таблице cities.
И эти дублирующиеся строки по умолчанию будут выводиться в результате запросов к cities.
На деле таблица capitals по умолчанию вообще не будет содержать ограничение уникально-
сти, так что в ней могут оказаться несколько строк с одним названием. Хотя вы можете доба-
вить в capitals соответствующее ограничение, но это не предотвратит дублирование при объ-
единении с cities.
74Определение данных
• Подобным образом, если мы укажем, что cities.name ссылается (REFERENCES) на какую-то дру-
гую таблицу, это ограничение не будет автоматически распространено на capitals. В этом
случае решением может стать явное добавление такого же ограничения REFERENCES в таблицу
capitals.
• Если вы сделаете, чтобы столбец другой таблицы ссылался на cities(name), в этом столбце
можно будет указывать только названия городов, но не столиц. В этом случае хорошего реше-
ния нет.
Возможно, в будущем эти недостатки будут исправлены, но в настоящее время вам следует тща-
тельно взвесить все за и против, прежде чем использовать наследование в своих приложениях.
5.10. Секционирование таблиц
PostgreSQL поддерживает простое секционирование таблиц. В этом разделе описывается, как и
почему бывает полезно применять секционирование при проектировании баз данных.
5.10.1. Обзор
Секционированием данных называется разбиение одной большой логической таблицы на несколь-
ко меньших физических секций. Секционирование может принести следующую пользу:
• В определённых ситуациях оно кардинально увеличивает быстродействие, особенно когда
большой процент часто запрашиваемых строк таблицы относится к одной или лишь несколь-
ким секциям. Секционирование может сыграть роль ведущих столбцов в индексах, что позво-
лит уменьшить размер индекса и увеличит вероятность нахождения наиболее востребованных
частей индексов в памяти.
• Когда в выборке или изменении данных задействована большая часть одной секции, последо-
вательное сканирование этой секции может выполняться гораздо быстрее, чем случайный до-
ступ по индексу к данным, разбросанным по всей таблице.
• Массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя секции, ес-
ли это было предусмотрено при проектировании секционированных таблиц. Операция ALTER
TABLE DETACH PARTITION или удаление отдельной секции с помощью команды DROP TABLE вы-
полняются гораздо быстрее, чем массовая обработка. Эти команды также полностью исклю-
чают накладные расходы, связанные с выполнением VACUUM после DELETE.
• Редко используемые данные можно перенести на более дешёвые и медленные носители.
Всё это обычно полезно только для очень больших таблиц. Какие именно таблицы выиграют от
секционирования, зависит от конкретного приложения, хотя, как правило, это следует применять
для таблиц, размер которых превышает объём ОЗУ сервера.
PostgreSQL предлагает поддержку следующих видов секционирования:
Секционирование по диапазонам
Таблица секционируется по «диапазонам», определённым по ключевому столбцу или набору
столбцов, и не пересекающимся друг с другом. Например, можно секционировать данные по
диапазонам дат или по диапазонам идентификаторов определённых бизнес-объектов.
Секционирование по списку
Таблица секционируется с помощью списка, явно указывающего, какие значения ключа долж-
ны относиться к каждой секции.
Секционирование по хешу
Таблица секционируется по определённым модулям и остаткам, которые указываются для каж-
дой секции. Каждая секция содержит строки, для которых хеш-значение ключа разбиения, де-
лённое на модуль, равняется заданному остатку.
Если вашему приложению требуются другие формы секционирования, можно также прибегнуть
к альтернативным реализациям, с использованием наследования и представлений с UNION ALL.
75Определение данных
Такие подходы дают гибкость, но не дают такого выигрыша в производительности, как встроенное
декларативное секционирование.
5.10.2. Декларативное секционирование
PostgreSQL предоставляет возможность указать, как разбить таблицу на части, называемые сек-
циями. Разделённая таким способом таблица называется секционированной таблицей. Указание
секционирования состоит из определения метода секционирования и списка столбцов или выра-
жений, которые будут составлять ключ разбиения.
Все строки, вставляемые в секционированную таблицу, будут направляться в одну из секций в
зависимости от значения ключа разбиения. В каждой секции содержится подмножество данных,
определяемое границами секции. В настоящее время поддерживается секционирование по диапа-
зонам, по списку и по хешу.
Сами секции могут представлять собой секционируемые таблицы, благодаря применению так на-
зываемого вложенного секционирования. В каждой секции могут быть определены свои индексы,
ограничения и значения по умолчанию, отличные от других секций. Подробнее о создании секци-
онированных таблиц и секций рассказывается в описании CREATE TABLE.
Преобразовать обычную таблицу в секционированную и наоборот нельзя. Однако в секциониро-
ванную таблицу можно добавить в качестве секции обычную или секционированную таблицу с
данными, а также можно удалить секцию из секционированной таблицы и превратить её в отдель-
ную таблицу; обратитесь к описанию ALTER TABLE, чтобы узнать больше о подкомандах ATTACH
PARTITION и DETACH PARTITION.
За кулисами отдельные секции связываются с секционируемой таблицей средствами наследова-
ния; однако с секционированными таблицами и секциями нельзя использовать некоторые общие
возможности наследования, описанные ниже. Например, секция не может иметь никаких других
родителей, кроме секционированной таблицы, к которой она присоединена, так же как обычная
таблица не может наследоваться от секционированной таблицы. Это означает, что секциониро-
ванные таблицы и их секции не совмещаются в иерархии наследования с обычными таблицами. Но
так как иерархия наследования, включающая секционированную таблицу и её секции, остаётся
иерархией наследования, на неё распространяются все обычные правила наследования, описан-
ные в Раздел 5.9, с некоторыми исключениями. А именно:
• Ограничения CHECK вместе с NOT NULL, определённые в секционированной таблице, всегда на-
следуются всеми её секциями. Ограничения CHECK с характеристикой NO INHERIT в секциони-
рованных таблицах создавать нельзя.
• Использование указания ONLY при добавлении или удалении ограничения только в секцио-
нированной таблице поддерживается лишь когда в ней нет секций. Если секции существуют,
при попытке использования ONLY возникнет ошибка, так как добавление или удаление ограни-
чений только в секционированной таблице при наличии секций не поддерживается. С другой
стороны, ограничения можно добавлять или удалять непосредственно в секциях (если они от-
сутствуют в родительской таблице).
• Так как секционированная таблица сама по себе не содержит данные, использование
TRUNCATE ONLY для секционированной таблицы всегда будет считаться ошибкой.
• В секциях не может быть столбцов, отсутствующих в родительской таблице. Такие столбцы
невозможно определить ни при создании секций командой CREATE TABLE, ни путём последую-
щего добавления в секции командой ALTER TABLE. Таблицы могут быть подключены в качестве
секций командой ALTER TABLE … ATTACH PARTITION, только если их столбцы в точности со-
ответствуют родительской таблице, включая столбец oid (если он есть).
• Ограничение NOT NULL для столбца в секции нельзя удалить, если это ограничение существу-
ет в родительской таблице.
Секции также могут быть сторонними таблицами, хотя при этом накладываются некоторые ограни-
чения, отсутствующие с обычными таблицами; за подробностями обратитесь к описанию CREATE
FOREIGN TABLE.
76Определение данных
Изменение ключа разбиения в строке может привести к перемещению её в другую секцию, огра-
ничению которой соответствует изменённая строка.
5.10.2.1. Пример
Предположим, что мы создаём базу данных для большой компании, торгующей мороженым. Ком-
пания учитывает максимальную температуру и продажи мороженого каждый день в разрезе ре-
гионов. По сути нам нужна следующая таблица:
CREATE TABLE measurement (
city_id
int not null,
logdate
date not null,
peaktemp
int,
unitsales
int
);
Мы знаем, что большинство запросов будут работать только с данными за последнюю неделю,
месяц или квартал, так как в основном эта таблица нужна для формирования текущих отчётов для
руководства. Чтобы сократить объём хранящихся старых данных, мы решили оставлять данные
только за 3 последних года. Ненужные данные мы будем удалять в начале каждого месяца. В этой
ситуации мы можем использовать секционирование для удовлетворения всех наших требований
к таблице показателей.
Чтобы использовать декларативное секционирование в этом случае, выполните следующее:</p>
<ol>
  <li>Создайте таблицу measurement как секционированную таблицу с предложением PARTITION BY,
указав метод разбиения (в нашем случае RANGE) и список столбцов, которые будут образовывать
ключ разбиения.
CREATE TABLE measurement (
city_id
int not null,
logdate
date not null,
peaktemp
int,
unitsales
int
) PARTITION BY RANGE (logdate);
При разбиении по диапазонам в качестве ключа разбиения при желании можно использовать
набор из нескольких столбцов. Конечно, при этом скорее всего увеличится количество секций, и
каждая из них будет меньше. И напротив, использование меньшего числа столбцов может при-
вести к менее дробному критерию разбиения с меньшим числом секций. Запрос, обращающийся
к секционированной таблице, будет сканировать меньше секций, если в условии поиска фигури-
руют некоторые или все эти столбцы. Например, в таблице, секционируемой по диапазонам, в
качестве ключа разбиения можно выбрать столбцы lastname и firstname (в таком порядке).</li>
  <li>Создайте секции. В определении каждой секции должны задаваться границы, соответствующие
методу и ключу разбиения родительской таблицы. Заметьте, что указание границ, при котором
множество значений новой секции пересекается со множеством значений в одной или несколь-
ких существующих секциях, будет ошибочным. При попытке добавления в родительскую табли-
цу данных, которые не соответствуют ни одной из существующей секций, произойдёт ошибка;
соответствующий раздел нужно добавлять вручную.
Секции, создаваемые таким образом, во всех отношениях являются обычными таблицами
PostgreSQL (или, возможно, сторонними таблицами). В частности, для каждой секции можно
независимо задать табличное пространство и параметры хранения.
Для таблиц-секций нет необходимости определять ограничения с условиями, задающими гра-
ницы значений. Нужные ограничения секций выводятся неявно из определения границ секции,
когда требуется к ним обратиться.
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
FOR VALUES FROM (‘2006-02-01’) TO (‘2006-03-01’);
CREATE TABLE measurement_y2006m03 PARTITION OF measurement
77Определение данных
FOR VALUES FROM (‘2006-03-01’) TO (‘2006-04-01’);
…
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
FOR VALUES FROM (‘2007-11-01’) TO (‘2007-12-01’);
CREATE TABLE measurement_y2007m12 PARTITION OF measurement
FOR VALUES FROM (‘2007-12-01’) TO (‘2008-01-01’)
TABLESPACE fasttablespace;
CREATE TABLE measurement_y2008m01 PARTITION OF measurement
FOR VALUES FROM (‘2008-01-01’) TO (‘2008-02-01’)
WITH (parallel_workers = 4)
TABLESPACE fasttablespace;
Для реализации вложенного секционирования укажите предложение PARTITION BY в командах,
создающих отдельные секции, например:
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
FOR VALUES FROM (‘2006-02-01’) TO (‘2006-03-01’)
PARTITION BY RANGE (peaktemp);
Когда будут созданы секции measurement_y2006m02, данные, добавляемые в measurement
и попадающие в measurement_y2006m02 (или данные, непосредственно добавляемые в
measurement_y2006m02, с учётом соответствия ограничению секции) будут затем перенаправле-
ны в одну из вложенных секций в зависимости от значения столбца peaktemp. Указанный ключ
разбиения может пересекаться с ключом разбиения родителя, хотя определять границы вло-
женной секции нужно осмотрительно, чтобы множество данных, которое она принимает, входи-
ло во множество, допускаемое собственными границами секции; система не пытается контро-
лировать это сама.</li>
  <li>Создайте в секционируемой таблице индекс по ключевому столбцу (или столбцам), а также лю-
бые другие индексы, которые могут понадобиться. (Индекс по ключу, строго говоря, создавать
не обязательно, но в большинстве случаев он будет полезен.) При этом будет автоматически
создан отдельный индекс в каждой секции, и все секции, которые вы будете создавать или при-
соединять позднее, тоже будут содержать такой индекс.
CREATE INDEX ON measurement (logdate);</li>
  <li>Убедитесь в том, что параметр конфигурации enable_partition_pruning не выключен в
postgresql.conf. Иначе запросы не будут оптимизироваться должным образом.
В данном примере нам потребуется создавать секцию каждый месяц, так что было бы разумно
написать скрипт, который бы формировал требуемый код DDL автоматически.
5.10.2.2. Обслуживание секций
Обычно набор секций, образованный изначально при создании таблиц, не предполагается сохра-
нять неизменным. Чаще наоборот, планируется удалять старые секции данных и периодически
добавлять новые. Одно из наиболее важных преимуществ секционирования состоит именно в том,
что оно позволяет практически моментально выполнять трудоёмкие операции, изменяя структуру
секций, а не физически перемещая большие объёмы данных.
Самый лёгкий способ удалить старые данные — просто удалить секцию, ставшую ненужной:
DROP TABLE measurement_y2006m02;
Так можно удалить миллионы записей гораздо быстрее, чем удалять их по одной. Заметьте, однако,
что приведённая выше команда требует установления блокировки ACCESS EXCLUSIVE.
Ещё один часто более предпочтительный вариант — убрать секцию из главной таблицы, но сохра-
нить возможность обращаться к ней как к самостоятельной таблице:
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
78Определение данных
При этом можно будет продолжать работать с данными, пока таблица не будет удалена. Например,
в этом состоянии очень кстати будет сделать резервную копию данных, используя COPY, pg_dump
или подобные средства. Возможно, эти данные также можно будет агрегировать, перевести в ком-
пактный формат, выполнить другую обработку или построить отчёты.
Аналогичным образом можно добавлять новую секцию с данными. Мы можем создать пустую сек-
цию в главной таблице так же, как мы создавали секции в исходном состоянии до этого:
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
FOR VALUES FROM (‘2008-02-01’) TO (‘2008-03-01’)
TABLESPACE fasttablespace;
А иногда удобнее создать новую таблицу вне структуры секций и сделать её полноценной секцией
позже. При таком подходе данные можно будет загрузить, проверить и преобразовать до того, как
они появятся в секционированной таблице:
CREATE TABLE measurement_y2008m02
(LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
TABLESPACE fasttablespace;
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
CHECK ( logdate &gt;= DATE ‘2008-02-01’ AND logdate &lt; DATE ‘2008-03-01’ );
\copy measurement_y2008m02 from ‘measurement_y2008m02’
– possibly some other data preparation work
ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
FOR VALUES FROM (‘2008-02-01’) TO (‘2008-03-01’ );
Прежде чем выполнять команду ATTACH PARTITION, рекомендуется создать ограничение CHECK в
присоединяемой таблице, описывающее желаемое ограничение секции. Благодаря этому система
сможет не сканировать таблицу для проверки выполнения неявного ограничения секции. Без этого
ограничения таблицу нужно будет просканировать и убедиться в выполнении ограничения секции,
удерживая блокировку ACCESS EXCLUSIVE в родительской таблице. После выполнения команды
ATTACH PARTITION это ограничение можно будет удалить за ненадобностью.
5.10.2.3. Ограничения
С секционированными таблицами связаны следующие ограничения:
• Нельзя создать ограничение-исключение, охватывающее все секции; можно только добавить
независимые ограничения в каждую отдельную секцию.
• Так как в секционированных таблицах первичные ключи не поддерживаются, на секциониро-
ванные таблицы не могут ссылаться внешние ключи. (Ссылки на внешние ключи других таб-
лиц из секционированных таблиц поддерживаются.)
• Когда в результате действия UPDATE строка должна переместиться из одной секции в другую,
есть вероятность, что другая параллельная команда UPDATE или DELETE пропустит эту стро-
ку. Например, предположим, что в сеансе 1 выполняется UPDATE для ключа секционирования,
а тем временем в параллельном сеансе 2, в котором эта строка видима, выполняется опера-
ция UPDATE или DELETE с этой строкой. Сеанс 2 может незаметно потерять эту строку, если
она будет удалена из секции вследствие действия в сеансе 1. В этом случае команды UPDATE
или DELETE в сессии 2, не зная о перемещении строки, считают, что строка была просто уда-
лена и ничего делать с ней не нужно. В обычном случае, когда таблица не секционирована
или когда строка не перемещается, в сеансе 2 была бы видна изменённая строка, и операция
UPDATE/DELETE выполнилась бы с новой версией строки.
• Триггеры BEFORE ROW при необходимости должны определяться в отдельных секциях, а не в
секционированной таблице.
• Смешивание временных и постоянных отношений в одном дереве секционирования не допус-
кается. Таким образом, если секционированная таблица постоянная, такими же должны быть
79Определение данных
её секции; с временными таблицами аналогично. В случае с временными отношениями все
таблицы дерева секционирования должны быть из одного сеанса.
5.10.3. Реализация с использованием наследования
Хотя встроенное декларативное секционирование полезно во многих часто возникающих ситуа-
циях, бывают обстоятельства, требующие более гибкого подхода. В этом случае секционирование
можно реализовать, применив механизм наследования таблиц, что даст ряд возможностей, непод-
держиваемых при декларативном секционировании, например:
• При декларативном секционировании все секции должны иметь в точности тот же набор
столбцов, что и секционируемая таблица, тогда как обычное наследование таблиц допускает
наличие в дочерних таблицах дополнительных столбцов, отсутствующих в родителе.
• Механизм наследования таблиц поддерживает множественное наследование.
• С декларативным секционированием поддерживается только разбиение по спискам, по диапа-
зонам и по хешу, тогда как с наследованием таблиц данные можно разделять по любому кри-
терию, выбранному пользователем. (Однако заметьте, что если исключение по ограничению
не позволяет эффективно устранять дочерние таблицы из планов запросов, производитель-
ность запросов будет очень низкой.)
• Для некоторых операций с декларативным секционированием требуется более сильная блоки-
ровка, чем с использованием наследования. Например, для добавления или удаления секций
из секционированной таблицы требуется установить блокировку ACCESS EXCLUSIVE в роди-
тельской таблице, тогда как в случае с обычным наследованием достаточно блокировки SHARE
UPDATE EXCLUSIVE.
5.10.3.1. Пример
Мы будем использовать ту же таблицу measurement, что и раньше. Чтобы реализовать секциони-
рование с использованием наследования, выполните следующие действия:</li>
  <li>Создайте «главную» таблицу, от которой будут наследоваться все «дочерние» таблицы. Главная
таблица не будет содержать данные. Не определяйте в ней никакие ограничения-проверки, ес-
ли только вы не намерены применить их во всех дочерних таблицах. Также не имеет смысла
определять в ней какие-либо индексы или ограничения уникальности. В нашем примере глав-
ной таблицей будет measurement со своим изначальным определением.</li>
  <li>Создайте несколько «дочерних» таблиц, унаследовав их все от главной. Обычно в таких таблицах
не будет никаких дополнительных столбцов, кроме унаследованных. Как и с декларативным сек-
ционированием, эти таблицы во всех отношениях будут обычными таблицами PostgreSQL (или
сторонними таблицами).
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
…
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);</li>
  <li>Добавьте в дочерние таблицы неперекрывающиеся ограничения, определяющие допустимые
значения ключей для каждой из них.
Типичные примеры таких ограничений:
CHECK ( x = 1 )
CHECK ( county IN ( ‘Oxfordshire’, ‘Buckinghamshire’, ‘Warwickshire’ ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
Убедитесь в том, что ограничения не пересекаются, то есть никакие значения ключа не относят-
ся сразу к нескольким дочерним таблицам. Например, часто допускают такую ошибку в опре-
делении диапазонов:
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
80Определение данных
Это не будет работать, так как неясно, к какой дочерней таблице должно относиться значение
200.
Дочерние таблицы лучше будет создать следующим образом:
CREATE TABLE measurement_y2006m02 (
CHECK ( logdate &gt;= DATE ‘2006-02-01’ AND logdate &lt; DATE ‘2006-03-01’ )
) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 (
CHECK ( logdate &gt;= DATE ‘2006-03-01’ AND logdate &lt; DATE ‘2006-04-01’ )
) INHERITS (measurement);
…
CREATE TABLE measurement_y2007m11 (
CHECK ( logdate &gt;= DATE ‘2007-11-01’ AND logdate &lt; DATE ‘2007-12-01’ )
) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 (
CHECK ( logdate &gt;= DATE ‘2007-12-01’ AND logdate &lt; DATE ‘2008-01-01’ )
) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 (
CHECK ( logdate &gt;= DATE ‘2008-01-01’ AND logdate &lt; DATE ‘2008-02-01’ )
) INHERITS (measurement);</li>
  <li>Для каждой дочерней таблицы создайте индекс по ключевому столбцу (или столбцам), а также
любые другие индексы по своему усмотрению.
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);</li>
  <li>Мы хотим, чтобы наше приложение могло сказать INSERT INTO measurement … и данные ока-
зались в соответствующей дочерней таблице. Мы можем добиться этого, добавив подходящую
триггерную функцию в главную таблицу. Если данные всегда будут добавляться только в послед-
нюю дочернюю таблицу, нам будет достаточно очень простой функции:
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS <script type="math/tex">BEGIN
INSERT INTO measurement_y2008m01 VALUES (NEW.*);
RETURN NULL;
END;</script>
LANGUAGE plpgsql;
Создав эту функцию, мы создадим вызывающий её триггер:
CREATE TRIGGER insert_measurement_trigger
BEFORE INSERT ON measurement
FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
Мы должны менять определение триггерной функции каждый месяц, чтобы она всегда указыва-
ла на текущую дочернюю таблицу. Определение самого триггера, однако, менять не требуется.
Но мы можем также сделать, чтобы сервер автоматически находил дочернюю таблицу, в кото-
рую нужно направить добавляемую строку. Для этого нам потребуется более сложная триггер-
ная функция:
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
81Определение данных
RETURNS TRIGGER AS <script type="math/tex">% <![CDATA[
BEGIN
IF ( NEW.logdate >= DATE '2006-02-01' AND
NEW.logdate < DATE '2006-03-01' ) THEN
INSERT INTO measurement_y2006m02 VALUES (NEW.*);
ELSIF ( NEW.logdate >= DATE '2006-03-01' AND
NEW.logdate < DATE '2006-04-01' ) THEN
INSERT INTO measurement_y2006m03 VALUES (NEW.*);
...
ELSIF ( NEW.logdate >= DATE '2008-01-01' AND
NEW.logdate < DATE '2008-02-01' ) THEN
INSERT INTO measurement_y2008m01 VALUES (NEW.*);
ELSE
RAISE EXCEPTION
'Date out of range. Fix the measurement_insert_trigger() function!';
END IF;
RETURN NULL;
END; %]]></script>
LANGUAGE plpgsql;
Определение триггера остаётся прежним. Заметьте, что все условия IF должны в точности от-
ражать ограничения CHECK соответствующих дочерних таблиц.
Хотя эта функция сложнее, чем вариант с одним текущим месяцем, её не придётся так часто
модифицировать, так как ветви условий можно добавить заранее.
Примечание
На практике будет лучше сначала проверять условие для последней дочерней таб-
лицы, если строки добавляются в неё чаще всего, но для простоты мы расположи-
ли проверки триггера в том же порядке, как и в других фрагментах кода для этого
примера.
Другой способ перенаправления добавляемых строк в соответствующую дочернюю таблицу
можно реализовать, определив для главной таблицы не триггер, а правила. Например:
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
( logdate &gt;= DATE ‘2006-02-01’ AND logdate &lt; DATE ‘2006-03-01’ )
DO INSTEAD
INSERT INTO measurement_y2006m02 VALUES (NEW.<em>);
…
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
( logdate &gt;= DATE ‘2008-01-01’ AND logdate &lt; DATE ‘2008-02-01’ )
DO INSTEAD
INSERT INTO measurement_y2008m01 VALUES (NEW.</em>);
С правилами связано гораздо больше накладных расходов, чем с триггером, но они относятся к
запросу в целом, а не к каждой строке. Поэтому этот способ может быть более выигрышным при
массовом добавлении данных. Однако в большинстве случаев триггеры будут работать быстрее.
Учтите, что команда COPY игнорирует правила. Если вы хотите вставить данные с помощью COPY,
вам придётся копировать их сразу в нужную дочернюю таблицу, а не в главную таблицу. С другой
стороны, COPY не отменяет триггеры, так что с триггерами вы сможете использовать её обычным
образом.
82Определение данных
Ещё один недостаток подхода с правилами связан с невозможностью выдать ошибку, если до-
бавляемая строка не подпадает ни под одно из правил; в этом случае данные просто попадут
в главную таблицу.</li>
  <li>Убедитесь в том, что параметр конфигурации constraint_exclusion не выключен в
postgresql.conf. В противном случае дочерние таблицы могут сканироваться, когда это не тре-
буется.
Как уже можно понять, для реализации сложной иерархии таблиц может потребоваться DDL-код
значительного объёма. В данном примере нам потребуется создавать дочернюю таблицу каждый
месяц, так что было бы разумно написать скрипт, формирующий требуемый код DDL автоматиче-
ски.
5.10.3.2. Обслуживание таблиц, секционированных через наследование
Чтобы быстро удалить старые данные, просто удалите ставшую ненужной дочернюю таблицу:
DROP TABLE measurement_y2006m02;
Чтобы удалить дочернюю таблицу из иерархии наследования, но сохранить к ней доступ как к
самостоятельной таблице:
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
Чтобы добавить новую дочернюю таблицу для новых данных, создайте пустую дочернюю таблицу
так же, как до этого создавали начальные:
CREATE TABLE measurement_y2008m02 (
CHECK ( logdate &gt;= DATE ‘2008-02-01’ AND logdate &lt; DATE ‘2008-03-01’ )
) INHERITS (measurement);
Можно также создать новую таблицу и наполнить её данными до добавления в иерархию таблиц.
Это позволит загрузить, проверить и при необходимости преобразовать данные до того, как запро-
сы к главной таблице смогут их увидеть.
CREATE TABLE measurement_y2008m02
(LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
CHECK ( logdate &gt;= DATE ‘2008-02-01’ AND logdate &lt; DATE ‘2008-03-01’ );
\copy measurement_y2008m02 from ‘measurement_y2008m02’
– возможна дополнительная подготовка данных
ALTER TABLE measurement_y2008m02 INHERIT measurement;
5.10.3.3. Ограничения
С реализацией секционирования через наследование связаны следующие ограничения:
• Система не может проверить автоматически, являются ли все ограничения CHECK взаимно ис-
ключающими. Поэтому безопаснее будет написать и отладить код для формирования дочер-
них таблиц и создания и/или изменения связанных объектов, чем делать это вручную.
• Показанные здесь схемы подразумевают, что ключевой столбец (или столбцы) в строке нико-
гда не меняется, или меняется не настолько, чтобы строку потребовалось перенести в другую
секцию. Если же попытаться выполнить такой оператор UPDATE, произойдёт ошибка из-за на-
рушения ограничения CHECK. Если вам нужно обработать и такие случаи, вы можете устано-
вить подходящие триггеры на обновление в дочерних таблицах, но это ещё больше усложнит
управление всей конструкцией.
• Если вы выполняете команды VACUUM или ANALYZE вручную, не забывайте, что их нужно запус-
кать для каждой дочерней таблицы в отдельности. Команда
ANALYZE measurement;
обработает только главную таблицу.
83Определение данных
• Операторы INSERT с предложениями ON CONFLICT скорее всего не будут работать ожидаемым
образом, так как действие ON CONFLICT предпринимается только в случае нарушений уникаль-
ности в указанном целевом отношении, а не его дочерних отношениях.
• Для направления строк в нужные дочерние таблицы потребуются триггеры или правила, ес-
ли только приложение не знает непосредственно о схеме секционирования. Разработать триг-
геры может быть довольно сложно, и они будут работать гораздо медленнее, чем внутреннее
распределение кортежей при декларативном секционировании.
5.10.4. Устранение секций
Устранение секций — это приём оптимизации запросов, который ускоряет работу с декларативно
секционированными таблицами. Например:
SET enable_partition_pruning = on;
– по умолчанию
SELECT count(<em>) FROM measurement WHERE logdate &gt;= DATE ‘2008-01-01’;
Без устранения секций показанный запрос должен будет просканировать все секции таблицы
measurement. Когда устранение секций включено, планировщик рассматривает определение каж-
дой секции и может заключить, что какую-либо секцию сканировать не нужно, так как в ней не
может быть строк, удовлетворяющих предложению WHERE в запросе. Когда планировщик может
сделать такой вывод, он исключает (устраняет) секцию из плана запроса.
Используя команду EXPLAIN и параметр конфигурации enable_partition_pruning, можно увидеть
отличие плана, из которого были устранены секции, от плана без устранения. Типичный неопти-
мизированный план для такой конфигурации таблицы будет выглядеть так:
SET enable_partition_pruning = off;
EXPLAIN SELECT count(</em>) FROM measurement WHERE logdate &gt;= DATE ‘2008-01-01’;
QUERY PLAN
———————————————————————————–
Aggregate (cost=188.76..188.77 rows=1 width=8)
-&gt; Append (cost=0.00..181.05 rows=3085 width=0)
-&gt; Seq Scan on measurement_y2006m02 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &gt;= ‘2008-01-01’::date)
-&gt; Seq Scan on measurement_y2006m03 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &gt;= ‘2008-01-01’::date)
…
-&gt; Seq Scan on measurement_y2007m11 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &gt;= ‘2008-01-01’::date)
-&gt; Seq Scan on measurement_y2007m12 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &gt;= ‘2008-01-01’::date)
-&gt; Seq Scan on measurement_y2008m01 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &gt;= ‘2008-01-01’::date)
В некоторых или всех секциях может применяться не полное последовательное сканирование,
а сканирование по индексу, но основная идея примера в том, что для удовлетворения запроса
не нужно сканировать старые секции. И когда мы включаем устранение секций, мы получаем
значительно более эффективный план, дающий тот же результат:
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE ‘2008-01-01’;
QUERY PLAN
———————————————————————————–
Aggregate (cost=37.75..37.76 rows=1 width=8)
-&gt; Append (cost=0.00..36.21 rows=617 width=0)
-&gt; Seq Scan on measurement_y2008m01 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &gt;= ‘2008-01-01’::date)
Заметьте, что механизм устранения секций учитывает только ограничения, определённые неявно
ключами разбиения, но не наличие индексов. Поэтому определять индексы для столбцов ключа не
обязательно. Нужно ли создавать индекс для определённой секции, зависит от того, какую часть
84Определение данных
секции (меньшую или большую), по вашим представлениям, будут сканировать запросы, обраща-
ющиеся к этой секции. Индекс будет полезен в первом случае, но не во втором.
Устранение секций может производиться не только при планировании конкретного запроса, но и в
процессе его выполнения. Благодаря этому может быть устранено больше секций, когда условные
выражения содержат значения, неизвестные во время планирования; например, это могут быть
параметры, определённые оператором PREPARE, значения, получаемые из подзапросов, или пара-
метризованные значения во внутренней стороне соединения с вложенным циклом. Устранение
секций во время выполнения запроса возможно в следующие моменты времени:
• Во время подготовки плана запроса. В этот момент можно устранить секции, учитывая зна-
чения параметров, известные при подготовке выполнения запроса. Секции, устранённые на
этом этапе, не будут видны в выводе EXPLAIN или EXPLAIN ANALYZE. Их общее количество мож-
но определить по свойству «Subplans Removed» в выводе EXPLAIN.
• В процессе собственно выполнения плана запроса. Устранение секций также может выпол-
няться на этом этапе и позволяет отфильтровать секции, используя значения, которые ста-
новятся известны, когда запрос выполняется фактически. В частности это могут быть значе-
ния из подзапросов и значения параметров времени выполнения, например из параметри-
зованных соединений с вложенными циклами. Так как значение этих параметров может ме-
няться многократно при выполнении запроса, устранение секций выполняется при измене-
нии любого из параметров, анализируемых механизмом устранения. Чтобы определить, были
ли секции устранены на данном этапе, нужно внимательно изучить свойство nloops в выводе
EXPLAIN ANALYZE.
Устранение секций можно отключить, воспользовавшись параметром enable_partition_pruning.
Примечание
В настоящее время устранение секций при планировании выполнения команд UPDATE
и DELETE реализовано посредством метода исключения по ограничению (однако оно
управляется параметром enable_partition_pruning, а не constraint_exclusion) — по-
дробности и замечания приведены в следующем разделе.
Кроме того, в настоящее время устранение секций в процессе выполнения распростра-
няется только на узлы типа Append, но не MergeAppend.
И то, и другое поведение скорее всего будет изменено в будущем выпуске PostgreSQL.
5.10.5. Секционирование и исключение по ограничению
Исключение по ограничению — приём оптимизации запросов, подобный устранению секций.
Прежде всего он применяется, когда секционирование осуществляется с использованием старо-
го метода наследования, но он может быть полезен и для других целей, включая декларативное
секционирование.
Исключение по ограничению работает во многом так же, как и устранение секций; отличие со-
стоит в том, что оно использует ограничения CHECK всех таблиц (поэтому оно так и называется),
тогда как для устранения секций используются границы секции, которые существуют только в
случае декларативного секционирования. Ещё одно различие состоит в том, что исключение по
ограничению применяется только во время планирования; во время выполнения секции из плана
удаляться не будут.
То, что исключение по ограничению использует ограничения CHECK (вследствие чего оно работает
медленнее устранения секций), иногда может быть и преимуществом. Ограничения могут быть
определены даже для декларативно секционированных таблиц, в дополнение к внутренним грани-
цам секций, и тогда исключение по ограничению сможет дополнительно убрать некоторые секции
из плана запроса.
85Определение данных
По умолчанию параметр constraint_exclusion имеет значение не on и не off, а промежуточное (и
рекомендуемое) значение partition, при котором этот приём будет применяться только к запро-
сам, где предположительно будут задействованы таблицы, секционированные с использованием
наследования. Значение on обязывает планировщик просматривать ограничения CHECK во всех за-
просах, даже в самых простых, где выигрыш от исключения по ограничению маловероятен.
Применяя исключения по ограничению, необходимо учитывать следующее:
• Исключение по ограничению применяется только при планировании запросов; в отличие от
устранения секций, оно не может осуществляться при выполнении запроса.
• Исключение по ограничению работает только когда предложение WHERE в запросе содержит
константы (или получаемые извне параметры). Например, сравнение с функцией переменной
природы, такой как CURRENT_TIMESTAMP, нельзя оптимизировать, так как планировщик не зна-
ет, в какую дочернюю таблицу попадёт значение функции во время выполнения.
• Ограничения секций должны быть простыми, иначе планировщик не сможет вычислить, ка-
кие дочерние таблицы не нужно обрабатывать. Для секционирования по спискам используй-
те простые условия на равенства, а для секционирования по диапазонам — простые проверки
диапазонов, подобные показанным в примерах. Рекомендуется создавать ограничения секций,
содержащие только такие сравнения секционирующих столбцов с константами, в которых ис-
пользуются операторы, поддерживающие B-деревья. Это объясняется тем, что в ключе разби-
ения допускаются только такие столбцы, которые могут быть проиндексированы в B-дереве.
• При анализе для исключения по ограничению исследуются все ограничения всех дочерних
таблиц, относящихся к главной, так что при большом их количестве время планирования за-
просов может значительно увеличиться. Поэтому устаревший вариант секционирования, ос-
нованный на наследовании, будет работать хорошо, пока количество дочерних таблиц не пре-
вышает примерно ста; не пытайтесь применять его с тысячами дочерних таблиц.
5.11. Сторонние данные
PostgreSQL частично реализует спецификацию SQL/MED, позволяя вам обращаться к данным, на-
ходящимся снаружи, используя обычные SQL-запросы. Такие данные называются сторонними.
Сторонние данные доступны в PostgreSQL через обёртку сторонних данных. Обёртка сторонних
данных — это библиотека, взаимодействующая с внешним источником данных и скрывающая в се-
бе внутренние особенности подключения и получения данных. Несколько готовых обёрток предо-
ставляются в виде модулей contrib ; см. Приложение F. Также вы можете найти другие обёртки,
выпускаемые как дополнительные продукты. Если ни одна из существующих обёрток вас не устра-
ивает, вы можете написать свою собственную (см. Главу 57).
Чтобы обратиться к сторонним данным, вы должны создать объект сторонний сервер, в котором
настраивается подключение к внешнему источнику данных, определяются параметры соответ-
ствующей обёртки сторонних данных. Затем вы должны создать одну или несколько сторонних
таблиц, определив тем самым структуру внешних данных. Сторонние таблицы можно использо-
вать в запросах так же, как и обычные, но их данные не хранятся на сервере PostgreSQL. При каж-
дом запросе PostgreSQL обращается к обёртке сторонних данных, которая, в свою очередь, полу-
чает данные из внешнего источника или передаёт их ему (в случае команд INSERT или UPDATE).
При обращении к внешним данным удалённый источник может потребовать аутентификации кли-
ента. Соответствующие учётные данные можно предоставить с помощью сопоставлений пользо-
вателей, позволяющих определить в частности имена и пароли, в зависимости от текущей роли
пользователя PostgreSQL.
Дополнительную информацию вы найдёте в CREATE FOREIGN DATA WRAPPER, CREATE SERVER,
CREATE USER MAPPING, CREATE FOREIGN TABLE и IMPORT FOREIGN SCHEMA.
5.12. Другие объекты баз данных
Таблицы — центральные объекты в структуре реляционной базы данных, так как они содержат
ваши данные. Но это не единственные объекты, которые могут в ней существовать. Помимо них вы
86Определение данных
можете создавать и использовать объекты и других типов, призванные сделать управление данны-
ми эффективнее и удобнее. Они не обсуждаются в этой главе, но мы просто перечислим некоторые
из них, чтобы вы знали об их существовании:
• Представления
• Функции, процедуры и операторы
• Типы данных и домены
• Триггеры и правила перезаписи
Подробнее соответствующие темы освещаются в Части V.
5.13. Отслеживание зависимостей
Когда вы создаёте сложные структуры баз данных, включающие множество таблиц с внешними
ключами, представлениями, триггерами, функциями и т. п., вы неявно создаёте сеть зависимостей
между объектами. Например, таблица с ограничением внешнего ключа зависит от таблицы, на
которую она ссылается.
Для сохранения целостности структуры всей базы данных, PostgreSQL не позволяет удалять объ-
екты, от которых зависят другие. Например, попытка удалить таблицу products (мы рассматривали
её в Подразделе 5.3.5), от которой зависит таблица orders, приведёт к ошибке примерно такого
содержания:
DROP TABLE products;
ОШИБКА: удалить объект “таблица products” нельзя, так как от него зависят другие
ПОДРОБНОСТИ: ограничение orders_product_no_fkey в отношении “таблица orders” зависит
от объекта “таблица products”
ПОДСКАЗКА: Для удаления зависимых объектов используйте DROP … CASCADE.
Сообщение об ошибке даёт полезную подсказку: если вы не хотите заниматься ликвидацией зави-
симостей по отдельности, можно выполнить:
DROP TABLE products CASCADE;
и все зависимые объекты, а также объекты, зависящие от них, будут удалены рекурсивно. В этом
случае таблица orders останется, а удалено будет только её ограничение внешнего ключа. Удале-
ние не распространится на другие объекты, так как ни один объект не зависит от этого ограни-
чения. (Если вы хотите проверить, что произойдёт при выполнении DROP … CASCADE, запустите
DROP без CASCADE и прочитайте ПОДРОБНОСТИ (DETAIL).)
Почти все команды DROP в PostgreSQL поддерживают указание CASCADE. Конечно, вид возможных
зависимостей зависит от типа объекта. Вы также можете написать RESTRICT вместо CASCADE, чтобы
включить поведение по умолчанию, когда объект можно удалить, только если от него не зависят
никакие другие.
Примечание
Стандарт SQL требует явного указания RESTRICT или CASCADE в команде DROP. Но это
требование на самом деле не выполняется ни в одной СУБД, при этом одни системы по
умолчанию подразумевают RESTRICT, а другие — CASCADE.
Если в команде DROP перечисляются несколько объектов, CASCADE требуется указывать, только ко-
гда есть зависимости вне заданной группы. Например, в команде DROP TABLE tab1, tab2 при на-
личии внешнего ключа, ссылающегося на tab1 из tab2, можно не указывать CASCADE, чтобы она
выполнилась успешно.
Для пользовательских функций PostgreSQL отслеживает зависимости, связанные с внешне види-
мыми свойствами функции, такими как типы аргументов и результата, но не зависимости, которые
87Определение данных
могут быть выявлены только при анализе тела функции. В качестве примера рассмотрите следу-
ющий сценарий:
CREATE TYPE rainbow AS ENUM (‘red’, ‘orange’, ‘yellow’,
‘green’, ‘blue’, ‘purple’);
CREATE TABLE my_colors (color rainbow, note text);
CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
‘SELECT note FROM my_colors WHERE color = $1’
LANGUAGE SQL;
(Описание функций языка SQL можно найти в Разделе 38.5.) PostgreSQL будет понимать, что функ-
ция get_color_note зависит от типа rainbow: при удалении типа будет принудительно удалена
функция, так как тип её аргумента оказывается неопределённым. Но PostgreSQL не будет учиты-
вать зависимость get_color_note от таблицы my_colors и не удалит функцию при удалении табли-
цы. Но у этого подхода есть не только минус, но и плюс. В случае отсутствия таблицы эта функция
останется рабочей в некотором смысле: хотя при попытке выполнить её возникнет ошибка, но при
создании новой таблицы с тем же именем функция снова будет работать.</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page24/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page23/">23</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page24/">24</a></li>
      
    
      
        <li><strong class="current-page">25</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page26/">26</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page27/">27</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page26/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>