<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page4/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page4/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-069/" title="Глава 69. Объявление и начальное содержимое системных каталогов"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 69. Объявление и начальное содержимое системных каталогов"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-069/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~17 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-069/" rel="bookmark" title="Глава 69. Объявление и начальное содержимое системных каталогов" itemprop="url">Глава 69. Объявление и начальное содержимое системных каталогов</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 69. Объявление и начальное содержимое системных каталогов</p>

<p>В PostgreSQL используется множество разных системных каталогов для учёта информации о су-
ществовании и свойствах объектов базы, например, таблиц и функций. Физически системный ка-
талог не отличается от простой таблицы, но серверный код на C знает структуру и характеристики
каждого каталога и может работать с ним на низком уровне. Поэтому, например, не стоит пытать-
ся изменять структуру каталога «на лету»; это нарушит встроенные в код предположения о том,
как располагаются строки в каталоге. Однако структура каталога может меняться при переходе
с одной основной версии на другую.
Структуры каталогов объявляются в специально оформленных заголовочных файлах C в каталоге
src/include/catalog/ дерева исходного кода. В частности, для каждого каталога имеется заголо-
вочный файл, названный по имени каталога (например, pg_class.h для pg_class) и определяющий
набор столбцов в этом каталоге, а также другие основные свойства, например, его OID. К другим
важным файлам, задающим структуру каталога, относится indexing.h, определяющий, какие ин-
дексы присутствуют во всех системных каталогах, и toasting.h, определяющий таблицы TOAST
для каталогов, которым они нужны.
Со многими каталогами связаны исходные данные, которые должны быть загружены в них на ста-
дии «начальной загрузки» initdb, чтобы система оказалась в состоянии, когда она сможет выпол-
нять команды SQL. (Например, pg_class.h должен содержать запись, ссылающуюся на этот же
каталог, и перечисление всех остальных системных каталогов и индексов.) Эти исходные данные
задаются в редактируемой форме в файлах, которые также находятся в каталоге src/include/
catalog/. Например, в pg_proc.dat описываются все исходные строки, которые должны быть
вставлены в каталог pg_proc.
Чтобы создать файлы каталогов и загрузить в них эти исходные данные, серверный процесс, рабо-
тающий в режиме начальной загрузки, считывает файл BKI (Backend Interface, Серверный интер-
фейс), содержащий команды и исходные данные. Файл postgres.bki, используемый в этом режи-
ме, конструируется из вышеупомянутых заголовочных файлов и файлов данных при сборке дис-
трибутива PostgreSQL Perl-скриптом genbki.pl. Хотя postgres.bki привязан к определённому вы-
пуску PostgreSQL, он является платформонезависимым и устанавливается в подкаталог share де-
рева инсталляции.
Скрипт genbki.pl также генерирует производный заголовочный файл для каждого каталога, на-
пример pg_class_d.h для каталога pg_class. Этот файл содержит автоматически генерируемые
макроопределения и может содержать другие макросы, определения перечислений и т. п., кото-
рые могут быть полезны для клиентского кода, читающего определённый каталог.
Большинству разработчиков Postgres нет необходимости иметь дело непосредственно с файлом
BKI, но для практически любой нетривиальной доработки потребуется модификация заголовочных
файлов и/или файлов с исходными данными каталога. В продолжении этой главы рассказывается
об этом, а также для полноты описывается формат файла BKI.
69.1. Правила объявления системных каталогов
Ключевой частью заголовочного файла каталога является описание структуры на C, определяю-
щее вид каждой строки каталога. Оно начинается с макроса CATALOG, который, если говорить о
компиляторе C, является просто сокращённой записью typedef struct FormData_имя_каталога.
Каждое поле в этой структуре порождает столбец каталога. Поля можно дополнить макросами
свойств BKI, объявленными в genbki.h. Например, для поля можно задать значение по умолчанию
или указать, допускается ли в нём NULL. Строку CATALOG можно также дополнить некоторыми
другими макросами свойств BKI, объявленными в genbki.h и определяющими другие свойства ка-
талога в целом, например, содержит ли он OID (по умолчанию каталоги содержат OID).
Код кеша системного каталога (и в принципе почти весь код, манипулирующий каталогом) предпо-
лагает, что имеющие постоянный размер части всех кортежей системных каталогов присутствуют
2181Объявление и начальное содер-
жимое системных каталогов
фактически, так как он отображает на них объявления структуры на C. Таким образом, все поля пе-
ременной длины и поля, принимающие NULL, должны располагаться в конце, и обращаться к ним
как к полям структуры нельзя. Например, если присвоить полю pg_type.typrelid значение NULL,
обращение в каком-либо месте кода к typetup-&gt;typrelid (или, что ещё хуже, к полю typetup-</p>
<blockquote>
  <p>typelem, следующему за typrelid) будет некорректным. Это приведёт к случайным ошибкам или
даже нарушениям сегментации.
В качестве частичной защиты от ошибок такого типа поля переменной длины или поля, прини-
мающие NULL, следует скрыть от компилятора C. Это реализуется посредством обёртки #ifdef
CATALOG_VARLEN … #endif (где CATALOG_VARLEN — символ, который всегда будет неопределённым).
Это не позволяет коду на C беспрепятственно обращаться к полям, которые могут отсутствовать
или располагаться по некоторому другому смещению. В качестве дополнительной меры, препят-
ствующей созданию некорректных строк, мы требуем, чтобы все столбцы, которые не должны
принимать NULL, помечались соответствующим образом в pg_attribute. Код начальной загруз-
ки автоматически пометит столбцы каталога как NOT NULL, если они имеют фиксированную дли-
ну и перед ними нет столбцов, принимающих NULL. Там, где это правило применяется некор-
ректно, можно исправить пометку, добавив дополнительные указания BKI_FORCE_NOT_NULL или
BKI_FORCE_NULL. Но заметьте, что ограничения NOT NULL контролируются только исполнителем
запросов; на уровне кода C они не действуют, поэтому создавать или изменять строки каталога
вручную нужно так же аккуратно.
Код клиентской части не должен включать никакие заголовочные файлы каталогов pg_xxx.h, так
как эти файлы могут содержать код на C, который не будет компилироваться вне кода сервера.
(Обычно это происходит из-за того, что эти файлы также содержат объявления функций в файлах
src/backend/catalog/.) Вместо этого клиентский код может включить соответствующий сгенери-
рованный заголовок pg_xxx_d.h с определениями различных OID и другими данными, которые
могут быть полезны на стороне клиента. Если вам нужно, чтобы макросы или другой код в заго-
ловочных файлах каталогов были видимы в клиентском коде, заключите соответствущую секцию
в условие #ifdef EXPOSE_TO_CLIENT_CODE … #endif, чтобы genbki.pl скопировал эту секцию в за-
головок pg_xxx_d.h.
Некоторые каталоги настолько основополагающие, что их нельзя создать даже командой BKI
create, которая используется для большинства каталогов, так как эта команда должна записать
информацию, описывающую новый каталог, в эти базовые каталоги. Они называются каталогами
начальной загрузки и для определения их требуется много дополнительные действий: вы долж-
ны вручную подготовить соответствующие записи для них в предварительно загружаемых данных
pg_class и pg_type, и эти записи потребуется модифицировать при последующих изменениях в
структуре каталога. (Каталогам начальной загрузки также нужны предварительно загруженные
записи в pg_attribute, но, к счастью, сейчас с этим управляется скрипт genbki.pl.) По возмож-
ности избегайте включения новых каталогов в категорию каталогов начальной загрузки.
69.2. Исходные данные системных каталогов
Для каждого каталога, с которым связаны вручную создаваемые исходные данные, (не все катало-
ги такие) имеется соответствующий файл .dat, содержащий эти данные в редактируемом формате.
69.2.1. Формат файла данных
Каждый файл .dat содержит описания структур данных Perl, в результате вычисления которых
(функцией eval) в памяти формируется структура данных, состоящая из массива хеш-ссылок, соот-
ветствующих каждой строке каталога. Немного модифицированная выдержка из pg_database.dat
иллюстрирует основные моменты:
[</p>
  <h1 id="Здесь-мог-быть-комментарий">Здесь мог быть комментарий.</h1>
  <p>{ oid =&gt; ‘1’, oid_symbol =&gt; ‘TemplateDbOid’,
descr =&gt; ‘database's default template’,
datname =&gt; ‘template1’, datdba =&gt; ‘PGUID’, encoding =&gt; ‘ENCODING’,
2182Объявление и начальное содер-
жимое системных каталогов
datcollate =&gt; ‘LC_COLLATE’, datctype =&gt; ‘LC_CTYPE’, datistemplate =&gt; ‘t’,
datallowconn =&gt; ‘t’, datconnlimit =&gt; ‘-1’, datlastsysoid =&gt; ‘0’,
datfrozenxid =&gt; ‘0’, datminmxid =&gt; ‘1’, dattablespace =&gt; ‘1663’,
datacl =&gt; ‘<em>null</em>’ },
]
Замечания:
• Общий формат файла: открывающая квадратная скобка, один или более наборов фигурных
скобок, каждый из которых представляет строку каталога, и закрывающая квадратная скобка.
После каждой закрывающей фигурной скобки должна идти запятая.
• В каждой строке каталога записываются разделённые запятыми пары ключ =&gt; значение.
В качестве ключа принимаются имена столбцов каталога, а также ключи метаданных oid,
oid_symbol и descr. (Использование oid и oid_symbol описывается в Подразделе 69.2.2. В
descr задаётся строка с описанием объекта, которое будет вставлено в pg_description или
pg_shdescription.) Ключи метаданных могут опускаться, но ключ для каждого столбца ката-
лога должен присутствовать, если только в файле .h данного каталога для столбца не задано
значение по умолчанию.
• Все значения должны заключаться в апострофы. Апострофы внутри значений экранируют-
ся обратной косой чертой. Обратные косые черты в данных могут, но не обязательно должны
дублироваться; это соответствует правилам Perl по оформлению простых строковых констант.
Заметьте, что обратные косые черты, фигурирующие в данных, будут обрабатываться скане-
ром исходных данных как символы экранирования, согласно тем же правилам записи строко-
вых констант (см. Подраздел 4.1.2.2); например, \t преобразуется в символ табуляции. Если
вы хотите получить именно обратную косую черту в окончательном значении, вам надо будет
написать четыре этих символа: Perl отбрасывает два и оставляет \ сканеру исходных данных.
• Значения NULL представляются как <em>null</em>. (Заметьте, что создать значение с именно такой
строкой невозможно.)
• Комментарии предваряются знаком # и должны размещаться в отдельных строках.
• Для большей наглядности значения полей, выражающие OID других записей каталога, могут
быть представлены именами, а не только числовыми кодами OID. Об этом рассказывается в
Подразделе 69.2.3.
• Так как хеши являются неупорядоченной структурой данных, порядок полей и расположе-
ние строк не имеют семантической значимости. Однако для поддержания согласованного
представления мы установили несколько правил, которые применяет скрипт форматирования
reformat_dat_file.pl:
• В каждой паре фигурных скобок сначала идут поля метаданных oid, oid_symbol и descr, в
этом же порядке, а затем собственные поля каталога в определённом для них порядке.
• Переводы строк при необходимости вставляются между полями для ограничения длины
строки 80 символами, если это возможно. Перевод строки также вставляется между поля-
ми метаданных и обычными полями.
• Если в файле .h каталога задаётся значение по умолчанию для столбца и то же значение
указано в записи данных, reformat_dat_file.pl уберёт его из файла данных. Таким обра-
зом обеспечивается компактное представление данных.
• Скрипт reformat_dat_file.pl сохраняет пустые строки и строки комментариев в неизмен-
ном виде.
Скрипт reformat_dat_file.pl рекомендуется запускать перед сохранением изменений в дан-
ных каталога. Им удобно пользоваться, просто выполняя make reformat-dat-files в src/
include/catalog/.
• Если вы хотите добавить новый метод уменьшения представления данных, вы должны реали-
зовать его в reformat_dat_file.pl и также научить Catalog::ParseData() разворачивать дан-
ные в полное представление.
2183Объявление и начальное содер-
жимое системных каталогов
69.2.2. Назначение OID
Строке каталога, фигурирующей в исходных данных, можно вручную присвоить OID, добавив поле
метаданных oid =&gt; nnnn. Более того, когда строке присваивается OID, для этого OID можно создать
макрос C, добавив поле метаданных oid_symbol =&gt; имя.
Предварительно загружаемым строкам каталога должны заранее назначаться OID, если на них
по OID ссылаются другие предварительно загружаемые строки. Назначать OID также требуется,
если на OID нужно будет ссылаться из кода на C. В отсутствие этих условий поле метаданных oid
можно опустить и тогда загрузочный код назначит OID автоматически либо оставит его нулевым,
если OID в данном каталоге не используются. На практике мы обычно явно назначаем OID для
всех строк в определённом каталоге (даже если фактически присутствуют ссылки только на часть
из них) либо не назначаем их вовсе.
Указание фактического числового значения любого OID в коде на C считается крайне нежела-
тельным; вместо этого всегда следует использовать макрос. Прямые обращения к OID в pg_proc
требуются достаточно часто, поэтому был создан специальный механизм, создающий необходи-
мые макросы автоматически; см. src/backend/utils/Gen_fmgrtab.pl. С аналогичной целью преду-
смотрен (но по историческим причинам реализован по-другому) метод создания макросов для OID
в pg_type. Как следствие, записи oid_symbol в этих двух каталогах добавлять не нужно. Подобным
образом в pg_class автоматически включаются макросы для OID системных каталогов и индексов.
Для остальных системных каталогов все нужные вам макросы с oid_symbol вы должны добавлять
вручную.
Чтобы найти свободный OID для новой предварительно загружаемой строки, запустите скрипт
src/include/catalog/unused_oids. Он выводит диапазоны неиспользуемых OID, включающие гра-
ничные значения (например, выведенная строка «45-900» означает, что OID с 45 по 900 включи-
тельно ещё не задействованы). В настоящее время для назначения вручную зарезервированы зна-
чения OID 1-9999; скрипт unused_oids просто просматривает заголовки каталогов и файлы .dat
и проверяет, какие значения в них отсутствуют. Для поиска ошибок вы можете воспользоваться
скриптом duplicate_oids. (Скрипт genbki.pl также выявит дублирующиеся OID во время компи-
ляции.)
Счётчик OID начинается с 10000 при запуске начальной загрузки. Если строка каталога находится
в таблице с OID, но для неё не было явно установлено поле oid, она получит OID, равный 10000
или больше.
69.2.3. Поиск по OID
Перекрёстную ссылку из одной строки исходного каталога на другую можно записать, просто ука-
зав предопределённый OID целевой строки. Однако этот подход провоцирует ошибки и сложен
для понимания, поэтому для часто используемых каталогов в genbki.pl реализованы механизмы
записи символических ссылок. В настоящее время по символическим ссылкам можно обращаться
к методам доступа, функциям, операторам, классам и семействам операторов, а также типам. При
этом действуют следующие правила:
• Для использования символических ссылок в некотором столбце каталога требуется доба-
вить указание BKI_LOOKUP(правило_поиска) в определение этого столбца, где правилом_поис-
ка может быть pg_am, pg_proc, pg_operator, pg_opclass, pg_opfamily или pg_type. Указание
BKI_LOOKUP может быть добавлено к столбцам типа Oid, regproc, oidvector или Oid[]; в по-
следних двух случаях поиск будет выполняться для каждого элемента массива.
• В таком столбце все записи должны иметь символьный формат (исключение составляет 0,
обозначающий InvalidOid). (Если столбец объявлен как regproc, вместо 0 можно написать -.)
Скрипт genbki.pl выдаст предупреждение, встретив нераспознанное имя.
• Методы доступа, как и типы, представляются просто своими именами. Имена типов должны
соответствовать полям typname в соответствующих записях pg_type; псевдонимы типов ис-
пользовать нельзя, например, нельзя написать integer вместо int4.
2184Объявление и начальное содер-
жимое системных каталогов
• Функция может быть представлена своим значением proname, если оно уникально среди запи-
сей pg_proc.dat (это работает как ввод значения типа regproc). В противном случае её нужно
представить как proname(имя_типа_аргумента,имя_типа_аргумента,…), как в regprocedure.
Имена типов аргументов должны записываться в точности так, как они фигурируют в поле
proargtypes в pg_proc.dat. Не добавляйте в эту строку пробелы.
• Операторы представляются в виде oprname(левый_тип,правый_тип), при этом имена ти-
пов записываются в точности так, как они фигурируют в полях oprleft и oprright в
pg_operator.dat. (Вместо опущенного операнда унарного оператора записывается 0.)
• Имена классов операторов и семейств операторов уникальны только в рамках определённого
метода доступа, так что они представляются в виде имя_метода_доступа/имя_объекта.
• Ни в одном из этих случаев не поддерживается указание схемы; все объекты, создаваемые на
стадии начальной загрузки, будут принадлежать схеме pg_catalog.
Скрипт genbki.pl разрешает все символические ссылки при запуске и помещает в формируемый
файл BKI обычные числовые OID. Таким образом, при начальной загрузке отпадает необходимость
в разрешении имён.
69.2.4. Рецепты по редактированию файлов данных
Ниже приведены некоторые предложения по оптимальному решению некоторых распространён-
ных задач при изменении файлов каталогов.
Добавление в каталог нового столбца со значением по умолчанию:  Добавьте столбец в
заголовочный файл с указанием BKI_DEFAULT(значение). Файл данных потребуется редактировать,
только если в каких-либо существующих строках в добавленном поле должно быть не значение
по умолчанию.
Указание значения по умолчанию для существующего столбца, который его не
имел:  Добавьте указание BKI_DEFAULT в заголовочный файл, а затем выполните make reformat-
dat-files для удаления ставших избыточными записей поля.
Удаление столбца, со значением по умолчанию или без:  Удалите столбец из заголовочного
файла, а затем выполните make reformat-dat-files для удаления ставших избыточными записей
поля.
Изменение или удаление существующего значения по умолчанию:  Просто изменить заго-
ловочный файл недостаточно, так как при этом текущие данные будут интерпретироваться некор-
ректно. Сначала выполните make expand-dat-files, чтобы перезаписать в файлах данных все явно
заданные значения по умолчанию, затем удалите или измените указания BKI_DEFAULT, и в завер-
шение выполните make reformat-dat-files для повторного удаления избыточных полей.
Разовая массовая модификация:  Скрипт reformat_dat_file.pl можно скорректировать для
выполнения самых разных массовых модификаций. Просмотрев в нём блочные комментарии, вы
найдёте место, куда можно вставить модифицирующий код. В следующем примере мы произведём
объединение двух логических полей в pg_proc в символьном поле:</p>
  <ol>
    <li>Добавьте новый столбец со значением по умолчанию в pg_proc.h:
+
+
/* see PROKIND_ categories below */
char
prokind BKI_DEFAULT(f);</li>
    <li>Создайте на основе reformat_dat_file.pl новый скрипт, который вставит соответствующие зна-
чения «на лету»:
-
-
-
-
+
+
#
#
#
#
#
#
At this point we have the full row in memory as a hash
and can do any operations we want. As written, it only
removes default values, but this script can be adapted to
do one-off bulk-editing.
One-off change to migrate to prokind
Default has already been filled in by now, so change to other
2185Объявление и начальное содер-
жимое системных каталогов
+
+
+
+
+
+
+
+
+
      <h1 id="values-as-appropriate">values as appropriate</h1>
      <p>if ($values{proisagg} eq ‘t’)
{
$values{prokind} = ‘a’;
}
elsif ($values{proiswindow} eq ‘t’)
{
$values{prokind} = ‘w’;
}</p>
    </li>
    <li>Запустите новый скрипт:
$ cd src/include/catalog
$ perl rewrite_dat_with_prokind.pl
pg_proc.dat
После этого в файле pg_proc.dat окажутся все три столбца, prokind, proisagg и proiswindow,
хотя они будут фигурировать только в тех строках, где им присваиваются не значения по умол-
чанию, а любые другие значения.</li>
    <li>
      <h2 id="Удалите-старые-столбцы-из-pg_proch">Удалите старые столбцы из pg_proc.h:</h2>
      <p>-
-
-
-
/* is it an aggregate? <em>/
bool
proisagg BKI_DEFAULT(f);
/</em> is it a window function? */
bool
proiswindow BKI_DEFAULT(f);</p>
    </li>
    <li>Наконец, выполните make
pg_proc.dat.
reformat-dat-files для удаления ненужных старых записей из
Примеры
кода,
производящего
массовые
модификации,
вы
може-
те
найти
в
скриптах
convert_oid2name.pl
и
remove_pg_type_oid_symbols.pl,
вложенных
в
сообщение:
https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm
+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com
69.3. Формат файла BKI
В этом разделе описывается, как сервер PostgreSQL интерпретирует файлы BKI. Это описание
будет легче понять, если для наглядности вы откроете файл postgres.bki.
Содержимое BKI состоит из последовательности команд. Команды образуются из нескольких ком-
понентов, в зависимости от синтаксиса конкретной команды. Компоненты команд обычно разде-
ляются пробельными символами, но это не обязательно, если не возникает неоднозначности. Спе-
циальный разделитель команд отсутствует; следующий компонент, который не может синтаксиче-
ски относиться к предыдущей команде, начинает следующую. (Обычно новая команда начинается
в отдельной строке, для структурности.) Компонентами команд могут быть определённые ключе-
вые слова, специальные символы (скобки, запятые и т. д.), числа или строки в двойных кавычках.
Все буквы в них воспринимаются с учётом регистра.
Строки, начинающиеся с #, игнорируются.
69.4. Команды BKI
create имя_таблицы oid_таблицы [bootstrap] [shared_relation] [without_oids] [rowtype_oid oid]
(имя1 = тип1 [FORCE NOT NULL | FORCE NULL] [, имя2 = тип2 [FORCE NOT NULL | FORCE NULL], …])
Создать таблицу имя_таблицы с заданным oid_таблицы и столбцами, указанными в скобках.
Непосредственно bootstrap.c поддерживает следующие типы столбцов: bool, bytea, char
(1 байт), name, int2, int4, regproc, regclass, regtype, text, oid, tid, xid, cid, int2vector,
oidvector, <em>int4 (массив), _text (массив), _oid (массив), _char (массив), _aclitem (массив). Хо-
тя возможно создать таблицы, содержащие столбцы и других типов, это нельзя сделать, пока не
2186Объявление и начальное содер-
жимое системных каталогов
будет создан и заполнен соответствующими записями каталог pg_type. (По сути это означает,
что только эти типы столбцов могут быть в каталогах начальной загрузки, хотя другие каталоги
могут содержать любые встроенные типы.)
С указанием bootstrap таблица будет создана только на диске; никакие записи о ней не бу-
дут добавлены в pg_class, pg_attribute и т. д. Таким образом, таблица не будет доступна для
обычных операций SQL, пока такие записи не будут добавлены явно (командами insert). Это
указание применяется для создания самой структуры pg_class и подобных ей.
Если добавлено указание shared_relation, таблица создаётся как общая. Она будет содер-
жать столбец OID, если отсутствует указание without_oids. Дополнительным предложением
rowtype_oid может быть задан OID типа строки (OID записи в pg_type); если он не указан, OID
генерируется автоматически. (Предложение rowtype_oid бесполезно, если присутствует ука-
зание bootstrap, но его всё равно можно добавить для документирования.)
open имя_таблицы
Открыть таблицу имя_таблицы для добавления данных. Любая другая таблица, открытая в дан-
ный момент, закрывается.
close имя_таблицы
Закрыть открытую таблицу. Имя таблицы должно задаваться для перепроверки.
insert [OID = значение_oid] ( значение1 значение2 … )
Вставить новую строку в открытую таблицу, установив значение1, значение2 и т. д. в качестве
значений столбцов и значение_oid в качестве OID. Если значение_oid равно нулю (0) или это
указание опущено, а таблица при этом содержит OID, строке назначается следующий свобод-
ный OID.
Значения NULL могут задаваться специальным ключевым словом _null</em>. Значения, отличные
от идентификаторов и цифровых строк, должны заключаться в двойные кавычки.
declare [unique] index имя_индекса oid_индекса on имя_таблицы using имя_метода_доступа ( клас-
с_оп1 имя1 [, …] )
Создать индекс имя_индекса с OID, равным oid_индекса, в таблице имя_таблицы, с методом до-
ступа имя_метода_доступа. Индекс строится по полям имя1, имя2 и т. д., и для них используют-
ся соответственно классы операторов класс_оп1, класс_оп2 и т. д. Эта команда создаёт файл
индекса и добавляет соответствующие записи в каталог, но не инициализирует содержимое
индекса.
declare toast oid_таблицы_toast oid_индекса_toast on имя_таблицы
Создаёт таблицу TOAST для таблицы имя_таблицы. Таблице TOAST назначается OID, равный
oid_таблицы_toast, а её индексу назначается OID, равный oid_индекса_toast. Как и с declare
index, заполнение индекса откладывается.
build indices
Заполнить индексы, объявленные ранее.
69.5. Структура файла BKI
Команда open может применяться, только когда открываемая ей таблица существует и для неё име-
ются записи в каталогах. (Минимальный набор этих каталогов образуют pg_class, pg_attribute,
pg_proc и pg_type.) Чтобы можно было заполнить сами эти таблицы, команда create с указанием
bootstrap неявно открывает создаваемую таблицу для добавления данных.
Кроме того, команды declare index и declare toast нельзя применять, пока не будут созданы и
заполнены системные каталоги.
2187Объявление и начальное содер-
жимое системных каталогов
Таким образом, файл postgres.bki должен иметь следующую структуру:</li>
    <li>create bootstrap (создание) одной из критичных таблиц</li>
    <li>insert (добавление) данных, описывающих как минимум критичные таблицы</li>
    <li>close</li>
    <li>Повторение для других критичных таблиц.</li>
    <li>create (создание) (без bootstrap) некритичной таблицы</li>
    <li>open</li>
    <li>insert (добавление) требуемых данных</li>
    <li>close</li>
    <li>Повторение для других некритичных таблиц.
10.Определение индексов и таблиц TOAST.</li>
    <li>build indices
Несомненно есть и другие, недокументированные зависимости, диктующие определённый поря-
док.
69.6. Пример BKI
Следующая последовательность команд создаст таблицу test_table с OID 420, имеющую два
столбца cola и colb типа int4 и text, соответственно, и вставит две строки в эту таблицу:
create test_table 420 (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 “value1” )
insert OID=422 ( 2 <em>null</em> )
close test_table
2188</li>
  </ol>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-068/" title="Глава 68. Физическое хранение базы данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 68. Физическое хранение базы данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-068/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~22 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-068/" rel="bookmark" title="Глава 68. Физическое хранение базы данных" itemprop="url">Глава 68. Физическое хранение базы данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 68. Физическое хранение базы данных</p>

<p>В данной главе рассматривается формат физического хранения, используемый базами данных
PostgreSQL.</p>

<p>68.1. Размещение файлов базы данных</p>

<p>Этот раздел описывает формат хранения на уровне файлов и каталогов.
Файлы конфигурации и файлы данных, используемые кластером базы данных, традиционно хра-
нятся вместе в каталоге данных кластера, который обычно называют PGDATA (по имени перемен-
ной среды, которую можно использовать для его определения). Обычно PGDATA находится в /var/
lib/pgsql/data. На одной и той же машине может находиться множество кластеров, управляемых
различными экземплярами сервера.
В каталоге PGDATA содержится несколько подкаталогов и управляющих файлов, как показано в
Таблице 68.1. В дополнение к этим обязательным элементам конфигурационные файлы кластера
postgresql.conf, pg_hba.conf и pg_ident.conf традиционно хранятся в PGDATA, хотя их можно
разместить и в другом месте.
Таблица 68.1. Содержание PGDATA
Элемент Описание
PG_VERSION Файл, содержащий
PostgreSQL
base Подкаталог, содержащий подкаталоги для каж-
дой базы данных
current_logfiles Файл, в котором отмечается, в какие файлы жур-
налов производит запись сборщик сообщений
global Подкаталог, содержащий общие таблицы кла-
стера, такие как pg_database
pg_commit_ts Подкаталог, содержащий данные о времени
фиксации транзакций
pg_dynshmem Подкаталог, содержащий файлы, используемые
подсистемой динамически разделяемой памяти
pg_logical Подкаталог, содержащий данные о состоянии
для логического декодирования
pg_multixact Подкаталог, содержащий данные о состоянии
мультитранзакций (используемые для разделяе-
мой блокировки строк)
pg_notify Подкаталог,
содержащий
данные
состоя-
ния прослушивания и нотификации (LISTEN/
NOTIFY)
pg_replslot Подкаталог, содержащий данные слота репли-
кации
pg_serial Подкаталог, содержащий информацию о выпол-
ненных сериализуемых транзакциях.
pg_snapshots Подкаталог, содержащий
снимки (snapshots)
pg_stat Подкаталог, содержащий постоянные файлы
для подсистемы статистики.
2171
номер
основной
версии
экспортированныеФизическое хранение базы данных
Элемент Описание
pg_stat_tmp Подкаталог, содержащий временные файлы для
подсистемы статистики
pg_subtrans Подкаталог, содержащий данные о состоянии
подтранзакций
pg_tblspc Подкаталог, содержащий символические ссыл-
ки на табличные пространства
pg_twophase Подкаталог, содержащий файлы состояний для
подготовленных транзакций
pg_wal Подкаталог, содержащий файлы WAL (журнал
предзаписи)
pg_xact Подкаталог, содержащий данные о состоянии
транзакции
postgresql.auto.conf Файл, используемый для хранения параметров
конфигурации, которые устанавливаются при
помощи ALTER SYSTEM
postmaster.opts Файл, содержащий параметры командной стро-
ки, с которыми сервер был запущен в последний
раз
postmaster.pid Файл блокировки, содержащий идентификатор (
ID) текущего управляющего процесса (PID), путь
к каталогу данных кластера, временную мет-
ку запуска управляющего процесса, номер пор-
та, путь к каталогу Unix-сокета (пустой для
Windows), первый корректный адрес прослуши-
вания (listen_address) (IP-адрес или *, либо пу-
стое значение в случае отсутствия прослушива-
ния по TCP), и ID сегмента разделяемой памяти (
этот файл отсутствует после остановки сервера).
Для каждой базы данных в кластере существует подкаталог внутри PGDATA/base, названный по
OID базы данных в pg_database. Этот подкаталог по умолчанию является местом хранения файлов
базы данных; в частности, там хранятся её системные каталоги.
Каждая таблица и индекс хранятся в отдельном файле. Для обычных отношений, эти фай-
лы получают имя по номеру файлового узла таблицы или индекса, который содержится в
pg_class.relfilenode. Но для временных отношений, имя файла имеет форму tBBB_FFF, где BBB</p>
<ul>
  <li>идентификатор серверного процесса сервера, который создал данный файл, а FFF — номер фай-
лового узла. В обоих случаях, помимо главного файла (также называемого основным слоем), у
каждой таблицы и индекса есть карта свободного пространства (см. Раздел 68.3), в которой хра-
нится информация о свободном пространстве в данном отношении. Имя файла карты свободного
пространства образуется из номера файлового узла с суффиксом _fsm. Также таблицы имеют кар-
ту видимости, хранящуюся в слое с суффиксом _vm, для отслеживания страниц, не содержащих
мёртвых записей. Карта видимости подробнее описана в Разделе 68.4. Нежурналируемые табли-
цы и индексы имеют третий слой, так называемый слой инициализации, имя которого содержит
суффикс _init (см. Раздел 68.5).
Внимание
Заметьте, что хотя номер файла таблицы часто совпадает с её OID, так бывает не всегда;
некоторые операции, например, TRUNCATE, REINDEX, CLUSTER и некоторые формы коман-
ды ALTER TABLE могут изменить номер файла, но при этом сохранят OID. Не следует рас-
считывать, что номер файлового узла и OID таблицы совпадают. Кроме того, для неко-
торых системных каталогов, включая и pg_class, в pg_class.relfilenode содержится
2172Физическое хранение базы данных
ноль. Фактический номер файлового узла для них хранится в низкоуровневой структу-
ре данных, и его можно получить при помощи функции pg_relation_filenode().
Когда объём таблицы или индекса превышает 1 GB, они делятся на сегменты размером в один
гигабайт. Файл первого сегмента называется по номеру файлового узла (filenode); последующие
сегменты получают имена filenode.1, filenode.2 и т. д. При такой организации хранения не возни-
кает проблем на платформах, имеющих ограничения по размеру файлов. (На самом деле, 1 ГБ —
лишь размер по умолчанию. Размер сегмента можно изменить при сборке PostgreSQL, используя
параметр конфигурации –with-segsize.) В принципе, карты свободного пространства и карты
видимости также могут занимать нескольких сегментов, хотя на практике это маловероятно.
У таблицы, столбцы которой могут содержать данные большого объёма, будет иметься собствен-
ная таблица TOAST, предназначенная для отдельного хранения значений, которые слишком вели-
ки для хранения в строках самой таблицы. Основная таблица связывается с её таблицей TOAST
(если таковая имеется) через pg_class.reltoastrelid. За подробной информацией обратитесь к
Разделу 68.2.
Содержание таблиц и индексов рассматривается ниже (см. Раздел 68.6).
Табличное пространство делает сценарий более сложным. Каждое пользовательское табличное
пространство имеет символическую ссылку внутри каталога PGDATA/pg_tblspc, указывающую на
физический каталог табличного пространства (т. е., положение, указанное в команде таблично-
го пространства CREATE TABLESPACE). Эта символическая ссылка получает имя по OID таблич-
ного пространства. Внутри физического каталога табличного пространства имеется подкаталог,
имя которого зависит от версии сервера PostgreSQL, как например PG_9.0_201008051. (Этот под-
каталог используется для того, чтобы последующие версии базы данных могли свободно исполь-
зовать одно и то же местоположение, заданное в CREATE TABLESPACE.) Внутри каталога конкрет-
ной версии находится подкаталог для каждой базы данных, которая имеет элементы в табличном
пространстве, названный по OID базы данных. Таблицы и индексы хранятся внутри этого катало-
га, используя схему именования файловых узлов. Табличное пространство pg_default недоступно
через pg_tblspc, но соответствует PGDATA/base. Подобным же образом, табличное пространство
pg_global недоступно через pg_tblspc, но соответствует PGDATA/global.
Функция pg_relation_filepath() показывает полный путь (относительно PGDATA) для любого от-
ношения. Часто это избавляет от необходимости запоминать многие из приведённых выше правил.
Но следует помнить, что эта функция выдаёт лишь имя первого сегмента основного слоя отноше-
ния, т. е. возможно, понадобится добавить номер сегмента и/или _fsm, _vm или _init, чтобы найти
все файлы, связанные с отношением.
Временные файлы (для таких операций, как сортировка объёма данных большего, чем может уме-
ститься в памяти) создаются внутри PGDATA/base/pgsql_tmp или внутри подкаталога pgsql_tmp
каталога табличного пространства, если для них определено табличное пространство, отличное
от pg_default. Имя временного файла имеет форму pgsql_tmpPPP.NNN, где PPP — PID серверного
процесса, а NNN служит для разделения различных временных файлов этого серверного процесса.
68.2. TOAST
В данном разделе рассматривается TOAST (The Oversized-Attribute Storage Technique, Методика
хранения сверхбольших атрибутов).
PostgreSQL использует фиксированный размер страницы (обычно 8 КБ), и не позволяет кортежам
занимать несколько страниц. Поэтому непосредственно хранить очень большие значения полей
невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или раз-
биваются на несколько физических строк. Это происходит незаметно для пользователя и на боль-
шую часть кода сервера влияет незначительно. Этот метод известен как TOAST (тост, или «лучшее
после изобретения нарезанного хлеба»). Инфраструктура TOAST также применяется для оптими-
зации обработки больших значений данных в памяти.
2173Физическое хранение базы данных
Лишь определённые типы данных поддерживают TOAST — нет смысла производить дополнитель-
ные действия с типами данных, размер которых не может быть большим. Чтобы поддерживать
TOAST, тип данных должен представлять значение переменной длины (varlena), в котором первое
четырёхбайтовое слово любого хранящегося значения содержит общую длину значения в байтах
(включая само это слово). Содержание оставшейся части значения TOAST не ограничивает. Спе-
циальные представления, в целом называемые значениями в формате TOAST, работают, манипу-
лируя этим начальным словом длины и интерпретируя его по-своему. Таким образом, функции
уровня C, работающие с типом данных, поддерживающим TOAST, должны аккуратно обращаться
со входными значениями, которые могут быть в формате TOAST: входные данные могут и не содер-
жать четырёхбайтовое слово длины и содержимое после него, пока не будут распакованы. (Обыч-
но в таких ситуациях нужно использовать макрос PG_DETOAST_DATUM прежде чем что-либо делать с
входным значением, но в некоторых случаях возможны и более эффективные подходы. За подроб-
ностями обратитесь к Подразделу 38.12.1.)
TOAST занимает два бита слова длины varlena (старшие биты на машинах с порядком байт от стар-
шего к младшему, или младшие биты — при другом порядке байт), таким образом, логический раз-
30
мер любого значения в формате TOAST ограничивается 1 Гигабайтом (2 - 1 байт). Когда оба бита
равны нулю, значение является обычным, не в формате TOAST, и оставшиеся биты слова длины
задают общий размер элемента данных (включая слово длины) в байтах. Когда установлен стар-
ший (или младший, в зависимости от архитектуры) бит, значение имеет однобайтовый заголовок
вместо обычного четырёхбайтового, а оставшиеся биты этого байта задают общий размер элемен-
та данных (включая байт длины) в байтах. Этот вариант позволяет экономно хранить значения
короче 127 байт и при этом допускает расширение значения этого типа данных до 1 Гбайта при
необходимости. Значения с однобайтовыми заголовками не выравниваются по какой-либо опреде-
лённой границе, тогда как значения с четырёхбайтовыми заголовками выравниваются по границе
минимум четырёх байт; это избавление от выравнивания даёт дополнительный выигрыш в объёме,
очень ощутимый для коротких значений. В качестве особого случая, если все оставшиеся биты
однобайтового заголовка равны нулю (что в принципе невозможно с учётом включения размера
длины), значением является указатель на отдельно размещённые данные, с несколькими возмож-
ными вариантами, описанными ниже. Тип и размер такого указателя TOAST определяется кодом,
хранящимся во втором байте значения. Наконец, когда старший (или младший, в зависимости от
архитектуры) бит очищен, а соседний бит установлен, содержимое данных хранится в упакован-
ном виде и должно быть распаковано перед использованием. В этом случае оставшиеся биты че-
тырёхбайтового слова длины задают общий размер сжатых, а не исходных данных. Заметьте, что
сжатие также возможно и для отделённых данных, но заголовок varlena не говорит, имеет ли оно
место — это определяется содержимым, на которое указывает указатель TOAST.
Как уже было сказано, существуют разные варианты использования указателя TOAST. Самый ста-
рый и наиболее популярный вариант — когда он указывает на отделённые данные, размещённые
в таблице TOAST, которая отделена, но связана с таблицей, содержащей собственно указатель
данных TOAST. Такой указатель на данные на диске создаётся кодом обработки TOAST (в access/
heap/tuptoaster.c), когда кортеж, сохраняемый на диск, оказывается слишком большим. Допол-
нительные подробности описаны в Подразделе  68.2.1. Кроме того, указатель TOAST может ука-
зывать на отделённые данные, размещённые где-то в памяти. Такие данные обязательно недолго-
временные и никогда не оказываются на диске, но этот механизм очень полезен для исключения
копирования и избыточной обработки данные большого размера. Дополнительные подробности
описаны в Подразделе 68.2.2.
В качестве метода сжатия внутренних и отделённых данных применяется довольно про-
стой и очень быстрый представитель семейства алгоритмов LZ. Подробнее см. src/common/
pg_lzcompress.c.
68.2.1. Отдельное размещение TOAST на диске
Если какие-либо столбцы таблицы хранятся в формате TOAST, у таблицы будет связанная с ней
таблица TOAST, OID которой хранится в значении pg_class.reltoastrelid для данной таблицы.
Размещаемые на диске TOAST-значения содержатся в таблице TOAST, что подробнее описано ни-
же.
2174Физическое хранение базы данных
Отделённые значения делятся на порции (после сжатия, если оно применяется) размером не бо-
лее TOAST_MAX_CHUNK_SIZE байт (по умолчанию это значение выбирается таким образом, чтобы
на странице помещались четыре строки порций, то есть размер одной составляет порядка 2000
байт). Каждая порция хранится как отдельная строка в таблице TOAST, принадлежащей исход-
ной таблице-владельцу. Каждая таблица TOAST имеет столбцы chunk_id (OID, идентифицирующий
конкретное TOAST-значение), chunk_seq (последовательный номер для порции внутри значения)
и chunk_data (фактические данные порции). Уникальный индекс по chunk_id и chunk_seq обеспе-
чивает быструю выдачу значений. Таким образом, в указателе, представляющем отдельно разме-
щаемое на диске значение TOAST, должно храниться OID таблицы TOAST, к которой нужно обра-
щаться, и OID определённого значения (его chunk_id). Для удобства в данных указателя также
хранится логический размер элемента данных (исходных данных без сжатия) и фактический раз-
мер хранимых данных (отличающийся, если было применено сжатие). Учитывая байты заголовка
varlena, общий размер указателя на хранимое на диске значение TOAST составляет 18 байт, неза-
висимо от фактического размера собственно значения.
Код обработки TOAST срабатывает, только когда значение строки, которое должно храниться в
таблице, по размеру больше, чем TOAST_TUPLE_THRESHOLD байт (обычно это 2 Кб). Код TOAST бу-
дет сжимать и/или выносить значения поля за пределы таблицы до тех пор, пока значение стро-
ки не станет меньше TOAST_TUPLE_TARGET байт (переменная величина, так же обычно 2 Кб) или
уменьшить объём станет невозможно. Во время операции UPDATE значения неизменённых полей
обычно сохраняются как есть, поэтому модификация строки с отдельно хранимыми значениями
не несёт издержек, связанных с TOAST, если все такие значения остаются без изменений.
Код обработки TOAST распознаёт четыре различные стратегии хранения столбцов, совместимых
с TOAST, на диске:
• PLAIN не допускает ни сжатие, ни отдельное хранение; кроме того, отключается использова-
ние однобайтовых заголовков для типов varlena. Это единственно возможная стратегия для
столбцов типов данных, которые несовместимы с TOAST.
• EXTENDED допускает как сжатие, так и отдельное хранение. Это стандартный вариант для
большинства типов данных, совместимых с TOAST. Сначала происходит попытка выполнить
сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.
• EXTERNAL допускает отдельное хранение, но не сжатие. Использование EXTERNAL ускорит опе-
рации над частями строк в больших столбцах text и bytea (ценой увеличения объёма памяти
для хранения), так как эти операции оптимизированы для извлечения только требуемых ча-
стей отделённого значения, когда оно не сжато.
• MAIN допускает сжатие, но не отдельное хранение. (Фактически, отдельное хранение, тем не
менее, будет выполнено для таких столбцов, но лишь как крайняя мера, когда нет другого
способа уменьшить строку так, чтобы она помещалась на странице.)
Каждый тип данных, совместимый с TOAST, определяет стандартную стратегию для столбцов этого
типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью ALTER
TABLE … SET STORAGE.
TOAST_TUPLE_TARGET можно задавать на уровне таблиц с помощью команды ALTER TABLE … SET
(toast_tuple_target = N)
Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк
могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются вы-
полнением сравнения с относительно маленькими значениями ключа, большая часть работы бу-
дет выполняться с использованием главной записи строки. Большие значения атрибутов в форма-
те TOAST будут просто передаваться (если будут выбраны) в тот момент, когда результирующий
набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в об-
щий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хра-
нения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполнять-
ся исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-
страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая
таблицу TOAST, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые
2175Физическое хранение базы данных
маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обра-
ботки таблицы без использования TOAST, в которой размер всех HTML-страниц был уменьшен до
7 Кб, чтобы они уместились в строках.
68.2.2. Отдельное размещение TOAST в памяти
Указатели TOAST могут указывать на данные, размещённые не на диске, а где-либо в памяти те-
кущего серверного процесса. Очевидно, что такие указатель не могут быть долговременными, но
они, тем не менее, полезны. В настоящее время поддерживаются два подварианта: косвенные ука-
затели на данные и указатели на развёрнутые данные.
Косвенный указатель TOAST просто указывает на значение varlena, хранящееся где-то в памяти.
Этот вариант изначально был реализован просто как подтверждение концепции, но в настоящее
время он применяется при логическом декодировании, чтобы не приходилось создавать физиче-
ские кортежи больше одного 1 ГБ (что может потребоваться при консолидации всех отделённых
значений полей в одном кортеже). Данный вариант имеет ограниченное применение, так как со-
здатель такого указателя должен полностью понимать, что целевые данные будут существовать,
только пока существует указатель, и никакой инфраструктуры для сохранения их нет.
Указатели на развёрнутые данные TOAST полезны для сложных типов, представление которых на
диске плохо приспособлено для вычислительных целей. Например, стандартное представление в
виде varlena массива PostgreSQL включает информацию о размерности, битовую карту элементов
NULL (если они в нём содержатся), а затем значения всех элементов по порядку. Когда элемент
сам по себе имеет переменную длину, единственный способ найти N-ный элемент — просканиро-
вать все предыдущие элементы. Это представление компактно, и поэтому подходит для хранения
на диске, но для вычислительной обработки массива гораздо удобнее иметь «развёрнутое» или
«деконструированное» представление, в котором можно определить начальные адреса всех эле-
ментов. Механизм указателей TOAST способствует решению этой задачи, допуская передачу по
ссылке элемента Datum как указателя на стандартное значение varlena (представление на диске)
или указателя TOAST на развёрнутое представление где-то в памяти. Детали развёрнутого пред-
ставление определяются самим типом данных, хотя оно может иметь стандартный заголовок и удо-
влетворять другим требованиям API, описанным в src/include/utils/expandeddatum.h. Функции
уровня C, работающие с этим типом, могут реализовать поддержку любого из этих представлений.
Функции, не знающие о развёрнутом представлении, а просто применяющие PG_DETOAST_DATUM к
своим входным данным, будут автоматически получать традиционное представление varlena; так
что поддержка развёрнутого представления может вводиться постепенно, по одной функции.
Указатели TOAST на развёрнутые значения далее подразделяются на указатели для чтения/за-
писи и указатели только для чтения. Представление, на которое они указывают, в любом случае
одинаковое, но функции, получающей указатель для чтения/записи, разрешается модифицировать
целевые данные прямо на месте, тогда как функция, получающая указатель только для чтения, не
должна этого делать; если ей нужно получить изменённую версию значения, она должна сначала
сделать копию. Это отличие и связанные с ним соглашения позволяют избежать излишнего копи-
рования развёрнутых значений при выполнении запросов.
Для всех типов указателей TOAST на данные в памяти, код обработки TOAST гарантирует, что та-
кие данные не окажутся случайно сохранены на диске. Указатели TOAST в памяти автоматически
сворачиваются в обычные значения varlena перед сохранением — а затем могут преобразоваться
в указатели TOAST на диске, если без этого не смогут уместиться в содержащем их кортеже.
68.3. Карта свободного пространства
Каждое табличное и индексное отношение, за исключением хеш-индексов, имеет карту свободно-
го пространства (Free Space Map, FSM) для отслеживания доступного места. Она хранится рядом с
данными главного отношения в отдельном слое, имя которого образуется номером файлового узла
отношения с суффиксом _fsm. Например, если файловый узел отношения — 12345, FSM хранится
в файле с именем 12345_fsm в том же каталоге, что и основной файл отношения.
Карта свободного пространства представляет собой дерево страниц FSM. Страницы FSM нижнего
уровня хранят информацию о свободном пространстве, доступном на каждой странице таблицы
2176Физическое хранение базы данных
(или индекса), используя один байт для представления каждой такой страницы. Верхние уровни
агрегируют информацию нижних уровней.
Внутри каждой страницы FSM имеется двоичное дерево, хранящееся в массиве, где один байт
выделяется на каждый узел дерева. Каждый листовой узел представляет страницу таблицы или
страницу FSM нижнего уровня. В каждом узле выше листовых хранится наибольшее из значений
его узлов-потомков. Поэтому максимальное из значений листовых узлов хранится в корневом узле.
Более подробную информацию о структуре FSM и о том, как выполняется обновление и поиск, вы
найдёте в src/backend/storage/freespace/README. Модуль pg_freespacemap может быть исполь-
зован для просмотра информации, хранящейся в картах свободного пространства.
68.4. Карта видимости
Каждое отношение таблицы имеет карту видимости (Visibility Map, VM) для отслеживания стра-
ниц, содержащих только кортежи, которые видны всем активным транзакциям; в ней также отсле-
живается, какие страницы содержат только замороженные кортежи. Она хранится вместе с дан-
ными главного отношения в отдельном файле, имя которого образуется номером файлового узла
отношения с суффиксом _vm. Например, если файловый узел отношения — 12345, VM хранится в
файле 12345_vm, в том же самом каталоге, что и основной файл отношения. Заметьте, что индексы
не имеют VM.
Карта видимости хранит по два бита на страницу таблицы. Первый бит, если он установлен, пока-
зывает, что вся страница видна или, другими словами, не содержит кортежей, которые необходи-
мо очистить. Эта информация может также использоваться при сканировании только индекса для
поиска ответов только в данных индекса. Установленный второй бит показывает, что все кортежи
на этой странице заморожены. Это означает, что процесс очистки для предотвращения зацикли-
вания не должен больше посещать эту страницу.
Карта может отражать реальные данные с запаздыванием в том смысле, что мы уверены, что в
случаях, когда установлен бит, известно, что условие верно, но если бит не установлен, оно может
быть верным или неверным. Биты карты видимости устанавливаются только при очистке, а сбра-
сываются при любых операциях, изменяющих данные на странице.
Для изучения информации, хранящейся в карте видимости, можно воспользоваться модулем
pg_visibility.
68.5. Слой инициализации
Каждая нежурналируемая таблица, и каждый индекс такой таблицы имеет файл инициализации.
Файл инициализации представляет собой пустую таблицу или индекс соответствующего типа. Ко-
гда нежурналируемая таблица должна быть заново очищена по причине сбоя, файл инициализа-
ции копируется поверх главного файла, а все прочие файлы удаляются (при необходимости они
будут автоматически созданы заново).
68.6. Компоновка страницы базы данных
В данном разделе рассматривается формат страницы, используемый в таблицах и индексах
1
PostgreSQL. Последовательности и таблицы TOAST форматируются как обычные таблицы.
В дальнейшем подразумевается, что байт содержит 8 бит. В дополнение, термин элемент отно-
сится к индивидуальному значению данных, которое хранится на странице. В таблице элемент —
это строка; в индексе — элемент индекса.
Каждая таблица и индекс хранятся как массив страниц фиксированного размера (обычно 8 kB,
хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы
1
Фактически индексные методы доступа не нуждаются в этом формате страниц. Все существующие индексные методы в действительности используют этот
основной формат, но данные, хранящиеся в индексных метастраницах обычно не следуют правилам компоновки.
2177Физическое хранение базы данных
логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой стра-
нице. В индексах первая страница обычно резервируется как метастраница, хранящая контроль-
ную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода
доступа индекса.
Таблица 68.2 показывает общую компоновку страницы. Каждая страница имеет пять частей.
Таблица 68.2. Общая компоновка страницы
Элемент Описание
Данные заголовка страницы Длина — 24 байта. Содержит общую информа-
цию о странице, включая указатели свободного
пространства.
Данные идентификаторов элементов Массив пар (смещение, длина), указывающих на
фактические элементы. Для каждого элемента
выделяется 4 байта.
Свободное пространство Незанятое пространство. Новые указатели эле-
ментов размещаются с начала этой области, са-
ми новые элементы — с конца.
Элементы Сами элементы данных как таковые.
Специальное пространство Специфические данные метода доступа. Для
различных методов хранятся различные дан-
ные. Для обычных таблиц таких данных нет.
Первые 24 байта каждой страницы образуют заголовок страницы (PageHeaderData). Его формат
подробно описан в Таблице  68.3. В первом поле отслеживается самая последняя запись в WAL,
связанная с этой страницей. Второе поле содержит контрольную сумму страницы, если включён
режим data checksums. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следуют
три двухбайтовых целочисленных поля (pd_lower, pd_upper и pd_special). Они содержат смещения
в байтах от начала страницы до начала незанятого пространства, до конца незанятого простран-
ства и до начала специального пространства. В следующих 2 байтах заголовка страницы, в поле
pd_pagesize_version, хранится размер страницы и индикатор версии. Начиная с PostgreSQL 8.3,
используется версия 4; в PostgreSQL 8.1 и 8.2 использовалась версия 3; в PostgreSQL 8.0 — версия
2; в PostgreSQL 7.3 и 7.4 — версия 1; а в предыдущих выпусках — версия 0. (Основная структура
страницы и формат заголовка почти во всех этих версиях одни и те же, но структура заголовка
строк в куче изменялась.) Размер страницы присутствует, в основном, только для перекрёстной
проверки; возможность использовать в одной инсталляции разные размеры страниц не поддержи-
вается. Последнее поле подсказывает, насколько вероятна возможность получить выигрыш, про-
изведя очистку страницы: оно отслеживает самый старый XMAX на странице, не подвергавшийся
очистке.
Таблица 68.3. Данные заголовка страницы (PageHeaderData)
Поле Тип Длина Описание
pd_lsn PageXLogRecPtr 8 байт LSN: Следующий байт
после последнего байта
записи WAL для послед-
него изменения на этой
странице
pd_checksum uint16 2 байта Контрольная
страницы
pd_flags uint16 2 байта Биты признаков
pd_lower LocationIndex 2 байта Смещение до начала
свободного простран-
ства
2178
суммаФизическое хранение базы данных
Поле Тип Длина Описание
pd_upper LocationIndex 2 байта Смещение до конца сво-
бодного пространства
pd_special LocationIndex 2 байта Смещение до нача-
ла специального про-
странства
pd_pagesize_version uint16 2 байта Информация о размере
страницы и номере вер-
сии компоновки
pd_prune_xid TransactionId 4 байта Самый старый неочи-
щенный
идентифика-
тор XMAX на страни-
це или ноль при отсут-
ствии такового
Всю подробную информацию можно найти в src/include/storage/bufpage.h.
За заголовком страницы следуют идентификаторы элемента (ItemIdData), каждому из которых
требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его
длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые иден-
тификаторы элементов размещаются по мере необходимости от начала свободного пространства.
Количество имеющихся идентификаторов элементов можно определить через значение pd_lower,
которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор эле-
мента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно исполь-
зовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам эле-
мент перемещается по странице для уплотнения свободного пространства. Фактически каждый
указатель на элемент (ItemPointer, также известный как CTID), созданный PostgreSQL, состоит из
номера страницы и индекса идентификатора элемента.
Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу неза-
нятого пространства. Точная структура меняется в зависимости от того, каким будет содер-
жание таблицы. Как таблицы, так и последовательности используют структуру под названием
HeapTupleHeaderData, которая описывается ниже.
Последний раздел является «особым разделом», который может содержать всё, что необходимо
методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева
и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные
таблицы не используют особый раздел вовсе (что указывается установкой значения pd_special
равным размеру страницы).
68.6.1. Компоновка строки таблицы
Все строки таблицы структурированы одним и тем же образом. Они включают заголовок фиксиро-
ванного размера (занимающий 23 байта на большинстве машин), за которым следует необязатель-
ная битовая карта пустых значений, необязательное поле идентификатора объекта и данные поль-
зователя. Подробное описание заголовка представлено в Таблица 68.4. Актуальные пользователь-
ские данные (столбцы строки) начинаются после смещения, заданного в t_hoff, которое должно
всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений имеет-
ся тогда, когда бит HEAP_HASNULL установлен в значении t_infomask. В случае наличия, она на-
чинается сразу после фиксированного заголовка и занимает достаточно байтов, чтобы иметь один
бит на столбец (т. е. t_natts битов всего). В этом списке битов установленный в единицу бит озна-
чает непустое значение, а установленный в ноль соответствует пустому значению. Когда битовая
карта отсутствует, все столбцы считаются непустыми. Идентификатор объекта присутствует, если
только бит HEAP_HASOID установлен в значении t_infomask. Если он есть, он расположен сразу
перед началом t_hoff. Любое заполнение, необходимое для того, чтобы сделать t_hoff кратным
MAXALIGN, будет расположено между битовой картой пустых значений и идентификатором объ-
екта. (Это в свою очередь гарантирует, что идентификатор объекта будет правильно выровнен.)
2179Физическое хранение базы данных
Таблица 68.4. Данные заголовка строки таблицы (HeapTupleHeaderData)
Поле Тип Длина Описание
t_xmin TransactionId 4 байта значение XID вставки
t_xmax TransactionId 4 байта значение XID удаления
t_cid CommandId 4 байта значение CID для встав-
ки и/или удаления (пе-
ресекается с t_xvac)
t_xvac TransactionId 4 байта XID
для
операции
VACUUM, которая пе-
ремещает версию стро-
ки
t_ctid ItemPointerData 6 байт текущее значение TID
этой или более новой
версии строки
t_infomask2 uint16 2 байта количество атрибутов
плюс различные биты
флагов
t_infomask uint16 2 байта различные биты флагов
t_hoff uint8 1 байт отступ до пользователь-
ских данных
Всю подробную информацию можно найти в src/include/access/htup_details.h.
Интерпретация текущих данных может быть проведена с помощью информации, полученной из
других таблиц, в основном из pg_attribute. Ключевые значения, необходимые для определения
расположения полей attlen и attalign. Не существует способа непосредственного получения за-
данного атрибута кроме случая, когда имеются только поля фиксированной длины, и при этом
нет пустых значений. Все эти особенности учитываются в функциях heap_getattr, fastgetattr и
heap_getsysattr.
Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь
нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений.
Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание
является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это
поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной дли-
ной имеют общую структуру заголовка struct varlena, которая включает общую длину сохранён-
ного значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут
храниться либо локально, либо в таблице TOAST. Также, возможно сжатие данных (см. Раздел 68.2).
2180</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-067/" title="Глава 67. Индексы BRIN"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 67. Индексы BRIN"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-067/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~9 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-067/" rel="bookmark" title="Глава 67. Индексы BRIN" itemprop="url">Глава 67. Индексы BRIN</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 67. Индексы BRIN</p>

<p>67.1. Введение</p>

<p>BRIN расшифровывается как «Block Range Index» (Индекс зон блоков). BRIN предназначается для
обработки очень больших таблиц, в которых определённые столбцы некоторым естественным об-
разом коррелируют с их физическим расположением в таблице. Зоной блоков называется группа
страниц, физически расположенных в таблице рядом; для каждой зоны в индексе сохраняется
некоторая сводная информация. Например, в таблице заказов магазина может содержаться поле
с датой добавления заказа, и практически всегда записи более ранних заказов и в таблице будут
размещены ближе к началу; в таблице, содержащей столбец с почтовым индексом, также есте-
ственным образом могут группироваться записи по городам.
Индексы BRIN могут удовлетворять запросы, выполняя обычное сканирование по битовой карте, и
будут возвращать все кортежи во всех страницах каждой зоны, если сводные данные, сохранённые
в индексе, соответствуют условиям запроса. Исполнитель запроса должен перепроверить эти
кортежи и отбросить те, что не соответствуют условиям запроса — другими словами, эти индексы
неточные. Так как индекс BRIN очень маленький, сканирование индекса влечёт мизерные издерж-
ки по сравнению с последовательным сканированием, но может избавить от необходимости ска-
нирования больших областей таблицы, которые определённо не содержат подходящие кортежи.
Конкретные данные, которые будут хранится в индексе BRIN, а также запросы, которые сможет
поддержать этот индекс, зависят от класса операторов, выбранного для каждого столбца индекса.
Например, типы данных с линейным порядком сортировки могут иметь классы операторов, храня-
щие минимальное и максимальное значение для каждой зоны блоков; для геометрических типов
может храниться прямоугольник, вмещающий все объекты в зоне блоков.
Размер зоны блоков определяется в момент создания индекса параметром хранения
pages_per_range. Число записей в индексе будет равняться размеру отношения в страницах, де-
лённому на установленное значение pages_per_range. Таким образом, чем меньше это число, тем
больше становится индекс (так как в нём требуется хранить больше элементов), но в то же время
сводные данные могут быть более точными и большее число блоков данных может быть пропущено
при сканировании индекса.
67.1.1. Обслуживание индекса
Во время создания индекса сканируются все существующие страницы, и в результате в индексе
создаётся сводный кортеж для каждой зоны, в том числе, возможно неполной зоны в конце. По
мере того, как данными наполняются новые страницы, если они оказываются в зонах, для которых
уже есть сводная информация, она будет обновлена с учётом данных из новых кортежей. Если же
создаётся новая страница, которая не попадает в последнюю зону, для новой зоны автоматически
не рассчитывается сводная запись; кортежи на таких страницах остаются неучтёнными, пока поз-
же не будет проведён расчёт сводных данных. Эта процедура может быть вызвана вручную, с по-
мощью функции brin_summarize_new_values(regclass), или автоматически, когда таблицу будет
обрабатывать VACUUM или при автоочистке по мере добавления записей. (Последний метод отклю-
чён по умолчанию и может быть включён параметром autosummarize.) И наоборот, можно удалить
сводное значение для зоны, вызвав функцию brin_desummarize_range(regclass, bigint), что мо-
жет быть полезно, когда этот кортеж в индексе становится не очень хорошим представлением со-
ответствующих данных, так как они изменились.
Когда включён режим автопересчёта сводки, при каждом заполнении зоны страниц механизму
автоочистки передаётся запрос для пересчёта сводки только по этой зоне, и он будет выполнен в
конце следующего прохода обработки той же базы данных. Если очередь запросов переполнена,
запрос в неё не записывается и в журнал сервера выводится соответствующее сообщение:
LOG: request for BRIN range summarization for index “brin_wi_idx” page 128 was not
recorded
2166Индексы BRIN
В этой ситуации сводка для данной зоны будет пересчитана при выполнении следующей обычной
очистки таблицы.
67.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов BRIN, перечисленные в Табли-
це 67.1.
Классы операторов minmax хранят минимальные и максимальные значения, встречающиеся в ин-
дексированном столбце в определённой зоне. Классы операторов inclusion хранят значение, в ко-
тором содержатся значения индексированного столбца в определённой зоне.
Таблица 67.1. Встроенные классы операторов BRIN
Имя Индексируемый тип данных Индексируемые операторы
abstime_minmax_ops abstime &lt; &lt;= = &gt;= &gt;
int8_minmax_ops bigint &lt; &lt;= = &gt;= &gt;
bit_minmax_ops bit &lt; &lt;= = &gt;= &gt;
varbit_minmax_ops bit varying &lt; &lt;= = &gt;= &gt;
box_inclusion_ops box « &amp;&lt; &amp;&amp; &amp;&gt; » ~= @&gt; &lt;@ &amp;&lt;| «| |</p>
<blockquote>
  <blockquote>
    <p>|&amp;&gt;
bytea_minmax_ops bytea &lt; &lt;= = &gt;= &gt;
bpchar_minmax_ops character &lt; &lt;= = &gt;= &gt;
char_minmax_ops “char” &lt; &lt;= = &gt;= &gt;
date_minmax_ops date &lt; &lt;= = &gt;= &gt;
float8<em>minmax_ops double precision &lt; &lt;= = &gt;= &gt;
inet_minmax_ops inet &lt; &lt;= = &gt;= &gt;
network_inclusion_ops inet &amp;&amp; »= «= = » «
int4_minmax_ops integer &lt; &lt;= = &gt;= &gt;
interval_minmax_ops interval &lt; &lt;= = &gt;= &gt;
macaddr_minmax_ops macaddr &lt; &lt;= = &gt;= &gt;
macaddr8_minmax_ops macaddr8 &lt; &lt;= = &gt;= &gt;
name_minmax_ops name &lt; &lt;= = &gt;= &gt;
numeric_minmax_ops numeric &lt; &lt;= = &gt;= &gt;
pg_lsn_minmax_ops pg_lsn &lt; &lt;= = &gt;= &gt;
oid_minmax_ops oid &lt; &lt;= = &gt;= &gt;
range_inclusion_ops любой тип диапазона « &amp;&lt; &amp;&amp; &amp;&gt; » @&gt; &lt;@ -|- = &lt; &lt;= =
=
float4_minmax_ops real &lt; &lt;= = &gt;= &gt;
reltime_minmax_ops reltime &lt; &lt;= = &gt;= &gt;
int2_minmax_ops smallint &lt; &lt;= = &gt;= &gt;
text_minmax_ops text &lt; &lt;= = &gt;= &gt;
tid_minmax_ops tid &lt; &lt;= = &gt;= &gt;
timestamp_minmax_ops timestamp without time zone &lt; &lt;= = &gt;= &gt;
timestamptz_minmax_ops timestamp with time zone &lt; &lt;= = &gt;= &gt;
time_minmax_ops time without time zone &lt; &lt;= = &gt;= &gt;
timetz_minmax_ops time with time zone &lt; &lt;= = &gt;= &gt;
2167Индексы BRIN
Имя Индексируемый тип данных Индексируемые операторы
uuid_minmax_ops uuid
&lt; &lt;= = &gt;= &gt;
67.3. Расширяемость
Интерфейс BRIN характеризуется высоким уровнем абстракции и таким образом требует от раз-
работчика метода доступа реализовать только смысловое наполнение обрабатываемого типа дан-
ных. Уровень BRIN берёт на себя заботу о параллельном доступе, поддержке журнала и поиске в
структуре индекса.
Всё, что нужно, чтобы получить работающий метод доступа BRIN — это реализовать несколько
пользовательских методов, определяющих поведение сводных значений, хранящихся в индексе, и
их взаимоотношения с ключами сканирования. Словом, BRIN сочетает расширяемость с универ-
сальностью, повторным использованием кода и аккуратным интерфейсом.
Класс операторов для BRIN должен предоставлять четыре метода:
BrinOpcInfo *opcInfo(Oid type_oid)
Возвращает внутреннюю информацию о сводных данных индексированных столбцов. Возвра-
щаемое значение должно указывать на BrinOpcInfo (в памяти palloc) со следующим определе-
нием:
typedef struct BrinOpcInfo
{
/* Число полей, хранящихся в столбце индекса этого класса операторов */
uint16
oi_nstored;
/* Непрозрачный указатель для внутреннего использования классом операторов */
void
*oi_opaque;
/* Элементы кеша типов для сохранённых столбцов */
TypeCacheEntry *oi_typcache[FLEXIBLE_ARRAY_MEMBER];
} BrinOpcInfo;
Поле BrinOpcInfo.oi_opaque могут использовать подпрограммы класса операторов для пере-
дачи информации опорным функциям при сканировании индекса.
bool consistent(BrinDesc *bdesc, BrinValues *column, ScanKey key)
Показывает, соответствует ли значение ScanKey заданным индексированным значениям неко-
торой зоны. Номер целевого атрибута передаётся в составе ключа сканирования.
bool addValue(BrinDesc *bdesc, BrinValues *column, Datum newval, bool isnull)
Для заданного кортежа индекса и индексируемого значения изменяет выбранный атрибут кор-
тежа, чтобы он дополнительно охватывал новое значение. Если в кортеж вносятся какие-либо
изменения, возвращается true.
bool unionTuples(BrinDesc *bdesc, BrinValues *a, BrinValues *b)
Консолидирует два кортежа индекса. Получая два кортежа, изменяет выбранный атрибут пер-
вого из них, что он охватывал оба кортежа. Второй кортеж не изменяется.
Основной дистрибутив включает поддержку двух типов классов операторов: minmax и inclusion.
Определения классов операторов, использующие их, представлены для встроенных типов данных,
насколько это уместно. Пользователь может определить дополнительные классы операторов для
других типов данных, применяя аналогичные определения, обойдясь без написания исходного ко-
да; достаточно будет объявить нужные записи в каталоге. Заметьте, что предположения о семан-
тике стратегий операторов зашиты в исходном коде опорных функций.
Также возможно создать классы операторов, воплощающие полностью другую семантику, разра-
ботав реализации четырёх основных опорных функций, описанных выше. Заметьте, что обратная
2168Индексы BRIN
совместимость между разными основными версиями не гарантируется: к примеру, в следующих
выпусках могут потребоваться дополнительные опорные функции.
При написании класса операторов для типа данных, представляющего полностью упорядоченное
множество, можно использовать опорные функции minmax вместе с соответствующими операто-
рами, как показано в Таблице 67.2. Все члены класса операторов (функции и операторы) являются
обязательными.
Таблица 67.2. Номера стратегий и опорных функций для классов операторов Minmax
Член класса операторов Объект
Опорная функция 1 внутренняя функция brin_minmax_opcinfo()
Опорная функция 2 внутренняя
value()
Опорная функция 3 внутренняя
consistent()
Опорная функция 4 внутренняя функция brin_minmax_union()
Стратегия оператора 1 оператор меньше
Стратегия оператора 2 оператор меньше-или-равно
Стратегия оператора 3 оператор равно
Стратегия оператора 4 оператор больше-или-равно
Стратегия оператора 5 оператор больше
функция
brin_minmax_add</em>
функция
brin_minmax_
При написании класса операторов для сложного типа данных, значения которого включаются в
другой тип, можно использовать опорные функции inclusion вместе с соответствующими операто-
рами, как показано в Таблице 67.3. Для этого требуется одна дополнительная функция, которую
можно написать на любом языке. Для расширенной функциональности можно определить другие
функции. Все операторы являются необязательными. Некоторые из них требует наличия других,
что показано в таблице как зависимости.
Таблица 67.3. Номера стратегий и опорных функций для классов операторов Inclusion
Член класса операторов Объект
Зависимость
Опорная функция 1 внутренняя
функция
inclusion_opcinfo()
brin_
Опорная функция 2 внутренняя
функция
inclusion_add_value()
brin_
Опорная функция 3 внутренняя
функция
brin_
inclusion_consistent()
Опорная функция 4 внутренняя
функция
inclusion_union()
Опорная функция 11 функция для слияния двух эле-
ментов
Опорная функция 12 необязательная функция для
проверки возможности слияния
двух элементов
Опорная функция 13 необязательная функция для
проверки, содержится ли один
элемент в другом
Опорная функция 14 необязательная функция для
проверки, является ли элемент
пустым
2169
brin_Индексы BRIN
Член класса операторов Объект Зависимость
Стратегия оператора 1 оператор левее Стратегия оператора 4
Стратегия оператора 2 оператор не-простирается-пра- Стратегия оператора 5
вее
Стратегия оператора 3 оператор перекрывается Стратегия оператора 4 оператор
вее Стратегия оператора 5 оператор правее Стратегия оператора 2
Стратегия оператора 6, 18 оператор то-же-или-равно Стратегия оператора 7
не-простирается-ле- Стратегия оператора 1
Стратегия оператора 7, 13, 16, оператор содержит-или-равно
24, 25
Стратегия оператора 8, 14, 26, оператор
27
равно
содержится-в-или- Стратегия оператора 3
Стратегия оператора 9 оператор
ше
не-простирается-вы- Стратегия оператора 11
Стратегия оператора 10 оператор ниже Стратегия оператора 12
Стратегия оператора 11 оператор выше Стратегия оператора 9
Стратегия оператора 12 оператор
же Стратегия оператора 20 оператор меньше Стратегия оператора 5
Стратегия оператора 21 оператор меньше-или-равно Стратегия оператора 5
Стратегия оператора 22 оператор больше Стратегия оператора 1
Стратегия оператора 23 оператор больше-или-равно Стратегия оператора 1
не-простирается-ни- Стратегия оператора 10
Номера опорных функций 1-10 зарезервированы для внутренних функций BRIN, так что функции
уровня SQL начинаются с номера 11. Опорная функция номер 11 является основной, необходимой
для построения индекса. Она должна принимать два аргумента того же типа данных, что и целе-
вой тип класса, и возвращать их объединение. Класс операторов inclusion может сохранять значе-
ния объединения в различных типах данных, в зависимости от параметра STORAGE. Возвращаемое
значение функции объединения должно соответствовать типу данных STORAGE.
Опорные функции под номерами 12 и 14 предоставляются для поддержки нерегулярностей встро-
енных типов данных. Функция номер 12 применяется для поддержки работы с сетевыми адресами
из различных семейств, которые нельзя объединять. Функция номер 14 применяется для поддерж-
ки зон с пустыми значениями. Функция номер 13 является необязательной, но рекомендуемой; она
проверяет новое значение, прежде чем оно будет передано функции объединения. Инфраструкту-
ра BRIN может соптимизировать некоторые операции, когда объединение не меняется, поэтому
применение этой функции может способствовать увеличению быстродействия индекса.
Классы операторов minmax и inclusion поддерживают операторы с разными типами, хотя с ними
зависимости становятся более сложными. Класс minmax требует, чтобы для двух аргументов одно-
го типа определялся полный набор операторов. Это позволяет поддерживать дополнительные ти-
пы данных, определяя дополнительные наборы операторов. Стратегии операторов класса inclusion
могут зависеть от других стратегий, как показано в Таблице 67.3, или от своих собственных стра-
тегий. Для них требуется, чтобы был определён необходимый оператор с типом данных STORAGE
для левого аргумента и другим поддерживаемым типом для правого аргумента реализуемого опе-
ратора. См. определение float4_minmax_ops в качестве примера для minmax и box_inclusion_ops
в качестве примера для inclusion.
2170</p>
  </blockquote>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page3/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page2/">2</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page3/">3</a></li>
      
    
      
        <li><strong class="current-page">4</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page5/">5</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page6/">6</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page5/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>