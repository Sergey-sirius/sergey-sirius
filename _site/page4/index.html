<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page4/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page4/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-070/" title="Глава 70. Как планировщик использует статистику"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 70. Как планировщик использует статистику"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-070/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-070/" rel="bookmark" title="Глава 70. Как планировщик использует статистику" itemprop="url">Глава 70. Как планировщик использует статистику</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 70. Как планировщик использует статистику</p>

<p>Данная глава основана на материалах, рассмотренных ранее (см. Раздел 14.1 и Раздел 14.2), и по-
дробнее рассказывает о том, как планировщик использует статистику для определения количества
строк, которое может вернуть каждая часть запроса. Это важная составляющая процесса создания
плана запроса, предоставляющая большую часть исходного материала для расчёта стоимости.
Целью данной главы является не подробное документирование кода, а общее описание его работы.
Возможно, это поможет тем, кто пожелает в дальнейшем ознакомиться с кодом.
70.1. Примеры оценки количества строк
В приведённых ниже примерах используются таблицы базы данных регрессионного тестирования
PostgreSQL. Приведённые листинги получены в версии 8.3. Поведение более ранних (или поздних)
версий может отличаться. Заметьте также, что поскольку команда ANALYZE использует случайную
выборку при формировании статистики, после любого нового выполнения команды ANALYZE ре-
зультаты незначительно изменятся.
Давайте начнём с очень простого запроса:
EXPLAIN SELECT * FROM tenk1;
QUERY PLAN
————————————————————-
Seq Scan on tenk1 (cost=0.00..458.00 rows=10000 width=244)
Как планировщик определяет мощность tenk1, рассматривается выше (см. Раздел  14.2), но для
полноты здесь говорится об этом ещё раз. Количество страниц и строк берётся в pg_class:
SELECT relpages, reltuples FROM pg_class WHERE relname = ‘tenk1’;
relpages | reltuples
———-+———–
358 |
10000
Это текущие цифры, полученные при последнем выполнении команд VACUUM или ANALYZE, при-
менённых к этой таблице. Затем планировщик выполняет выборку фактического текущего числа
страниц в таблице (это недорогая операция, для которой не требуется сканирование таблицы). Ес-
ли оно отличается от relpages, то reltuples изменяется для того, чтобы привести это значение
к текущей оценке количества строк. В показанном выше примере значение relpages является ак-
туальным, поэтому количество строк берётся равным reltuples.
Давайте обратимся к примеру с диапазонным условием в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;
QUERY PLAN
——————————————————————————–
Bitmap Heap Scan on tenk1 (cost=24.06..394.64 rows=1007 width=244)
Recheck Cond: (unique1 &lt; 1000)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..23.80 rows=1007 width=0)
Index Cond: (unique1 &lt; 1000)
Планировщик рассматривает условие предложения WHERE и находит в справочнике функцию из-
бирательности для оператора &lt; в pg_operator. Это значение содержится в столбце oprrest, и в
данном случае значением является scalarltsel. Функция scalarltsel извлекает гистограмму для
unique1 из pg_statistic. Для вводимых вручную запросов удобнее просматривать более простое
представление pg_stats:
2189Как планировщик ис-
пользует статистику
SELECT histogram_bounds FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’unique1’;
histogram_bounds
——————————————————
{0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}
Затем обрабатывается часть гистограммы, которая соответствует условию «&lt; 1000». Таким обра-
зом и определяется избирательность. Гистограмма делит диапазон на равные частотные группы,
поэтому нужно лишь определить группу, содержащую наше значение, и подсчитать её долю и
долю групп, предшествующих данной. Очевидно, что значение 1000 находится во второй группе
(993-1997). Если предположить, что внутри каждой группы распределение значений линейное, мы
можем вычислить избирательность следующим образом:
selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets
= (1 + (1000 - 993)/(1997 - 993))/10
= 0.100697
т. е. сумма элементов одной целой группы и пропорциональной части элементов второй, делённая
на число групп. Теперь примерное число строк может быть рассчитано как произведение избира-
тельности и мощности tenk1:
rows = rel_cardinality * selectivity
= 10000 * 0.100697
= 1007 (округлённо)
Далее, давайте рассмотрим пример с условием на равенство в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = ‘CRAAAA’;
QUERY PLAN
———————————————————-
Seq Scan on tenk1 (cost=0.00..483.00 rows=30 width=244)
Filter: (stringu1 = ‘CRAAAA’::name)
Планировщик вновь проверяет условие в предложении WHERE и определяет функцию избиратель-
ности для =, и этой функцией является eqsel. Для оценки равенства гистограмма бесполезна, вме-
сто неё для оценки избирательности используется список наиболее распространённых значений
(Most Commom Values, MCV). Давайте рассмотрим MCV и соответствующие дополнительные столб-
цы, которые пригодятся позже:
SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’stringu1’;
null_frac
| 0
n_distinct
| 676
most_common_vals |
{EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}
most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}
Так как значение CRAAAA оказалось в списке MCV, избирательность будет определяться просто
соответствующим элементом в списке частот наиболее распространённых значений (Most Common
Frequencies, MCF):
selectivity = mcf[3]
= 0.003
Как и в предыдущем примере, оценка числа строк берётся как произведение мощности и избира-
тельности tenk1:
rows = 10000 * 0.003
= 30
Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке MCV:
2190Как планировщик ис-
пользует статистику
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = ‘xxx’;
QUERY PLAN
———————————————————-
Seq Scan on tenk1 (cost=0.00..483.00 rows=15 width=244)
Filter: (stringu1 = ‘xxx’::name)
Это совершенно другая задача — как оценить избирательность значения, которого нет в списке
MCV. При её решении используется факт отсутствия данного значения в списке в сочетании с
частотой для каждого значения из списка MCV.
selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)
= (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +
0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)
= 0.0014559
Т. е. нужно сложить частоты значений из списка MCV, отнять полученное число от единицы, и
полученное значение разделить на количество остальных уникальных значений. Эти вычисления
основаны на предположении, что значения, которые не входят в список MCV, имеют равномерное
распределение. Заметьте, что в данном примере нет неопределённых значений, поэтому о них
беспокоиться не нужно (иначе их долю также пришлось бы вычитать из числителя). Оценка числа
строк затем производится как обычно:
rows = 10000 * 0.0014559
= 15 (округлённо)
Предыдущий пример с unique1 &lt; 1000 был большим упрощением того, что в действительности
делает scalarltsel. Но после того, как мы увидели пример использования списка MCV, мы можем
внести некоторые дополнения. Что касается самого примера, в нём все было правильно, поскольку
unique1 это уникальный столбец, у него нет значений в списке MCV (очевидно, в данном случае
нет значения, которое является более распространённым, чем любое другое). Для неуникального
столбца обычно создаётся как гистограмма, так и список MCV, при этом гистограмма не включает
значения, представленные в списке MCV. Данный способ позволяет выполнить более точный под-
счёт. В этой ситуации scalarltsel напрямую применяет условие «&lt; 1000» к каждому значению
списка MCV и суммирует частоты значений MCV, для которых условие является верным. Это даёт
точную оценку избирательности для той части таблицы, которая содержит значения из списка
MCV. Подобным же образом используется гистограмма для оценки избирательности для той части
таблицы, которая не содержит значения из списка MCV, а затем эти две цифры складываются для
оценки общей избирательности. Например, рассмотрим
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; ‘IAAAAA’;
QUERY PLAN
————————————————————
Seq Scan on tenk1 (cost=0.00..483.00 rows=3077 width=244)
Filter: (stringu1 &lt; ‘IAAAAA’::name)
Мы уже видели данные списка MCV для stringu1, а это его гистограмма:
SELECT histogram_bounds FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’stringu1’;
histogram_bounds
——————————————————————————–
{AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}
Проверяя список MCV, находим, что условие stringu1 &lt; ‘IAAAAA’ соответствует первым шести
записям, но не соответствует последним четырём, поэтому избирательность для значений, соот-
ветствующих значениям в списке MCV, такова:
selectivity = sum(relevant mvfs)
= 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003
= 0.01833333
2191Как планировщик ис-
пользует статистику
Сумма всех частот из списка MCF также сообщает нам, что общая часть представленной списком
MCV совокупности записей равняется 0.03033333, и поэтому представленная гистограммой часть
равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе их пришлось бы
также исключить). Видно, что значение IAAAAA попадает почти в конец третьего столбца гисто-
граммы. Основываясь на простых предположениях относительно частоты различных символов,
планировщик получает число 0.298387 для части значений, представленных в гистограмме, кото-
рые меньше чем IAAAAA. Затем объединяем оценки части значений из списка MCV и значений, не
содержащихся в нём:
selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction
= 0.01833333 + 0.298387 * 0.96966667
= 0.307669
rows
= 10000 * 0.307669
= 3077 (округлённо)
В этом конкретном примере, корректировка со стороны списка MCV достаточно мала, потому что
распределение значений столбца довольно плоское (статистика, показывающая конкретные зна-
чения как более распространённые, чаще всего получается вследствие статистической погреш-
ности). В более типичном случае, когда некоторые значения являются значительно более распро-
странёнными по сравнению с другими, этот более сложный метод повышает точность вследствие
точного определения избирательности наиболее распространённых значений.
Теперь давайте рассмотрим случай с более чем одним условием в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = ‘xxx’;
QUERY PLAN
——————————————————————————–
Bitmap Heap Scan on tenk1 (cost=23.80..396.91 rows=1 width=244)
Recheck Cond: (unique1 &lt; 1000)
Filter: (stringu1 = ‘xxx’::name)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..23.80 rows=1007 width=0)
Index Cond: (unique1 &lt; 1000)
Планировщик исходит из того, что два условия независимы, таким образом, отдельные значения
избирательности можно перемножить:
selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = ‘xxx’)
= 0.100697 * 0.0014559
= 0.0001466
rows
= 10000 * 0.0001466
= 1 (округлённо)
Заметьте, что число строк, которые предполагается вернуть через сканирование битового индекса,
соответствует условию, используемому при работе индекса; это важно, так как влияет на оценку
стоимости для последующих выборок из таблицы.
В заключение исследуем запрос, выполняющий соединение:
EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;
QUERY PLAN
————————————————————————————–
Nested Loop (cost=4.64..456.23 rows=50 width=488)
-&gt; Bitmap Heap Scan on tenk1 t1 (cost=4.64..142.17 rows=50 width=244)
Recheck Cond: (unique1 &lt; 50)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..4.63 rows=50 width=0)
Index Cond: (unique1 &lt; 50)
-&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.00..6.27 rows=1 width=244)
2192Как планировщик ис-
пользует статистику
Index Cond: (unique2 = t1.unique2)
Ограничение, накладываемое на tenk1, unique1 &lt; 50, производится до соединения вложенным
циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным условием. На этот
раз значение 50 попадает в первый столбец гистограммы unique1:
selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets
= (0 + (50 - 0)/(993 - 0))/10
= 0.005035
rows
= 10000 * 0.005035
= 50 (округлённо)
Ограничение для соединения следующее t2.unique2 = t1.unique2. Здесь используется уже из-
вестный нам оператор =, однако функцию избирательности получаем из столбца oprjoin представ-
ления pg_operator, и эта функция — eqjoinsel. Функция eqjoinsel находит статистические дан-
ные как для tenk2, так и для tenk1:
SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats
WHERE tablename IN (‘tenk1’, ‘tenk2’) AND attname=’unique2’;
tablename | null_frac | n_distinct | most_common_vals
———–+———–+————+——————
tenk1
|
0 |
-1 |
tenk2
|
0 |
-1 |
В этом случае нет данных MCV для unique2, потому что все значения будут уникальными. Таким
образом, используется алгоритм, зависящий только от числа различающихся значений для обеих
таблиц и от данных с неопределёнными значениями:
selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/
num_distinct2)
= (1 - 0) * (1 - 0) / max(10000, 10000)
= 0.0001
Т. е., вычитаем долю неопределённых значений из единицы для каждой таблицы и делим на мак-
симальное из чисел различающихся значений. Количество строк, которое соединение, вероятно,
сгенерирует, вычисляется как мощность декартова произведения двух входных значений, умно-
женная на избирательность:
rows = (outer_cardinality * inner_cardinality) * selectivity
= (50 * 10000) * 0.0001
= 50
Если бы имелись списки MCV для двух столбцов, функцией eqjoinsel использовалось бы прямое
сравнение со списками MCV для определения общей избирательности той части данных, которая
содержит значения списка MCV. Оценка остальной части данных при этом выполнялась бы пред-
ставленным выше способом.
Заметьте, что здесь выводится для inner_cardinality значение 10000, то есть исходный размер
tenk2. Если изучить вывод EXPLAIN, может показаться, что оценка количества строк вычисляется
как 50 * 1, то есть число внешних строк умножается на ориентировочное число строк, получаемых
при каждом внутреннем сканировании индекса в tenk2. Но это не так, ведь размер результата
соединения оценивается до того, как выбирается конкретный план соединения. Если всё работает
корректно, оба варианта вычисления этого размера должны давать один и тот же ответ, но из-за
ошибок округления и других факторов иногда они значительно различаются.
Для интересующихся более подробной информацией: оценка размера таблицы (до выполнения
условий в предложении WHERE) реализована в файле src/backend/optimizer/util/plancat.c.
Основная логика для вычисления избирательности предложений находится в src/backend/
optimizer/path/clausesel.c. Специфичные для отдельных операторов функции избирательности,
в основном, расположены в src/backend/utils/adt/selfuncs.c.
2193Как планировщик ис-
пользует статистику
70.2. Примеры многовариантной статистики
70.2.1. Функциональные зависимости
Многовариантную корреляцию можно продемонстрировать на очень простом наборе данных —
таблице с двумя столбцами, содержащими одинаковые значения:
CREATE TABLE t (a INT, b INT);
INSERT INTO t SELECT i % 100, i % 100 FROM generate_series(1, 10000) s(i);
ANALYZE t;
Как рассказывается в Разделе 14.2, планировщик может определить мощность t, исходя из числа
страниц и строк, полученного из pg_class:
SELECT relpages, reltuples FROM pg_class WHERE relname = ‘t’;
relpages | reltuples
———-+———–
45 |
10000
Распределение данных очень простое: в каждом столбце содержится всего 100 различных значе-
ний, равномерно распределённых.
Следующий пример показывает результат оценивания условия WHERE по столбцу a:
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1;
QUERY PLAN
——————————————————————————-
Seq Scan on t (cost=0.00..170.00 rows=100 width=8) (actual rows=100 loops=1)
Filter: (a = 1)
Rows Removed by Filter: 9900
Планировщик рассматривает условие и определяет, что его избирательность равна 1%. Сравнивая
эту оценку и фактическое число строк, мы видим, что оценка очень точна (на самом деле абсолют-
на точна, так как таблица очень маленькая). Если изменить условие WHERE, чтобы использовался
столбец b, будет получен такой же план. Но посмотрите, что получится, если мы применим оди-
наковое условие к двум столбцам, объединив их оператором AND:
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;
QUERY PLAN
—————————————————————————–
Seq Scan on t (cost=0.00..195.00 rows=1 width=8) (actual rows=100 loops=1)
Filter: ((a = 1) AND (b = 1))
Rows Removed by Filter: 9900
Планировщик оценивает избирательность каждого условия индивидуально, и получает ту же оцен-
ку в 1%, что и выше. Затем он предполагает, что условия независимы, так что он перемножает
избирательности и выдаёт окончательную оценку избирательности, равную всего 0.01%. Это зна-
чительная недооценка, так как фактическое число строк, соответствующих условию, (100) на два
порядка больше.
Эту проблему можно решить, создав объект статистики, который укажет команде ANALYZE вычис-
лить многовариантную статистику функциональной зависимости по двум столбцам:
CREATE STATISTICS stts (dependencies) ON a, b FROM t;
ANALYZE t;
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;
QUERY PLAN
——————————————————————————-
Seq Scan on t (cost=0.00..195.00 rows=100 width=8) (actual rows=100 loops=1)
Filter: ((a = 1) AND (b = 1))
Rows Removed by Filter: 9900
2194Как планировщик ис-
пользует статистику
70.2.2. Многовариантное число различных значений
Подобная проблема возникает с оценкой мощности наборов с несколькими столбцами, например,
с оценкой числа групп, которые могут быть выданы предложением GROUP BY. Когда в GROUP BY
указан один столбец, оценка числа различных значений (которую можно увидеть как ожидаемое
число строк, выдаваемое узлом HashAggregate) очень точная:
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(<em>) FROM t GROUP BY a;
QUERY PLAN
—————————————————————————————–
HashAggregate (cost=195.00..196.00 rows=100 width=12) (actual rows=100 loops=1)
Group Key: a
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=4) (actual rows=10000
loops=1)
Но оценка числа групп в запросе с двумя столбцами в GROUP BY без многовариантной статистики,
как и в предыдущем примере, отличается от правильной на порядок:
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(</em>) FROM t GROUP BY a, b;
QUERY PLAN
——————————————————————————————–
HashAggregate (cost=220.00..230.00 rows=1000 width=16) (actual rows=100 loops=1)
Group Key: a, b
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000
loops=1)
Если переопределить объект статистики, чтобы он включал подсчёт числа различных значений
для двух столбцов, оценка станет гораздо лучше:
DROP STATISTICS stts;
CREATE STATISTICS stts (dependencies, ndistinct) ON a, b FROM t;
ANALYZE t;
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;
QUERY PLAN
——————————————————————————————–
HashAggregate (cost=220.00..221.00 rows=100 width=16) (actual rows=100 loops=1)
Group Key: a, b
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000
loops=1)
70.3. Статистика планировщика и безопасность
Доступ к таблице pg_statistic разрешён только суперпользователям, так что обычные пользо-
ватели не могут получить из неё сведения о содержимом таблиц других пользователей. Но неко-
торые функции оценки избирательности будут использовать пользовательский оператор (опера-
тор, фигурирующий в запросе, или связанный) для анализа сохранённой статистики. Например,
чтобы определить применимость сохранённого самого частого значения, функция оценки избира-
тельности должна задействовать соответствующий оператор = для сравнения константы в запро-
се с этим сохранённым значением. Таким образом, данные pg_statistic в принципе могут пере-
даваться пользовательским операторам. А особым образом сконструированный оператор может
выводить наружу передаваемые ему операнды преднамеренно (например, записывая их в журнал
или помещая в другую таблицу) либо непреднамеренно (показывая их значения в сообщениях об
ошибках). В любом случае это даёт возможность пользователю, не имеющему доступа к таблице
pg_statistic, увидеть содержащиеся в ней данные.
Для предотвращения этого все встроенные функции оценки избирательности действуют по следу-
ющим правилам. Чтобы сохранённая статистика могла использоваться при планировании запроса,
текущий пользователь должен иметь либо право SELECT для таблицы или задействованных столб-
2195Как планировщик ис-
пользует статистику
цов, либо у оператора должна быть характеристика LEAKPROOF (точнее, она должна быть у функции,
реализующей этот оператор). В противном случае оценка избирательности будет осуществляться
так, как если бы статистики не было вовсе, и планировщик продолжит работу с общими или вто-
ричными предположениями.
Если пользователь не имеет требуемого права доступа к таблице или столбцам, то во многих слу-
чаях при выполнении запроса в конце концов возникнет ошибка «нет доступа», так что этот меха-
низм будет незаметен на практике. Но если пользователь читает данные из представления с ба-
рьером безопасности, планировщик может захотеть проверить статистику нижележащей таблицы,
которая недоступна пользователю непосредственно. В этом случае оператор должен быть герме-
тичным; иначе статистика не будет использоваться. Это не будет иметь внешних проявлений кро-
ме того, что план запроса может быть неоптимальным. В случае подозрений, что вы столкнулись с
этим, попробуйте запустить запрос от имени пользователя с расширенными правами и проверьте,
не выбирается ли другой план запроса.
Это ограничение применяется только тогда, когда планировщику может потребоваться выполнить
пользовательский оператор с одним или несколькими значениями из pg_statistic. При этом пла-
нировщику разрешено использовать общую статистическую информацию, например, процент зна-
чений NULL или количество различных значений в столбце, вне зависимости от прав доступа.
Реализуемые в дополнительных расширениях функции оценки избирательности, которые могут
обращаться к статистике, вызывая пользовательские операторы, должны следовать тем же прави-
лам безопасности. За практическими указаниями обратитесь к исходному коду PostgreSQL.
2196</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-069/" title="Глава 69. Объявление и начальное содержимое системных каталогов"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 69. Объявление и начальное содержимое системных каталогов"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-069/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~17 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-069/" rel="bookmark" title="Глава 69. Объявление и начальное содержимое системных каталогов" itemprop="url">Глава 69. Объявление и начальное содержимое системных каталогов</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 69. Объявление и начальное содержимое системных каталогов</p>

<p>В PostgreSQL используется множество разных системных каталогов для учёта информации о су-
ществовании и свойствах объектов базы, например, таблиц и функций. Физически системный ка-
талог не отличается от простой таблицы, но серверный код на C знает структуру и характеристики
каждого каталога и может работать с ним на низком уровне. Поэтому, например, не стоит пытать-
ся изменять структуру каталога «на лету»; это нарушит встроенные в код предположения о том,
как располагаются строки в каталоге. Однако структура каталога может меняться при переходе
с одной основной версии на другую.
Структуры каталогов объявляются в специально оформленных заголовочных файлах C в каталоге
src/include/catalog/ дерева исходного кода. В частности, для каждого каталога имеется заголо-
вочный файл, названный по имени каталога (например, pg_class.h для pg_class) и определяющий
набор столбцов в этом каталоге, а также другие основные свойства, например, его OID. К другим
важным файлам, задающим структуру каталога, относится indexing.h, определяющий, какие ин-
дексы присутствуют во всех системных каталогах, и toasting.h, определяющий таблицы TOAST
для каталогов, которым они нужны.
Со многими каталогами связаны исходные данные, которые должны быть загружены в них на ста-
дии «начальной загрузки» initdb, чтобы система оказалась в состоянии, когда она сможет выпол-
нять команды SQL. (Например, pg_class.h должен содержать запись, ссылающуюся на этот же
каталог, и перечисление всех остальных системных каталогов и индексов.) Эти исходные данные
задаются в редактируемой форме в файлах, которые также находятся в каталоге src/include/
catalog/. Например, в pg_proc.dat описываются все исходные строки, которые должны быть
вставлены в каталог pg_proc.
Чтобы создать файлы каталогов и загрузить в них эти исходные данные, серверный процесс, рабо-
тающий в режиме начальной загрузки, считывает файл BKI (Backend Interface, Серверный интер-
фейс), содержащий команды и исходные данные. Файл postgres.bki, используемый в этом режи-
ме, конструируется из вышеупомянутых заголовочных файлов и файлов данных при сборке дис-
трибутива PostgreSQL Perl-скриптом genbki.pl. Хотя postgres.bki привязан к определённому вы-
пуску PostgreSQL, он является платформонезависимым и устанавливается в подкаталог share де-
рева инсталляции.
Скрипт genbki.pl также генерирует производный заголовочный файл для каждого каталога, на-
пример pg_class_d.h для каталога pg_class. Этот файл содержит автоматически генерируемые
макроопределения и может содержать другие макросы, определения перечислений и т. п., кото-
рые могут быть полезны для клиентского кода, читающего определённый каталог.
Большинству разработчиков Postgres нет необходимости иметь дело непосредственно с файлом
BKI, но для практически любой нетривиальной доработки потребуется модификация заголовочных
файлов и/или файлов с исходными данными каталога. В продолжении этой главы рассказывается
об этом, а также для полноты описывается формат файла BKI.
69.1. Правила объявления системных каталогов
Ключевой частью заголовочного файла каталога является описание структуры на C, определяю-
щее вид каждой строки каталога. Оно начинается с макроса CATALOG, который, если говорить о
компиляторе C, является просто сокращённой записью typedef struct FormData_имя_каталога.
Каждое поле в этой структуре порождает столбец каталога. Поля можно дополнить макросами
свойств BKI, объявленными в genbki.h. Например, для поля можно задать значение по умолчанию
или указать, допускается ли в нём NULL. Строку CATALOG можно также дополнить некоторыми
другими макросами свойств BKI, объявленными в genbki.h и определяющими другие свойства ка-
талога в целом, например, содержит ли он OID (по умолчанию каталоги содержат OID).
Код кеша системного каталога (и в принципе почти весь код, манипулирующий каталогом) предпо-
лагает, что имеющие постоянный размер части всех кортежей системных каталогов присутствуют
2181Объявление и начальное содер-
жимое системных каталогов
фактически, так как он отображает на них объявления структуры на C. Таким образом, все поля пе-
ременной длины и поля, принимающие NULL, должны располагаться в конце, и обращаться к ним
как к полям структуры нельзя. Например, если присвоить полю pg_type.typrelid значение NULL,
обращение в каком-либо месте кода к typetup-&gt;typrelid (или, что ещё хуже, к полю typetup-</p>
<blockquote>
  <p>typelem, следующему за typrelid) будет некорректным. Это приведёт к случайным ошибкам или
даже нарушениям сегментации.
В качестве частичной защиты от ошибок такого типа поля переменной длины или поля, прини-
мающие NULL, следует скрыть от компилятора C. Это реализуется посредством обёртки #ifdef
CATALOG_VARLEN … #endif (где CATALOG_VARLEN — символ, который всегда будет неопределённым).
Это не позволяет коду на C беспрепятственно обращаться к полям, которые могут отсутствовать
или располагаться по некоторому другому смещению. В качестве дополнительной меры, препят-
ствующей созданию некорректных строк, мы требуем, чтобы все столбцы, которые не должны
принимать NULL, помечались соответствующим образом в pg_attribute. Код начальной загруз-
ки автоматически пометит столбцы каталога как NOT NULL, если они имеют фиксированную дли-
ну и перед ними нет столбцов, принимающих NULL. Там, где это правило применяется некор-
ректно, можно исправить пометку, добавив дополнительные указания BKI_FORCE_NOT_NULL или
BKI_FORCE_NULL. Но заметьте, что ограничения NOT NULL контролируются только исполнителем
запросов; на уровне кода C они не действуют, поэтому создавать или изменять строки каталога
вручную нужно так же аккуратно.
Код клиентской части не должен включать никакие заголовочные файлы каталогов pg_xxx.h, так
как эти файлы могут содержать код на C, который не будет компилироваться вне кода сервера.
(Обычно это происходит из-за того, что эти файлы также содержат объявления функций в файлах
src/backend/catalog/.) Вместо этого клиентский код может включить соответствующий сгенери-
рованный заголовок pg_xxx_d.h с определениями различных OID и другими данными, которые
могут быть полезны на стороне клиента. Если вам нужно, чтобы макросы или другой код в заго-
ловочных файлах каталогов были видимы в клиентском коде, заключите соответствущую секцию
в условие #ifdef EXPOSE_TO_CLIENT_CODE … #endif, чтобы genbki.pl скопировал эту секцию в за-
головок pg_xxx_d.h.
Некоторые каталоги настолько основополагающие, что их нельзя создать даже командой BKI
create, которая используется для большинства каталогов, так как эта команда должна записать
информацию, описывающую новый каталог, в эти базовые каталоги. Они называются каталогами
начальной загрузки и для определения их требуется много дополнительные действий: вы долж-
ны вручную подготовить соответствующие записи для них в предварительно загружаемых данных
pg_class и pg_type, и эти записи потребуется модифицировать при последующих изменениях в
структуре каталога. (Каталогам начальной загрузки также нужны предварительно загруженные
записи в pg_attribute, но, к счастью, сейчас с этим управляется скрипт genbki.pl.) По возмож-
ности избегайте включения новых каталогов в категорию каталогов начальной загрузки.
69.2. Исходные данные системных каталогов
Для каждого каталога, с которым связаны вручную создаваемые исходные данные, (не все катало-
ги такие) имеется соответствующий файл .dat, содержащий эти данные в редактируемом формате.
69.2.1. Формат файла данных
Каждый файл .dat содержит описания структур данных Perl, в результате вычисления которых
(функцией eval) в памяти формируется структура данных, состоящая из массива хеш-ссылок, соот-
ветствующих каждой строке каталога. Немного модифицированная выдержка из pg_database.dat
иллюстрирует основные моменты:
[</p>
  <h1 id="Здесь-мог-быть-комментарий">Здесь мог быть комментарий.</h1>
  <p>{ oid =&gt; ‘1’, oid_symbol =&gt; ‘TemplateDbOid’,
descr =&gt; ‘database's default template’,
datname =&gt; ‘template1’, datdba =&gt; ‘PGUID’, encoding =&gt; ‘ENCODING’,
2182Объявление и начальное содер-
жимое системных каталогов
datcollate =&gt; ‘LC_COLLATE’, datctype =&gt; ‘LC_CTYPE’, datistemplate =&gt; ‘t’,
datallowconn =&gt; ‘t’, datconnlimit =&gt; ‘-1’, datlastsysoid =&gt; ‘0’,
datfrozenxid =&gt; ‘0’, datminmxid =&gt; ‘1’, dattablespace =&gt; ‘1663’,
datacl =&gt; ‘<em>null</em>’ },
]
Замечания:
• Общий формат файла: открывающая квадратная скобка, один или более наборов фигурных
скобок, каждый из которых представляет строку каталога, и закрывающая квадратная скобка.
После каждой закрывающей фигурной скобки должна идти запятая.
• В каждой строке каталога записываются разделённые запятыми пары ключ =&gt; значение.
В качестве ключа принимаются имена столбцов каталога, а также ключи метаданных oid,
oid_symbol и descr. (Использование oid и oid_symbol описывается в Подразделе 69.2.2. В
descr задаётся строка с описанием объекта, которое будет вставлено в pg_description или
pg_shdescription.) Ключи метаданных могут опускаться, но ключ для каждого столбца ката-
лога должен присутствовать, если только в файле .h данного каталога для столбца не задано
значение по умолчанию.
• Все значения должны заключаться в апострофы. Апострофы внутри значений экранируют-
ся обратной косой чертой. Обратные косые черты в данных могут, но не обязательно должны
дублироваться; это соответствует правилам Perl по оформлению простых строковых констант.
Заметьте, что обратные косые черты, фигурирующие в данных, будут обрабатываться скане-
ром исходных данных как символы экранирования, согласно тем же правилам записи строко-
вых констант (см. Подраздел 4.1.2.2); например, \t преобразуется в символ табуляции. Если
вы хотите получить именно обратную косую черту в окончательном значении, вам надо будет
написать четыре этих символа: Perl отбрасывает два и оставляет \ сканеру исходных данных.
• Значения NULL представляются как <em>null</em>. (Заметьте, что создать значение с именно такой
строкой невозможно.)
• Комментарии предваряются знаком # и должны размещаться в отдельных строках.
• Для большей наглядности значения полей, выражающие OID других записей каталога, могут
быть представлены именами, а не только числовыми кодами OID. Об этом рассказывается в
Подразделе 69.2.3.
• Так как хеши являются неупорядоченной структурой данных, порядок полей и расположе-
ние строк не имеют семантической значимости. Однако для поддержания согласованного
представления мы установили несколько правил, которые применяет скрипт форматирования
reformat_dat_file.pl:
• В каждой паре фигурных скобок сначала идут поля метаданных oid, oid_symbol и descr, в
этом же порядке, а затем собственные поля каталога в определённом для них порядке.
• Переводы строк при необходимости вставляются между полями для ограничения длины
строки 80 символами, если это возможно. Перевод строки также вставляется между поля-
ми метаданных и обычными полями.
• Если в файле .h каталога задаётся значение по умолчанию для столбца и то же значение
указано в записи данных, reformat_dat_file.pl уберёт его из файла данных. Таким обра-
зом обеспечивается компактное представление данных.
• Скрипт reformat_dat_file.pl сохраняет пустые строки и строки комментариев в неизмен-
ном виде.
Скрипт reformat_dat_file.pl рекомендуется запускать перед сохранением изменений в дан-
ных каталога. Им удобно пользоваться, просто выполняя make reformat-dat-files в src/
include/catalog/.
• Если вы хотите добавить новый метод уменьшения представления данных, вы должны реали-
зовать его в reformat_dat_file.pl и также научить Catalog::ParseData() разворачивать дан-
ные в полное представление.
2183Объявление и начальное содер-
жимое системных каталогов
69.2.2. Назначение OID
Строке каталога, фигурирующей в исходных данных, можно вручную присвоить OID, добавив поле
метаданных oid =&gt; nnnn. Более того, когда строке присваивается OID, для этого OID можно создать
макрос C, добавив поле метаданных oid_symbol =&gt; имя.
Предварительно загружаемым строкам каталога должны заранее назначаться OID, если на них
по OID ссылаются другие предварительно загружаемые строки. Назначать OID также требуется,
если на OID нужно будет ссылаться из кода на C. В отсутствие этих условий поле метаданных oid
можно опустить и тогда загрузочный код назначит OID автоматически либо оставит его нулевым,
если OID в данном каталоге не используются. На практике мы обычно явно назначаем OID для
всех строк в определённом каталоге (даже если фактически присутствуют ссылки только на часть
из них) либо не назначаем их вовсе.
Указание фактического числового значения любого OID в коде на C считается крайне нежела-
тельным; вместо этого всегда следует использовать макрос. Прямые обращения к OID в pg_proc
требуются достаточно часто, поэтому был создан специальный механизм, создающий необходи-
мые макросы автоматически; см. src/backend/utils/Gen_fmgrtab.pl. С аналогичной целью преду-
смотрен (но по историческим причинам реализован по-другому) метод создания макросов для OID
в pg_type. Как следствие, записи oid_symbol в этих двух каталогах добавлять не нужно. Подобным
образом в pg_class автоматически включаются макросы для OID системных каталогов и индексов.
Для остальных системных каталогов все нужные вам макросы с oid_symbol вы должны добавлять
вручную.
Чтобы найти свободный OID для новой предварительно загружаемой строки, запустите скрипт
src/include/catalog/unused_oids. Он выводит диапазоны неиспользуемых OID, включающие гра-
ничные значения (например, выведенная строка «45-900» означает, что OID с 45 по 900 включи-
тельно ещё не задействованы). В настоящее время для назначения вручную зарезервированы зна-
чения OID 1-9999; скрипт unused_oids просто просматривает заголовки каталогов и файлы .dat
и проверяет, какие значения в них отсутствуют. Для поиска ошибок вы можете воспользоваться
скриптом duplicate_oids. (Скрипт genbki.pl также выявит дублирующиеся OID во время компи-
ляции.)
Счётчик OID начинается с 10000 при запуске начальной загрузки. Если строка каталога находится
в таблице с OID, но для неё не было явно установлено поле oid, она получит OID, равный 10000
или больше.
69.2.3. Поиск по OID
Перекрёстную ссылку из одной строки исходного каталога на другую можно записать, просто ука-
зав предопределённый OID целевой строки. Однако этот подход провоцирует ошибки и сложен
для понимания, поэтому для часто используемых каталогов в genbki.pl реализованы механизмы
записи символических ссылок. В настоящее время по символическим ссылкам можно обращаться
к методам доступа, функциям, операторам, классам и семействам операторов, а также типам. При
этом действуют следующие правила:
• Для использования символических ссылок в некотором столбце каталога требуется доба-
вить указание BKI_LOOKUP(правило_поиска) в определение этого столбца, где правилом_поис-
ка может быть pg_am, pg_proc, pg_operator, pg_opclass, pg_opfamily или pg_type. Указание
BKI_LOOKUP может быть добавлено к столбцам типа Oid, regproc, oidvector или Oid[]; в по-
следних двух случаях поиск будет выполняться для каждого элемента массива.
• В таком столбце все записи должны иметь символьный формат (исключение составляет 0,
обозначающий InvalidOid). (Если столбец объявлен как regproc, вместо 0 можно написать -.)
Скрипт genbki.pl выдаст предупреждение, встретив нераспознанное имя.
• Методы доступа, как и типы, представляются просто своими именами. Имена типов должны
соответствовать полям typname в соответствующих записях pg_type; псевдонимы типов ис-
пользовать нельзя, например, нельзя написать integer вместо int4.
2184Объявление и начальное содер-
жимое системных каталогов
• Функция может быть представлена своим значением proname, если оно уникально среди запи-
сей pg_proc.dat (это работает как ввод значения типа regproc). В противном случае её нужно
представить как proname(имя_типа_аргумента,имя_типа_аргумента,…), как в regprocedure.
Имена типов аргументов должны записываться в точности так, как они фигурируют в поле
proargtypes в pg_proc.dat. Не добавляйте в эту строку пробелы.
• Операторы представляются в виде oprname(левый_тип,правый_тип), при этом имена ти-
пов записываются в точности так, как они фигурируют в полях oprleft и oprright в
pg_operator.dat. (Вместо опущенного операнда унарного оператора записывается 0.)
• Имена классов операторов и семейств операторов уникальны только в рамках определённого
метода доступа, так что они представляются в виде имя_метода_доступа/имя_объекта.
• Ни в одном из этих случаев не поддерживается указание схемы; все объекты, создаваемые на
стадии начальной загрузки, будут принадлежать схеме pg_catalog.
Скрипт genbki.pl разрешает все символические ссылки при запуске и помещает в формируемый
файл BKI обычные числовые OID. Таким образом, при начальной загрузке отпадает необходимость
в разрешении имён.
69.2.4. Рецепты по редактированию файлов данных
Ниже приведены некоторые предложения по оптимальному решению некоторых распространён-
ных задач при изменении файлов каталогов.
Добавление в каталог нового столбца со значением по умолчанию:  Добавьте столбец в
заголовочный файл с указанием BKI_DEFAULT(значение). Файл данных потребуется редактировать,
только если в каких-либо существующих строках в добавленном поле должно быть не значение
по умолчанию.
Указание значения по умолчанию для существующего столбца, который его не
имел:  Добавьте указание BKI_DEFAULT в заголовочный файл, а затем выполните make reformat-
dat-files для удаления ставших избыточными записей поля.
Удаление столбца, со значением по умолчанию или без:  Удалите столбец из заголовочного
файла, а затем выполните make reformat-dat-files для удаления ставших избыточными записей
поля.
Изменение или удаление существующего значения по умолчанию:  Просто изменить заго-
ловочный файл недостаточно, так как при этом текущие данные будут интерпретироваться некор-
ректно. Сначала выполните make expand-dat-files, чтобы перезаписать в файлах данных все явно
заданные значения по умолчанию, затем удалите или измените указания BKI_DEFAULT, и в завер-
шение выполните make reformat-dat-files для повторного удаления избыточных полей.
Разовая массовая модификация:  Скрипт reformat_dat_file.pl можно скорректировать для
выполнения самых разных массовых модификаций. Просмотрев в нём блочные комментарии, вы
найдёте место, куда можно вставить модифицирующий код. В следующем примере мы произведём
объединение двух логических полей в pg_proc в символьном поле:</p>
  <ol>
    <li>Добавьте новый столбец со значением по умолчанию в pg_proc.h:
+
+
/* see PROKIND_ categories below */
char
prokind BKI_DEFAULT(f);</li>
    <li>Создайте на основе reformat_dat_file.pl новый скрипт, который вставит соответствующие зна-
чения «на лету»:
-
-
-
-
+
+
#
#
#
#
#
#
At this point we have the full row in memory as a hash
and can do any operations we want. As written, it only
removes default values, but this script can be adapted to
do one-off bulk-editing.
One-off change to migrate to prokind
Default has already been filled in by now, so change to other
2185Объявление и начальное содер-
жимое системных каталогов
+
+
+
+
+
+
+
+
+
      <h1 id="values-as-appropriate">values as appropriate</h1>
      <p>if ($values{proisagg} eq ‘t’)
{
$values{prokind} = ‘a’;
}
elsif ($values{proiswindow} eq ‘t’)
{
$values{prokind} = ‘w’;
}</p>
    </li>
    <li>Запустите новый скрипт:
$ cd src/include/catalog
$ perl rewrite_dat_with_prokind.pl
pg_proc.dat
После этого в файле pg_proc.dat окажутся все три столбца, prokind, proisagg и proiswindow,
хотя они будут фигурировать только в тех строках, где им присваиваются не значения по умол-
чанию, а любые другие значения.</li>
    <li>
      <h2 id="Удалите-старые-столбцы-из-pg_proch">Удалите старые столбцы из pg_proc.h:</h2>
      <p>-
-
-
-
/* is it an aggregate? <em>/
bool
proisagg BKI_DEFAULT(f);
/</em> is it a window function? */
bool
proiswindow BKI_DEFAULT(f);</p>
    </li>
    <li>Наконец, выполните make
pg_proc.dat.
reformat-dat-files для удаления ненужных старых записей из
Примеры
кода,
производящего
массовые
модификации,
вы
може-
те
найти
в
скриптах
convert_oid2name.pl
и
remove_pg_type_oid_symbols.pl,
вложенных
в
сообщение:
https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm
+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com
69.3. Формат файла BKI
В этом разделе описывается, как сервер PostgreSQL интерпретирует файлы BKI. Это описание
будет легче понять, если для наглядности вы откроете файл postgres.bki.
Содержимое BKI состоит из последовательности команд. Команды образуются из нескольких ком-
понентов, в зависимости от синтаксиса конкретной команды. Компоненты команд обычно разде-
ляются пробельными символами, но это не обязательно, если не возникает неоднозначности. Спе-
циальный разделитель команд отсутствует; следующий компонент, который не может синтаксиче-
ски относиться к предыдущей команде, начинает следующую. (Обычно новая команда начинается
в отдельной строке, для структурности.) Компонентами команд могут быть определённые ключе-
вые слова, специальные символы (скобки, запятые и т. д.), числа или строки в двойных кавычках.
Все буквы в них воспринимаются с учётом регистра.
Строки, начинающиеся с #, игнорируются.
69.4. Команды BKI
create имя_таблицы oid_таблицы [bootstrap] [shared_relation] [without_oids] [rowtype_oid oid]
(имя1 = тип1 [FORCE NOT NULL | FORCE NULL] [, имя2 = тип2 [FORCE NOT NULL | FORCE NULL], …])
Создать таблицу имя_таблицы с заданным oid_таблицы и столбцами, указанными в скобках.
Непосредственно bootstrap.c поддерживает следующие типы столбцов: bool, bytea, char
(1 байт), name, int2, int4, regproc, regclass, regtype, text, oid, tid, xid, cid, int2vector,
oidvector, <em>int4 (массив), _text (массив), _oid (массив), _char (массив), _aclitem (массив). Хо-
тя возможно создать таблицы, содержащие столбцы и других типов, это нельзя сделать, пока не
2186Объявление и начальное содер-
жимое системных каталогов
будет создан и заполнен соответствующими записями каталог pg_type. (По сути это означает,
что только эти типы столбцов могут быть в каталогах начальной загрузки, хотя другие каталоги
могут содержать любые встроенные типы.)
С указанием bootstrap таблица будет создана только на диске; никакие записи о ней не бу-
дут добавлены в pg_class, pg_attribute и т. д. Таким образом, таблица не будет доступна для
обычных операций SQL, пока такие записи не будут добавлены явно (командами insert). Это
указание применяется для создания самой структуры pg_class и подобных ей.
Если добавлено указание shared_relation, таблица создаётся как общая. Она будет содер-
жать столбец OID, если отсутствует указание without_oids. Дополнительным предложением
rowtype_oid может быть задан OID типа строки (OID записи в pg_type); если он не указан, OID
генерируется автоматически. (Предложение rowtype_oid бесполезно, если присутствует ука-
зание bootstrap, но его всё равно можно добавить для документирования.)
open имя_таблицы
Открыть таблицу имя_таблицы для добавления данных. Любая другая таблица, открытая в дан-
ный момент, закрывается.
close имя_таблицы
Закрыть открытую таблицу. Имя таблицы должно задаваться для перепроверки.
insert [OID = значение_oid] ( значение1 значение2 … )
Вставить новую строку в открытую таблицу, установив значение1, значение2 и т. д. в качестве
значений столбцов и значение_oid в качестве OID. Если значение_oid равно нулю (0) или это
указание опущено, а таблица при этом содержит OID, строке назначается следующий свобод-
ный OID.
Значения NULL могут задаваться специальным ключевым словом _null</em>. Значения, отличные
от идентификаторов и цифровых строк, должны заключаться в двойные кавычки.
declare [unique] index имя_индекса oid_индекса on имя_таблицы using имя_метода_доступа ( клас-
с_оп1 имя1 [, …] )
Создать индекс имя_индекса с OID, равным oid_индекса, в таблице имя_таблицы, с методом до-
ступа имя_метода_доступа. Индекс строится по полям имя1, имя2 и т. д., и для них используют-
ся соответственно классы операторов класс_оп1, класс_оп2 и т. д. Эта команда создаёт файл
индекса и добавляет соответствующие записи в каталог, но не инициализирует содержимое
индекса.
declare toast oid_таблицы_toast oid_индекса_toast on имя_таблицы
Создаёт таблицу TOAST для таблицы имя_таблицы. Таблице TOAST назначается OID, равный
oid_таблицы_toast, а её индексу назначается OID, равный oid_индекса_toast. Как и с declare
index, заполнение индекса откладывается.
build indices
Заполнить индексы, объявленные ранее.
69.5. Структура файла BKI
Команда open может применяться, только когда открываемая ей таблица существует и для неё име-
ются записи в каталогах. (Минимальный набор этих каталогов образуют pg_class, pg_attribute,
pg_proc и pg_type.) Чтобы можно было заполнить сами эти таблицы, команда create с указанием
bootstrap неявно открывает создаваемую таблицу для добавления данных.
Кроме того, команды declare index и declare toast нельзя применять, пока не будут созданы и
заполнены системные каталоги.
2187Объявление и начальное содер-
жимое системных каталогов
Таким образом, файл postgres.bki должен иметь следующую структуру:</li>
    <li>create bootstrap (создание) одной из критичных таблиц</li>
    <li>insert (добавление) данных, описывающих как минимум критичные таблицы</li>
    <li>close</li>
    <li>Повторение для других критичных таблиц.</li>
    <li>create (создание) (без bootstrap) некритичной таблицы</li>
    <li>open</li>
    <li>insert (добавление) требуемых данных</li>
    <li>close</li>
    <li>Повторение для других некритичных таблиц.
10.Определение индексов и таблиц TOAST.</li>
    <li>build indices
Несомненно есть и другие, недокументированные зависимости, диктующие определённый поря-
док.
69.6. Пример BKI
Следующая последовательность команд создаст таблицу test_table с OID 420, имеющую два
столбца cola и colb типа int4 и text, соответственно, и вставит две строки в эту таблицу:
create test_table 420 (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 “value1” )
insert OID=422 ( 2 <em>null</em> )
close test_table
2188</li>
  </ol>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-068/" title="Глава 68. Физическое хранение базы данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 68. Физическое хранение базы данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-068/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~22 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-068/" rel="bookmark" title="Глава 68. Физическое хранение базы данных" itemprop="url">Глава 68. Физическое хранение базы данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 68. Физическое хранение базы данных</p>

<p>В данной главе рассматривается формат физического хранения, используемый базами данных
PostgreSQL.</p>

<p>68.1. Размещение файлов базы данных</p>

<p>Этот раздел описывает формат хранения на уровне файлов и каталогов.
Файлы конфигурации и файлы данных, используемые кластером базы данных, традиционно хра-
нятся вместе в каталоге данных кластера, который обычно называют PGDATA (по имени перемен-
ной среды, которую можно использовать для его определения). Обычно PGDATA находится в /var/
lib/pgsql/data. На одной и той же машине может находиться множество кластеров, управляемых
различными экземплярами сервера.
В каталоге PGDATA содержится несколько подкаталогов и управляющих файлов, как показано в
Таблице 68.1. В дополнение к этим обязательным элементам конфигурационные файлы кластера
postgresql.conf, pg_hba.conf и pg_ident.conf традиционно хранятся в PGDATA, хотя их можно
разместить и в другом месте.
Таблица 68.1. Содержание PGDATA
Элемент Описание
PG_VERSION Файл, содержащий
PostgreSQL
base Подкаталог, содержащий подкаталоги для каж-
дой базы данных
current_logfiles Файл, в котором отмечается, в какие файлы жур-
налов производит запись сборщик сообщений
global Подкаталог, содержащий общие таблицы кла-
стера, такие как pg_database
pg_commit_ts Подкаталог, содержащий данные о времени
фиксации транзакций
pg_dynshmem Подкаталог, содержащий файлы, используемые
подсистемой динамически разделяемой памяти
pg_logical Подкаталог, содержащий данные о состоянии
для логического декодирования
pg_multixact Подкаталог, содержащий данные о состоянии
мультитранзакций (используемые для разделяе-
мой блокировки строк)
pg_notify Подкаталог,
содержащий
данные
состоя-
ния прослушивания и нотификации (LISTEN/
NOTIFY)
pg_replslot Подкаталог, содержащий данные слота репли-
кации
pg_serial Подкаталог, содержащий информацию о выпол-
ненных сериализуемых транзакциях.
pg_snapshots Подкаталог, содержащий
снимки (snapshots)
pg_stat Подкаталог, содержащий постоянные файлы
для подсистемы статистики.
2171
номер
основной
версии
экспортированныеФизическое хранение базы данных
Элемент Описание
pg_stat_tmp Подкаталог, содержащий временные файлы для
подсистемы статистики
pg_subtrans Подкаталог, содержащий данные о состоянии
подтранзакций
pg_tblspc Подкаталог, содержащий символические ссыл-
ки на табличные пространства
pg_twophase Подкаталог, содержащий файлы состояний для
подготовленных транзакций
pg_wal Подкаталог, содержащий файлы WAL (журнал
предзаписи)
pg_xact Подкаталог, содержащий данные о состоянии
транзакции
postgresql.auto.conf Файл, используемый для хранения параметров
конфигурации, которые устанавливаются при
помощи ALTER SYSTEM
postmaster.opts Файл, содержащий параметры командной стро-
ки, с которыми сервер был запущен в последний
раз
postmaster.pid Файл блокировки, содержащий идентификатор (
ID) текущего управляющего процесса (PID), путь
к каталогу данных кластера, временную мет-
ку запуска управляющего процесса, номер пор-
та, путь к каталогу Unix-сокета (пустой для
Windows), первый корректный адрес прослуши-
вания (listen_address) (IP-адрес или *, либо пу-
стое значение в случае отсутствия прослушива-
ния по TCP), и ID сегмента разделяемой памяти (
этот файл отсутствует после остановки сервера).
Для каждой базы данных в кластере существует подкаталог внутри PGDATA/base, названный по
OID базы данных в pg_database. Этот подкаталог по умолчанию является местом хранения файлов
базы данных; в частности, там хранятся её системные каталоги.
Каждая таблица и индекс хранятся в отдельном файле. Для обычных отношений, эти фай-
лы получают имя по номеру файлового узла таблицы или индекса, который содержится в
pg_class.relfilenode. Но для временных отношений, имя файла имеет форму tBBB_FFF, где BBB</p>
<ul>
  <li>идентификатор серверного процесса сервера, который создал данный файл, а FFF — номер фай-
лового узла. В обоих случаях, помимо главного файла (также называемого основным слоем), у
каждой таблицы и индекса есть карта свободного пространства (см. Раздел 68.3), в которой хра-
нится информация о свободном пространстве в данном отношении. Имя файла карты свободного
пространства образуется из номера файлового узла с суффиксом _fsm. Также таблицы имеют кар-
ту видимости, хранящуюся в слое с суффиксом _vm, для отслеживания страниц, не содержащих
мёртвых записей. Карта видимости подробнее описана в Разделе 68.4. Нежурналируемые табли-
цы и индексы имеют третий слой, так называемый слой инициализации, имя которого содержит
суффикс _init (см. Раздел 68.5).
Внимание
Заметьте, что хотя номер файла таблицы часто совпадает с её OID, так бывает не всегда;
некоторые операции, например, TRUNCATE, REINDEX, CLUSTER и некоторые формы коман-
ды ALTER TABLE могут изменить номер файла, но при этом сохранят OID. Не следует рас-
считывать, что номер файлового узла и OID таблицы совпадают. Кроме того, для неко-
торых системных каталогов, включая и pg_class, в pg_class.relfilenode содержится
2172Физическое хранение базы данных
ноль. Фактический номер файлового узла для них хранится в низкоуровневой структу-
ре данных, и его можно получить при помощи функции pg_relation_filenode().
Когда объём таблицы или индекса превышает 1 GB, они делятся на сегменты размером в один
гигабайт. Файл первого сегмента называется по номеру файлового узла (filenode); последующие
сегменты получают имена filenode.1, filenode.2 и т. д. При такой организации хранения не возни-
кает проблем на платформах, имеющих ограничения по размеру файлов. (На самом деле, 1 ГБ —
лишь размер по умолчанию. Размер сегмента можно изменить при сборке PostgreSQL, используя
параметр конфигурации –with-segsize.) В принципе, карты свободного пространства и карты
видимости также могут занимать нескольких сегментов, хотя на практике это маловероятно.
У таблицы, столбцы которой могут содержать данные большого объёма, будет иметься собствен-
ная таблица TOAST, предназначенная для отдельного хранения значений, которые слишком вели-
ки для хранения в строках самой таблицы. Основная таблица связывается с её таблицей TOAST
(если таковая имеется) через pg_class.reltoastrelid. За подробной информацией обратитесь к
Разделу 68.2.
Содержание таблиц и индексов рассматривается ниже (см. Раздел 68.6).
Табличное пространство делает сценарий более сложным. Каждое пользовательское табличное
пространство имеет символическую ссылку внутри каталога PGDATA/pg_tblspc, указывающую на
физический каталог табличного пространства (т. е., положение, указанное в команде таблично-
го пространства CREATE TABLESPACE). Эта символическая ссылка получает имя по OID таблич-
ного пространства. Внутри физического каталога табличного пространства имеется подкаталог,
имя которого зависит от версии сервера PostgreSQL, как например PG_9.0_201008051. (Этот под-
каталог используется для того, чтобы последующие версии базы данных могли свободно исполь-
зовать одно и то же местоположение, заданное в CREATE TABLESPACE.) Внутри каталога конкрет-
ной версии находится подкаталог для каждой базы данных, которая имеет элементы в табличном
пространстве, названный по OID базы данных. Таблицы и индексы хранятся внутри этого катало-
га, используя схему именования файловых узлов. Табличное пространство pg_default недоступно
через pg_tblspc, но соответствует PGDATA/base. Подобным же образом, табличное пространство
pg_global недоступно через pg_tblspc, но соответствует PGDATA/global.
Функция pg_relation_filepath() показывает полный путь (относительно PGDATA) для любого от-
ношения. Часто это избавляет от необходимости запоминать многие из приведённых выше правил.
Но следует помнить, что эта функция выдаёт лишь имя первого сегмента основного слоя отноше-
ния, т. е. возможно, понадобится добавить номер сегмента и/или _fsm, _vm или _init, чтобы найти
все файлы, связанные с отношением.
Временные файлы (для таких операций, как сортировка объёма данных большего, чем может уме-
ститься в памяти) создаются внутри PGDATA/base/pgsql_tmp или внутри подкаталога pgsql_tmp
каталога табличного пространства, если для них определено табличное пространство, отличное
от pg_default. Имя временного файла имеет форму pgsql_tmpPPP.NNN, где PPP — PID серверного
процесса, а NNN служит для разделения различных временных файлов этого серверного процесса.
68.2. TOAST
В данном разделе рассматривается TOAST (The Oversized-Attribute Storage Technique, Методика
хранения сверхбольших атрибутов).
PostgreSQL использует фиксированный размер страницы (обычно 8 КБ), и не позволяет кортежам
занимать несколько страниц. Поэтому непосредственно хранить очень большие значения полей
невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или раз-
биваются на несколько физических строк. Это происходит незаметно для пользователя и на боль-
шую часть кода сервера влияет незначительно. Этот метод известен как TOAST (тост, или «лучшее
после изобретения нарезанного хлеба»). Инфраструктура TOAST также применяется для оптими-
зации обработки больших значений данных в памяти.
2173Физическое хранение базы данных
Лишь определённые типы данных поддерживают TOAST — нет смысла производить дополнитель-
ные действия с типами данных, размер которых не может быть большим. Чтобы поддерживать
TOAST, тип данных должен представлять значение переменной длины (varlena), в котором первое
четырёхбайтовое слово любого хранящегося значения содержит общую длину значения в байтах
(включая само это слово). Содержание оставшейся части значения TOAST не ограничивает. Спе-
циальные представления, в целом называемые значениями в формате TOAST, работают, манипу-
лируя этим начальным словом длины и интерпретируя его по-своему. Таким образом, функции
уровня C, работающие с типом данных, поддерживающим TOAST, должны аккуратно обращаться
со входными значениями, которые могут быть в формате TOAST: входные данные могут и не содер-
жать четырёхбайтовое слово длины и содержимое после него, пока не будут распакованы. (Обыч-
но в таких ситуациях нужно использовать макрос PG_DETOAST_DATUM прежде чем что-либо делать с
входным значением, но в некоторых случаях возможны и более эффективные подходы. За подроб-
ностями обратитесь к Подразделу 38.12.1.)
TOAST занимает два бита слова длины varlena (старшие биты на машинах с порядком байт от стар-
шего к младшему, или младшие биты — при другом порядке байт), таким образом, логический раз-
30
мер любого значения в формате TOAST ограничивается 1 Гигабайтом (2 - 1 байт). Когда оба бита
равны нулю, значение является обычным, не в формате TOAST, и оставшиеся биты слова длины
задают общий размер элемента данных (включая слово длины) в байтах. Когда установлен стар-
ший (или младший, в зависимости от архитектуры) бит, значение имеет однобайтовый заголовок
вместо обычного четырёхбайтового, а оставшиеся биты этого байта задают общий размер элемен-
та данных (включая байт длины) в байтах. Этот вариант позволяет экономно хранить значения
короче 127 байт и при этом допускает расширение значения этого типа данных до 1 Гбайта при
необходимости. Значения с однобайтовыми заголовками не выравниваются по какой-либо опреде-
лённой границе, тогда как значения с четырёхбайтовыми заголовками выравниваются по границе
минимум четырёх байт; это избавление от выравнивания даёт дополнительный выигрыш в объёме,
очень ощутимый для коротких значений. В качестве особого случая, если все оставшиеся биты
однобайтового заголовка равны нулю (что в принципе невозможно с учётом включения размера
длины), значением является указатель на отдельно размещённые данные, с несколькими возмож-
ными вариантами, описанными ниже. Тип и размер такого указателя TOAST определяется кодом,
хранящимся во втором байте значения. Наконец, когда старший (или младший, в зависимости от
архитектуры) бит очищен, а соседний бит установлен, содержимое данных хранится в упакован-
ном виде и должно быть распаковано перед использованием. В этом случае оставшиеся биты че-
тырёхбайтового слова длины задают общий размер сжатых, а не исходных данных. Заметьте, что
сжатие также возможно и для отделённых данных, но заголовок varlena не говорит, имеет ли оно
место — это определяется содержимым, на которое указывает указатель TOAST.
Как уже было сказано, существуют разные варианты использования указателя TOAST. Самый ста-
рый и наиболее популярный вариант — когда он указывает на отделённые данные, размещённые
в таблице TOAST, которая отделена, но связана с таблицей, содержащей собственно указатель
данных TOAST. Такой указатель на данные на диске создаётся кодом обработки TOAST (в access/
heap/tuptoaster.c), когда кортеж, сохраняемый на диск, оказывается слишком большим. Допол-
нительные подробности описаны в Подразделе  68.2.1. Кроме того, указатель TOAST может ука-
зывать на отделённые данные, размещённые где-то в памяти. Такие данные обязательно недолго-
временные и никогда не оказываются на диске, но этот механизм очень полезен для исключения
копирования и избыточной обработки данные большого размера. Дополнительные подробности
описаны в Подразделе 68.2.2.
В качестве метода сжатия внутренних и отделённых данных применяется довольно про-
стой и очень быстрый представитель семейства алгоритмов LZ. Подробнее см. src/common/
pg_lzcompress.c.
68.2.1. Отдельное размещение TOAST на диске
Если какие-либо столбцы таблицы хранятся в формате TOAST, у таблицы будет связанная с ней
таблица TOAST, OID которой хранится в значении pg_class.reltoastrelid для данной таблицы.
Размещаемые на диске TOAST-значения содержатся в таблице TOAST, что подробнее описано ни-
же.
2174Физическое хранение базы данных
Отделённые значения делятся на порции (после сжатия, если оно применяется) размером не бо-
лее TOAST_MAX_CHUNK_SIZE байт (по умолчанию это значение выбирается таким образом, чтобы
на странице помещались четыре строки порций, то есть размер одной составляет порядка 2000
байт). Каждая порция хранится как отдельная строка в таблице TOAST, принадлежащей исход-
ной таблице-владельцу. Каждая таблица TOAST имеет столбцы chunk_id (OID, идентифицирующий
конкретное TOAST-значение), chunk_seq (последовательный номер для порции внутри значения)
и chunk_data (фактические данные порции). Уникальный индекс по chunk_id и chunk_seq обеспе-
чивает быструю выдачу значений. Таким образом, в указателе, представляющем отдельно разме-
щаемое на диске значение TOAST, должно храниться OID таблицы TOAST, к которой нужно обра-
щаться, и OID определённого значения (его chunk_id). Для удобства в данных указателя также
хранится логический размер элемента данных (исходных данных без сжатия) и фактический раз-
мер хранимых данных (отличающийся, если было применено сжатие). Учитывая байты заголовка
varlena, общий размер указателя на хранимое на диске значение TOAST составляет 18 байт, неза-
висимо от фактического размера собственно значения.
Код обработки TOAST срабатывает, только когда значение строки, которое должно храниться в
таблице, по размеру больше, чем TOAST_TUPLE_THRESHOLD байт (обычно это 2 Кб). Код TOAST бу-
дет сжимать и/или выносить значения поля за пределы таблицы до тех пор, пока значение стро-
ки не станет меньше TOAST_TUPLE_TARGET байт (переменная величина, так же обычно 2 Кб) или
уменьшить объём станет невозможно. Во время операции UPDATE значения неизменённых полей
обычно сохраняются как есть, поэтому модификация строки с отдельно хранимыми значениями
не несёт издержек, связанных с TOAST, если все такие значения остаются без изменений.
Код обработки TOAST распознаёт четыре различные стратегии хранения столбцов, совместимых
с TOAST, на диске:
• PLAIN не допускает ни сжатие, ни отдельное хранение; кроме того, отключается использова-
ние однобайтовых заголовков для типов varlena. Это единственно возможная стратегия для
столбцов типов данных, которые несовместимы с TOAST.
• EXTENDED допускает как сжатие, так и отдельное хранение. Это стандартный вариант для
большинства типов данных, совместимых с TOAST. Сначала происходит попытка выполнить
сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.
• EXTERNAL допускает отдельное хранение, но не сжатие. Использование EXTERNAL ускорит опе-
рации над частями строк в больших столбцах text и bytea (ценой увеличения объёма памяти
для хранения), так как эти операции оптимизированы для извлечения только требуемых ча-
стей отделённого значения, когда оно не сжато.
• MAIN допускает сжатие, но не отдельное хранение. (Фактически, отдельное хранение, тем не
менее, будет выполнено для таких столбцов, но лишь как крайняя мера, когда нет другого
способа уменьшить строку так, чтобы она помещалась на странице.)
Каждый тип данных, совместимый с TOAST, определяет стандартную стратегию для столбцов этого
типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью ALTER
TABLE … SET STORAGE.
TOAST_TUPLE_TARGET можно задавать на уровне таблиц с помощью команды ALTER TABLE … SET
(toast_tuple_target = N)
Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк
могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются вы-
полнением сравнения с относительно маленькими значениями ключа, большая часть работы бу-
дет выполняться с использованием главной записи строки. Большие значения атрибутов в форма-
те TOAST будут просто передаваться (если будут выбраны) в тот момент, когда результирующий
набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в об-
щий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хра-
нения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполнять-
ся исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-
страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая
таблицу TOAST, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые
2175Физическое хранение базы данных
маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обра-
ботки таблицы без использования TOAST, в которой размер всех HTML-страниц был уменьшен до
7 Кб, чтобы они уместились в строках.
68.2.2. Отдельное размещение TOAST в памяти
Указатели TOAST могут указывать на данные, размещённые не на диске, а где-либо в памяти те-
кущего серверного процесса. Очевидно, что такие указатель не могут быть долговременными, но
они, тем не менее, полезны. В настоящее время поддерживаются два подварианта: косвенные ука-
затели на данные и указатели на развёрнутые данные.
Косвенный указатель TOAST просто указывает на значение varlena, хранящееся где-то в памяти.
Этот вариант изначально был реализован просто как подтверждение концепции, но в настоящее
время он применяется при логическом декодировании, чтобы не приходилось создавать физиче-
ские кортежи больше одного 1 ГБ (что может потребоваться при консолидации всех отделённых
значений полей в одном кортеже). Данный вариант имеет ограниченное применение, так как со-
здатель такого указателя должен полностью понимать, что целевые данные будут существовать,
только пока существует указатель, и никакой инфраструктуры для сохранения их нет.
Указатели на развёрнутые данные TOAST полезны для сложных типов, представление которых на
диске плохо приспособлено для вычислительных целей. Например, стандартное представление в
виде varlena массива PostgreSQL включает информацию о размерности, битовую карту элементов
NULL (если они в нём содержатся), а затем значения всех элементов по порядку. Когда элемент
сам по себе имеет переменную длину, единственный способ найти N-ный элемент — просканиро-
вать все предыдущие элементы. Это представление компактно, и поэтому подходит для хранения
на диске, но для вычислительной обработки массива гораздо удобнее иметь «развёрнутое» или
«деконструированное» представление, в котором можно определить начальные адреса всех эле-
ментов. Механизм указателей TOAST способствует решению этой задачи, допуская передачу по
ссылке элемента Datum как указателя на стандартное значение varlena (представление на диске)
или указателя TOAST на развёрнутое представление где-то в памяти. Детали развёрнутого пред-
ставление определяются самим типом данных, хотя оно может иметь стандартный заголовок и удо-
влетворять другим требованиям API, описанным в src/include/utils/expandeddatum.h. Функции
уровня C, работающие с этим типом, могут реализовать поддержку любого из этих представлений.
Функции, не знающие о развёрнутом представлении, а просто применяющие PG_DETOAST_DATUM к
своим входным данным, будут автоматически получать традиционное представление varlena; так
что поддержка развёрнутого представления может вводиться постепенно, по одной функции.
Указатели TOAST на развёрнутые значения далее подразделяются на указатели для чтения/за-
писи и указатели только для чтения. Представление, на которое они указывают, в любом случае
одинаковое, но функции, получающей указатель для чтения/записи, разрешается модифицировать
целевые данные прямо на месте, тогда как функция, получающая указатель только для чтения, не
должна этого делать; если ей нужно получить изменённую версию значения, она должна сначала
сделать копию. Это отличие и связанные с ним соглашения позволяют избежать излишнего копи-
рования развёрнутых значений при выполнении запросов.
Для всех типов указателей TOAST на данные в памяти, код обработки TOAST гарантирует, что та-
кие данные не окажутся случайно сохранены на диске. Указатели TOAST в памяти автоматически
сворачиваются в обычные значения varlena перед сохранением — а затем могут преобразоваться
в указатели TOAST на диске, если без этого не смогут уместиться в содержащем их кортеже.
68.3. Карта свободного пространства
Каждое табличное и индексное отношение, за исключением хеш-индексов, имеет карту свободно-
го пространства (Free Space Map, FSM) для отслеживания доступного места. Она хранится рядом с
данными главного отношения в отдельном слое, имя которого образуется номером файлового узла
отношения с суффиксом _fsm. Например, если файловый узел отношения — 12345, FSM хранится
в файле с именем 12345_fsm в том же каталоге, что и основной файл отношения.
Карта свободного пространства представляет собой дерево страниц FSM. Страницы FSM нижнего
уровня хранят информацию о свободном пространстве, доступном на каждой странице таблицы
2176Физическое хранение базы данных
(или индекса), используя один байт для представления каждой такой страницы. Верхние уровни
агрегируют информацию нижних уровней.
Внутри каждой страницы FSM имеется двоичное дерево, хранящееся в массиве, где один байт
выделяется на каждый узел дерева. Каждый листовой узел представляет страницу таблицы или
страницу FSM нижнего уровня. В каждом узле выше листовых хранится наибольшее из значений
его узлов-потомков. Поэтому максимальное из значений листовых узлов хранится в корневом узле.
Более подробную информацию о структуре FSM и о том, как выполняется обновление и поиск, вы
найдёте в src/backend/storage/freespace/README. Модуль pg_freespacemap может быть исполь-
зован для просмотра информации, хранящейся в картах свободного пространства.
68.4. Карта видимости
Каждое отношение таблицы имеет карту видимости (Visibility Map, VM) для отслеживания стра-
ниц, содержащих только кортежи, которые видны всем активным транзакциям; в ней также отсле-
живается, какие страницы содержат только замороженные кортежи. Она хранится вместе с дан-
ными главного отношения в отдельном файле, имя которого образуется номером файлового узла
отношения с суффиксом _vm. Например, если файловый узел отношения — 12345, VM хранится в
файле 12345_vm, в том же самом каталоге, что и основной файл отношения. Заметьте, что индексы
не имеют VM.
Карта видимости хранит по два бита на страницу таблицы. Первый бит, если он установлен, пока-
зывает, что вся страница видна или, другими словами, не содержит кортежей, которые необходи-
мо очистить. Эта информация может также использоваться при сканировании только индекса для
поиска ответов только в данных индекса. Установленный второй бит показывает, что все кортежи
на этой странице заморожены. Это означает, что процесс очистки для предотвращения зацикли-
вания не должен больше посещать эту страницу.
Карта может отражать реальные данные с запаздыванием в том смысле, что мы уверены, что в
случаях, когда установлен бит, известно, что условие верно, но если бит не установлен, оно может
быть верным или неверным. Биты карты видимости устанавливаются только при очистке, а сбра-
сываются при любых операциях, изменяющих данные на странице.
Для изучения информации, хранящейся в карте видимости, можно воспользоваться модулем
pg_visibility.
68.5. Слой инициализации
Каждая нежурналируемая таблица, и каждый индекс такой таблицы имеет файл инициализации.
Файл инициализации представляет собой пустую таблицу или индекс соответствующего типа. Ко-
гда нежурналируемая таблица должна быть заново очищена по причине сбоя, файл инициализа-
ции копируется поверх главного файла, а все прочие файлы удаляются (при необходимости они
будут автоматически созданы заново).
68.6. Компоновка страницы базы данных
В данном разделе рассматривается формат страницы, используемый в таблицах и индексах
1
PostgreSQL. Последовательности и таблицы TOAST форматируются как обычные таблицы.
В дальнейшем подразумевается, что байт содержит 8 бит. В дополнение, термин элемент отно-
сится к индивидуальному значению данных, которое хранится на странице. В таблице элемент —
это строка; в индексе — элемент индекса.
Каждая таблица и индекс хранятся как массив страниц фиксированного размера (обычно 8 kB,
хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы
1
Фактически индексные методы доступа не нуждаются в этом формате страниц. Все существующие индексные методы в действительности используют этот
основной формат, но данные, хранящиеся в индексных метастраницах обычно не следуют правилам компоновки.
2177Физическое хранение базы данных
логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой стра-
нице. В индексах первая страница обычно резервируется как метастраница, хранящая контроль-
ную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода
доступа индекса.
Таблица 68.2 показывает общую компоновку страницы. Каждая страница имеет пять частей.
Таблица 68.2. Общая компоновка страницы
Элемент Описание
Данные заголовка страницы Длина — 24 байта. Содержит общую информа-
цию о странице, включая указатели свободного
пространства.
Данные идентификаторов элементов Массив пар (смещение, длина), указывающих на
фактические элементы. Для каждого элемента
выделяется 4 байта.
Свободное пространство Незанятое пространство. Новые указатели эле-
ментов размещаются с начала этой области, са-
ми новые элементы — с конца.
Элементы Сами элементы данных как таковые.
Специальное пространство Специфические данные метода доступа. Для
различных методов хранятся различные дан-
ные. Для обычных таблиц таких данных нет.
Первые 24 байта каждой страницы образуют заголовок страницы (PageHeaderData). Его формат
подробно описан в Таблице  68.3. В первом поле отслеживается самая последняя запись в WAL,
связанная с этой страницей. Второе поле содержит контрольную сумму страницы, если включён
режим data checksums. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следуют
три двухбайтовых целочисленных поля (pd_lower, pd_upper и pd_special). Они содержат смещения
в байтах от начала страницы до начала незанятого пространства, до конца незанятого простран-
ства и до начала специального пространства. В следующих 2 байтах заголовка страницы, в поле
pd_pagesize_version, хранится размер страницы и индикатор версии. Начиная с PostgreSQL 8.3,
используется версия 4; в PostgreSQL 8.1 и 8.2 использовалась версия 3; в PostgreSQL 8.0 — версия
2; в PostgreSQL 7.3 и 7.4 — версия 1; а в предыдущих выпусках — версия 0. (Основная структура
страницы и формат заголовка почти во всех этих версиях одни и те же, но структура заголовка
строк в куче изменялась.) Размер страницы присутствует, в основном, только для перекрёстной
проверки; возможность использовать в одной инсталляции разные размеры страниц не поддержи-
вается. Последнее поле подсказывает, насколько вероятна возможность получить выигрыш, про-
изведя очистку страницы: оно отслеживает самый старый XMAX на странице, не подвергавшийся
очистке.
Таблица 68.3. Данные заголовка страницы (PageHeaderData)
Поле Тип Длина Описание
pd_lsn PageXLogRecPtr 8 байт LSN: Следующий байт
после последнего байта
записи WAL для послед-
него изменения на этой
странице
pd_checksum uint16 2 байта Контрольная
страницы
pd_flags uint16 2 байта Биты признаков
pd_lower LocationIndex 2 байта Смещение до начала
свободного простран-
ства
2178
суммаФизическое хранение базы данных
Поле Тип Длина Описание
pd_upper LocationIndex 2 байта Смещение до конца сво-
бодного пространства
pd_special LocationIndex 2 байта Смещение до нача-
ла специального про-
странства
pd_pagesize_version uint16 2 байта Информация о размере
страницы и номере вер-
сии компоновки
pd_prune_xid TransactionId 4 байта Самый старый неочи-
щенный
идентифика-
тор XMAX на страни-
це или ноль при отсут-
ствии такового
Всю подробную информацию можно найти в src/include/storage/bufpage.h.
За заголовком страницы следуют идентификаторы элемента (ItemIdData), каждому из которых
требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его
длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые иден-
тификаторы элементов размещаются по мере необходимости от начала свободного пространства.
Количество имеющихся идентификаторов элементов можно определить через значение pd_lower,
которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор эле-
мента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно исполь-
зовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам эле-
мент перемещается по странице для уплотнения свободного пространства. Фактически каждый
указатель на элемент (ItemPointer, также известный как CTID), созданный PostgreSQL, состоит из
номера страницы и индекса идентификатора элемента.
Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу неза-
нятого пространства. Точная структура меняется в зависимости от того, каким будет содер-
жание таблицы. Как таблицы, так и последовательности используют структуру под названием
HeapTupleHeaderData, которая описывается ниже.
Последний раздел является «особым разделом», который может содержать всё, что необходимо
методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева
и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные
таблицы не используют особый раздел вовсе (что указывается установкой значения pd_special
равным размеру страницы).
68.6.1. Компоновка строки таблицы
Все строки таблицы структурированы одним и тем же образом. Они включают заголовок фиксиро-
ванного размера (занимающий 23 байта на большинстве машин), за которым следует необязатель-
ная битовая карта пустых значений, необязательное поле идентификатора объекта и данные поль-
зователя. Подробное описание заголовка представлено в Таблица 68.4. Актуальные пользователь-
ские данные (столбцы строки) начинаются после смещения, заданного в t_hoff, которое должно
всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений имеет-
ся тогда, когда бит HEAP_HASNULL установлен в значении t_infomask. В случае наличия, она на-
чинается сразу после фиксированного заголовка и занимает достаточно байтов, чтобы иметь один
бит на столбец (т. е. t_natts битов всего). В этом списке битов установленный в единицу бит озна-
чает непустое значение, а установленный в ноль соответствует пустому значению. Когда битовая
карта отсутствует, все столбцы считаются непустыми. Идентификатор объекта присутствует, если
только бит HEAP_HASOID установлен в значении t_infomask. Если он есть, он расположен сразу
перед началом t_hoff. Любое заполнение, необходимое для того, чтобы сделать t_hoff кратным
MAXALIGN, будет расположено между битовой картой пустых значений и идентификатором объ-
екта. (Это в свою очередь гарантирует, что идентификатор объекта будет правильно выровнен.)
2179Физическое хранение базы данных
Таблица 68.4. Данные заголовка строки таблицы (HeapTupleHeaderData)
Поле Тип Длина Описание
t_xmin TransactionId 4 байта значение XID вставки
t_xmax TransactionId 4 байта значение XID удаления
t_cid CommandId 4 байта значение CID для встав-
ки и/или удаления (пе-
ресекается с t_xvac)
t_xvac TransactionId 4 байта XID
для
операции
VACUUM, которая пе-
ремещает версию стро-
ки
t_ctid ItemPointerData 6 байт текущее значение TID
этой или более новой
версии строки
t_infomask2 uint16 2 байта количество атрибутов
плюс различные биты
флагов
t_infomask uint16 2 байта различные биты флагов
t_hoff uint8 1 байт отступ до пользователь-
ских данных
Всю подробную информацию можно найти в src/include/access/htup_details.h.
Интерпретация текущих данных может быть проведена с помощью информации, полученной из
других таблиц, в основном из pg_attribute. Ключевые значения, необходимые для определения
расположения полей attlen и attalign. Не существует способа непосредственного получения за-
данного атрибута кроме случая, когда имеются только поля фиксированной длины, и при этом
нет пустых значений. Все эти особенности учитываются в функциях heap_getattr, fastgetattr и
heap_getsysattr.
Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь
нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений.
Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание
является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это
поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной дли-
ной имеют общую структуру заголовка struct varlena, которая включает общую длину сохранён-
ного значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут
храниться либо локально, либо в таблице TOAST. Также, возможно сжатие данных (см. Раздел 68.2).
2180</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page3/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page2/">2</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page3/">3</a></li>
      
    
      
        <li><strong class="current-page">4</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page5/">5</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page6/">6</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page5/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>