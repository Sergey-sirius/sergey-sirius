<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 20. Аутентификация клиентского приложения &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 20. Аутентификация клиентского приложения">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 20. Аутентификация клиентского приложения">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/PostgreSQL-V11_Doc-020/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/PostgreSQL-V11_Doc-020/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 20. Аутентификация клиентского приложения">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-020/" rel="bookmark" title="Глава 20. Аутентификация клиентского приложения">Глава 20. Аутентификация клиентского приложения</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-01T00:00:00+02:00">December 01, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~37 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 20. Аутентификация клиентского приложения</p>

<p>При подключении к серверу базы данных, клиентское приложение указывает имя пользователя
PostgreSQL, так же как и при обычном входе пользователя на компьютер с ОС Unix. При работе в
среде SQL по имени пользователя определяется, какие у него есть права доступа к объектам базы
данных (подробнее это описывается в Главе 21). Следовательно, важно указать на этом этапе, к
каким базам пользователь имеет право подключиться.
Примечание
Как можно узнать из Главы  21, PostgreSQL управляет правами и привилегиями, ис-
пользуя так называемые «роли». В этой главе под пользователем мы подразумеваем
«роль с привилегией LOGIN».
Аутентификация это процесс идентификации клиента сервером базы данных, а также определе-
ние того, может ли клиентское приложение (или пользователь запустивший приложение) подклю-
читься с указанным именем пользователя.
PostgreSQL предлагает несколько различных методов аутентификации клиентов. Метод аутенти-
фикации конкретного клиентского соединения может основываться на адресе компьютера клиен-
та, имени базы данных, имени пользователя.
Имена пользователей базы данных PostgreSQL не имеют прямой связи с пользователями операци-
онной системы на которой запущен сервер. Если у всех пользователей базы данных заведена учёт-
ная запись в операционной системе сервера, то имеет смысл назначить им точно такие же име-
на для входа в PostgreSQL. Однако, сервер, принимающий удалённые подключения, может иметь
большое количество пользователей базы данных, у которых нет учётной записи в ОС. В таких слу-
чаях не требуется соответствие между именами пользователей базы данных и именами пользова-
телей операционной системы.
20.1. Файл pg_hba.conf
Аутентификация клиентов управляется конфигурационным файлом, который традиционно назы-
вается pg_hba.conf и расположен в каталоге с данными кластера базы данных. (HBA расшифро-
вывается как host-based authentication — аутентификации по имени узла.) Файл pg_hba.conf, со
стандартным содержимым, создаётся командой initdb при инициализации каталога с данными.
Однако его можно разместить в любом другом месте; см. конфигурационный параметр hba_file.
Обычный формат файла pg_hba.conf представляет собой набор записей, по одной в строке. Пустые
строки игнорируются, как и любой текст комментария после знака #. Записи не продолжаются
на следующей строке. Записи состоят из некоторого количества полей, разделённых между собой
пробелом и/или tabs. В полях могут быть использованы пробелы, если они взяты в кавычки. Если в
кавычки берётся какое-либо зарезервированное слово в поле базы данных, пользователя или адре-
сации (например, all или replication), то слово теряет своё особое значение и просто обозначает
базу данных, пользователя или сервер с данным именем.
Каждая запись обозначает тип соединения, диапазон IP-адресов клиента (если он соотносится с
типом соединения), имя базы данных, имя пользователя, и способ аутентификации, который бу-
дет использован для соединения в соответствии с этими параметрами. Первая запись с соответ-
ствующим типом соединения, адресом клиента, указанной базой данных и именем пользователя
применяется для аутентификации. Процедур «fall-through» или «backup» не предусмотрено: если
выбрана запись и аутентификация не прошла, последующие записи не рассматриваются. Если же
ни одна из записей не подошла, в доступе будет отказано.
Запись может быть сделана в одном из семи форматов:
572Аутентификация кли-
ентского приложения
local
база
host
база
hostssl
база
hostnossl база
host
база
аутентификации]
hostssl
база
аутентификации]
hostnossl база
аутентификации]
пользователь
пользователь
пользователь
пользователь
пользователь метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
адрес метод-аутентификации [параметры-аутентификации]
IP-адрес IP-маска метод-аутентификации [параметры-
пользователь IP-адрес
IP-маска
метод-аутентификации
[параметры-
пользователь IP-адрес
IP-маска
метод-аутентификации
[параметры-
Значения полей описаны ниже:
local
Управляет подключениями через Unix-сокеты. Без подобной записи подключения через Unix-
сокеты невозможны.
host
Управляет подключениями, устанавливаемыми по TCP/IP. Записи host соответствуют подклю-
чениям с SSL и без SSL.
Примечание
Удалённое соединение по TCP/IP невозможно, если сервер запущен без определе-
ния соответствующих значений для параметра конфигурации listen_addresses, по-
скольку по умолчанию система принимает подключения по TCP/IP только для ло-
кального адреса замыкания localhost.
hostssl
Управляет подключениями, устанавливаемыми по TCP/IP с применением шифрования SSL.
Чтобы использовать эту возможность, сервер должен быть собран с поддержкой SSL. Более
того, механизм SSL должен быть включён параметром конфигурации ssl (подробнее об этом в
Разделе 18.9). В противном случае запись hostssl игнорируется (не считая предупреждения о
том, что ей не будут соответствовать никакие подключения).
hostnossl
Этот тип записей противоположен hostssl, ему соответствуют только подключения по TCP/IP
без шифрования SSL.
база
Определяет, каким именам баз данных соответствует эта запись. Значение all определяет, что
подходят все базы данных. Значение sameuser определяет, что данная запись соответствует
только, если имя запрашиваемой базы данных совпадает с именем запрашиваемого пользова-
теля. Значение samerole определяет, что запрашиваемый пользователь должен быть членом
роли с таким же именем, как и у запрашиваемой базы данных. (samegroup - это устаревший, но
допустимый вариант значения samerole.) Суперпользователи не становятся членами роли ав-
томатически из-за samerole, а только если они являются явными членами роли, прямо или кос-
венно, и не только из-за того, что они суперпользователи. Значение replication показывает,
что запись соответствует, если запрашивается подключение физической репликации (имейте в
виду, что подключения репликации не определяют какую-то конкретную базу данных). В про-
тивном случае, это имя определённой базы данных PostgreSQL. Несколько имён баз данных
можно указать, разделяя их запятыми. Файл, содержащий имена баз данных, можно указать,
поставив знак @ в начале его имени.
573Аутентификация кли-
ентского приложения
пользователь
Указывает, какому имени (или именам) пользователя базы данных соответствует эта запись.
Значение all показывает, что это подходит всем пользователям. В противном случае, это либо
имя конкретного пользователя базы данных, или имя группы, в начале которого стоит знак
+. (Напомним, что в PostgreSQL нет никакой разницы между пользователем и группой; знак +
означает « совпадение любых ролей, которые прямо или косвенно являются членами роли»,
тогда как имя без знака + является подходящей только для этой конкретной роли.) В связи
с этим, суперпользователь рассматривается как член роли, только если он явно является чле-
ном этой роли, прямо или косвенно, а не только потому, что он является суперпользователем.
Несколько имён пользователей можно указать, разделяя их запятыми. Файл, содержащий име-
на пользователей, можно указать, поставив знак @ в начале его имени.
адрес
Указывает адрес (или адреса) клиентской машины, которым соответствует данная запись. Это
поле может содержать или имя компьютера, или диапазон IP-адресов, или одно из нижеупомя-
нутых ключевых слов.
Диапазон IP-адресов указывается в виде начального адреса диапазона, дополненного косой
чертой (/) и длиной маски CIDR. Длина маски задаёт количество старших битов клиентского IP-
адреса, которые должны совпадать с битами IP-адреса диапазона. Биты, находящиеся правее, в
указанном IP-адресе должны быть нулевыми. Между IP-адресом, знаком / и длиной маски CIDR
не должно быть пробельных символов.
Типичные примеры диапазонов адресов IPv4, указанных таким образом: 172.20.143.89/32 для
одного компьютера, 172.20.143.0/24 для небольшой и 10.6.0.0/16 для крупной сети. Диапа-
зон адресов IPv6 может выглядеть как ::1/128 для одного компьютера (это адрес замыкания
IPv6) или как fe80::7a31:c1ff:0000:0000/96 для небольшой сети. 0.0.0.0/0 представляет все
адреса IPv4, а ::0/0 — все адреса IPv6. Чтобы указать один компьютер, используйте длину мас-
ки 32 для IPv4 или 128 для IPv6. Опускать замыкающие нули в сетевом адресе нельзя.
Запись, сделанная в формате IPv4, подойдёт только для подключений по IPv4, а запись в фор-
мате IPv6 подойдёт только для подключений по IPv6, даже если представленный адрес нахо-
дится в диапазоне IPv4-в-IPv6. Имейте в виду, что записи в формате IPv6 не будут приниматься,
если системная библиотека С не поддерживает адреса IPv6.
Вы также можете прописать значение all, чтобы указать любой IP-адрес, samehost, чтобы ука-
зать любые IP-адреса данного сервера, или samenet, чтобы указать любой адрес любой подсети,
к которой сервер подключён напрямую.
Если определено имя компьютера (всё, что не является диапазоном IP-адресов или специаль-
ным ключевым словом, воспринимается как имя компьютера), то оно сравнивается с результа-
том обратного преобразования IP-адреса клиента (например, обратного DNS-запроса, если ис-
пользуется DNS). При сравнении имён компьютеров регистр не учитывается. Если имена сов-
пали, выполняется прямое преобразование имени (например, прямой DNS-запрос) для провер-
ки, относится ли клиентский IP-адрес к адресам, соответствующим имени. Если двусторонняя
проверка пройдена, запись считается соответствующей компьютеру. (В качестве имени узла
в файле pg_hba.conf должно указываться то, что возвращается при преобразовании IP-адре-
са клиента в имя, иначе строка не будет соответствовать узлу. Некоторые базы данных имён
позволяют связать с одним IP-адресом несколько имён узлов, но операционная система при
попытке разрешить IP-адрес возвращает только одно имя.)
Указание имени, начинающееся с точки (.), соответствует суффиксу актуального имени узла.
Так, .example.com будет соответствовать foo.example.com (а не только example.com).
Когда в pg_hba.conf указываются имена узлов, следует добиться, чтобы разрешение имён вы-
полнялось достаточно быстро. Для этого может быть полезен локальный кеш разрешения имён,
например, nscd. Вы также можете включить конфигурационный параметр log_hostname, чтобы
видеть в журналах имя компьютера клиента вместо IP-адреса.
574Аутентификация кли-
ентского приложения
Это поле применимо только к записям host, hostssl и hostnossl.
Примечание
Пользователи часто задаются вопросом, почему имена серверов обрабатываются
таким сложным, на первый взгляд, способом, с разрешением двух имён, включая
обратный запрос клиентского IP-адреса. Это усложняет процесс в случае, если об-
ратная DNS-запись клиента не установлена или включает в себя нежелательное
имя узла. Такой способ избран, в первую очередь, для повышения эффективности:
в этом случае соединение требует максимум два запроса разрешения, один прямой
и один обратный. Если есть проблема разрешения с каким-то адресом, то она оста-
ётся проблемой этого клиента. Гипотетически, могла бы быть реализована возмож-
ность во время каждой попытки соединения выполнять только прямой запрос для
разрешения каждого имени сервера, упомянутого в pg_hba.conf. Но если список
имён велик, процесс был бы довольно медленным, а в случае наличия проблемы
разрешения у одного имени сервера, это стало бы общей проблемой.
Также обратный запрос необходим для того, чтобы реализовать возможность со-
ответствия суффиксов, поскольку для сопоставления с шаблоном требуется знать
фактическое имя компьютера клиента.
Обратите внимание, что такое поведение согласуется с другими популярными ре-
ализациями контроля доступа на основе имён, такими как Apache HTTP Server и
TCP Wrappers.
IP-адрес
IP-маска
Эти два поля могут быть использованы как альтернатива записи IP-адрес/длина-маски. Вместо
того, чтобы указывать длину маски, в отдельном столбце указывается сама маска. Например,
255.0.0.0 представляет собой маску CIDR для IPv4 длиной 8 бит, а 255.255.255.255 представ-
ляет маску CIDR длиной 32 бита.
Эти поля применимы только к записям host, hostssl и hostnossl.
метод-аутентификации
Указывает метод аутентификации, когда подключение соответствует этой записи. Варианты
выбора приводятся ниже; подробности в Разделе 20.3.
trust
Разрешает безусловное подключение. Этот метод позволяет тому, кто может подключить-
ся к серверу с базой данных PostgreSQL, войти под любым желаемым пользователем
PostgreSQL без введения пароля и без какой-либо другой аутентификации. За подробностя-
ми обратитесь к Разделу 20.4.
reject
Отклоняет подключение безусловно. Эта возможность полезна для «фильтрации» некото-
рых серверов группы, например, строка reject может отклонить попытку подключения од-
ного компьютера, при этом следующая строка позволяет подключиться остальным компью-
терам в той же сети.
scram-sha-256
Проверяет пароль пользователя, производя аутентификацию SCRAM-SHA-256. За подроб-
ностями обратитесь к Разделу 20.5.
md5
Проверяет пароль пользователя, производя аутентификацию SCRAM-SHA-256 или MD5. За
подробностями обратитесь к Разделу 20.5.
575Аутентификация кли-
ентского приложения
password
Требует для аутентификации введения клиентом незашифрованного пароля. Поскольку па-
роль посылается простым текстом через сеть, такой способ не стоит использовать, если сеть
не вызывает доверия. За подробностями обратитесь к Разделу 20.5.
gss
Для аутентификации пользователя использует GSSAPI. Этот способ доступен только для
подключений по TCP/IP. За подробностями обратитесь к Разделу 20.6.
sspi
Для аутентификации пользователя использует SSPI. Способ доступен только для Windows.
За подробностями обратитесь к Разделу 20.7.
ident
Получает имя пользователя операционной системы клиента, связываясь с сервером Ident,
и проверяет, соответствует ли оно имени пользователя базы данных. Аутентификация ident
может использоваться только для подключений по TCP/IP. Для локальных подключений при-
меняется аутентификация peer. За подробностями обратитесь к Разделу 20.8.
peer
Получает имя пользователя операционной системы клиента из операционной системы и
проверяет, соответствует ли оно имени пользователя запрашиваемой базы данных. Доступ-
но только для локальных подключений. За подробностями обратитесь к Разделу 20.9.
ldap
Проводит аутентификацию, используя сервер LDAP. За подробностями обратитесь к Разде-
лу 20.10.
radius
Проводит аутентификацию, используя сервер RADIUS. За подробностями обратитесь к Раз-
делу 20.11
cert
Проводит аутентификацию, используя клиентский сертификат SSL. За подробностями об-
ратитесь к Разделу 20.12
pam
Проводит аутентификацию, используя службу подключаемых модулей аутентификации
(PAM), предоставляемую операционной системой. За подробностями обратитесь к Разде-
лу 20.13.
bsd
Проводит аутентификацию, используя службу аутентификации BSD, предоставляемую опе-
рационной системой. За подробностями обратитесь к Разделу 20.14.
.
параметры-аутентификации
После поля метод-аутентификации может идти поле (поля) вида имя=значение, определяющее
параметры метода аутентификации. Подробнее о параметрах, доступных для различных мето-
дов аутентификации, рассказывается ниже.
Помимо описанных далее параметров, относящихся к различным методам, есть один общий
параметр аутентификации clientcert, который можно задать в любой записи hostssl. Если он
равен 1, клиент должен представить подходящий (доверенный) сертификат SSL, в дополнение
к другим требованиям метода проверки подлинности.
576Аутентификация кли-
ентского приложения
Файлы, включённые в конструкции, начинающиеся с @, читаются, как список имён, разделённых
запятыми или пробелами. Комментарии предваряются знаком #, как и в файле pg_hba.conf, и
вложенные @ конструкции допустимы. Если только имя файла, начинающегося с @ не является
абсолютным путём.
Поскольку записи файла pg_hba.conf рассматриваются последовательно для каждого подключе-
ния, порядок записей имеет большое значение. Обычно, более ранние записи определяют чёткие
критерии для соответствия параметров подключения, но для методов аутентификации допускают
послабления. Напротив, записи более поздние смягчают требования к соответствию параметров
подключения, но усиливают их в отношении методов аутентификации. Например, некто желает
использовать trust аутентификацию для локального подключения по TCP/IP, но при этом запра-
шивать пароль для удалённых подключений по TCP/IP. В этом случае, запись, указывающая trust
аутентификацию для подключения адреса 127.0.0.1 должна появиться до записи, определяющей
аутентификацию через пароль для более широкого диапазона клиентских IP-адресов.
Файл pg_hba.conf прочитывается во время запуска и в момент получения основным процессом
сервера сигнала SIGHUP. Если вы редактируете файл во время работы системы, необходимо по-
слать сигнал процессу postmaster (используя pg_ctl reload или kill -HUP), чтобы он прочел об-
новленный файл.
Примечание
Предыдущее утверждение не касается Microsoft Windows: там любые изменения в
pg_hba.conf сразу применяются к последующим подключениям.
Системное представление pg_hba_file_rules может быть полезно для предварительной проверки
изменений в файле pg_hba.conf или для диагностики проблем, когда перезагрузка этого файла
не даёт желаемого эффекта. Строки в этом представлении, содержащие в поле error не NULL,
указывают на проблемы в соответствующих строках файла.
Подсказка
Чтобы подключиться к конкретной базе данных, пользователь не только должен прой-
ти все проверки файла pg_hba.conf, но должен иметь привилегию CONNECT для под-
ключения к базе данных. Если вы хотите ограничить доступ к базам данных для опре-
делённых пользователей, проще предоставить/отозвать привилегию CONNECT, нежели
устанавливать правила в записях файла pg_hba.conf.
Примеры записей файла pg_hba.conf показаны в Примере 20.1. Обратитесь к следующему разделу
за более подробной информацией по методам аутентификации.
Пример 20.1. Примеры записей pg_hba.conf</p>
<h1 id="Позволяет-любому-пользователю-локальной-системы-подключаться">Позволяет любому пользователю локальной системы подключаться</h1>
<h1 id="к-любой-базе-данных-используя-любое-имя-пользователя-баз-данных-через">к любой базе данных, используя любое имя пользователя баз данных, через</h1>
<h1 id="unix-сокеты-по-умолчанию-для-локальных-подключений">Unix-сокеты (по умолчанию для локальных подключений).</h1>
<p>#</p>
<h1 id="type-database">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
local
all
all
trust</p>
<h1 id="То-же-но-для-локальных-замкнутых-подключений-по-tcpip">То же, но для локальных замкнутых подключений по TCP/IP.</h1>
<p>#</p>
<h1 id="type-database-1">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
all
all
127.0.0.1/32</p>
<h1 id="То-же-что-и-в-предыдущей-строке-но-с-указанием">То же, что и в предыдущей строке, но с указанием</h1>
<h1 id="сетевой-маски-в-отдельном-столбце">сетевой маски в отдельном столбце</h1>
<p>#
577
METHOD
trustАутентификация кли-
ентского приложения</p>
<h1 id="type">TYPE</h1>
<p>host
DATABASE
all</p>
<h1 id="То-же-для-ipv6">То же для IPv6.</h1>
<p>#</p>
<h1 id="type-database-2">TYPE DATABASE</h1>
<p>host
all
USER
all IP-ADDRESS
127.0.0.1
USER
all ADDRESS
::1/128
IP-MASK
255.255.255.255
METHOD
trust
METHOD
trust</p>
<h1 id="То-же-самое-но-с-использованием-имени-компьютера">То же самое, но с использованием имени компьютера</h1>
<h1 id="обычно-покрывает-и-ipv4-и-ipv6">(обычно покрывает и IPv4, и IPv6).</h1>
<p>#</p>
<h1 id="type-database-3">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
all
all
localhost METHOD
trust</p>
<h1 id="Позволяет-любому-пользователю-любого-компьютера-с-ip-адресом">Позволяет любому пользователю любого компьютера с IP-адресом</h1>
<h1 id="19216893x-подключаться-к-базе-данных-postgres">192.168.93.x подключаться к базе данных “postgres”</h1>
<h1 id="с-именем-которое-сообщает-для-данного-подключения-ident">с именем, которое сообщает для данного подключения ident</h1>
<h1 id="как-правило-имя-пользователя-операционной-системы">(как правило, имя пользователя операционной системы).</h1>
<p>#</p>
<h1 id="type-database-4">TYPE DATABASE</h1>
<p>USER
ADDRESS
host
postgres
all
192.168.93.0/24 METHOD
ident</p>
<h1 id="Позволяет-любому-пользователю-компьютера-1921681210-подключаться">Позволяет любому пользователю компьютера 192.168.12.10 подключаться</h1>
<h1 id="к-базе-данных-postgres-если-он-передаёт-правильный-пароль">к базе данных “postgres”, если он передаёт правильный пароль.</h1>
<p>#</p>
<h1 id="type-database-5">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
postgres
all
192.168.12.10/32
scram-sha-256</p>
<h1 id="Позволяет-любым-пользователям-с-компьютеров-в-домене-examplecom">Позволяет любым пользователям с компьютеров в домене example.com</h1>
<h1 id="подключаться-к-любой-базе-данных-если-передаётся-правильный-пароль">подключаться к любой базе данных, если передаётся правильный пароль.</h1>
<p>#</p>
<h1 id="Для-всех-пользователей-требуется-аутентификация-scram-за-исключением">Для всех пользователей требуется аутентификация SCRAM, за исключением</h1>
<h1 id="пользователя-mike-который-использует-старый-клиент-не-поддерживающий">пользователя ‘mike’, который использует старый клиент, не поддерживающий</h1>
<h1 id="аутентификацию-scram">аутентификацию SCRAM.</h1>
<p>#</p>
<h1 id="type-database-6">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
mike
.example.com
md5
host
all
all
.example.com
scram-sha-256</p>
<h1 id="В-случае-отсутствия-предшествующих-строчек-с-host-следующие-две-строки">В случае отсутствия предшествующих строчек с “host”, следующие две строки</h1>
<h1 id="откажут-в-подключении-с-192168541-поскольку-данная-запись-будет">откажут в подключении с 192.168.54.1 (поскольку данная запись будет</h1>
<h1 id="выбрана-первой-но-разрешат-подключения-gssapi-с-любых-других">выбрана первой), но разрешат подключения GSSAPI с любых других</h1>
<h1 id="адресов-С-нулевой-маской-ни-один-бит-из-ip-адреса-компьютера">адресов. С нулевой маской ни один бит из IP-адреса компьютера</h1>
<h1 id="не-учитывается-так-что-этой-строке-соответствует-любой-компьютер">не учитывается, так что этой строке соответствует любой компьютер.</h1>
<p>#</p>
<h1 id="type-database-7">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
all
192.168.54.1/32
reject
host
all
all
0.0.0.0/0
gss</p>
<h1 id="Позволяет-пользователям-с-любого-компьютера-192168xx-подключаться">Позволяет пользователям с любого компьютера 192.168.x.x подключаться</h1>
<h1 id="к-любой-базе-данных-если-они-проходят-проверку-ident-Если-же-ident">к любой базе данных, если они проходят проверку ident. Если же ident</h1>
<h1 id="говорит-например-что-это-пользователь-bryanh-и-он-запрашивает">говорит, например, что это пользователь “bryanh” и он запрашивает</h1>
<h1 id="подключение-как-пользователь-postgresql-guest1-подключение">подключение как пользователь PostgreSQL “guest1”, подключение</h1>
<h1 id="будет-разрешено-если-в-файле-pg_identconf-есть-сопоставление">будет разрешено, если в файле pg_ident.conf есть сопоставление</h1>
<h1 id="omicron-позволяющее-пользователю-bryanh-подключаться-как-guest1">“omicron”, позволяющее пользователю “bryanh” подключаться как “guest1”.</h1>
<p>#</p>
<h1 id="type-database-8">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
host
all
all
192.168.0.0/16
ident map=omicron
578Аутентификация кли-
ентского приложения</p>
<h1 id="Если-для-локальных-подключений-предусмотрены-только-эти-три-строки">Если для локальных подключений предусмотрены только эти три строки,</h1>
<h1 id="они-позволят-локальным-пользователям-подключаться-только-к-своим">они позволят локальным пользователям подключаться только к своим</h1>
<h1 id="базам-данных-базам-данных-с-именами-совпадающими-с">базам данных (базам данных с именами, совпадающими с</h1>
<h1 id="именами-пользователей-баз-данных-кроме-администраторов">именами пользователей баз данных), кроме администраторов</h1>
<h1 id="или-членов-роли-support-которые-могут-подключиться-к-любой-БД">или членов роли “support”, которые могут подключиться к любой БД.</h1>
<h1 id="Список-имён-администраторов-содержится-в-файле-pgdataadmins">Список имён администраторов содержится в файле $PGDATA/admins.</h1>
<h1 id="Пароли-запрашиваются-в-любом-случае">Пароли запрашиваются в любом случае.</h1>
<p>#</p>
<h1 id="type-database-9">TYPE DATABASE</h1>
<p>USER
ADDRESS
METHOD
local
sameuser
all
md5
local
all
@admins
md5
local
all
+support
md5</p>
<h1 id="Последние-две-строчки-выше-могут-быть-объединены-в-одну">Последние две строчки выше могут быть объединены в одну:</h1>
<p>local
all
@admins,+support
md5</p>
<h1 id="В-столбце-database-также-могут-указываться-списки-и-имена-файлов">В столбце DATABASE также могут указываться списки и имена файлов:</h1>
<p>local
db1,db2,@demodbs all
md5
20.2. Файл сопоставления имён пользователей
Когда используется внешняя система аутентификации, например Ident или GSSAPI, имя пользова-
теля операционной системы, устанавливающего подключение, может не совпадать с именем це-
левого пользователя (роли) базы данных. В этом случае можно применить сопоставление имён
пользователей, чтобы сменить имя пользователя операционной системы на имя пользователя БД.
Чтобы задействовать сопоставление имён, укажите map=имя-сопоставления в поле параметров в
pg_hba.conf. Этот параметр поддерживается для всех методов аутентификации, которые принима-
ют внешние имена пользователей. Так как для разных подключений могут требоваться разные со-
поставления, сопоставление определяется параметром имя-сопоставления в pg_hba.conf для каж-
дого отдельного подключения.
Сопоставления имён пользователя определяются в файле сопоставления ident, который по умол-
чанию называется pg_ident.confи хранится в каталоге данных кластера. (Файл сопоставления мо-
жет быть помещён и в другое место, обратитесь к информации о настройке параметра ident_file.)
Файл сопоставления ident содержит строки общей формы:
map-name system-username database-username
Комментарии и пробелы применяются так же, как и в файле pg_hba.conf. map-name является про-
извольным именем, на которое будет ссылаться файл сопоставления файла pg_hba.conf. Два дру-
гих поля указывают имя пользователя операционной системы и соответствующее имя пользовате-
ля базы данных. Имя map-name может быть использовано неоднократно, чтобы указывать множе-
ственные сопоставления пользовательских имён в рамках одного файла сопоставления.
Нет никаких ограничений по количеству пользователей баз данных, на которые может ссылаться
пользователь операционной системы, и наоборот. Тем не менее, записи в файле скорее подразу-
мевают, что « пользователь этой операционной системы может подключиться как пользователь
этой базы данных», нежели показывают, что эти имена пользователей эквивалентны. Подключе-
ние разрешается, если существует запись в файле сопоставления, соединяющая имя, полученное
от внешней системы аутентификации, с именем пользователя базы данных, под которым пользо-
ватель хочет подключиться.
Если поле system-username начинается со знака (/), оставшаяся его часть рассматривается как
регулярное выражение. (Подробнее синтаксис регулярных выражений PostgreSQL описан в Под-
разделе 9.7.3.1.) Регулярное выражение может включать в себя одну группу, или заключённое в
скобки подвыражение, на которое можно сослаться в поле database-username, написав \1 (с одной
обратной косой). Это позволяет сопоставить несколько имён пользователя с одной строкой, что
особенно удобно для простых замен. Например, эти строки
579Аутентификация кли-
ентского приложения
mymap
mymap
/^(.<em>)@mydomain.com$
/^(.</em>)@otherdomain.com$
\1
guest
удалят часть домена для имён пользователей, которые заканчиваются на @mydomain.com, и позво-
лят пользователям, чьё имя пользователя системы заканчивается на @otherdomain.com, подклю-
читься как guest.
Подсказка
Помните, что по умолчанию, регулярное выражение может совпасть только с частью
строки. Разумным выходом будет использование символов ^ и $, как показано в при-
мере выше, для принудительного совпадения со всем именем пользователя операци-
онной системы
Файл pg_ident.conf читается при запуске системы, а также в тот момент, когда основной сервер
получает сигнал SIGHUP. Если вы редактируете файл во время работы системы, необходимо по-
слать сигнал процессу postmaster (используя pg_ctl reload или kill -HUP), чтобы он прочел об-
новленный файл.
Файл pg_ident.conf, который может быть использован в сочетании с файлом pg_hba.conf (см.
Пример 20.1), показан в Примере 20.2. В этом примере любым пользователям компьютеров в сети
192.168 с именами, отличными от bryanh, ann или robert, будет отказано в доступе. Пользователь
системы robert получит доступ только тогда, когда подключается как пользователь PostgreSQL
bob, а не как robert, или какой-либо другой пользователь. Пользователь ann сможет подключиться
только как ann. Пользователь bryanh сможет подключиться как bryanh или как guest1.
Пример 20.2. Пример файла pg_ident.conf</p>
<h1 id="mapname">MAPNAME</h1>
<p>SYSTEM-USERNAME
PG-USERNAME
omicron
bryanh
bryanh
omicron
ann
ann</p>
<h1 id="на-этих-машинах-bob-может-подключаться-как-robert">на этих машинах bob может подключаться как robert</h1>
<p>omicron
robert
bob</p>
<h1 id="bryanh-также-может-подключаться-как-guest1">bryanh также может подключаться как guest1</h1>
<p>omicron
bryanh
guest1
20.3. Методы аутентификации
Более подробно методы аутентификации рассматриваются в следующих разделах.
20.4. Аутентификация trust
Когда указан способ аутентификации trust, PostgreSQL предполагает, что любой подключающий-
ся к серверу авторизован для доступа к базе данных вне зависимости от указанного имени пользо-
вателя базы данных (даже если это имя суперпользователя). Конечно, ограничения, прописанные
в столбцах база и пользователь, продолжают работать. Этот метод должен применяться только в
том случае, когда на уровне операционной системы обеспечена адекватная защита от подключе-
ний к серверу.
Аутентификация trust очень удобна для локальных подключений на однопользовательской
рабочей станции. Но сам по себе этот метод обычно не подходит для машин с нескольки-
ми пользователями. Однако вы можете использовать trust даже на многопользовательской
машине, если ограничите доступ к файлу Unix-сокета сервера на уровне файловой системы.
Для этого установите конфигурационные параметры unix_socket_permissions (и, возможно,
unix_socket_group) как описано в Разделе 19.3. Либо вы можете установить конфигурационный
параметр unix_socket_directories, чтобы разместить файл сокета в должным образом защищён-
ном каталоге.
580Аутентификация кли-
ентского приложения
Установка разрешений на уровне файловой системы помогает только в случае подключений через
Unix-сокеты. На локальные подключения по TCP/IP ограничения файловой системы не влияют.
Поэтому, если вы хотите использовать разрешения файловой системы для обеспечения локальной
безопасности, уберите строку host … 127.0.0.1 … из pg_hba.conf или смените метод аутен-
тификации.
Метод аутентификации trust для подключений по TCP/IP допустим только в случае, если вы до-
веряете каждому пользователю компьютера, получившему разрешение на подключение к серверу
строками файла pg_hba.conf, указывающими метод trust. Не стоит использовать trust для любых
подключений по TCP/IP, отличных от localhost (127.0.0.1).
20.5. Аутентификация password
Существует несколько методов аутентификации по паролю. Они работают примерно одинаково,
но различаются тем, как пароли пользователей хранятся на сервере и как пароль передаётся от
клиента по каналу связи.
scram-sha-256
С методом scram-sha-256 выполняется аутентификация SCRAM-SHA-256, как описано в RFC</p>
<ol>
  <li>Она производится по схеме вызов-ответ, которая предотвращает перехват паролей через
недоверенные соединения и поддерживает хранение паролей на сервере в виде криптографи-
ческого хеша, что считается безопасным.
Это наиболее безопасный из существующих на данный момент методов, но он не поддержива-
ется старыми клиентскими библиотеками.
md5
Для метода md5 реализован менее безопасный механизм вызов-ответ. Он предотвращает пере-
хват паролей и предусматривает хранение паролей на сервере в зашифрованном виде, но не
защищает в случае похищения хешей паролей с сервера. Кроме того, алгоритм хеширования
MD5 в наши дни уже может не защитить от целенаправленных атак.
Метод md5 несовместим с функциональностью db_user_namespace.
Для облегчения перехода от метода md5 к более новому методу SCRAM, если в качестве метода
аутентификации в pg_hba.conf указан md5, но пароль пользователя на сервере зашифрован для
SCRAM (см. ниже), автоматически будет производиться аутентификация на базе SCRAM.
password
С методом password пароль передаётся в открытом виде и поэтому является уязвимым для атак
с перехватом трафика. Его следует избегать всегда, если это возможно. Однако, если подклю-
чение защищено SSL, метод password может быть безопасен. (Хотя аутентификация по серти-
фикату SSL может быть лучшим выбором когда используется SSL).
Пароли баз данных PostgreSQL отделены от паролей пользователей операционной системы. Па-
роли всех пользователей базы данных хранятся в системном каталоге pg_authid. Управлять паро-
лями можно либо используя SQL-команды CREATE ROLE и ALTER ROLE, например, CREATE ROLE
foo WITH LOGIN PASSWORD ‘secret’, либо с помощью команды psql \password. Если пароль для
пользователя не задан, вместо него хранится NULL, и пройти аутентификацию по паролю этот
пользователь не сможет.
Доступность различных методов аутентификации по паролю зависит от того, как пароли пользо-
вателей шифруются на сервере (или, говоря точнее, хешируются). Это определяется параметром
конфигурации password_encryption в момент назначения пароля. Если пароль шифруется в режи-
ме scram-sha-256, его можно будет использовать для методов аутентификации scram-sha-256 и
password (но в последнем случае он будет передаваться открытым текстом). В случае указания ме-
тода аутентификации md5 при этом произойдёт автоматический переход к использованию scram-
sha-256, как сказано выше, так что этот вариант тоже будет работать. Если пароль шифруется в
581Аутентификация кли-
ентского приложения
режиме md5, его можно будет использовать только для методов аутентификации md5 и password (и
в последнем случае он так же будет передаваться открытым текстом). (Ранние версии PostgreSQL
поддерживали хранение паролей на сервере в открытом виде, но теперь это невозможно.) Чтобы
просмотреть хранящиеся в БД хеши паролей, обратитесь к системному каталогу pg_authid.
Для перевода существующей инсталляции с md5 на scram-sha-256, после того как все клиентские
библиотеки будут обновлены до версий, поддерживающих SCRAM, задайте password_encryption
= ‘scram-sha-256’ в postgresql.conf, добейтесь, чтобы все пользователи сменили свои пароли, а
затем поменяйте указания метода аутентификации в pg_hba.conf на scram-sha-256.
20.6. Аутентификация GSSAPI
GSSAPI является протоколом отраслевого стандарта для безопасной авторизации, определённым
в RFC 2743. PostgreSQL поддерживает GSSAPI с Kerberos аутентификацией с соответствии с RFC</li>
  <li>GSSAPI обеспечивает автоматическую аутентификацию (single sign-on), для систем, которые
её поддерживают. Сама по себе аутентификация безопасна, но данные, отсылаемые в ходе под-
ключения к базе данных, не защищены, если не используется SSL.
Поддержка GSSAPI должна быть включена при сборке PostgreSQL; за дополнительными сведени-
ями обратитесь к Главе 16.
При работе с Kerberos GSSAPI использует стандартные учётные записи в формате servicename/
hostname@realm. Сервер PostgreSQL примет любого принципала, включённого в используемый сер-
вером файл таблицы ключей, но необходимо проявить осторожность в указании корректных дета-
лей принципала в ходе соединения с клиентом, применяющим параметр подключения krbsrvname.
(См. также Подраздел 34.1.2.) Значение имени сервиса по умолчанию postgres может быть изме-
нено во время сборки с помощью ./configure –with-krb-srvnam=whatever. В большинстве сред
изменять данный параметр не требуется. Однако некоторые реализации Kerberos могут потребо-
вать иного имени сервиса, например, Microsoft Active Directory требует, чтобы имя сервиса было
набрано заглавными буквами (POSTGRES).
hostname здесь — это полное доменное имя компьютера, где работает сервер. Областью субъек-
та-службы является предпочитаемая область данного компьютера.
Принципалы клиентов могут быть сопоставлены с различными именами пользователей баз данных
PostgreSQL в pg_ident.conf. Например, принципалу pgusername@realm может быть сопоставлено
просто pgusername. Так же возможно использовать в качестве имени роли в PostgreSQL полное
имя принципала username@realm без какого-либо сопоставления.
PostgreSQL также поддерживает возможность убирать область из имени принципала. Эта возмож-
ность оставлена для обратной совместимости и использовать её крайне нежелательно, так как
при этом оказывается невозможно различить разных пользователей, имеющих одинаковые име-
на, но приходящих из разных областей. Чтобы включить её, установите для include_realm значе-
ние 0. В простых конфигурациях с одной областью исключение области в сочетании с парамет-
ром krb_realm (который позволяет ограничить область пользователя одним значением, заданным
в krb_realm parameter) будет безопасным, но менее гибким вариантом по сравнению с явным опи-
санием сопоставлений в pg_ident.conf.
Убедитесь, что файл ключей вашего сервера доступен для чтения (и желательно недоступен для
записи) учётной записи сервера PostgreSQL. (См. также Раздел  18.1.) Расположение этого фай-
ла ключей указывается параметром krb_server_keyfile. По умолчанию это /usr/local/pgsql/etc/
krb5.keytab (каталог может быть другим, в зависимости от значения sysconfdir при сборке).
Из соображений безопасности рекомендуется использовать отдельный файл keytab для сервера
PostgreSQL, а не открывать доступ к общесистемному файлу.
Файл таблицы ключей генерируется программным обеспечением Kerberos; подробнее это описано
в документации Kerberos. Следующий пример для MIT-совместимых реализаций Kerberos 5:
kadmin% ank -randkey postgres/server.my.domain.org
kadmin% ktadd -k krb5.keytab postgres/server.my.domain.org
582Аутентификация кли-
ентского приложения
При подключении к базе данных убедитесь, что у вас есть разрешение на сопоставление прин-
ципала с именем пользователя базы данных. Например, для имени пользователя базы данных
fred, принципал fred@EXAMPLE.COM сможет подключиться. Чтобы дать разрешение на подклю-
чение принципалу fred/users.example.com@EXAMPLE.COM, используйте файл сопоставления имён
пользователей, как описано в Разделе 20.2.
Для метода GSSAPI доступны следующие параметры конфигурации:
include_realm
Когда этот параметр равен 0, из принципала аутентифицированного пользователя убирается
область, и оставшееся имя проходит сопоставление имён (см. Раздел 20.2). Этот вариант не ре-
комендуется и поддерживается в основном для обратной совместимости, так как он небезопа-
сен в окружениях с несколькими областями, если только дополнительно не задаётся krb_realm.
Более предпочтительный вариант — оставить значение include_realm по умолчанию (1) и за-
дать в pg_ident.conf явное сопоставление для преобразования имён принципалов в имена
пользователей PostgreSQL.
map
Разрешает сопоставление имён пользователей системы и пользователей баз данных. За
подробностями обратитесь к Разделу  20.2. Для принципала GSSAPI/Kerberos, такого как
username@EXAMPLE.COM (или более редкого username/hostbased@EXAMPLE.COM), именем пользо-
вателя в сопоставлении будет username@EXAMPLE.COM (или username/hostbased@EXAMPLE.COM,
соответственно), если include_realm не равно 0; в противном случае именем системного поль-
зователя в сопоставлении будет username (или username/hostbased).
krb_realm
Устанавливает область, с которой будут сверяться имена принципалов пользователей. Если
этот параметр задан, подключаться смогут только пользователи из этой области. Если не за-
дан, подключаться смогут пользователи из любой области, в зависимости от установленного
сопоставления имён пользователей.
20.7. Аутентификация SSPI
SSPI — технология Windows для защищённой аутентификации с единственным входом. PostgreSQL
использует SSPI в режиме negotiate, который применяет Kerberos, когда это возможно, и автома-
тически возвращается к NTLM в других случаях. Аутентификация SSPI работает только, когда и
сервер, и клиент работают на платформе Windows, или, на не-Windows платформах, если доступен
GSSAPI.
Если используется аутентификация Kerberos, SSPI работает так же, как GSSAPI; подробнее об этом
рассказывается в Разделе 20.6.
Для SSPI доступны следующие параметры конфигурации:
include_realm
Когда этот параметр равен 0, из принципала аутентифицированного пользователя убирается
область, и оставшееся имя проходит сопоставление имён (см. Раздел 20.2). Этот вариант не ре-
комендуется и поддерживается в основном для обратной совместимости, так как он небезопа-
сен в окружениях с несколькими областями, если только дополнительно не задаётся krb_realm.
Более предпочтительный вариант — оставить значение include_realm по умолчанию (1) и за-
дать в pg_ident.conf явное сопоставление для преобразования имён принципалов в имена
пользователей PostgreSQL.
compat_realm
Если равен 1, для параметра include_realm применяется имя домена, совместимое с SAM
(также известное как имя NetBIOS). Это вариант по умолчанию. Если он равен 0, для имени
принципала Kerberos применяется действительное имя области.
583Аутентификация кли-
ентского приложения
Этот параметр можно отключить, только если ваш сервер работает под именем доменного поль-
зователя (в том числе, виртуального пользователя службы на компьютере, включённом в до-
мен) и все клиенты, проходящие проверку подлинности через SSPI, также используют домен-
ные учётные записи; в противном случае аутентификация не будет выполнена.
upn_username
Если этот параметр включён вместе с compat_realm, для аутентификации применяется имя
Kerberos UPN. Если он отключён (по умолчанию), применяется SAM-совместимое имя пользо-
вателя. По умолчанию у новых учётных записей эти два имени совпадают.
Заметьте, что libpq использует имя, совместимое с SAM, если имя не задано явно. Если вы
применяете libpq или драйвер на его базе, этот параметр следует оставить отключённым, либо
явно задавать имя пользователя в строке подключения.
map
Позволяет сопоставить пользователей системы с пользователями баз данных. За подробностя-
ми обратитесь к Разделу 20.2. Для принципала SSPI/Kerberos, такого как username@EXAMPLE.COM
(или более редкого username/hostbased@EXAMPLE.COM), именем пользователя в сопоставле-
нии будет username@EXAMPLE.COM (или username/hostbased@EXAMPLE.COM, соответственно), если
include_realm не равно 0; в противном случае именем системного пользователя в сопоставле-
нии будет username (или username/hostbased).
krb_realm
Устанавливает область, с которой будут сверяться имена принципалов пользователей. Если
этот параметр задан, подключаться смогут только пользователи из этой области. Если не за-
дан, подключаться смогут пользователи из любой области, в зависимости от установленного
сопоставления имён пользователей.
20.8. Аутентификация Ident
Метод аутентификации ident работает, получая имя пользователя операционной системы клиента
от сервера Ident и используя его в качестве разрешённого имени пользователя базы данных (с воз-
можным сопоставлением имён пользователя). Способ доступен только для подключений по TCP/IP.
Примечание
Когда для локального подключения (не TCP/IP) указан ident, вместо него используется
метод аутентификации peer (см. Раздел 20.9).
Для метода ident доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
Протокол «Identification» (Ident) описан в RFC 1413. Практически каждая Unix-подобная операци-
онная система поставляется с сервером Ident, по умолчанию слушающим TCP-порт 113. Базовая
функция этого сервера — отвечать на вопросы, вроде «Какой пользователь инициировал подклю-
чение, которое идет через твой порт X и подключается к моему порту Y?». Поскольку после уста-
новления физического подключения PostgreSQL знает и X, и Y, он может опрашивать сервер Ident
на компьютере клиента и теоретически может определять пользователя операционной системы
при каждом подключении.
Недостатком этой процедуры является то, что она зависит от интеграции с клиентом: если кли-
ентская машина не вызывает доверия или скомпрометирована, злоумышленник может запустить
584Аутентификация кли-
ентского приложения
любую программу на порту 113 и вернуть любое имя пользователя на свой выбор. Поэтому этот
метод аутентификации подходит только для закрытых сетей, где каждая клиентская машина нахо-
дится под жёстким контролем и где администраторы операционных систем и баз данных работают
в тесном контакте. Другими словами, вы должны доверять машине, на которой работает сервер
Ident. Помните предупреждение:
Протокол Ident не предназначен для использования как протокол авторизации и кон-
троля доступа.
—RFC 1413
У некоторых серверов Ident есть нестандартная возможность, позволяющая зашифровать возвра-
щаемое имя пользователя, используя ключ, который известен только администратору исходного
компьютера. Эту возможность нельзя использовать с PostgreSQL, поскольку PostgreSQL не сможет
расшифровать возвращаемую строку и получить фактическое имя пользователя.
20.9. Аутентификация peer
Метод аутентификации peer работает, получая имя пользователя операционной системы клиента
из ядра и используя его в качестве разрешённого имени пользователя базы данных (с возможно-
стью сопоставления имён пользователя). Этот метод поддерживается только для локальных под-
ключений.
Для метода peer доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
Аутентификация peer доступна только в операционных системах, поддерживающих функцию
getpeereid(), параметр сокета SO_PEERCRED или подобные механизмы. В настоящее время это
Linux, большая часть разновидностей BSD, включая macOS, и Solaris.
20.10. Аутентификация LDAP
Данный метод аутентификации работает сходным с методом password образом, за исключением
того, что он использует LDAP как метод подтверждения пароля. LDAP используется только для
подтверждения пары “имя пользователя/пароль”. Поэтому пользователь должен уже существовать
в базе данных до того, как для аутентификации будет использован LDAP.
Аутентификация LDAP может работать в двух режимах. Первый режим называется простое связы-
вание. В ходе аутентификации сервер связывается с характерным именем, составленным следую-
щим образом: prefix username suffix. Обычно, параметр prefix используется для указания cn=
или DOMAIN\ в среде Active Directory. suffix используется для указания оставшейся части DN или
в среде, отличной от Active Directory.
Во втором режиме, который мы называем поиск+связывание, сервер сначала связывается с ка-
талогом LDAP с предопределённым именем пользователя и паролем, указанным в ldapbinddn и
ldapbindpasswd, и выполняет поиск пользователя, пытающегося подключиться к базе данных. Ес-
ли имя пользователя и пароль не определены, сервер пытается связаться с каталогом анонимно.
Поиск выполняется в поддереве ldapbasedn, при этом проверятся точное соответствие имени поль-
зователя атрибуту ldapsearchattribute. Как только при поиске находится пользователь, сервер
отключается и заново связывается с каталогом уже как этот пользователь, с паролем, передан-
ным клиентом, чтобы удостовериться, что учётная запись корректна. Этот же режим использует-
ся в схемах LDAP-аутентификации в другом программном обеспечении, например, в pam_ldap и
mod_authnz_ldap в Apache. Данный вариант даёт больше гибкости в выборе расположения объек-
тов пользователей, но при этом требует дважды подключаться к серверу LDAP.
В обоих режимах используются следующие параметры конфигурации:
585Аутентификация кли-
ентского приложения
ldapserver
Имена и IP-адреса LDAP-серверов для связи. Можно указать несколько серверов, разделяя их
пробелами.
ldapport
Номер порта для связи с LDAP-сервером. Если порт не указан, используется установленный по
умолчанию порт библиотеки LDAP.
ldapscheme
Значение ldaps выбирает протокол LDAPS. Это нестандартный способ использования LDAP по-
верх SSL, поддерживаемый некоторыми серверами LDAP. Альтернативную возможность предо-
ставляет параметр ldaptls.
ldaptls
Значение 1 включает TLS-шифрование для защиты соединения PostgreSQL с LDAP-сервером.
При этом используется операция StartTLS, описанная в RFC 4513. Альтернативную возмож-
ность предоставляет параметр ldapscheme.
Заметьте, что при использовании ldapscheme или ldaptls шифруется только трафик между серве-
ром PostgreSQL и сервером LDAP. Соединение между сервером PostgreSQL и клиентом остаётся
незашифрованным, если только и для него не включён SSL.
Следующие параметры используются только в режиме простого связывания:
ldapprefix
Эта строка подставляется перед именем пользователя во время формирования DN для связы-
вания при аутентификации в режиме простого связывания.
ldapsuffix
Эта строка размещается после имени пользователя во время формирования DN для связыва-
ния, при аутентификации в режиме простого связывания.
Следующие параметры используются только в режиме поиск+связывание:
ldapbasedn
Корневая папка DN для начала поиска пользователя при аутентификации в режиме поиск+свя-
зывание.
ldapbinddn
DN пользователя для связи с каталогом при выполнении поиска в ходе аутентификации в ре-
жиме поиск+связывание.
ldapbindpasswd
Пароль пользователя для связывания с каталогом при выполнении поиска в ходе аутентифика-
ции в режиме поиск+связывание.
ldapsearchattribute
Атрибут для соотнесения с именем пользователя в ходе аутентификации поиск+связывание.
Если атрибут не указан, будет использован атрибут uid.
ldapsearchfilter
Фильтр поиска, используемый для аутентификации в режиме поиск+связывание. Вхождения
$username в нём будут заменяться именем пользователя. Это позволяет задавать более гибкие
фильтры поиска, чем ldapsearchattribute.
586Аутентификация кли-
ентского приложения
ldapurl
Адрес LDAP по стандарту RFC 4516. Это альтернативный способ записи некоторых других па-
раметров LDAP в более компактном и стандартном виде. Формат адреса таков:
ldap[s]://сервер[:порт]/basedn[?[атрибут][?[scope][?[фильтр]]]]
Здесь scope принимает значение base, one или sub (обычно последнее). По умолчанию под-
разумевается base, что не очень полезно при таком применении. В качестве атрибута мо-
жет указываться один атрибут; в этом случае он используется как значение параметра
ldapsearchattribute. Если атрибут не указан, в качестве значения ldapsearchfilter может
использоваться фильтр.
Схема адреса ldaps выбирает для установления LDAP-подключений поверх SSL метод LDAPS,
что равнозначно указанию ldapscheme=ldaps. Для применения шифрования LDAP с использо-
ванием операции StartTLS используйте обычную схему URL ldap и укажите параметр ldaptls
в дополнение к ldapurl.
Для неанонимного связывания ldapbinddn и ldapbindpasswd должны быть указаны как раз-
дельные параметры.
В настоящее время URL-адреса LDAP поддерживаются только с OpenLDAP, не в Windows.
Нельзя путать параметры конфигурации для режима простого связывания с параметрами для ре-
жима поиск+связывание, это ошибка.
В режиме поиск+связывание поиск может выполняться либо по одному атрибуту, указанному в
ldapsearchattribute, либо по произвольному фильтру поиска, заданному в ldapsearchfilter. Ука-
зание ldapsearchattribute=foo равнозначно указанию ldapsearchfilter=”(foo=$username)”. Ес-
ли не указан ни один параметр, по умолчанию подразумевается ldapsearchattribute=uid.
Это пример конфигурации LDAP для простого связывания:
host … ldap ldapserver=ldap.example.net ldapprefix=”cn=” ldapsuffix=”, dc=example,
dc=net”
Когда запрашивается подключение к серверу базы данных в качестве пользователя базы дан-
ных someuser, PostgreSQL пытается связаться с LDAP-сервером, используя DN cn=someuser,
dc=example, dc=net и пароль, предоставленный клиентом. Если это подключение удалось, то до-
ступ к базе данных будет открыт.
Пример конфигурации для режима поиск+связывание:
host … ldap ldapserver=ldap.example.net ldapbasedn=”dc=example, dc=net”
ldapsearchattribute=uid
Когда запрашивается подключение к серверу базы данных в качестве пользователя базы данных
someuser, PostgreSQL пытается связаться с сервером LDAP анонимно (поскольку ldapbinddn не
был указан), выполняет поиск для (uid=someuser) под указанной базой DN. Если запись найдена,
проводится попытка связывание с использованием найденной информации и паролем, предостав-
ленным клиентом. Если вторая попытка подключения проходит успешно, предоставляется доступ
к базе данных.
Пример той же конфигурации для режима поиск+связывание, но записанной в виде URL:
host … ldap ldapurl=”ldap://ldap.example.net/dc=example,dc=net?uid?sub”
Такой URL-формат используется и другим программным обеспечением, поддерживающим аутен-
тификацию по протоколу LDAP, поэтому распространять такую конфигурацию будет легче.
Пример конфигурации поиск+связывание, в котором ldapsearchfilter используется вместо
ldapsearchattribute для прохождения аутентификации по идентификатору или почтовому адре-
су пользователя:
587Аутентификация кли-
ентского приложения
host … ldap ldapserver=ldap.example.net ldapbasedn=”dc=example, dc=net”
ldapsearchfilter=”(|(uid=$username)(mail=$username))”
Подсказка
Поскольку LDAP часто применяет запятые и пробелы для разделения различных ча-
стей DN, необходимо использовать кавычки при определении значения параметров,
как показано в наших примерах.
20.11. Аутентификация RADIUS
Данный метод аутентификации работает сходным с методом password образом, за исключением
того, что он использует RADIUS как метод проверки пароля. RADIUS используется только для под-
тверждения пары имя пользователя/пароль. Поэтому пользователь должен уже существовать в ба-
зе данных до того, как для аутентификации будет использован RADIUS.
В ходе аутентификации RADIUS настроенному RADIUS-серверу посылается запрос доступа. Это
сообщение типа Только Аутентификация, которое включает в себя параметры имя пользователя,
пароль (зашифрованный) и идентификатор NAS. Запрос зашифровывается с использованием общего
с сервером секрета. RADIUS-сервер отвечает на запрос сервера либо Доступ принят, либо Доступ
отклонён. Система ведения учёта RADIUS не поддерживается.
Указать можно адреса нескольких серверов RADIUS, тогда они будут перебираться по очереди.
В случае получения от любого сервера отрицательного ответа произойдёт сбой аутентификации.
Если ответ не будет получен, последует попытка подключения к следующему серверу в списке.
Чтобы задать имена нескольких серверов, заключите их в кавычки и разделите запятыми. Если
указывается несколько серверов, все остальные параметры RADIUS так же должны записываться
в списке через запятую, чтобы каждый сервер получил собственное значение. Возможно также
задавать их единственным значением, в этом случае это значение будет применяться ко всем сер-
верам.
Для метода RADIUS доступны следующие параметры конфигурации:
radiusservers
Имена или IP-адреса серверов RADIUS для подключения. Это обязательный параметр.
radiussecrets
Общие секреты, используемые при общении с сервером RADIUS. Секрет должен быть одинако-
вым на серверах PostgreSQL и RADIUS. Рекомендуется использовать строку как минимум из 16
символов. Это обязательный параметр.
Примечание
Шифровальный вектор будет достаточно эффективен только в том случае, если
PostgreSQL собран с поддержкой OpenSSL. В противном случае, передача данных
серверу RADIUS будет лишь замаскированной, но не защищённой, поэтому необхо-
димо принять дополнительные меры безопасности.
radiusports
Номер порта для подключения к серверам RADIUS. Если порт не указан, по умолчанию исполь-
зуется порт 1812.
radiusidentifiers
Строка, используемая в запросах сервера RADIUS как Идентификатор NAS. Этот параметр мо-
жет использоваться как второй параметр, выявляющий, например, какой пользователь пыта-
588Аутентификация кли-
ентского приложения
ется подключиться под каким пользователем базы данных, что может быть использовано для
формирования соответствий на сервере RADIUS. Если не указан идентификатор, по умолчанию
используется postgresql.
20.12. Аутентификация по сертификату
Для аутентификации в рамках этого метода используется клиентский сертификат SSL, поэтому
данный способ применим только для SSL-подключений. Когда используется этот метод, сервер
потребует от клиента предъявления действительного и доверенного сертификата. Пароль у кли-
ента не запрашивается. Атрибут cn (Обычное имя) сертификата сравнивается с запрашиваемым
именем пользователя базы данных, и если они соответствуют, вход разрешается. Если cn отлича-
ется от имени пользователя базы данных, то может быть использовано сопоставление имён поль-
зователей.
Для аутентификации по SSL сертификату доступны следующие параметры конфигурации:
map
Позволяет сопоставить имена пользователей системы и базы данных. За подробностями обра-
титесь к Разделу 20.2.
В записи pg_hba.conf, описывающей аутентификацию по сертификату, параметр clientcert пред-
полагается равным 1, и его нельзя отключить, так как для этого метода клиентский сертификат
является обязательным. Метод cert отличается от простой проверки пригодности сертификата
clientcert только тем, что также проверяет, соответствует ли атрибут cn имени пользователя ба-
зы данных.
20.13. Аутентификация PAM
Данный метод аутентификации работает подобно методу password, но использует в качестве ме-
ханизма проверки подлинности PAM (Pluggable Authentication Modules, Подключаемые модули
аутентификации). По умолчанию имя службы PAM — postgresql. PAM используется только для
проверки пар “имя пользователя/пароль” и может дополнительно проверять имя или IP-адрес уда-
лённого компьютера. Поэтому пользователь должен уже существовать в базе данных, чтобы PAM
можно было использовать для аутентификации. За дополнительной информацией о PAM обрати-
тесь к Странице описания Linux-PAM.
Для аутентификации PAM доступны следующие параметры конфигурации:
pamservice
Имя службы PAM
pam_use_hostname
Указывает, предоставляется ли модулям PAM через поле PAM_RHOST IP-адрес либо имя удалён-
ного компьютера. По умолчанию выдаётся IP-адрес. Установите в этом параметре 1, чтобы ис-
пользовать имя узла. Разрешение имени узла может приводить к задержкам при подключении.
(Обычно конфигурации PAM не задействуют эту информацию, так что этот параметр следует
учитывать, только если создана специальная конфигурация, в которой он используется.)
Примечание
Если PAM настроен для чтения /etc/shadow, произойдёт сбой аутентификации, потому
что сервер PostgreSQL запущен не пользователем root. Однако это не имеет значения,
когда PAM настроен для использования LDAP или других методов аутентификации.
20.14. Аутентификация BSD
589Аутентификация кли-
ентского приложения
Данный метод аутентификации работает подобно методу password, но использует для проверки
пароля механизм аутентификации BSD. Аутентификация BSD используется только для проверки
пар “имя пользователя/пароль”. Поэтому роль пользователя должна уже существовать в базе дан-
ных, чтобы эта аутентификация была успешной. Механизм аутентификации BSD в настоящее вре-
мя может применяться только в OpenBSD.
Для аутентификации BSD в PostgreSQL применяется тип входа auth-postgresql и класс
postgresql, если он определён в login.conf. По умолчанию этот класс входа не существует и
PostgreSQL использует класс входа по умолчанию.
Примечание
Для использования аутентификации BSD необходимо сначала добавить учётную за-
пись пользователя PostgreSQL (то есть, пользователя ОС, запускающего сервер) в груп-
пу auth. Группа auth существует в системах OpenBSD по умолчанию.
20.15. Проблемы аутентификации
Сбои и другие проблемы с аутентификацией обычно дают о себе знать через сообщения об ошиб-
ках, например:
FATAL: no pg_hba.conf entry for host “123.123.123.123”, user “andym”, database
“testdb”
Это сообщение вы, скорее всего, получите, если сможете связаться с сервером, но он не захочет
с вами общаться. В сообщении содержится предположение, что сервер отказывает вам в подклю-
чении, поскольку не может найти подходящую запись в файле pg_hba.conf.
FATAL:
password authentication failed for user “andym”
Такое сообщение показывает, что вы связались с сервером, он готов общаться с вами, но только
после того, как вы прошли авторизацию по методу, указанному в файле pg_hba.conf. Проверьте
пароль, который вы вводите, и как настроен Kerberos или ident, если в сообщении упоминается
один из этих типов аутентификации.
FATAL:
user “andym” does not exist
Указанное имя пользователя базы данных не найдено.
FATAL:
database “testdb” does not exist
База данных, к которой вы пытаетесь подключиться, не существует. Имейте в виду, что если вы
не указали имя базы данных, по умолчанию берётся имя пользователя базы данных, что может
приводить к ошибкам.
Подсказка
В журнале сервера может содержаться больше информации, чем в выдаваемых кли-
енту сообщениях об ошибке аутентификации, поэтому, если вас интересуют причины
сбоя, проверьте журнал сервера.
590</li>
</ol>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#PostgreSQL" title="Pages tagged PostgreSQL" class="tag"><span class="term">PostgreSQL</span></a></span>
        <span>Updated on <span class="entry-date date updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/PostgreSQL-V11_Doc-020/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/PostgreSQL-V11_Doc-020/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/PostgreSQL-V11_Doc-020/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/PostgreSQL-V11_Doc-019/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/PostgreSQL-V11_Doc-077/" title="Приложение G. Дополнительно поставляемые программы">Приложение G. Дополнительно поставляемые программы</a></h3>
      <p> <a href="http://localhost:4000/PostgreSQL-V11_Doc-077/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-076/" title="Приложение F. Дополнительно поставляемые модули">Приложение F. Дополнительно поставляемые модули</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/PostgreSQL-V11_Doc-075/" title="Приложение E. Замечания к выпуску">Приложение E. Замечания к выпуску</a></h4>
        <span>Published on December 01, 2018</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
