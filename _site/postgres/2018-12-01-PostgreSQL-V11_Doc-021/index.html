<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 21. Роли базы данных &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 21. Роли базы данных">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 21. Роли базы данных">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-021/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-021/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="page" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 21. Роли базы данных">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        <h1 class="entry-title">Глава 21. Роли базы данных</h1>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~12 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 21. Роли базы данных</p>

<p>PostgreSQL использует концепцию ролей (roles) для управления разрешениями на доступ к базе
данных. Роль можно рассматривать как пользователя базы данных или как группу пользователей,
в зависимости от того, как роль настроена. Роли могут владеть объектами базы данных (например,
таблицами и функциями) и выдавать другим ролям разрешения на доступ к этим объектам, управ-
ляя тем, кто имеет доступ и к каким объектам. Кроме того, можно предоставить одной роли член-
ство в другой роли, таким образом одна роль может использовать привилегии других ролей.
Концепция ролей включает в себя концепцию пользователей («users») и групп («groups»). До вер-
сии 8.1 в PostgreSQL пользователи и группы были отдельными сущностями, но теперь есть только
роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.
В этой главе описывается как создавать и управлять ролями. Дополнительную информацию о при-
вилегиях для ролей на различные объекты базы данных можно найти в Разделе 5.6.
21.1. Роли базы данных
Роли базы данных концептуально полностью отличаются от пользователей операционной системы.
На практике поддержание соответствия между ними может быть удобным, но не является обяза-
тельным. Роли базы данных являются глобальными для всей установки кластера базы данных (не
для отдельной базы данных). Для создания роли используется команда SQL CREATE ROLE:
CREATE ROLE имя;
Здесь имя соответствует правилам именования идентификаторов SQL: либо обычное, без специ-
альных символов, либо в двойных кавычках. (На практике, к команде обычно добавляются другие
указания, такие как LOGIN. Подробнее об этом ниже.) Для удаления роли используется команда
DROP ROLE:
DROP ROLE имя;
Для удобства поставляются программы createuser и dropuser, которые являются обёртками для
этих команд SQL и вызываются из командной строки оболочки ОС:
createuser имя
dropuser имя
Для получения списка существующих ролей, рассмотрите pg_roles системного каталога, напри-
мер:
SELECT rolname FROM pg_roles;
Метакоманда \du программы psql также полезна для получения списка существующих ролей.
Для начальной настройки кластера базы данных, система сразу после инициализации всегда со-
держит одну предопределённую роль. Эта роль является суперпользователем («superuser») и по
умолчанию (если не изменено при запуске initdb) имеет такое же имя, как и пользователь опера-
ционной системы, инициализирующий кластер баз данных. Обычно эта роль называется postgres.
Для создания других ролей, вначале нужно подключиться с этой ролью.
Каждое подключение к серверу базы данных выполняется под именем конкретной роли и эта роль
определяет начальные привилегии доступа для команд выполняемых в этом соединении. Имя ро-
ли для конкретного подключения к базе данных указывается клиентской программой характер-
ным для неё способом, таким образом инициируя запрос на подключение. Например, программа
psql для указания роли использует аргумент командной строки -U. Многие приложения предпо-
лагают, что по умолчанию нужно использовать имя пользователя операционной системы (включая
createuser и psql). Поэтому часто бывает удобным поддерживать соответствие между именами
ролей и именами пользователей операционной системы.
591Роли базы данных
Список доступных для подключения ролей, который могут использовать клиенты, определяется
конфигурацией аутентификации, как описывалось в Главе 20. (Поэтому, клиент не ограничен толь-
ко ролью, соответствующей имени пользователя операционной системы, также как и имя для вхо-
да может не соответствовать реальному имени.) Так как роль определяет набор доступных приви-
легий, очень важно тщательно настраивать привилегии в многопользовательской среде.
21.2. Атрибуты ролей
Роль базы данных может иметь атрибуты, определяющие её полномочия и взаимодействие с си-
стемой аутентификации клиентов.
Право подключения
Только роли с атрибутом LOGIN могут использоваться для начального подключения к базе дан-
ных. Роль с атрибутом LOGIN можно рассматривать как пользователя базы данных. Для созда-
ния роли такой роли можно использовать любой из вариантов:
CREATE ROLE имя LOGIN;
CREATE USER имя;
(Команда CREATE USER эквивалентна CREATE ROLE за исключением того, что CREATE USER по
умолчанию включает атрибут LOGIN, в то время как CREATE ROLE — нет.)
Статус суперпользователя
Суперпользователь базы данных обходит все проверки прав доступа, за исключением права на
вход в систему. Это опасная привилегия и она не должна использоваться небрежно. Лучше
всего выполнять большую часть работы не как суперпользователь. Для создания нового супер-
пользователя используется CREATE ROLE имя SUPERUSER. Это нужно выполнить из под роли,
которая также является суперпользователем.
Создание базы данных
Роль должна явно иметь разрешение на создание базы данных (за исключением суперпользо-
вателей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEDB.
Создание роли
Роль должна явно иметь разрешение на создание других ролей (за исключением суперполь-
зователей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEROLE. Роль с привилегией CREATEROLE может также изменять и удалять другие
роли, а также выдавать и отзывать членство в ролях. Однако, для создания, изменения, удале-
ния суперпользовательских ролей, а также изменения в них членства, требуется иметь статус
суперпользователя; привилегии CREATEROLE в таких случаях недостаточно.
Запуск репликации
Роль должна иметь явное разрешение на запуск потоковой репликации (за исключением су-
перпользователей, которые пропускают все проверки). Роль, используемая для потоковой ре-
пликации, также должна иметь атрибут LOGIN. Для создания такой роли используется CREATE
ROLE имя REPLICATION LOGIN.
Пароль
Пароль имеет значение, если метод аутентификации клиентов требует, чтобы пользователи
предоставляли пароль при подключении к базе данных. Методы аутентификации password и
md5 используют пароли. База данных и операционная система используют раздельные пароли.
Пароль указывается при создании роли: CREATE ROLE имя PASSWORD ‘строка’.
Атрибуты ролей могут быть изменены после создания командой ALTER ROLE.Более детальная ин-
формация в справке по командам CREATE ROLE и ALTER ROLE.
592Роли базы данных
Подсказка
Рекомендуется создать роль с привилегиями CREATEDB и CREATEROLE, но не суперполь-
зователя и в последующем использовать её для управления базами данных и ролями.
Такой подход позволит избежать опасностей, связанных с использованием полномочий
суперпользователя для задач, которые их не требуют.
На уровне ролей можно устанавливать многие конфигурационные параметры времени выполне-
ния, описанные в Главе 19. Например, если по некоторым причинам всякий раз при подключении
к базе данных требуется отключить использование индексов (подсказка: плохая идея) можно вы-
полнить:
ALTER ROLE myname SET enable_indexscan TO off;
Установленное значение параметра будет сохранено (но не будет применено сразу). Для по-
следующих подключений с этой ролью это будет выглядеть как выполнение команды SET
enable_indexscan TO off перед началом сессии. Но это только значение по умолчанию, в течение
сессии эту установку можно изменить. Для удаления установок на уровне ролей для параметров
конфигурации используется ALTER ROLE rolename RESET varname. Обратите внимание, что уста-
новка параметров конфигурации на уровне роли без привилегии LOGIN лишено смысла, т. к. они
никогда не будут применены,
21.3. Членство в роли
Часто бывает удобным сгруппировать пользователей для упрощения администрирования приви-
легий: привилегии выдаются или отзываются на всю группу. В PostgreSQL для этого создаётся
роль, которая представляет группу, а затем членство (membership) в этой группе выдаётся ролям
индивидуальных пользователей.
Для настройки групповой роли, сначала нужно создать саму роль:
CREATE ROLE имя;
Обычно групповая роль не имеет атрибута LOGIN, хотя при желании его можно установить.
После того как групповая роль создана, в неё можно добавлять или удалять членов, используя
команды GRANT и REVOKE:
GRANT group_role TO role1, … ;
REVOKE group_role FROM role1, … ;
Можно выдавать членство в групповой роли другим групповым ролям (потому что в действитель-
ности нет никаких различий между групповыми и не групповыми ролями). База данных не позво-
лит замкнуть предоставление членства по кругу. Также, не допускается выдача членства в роли
для PUBLIC.
Члены групповой роли могут использовать её привилегии двумя способами. Во-первых, каждый
член группы может явно выполнить SET ROLE, чтобы временно «стать» групповой ролью. В этом
состоянии, сессия базы данных использует полномочия групповой роли, вместо оригинальной ро-
ли, под которой был выполнен вход в систему. При этом для всех создаваемых объектов базы дан-
ных владельцем считается групповая, а не оригинальная роль. Во-вторых, роли, имеющие атрибут
INHERIT, автоматически используют привилегии всех ролей, членами которых они являются, в том
числе и унаследованными этими ролями привилегиями. Например:
CREATE ROLE
CREATE ROLE
CREATE ROLE
GRANT admin
GRANT wheel
joe LOGIN INHERIT;
admin NOINHERIT;
wheel NOINHERIT;
TO joe;
TO admin;
После подключения с ролью joe, сессия базы данных будет использовать полномочия выданные
напрямую joe и привилегии выданные admin, так как joe “наследует” привилегии admin. Однако
593Роли базы данных
привилегии выданные wheel не будут доступны, потому что, хотя joe неявно и является членом
wheel, это членство получено через роль admin, которая имеет атрибут NOINHERIT. После выпол-
нения команды:
SET ROLE admin;
сессия будет использовать только привилегии выданные admin, привилегии выданные joe не будут
доступны. После выполнения команды:
SET ROLE wheel;
сессия будет использовать только привилегии выданные wheel, привилегии joe и admin не будут
доступны. Начальный набор привилегий можно вернуть любой из команд:
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
Примечание
Команда SET ROLE в любой момент разрешает выбрать любую роль, прямым или кос-
венным членом которой является оригинальная роль, под которой был выполнен вход
в систему. Поэтому, в примере выше, не обязательно сначала становиться admin, перед
тем как стать wheel.
Примечание
В стандарте SQL есть чёткое различие между пользователями и ролями. При этом поль-
зователи не наследуют автоматически привилегии, а роли наследуют автоматически.
Такое поведение может быть получено в PostgreSQL, если для ролей, используемых как
роли в стандарте SQL, устанавливать атрибут INHERIT, а для ролей, используемых как
пользователи в стандарте SQL, устанавливать атрибут NOINHERIT. Однако, в PostgreSQL
все роли по умолчанию имеют атрибут INHERIT. Это сделано для обратной совместимо-
сти с версиями предшествующими 8.1, в которых пользователи всегда могли исполь-
зовать привилегии групп, членами которых они являются.
Атрибуты роли LOGIN, SUPERUSER, CREATEDB и CREATEROLE можно рассматривать как особые приви-
легии, но они никогда не наследуются, как обычные привилегии на объекты базы данных. Необхо-
димо через SET ROLE установить роль, имеющую один из этих атрибутов, чтобы им воспользовать-
ся. Продолжая предыдущий пример, можно установить атрибуты CREATEDB и CREATEROLE для роли
admin. Затем при входе с ролью joe, получить доступ к этим привилегиям будет возможно только
после выполнения SET ROLE admin.
Для удаления групповой роли используется DROP ROLE:
DROP ROLE имя;
Любое членство в групповой роли будет автоматически отозвано (в остальном на членов этой роли
это никак не повлияет).
21.4. Удаление ролей
Так как роли могут владеть объектами баз данных и иметь права доступа к объектам других, уда-
ление роли не сводится к немедленному действию DROP ROLE. Сначала должны быть удалены и
переданы другим владельцами все объекты, принадлежащие роли; также должны быть отозваны
все права, данные роли.
594Роли базы данных
Владение объектами можно передавать в индивидуальном порядке, применяя команду ALTER, на-
пример:
ALTER TABLE bobs_table OWNER TO alice;
Кроме того, для переназначения какой-либо другой роли владения сразу всеми объектами, при-
надлежащих удаляемой роли, можно применить команду REASSIGN OWNED. Так как REASSIGN
OWNED не может обращаться к объектам в других базах данных, её необходимо выполнить в каждой
базе, которая содержит объекты, принадлежащие этой роли. (Заметьте, что первая такая команда
REASSIGN OWNED изменит владельца для всех разделяемых между базами объектов, то есть для баз
данных или табличных пространств, принадлежащих удаляемой роли.)
После того как все ценные объекты будут переданы новым владельцам, все оставшиеся объекты,
принадлежащие удаляемой роли, могут быть удалены с помощью команды DROP OWNED. И эта
команда не может обращаться к объектам в других базах данных, так что её нужно запускать в
каждой базе, которая содержит объекты, принадлежащие роли. Также заметьте, что DROP OWNED не
удаляет табличные пространства или базы данных целиком, так что это необходимо сделать вруч-
ную, если роли принадлежат базы или табличные пространства, не переданные новым владельцам.
DROP OWNED также удаляет все права, которые даны целевой роли для объектов, не принадлежа-
щих ей. Так как REASSIGN OWNED такие объекты не затрагивает, обычно необходимо запустить и
REASSIGN OWNED, и DROP OWNED (в этом порядке!), чтобы полностью ликвидировать зависимости
удаляемой роли.
С учётом этого, общий рецепт удаления роли, которая владела объектами, вкратце таков:
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
– повторить предыдущие команды для каждой базы в кластере
DROP ROLE doomed_role;
Когда не все объекты нужно передать одному новому владельцу, лучше сначала вручную отрабо-
тать исключения, а в завершение выполнить показанные выше действия.
При попытке выполнить DROP ROLE для роли, у которой сохраняются зависимые объекты, будут
выданы сообщения, говорящие, какие объекты нужно передать другому владельцу или удалить.
21.5. Предопределённые роли
В PostgreSQL имеется набор предопределённых ролей, которые дают доступ к некоторым часто
востребованным, но не общедоступным функциям и данным. Администраторы могут назначать
(GRANT) эти роли пользователям и/или ролям в своей среде, таким образом открывая этим поль-
зователям доступ к указанной функциональности и информации.
Имеющиеся предопределённые роли описаны в Таблице 21.1. Заметьте, что конкретные разреше-
ния для каждой из предопределённых ролей в будущем могут изменяться по мере добавления до-
полнительной функциональности. Администраторы должны следить за этими изменениями, про-
сматривая замечания к выпускам.
Таблица 21.1. Предопределённые роли
Роль Разрешаемый доступ
pg_read_all_settings Читать все конфигурационные переменные, да-
же те, что обычно видны только суперпользова-
телям.
pg_read_all_stats Читать все представления pg_stat_* и использо-
вать различные расширения, связанные со ста-
тистикой, даже те, что обычно видны только су-
перпользователям.
595Роли базы данных
Роль Разрешаемый доступ
pg_stat_scan_tables Выполнять функции мониторинга, которые мо-
гут устанавливать блокировки ACCESS SHARE в
таблицах, возможно, на длительное время.
pg_signal_backend Передавать сигналы другим обслуживающим
процессам (например, отменять запрос, завер-
шать процесс).
pg_read_server_files Читать файлы в любом месте файловой системы,
куда имеет доступ СУБД на сервере, выполняя
COPY и другие функции работы с файлами.
pg_write_server_files Записывать файлы в любом месте файловой си-
стемы, куда имеет доступ СУБД на сервере, вы-
полняя COPY и другие функции работы с файла-
ми.
pg_execute_server_program Выполнять программы на сервере (от имени
пользователя, запускающего СУБД), так же, как
это делает команда COPY и другие функции, вы-
полняющие программы на стороне сервера.
pg_monitor Читать/выполнять различные представления и
функции для мониторинга. Эта роль включена в
роли pg_read_all_settings
, pg_read_all_
stats и pg_stat_scan_tables
.
Роли pg_read_server_files, pg_write_server_files и pg_execute_server_program предназначе-
ны для того, чтобы администраторы могли выделить доверенные, но не имеющие права суперполь-
зователей роли для доступа к файлам и запуска программ на сервере БД от имени пользователя,
запускающего СУБД. Так как эти роли могут напрямую обращаться к любым файлам в файловой
системе сервера, они обходят все проверки разрешений на уровне базы данных, а значит, восполь-
зовавшись ими, можно получить права суперпользователя. Поэтому назначать их пользователям
следует со всей осторожностью.
Роли pg_monitor, pg_read_all_settings, pg_read_all_stats и pg_stat_scan_tables созданы для
того, чтобы администраторы могли легко настроить роль для мониторинга сервера БД. Эти роли
наделяют своих членов набором общих прав, позволяющих читать различные полезные парамет-
ры конфигурации, статистику и другую системную информацию, что обычно доступно только су-
перпользователям.
Управлять членством в этих ролях следует осмотрительно, чтобы они использовались только по
необходимости и только с пониманием, что они открывают доступ к закрытой информации.
Администраторы могут давать пользователям доступ к этим ролям, используя команду GRANT:
GRANT pg_signal_backend TO admin_user;
21.6. Безопасность функций
Функции, триггеры и политики защиты на уровне строк позволяют пользователям внедрять код
в обслуживающие процессы, который может быть непреднамеренно выполнен другими пользова-
телями. Таким образом эти механизмы позволяют пользователям запускать «троянский код» от-
носительно просто. Лучшая защита от этого — строгое ограничение круга лиц, которые могут со-
здавать объекты. Там где это невозможно, пишите запросы так, чтобы они ссылались только на
объекты с доверенными владельцами. Удалите из search_path схему public и любые другие схемы,
в которых могут создавать объекты недоверенные пользователи.
Функции выполняются внутри серверного процесса с полномочиями пользователя операционной
системы, запускающего сервер базы данных. Если используемый для функций язык программи-
рования разрешает неконтролируемый доступ к памяти, то это даёт возможность изменить внут-
596Роли базы данных
ренние структуры данных сервера. Таким образом, помимо всего прочего, такие функции могут
обойти ограничения доступа к системе. Языки программирования, допускающие такой доступ,
считаются «недоверенными» и создавать функции на этих языках PostgreSQL разрешает только
суперпользователям.</p>

      <footer class="entry-meta">
        <span>Updated on <span class="entry-date date published updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-021/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-021/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-021/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>
