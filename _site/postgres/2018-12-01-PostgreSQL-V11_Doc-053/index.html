<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 53. Клиент-серверный протокол &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 53. Клиент-серверный протокол">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 53. Клиент-серверный протокол">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-053/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-053/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="page" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 53. Клиент-серверный протокол">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        <h1 class="entry-title">Глава 53. Клиент-серверный протокол</h1>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~76 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 53. Клиент-серверный протокол</p>

<p>Клиенты и серверы PostgreSQL взаимодействуют друг с другом, используя специальный протокол,
основанный на сообщениях. Этот протокол поддерживается для соединений по TCP/IP и через
Unix-сокеты. Для серверов, поддерживающих этот протокол, в IANA зарезервирован номер TCP-
порта 5432, но на практике можно задействовать любой порт, не требующий особых привилегий.
В этой документации описана версия 3.0 этого протокола, реализованная в PostgreSQL версии
7.4 и новее. За описанием предыдущих версий протокола обратитесь к документации более ран-
них выпусков PostgreSQL. Один сервер способен поддерживать несколько версий протокола. Ка-
кую версию протокола пытается использовать клиент, сервер узнаёт из стартового сообщения при
установлении соединения. Если старшая версия, запрашиваемая клиентом, не поддерживается
сервером, соединение будет разорвано (например, это будет иметь место, если клиент запросит
протокол версии 4.0, несуществующий на момент написания этого текста). Если младшая версия,
запрашиваемая клиентом, не поддерживается сервером (например, клиент запросил версию 3.1,
а сервер поддерживает только 3.0), сервер может либо разорвать соединение, либо ответить со-
общением NegotiateProtocolVersion с указанием наибольшей младшей версии, которую он поддер-
живает. Затем клиент может решить либо продолжить установление соединения с указанной вер-
сией протокола, либо разорвать соединение.
Чтобы эффективно обслуживать множество клиентов, сервер запускает отдельный «обслуживаю-
щий» процесс для каждого клиента. В текущей реализации новый дочерний процесс запускается
немедленно после обнаружения входящего подключения. Однако это происходит прозрачно для
протокола. С точки зрения протокола, термины «обслуживающий процесс», «процесс заднего пла-
на» и «сервер» взаимозаменяемы, как и «приложение переднего плана» и «клиент».
53.1. Обзор
В протоколе выделены отдельные фазы для запуска и обычных операций. На стадии запуска кли-
ент устанавливает подключение к серверу и должен удовлетворить сервер, подтвердив свою под-
линность. (Для этого может потребоваться одно или несколько сообщений, в зависимости от при-
меняемого метода проверки подлинности.) Если всё проходит успешно, сервер сообщает клиенту
о текущем состоянии, а затем переходит к обычной работе. Не считая начального стартового со-
общения, в этой фазе протокола ведущую роль играет сервер.
В ходе обычной работы клиент передаёт запросы и другие команды серверу, а сервер возвращает
результаты запросов и другие ответы. В некоторых случаях (например, с NOTIFY) сервер переда-
ёт клиенту сообщения по своей инициативе, но по большей части эта фаза сеанса управляется
запросами клиента.
Завершение сеанса обычно происходит по желанию клиента, но в некоторых случаях и сервер
может принудительно завершить сеанс. В любом случае, когда сервер закрывает соединение, он
предварительно откатывает любую открытую (незавершённую) транзакцию.
В процессе обычной работы команды SQL могут выполняться по одному из двух внутренних про-
токолов. По протоколу «простых запросов» клиент посылает просто текстовую строку запроса, ко-
торую сервер сразу же разбирает и выполняет. С протоколом «расширенных запросов» обработ-
ка запросов разделяется на несколько этапов: разбор, привязывание значений параметров и ис-
полнение. Это даёт дополнительную гибкость и может увеличить быстродействие ценой большей
сложности.
В обычном режиме также поддерживаются дополнительные внутренние протоколы для специаль-
ных операций, например COPY.
53.1.1. Обзор обмена сообщениями
Всё взаимодействие представляет собой поток сообщений. Первый байт сообщения определяет
тип сообщения, а следующие четыре байта задают длину остального сообщения (эта длина вклю-
чает размер самого поля длины, но не байт с типом сообщения). Остальное содержимое сообщения
2023Клиент-серверный протокол
определяется его типом. По историческим причинам в самом первом сообщении, передаваемом
клиентом, (стартовом сообщении) первый байт с типом сообщения отсутствует.
Чтобы не потерять синхронизацию в потоке сообщений, и серверы, и клиенты обычно считывают
всё сообщение в буфер (его размер определяется счётчиком байт), прежде чем обрабатывать его
содержимое. Это позволяет без труда продолжить работу, если возникает ошибка при разборе со-
общения. В исключительных случаях (например, при нехватке памяти для помещения сообщения
в буфер), счётчик байт помогает получателю определить, сколько поступающих байт нужно про-
пустить, прежде чем продолжать получать сообщения.
С другой стороны, и клиенты, и серверы, ни при каких условиях не должны передавать неполные
сообщения. Чтобы этого не допустить, обычно всё сообщение сначала размещается в буфере, и
только потом передаётся. Если в процессе отправки или получения сообщения происходит сбой
передачи, единственным разумным вариантом продолжения будет прерывание соединения, так
как вероятность восстановления синхронизации по границам сообщений в этой ситуации мини-
мальна.
53.1.2. Обзор расширенных запросов
В протоколе расширенных запросов исполнение команд SQL разделяется на несколько этапов.
Состояние между этапами представляется объектами двух типов: подготовленные операторы и
порталы. Подготовленный оператор представляет собой результат разбора и семантического ана-
лиза текстовой строки запроса. Подготовленный оператор сам по себе не готов для исполнения,
так как он может не иметь конкретных значений для параметров. Портал представляет собой
готовый к исполнению или уже частично выполненный оператор, в котором заданы все недоста-
ющие значения параметров. (Для операторов SELECT портал равнозначен открытому курсору, но
мы выбрали другой термин, так как курсоры неприменимы к операторам, отличным от SELECT.)
Общий цикл выполнения состоит из этапа разбора, на котором из текстовой строки запроса со-
здаётся подготовленный оператор; этапа привязки, на котором из подготовленного оператора и
значений для необходимых параметров создаётся портал; и этапа выполнения, на котором испол-
няется запрос портала. В случае запроса, возвращающего строки (SELECT, SHOW и т. д.), можно ука-
зать, чтобы за один шаг выполнения возвращалось только ограниченное число строк, так что для
завершения операции понадобятся несколько шагов выполнения.
Сервер может контролировать одновременно несколько подготовленных операторов и порталов
(но учтите, что они существуют только в рамках сеанса и никогда не разделяются между сеан-
сами). Обращаться к подготовленным операторам и порталам можно по именам, которые назна-
чаются им при создании. Кроме того, существуют и «безымянные» подготовленные операторы и
порталы. Хотя они практически не отличаются от именованных объектов, операции с ними опти-
мизированы для разового выполнения запроса с последующим освобождением объекта, тогда как
операции с именованными объектами оптимизируются в расчёте на многоразовое использование.
53.1.3. Форматы и коды форматов
Данные определённого типа могут передаваться в одном из нескольких различных форматов. С
версии 7.4 PostgreSQL поддерживаются только текстовый («text») и двоичный («binary») форматы,
но в протоколе предусмотрены возможности для расширения в будущем. Ожидаемый формат для
любого значения задаётся кодом формата. Клиенты могут указывать код формата для каждого
передаваемого значения параметра и для каждого столбца результата запроса. Текстовый формат
имеет код ноль, двоичный — код один, а другие коды оставлены для определения в будущем.
Текстовым представлением значений будут строки, которые выдаются и принимаются функциями
ввода/вывода определённого типа данных. В передаваемом представлении завершающий нулевой
символ отсутствует, клиент должен добавить его сам, если хочет обрабатывать такое представле-
ние в виде строки C. (Собственно, данные в текстовом формате не могут содержать нулевые сим-
волы.)
В двоичном представлении целых чисел применяется сетевой порядок байт (наиболее значащий
байт первый). Какое именно двоичное представление имеют другие типы данных, можно узнать
2024Клиент-серверный протокол
в документации или исходном коде. Но учтите, что двоичное представление сложных типов дан-
ных может меняться от версии к версии сервера; с точки зрения портируемости обычно лучше
текстовый формат.
53.2. Поток сообщений
В этом разделе описывается поток сообщений и семантика каждого типа сообщений. (Подробнее
точное представление каждого сообщения описывается в Разделе 53.7.) В зависимости от состоя-
ния соединения выделяются несколько различных подразделов протокола: запуск, запрос, вызов
функции, копирование (COPY) и завершение. Есть также специальные средства для асинхронных
операций (в частности, для уведомлений и отмены команд), которые могут выполняться в любой
момент после этапа запуска.
53.2.1. Запуск
Чтобы начать сеанс, клиент открывает подключение к серверу и передаёт стартовое сообщение.
В этом сообщении содержатся имена пользователя и базы данных, к которой пользователь хочет
подключиться; в нём также определяется, какая именно версия протокола будет использоваться.
(Стартовое сообщение также может содержать дополнительные значения для параметров време-
ни выполнения.) Проанализировав эту информацию и содержимое своих файлов конфигурации (в
частности, pg_hba.conf), сервер определяет, можно ли предварительно разрешить это подключе-
ние, и какая дополнительная проверка подлинности требуется.
Затем сервер отправляет соответствующее сообщение с запросом аутентификации, на которое
клиент должен ответить сообщением, подтверждающим его подлинность (например, по паролю).
Для всех методов аутентификации, за исключением GSSAPI, SSPI и SASL, может быть максимум
один запрос и один ответ. Для некоторых методов ответ клиента вообще не требуется, так что
запрос аутентификации также не передаётся. Методы GSSAPI, SSPI и SASL для прохождения про-
верки подлинности могут потребовать выполнить серию обменов пакетами.
Цикл аутентификации заканчивает сервер, либо запрещая соединение (ErrorResponse), либо при-
нимая его (отправляя AuthenticationOk).
Сервер может передавать в этой фазе следующие сообщения:
ErrorResponse (Ошибочный ответ)
Попытка соединения была отвергнута. Сразу после этого сервер закрывает соединение.
AuthenticationOk (Аутентификация пройдена)
Обмен сообщениями для проверки подлинности завершён успешно.
AuthenticationKerberosV5 (Аутентификация Kerberos V5)
Клиент должен теперь принять участие в диалоге аутентификации по протоколу Kerberos V5
(здесь его детали не описывается, так как они относятся к спецификации Kerberos) с сер-
вером. Если этот диалог завершается успешно, сервер отвечает AuthenticationOk, иначе —
ErrorResponse. Этот вариант аутентификации больше не поддерживается.
AuthenticationCleartextPassword (Аутентификация с открытым паролем)
Клиент должен передать в ответ сообщение PasswordMessage, содержащее пароль в открытом
виде. Если пароль правильный, сервер отвечает ему AuthenticationOk, иначе — ErrorResponse.
AuthenticationMD5Password (Аутентификация с паролем MD5)
Клиент должен передать в ответ сообщение PasswordMessage с результатом преобразова-
ния пароля (и имени пользователя) в хеш MD5 с последующим хешированием с четырёх-
байтовым случайным значением соли, переданным в сообщении AuthenticationMD5Password.
Если пароль правильный, сервер отвечает AuthenticationOk, иначе — ErrorResponse.
Содержимое сообщения PasswordMessage можно вычислить в SQL как concat(‘md5’,
2025Клиент-серверный протокол
md5(concat(md5(concat(password, username)), random-salt))). (Учтите, что функция md5()
возвращает результат в виде шестнадцатеричной строки.)
AuthenticationSCMCredential (Аутентификация по учётным данным SCM)
Этот ответ возможен только для локальных подключений через Unix-сокеты на платформах,
поддерживающих сообщения с учётными данными SCM. Клиент должен выдать сообщение
с учётными данными SCM и дополнительно отправить один байт данных. (Содержимое это-
го байта не представляет интереса; его нужно передавать, только чтобы сервер дожидал-
ся сообщения с учётными данными.) Если сервер принимает учётные данные, он отвечает
AuthenticationOk, иначе — ErrorResponse. (Этот тип сообщений выдают только серверы версии
до 9.1. В конце концов он может быть исключён из спецификации протокола.)
AuthenticationGSS (Аутентификация GSS)
Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент отправляет
GSSResponse с первой частью потока данных GSSAPI. Если потребуются дополнительные сооб-
щения, сервер передаст в ответ AuthenticationGSSContinue.
AuthenticationSSPI (Аутентификация SSPI)
Клиент должен начать согласование SSPI. В ответ на это сообщение клиент отправляет
GSSResponse с первой частью потока данных SSPI. Если потребуются дополнительные сообще-
ния, сервер передаст в ответ AuthenticationGSSContinue.
AuthenticationGSSContinue (Продолжение аутентификации GSS)
Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI или SSPI
(AuthenticationGSS, AuthenticationSSPI или предыдущего AuthenticationGSSContinue). Если в
структуре GSSAPI или SSPI в этом сообщении указывается, что для завершения аутентифика-
ции требуются дополнительные данные, клиент должен передать их в очередном сообщении
GSSResponse. Если этим сообщением завершается проверка подлинности GSSAPI или SSPI,
сервер затем передаёт AuthenticationOk, сообщая об успешной проверке подлинности, либо
ErrorResponse, сообщая об ошибке.
AuthenticationSASL (Аутентификация SASL)
Клиент должен начать согласование SASL, используя один из механизмов SASL, перечислен-
ных в сообщении. В ответ на это сообщение клиент отправляет SASLInitialResponse с именем
выбранного механизма и первой частью потока данных SASL. Если потребуются дополнитель-
ные сообщения, сервер передаст в ответ AuthenticationSASLContinue. За подробностями обра-
титесь к Разделу 53.3.
AuthenticationSASLContinue (Продолжение аутентификации SASL)
Это сообщение содержит данные вызова с предыдущего шага согласования SASL
(AuthenticationSASL или предыдущего AuthenticationSASLContinue). Клиент должен передать в
ответ сообщение SASLResponse.
AuthenticationSASLFinal (Окончание аутентификации SASL)
Аутентификация SASL завершена с дополнительными данными для клиента, специфичными
для механизма. Затем сервер передаст сообщение AuthenticationOk, говорящее об успешной
аутентификации, или ErrorResponse, говорящее об ошибке. Данное сообщение передаётся,
только если механизм SASL должен в завершение передать с сервера клиенту дополнительные
специфичные данные.
NegotiateProtocolVersion
Сервер не поддерживает младшую версию протокола, запрошенную клиентом, но поддержи-
вает более раннюю версию протокола; в этом сообщении указывается наибольшая поддержи-
ваемая младшая версия. Это сообщение будет также передаваться, если клиент запросил в
стартовом пакете неподдерживаемые параметры протокола (то есть, начинающиеся с <em>pq</em>.).
2026Клиент-серверный протокол
За этим сообщением должен последовать или ответ ErrorResponse, или сообщение, говорящее
об успехе или неудаче проверки подлинности.
Если клиент не поддерживает метод проверки подлинности, запрошенный сервером, он должен
немедленно закрыть соединение.
Получив сообщение AuthenticationOk, клиент должен ждать дальнейших сообщений от серве-
ра. В этой фазе запускается обслуживающий процесс, а клиент представляет собой просто
заинтересованного наблюдателя. Попытка запуска может быть неудачной (и клиент получит
ErrorResponse) либо сервер может отказать в поддержке запрошенной младшей версии протокола
(NegotiateProtocolVersion), но в обычной ситуации обслуживающий процесс передаёт несколько
сообщений ParameterStatus, BackendKeyData и, наконец, ReadyForQuery.
В ходе этой фазы обслуживающий процесс попытается применить все параметры времени выпол-
нения, полученные в стартовом сообщении. Если это удастся, эти значения становятся сеансовы-
ми значениями по умолчанию. При ошибке он передаёт ErrorResponse и завершается.
Обслуживающий процесс может передавать в этой фазе следующие сообщения:
BackendKeyData (Данные ключа сервера)
В этом сообщении передаётся секретный ключ, который клиент должен сохранить, чтобы впо-
следствии иметь возможность выполнять запросы. Клиент не должен отвечать на это сообще-
ние, он должен дожидаться сообщения ReadyForQuery.
ParameterStatus (Состояние параметров)
Это сообщение говорит клиенту о текущих (начальных) значениях параметров обслуживающе-
го процесса, например, client_encoding или DateStyle. Клиент может проигнорировать это сооб-
щение или сохранить значения для дальнейшего использования; за дополнительными подроб-
ностями обратитесь к Подразделу 53.2.6. Клиент не должен отвечать на это сообщение, он дол-
жен дожидаться сообщения ReadyForQuery.
ReadyForQuery (Готов к запросам)
Запуск завершён. Теперь клиент может выполнять команды.
ErrorResponse (Ошибочный ответ)
Запуск не удался. Соединение закрывается после передачи этого сообщения.
NoticeResponse (Ответ с замечанием)
Выдаётся предупреждающее сообщение. Клиент должен вывести это сообщение, но продол-
жать ожидать сообщения ReadyForQuery или ErrorResponse.
Сообщение ReadyForQuery в данной фазе ничем не отличается от сообщений, который передаёт
сервер после каждого цикла команд. В зависимости от условий реализации клиента, можно вос-
принимать сообщение ReadyForQuery как начинающее цикл команд, либо как завершающее фазу
запуска и каждый последующий цикл команд.
53.2.2. Простой запрос
Цикл простого запроса начинает клиент, передавая серверу сообщение Query. Это сообщение
включает команду (или команды) SQL, выраженную в виде текстовой строки. В ответ сервер пере-
даёт одно или несколько сообщений, в зависимости от строки запроса, и завершает цикл сообщени-
ем ReadyForQuery. ReadyForQuery говорит клиенту, что он может безопасно передавать новую ко-
манду. (На самом деле клиент может передать следующую команду, не дожидаясь ReadyForQuery,
но тогда он сам должен разобраться в ситуации, когда первая команда завершается ошибкой, а
последующая выполняется успешно.)
Сервер может передавать в этой фазе следующие ответные сообщения:
CommandComplete (Команда завершена)
Команда SQL выполнена нормально.
2027Клиент-серверный протокол
CopyInResponse (Ответ входящего копирования)
Сервер готов копировать данные, получаемые от клиента, в таблицу; см. Подраздел 53.2.5.
CopyOutResponse (Ответ исходящего копирования)
Сервер готов копировать данные из таблицы клиенту; см. Подраздел 53.2.5.
RowDescription (Описание строк)
Показывает, что в ответ на запрос SELECT, FETCH и т. п. будут возвращены строки. В содержи-
мом этого сообщения описывается структура столбцов этих строк. За ним для каждой строки,
возвращаемой клиенту, следует сообщение DataRow.
DataRow (Строка данных)
Одна строка из набора, возвращаемого запросом SELECT, FETCH и т. п.
EmptyQueryResponse (Ответ на пустой запрос)
Была принята пустая строка запроса.
ErrorResponse (Ошибочный ответ)
Произошла ошибка.
ReadyForQuery (Готов к запросам)
Обработка строки запроса завершена. Чтобы отметить это, отправляется отдельное со-
общение, так как строка запроса может содержать несколько команд SQL. (Сообщение
CommandComplete говорит о завершении обработки одной команды SQL, а не всей строки.)
ReadyForQuery передаётся всегда, и при успешном завершении обработки, и при ошибке.
NoticeResponse (Ответ с замечанием)
Выдаётся предупреждение, связанное с запросом. Эти замечания дополняют другие ответы, то
есть сервер, выдавая их, продолжает обрабатывать команду.
Ответ на запрос SELECT (или другие запросы, возвращающие наборы строк, такие как EXPLAIN и
SHOW) обычно состоит из RowDescription, нуля или нескольких сообщений DataRow, и завершающе-
го CommandComplete. Для команды COPY с вводом или выводом данных через клиента, применя-
ется специальный протокол, описанный в Подразделе 53.2.5. Со всеми другими типами запросами
обычно выдаётся только сообщение CommandComplete.
Так как строка запроса может содержать несколько запросов (разделённых точкой с запятой), до
завершения обработки всей строки сервер может передать несколько серий таких ответов. Когда
сервер завершает обработку всей строки и готов принять следующую строку запроса, он выдаёт
сообщение ReadyForQuery.
Если получена полностью пустая строка запроса (не содержащая ничего, кроме пробельных сим-
волов), ответом будет EmptyQueryResponse с последующим ReadyForQuery.
В случае ошибки выдаётся ErrorResponse с последующим ReadyForQuery. Сообщение
ErrorResponse прерывает дальнейшую обработку строки запроса (даже если в ней остались другие
запросы). Заметьте, что оно может быть выдано и в середине последовательности сообщений, вы-
даваемых в ответ на отдельный запрос.
В режиме простых запросов получаемые значения всегда передаются в текстовом формате, за ис-
ключением результатов команды FETCH для курсора, объявленного с атрибутом BINARY. С такой
командой значения передаются в двоичном формате. Какой именно формат используется, опре-
деляют коды формата, передаваемые в сообщении RowDescription.
Клиент должен быть готов принять сообщения ErrorResponse и NoticeResponse, ожидая любой дру-
гой тип сообщений. Также обратитесь к Подразделу 53.2.6 за информацией о сообщениях, которые
сервер может выдавать в ответ на внешние события.
2028Клиент-серверный протокол
Код клиента рекомендуется реализовывать в виде машины состояний, которая в любой момент
будет принимать сообщения всех типов, имеющих смысл на данном этапе, но не программировать
жёстко обработку точной последовательности сообщений.
53.2.2.1. Несколько операторов в простом запросе
Когда сообщение простого запроса содержит несколько SQL-операторов (разделённых точкой с
запятой), эти операторы выполняются в одной транзакции, если только среди них нет явных ко-
манд управления транзакциями, меняющих это поведение. Например, если сообщение содержит
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
, то ошибка деления на ноль в SELECT приведёт к откату результата первого INSERT. Более того,
вследствие прерывания обработки сообщения на первой ошибке, второй INSERT не будет выпол-
няться вовсе.
Если же сообщение содержит:
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
результат первого INSERT фиксируется явной командой COMMIT. Второй INSERT и последующий
SELECT будут так же обрабатываться в одной транзакции, поэтому ошибка деления на ноль приве-
дёт к откату второго INSERT, и не затронет первый.
Для реализации этого поведения операторы в составном сообщении запроса выполняются в неяв-
ном блоке транзакций, если только в сообщении нет явного блока транзакции, в котором они
должны выполняться. Основное отличие неявного блока транзакции от обычного состоит в том,
что неявный блок автоматически закрывается в конце сообщения Query — либо неявно фиксиру-
ется при отсутствии ошибок, либо неявно откатывается в противном случае. Подобная неявная
фиксация или отмена транзакции имеет место, когда оператор выполняется отдельно (вне блока
транзакции).
Если в рамках сеанса уже начат блок транзакции (в результате выполнения оператора BEGIN из
некоторого предыдущего сообщения), сообщение Query просто продолжает этот блок независимо
от того, содержится ли в нём один оператор или несколько. Однако если сообщение Query содер-
жит команду COMMIT или ROLLBACK, закрывающую существующий блок транзакций, то все последу-
ющие команды в нём выполняются в неявном блоке транзакции. И напротив, если составное сооб-
щение Query содержит команду BEGIN, она начинает обычный блок транзакции, который будет за-
кончен только явными командами COMMIT или ROLLBACK, в каком бы сообщении Query, текущем или
последующих, они ни содержались. Если BEGIN следует за операторами, которые выполнялись в
неявном блоке транзакции, эти операторы не фиксируются немедленно; они задним числом вклю-
чаются в новый обычный блок транзакции.
Операторы COMMIT и ROLLBACK, фигурирующие в неявном блоке транзакции, выполняются как
обычно, закрывая неявный блок; однако при этом будет выдано предупреждение, так как COMMIT
или ROLLBACK без предшествующего BEGIN могут выполняться по ошибке. Если за этими операто-
рами следуют другие, для них будет начат новый неявный блок транзакции.
Точки сохранения в неявных блоках транзакций не допускаются, так как они будут конфликтовать
с правилом автоматического закрытия блока при любой ошибке.
Помните, что, вне зависимости от наличия любых команд управления транзакциями, выполнение
сообщения Query останавливается при первой же ошибке. Таким образом, с данными командами:
BEGIN;
SELECT 1/0;
2029Клиент-серверный протокол
ROLLBACK;
в одном сообщении Query сеанс останется внутри прерванного обычного блока транзакции, так
как команда ROLLBACK не достигается после ошибки деления на ноль. Для приведения сеанса в
порядок потребуется выполнить ещё один ROLLBACK.
Также следует заметить, что первоначальный лексический и синтаксический анализ производит-
ся для всей строки запроса, прежде чем какая-либо её часть будет выполняться. Таким образом,
простые ошибки (например, опечатка в ключевом слове) в последующих операторах могут приве-
сти к тому, что не будет выполнен и ни один из предшествующих операторов. Это обычно незамет-
но для пользователей, так как эти операторы откатились бы всё равно при выполнении в неявном
блоке транзакции. Однако эта особенность может проявиться при попытке выполнить несколько
транзакций в одном составном запросе. Например, если из-за опечатки предыдущий пример пре-
вратился в:
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;
ни один из операторов не будет выполняться, и отличие проявится в том, что первый INSERT не
будет зафиксирован. Ошибки, выявленные на стадии семантического анализа или позже, напри-
мер, опечатки в имени таблиц или столбца, такого влияния на выполнение не оказывают.
53.2.3. Расширенный запрос
Протокол расширенных запросов разбивает вышеописанный протокол простых запросов на
несколько шагов. Результаты подготовительных шагов можно неоднократно использовать повтор-
но для улучшения эффективности. Кроме того, он открывает дополнительные возможности, в част-
ности, возможность передавать значения данных в отдельных параметрах вместо того, чтобы внед-
рять их непосредственно в строку запроса.
В расширенном протоколе клиент сначала передаёт сообщение Parse с текстовой строкой запроса
и, возможно, некоторыми сведениями о типах параметров и именем целевого объекта подготов-
ленного оператора (если имя пустое, создаётся безымянный подготовленный оператор). Ответом
на это сообщение будет ParseComplete или ErrorResponse. Типы параметров указываются по OID;
при отсутствии явного указания анализатор запроса пытается определить типы данных так же,
как он делал бы для нетипизированных строковых констант.
Примечание
Тип данных параметра можно оставить неопределённым, задав для него значение
ноль, либо сделав массив с OID типов параметров короче, чем набор символов пара-
метров ($n), используемых в строке запроса. Другой особый случай — передача типа
параметра как void (то есть передача OID псевдотипа void). Это предусмотрено для
того, чтобы символы параметров можно было использовать для параметров функций,
на самом деле представляющих собой параметры OUT. Обычно параметр void нельзя
использовать ни в каком контексте, но если такой параметр фигурирует в списке пара-
метров функции, он фактически игнорируется. Например, вызову функции foo($1,$2,
$3,$4) может соответствовать функция с аргументами IN и двумя OUT, если аргументы
$3 и $4 объявлены как имеющие тип void.
Примечание
Строка запроса, содержащаяся в сообщении Parse, не может содержать больше одного
оператора SQL; иначе выдаётся синтаксическая ошибка. Это ограничение отсутствует
в протоколе простых запросов, но присутствует в расширенном протоколе, так как до-
2030Клиент-серверный протокол
бавление поддержки подготовленных операторов или порталов, содержащих несколь-
ко команд, неоправданно усложнило бы протокол.
В случае успешного создания именованный подготовленный оператор продолжает существовать
до завершения текущего сеанса, если только он не будет уничтожен явно. Безымянный подготов-
ленный оператор сохраняется только до следующей команды Parse, в которой целевым является
безымянный оператор. (Заметьте, что сообщение простого запроса также уничтожает безымян-
ный оператор.) Именованные операторы должны явно закрываться, прежде чем их можно будет
переопределить другим сообщением Parse, но для безымянных операторов это не требуется. Име-
нованные подготовленные операторы также можно создавать и вызывать на уровне команд SQL,
используя команды PREPARE и EXECUTE.
Когда подготовленный оператор существует, его можно подготовить к выполнению сообщением
Bind. В сообщении Bind задаётся имя исходного подготовленного оператора (пустая строка подра-
зумевает безымянный подготовленный оператор), имя целевого портала (пустая строка подразу-
мевает безымянный портал) и значения для любых шаблонов параметров, представленных в под-
готовленном операторе. Набор передаваемых значений должен соответствовать набору парамет-
ров, требующихся для подготовленного оператора. (Если вы объявили параметры void в сообще-
нии Parse, передайте для них значения NULL в сообщении Bind.) Bind также принимает указание
формата для данных, возвращаемых в результате запроса; формат можно указать для всех данных,
либо для отдельных столбцов. Ответом на это сообщение будет BindComplete или ErrorResponse.
Примечание
Выбор между текстовым и двоичным форматом вывода определяется кодами формата,
передаваемыми в Bind, вне зависимости от команды SQL. При использовании протоко-
ла расширенных запросов атрибут BINARY в объявлении курсоров не имеет значения.
Планирование запроса обычно имеет место при обработке сообщения Bind. Если подготовленный
оператор не имеет параметров, либо он выполняется многократно, сервер может сохранить со-
зданный план и использовать его повторно при последующих сообщениях Bind для того же подго-
товленного оператора. Однако он будет делать это, только если решит, что можно получить уни-
версальный план, который не будет значительно неэффективнее планов, зависящих от конкретных
значений параметров. С точки зрения протокола это происходит незаметно.
В случае успешного создания объект именованного портала продолжает существование до конца
текущей транзакции, если только он не будет уничтожен явно. Безымянный портал уничтожается
в конце транзакции или при выполнении следующей команды Bind, в которой в качестве целевого
выбирается безымянный портал. (Заметьте, что сообщение простого запроса также уничтожает
безымянный портал.) Именованные порталы должны явно закрываться, прежде чем их можно бу-
дет явно переопределить другим сообщением Bind, но это не требуется для безымянных порталов.
Именованные порталы также можно создавать и вызывать на уровне команд SQL, используя ко-
манды DECLARE CURSOR и FETCH.
Когда портал существует, его можно запустить на выполнение сообщением Execute. В сообщении
Execute указывается имя портала (пустая строка подразумевает безымянный портал) и максималь-
ное число результирующих строк (ноль означает «выбрать все строки»). Число результирующих
строк имеет значение только для порталов, которые содержат команды, возвращающие наборы
строк; в других случаях команда всегда выполняется до завершения и число строк игнорируется.
В ответ на Execute могут быть получены те же сообщения, что описаны выше для запросов, выпол-
няемых через протокол простых запросов, за исключением того, что после Execute не выдаются
сообщения ReadyForQuery и RowDescription.
Если операция Execute оканчивается до завершения выполнения портала (из-за достижения нену-
левого ограничения на число строк), сервер отправляет сообщение PortalSuspended; появление
этого сообщения говорит клиенту о том, что для завершения операции с данным порталом нуж-
но выдать ещё одно сообщение Execute. Сообщение CommandComplete, говорящее о заверше-
2031Клиент-серверный протокол
нии исходной команды SQL, не передаётся до завершения выполнения портала. Таким обра-
зом, фаза Execute всегда заканчивается при появлении одного из сообщений: CommandComplete,
EmptyQueryResponse (если портал был создан из пустой строки запроса), ErrorResponse или
PortalSuspended.
В конце каждой серии сообщений расширенных запросов клиент должен выдать сообщение Sync.
Получив это сообщение без параметров, сервер закрывает текущую транзакцию, если команды
выполняются не внутри блока транзакции BEGIN/COMMIT (под «закрытием» понимается фиксация
при отсутствии ошибок или откат в противном случае). Затем он выдаёт ответ ReadyForQuery.
Целью сообщения Sync является обозначение точки синхронизации для восстановления в слу-
чае ошибок. Если при обработке сообщений расширенных запросов происходит ошибка, сер-
вер выдаёт ErrorResponse, затем считывает и пропускает сообщения до Sync, после чего выдаёт
ReadyForQuery и возвращается к обычной обработке сообщений. (Но заметьте, что он не будет
пропускать следующие сообщения, если ошибка происходит в процессе обработки Sync — это га-
рантирует, что для каждого Sync будет передаваться в точности одно сообщение ReadyForQuery.)
Примечание
Сообщение Sync не приводит к закрытию блока транзакции, открытого командой
BEGIN. Выявить эту ситуацию можно, используя информацию о состоянии транзакции,
содержащуюся в сообщении ReadyForQuery.
В дополнение к этим фундаментальным и обязательным операциям, протокол расширенных за-
просов позволяет выполнить и несколько дополнительных операций.
В сообщении Describe (в вариации для портала) задаётся имя существующего портала (пустая стро-
ка обозначает безымянный портал). В ответ передаётся сообщение RowDescription, описывающее
строки, которые будут возвращены при выполнении портала; либо сообщение NoData, если портал
не содержит запроса, возвращающего строки; либо ErrorResponse, если такого портала нет.
В сообщении Describe (в вариации для оператора) задаётся имя существующего подготовленного
оператора (пустая строка обозначает безымянный подготовленный оператор). В ответ передаётся
сообщение ParameterDescription, описывающее параметры, требующиеся для оператора, за кото-
рым следует сообщение RowDescription, описывающее строки, которые будут возвращены, когда
оператор будет собственно выполнен (или сообщение NoData, если оператор не возвратит строки).
ErrorResponse выдаётся, если такой подготовленный оператор отсутствует. Заметьте, что так как
команда Bind не выполнялась, сервер ещё не знает, в каком формате будут возвращаться столбцы;
в этом случае поля кодов формата в сообщении RowDescription будут содержать нули.
Подсказка
В большинстве случаев клиент должен выдать ту или иную вариацию Describe, прежде
чем выдавать Execute, чтобы понять, как интерпретировать результаты, которые он
получит.
Сообщение Close закрывает существующий подготовленный оператор или портал и освобожда-
ет связанные ресурсы. При попытке выполнить Close для имени несуществующего портала или
оператора ошибки не будет. Ответ на это сообщение обычно CloseComplete, но может быть и
ErrorResponse, если при освобождении ресурсов возникают проблемы. Заметьте, что при закрытии
подготовленного оператора неявно закрываются все открытые порталы, которые были получены
из этого оператора.
Сообщение Flush не приводит к генерации каких-либо данных, а указывает серверу передать все
данные, находящиеся в очереди в его буферах вывода. Сообщение Flush клиент должен отправлять
после любой команды расширенных запросов, кроме Sync, если он желает проанализировать ре-
зультаты этой команды, прежде чем выдавать следующие команды. Без Flush сообщения, возвра-
2032Клиент-серверный протокол
щаемые сервером, будут объединяться вместе в минимальное количество пакетов с целью умень-
шения сетевого трафика.
Примечание
Простое сообщение Query примерно равнозначно последовательности сообщений
Parse, Bind, Describe (для портала), Execute, Close, Sync, с использованием объектов
подготовленного оператора и портала без имён и без параметров. Одно отличие состо-
ит в том, что такое сообщение может содержать в строке запроса несколько операто-
ров SQL, для каждого из которых по очереди автоматически выполняется последова-
тельность Bind/Describe/Execute. Другое отличие состоит в том, что в ответ на него не
приходят сообщения ParseComplete, BindComplete, CloseComplete или NoData.
53.2.4. Вызов функций
Подраздел протокола «Вызов функций» позволяет клиенту запросить непосредственный вызов лю-
бой функции, существующей в системном каталоге pg_proc. При этом клиент должен иметь право
на выполнение этой функции.
Примечание
Этот подраздел протокола считается устаревшим и в новом коде использовать его не
следует. Примерно тот же результат можно получить, подготовив оператор с командой
SELECT function($1, …). При таком подходе цикл вызова функции заменяется по-
следовательностью Bind/Execute.
Цикл вызова функции начинает клиент, передавая серверу сообщение FunctionCall. Сервер воз-
вращает одно или несколько сообщений ответа, в зависимости от результата вызова функции, и
завершающее сообщение ReadyForQuery. ReadyForQuery говорит клиенту, что он может свободно
передавать новый запрос или вызов функции.
Сервер может передавать в этой фазе следующие ответные сообщения:
ErrorResponse (Ошибочный ответ)
Произошла ошибка.
FunctionCallResponse (Ответ на вызов функции)
Вызов функции завершён и в этом сообщении передаётся её результат. (Заметьте, что протокол
вызова функций позволяет выдать только один скалярный результат, но не кортеж или набор
результатов.)
ReadyForQuery (Готов к запросам)
Обработка вызова функции завершена. В ответ всегда передаётся ReadyForQuery, независимо
от того, была ли функция выполнена успешно или с ошибкой.
NoticeResponse (Ответ с замечанием)
Выдаётся предупреждение, связанное с вызовом функции. Эти замечания дополняют другие
ответы, то есть сервер, выдавая их, продолжает обрабатывать вызов.
53.2.5. Операции COPY
Команда COPY позволяет обеспечить скоростную передачу данных на сервер или с сервера. Опе-
рации входящего и исходящего копирования переключают соединение в отдельные режимы про-
токола, которые завершаются только в конце операции.
2033Клиент-серверный протокол
Режим входящего копирования (передача данных на сервер) включается, когда клиент выполня-
ет SQL-оператор COPY FROM STDIN. Переходя в этот режим, сервер передаёт клиенту сообщение
CopyInResponse. После этого клиент должен передать ноль или более сообщений CopyData, обра-
зующих поток входных данных. (При этом границы сообщений не обязательно должны совпадать
с границами строк данных, хотя часто имеет смысл выровнять их.) Клиент может завершить ре-
жим входящего копирования, передав либо сообщение CopyDone (говорящее об успешном завер-
шении), либо CopyFail (которое приведёт к завершению SQL-оператора COPY с ошибкой). При этом
сервер вернётся в обычный режим обработки, в котором он находился до выполнения команды
COPY (это может быть протокол простых или расширенных запросов). Затем он отправит сообщение
CommandComplete (в случае успешного завершения) или ErrorResponse (в противном случае).
В случае возникновения ошибки в режиме входящего копирования (включая получение сообще-
ния CopyFail), сервер выдаёт сообщение ErrorResponse. Если команда COPY была получена в сооб-
щении расширенного запроса, сервер не будет обрабатывать последующие сообщения клиента,
пока не получит сообщение Sync, после которого он выдаст ReadyForQuery и вернётся в обычный
режим работы. Если команда COPY была получена в сообщении простого запроса, остальная часть
сообщения игнорируется и сразу выдаётся ReadyForQuery. В любом случае все последующие сооб-
щения CopyData, CopyDone или CopyFail, поступающие от клиента, будут просто игнорироваться.
В режиме входящего копирования сервер игнорирует поступающие сообщения Flush и Sync. При
поступлении сообщений любого другого типа, не связанного с копированием, возникает ошибка,
приводящая к прерыванию режима входящего копирования, как описано выше. (Исключение для
сообщений Flush и Sync сделано для удобства клиентских библиотек, которые всегда передают
Flush или Sync после сообщения Execute, не проверяя, не запускается ли в нём команда COPY FROM
STDIN.)
Режим исходящего копирования (передача данных с сервера) включается, когда клиент выполня-
ет SQL-оператор COPY TO STDOUT. Переходя в этот режим, сервер передаёт клиенту сообщение
CopyOutResponse, за ним ноль или более сообщений CopyData (всегда одно сообщение для каж-
дой строки) и в завершение CopyDone. Затем сервер возвращается в обычный режим обработки,
в котором он находился до выполнения команды COPY, и передаёт CommandComplete. Клиент не
может прервать передачу (кроме как закрыв соединение или выдав запрос Cancel), но он может
игнорировать ненужные ему сообщения CopyData и CopyDone.
В случае обнаружения ошибки в режиме исходящего копирования, сервер выдаёт сообщение
ErrorResponse и возвращается к обычной обработке. Клиент должен воспринимать поступление
ErrorResponse как завершение режима исходящего копирования.
Между сообщениями CopyData могут поступать сообщения NoticeResponse и ParameterStatus; кли-
енты должны обрабатывать их и быть готовы принимать и другие типы асинхронных сообщений
(см. Подраздел 53.2.6). В остальном, сообщения любых типов, кроме CopyData и CopyDone, могут
восприниматься как завершающие режим исходящего копирования.
Есть ещё один режим копирования, называемый двусторонним копированием и обеспечивающий
высокоскоростную передачу данных на и с сервера. Двустороннее копирование запускается, когда
клиент в режиме walsender выполняет оператор START_REPLICATION. В ответ сервер передаёт кли-
енту сообщение CopyBothResponse. Затем и сервер, и клиент могут передавать друг другу сообще-
ния CopyData, пока кто-то из них не завершит передачу сообщением CopyDone. Когда сообщение
CopyDone передаёт клиент, соединение переходит из режима двустороннего в режим исходяще-
го копирования и клиент больше не может передавать сообщения CopyData. Аналогично, когда
сообщение CopyDone передаёт сервер, соединение переходит в режим входящего копирования и
сервер больше не может передавать сообщения CopyData. Когда сообщения CopyDone переданы
обеими сторонами, режим копирования завершается и сервер возвращается в режим обработки
команд. В случае обнаружения ошибки на стороне сервера в режиме двустороннего копирования,
сервер выдаёт сообщение ErrorResponse, пропускает следующие сообщения клиента, пока не бу-
дет получено сообщение Sync, а затем выдаёт ReadyForQuery и возвращается к обычной обработке.
Клиент должен воспринимать получение ErrorResponse как завершение двустороннего копирова-
ния; в этом случае сообщение CopyDone посылаться не должно. За дополнительной информацией
о подразделе протокола, управляющем двусторонним копированием, обратитесь к Разделу 53.4.
2034Клиент-серверный протокол
Сообщения CopyInResponse, CopyOutResponse и CopyBothResponse содержат поля, из которых кли-
ент может узнать количество столбцов в строке и код формата для каждого столбца. (В текущей
реализации для всех столбцов в заданной операции COPY устанавливается один формат, но в кон-
струкции сообщения это не заложено.)
53.2.6. Асинхронные операции
Возможны ситуации, в которых сервер будет отправлять клиенту сообщения, не предполагаемые
потоком команд в текущем режиме. Клиенты должны быть готовы принять эти сообщения в любой
момент, даже не в процессе выполнения запроса. Как минимум, следует проверять такие сообще-
ния, прежде чем начинать читать ответ на запрос.
Сообщения NoticeResponse могут выдаваться вследствие внешней активности; например, если ад-
министратор инициирует «быстрое» отключение баз данных, сервер отправит NoticeResponse, сиг-
нализирующее об этом факте, прежде чем закрывать соединение. Соответственно, клиенты долж-
ны быть готовы всегда принять и вывести сообщения NoticeResponse, даже когда соединение фак-
тически простаивает.
Сообщения ParameterStatus будут выдаваться всякий раз, когда меняется действующее значение
одного из параметров, об изменении которых, по мнению сервера, должен знать клиент. Чаще
всего это происходит в ответ на SQL-команду SET, выполняемую клиентом и в таком случае это
сообщение по сути синхронно — но состояние параметров может меняться и когда администратор
изменяет файл конфигурации, а затем посылает серверу сигнал SIGHUP. Также, если действие
команды SET отменяется, клиенту передаётся сообщение ParameterStatus, в котором отражается
текущее значение параметра.
В настоящее время есть жёстко зафиксированный набор параметров, при изменении которых
выдаётся ParameterStatus: server_version, server_encoding, client_encoding, application_name,
is_superuser, session_authorization, DateStyle, IntervalStyle, TimeZone, integer_datetimes и
standard_conforming_strings. (server_encoding, TimeZone и integer_datetimes не отслежива-
лись до версии 8.0; standard_conforming_strings не отслеживался до 8.1; IntervalStyle — до
версии 8.4; application_name — до версии 9.0.) Заметьте, что server_version, server_encoding
и integer_datetimes — это псевдопараметры, которые не могут меняться после запуска сервера.
Этот набор может быть изменён в будущем или даже будет настраиваемым. Соответственно, кли-
ент может просто игнорировать сообщения ParameterStatus для параметров, которые ему неиз-
вестны или не представляют интереса.
Если клиент выполняет команду LISTEN, сервер будет передавать ему сообщения
NotificationResponse (не путайте с NoticeResponse!), когда для канала с тем же именем затем будет
выполняться команда NOTIFY.
Примечание
В настоящее время, сообщение NotificationResponse может быть передано только
вне транзакции, так что оно не может оказаться в середине серии ответов на ко-
манду, хотя может поступить сразу после ReadyForQuery. Однако полагаться на это
при проектировании логики клиента неразумно. Лучше разработать код так, чтобы
NotificationResponse могло быть принято в любой фазе протокола.
53.2.7. Отмена выполняющихся запросов
В процессе обработки запроса клиент может запросить отмену этого запроса. Запрос отмены не
передаётся серверу непосредственно через открытое соединение из соображений эффективности:
мы не хотим, чтобы сервер постоянно проверял поступающие от клиента сообщения в процессе
выполнения запроса. Запросы отмены должны быть относительно редкими, поэтому мы выбрали
для них не самый простой путь во избежание негативного влияния на обычный режим работы.
Чтобы запросить отмену запроса, клиент должен установить новое подключение к серверу и от-
править ему сообщение CancelRequest, вместо StartupMessage, обычно передаваемого при уста-
2035Клиент-серверный протокол
новлении нового подключения. Сервер обработает полученную команду и закроет это подключе-
ние. По соображениям безопасности сервер не отвечает непосредственно на сообщение с запро-
сом отмены.
Сообщение CancelRequest обрабатывается, только если оно содержит те же ключевые данные (PID
и секретный ключ), что были переданы клиенту при запуске. Если PID и секретный ключ в запросе
соответствуют данным выполняющегося в данный момент обслуживающего процесса, обработка
текущего запроса в нём прерывается. (В существующей реализации это осуществляется путём
передачи специального сигнала данному обслуживающему процессу.)
Сигнал отмены может подействовать, а может и не подействовать (например, если он поступит
после того, как сервер завершит обработку запроса). Если отмена действительно происходит, те-
кущая команда прерывается досрочно с сообщением об ошибке.
Вследствие такой организации, объясняемой соображениями безопасности и эффективности, кли-
ент не может непосредственно определить, был ли запрос отмены успешен. Он должен продол-
жать ожидать ответа сервера на исходный запрос. Запрос отмены просто увеличивает вероятность
того, что текущий запрос завершится быстрее, как и вероятность того, что он будет завершён не
успешно, а с ошибкой.
Так как запрос отмены передаётся серверу через новое подключение к серверу, а не через обыч-
ный канал связи клиент-сервер, такие запросы могут выдавать любые процессы, а не только кли-
ентский процесс, запрос которого требуется отменить. Это может дать дополнительную гибкость
при построении многопроцессных приложений. Это также представляет собой угрозу безопасно-
сти, так как попытаться отменить запросы могут и неавторизованные пользователи. Для ликвида-
ции этой угрозы в запросах отмены требуется передавать динамически генерируемый секретный
ключ.
53.2.8. Завершение
Обычная процедура мягкого завершения заключается в том, что клиент отправляет сообщение
Terminate и немедленно закрывает соединение. Получая это сообщение, обслуживающий процесс
закрывает соединение и завершается.
В редких случаях (например, при отключении базы данных по команде администратора) обслужи-
вающий процесс может отключиться, даже если клиент не запрашивает этого. В таких случаях,
перед тем, как закрыть соединение, этот процесс пытается передать сообщение с ошибкой или
уведомлением, в котором будет указана причина отключения.
Другие сценарии завершения возникают с различными вариантами отказа, например, при крити-
ческом сбое с дампом памяти на одной или другой стороне, при потере канала соединения, потере
синхронизации по границам сообщений и т. д. Если клиент или сервер обнаруживает, что соеди-
нение было неожиданно закрыто, он должен очистить ресурсы и завершиться. Клиент при этом
может запустить новый обслуживающий процесс, переподключившись к серверу, если он сам хо-
чет продолжать работу. Закрывать соединение также рекомендуется при получении сообщений
нераспознанного типа, так как это может быть признаком потери синхронизации по границам со-
общений.
При штатном или нештатном завершении сеанса любая открытая транзакция откатывается, а не
фиксируется. Однако следует заметить, что при отключении клиента в процессе обработки запро-
са, отличного от SELECT, обслуживающий процесс вероятнее всего завершит запрос, прежде чем
заметит отключение. Если запрос выполняется не в блоке транзакции (вне последовательности
BEGIN … COMMIT), его результаты могут быть зафиксированы до того, как будет обнаружено отклю-
чение.
53.2.9. Защита сеанса с SSL
Если PostgreSQL был собран с поддержкой SSL, взаимодействие клиента с сервером может быть
зашифровано с применением SSL. Это обеспечивает защиту на уровне канала в среде, где зло-
умышленники могут перехватить трафик сеанса. За дополнительными сведениями о шифровании
трафика сеансов PostgreSQL с использованием SSL, обратитесь к Разделу 18.9.
2036Клиент-серверный протокол
Чтобы начать сеанс с SSL-шифрованием, клиент передаёт серверу вместо StartupMessage сообще-
ние SSLRequest. В ответ сервер передаёт один байт, содержащий символ S или N, показывающий,
что он желает, либо не желает включать SSL, соответственно. Если клиент не удовлетворён отве-
том, он должен закрыть соединение на этом этапе. Чтобы продолжить установление соединения
после получения S, он выполняет начальное согласование SSL с сервером (не описывается здесь,
так как относится к протоколу SSL). Если эта процедура выполняется успешно, он продолжает
соединение, передавая обычное сообщение StartupMessage. При этом StartupMessage и все после-
дующие данные будут защищены SSL-шифрованием. Чтобы продолжить после получения N, кли-
ент может передать обычное сообщение StartupMessage и дальше взаимодействовать с сервером
без шифрования.
Клиент также должен быть готов обработать сообщение ErrorMessage, полученное от сервера в
ответ на SSLRequest. Такая ситуация возможна, только если сервер имеет версию, которая ещё не
поддерживала SSL в PostgreSQL. (Такие серверы сейчас антикварная редкость, и скорее всего их
уже не встретить в природе.) В этом случае соединение должно быть закрыто, но клиент может
решить открыть новое соединение, не запрашивая SSL-шифрование.
Начальный запрос SSLRequest может также передаваться при установлении соединения, откры-
ваемого для передачи сообщения CancelRequest.
Так как в самом протоколе не предусмотрено принудительное включение SSL-шифрования серве-
ром, администратор может настроить сервер так, чтобы в качестве дополнительного условия при
проверке подлинности клиента он не принимал незашифрованные сеансы.
53.3. Аутентификация SASL
SASL — это инфраструктура аутентификации для протоколов, ориентированных на соединения. На
данный момент PostgreSQL реализует два механизма SASL: SCRAM-SHA-256 и SCRAM-SHA-256-
PLUS, а в будущем могут появиться и другие. Далее описывается, как в принципе осуществляет-
ся аутентификация SASL, а в следующем подразделе более подробно рассматриваются SCRAM-
SHA-256 и SCRAM-SHA-256-PLUS.
Поток сообщений аутентификации SASL</p>
<ol>
  <li>Чтобы начать обмен по схеме аутентификации SASL, сервер передаёт сообщение
AuthenticationSASL. Оно содержит список механизмов аутентификации SASL, с которыми мо-
жет работать сервер, в порядке предпочтений сервера.</li>
  <li>Клиент выбирает один из поддерживаемых механизмов из списка и передаёт серверу сообще-
ние SASLInitialResponse. Это сообщение содержит имя выбранного механизма и может содер-
жать «Начальный ответ клиента», если это использует выбранный механизм.</li>
  <li>За этим следует одно или нескольких сообщений вызова со стороны сервера и ответов со сто-
роны клиента. Все вызовы сервер передаёт в сообщениях AuthenticationSASLContinue, а клиент
отвечает на них сообщениями SASLResponse. Частные детали сообщений зависят от конкрет-
ного механизма.</li>
  <li>Наконец, когда обмен аутентификационной информацией заканчивается успешно, сервер пе-
редаёт сообщение AuthenticationSASLFinal и сразу за ним сообщение AuthenticationOk. В со-
общении AuthenticationSASLFinal передаются дополнительные данные от сервера клиенту, со-
держимое которых определяется выбранным механизмом аутентификации. Если механизм
аутентификации не требует передавать дополнительные данные в завершение обмена, сооб-
щение AuthenticationSASLFinal опускается.
В случае ошибки сервер может прервать процесс аутентификации на любом этапе и передать со-
общение ErrorMessage.
53.3.1. Аутентификация SCRAM-SHA-256
На данный момент реализованы два механизма SASL: SCRAM-SHA-256 и его вариация со связыва-
нием каналов, SCRAM-SHA-256-PLUS. Они подробно описываются в RFC 7677 и в RFC 5802.
2037Клиент-серверный протокол
Когда в PostgreSQL задействуется SCRAM-SHA-256, сервер игнорирует имя пользователя, кото-
рое клиент передаёт в client-first-message. Вместо этого используется имя, переданное ранее
в стартовом сообщении. Согласно спецификации SCRAM, имя пользователя должно быть в UTF-8,
но PostgreSQL поддерживает разные кодировки символов, и значит, имя пользователя PostgreSQL
не всегда будет представимо в UTF-8.
В спецификации SCRAM говорится, что пароль также должен передаваться в UTF-8 и обрабаты-
ваться алгоритмом SASLprep. Однако PostgreSQL не требует, чтобы пароль представлялся в UTF-8.
Когда устанавливается пароль пользователя, он обрабатывается алгоритмом SASLprep как пароль
в UTF-8, вне зависимости от фактической кодировки. Однако, если он представлен недопустимой
для UTF-8 последовательностью байтов либо содержит комбинации байтов UTF-8, которые не при-
нимает алгоритм SASLprep, это не будет считаться ошибкой — при аутентификации будет исполь-
зоваться исходный пароль, без обработки SASLprep. Это позволяет нормализовать пароли, пред-
ставленные в UTF-8, и при этом использовать пароли не в UTF-8, а также не требует, чтобы система
знала, в какой кодировке задан пароль.
Связывание каналов поддерживается в PostgreSQL при сборке с использованием SSL. Для
SCRAM со связыванием каналов в качестве имени механизма SASL выбрано SCRAM-SHA-256-PLUS.
PostgreSQL использует тип связывания tls-server-end-point.
В SCRAM без связывания каналов сервер выбирает случайное число, которое передаётся клиенту
для смешивания с введённым пользователем паролем и получения передаваемого в ответ хеша.
Хотя это препятствует повторному воспроизведению пароля в последующем сеансе, поддельный
сервер между настоящим сервером и клиентом может прозрачно передать случайное число сер-
вера и затем успешно пройти аутентификацию.
SCRAM со связыванием каналов позволяет предотвратить такие атаки посредника, подмешивая
подпись сертификата сервера в передаваемый хеш пароля. Хотя поддельный сервер может повто-
рить передачу сертификата настоящего сервера, у него не будет доступа к закрытому ключу, соот-
ветствующему этому сертификату, поэтому он не сможет подтвердить, что является его владель-
цем, и, как следствие, установить SSL-соединение.
Пример</li>
  <li>Сервер передаёт сообщение AuthenticationSASL. Оно содержит список механизмов аутентифи-
кации SASL, с которыми может работать сервер. Этот список будет включать SCRAM-SHA-256-
PLUS и SCRAM-SHA-256, если сервер собран с поддержкой SSL, а иначе — только последнее зна-
чение.</li>
  <li>Клиент в ответ передаёт сообщение SASLInitialResponse, информирующее о выбранном меха-
низме, SCRAM-SHA-256 или SCRAM-SHA-256-PLUS. (Клиент волен выбрать любой механизм, но
для большей безопасности следует выбирать вариацию со связыванием каналов, если он это
поддерживает.) В поле «Начальный ответ клиента» это сообщение содержит данные SCRAM
client-first-message. В client-first-message содержится тип связывания каналов, выбран-
ный клиентом.</li>
  <li>Сервер передаёт сообщение AuthenticationSASLContinue, содержащее данные SCRAM server-
first message.</li>
  <li>Клиент передаёт сообщение SASLResponse, содержащее данные SCRAM client-final-
message.</li>
  <li>Сервер передаёт сообщение AuthenticationSASLFinal, содержащее данные SCRAM server-
final-message, и сразу за ним сообщение AuthenticationOk.
53.4. Протокол потоковой репликации
Чтобы инициировать потоковую репликацию, клиент передаёт в стартовом сообщении параметр
replication. Логическое значение true (или on, yes, 1) этого параметра указывает обслуживаю-
щему процессу перейти в режим передатчика данных физической репликации. В этом режиме
вместо SQL-операторов клиент может выдавать только ограниченный набор команд репликации,
показанный ниже.
2038Клиент-серверный протокол
Если параметр replication имеет значение database, обслуживающий процесс должен перейти в
режим передатчика данных логической репликации. При этом выполняется подключение к базе
данных, заданной в параметре dbname. В режиме логической репликации могут выполняться как
команды репликации, показанные ниже, так и обычные SQL-команды.
В режиме передачи данных физической или логической репликации может использоваться только
протокол простых запросов.
Для тестирования команд репликации вы можете установить соединение для репликации, запу-
стив psql или другую программу на базе libpq со строкой подключения, включающей параметр
replication, например так:
psql “dbname=postgres replication=database” -c “IDENTIFY_SYSTEM;”
Однако часто полезнее использовать
pg_recvlogical (для логической).
pg_receivewal
(для
физической
репликации)
или
Команды репликации записываются в журнал работы сервера, когда включён параметр
log_replication_commands.
В режиме репликации принимаются следующие команды:
IDENTIFY_SYSTEM
Запрашивает идентификационные данные сервера. Сервер возвращает набор результатов с од-
ной строкой, содержащей четыре поля:
systemid (text)
Уникальный идентификатор системы, идентифицирующий кластер. По нему можно опреде-
лить, что базовая резервная копия, из которой инициализировался резервный сервер, по-
лучена из того же кластера.
timeline (int4)
Идентификатор текущей линии времени. Также полезен для того, чтобы убедиться, что ре-
зервный сервер согласован с главным.
xlogpos (text)
Текущее положение сохранённых данных в WAL. Позволяет узнать, с какой позиции в жур-
нале предзаписи может начаться потоковая передача.
dbname (text)
Подключённая база данных или NULL.
SHOW имя
Запрашивает у сервера текущее значение параметра времени выполнения. Эта команда подоб-
на SQL-команде SHOW.
имя
Имя параметра времени выполнения. Доступные параметры описаны в Главе 19.
TIMELINE_HISTORY tli
Запрашивает с сервера файл истории для линии времени лин_врем. Сервер возвращает набор
результатов с одной строкой, содержащей два поля:
filename (text)
Имя файла с историей линии времени, например 00000002.history.
content (bytea)
Содержимое файла с историей линией времени.
2039Клиент-серверный протокол
CREATE_REPLICATION_SLOT имя_слота [ TEMPORARY ] { PHYSICAL [ RESERVE_WAL ] | LOGICAL модуль_вы-
вода [ EXPORT_SNAPSHOT | NOEXPORT_SNAPSHOT | USE_SNAPSHOT ] }
Создаёт слот физической или логической репликации. Слоты репликации описаны подробно
в Подразделе 26.2.6.
имя_слота
Имя создаваемого слота. Заданное имя должно быть допустимым для слота репликации (см.
Подраздел 26.2.6.1).
модуль_вывода
Имя модуля вывода, применяемого для логического декодирования (см. Раздел 49.6).
TEMPORARY
Это указание отмечает, что данный слот репликации является временным. Временные сло-
ты не сохраняются на диске и автоматически удаляются при ошибке или завершении се-
анса.
RESERVE_WAL
Указывает, что этот слот физической репликации резервирует WAL немедленно. Без этого
указания WAL резервируется только при подключении клиента потоковой репликации.
EXPORT_SNAPSHOT
NOEXPORT_SNAPSHOT
USE_SNAPSHOT
Эти указания выбирают, что делать со снимком, создаваемым при инициализации логиче-
ского слота. С указанием EXPORT_SNAPSHOT, подразумеваемым по умолчанию, этот снимок
будет экспортироваться для использования в других сеансах. Это указание нельзя исполь-
зовать внутри транзакции. С указанием USE_SNAPSHOT снимок будет использоваться для те-
кущей транзакции, в которой выполняется команда. Это указание должно использоваться в
транзакции, при этом команда CREATE_REPLICATION_SLOT должна быть первой в этой тран-
закции. Наконец, с NOEXPORT_SNAPSHOT снимок будет использоваться только для логическо-
го декодирования в обычном режиме, но ничего больше с ним делать нельзя.
В ответ на эту команду сервер передаст набор результатов с одной строкой, содержащей сле-
дующие поля:
slot_name (text)
Имя создаваемого слота репликации.
consistent_point (text)
Позиция в WAL, в которой слот достиг согласованного состояния. Это самая ранняя пози-
ция, с которой может начаться трансляция через этот слот репликации.
snapshot_name (text)
Идентификатор снимка, экспортированного командой. Этот снимок действителен до тех
пор, пока через это соединение не будет выполнена следующая команда или соединение не
будет закрыто. Null, если созданный слот — физический.
output_plugin (text)
Имя модуля вывода, используемого созданным слотом репликации. Null, если созданный
слот — физический.
START_REPLICATION [ SLOT имя_слота ] [ PHYSICAL ] XXX/XXX [ TIMELINE лин_врем ]
Указывает серверу начать потоковую передачу WAL, начиная с позиции XXX/XXX в WAL. Если
указывается параметр TIMELINE, передача начинается на линии времени лин_врем, иначе вы-
2040Клиент-серверный протокол
бирается текущая линия времени сервера. Сервер может вернуть в ответ ошибку, например,
если запрошенный сегмент WAL уже потерян. Если проблем не возникает, сервер возвращает
сообщение CopyBothResponse, а затем начинает передавать поток WAL клиенту.
Если в параметрах передаётся имя_слота, сервер будет отражать состояние репликации в этом
слоте и отслеживать, какие сегменты, а если включён режим hot_standby_feedback, то и в
каких транзакциях, всё ещё нужны этому резервному серверу.
Если клиент запрашивает не последнюю, но существующую в истории сервера линию времени,
сервер будет передавать весь WAL на этой линии времени, начиная с запрошенной стартовой
точки до момента, когда сервер переключился на другую линию времени. Если клиент запра-
шивает передачу с начальной позицией точно в конце старой линии времени, сервер немед-
ленно отвечает CommandComplete, не переходя в режим COPY.
После передачи всех записей WAL на линии времени, не являющейся текущей, сервер завер-
шает потоковую передачу, выходя из режима копирования. Когда клиент подтверждает завер-
шение передачи, также выходя из режима копирования, сервер возвращает набор результатов
в одной строке с двумя столбцами, сообщая таким образом о следующей линии времени в ис-
тории сервера. В первом столбце передаётся идентификатор следующей линии времени (типа
int8), а во втором — позиция в WAL, в которой произошло переключение (типа text). Обычно
в этой же позиции завершается передача потока WAL, но возможны исключения, когда сервер
может передавать записи WAL из старой линии времени, которые он сам ещё не воспроизвёл
до переключения. Наконец сервер передаёт сообщение CommandComplete, после чего он готов
принять следующую команду.
Данные WAL передаются в серии сообщений CopyData. (Это позволяет перемежать их с другой
информацией; в частности, сервер может передать сообщение ErrorResponse, если он столк-
нулся с проблемами, уже начав передачу потока.) Полезная нагрузка каждого сообщения
CopyData от сервера к клиенту содержит данные в одном из следующих форматов:
XLogData (B) — данные журнала транзакций
Byte1(‘w’)
Указывает, что в этом сообщении передаются данные WAL.
Int64
Начальная точка данных WAL в этом сообщении.
Int64
Текущее положение конца WAL на сервере.
Int64
Показания системных часов сервера в момент передачи, в микросекундах с полуночи
2000-01-01.
Byten
Фрагмент потока данных WAL.
Одна запись WAL никогда не разделяется на два сообщения XLogData. Когда запись WAL
пересекает границу страницы WAL, и таким образом от неё уже оказывается отделена
продолжающая запись, её можно разделить на сообщения по границе страницы. Други-
ми словами, первая основная запись WAL и продолжающие её записи могут быть пере-
даны в различных сообщениях XLogData.
Primary keepalive message (B) — Сообщение об активности ведущего
Byte1(‘k’)
Указывает, что это сообщение об активности отправителя.
2041Клиент-серверный протокол
Int64
Текущее положение конца WAL на сервере.
Int64
Показания системных часов сервера в момент передачи, в микросекундах с полуночи
2000-01-01.
Byte1
Значение 1 означает, что клиент должен ответить на это сообщение как можно скорее,
во избежание отключения по тайм-ауту. Со значением 0 это не требуется.
Принимающий процесс может передавать ответы отправителю в любое время, используя один
из следующих форматов данных (также в полезной нагрузке сообщения CopyData):
Standby status update (F) — Обновление состояния резервного сервера
Byte1(‘r’)
Указывает, что это сообщение передаёт обновлённое состояние получателя.
Int64
Положение следующего за последним байтом WAL, полученным и записанным на диск
на резервном сервере.
Int64
Положение следующего за последним байтом WAL, сохранённым на диске на резервном
сервере.
Int64
Положение следующего за последним байтом WAL, применённым на резервном сервере.
Int64
Показания системных часов клиента в момент передачи, в микросекундах с полуночи
2000-01-01.
Byte1
Если содержит 1, клиент запрашивает от сервера немедленный ответ на это сообщение.
Так клиент может запросить отклик сервера и проверить, продолжает ли функциониро-
вать соединение.
Hot Standby feedback message (F) — Сообщение обратной связи горячего резерва
Byte1(‘h’)
Указывает, что это сообщение обратной связи горячего резерва.
Int64
Показания системных часов клиента в момент передачи, в микросекундах с полуночи
2000-01-01.
Int32
Текущее глобальное значение xmin данного резервного сервера, не учитывающее
catalog_xmin всех слотов репликации. Если и это значение, и следующее catalog_xmin,
равны 0, это воспринимается как уведомление о том, что через данное подключение
больше не будут передаваться сообщения обратной связи горячего резерва. Последую-
щие ненулевые сообщения могут возобновить работу механизма обратной связи.
2042Клиент-серверный протокол
Int32
Эпоха глобального идентификатора транзакции xmin на резервном сервере.
Int32
Наименьшее значение catalog_xmin для всех слотов репликации на резервном сервере.
Значение 0 показывает, что на резервном сервере нет catalog_xmin, либо обратная связь
горячего резерва отключена.
Int32
Эпоха идентификатора транзакции catalog_xmin на резервном сервере.
START_REPLICATION SLOT имя_слота LOGICAL XXX/XXX [ ( имя_параметра [ значение_параметра ] [, …] ) ]
Указывает серверу начать потоковую передачу WAL для логической репликации, начиная с
позиции XXX/XXX в WAL. Сервер может вернуть в ответ ошибку, например, если запрошен-
ный сегмент WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение
CopyBothResponse, а затем начинает передавать поток WAL клиенту.
Данные, передаваемые внутри сообщений CopyBothResponse, имеют тот же формат, что описан
для команды START_REPLICATION … PHYSICAL.
Обработку выводимых данных для передачи выполняет модуль вывода, связанный с выбранным
слотом.
SLOT имя_слота
Имя слота, из которого передаются изменения. Это имя является обязательным, оно долж-
но соответствовать существующему логическому слоту репликации, созданному командой
CREATE_REPLICATION_SLOT в режиме LOGICAL.
XXX/XXX
Позиция в WAL, с которой должна начаться передача.
имя_параметра
Имя параметра, передаваемого модулю логического декодирования для выбранного слота.
значение_параметра
Необязательное значение, в форме строковой константы, связываемое с указанным пара-
метром.
DROP_REPLICATION_SLOT имя_слота [ WAIT ]
Удаляет слот репликации, что приводит к освобождению всех занятых им ресурсов на стороне
сервера. Если слот представляет собой логический слот, созданный не в той базе данных, к
которой подключён walsender, команда завершается ошибкой.
имя_слота
Имя слота, подлежащего удалению.
WAIT
С этим указанием команда будет ждать, пока активный слот не станет неактивным (по умол-
чанию в этом случае выдаётся ошибка).
BASE_BACKUP [ LABEL ‘метка’ ] [ PROGRESS ] [ FAST ] [ WAL ] [ NOWAIT ] [ MAX_RATE rate ] [ TABLESPACE_MAP
] [ NOVERIFY_CHECKSUMS ]
Указывает серверу начать потоковую передачу базовой копии. Система автоматически перехо-
дит в режим резервного копирования до начала передачи, и выходит из него после завершения
копирования. Эта команда принимает следующие параметры:
2043Клиент-серверный протокол
LABEL ‘метка’
Устанавливает метку для резервной копии. Если метка не задана, по умолчанию устанав-
ливается метка base backup. Для метки действуют те же правила применения кавычек, что
и для стандартных строк SQL при включённым режиме standard_conforming_strings.
PROGRESS
Запрашивает информацию, необходимую для отслеживания прогресса операции. Сервер
передаёт в ответ приблизительный размер в заголовке каждого табличного пространства,
исходя из которого можно понять, насколько продвинулась передача потока. Для вычис-
ления этого размера анализируются размеры всех файлов ещё до начала передачи, и это
может негативно повлиять на производительность — в частности, может увеличиться за-
держка до передачи первых данных. Так как файлы базы данных могут меняться во время
резервного копирования, оценка размера не будет точной; размер базы может увеличиться
или уменьшиться за время от вычисления этой оценки до передачи актуальных файлов.
FAST
Запрашивает быструю контрольную точку.
WAL
Включает в резервную копию необходимые сегменты WAL. При этом в подкаталог pg_wal
архива базового каталога будут включены все файлы с начала до конца копирования.
NOWAIT
По умолчанию при копировании ожидается завершение архивации последнего требуемого
сегмента WAL либо выдаётся предупреждение, если архивация журнала не включена. Ука-
зание NOWAIT отключает и ожидание, и предупреждение, так что обеспечение наличия тре-
буемого журнала становится задачей клиента.
MAX_RATE скорость
Ограничивает (сдерживает) максимальный объём данных, передаваемый от сервера клиен-
ту за единицу времени. Единица измерения этого параметра — килобайты в секунду. Если
задаётся этот параметр, его значение должно быть равно нулю, либо должно находиться в
диапазоне от 32 (килобайт/сек) до 1 Гбайта/сек (включая границы). Если передаётся ноль,
либо параметр не задаётся, скорость передачи не ограничивается.
TABLESPACE_MAP
Включает информацию о символических ссылках, представленных в каталоге pg_tblspc,
в файл tablespace_map. Файл карты табличных пространств содержит имена всех ссылок,
содержащихся в каталоге pg_tblspc/, и полный путь для каждой ссылки.
NOVERIFY_CHECKSUMS
По умолчанию контрольные суммы проверяются в процессе базового резервного копирова-
ния, если они включены. Указание NOVERIFY_CHECKSUMS отключает эту проверку.
Когда запускается копирование, сервер сначала передаёт два обычных набора результатов, за
которыми следуют один или более результатов CopyResponse.
В первом обычном наборе результатов передаётся начальная позиция резервной копии, в од-
ной строке с двумя столбцами. В первом столбце содержится стартовая позиция в формате
XLogRecPtr, а во втором идентификатор соответствующей линии времени.
Во втором обычном наборе результатов передаётся по одной строке для каждого табличного
пространства. Эта строка содержит следующие поля:
spcoid (oid)
OID табличного пространства либо NULL, если это базовый каталог.
2044Клиент-серверный протокол
spclocation (text)
Полный путь к каталогу табличного пространства либо NULL, если это базовый каталог.
size (int8)
Приблизительный размер табличного пространства, если была запрошена информация о
прогрессе операции; в противном случае NULL.
За вторым обычным набором результатов следует одна или несколько серий результатов
CopyResponse, одна для основного каталога данных и по одной для каждого табличного
пространства, отличного от pg_default и pg_global. Данные в CopyResponse представляют
собой выгруженное в формате tar («формате обмена ustar», описанном в стандарте POSIX
1003.1-2008) содержимое табличных пространств, за исключением того, что два замыкающих
блока нулей, описанных в стандарте, не передаются. После завершения передачи данных tar
передаётся заключительный обычный набор результатов, в котором сообщается конечная по-
зиция копии в WAL, в том же формате, что и стартовая позиция.
Архив tar каталога данных и всех табличных пространств будет содержать все файлы в этих
каталогах, будь то файлы PostgreSQL или посторонние файлы, добавленные в эти каталоги.
Исключение составляют только следующие файлы:
•
•
•
•
•
•
•
•
postmaster.pid
postmaster.opts
pg_internal.init (находится в нескольких каталогах)
Различные временные файлы и каталоги, создаваемые в процессе работы сервером
PostgreSQL, в частности, файлы и каталоги с именами, начинающимися с pgsql_tmp, и вре-
менные отношения.
Нежурналируемые отношения, за исключением слоя инициализации, который необходим
при восстановлении для пересоздания нежурналируемого отношения (пустого).
pg_wal, включая подкаталоги. Если в резервную копию включаются файлы WAL, в архив
входит преобразованная версия pg_wal, в которой будут находиться только файлы, необхо-
димые для восстановления копии, но не всё остальное содержимое этого каталога
pg_dynshmem, pg_notify, pg_replslot, pg_serial, pg_snapshots, pg_stat_tmp и pg_subtrans
копируются как пустые каталоги (даже если это символические ссылки)
файлы, кроме обычных файлов и каталогов, например, символические ссылки (кроме вы-
шеупомянутых каталогов) и файлы специальных устройств, пропускаются (символические
ссылки в pg_tblspc сохраняются).
Если файловая система сервера поддерживает это, в архив включается информация о владель-
це, группе и режиме файла.
53.5. Протокол логической потоковой репликации
В этом разделе описывается протокол логической репликации, регламентирующий поток сообще-
ний, который запускается командой репликации START_REPLICATION SLOT имя_слота LOGICAL.
Протокол логической потоковой репликации построен на примитивах протокола физической по-
токовой репликации.
53.5.1. Параметры протокола логической потоковой репликации
Команда логической репликации START_REPLICATION принимает следующие параметры:
proto_version
Версия протокола. В настоящее время поддерживается только версия 1.
publication_names
Список разделённых запятыми имён публикаций, на которые подписывается клиент (будет по-
лучать их изменения). Имена отдельных публикаций обрабатываются как стандартные имена
объектов и могут так же заключаться в кавычки при необходимости.
2045Клиент-серверный протокол
53.5.2. Сообщения протокола логической репликации
Отдельные сообщения протокола рассматриваются в следующих подразделах. Собственно сооб-
щения описаны в Раздел 53.9.
Все сообщения верхнего уровня начинаются с байта, определяющего тип сообщения. Хотя он пред-
ставлен в коде символьным типом, это знаковый байт без явно заданной кодировки.
Так как в протоколе потоковой репликации передаётся длина сообщения, нет необходимости ука-
зывать длину в заголовках сообщений верхнего уровня.
53.5.3. Поток сообщений протокола логической репликации
За исключением команды START_REPLICATION и сообщений о прогрессе воспроизведения, весь ин-
формационный поток направлен от сервера к клиенту.
Протокол логической репликации передаёт отдельные транзакции одну за другой. Это значит, что
все сообщения между парой сообщений Begin и Commit относятся к одной транзакции.
Каждая передаваемая транзакция содержит ноль или более сообщений DML (Insert, Update,
Delete). В каскадной схеме она может также содержать сообщения Origin. Это сообщение показы-
вает, что транзакция пришла с другого узла в схеме репликации. Так как этим узлом в контексте
протокола логической репликации может быть что угодно, единственным идентификатором явля-
ется его имя. Как воспринимать это имя (если это вообще нужно), определяют нижестоящие узлы.
Сообщение Origin всегда передаётся перед всеми остальными сообщениями DML в транзакции.
Каждое DML-сообщение содержит произвольный идентификатор отношения, который можно со-
поставить с идентификатором в сообщениях Relation. Сообщения Relation описывают схему данно-
го отношения. Такие сообщения передаются для заданного отношения либо когда нужно впервые
передать DML-сообщения для этого отношения в текущем сеансе, либо когда определение отноше-
ния изменилось со времени предыдущей передачи сообщения Relation о нём. В протоколе предпо-
лагается, что клиент сможет кешировать метаданные для достаточно большого числа отношений.
53.6. Типы данных в сообщениях
В этом разделе описываются базовые типы данных, применяемые в сообщениях.
Intn(i)
Целое число из n бит с сетевым порядком байт (наиболее значащий байт первый). Если указано
i, это поле будет содержать именно указанное значение, в противном случае значение пере-
менное. Например: Int16, Int32(42).
Intn[k]
Массив из k n-битовых целых, каждое записывается с сетевым порядком байт. Длина массива
k всегда определяется по предыдущему полю сообщения, например Int16[M].
String(s)
Строка, оканчивающаяся нулём (строка в стиле C). На длину строк ограничение не накладыва-
ется. Если указывается s, это поле будет содержать именно указанное значение, в противном
случае значение переменное. Например: String, String(“user”).
Примечание
Нет никакого предопределённого ограничения длины строки, которую может воз-
вратить сервер. Поэтому при реализации клиента лучше использовать расширяе-
мый буфер, чтобы он мог принять строку любого размера, умещающуюся в памяти.
Если такой возможности нет, прочитайте строку целиком и отбросьте последние
символы, не помещающиеся в ваш буфер фиксированного размера.
2046Клиент-серверный протокол
Byten(c)
В точности n байт. Если размер поля n задаётся не константой, он всегда определяется по
предыдущему полю сообщения. Если указывается c, оно задаёт точное значение. Например:
Byte2, Byte1(‘\n’).
53.7. Форматы сообщений
В этом разделе подробно описывается формат каждого сообщения. Все сообщения помечены сим-
волами, обозначающими, какая сторона может их передавать: сервер (F), клиент (B) или обе сто-
роны (F &amp; B). Заметьте, что хотя каждое сообщение включает счётчик байт в начале, формат сооб-
щения разработан так, чтобы конец сообщения можно было найти, не обращаясь к счётчику байт.
Это помогает проверять корректность сообщений. (Исключением является сообщение CopyData,
так как оно образует часть потока данных; содержимое любого отдельного сообщения CopyData
нельзя интерпретировать само по себе.)
AuthenticationOk (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(0)
Показывает, что проверка подлинности прошла успешно.
AuthenticationKerberosV5 (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(2)
Указывает, что требуется проверка подлинности по протоколу Kerberos V5.
AuthenticationCleartextPassword (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(3)
Указывает, что требуется пароль, передаваемый открытым текстом.
AuthenticationMD5Password (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(12)
Длина содержимого сообщения в байтах, включая само поле длины.
2047Клиент-серверный протокол
Int32(5)
Указывает, что требуется пароль, преобразованный в хеш MD5.
Byte4
Значение соли, с которым должен хешироваться пароль.
AuthenticationSCMCredential (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(6)
Указывает, что требуется сообщение с учётными данными SCM.
AuthenticationGSS (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(7)
Указывает, что требуется проверка подлинности на базе GSSAPI.
AuthenticationSSPI (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(9)
Указывает, что требуется проверка подлинности на базе SSPI.
AuthenticationGSSContinue (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(8)
Указывает, что это сообщение содержит данные GSSAPI или SSPI.
Byten
Данные аутентификации для GSSAPI или SSPI.
AuthenticationSASL (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
2048Клиент-серверный протокол
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(10)
Указывает, что требуется проверка подлинности на базе SASL.
Тело сообщения содержит список механизмов аутентификации SASL, в порядке предпочтений
сервера. За последним именем механизма аутентификации должен идти завершающий нулевой
байт. Для каждого механизма передаётся:
String
Имя механизма аутентификации SASL.
AuthenticationSASLContinue (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(11)
Указывает, что это сообщение содержит данные вызова SASL.
Byten
Данные SASL, специфичные для применяемого механизма SASL.
AuthenticationSASLFinal (B)
Byte1(‘R’)
Указывает, что это сообщение представляет запрос аутентификации.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(12)
Указывает, что аутентификация SASL завершена.
Byten
«Дополнительные данные» результата SASL, специфичные для применяемого механизма
SASL.
BackendKeyData (B)
Byte1(‘K’)
Указывает, что это сообщение содержит ключевые данные для отмены запросов. Клиент
должен сохранить эти данные, если ему нужна возможность впоследствии выдавать сооб-
щения CancelRequest.
Int32(12)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32
PID обслуживающего процесса.
2049Клиент-серверный протокол
Int32
Секретный ключ обслуживающего процесса.
Bind (F)
Byte1(‘B’)
Указывает, что это сообщение представляет команду Bind.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Имя целевого портала (пустая строка выбирает безымянный портал).
String
Имя исходного подготовленного оператора (пустая строка выбирает безымянный подготов-
ленный оператор).
Int16
Количество кодов форматов следующих параметров (обозначается ниже символом C). Мо-
жет быть нулевым, что показывает, что параметры отсутствуют или все параметры переда-
ются в формате по умолчанию (текстовом); либо равняться одному, в этом случае указанный
один код формата применяется ко всем параметрам; либо может равняться действительно-
му количеству параметров.
Int16[C]
Коды форматов параметров. В настоящее время допускаются коды ноль (текстовый формат)
и один (двоичный).
Int16
Количество следующих значений параметров (может быть нулевым). Оно должно совпадать
с количеством параметров, требующихся для запроса.
Затем для каждого параметра идёт следующая пара полей:
Int32
Длина значения параметра, в байтах (само поле длины не считается). Может быть нулевой.
В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие
байты значений далее не следуют.
Byten
Значение параметра в формате, определённом соответствующим кодом формата. Перемен-
ная n задаёт длину значения.
За последним параметром идут следующие поля:
Int16
Количество кодов формата для следующих столбцов результата (обозначается ниже симво-
лом R). Может быть нулевым, что показывает, что столбцы результата отсутствуют или для
всех столбцов должен использоваться формат по умолчанию (текстовый), либо равняться
одному, в этом случае указанный один код формата применяется ко всем столбцам (если
они есть), либо может равняться действительному количеству столбцов результата запроса.
Int16[R]
Коды форматов столбцов результата. В настоящее время допускаются коды ноль (текстовый
формат) и один (двоичный).
2050Клиент-серверный протокол
BindComplete (B)
Byte1(‘2’)
Указывает, что это сообщение, сигнализирующее о завершении Bind.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
CancelRequest (F)
Int32(16)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(80877102)
Код запроса отмены. Это специально выбранное значение содержит 1234 в старших 16 битах
и 5678 в младших 16 битах. (Во избежание неоднозначности этот код не должен совпадать
с номером версии протокола.)
Int32
PID целевого обслуживающего процесса.
Int32
Секретный ключ целевого обслуживающего процесса.
Close (F)
Byte1(‘C’)
Указывает, что это сообщение представляет команду Close.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Byte1
‘S’ для закрытия подготовленного оператора, ‘P’ для закрытия портала.
String
Имя подготовленного оператора или портала, который должен быть закрыт (пустая строка
выбирает безымянный подготовленный оператор или портал).
CloseComplete (B)
Byte1(‘3’)
Указывает, что это сообщение, сигнализирующее о завершении Close.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
CommandComplete (B)
Byte1(‘C’)
Указывает, что это сообщение об успешном завершении команды.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
2051Клиент-серверный протокол
String
Тег команды. Обычно это одно слово, обозначающее завершённую команду SQL.
Для команды INSERT в качестве тега передаётся INSERT oid строк, где строк — количество
вставленных строк. В поле oid передаётся идентификатор объекта вставленной строки, если
число строк равно 1 и в целевой таблице содержатся OID; в противном случае вместо oid
передаётся 0.
Для команды DELETE в качестве тега передаётся DELETE строк, где строк — количество уда-
лённых строк.
Для команды UPDATE в качестве тега передаётся UPDATE строк, где строк — количество из-
менённых строк.
Для команды SELECT или CREATE TABLE AS в качестве тега передаётся SELECT строк, где
строк — число полученных строк.
Для команды MOVE в качестве тега передаётся MOVE строк, где строк — количество строк,
на которое изменилась позиция курсора.
Для команды FETCH в качестве тега передаётся FETCH строк, где строк — количество строк,
полученное через курсор.
Для команды COPY в качестве тега передаётся COPY строк, где строк — количество скопи-
рованных строк. (Заметьте: число строк выводится, начиная только с PostgreSQL 8.2.)
CopyData (F &amp; B)
Byte1(‘d’)
Указывает, что в этом сообщении передаются данные COPY.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Byten
Данные, образующие часть информационного потока COPY. Сообщения от сервера всегда
соответствуют отдельным строкам данных, но сообщения, передаваемые клиентами, могут
разделять поток произвольным образом.
CopyDone (F &amp; B)
Byte1(‘c’)
Указывает, что это сообщение, сигнализирующее о завершении COPY.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
CopyFail (F)
Byte1(‘f’)
Указывает, что это сообщение, сигнализирующее об ошибке операции COPY.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Сообщение об ошибке, описывающее причину сбоя операции.
2052Клиент-серверный протокол
CopyInResponse (B)
Byte1(‘G’)
Указывает, что это сообщение является ответом на запуск входящего копирования. Получив
его, клиент начинает передавать данные на вход операции копирования (если клиент не
готов к этому, он передаёт сообщение CopyFail).
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int8
Значение 0 указывает, что для всей операции COPY применяется текстовый формат (строки
разделяются символами новой строки, столбцы разделяются символами-разделителями и
т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный
формат (подобный формату DataRow). За дополнительными сведениями обратитесь к COPY.
Int16
Количество столбцов в копируемых данных (ниже обозначается символом N).
Int16[N]
Коды формата для каждого столбца. В настоящее время допускаются коды ноль (текстовый
формат) и один (двоичный). Если общий формат копирования — текстовый, все эти коды
должны быть нулевыми.
CopyOutResponse (B)
Byte1(‘H’)
Указывает, что это сообщение является ответом на запуск исходящего копирования. За этим
сообщением следуют данные, исходящие со стороны сервера.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int8
Значение 0 указывает, что для всей операции COPY применяется текстовый формат (строки
разделяются символами новой строки, столбцы разделяются символами-разделителями и
т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный
формат (подобный формату DataRow). За дополнительными сведениями обратитесь к COPY.
Int16
Количество столбцов в копируемых данных (ниже обозначается символом N).
Int16[N]
Коды формата для каждого столбца. В настоящее время допускаются коды ноль (текстовый
формат) и один (двоичный). Если общий формат копирования — текстовый, все эти коды
должны быть нулевыми.
CopyBothResponse (B)
Byte1(‘W’)
Указывает, что это сообщение является ответом на запуск двустороннего копирования. Это
сообщение используется только для потоковой репликации.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
2053Клиент-серверный протокол
Int8
Значение 0 указывает, что для всей операции COPY применяется текстовый формат (строки
разделяются символами новой строки, столбцы разделяются символами-разделителями и
т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный
формат (подобный формату DataRow). За дополнительными сведениями обратитесь к COPY.
Int16
Количество столбцов в копируемых данных (ниже обозначается символом N).
Int16[N]
Коды формата для каждого столбца. В настоящее время допускаются коды ноль (текстовый
формат) и один (двоичный). Если общий формат копирования — текстовый, все эти коды
должны быть нулевыми.
DataRow (B)
Byte1(‘D’)
Указывает, что в этом сообщении передаётся строка данных.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int16
Количество последующих значений столбцов (может быть нулевым).
Затем для каждого столбца идёт следующая пара полей:
Int32
Длина значения столбца, в байтах (само поле длины не считается). Может быть нулевой.
В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие
байты значений далее не следуют.
Byten
Значение столбца в формате, определённом соответствующим кодом формата. Переменная
n задаёт длину значения.
Describe (F)
Byte1(‘D’)
Указывает, что это сообщение представляет команду Describe.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Byte1
‘S’ для получения описания подготовленного оператора, ‘P’ — портала.
String
Имя подготовленного оператора или портала, описание которого запрашивается (пустая
строка выбирает безымянный подготовленный оператор или портал).
EmptyQueryResponse (B)
Byte1(‘I’)
Указывает, что это сообщение является ответом на пустую строку запроса. (Это сообщение
заменяет CommandComplete.)
2054Клиент-серверный протокол
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
ErrorResponse (B)
Byte1(‘E’)
Указывает, что это сообщение ошибки.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Тело сообщения состоит из одного или нескольких определённых полей, за которыми в каче-
стве завершающего следует нулевой байт. Поля могут идти в любом порядке. Для каждого по-
ля передаётся:
Byte1
Код, задающий тип поля; ноль обозначает конец сообщения, после которого ничего нет. Ти-
пы полей, определённые в настоящее время, перечислены в Разделе 53.8. Так как в будущем
могут появиться другие типы полей, клиенты должны просто игнорировать поля нераспо-
знанного типа.
String
Значение поля.
Execute (F)
Byte1(‘E’)
Указывает, что это сообщение представляет команду Execute.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Имя портала, подлежащего выполнению (пустая строка выбирает безымянный портал).
Int32
Максимальное число строк, которое должно быть возвращено, если портал содержит за-
прос, возвращающий строки (в противном случае игнорируется). Ноль означает «без огра-
ничения».
Flush (F)
Byte1(‘H’)
Указывает, что это сообщение представляет команду Flush.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
FunctionCall (F)
Byte1(‘F’)
Указывает, что это сообщение представляет вызов функции.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32
Задаёт идентификатор объекта вызываемой функции.
2055Клиент-серверный протокол
Int16
Количество кодов форматов следующих аргументов (обозначается ниже символом C). Мо-
жет быть нулевым, что показывает, что аргументы отсутствуют или все аргументы переда-
ются в формате по умолчанию (текстовом); либо равняться одному, в этом случае указан-
ный один код формата применяется ко всем аргументами, либо может равняться действи-
тельному количеству аргументов.
Int16[C]
Коды форматов аргументов. В настоящее время допускаются коды ноль (текстовый формат)
и один (двоичный).
Int16
Задаёт число аргументов, передаваемых функции.
Затем для каждого аргумента идёт следующая пара полей:
Int32
Длина значения аргумента, в байтах (само поле длины не считается). Может быть нулевой.
В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие
байты значений далее не следуют.
Byten
Значение аргумента, в формате, определённом соответствующим кодом формата. Перемен-
ная n задаёт длину значения.
За последним аргументом идут следующие поля:
Int16
Код формата результата функции. В настоящее время допускается код ноль (текстовый фор-
мат) и один (двоичный).
FunctionCallResponse (B)
Byte1(‘V’)
Указывает, что в этом сообщении передаётся результат вызова функции.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32
Длина значения результата функции, в байтах (само поле длины не считается). Может быть
нулевой. В качестве особого значения, -1 представляет значение NULL. В случае с NULL
никакие байты значения далее не следуют.
Byten
Значение результата функции в формате, определённом соответствующим кодом формата.
Переменная n задаёт длину значения.
GSSResponse (F)
Byte1(‘p’)
Обозначает это сообщение как ответ GSSAPI или SSPI. Заметьте, что оно также применя-
ется для ответов SASL и при аутентификации по паролю. Точный тип сообщения можно
определить из контекста.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
2056Клиент-серверный протокол
Byten
Данные сообщения, специфичные для GSSAPI/SSPI.
NegotiateProtocolVersion (B)
Byte1(‘v’)
Указывает, что это сообщение согласования версии протокола.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32
Новейшая младшая версия протокола, поддерживаемая сервером, для запрошенной клиен-
том старшей версии.
Int32
Число параметров протокола, не принятых сервером.
Затем для параметров протокола, не принятых сервером, передаётся:
String
Имя параметра.
NoData (B)
Byte1(‘n’)
Указывает, что это сообщение сигнализирует об отсутствии данных.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
NoticeResponse (B)
Byte1(‘N’)
Указывает, что это сообщение представляет замечание.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Тело сообщения состоит из одного или нескольких определённых полей, за которыми в каче-
стве завершающего следует нулевой байт. Поля могут идти в любом порядке. Для каждого по-
ля передаётся:
Byte1
Код, задающий тип поля; ноль обозначает конец сообщения, после которого ничего нет. Ти-
пы полей, определённые в настоящее время, перечислены в Разделе 53.8. Так как в будущем
могут появиться другие типы полей, клиенты должны просто игнорировать поля нераспо-
знанного типа.
String
Значение поля.
NotificationResponse (B)
Byte1(‘A’)
Указывает, что это сообщение представляет уведомление.
2057Клиент-серверный протокол
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32
PID обслуживающего процесса, отправляющего уведомление.
String
Имя канала, для которого было выдано уведомление.
String
Строка «сообщения», сопровождающего уведомление.
ParameterDescription (B)
Byte1(‘t’)
Указывает, что это сообщение представляет описание параметра.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int16
Количество параметров для оператора (может быть нулевым).
Затем для каждого параметра передаётся:
Int32
Задаёт идентификатор объекта типа данных параметра.
ParameterStatus (B)
Byte1(‘S’)
Указывает, что в этом сообщении передаётся состояние параметра времени выполнения.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Имя параметра времени выполнения, состояние которого передаётся.
String
Текущее значение параметра.
Parse (F)
Byte1(‘P’)
Указывает, что это сообщение представляет команду Parse.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Имя целевого подготовленного оператора (пустая строка выбирает безымянный подготов-
ленный оператор).
String
Строка запроса, которая должна быть разобрана.
2058Клиент-серверный протокол
Int16
Количество типов параметров (может быть нулевым). Заметьте, что это значение представ-
ляет не число параметров, которые могут фигурировать в строке запроса, а число парамет-
ров, для которых клиент хочет предопределить типы.
Затем для каждого параметра передаётся:
Int32
Задаёт идентификатор объекта типа данных параметра. Указание нулевого значения рав-
носильно отсутствию указания типа.
ParseComplete (B)
Byte1(‘1’)
Указывает, что это сообщение, сигнализирующее о завершении Parse.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
PasswordMessage (F)
Byte1(‘p’)
Обозначает это сообщение как ответ SASL. Заметьте, что оно также применяется для отве-
тов GSSAPI, SSPI и SASL. Точный тип сообщения можно определить из контекста.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Пароль (зашифрованный, если требуется).
PortalSuspended (B)
Byte1(‘s’)
Указывает, что это сообщение сигнализирует о приостановке портала. Заметьте, что оно
выдаётся только при достижении ограничения числа строк, заданного в сообщении Execute.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
Query (F)
Byte1(‘Q’)
Указывает, что это сообщение представляет простой запрос.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Собственно строка запроса.
ReadyForQuery (B)
Byte1(‘Z’)
Определяет тип сообщения. Сообщение ReadyForQuery передаётся, когда сервер готов к
новому циклу запросов.
2059Клиент-серверный протокол
Int32(5)
Длина содержимого сообщения в байтах, включая само поле длины.
Byte1
Индикатор текущего состояния транзакции на сервере. Возможные значения: ‘I’, транзак-
ция неактивна (вне блока транзакции), ‘T’ в блоке транзакции, либо ‘E’ в блоке прерванной
транзакции (запросы не будут обрабатываться до завершения блока).
RowDescription (B)
Byte1(‘T’)
Указывает, что это сообщение представляет описание строки.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int16
Задаёт количество полей в строке (может быть нулевым).
Затем для каждого поля передаётся:
String
Имя поля.
Int32
Если поле связано со столбцом определённой таблицы, идентификатор объекта этой табли-
цы; в противном случае — ноль.
Int16
Если поле связано со столбцом определённой таблицы, номер атрибута для этого столбца;
в противном случае — ноль.
Int32
Идентификатор объекта типа данных поля.
Int16
Размер типа данных (см. pg_type.typlen). Заметьте, что отрицательные значения показы-
вают, что тип имеет переменную длину.
Int32
Модификатор типа (см. pg_attribute.atttypmod). Смысл этого модификатора зависит от
типа.
Int16
Код формата, используемого для поля. В настоящее время допускаются коды ноль (тек-
стовый формат) и один (двоичный). В сообщении RowDescription, возвращаемом вариацией
Describe для оператора, код формата ещё не известен и всегда будет нулевым.
SASLInitialResponse (F)
Byte1(‘p’)
Обозначает это сообщение как начальный ответ SASL. Заметьте, что оно также применя-
ется для ответов GSSAPI, SSPI и при аутентификации по паролю. Точный тип сообщения
определяется из контекста.
2060Клиент-серверный протокол
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
String
Имя механизма аутентификации SASL, выбранного клиентом.
Int32
Длина последующего сообщения «Начальный ответ клиента», специфичного для механизма
SASL, или -1, если начального ответа нет.
Byten
«Начальный ответ», специфичный для механизма SASL.
SASLResponse (F)
Byte1(‘p’)
Обозначает это сообщение как ответ SASL. Заметьте, что оно также применяется для отве-
тов GSSAPI, SSPI и при аутентификации по паролю. Точный тип сообщения можно опреде-
лить из контекста.
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Byten
Данные сообщения, специфичные для механизма SASL.
SSLRequest (F)
Int32(8)
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(80877103)
Код запроса SSL. Это специально выбранное значение содержит 1234 в старших 16 битах
и 5679 в младших 16 битах. (Во избежание неоднозначности этот код не должен совпадать
с номером версии протокола.)
StartupMessage (F)
Int32
Длина содержимого сообщения в байтах, включая само поле длины.
Int32(196608)
Номер версии протокола. В старших 16 битах задаётся старший номер версии (3 для про-
токола, описываемого здесь). В младших 16 битах задаётся младший номер версии (0 для
протокола, описываемого здесь).
За номером версии протокола следует одна или несколько пар из имени параметра и строки
значения. За последней парой имя/значение должен следовать нулевой байт. Передаваться
параметры могут в любом порядке. Обязательным является только параметр user, остальные
могут отсутствовать. Каждый параметр задаётся так:
String
Имя параметра. В настоящее время принимаются имена:
user
Имя пользователя баз данных, с которым выполняется подключение. Является обяза-
тельным, значения по умолчанию нет.
2061Клиент-серверный протокол
database
База данных, к которой выполняется подключение. По умолчанию подставляется имя
пользователя.
options
Аргументы командной строки для обслуживающего процесса. (Этот способ считается
устаревшим; теперь следует устанавливать отдельные параметры времени выполнения.)
Пробелы в этой строке воспринимаются как разделяющие аргументы, если перед ними
нет обратной косой черты (); чтобы представить обратную косую черту буквально, про-
дублируйте её (\).
replication
Используется для подключения в режиме потоковой репликации, в котором вместо опе-
раторов SQL может выполняться небольшой набор команд репликации. Допустимые зна-
чения: true, false (по умолчанию) и database. За подробностями обратитесь к Разде-
лу 53.4.
В дополнение к ним могут задаваться и другие параметры. Имена параметров, начинаю-
щиеся с <em>pq</em>., резервируются для использования в расширениях протокола, а остальные
воспринимаются как параметры времени выполнения, передаваемые во время запуска сер-
верному процессу. Такие параметры будут применяться при запуске серверного процесса
(после разбора аргументов командной строки, если они есть) и будут действовать как пара-
метры сеанса по умолчанию.
String
Значение параметра.
Sync (F)
Byte1(‘S’)
Указывает, что это сообщение представляет команду Sync.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
Terminate (F)
Byte1(‘X’)
Указывает, что это сообщение завершает сеанс.
Int32(4)
Длина содержимого сообщения в байтах, включая само поле длины.
53.8. Поля сообщений с ошибками и замечаниями
В этом разделе описываются поля, которые могут содержаться в сообщениях ErrorResponse и
NoticeResponse. Для каждого типа поля определён свой идентификационный маркер. Заметьте,
что в сообщении может содержаться поле любого из этих типов, но не больше одного раза.
S
Важность: поле содержит ERROR, FATAL или PANIC (в сообщении об ошибке), либо WARNING,
NOTICE, DEBUG, INFO или LOG (в сообщении с замечанием), либо переведённые значения (ОШИБ-
КА, ВАЖНО, ПАНИКА, ПРЕДУПРЕЖДЕНИЕ, ЗАМЕЧАНИЕ, ОТЛАДКА, ИНФОРМАЦИЯ, СООБ-
ЩЕНИЕ, соответственно). Это поле присутствует всегда.
2062Клиент-серверный протокол
V
Важность: поле содержит ERROR, FATAL или PANIC (в сообщении об ошибке) либо WARNING, NOTICE,
DEBUG, INFO или LOG (в сообщении с замечанием). Это поле подобно S, но его содержимое ни-
когда не переводится. Присутствует только в сообщениях, выдаваемых PostgreSQL версии 9.6
и новее.
C
Код: код SQLSTATE выданной ошибки (см. Приложение A). Не переводится на другие языки,
присутствует всегда.
M
Сообщение: основное сообщение об ошибке, предназначенное для человека. Должно быть точ-
ным, но кратким (обычно в одну строку). Присутствует всегда.
D
Необязательное дополнительное сообщение об ошибке, передающее более детальную инфор-
мацию о проблеме. Может занимать несколько строк.
H
Подсказка: необязательное предложение решения проблемы. Оно должно отличаться от по-
дробного описания тем, что предлагает совет (не обязательно подходящий во всех случаях), а
не сухие факты. Может располагаться в нескольких строках.
P
Позиция: значение поля представляет целочисленное число в ASCII, указывающее на положе-
ние ошибки в исходной строке запроса. Первый символ находится в позиции 1, при этом пози-
ции отсчитываются по символам, а не по байтам.
p
Внутренняя позиция: она определяется так же, как поле P, но отражает положение ошибки
во внутренне сгенерированной команде, а не в строке, переданной клиентом. Вместе с этим
полем всегда присутствует поле q.
q
Внутренний запрос: текст внутренне сгенерированной команды, в которой произошла ошибка.
Это может быть, например, SQL-запрос, выполняемый функцией на PL/pgSQL.
W
Где: указывает на контекст, в котором произошла ошибка. В настоящее время включает трас-
сировку стека вызовов текущей функции на процедурном языке и внутренне сгенерированных
запросов. Записи трассировки разделяются по строкам, вначале последняя.
s
Имя схемы: если ошибка связана с некоторым объектом базы данных, это поле содержит имя
схемы, к которой относится объект (если такая есть).
t
Имя таблицы: если ошибка связана с некоторой таблицей, это поле содержит имя таблицы.
(Узнать имя схемы таблицы можно из соответствующего отдельного поля.)
c
Имя столбца: если ошибка связана с некоторым столбцом таблицы, это поле содержит имя
столбца. (Идентифицировать таблицу можно, обратившись к полям, содержащим имя таблицы
и схемы.)
2063Клиент-серверный протокол
d
Имя типа данных: если ошибка связана с некоторым типом данных, это поле содержит имя
типа. (Узнать имя схемы типа можно из соответствующего поля.)
n
Имя ограничения: если ошибка связана с некоторым ограничением, это поле содержит имя
ограничения. Чтобы узнать, к какой таблице или домену она относится, обратитесь к полям,
описанным выше. (В данном контексте индексы считаются ограничениями, даже если они были
созданы не с синтаксисом ограничений.)
F
Файл: имя файла с исходным кодом, в котором была обнаружена ошибка.
L
Строка: номер строки в исходном коде, в которой была обнаружена ошибка.
R
Программа: имя программы в исходном коде, в которой была обнаружена ошибка.
Примечание
Поля, содержащие имена схемы, таблицы, столбца, типа данных и ограничения, выда-
ются только для ограниченного числа типов ошибок; см. Приложение A. Клиенты не
должны рассчитывать на то, что присутствие одного из полей обязательно влечёт при-
сутствие другого поля. Системные источники ошибок устанавливают связь между ни-
ми, но пользовательские функции могут использовать эти поля по-другому. Подобным
образом, клиенты не должны полагаться на то, что эти поля ссылаются на актуальные
объекты в текущей базе данных.
Клиент отвечает за форматирование отображаемой информации в соответствии с его нуждами; в
частности, он должен разбивать длинные строки, как требуется. Символы новой строки, встреча-
ющиеся в полях сообщения об ошибке, должны обрабатываться, как разрывы абзацев, а не строк.
53.9. Форматы сообщений логической репликации
В этом разделе подробно описывается формат каждого сообщения логической репликации. Эти
сообщения или выдаются через SQL-интерфейс слота репликации или передаются процессом
walsender. Когда их передаёт walsender, они помещаются внутрь WAL-сообщений протокола репли-
кации, описанных в Разделе 53.4, и в общем следуют тому же потоку сообщений, что и сообщения
физической репликации.
Begin
Byte1(‘B’)
Указывает, что это начальное сообщение.
Int64
Окончательный LSN транзакции.
Int64
Время фиксации транзакции. Значение задаётся в микросекундах, прошедших с начала эпо-
хи PostgreSQL (2000-01-01).
Int32
Идентификатор транзакции.
2064Клиент-серверный протокол
Commit
Byte1(‘C’)
Указывает, что это сообщение о фиксации.
Int8
Флаги; в настоящее время не используются (поле должно содержать 0).
Int64
LSN записи фиксации.
Int64
Конечный LSN транзакции.
Int64
Время фиксации транзакции. Значение задаётся в микросекундах, прошедших с начала эпо-
хи PostgreSQL (2000-01-01).
Origin
Byte1(‘O’)
Указывает, что это сообщение об источнике.
Int64
LSN записи фиксации на сервере-источнике.
String
Имя источника.
Заметьте, что внутри одной транзакции может быть несколько сообщений Origin.
Relation
Byte1(‘R’)
Указывает, что это сообщение об отношении.
Int32
Идентификатор отношения.
String
Пространство имён (пустая строка для pg_catalog).
String
Имя отношения.
Int8
Свойство идентификации реплики для отношения (то же, что и relreplident в pg_class).
Int16
Число столбцов.
Затем для каждого столбца идёт следующий блок сообщения:
Int8
Флаги столбца. В настоящее время это может быть 0 (флагов нет) или 1 (столбец помечается
как часть ключа).
2065Клиент-серверный протокол
String
Имя столбца.
Int32
Идентификатор типа данных столбца.
Int32
Модификатор типа столбца (atttypmod).
Тип
Byte1(‘Y’)
Указывает, что это сообщение о типе.
Int32
Идентификатор типа данных.
String
Пространство имён (пустая строка для pg_catalog).
String
Имя типа данных.
Insert
Byte1(‘I’)
Указывает, что это сообщение о добавлении данных.
Int32
Идентификатор отношения, соответствующий идентификатору в сообщении об отношении.
Byte1(‘N’)
Обозначает следующее сообщение TupleData как содержащее новый кортеж.
TupleData
Блок сообщения TupleData, представляющий содержимое нового кортежа.
Update
Byte1(‘U’)
Указывает, что это сообщение об изменении данных.
Int32
Идентификатор отношения, соответствующий идентификатору в сообщении об отношении.
Byte1(‘K’)
Указывает, что следующий блок TupleData содержит ключ. Это поле является необязатель-
ным и присутствует, только если изменение затронуло столбцы, являющиеся частью индек-
са REPLICA IDENTITY.
Byte1(‘O’)
Указывает, что следующий блок TupleData содержит старый кортеж. Это поле является
необязательным и присутствует, только если у таблицы, в которой произошло изменение,
свойство REPLICA IDENTITY равно FULL.
2066Клиент-серверный протокол
TupleData
Блок сообщения TupleData, представляющий содержимое старого кортежа или первичного
ключа. Присутствует, только если перед ним идёт признак ‘O’ или ‘K’.
Byte1(‘N’)
Обозначает следующее сообщение TupleData как содержащее новый кортеж.
TupleData
Блок сообщения TupleData, представляющий содержимое нового кортежа.
Сообщение Update может содержать либо блок ‘K’, либо блок ‘O’, либо ни один из них, но не
оба сразу.
Delete
Byte1(‘D’)
Указывает, что это сообщение об удалении данных.
Int32
Идентификатор отношения, соответствующий идентификатору в сообщении об отношении.
Byte1(‘K’)
Указывает, что следующий блок TupleData содержит ключ. Это поле присутствует, если
таблица, в которой произошло удаление, использует индекс в качестве REPLICA IDENTITY.
Byte1(‘O’)
Указывает, что следующий блок TupleData содержит старый кортеж. Это поле присутствует,
если у таблицы, в которой произошло удаление, свойство REPLICA IDENTITY равно FULL.
TupleData
Блок сообщения TupleData, представляющий содержимое старого кортежа или первичного
ключа, в зависимости от предыдущего поля.
Сообщение Delete может содержать либо блок ‘K’, либо блок ‘O’, но не оба сразу.
Truncate
Byte1(‘T’)
Указывает, что это сообщение об усечении отношений.
Int32
Число отношений.
Int8
Битовые флаги для TRUNCATE: 1 соответствует указанию CASCADE, 2 — RESTART IDENTITY.
Int32
Идентификатор отношения, соответствующий идентификатору в сообщении об отношении.
Это поле повторятся для каждого отношения.
Описанные выше сообщения имеют следующие общие блоки.
TupleData
Int16
Число столбцов.
2067Клиент-серверный протокол
Затем для каждого столбца следует один из следующих блоков для каждого столбца:
Byte1(‘n’)
Обозначает данные как значение NULL.
Или
Byte1(‘u’)
Обозначает неизменённое значение TOAST (само значение не передаётся).
Или
Byte1(‘t’)
Обозначает данные как значение в текстовом формате.
Int32
Длина значения столбца.
Byten
Значение столбца в текстовом формате. (В будущих выпусках могут поддерживаться и дру-
гие форматы.) Здесь n — заданная выше длина.
53.10. Сводка изменений по сравнению с протоколом
версии 2.0
В этом разделе представлен краткий список изменений к сведению разработчиков, желающих
модернизировать существующие клиентские библиотеки до протокола 3.0.
В начальном стартовом пакете вместо фиксированного формата применяется гибкий формат спис-
ка строк. Заметьте, что теперь сеансовые значения по умолчанию для параметров времени выпол-
нения можно задать непосредственно в стартовом пакете. (Вообще, это можно было делать и рань-
ше, используя поле options, но из-за ограниченного размера options и невозможности задавать
значения с пробелами, это вариант был не очень безопасным.)
Во всех сообщениях непосредственно за байтом типа сообщения следует счётчик длины (за ис-
ключением стартовых пакетов, в которых нет байта типа). Также заметьте, что байт типа теперь
есть в сообщении PasswordMessage.
Сообщения ErrorResponse и NoticeResponse (‘E’ и ‘N’) могут содержать несколько полей, из которых
клиентский код может собрать сообщение об ошибке желаемого уровня детализации. Заметьте,
что текст отдельных полей обычно не завершается новой строкой, тогда как в старом протоколе
одиночная строка всегда завершалась так.
Сообщение ReadyForQuery (‘Z’) включает индикатор статуса транзакции.
Различие между типами данных BinaryRow и DataRow ушло; один тип сообщений DataRow позво-
ляет возвращать данные во всех форматах. Заметьте, что формат DataRow был изменён для упро-
щения его разбора. Также изменилось представление двоичных значений: оно больше не привя-
зано к внутреннему представлению сервера.
В протоколе появился новый подраздел «расширенный запрос», в котором добавлены типы со-
общений для команд Parse, Bind, Execute, Describe, Close, Flush и Sync, а также типы сервер-
ных сообщений ParseComplete, BindComplete, PortalSuspended, ParameterDescription, NoData и
CloseComplete. Существующие клиенты могут не подстраиваться под этот раздел протокола, но
если они задействует его, это позволит улучшить производительность или функциональность.
Данные COPY теперь внедряются в сообщения CopyData и CopyDone. Есть чётко определённый спо-
соб восстановить работу в случае ошибок в процессе COPY. Специальная последняя строка «.»
2068Клиент-серверный протокол
больше не нужна, она не передаётся при выполнении COPY OUT. (Она по-прежнему воспринимает-
ся как завершающая последовательность в потоке COPY IN, но это считается устаревшим спосо-
бом завершения, и в конце концов он будет исключён.) Поддерживается COPY в двоичном режиме.
Сообщения CopyInResponse и CopyOutResponse включают поля, определяющие число столбцов и
формат каждого столбца.
Изменилась структура сообщений FunctionCall и FunctionCallResponse. Сообщение FunctionCall те-
перь позволяет передавать функциям аргументы NULL. Ещё в нём могут передаваться параметры
и получаться результаты в текстовом или двоичном формате. Не осталось повода считать сообще-
ние FunctionCall потенциально небезопасным, так как оно не даёт прямого доступа к внутренней
презентации данных на сервере.
Сервер отправляет сообщения ParameterStatus (‘S’) при попытке подключения для всех парамет-
ров, которые он считает интересными для клиентской библиотеки. Как следствие, при любом изме-
нении активного значения одного из этих параметров также выдаётся сообщение ParameterStatus.
Сообщение RowDescription (‘T’) содержит поля с OID таблицы и номером столбца для каждого
столбца описываемой строки. В нём также передаётся код формата для каждого столбца.
Сервер более не выдаёт сообщение CursorResponse (‘P’).
В сообщении NotificationResponse (‘A’) добавилось ещё одно строковое поле, в котором может пе-
редаваться строка «сообщения» от отправителя события NOTIFY.
Раньше сообщение EmptyQueryResponse (‘I’) включало пустой строковый параметр; теперь он лик-
видирован.
2069</li>
</ol>

      <footer class="entry-meta">
        <span>Updated on <span class="entry-date date published updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-053/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-053/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-053/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>
