<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Глава 68. Физическое хранение базы данных &#8211; Sirius Blog</title>
<meta name="description" content="">
<meta name="keywords" content="PostgreSQL">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-11.jpg">

<meta name="twitter:title" content="Глава 68. Физическое хранение базы данных">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Глава 68. Физическое хранение базы данных">
<meta property="og:description" content="">
<meta property="og:url" content="http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-068/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-068/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="page" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->



<div class="entry-header">
  
  <div class="entry-image">
    <img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 68. Физическое хранение базы данных">
  </div><!-- /.entry-image -->
</div><!-- /.entry-header -->


<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        <h1 class="entry-title">Глава 68. Физическое хранение базы данных</h1>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~22 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Глава 68. Физическое хранение базы данных</p>

<p>В данной главе рассматривается формат физического хранения, используемый базами данных
PostgreSQL.</p>

<p>68.1. Размещение файлов базы данных</p>

<p>Этот раздел описывает формат хранения на уровне файлов и каталогов.
Файлы конфигурации и файлы данных, используемые кластером базы данных, традиционно хра-
нятся вместе в каталоге данных кластера, который обычно называют PGDATA (по имени перемен-
ной среды, которую можно использовать для его определения). Обычно PGDATA находится в /var/
lib/pgsql/data. На одной и той же машине может находиться множество кластеров, управляемых
различными экземплярами сервера.
В каталоге PGDATA содержится несколько подкаталогов и управляющих файлов, как показано в
Таблице 68.1. В дополнение к этим обязательным элементам конфигурационные файлы кластера
postgresql.conf, pg_hba.conf и pg_ident.conf традиционно хранятся в PGDATA, хотя их можно
разместить и в другом месте.
Таблица 68.1. Содержание PGDATA
Элемент Описание
PG_VERSION Файл, содержащий
PostgreSQL
base Подкаталог, содержащий подкаталоги для каж-
дой базы данных
current_logfiles Файл, в котором отмечается, в какие файлы жур-
налов производит запись сборщик сообщений
global Подкаталог, содержащий общие таблицы кла-
стера, такие как pg_database
pg_commit_ts Подкаталог, содержащий данные о времени
фиксации транзакций
pg_dynshmem Подкаталог, содержащий файлы, используемые
подсистемой динамически разделяемой памяти
pg_logical Подкаталог, содержащий данные о состоянии
для логического декодирования
pg_multixact Подкаталог, содержащий данные о состоянии
мультитранзакций (используемые для разделяе-
мой блокировки строк)
pg_notify Подкаталог,
содержащий
данные
состоя-
ния прослушивания и нотификации (LISTEN/
NOTIFY)
pg_replslot Подкаталог, содержащий данные слота репли-
кации
pg_serial Подкаталог, содержащий информацию о выпол-
ненных сериализуемых транзакциях.
pg_snapshots Подкаталог, содержащий
снимки (snapshots)
pg_stat Подкаталог, содержащий постоянные файлы
для подсистемы статистики.
2171
номер
основной
версии
экспортированныеФизическое хранение базы данных
Элемент Описание
pg_stat_tmp Подкаталог, содержащий временные файлы для
подсистемы статистики
pg_subtrans Подкаталог, содержащий данные о состоянии
подтранзакций
pg_tblspc Подкаталог, содержащий символические ссыл-
ки на табличные пространства
pg_twophase Подкаталог, содержащий файлы состояний для
подготовленных транзакций
pg_wal Подкаталог, содержащий файлы WAL (журнал
предзаписи)
pg_xact Подкаталог, содержащий данные о состоянии
транзакции
postgresql.auto.conf Файл, используемый для хранения параметров
конфигурации, которые устанавливаются при
помощи ALTER SYSTEM
postmaster.opts Файл, содержащий параметры командной стро-
ки, с которыми сервер был запущен в последний
раз
postmaster.pid Файл блокировки, содержащий идентификатор (
ID) текущего управляющего процесса (PID), путь
к каталогу данных кластера, временную мет-
ку запуска управляющего процесса, номер пор-
та, путь к каталогу Unix-сокета (пустой для
Windows), первый корректный адрес прослуши-
вания (listen_address) (IP-адрес или *, либо пу-
стое значение в случае отсутствия прослушива-
ния по TCP), и ID сегмента разделяемой памяти (
этот файл отсутствует после остановки сервера).
Для каждой базы данных в кластере существует подкаталог внутри PGDATA/base, названный по
OID базы данных в pg_database. Этот подкаталог по умолчанию является местом хранения файлов
базы данных; в частности, там хранятся её системные каталоги.
Каждая таблица и индекс хранятся в отдельном файле. Для обычных отношений, эти фай-
лы получают имя по номеру файлового узла таблицы или индекса, который содержится в
pg_class.relfilenode. Но для временных отношений, имя файла имеет форму tBBB_FFF, где BBB</p>
<ul>
  <li>идентификатор серверного процесса сервера, который создал данный файл, а FFF — номер фай-
лового узла. В обоих случаях, помимо главного файла (также называемого основным слоем), у
каждой таблицы и индекса есть карта свободного пространства (см. Раздел 68.3), в которой хра-
нится информация о свободном пространстве в данном отношении. Имя файла карты свободного
пространства образуется из номера файлового узла с суффиксом _fsm. Также таблицы имеют кар-
ту видимости, хранящуюся в слое с суффиксом _vm, для отслеживания страниц, не содержащих
мёртвых записей. Карта видимости подробнее описана в Разделе 68.4. Нежурналируемые табли-
цы и индексы имеют третий слой, так называемый слой инициализации, имя которого содержит
суффикс _init (см. Раздел 68.5).
Внимание
Заметьте, что хотя номер файла таблицы часто совпадает с её OID, так бывает не всегда;
некоторые операции, например, TRUNCATE, REINDEX, CLUSTER и некоторые формы коман-
ды ALTER TABLE могут изменить номер файла, но при этом сохранят OID. Не следует рас-
считывать, что номер файлового узла и OID таблицы совпадают. Кроме того, для неко-
торых системных каталогов, включая и pg_class, в pg_class.relfilenode содержится
2172Физическое хранение базы данных
ноль. Фактический номер файлового узла для них хранится в низкоуровневой структу-
ре данных, и его можно получить при помощи функции pg_relation_filenode().
Когда объём таблицы или индекса превышает 1 GB, они делятся на сегменты размером в один
гигабайт. Файл первого сегмента называется по номеру файлового узла (filenode); последующие
сегменты получают имена filenode.1, filenode.2 и т. д. При такой организации хранения не возни-
кает проблем на платформах, имеющих ограничения по размеру файлов. (На самом деле, 1 ГБ —
лишь размер по умолчанию. Размер сегмента можно изменить при сборке PostgreSQL, используя
параметр конфигурации –with-segsize.) В принципе, карты свободного пространства и карты
видимости также могут занимать нескольких сегментов, хотя на практике это маловероятно.
У таблицы, столбцы которой могут содержать данные большого объёма, будет иметься собствен-
ная таблица TOAST, предназначенная для отдельного хранения значений, которые слишком вели-
ки для хранения в строках самой таблицы. Основная таблица связывается с её таблицей TOAST
(если таковая имеется) через pg_class.reltoastrelid. За подробной информацией обратитесь к
Разделу 68.2.
Содержание таблиц и индексов рассматривается ниже (см. Раздел 68.6).
Табличное пространство делает сценарий более сложным. Каждое пользовательское табличное
пространство имеет символическую ссылку внутри каталога PGDATA/pg_tblspc, указывающую на
физический каталог табличного пространства (т. е., положение, указанное в команде таблично-
го пространства CREATE TABLESPACE). Эта символическая ссылка получает имя по OID таблич-
ного пространства. Внутри физического каталога табличного пространства имеется подкаталог,
имя которого зависит от версии сервера PostgreSQL, как например PG_9.0_201008051. (Этот под-
каталог используется для того, чтобы последующие версии базы данных могли свободно исполь-
зовать одно и то же местоположение, заданное в CREATE TABLESPACE.) Внутри каталога конкрет-
ной версии находится подкаталог для каждой базы данных, которая имеет элементы в табличном
пространстве, названный по OID базы данных. Таблицы и индексы хранятся внутри этого катало-
га, используя схему именования файловых узлов. Табличное пространство pg_default недоступно
через pg_tblspc, но соответствует PGDATA/base. Подобным же образом, табличное пространство
pg_global недоступно через pg_tblspc, но соответствует PGDATA/global.
Функция pg_relation_filepath() показывает полный путь (относительно PGDATA) для любого от-
ношения. Часто это избавляет от необходимости запоминать многие из приведённых выше правил.
Но следует помнить, что эта функция выдаёт лишь имя первого сегмента основного слоя отноше-
ния, т. е. возможно, понадобится добавить номер сегмента и/или _fsm, _vm или _init, чтобы найти
все файлы, связанные с отношением.
Временные файлы (для таких операций, как сортировка объёма данных большего, чем может уме-
ститься в памяти) создаются внутри PGDATA/base/pgsql_tmp или внутри подкаталога pgsql_tmp
каталога табличного пространства, если для них определено табличное пространство, отличное
от pg_default. Имя временного файла имеет форму pgsql_tmpPPP.NNN, где PPP — PID серверного
процесса, а NNN служит для разделения различных временных файлов этого серверного процесса.
68.2. TOAST
В данном разделе рассматривается TOAST (The Oversized-Attribute Storage Technique, Методика
хранения сверхбольших атрибутов).
PostgreSQL использует фиксированный размер страницы (обычно 8 КБ), и не позволяет кортежам
занимать несколько страниц. Поэтому непосредственно хранить очень большие значения полей
невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или раз-
биваются на несколько физических строк. Это происходит незаметно для пользователя и на боль-
шую часть кода сервера влияет незначительно. Этот метод известен как TOAST (тост, или «лучшее
после изобретения нарезанного хлеба»). Инфраструктура TOAST также применяется для оптими-
зации обработки больших значений данных в памяти.
2173Физическое хранение базы данных
Лишь определённые типы данных поддерживают TOAST — нет смысла производить дополнитель-
ные действия с типами данных, размер которых не может быть большим. Чтобы поддерживать
TOAST, тип данных должен представлять значение переменной длины (varlena), в котором первое
четырёхбайтовое слово любого хранящегося значения содержит общую длину значения в байтах
(включая само это слово). Содержание оставшейся части значения TOAST не ограничивает. Спе-
циальные представления, в целом называемые значениями в формате TOAST, работают, манипу-
лируя этим начальным словом длины и интерпретируя его по-своему. Таким образом, функции
уровня C, работающие с типом данных, поддерживающим TOAST, должны аккуратно обращаться
со входными значениями, которые могут быть в формате TOAST: входные данные могут и не содер-
жать четырёхбайтовое слово длины и содержимое после него, пока не будут распакованы. (Обыч-
но в таких ситуациях нужно использовать макрос PG_DETOAST_DATUM прежде чем что-либо делать с
входным значением, но в некоторых случаях возможны и более эффективные подходы. За подроб-
ностями обратитесь к Подразделу 38.12.1.)
TOAST занимает два бита слова длины varlena (старшие биты на машинах с порядком байт от стар-
шего к младшему, или младшие биты — при другом порядке байт), таким образом, логический раз-
30
мер любого значения в формате TOAST ограничивается 1 Гигабайтом (2 - 1 байт). Когда оба бита
равны нулю, значение является обычным, не в формате TOAST, и оставшиеся биты слова длины
задают общий размер элемента данных (включая слово длины) в байтах. Когда установлен стар-
ший (или младший, в зависимости от архитектуры) бит, значение имеет однобайтовый заголовок
вместо обычного четырёхбайтового, а оставшиеся биты этого байта задают общий размер элемен-
та данных (включая байт длины) в байтах. Этот вариант позволяет экономно хранить значения
короче 127 байт и при этом допускает расширение значения этого типа данных до 1 Гбайта при
необходимости. Значения с однобайтовыми заголовками не выравниваются по какой-либо опреде-
лённой границе, тогда как значения с четырёхбайтовыми заголовками выравниваются по границе
минимум четырёх байт; это избавление от выравнивания даёт дополнительный выигрыш в объёме,
очень ощутимый для коротких значений. В качестве особого случая, если все оставшиеся биты
однобайтового заголовка равны нулю (что в принципе невозможно с учётом включения размера
длины), значением является указатель на отдельно размещённые данные, с несколькими возмож-
ными вариантами, описанными ниже. Тип и размер такого указателя TOAST определяется кодом,
хранящимся во втором байте значения. Наконец, когда старший (или младший, в зависимости от
архитектуры) бит очищен, а соседний бит установлен, содержимое данных хранится в упакован-
ном виде и должно быть распаковано перед использованием. В этом случае оставшиеся биты че-
тырёхбайтового слова длины задают общий размер сжатых, а не исходных данных. Заметьте, что
сжатие также возможно и для отделённых данных, но заголовок varlena не говорит, имеет ли оно
место — это определяется содержимым, на которое указывает указатель TOAST.
Как уже было сказано, существуют разные варианты использования указателя TOAST. Самый ста-
рый и наиболее популярный вариант — когда он указывает на отделённые данные, размещённые
в таблице TOAST, которая отделена, но связана с таблицей, содержащей собственно указатель
данных TOAST. Такой указатель на данные на диске создаётся кодом обработки TOAST (в access/
heap/tuptoaster.c), когда кортеж, сохраняемый на диск, оказывается слишком большим. Допол-
нительные подробности описаны в Подразделе  68.2.1. Кроме того, указатель TOAST может ука-
зывать на отделённые данные, размещённые где-то в памяти. Такие данные обязательно недолго-
временные и никогда не оказываются на диске, но этот механизм очень полезен для исключения
копирования и избыточной обработки данные большого размера. Дополнительные подробности
описаны в Подразделе 68.2.2.
В качестве метода сжатия внутренних и отделённых данных применяется довольно про-
стой и очень быстрый представитель семейства алгоритмов LZ. Подробнее см. src/common/
pg_lzcompress.c.
68.2.1. Отдельное размещение TOAST на диске
Если какие-либо столбцы таблицы хранятся в формате TOAST, у таблицы будет связанная с ней
таблица TOAST, OID которой хранится в значении pg_class.reltoastrelid для данной таблицы.
Размещаемые на диске TOAST-значения содержатся в таблице TOAST, что подробнее описано ни-
же.
2174Физическое хранение базы данных
Отделённые значения делятся на порции (после сжатия, если оно применяется) размером не бо-
лее TOAST_MAX_CHUNK_SIZE байт (по умолчанию это значение выбирается таким образом, чтобы
на странице помещались четыре строки порций, то есть размер одной составляет порядка 2000
байт). Каждая порция хранится как отдельная строка в таблице TOAST, принадлежащей исход-
ной таблице-владельцу. Каждая таблица TOAST имеет столбцы chunk_id (OID, идентифицирующий
конкретное TOAST-значение), chunk_seq (последовательный номер для порции внутри значения)
и chunk_data (фактические данные порции). Уникальный индекс по chunk_id и chunk_seq обеспе-
чивает быструю выдачу значений. Таким образом, в указателе, представляющем отдельно разме-
щаемое на диске значение TOAST, должно храниться OID таблицы TOAST, к которой нужно обра-
щаться, и OID определённого значения (его chunk_id). Для удобства в данных указателя также
хранится логический размер элемента данных (исходных данных без сжатия) и фактический раз-
мер хранимых данных (отличающийся, если было применено сжатие). Учитывая байты заголовка
varlena, общий размер указателя на хранимое на диске значение TOAST составляет 18 байт, неза-
висимо от фактического размера собственно значения.
Код обработки TOAST срабатывает, только когда значение строки, которое должно храниться в
таблице, по размеру больше, чем TOAST_TUPLE_THRESHOLD байт (обычно это 2 Кб). Код TOAST бу-
дет сжимать и/или выносить значения поля за пределы таблицы до тех пор, пока значение стро-
ки не станет меньше TOAST_TUPLE_TARGET байт (переменная величина, так же обычно 2 Кб) или
уменьшить объём станет невозможно. Во время операции UPDATE значения неизменённых полей
обычно сохраняются как есть, поэтому модификация строки с отдельно хранимыми значениями
не несёт издержек, связанных с TOAST, если все такие значения остаются без изменений.
Код обработки TOAST распознаёт четыре различные стратегии хранения столбцов, совместимых
с TOAST, на диске:
• PLAIN не допускает ни сжатие, ни отдельное хранение; кроме того, отключается использова-
ние однобайтовых заголовков для типов varlena. Это единственно возможная стратегия для
столбцов типов данных, которые несовместимы с TOAST.
• EXTENDED допускает как сжатие, так и отдельное хранение. Это стандартный вариант для
большинства типов данных, совместимых с TOAST. Сначала происходит попытка выполнить
сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.
• EXTERNAL допускает отдельное хранение, но не сжатие. Использование EXTERNAL ускорит опе-
рации над частями строк в больших столбцах text и bytea (ценой увеличения объёма памяти
для хранения), так как эти операции оптимизированы для извлечения только требуемых ча-
стей отделённого значения, когда оно не сжато.
• MAIN допускает сжатие, но не отдельное хранение. (Фактически, отдельное хранение, тем не
менее, будет выполнено для таких столбцов, но лишь как крайняя мера, когда нет другого
способа уменьшить строку так, чтобы она помещалась на странице.)
Каждый тип данных, совместимый с TOAST, определяет стандартную стратегию для столбцов этого
типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью ALTER
TABLE … SET STORAGE.
TOAST_TUPLE_TARGET можно задавать на уровне таблиц с помощью команды ALTER TABLE … SET
(toast_tuple_target = N)
Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк
могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются вы-
полнением сравнения с относительно маленькими значениями ключа, большая часть работы бу-
дет выполняться с использованием главной записи строки. Большие значения атрибутов в форма-
те TOAST будут просто передаваться (если будут выбраны) в тот момент, когда результирующий
набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в об-
щий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хра-
нения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполнять-
ся исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-
страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая
таблицу TOAST, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые
2175Физическое хранение базы данных
маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обра-
ботки таблицы без использования TOAST, в которой размер всех HTML-страниц был уменьшен до
7 Кб, чтобы они уместились в строках.
68.2.2. Отдельное размещение TOAST в памяти
Указатели TOAST могут указывать на данные, размещённые не на диске, а где-либо в памяти те-
кущего серверного процесса. Очевидно, что такие указатель не могут быть долговременными, но
они, тем не менее, полезны. В настоящее время поддерживаются два подварианта: косвенные ука-
затели на данные и указатели на развёрнутые данные.
Косвенный указатель TOAST просто указывает на значение varlena, хранящееся где-то в памяти.
Этот вариант изначально был реализован просто как подтверждение концепции, но в настоящее
время он применяется при логическом декодировании, чтобы не приходилось создавать физиче-
ские кортежи больше одного 1 ГБ (что может потребоваться при консолидации всех отделённых
значений полей в одном кортеже). Данный вариант имеет ограниченное применение, так как со-
здатель такого указателя должен полностью понимать, что целевые данные будут существовать,
только пока существует указатель, и никакой инфраструктуры для сохранения их нет.
Указатели на развёрнутые данные TOAST полезны для сложных типов, представление которых на
диске плохо приспособлено для вычислительных целей. Например, стандартное представление в
виде varlena массива PostgreSQL включает информацию о размерности, битовую карту элементов
NULL (если они в нём содержатся), а затем значения всех элементов по порядку. Когда элемент
сам по себе имеет переменную длину, единственный способ найти N-ный элемент — просканиро-
вать все предыдущие элементы. Это представление компактно, и поэтому подходит для хранения
на диске, но для вычислительной обработки массива гораздо удобнее иметь «развёрнутое» или
«деконструированное» представление, в котором можно определить начальные адреса всех эле-
ментов. Механизм указателей TOAST способствует решению этой задачи, допуская передачу по
ссылке элемента Datum как указателя на стандартное значение varlena (представление на диске)
или указателя TOAST на развёрнутое представление где-то в памяти. Детали развёрнутого пред-
ставление определяются самим типом данных, хотя оно может иметь стандартный заголовок и удо-
влетворять другим требованиям API, описанным в src/include/utils/expandeddatum.h. Функции
уровня C, работающие с этим типом, могут реализовать поддержку любого из этих представлений.
Функции, не знающие о развёрнутом представлении, а просто применяющие PG_DETOAST_DATUM к
своим входным данным, будут автоматически получать традиционное представление varlena; так
что поддержка развёрнутого представления может вводиться постепенно, по одной функции.
Указатели TOAST на развёрнутые значения далее подразделяются на указатели для чтения/за-
писи и указатели только для чтения. Представление, на которое они указывают, в любом случае
одинаковое, но функции, получающей указатель для чтения/записи, разрешается модифицировать
целевые данные прямо на месте, тогда как функция, получающая указатель только для чтения, не
должна этого делать; если ей нужно получить изменённую версию значения, она должна сначала
сделать копию. Это отличие и связанные с ним соглашения позволяют избежать излишнего копи-
рования развёрнутых значений при выполнении запросов.
Для всех типов указателей TOAST на данные в памяти, код обработки TOAST гарантирует, что та-
кие данные не окажутся случайно сохранены на диске. Указатели TOAST в памяти автоматически
сворачиваются в обычные значения varlena перед сохранением — а затем могут преобразоваться
в указатели TOAST на диске, если без этого не смогут уместиться в содержащем их кортеже.
68.3. Карта свободного пространства
Каждое табличное и индексное отношение, за исключением хеш-индексов, имеет карту свободно-
го пространства (Free Space Map, FSM) для отслеживания доступного места. Она хранится рядом с
данными главного отношения в отдельном слое, имя которого образуется номером файлового узла
отношения с суффиксом _fsm. Например, если файловый узел отношения — 12345, FSM хранится
в файле с именем 12345_fsm в том же каталоге, что и основной файл отношения.
Карта свободного пространства представляет собой дерево страниц FSM. Страницы FSM нижнего
уровня хранят информацию о свободном пространстве, доступном на каждой странице таблицы
2176Физическое хранение базы данных
(или индекса), используя один байт для представления каждой такой страницы. Верхние уровни
агрегируют информацию нижних уровней.
Внутри каждой страницы FSM имеется двоичное дерево, хранящееся в массиве, где один байт
выделяется на каждый узел дерева. Каждый листовой узел представляет страницу таблицы или
страницу FSM нижнего уровня. В каждом узле выше листовых хранится наибольшее из значений
его узлов-потомков. Поэтому максимальное из значений листовых узлов хранится в корневом узле.
Более подробную информацию о структуре FSM и о том, как выполняется обновление и поиск, вы
найдёте в src/backend/storage/freespace/README. Модуль pg_freespacemap может быть исполь-
зован для просмотра информации, хранящейся в картах свободного пространства.
68.4. Карта видимости
Каждое отношение таблицы имеет карту видимости (Visibility Map, VM) для отслеживания стра-
ниц, содержащих только кортежи, которые видны всем активным транзакциям; в ней также отсле-
живается, какие страницы содержат только замороженные кортежи. Она хранится вместе с дан-
ными главного отношения в отдельном файле, имя которого образуется номером файлового узла
отношения с суффиксом _vm. Например, если файловый узел отношения — 12345, VM хранится в
файле 12345_vm, в том же самом каталоге, что и основной файл отношения. Заметьте, что индексы
не имеют VM.
Карта видимости хранит по два бита на страницу таблицы. Первый бит, если он установлен, пока-
зывает, что вся страница видна или, другими словами, не содержит кортежей, которые необходи-
мо очистить. Эта информация может также использоваться при сканировании только индекса для
поиска ответов только в данных индекса. Установленный второй бит показывает, что все кортежи
на этой странице заморожены. Это означает, что процесс очистки для предотвращения зацикли-
вания не должен больше посещать эту страницу.
Карта может отражать реальные данные с запаздыванием в том смысле, что мы уверены, что в
случаях, когда установлен бит, известно, что условие верно, но если бит не установлен, оно может
быть верным или неверным. Биты карты видимости устанавливаются только при очистке, а сбра-
сываются при любых операциях, изменяющих данные на странице.
Для изучения информации, хранящейся в карте видимости, можно воспользоваться модулем
pg_visibility.
68.5. Слой инициализации
Каждая нежурналируемая таблица, и каждый индекс такой таблицы имеет файл инициализации.
Файл инициализации представляет собой пустую таблицу или индекс соответствующего типа. Ко-
гда нежурналируемая таблица должна быть заново очищена по причине сбоя, файл инициализа-
ции копируется поверх главного файла, а все прочие файлы удаляются (при необходимости они
будут автоматически созданы заново).
68.6. Компоновка страницы базы данных
В данном разделе рассматривается формат страницы, используемый в таблицах и индексах
1
PostgreSQL. Последовательности и таблицы TOAST форматируются как обычные таблицы.
В дальнейшем подразумевается, что байт содержит 8 бит. В дополнение, термин элемент отно-
сится к индивидуальному значению данных, которое хранится на странице. В таблице элемент —
это строка; в индексе — элемент индекса.
Каждая таблица и индекс хранятся как массив страниц фиксированного размера (обычно 8 kB,
хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы
1
Фактически индексные методы доступа не нуждаются в этом формате страниц. Все существующие индексные методы в действительности используют этот
основной формат, но данные, хранящиеся в индексных метастраницах обычно не следуют правилам компоновки.
2177Физическое хранение базы данных
логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой стра-
нице. В индексах первая страница обычно резервируется как метастраница, хранящая контроль-
ную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода
доступа индекса.
Таблица 68.2 показывает общую компоновку страницы. Каждая страница имеет пять частей.
Таблица 68.2. Общая компоновка страницы
Элемент Описание
Данные заголовка страницы Длина — 24 байта. Содержит общую информа-
цию о странице, включая указатели свободного
пространства.
Данные идентификаторов элементов Массив пар (смещение, длина), указывающих на
фактические элементы. Для каждого элемента
выделяется 4 байта.
Свободное пространство Незанятое пространство. Новые указатели эле-
ментов размещаются с начала этой области, са-
ми новые элементы — с конца.
Элементы Сами элементы данных как таковые.
Специальное пространство Специфические данные метода доступа. Для
различных методов хранятся различные дан-
ные. Для обычных таблиц таких данных нет.
Первые 24 байта каждой страницы образуют заголовок страницы (PageHeaderData). Его формат
подробно описан в Таблице  68.3. В первом поле отслеживается самая последняя запись в WAL,
связанная с этой страницей. Второе поле содержит контрольную сумму страницы, если включён
режим data checksums. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следуют
три двухбайтовых целочисленных поля (pd_lower, pd_upper и pd_special). Они содержат смещения
в байтах от начала страницы до начала незанятого пространства, до конца незанятого простран-
ства и до начала специального пространства. В следующих 2 байтах заголовка страницы, в поле
pd_pagesize_version, хранится размер страницы и индикатор версии. Начиная с PostgreSQL 8.3,
используется версия 4; в PostgreSQL 8.1 и 8.2 использовалась версия 3; в PostgreSQL 8.0 — версия
2; в PostgreSQL 7.3 и 7.4 — версия 1; а в предыдущих выпусках — версия 0. (Основная структура
страницы и формат заголовка почти во всех этих версиях одни и те же, но структура заголовка
строк в куче изменялась.) Размер страницы присутствует, в основном, только для перекрёстной
проверки; возможность использовать в одной инсталляции разные размеры страниц не поддержи-
вается. Последнее поле подсказывает, насколько вероятна возможность получить выигрыш, про-
изведя очистку страницы: оно отслеживает самый старый XMAX на странице, не подвергавшийся
очистке.
Таблица 68.3. Данные заголовка страницы (PageHeaderData)
Поле Тип Длина Описание
pd_lsn PageXLogRecPtr 8 байт LSN: Следующий байт
после последнего байта
записи WAL для послед-
него изменения на этой
странице
pd_checksum uint16 2 байта Контрольная
страницы
pd_flags uint16 2 байта Биты признаков
pd_lower LocationIndex 2 байта Смещение до начала
свободного простран-
ства
2178
суммаФизическое хранение базы данных
Поле Тип Длина Описание
pd_upper LocationIndex 2 байта Смещение до конца сво-
бодного пространства
pd_special LocationIndex 2 байта Смещение до нача-
ла специального про-
странства
pd_pagesize_version uint16 2 байта Информация о размере
страницы и номере вер-
сии компоновки
pd_prune_xid TransactionId 4 байта Самый старый неочи-
щенный
идентифика-
тор XMAX на страни-
це или ноль при отсут-
ствии такового
Всю подробную информацию можно найти в src/include/storage/bufpage.h.
За заголовком страницы следуют идентификаторы элемента (ItemIdData), каждому из которых
требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его
длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые иден-
тификаторы элементов размещаются по мере необходимости от начала свободного пространства.
Количество имеющихся идентификаторов элементов можно определить через значение pd_lower,
которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор эле-
мента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно исполь-
зовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам эле-
мент перемещается по странице для уплотнения свободного пространства. Фактически каждый
указатель на элемент (ItemPointer, также известный как CTID), созданный PostgreSQL, состоит из
номера страницы и индекса идентификатора элемента.
Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу неза-
нятого пространства. Точная структура меняется в зависимости от того, каким будет содер-
жание таблицы. Как таблицы, так и последовательности используют структуру под названием
HeapTupleHeaderData, которая описывается ниже.
Последний раздел является «особым разделом», который может содержать всё, что необходимо
методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева
и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные
таблицы не используют особый раздел вовсе (что указывается установкой значения pd_special
равным размеру страницы).
68.6.1. Компоновка строки таблицы
Все строки таблицы структурированы одним и тем же образом. Они включают заголовок фиксиро-
ванного размера (занимающий 23 байта на большинстве машин), за которым следует необязатель-
ная битовая карта пустых значений, необязательное поле идентификатора объекта и данные поль-
зователя. Подробное описание заголовка представлено в Таблица 68.4. Актуальные пользователь-
ские данные (столбцы строки) начинаются после смещения, заданного в t_hoff, которое должно
всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений имеет-
ся тогда, когда бит HEAP_HASNULL установлен в значении t_infomask. В случае наличия, она на-
чинается сразу после фиксированного заголовка и занимает достаточно байтов, чтобы иметь один
бит на столбец (т. е. t_natts битов всего). В этом списке битов установленный в единицу бит озна-
чает непустое значение, а установленный в ноль соответствует пустому значению. Когда битовая
карта отсутствует, все столбцы считаются непустыми. Идентификатор объекта присутствует, если
только бит HEAP_HASOID установлен в значении t_infomask. Если он есть, он расположен сразу
перед началом t_hoff. Любое заполнение, необходимое для того, чтобы сделать t_hoff кратным
MAXALIGN, будет расположено между битовой картой пустых значений и идентификатором объ-
екта. (Это в свою очередь гарантирует, что идентификатор объекта будет правильно выровнен.)
2179Физическое хранение базы данных
Таблица 68.4. Данные заголовка строки таблицы (HeapTupleHeaderData)
Поле Тип Длина Описание
t_xmin TransactionId 4 байта значение XID вставки
t_xmax TransactionId 4 байта значение XID удаления
t_cid CommandId 4 байта значение CID для встав-
ки и/или удаления (пе-
ресекается с t_xvac)
t_xvac TransactionId 4 байта XID
для
операции
VACUUM, которая пе-
ремещает версию стро-
ки
t_ctid ItemPointerData 6 байт текущее значение TID
этой или более новой
версии строки
t_infomask2 uint16 2 байта количество атрибутов
плюс различные биты
флагов
t_infomask uint16 2 байта различные биты флагов
t_hoff uint8 1 байт отступ до пользователь-
ских данных
Всю подробную информацию можно найти в src/include/access/htup_details.h.
Интерпретация текущих данных может быть проведена с помощью информации, полученной из
других таблиц, в основном из pg_attribute. Ключевые значения, необходимые для определения
расположения полей attlen и attalign. Не существует способа непосредственного получения за-
данного атрибута кроме случая, когда имеются только поля фиксированной длины, и при этом
нет пустых значений. Все эти особенности учитываются в функциях heap_getattr, fastgetattr и
heap_getsysattr.
Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь
нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений.
Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание
является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это
поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной дли-
ной имеют общую структуру заголовка struct varlena, которая включает общую длину сохранён-
ного значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут
храниться либо локально, либо в таблице TOAST. Также, возможно сжатие данных (см. Раздел 68.2).
2180</li>
</ul>

      <footer class="entry-meta">
        <span>Updated on <span class="entry-date date published updated"><time datetime="2018-12-03 T15:14:43-04:00">December 03, 2018</time></span></span>
        <span class="author vcard"><span class="fn">Sergey Khatsiola</span></span>
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-068/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-068/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/postgres/2018-12-01-PostgreSQL-V11_Doc-068/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>
