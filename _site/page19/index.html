<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page19/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page19/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="http://localhost:4000/postgres/" >PostgreSQL_11</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-023/" title="Глава 23. Локализация"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 23. Локализация"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-023/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~26 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-023/" rel="bookmark" title="Глава 23. Локализация" itemprop="url">Глава 23. Локализация</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 23. Локализация</p>

<p>Данная глава описывает доступные возможности локализации с точки зрения администратора.
PostgreSQL поддерживает два средства локализации:
• Использование средств локализации операционной системы для обеспечения определяемых
локалью порядка правил сортировки, форматирования чисел, перевода сообщений и прочих
аспектов. Это рассматривается в Разделе 23.1 и Разделе 23.2.
• Обеспечение возможностей использования различных кодировок для хранения текста на раз-
ных языках и перевода кодировок между клиентом и сервером. Это рассматривается в Разде-
ле 23.3.
23.1. Поддержка языковых стандартов
Поддержка языковых стандартов в приложениях относится к культурным предпочтениям, кото-
рые касаются алфавита, порядка сортировки, форматирования чисел и т. п. PostgreSQL использует
соответствующие стандартам ISO C и POSIX возможности локали, предоставляемые операционной
системой сервера. За дополнительной информацией обращайтесь к документации вашей системы.
23.1.1. Обзор
Поддержка локали автоматически инициализируется, когда кластер базы данных создаётся при
помощи initdb. initdb инициализирует кластер баз данных по умолчанию с локалью из окруже-
ния выполнения. Поэтому, если ваша система уже использует локаль, которую вы хотите выбрать
для вашего кластера баз данных, вам не требуется дополнительно совершать никаких действий.
Если вы хотите использовать другую локаль (или вы точно не знаете, какая локаль используется в
вашей системе), вы можете указать для initdb какую именно локаль использовать через задание
параметра –locale. Например:
initdb –locale=ru_RU
Данный пример для Unix-систем задаёт русский язык (ru), на котором говорят в России (RU).
Другими вариантами могут быть en_US (американский английский) и fr_CA (канадский француз-
ский). Если в языковом окружении может использоваться более одного набора символов, значение
может принимать вид language_territory.codeset. Например, fr_BE.UTF-8 обозначает француз-
ский язык (fr), на котором говорят в Бельгии (BE), с кодировкой UTF-8.
То, какие локали и под какими именами доступны на вашей системе, зависит от того, что было
включено в операционную систему производителем и что из этого было установлено. В большин-
стве Unix-систем команда locale -a выведет список доступных локалей. Windows использует бо-
лее развёрнутые имена локалей, такие как German_Germany или Russian_Russia.1251, но принци-
пы остаются теми же.
Иногда целесообразно объединить правила из различных локалей, например, использовать ан-
глийские правила сравнения и испанские сообщения. Для этой цели существует набор категорий
локали, каждая из которых управляет только определёнными аспектами правил локализации:
LC_COLLATE Порядок сортировки строк
LC_CTYPE Классификация символов (Что представляет со-
бой буква? Каков её эквивалент в верхнем реги-
стре?)
LC_MESSAGES Язык сообщений
LC_MONETARY Форматирование валютных сумм
LC_NUMERIC Форматирование чисел
LC_TIME Форматирование даты и времени
Эти имена категорий initdb принимает в качестве имён соответствующих параметров, позволяю-
щих переопределить выбор локали в определённой категории. Например, чтобы настроить локаль
604Локализация
на канадский французский, но при этом использовать американские правила форматирования де-
нежных сумм, используйте initdb –locale=fr_CA –lc-monetary=en_US.
Если вы хотите, чтобы система работала без языковой поддержки, используйте специальное имя
локали C либо эквивалентное ему POSIX.
Значения некоторых категорий локали должны быть заданы при создании базы данных. Вы може-
те использовать различные параметры локали для различных баз данных, но после создания базы
вы уже не сможете изменить их для этой базы данных. LC_COLLATE и LC_CTYPE являются этими
категориями. Они влияют на порядок сортировки в индексах, поэтому они должны быть зафикси-
рованы, иначе индексы на текстовых столбцах могут повредиться. (Однако, можно смягчить эти
ограничения через задание правил сравнения, как это описано в разделе Раздел 23.2.) Значения
по умолчанию для этих категорий определяются при запуске initdb, и эти значения используются
при создании новых баз данных, если другие значения не указаны явно в команде CREATE DATABASE.
Прочие категории локали вы можете изменить в любое время, настроив параметры конфигу-
рации сервера, которые имеют такое же имя как и категории локали (подробнее см. Подраз-
дел 19.11.2). Значения, выбранные через initdb, фактически записываются лишь в файл конфи-
гурации postgresql.conf, чтобы использоваться по умолчанию при запуске сервера. Если вы уда-
лите эти значения из postgresql.conf, сервер получит соответствующие значения из своей среды
выполнения.
Обратите внимание на то, что поведение локали сервера определяется переменными среды, уста-
новленными на стороне сервера, а не средой клиента. Таким образом, необходимо правильно скон-
фигурировать локаль перед запуском сервера. Если же клиент и сервер работают с разными ло-
калями, то сообщения, возможно, будут появляться на разных языках в зависимости от того, где
они возникают.
Примечание
Когда мы говорим о наследовании локали от среды выполнения, это означает следу-
ющее для большинства операционных систем: для определённой категории локали, к
примеру, для правил сортировки, следующие переменные среды анализируются в при-
ведённом ниже порядке до тех пор, пока одна из них не окажется заданной: LC_ALL,
LC_COLLATE (или переменная, относящаяся к соответствующей категории), LANG. Если
ни одна их этих переменных среды не задана, значение локали устанавливается по
умолчанию в C.
Некоторые библиотеки локализации сообщений также обращаются к переменной сре-
ды LANGUAGE, которая заменяет все прочие параметры локализации при выборе языка
сообщений. В случае затруднений, пожалуйста, воспользуйтесь документацией по ва-
шей операционной системе, в частности, справкой по gettext.
Для того чтобы стал возможен перевод сообщений на язык, выбранный пользователем, NLS дол-
жен быть выбран на момент сборки (configure –enable-nls). В остальном поддержка локализа-
ции осуществляется автоматически.
23.1.2. Поведение
Локаль влияет на следующий функционал SQL:
• Порядок сортировки в запросах с использованием ORDER BY или стандартных операторах срав-
нения текстовых данных
• Функции upper, lower, и initcap
• Операторы поиска по шаблону (LIKE, SIMILAR TO, и регулярные выражения в стиле POSIX);
локаль влияет как на поиск без учёта регистра, так и на классификацию знаков по классам
символов регулярных выражений
605Локализация
• семейство функций to_char
• Возможность использовать индексы с предложениями LIKE
Недостатком использования отличающихся от C или POSIX локалей в PostgreSQL является влияние
на производительность. Это замедляет обработку символов и мешает LIKE использовать обычные
индексы. По этой причине используйте локали только в том случае, если они действительно вам
нужны.
В качестве обходного решения, которое позволит PostgreSQL пользоваться индексами с предло-
жениями LIKE с использованием локали, отличной от С, существует несколько классов пользова-
тельских операторов. Они позволяют создать индекс, который выполняет строгое посимвольное
сравнение, игнорируя правила сравнения, соответствующие локали. За дополнительными сведе-
ниями обратитесь к Разделу 11.9. Ещё один подход заключается в создании индексов с помощью
правил сортировки C, как было сказано в Разделе 23.2.
23.1.3. Проблемы
Если поддержка локализации не работает в соответствии с объяснением, данным выше, проверь-
те, насколько корректна конфигурация поддержки локализации в вашей операционной системе.
Чтобы проверить, какие локали установлены на вашей системе, вы можете использовать команду
locale -a, если ваша операционная система поддерживает это.
Проверьте, действительно ли PostgreSQL использует локаль, которую вы подразумеваете. Пара-
метры LC_COLLATE и LC_CTYPE определяются при создании базы данных, и не могут быть изменены,
за исключением случаев, когда создаётся новая база данных. Прочие параметры локали, включая
LC_MESSAGES и LC_MONETARY первоначально определены средой, в которой запускается сервер, но
могут быть оперативно изменены. Вы можете проверить текущие параметры локали с помощью
команды SHOW.
Каталог src/test/locale в комплекте файлов исходного кода содержит набор тестов для поддерж-
ки локализации PostgreSQL.
Клиентские приложения, которые обрабатывают ошибки сервера, разбирая текст сообщения об
ошибке, очевидно, столкнутся с проблемами, когда сообщения сервера будут на другом языке.
Авторам таких приложений рекомендуется пользоваться системой кодов ошибок в качестве аль-
тернативы.
Для поддержки наборов переводов сообщений требуется постоянная работа большого числа во-
лонтёров, которые хотят, чтобы в PostgreSQL правильно использовался предпочитаемый ими язык.
Если в настоящее время сообщения на вашем языке недоступны или переведены не полностью,
будем благодарны вам за содействие. Если вы хотите помочь, обратитесь к Главе 55 или напишите
на адрес рассылки разработчиков.
23.2. Поддержка правил сортировки
Правила сортировки позволяют устанавливать порядок сортировки и особенности классификации
символов в отдельных столбцах или даже при выполнении отдельных операций. Это смягчает по-
следствия того, что параметры базы данных LC_COLLATE и LC_CTYPE невозможно изменить после
её создания.
23.2.1. Основные понятия
Концептуально, каждое выражение с типом данных, к которому применяется сортировка, имеет
правила сортировки. (Встроенными сортируемыми типами данных являются text, varchar, и char.
Типы, определяемые в базе пользователем, могут также быть отмечены как сортируемые, и, ко-
нечно, домен на основе сортируемого типа данных является сортируемым.) Если выражение со-
держит ссылку на столбец, правила сортировки выражения определяются правилами сортировки
столбца. Если выражение — константа, правилами сортировки являются стандартные правила для
типа данных константы. Правила сортировки более сложных выражений являются производной
от правил сортировки входящих в него частей, как описано ниже.
606Локализация
Правилами сортировки выражения могут быть правила сортировки «по умолчанию», что означает
использование параметров локали, установленных для базы данных. Также возможно, что прави-
ла сортировки выражения могут не определиться. В таких случаях операции упорядочивания и
другие операции, для которых необходимы правила сортировки, завершатся с ошибкой.
Когда база данных должна выполнить упорядочивание или классификацию символов, она исполь-
зует правила сортировки выполняемого выражения. Это происходит, к примеру, с предложениями
ORDER BY и такими вызовами функций или операторов как &lt;. Правила сортировки, которые при-
меняются в предложении ORDER BY, это просто правила ключа сортировки. Правила сортировки,
применяемые к вызову функции или оператора, определяются их параметрами, как описано ниже.
В дополнение к операциям сравнения, правила сортировки учитываются функциями, преобразу-
ющими регистр символов, такими как lower, upper, и initcap; операторами поиска по шаблону;
и функцией to_char и связанными с ней.
При вызове функции или оператора правило сортировки определяется в зависимости от того, ка-
кие правила заданы для аргументов во время выполнения данной операции. Если результатом
вызова функции или оператора является сортируемый тип данных, правила сортировки также ис-
пользуются во время разбора как определяемые правила сортировки функции или выражения опе-
ратора, в случае, если для внешнего выражения требуется знание правил сортировки.
Определение правил сортировки выражения может быть неявным или явным. Это отличие влия-
ет на то, как комбинируются правила сортировки, когда несколько разных правил появляются в
выражении. Явное определение правил сортировки возникает, когда используется предложение
COLLATE; все прочие варианты являются неявными. Когда необходимо объединить несколько пра-
вил сортировки, например, в вызове функции, используются следующие правила:</p>
<ol>
  <li>Если для одного из выражений-аргументов правило сортировки определено явно, то и для других
аргументов явно задаваемое правило должно быть тем же, иначе возникнет ошибка. В случае
присутствия явного определения правила сортировки, оно становится результирующим для всей
операции.</li>
  <li>В противном случае все входные выражения должны иметь одни и те же неявно определяемые
правила сортировки или правила сортировки по умолчанию. Если присутствуют какие- либо пра-
вила сортировки, отличные от заданных по умолчанию, получаем результат комбинации правил
сортировки. Иначе результатом станут правила сортировки, заданные по умолчанию.</li>
  <li>Если среди входных выражений есть конфликтующие неявные правила сортировки, отличные
от заданных по умолчанию, тогда комбинация рассматривается как имеющая неопределённые
правила сортировки. Это не является условием возникновения ошибки, если вызываемой кон-
кретной функции не требуются данные о правилах сортировки, которые ей следует применить.
Если же такие данные требуются, это приведёт к ошибке во время выполнения.
В качестве примера рассмотрим данное определение таблицы:
CREATE TABLE test1 (
a text COLLATE “de_DE”,
b text COLLATE “es_ES”,
…
);
Затем в
SELECT a &lt; ‘foo’ FROM test1;
выполняется оператор сравнения &lt; согласно правилам de_DE, так как выражение объединяет неяв-
но определяемые правила сортировки с правилами, заданными по умолчанию. Но в
SELECT a &lt; (‘foo’ COLLATE “fr_FR”) FROM test1;
сравнение выполняется с помощью правил fr_FR, так как явное определение правил сортировки
переопределяет неявное. Кроме того, получив
SELECT a &lt; b FROM test1;
, анализатор запросов не может определить, какое правило сортировки использовать, поскольку
столбцы a и b имеют конфликтующие неявные правила сортировки. Так как оператору &lt; требуется
607Локализация
знать, какое правило использовать, это приведёт к ошибке. Ошибку можно устранить, применив
явное указание правил сортировки к любому из двух входных выражений. Например:
SELECT a &lt; b COLLATE “de_DE” FROM test1;
либо эквивалентное ему
SELECT a COLLATE “de_DE” &lt; b FROM test1;
С другой стороны, следующее выражение схожей структуры
SELECT a || b FROM test1;
не приводит к ошибке, поскольку для оператора || правила сортировки не имеют значения, так
как результат не зависит от сортировки.
Правила сортировки, назначенные функции или комбинации входных выражений оператора,
также могут быть применены к функции или результату оператора, если функция или оператор
возвращают результат сортируемого типа данных. Так, в
SELECT * FROM test1 ORDER BY a || ‘foo’;
упорядочение будет происходить согласно правилам de_DE. Но данный запрос:
SELECT * FROM test1 ORDER BY a || b;
приводит к ошибке, потому что, даже если оператору || не нужно знать правила сортировки, пред-
ложению ORDER BY это требуется. Как было сказано выше, конфликт может быть разрешён при
помощи явного указания правил сортировки:
SELECT * FROM test1 ORDER BY a || b COLLATE “fr_FR”;
23.2.2. Управление правилами сортировки
Правила сортировки представляют собой объект схемы SQL, который сопоставляет SQL-имя с ло-
калью, реализуемой библиотекой, установленной в операционной системе. В определении прави-
ла сортировки задаётся провайдер, то есть библиотека, реализующая правило сортировки. Стан-
дартный провайдер с именем libc использует системную библиотеку C и предоставляет её лока-
ли. Именно эти локали используются большинством утилит операционной системы. Также есть
провайдер icu, который использует внешнюю библиотеку ICU. Локали ICU можно использовать,
только если поддержка ICU была включена в конфигурации сборки PostgreSQL.
Правило сортировки, предоставляемое провайдером libc, сопоставляется с комбинацией пара-
метров LC_COLLATE и LC_CTYPE, которую может принять системный вызов setlocale(). (Основная
цель правила сортировки — настроить параметр LC_COLLATE, который управляет упорядочиванием
символов. Однако на практике редко требуется иметь значение LC_CTYPE, отличное от LC_COLLATE,
поэтому удобнее объединить их в одну сущность, и не создавать отдельную инфраструктуру для
указания LC_CTYPE в выражениях.) Правила сортировки libc также связаны с кодировкой набора
символов (см. Раздел 23.3). Одно и то же имя правила сортировки может существовать для разных
кодировок.
Объект правила сортировки, предоставляемой провайдером icu, сопоставляется с именованным
сортировщиком, реализуемым библиотекой ICU. ICU не поддерживает различные характеристики
«collate» и «ctype», так что они всегда совпадают. Кроме того, правила сортировки ICU не зависят
от кодировки, так что в базе данных будет всего одно правило сортировки ICU с определённым
именем.
23.2.2.1. Стандартные правила сортировки
На всех платформах доступны правила сортировки под названием default, C, и POSIX. Дополни-
тельные правила сортировки могут быть доступны в зависимости от поддержки операционной си-
стемы. Правило сортировки default использует значения LC_COLLATE и LC_CTYPE, заданные при
создании базы данных. Правила сортировки C и POSIX определяют поведение, характерное для
«традиционного C », в котором только знаки кодировки ASCII от «A» до «Z» рассматриваются как
буквы, и сортировка осуществляется строго по символьному коду байтов.
608Локализация
Для кодировки UTF8 дополнительно поддерживается имя ucs_basic, определённое в стандарте
SQL. Это правило сортировки равнозначно правилу C и производит сортировку по кодам символов
Unicode.
23.2.2.2. Предопределённые правила сортировки
Если операционная система поддерживает использование нескольких локалей в одной программе
(newlocale и связанные функции) или включена поддержка ICU, то при инициализации кластера
баз данных программа initdb наполняет системный каталог pg_collation информацией обо всех
локалях, которые обнаруживает в этот момент в операционной системе.
Для просмотра всех имеющихся локалей выполните запрос SELECT * FROM pg_collation или ко-
манду \dOS+ в psql.
23.2.2.2.1. правила сортировки libc
Например, операционная система может предоставлять локаль с именем de_DE.utf8. При этом
программа initdb создаст правило сортировки с именем de_DE.utf8 для кодировки UTF8, в котором
LC_COLLATE и LC_CTYPE будут равны de_DE.utf8. Также будет создано правило сортировки с именем
без метки .utf8 в окончании. Таким образом, вы можете использовать это правило под именем
de_DE, которое будет компактнее и не будет зависеть от кодировки. Заметьте, что изначальный
набор имён правил сортировки, тем не менее, является зависящим от платформы.
Стандартный набор правил сортировки, предоставляемый провайдером libc, сопоставляется
непосредственно с локалями, установленными в операционной системе (их можно просмотреть с
помощью команды locale -a). В случаях, когда у правила сортировки libc должны быть различ-
ные значения LC_COLLATE и LC_CTYPE, или когда в операционную систему после инициализации
СУБД устанавливаются новые локали, создать новое правило сортировки можно с помощью ко-
манды CREATE COLLATION. Новые локали операционной системы можно также импортировать в
массовом порядке, воспользовавшись функцией pg_import_system_collations().
В любой базе данных имеют значение только те правила сортировки, которые используют коди-
ровку этой базы данных. Прочие записи в pg_collation игнорируются. Таким образом, усечённое
имя правил сортировки, такое как de_DE, может считаться уникальным внутри данной базы дан-
ных, даже если бы оно не было уникальным глобально. Использование усечённого имени сорти-
ровки рекомендуется, так как при переходе на другую кодировку базы данных придётся выполнить
на одно изменение меньше. Однако, следует помнить, что правила сортировки default, C и POSIX
можно использовать независимо от кодировки базы данных.
В PostgreSQL предполагается, что отдельные объекты правил сортировки несовместимы, даже ко-
гда они имеют идентичные свойства. Так, например,
SELECT a COLLATE “C” &lt; b COLLATE “POSIX” FROM test1;
выведет сообщение об ошибке, несмотря на то, что поведение правил сортировки C и POSIX иден-
тично. По этой причине смешивать усечённые и полные имена правил сортировки не рекоменду-
ется.
23.2.2.2.2. Правила сортировки ICU
С ICU не представляется разумным перечислять все возможные имена локалей. ICU использует
для локалей определённую схему именования, но имён локалей может быть гораздо больше, чем
собственно различных локалей. Программа initdb, используя API ICU, извлекает список различ-
ных локалей и наполняет начальный набор правил в базе данных. Правила сортировки провайдера
ICU создаются с именами, включающими метку языка в формате BCP 47 и указание расширения
«для частного использования» (-x-icu), для отличия от локалей libc.
Например, могут быть созданы такие правила сортировки:
de-x-icu
Немецкое правило сортировки, стандартный вариант
609Локализация
de-AT-x-icu
Немецкое правило сортировки для Австрии, стандартный вариант
(Например, существуют правила de-DE-x-icu и de-CH-x-icu, но на момент написания докумен-
тации они равнозначны правилу de-x-icu.)
und-x-icu («undefined», неопределённая)
«Корневое» правило сортировки ICU. Оно устанавливает разумный языконезависимый порядок
сортировки.
Некоторые (редко используемые) кодировки не поддерживаются ICU. Когда база имеет одну из
таких кодировок, записи правил сортировки ICU в pg_collation игнорируются. При попытке ис-
пользовать их будет выдана ошибка с сообщением вида «правило сортировки “de-x-icu” для коди-
ровки “WIN874” не существует».
23.2.2.3. Создание новых правил сортировки
Если стандартных и предопределённых правил сортировки недостаточно, пользователи могут со-
здавать собственные правила сортировки, используя команду SQL CREATE COLLATION.
Стандартные и предопределённые правила сортировки находятся в схеме pg_catalog, как и все
предопределённые объекты. Пользовательские правила сортировки должны создаваться в пользо-
вательских схемах. Помимо прочего, это полезно тем, что их будет выгружать pg_dump.
23.2.2.3.1. правила сортировки libc
Новые правила сортировки libc могут создаваться так:
CREATE COLLATION german (provider = libc, locale = ‘de_DE’);
Точные значения, которые могут допускаться в предложении locale в этой команде, зависят от
операционной системы. В Unix-подобных системах их список выдаёт команда locale -a.
Так как предопределённый набор правил сортировки libc уже включает все правила сортировки,
определённые в операционной системе в момент инициализации базы данных, необходимость со-
здавать новые правила вручную обычно не возникает. Такая потребность может возникнуть, когда
нужно сменить систему именования (в этом случае см. Подраздел 23.2.2.3.3) либо когда операци-
онная система была обновлена и в ней появились новые определения локалей (в этом случае см.
pg_import_system_collations()).
23.2.2.3.2. Правила сортировки ICU
ICU допускает видоизменения правил сортировки, не ограничивая пользователей наборами язык
+страна, которые подготавливает initdb. Пользователи могут свободно создавать собственные
объекты-правила сортировки, использующие предоставляемые средства для получения требуе-
мых порядков сортировки. Информацию об именовании локалей ICU можно найти на странице
http://userguide.icu-project.org/locale и http://userguide.icu-project.org/collation/api. Набор допусти-
мых имён и атрибутов зависит от конкретной версии ICU.
Несколько примеров:
CREATE COLLATION “de-u-co-phonebk-x-icu” (provider = icu, locale = ‘de-u-co-phonebk’);
CREATE
COLLATION
“de-u-co-phonebk-x-icu”
(provider
=
icu,
locale
=
‘de@collation=phonebook’);
Немецкое правило сортировки с порядком, принятым для телефонной книги
В первом примере локаль ICU выбирается по «метке языка» в формате BCP 47. Во втором при-
мере используется традиционный принятый в ICU синтаксис имени. Первый вариант является
более предпочтительным в перспективе, но он не поддерживается старыми версиями ICU.
Заметьте, что объекты-правила сортировки в среде SQL вы можете называть как угодно. В этом
примере мы следуем стилю именования, который используется предопределёнными правила-
ми, которые в свою очередь следуют BCP 47, но это не требуется для правил сортировки, опре-
деляемых пользователем.
610Локализация
CREATE COLLATION “und-u-co-emoji-x-icu” (provider = icu, locale = ‘und-u-co-emoji’);
CREATE COLLATION “und-u-co-emoji-x-icu” (provider = icu, locale = ‘@collation=emoji’);
Корневое правило с сортировкой эмодзи, соответствующее техническому стандарту Unicode
No51
Заметьте, что в традиционной системе именования локалей ICU корневая локаль выбирается
пустой строкой.
CREATE COLLATION digitslast (provider = icu, locale = ‘en-u-kr-latn-digit’);
CREATE COLLATION digitslast (provider = icu, locale = ‘en@colReorder=latn-digit’);
Правило сортировки, с которым цифры идут после латинских букв. (По умолчанию цифры идут
перед буквами.)
CREATE COLLATION upperfirst (provider = icu, locale = ‘en-u-kf-upper’);
CREATE COLLATION upperfirst (provider = icu, locale = ‘en@colCaseFirst=upper’);
Правило сортировки, с которым буквы в верхнем регистре идут перед буквами в нижнем. (По
умолчанию сначала идут буквы в нижнем регистре.)
CREATE COLLATION special (provider = icu, locale = ‘en-u-kf-upper-kr-latn-digit’);
CREATE
COLLATION
special
(provider
=
icu,
locale
‘en@colCaseFirst=upper;colReorder=latn-digit’);
=
Правило, в котором сочетаются предыдущие свойства.
CREATE COLLATION numeric (provider = icu, locale = ‘en-u-kn-true’);
CREATE COLLATION numeric (provider = icu, locale = ‘en@colNumeric=yes’);
Числовая сортировка, с которой последовательности чисел упорядочиваются по числовому зна-
чению, например: A-21 &lt; A-123 (также называется естественной сортировкой).
За подробностями обратитесь к описанию Технического стандарта Unicode No35 и BCP 47. Список
возможных типов сортировки (внутренняя метка co) можно найти в репозитории CLDR. Для ис-
следования свойств определённой локали может быть полезен ICU Locale Explorer (Обозреватель
локалей ICU). Для примеров с использованием внутренних меток k* требуется ICU как минимум
версии 54.
Заметьте, что хотя данная система позволяет создавать правила сортировки, которые «игнориру-
ют регистр» или «игнорируют ударения» и тому подобное (используя ключ ks), PostgreSQL в дан-
ный момент не позволяет применять такие правила сортировки действительно независящим от
регистра или ударения способом. Все строки, которые считаются равными согласно правилу сор-
тировки, но не равны побайтово, будут сортироваться по своим байтовым значениям.
Примечание
ICU по природе своей принимает в качестве имени локали практическую любую строку
и сопоставляет её с наиболее подходящей локалью, которую она может предоставить,
следуя процедуре выбора, описанной в её документации. Таким образом, если указание
правила сортировки будет составлено с использованием характеристик, которые дан-
ная инсталляция ICU на самом деле не поддерживает, непосредственно узнать об этом
нельзя. Поэтому, чтобы убедиться, что определения правил сортировки соответствует
требованиям, рекомендуется проверять поведение правил на уровне приложения.
23.2.2.3.3. Копирование правил сортировки
Команда CREATE COLLATION может также создать новое правило сортировки из существующего,
что может быть полезно для использования имён, независимых от операционных систем, создания
имён для совместимости или использования правил сортировки ICU под более понятными имена-
ми. Например:
CREATE COLLATION german FROM “de_DE”;
611Локализация
CREATE COLLATION french FROM “fr-x-icu”;
23.3. Поддержка кодировок
Поддержка кодировок в PostgreSQL позволяет хранить текст в различных кодировках, включая
однобайтовые кодировки, такие как входящие в семейство ISO 8859 и многобайтовые кодировки,
такие как EUC (Extended Unix Code), UTF-8 и внутренний код Mule. Все поддерживаемые кодиров-
ки могут прозрачно использоваться клиентами, но некоторые не поддерживаются сервером (в ка-
честве серверной кодировки). Кодировка по умолчанию выбирается при инициализации кластера
базы данных PostgreSQL при помощи initdb. Она может быть переопределена при создании базы
данных, что позволяет иметь несколько баз данных с разными кодировками.
Важным ограничением, однако, является то, что кодировка каждой базы данных должна быть сов-
местима с параметрами локали базы данных LC_CTYPE (классификация символов) и LC_COLLATE
(порядок сортировки строк). Для локали C или POSIX подойдёт любой набор символов, но для дру-
гих локалей, предоставляемых библиотекой libc, есть только один набор символов, который будет
работать правильно. (Однако в среде Windows кодировка UTF-8 может использоваться с любой ло-
калью.) Если у вас включена поддержка ICU, локали, предоставляемые библиотекой ICU, можно
использовать с большинством (но не всеми) кодировками на стороне сервера.
23.3.1. Поддерживаемые кодировки
Таблица 23.1 показывает кодировки, доступные для использования в PostgreSQL.
Таблица 23.1. Кодировки PostgreSQL
Имя Описание Язык
Поддержка ICU?
на сервере
BIG5 Big Five Традицион- Нет
ные
китай-
ские
иеро-
глифы
EUC_CN
Байтов
символ
Нет 1-2
Extended
Упрощённые Да
UNIX Code- китайские
CN
иероглифы Да 1-3
EUC_JP Extended
Японский
UNIX Code-
JP Да Да 1-3
EUC_JIS_
2004 Extended
Японский
UNIX Code-
JP, JIS X 0213 Да Нет 1-3
EUC_KR Extended
Корейский
UNIX Code-
KR Да Да 1-3
EUC_TW Extended
Традицион- Да
UNIX Code- ные
китай-
TW
ские
иеро-
глифы, тай-
ваньский Да 1-3
GB18030 Националь- Китайский
ный
стан-
дарт Нет Нет 1-4
GBK Расширен-
Упрощённые Нет
ный нацио- китайские
нальный
иероглифы
стандарт Нет 1-2
612
на Псевдони-
мы
WIN950,
Windows950
WIN936,
Windows936Локализация
Имя Описание
Язык
Поддержка ICU?
на сервере
ISO_8859_
5 ISO 8859-5, Латин-
Да
ECMA 113
ский/Кирил-
лица Да 1 ISO_8859_
6 ISO 8859-6, Латин-
ECMA 114
ский/Араб-
ский Да Да 1 ISO_8859_
7 ISO 8859-7, Латин-
ECMA 118
ский/Грече-
ский Да Да 1 ISO_8859_
8 ISO 8859-8, Латин-
ECMA 121
ский/Иврит Да Да 1 JOHAB JOHAB Корейский ( Нет
Хангыль) Нет 1-3 KOI8R KOI8-R Кириллица ( Да
Русский) Да 1 KOI8U KOI8-U Кириллица ( Да
Украинский) Да 1 LATIN1 ISO 8859-1, Западноев-
ECMA 94
ропейские Да Да 1 ISO88591
LATIN2 ISO 8859-2, Центрально- Да
ECMA 94
европейские Да 1 ISO88592
LATIN3 ISO 8859-3, Южноевро-
ECMA 94
пейские Да Да 1 ISO88593
LATIN4 ISO 8859-4, Североевро-
ECMA 94
пейские Да Да 1 ISO88594
LATIN5 ISO 8859-9, Турецкий
ECMA 128 Да Да 1 ISO88599
LATIN6 ISO 8859-10, Скандинав-
ECMA 144
ские Да Да 1 ISO885910
LATIN7 ISO 8859-13 Балтийские Да Да 1 ISO885913
LATIN8 ISO 8859-14 Кельтские Да Да 1 ISO885914
LATIN9 ISO 8859-15 LATIN1 c ев- Да
ропейскими
языками
и
диалектами Да 1 ISO885915
LATIN10 ISO 8859-16, Румынский
ASRO SR
14111 Да Нет 1 ISO885916
MULE_
INTERNAL Внутренний
код Mule Мультиязыч- Да
ный
редак-
тор Emacs Нет 1-4 SJIS Shift JIS Японский Нет Нет 1-2 SHIFT_JIS_
2004 Shift JIS, JIS X Японский
0213 Нет Нет 1-2
613
Байтов
символ
на Псевдони-
мы
KOI8
Mskanji,
ShiftJIS,
WIN932,
Windows932Локализация
Имя Описание
SQL_ASCII
Язык
Поддержка ICU?
на сервере Байтов
символ не указан ( any
см. текст) Да Нет 1 UHC Унифициро- Корейский
ванный код
Хангыль Нет Нет 1-2 WIN949,
Windows949
UTF8 Unicode,
bit Да Да 1-4 Unicode
WIN866 Windows
CP866 Кириллица Да Да 1 ALT
WIN874 Windows
CP874 Тайский Да Нет 1 WIN1250 Windows
CP1250 Центрально- Да
европейские Да 1 WIN1251 Windows
CP1251 Кириллица Да Да 1 WIN1252 Windows
CP1252 Западноев-
ропейские Да Да 1 WIN1253 Windows
CP1253 Греческий Да Да 1 WIN1254 Windows
CP1254 Турецкий Да Да 1 WIN1255 Windows
CP1255 Иврит Да Да 1 WIN1256 Windows
CP1256 Арабский Да Да 1 WIN1257 Windows
CP1257 Балтийские Да Да 1 WIN1258 Windows
CP1258 Вьетнамский Да Да 1
8- все
на Псевдони-
мы
WIN
ABC,
TCVN,
TCVN5712,
VSCII
Не все клиентские API поддерживают все перечисленные кодировки. Например, драйвер интер-
фейса JDBC PostgreSQL не поддерживает MULE_INTERNAL, LATIN6, LATIN8 и LATIN10.
Поведение кодировки SQL_ASCII существенно отличается от других. Когда набором символов сер-
вера является SQL_ASCII, сервер интерпретирует значения от 0 до 127 байт согласно кодировке
ASCII, тогда как значения от 128 до 255 воспринимаются как незначимые. Перекодировка не будет
выполнена при выборе SQL_ASCII. Таким образом, этот вариант является не столько объявлением
того, что используется определённая кодировка, сколько объявлением того, что кодировка игно-
рируется. В большинстве случаев, если вы работаете с любыми данными, отличными от ASCII, не
стоит использовать SQL_ASCII, так как PostgreSQL не сможет преобразовать или проверить симво-
лы, отличные от ASCII.
23.3.2. Настройка кодировки
initdb определяет кодировку по умолчанию для кластера PostgreSQL. Например,
initdb -E EUC_JP
настраивает кодировку по умолчанию на EUC_JP (Расширенная система кодирования для японско-
го языка). Можно использовать –encoding вместо -E в случае предпочтения более длинных имён
614Локализация
параметров. Если параметр -E или –encoding не задан, initdb пытается определить подходящую
кодировку в зависимости от указанной или заданной по умолчанию локали.
При создании базы данных можно указать кодировку, отличную от заданной по умолчанию, если
эта кодировка совместима с выбранной локалью:
createdb -E EUC_KR -T template0 –lc-collate=ko_KR.euckr –lc-ctype=ko_KR.euckr korean
Это создаст базу данных с именем korean, которая использует кодировку EUC_KR и локаль ko_KR.
Также, получить желаемый результат можно с помощью данной SQL-команды:
CREATE DATABASE korean WITH ENCODING ‘EUC_KR’ LC_COLLATE=’ko_KR.euckr’
LC_CTYPE=’ko_KR.euckr’ TEMPLATE=template0;
Заметьте, что приведённые выше команды задают копирование базы данных template0. При ко-
пировании любой другой базы данных, параметры локали и кодировку исходной базы изменить
нельзя, так как это может привести к искажению данных. Более подробное описание приведено
в Разделе 22.3.
Кодировка базы данных хранится в системном каталоге pg_database. Её можно увидеть при помо-
щи параметра psql -l или команды \l.
$ psql -l
List of databases
Name
| Owner
| Encoding | Collation |
Ctype
|
Privileges
———–+———-+———–+————-+————-
+————————————-
clocaledb | hlinnaka | SQL_ASCII | C
| C
|
englishdb | hlinnaka | UTF8
| en_GB.UTF8 | en_GB.UTF8 |
japanese | hlinnaka | UTF8
| ja_JP.UTF8 | ja_JP.UTF8 |
korean
| hlinnaka | EUC_KR
| ko_KR.euckr | ko_KR.euckr |
postgres | hlinnaka | UTF8
| fi_FI.UTF8 | fi_FI.UTF8 |
template0 | hlinnaka | UTF8
| fi_FI.UTF8 | fi_FI.UTF8 | {=c/
hlinnaka,hlinnaka=CTc/hlinnaka}
template1 | hlinnaka | UTF8
| fi_FI.UTF8 | fi_FI.UTF8 | {=c/
hlinnaka,hlinnaka=CTc/hlinnaka}
(7 rows)
Access
Важно
На большинстве современных операционных систем PostgreSQL может определить, ка-
кая кодировка подразумевается параметром LC_CTYPE, что обеспечит использование
только соответствующей кодировки базы данных. На более старых системах необходи-
мо самостоятельно следить за тем, чтобы использовалась кодировка, соответствующая
выбранной языковой среде. Ошибка в этой области, скорее всего, приведёт к странно-
му поведению зависимых от локали операций, таких как сортировка.
PostgreSQL позволит суперпользователям создавать базы данных с кодировкой
SQL_ASCII, даже когда значение LC_CTYPE не установлено в C или POSIX. Как было ска-
зано выше, SQL_ASCII не гарантирует, что данные, хранящиеся в базе, имеют опреде-
лённую кодировку, и таким образом, этот выбор чреват сбоями, связанными с локалью.
Использование данной комбинации устарело и, возможно, будет полностью запреще-
но.
23.3.3. Автоматическая перекодировка между сервером и клиен-
том
PostgreSQL поддерживает автоматическую перекодировку между сервером и клиентом для опре-
делённых комбинаций кодировок. Информация, касающаяся перекодировки, хранится в систем-
615Локализация
ном каталоге pg_conversion. PostgreSQL включает в себя некоторые предопределённые кодиров-
ки, как показано в Таблице 23.2. Есть возможность создать новую перекодировку при помощи SQL-
команды CREATE CONVERSION.
Таблица 23.2. Клиент-серверные перекодировки наборов символов
Серверная кодировка Доступные клиентские кодировки
BIG5 не поддерживается как серверная кодировка
EUC_CN EUC_CN, MULE_INTERNAL , UTF8
EUC_JP EUC_JP, MULE_INTERNAL , SJIS, UTF8
EUC_JIS_2004 EUC_JIS_2004, SHIFT_JIS_2004
EUC_KR EUC_KR, MULE_INTERNAL , UTF8
EUC_TW EUC_TW, BIG5, MULE_INTERNAL , UTF8
GB18030 не поддерживается как серверная кодировка
GBK не поддерживается как серверная кодировка
ISO_8859<em>5 ISO_8859_5,
KOI8R,
WIN866, WIN1251
ISO_8859_6 ISO_8859_6, UTF8
ISO_8859_7 ISO_8859_7, UTF8
ISO_8859_8 ISO_8859_8, UTF8
JOHAB не поддерживается как серверная кодировка
KOI8R KOI8R, ISO_8859_5
WIN866, WIN1251
KOI8U KOI8U, UTF8
LATIN1 LATIN1, MULE_INTERNAL , UTF8
LATIN2 LATIN2, MULE_INTERNAL , UTF8, WIN1250
LATIN3 LATIN3, MULE_INTERNAL , UTF8
LATIN4 LATIN4, MULE_INTERNAL , UTF8
LATIN5 LATIN5, UTF8
LATIN6 LATIN6, UTF8
LATIN7 LATIN7, UTF8
LATIN8 LATIN8, UTF8
LATIN9 LATIN9, UTF8
LATIN10 LATIN10, UTF8
MULE_INTERNAL MULE_INTERNAL, BIG5, EUC_CN , EUC_JP , EUC</em>
KR , EUC_TW , ISO_8859_5 , KOI8R, LATIN1 to
LATIN4, SJIS, WIN866, WIN1250, WIN1251
SJIS не поддерживается как серверная кодировка
SHIFT_JIS_2004 не поддерживается как серверная кодировка
SQL_ASCII любая (перекодировка не будет выполнена)
UHC не поддерживается как серверная кодировка
UTF8 все поддерживаемые кодировки
WIN866 WIN866, ISO_8859_5
UTF8, WIN1251
WIN874 WIN874, UTF8
616
, UTF8
MULE_INTERNAL ,
,
MULE_INTERNAL ,
UTF8,
UTF8,
, KOI8R, MULE_INTERNAL ,Локализация
Серверная кодировка Доступные клиентские кодировки
WIN1250 WIN1250, LATIN2, MULE_INTERNAL , UTF8
WIN1251 WIN1251, ISO_8859_5
UTF8, WIN866
WIN1252 WIN1252, UTF8
WIN1253 WIN1253, UTF8
WIN1254 WIN1254, UTF8
WIN1255 WIN1255, UTF8
WIN1256 WIN1256, UTF8
WIN1257 WIN1257, UTF8
WIN1258 WIN1258, UTF8
, KOI8R, MULE_INTERNAL ,
Чтобы включить автоматическую перекодировку символов, необходимо сообщить PostgreSQL ко-
дировку, которую вы хотели бы использовать на стороне клиента. Это можно выполнить несколь-
кими способами:
• Использование команды \encoding в psql. \encoding позволяет оперативно изменять клиент-
скую кодировку. Например, чтобы изменить кодировку на SJIS, введите:
\encoding SJIS
• libpq (Раздел 34.10) имеет функции, для управления клиентской кодировкой.
• Использование SET client_encoding TO. Клиентская кодировка устанавливается следующей
SQL-командой:
SET CLIENT_ENCODING TO ‘value’;
Также, для этой цели можно использовать стандартный синтаксис SQL SET NAMES:
SET NAMES ‘value’;
Получить текущую клиентскую кодировку:
SHOW client_encoding;
Вернуть кодировку по умолчанию:
RESET client_encoding;
• Использование PGCLIENTENCODING. Если установлена переменная окружения
PGCLIENTENCODING, то эта клиентская кодировка выбирается автоматически при подключении
к серверу. (В дальнейшем это может быть переопределено при помощи любого из методов,
указанных выше.)
• Использование переменной конфигурации client_encoding. Если задана переменная
client_encoding, указанная клиентская кодировка выбирается автоматически при подключе-
нии к серверу. (В дальнейшем это может быть переопределено при помощи любого из мето-
дов, указанных выше.)
Если перекодировка определённого символа невозможна (предположим, выбраны EUC_JP для сер-
вера и LATIN1 для клиента, и передаются некоторые японские иероглифы, не представленные в
LATIN1), возникает ошибка.
Если клиентская кодировка определена как SQL_ASCII, перекодировка отключается вне зависимо-
сти от кодировки сервера. Что же касается сервера, не стоит использовать SQL_ASCII, если только
вы не работаете с данными, которые полностью соответствуют ASCII.
23.3.4. Дополнительные источники информации
Рекомендуемые источники для начала изучения различных видов систем кодирования.
617Локализация
Обработка информации на китайском, японском, корейском &amp; вьетнамском языках.
Содержит подробные объяснения по EUC_JP, EUC_CN, EUC_KR, EUC_TW.
http://www.unicode.org/
Сайт Unicode Consortium.
RFC 3629
UTF-8 (формат преобразования 8-битного UCS/Unicode) определён здесь.</li>
</ol>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-022/" title="Глава 22. Управление базами данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 22. Управление базами данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-022/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~11 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-022/" rel="bookmark" title="Глава 22. Управление базами данных" itemprop="url">Глава 22. Управление базами данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 22. Управление базами данных</p>

<p>Каждый работающий экземпляр сервера PostgreSQL обслуживает одну или несколько баз данных.
Поэтому базы данных представляют собой вершину иерархии SQL-объектов («объектов базы дан-
ных»). Данная глава описывает свойства баз данных, процессы создания, управления и удаления.
22.1. Обзор
База данных — именованная коллекция объектов SQL («объектов базы данных»). В целом, каждый
объект базы данных (таблицы, функции и т. д.) принадлежит одной и только одной базе данных.
(Правда есть несколько системных каталогов, например, pg_database, которые принадлежат всему
кластеру и доступны для каждой базы данных этого кластера.) Если точнее, база данных это набор
схем, которые включают в себя таблицы, функции и т. д. Таким образом, полная иерархия включает
в себя: сервер, базу данных, схему, таблицу (или иные типы объектов, к примеру, функции).
При подключении к серверу базы данных, клиент должен указать в параметрах подключения имя
базы данных, с которой нужно соединиться. Одно соединение не может иметь доступ более чем
к одной базе данных. Однако приложение не ограничено в количестве соединений к одной и той
же или разным базам данных. Базы данных разделены физически и контроль доступа осуществ-
ляется на уровне соединения. В случае, когда один экземпляр сервера PostgreSQL обслуживает
проекты или пользователей, которых необходимо изолировать друг от друга, рекомендуется раз-
мещать их в раздельных базах данных. В случае, когда проекты или пользователи взаимосвязаны
и должны иметь возможность использовать общие ресурсы, они должны размещаться в одной базе
данных, но, возможно, в раздельных схемах. Схемы — в чистом виде логическая структура, и кто
к чему может получить доступ управляется системой привилегий. Более подробная информация
по управлению схемами приведена в Разделе 5.8.
Базы данных создаются командой CREATE DATABASE (см. Раздел 22.2), а удаляются командой DROP
DATABASE (см. Раздел 22.5). Список существующих баз данных можно посмотреть в системном ка-
талоге pg_database, например,
SELECT datname FROM pg_database;
Метакоманда \l или ключ -l командной строки приложения psql также позволяют вывести список
существующих баз данных.
Примечание
Стандарт SQL называет базы данных «каталогами», но на практике у них нет отличий.
22.2. Создание базы данных
Для создания базы данных сервер PostgreSQL должен быть развёрнут и запущен (см. Раздел 18.3).
База данных создаётся SQL-командой CREATE DATABASE:
CREATE DATABASE имя;
где имя подчиняется правилам именования идентификаторов SQL. Текущий пользователь автома-
тически назначается владельцем. Владелец может удалить свою базу, что также приведёт к уда-
лению всех её объектов, в том числе, имеющих других владельцев.
Создание баз данных это привилегированная операция. Как предоставить права доступа, описано
в Разделе 21.2.
Поскольку для выполнения команды CREATE DATABASE необходимо подключение к серверу базы
данных, возникает вопрос как создать самую первую базу данных. Первая база данных всегда со-
здаётся командой initdb при инициализации пространства хранения данных (см. Раздел  18.2.)
598Управление базами данных
Эта база данных называется postgres.Далее для создания первой «обычной» базы данных можно
подключиться к postgres.
Вторая база данных template1,также создаётся во время инициализации кластера. При каждом
создании новой базы данных в рамках кластера по факту производится клонирование шаблона
template1. При этом любые изменения сделанные в template1 распространяются на все создан-
ные впоследствии базы данных. Следует избегать создания объектов в template1, за исключением
ситуации, когда их необходимо автоматически добавлять в новые базы. Более подробно в Разде-
ле 22.3.
Для удобства, есть утилита командной строки для создания баз данных, createdb.
createdb dbname
Утилита createdb не делает ничего волшебного, она просто подключается к базе данных postgres
и выполняет ранее описанную SQL-команду CREATE DATABASE. Подробнее о её вызове можно узнать
в createdb. Обратите внимание, что команда createdb без параметров создаст базу данных с име-
нем текущего пользователя.
Примечание
Глава 20 содержит информацию о том, как ограничить права на подключение к задан-
ной базе данных.
Иногда необходимо создать базу данных для другого пользователя и назначить его владельцем,
чтобы он мог конфигурировать и управлять ею. Для этого используйте одну из следующих команд:
CREATE DATABASE имя_базы OWNER имя_роли;
из среды SQL, или:
createdb -O имя_роли имя_базы
из командной строки ОС. Лишь суперпользователь может создавать базы данных для других (для
ролей, членом которых он не является).
22.3. Шаблоны баз данных
По факту команда CREATE DATABASE выполняет копирование существующей базы данных. По умол-
чанию копируется стандартная системная база template1. Таким образом, template1 это шаблон,
на основе которого создаются новые базы. Если добавить объекты в template1, то впоследствии
они будут копироваться в новые базы данных. Это позволяет внести изменения в стандартный на-
бор объектов. Например, если в template1 установить процедурный язык PL/Perl, то он будет до-
ступен в новых базах без дополнительных действий.
Также существует вторая системная база template0.При инициализации она содержит те же са-
мые объекты, что и template1, предопределённые в рамках устанавливаемой версии PostgreSQL.
Не нужно вносить никаких изменений в template0 после инициализации кластера. Если в команде
CREATE DATABASE указать на необходимость копирования template0 вместо template1, то на выходе
можно получить «чистую» пользовательскую базу данных без изменений, внесённых в template1.
Это удобно, когда производится восстановление из дампа данных с помощью утилиты pg_dump:
скрипт дампа лучше выполнять в чистую базу, во избежание каких-либо конфликтов с объектами,
которые могли быть добавлены в template1.
Другая причина, для копирования template0 вместо template1 заключается в том, что можно ука-
зать новые параметры локали и кодировку при копировании template0, в то время как для копий
template1 они не должны меняться. Это связано с тем, что template1 может содержать данные в
специфических кодировках и локалях, в отличие от template0.
Для создания базы данных на основе template0, используйте:
599Управление базами данных
CREATE DATABASE dbname TEMPLATE template0;
из среды SQL, или:
createdb -T template0 dbname
из командной строки ОС.
Можно создавать дополнительные шаблоны баз данных, и, более того, можно копировать любую
базу данных кластера, если указать её имя в качестве шаблона в команде CREATE DATABASE. Важно
понимать, что это (пока) не рассматривается в качестве основного инструмента для реализации
возможности «COPY DATABASE». Важным является то, что при копировании все сессии к копиру-
емой базе данных должны быть закрыты. CREATE DATABASE выдаст ошибку, если есть другие под-
ключения; во время операции копирования новые подключения к этой базе данных не разрешены.
В таблице pg_databaseесть два полезных флага для каждой базы данных: столбцы datistemplate
и datallowconn. datistemplate указывает на факт того, что база данных может выступать в каче-
стве шаблона в команде CREATE DATABASE. Если флаг установлен, то для пользователей с правом
CREATEDB клонирование доступно; если флаг не установлен, то лишь суперпользователь и владелец
базы данных могут её клонировать. Если datallowconn не установлен, то новые подключения к
этой базе не допустимы (однако текущие сессии не закрываются при сбросе этого флага). База
template0 обычно помечена как datallowconn = false для избежания любых её модификаций. И
template0, и template1 всегда должны быть помечены флагом datistemplate = true.
Примечание
template1 и template0 не выделены как-то особенно, кроме того факта, что template1
используется по умолчанию в команде CREATE DATABASE. Например, можно удалить
template1 и безболезненно создать заново из template0. Это можно посоветовать в слу-
чае, если template1 был замусорен. (Чтобы удалить template1, необходимо сбросить
флаг pg_database.datistemplate = false.)
База данных postgres также создаётся при инициализации кластера. Она использу-
ется пользователями и приложениями для подключения по умолчанию. Представля-
ет собой всего лишь копию template1, и может быть удалена и повторно создана при
необходимости.
22.4. Конфигурирование баз данных
Обратившись к Главе  19 можно выяснить, что сервер PostgreSQL имеет множество параметров
конфигурации времени исполнения. Можно выставить специфичные для базы данных значения
по умолчанию.
Например, если по какой-то причине необходимо выключить GEQO оптимизатор в какой-то из
баз, то можно, либо выключить его для всех баз данных одновременно, либо убедиться, что все
клиенты заботятся об этом, выполняя команду SET geqo TO off. Для того чтобы это действовало
по умолчанию в конкретной базе данных, необходимо выполнить команду:
ALTER DATABASE mydb SET geqo TO off;
Установка сохраняется, но не применяется тотчас. В последующих подключениях к этой базе дан-
ных, эффект будет таким, будто перед началом сессии была выполнена команда SET geqo TO off;.
Стоит обратить внимание, что пользователь по-прежнему может изменять этот параметр во время
сессии; ведь это просто значение по умолчанию. Чтобы сбросить такое установленное значение,
используйте ALTER DATABASE dbname RESET varname.
22.5. Удаление базы данных
Базы данных удаляются командой DROP DATABASE:
600Управление базами данных
DROP DATABASE имя;
Лишь владелец базы данных или суперпользователь могут удалить базу. При удалении также уда-
ляются все её объекты. Удаление базы данных это необратимая операция.
Невозможно выполнить команду DROP DATABASE пока существует хоть одно подключение к задан-
ной базе. Однако можно подключиться к любой другой, в том числе и template1. template1 мо-
жет быть единственной возможностью при удалении последней пользовательской базы данных
кластера.
Также существует утилита командной строки для удаления баз данных dropdb:
dropdb dbname
(В отличие от команды createdb утилита не использует имя текущего пользователя по умолча-
нию).
22.6. Табличные пространства
Табличные пространства в PostgreSQL позволяют администраторам организовать логику разме-
щения файлов объектов базы данных в файловой системе. К однажды созданному табличному про-
странству можно обращаться по имени на этапе создания объектов.
Табличные пространства позволяют администратору управлять дисковым пространством для ин-
сталляции PostgreSQL. Это полезно минимум по двум причинам. Во-первых, это нехватка места в
разделе, на котором был инициализирован кластер и невозможность его расширения. Табличное
пространство можно создать в другом разделе и использовать его до тех пор, пока не появится
возможность переконфигурирования системы.
Во-вторых, табличные пространства позволяют администраторам оптимизировать производитель-
ность согласно бизнес-процессам, связанным с объектами базы данных. Например, часто исполь-
зуемый индекс можно разместить на очень быстром и надёжном, но дорогом SSD-диске. В то же
время таблица с архивными данными, которые редко используются и скорость к доступа к ним не
важна, может быть размещена в более дешёвом и медленном хранилище.
Предупреждение
Несмотря на внешнее размещение относительно основного каталога хранения данных
PostgreSQL, табличные пространства являются неотъемлемой частью кластера и не
могут трактоваться, как самостоятельная коллекция файлов данных. Они зависят от
метаданных, расположенных в главном каталоге, и потому не могут быть подключены
к другому кластеру, или копироваться по отдельности. Также, в случае потери таблич-
ного пространства (при удалении файлов, сбое диска и т. п.), кластер может оказаться
недоступным или не сможет запуститься. Таким образом, при размещении таблично-
го пространства во временной файловой системе, например, в RAM-диске, возникает
угроза надёжности всего кластера.
Для создания табличного пространства используется команда CREATE TABLESPACE, например::
CREATE TABLESPACE fastspace LOCATION ‘/ssd1/postgresql/data’;
Каталог должен существовать, быть пустым и принадлежать пользователю ОС, под которым за-
пущен PostgreSQL. Все созданные впоследствии объекты, принадлежащие целевому табличному
пространству, будут храниться в файлах расположенных в этом каталоге. Каталог не должен раз-
мещаться на съёмных или устройствах временного хранения, так как кластер может перестать
функционировать из-за потери этого пространства.
Примечание
Обычно нет смысла создавать более одного пространства на одну логическую файло-
вую систему, так как нет возможности контролировать расположение отдельных фай-
601Управление базами данных
лов в файловой системе. Однако PostgreSQL не накладывает никаких ограничений в
этом отношении, и более того, напрямую не заботится о точках монтирования файло-
вой системы. Просто осуществляется хранение файлов в указанных каталогах.
Создавать табличное пространство должен суперпользователь базы данных, но после этого можно
разрешить обычным пользователям его использовать. Для этого необходимо предоставить приви-
легию CREATE на табличное пространство.
Таблицы, индексы и целые базы данных могут храниться в отдельных табличных пространствах.
Для этого пользователь с правом CREATE на табличное пространство должен указать его имя в
качестве параметра соответствующей команды. Например, далее создаётся таблица в табличном
пространстве space1:
CREATE TABLE foo(i int) TABLESPACE space1;
Как вариант, используйте параметр default_tablespace:
SET default_tablespace = space1;
CREATE TABLE foo(i int);
Когда default_tablespace имеет значение отличное от пустой строки, он будет использоваться
неявно в качестве значения параметра TABLESPACE в командах CREATE TABLE и CREATE INDEX, если
в самой команде не задано иное.
Существует параметр temp_tablespaces, который указывает на размещение временных таблиц и
индексов, а также файлов, создаваемых, например, при операциях сортировки больших наборов
данных. Предпочтительнее, в качестве значения этого параметра, указывать не одно имя, а спи-
сок из нескольких табличных пространств. Это поможет распределить нагрузку, связанную с вре-
менными объектами, по различным табличным пространствам. При каждом создании временного
объекта будет случайным образом выбираться имя из указанного списка табличных пространств.
Табличное пространство, связанное с базой данных, также используется для хранения её систем-
ных каталогов. Более того, это табличное пространство используется по умолчанию для таблиц,
индексов и временных файлов, создаваемых в базе данных, если не указано иное в выражении
TABLESPACE, или переменной default_tablespace, или temp_tablespaces (соответственно). Если
база данных создана без указания конкретного табличного пространства, то используется про-
странство, к которому принадлежит копируемый шаблон.
При инициализации кластера автоматически создаются два табличных пространства. Табличное
пространство pg_global используется для общих системных каталогов. Табличное пространство
pg_default используется по умолчанию для баз данных template1 и template0 (в свою очередь,
также является пространством по умолчанию для других баз данных, пока не будет явно указано
иное в выражении TABLESPACE команды CREATE DATABASE).
После создания, табличное пространство можно использовать в рамках любой базы данных, при
условии, что у пользователя имеются необходимые права. Это означает, что табличное простран-
ство невозможно удалить до тех пор, пока не будут удалены все объекты баз данных, использую-
щих это пространство.
Для удаления пустого табличного пространства используйте команду DROP TABLESPACE.
Чтобы получить список табличных пространств можно сделать запрос к системному каталогу
pg_tablespace, например,
SELECT spcname FROM pg_tablespace;
Метакоманда \db утилиты psql также позволяет отобразить список существующих табличных про-
странств.
PostgreSQL использует символические ссылки для упрощения реализации табличных про-
странств. Это означает, что табличные пространства могут использоваться только в системах,
поддерживающих символические ссылки.
602Управление базами данных
Каталог $PGDATA/pg_tblspc содержит символические ссылки, которые указывают на внешние таб-
личные пространства кластера. Хоть и не рекомендуется, но возможно регулировать табличные
пространства вручную, переопределяя эти ссылки. Ни при каких обстоятельствах эти операции
нельзя проводить, пока запущен сервер баз данных. Обратите внимание, что в версии PostgreSQL
9.1 и более ранних также необходимо обновить информацию в pg_tablespace о новых расположе-
ниях. (Если это не сделать, то pg_dump будет продолжать выводить старые расположения таблич-
ных пространств.)</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-021/" title="Глава 21. Роли базы данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 21. Роли базы данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-021/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~12 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-021/" rel="bookmark" title="Глава 21. Роли базы данных" itemprop="url">Глава 21. Роли базы данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 21. Роли базы данных</p>

<p>PostgreSQL использует концепцию ролей (roles) для управления разрешениями на доступ к базе
данных. Роль можно рассматривать как пользователя базы данных или как группу пользователей,
в зависимости от того, как роль настроена. Роли могут владеть объектами базы данных (например,
таблицами и функциями) и выдавать другим ролям разрешения на доступ к этим объектам, управ-
ляя тем, кто имеет доступ и к каким объектам. Кроме того, можно предоставить одной роли член-
ство в другой роли, таким образом одна роль может использовать привилегии других ролей.
Концепция ролей включает в себя концепцию пользователей («users») и групп («groups»). До вер-
сии 8.1 в PostgreSQL пользователи и группы были отдельными сущностями, но теперь есть только
роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.
В этой главе описывается как создавать и управлять ролями. Дополнительную информацию о при-
вилегиях для ролей на различные объекты базы данных можно найти в Разделе 5.6.
21.1. Роли базы данных
Роли базы данных концептуально полностью отличаются от пользователей операционной системы.
На практике поддержание соответствия между ними может быть удобным, но не является обяза-
тельным. Роли базы данных являются глобальными для всей установки кластера базы данных (не
для отдельной базы данных). Для создания роли используется команда SQL CREATE ROLE:
CREATE ROLE имя;
Здесь имя соответствует правилам именования идентификаторов SQL: либо обычное, без специ-
альных символов, либо в двойных кавычках. (На практике, к команде обычно добавляются другие
указания, такие как LOGIN. Подробнее об этом ниже.) Для удаления роли используется команда
DROP ROLE:
DROP ROLE имя;
Для удобства поставляются программы createuser и dropuser, которые являются обёртками для
этих команд SQL и вызываются из командной строки оболочки ОС:
createuser имя
dropuser имя
Для получения списка существующих ролей, рассмотрите pg_roles системного каталога, напри-
мер:
SELECT rolname FROM pg_roles;
Метакоманда \du программы psql также полезна для получения списка существующих ролей.
Для начальной настройки кластера базы данных, система сразу после инициализации всегда со-
держит одну предопределённую роль. Эта роль является суперпользователем («superuser») и по
умолчанию (если не изменено при запуске initdb) имеет такое же имя, как и пользователь опера-
ционной системы, инициализирующий кластер баз данных. Обычно эта роль называется postgres.
Для создания других ролей, вначале нужно подключиться с этой ролью.
Каждое подключение к серверу базы данных выполняется под именем конкретной роли и эта роль
определяет начальные привилегии доступа для команд выполняемых в этом соединении. Имя ро-
ли для конкретного подключения к базе данных указывается клиентской программой характер-
ным для неё способом, таким образом инициируя запрос на подключение. Например, программа
psql для указания роли использует аргумент командной строки -U. Многие приложения предпо-
лагают, что по умолчанию нужно использовать имя пользователя операционной системы (включая
createuser и psql). Поэтому часто бывает удобным поддерживать соответствие между именами
ролей и именами пользователей операционной системы.
591Роли базы данных
Список доступных для подключения ролей, который могут использовать клиенты, определяется
конфигурацией аутентификации, как описывалось в Главе 20. (Поэтому, клиент не ограничен толь-
ко ролью, соответствующей имени пользователя операционной системы, также как и имя для вхо-
да может не соответствовать реальному имени.) Так как роль определяет набор доступных приви-
легий, очень важно тщательно настраивать привилегии в многопользовательской среде.
21.2. Атрибуты ролей
Роль базы данных может иметь атрибуты, определяющие её полномочия и взаимодействие с си-
стемой аутентификации клиентов.
Право подключения
Только роли с атрибутом LOGIN могут использоваться для начального подключения к базе дан-
ных. Роль с атрибутом LOGIN можно рассматривать как пользователя базы данных. Для созда-
ния роли такой роли можно использовать любой из вариантов:
CREATE ROLE имя LOGIN;
CREATE USER имя;
(Команда CREATE USER эквивалентна CREATE ROLE за исключением того, что CREATE USER по
умолчанию включает атрибут LOGIN, в то время как CREATE ROLE — нет.)
Статус суперпользователя
Суперпользователь базы данных обходит все проверки прав доступа, за исключением права на
вход в систему. Это опасная привилегия и она не должна использоваться небрежно. Лучше
всего выполнять большую часть работы не как суперпользователь. Для создания нового супер-
пользователя используется CREATE ROLE имя SUPERUSER. Это нужно выполнить из под роли,
которая также является суперпользователем.
Создание базы данных
Роль должна явно иметь разрешение на создание базы данных (за исключением суперпользо-
вателей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEDB.
Создание роли
Роль должна явно иметь разрешение на создание других ролей (за исключением суперполь-
зователей, которые пропускают все проверки). Для создания такой роли используется CREATE
ROLE имя CREATEROLE. Роль с привилегией CREATEROLE может также изменять и удалять другие
роли, а также выдавать и отзывать членство в ролях. Однако, для создания, изменения, удале-
ния суперпользовательских ролей, а также изменения в них членства, требуется иметь статус
суперпользователя; привилегии CREATEROLE в таких случаях недостаточно.
Запуск репликации
Роль должна иметь явное разрешение на запуск потоковой репликации (за исключением су-
перпользователей, которые пропускают все проверки). Роль, используемая для потоковой ре-
пликации, также должна иметь атрибут LOGIN. Для создания такой роли используется CREATE
ROLE имя REPLICATION LOGIN.
Пароль
Пароль имеет значение, если метод аутентификации клиентов требует, чтобы пользователи
предоставляли пароль при подключении к базе данных. Методы аутентификации password и
md5 используют пароли. База данных и операционная система используют раздельные пароли.
Пароль указывается при создании роли: CREATE ROLE имя PASSWORD ‘строка’.
Атрибуты ролей могут быть изменены после создания командой ALTER ROLE.Более детальная ин-
формация в справке по командам CREATE ROLE и ALTER ROLE.
592Роли базы данных
Подсказка
Рекомендуется создать роль с привилегиями CREATEDB и CREATEROLE, но не суперполь-
зователя и в последующем использовать её для управления базами данных и ролями.
Такой подход позволит избежать опасностей, связанных с использованием полномочий
суперпользователя для задач, которые их не требуют.
На уровне ролей можно устанавливать многие конфигурационные параметры времени выполне-
ния, описанные в Главе 19. Например, если по некоторым причинам всякий раз при подключении
к базе данных требуется отключить использование индексов (подсказка: плохая идея) можно вы-
полнить:
ALTER ROLE myname SET enable_indexscan TO off;
Установленное значение параметра будет сохранено (но не будет применено сразу). Для по-
следующих подключений с этой ролью это будет выглядеть как выполнение команды SET
enable_indexscan TO off перед началом сессии. Но это только значение по умолчанию, в течение
сессии эту установку можно изменить. Для удаления установок на уровне ролей для параметров
конфигурации используется ALTER ROLE rolename RESET varname. Обратите внимание, что уста-
новка параметров конфигурации на уровне роли без привилегии LOGIN лишено смысла, т. к. они
никогда не будут применены,
21.3. Членство в роли
Часто бывает удобным сгруппировать пользователей для упрощения администрирования приви-
легий: привилегии выдаются или отзываются на всю группу. В PostgreSQL для этого создаётся
роль, которая представляет группу, а затем членство (membership) в этой группе выдаётся ролям
индивидуальных пользователей.
Для настройки групповой роли, сначала нужно создать саму роль:
CREATE ROLE имя;
Обычно групповая роль не имеет атрибута LOGIN, хотя при желании его можно установить.
После того как групповая роль создана, в неё можно добавлять или удалять членов, используя
команды GRANT и REVOKE:
GRANT group_role TO role1, … ;
REVOKE group_role FROM role1, … ;
Можно выдавать членство в групповой роли другим групповым ролям (потому что в действитель-
ности нет никаких различий между групповыми и не групповыми ролями). База данных не позво-
лит замкнуть предоставление членства по кругу. Также, не допускается выдача членства в роли
для PUBLIC.
Члены групповой роли могут использовать её привилегии двумя способами. Во-первых, каждый
член группы может явно выполнить SET ROLE, чтобы временно «стать» групповой ролью. В этом
состоянии, сессия базы данных использует полномочия групповой роли, вместо оригинальной ро-
ли, под которой был выполнен вход в систему. При этом для всех создаваемых объектов базы дан-
ных владельцем считается групповая, а не оригинальная роль. Во-вторых, роли, имеющие атрибут
INHERIT, автоматически используют привилегии всех ролей, членами которых они являются, в том
числе и унаследованными этими ролями привилегиями. Например:
CREATE ROLE
CREATE ROLE
CREATE ROLE
GRANT admin
GRANT wheel
joe LOGIN INHERIT;
admin NOINHERIT;
wheel NOINHERIT;
TO joe;
TO admin;
После подключения с ролью joe, сессия базы данных будет использовать полномочия выданные
напрямую joe и привилегии выданные admin, так как joe “наследует” привилегии admin. Однако
593Роли базы данных
привилегии выданные wheel не будут доступны, потому что, хотя joe неявно и является членом
wheel, это членство получено через роль admin, которая имеет атрибут NOINHERIT. После выпол-
нения команды:
SET ROLE admin;
сессия будет использовать только привилегии выданные admin, привилегии выданные joe не будут
доступны. После выполнения команды:
SET ROLE wheel;
сессия будет использовать только привилегии выданные wheel, привилегии joe и admin не будут
доступны. Начальный набор привилегий можно вернуть любой из команд:
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
Примечание
Команда SET ROLE в любой момент разрешает выбрать любую роль, прямым или кос-
венным членом которой является оригинальная роль, под которой был выполнен вход
в систему. Поэтому, в примере выше, не обязательно сначала становиться admin, перед
тем как стать wheel.
Примечание
В стандарте SQL есть чёткое различие между пользователями и ролями. При этом поль-
зователи не наследуют автоматически привилегии, а роли наследуют автоматически.
Такое поведение может быть получено в PostgreSQL, если для ролей, используемых как
роли в стандарте SQL, устанавливать атрибут INHERIT, а для ролей, используемых как
пользователи в стандарте SQL, устанавливать атрибут NOINHERIT. Однако, в PostgreSQL
все роли по умолчанию имеют атрибут INHERIT. Это сделано для обратной совместимо-
сти с версиями предшествующими 8.1, в которых пользователи всегда могли исполь-
зовать привилегии групп, членами которых они являются.
Атрибуты роли LOGIN, SUPERUSER, CREATEDB и CREATEROLE можно рассматривать как особые приви-
легии, но они никогда не наследуются, как обычные привилегии на объекты базы данных. Необхо-
димо через SET ROLE установить роль, имеющую один из этих атрибутов, чтобы им воспользовать-
ся. Продолжая предыдущий пример, можно установить атрибуты CREATEDB и CREATEROLE для роли
admin. Затем при входе с ролью joe, получить доступ к этим привилегиям будет возможно только
после выполнения SET ROLE admin.
Для удаления групповой роли используется DROP ROLE:
DROP ROLE имя;
Любое членство в групповой роли будет автоматически отозвано (в остальном на членов этой роли
это никак не повлияет).
21.4. Удаление ролей
Так как роли могут владеть объектами баз данных и иметь права доступа к объектам других, уда-
ление роли не сводится к немедленному действию DROP ROLE. Сначала должны быть удалены и
переданы другим владельцами все объекты, принадлежащие роли; также должны быть отозваны
все права, данные роли.
594Роли базы данных
Владение объектами можно передавать в индивидуальном порядке, применяя команду ALTER, на-
пример:
ALTER TABLE bobs_table OWNER TO alice;
Кроме того, для переназначения какой-либо другой роли владения сразу всеми объектами, при-
надлежащих удаляемой роли, можно применить команду REASSIGN OWNED. Так как REASSIGN
OWNED не может обращаться к объектам в других базах данных, её необходимо выполнить в каждой
базе, которая содержит объекты, принадлежащие этой роли. (Заметьте, что первая такая команда
REASSIGN OWNED изменит владельца для всех разделяемых между базами объектов, то есть для баз
данных или табличных пространств, принадлежащих удаляемой роли.)
После того как все ценные объекты будут переданы новым владельцам, все оставшиеся объекты,
принадлежащие удаляемой роли, могут быть удалены с помощью команды DROP OWNED. И эта
команда не может обращаться к объектам в других базах данных, так что её нужно запускать в
каждой базе, которая содержит объекты, принадлежащие роли. Также заметьте, что DROP OWNED не
удаляет табличные пространства или базы данных целиком, так что это необходимо сделать вруч-
ную, если роли принадлежат базы или табличные пространства, не переданные новым владельцам.
DROP OWNED также удаляет все права, которые даны целевой роли для объектов, не принадлежа-
щих ей. Так как REASSIGN OWNED такие объекты не затрагивает, обычно необходимо запустить и
REASSIGN OWNED, и DROP OWNED (в этом порядке!), чтобы полностью ликвидировать зависимости
удаляемой роли.
С учётом этого, общий рецепт удаления роли, которая владела объектами, вкратце таков:
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
– повторить предыдущие команды для каждой базы в кластере
DROP ROLE doomed_role;
Когда не все объекты нужно передать одному новому владельцу, лучше сначала вручную отрабо-
тать исключения, а в завершение выполнить показанные выше действия.
При попытке выполнить DROP ROLE для роли, у которой сохраняются зависимые объекты, будут
выданы сообщения, говорящие, какие объекты нужно передать другому владельцу или удалить.
21.5. Предопределённые роли
В PostgreSQL имеется набор предопределённых ролей, которые дают доступ к некоторым часто
востребованным, но не общедоступным функциям и данным. Администраторы могут назначать
(GRANT) эти роли пользователям и/или ролям в своей среде, таким образом открывая этим поль-
зователям доступ к указанной функциональности и информации.
Имеющиеся предопределённые роли описаны в Таблице 21.1. Заметьте, что конкретные разреше-
ния для каждой из предопределённых ролей в будущем могут изменяться по мере добавления до-
полнительной функциональности. Администраторы должны следить за этими изменениями, про-
сматривая замечания к выпускам.
Таблица 21.1. Предопределённые роли
Роль Разрешаемый доступ
pg_read_all_settings Читать все конфигурационные переменные, да-
же те, что обычно видны только суперпользова-
телям.
pg_read_all_stats Читать все представления pg_stat_* и использо-
вать различные расширения, связанные со ста-
тистикой, даже те, что обычно видны только су-
перпользователям.
595Роли базы данных
Роль Разрешаемый доступ
pg_stat_scan_tables Выполнять функции мониторинга, которые мо-
гут устанавливать блокировки ACCESS SHARE в
таблицах, возможно, на длительное время.
pg_signal_backend Передавать сигналы другим обслуживающим
процессам (например, отменять запрос, завер-
шать процесс).
pg_read_server_files Читать файлы в любом месте файловой системы,
куда имеет доступ СУБД на сервере, выполняя
COPY и другие функции работы с файлами.
pg_write_server_files Записывать файлы в любом месте файловой си-
стемы, куда имеет доступ СУБД на сервере, вы-
полняя COPY и другие функции работы с файла-
ми.
pg_execute_server_program Выполнять программы на сервере (от имени
пользователя, запускающего СУБД), так же, как
это делает команда COPY и другие функции, вы-
полняющие программы на стороне сервера.
pg_monitor Читать/выполнять различные представления и
функции для мониторинга. Эта роль включена в
роли pg_read_all_settings
, pg_read_all_
stats и pg_stat_scan_tables
.
Роли pg_read_server_files, pg_write_server_files и pg_execute_server_program предназначе-
ны для того, чтобы администраторы могли выделить доверенные, но не имеющие права суперполь-
зователей роли для доступа к файлам и запуска программ на сервере БД от имени пользователя,
запускающего СУБД. Так как эти роли могут напрямую обращаться к любым файлам в файловой
системе сервера, они обходят все проверки разрешений на уровне базы данных, а значит, восполь-
зовавшись ими, можно получить права суперпользователя. Поэтому назначать их пользователям
следует со всей осторожностью.
Роли pg_monitor, pg_read_all_settings, pg_read_all_stats и pg_stat_scan_tables созданы для
того, чтобы администраторы могли легко настроить роль для мониторинга сервера БД. Эти роли
наделяют своих членов набором общих прав, позволяющих читать различные полезные парамет-
ры конфигурации, статистику и другую системную информацию, что обычно доступно только су-
перпользователям.
Управлять членством в этих ролях следует осмотрительно, чтобы они использовались только по
необходимости и только с пониманием, что они открывают доступ к закрытой информации.
Администраторы могут давать пользователям доступ к этим ролям, используя команду GRANT:
GRANT pg_signal_backend TO admin_user;
21.6. Безопасность функций
Функции, триггеры и политики защиты на уровне строк позволяют пользователям внедрять код
в обслуживающие процессы, который может быть непреднамеренно выполнен другими пользова-
телями. Таким образом эти механизмы позволяют пользователям запускать «троянский код» от-
носительно просто. Лучшая защита от этого — строгое ограничение круга лиц, которые могут со-
здавать объекты. Там где это невозможно, пишите запросы так, чтобы они ссылались только на
объекты с доверенными владельцами. Удалите из search_path схему public и любые другие схемы,
в которых могут создавать объекты недоверенные пользователи.
Функции выполняются внутри серверного процесса с полномочиями пользователя операционной
системы, запускающего сервер базы данных. Если используемый для функций язык программи-
рования разрешает неконтролируемый доступ к памяти, то это даёт возможность изменить внут-
596Роли базы данных
ренние структуры данных сервера. Таким образом, помимо всего прочего, такие функции могут
обойти ограничения доступа к системе. Языки программирования, допускающие такой доступ,
считаются «недоверенными» и создавать функции на этих языках PostgreSQL разрешает только
суперпользователям.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page18/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page17/">17</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page18/">18</a></li>
      
    
      
        <li><strong class="current-page">19</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page20/">20</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page21/">21</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page35/">35</a></li>
    

    
    
      <li><a href="http://localhost:4000/page20/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>