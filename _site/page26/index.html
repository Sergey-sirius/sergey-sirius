<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page26/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page26/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-003/" title="Глава 3. Расширенные возможности"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 3. Расширенные возможности"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-003/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-003/" rel="bookmark" title="Глава 3. Расширенные возможности" itemprop="url">Глава 3. Расширенные возможности</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 3. Расширенные возможности</p>

<p>3.1. Введение
В предыдущей главе мы изучили азы использования SQL для хранения и обработки данных в
PostgreSQL. Теперь мы обсудим более сложные возможности SQL, помогающие управлять данны-
ми и предотвратить их потерю или порчу. В конце главы мы рассмотрим некоторые расширения
PostgreSQL.
В этой главе мы будем время от времени ссылаться на примеры, приведённые в Главе 2 и изменять
или развивать их, поэтому будет полезно сначала прочитать предыдущую главу. Некоторые при-
меры этой главы также можно найти в файле advanced.sql в каталоге tutorial. Кроме того, этот
файл содержит пример данных для загрузки (здесь она повторно не рассматривается). Если вы не
знаете, как использовать этот файл, обратитесь к Разделу 2.1.
3.2. Представления
Вспомните запросы, с которыми мы имели дело в Разделе 2.6. Предположим, что вас интересует
составной список из погодных записей и координат городов, но вы не хотите каждый раз вводить
весь этот запрос. Вы можете создать представление по данному запросу, фактически присвоить
имя запросу, а затем обращаться к нему как к обычной таблице:
CREATE VIEW myview AS
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
SELECT * FROM myview;
Активное использование представлений — это ключевой аспект хорошего проектирования баз дан-
ных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые мо-
гут меняться по мере развития приложения, за надёжными интерфейсами.
Представления можно использовать практически везде, где можно использовать обычные табли-
цы. И довольно часто представления создаются на базе других представлений.
3.3. Внешние ключи
Вспомните таблицы weather и cities из Главы 2. Давайте рассмотрим следующую задачу: вы хо-
тите добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится
соответствующая строка в таблице cities. Это называется обеспечением ссылочной целостности
данных. В простых СУБД это пришлось бы реализовать (если это вообще возможно) так: сначала
явно проверить, есть ли соответствующие записи в таблице cities, а затем отклонить или вставить
новые записи в таблицу weather. Этот подход очень проблематичен и неудобен, поэтому всё это
PostgreSQL может сделать за вас.
Новое объявление таблицы будет выглядеть так:
CREATE TABLE cities (
city
varchar(80) primary key,
location point
);
CREATE TABLE weather (
city
varchar(80) references cities(city),
temp_lo
int,
temp_hi
int,
prcp
real,
14Расширенные возможности
date
date
);
Теперь попробуйте вставить недопустимую запись:
INSERT INTO weather VALUES (‘Berkeley’, 45, 53, 0.0, ‘1994-11-28’);
ОШИБКА: INSERT или UPDATE в таблице “weather” нарушает ограничение внешнего
ключа “weather_city_fkey”
ПОДРОБНОСТИ: Ключ (city)=(Berkeley) отсутствует в таблице “cities”.
Поведение внешних ключей можно подстроить согласно требованиям вашего приложения. Мы не
будем усложнять этот простой пример в данном введении, но вы можете обратиться за дополни-
тельной информацией к Главе 5. Правильно применяя внешние ключи, вы определённо создадите
более качественные приложения, поэтому мы настоятельно рекомендуем изучить их.
3.4. Транзакции
Транзакции — это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объ-
единяет последовательность действий в одну операцию “всё или ничего”. Промежуточные состо-
яния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно
завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.
Например, рассмотрим базу данных банка, в которой содержится информация о счетах клиентов,
а также общие суммы по отделениям банка. Предположим, что мы хотим перевести 100 долларов
со счёта Алисы на счёт Боба. Простоты ради, соответствующие SQL-команды можно записать так:
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
UPDATE branches SET balance = balance - 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Alice’);
UPDATE accounts SET balance = balance + 100.00
WHERE name = ‘Bob’;
UPDATE branches SET balance = balance + 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Bob’);
Точное содержание команд здесь не важно, важно лишь то, что для выполнения этой довольно
простой операции потребовалось несколько отдельных действий. При этом с точки зрения банка
необходимо, чтобы все эти действия выполнились вместе, либо не выполнились совсем. Если Боб
получит 100 долларов, но они не будут списаны со счёта Алисы, объяснить это сбоем системы
определённо не удастся. И наоборот, Алиса вряд ли будет довольна, если она переведёт деньги,
а до Боба они не дойдут. Нам нужна гарантия, что если что-то помешает выполнить операцию
до конца, ни одно из действий не оставит следа в базе данных. И мы получаем эту гарантию, объ-
единяя действия в одну транзакцию. Говорят, что транзакция атомарна: с точки зрения других
транзакций она либо выполняется и фиксируется полностью, либо не фиксируется совсем.
Нам также нужна гарантия, что после завершения и подтверждения транзакции системой баз дан-
ных, её результаты в самом деле сохраняются и не будут потеряны, даже если вскоре произойдёт
авария. Например, если мы списали сумму и выдали её Бобу, мы должны исключить возможность
того, что сумма на его счёте восстановится, как только он выйдет за двери банка. Транзакционная
база данных гарантирует, что все изменения записываются в постоянное хранилище (например,
на диск) до того, как транзакция будет считаться завершённой.
Другая важная характеристика транзакционных баз данных тесно связана с атомарностью изме-
нений: когда одновременно выполняется множество транзакций, каждая из них не видит незавер-
шённые изменения, произведённые другими. Например, если одна транзакция подсчитывает ба-
ланс по отделениям, будет неправильно, если она посчитает расход в отделении Алисы, но не учтёт
приход в отделении Боба, или наоборот. Поэтому свойство транзакций “всё или ничего” должно
определять не только, как изменения сохраняются в базе данных, но и как они видны в процессе
работы. Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока
она не будет завершена, а затем они становятся видны все сразу.
15Расширенные возможности
В PostgreSQL транзакция определяется набором SQL-команд, окружённым командами BEGIN и
COMMIT. Таким образом, наша банковская транзакция должна была бы выглядеть так:
BEGIN;
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
– …
COMMIT;
Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения (на-
пример, потому что оказалось, что баланс Алисы стал отрицательным), мы можем выполнить ко-
манду ROLLBACK вместо COMMIT, и все наши изменения будут отменены.
PostgreSQL на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не встави-
те команду BEGIN, то каждый отдельный оператор будет неявно окружён командами BEGIN и COMMIT
(в случае успешного завершения). Группу операторов, окружённых командами BEGIN и COMMIT ино-
гда называют блоком транзакции.
Примечание
Некоторые клиентские библиотеки добавляют команды BEGIN и COMMIT автоматически
и неявно создают за вас блоки транзакций. Подробнее об этом вы можете узнать в
документации интересующего вас интерфейса.
Операторами в транзакции можно также управлять на более детальном уровне, используя точ-
ки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и
фиксировать все остальные. Определив точку сохранения с помощью SAVEPOINT, при необходимо-
сти вы можете вернуться к ней с помощью команды ROLLBACK TO. Все изменения в базе данных,
произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произ-
ведённые ранее, сохраняются.
Когда вы возвращаетесь к точке сохранения, она продолжает существовать, так что вы можете от-
катываться к ней несколько раз. С другой стороны, если вы уверены, что вам не придётся откаты-
ваться к определённой точке сохранения, её можно удалить, чтобы система высвободила ресурсы.
Помните, что при удалении или откате к точке сохранения все точки сохранения, определённые
после неё, автоматически уничтожаются.
Всё это происходит в блоке транзакции, так что в других сеансах работы с базой данных этого не
видно. Совершённые действия становятся видны для других сеансов все сразу, только когда вы
фиксируете транзакцию, а отменённые действия не видны вообще никогда.
Вернувшись к банковской базе данных, предположим, что мы списываем 100 долларов со счёта
Алисы, добавляем их на счёт Боба, и вдруг оказывается, что деньги нужно было перевести Уолли.
В данном случае мы можем применить точки сохранения:
BEGIN;
UPDATE accounts SET balance = balance
WHERE name = ‘Alice’;
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Bob’;
– ошибочное действие… забыть его и
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Wally’;
COMMIT;</p>
<ul>
  <li>100.00</li>
  <li>100.00
использовать счёт Уолли</li>
  <li>100.00
Этот пример, конечно, несколько надуман, но он показывает, как можно управлять выполнением
команд в блоке транзакций, используя точки сохранения. Более того, ROLLBACK TO — это един-
16Расширенные возможности
ственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии
из-за ошибки системы, не считая возможности полностью отменить её и начать снова.
3.5. Оконные функции
Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с теку-
щей строкой. Её действие можно сравнить с вычислением, производимым агрегатной функцией.
Однако с оконными функциями строки не группируются в одну выходную строку, что имеет место
с обычными, не оконными, агрегатными функциями. Вместо этого, эти строки остаются отдельны-
ми сущностями. Внутри же, оконная функция, как и агрегатная, может обращаться не только к
текущей строке результата запроса.
Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его
отдела:
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
FROM empsalary;
depname | empno | salary |
avg
———–+——-+——–+———————–
develop
|
11 |
5200 | 5020.0000000000000000
develop
|
7 |
4200 | 5020.0000000000000000
develop
|
9 |
4500 | 5020.0000000000000000
develop
|
8 |
6000 | 5020.0000000000000000
develop
|
10 |
5200 | 5020.0000000000000000
personnel |
5 |
3500 | 3700.0000000000000000
personnel |
2 |
3900 | 3700.0000000000000000
sales
|
3 |
4800 | 4866.6666666666666667
sales
|
1 |
5000 | 4866.6666666666666667
sales
|
4 |
4800 | 4866.6666666666666667
(10 rows)
Первые три столбца извлекаются непосредственно из таблицы empsalary, при этом для каждой
строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычис-
ленное по всем строкам, имеющим то же значение depname, что и текущая строка. (Фактически
среднее вычисляет та же обычная, не оконная функция avg, но предложение OVER превращает её
в оконную, так что её действие ограничивается рамками окон.)
Вызов оконной функции всегда содержит предложение OVER, следующее за названием и аргумен-
тами оконной функции. Это синтаксически отличает её от обычной, не оконной агрегатной функ-
ции. Предложение OVER определяет, как именно нужно разделить строки запроса для обработки
оконной функцией. Предложение PARTITION BY, дополняющее OVER, разделяет строки по группам,
или разделам, объединяя одинаковые значения выражений PARTITION BY. Оконная функция вы-
числяется по строкам, попадающим в один раздел с текущей строкой.
Вы можете также определять порядок, в котором строки будут обрабатываться оконными функци-
ями, используя ORDER BY в OVER. (Порядок ORDER BY для окна может даже не совпадать с порядком,
в котором выводятся строки.) Например:
SELECT depname, empno, salary,
rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
depname | empno | salary | rank
———–+——-+——–+——
develop
|
8 |
6000 |
1
develop
|
10 |
5200 |
2
develop
|
11 |
5200 |
2
develop
|
9 |
4500 |
4
develop
|
7 |
4200 |
5
17Расширенные возможности
personnel
personnel
sales
sales
sales
(10 rows)
|
|
|
|
|
2
5
1
4
3
|
|
|
|
|
3900
3500
5000
4800
4800
|
|
|
|
|
1
2
1
2
2
Как показано здесь, функция rank выдаёт порядковый номер для каждого уникального значения
в разделе текущей строки, по которому выполняет сортировку предложение ORDER BY. У функции
rank нет параметров, так как её поведение полностью определяется предложением OVER.
Строки, обрабатываемые оконной функцией, представляют собой «виртуальные таблицы», создан-
ные из предложения FROM и затем прошедшие через фильтрацию и группировку WHERE и GROUP BY
и, возможно, условие HAVING. Например, строка, отфильтрованная из-за нарушения условия WHERE,
не будет видна для оконных функций. Запрос может содержать несколько оконных функций, раз-
деляющих данные по-разному с применением разных предложений OVER, но все они будут обраба-
тывать один и тот же набор строк этой виртуальной таблицы.
Мы уже видели, что ORDER BY можно опустить, если порядок строк не важен. Также возможно
опустить PARTITION BY, в этом случае образуется один раздел, содержащий все строки.
Есть ещё одно важное понятие, связанное с оконными функциями: для каждой строки существует
набор строк в её разделе, называемый рамкой окна. Некоторые оконные функции обрабатывают
только строки рамки окна, а не всего раздела. По умолчанию с указанием ORDER BY рамка состоит
из всех строк от начала раздела до текущей строки и строк, равных текущей по значению выра-
1
жения ORDER BY. Без ORDER BY рамка по умолчанию состоит из всех строк раздела. Посмотрите
на пример использования sum:
SELECT salary, sum(salary) OVER () FROM empsalary;
salary | sum
——–+——-
5200 | 47100
5000 | 47100
3500 | 47100
4800 | 47100
3900 | 47100
4200 | 47100
4500 | 47100
4800 | 47100
6000 | 47100
5200 | 47100
(10 rows)
Так как в этом примере нет указания ORDER BY в предложении OVER, рамка окна содержит все
строки раздела, а он, в свою очередь, без предложения PARTITION BY включает все строки таблицы;
другими словами, сумма вычисляется по всей таблице и мы получаем один результат для каждой
строки результата. Но если мы добавим ORDER BY, мы получим совсем другие результаты:
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
salary | sum
——–+——-
3500 | 3500
3900 | 7400
4200 | 11600
4500 | 16100
4800 | 25700
1
Рамки окна можно определять и другими способами, но в этом введении они не рассматриваются. Узнать о них подробнее вы можете в Подразделе 4.2.8.
18Расширенные возможности
4800 |
5000 |
5200 |
5200 |
6000 |
(10 rows)
25700
30700
41100
41100
47100
Здесь в сумме накапливаются зарплаты от первой (самой низкой) до текущей, включая повторяю-
щиеся текущие значения (обратите внимание на результат в строках с одинаковой зарплатой).
Оконные функции разрешается использовать в запросе только в списке SELECT и предложении
ORDER BY. Во всех остальных предложениях, включая GROUP BY, HAVING и WHERE, они запрещены.
Это объясняется тем, что логически они выполняются после этих предложений, а также после
не оконных агрегатных функций, и значит агрегатную функцию можно вызывать в аргументах
оконной, но не наоборот.
Если вам нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы
можете использовать вложенный запрос. Например:
SELECT depname, empno, salary, enroll_date
FROM
(SELECT depname, empno, salary, enroll_date,
rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
FROM empsalary
) AS ss
WHERE pos &lt; 3;
Данный запрос покажет только те строки внутреннего запроса, у которых rank (порядковый номер)
меньше 3.
Когда в запросе вычисляются несколько оконных функций для одинаково определённых окон, ко-
нечно можно написать для каждой из них отдельное предложение OVER, но при этом оно будет
дублироваться, что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна
выделить в предложение WINDOW, а затем ссылаться на него в OVER. Например:
SELECT sum(salary) OVER w, avg(salary) OVER w
FROM empsalary
WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
Подробнее об оконных функциях можно узнать в Подразделе 4.2.8, Разделе 9.21, Подразделе 7.2.5
и в справке SELECT.
3.6. Наследование
Наследование — это концепция, взятая из объектно-ориентированных баз данных. Она открывает
множество интересных возможностей при проектировании баз данных.
Давайте создадим две таблицы: cities (города) и capitals (столицы штатов). Естественно, столи-
цы штатов также являются городами, поэтому нам нужно явным образом добавлять их в резуль-
тат, когда мы хотим просмотреть все города. Если вы проявите смекалку, вы можете предложить,
например, такое решение:
CREATE TABLE
name
population
altitude
state
);
capitals (
text,
real,
int,
– (высота в футах)
char(2)
CREATE TABLE non_capitals (
name
text,
19Расширенные возможности
population real,
altitude
int
– (высота в футах)
);
CREATE VIEW cities AS
SELECT name, population, altitude FROM capitals
UNION
SELECT name, population, altitude FROM non_capitals;
Оно может устраивать, пока мы извлекаем данные, но если нам потребуется изменить несколько
строк, это будет выглядеть некрасиво.
Поэтому есть лучшее решение:
CREATE TABLE
name
population
altitude
);
cities (
text,
real,
int
– (высота в футах)
CREATE TABLE capitals (
state
char(2)
) INHERITS (cities);
В данном случае строка таблицы capitals наследует все столбцы (name, population и altitude)
от родительской таблицы cities. Столбец name имеет тип text, собственный тип PostgreSQL для
текстовых строк переменной длины. А в таблицу столиц добавлен дополнительный столбец state,
в котором будет указан штат. В PostgreSQL таблица может наследоваться от нуля или нескольких
других таблиц.
Например, следующий запрос выведет названия всех городов, включая столицы, находящихся вы-
ше 500 футов над уровнем моря:
SELECT name, altitude
FROM cities
WHERE altitude &gt; 500;
Результат его выполнения:
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Madison
|
845
(3 rows)
А следующий запрос находит все города, которые не являются столицами штатов, но также нахо-
дятся выше 500 футов:
SELECT name, altitude
FROM ONLY cities
WHERE altitude &gt; 500;
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
(2 rows)
Здесь слово ONLY перед названием таблицы cities указывает, что запрос следует выполнять только
для строк таблицы cities, не включая таблицы, унаследованные от cities. Многие операторы,
которые мы уже обсудили — SELECT, UPDATE и DELETE — поддерживают указание ONLY.
20Расширенные возможности
Примечание
Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уни-
кальности и внешними ключами, что ограничивает его применимость. Подробнее это
описывается в Разделе 5.9.
3.7. Заключение
PostgreSQL имеет множество возможностей, не затронутых в этом кратком введении, рассчитан-
ном на начинающих пользователей SQL. Эти возможности будут рассмотрены в деталях в продол-
жении книги.
Если вам необходима дополнительная вводная информация, посетите сайт PostgreSQL, там вы
найдёте ссылки на другие ресурсы.
21</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-002/" title="Глава 2. Язык SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 2. Язык SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-002/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-002/" rel="bookmark" title="Глава 2. Язык SQL" itemprop="url">Глава 2. Язык SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 2. Язык SQL</p>

<p>2.1. Введение</p>

<p>В этой главе рассматривается использование SQL для выполнения простых операций. Она призва-
на только познакомить вас с SQL, но ни в коей мере не претендует на исчерпывающее руководство.
Про SQL написано множество книг, включая melt93 и date97. При этом следует учитывать, что
некоторые возможности языка PostgreSQL являются расширениями стандарта.
В следующих примерах мы предполагаем, что вы создали базу данных mydb, как описано в преды-
дущей главе, и смогли запустить psql.
Примеры этого руководства также можно найти в пакете исходного кода PostgreSQL в каталоге
src/tutorial/. (Двоичные дистрибутивы PostgreSQL могут не включать эти файлы.) Чтобы исполь-
зовать эти файлы, перейдите в этот каталог и запустите make:
$ cd …./src/tutorial
$ make
При этом будут созданы скрипты и скомпилированы модули C, содержащие пользовательские
функции и типы. Затем, чтобы начать работу с учебным материалом, выполните следующее:
$ cd …./tutorial
$ psql -s mydb
…
mydb=&gt; \i basics.sql
Команда \i считывает и выполняет команды из заданного файла. Переданный psql параметр -
s переводит его в пошаговый режим, когда он делает паузу перед отправкой каждого оператора
серверу. Команды, используемые в этом разделе, содержатся в файле basics.sql.
2.2. Основные понятия
PostgreSQL — это реляционная система управления базами данных (РСУБД). Это означает, что
это система управления данными, представленными в виде отношений (relation). Отношение —
это математически точное обозначение таблицы. Хранение данных в таблицах так распростране-
но сегодня, что это кажется самым очевидным вариантом, хотя есть множество других способов
организации баз данных. Например, файлы и каталоги в Unix-подобных операционных системах
образуют иерархическую базу данных, а сегодня активно развиваются объектно-ориентированные
базы данных.
Любая таблица представляет собой именованный набор строк. Все строки таблицы имеют одина-
ковый набор именованных столбцов, при этом каждому столбцу назначается определённый тип
данных. Хотя порядок столбцов во всех строках фиксирован, важно помнить, что SQL не гаранти-
рует какой-либо порядок строк в таблице (хотя их можно явно отсортировать при выводе).
Таблицы объединяются в базы данных, а набор баз данных, управляемый одним экземпляром сер-
вера PostgreSQL, образует кластер баз данных.
2.3. Создание таблицы
Вы можете создать таблицу, указав её имя и перечислив все имена столбцов и их типы:
CREATE TABLE weather (
city
varchar(80),
temp_lo
int,
temp_hi
int,
– минимальная температура дня
– максимальная температура дня
6Язык SQL
prcp
date
real,
date
– уровень осадков
);
Весь этот текст можно ввести в psql вместе с символами перевода строк. psql понимает, что ко-
манда продолжается до точки с запятой.
В командах SQL можно свободно использовать пробельные символы (пробелы, табуляции и пере-
воды строк). Это значит, что вы можете ввести команду, выровняв её по-другому или даже уместив
в одной строке. Два минуса («–») обозначают начало комментария. Всё, что идёт за ними до конца
строки, игнорируется. SQL не чувствителен к регистру в ключевых словах и идентификаторах, за
исключением идентификаторов, взятых в кавычки (в данном случае это не так).
varchar(80) определяет тип данных, допускающий хранение произвольных символьных строк дли-
ной до 80 символов. int — обычный целочисленный тип. real — тип для хранения чисел с плаваю-
щей точкой одинарной точности. date — тип даты. (Да, столбец типа date также называется date.
Это может быть удобно или вводить в заблуждение — как посмотреть.)
PostgreSQL поддерживает стандартные типы SQL: int, smallint, real, double precision, char(N),
varchar(N), date, time, timestamp и interval, а также другие универсальные типы и богатый набор
геометрических типов. Кроме того, PostgreSQL можно расширять, создавая набор собственных ти-
пов данных. Как следствие, имена типов не являются ключевыми словами в данной записи, кроме
тех случаев, когда это требуется для реализации особых конструкций стандарта SQL.
Во втором примере мы сохраним в таблице города и их географическое положение:
CREATE TABLE cities (
name
varchar(80),
location
point
);
Здесь point — пример специфического типа данных PostgreSQL.
Наконец, следует сказать, что если вам больше не нужна какая-либо таблица, или вы хотите пере-
создать её по-другому, вы можете удалить её, используя следующую команду:
DROP TABLE имя_таблицы;
2.4. Добавление строк в таблицу
Для добавления строк в таблицу используется оператор INSERT:
INSERT INTO weather VALUES (‘San Francisco’, 46, 50, 0.25, ‘1994-11-27’);
Заметьте, что для всех типов данных применяются довольно очевидные форматы. Константы, за
исключением простых числовых значений, обычно заключаются в апострофы (‘), как в данном
примере. Тип date на самом деле очень гибок и принимает разные форматы, но в данном введении
мы будем придерживаться простого и однозначного.
Тип point требует ввода пары координат, например таким образом:
INSERT INTO cities VALUES (‘San Francisco’, ‘(-194.0, 53.0)’);
Показанный здесь синтаксис требует, чтобы вы запомнили порядок столбцов. Можно также при-
менить альтернативную запись, перечислив столбцы явно:
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
VALUES (‘San Francisco’, 43, 57, 0.0, ‘1994-11-29’);
Вы можете перечислить столбцы в другом порядке, если желаете опустить некоторые из них, на-
пример, если уровень осадков (столбец prcp) неизвестен:
INSERT INTO weather (date, city, temp_hi, temp_lo)
VALUES (‘1994-11-29’, ‘Hayward’, 54, 37);
7Язык SQL
Многие разработчики предпочитают явно перечислять столбцы, а не полагаться на их порядок в
таблице.
Пожалуйста, введите все показанные выше команды, чтобы у вас были данные, с которыми можно
будет работать дальше.
Вы также можете загрузить большой объём данных из обычных текстовых файлов, применив ко-
манду COPY. Обычно это будет быстрее, так как команда COPY оптимизирована для такого приме-
нения, хотя и менее гибка, чем INSERT. Например, её можно использовать так:
COPY weather FROM ‘/home/user/weather.txt’;
здесь подразумевается, что данный файл доступен на компьютере, где работает серверный про-
цесс, а не на клиенте, так как указанный файл будет прочитан непосредственно на сервере. По-
дробнее об этом вы можете узнать в описании команды COPY.
2.5. Выполнение запроса
Чтобы получить данные из таблицы, нужно выполнить запрос. Для этого предназначен SQL-опе-
ратор SELECT. Он состоит из нескольких частей: выборки (в которой перечисляются столбцы, ко-
торые должны быть получены), списка таблиц (в нём перечисляются таблицы, из которых будут
получены данные) и необязательного условия (определяющего ограничения). Например, чтобы
получить все строки таблицы weather, введите:
SELECT * FROM weather;
Здесь * — это краткое обозначение «всех столбцов».
1
Таким образом, это равносильно записи:
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
В результате должно получиться:
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
43 |
57 |
0 | 1994-11-29
Hayward
|
37 |
54 |
| 1994-11-29
(3 rows)
В списке выборки вы можете писать не только ссылки на столбцы, но и выражения. Например,
вы можете написать:
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
И получить в результате:
city
| temp_avg |
date
—————+———-+————
San Francisco |
48 | 1994-11-27
San Francisco |
50 | 1994-11-29
Hayward
|
45 | 1994-11-29
(3 rows)
Обратите внимание, как предложение AS позволяет переименовать выходной столбец. (Само слово
AS можно опускать.)
Запрос можно дополнить «условием», добавив предложение WHERE, ограничивающее множество
возвращаемых строк. В предложении WHERE указывается логическое выражение (проверка истин-
ности), которое служит фильтром строк: в результате оказываются только те строки, для которых
это выражение истинно. В этом выражении могут присутствовать обычные логические операто-
ры (AND, OR и NOT). Например, следующий запрос покажет, какая погода была в Сан-Франциско в
дождливые дни:
1
Хотя запросы SELECT * часто пишут экспромтом, это считается плохим стилем в производственном коде, так как результат таких запросов будет меняться
при добавлении новых столбцов.
8Язык SQL
SELECT * FROM weather
WHERE city = ‘San Francisco’ AND prcp &gt; 0.0;
Результат:
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
(1 row)
Вы можете получить результаты запроса в определённом порядке:
SELECT * FROM weather
ORDER BY city;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
Hayward
|
37 |
54 |
| 1994-11-29
San Francisco |
43 |
57 |
0 | 1994-11-29
San Francisco |
46 |
50 | 0.25 | 1994-11-27
В этом примере порядок сортировки определён не полностью, поэтому вы можете получить стро-
ки Сан-Франциско в любом порядке. Но вы всегда получите результат, показанный выше, если
напишете:
SELECT * FROM weather
ORDER BY city, temp_lo;
Если требуется, вы можете убрать дублирующиеся строки из результата запроса:
SELECT DISTINCT city
FROM weather;
city
—————
Hayward
San Francisco
(2 rows)
И здесь порядок строк также может варьироваться. Чтобы получать неизменные результаты, со-
2
едините предложения DISTINCT и ORDER BY:
SELECT DISTINCT city
FROM weather
ORDER BY city;
2.6. Соединения таблиц
До этого все наши запросы обращались только к одной таблице. Однако запросы могут также об-
ращаться сразу к нескольким таблицам или обращаться к той же таблице так, что одновременно
будут обрабатываться разные наборы её строк. Запрос, обращающийся к разным наборам строк
одной или нескольких таблиц, называется соединением (JOIN). Например, мы захотели перечис-
лить все погодные события вместе с координатами соответствующих городов. Для этого мы долж-
ны сравнить столбец city каждой строки таблицы weather со столбцом name всех строк таблицы
cities и выбрать пары строк, для которых эти значения совпадают.
Примечание
Это не совсем точная модель. Обычно соединения выполняются эффективнее (сравни-
ваются не все возможные пары строк), но это скрыто от пользователя.
2
В некоторых СУБД, включая старые версии PostgreSQL, реализация предложения DISTINCT автоматически упорядочивает строки, так что ORDER BY добав-
лять не обязательно. Но стандарт SQL этого не требует и текущая версия PostgreSQL не гарантирует определённого порядка строк после DISTINCT.
9Язык SQL
Это можно сделать с помощью следующего запроса:
SELECT *
FROM weather, cities
WHERE city = name;
city
|temp_lo|temp_hi| prcp|
date
|
name
| location
————–+——-+——-+—–+———–+————–+———-
San Francisco|
46|
50| 0.25| 1994-11-27| San Francisco| (-194,53)
San Francisco|
43|
57|
0| 1994-11-29| San Francisco| (-194,53)
(2 rows)
Обратите внимание на две особенности полученных данных:
• В результате нет строки с городом Хейуорд (Hayward). Так получилось потому, что в таблице
cities нет строки для данного города, а при соединении все строки таблицы weather, для ко-
торых не нашлось соответствие, опускаются. Вскоре мы увидим, как это можно исправить.
• Название города оказалось в двух столбцах. Это правильно и объясняется тем, что столбцы
таблиц weather и cities были объединены. Хотя на практике это нежелательно, поэтому луч-
ше перечислить нужные столбцы явно, а не использовать *:
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
Упражнение:
Попробуйте определить, что будет делать этот запрос без предложения WHERE.
Так как все столбцы имеют разные имена, анализатор запроса автоматически понимает, к какой
таблице они относятся. Если бы имена столбцов в двух таблицах повторялись, вам пришлось бы
дополнить имена столбцов, конкретизируя, что именно вы имели в виду:
SELECT weather.city, weather.temp_lo, weather.temp_hi,
weather.prcp, weather.date, cities.location
FROM weather, cities
WHERE cities.name = weather.city;
Вообще хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтобы
запрос не поломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.
Запросы соединения, которые вы видели до этого, можно также записать в другом виде:
SELECT *
FROM weather INNER JOIN cities ON (weather.city = cities.name);
Эта запись не так распространена, как первый вариант, но мы показываем её, чтобы вам было
проще понять следующие темы.
Сейчас мы выясним, как вернуть записи о погоде в городе Хейуорд. Мы хотим, чтобы запрос про-
сканировал таблицу weather и для каждой её строки нашёл соответствующую строку в таблице
cities. Если же такая строка не будет найдена, мы хотим, чтобы вместо значений столбцов из таб-
лицы cities были подставлены «пустые значения». Запросы такого типа называются внешними
соединениями. (Соединения, которые мы видели до этого, называются внутренними.) Эта команда
будет выглядеть так:
SELECT *
FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);
city
|temp_lo|temp_hi| prcp|
date
|
name
| location
————–+——-+——-+—–+———–+————–+———-
Hayward
|
37|
54|
| 1994-11-29|
|
San Francisco|
46|
50| 0.25| 1994-11-27| San Francisco| (-194,53)
San Francisco|
43|
57|
0| 1994-11-29| San Francisco| (-194,53)
(3 rows)
10Язык SQL
Этот запрос называется левым внешним соединением, потому что из таблицы в левой части опе-
ратора будут выбраны все строки, а из таблицы справа только те, которые удалось сопоставить
каким-нибудь строкам из левой. При выводе строк левой таблицы, для которых не удалось найти
соответствия в правой, вместо столбцов правой таблицы подставляются пустые значения (NULL).
Упражнение:  Существуют также правые внешние соединения и полные внешние соединения.
Попробуйте выяснить, что они собой представляют.
В соединении мы также можем замкнуть таблицу на себя. Это называется замкнутым соединени-
ем. Например, представьте, что мы хотим найти все записи погоды, в которых температура лежит в
диапазоне температур других записей. Для этого мы должны сравнить столбцы temp_lo и temp_hi
каждой строки таблицы weather со столбцами temp_lo и temp_hi другого набора строк weather.
Это можно сделать с помощью следующего запроса:
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
W2.city, W2.temp_lo AS low, W2.temp_hi AS high
FROM weather W1, weather W2
WHERE W1.temp_lo &lt; W2.temp_lo
AND W1.temp_hi &gt; W2.temp_hi;
city
| low | high |
city
| low | high
—————+—–+——+—————+—–+——
San Francisco | 43 |
57 | San Francisco | 46 |
50
Hayward
| 37 |
54 | San Francisco | 46 |
50
(2 rows)
Здесь мы ввели новые обозначения таблицы weather: W1 и W2, чтобы можно было различить левую
и правую стороны соединения. Вы можете использовать подобные псевдонимы и в других запросах
для сокращения:
SELECT *
FROM weather w, cities c
WHERE w.city = c.name;
Вы будете встречать сокращения такого рода довольно часто.
2.7. Агрегатные функции
Как большинство других серверов реляционных баз данных, PostgreSQL поддерживает агрегатные
функции. Агрегатная функция вычисляет единственное значение, обрабатывая множество строк.
Например, есть агрегатные функции, вычисляющие: count (количество), sum (сумму), avg (сред-
нее), max (максимум) и min (минимум) для набора строк.
К примеру, мы можем найти самую высокую из всех минимальных дневных температур:
SELECT max(temp_lo) FROM weather;
max
—–
46
(1 row)
Если мы хотим узнать, в каком городе (или городах) наблюдалась эта температура, можно попро-
бовать:
SELECT city FROM weather WHERE temp_lo = max(temp_lo);
НЕВЕРНО
но это не будет работать, так как агрегатную функцию max нельзя использовать в предложении
WHERE. (Это ограничение объясняется тем, что предложение WHERE должно определить, для каких
строк вычислять агрегатную функцию, так что оно, очевидно, должно вычисляться до агрегатных
функций.) Однако, как часто бывает, запрос можно перезапустить и получить желаемый резуль-
тат, применив подзапрос:
SELECT city FROM weather
11Язык SQL
WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
city
—————
San Francisco
(1 row)
Теперь всё в порядке — подзапрос выполняется отдельно и результат агрегатной функции вычис-
ляется вне зависимости от того, что происходит во внешнем запросе.
Агрегатные функции также очень полезны в сочетании с предложением GROUP BY. Например, мы
можем получить максимум минимальной дневной температуры в разрезе городов:
SELECT city, max(temp_lo)
FROM weather
GROUP BY city;
city
| max
—————+—–
Hayward
| 37
San Francisco | 46
(2 rows)
Здесь мы получаем по одной строке для каждого города. Каждый агрегатный результат вычисля-
ется по строкам таблицы, соответствующим отдельному городу. Мы можем отфильтровать сгруп-
пированные строки с помощью предложения HAVING:
SELECT city, max(temp_lo)
FROM weather
GROUP BY city
HAVING max(temp_lo) &lt; 40;
city
| max
———+—–
Hayward | 37
(1 row)
Мы получаем те же результаты, но только для тех городов, где все значения temp_lo меньше 40.
Наконец, если нас интересуют только города, названия которых начинаются с «S», мы можем сде-
лать:
SELECT city, max(temp_lo)
FROM weather
WHERE city LIKE ‘S%’
GROUP BY city
HAVING max(temp_lo) &lt; 40;
1
–
1
Оператор LIKE (выполняющий сравнение по шаблону) рассматривается в Разделе 9.7.
Важно понимать, как соотносятся агрегатные функции и SQL-предложения WHERE и HAVING. Основ-
ное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем груп-
пирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления
агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных
функций. Как следствие, предложение WHERE не должно содержать агрегатных функций; не име-
ет смысла использовать агрегатные функции для определения строк для вычисления агрегатных
функций. Предложение HAVING, напротив, всегда содержит агрегатные функции. (Строго говоря,
вы можете написать предложение HAVING, не используя агрегаты, но это редко бывает полезно. То
же самое условие может работать более эффективно на стадии WHERE.)
В предыдущем примере мы смогли применить фильтр по названию города в предложении WHERE,
так как названия не нужно агрегировать. Такой фильтр эффективнее, чем дополнительное ограни-
чение HAVING, потому что с ним не приходится группировать и вычислять агрегаты для всех строк,
не удовлетворяющих условию WHERE.
12Язык SQL
2.8. Изменение данных
Данные в существующих строках можно изменять, используя команду UPDATE. Например, предпо-
ложим, что вы обнаружили, что все значения температуры после 28 ноября завышены на два гра-
дуса. Вы можете поправить ваши данные следующим образом:
UPDATE weather
SET temp_hi = temp_hi - 2,
WHERE date &gt; ‘1994-11-28’;
temp_lo = temp_lo - 2
Посмотрите на новое состояние данных:
SELECT * FROM weather;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
41 |
55 |
0 | 1994-11-29
Hayward
|
35 |
52 |
| 1994-11-29
(3 rows)
2.9. Удаление данных
Строки также можно удалить из таблицы, используя команду DELETE. Предположим, что вас боль-
ше не интересует погода в Хейуорде. В этом случае вы можете удалить ненужные строки из таб-
лицы:
DELETE FROM weather WHERE city = ‘Hayward’;
Записи всех наблюдений, относящиеся к Хейуорду, удалены.
SELECT * FROM weather;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
41 |
55 |
0 | 1994-11-29
(2 rows)
Остерегайтесь операторов вида
DELETE FROM имя_таблицы;
Без указания условия DELETE удалит все строки данной таблицы, полностью очистит её. При этом
система не попросит вас подтвердить операцию!</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-001/" title="Глава 1. Начало"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 1. Начало"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-001/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-001/" rel="bookmark" title="Глава 1. Начало" itemprop="url">Глава 1. Начало</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 1. Начало</p>

<p>1.1. Установка</p>

<p>Прежде чем вы сможете использовать PostgreSQL, вы конечно должны его установить. Однако
возможно, что PostgreSQL уже установлен у вас, либо потому что он включён в вашу операцион-
ную систему, либо его установил системный администратор. Если это так, обратитесь к докумен-
тации по операционной системе или к вашему администратору и узнайте, как получить доступ к
PostgreSQL.
Если же вы не знаете, установлен ли PostgreSQL или можно ли использовать его для эксперимен-
тов, тогда просто установите его сами. Сделать это несложно и это будет хорошим упражнением.
PostgreSQL может установить любой обычный пользователь; права суперпользователя (root) не
требуются.
Если вы устанавливаете PostgreSQL самостоятельно, обратитесь к Главе 16 за инструкциями по
установке, а закончив установку, вернитесь к этому введению. Обязательно прочитайте и выпол-
ните указания по установке соответствующих переменных окружения.
Если ваш администратор выполнил установку не с параметрами по умолчанию, вам может потре-
боваться проделать дополнительную работу. Например, если сервер баз данных установлен на уда-
лённом компьютере, вам нужно будет указать в переменной окружения PGHOST имя этого компью-
тера. Вероятно, также придётся установить переменную окружения PGPORT. То есть, если вы пыта-
етесь запустить клиентское приложение и оно сообщает, что не может подключиться к базе дан-
ных, вы должны обратиться к вашему администратору. Если это вы сами, вам следует обратиться к
документации и убедиться в правильности настройки окружения. Если вы не поняли, о чём здесь
идёт речь, перейдите к следующему разделу.
1.2. Основы архитектуры
Прежде чем продолжить, вы должны разобраться в основах архитектуры системы PostgreSQL. Со-
ставив картину взаимодействия частей PostgreSQL, вы сможете лучше понять материал этой гла-
вы.
Говоря техническим языком, PostgreSQL реализован в архитектуре клиент-сервер. Рабочий сеанс
PostgreSQL включает следующие взаимодействующие процессы (программы):
• Главный серверный процесс, управляющий файлами баз данных, принимающий подключения
клиентских приложений и выполняющий различные запросы клиентов к базам данных. Эта
программа сервера БД называется postgres.
• Клиентское приложение пользователя, желающее выполнять операции в базе данных. Кли-
ентские приложения могут быть очень разнообразными: это может быть текстовая утилита,
графическое приложение, веб-сервер, использующий базу данных для отображения веб-стра-
ниц, или специализированный инструмент для обслуживания БД. Некоторые клиентские при-
ложения поставляются в составе дистрибутива PostgreSQL, однако большинство создают сто-
ронние разработчики.
Как и в других типичных клиент-серверных приложениях, клиент и сервер могут располагаться
на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP. Важно не забывать
это и понимать, что файлы, доступные на клиентском компьютере, могут быть недоступны (или
доступны только под другим именем) на компьютере-сервере.
Сервер PostgreSQL может обслуживать одновременно несколько подключений клиентов. Для это-
го он запускает («порождает») отдельный процесс для каждого подключения. Можно сказать, что
клиент и серверный процесс общаются, не затрагивая главный процесс postgres. Таким образом,
главный серверный процесс всегда работает и ожидает подключения клиентов, принимая кото-
рые, он организует взаимодействие клиента и отдельного серверного процесса. (Конечно всё это
2Начало
происходит незаметно для пользователя, а эта схема рассматривается здесь только для понима-
ния.)
1.3. Создание базы данных
Первое, как можно проверить, есть ли у вас доступ к серверу баз данных, — это попытаться создать
базу данных. Работающий сервер PostgreSQL может управлять множеством баз данных, что поз-
воляет создавать отдельные базы данных для разных проектов и пользователей.
Возможно, ваш администратор уже создал базу данных для вас. В этом случае вы можете пропу-
стить этот этап и перейти к следующему разделу.
Для создания базы данных, в этом примере названной mydb, выполните следующую команду:
$ createdb mydb
Если вы не увидите никаких сообщений, значит операция была выполнена успешно и продолжение
этого раздела можно пропустить.
Если вы видите сообщение типа:
createdb: command not found
значит PostgreSQL не был установлен правильно. Либо он не установлен вообще, либо в путь по-
иска команд оболочки не включён его каталог. Попробуйте вызвать ту же команду, указав абсо-
лютный путь:
$ /usr/local/pgsql/bin/createdb mydb
У вас этот путь может быть другим. Свяжитесь с вашим администратором или проверьте, как были
выполнены инструкции по установке, чтобы исправить ситуацию.
Ещё один возможный ответ:
createdb: не удалось подключиться к базе postgres:
не удалось подключиться к серверу: No such file or directory
Он действительно работает локально и принимает
соединения через Unix-сокет “/tmp/.s.PGSQL.5432”?
Это означает, что сервер не работает или createdb не может к нему подключиться. И в этом случае
пересмотрите инструкции по установке или обратитесь к администратору.
Также вы можете получить сообщение:
createdb: не удалось подключиться к базе postgres:
ВАЖНО: роль “joe” не существует
где фигурирует ваше имя пользователя. Это говорит о том, что администратор не создал учётную
запись PostgreSQL для вас. (Учётные записи PostgreSQL отличаются от учётных записей пользо-
вателей операционной системы.) Если вы сами являетесь администратором, прочитайте Главу 21,
где написано, как создавать учётные записи. Для создания нового пользователя вы должны стать
пользователем операционной системы, под именем которого был установлен PostgreSQL (обычно
это postgres). Также возможно, что вам назначено имя пользователя PostgreSQL, не совпадающее
с вашим именем в ОС; в этом случае вам нужно явно указать ваше имя пользователя PostgreSQL,
используя ключ -U или установив переменную окружения PGUSER.
Если у вас есть учётная запись пользователя, но нет прав на создание базы данных, вы увидите
сообщение:
createdb: создать базу данных не удалось:
ОШИБКА: нет прав на создание базы данных
Создавать базы данных разрешено не всем пользователям. Если PostgreSQL отказывается созда-
вать базы данных для вас, значит вам необходимо соответствующее разрешение. В этом случае
3Начало
обратитесь к вашему администратору. Если вы устанавливали PostgreSQL сами, то для целей этого
1
введения вы должны войти в систему с именем пользователя, запускающего сервер БД.
Вы также можете создавать базы данных с другими именами. PostgreSQL позволяет создавать
сколько угодно баз данных. Имена баз данных должны начинаться с буквы и быть не длиннее 63
символов. В качестве имени базы данных удобно использовать ваше текущее имя пользователя.
Многие утилиты предполагают такое имя по умолчанию, так что вы сможете упростить ввод ко-
манд. Чтобы создать базу данных с таким именем, просто введите:
$ createdb
Если вы больше не хотите использовать вашу базу данных, вы можете удалить её. Например, ес-
ли вы владелец (создатель) базы данных mydb, вы можете уничтожить её, выполнив следующую
команду:
$ dropdb mydb
(Эта команда не считает именем БД по умолчанию имя текущего пользователя, вы должны явно
указать его.) В результате будут физически удалены все файлы, связанные с базой данных, и так
как отменить это действие нельзя, не выполняйте его, не подумав о последствиях.
Узнать о командах createdb и dropdb больше можно в справке createdb и dropdb.
1.4. Подключение к базе данных
Создав базу данных, вы можете обратиться к ней:
• Запустив терминальную программу PostgreSQL под названием psql, в которой можно интерак-
тивно вводить, редактировать и выполнять команды SQL.
• Используя существующие графические инструменты, например, pgAdmin или офисный пакет
с поддержкой ODBC или JDBC, позволяющий создавать и управлять базой данных. Эти воз-
можности здесь не рассматриваются.
• Написав собственное приложение, используя один из множества доступных языковых интер-
фейсов. Подробнее это рассматривается в Части IV.
Чтобы работать с примерами этого введения, начните с psql. Подключиться с его помощью к базе
данных mydb можно, введя команду:
$ psql mydb
Если имя базы данных не указать, она будет выбрана по имени пользователя. Об этом уже расска-
зывалось в предыдущем разделе, посвящённом команде createdb.
В psql вы увидите следующее сообщение:
psql (11.1)
Type “help” for help.
mydb=&gt;
Последняя строка может выглядеть и так:
mydb=#
Что показывает, что вы являетесь суперпользователем, и так скорее всего будет, если вы уста-
навливали экземпляр PostgreSQL сами. В этом случае на вас не будут распространяться никакие
ограничения доступа, но для целей данного введения это не важно.
Если вы столкнулись с проблемами при запуске psql, вернитесь к предыдущему разделу. Команды
createdb и psql подключаются к серверу одинаково, так что если первая работает, должна рабо-
тать и вторая.
1
Объяснить это поведение можно так: Учётные записи пользователей PostgreSQL отличаются от учётных записей операционной системы. При подключении
к базе данных вы можете указать, с каким именем пользователя PostgreSQL нужно подключаться. По умолчанию же используется имя, с которым вы
зарегистрированы в операционной системе. При этом получается, что в PostgreSQL всегда есть учётная запись с именем, совпадающим с именем системного
пользователя, запускающего сервер, и к тому же этот пользователь всегда имеет права на создание баз данных. И чтобы подключиться с именем этого
пользователя PostgreSQL, необязательно входить с этим именем в систему, достаточно везде передавать его с параметром -U.
4Начало
Последняя строка в выводе psql — это приглашение, которое показывает, что psql ждёт ваших
команд и вы можете вводить SQL-запросы в рабочей среде psql. Попробуйте эти команды:
mydb=&gt; SELECT version();
version
——————————————————————————————
PostgreSQL 11.1 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-
bit
(1 row)
mydb=&gt; SELECT current_date;
date
————
2016-01-07
(1 row)
mydb=&gt; SELECT 2 + 2;
?column?
———-
4
(1 row)
В программе psql есть множество внутренних команд, которые не являются SQL-операторами. Они
начинаются с обратной косой черты, «\». Например, вы можете получить справку по различным
SQL-командам PostgreSQL, введя:
mydb=&gt; \h
Чтобы выйти из psql, введите:
mydb=&gt; \q
и psql завершит свою работу, а вы вернётесь в командную оболочку операционной системы. (Что-
бы узнать о внутренних командах, введите \? в приглашении командной строки psql.) Все возмож-
ности psql документированы в справке psql. В этом руководстве мы не будем использовать эти
возможности явно, но вы можете изучить их и применять при удобном случае.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page25/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page24/">24</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page25/">25</a></li>
      
    
      
        <li><strong class="current-page">26</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page27/">27</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page28/">28</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page27/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>