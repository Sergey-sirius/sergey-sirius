<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page26/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page26/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-004/" title="Глава 4. Синтаксис SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 4. Синтаксис SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-004/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~46 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-004/" rel="bookmark" title="Глава 4. Синтаксис SQL" itemprop="url">Глава 4. Синтаксис SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 4. Синтаксис SQL</p>

<p>В этой главе описывается синтаксис языка SQL. Тем самым закладывается фундамент для следу-
ющих глав, где будет подробно рассмотрено, как с помощью команд SQL описывать и изменять
данные.
Мы советуем прочитать эту главу и тем, кто уже знаком SQL, так как в ней описываются несколько
правил и концепций, которые реализованы в разных базах данных SQL по-разному или относятся
только к PostgreSQL.
4.1. Лексическая структура
SQL-программа состоит из последовательности команд. Команда, в свою очередь, представляет
собой последовательность компонентов, оканчивающуюся точкой с запятой («;»). Конец входного
потока также считается концом команды. Какие именно компоненты допустимы для конкретной
команды, зависит от её синтаксиса.
Компонентом команды может быть ключевое слово, идентификатор, идентификатор в кавычках,
строка (или константа) или специальный символ. Компоненты обычно разделяются пробельными
символами (пробел, табуляция, перевод строки), но это не требуется, если нет неоднозначности
(например, когда спецсимвол оказывается рядом с компонентом другого типа).
Например, следующий текст является правильной (синтаксически) SQL-программой:
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, ‘hi there’);
Это последовательность трёх команд, по одной в строке (хотя их можно было разместить и в одну
строку или наоборот, разделить команды на несколько строк).
Кроме этого, SQL-программы могут содержать комментарии. Они не являются компонентами ко-
манд, а по сути равносильны пробельным символам.
Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют команды, а какие
— их операнды или параметры. Первые несколько компонентов обычно содержат имя команды,
так что в данном примере мы можем говорить о командах «SELECT», «UPDATE» и «INSERT». Но
например, команда UPDATE требует, чтобы также в определённом положении всегда стоял компо-
нент SET, а INSERT в приведённом виде требует наличия компонента VALUES. Точные синтаксиче-
ские правила для каждой команды описаны в Части VI.
4.1.1. Идентификаторы и ключевые слова
Показанные выше команды содержали компоненты SELECT, UPDATE и VALUES, которые являются
примерами ключевых слов, то есть слов, имеющих фиксированное значение в языке SQL. Компо-
ненты MY_TABLE и A являются примерами идентификаторов. Они идентифицируют имена таблиц,
столбцов или других объектов баз данных, в зависимости от того, где они используются. Поэтому
иногда их называют просто «именами». Ключевые слова и идентификаторы имеют одинаковую
лексическую структуру, то есть, не зная языка, нельзя определить, является ли некоторый ком-
понент ключевым словом или идентификатором. Полный список ключевых слов приведён в При-
ложении C.
Идентификаторы и ключевые слова SQL должны начинаться с буквы (a-z, хотя допускаются также
не латинские буквы и буквы с диакритическими знаками) или подчёркивания (_). Последующими
символами в идентификаторе или ключевом слове могут быть буквы, цифры (0-9), знаки доллара
($) или подчёркивания. Заметьте, что строго следуя букве стандарта SQL, знаки доллара нельзя
использовать в идентификаторах, так что их использование вредит переносимости приложений.
В стандарте SQL гарантированно не будет ключевых слов с цифрами и начинающихся или закан-
чивающихся подчёркиванием, так что идентификаторы такого вида защищены от возможных кон-
фликтов с будущими расширениями стандарта.
23Синтаксис SQL
Система выделяет для идентификатора не более NAMEDATALEN-1 байт, а более длинные имена усека-
ются. По умолчанию NAMEDATALEN равно 64, так что максимальная длина идентификатора равна 63
байтам. Если этого недостаточно, этот предел можно увеличить, изменив константу NAMEDATALEN
в файле src/include/pg_config_manual.h.
Ключевые слова и идентификаторы без кавычек воспринимаются системой без учёта регистра.
Таким образом:
UPDATE MY_TABLE SET A = 5;
равносильно записи:
uPDaTE my_TabLE SeT a = 5;
Часто используется неформальное соглашение записывать ключевые слова заглавными буквами,
а имена строчными, например:
UPDATE my_table SET a = 5;
Есть и другой тип идентификаторов: отделённые идентификаторы или идентификаторы в ка-
вычках. Они образуются при заключении обычного набора символов в двойные кавычки (“). Та-
кие идентификаторы всегда будут считаться идентификаторами, но не ключевыми словами. Так
“select” можно использовать для обозначения столбца или таблицы «select», тогда как select
без кавычек будет воспринят как ключевое слово и приведёт к ошибке разбора команды в месте,
где ожидается имя таблицы или столбца. Тот же пример можно переписать с идентификаторами
в кавычках следующим образом:
UPDATE “my_table” SET “a” = 5;
Идентификаторы в кавычках могут содержать любые символы, за исключением символа с кодом</p>
<ol>
  <li>(Чтобы включить в такой идентификатор кавычки, продублируйте их.) Это позволяет создавать
таблицы и столбцы с именами, которые иначе были бы невозможны, например, с пробелами или
амперсандами. Ограничение длины при этом сохраняется.
Ещё один вариант идентификаторов в кавычках позволяет использовать символы Unicode по их
кодам. Такой идентификатор начинается с U&amp; (строчная или заглавная U и амперсанд), а затем
сразу без пробелов идёт двойная кавычка, например U&amp;”foo”. (Заметьте, что при этом возникает
неоднозначность с оператором &amp;. Чтобы её избежать, окружайте этот оператор пробелами.) Затем
в кавычках можно записывать символы Unicode двумя способами: обратная косая черта, а за ней
код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем
код из шести шестнадцатеричных цифр. Например, идентификатор “data” можно записать так:
U&amp;”d\0061t+000061”
В следующем менее тривиальном примере закодировано русское слово «слон», записанное кирил-
лицей:
U&amp;”\0441\043B\043E\043D”
Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать,
добавив UESCAPE после строки, например:
U&amp;”d!0061t!+000061” UESCAPE ‘!’
В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака
плюс, апострофа, кавычки или пробельного символа. Заметьте, что спецсимвол заключается не в
двойные кавычки, а в апострофы.
Чтобы сделать спецсимволом знак апострофа, напишите его дважды.
Unicode-формат полностью поддерживается только при использовании на сервере кодировки UTF8.
Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами
до \007F). И в четырёх, и в шестизначной форме можно записывать суррогатные пары UTF-16 и
таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шестизначной
24Синтаксис SQL
формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно, а
объединяются в один символ, который затем кодируется в UTF-8.)
Идентификатор, заключённый в кавычки, становится зависимым от регистра, тогда как идентифи-
каторы без кавычек всегда переводятся в нижний регистр. Например, идентификаторы FOO, foo и
“foo” считаются одинаковыми в PostgreSQL, но “Foo” и “FOO” отличны друг от друга и от предыду-
щих трёх. (Приведение имён без кавычек к нижнему регистру, как это делает PostgreSQL, несов-
местимо со стандартом SQL, который говорит о том, что имена должны приводиться к верхнему
регистру. То есть, согласно стандарту foo должно быть эквивалентно “FOO”, а не “foo”. Поэтому
при создании переносимых приложений рекомендуется либо всегда заключать определённое имя
в кавычки, либо не заключать никогда.)
4.1.2. Константы
В PostgreSQL есть три типа констант подразумеваемых типов: строки, битовые строки и числа.
Константы можно также записывать, указывая типы явно, что позволяет представить их более
точно и обработать более эффективно. Эти варианты рассматриваются в следующих подразделах.
4.1.2.1. Строковые константы
Строковая константа в SQL — это обычная последовательность символов, заключённая в апостро-
фы (‘), например: ‘Это строка’. Чтобы включить апостроф в строку, напишите в ней два апострофа
рядом, например: ‘Жанна д’‘Арк’. Заметьте, это не то же самое, что двойная кавычка (“).
Две строковые константы, разделённые пробельными символами и минимум одним переводом
строки, объединяются в одну и обрабатываются, как если бы строка была записана в одной кон-
станте. Например:
SELECT ‘foo’
‘bar’;
эквивалентно:
SELECT ‘foobar’;
но эта запись:
SELECT ‘foo’
‘bar’;
считается синтаксической ошибкой. (Это несколько странное поведение определено в стандарте
SQL, PostgreSQL просто следует ему.)
4.1.2.2. Строковые константы со спецпоследовательностями в стиле C
PostgreSQL также принимает «спецпоследовательности», что является расширением стандарта
SQL. Строка со спецпоследовательностями начинается с буквы E (заглавной или строчной), стоя-
щей непосредственно перед апострофом, например: E’foo’. (Когда константа со спецпоследова-
тельностью разбивается на несколько строк, букву E нужно поставить только перед первым откры-
вающим апострофом.) Внутри таких строк символ обратной косой черты () начинает C-подобные
спецпоследовательности, в которых сочетание обратной косой черты со следующим символом(а-
ми) даёт определённое байтовое значение, как показано в Таблице 4.1.
Таблица 4.1. Спецпоследовательности
Спецпоследовательность Интерпретация
\b символ «забой»
\f подача формы
\n новая строка
\r возврат каретки
\t табуляция
\o, \oo, \ooo (o = 0 - 7) восьмеричное значение байта
25Синтаксис SQL
Спецпоследовательность Интерпретация
\xh, \xhh (h = 0 — 9, A — F) шестнадцатеричное значение байта
\uxxxx, \Uxxxxxxxx (x = 0 — 9, A — F) 16- или 32-битный шестнадцатеричный код сим-
вола Unicode
Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким
образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (\).
Так же можно включить в строку апостроф, написав ', в дополнение к обычному способу ‘’.
Вы должны позаботиться, чтобы байтовые последовательности, которые вы создаёте таким обра-
зом, особенно в восьмеричной и шестнадцатеричной записи, образовывали допустимые символы
в серверной кодировке. Когда сервер работает с кодировкой UTF-8, вместо такой записи байт сле-
дует использовать спецпоследовательности Unicode или альтернативный синтаксис Unicode, опи-
санный в Подразделе 4.1.2.3. (В противном случае придётся кодировать символы UTF-8 вручную
и выписывать их по байтам, что очень неудобно.)
Спецпоследовательности с Unicode полностью поддерживаются только при использовании на сер-
вере кодировки UTF8. Когда используются другие кодировки, допускается указание только ASCII-
символов (с кодами до \u007F). И в четырёх, и в восьмизначной форме можно записывать сурро-
гатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя на-
личие восьмизначной формы технически делает это ненужным. (Когда суррогатные пары исполь-
зуются с серверной кодировкой UTF8, они сначала объединяются в один символ, который затем
кодируется в UTF-8.)
Внимание
Если параметр конфигурации standard_conforming_strings имеет значение off,
PostgreSQL распознаёт обратную косую черту как спецсимвол и в обычных строках,
и в строках со спецпоследовательностями. Однако в версии PostgreSQL 9.1 по умолча-
нию принято значение on, и в этом случае обратная косая черта распознаётся только
в спецстроках. Это поведение больше соответствует стандарту, хотя может нарушить
работу приложений, рассчитанных на предыдущий режим, когда обратная косая черта
распознавалась везде. В качестве временного решения вы можете изменить этот пара-
метр на off, но лучше уйти от такой практики. Если вам нужно, чтобы обратная косая
черта представляла специальный символ, задайте строковую константу с E.
В дополнение к standard_conforming_strings поведением обратной косой черты в
строковых константах управляют параметры escape_string_warning и backslash_quote.
Строковая константа не может включать символ с кодом 0.
4.1.2.3. Строковые константы со спецпоследовательностями Unicode
PostgreSQL также поддерживает ещё один вариант спецпоследовательностей, позволяющий вклю-
чать в строки символы Unicode по их кодам. Строковая константа со спецпоследовательностями
Unicode начинается с U&amp; (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт
апостроф, например U&amp;’foo’. (Заметьте, что при этом возникает неоднозначность с оператором &amp;.
Чтобы её избежать, окружайте этот оператор пробелами.) Затем в апострофах можно записывать
символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шест-
надцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцате-
ричных цифр. Например, строку ‘data’ можно записать так:
U&amp;’d\0061t+000061’
В следующем менее тривиальном примере закодировано русское слово «слон», записанное кирил-
лицей:
U&amp;’\0441\043B\043E\043D’
26Синтаксис SQL
Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать,
добавив UESCAPEпосле строки, например:
U&amp;’d!0061t!+000061’ UESCAPE ‘!’
В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака
плюс, апострофа, кавычки или пробельного символа.
Спецпоследовательности с Unicode поддерживаются только при использовании на сервере коди-
ровки UTF8. Когда используются другие кодировки, допускается указание только ASCII-символов
(с кодами до \007F). И в четырёх, и в шестизначной форме можно записывать суррогатные пары
UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шести-
значной формы технически делает это ненужным. (Когда суррогатные пары используются с сер-
верной кодировкой UTF8, они сначала объединяются в один символ, который затем кодируется в
UTF-8.)
Также заметьте, что спецпоследовательности Unicode в строковых константах работают, только
когда параметр конфигурации standard_conforming_strings равен on. Это объясняется тем, что ина-
че клиентские программы, проверяющие SQL-операторы, можно будет ввести в заблуждение и
эксплуатировать это как уязвимость, например, для SQL-инъекций. Если этот параметр имеет зна-
чение off, эти спецпоследовательности будут вызывать ошибку.
Чтобы включить спецсимвол в строку буквально, напишите его дважды.
4.1.2.4. Строковые константы, заключённые в доллары
Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, он может пло-
хо читаться, когда строка содержит много апострофов или обратных косых черт, так как каждый
такой символ приходится дублировать. Чтобы и в таких случаях запросы оставались читаемыми,
PostgreSQL предлагает ещё один способ записи строковых констант — «заключение строк в дол-
лары». Строковая константа, заключённая в доллары, начинается со знака доллара ($), необяза-
тельного «тега» из нескольких символов и ещё одного знака доллара, затем содержит обычную
последовательность символов, составляющую строку, и оканчивается знаком доллара, тем же те-
гом и замыкающим знаком доллара. Например, строку «Жанна д’Арк» можно записать в долларах
двумя способами:
<script type="math/tex">Жанна д'Арк</script>
$SomeTag$Жанна д’Арк$SomeTag$
Заметьте, что внутри такой строки апострофы не нужно записывать особым образом. На самом
деле, в строке, заключённой в доллары, все символы можно записывать в чистом виде: содержи-
мое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не
являются спецсимволами, если только они не образуют последовательность, соответствующую от-
крывающему тегу.
Строковые константы в долларах можно вкладывать друг в друга, выбирая на разных уровнях вло-
женности разные теги. Чаще всего это используется при написании определений функций. На-
пример:
$function$
BEGIN
RETURN ($1 ~ $q$[\t\r\n\v\]$q$);
END;
$function$
Здесь последовательность $q$[\t\r\n\v\]$q$ представляет в долларах текстовую строку [\t\r
\n\v\], которая будет обработана, когда PostgreSQL будет выполнять эту функцию. Но так как
эта последовательность не соответствует внешнему тегу в долларах ($function$), с точки зрения
внешней строки это просто обычные символы внутри константы.
Тег строки в долларах, если он присутствует, должен соответствовать правилам, определённым
для идентификаторов без кавычек, и к тому же не должен содержать знак доллара. Теги регистро-
27Синтаксис SQL
зависимы, так что $tag$String content$tag$ — правильная строка, а $TAG$String content$tag
$ — нет.
Строка в долларах, следующая за ключевым словом или идентификатором, должна отделяться от
него пробельными символами, иначе доллар будет считаться продолжением предыдущего иден-
тификатора.
Заключение строк в доллары не является частью стандарта SQL, но часто это более удобный спо-
соб записывать сложные строки, чем стандартный вариант с апострофами. Он особенно полезен,
когда нужно представить строковую константу внутри другой строки, что часто требуется в опре-
делениях процедурных функций. Ограничившись только апострофами, каждую обратную косую
черту в приведённом примере пришлось бы записывать четырьмя такими символами, которые бы
затем уменьшились до двух при разборе внешней строки, и наконец до одного при обработке внут-
ренней строки во время выполнения функции.
4.1.2.5. Битовые строковые константы
Битовые строковые константы похожи на обычные с дополнительной буквой B (заглавной или
строчной), добавленной непосредственно перед открывающим апострофом (без промежуточных
пробелов), например: B’1001’. В битовых строковых константах допускаются лишь символы 0 и 1.
Битовые константы могут быть записаны и по-другому, в шестнадцатеричном виде, с начальной
буквой X (заглавной или строчной), например: X’1FF’. Такая запись эквивалентна двоичной, только
четыре двоичных цифры заменяются одной шестнадцатеричной.
Обе формы записи допускают перенос строк так же, как и обычные строковые константы. Однако
заключать в доллары битовые строки нельзя.
4.1.2.6. Числовые константы
Числовые константы могут быть заданы в следующем общем виде:
цифры
цифры.[цифры][e[+-]цифры]
[цифры].цифры[e[+-]цифры]
цифрыe[+-]цифры
где цифры — это одна или несколько десятичных цифр (0..9). До или после десятичной точки (при
её наличии) должна быть минимум одна цифра. Как минимум одна цифра должна следовать за
обозначением экспоненты (e), если оно присутствует. В числовой константе не может быть пробе-
лов или других символов. Заметьте, что любой знак минус или плюс в начале строки не считается
частью числа; это оператор, применённый к константе.
Несколько примеров допустимых числовых констант:
42
3.5
4.
.001
5e2
1.925e-3
Числовая константа, не содержащая точки и экспоненты, изначально рассматривается как кон-
станта типа integer, если её значение умещается в 32-битный тип integer; затем как константа
типа bigint, если её значение умещается в 64-битный bigint; в противном случае она принима-
ет тип numeric. Константы, содержащие десятичные точки и/или экспоненты, всегда считаются
константами типа numeric.
Изначально назначенный тип данных числовой константы это только отправная точка для алго-
ритмов определения типа. В большинстве случаев константа будет автоматически приведена к
наиболее подходящему типу для данного контекста. При необходимости вы можете принудительно
интерпретировать числовое значение как значение определённого типа, приведя его тип к нуж-
28Синтаксис SQL
ному.Например, вы можете сделать, чтобы числовое значение рассматривалось как имеющее тип
real (float4), написав:
REAL ‘1.23’
1.23::REAL
– строковый стиль
– стиль PostgreSQL (исторический)
На самом деле это только частные случаи синтаксиса приведения типов, который будет рассмат-
риваться далее.
4.1.2.7. Константы других типов
Константу обычного типа можно ввести одним из следующих способов:
type ‘string’
‘string’::type
CAST ( ‘string’ AS type )
Текст строковой константы передаётся процедуре преобразования ввода для типа, обозначенного
здесь type. Результатом становится константа указанного типа. Явное приведение типа можно
опустить, если нужный тип константы определяется однозначно (например, когда она присваива-
ется непосредственно столбцу таблицы), так как в этом случае приведение происходит автомати-
чески.
Строковую константу можно записать, используя как обычный синтаксис SQL, так и формат с
долларами.
Также можно записать приведение типов, используя синтаксис функций:
typename ( ‘string’ )
но это работает не для всех имён типов; подробнее об этом написано в Подразделе 4.2.9.
Конструкцию ::, CAST() и синтаксис вызова функции можно также использовать для преобразо-
вания типов обычных выражений во время выполнения, как описано в Подразделе 4.2.9. Во избе-
жание синтаксической неопределённости, запись тип ‘строка’ можно использовать только для
указания типа простой текстовой константы. Ещё одно ограничение записи тип ‘строка’: она не
работает для массивов; для таких констант следует использовать :: или CAST().
Синтаксис CAST() соответствует SQL, а запись type ‘string’ является обобщением стандарта:
в SQL такой синтаксис поддерживает только некоторые типы данных, но PostgreSQL позволяет
использовать его для всех. Синтаксис с :: имеет исторические корни в PostgreSQL, как и запись
в виде вызова функции.
4.1.3. Операторы
Имя оператора образует последовательность не более чем NAMEDATALEN-1 (по умолчанию 63) сим-
волов из следующего списка:
    <ul>
      <li>
        <ul>
          <li>
            <ul>
              <li>/ &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
Однако для имён операторов есть ещё несколько ограничений:
• Сочетания символов – и /* не могут присутствовать в имени оператора, так как они будут
обозначать начало комментария.
• Многосимвольное имя оператора не может заканчиваться знаком + или -, если только оно не
содержит также один из этих символов:
~ ! @ # % ^ &amp; | ` ?
Например, @- — допустимое имя оператора, а <em>- — нет. Благодаря этому ограничению,
PostgreSQL может разбирать корректные SQL-запросы без пробелов между компонентами.
Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних операторов
пробелами для однозначности. Например, если вы определили левый унарный оператор с именем
29Синтаксис SQL
@, вы не можете написать X</em>@Y, а должны написать X* @Y, чтобы PostgreSQL однозначно прочитал
это как два оператора, а не один.
4.1.4. Специальные знаки
Некоторые не алфавитно-цифровые символы имеют специальное значение, но при этом не явля-
ются операторами. Подробнее их использование будет рассмотрено при описании соответствую-
щего элемента синтаксиса. Здесь они упоминаются только для сведения и обобщения их предна-
значения.
• Знак доллара ($), предваряющий число, используется для представления позиционного пара-
метра в теле определения функции или подготовленного оператора. В других контекстах знак
доллара может быть частью идентификатора или строковой константы, заключённой в долла-
ры.
• Круглые скобки (()) имеют обычное значение и применяются для группировки выражений и
повышения приоритета операций. В некоторых случаях скобки — это необходимая часть син-
таксиса определённых SQL-команд.
• Квадратные скобки ([]) применяются для выделения элементов массива. Подробнее массивы
рассматриваются в Разделе 8.15.
• Запятые (,) используются в некоторых синтаксических конструкциях для разделения элемен-
тов списка.
• Точка с запятой (;) завершает команду SQL. Она не может находиться нигде внутри команды,
за исключением строковых констант или идентификаторов в кавычках.
• Двоеточие (:) применяется для выборки «срезов» массивов (см. Раздел 8.15.) В некоторых
диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в имени пере-
менной.
• Звёздочка (<em>) используется в некоторых контекстах как обозначение всех полей строки или
составного значения. Она также имеет специальное значение, когда используется как аргу-
мент некоторых агрегатных функций, а именно функций, которым не нужны явные парамет-
ры.
• Точка (.) используется в числовых константах, а также для отделения имён схемы, таблицы и
столбца.
4.1.5. Комментарии
Комментарий — это последовательность символов, которая начинается с двух минусов и продол-
жается до конца строки, например:
– Это стандартный комментарий SQL
Кроме этого, блочные комментарии можно записывать в стиле C:
/</em> многострочный комментарий</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>с вложенностью: /* вложенный блок комментария <em>/
*/
где комментарий начинается с /</em> и продолжается до соответствующего вхождения */. Блочные
комментарии можно вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в
C), так что вы можете комментировать большие блоки кода, которые при этом уже могут содержать
блоки комментариев.
Комментарий удаляется из входного потока в начале синтаксического анализа и фактически за-
меняется пробелом.
4.1.6. Приоритеты операторов
В Таблице 4.2 показаны приоритеты и очерёдность операторов, действующие в PostgreSQL. Боль-
шинство операторов имеют одинаковый приоритет и вычисляются слева направо. Приоритет и
очерёдность операторов жёстко фиксированы в синтаксическом анализаторе.
30Синтаксис SQL
Иногда вам потребуется добавлять скобки, когда вы комбинируете унарные и бинарные операторы.
Например, выражение:
SELECT 5 ! - 6;
будет разобрано как:
SELECT 5 ! (- 6);
так как анализатор до последнего не знает, что оператор ! определён как постфиксный, а не ин-
фиксный (внутренний). Чтобы получить желаемый результат в этом случае, нужно написать:
SELECT (5 !) - 6;
Такова цена расширяемости.
Таблица 4.2. Приоритет операторов (от большего к меньшему)
Оператор/элемент Очерёдность Описание
. слева-направо разделитель имён таблицы и
столбца
:: слева-направо приведение
PostgreSQL
[ ] слева-направо выбор элемента массива</li>
      <li>
        <ul>
          <li>справа-налево унарный плюс, унарный минус
^ слева-направо возведение в степень</li>
        </ul>
      </li>
      <li>/ % слева-направо умножение, деление, остаток от
деления</li>
      <li>
        <ul>
          <li>слева-направо сложение, вычитание
(любой другой оператор) слева-направо все другие встроенные и пользо-
вательские операторы
типов
в
стиле
BETWEEN IN LIKE ILIKE SIMILAR проверка диапазона, проверка
членства, сравнение строк
&lt; &gt; = &lt;= &gt;= &lt;&gt; операторы сравнения
IS ISNULL NOTNULL IS TRUE, IS FALSE, IS NULL, IS
DISTINCT FROM и т. д.
NOT справа-налево логическое отрицание
AND слева-направо логическая конъюнкция
OR слева-направо логическая дизъюнкция
Заметьте, что правила приоритета операторов также применяются к операторам, определённым
пользователем с теми же именами, что и вышеперечисленные встроенные операторы. Например,
если вы определите оператор «+» для некоторого нестандартного типа данных, он будет иметь тот
же приоритет, что и встроенный оператор «+», независимо от того, что он у вас делает.
Когда в конструкции OPERATOR используется имя оператора со схемой, например так:
SELECT 3 OPERATOR(pg_catalog.+) 4;
тогда OPERATOR имеет приоритет по умолчанию, соответствующий в Таблице  4.2 строке «любой
другой оператор». Это не зависит от того, какие именно операторы находятся в конструкции
OPERATOR().
Примечание
В PostgreSQL до версии 9.5 действовали немного другие правила приоритета операто-
ров. В частности, операторы &lt;=, &gt;= и &lt;&gt; обрабатывались по общему правилу; проверки
31Синтаксис SQL
IS имели более высокий приоритет; а NOT BETWEEN и связанные конструкции работа-
ли несогласованно — в некоторых случаях приоритетнее оказывался оператор NOT, а
не BETWEEN. Эти правила были изменены для лучшего соответствия стандарту SQL и
для уменьшения путаницы из-за несогласованной обработки логически равнозначных
конструкций. В большинстве случаев эти изменения никак не проявятся, либо могут
привести к ошибкам типа «нет такого оператора», которые можно разрешить, добавив
скобки. Однако, возможны особые случаи, когда запрос будет разобран без ошибки, но
его поведение может измениться. Если вас беспокоит, не нарушают ли эти изменения
незаметно работу вашего приложения, вы можете проверить это, включив конфигура-
ционный параметр operator_precedence_warning и пронаблюдав, не появятся ли преду-
преждения в журнале.
4.2. Выражения значения
Выражения значения применяются в самых разных контекстах, например в списке результатов
команды SELECT, в значениях столбцов в INSERT или UPDATE или в условиях поиска во многих ко-
мандах. Результат такого выражения иногда называют скаляром, чтобы отличить его от резуль-
тата табличного выражения (который представляет собой таблицу). А сами выражения значения
часто называют скалярными (или просто выражениями). Синтаксис таких выражений позволя-
ет вычислять значения из примитивных частей, используя арифметические, логические и другие
операции.
Выражениями значения являются:
• Константа или непосредственное значение
• Ссылка на столбец
• Ссылка на позиционный параметр в теле определения функции или подготовленного операто-
ра
• Выражение с индексом
• Выражение выбора поля
• Применение оператора
• Вызов функции
• Агрегатное выражение
• Вызов оконной функции
• Приведение типов
• Применение правил сортировки
• Скалярный подзапрос
• Конструктор массива
• Конструктор табличной строки
• Кроме того, выражением значения являются скобки (предназначенные для группировки под-
выражений и переопределения приоритета )
В дополнение к этому списку есть ещё несколько конструкций, которые можно классифицировать
как выражения, хотя они не соответствуют общим синтаксическим правилам. Они обычно имеют
вид функции или оператора и будут рассмотрены в соответствующем разделе Главы  9. Пример
такой конструкции — предложение IS NULL.
Мы уже обсудили константы в Подразделе 4.1.2. В следующих разделах рассматриваются осталь-
ные варианты.
4.2.1. Ссылки на столбцы
32Синтаксис SQL
Ссылку на столбец можно записать в форме:
отношение.имя_столбца
Здесь отношение — имя таблицы (возможно, полное, с именем схемы) или её псевдоним, опреде-
лённый в предложении FROM. Это имя и разделяющую точку можно опустить, если имя столбца
уникально среди всех таблиц, задействованных в текущем запросе. (См. также Главу 7.)
4.2.2. Позиционные параметры
Ссылка на позиционный параметр применяется для обращения к значению, переданному в SQL-
оператор извне. Параметры используются в определениях SQL-функций и подготовленных опе-
раторов. Некоторые клиентские библиотеки также поддерживают передачу значений данных от-
дельно от самой SQL-команды, и в этом случае параметры позволяют ссылаться на такие значе-
ния. Ссылка на параметр записывается в следующей форме:
$число
Например, рассмотрим следующее определение функции dept:
CREATE FUNCTION dept(text) RETURNS dept
AS <script type="math/tex">SELECT * FROM dept WHERE name = $1</script>
LANGUAGE SQL;
Здесь $1 всегда будет ссылаться на значение первого аргумента функции.
4.2.3. Индексы элементов
Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, на-
писав:
выражение[индекс]
или несколько соседних элементов («срез массива»):
выражение[нижний_индекс:верхний_индекс]
(Здесь квадратные скобки [ ] должны быть в явном виде.) Каждый индекс сам по себе является
выражением, результатом которого должно быть целое число.
В общем случае выражение массива должно заключаться в круглые скобки, но их можно опустить,
когда выражение с индексом — это просто ссылка на столбец или позиционный параметр. Кроме
того, можно соединить несколько индексов, если исходный массив многомерный. Например:
моя_таблица.столбец_массив[4]
моя_таблица.столбец_массив_2d[17][34]
$1[10:42]
(функция_массив(a,b))[42]
В последней строке круглые скобки необходимы. Подробнее массивы рассматриваются в Разде-
ле 8.15.
4.2.4. Выбор поля
Если результат выражения — значение составного типа (строка таблицы), тогда определённое
поле этой строки можно извлечь, написав:
выражение.имя_поля
В общем случае выражение такого типа должно заключаться в круглые скобки, но их можно опу-
стить, когда это ссылка на таблицу или позиционный параметр. Например:
моя_таблица.столбец
$1.столбец
(функция_кортеж(a,b)).стол3
33Синтаксис SQL
(Таким образом, полная ссылка на столбец — это просто частный случай выбора поля.) Важный
особый случай здесь — извлечение поля из столбца составного типа:
(составной_столбец).поле
(моя_таблица.составной_столбец).поле
Здесь скобки нужны, чтобы показать, что составной_столбец — это имя столбца, а не таблицы, и
что моя_таблица — имя таблицы, а не схемы.
Вы можете запросить все поля составного значения, написав .<em>:
(составной_столбец).</em>
Эта запись действует по-разному в зависимости от контекста; подробнее об этом говорится в Под-
разделе 8.16.5.
4.2.5. Применение оператора
Существуют три возможных синтаксиса применения операторов:
выражение оператор выражение (бинарный инфиксный оператор)
оператор выражение (унарный префиксный оператор)
выражение оператор (унарный постфиксный оператор)
где оператор соответствует синтаксическим правилам, описанным в Подразделе  4.1.3, либо это
одно из ключевых слов AND, OR и NOT, либо полное имя оператора в форме:
OPERATOR(схема.имя_оператора)
Существование конкретных операторов и их тип (унарный или бинарный) зависит от того, как и ка-
кие операторы определены системой и пользователем. Встроенные операторы описаны в Главе 9.
4.2.6. Вызовы функций
Вызов функции записывается просто как имя функции (возможно, дополненное именем схемы) и
список аргументов в скобках:
имя_функции ([выражение [, выражение … ]])
Например, так вычисляется квадратный корень из 2:
sqrt(2)
Список встроенных функций приведён в Главе 9. Пользователь также может определить и другие
функции.
Выполняя запросы в базе данных, где одни пользователи могут не доверять другим, в записи вы-
зовов функций соблюдайте меры предосторожности, описанные в Разделе 10.3.
Аргументам могут быть присвоены необязательные имена. Подробнее об этом см. Раздел 4.3.
Примечание
Функцию, принимающую один аргумент составного типа, можно также вызывать, ис-
пользуя синтаксис выбора поля, и наоборот, выбор поля можно записать в функцио-
нальном стиле. То есть записи col(table) и table.col равносильны и взаимозаменяе-
мы. Это поведение не оговорено стандартом SQL, но реализовано в PostgreSQL, так как
это позволяет использовать функции для эмуляции «вычисляемых полей». Подробнее
это описано в Подразделе 8.16.5.
4.2.7. Агрегатные выражения
34Синтаксис SQL
Агрегатное выражение представляет собой применение агрегатной функции к строкам, выбран-
ным запросом. Агрегатная функция сводит множество входных значений к одному выходному, как
например, сумма или среднее. Агрегатное выражение может записываться следующим образом:
агрегатная_функция (выражение [ , … ] [ предложение_order_by ] ) [ FILTER
( WHERE условие_фильтра ) ]
агрегатная_функция (ALL выражение [ , … ] [ предложение_order_by ] ) [ FILTER
( WHERE условие_фильтра ) ]
агрегатная_функция (DISTINCT выражение [ , … ] [ предложение_order_by ] ) [ FILTER
( WHERE условие_фильтра ) ]
агрегатная_функция ( * ) [ FILTER ( WHERE условие_фильтра ) ]
агрегатная_функция ( [ выражение [ , … ] ] ) WITHIN GROUP ( предложение_order_by )
[ FILTER ( WHERE условие_фильтра ) ]
Здесь агрегатная_функция — имя ранее определённой агрегатной функции (возможно, дополнен-
ное именем схемы), выражение — любое выражение значения, не содержащее в себе агрегатного
выражения или вызова оконной функции. Необязательные предложения предложение_order_by и
условие_фильтра описываются ниже.
В первой форме агрегатного выражения агрегатная функция вызывается для каждой строки. Вто-
рая форма эквивалентна первой, так как указание ALL подразумевается по умолчанию. В третьей
форме агрегатная функция вызывается для всех различных значений выражения (или набора раз-
личных значений, для нескольких выражений), выделенных во входных данных. В четвёртой фор-
ме агрегатная функция вызывается для каждой строки, так как никакого конкретного значения не
указано (обычно это имеет смысл только для функции count(<em>)). В последней форме используются
сортирующие агрегатные функции, которые будут описаны ниже.
Большинство агрегатных функций игнорируют значения NULL, так что строки, для которых выра-
жения выдают одно или несколько значений NULL, отбрасываются. Это можно считать истинным
для всех встроенных операторов, если явно не говорится об обратном.
Например, count(</em>) подсчитает общее количество строк, а count(f1) только количество строк, в
которых f1 не NULL (так как count игнорирует NULL), а count(distinct f1) подсчитает число
различных и отличных от NULL значений столбца f1.
Обычно строки данных передаются агрегатной функции в неопределённом порядке и во многих
случаях это не имеет значения, например функция min выдаёт один и тот же результат независи-
мо от порядка поступающих данных. Однако некоторые агрегатные функции (такие как array_agg
и string_agg) выдают результаты, зависящие от порядка данных. Для таких агрегатных функций
можно добавить предложение_order_by и задать нужный порядок. Это предложение_order_by име-
ет тот же синтаксис, что и предложение ORDER BY на уровне запроса, как описано в Разделе 7.5, за
исключением того, что его выражения должны быть просто выражениями, а не именами резуль-
тирующих столбцов или числами. Например:
SELECT array_agg(a ORDER BY b DESC) FROM table;
Заметьте, что при использовании агрегатных функций с несколькими аргументами, предложение
ORDER BY идёт после всех аргументов. Например, надо писать так:
SELECT string_agg(a, ‘,’ ORDER BY a) FROM table;
а не так:
SELECT string_agg(a ORDER BY a, ‘,’) FROM table;
– неправильно
Последний вариант синтаксически допустим, но он представляет собой вызов агрегатной функции
одного аргумента с двумя ключами ORDER BY (при этом второй не имеет смысла, так как это кон-
станта).
Если предложение_order_by дополнено указанием DISTINCT, тогда все выражения ORDER BY долж-
ны соответствовать обычным аргументам агрегатной функции; то есть вы не можете сортировать
строки по выражению, не включённому в список DISTINCT.
35Синтаксис SQL
Примечание
Возможность указывать и DISTINCT, и ORDER BY в агрегатной функции — это расшире-
ние PostgreSQL.
При добавлении ORDER BY в обычный список аргументов агрегатной функции, описанном до это-
го, выполняется сортировка входных строк для универсальных и статистических агрегатных функ-
ций, для которых сортировка необязательна. Но есть подмножество агрегатных функций, сорти-
рующие агрегатные функции, для которых предложение_order является обязательным, обычно
потому, что вычисление этой функции имеет смысл только при определённой сортировке входных
строк. Типичными примерами сортирующих агрегатных функций являются вычисления ранга и
процентиля. Для сортирующей агрегатной функции предложение_order_by записывается внутри
WITHIN GROUP (…), что иллюстрирует последний пример, приведённый выше. Выражения в пред-
ложении_order_by вычисляются однократно для каждой входной строки как аргументы обычной
агрегатной функции, сортируются в соответствии с требованием предложения_order_by и поступа-
ют в агрегатную функции как входящие аргументы. (Если же предложение_order_by находится не
в WITHIN GROUP, оно не передаётся как аргумент(ы) агрегатной функции.) Выражения-аргументы,
предшествующие WITHIN GROUP, (если они есть), называются непосредственными аргументами,
а выражения, указанные в предложении_order_by — агрегируемыми аргументами. В отличие от
аргументов обычной агрегатной функции, непосредственные аргументы вычисляются однократно
для каждого вызова функции, а не для каждой строки. Это значит, что они могут содержать пе-
ременные, только если эти переменные сгруппированы в GROUP BY; это суть то же ограничение,
что действовало бы, будь эти непосредственные аргументы вне агрегатного выражения. Непосред-
ственные аргументы обычно используются, например, для указания значения процентиля, кото-
рое имеет смысл, только если это конкретное число для всего расчёта агрегатной функции. Спи-
сок непосредственных аргументов может быть пуст; в этом случае запишите просто (), но не (<em>).
(На самом деле PostgreSQL примет обе записи, но только первая соответствует стандарту SQL.)
Пример вызова сортирующей агрегатной функции:
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
percentile_cont
—————–
50489
она получает 50-ый процентиль, или медиану, значения столбца income из таблицы households.
В данном случае, 0.5 — это непосредственный аргумент; если бы дробь процентиля менялась от
строки к строке, это не имело бы смысла.
Если добавлено предложение FILTER, агрегатной функции подаются только те входные строки, для
которых условие_фильтра вычисляется как истинное; другие строки отбрасываются. Например:
SELECT
count(</em>) AS unfiltered,
count(<em>) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
unfiltered | filtered
————+———-
10 |
4
(1 row)
Предопределённые агрегатные функции описаны в Разделе 9.20. Пользователь также может опре-
делить другие агрегатные функции.
Агрегатное выражение может фигурировать только в списке результатов или в предложении
HAVING команды SELECT. Во всех остальных предложениях, например WHERE, они запрещены, так
как эти предложения логически вычисляются до того, как формируются результаты агрегатных
функций.
36Синтаксис SQL
Когда агрегатное выражение используется в подзапросе (см. Подраздел 4.2.11 и Раздел 9.22), оно
обычно вычисляется для всех строк подзапроса. Но если в аргументах (или в условии_filter) аг-
регатной функции есть только переменные внешнего уровня, агрегатная функция относится к бли-
жайшему внешнему уровню и вычисляется для всех строк соответствующего запроса. Такое агре-
гатное выражение в целом является внешней ссылкой для своего подзапроса и на каждом вычис-
лении считается константой. При этом допустимое положение агрегатной функции ограничива-
ется списком результатов и предложением HAVING на том уровне запросов, где она находится.
4.2.8. Вызовы оконных функций
Вызов оконной функции представляет собой применение функции, подобной агрегатной, к некото-
рому набору строк, выбранному запросом. В отличие от вызовов не оконных агрегатных функций,
при этом не происходит группировка выбранных строк в одну — каждая строка остаётся отдель-
ной в результате запроса. Однако оконная функция имеет доступ ко всем строкам, вошедшим в
группу текущей строки согласно указанию группировки (списку PARTITION BY) в вызове оконной
функции. Вызов оконной функции может иметь следующие формы:
имя_функции ([выражение [,
OVER имя_окна
имя_функции ([выражение [,
OVER ( определение_окна )
имя_функции ( * ) [ FILTER
имя_функции ( * ) [ FILTER
выражение … ]]) [ FILTER ( WHERE предложение_фильтра ) ]
выражение … ]]) [ FILTER ( WHERE предложение_фильтра ) ]
( WHERE предложение_фильтра ) ] OVER имя_окна
( WHERE предложение_фильтра ) ] OVER ( определение_окна )
Здесь определение_окна записывается в виде
[ имя_существующего_окна ]
[ PARTITION BY выражение [, …] ]
[ ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS ( FIRST | LAST ) ]
[, …] ]
[ определение_рамки ]
Необязательное определение_рамки может иметь вид:
( RANGE | ROWS | GROUPS ) начало_рамки [ исключение_рамки ]
( RANGE | ROWS | GROUPS ) BETWEEN начало_рамки AND конец_рамки [ исключение_рамки ]
Здесь начало_рамки и конец_рамки задаются одним из следующих способов:
UNBOUNDED PRECEDING
смещение PRECEDING
CURRENT ROW
смещение FOLLOWING
UNBOUNDED FOLLOWING
и исключение_рамки может быть следующим:
EXCLUDE
EXCLUDE
EXCLUDE
EXCLUDE
CURRENT ROW
GROUP
TIES
NO OTHERS
Здесь выражение — это любое выражение значения, не содержащее вызовов оконных функций.
имя_окна — ссылка на именованное окно, определённое предложением WINDOW в данном запросе.
Также возможно написать в скобках полное определение_окна, используя тот же синтаксис опре-
деления именованного окна в предложении WINDOW; подробнее это описано в справке по SELECT.
Стоит отметить, что запись OVER имя_окна не полностью равнозначна OVER (имя_окна …); по-
следний вариант подразумевает копирование и изменение определения окна и не будет допусти-
мым, если определение этого окна включает определение рамки.
Указание PARTITION BY группирует строки запроса в разделы, которые затем обрабатываются
оконной функцией независимо друг от друга. PARTITION BY работает подобно предложению GROUP
37Синтаксис SQL
BY на уровне запроса, за исключением того, что его аргументы всегда просто выражения, а не
имена выходных столбцов или числа. Без PARTITION BY все строки, выдаваемые запросом, рассмат-
риваются как один раздел. Указание ORDER BY определяет порядок, в котором оконная функция
обрабатывает строки раздела. Оно так же подобно предложению ORDER BY на уровне запроса и
так же не принимает имена выходных столбцов или числа. Без ORDER BY строки обрабатываются
в неопределённом порядке.
определение_рамки задаёт набор строк, образующих рамку окна, которая представляет собой под-
множество строк текущего раздела и используется для оконных функций, работающих с рамкой,
а не со всем разделом. Подмножество строк в рамке может меняться в зависимости от того, какая
строка является текущей. Рамку можно задать в режимах RANGE, ROWS или GROUPS; в каждом случае
она начинается с положения начало_рамки и заканчивается положением конец_рамки. Если коне-
ц_рамки не задаётся явно, подразумевается CURRENT ROW (текущая строка).
Если начало_рамки задано как UNBOUNDED PRECEDING, рамка начинается с первой строки раздела,
а если конец_рамки определён как UNBOUNDED FOLLOWING, рамка заканчивается последней строкой
раздела.
В режиме RANGE или GROUPS начало_рамки, заданное как CURRENT ROW, определяет в качестве нача-
ла первую родственную строку (строку, которая при сортировке согласно указанному для окна
предложению ORDER BY считается равной текущей), тогда как конец_рамки, заданный как CURRENT
ROW, определяет концом рамки последнюю родственную строку. В режиме ROWS вариант CURRENT
ROW просто обозначает текущую строку.
В вариантах определения рамки смещение PRECEDING и смещение FOLLOWING в качестве смещения
должно задаваться выражение, не содержащее какие-либо переменные и вызовы агрегатных или
оконных функций. Что именно будет означать смещение, определяется в зависимости от режима
рамки:
• В режиме ROWS смещение должно задаваться отличным от NULL неотрицательным целым чис-
лом, и это число определяет сдвиг, с которым начало рамки позиционируется перед текущей
строкой, а конец — после текущей строки.
• В режиме GROUPS смещение также должно задаваться отличным от NULL неотрицательным це-
лым числом, и это число определяет сдвиг (по количеству групп родственных строк), с кото-
рым начало рамки позиционируется перед группой строк, родственных текущей, а конец —
после этой группы. Группу родственных строк образуют строки, которые считаются равными
согласно ORDER BY. (Для использования режима GROUPS определение окна должно содержать
предложение ORDER BY.)
• В режиме RANGE для использования этих указаний предложение ORDER BY должно содержать
ровно один столбец. В этом случае смещение задаёт максимальную разницу между значени-
ем этого столбца в текущей строке и значением его же в предшествующих или последую-
щих строках рамки. Тип данных выражения смещение зависит от типа данных упорядочиваю-
щего столбца. Для числовых столбцов это обычно тот же числовой тип, а для столбцов с ти-
пом дата/время — тип interval. Например, если упорядочивающий столбец имеет тип date
или timestamp, возможна такая запись: RANGE BETWEEN ‘1 day’ PRECEDING AND ‘10 days’
FOLLOWING. Значение смещение при этом может так же быть отличным от NULL и неотрица-
тельным, хотя что считать «неотрицательным», будет зависит от типа данных.
В любом случае расстояние до конца рамки ограничивается расстоянием до конца раздела, так
что для строк, которые находятся у конца раздела, рамка может содержать меньше строк, чем
для других.
Заметьте, что в режимах ROWS и GROUPS указания 0 PRECEDING и 0 FOLLOWING равнозначны указанию
CURRENT ROW. Обычно это справедливо и для режима RANGE, в случае подходящего для типа данных
определения значения «нуля».
Дополнение исключение_рамки позволяет исключить из рамки строки, которые окружают текущую
строку, даже если они должны быть включены согласно указаниям, определяющим начало и конец
38Синтаксис SQL
рамки. EXCLUDE CURRENT ROW исключает из рамки текущую строку. EXCLUDE GROUP исключает из
рамки текущую строку и родственные ей согласно порядку сортировки. EXCLUDE TIES исключает
из рамки все родственные строки для текущей, но не собственно текущую строку. EXCLUDE NO
OTHERS просто явно выражает поведение по умолчанию — не исключает ни текущую строку, ни
родственные ей.
По умолчанию рамка определяется как RANGE UNBOUNDED PRECEDING, что равносильно расширен-
ному определению RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. С указанием ORDER BY
это означает, что рамка будет включать все строки от начала раздела до последней строки, род-
ственной текущей (для ORDER BY). Без ORDER BY это означает, что в рамку включаются все строки
раздела, так как все они считаются родственными текущей.
Действуют также следующие ограничения: в качестве начала_рамки нельзя задать UNBOUNDED
FOLLOWING, в качестве конца_рамки не допускается UNBOUNDED PRECEDING и конец_рамки не может
идти в показанном выше списке указаний начало_рамки AND конец_рамки перед началом_рамки. В
частности, синтаксис RANGE BETWEEN CURRENT ROW AND смещение PRECEDING не допускается. Но
при этом, например, определение ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING допустимо, хотя
оно и не выберет никакие строки.
Если добавлено предложение FILTER, оконной функции подаются только те входные строки, для
которых условие_фильтра вычисляется как истинное; другие строки отбрасываются. Предложение
FILTER допускается только для агрегирующих оконных функций.
Встроенные оконные функции описаны в Таблице  9.57, но пользователь может расширить этот
набор, создавая собственные функции. Кроме того, в качестве оконных функций можно использо-
вать любые встроенные или пользовательские универсальные, а также статистические агрегатные
функции. (Сортирующие и гипотезирующие агрегатные функции в настоящее время использовать
в качестве оконных нельзя.)
Запись со звёздочкой (</em>) применяется при вызове не имеющих параметров агрегатных функций в
качестве оконных, например count(<em>) OVER (PARTITION BY x ORDER BY y). Звёздочка (</em>) обычно не
применяется для исключительно оконных функций. Такие функции не допускают использования
DISTINCT и ORDER BY в списке аргументов функции.
Вызовы оконных функций разрешены в запросах только в списке SELECT и в предложении ORDER BY.
Дополнительно об оконных функциях можно узнать в Разделе 3.5, Разделе 9.21 и Подразделе 7.2.5.
4.2.9. Приведения типов
Приведение типа определяет преобразование данных из одного типа в другой. PostgreSQL воспри-
нимает две равносильные записи приведения типов:
CAST ( выражение AS тип )
выражение::тип
Запись с CAST соответствует стандарту SQL, тогда как вариант с :: — историческое наследие
PostgreSQL.
Когда приведению подвергается значение выражения известного типа, происходит преобразова-
ние типа во время выполнения. Это приведение будет успешным, только если определён подходя-
щий оператор преобразования типов. Обратите внимание на небольшое отличие от приведения
констант, описанного в Подразделе 4.1.2.7. Приведение строки в чистом виде представляет собой
начальное присваивание строковой константы и оно будет успешным для любого типа (конечно,
если строка содержит значение, приемлемое для данного типа данных).
Неявное приведение типа можно опустить, если возможно однозначно определить, какой тип
должно иметь выражение (например, когда оно присваивается столбцу таблицы); в таких случа-
ях система автоматически преобразует тип. Однако автоматическое преобразование выполняется
только для приведений с пометкой «допускается неявное применение» в системных каталогах. Все
39Синтаксис SQL
остальные приведения должны записываться явно. Это ограничение позволяет избежать сюрпри-
зов с неявным преобразованием.
Также можно записать приведение типа как вызов функции:
имя_типа ( выражение )
Однако это будет работать только для типов, имена которых являются также допустимыми име-
нами функций. Например, double precision так использовать нельзя, а float8 (альтернативное
название того же типа) — можно. Кроме того, имена типов interval, time и timestamp из-за син-
таксического конфликта можно использовать в такой записи только в кавычках. Таким образом,
запись приведения типа в виде вызова функции провоцирует несоответствия и, возможно, лучше
будет её не применять.
Примечание
Приведение типа, представленное в виде вызова функции, на самом деле соответству-
ет внутреннему механизму. Даже при использовании двух стандартных типов записи
внутри происходит вызов зарегистрированной функции, выполняющей преобразова-
ние. По соглашению именем такой функции преобразования является имя выходно-
го типа, и таким образом запись «в виде вызова функции» есть не что иное, как пря-
мой вызов нижележащей функции преобразования. При создании переносимого при-
ложения на это поведение, конечно, не следует рассчитывать. Подробнее это описано
в справке CREATE CAST.
4.2.10. Применение правил сортировки
Предложение COLLATE переопределяет правило сортировки выражения. Оно добавляется после
выражения:
выражение COLLATE правило_сортировки
где правило_сортировки — идентификатор правила, возможно дополненный именем схемы. Пред-
ложение COLLATE связывает выражение сильнее, чем операторы, так что при необходимости сле-
дует использовать скобки.
Если правило сортировки не определено явно, система либо выбирает его по столбцам, которые
используются в выражении, либо, если таких столбцов нет, переключается на установленное для
базы данных правило сортировки по умолчанию.
Предложение COLLATE имеет два распространённых применения: переопределение порядка сор-
тировки в предложении ORDER BY, например:
SELECT a, b, c FROM tbl WHERE … ORDER BY a COLLATE “C”;
и переопределение правил сортировки при вызове функций или операторов, возвращающих язы-
козависимые результаты, например:
SELECT * FROM tbl WHERE a &gt; ‘foo’ COLLATE “C”;
Заметьте, что в последнем случае предложение COLLATE добавлено к аргументу оператора, на дей-
ствие которого мы хотим повлиять. При этом не имеет значения, к какому именно аргументу опе-
ратора или функции добавляется COLLATE, так как правило сортировки, применяемое к оператору
или функции, выбирается при рассмотрении всех аргументов, а явное предложение COLLATE пе-
реопределяет правила сортировки для всех других аргументов. (Однако добавление разных пред-
ложений COLLATE к нескольким аргументам будет ошибкой. Подробнее об этом см. Раздел 23.2.)
Таким образом, эта команда выдаст тот же результат:
SELECT * FROM tbl WHERE a COLLATE “C” &gt; ‘foo’;
Но это будет ошибкой:
40Синтаксис SQL
SELECT * FROM tbl WHERE (a &gt; ‘foo’) COLLATE “C”;
здесь правило сортировки нельзя применить к результату оператора &gt;, который имеет несравни-
ваемый тип данных boolean.
4.2.11. Скалярные подзапросы
Скалярный подзапрос — это обычный запрос SELECT в скобках, который возвращает ровно одну
строку и один столбец. (Написание запросов освещается в Главе 7.) После выполнения запроса
SELECT его единственный результат используется в окружающем его выражении. В качестве ска-
лярного подзапроса нельзя использовать запросы, возвращающие более одной строки или столб-
ца. (Но если в результате выполнения подзапрос не вернёт строк, скалярный результат считается
равным NULL.) В подзапросе можно ссылаться на переменные из окружающего запроса; в процес-
се одного вычисления подзапроса они будут считаться константами. Другие выражения с подза-
просами описаны в Разделе 9.22.
Например, следующий запрос находит самый населённый город в каждом штате:
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
FROM states;
4.2.12. Конструкторы массивов
Конструктор массива — это выражение, которое создаёт массив, определяя значения его элемен-
тов. Конструктор простого массива состоит из ключевого слова ARRAY, открывающей квадратной
скобки [, списка выражений (разделённых запятыми), задающих значения элементов массива, и
закрывающей квадратной скобки ]. Например:
SELECT ARRAY[1,2,3+4];
array
———
_(1,2,7)
(1 row)
По умолчанию типом элементов массива считается общий тип для всех выражений, определённый
по правилам, действующим и для конструкций UNION и CASE (см. Раздел 10.5). Вы можете пере-
определить его явно, приведя конструктор массива к требуемому типу, например:</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>SELECT ARRAY[1,2,22.7]::integer[];
array ‘(1,2,23)’
(1 row)
Это равносильно тому, что привести к нужному типу каждое выражение по отдельности. Подроб-
нее приведение типов описано в Подразделе 4.2.9.
Многомерные массивы можно образовывать, вкладывая конструкторы массивов. При этом во внут-
ренних конструкторах слово ARRAY можно опускать. Например, результат работы этих конструк-
торов одинаков:
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
array ((1,2),(3,4))
(1 row)
SELECT ARRAY[[1,2],[3,4]];
array
—————
((1,2),(3,4))
(1 row)
41Синтаксис SQL
Многомерные массивы должны быть прямоугольными, и поэтому внутренние конструкторы одно-
го уровня должны создавать вложенные массивы одинаковой размерности. Любое приведение ти-
па, применённое к внешнему конструктору ARRAY, автоматически распространяется на все внут-
ренние.
Элементы многомерного массива можно создавать не только вложенными конструкторами ARRAY,
но и другими способами, позволяющими получить массивы нужного типа. Например:
CREATE TABLE arr(f1 int[], f2 int[]);
INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);
SELECT ARRAY[f1, f2, ‘((9,10),(11,12))’::int[]] FROM arr;
array
————————————————
(((1,2),(3,4)),((5,6),(7,8)),((9,10),(11,12)))
(1 row)
Вы можете создать и пустой массив, но так как массив не может быть не типизированным, вы
должны явно привести пустой массив к нужному типу. Например:
SELECT ARRAY[]::integer[];
array
——-
()
(1 row)
Также возможно создать массив из результатов подзапроса. В этом случае конструктор массива
записывается так же с ключевым словом ARRAY, за которым в круглых скобках следует подзапрос.
Например:
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE ‘bytea%’);
array
———————————————————————–
(2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413)
(1 row)
SELECT ARRAY(SELECT ARRAY[i, i<em>2] FROM generate_series(1,5) AS a(i));
array
———————————-
((1,2),(2,4),(3,6),(4,8),(5,10))
(1 row)
Такой подзапрос должен возвращать один столбец. Если этот столбец имеет тип, отличный от мас-
сива, результирующий одномерный массив будет включать элементы для каждой строки-резуль-
тата подзапроса и типом элемента будет тип столбца результата. Если же тип столбца — массив,
будет создан массив того же типа, но большей размерности; в любом случае во всех строках под-
запроса должны выдаваться массивы одинаковой размерности, чтобы можно было получить пря-
моугольный результат.
Индексы массива, созданного конструктором ARRAY, всегда начинаются с одного. Подробнее о мас-
сивах вы узнаете в Разделе 8.15.
4.2.13. Конструкторы табличных строк
Конструктор табличной строки — это выражение, создающее строку или кортеж (или составное
значение) из значений его аргументов-полей. Конструктор строки состоит из ключевого слова ROW,
открывающей круглой скобки, нуля или нескольких выражений (разделённых запятыми), опреде-
ляющих значения полей, и закрывающей скобки. Например:
SELECT ROW(1,2.5,’this is a test’);
42Синтаксис SQL
Если в списке более одного выражения, ключевое слово ROW можно опустить.
Конструктор строки поддерживает запись составное_значение.</em>, при этом данное значение будет
развёрнуто в список элементов, так же, как в записи .* на верхнем уровне списка SELECT (см.
Подраздел 8.16.5). Например, если таблица t содержит столбцы f1 и f2, эти записи равнозначны:
SELECT ROW(t.<em>, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
Примечание
До версии PostgreSQL 8.2 запись .</em> не разворачивалась в конструкторах строк, так
что выражение ROW(t.<em>, 42) создавало составное значение из двух полей, в котором
первое поле так же было составным. Новое поведение обычно более полезно. Если
вам нужно получить прежнее поведение, чтобы одно значение строки было вложено в
другое, напишите внутреннее значение без .</em>, например: ROW(t, 42).
По умолчанию значение, созданное выражением ROW, имеет тип анонимной записи. Если необхо-
димо, его можно привести к именованному составному типу — либо к типу строки таблицы, либо
составному типу, созданному оператором CREATE TYPE AS. Явное приведение может потребоваться
для достижения однозначности. Например:
CREATE TABLE mytable(f1 int, f2 float, f3 text);
CREATE FUNCTION getf1(mytable) RETURNS int AS ‘SELECT $1.f1’ LANGUAGE SQL;
– Приведение не требуется, так как существует только одна getf1()
SELECT getf1(ROW(1,2.5,’this is a test’));
getf1
——-
1
(1 row)
CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
CREATE FUNCTION getf1(myrowtype) RETURNS int AS ‘SELECT $1.f1’ LANGUAGE SQL;
– Теперь приведение необходимо для однозначного выбора функции:
SELECT getf1(ROW(1,2.5,’this is a test’));
ОШИБКА: функция getf1(record) не уникальна
SELECT getf1(ROW(1,2.5,’this is a test’)::mytable);
getf1
——-
1
(1 row)
SELECT getf1(CAST(ROW(11,’this is a test’,2.5) AS myrowtype));
getf1
——-
11
(1 row)
Используя конструктор строк (кортежей), можно создавать составное значение для сохранения
в столбце составного типа или для передачи функции, принимающей составной параметр. Также
вы можете сравнить два составных значения или проверить их с помощью IS NULL или IS NOT
NULL, например:
SELECT ROW(1,2.5,’this is a test’) = ROW(1, 3, ‘not the same’);
43Синтаксис SQL
– выбрать все строки, содержащие только NULL
SELECT ROW(table.<em>) IS NULL FROM table;
Подробнее см. Раздел 9.23. Конструкторы строк также могут использоваться в сочетании с подза-
просами, как описано в Разделе 9.22.
4.2.14. Правила вычисления выражений
Порядок вычисления подвыражений не определён. В частности, аргументы оператора или функ-
ции не обязательно вычисляются слева направо или в любом другом фиксированном порядке.
Более того, если результат выражения можно получить, вычисляя только некоторые его части,
тогда другие подвыражения не будут вычисляться вовсе. Например, если написать:
SELECT true OR somefunc();
тогда функция somefunc() не будет вызываться (возможно). То же самое справедливо для записи:
SELECT somefunc() OR true;
Заметьте, что это отличается от «оптимизации» вычисления логических операторов слева напра-
во, реализованной в некоторых языках программирования.
Как следствие, в сложных выражениях не стоит использовать функции с побочными эффектами.
Особенно опасно рассчитывать на порядок вычисления или побочные эффекты в предложениях
WHERE и HAVING, так как эти предложения тщательно оптимизируются при построении плана вы-
полнения. Логические выражения (сочетания AND/OR/NOT) в этих предложениях могут быть видо-
изменены любым способом, допустимым законами Булевой алгебры.
Когда порядок вычисления важен, его можно зафиксировать с помощью конструкции CASE (см.
Раздел 9.17). Например, такой способ избежать деления на ноль в предложении WHERE ненадёжен:
SELECT … WHERE x &gt; 0 AND y/x &gt; 1.5;
Безопасный вариант:
SELECT … WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
Применяемая так конструкция CASE защищает выражение от оптимизации, поэтому использовать
её нужно только при необходимости. (В данном случае было бы лучше решить проблему, переписав
условие как y &gt; 1.5</em>x.)
Однако, CASE не всегда спасает в подобных случаях. Показанный выше приём плох тем, что не
предотвращает раннее вычисление константных подвыражений. Как описано в Разделе 38.7, функ-
ции и операторы, помеченные как IMMUTABLE, могут вычисляться при планировании, а не выпол-
нении запроса. Поэтому в примере
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
, скорее всего, произойдёт деление на ноль из-за того, что планировщик попытается упростить
константное подвыражение, даже если во всех строках в таблице x &gt; 0, а значит во время выпол-
нения ветвь ELSE никогда не будет выполняться.
Хотя этот конкретный пример может показаться надуманным, похожие ситуации, в которых неяв-
но появляются константы, могут возникать и в запросах внутри функций, так как значения аргу-
ментов функции и локальных переменных при планировании могут быть заменены константами.
Поэтому, например, в функциях PL/pgSQL гораздо безопаснее для защиты от рискованных вычис-
лений использовать конструкцию IF-THEN-ELSE, чем выражение CASE.
Ещё один подобный недостаток этого подхода в том, что CASE не может предотвратить вычисление
заключённого в нём агрегатного выражения, так как агрегатные выражения вычисляются перед
всеми остальными в списке SELECT или предложении HAVING. Например, в следующем запросе
может возникнуть ошибка деления на ноль, несмотря на то, что он вроде бы защищён от неё:
44Синтаксис SQL
SELECT CASE WHEN min(employees) &gt; 0
THEN avg(expenses / employees)
END
FROM departments;
Агрегатные функции min() и avg() вычисляются независимо по всем входным строкам, так что ес-
ли в какой-то строке поле employees окажется равным нулю, деление на ноль произойдёт раньше,
чем станет возможным проверить результат функции min(). Поэтому, чтобы проблемные входные
строки изначально не попали в агрегатную функцию, следует воспользоваться предложениями
WHERE или FILTER.
4.3. Вызов функций
PostgreSQL позволяет вызывать функции с именованными параметрами, используя запись с пози-
ционной или именной передачей аргументов. Именная передача особенно полезна для функций
со множеством параметров, так как она делает связь параметров и аргументов более явной и на-
дёжной. В позиционной записи значения аргументов функции указываются в том же порядке, в
каком они описаны в определении функции. При именной передаче аргументы сопоставляются с
параметрами функции по именам и указывать их можно в любом порядке. Для каждого варианта
вызова также учитывайте влияние типов аргументов функций, описанное в Разделе 10.3.
При записи любым способом параметры, для которых в определении функции заданы значения по
умолчанию, можно вовсе не указывать. Но это особенно полезно при именной передаче, так как
опустить можно любой набор параметров, тогда как при позиционной параметры можно опускать
только последовательно, справа налево.
PostgreSQL также поддерживает смешанную передачу, когда параметры передаются и по именам,
и по позиции. В этом случае позиционные параметры должны идти перед параметрами, передава-
емыми по именам.
Мы рассмотрим все три варианта записи на примере следующей функции:
CREATE FUNCTION concat_lower_or_upper(a text, b text,
uppercase boolean DEFAULT false)
RETURNS text
AS
<script type="math/tex">SELECT CASE
WHEN $3 THEN UPPER($1 || ' ' || $2)
ELSE LOWER($1 || ' ' || $2)
END;</script>
LANGUAGE SQL IMMUTABLE STRICT;
Функция concat_lower_or_upper имеет два обязательных параметра: a и b. Кроме того, есть один
необязательный параметр uppercase, который по умолчанию имеет значение false. Аргументы a и
b будут сложены вместе и переведены в верхний или нижний регистр, в зависимости от параметра
uppercase. Остальные тонкости реализации функции сейчас не важны (подробнее о них рассказано
в Главе 38).
4.3.1. Позиционная передача
Позиционная передача — это традиционный механизм передачи аргументов функции в
PostgreSQL. Пример такой записи:
SELECT concat_lower_or_upper(‘Hello’, ‘World’, true);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
45Синтаксис SQL
Все аргументы указаны в заданном порядке. Результат возвращён в верхнем регистре, так как
параметр uppercase имеет значение true. Ещё один пример:
SELECT concat_lower_or_upper(‘Hello’, ‘World’);
concat_lower_or_upper
———————–
hello world
(1 row)
Здесь параметр uppercase опущен, и поэтому он принимает значение по умолчанию (false), и ре-
зультат переводится в нижний регистр. В позиционной записи любые аргументы с определённым
значением по умолчанию можно опускать справа налево.
4.3.2. Именная передача
При именной передаче для аргумента добавляется имя, которое отделяется от выражения значе-
ния знаками =&gt;. Например:
SELECT concat_lower_or_upper(a =&gt; ‘Hello’, b =&gt; ‘World’);
concat_lower_or_upper
———————–
hello world
(1 row)
Здесь аргумент uppercase был так же опущен, так что он неявно получил значение false. Преиму-
ществом такой записи является возможность записывать аргументы в любом порядке, например:
SELECT concat_lower_or_upper(a =&gt; ‘Hello’, b =&gt; ‘World’, uppercase =&gt; true);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
SELECT concat_lower_or_upper(a =&gt; ‘Hello’, uppercase =&gt; true, b =&gt; ‘World’);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
Для обратной совместимости поддерживается и старый синтаксис с “:=”:
SELECT concat_lower_or_upper(a := ‘Hello’, uppercase := true, b := ‘World’);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
4.3.3. Смешанная передача
При смешанной передаче параметры передаются и по именам, и по позиции. Однако, как уже
было сказано, именованные аргументы не могут стоять перед позиционными. Например:
SELECT concat_lower_or_upper(‘Hello’, ‘World’, uppercase =&gt; true);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
В данном запросе аргументы a и b передаются по позиции, а uppercase — по имени. Единствен-
ное обоснование такого вызова здесь — он стал чуть более читаемым. Однако для более сложных
функций с множеством аргументов, часть из которых имеют значения по умолчанию, именная или
смешанная передача позволяют записать вызов эффективнее и уменьшить вероятность ошибок.
46Синтаксис SQL
Примечание
Именная и смешанная передача в настоящий момент не может использоваться при
вызове агрегатной функции (но они допускаются, если агрегатная функция использу-
ется в качестве оконной).</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-003/" title="Глава 3. Расширенные возможности"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 3. Расширенные возможности"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-003/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-003/" rel="bookmark" title="Глава 3. Расширенные возможности" itemprop="url">Глава 3. Расширенные возможности</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 3. Расширенные возможности</p>

<p>3.1. Введение
В предыдущей главе мы изучили азы использования SQL для хранения и обработки данных в
PostgreSQL. Теперь мы обсудим более сложные возможности SQL, помогающие управлять данны-
ми и предотвратить их потерю или порчу. В конце главы мы рассмотрим некоторые расширения
PostgreSQL.
В этой главе мы будем время от времени ссылаться на примеры, приведённые в Главе 2 и изменять
или развивать их, поэтому будет полезно сначала прочитать предыдущую главу. Некоторые при-
меры этой главы также можно найти в файле advanced.sql в каталоге tutorial. Кроме того, этот
файл содержит пример данных для загрузки (здесь она повторно не рассматривается). Если вы не
знаете, как использовать этот файл, обратитесь к Разделу 2.1.
3.2. Представления
Вспомните запросы, с которыми мы имели дело в Разделе 2.6. Предположим, что вас интересует
составной список из погодных записей и координат городов, но вы не хотите каждый раз вводить
весь этот запрос. Вы можете создать представление по данному запросу, фактически присвоить
имя запросу, а затем обращаться к нему как к обычной таблице:
CREATE VIEW myview AS
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
SELECT * FROM myview;
Активное использование представлений — это ключевой аспект хорошего проектирования баз дан-
ных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые мо-
гут меняться по мере развития приложения, за надёжными интерфейсами.
Представления можно использовать практически везде, где можно использовать обычные табли-
цы. И довольно часто представления создаются на базе других представлений.
3.3. Внешние ключи
Вспомните таблицы weather и cities из Главы 2. Давайте рассмотрим следующую задачу: вы хо-
тите добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится
соответствующая строка в таблице cities. Это называется обеспечением ссылочной целостности
данных. В простых СУБД это пришлось бы реализовать (если это вообще возможно) так: сначала
явно проверить, есть ли соответствующие записи в таблице cities, а затем отклонить или вставить
новые записи в таблицу weather. Этот подход очень проблематичен и неудобен, поэтому всё это
PostgreSQL может сделать за вас.
Новое объявление таблицы будет выглядеть так:
CREATE TABLE cities (
city
varchar(80) primary key,
location point
);
CREATE TABLE weather (
city
varchar(80) references cities(city),
temp_lo
int,
temp_hi
int,
prcp
real,
14Расширенные возможности
date
date
);
Теперь попробуйте вставить недопустимую запись:
INSERT INTO weather VALUES (‘Berkeley’, 45, 53, 0.0, ‘1994-11-28’);
ОШИБКА: INSERT или UPDATE в таблице “weather” нарушает ограничение внешнего
ключа “weather_city_fkey”
ПОДРОБНОСТИ: Ключ (city)=(Berkeley) отсутствует в таблице “cities”.
Поведение внешних ключей можно подстроить согласно требованиям вашего приложения. Мы не
будем усложнять этот простой пример в данном введении, но вы можете обратиться за дополни-
тельной информацией к Главе 5. Правильно применяя внешние ключи, вы определённо создадите
более качественные приложения, поэтому мы настоятельно рекомендуем изучить их.
3.4. Транзакции
Транзакции — это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объ-
единяет последовательность действий в одну операцию “всё или ничего”. Промежуточные состо-
яния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно
завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.
Например, рассмотрим базу данных банка, в которой содержится информация о счетах клиентов,
а также общие суммы по отделениям банка. Предположим, что мы хотим перевести 100 долларов
со счёта Алисы на счёт Боба. Простоты ради, соответствующие SQL-команды можно записать так:
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
UPDATE branches SET balance = balance - 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Alice’);
UPDATE accounts SET balance = balance + 100.00
WHERE name = ‘Bob’;
UPDATE branches SET balance = balance + 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Bob’);
Точное содержание команд здесь не важно, важно лишь то, что для выполнения этой довольно
простой операции потребовалось несколько отдельных действий. При этом с точки зрения банка
необходимо, чтобы все эти действия выполнились вместе, либо не выполнились совсем. Если Боб
получит 100 долларов, но они не будут списаны со счёта Алисы, объяснить это сбоем системы
определённо не удастся. И наоборот, Алиса вряд ли будет довольна, если она переведёт деньги,
а до Боба они не дойдут. Нам нужна гарантия, что если что-то помешает выполнить операцию
до конца, ни одно из действий не оставит следа в базе данных. И мы получаем эту гарантию, объ-
единяя действия в одну транзакцию. Говорят, что транзакция атомарна: с точки зрения других
транзакций она либо выполняется и фиксируется полностью, либо не фиксируется совсем.
Нам также нужна гарантия, что после завершения и подтверждения транзакции системой баз дан-
ных, её результаты в самом деле сохраняются и не будут потеряны, даже если вскоре произойдёт
авария. Например, если мы списали сумму и выдали её Бобу, мы должны исключить возможность
того, что сумма на его счёте восстановится, как только он выйдет за двери банка. Транзакционная
база данных гарантирует, что все изменения записываются в постоянное хранилище (например,
на диск) до того, как транзакция будет считаться завершённой.
Другая важная характеристика транзакционных баз данных тесно связана с атомарностью изме-
нений: когда одновременно выполняется множество транзакций, каждая из них не видит незавер-
шённые изменения, произведённые другими. Например, если одна транзакция подсчитывает ба-
ланс по отделениям, будет неправильно, если она посчитает расход в отделении Алисы, но не учтёт
приход в отделении Боба, или наоборот. Поэтому свойство транзакций “всё или ничего” должно
определять не только, как изменения сохраняются в базе данных, но и как они видны в процессе
работы. Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока
она не будет завершена, а затем они становятся видны все сразу.
15Расширенные возможности
В PostgreSQL транзакция определяется набором SQL-команд, окружённым командами BEGIN и
COMMIT. Таким образом, наша банковская транзакция должна была бы выглядеть так:
BEGIN;
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
– …
COMMIT;
Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения (на-
пример, потому что оказалось, что баланс Алисы стал отрицательным), мы можем выполнить ко-
манду ROLLBACK вместо COMMIT, и все наши изменения будут отменены.
PostgreSQL на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не встави-
те команду BEGIN, то каждый отдельный оператор будет неявно окружён командами BEGIN и COMMIT
(в случае успешного завершения). Группу операторов, окружённых командами BEGIN и COMMIT ино-
гда называют блоком транзакции.
Примечание
Некоторые клиентские библиотеки добавляют команды BEGIN и COMMIT автоматически
и неявно создают за вас блоки транзакций. Подробнее об этом вы можете узнать в
документации интересующего вас интерфейса.
Операторами в транзакции можно также управлять на более детальном уровне, используя точ-
ки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и
фиксировать все остальные. Определив точку сохранения с помощью SAVEPOINT, при необходимо-
сти вы можете вернуться к ней с помощью команды ROLLBACK TO. Все изменения в базе данных,
произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произ-
ведённые ранее, сохраняются.
Когда вы возвращаетесь к точке сохранения, она продолжает существовать, так что вы можете от-
катываться к ней несколько раз. С другой стороны, если вы уверены, что вам не придётся откаты-
ваться к определённой точке сохранения, её можно удалить, чтобы система высвободила ресурсы.
Помните, что при удалении или откате к точке сохранения все точки сохранения, определённые
после неё, автоматически уничтожаются.
Всё это происходит в блоке транзакции, так что в других сеансах работы с базой данных этого не
видно. Совершённые действия становятся видны для других сеансов все сразу, только когда вы
фиксируете транзакцию, а отменённые действия не видны вообще никогда.
Вернувшись к банковской базе данных, предположим, что мы списываем 100 долларов со счёта
Алисы, добавляем их на счёт Боба, и вдруг оказывается, что деньги нужно было перевести Уолли.
В данном случае мы можем применить точки сохранения:
BEGIN;
UPDATE accounts SET balance = balance
WHERE name = ‘Alice’;
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Bob’;
– ошибочное действие… забыть его и
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Wally’;
COMMIT;</p>
<ul>
  <li>100.00</li>
  <li>100.00
использовать счёт Уолли</li>
  <li>100.00
Этот пример, конечно, несколько надуман, но он показывает, как можно управлять выполнением
команд в блоке транзакций, используя точки сохранения. Более того, ROLLBACK TO — это един-
16Расширенные возможности
ственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии
из-за ошибки системы, не считая возможности полностью отменить её и начать снова.
3.5. Оконные функции
Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с теку-
щей строкой. Её действие можно сравнить с вычислением, производимым агрегатной функцией.
Однако с оконными функциями строки не группируются в одну выходную строку, что имеет место
с обычными, не оконными, агрегатными функциями. Вместо этого, эти строки остаются отдельны-
ми сущностями. Внутри же, оконная функция, как и агрегатная, может обращаться не только к
текущей строке результата запроса.
Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его
отдела:
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
FROM empsalary;
depname | empno | salary |
avg
———–+——-+——–+———————–
develop
|
11 |
5200 | 5020.0000000000000000
develop
|
7 |
4200 | 5020.0000000000000000
develop
|
9 |
4500 | 5020.0000000000000000
develop
|
8 |
6000 | 5020.0000000000000000
develop
|
10 |
5200 | 5020.0000000000000000
personnel |
5 |
3500 | 3700.0000000000000000
personnel |
2 |
3900 | 3700.0000000000000000
sales
|
3 |
4800 | 4866.6666666666666667
sales
|
1 |
5000 | 4866.6666666666666667
sales
|
4 |
4800 | 4866.6666666666666667
(10 rows)
Первые три столбца извлекаются непосредственно из таблицы empsalary, при этом для каждой
строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычис-
ленное по всем строкам, имеющим то же значение depname, что и текущая строка. (Фактически
среднее вычисляет та же обычная, не оконная функция avg, но предложение OVER превращает её
в оконную, так что её действие ограничивается рамками окон.)
Вызов оконной функции всегда содержит предложение OVER, следующее за названием и аргумен-
тами оконной функции. Это синтаксически отличает её от обычной, не оконной агрегатной функ-
ции. Предложение OVER определяет, как именно нужно разделить строки запроса для обработки
оконной функцией. Предложение PARTITION BY, дополняющее OVER, разделяет строки по группам,
или разделам, объединяя одинаковые значения выражений PARTITION BY. Оконная функция вы-
числяется по строкам, попадающим в один раздел с текущей строкой.
Вы можете также определять порядок, в котором строки будут обрабатываться оконными функци-
ями, используя ORDER BY в OVER. (Порядок ORDER BY для окна может даже не совпадать с порядком,
в котором выводятся строки.) Например:
SELECT depname, empno, salary,
rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
depname | empno | salary | rank
———–+——-+——–+——
develop
|
8 |
6000 |
1
develop
|
10 |
5200 |
2
develop
|
11 |
5200 |
2
develop
|
9 |
4500 |
4
develop
|
7 |
4200 |
5
17Расширенные возможности
personnel
personnel
sales
sales
sales
(10 rows)
|
|
|
|
|
2
5
1
4
3
|
|
|
|
|
3900
3500
5000
4800
4800
|
|
|
|
|
1
2
1
2
2
Как показано здесь, функция rank выдаёт порядковый номер для каждого уникального значения
в разделе текущей строки, по которому выполняет сортировку предложение ORDER BY. У функции
rank нет параметров, так как её поведение полностью определяется предложением OVER.
Строки, обрабатываемые оконной функцией, представляют собой «виртуальные таблицы», создан-
ные из предложения FROM и затем прошедшие через фильтрацию и группировку WHERE и GROUP BY
и, возможно, условие HAVING. Например, строка, отфильтрованная из-за нарушения условия WHERE,
не будет видна для оконных функций. Запрос может содержать несколько оконных функций, раз-
деляющих данные по-разному с применением разных предложений OVER, но все они будут обраба-
тывать один и тот же набор строк этой виртуальной таблицы.
Мы уже видели, что ORDER BY можно опустить, если порядок строк не важен. Также возможно
опустить PARTITION BY, в этом случае образуется один раздел, содержащий все строки.
Есть ещё одно важное понятие, связанное с оконными функциями: для каждой строки существует
набор строк в её разделе, называемый рамкой окна. Некоторые оконные функции обрабатывают
только строки рамки окна, а не всего раздела. По умолчанию с указанием ORDER BY рамка состоит
из всех строк от начала раздела до текущей строки и строк, равных текущей по значению выра-
1
жения ORDER BY. Без ORDER BY рамка по умолчанию состоит из всех строк раздела. Посмотрите
на пример использования sum:
SELECT salary, sum(salary) OVER () FROM empsalary;
salary | sum
——–+——-
5200 | 47100
5000 | 47100
3500 | 47100
4800 | 47100
3900 | 47100
4200 | 47100
4500 | 47100
4800 | 47100
6000 | 47100
5200 | 47100
(10 rows)
Так как в этом примере нет указания ORDER BY в предложении OVER, рамка окна содержит все
строки раздела, а он, в свою очередь, без предложения PARTITION BY включает все строки таблицы;
другими словами, сумма вычисляется по всей таблице и мы получаем один результат для каждой
строки результата. Но если мы добавим ORDER BY, мы получим совсем другие результаты:
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
salary | sum
——–+——-
3500 | 3500
3900 | 7400
4200 | 11600
4500 | 16100
4800 | 25700
1
Рамки окна можно определять и другими способами, но в этом введении они не рассматриваются. Узнать о них подробнее вы можете в Подразделе 4.2.8.
18Расширенные возможности
4800 |
5000 |
5200 |
5200 |
6000 |
(10 rows)
25700
30700
41100
41100
47100
Здесь в сумме накапливаются зарплаты от первой (самой низкой) до текущей, включая повторяю-
щиеся текущие значения (обратите внимание на результат в строках с одинаковой зарплатой).
Оконные функции разрешается использовать в запросе только в списке SELECT и предложении
ORDER BY. Во всех остальных предложениях, включая GROUP BY, HAVING и WHERE, они запрещены.
Это объясняется тем, что логически они выполняются после этих предложений, а также после
не оконных агрегатных функций, и значит агрегатную функцию можно вызывать в аргументах
оконной, но не наоборот.
Если вам нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы
можете использовать вложенный запрос. Например:
SELECT depname, empno, salary, enroll_date
FROM
(SELECT depname, empno, salary, enroll_date,
rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
FROM empsalary
) AS ss
WHERE pos &lt; 3;
Данный запрос покажет только те строки внутреннего запроса, у которых rank (порядковый номер)
меньше 3.
Когда в запросе вычисляются несколько оконных функций для одинаково определённых окон, ко-
нечно можно написать для каждой из них отдельное предложение OVER, но при этом оно будет
дублироваться, что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна
выделить в предложение WINDOW, а затем ссылаться на него в OVER. Например:
SELECT sum(salary) OVER w, avg(salary) OVER w
FROM empsalary
WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
Подробнее об оконных функциях можно узнать в Подразделе 4.2.8, Разделе 9.21, Подразделе 7.2.5
и в справке SELECT.
3.6. Наследование
Наследование — это концепция, взятая из объектно-ориентированных баз данных. Она открывает
множество интересных возможностей при проектировании баз данных.
Давайте создадим две таблицы: cities (города) и capitals (столицы штатов). Естественно, столи-
цы штатов также являются городами, поэтому нам нужно явным образом добавлять их в резуль-
тат, когда мы хотим просмотреть все города. Если вы проявите смекалку, вы можете предложить,
например, такое решение:
CREATE TABLE
name
population
altitude
state
);
capitals (
text,
real,
int,
– (высота в футах)
char(2)
CREATE TABLE non_capitals (
name
text,
19Расширенные возможности
population real,
altitude
int
– (высота в футах)
);
CREATE VIEW cities AS
SELECT name, population, altitude FROM capitals
UNION
SELECT name, population, altitude FROM non_capitals;
Оно может устраивать, пока мы извлекаем данные, но если нам потребуется изменить несколько
строк, это будет выглядеть некрасиво.
Поэтому есть лучшее решение:
CREATE TABLE
name
population
altitude
);
cities (
text,
real,
int
– (высота в футах)
CREATE TABLE capitals (
state
char(2)
) INHERITS (cities);
В данном случае строка таблицы capitals наследует все столбцы (name, population и altitude)
от родительской таблицы cities. Столбец name имеет тип text, собственный тип PostgreSQL для
текстовых строк переменной длины. А в таблицу столиц добавлен дополнительный столбец state,
в котором будет указан штат. В PostgreSQL таблица может наследоваться от нуля или нескольких
других таблиц.
Например, следующий запрос выведет названия всех городов, включая столицы, находящихся вы-
ше 500 футов над уровнем моря:
SELECT name, altitude
FROM cities
WHERE altitude &gt; 500;
Результат его выполнения:
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Madison
|
845
(3 rows)
А следующий запрос находит все города, которые не являются столицами штатов, но также нахо-
дятся выше 500 футов:
SELECT name, altitude
FROM ONLY cities
WHERE altitude &gt; 500;
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
(2 rows)
Здесь слово ONLY перед названием таблицы cities указывает, что запрос следует выполнять только
для строк таблицы cities, не включая таблицы, унаследованные от cities. Многие операторы,
которые мы уже обсудили — SELECT, UPDATE и DELETE — поддерживают указание ONLY.
20Расширенные возможности
Примечание
Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уни-
кальности и внешними ключами, что ограничивает его применимость. Подробнее это
описывается в Разделе 5.9.
3.7. Заключение
PostgreSQL имеет множество возможностей, не затронутых в этом кратком введении, рассчитан-
ном на начинающих пользователей SQL. Эти возможности будут рассмотрены в деталях в продол-
жении книги.
Если вам необходима дополнительная вводная информация, посетите сайт PostgreSQL, там вы
найдёте ссылки на другие ресурсы.
21</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-002/" title="Глава 2. Язык SQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 2. Язык SQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-002/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-002/" rel="bookmark" title="Глава 2. Язык SQL" itemprop="url">Глава 2. Язык SQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 2. Язык SQL</p>

<p>2.1. Введение</p>

<p>В этой главе рассматривается использование SQL для выполнения простых операций. Она призва-
на только познакомить вас с SQL, но ни в коей мере не претендует на исчерпывающее руководство.
Про SQL написано множество книг, включая melt93 и date97. При этом следует учитывать, что
некоторые возможности языка PostgreSQL являются расширениями стандарта.
В следующих примерах мы предполагаем, что вы создали базу данных mydb, как описано в преды-
дущей главе, и смогли запустить psql.
Примеры этого руководства также можно найти в пакете исходного кода PostgreSQL в каталоге
src/tutorial/. (Двоичные дистрибутивы PostgreSQL могут не включать эти файлы.) Чтобы исполь-
зовать эти файлы, перейдите в этот каталог и запустите make:
$ cd …./src/tutorial
$ make
При этом будут созданы скрипты и скомпилированы модули C, содержащие пользовательские
функции и типы. Затем, чтобы начать работу с учебным материалом, выполните следующее:
$ cd …./tutorial
$ psql -s mydb
…
mydb=&gt; \i basics.sql
Команда \i считывает и выполняет команды из заданного файла. Переданный psql параметр -
s переводит его в пошаговый режим, когда он делает паузу перед отправкой каждого оператора
серверу. Команды, используемые в этом разделе, содержатся в файле basics.sql.
2.2. Основные понятия
PostgreSQL — это реляционная система управления базами данных (РСУБД). Это означает, что
это система управления данными, представленными в виде отношений (relation). Отношение —
это математически точное обозначение таблицы. Хранение данных в таблицах так распростране-
но сегодня, что это кажется самым очевидным вариантом, хотя есть множество других способов
организации баз данных. Например, файлы и каталоги в Unix-подобных операционных системах
образуют иерархическую базу данных, а сегодня активно развиваются объектно-ориентированные
базы данных.
Любая таблица представляет собой именованный набор строк. Все строки таблицы имеют одина-
ковый набор именованных столбцов, при этом каждому столбцу назначается определённый тип
данных. Хотя порядок столбцов во всех строках фиксирован, важно помнить, что SQL не гаранти-
рует какой-либо порядок строк в таблице (хотя их можно явно отсортировать при выводе).
Таблицы объединяются в базы данных, а набор баз данных, управляемый одним экземпляром сер-
вера PostgreSQL, образует кластер баз данных.
2.3. Создание таблицы
Вы можете создать таблицу, указав её имя и перечислив все имена столбцов и их типы:
CREATE TABLE weather (
city
varchar(80),
temp_lo
int,
temp_hi
int,
– минимальная температура дня
– максимальная температура дня
6Язык SQL
prcp
date
real,
date
– уровень осадков
);
Весь этот текст можно ввести в psql вместе с символами перевода строк. psql понимает, что ко-
манда продолжается до точки с запятой.
В командах SQL можно свободно использовать пробельные символы (пробелы, табуляции и пере-
воды строк). Это значит, что вы можете ввести команду, выровняв её по-другому или даже уместив
в одной строке. Два минуса («–») обозначают начало комментария. Всё, что идёт за ними до конца
строки, игнорируется. SQL не чувствителен к регистру в ключевых словах и идентификаторах, за
исключением идентификаторов, взятых в кавычки (в данном случае это не так).
varchar(80) определяет тип данных, допускающий хранение произвольных символьных строк дли-
ной до 80 символов. int — обычный целочисленный тип. real — тип для хранения чисел с плаваю-
щей точкой одинарной точности. date — тип даты. (Да, столбец типа date также называется date.
Это может быть удобно или вводить в заблуждение — как посмотреть.)
PostgreSQL поддерживает стандартные типы SQL: int, smallint, real, double precision, char(N),
varchar(N), date, time, timestamp и interval, а также другие универсальные типы и богатый набор
геометрических типов. Кроме того, PostgreSQL можно расширять, создавая набор собственных ти-
пов данных. Как следствие, имена типов не являются ключевыми словами в данной записи, кроме
тех случаев, когда это требуется для реализации особых конструкций стандарта SQL.
Во втором примере мы сохраним в таблице города и их географическое положение:
CREATE TABLE cities (
name
varchar(80),
location
point
);
Здесь point — пример специфического типа данных PostgreSQL.
Наконец, следует сказать, что если вам больше не нужна какая-либо таблица, или вы хотите пере-
создать её по-другому, вы можете удалить её, используя следующую команду:
DROP TABLE имя_таблицы;
2.4. Добавление строк в таблицу
Для добавления строк в таблицу используется оператор INSERT:
INSERT INTO weather VALUES (‘San Francisco’, 46, 50, 0.25, ‘1994-11-27’);
Заметьте, что для всех типов данных применяются довольно очевидные форматы. Константы, за
исключением простых числовых значений, обычно заключаются в апострофы (‘), как в данном
примере. Тип date на самом деле очень гибок и принимает разные форматы, но в данном введении
мы будем придерживаться простого и однозначного.
Тип point требует ввода пары координат, например таким образом:
INSERT INTO cities VALUES (‘San Francisco’, ‘(-194.0, 53.0)’);
Показанный здесь синтаксис требует, чтобы вы запомнили порядок столбцов. Можно также при-
менить альтернативную запись, перечислив столбцы явно:
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
VALUES (‘San Francisco’, 43, 57, 0.0, ‘1994-11-29’);
Вы можете перечислить столбцы в другом порядке, если желаете опустить некоторые из них, на-
пример, если уровень осадков (столбец prcp) неизвестен:
INSERT INTO weather (date, city, temp_hi, temp_lo)
VALUES (‘1994-11-29’, ‘Hayward’, 54, 37);
7Язык SQL
Многие разработчики предпочитают явно перечислять столбцы, а не полагаться на их порядок в
таблице.
Пожалуйста, введите все показанные выше команды, чтобы у вас были данные, с которыми можно
будет работать дальше.
Вы также можете загрузить большой объём данных из обычных текстовых файлов, применив ко-
манду COPY. Обычно это будет быстрее, так как команда COPY оптимизирована для такого приме-
нения, хотя и менее гибка, чем INSERT. Например, её можно использовать так:
COPY weather FROM ‘/home/user/weather.txt’;
здесь подразумевается, что данный файл доступен на компьютере, где работает серверный про-
цесс, а не на клиенте, так как указанный файл будет прочитан непосредственно на сервере. По-
дробнее об этом вы можете узнать в описании команды COPY.
2.5. Выполнение запроса
Чтобы получить данные из таблицы, нужно выполнить запрос. Для этого предназначен SQL-опе-
ратор SELECT. Он состоит из нескольких частей: выборки (в которой перечисляются столбцы, ко-
торые должны быть получены), списка таблиц (в нём перечисляются таблицы, из которых будут
получены данные) и необязательного условия (определяющего ограничения). Например, чтобы
получить все строки таблицы weather, введите:
SELECT * FROM weather;
Здесь * — это краткое обозначение «всех столбцов».
1
Таким образом, это равносильно записи:
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
В результате должно получиться:
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
43 |
57 |
0 | 1994-11-29
Hayward
|
37 |
54 |
| 1994-11-29
(3 rows)
В списке выборки вы можете писать не только ссылки на столбцы, но и выражения. Например,
вы можете написать:
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
И получить в результате:
city
| temp_avg |
date
—————+———-+————
San Francisco |
48 | 1994-11-27
San Francisco |
50 | 1994-11-29
Hayward
|
45 | 1994-11-29
(3 rows)
Обратите внимание, как предложение AS позволяет переименовать выходной столбец. (Само слово
AS можно опускать.)
Запрос можно дополнить «условием», добавив предложение WHERE, ограничивающее множество
возвращаемых строк. В предложении WHERE указывается логическое выражение (проверка истин-
ности), которое служит фильтром строк: в результате оказываются только те строки, для которых
это выражение истинно. В этом выражении могут присутствовать обычные логические операто-
ры (AND, OR и NOT). Например, следующий запрос покажет, какая погода была в Сан-Франциско в
дождливые дни:
1
Хотя запросы SELECT * часто пишут экспромтом, это считается плохим стилем в производственном коде, так как результат таких запросов будет меняться
при добавлении новых столбцов.
8Язык SQL
SELECT * FROM weather
WHERE city = ‘San Francisco’ AND prcp &gt; 0.0;
Результат:
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
(1 row)
Вы можете получить результаты запроса в определённом порядке:
SELECT * FROM weather
ORDER BY city;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
Hayward
|
37 |
54 |
| 1994-11-29
San Francisco |
43 |
57 |
0 | 1994-11-29
San Francisco |
46 |
50 | 0.25 | 1994-11-27
В этом примере порядок сортировки определён не полностью, поэтому вы можете получить стро-
ки Сан-Франциско в любом порядке. Но вы всегда получите результат, показанный выше, если
напишете:
SELECT * FROM weather
ORDER BY city, temp_lo;
Если требуется, вы можете убрать дублирующиеся строки из результата запроса:
SELECT DISTINCT city
FROM weather;
city
—————
Hayward
San Francisco
(2 rows)
И здесь порядок строк также может варьироваться. Чтобы получать неизменные результаты, со-
2
едините предложения DISTINCT и ORDER BY:
SELECT DISTINCT city
FROM weather
ORDER BY city;
2.6. Соединения таблиц
До этого все наши запросы обращались только к одной таблице. Однако запросы могут также об-
ращаться сразу к нескольким таблицам или обращаться к той же таблице так, что одновременно
будут обрабатываться разные наборы её строк. Запрос, обращающийся к разным наборам строк
одной или нескольких таблиц, называется соединением (JOIN). Например, мы захотели перечис-
лить все погодные события вместе с координатами соответствующих городов. Для этого мы долж-
ны сравнить столбец city каждой строки таблицы weather со столбцом name всех строк таблицы
cities и выбрать пары строк, для которых эти значения совпадают.
Примечание
Это не совсем точная модель. Обычно соединения выполняются эффективнее (сравни-
ваются не все возможные пары строк), но это скрыто от пользователя.
2
В некоторых СУБД, включая старые версии PostgreSQL, реализация предложения DISTINCT автоматически упорядочивает строки, так что ORDER BY добав-
лять не обязательно. Но стандарт SQL этого не требует и текущая версия PostgreSQL не гарантирует определённого порядка строк после DISTINCT.
9Язык SQL
Это можно сделать с помощью следующего запроса:
SELECT *
FROM weather, cities
WHERE city = name;
city
|temp_lo|temp_hi| prcp|
date
|
name
| location
————–+——-+——-+—–+———–+————–+———-
San Francisco|
46|
50| 0.25| 1994-11-27| San Francisco| (-194,53)
San Francisco|
43|
57|
0| 1994-11-29| San Francisco| (-194,53)
(2 rows)
Обратите внимание на две особенности полученных данных:
• В результате нет строки с городом Хейуорд (Hayward). Так получилось потому, что в таблице
cities нет строки для данного города, а при соединении все строки таблицы weather, для ко-
торых не нашлось соответствие, опускаются. Вскоре мы увидим, как это можно исправить.
• Название города оказалось в двух столбцах. Это правильно и объясняется тем, что столбцы
таблиц weather и cities были объединены. Хотя на практике это нежелательно, поэтому луч-
ше перечислить нужные столбцы явно, а не использовать *:
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
Упражнение:
Попробуйте определить, что будет делать этот запрос без предложения WHERE.
Так как все столбцы имеют разные имена, анализатор запроса автоматически понимает, к какой
таблице они относятся. Если бы имена столбцов в двух таблицах повторялись, вам пришлось бы
дополнить имена столбцов, конкретизируя, что именно вы имели в виду:
SELECT weather.city, weather.temp_lo, weather.temp_hi,
weather.prcp, weather.date, cities.location
FROM weather, cities
WHERE cities.name = weather.city;
Вообще хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтобы
запрос не поломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.
Запросы соединения, которые вы видели до этого, можно также записать в другом виде:
SELECT *
FROM weather INNER JOIN cities ON (weather.city = cities.name);
Эта запись не так распространена, как первый вариант, но мы показываем её, чтобы вам было
проще понять следующие темы.
Сейчас мы выясним, как вернуть записи о погоде в городе Хейуорд. Мы хотим, чтобы запрос про-
сканировал таблицу weather и для каждой её строки нашёл соответствующую строку в таблице
cities. Если же такая строка не будет найдена, мы хотим, чтобы вместо значений столбцов из таб-
лицы cities были подставлены «пустые значения». Запросы такого типа называются внешними
соединениями. (Соединения, которые мы видели до этого, называются внутренними.) Эта команда
будет выглядеть так:
SELECT *
FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);
city
|temp_lo|temp_hi| prcp|
date
|
name
| location
————–+——-+——-+—–+———–+————–+———-
Hayward
|
37|
54|
| 1994-11-29|
|
San Francisco|
46|
50| 0.25| 1994-11-27| San Francisco| (-194,53)
San Francisco|
43|
57|
0| 1994-11-29| San Francisco| (-194,53)
(3 rows)
10Язык SQL
Этот запрос называется левым внешним соединением, потому что из таблицы в левой части опе-
ратора будут выбраны все строки, а из таблицы справа только те, которые удалось сопоставить
каким-нибудь строкам из левой. При выводе строк левой таблицы, для которых не удалось найти
соответствия в правой, вместо столбцов правой таблицы подставляются пустые значения (NULL).
Упражнение:  Существуют также правые внешние соединения и полные внешние соединения.
Попробуйте выяснить, что они собой представляют.
В соединении мы также можем замкнуть таблицу на себя. Это называется замкнутым соединени-
ем. Например, представьте, что мы хотим найти все записи погоды, в которых температура лежит в
диапазоне температур других записей. Для этого мы должны сравнить столбцы temp_lo и temp_hi
каждой строки таблицы weather со столбцами temp_lo и temp_hi другого набора строк weather.
Это можно сделать с помощью следующего запроса:
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
W2.city, W2.temp_lo AS low, W2.temp_hi AS high
FROM weather W1, weather W2
WHERE W1.temp_lo &lt; W2.temp_lo
AND W1.temp_hi &gt; W2.temp_hi;
city
| low | high |
city
| low | high
—————+—–+——+—————+—–+——
San Francisco | 43 |
57 | San Francisco | 46 |
50
Hayward
| 37 |
54 | San Francisco | 46 |
50
(2 rows)
Здесь мы ввели новые обозначения таблицы weather: W1 и W2, чтобы можно было различить левую
и правую стороны соединения. Вы можете использовать подобные псевдонимы и в других запросах
для сокращения:
SELECT *
FROM weather w, cities c
WHERE w.city = c.name;
Вы будете встречать сокращения такого рода довольно часто.
2.7. Агрегатные функции
Как большинство других серверов реляционных баз данных, PostgreSQL поддерживает агрегатные
функции. Агрегатная функция вычисляет единственное значение, обрабатывая множество строк.
Например, есть агрегатные функции, вычисляющие: count (количество), sum (сумму), avg (сред-
нее), max (максимум) и min (минимум) для набора строк.
К примеру, мы можем найти самую высокую из всех минимальных дневных температур:
SELECT max(temp_lo) FROM weather;
max
—–
46
(1 row)
Если мы хотим узнать, в каком городе (или городах) наблюдалась эта температура, можно попро-
бовать:
SELECT city FROM weather WHERE temp_lo = max(temp_lo);
НЕВЕРНО
но это не будет работать, так как агрегатную функцию max нельзя использовать в предложении
WHERE. (Это ограничение объясняется тем, что предложение WHERE должно определить, для каких
строк вычислять агрегатную функцию, так что оно, очевидно, должно вычисляться до агрегатных
функций.) Однако, как часто бывает, запрос можно перезапустить и получить желаемый резуль-
тат, применив подзапрос:
SELECT city FROM weather
11Язык SQL
WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
city
—————
San Francisco
(1 row)
Теперь всё в порядке — подзапрос выполняется отдельно и результат агрегатной функции вычис-
ляется вне зависимости от того, что происходит во внешнем запросе.
Агрегатные функции также очень полезны в сочетании с предложением GROUP BY. Например, мы
можем получить максимум минимальной дневной температуры в разрезе городов:
SELECT city, max(temp_lo)
FROM weather
GROUP BY city;
city
| max
—————+—–
Hayward
| 37
San Francisco | 46
(2 rows)
Здесь мы получаем по одной строке для каждого города. Каждый агрегатный результат вычисля-
ется по строкам таблицы, соответствующим отдельному городу. Мы можем отфильтровать сгруп-
пированные строки с помощью предложения HAVING:
SELECT city, max(temp_lo)
FROM weather
GROUP BY city
HAVING max(temp_lo) &lt; 40;
city
| max
———+—–
Hayward | 37
(1 row)
Мы получаем те же результаты, но только для тех городов, где все значения temp_lo меньше 40.
Наконец, если нас интересуют только города, названия которых начинаются с «S», мы можем сде-
лать:
SELECT city, max(temp_lo)
FROM weather
WHERE city LIKE ‘S%’
GROUP BY city
HAVING max(temp_lo) &lt; 40;
1
–
1
Оператор LIKE (выполняющий сравнение по шаблону) рассматривается в Разделе 9.7.
Важно понимать, как соотносятся агрегатные функции и SQL-предложения WHERE и HAVING. Основ-
ное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем груп-
пирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления
агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных
функций. Как следствие, предложение WHERE не должно содержать агрегатных функций; не име-
ет смысла использовать агрегатные функции для определения строк для вычисления агрегатных
функций. Предложение HAVING, напротив, всегда содержит агрегатные функции. (Строго говоря,
вы можете написать предложение HAVING, не используя агрегаты, но это редко бывает полезно. То
же самое условие может работать более эффективно на стадии WHERE.)
В предыдущем примере мы смогли применить фильтр по названию города в предложении WHERE,
так как названия не нужно агрегировать. Такой фильтр эффективнее, чем дополнительное ограни-
чение HAVING, потому что с ним не приходится группировать и вычислять агрегаты для всех строк,
не удовлетворяющих условию WHERE.
12Язык SQL
2.8. Изменение данных
Данные в существующих строках можно изменять, используя команду UPDATE. Например, предпо-
ложим, что вы обнаружили, что все значения температуры после 28 ноября завышены на два гра-
дуса. Вы можете поправить ваши данные следующим образом:
UPDATE weather
SET temp_hi = temp_hi - 2,
WHERE date &gt; ‘1994-11-28’;
temp_lo = temp_lo - 2
Посмотрите на новое состояние данных:
SELECT * FROM weather;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
41 |
55 |
0 | 1994-11-29
Hayward
|
35 |
52 |
| 1994-11-29
(3 rows)
2.9. Удаление данных
Строки также можно удалить из таблицы, используя команду DELETE. Предположим, что вас боль-
ше не интересует погода в Хейуорде. В этом случае вы можете удалить ненужные строки из таб-
лицы:
DELETE FROM weather WHERE city = ‘Hayward’;
Записи всех наблюдений, относящиеся к Хейуорду, удалены.
SELECT * FROM weather;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
41 |
55 |
0 | 1994-11-29
(2 rows)
Остерегайтесь операторов вида
DELETE FROM имя_таблицы;
Без указания условия DELETE удалит все строки данной таблицы, полностью очистит её. При этом
система не попросит вас подтвердить операцию!</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page25/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page24/">24</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page25/">25</a></li>
      
    
      
        <li><strong class="current-page">26</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page27/">27</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page28/">28</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page27/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>