<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page7/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page7/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-060/" title="Глава 60. Генетический оптимизатор запросов"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 60. Генетический оптимизатор запросов"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-060/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~5 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-060/" rel="bookmark" title="Глава 60. Генетический оптимизатор запросов" itemprop="url">Глава 60. Генетический оптимизатор запросов</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 60. Генетический оптимизатор запросов</p>

<p>Автор
Разработал Мартин Утеш (<a href="mailto:utesch@aut.tu-freiberg.de">utesch@aut.tu-freiberg.de</a>) для Института автоматиче-
ского управления в Техническом университете Фрайбергская горная академия, Герма-
ния.
60.1. Обработка запроса как сложная задача оптими-
зации
Среди всех реляционных операторов самым сложным для обработки и оптимизации является со-
единение. В первую очередь потому, что по мере увеличения числа соединений в запросе число
возможных планов запроса увеличивается экспоненциально. Дополнительная сложность оптими-
зации связана с наличием различных методов соединения (например, в PostgreSQL это вложен-
ный цикл, соединение по хешу и соединение слиянием) для каждого отдельного соединения и раз-
нообразием индексов (например, в PostgreSQL это B-дерево, хеш, GiST и GIN), определяющих путь
доступа к отношениям.
Традиционный оптимизатор запросов PostgreSQL выполняет почти исчерпывающий поиск во всём
множестве возможных стратегий. Этот алгоритм, появившийся в СУБД IBM System R, находит
порядок соединений, близкий к оптимальному, но может требовать огромного количества време-
ни и памяти, когда число соединений оказывается большим. В результате обычный оптимизатор
PostgreSQL оказывается неподходящим для запросов, в которых соединяется большое количество
таблиц.
Институт автоматического управления в Техническом университете Фрайбергская горная акаде-
мия, Германия, столкнулся с этими проблемами, разрабатывая систему принятия решений на ос-
нове базы знаний для обслуживания электростанций, в которой в качестве СУБД планировалось
применять PostgreSQL. Для машины, делающей выводы на основе базы знаний, СУБД должна была
выполнять запросы с таким количеством соединений, что использование обычного оптимизатора
запросов оказалось неприемлемым.
Далее мы опишем реализацию генетического алгоритма, который решает проблему выбора по-
рядка соединений эффективным способом для запросов с большим числом соединений.
60.2. Генетические алгоритмы
Генетический алгоритм (ГА) реализует метод эвристической оптимизации, построенный на слу-
чайном поиске. В данном контексте множество возможных решений проблемы оптимизации на-
зывается популяцией особей. Степень адаптации особи к среде определяет функция приспособ-
ленности.
Координаты особи в пространстве поиска представляются хромосомами, которые по сути являют-
ся символьными строками. Фрагмент хромосомы, кодирующий значение одного оптимизируемого
параметра, называется геном. Обычно ген кодируется в виде двоичного или целочисленного зна-
чения.
В результате симуляции эволюционных операций (скрещивания, мутации и селекции) данный ал-
горитм формирует новые поколения особей, у которых приспособленность в среднем будет выше,
чем у их предшественников.
Как сказано в ответах на вопросы в группе comp.ai.genetic, нельзя не отметить, что ГА реализует
не чисто случайный поиск решения проблемы. В ГА происходят вероятностные процессы, но ре-
зультат явно оказывается не случайным (лучше случайного).
2115Генетический опти-
мизатор запросов
Рисунок 60.1. Диаграмма структуры генетического алгоритма
P(t) поколение предков на момент t
P’‘(t) поколение потомков на момент t
+=========================================+
|»»»»»&gt; Алгоритм ГА «««««««|
+=========================================+
| ИНИЦИАЛИЗАЦИЯ t := 0
|
+=========================================+
| ИНИЦИАЛИЗАЦИЯ P(t)
|
+=========================================+
| вычислить ПРИСПОСОБЛЕННОСТЬ P(t)
|
+=========================================+
| пока не выполняется УСЛОВИЕ ОСТАНОВКИ
|
|
+————————————-+
|
| P’(t) := СКРЕЩИВАНИЕ{P(t)}
|
|
+————————————-+
|
| P’‘(t) := МУТАЦИЯ{P’(t)}
|
|
+————————————-+
|
| P(t+1) := СЕЛЕКЦИЯ{P’‘(t) + P(t)}
|
|
+————————————-+
|
| вычислить ПРИСПОСОБЛЕННОСТЬ P’‘(t) |
|
+————————————-+
|
| t := t + 1
|
+===+=====================================+
60.3. Генетическая оптимизация запросов (GEQO) в
PostgreSQL
Модуль GEQO (Genetic Query Optimization, Генетическая оптимизация запросов) подходит к
проблеме оптимизации запроса как к хорошо известной задаче коммивояжёра (TSP, Traveling
Salesman Problem). Возможные планы запроса кодируются числами в строковом виде. Каждая
строка представляет порядок соединения одного отношения из запроса со следующим. Например,
дерево соединения
/\
/\ 2
/\ 3
4 1
кодируется строкой целых чисел ‘4-1-3-2’, которая означает: сначала соединить отношения ‘4’ и
‘1’, потом добавить ‘3’, а затем ‘2’, где 1, 2, 3, 4 — идентификаторы отношений внутри оптимизатора
PostgreSQL.
Реализация GEQO в PostgreSQL имеет следующие особые характеристики:
• Использование ГА с зафиксированным состоянием (когда заменяются наименее приспособ-
ленные особи популяции, а не всё поколение) способствует быстрой сходимости к улучшен-
ным планам запроса. Это важно для обработки запроса за приемлемое время;
• Использование скрещивания с обменом рёбер, которое очень удачно минимизирует число по-
терянных рёбер при решении задачи коммивояжёра с применением ГА;
• Мутация как генетический оператор считается устаревшей, так что для получения допусти-
мых путей TSP не требуются механизмы исправления.
Части модуля GEQO взяты из алгоритма Genitor, разработанного Д. Уитли.
В результате, модуль GEQO позволяет оптимизатору запросов PostgreSQL эффективно выполнять
запросы со множеством соединений, обходясь без полного перебора вариантов.
2116Генетический опти-
мизатор запросов
60.3.1. Построение возможных планов с GEQO
В процедуре планирования в GEQO используется код стандартного планировщика, который строит
планы сканирования отдельных отношений. Затем вырабатываются планы соединений с примене-
нием генетического подхода. Как было сказано выше, каждый план соединения представляется по-
следовательностью чисел, определяющей порядок соединений базовых отношений. На начальной
стадии код GEQO просто случайным образом генерирует несколько возможных последовательно-
стей. Затем для каждой рассматриваемой последовательности вызывается функция стандартного
планировщика, оценивающая стоимость запроса в случае выбора этого порядка соединений. (Для
каждого шага последовательности рассматриваются все три возможные стратегии соединения и
все изначально выбранные планы сканирования отношений. Результирующей оценкой стоимости
будет минимальная из всех возможных.) Последовательности соединений с наименьшей оценкой
стоимости считаются «более приспособленными», чем последовательности с большей оценкой.
Проанализировав возможные последовательности, генетический алгоритм отбрасывает наименее
приспособленные из них. Затем генерируются новые кандидаты путём объединения генов более
приспособленных последовательностей — для этого выбираются случайные фрагменты известных
последовательностей с низкой стоимостью, из которых складываются новые последовательности
для рассмотрения. Этот процесс повторяется, пока не будет рассмотрено некоторое предопреде-
лённое количество последовательностей соединений; после этого для построения окончательного
плана выбирается лучшая последовательность, найденная за всё время поиска.
Этот процесс по природе своей недетерминирован, вследствие случайного выбора при форми-
ровании начальной популяции и последующей «мутации» лучших кандидатов. Но во избежание
неожиданных изменений выбранного плана, на каждом проходе алгоритм GEQO перезапускает
свой генератор случайных чисел с текущим значением параметра geqo_seed. Поэтому пока зна-
чение geqo_seed и другие параметры GEQO остаются неизменными, для определённого запроса
(и других входных данных планировщика, в частности, статистики) будет строиться один и тот же
план. Если вы хотите поэкспериментировать с разными путями соединений, попробуйте изменить
geqo_seed.
60.3.2. Будущее развитие модуля PostgreSQL GEQO
Требуется провести дополнительную работу для выбора оптимальных параметров генетического
алгоритма. В файле src/backend/optimizer/geqo/geqo_main.c, подпрограммах gimme_pool_size
и gimme_number_generations, мы должны найти компромиссные значения параметров, удовлетво-
ряющие двум несовместимым требованиям:
• Оптимальность плана запроса
• Время вычисления
В текущей реализации приспособленность каждой рассматриваемой последовательности соеди-
нений рассчитывается стандартным планировщиком, который каждый раз вычисляет избиратель-
ность соединения и стоимость заново. С учётом того, что различные кандидаты могут содержать
общие подпоследовательности соединений, при этом будет повторяться большой объём работы.
Таким образом, расчёт можно значительно ускорить, сохраняя оценки стоимости для внутренних
соединений, но сложность состоит в том, чтобы уместить это состояние в разумные объёмы памяти.
На более общем уровне не вполне понятно, насколько уместно для оптимизации запросов исполь-
зовать ГА, предназначенный для решения задачи коммивояжёра. В этой задаче стоимость, свя-
занная с любой подстрокой (частью тура) не зависит от остального маршрута, но это определённо
не так для оптимизации запросов. Таким образом, возникает вопрос, насколько эффективно скре-
щивание путём обмена рёбрами.
60.4. Дополнительные источники информации
Дополнительную информацию о генетических алгоритмах можно получить в следующих источни-
ках:
• The Hitch-Hiker’s Guide to Evolutionary Computation, (Руководство для путешествующих авто-
стопом по эволюционным вычислениям, Ответы на часто задаваемые вопросы в группе news://
comp.ai.genetic)
2117Генетический опти-
мизатор запросов
• Evolutionary Computation and its application to art and design (Эволюционные вычисления и их
применение в искусстве и дизайне), Крейг Рейнольдс
• elma04
• fong
2118</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-059/" title="Глава 59. Написание провайдера нестандартного сканирования"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 59. Написание провайдера нестандартного сканирования"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-059/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~7 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-059/" rel="bookmark" title="Глава 59. Написание провайдера нестандартного сканирования" itemprop="url">Глава 59. Написание провайдера нестандартного сканирования</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 59. Написание провайдера нестандартного сканирования</p>

<p>PostgreSQL поддерживает набор экспериментальных средств, предназначенных для того, чтобы
модули расширения могли добавлять в систему новые типы сканирования. В отличие от обёртки
сторонних данных, которая должна знать, как сканировать только собственные таблицы, провай-
дер сканирования может реализовать нестандартный вариант сканирования любого отношения в
системе. Обычно к написанию провайдера нестандартного сканирования подталкивает желание
реализовать какую-то оптимизацию, не поддерживаемую основной системой, например, кеширо-
вание или аппаратное ускорение некоторого рода. В этой главе рассказывается, как написать свой
провайдер нестандартного сканирования.
Процесс реализации нестандартного сканирования нового типа состоит из трёх этапов. Во-пер-
вых, во время планирования необходимо построить пути доступа, представляющие сканирование
с предлагаемой стратегией. Во-вторых, если один из этих путей доступа выбирается планировщи-
ком как оптимальная стратегия сканирования определённого отношения, этот путь доступа дол-
жен быть преобразован в план. Наконец, должно быть возможно выполнить этот план, получив
при этом те же результаты, что были бы получены с любым другим путём доступа, выбранным для
того же отношения.
59.1. Создание нестандартных путей сканирования
Провайдер нестандартного сканирования обычно добавляет пути для базового отношения, уста-
новив следующий обработчик, который вызывается после того, как ядро системы построит, по её
мнению, полный и корректный набор путей доступа для отношения.
typedef void (<em>set_rel_pathlist_hook_type) (PlannerInfo *root,
RelOptInfo *rel,
Index rti,
RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
Хотя эта функция-обработчик может изучать, изменять или удалять пути, сформированные основ-
ной системой, провайдер нестандартного сканирования обычно ограничивается созданием объек-
тов CustomPath и добавлением их в rel (с помощью add_path). Провайдер нестандартного скани-
рования отвечает за инициализацию объекта CustomPath, который описан так:
typedef struct CustomPath
{
Path
path;
uint32
flags;
List
*custom_paths;
List
*custom_private;
const CustomPathMethods *methods;
} CustomPath;
Поле path должно инициализироваться как для любого другого пути и включать оцен-
ку числа строк, стоимость запуска и общую, а также порядок сортировки, устанавли-
ваемый этим путём. Поле flags задаёт битовую маску, которая должна включать флаг
CUSTOMPATH_SUPPORT_BACKWARD_SCAN, если нестандартный путь поддерживает сканирование назад,
и CUSTOMPATH_SUPPORT_MARK_RESTORE, если он поддерживает пометку позиции и её восстановление.
Обе эти возможности являются факультативными. В необязательном поле custom_paths задаётся
список узлов Path, используемых данным узлом; они будут преобразованы планировщиком в узлы
Plan. В поле custom_private могут быть сохранены внутренние данные нестандартного пути. Со-
хранять их нужно в форме, которую может принять nodeToString, чтобы отладочные процедуры,
пытающиеся вывести нестандартный путь, работали ожидаемым образом. Поле methods должно
указывать на объект (обычно статически размещённый), реализующий требуемые методы нестан-
дартного пути (на данный момент это один метод). В этом объекте также должны быть инициа-
2110Написание провайдера нестан-
дартного сканирования
лизированы поля LibraryName и SymbolName, чтобы динамический загрузчик мог разрешить их и
загрузить таблицу методов.
Провайдер нестандартного сканирования может также реализовать пути соединений. Как и для
базовых отношений, такой путь должен выдавать тот же результат, какой был бы получен обычным
соединением, которое он заменяет. Для этого провайдер соединения должен установить следую-
щий обработчик, а затем внутри функции-обработчика создать пути CustomPath для отношения
соединения.
typedef void (</em>set_join_pathlist_hook_type) (PlannerInfo <em>root,
RelOptInfo *joinrel,
RelOptInfo *outerrel,
RelOptInfo *innerrel,
JoinType jointype,
JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
Этот обработчик будет вызываться многократно для одного отношения соединения с разными со-
четаниями внутренних и внешних отношений; задача обработчика — минимизировать при этом
дублирующиеся операции.
59.1.1. Обработчики пути нестандартного сканирования
Plan *(</em>PlanCustomPath) (PlannerInfo <em>root,
RelOptInfo *rel,
CustomPath *best_path,
List *tlist,
List *clauses,
List *custom_plans);
Преобразует нестандартный путь в законченный план. Возвращаемым значением обычно будет
объект CustomScan, который этот обработчик должен разместить в памяти и инициализировать. За
подробностями обратитесь к Разделу 59.2.
59.2. Создание нестандартных планов сканирования
Нестандартное сканирование представляется в окончательном дереве плана в виде следующей
структуры:
typedef struct CustomScan
{
Scan
scan;
uint32
flags;
List
*custom_plans;
List
*custom_exprs;
List
*custom_private;
List
*custom_scan_tlist;
Bitmapset *custom_relids;
const CustomScanMethods *methods;
} CustomScan;
Объект в поле scan должен быть инициализирован, как и для любого другого сканирования, и
включать оценки стоимости, целевые списки, условия и т. д. Поле flags содержит битовую мас-
ку с тем же значением, что и в CustomPath. В поле custom_plans могут быть сохранены дочерние
узлы Plan. В custom_exprs могут быть сохранены деревья выражений, которые будут исправлять-
ся кодом в setrefs.c и subselect.c, а в custom_private следует сохранить другие внутренние
данные, которые будут использоваться только самим провайдером нестандартного сканирования.
Поле custom_scan_tlist может содержать NIL при сканировании базового отношения, что будет
показывать, что нестандартное сканирование возвращает кортежи, соответствующие типу строк
базового отношения. В противном случае оно должно указывать на целевой список, описывающий
2111Написание провайдера нестан-
дартного сканирования
фактические кортежи. Список custom_scan_tlist должен устанавливаться при соединениях и мо-
жет задаваться при сканировании, если провайдер сканирования может вычислять какие-либо вы-
ражения без переменных. Поле custom_relids заполняется ядром и задаёт набор отношений (ин-
дексов в списке отношений), которые обрабатывает данный узел сканирования; когда имеет место
сканирование, а не соединение, в этом списке будет всего один элемент. Поле methods должно
указывать на объект (обычно статически размещённый), реализующий требуемые методы нестан-
дартного сканирования, которые подробнее описываются ниже.
Когда CustomScan сканирует одно отношение, в scan.scanrelid должен задаваться индекс скани-
руемой таблицы в списке отношений. Когда он заменяет соединение, поле scan.scanrelid должно
быть нулевым.
Деревья планов должны поддерживать возможность копирования функцией copyObject, так что
все данные, сохранённые в «дополнительных» полях, должны быть узлами, которые может об-
работать эта функция. Более того, провайдеры нестандартного сканирования не могут заменять
структуру CustomScan расширенной структурой, её содержащей, что возможно с CustomPath или
CustomScanState.
59.2.1. Обработчики плана нестандартного сканирования
Node *(</em>CreateCustomScanState) (CustomScan <em>cscan);
Выделяет структуру CustomScanState для заданного объекта CustomScan. Фактически выделенная
область будет обычно больше, чем требуется для самой структуры CustomScanState, так как мно-
гие провайдеры могут включать её в расширенную структуру в качестве первого поля. В возвра-
щаемом значении должны быть подходящим образом заполнены тег узла и поле methods, но дру-
гие поля на данном этапе должны быть обнулены; после того как ExecInitCustomScan произведёт
базовую инициализацию, будет вызван обработчик BeginCustomScan, в котором провайдер нестан-
дартного сканирования может выполнить все остальные требуемые действия.
59.3. Выполнение нестандартного сканирования
Когда выполняется узел CustomScan, его состояние представляется структурой CustomScanState,
объявленной следующим образом:
typedef struct CustomScanState
{
ScanState ss;
uint32
flags;
const CustomExecMethods *methods;
} CustomScanState;
Поле ss инициализируется как и для состояния любого другого сканирования, за исключе-
нием того, что когда это сканирование для соединения, а не для базового отношения, в
ss.ss_currentRelation остаётся NULL. Поле flags содержит битовую маску с тем же значени-
ем, что и в CustomPath и CustomScan. Поле methods должно указывать на объект (обычно стати-
чески размещённый), реализующий требуемые методы состояния нестандартного сканирования,
подробнее описанные ниже. Обычно структура CustomScanState, которой не нужно поддерживать
copyObject, фактически включается в расширенную структуру в качестве её первого члена.
59.3.1. Обработчики выполнения нестандартного сканирования
void (</em>BeginCustomScan) (CustomScanState <em>node,
EState *estate,
int eflags);
Завершает инициализацию переданного объекта CustomScanState. Стандартные поля инициали-
зируются в ExecInitCustomScan, но все внутренние поля должны инициализироваться здесь.
TupleTableSlot *(</em>ExecCustomScan) (CustomScanState <em>node);
2112Написание провайдера нестан-
дартного сканирования
Считывает следующий кортеж. В случае наличия кортежей эта функция должна записать в
ps_ResultTupleSlot следующий кортеж в текущем направлении сканирования и вернуть слот с
кортежем. Если же кортежей больше нет, она должна вернуть NULL или пустой слот.
void (</em>EndCustomScan) (CustomScanState <em>node);
Очищает все внутренние данные, связанные с CustomScanState. Этот метод является обязатель-
ным, но он может ничего не делать, если такие данные отсутствуют или они будут очищены авто-
матически.
void (</em>ReScanCustomScan) (CustomScanState <em>node);
Возвращает позицию текущего сканирования в начало и подготавливает повторное сканирование
отношения.
void (</em>MarkPosCustomScan) (CustomScanState <em>node);
Сохраняет текущую позицию сканирования, чтобы к ней впоследствии можно было вернуться,
вызвав обработчик RestrPosCustomScan. Данный обработчик является необязательным и должен
присутствовать, только если установлен флаг CUSTOMPATH_SUPPORT_MARK_RESTORE.
void (</em>RestrPosCustomScan) (CustomScanState <em>node);
Восстанавливает
предыдущую
позицию
сканирования,
сохранённую
обработчиком
MarkPosCustomScan. Данный обработчик является необязательным и должен присутствовать, толь-
ко если установлен флаг CUSTOMPATH_SUPPORT_MARK_RESTORE.
Size (</em>EstimateDSMCustomScan) (CustomScanState <em>node,
ParallelContext *pcxt);
Оценивает объём динамической разделяемой памяти, которая потребуется для параллельной опе-
рации. Это значение может превышать объём, который будет занят фактически, но не должно быть
меньше. Возвращаемое значение задаётся в байтах. Этот обработчик не является обязательным
и должен устанавливаться, только если провайдер нестандартного сканирования поддерживает
параллельное выполнение.
void (</em>InitializeDSMCustomScan) (CustomScanState <em>node,
ParallelContext *pcxt,
void *coordinate);
Инициализирует динамическую разделяемую память, которая потребуется для параллельной опе-
рации; coordinate указывает на область разделяемой памяти размера, равного возвращаемому
значению EstimateDSMCustomScan. Этот обработчик является необязательным и должен устанав-
ливаться, только если провайдер нестандартного сканирования поддерживает параллельное вы-
полнение.
void (</em>ReInitializeDSMCustomScan) (CustomScanState <em>node,
ParallelContext *pcxt,
void *coordinate);
Заново инициализирует динамическую разделяемую память, требуемую для параллельной опера-
ции, перед тем как будет повторно просканирован узел нестандартного сканирования. Этот обра-
ботчик является необязательным и должен устанавливаться, только если провайдер нестандарт-
ного сканирования поддерживает параллельное выполнение. В этом обработчике рекомендуется
сбрасывать только общее состояние, а в обработчике ReScanCustomScan сбрасывать только локаль-
ное. В настоящее время этот обработчик будет вызываться перед ReScanCustomScan, но лучше на
этот порядок не рассчитывать.
void (</em>InitializeWorkerCustomScan) (CustomScanState <em>node,
shm_toc *toc,
void *coordinate);
Инициализирует локальное состояние параллельного исполнителя на основе общего состояния,
заданного ведущим исполнителем во время InitializeDSMCustomScan. Этот обработчик является
2113Написание провайдера нестан-
дартного сканирования
необязательным и должен устанавливаться, только если провайдер нестандартного сканирования
поддерживает параллельное выполнение.
void (</em>ShutdownCustomScan) (CustomScanState <em>node);
Освобождает ресурсы, когда становится понятно, что этот узел больше не будет выполняться. Этот
обработчик вызывается не во всех случаях; иногда может вызываться только EndCustomScan. Так
как сегмент DSM, используемый параллельным запросом, освобождается сразу после вызова это-
го обработчика, провайдеры нестандартного сканирования, которым нужно выполнять некоторые
действия до ликвидации сегмента DSM, должны реализовывать этот метод.
void (</em>ExplainCustomScan) (CustomScanState *node,
List *ancestors,
ExplainState *es);
Выводит дополнительную информацию для EXPLAIN об узле нестандартного сканирования. Этот
обработчик является необязательным. Общие данные, сохранённые в ScanState, такие как целе-
вой список и сканируемое отношение, будут выводиться и без этого обработчика, но с помощью
этого обработчика можно выдать дополнительные, внутренние сведения.
2114</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-058/" title="Глава 58. Написание метода извлечения выборки таблицы"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 58. Написание метода извлечения выборки таблицы"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-058/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~6 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-058/" rel="bookmark" title="Глава 58. Написание метода извлечения выборки таблицы" itemprop="url">Глава 58. Написание метода извлечения выборки таблицы</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 58. Написание метода извлечения выборки таблицы</p>

<p>Реализация предложения TABLESAMPLE в PostgreSQL поддерживает подключение собственных ме-
тодов извлечения выборки таблицы, в дополнение к методам BERNOULLI и SYSTEM, которые требу-
ются стандартом SQL. Метод выборки определяет, какие строки таблицы будут выбираться, когда
используется предложение TABLESAMPLE.
На уровне SQL метод извлечения выборки таблицы представляется одной функцией SQL, обычно
реализуемой на C, имеющей сигнатуру
method_name(internal) RETURNS tsm_handler
Имя функции будет совпадать с именем метода, указываемым в предложении TABLESAMPLE. Аргу-
мент internal является фиктивным (в нём всегда передаётся ноль) и введён только для того, что-
бы эту функцию нельзя было вызывать напрямую из команд SQL. Возвращать эта функция должна
структуру типа TsmRoutine (выделенную вызовом palloc), содержащую указатели на опорные функ-
ции для метода извлечения выборки. Эти опорные функции представляют собой простые функции
на C, которые не видны и не могут вызываться на уровне SQL. Эти опорные функции описаны в
Разделе 58.1.
В дополнение к указателям на функции в структуре TsmRoutine должны задаваться следующие
дополнительные поля:
List *parameterTypes
Это список OID, содержащий OID типов данных параметров, которые будут приниматься пред-
ложением TABLESAMPLE при использовании этого метода извлечения выборки. Например, для
встроенных методов этот список содержит один элемент со значением FLOAT4OID, представля-
ющий процент выборки. Другие методы могут иметь дополнительные или иные параметры.
bool repeatable_across_queries
Если это поле равно true, данный метод извлечения выборки может выдавать одинаковые вы-
борки при последовательных запросах с одними и теми же параметрами и значением затравки
REPEATABLE при условии неизменности содержимого таблицы. Если равно false, предложение
REPEATABLE не будет приниматься с этим методом извлечения выборки.
bool repeatable_across_scans
Если это поле равно true, метод извлечения выборки может выдавать одинаковые выборки при
последовательном сканировании в рамках одного запроса (предполагается неизменность па-
раметров, значения затравки и снимка данных). Если равно false, планировщик не будет вы-
бирать планы, требующие неоднократного сканирования выборки, так как это может привести
к несогласованному результату запроса.
Тип структуры TsmRoutine объявлен в src/include/access/tsmapi.h, где можно найти дополни-
тельную информацию.
Методы извлечения выборки, включённые в стандартный дистрибутив, могут послужить хорошим
примером, если вы хотите написать свой метод. Код встроенных методов вы можете найти в под-
каталоге src/backend/access/tablesample дерева исходного кода, а код дополнительных методов
— в подкаталоге contrib.
58.1. Опорные функции метода извлечения выборки
Функция-обработчик TSM возвращает структуру TsmRoutine (выделенную вызовом palloc) с указа-
телями на опорные функции, описанные ниже. Большинство этих функций обязательные, но неко-
торые — нет, и их указатели могут быть равны NULL.
2107Написание метода извле-
чения выборки таблицы
void
SampleScanGetSampleSize (PlannerInfo *root,
RelOptInfo *baserel,
List *paramexprs,
BlockNumber *pages,
double *tuples);
Эта функция вызывается во время планирования. Она должна рассчитать число страниц отно-
шения, которые будут прочитаны при простом сканировании, и число кортежей, выбираемых
при сканировании. (Например, эти числа можно получить, оценив процент выбираемых дан-
ных, а затем умножив baserel-&gt;pages и baserel-&gt;tuples на это значение и округлив резуль-
тат до целых.) Список paramexprs содержит выражения, переданные в параметрах предложению
TABLESAMPLE. Если для целей оценивания нужны их значения, рекомендуется воспользоваться
estimate_expression_value(), чтобы попытаться свести эти выражения к константам; но данная
функция должна выдавать оценку размера, даже если это не удастся, и не должна выдавать ошиб-
ку, даже если считает переданные значения неверными (помните, что это только приблизитель-
ные оценки чисел, которые будут получены во время выполнения). Параметры pages и tuples яв-
ляются выходными.
void
InitSampleScan (SampleScanState *node,
int eflags);
Выполняет инициализацию перед выполнением узла плана SampleScan. Эта функция вызывается
при запуске исполнителя. Она должна выполнить все подготовительные действия, необходимые
для начала обработки. Узел SampleScanState уже был создан, но его поле tsm_state содержит
NULL. Функция InitSampleScan может выделить через palloc область для любых внутренних дан-
ных, нужных методу извлечения выборки, и сохранить указатель на неё в node-&gt;tsm_state. Инфор-
мацию о сканируемой таблице можно получить через другие поля узла SampleScanState (но за-
метьте, что дескриптор сканирования node-&gt;ss.ss_currentScanDesc ещё не настроен). Параметр
eflags содержит битовые флаги, описывающие режим работы исполнителя для этого узла плана.
Когда (eflags &amp; EXEC_FLAG_EXPLAIN_ONLY) не равно нулю, собственно сканирование не будет вы-
полняться, поэтому эта функция должна сделать только то, что необходимо для получения состо-
яния узла, подходящего для EXPLAIN и EndSampleScan.
Эту функцию можно опустить (присвоить указателю NULL), тогда вся инициализация, необходи-
мая для метода извлечения выборки, должна иметь место в BeginSampleScan.
void
BeginSampleScan (SampleScanState *node,
Datum *params,
int nparams,
uint32 seed);
Начинает выполнение сканирования выборки. Эта функция вызывается непосредственно пе-
ред первой попыткой выбрать кортеж и может вызываться повторно, если потребуется переза-
пустить сканирование. Информацию о сканируемой таблице можно получить через поля узла
SampleScanState (но заметьте, что дескриптор сканирования node-&gt;ss.ss_currentScanDesc ещё
не настроен). Массив params, длины nparams, содержит значения параметров, переданных в пред-
ложении TABLESAMPLE. Их количество и типы задаются в списке parameterTypes метода выборки,
и они гарантированно не равны NULL. Параметр seed содержит значение затравки, которое этот
метод должен учитывать при генерации любых случайных чисел; это либо хеш, полученный из
значения REPEATABLE, если оно было передано, либо результат random() в противном случае.
Эта функция может скорректировать поля node-&gt;use_bulkread и node-&gt;use_pagemode. Если поле
node-&gt;use_bulkread равно true (это значение по умолчанию), при сканировании будет использо-
ваться стратегия доступа к буферу, ориентированная на переработку буферов после использова-
ния. Может быть разумным присвоить ему false, если при сканировании будет просматриваться
только небольшой процент страниц. Если поле node-&gt;use_pagemode равно true (это значение по
2108Написание метода извле-
чения выборки таблицы
умолчанию), при сканировании проверка видимости будет выполняться в один проход для всех
кортежей на каждой просматриваемой странице. Может иметь смысл присвоить ему false, если
при сканировании выбирается только небольшой процент кортежей на странице. В результате бу-
дет выполняться меньше проверок видимости кортежей, хотя каждая проверка будет дороже, так
как потребует расширенную блокировку.
Если метод выборки помечен как repeatable_across_scans, он должен быть способен выбирать
при повторном сканировании тот же набор кортежей, что был выбран в первый раз, то есть новый
вызов BeginSampleScan должен приводить к выборке тех же кортежей, что и предыдущий (если
параметры TABLESAMPLE и значение затравки не меняются).
BlockNumber
NextSampleBlock (SampleScanState *node);
Возвращает номер блока следующей сканируемой страницы либо InvalidBlockNumber, если стра-
ниц для сканирования не осталось.
Эту функцию можно опустить (присвоить её указателю NULL), в этом случае код ядра произведёт
последовательное сканирование всего отношения. Такое сканирование может быть синхронизи-
рованным, так что метод выборки не должен полагать, что страницы отношения каждый раз про-
сматриваются в одном и том же порядке.
OffsetNumber
NextSampleTuple (SampleScanState *node,
BlockNumber blockno,
OffsetNumber maxoffset);
Возвращает номер смещения следующего кортежа, выбираемого с указанной страницы, либо
InvalidOffsetNumber, если кортежей для выборки не осталось. В maxoffset задаётся максималь-
ный номер смещения, допустимый на этой странице.
Примечание
NextSampleTuple не говорит явно, для каких из номеров смещений в диапазоне 1 ..
maxoffset действительно содержатся актуальные кортежи. Это обычно не проблема,
так как код ядра игнорирует запросы на выборку несуществующих или невидимых кор-
тежей; это не должно приводить к отклонениям в выборке. Однако при необходимо-
сти функция может проверить node-&gt;ss.ss_currentScanDesc-&gt;rs_vistuples[] и по-
нять, какие кортежи актуальны и видимы. (Для этого требуется, чтобы признак node-</p>
<blockquote>
  <p>use_pagemode равнялся true.)
Примечание
Функция NextSampleTuple не должна полагать, что в blockno будет получен тот же
номер страницы, что был выдан при последнем вызове NextSampleBlock. Этот номер
определённо был выдан при каком-то предыдущем вызове NextSampleBlock, но код яд-
ра может вызывать NextSampleBlock перед тем, как собственно сканировать страни-
цы, для поддержки упреждающего чтения. Однако можно рассчитывать на то, что как
только начнётся выборка кортежей с одной данной страницы, все последующие вызо-
вы NextSampleTuple будут обращаться к этой странице, пока не будет возвращено зна-
чение InvalidOffsetNumber.
void
EndSampleScan (SampleScanState *node);
Завершает сканирование и освобождает ресурсы. Обычно при этом не нужно освобождать память,
выделенную через palloc, но все видимые извне ресурсы должны быть очищены. Эту функцию чаще
всего можно опустить (присвоить её указателю NULL), если таких ресурсов нет.
2109</p>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page6/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page5/">5</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page6/">6</a></li>
      
    
      
        <li><strong class="current-page">7</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page8/">8</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page9/">9</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page8/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>