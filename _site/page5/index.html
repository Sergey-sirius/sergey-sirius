<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page5/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page5/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-071/" title="Приложение A. Коды ошибок PostgreSQL"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Приложение A. Коды ошибок PostgreSQL"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-071/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~5 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-071/" rel="bookmark" title="Приложение A. Коды ошибок PostgreSQL" itemprop="url">Приложение A. Коды ошибок PostgreSQL</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Часть VIII. Приложения
Приложение A. Коды ошибок PostgreSQL</p>

<p>Всем сообщениям, которые выдаёт сервер PostgreSQL, назначены пятисимвольные коды ошибок,
соответствующие кодам «SQLSTATE», описанным в стандарте SQL. Приложения, которые должны
знать, какое условие ошибки имело место, обычно проверяют код ошибки и только потом обраща-
ются к текстовому сообщению об ошибке. Коды ошибок, скорее всего, не изменятся от выпуска к
выпуску PostgreSQL, и они не меняются при локализации как сообщения об ошибках. Заметьте,
что отдельные, но не все коды ошибок, которые выдаёт PostgreSQL, определены стандартом SQL;
некоторые дополнительные коды ошибок для условий, не описанных стандартом, были добавлены
независимо или позаимствованы из других баз данных.
Согласно стандарту, первые два символа кода ошибки обозначают класс ошибок, а последние три
символа обозначают определённое условие в этом классе. Таким образом, приложение, не знаю-
щее значение определённого кода ошибки, всё же может понять, что делать, по классу ошибки.
В Таблице A.1 перечислены все коды ошибок, определённые в PostgreSQL 11.1. (Некоторые коды в
настоящее время не используются, хотя они определены в стандарте SQL.) Также показаны клас-
сы ошибок. Для каждого класса ошибок имеется «стандартный» код ошибки с последними тремя
символами 000. Этот код выдаётся только для таких условий ошибок, которые относятся к некото-
рому классу, но не имеют более определённого кода.
Символ, указанный в столбце «Имя условия», определяет условие в PL/pgSQL. Имена условий мо-
гут записываться в верхнем или нижнем регистре. (Заметьте, что PL/pgSQL, в отличие от ошибок,
не распознаёт предупреждения; то есть классы 00, 01 и 02.)
Для некоторых типов ошибок сервер сообщает имя объекта базы данных (таблица, столбец таб-
лицы, тип данных или ограничение), связанного с ошибкой; например, имя уникального ограни-
чения, вызвавшего ошибку unique_violation. Такие имена передаются в отдельных полях сооб-
щения об ошибке, чтобы приложениям не пришлось извлекать его из возможно локализованного
текста ошибки для человека. На момент выхода PostgreSQL 9.3 полностью охватывались только
ошибки класса SQLSTATE 23 (нарушения ограничений целостности), но в будущем должны быть
охвачены и другие классы.
Таблица A.1. Коды ошибок PostgreSQL
Код ошибки
Имя условия
Класс 00 — Успешное завершение
00000
successful_completion
Класс 01 — Предупреждение
01000 warning
0100C dynamic_result_sets_returned
01008 implicit_zero_bit_padding
01003 null_value_eliminated_in_set_function
01007 privilege_not_granted
01006 privilege_not_revoked
01004 string_data_right_truncation
01P01 deprecated_feature
Класс 02 — Нет данных (это также класс предупреждений согласно стандарту SQL)
02000 no_data
02001 no_additional_dynamic_result_sets_
returned
2198Коды ошибок PostgreSQL
Код ошибки
Имя условия
Класс 03 — SQL-оператор ещё не завершён
03000
sql_statement_not_yet_complete
Класс 08 — Исключение, связанное с подключением
08000 connection_exception
08003 connection_does_not_exist
08006 connection_failure
08001 sqlclient_unable_to_establish_
sqlconnection
08004 sqlserver_rejected_establishment_of_
sqlconnection
08007 transaction_resolution_unknown
08P01 protocol_violation
Класс 09 — Исключение с действием триггера
09000
triggered_action_exception
Класс 0A — Неподдерживаемая функциональность
0A000
feature_not_supported
Класс 0B — Неверное начало транзакции
0B000
invalid_transaction_initiation
Класс 0F — Исключение с указателем на данные
0F000 locator_exception
0F001 invalid_locator_specification
Класс 0L — Неверный праводатель
0L000 invalid_grantor
0LP01 invalid_grant_operation
Класс 0P — Неверное указание роли
0P000
invalid_role_specification
Класс 0Z — Исключение диагностики
0Z000 diagnostics_exception
0Z002 stacked_diagnostics_accessed_without_
active_handler
Класс 20 — Case не найден
20000
case_not_found
Класс 21 — Нарушение количества
21000
cardinality_violation
Класс 22 — Исключение в данных
22000 data_exception
2202E array_subscript_error
22021 character_not_in_repertoire
22008 datetime_field_overflow
22012 division_by_zero
22005 error_in_assignment
2199Коды ошибок PostgreSQL
Код ошибки Имя условия
2200B escape_character_conflict
22022 indicator_overflow
22015 interval_field_overflow
2201E invalid_argument_for_logarithm
22014 invalid_argument_for_ntile_function
22016 invalid_argument_for_nth_value_
function
2201F invalid_argument_for_power_function
2201G invalid_argument_for_width_bucket_
function
22018 invalid_character_value_for_cast
22007 invalid_datetime_format
22019 invalid_escape_character
2200D invalid_escape_octet
22025 invalid_escape_sequence
22P06 nonstandard_use_of_escape_character
22010 invalid_indicator_parameter_value
22023 invalid_parameter_value
22013 invalid_preceding_or_following_size
2201B invalid_regular_expression
2201W invalid_row_count_in_limit_clause
2201X invalid_row_count_in_result_offset_
clause
2202H invalid_tablesample_argument
2202G invalid_tablesample_repeat
22009 invalid_time_zone_displacement_value
2200C invalid_use_of_escape_character
2200G most_specific_type_mismatch
22004 null_value_not_allowed
22002 null_value_no_indicator_parameter
22003 numeric_value_out_of_range
2200H sequence_generator_limit_exceeded
22026 string_data_length_mismatch
22001 string_data_right_truncation
22011 substring_error
22027 trim_error
22024 unterminated_c_string
2200F zero_length_character_string
22P01 floating_point_exception
22P02 invalid_text_representation
22P03 invalid_binary_representation
2200Коды ошибок PostgreSQL
Код ошибки Имя условия
22P04 bad_copy_file_format
22P05 untranslatable_character
2200L not_an_xml_document
2200M invalid_xml_document
2200N invalid_xml_content
2200S invalid_xml_comment
2200T invalid_xml_processing_instruction
Класс 23 — Нарушение ограничения целостности
23000 integrity_constraint_violation
23001 restrict_violation
23502 not_null_violation
23503 foreign_key_violation
23505 unique_violation
23514 check_violation
23P01 exclusion_violation
Класс 24 — Неверное состояние курсора
24000
invalid_cursor_state
Класс 25 — Неверное состояние транзакции
25000 invalid_transaction_state
25001 active_sql_transaction
25002 branch_transaction_already_active
25008 held_cursor_requires_same_isolation_
level
25003 inappropriate_access_mode_for_branch_
transaction
25004 inappropriate_isolation_level_for_
branch_transaction
25005 no_active_sql_transaction_for_branch_
transaction
25006 read_only_sql_transaction
25007 schema_and_data_statement_mixing_not_
supported
25P01 no_active_sql_transaction
25P02 in_failed_sql_transaction
25P03 idle_in_transaction_session_timeout
Класс 26 — Неверное имя SQL-оператора
26000
invalid_sql_statement_name
Класс 27 — Нарушение при изменении данных в триггере
27000
triggered_data_change_violation
Класс 28 — Неверное указание авторизации
28000
invalid_authorization_specification
2201Коды ошибок PostgreSQL
Код ошибки Имя условия
28P01 invalid_password
Класс 2B — Зависимые описания привилегий всё ещё существуют
2B000 dependent_privilege_descriptors_still_
exist
2BP01 dependent_objects_still_exist
Класс 2D — Неверное завершение транзакции
2D000
invalid_transaction_termination
Класс 2F — Исключение в подпрограмме SQL
2F000 sql_routine_exception
2F005 function_executed_no_return_statement
2F002 modifying_sql_data_not_permitted
2F003 prohibited_sql_statement_attempted
2F004 reading_sql_data_not_permitted
Класс 34 — Неверное имя курсора
34000
invalid_cursor_name
Класс 38 — Исключение во внешней подпрограмме
38000 external_routine_exception
38001 containing_sql_not_permitted
38002 modifying_sql_data_not_permitted
38003 prohibited_sql_statement_attempted
38004 reading_sql_data_not_permitted
Класс 39 — Исключение при вызове внешней подпрограммы
39000 external_routine_invocation_exception
39001 invalid_sqlstate_returned
39004 null_value_not_allowed
39P01 trigger_protocol_violated
39P02 srf_protocol_violated
39P03 event_trigger_protocol_violated
Класс 3B — Исключение точки сохранения
3B000 savepoint_exception
3B001 invalid_savepoint_specification
Класс 3D — Неверное имя каталога
3D000
invalid_catalog_name
Класс 3F — Неверное имя схемы
3F000
invalid_schema_name
Класс 40 — Откат транзакции
40000 transaction_rollback
40002 transaction_integrity_constraint_
violation
40001 serialization_failure
40003 statement_completion_unknown
2202Коды ошибок PostgreSQL
Код ошибки Имя условия
40P01 deadlock_detected
Класс 42 — Ошибка синтаксиса или нарушение правила доступа
42000 syntax_error_or_access_rule_violation
42601 syntax_error
42501 insufficient_privilege
42846 cannot_coerce
42803 grouping_error
42P20 windowing_error
42P19 invalid_recursion
42830 invalid_foreign_key
42602 invalid_name
42622 name_too_long
42939 reserved_name
42804 datatype_mismatch
42P18 indeterminate_datatype
42P21 collation_mismatch
42P22 indeterminate_collation
42809 wrong_object_type
428C9 generated_always
42703 undefined_column
42883 undefined_function
42P01 undefined_table
42P02 undefined_parameter
42704 undefined_object
42701 duplicate_column
42P03 duplicate_cursor
42P04 duplicate_database
42723 duplicate_function
42P05 duplicate_prepared_statement
42P06 duplicate_schema
42P07 duplicate_table
42712 duplicate_alias
42710 duplicate_object
42702 ambiguous_column
42725 ambiguous_function
42P08 ambiguous_parameter
42P09 ambiguous_alias
42P10 invalid_column_reference
42611 invalid_column_definition
42P11 invalid_cursor_definition
2203Коды ошибок PostgreSQL
Код ошибки Имя условия
42P12 invalid_database_definition
42P13 invalid_function_definition
42P14 invalid_prepared_statement_definition
42P15 invalid_schema_definition
42P16 invalid_table_definition
42P17 invalid_object_definition
Класс 44 — Нарушение WITH CHECK OPTION
44000
with_check_option_violation
Класс 53 — Нехватка ресурсов
53000 insufficient_resources
53100 disk_full
53200 out_of_memory
53300 too_many_connections
53400 configuration_limit_exceeded
Класс 54 — Превышение ограничения программы
54000 program_limit_exceeded
54001 statement_too_complex
54011 too_many_columns
54023 too_many_arguments
Класс 55 — Объект не в требуемом состоянии
55000 object_not_in_prerequisite_state
55006 object_in_use
55P02 cant_change_runtime_param
55P03 lock_not_available
Класс 57 — Вмешательство оператора
57000 operator_intervention
57014 query_canceled
57P01 admin_shutdown
57P02 crash_shutdown
57P03 cannot_connect_now
57P04 database_dropped
Класс 58 — Ошибка системы (ошибка, внешняя по отношению к PostgreSQL)
58000 system_error
58030 io_error
58P01 undefined_file
58P02 duplicate_file
Класс 72 — Ошибка снимка
72000
snapshot_too_old
Класс F0 — Ошибка файла конфигурации
F0000
config_file_error
2204Коды ошибок PostgreSQL
Код ошибки Имя условия
F0001 lock_file_exists
Класс HV — Ошибка обёртки сторонних данных (SQL/MED)
HV000 fdw_error
HV005 fdw_column_name_not_found
HV002 fdw_dynamic_parameter_value_needed
HV010 fdw_function_sequence_error
HV021 fdw_inconsistent_descriptor_information
HV024 fdw_invalid_attribute_value
HV007 fdw_invalid_column_name
HV008 fdw_invalid_column_number
HV004 fdw_invalid_data_type
HV006 fdw_invalid_data_type_descriptors
HV091 fdw_invalid_descriptor_field_
identifier
HV00B fdw_invalid_handle
HV00C fdw_invalid_option_index
HV00D fdw_invalid_option_name
HV090 fdw_invalid_string_length_or_buffer_
length
HV00A fdw_invalid_string_format
HV009 fdw_invalid_use_of_null_pointer
HV014 fdw_too_many_handles
HV001 fdw_out_of_memory
HV00P fdw_no_schemas
HV00J fdw_option_name_not_found
HV00K fdw_reply_handle
HV00Q fdw_schema_not_found
HV00R fdw_table_not_found
HV00L fdw_unable_to_create_execution
HV00M fdw_unable_to_create_reply
HV00N fdw_unable_to_establish_connection
Класс P0 — Ошибка PL/pgSQL
P0000 plpgsql_error
P0001 raise_exception
P0002 no_data_found
P0003 too_many_rows
P0004 assert_failure
Класс XX — Внутренняя ошибка
XX000 internal_error
XX001 data_corrupted
2205Коды ошибок PostgreSQL
Код ошибки Имя условия
XX002 index_corrupted
2206</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-070/" title="Глава 70. Как планировщик использует статистику"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 70. Как планировщик использует статистику"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-070/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-070/" rel="bookmark" title="Глава 70. Как планировщик использует статистику" itemprop="url">Глава 70. Как планировщик использует статистику</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 70. Как планировщик использует статистику</p>

<p>Данная глава основана на материалах, рассмотренных ранее (см. Раздел 14.1 и Раздел 14.2), и по-
дробнее рассказывает о том, как планировщик использует статистику для определения количества
строк, которое может вернуть каждая часть запроса. Это важная составляющая процесса создания
плана запроса, предоставляющая большую часть исходного материала для расчёта стоимости.
Целью данной главы является не подробное документирование кода, а общее описание его работы.
Возможно, это поможет тем, кто пожелает в дальнейшем ознакомиться с кодом.
70.1. Примеры оценки количества строк
В приведённых ниже примерах используются таблицы базы данных регрессионного тестирования
PostgreSQL. Приведённые листинги получены в версии 8.3. Поведение более ранних (или поздних)
версий может отличаться. Заметьте также, что поскольку команда ANALYZE использует случайную
выборку при формировании статистики, после любого нового выполнения команды ANALYZE ре-
зультаты незначительно изменятся.
Давайте начнём с очень простого запроса:
EXPLAIN SELECT * FROM tenk1;
QUERY PLAN
————————————————————-
Seq Scan on tenk1 (cost=0.00..458.00 rows=10000 width=244)
Как планировщик определяет мощность tenk1, рассматривается выше (см. Раздел  14.2), но для
полноты здесь говорится об этом ещё раз. Количество страниц и строк берётся в pg_class:
SELECT relpages, reltuples FROM pg_class WHERE relname = ‘tenk1’;
relpages | reltuples
———-+———–
358 |
10000
Это текущие цифры, полученные при последнем выполнении команд VACUUM или ANALYZE, при-
менённых к этой таблице. Затем планировщик выполняет выборку фактического текущего числа
страниц в таблице (это недорогая операция, для которой не требуется сканирование таблицы). Ес-
ли оно отличается от relpages, то reltuples изменяется для того, чтобы привести это значение
к текущей оценке количества строк. В показанном выше примере значение relpages является ак-
туальным, поэтому количество строк берётся равным reltuples.
Давайте обратимся к примеру с диапазонным условием в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;
QUERY PLAN
——————————————————————————–
Bitmap Heap Scan on tenk1 (cost=24.06..394.64 rows=1007 width=244)
Recheck Cond: (unique1 &lt; 1000)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..23.80 rows=1007 width=0)
Index Cond: (unique1 &lt; 1000)
Планировщик рассматривает условие предложения WHERE и находит в справочнике функцию из-
бирательности для оператора &lt; в pg_operator. Это значение содержится в столбце oprrest, и в
данном случае значением является scalarltsel. Функция scalarltsel извлекает гистограмму для
unique1 из pg_statistic. Для вводимых вручную запросов удобнее просматривать более простое
представление pg_stats:
2189Как планировщик ис-
пользует статистику
SELECT histogram_bounds FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’unique1’;
histogram_bounds
——————————————————
{0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}
Затем обрабатывается часть гистограммы, которая соответствует условию «&lt; 1000». Таким обра-
зом и определяется избирательность. Гистограмма делит диапазон на равные частотные группы,
поэтому нужно лишь определить группу, содержащую наше значение, и подсчитать её долю и
долю групп, предшествующих данной. Очевидно, что значение 1000 находится во второй группе
(993-1997). Если предположить, что внутри каждой группы распределение значений линейное, мы
можем вычислить избирательность следующим образом:
selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets
= (1 + (1000 - 993)/(1997 - 993))/10
= 0.100697
т. е. сумма элементов одной целой группы и пропорциональной части элементов второй, делённая
на число групп. Теперь примерное число строк может быть рассчитано как произведение избира-
тельности и мощности tenk1:
rows = rel_cardinality * selectivity
= 10000 * 0.100697
= 1007 (округлённо)
Далее, давайте рассмотрим пример с условием на равенство в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = ‘CRAAAA’;
QUERY PLAN
———————————————————-
Seq Scan on tenk1 (cost=0.00..483.00 rows=30 width=244)
Filter: (stringu1 = ‘CRAAAA’::name)
Планировщик вновь проверяет условие в предложении WHERE и определяет функцию избиратель-
ности для =, и этой функцией является eqsel. Для оценки равенства гистограмма бесполезна, вме-
сто неё для оценки избирательности используется список наиболее распространённых значений
(Most Commom Values, MCV). Давайте рассмотрим MCV и соответствующие дополнительные столб-
цы, которые пригодятся позже:
SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’stringu1’;
null_frac
| 0
n_distinct
| 676
most_common_vals |
{EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}
most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}
Так как значение CRAAAA оказалось в списке MCV, избирательность будет определяться просто
соответствующим элементом в списке частот наиболее распространённых значений (Most Common
Frequencies, MCF):
selectivity = mcf[3]
= 0.003
Как и в предыдущем примере, оценка числа строк берётся как произведение мощности и избира-
тельности tenk1:
rows = 10000 * 0.003
= 30
Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке MCV:
2190Как планировщик ис-
пользует статистику
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = ‘xxx’;
QUERY PLAN
———————————————————-
Seq Scan on tenk1 (cost=0.00..483.00 rows=15 width=244)
Filter: (stringu1 = ‘xxx’::name)
Это совершенно другая задача — как оценить избирательность значения, которого нет в списке
MCV. При её решении используется факт отсутствия данного значения в списке в сочетании с
частотой для каждого значения из списка MCV.
selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)
= (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +
0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)
= 0.0014559
Т. е. нужно сложить частоты значений из списка MCV, отнять полученное число от единицы, и
полученное значение разделить на количество остальных уникальных значений. Эти вычисления
основаны на предположении, что значения, которые не входят в список MCV, имеют равномерное
распределение. Заметьте, что в данном примере нет неопределённых значений, поэтому о них
беспокоиться не нужно (иначе их долю также пришлось бы вычитать из числителя). Оценка числа
строк затем производится как обычно:
rows = 10000 * 0.0014559
= 15 (округлённо)
Предыдущий пример с unique1 &lt; 1000 был большим упрощением того, что в действительности
делает scalarltsel. Но после того, как мы увидели пример использования списка MCV, мы можем
внести некоторые дополнения. Что касается самого примера, в нём все было правильно, поскольку
unique1 это уникальный столбец, у него нет значений в списке MCV (очевидно, в данном случае
нет значения, которое является более распространённым, чем любое другое). Для неуникального
столбца обычно создаётся как гистограмма, так и список MCV, при этом гистограмма не включает
значения, представленные в списке MCV. Данный способ позволяет выполнить более точный под-
счёт. В этой ситуации scalarltsel напрямую применяет условие «&lt; 1000» к каждому значению
списка MCV и суммирует частоты значений MCV, для которых условие является верным. Это даёт
точную оценку избирательности для той части таблицы, которая содержит значения из списка
MCV. Подобным же образом используется гистограмма для оценки избирательности для той части
таблицы, которая не содержит значения из списка MCV, а затем эти две цифры складываются для
оценки общей избирательности. Например, рассмотрим
EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; ‘IAAAAA’;
QUERY PLAN
————————————————————
Seq Scan on tenk1 (cost=0.00..483.00 rows=3077 width=244)
Filter: (stringu1 &lt; ‘IAAAAA’::name)
Мы уже видели данные списка MCV для stringu1, а это его гистограмма:
SELECT histogram_bounds FROM pg_stats
WHERE tablename=’tenk1’ AND attname=’stringu1’;
histogram_bounds
——————————————————————————–
{AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}
Проверяя список MCV, находим, что условие stringu1 &lt; ‘IAAAAA’ соответствует первым шести
записям, но не соответствует последним четырём, поэтому избирательность для значений, соот-
ветствующих значениям в списке MCV, такова:
selectivity = sum(relevant mvfs)
= 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003
= 0.01833333
2191Как планировщик ис-
пользует статистику
Сумма всех частот из списка MCF также сообщает нам, что общая часть представленной списком
MCV совокупности записей равняется 0.03033333, и поэтому представленная гистограммой часть
равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе их пришлось бы
также исключить). Видно, что значение IAAAAA попадает почти в конец третьего столбца гисто-
граммы. Основываясь на простых предположениях относительно частоты различных символов,
планировщик получает число 0.298387 для части значений, представленных в гистограмме, кото-
рые меньше чем IAAAAA. Затем объединяем оценки части значений из списка MCV и значений, не
содержащихся в нём:
selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction
= 0.01833333 + 0.298387 * 0.96966667
= 0.307669
rows
= 10000 * 0.307669
= 3077 (округлённо)
В этом конкретном примере, корректировка со стороны списка MCV достаточно мала, потому что
распределение значений столбца довольно плоское (статистика, показывающая конкретные зна-
чения как более распространённые, чаще всего получается вследствие статистической погреш-
ности). В более типичном случае, когда некоторые значения являются значительно более распро-
странёнными по сравнению с другими, этот более сложный метод повышает точность вследствие
точного определения избирательности наиболее распространённых значений.
Теперь давайте рассмотрим случай с более чем одним условием в предложении WHERE:
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = ‘xxx’;
QUERY PLAN
——————————————————————————–
Bitmap Heap Scan on tenk1 (cost=23.80..396.91 rows=1 width=244)
Recheck Cond: (unique1 &lt; 1000)
Filter: (stringu1 = ‘xxx’::name)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..23.80 rows=1007 width=0)
Index Cond: (unique1 &lt; 1000)
Планировщик исходит из того, что два условия независимы, таким образом, отдельные значения
избирательности можно перемножить:
selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = ‘xxx’)
= 0.100697 * 0.0014559
= 0.0001466
rows
= 10000 * 0.0001466
= 1 (округлённо)
Заметьте, что число строк, которые предполагается вернуть через сканирование битового индекса,
соответствует условию, используемому при работе индекса; это важно, так как влияет на оценку
стоимости для последующих выборок из таблицы.
В заключение исследуем запрос, выполняющий соединение:
EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;
QUERY PLAN
————————————————————————————–
Nested Loop (cost=4.64..456.23 rows=50 width=488)
-&gt; Bitmap Heap Scan on tenk1 t1 (cost=4.64..142.17 rows=50 width=244)
Recheck Cond: (unique1 &lt; 50)
-&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..4.63 rows=50 width=0)
Index Cond: (unique1 &lt; 50)
-&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.00..6.27 rows=1 width=244)
2192Как планировщик ис-
пользует статистику
Index Cond: (unique2 = t1.unique2)
Ограничение, накладываемое на tenk1, unique1 &lt; 50, производится до соединения вложенным
циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным условием. На этот
раз значение 50 попадает в первый столбец гистограммы unique1:
selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets
= (0 + (50 - 0)/(993 - 0))/10
= 0.005035
rows
= 10000 * 0.005035
= 50 (округлённо)
Ограничение для соединения следующее t2.unique2 = t1.unique2. Здесь используется уже из-
вестный нам оператор =, однако функцию избирательности получаем из столбца oprjoin представ-
ления pg_operator, и эта функция — eqjoinsel. Функция eqjoinsel находит статистические дан-
ные как для tenk2, так и для tenk1:
SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats
WHERE tablename IN (‘tenk1’, ‘tenk2’) AND attname=’unique2’;
tablename | null_frac | n_distinct | most_common_vals
———–+———–+————+——————
tenk1
|
0 |
-1 |
tenk2
|
0 |
-1 |
В этом случае нет данных MCV для unique2, потому что все значения будут уникальными. Таким
образом, используется алгоритм, зависящий только от числа различающихся значений для обеих
таблиц и от данных с неопределёнными значениями:
selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/
num_distinct2)
= (1 - 0) * (1 - 0) / max(10000, 10000)
= 0.0001
Т. е., вычитаем долю неопределённых значений из единицы для каждой таблицы и делим на мак-
симальное из чисел различающихся значений. Количество строк, которое соединение, вероятно,
сгенерирует, вычисляется как мощность декартова произведения двух входных значений, умно-
женная на избирательность:
rows = (outer_cardinality * inner_cardinality) * selectivity
= (50 * 10000) * 0.0001
= 50
Если бы имелись списки MCV для двух столбцов, функцией eqjoinsel использовалось бы прямое
сравнение со списками MCV для определения общей избирательности той части данных, которая
содержит значения списка MCV. Оценка остальной части данных при этом выполнялась бы пред-
ставленным выше способом.
Заметьте, что здесь выводится для inner_cardinality значение 10000, то есть исходный размер
tenk2. Если изучить вывод EXPLAIN, может показаться, что оценка количества строк вычисляется
как 50 * 1, то есть число внешних строк умножается на ориентировочное число строк, получаемых
при каждом внутреннем сканировании индекса в tenk2. Но это не так, ведь размер результата
соединения оценивается до того, как выбирается конкретный план соединения. Если всё работает
корректно, оба варианта вычисления этого размера должны давать один и тот же ответ, но из-за
ошибок округления и других факторов иногда они значительно различаются.
Для интересующихся более подробной информацией: оценка размера таблицы (до выполнения
условий в предложении WHERE) реализована в файле src/backend/optimizer/util/plancat.c.
Основная логика для вычисления избирательности предложений находится в src/backend/
optimizer/path/clausesel.c. Специфичные для отдельных операторов функции избирательности,
в основном, расположены в src/backend/utils/adt/selfuncs.c.
2193Как планировщик ис-
пользует статистику
70.2. Примеры многовариантной статистики
70.2.1. Функциональные зависимости
Многовариантную корреляцию можно продемонстрировать на очень простом наборе данных —
таблице с двумя столбцами, содержащими одинаковые значения:
CREATE TABLE t (a INT, b INT);
INSERT INTO t SELECT i % 100, i % 100 FROM generate_series(1, 10000) s(i);
ANALYZE t;
Как рассказывается в Разделе 14.2, планировщик может определить мощность t, исходя из числа
страниц и строк, полученного из pg_class:
SELECT relpages, reltuples FROM pg_class WHERE relname = ‘t’;
relpages | reltuples
———-+———–
45 |
10000
Распределение данных очень простое: в каждом столбце содержится всего 100 различных значе-
ний, равномерно распределённых.
Следующий пример показывает результат оценивания условия WHERE по столбцу a:
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1;
QUERY PLAN
——————————————————————————-
Seq Scan on t (cost=0.00..170.00 rows=100 width=8) (actual rows=100 loops=1)
Filter: (a = 1)
Rows Removed by Filter: 9900
Планировщик рассматривает условие и определяет, что его избирательность равна 1%. Сравнивая
эту оценку и фактическое число строк, мы видим, что оценка очень точна (на самом деле абсолют-
на точна, так как таблица очень маленькая). Если изменить условие WHERE, чтобы использовался
столбец b, будет получен такой же план. Но посмотрите, что получится, если мы применим оди-
наковое условие к двум столбцам, объединив их оператором AND:
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;
QUERY PLAN
—————————————————————————–
Seq Scan on t (cost=0.00..195.00 rows=1 width=8) (actual rows=100 loops=1)
Filter: ((a = 1) AND (b = 1))
Rows Removed by Filter: 9900
Планировщик оценивает избирательность каждого условия индивидуально, и получает ту же оцен-
ку в 1%, что и выше. Затем он предполагает, что условия независимы, так что он перемножает
избирательности и выдаёт окончательную оценку избирательности, равную всего 0.01%. Это зна-
чительная недооценка, так как фактическое число строк, соответствующих условию, (100) на два
порядка больше.
Эту проблему можно решить, создав объект статистики, который укажет команде ANALYZE вычис-
лить многовариантную статистику функциональной зависимости по двум столбцам:
CREATE STATISTICS stts (dependencies) ON a, b FROM t;
ANALYZE t;
EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;
QUERY PLAN
——————————————————————————-
Seq Scan on t (cost=0.00..195.00 rows=100 width=8) (actual rows=100 loops=1)
Filter: ((a = 1) AND (b = 1))
Rows Removed by Filter: 9900
2194Как планировщик ис-
пользует статистику
70.2.2. Многовариантное число различных значений
Подобная проблема возникает с оценкой мощности наборов с несколькими столбцами, например,
с оценкой числа групп, которые могут быть выданы предложением GROUP BY. Когда в GROUP BY
указан один столбец, оценка числа различных значений (которую можно увидеть как ожидаемое
число строк, выдаваемое узлом HashAggregate) очень точная:
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(<em>) FROM t GROUP BY a;
QUERY PLAN
—————————————————————————————–
HashAggregate (cost=195.00..196.00 rows=100 width=12) (actual rows=100 loops=1)
Group Key: a
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=4) (actual rows=10000
loops=1)
Но оценка числа групп в запросе с двумя столбцами в GROUP BY без многовариантной статистики,
как и в предыдущем примере, отличается от правильной на порядок:
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(</em>) FROM t GROUP BY a, b;
QUERY PLAN
——————————————————————————————–
HashAggregate (cost=220.00..230.00 rows=1000 width=16) (actual rows=100 loops=1)
Group Key: a, b
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000
loops=1)
Если переопределить объект статистики, чтобы он включал подсчёт числа различных значений
для двух столбцов, оценка станет гораздо лучше:
DROP STATISTICS stts;
CREATE STATISTICS stts (dependencies, ndistinct) ON a, b FROM t;
ANALYZE t;
EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;
QUERY PLAN
——————————————————————————————–
HashAggregate (cost=220.00..221.00 rows=100 width=16) (actual rows=100 loops=1)
Group Key: a, b
-&gt; Seq Scan on t (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000
loops=1)
70.3. Статистика планировщика и безопасность
Доступ к таблице pg_statistic разрешён только суперпользователям, так что обычные пользо-
ватели не могут получить из неё сведения о содержимом таблиц других пользователей. Но неко-
торые функции оценки избирательности будут использовать пользовательский оператор (опера-
тор, фигурирующий в запросе, или связанный) для анализа сохранённой статистики. Например,
чтобы определить применимость сохранённого самого частого значения, функция оценки избира-
тельности должна задействовать соответствующий оператор = для сравнения константы в запро-
се с этим сохранённым значением. Таким образом, данные pg_statistic в принципе могут пере-
даваться пользовательским операторам. А особым образом сконструированный оператор может
выводить наружу передаваемые ему операнды преднамеренно (например, записывая их в журнал
или помещая в другую таблицу) либо непреднамеренно (показывая их значения в сообщениях об
ошибках). В любом случае это даёт возможность пользователю, не имеющему доступа к таблице
pg_statistic, увидеть содержащиеся в ней данные.
Для предотвращения этого все встроенные функции оценки избирательности действуют по следу-
ющим правилам. Чтобы сохранённая статистика могла использоваться при планировании запроса,
текущий пользователь должен иметь либо право SELECT для таблицы или задействованных столб-
2195Как планировщик ис-
пользует статистику
цов, либо у оператора должна быть характеристика LEAKPROOF (точнее, она должна быть у функции,
реализующей этот оператор). В противном случае оценка избирательности будет осуществляться
так, как если бы статистики не было вовсе, и планировщик продолжит работу с общими или вто-
ричными предположениями.
Если пользователь не имеет требуемого права доступа к таблице или столбцам, то во многих слу-
чаях при выполнении запроса в конце концов возникнет ошибка «нет доступа», так что этот меха-
низм будет незаметен на практике. Но если пользователь читает данные из представления с ба-
рьером безопасности, планировщик может захотеть проверить статистику нижележащей таблицы,
которая недоступна пользователю непосредственно. В этом случае оператор должен быть герме-
тичным; иначе статистика не будет использоваться. Это не будет иметь внешних проявлений кро-
ме того, что план запроса может быть неоптимальным. В случае подозрений, что вы столкнулись с
этим, попробуйте запустить запрос от имени пользователя с расширенными правами и проверьте,
не выбирается ли другой план запроса.
Это ограничение применяется только тогда, когда планировщику может потребоваться выполнить
пользовательский оператор с одним или несколькими значениями из pg_statistic. При этом пла-
нировщику разрешено использовать общую статистическую информацию, например, процент зна-
чений NULL или количество различных значений в столбце, вне зависимости от прав доступа.
Реализуемые в дополнительных расширениях функции оценки избирательности, которые могут
обращаться к статистике, вызывая пользовательские операторы, должны следовать тем же прави-
лам безопасности. За практическими указаниями обратитесь к исходному коду PostgreSQL.
2196</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-069/" title="Глава 69. Объявление и начальное содержимое системных каталогов"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 69. Объявление и начальное содержимое системных каталогов"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-069/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~17 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-069/" rel="bookmark" title="Глава 69. Объявление и начальное содержимое системных каталогов" itemprop="url">Глава 69. Объявление и начальное содержимое системных каталогов</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 69. Объявление и начальное содержимое системных каталогов</p>

<p>В PostgreSQL используется множество разных системных каталогов для учёта информации о су-
ществовании и свойствах объектов базы, например, таблиц и функций. Физически системный ка-
талог не отличается от простой таблицы, но серверный код на C знает структуру и характеристики
каждого каталога и может работать с ним на низком уровне. Поэтому, например, не стоит пытать-
ся изменять структуру каталога «на лету»; это нарушит встроенные в код предположения о том,
как располагаются строки в каталоге. Однако структура каталога может меняться при переходе
с одной основной версии на другую.
Структуры каталогов объявляются в специально оформленных заголовочных файлах C в каталоге
src/include/catalog/ дерева исходного кода. В частности, для каждого каталога имеется заголо-
вочный файл, названный по имени каталога (например, pg_class.h для pg_class) и определяющий
набор столбцов в этом каталоге, а также другие основные свойства, например, его OID. К другим
важным файлам, задающим структуру каталога, относится indexing.h, определяющий, какие ин-
дексы присутствуют во всех системных каталогах, и toasting.h, определяющий таблицы TOAST
для каталогов, которым они нужны.
Со многими каталогами связаны исходные данные, которые должны быть загружены в них на ста-
дии «начальной загрузки» initdb, чтобы система оказалась в состоянии, когда она сможет выпол-
нять команды SQL. (Например, pg_class.h должен содержать запись, ссылающуюся на этот же
каталог, и перечисление всех остальных системных каталогов и индексов.) Эти исходные данные
задаются в редактируемой форме в файлах, которые также находятся в каталоге src/include/
catalog/. Например, в pg_proc.dat описываются все исходные строки, которые должны быть
вставлены в каталог pg_proc.
Чтобы создать файлы каталогов и загрузить в них эти исходные данные, серверный процесс, рабо-
тающий в режиме начальной загрузки, считывает файл BKI (Backend Interface, Серверный интер-
фейс), содержащий команды и исходные данные. Файл postgres.bki, используемый в этом режи-
ме, конструируется из вышеупомянутых заголовочных файлов и файлов данных при сборке дис-
трибутива PostgreSQL Perl-скриптом genbki.pl. Хотя postgres.bki привязан к определённому вы-
пуску PostgreSQL, он является платформонезависимым и устанавливается в подкаталог share де-
рева инсталляции.
Скрипт genbki.pl также генерирует производный заголовочный файл для каждого каталога, на-
пример pg_class_d.h для каталога pg_class. Этот файл содержит автоматически генерируемые
макроопределения и может содержать другие макросы, определения перечислений и т. п., кото-
рые могут быть полезны для клиентского кода, читающего определённый каталог.
Большинству разработчиков Postgres нет необходимости иметь дело непосредственно с файлом
BKI, но для практически любой нетривиальной доработки потребуется модификация заголовочных
файлов и/или файлов с исходными данными каталога. В продолжении этой главы рассказывается
об этом, а также для полноты описывается формат файла BKI.
69.1. Правила объявления системных каталогов
Ключевой частью заголовочного файла каталога является описание структуры на C, определяю-
щее вид каждой строки каталога. Оно начинается с макроса CATALOG, который, если говорить о
компиляторе C, является просто сокращённой записью typedef struct FormData_имя_каталога.
Каждое поле в этой структуре порождает столбец каталога. Поля можно дополнить макросами
свойств BKI, объявленными в genbki.h. Например, для поля можно задать значение по умолчанию
или указать, допускается ли в нём NULL. Строку CATALOG можно также дополнить некоторыми
другими макросами свойств BKI, объявленными в genbki.h и определяющими другие свойства ка-
талога в целом, например, содержит ли он OID (по умолчанию каталоги содержат OID).
Код кеша системного каталога (и в принципе почти весь код, манипулирующий каталогом) предпо-
лагает, что имеющие постоянный размер части всех кортежей системных каталогов присутствуют
2181Объявление и начальное содер-
жимое системных каталогов
фактически, так как он отображает на них объявления структуры на C. Таким образом, все поля пе-
ременной длины и поля, принимающие NULL, должны располагаться в конце, и обращаться к ним
как к полям структуры нельзя. Например, если присвоить полю pg_type.typrelid значение NULL,
обращение в каком-либо месте кода к typetup-&gt;typrelid (или, что ещё хуже, к полю typetup-</p>
<blockquote>
  <p>typelem, следующему за typrelid) будет некорректным. Это приведёт к случайным ошибкам или
даже нарушениям сегментации.
В качестве частичной защиты от ошибок такого типа поля переменной длины или поля, прини-
мающие NULL, следует скрыть от компилятора C. Это реализуется посредством обёртки #ifdef
CATALOG_VARLEN … #endif (где CATALOG_VARLEN — символ, который всегда будет неопределённым).
Это не позволяет коду на C беспрепятственно обращаться к полям, которые могут отсутствовать
или располагаться по некоторому другому смещению. В качестве дополнительной меры, препят-
ствующей созданию некорректных строк, мы требуем, чтобы все столбцы, которые не должны
принимать NULL, помечались соответствующим образом в pg_attribute. Код начальной загруз-
ки автоматически пометит столбцы каталога как NOT NULL, если они имеют фиксированную дли-
ну и перед ними нет столбцов, принимающих NULL. Там, где это правило применяется некор-
ректно, можно исправить пометку, добавив дополнительные указания BKI_FORCE_NOT_NULL или
BKI_FORCE_NULL. Но заметьте, что ограничения NOT NULL контролируются только исполнителем
запросов; на уровне кода C они не действуют, поэтому создавать или изменять строки каталога
вручную нужно так же аккуратно.
Код клиентской части не должен включать никакие заголовочные файлы каталогов pg_xxx.h, так
как эти файлы могут содержать код на C, который не будет компилироваться вне кода сервера.
(Обычно это происходит из-за того, что эти файлы также содержат объявления функций в файлах
src/backend/catalog/.) Вместо этого клиентский код может включить соответствующий сгенери-
рованный заголовок pg_xxx_d.h с определениями различных OID и другими данными, которые
могут быть полезны на стороне клиента. Если вам нужно, чтобы макросы или другой код в заго-
ловочных файлах каталогов были видимы в клиентском коде, заключите соответствущую секцию
в условие #ifdef EXPOSE_TO_CLIENT_CODE … #endif, чтобы genbki.pl скопировал эту секцию в за-
головок pg_xxx_d.h.
Некоторые каталоги настолько основополагающие, что их нельзя создать даже командой BKI
create, которая используется для большинства каталогов, так как эта команда должна записать
информацию, описывающую новый каталог, в эти базовые каталоги. Они называются каталогами
начальной загрузки и для определения их требуется много дополнительные действий: вы долж-
ны вручную подготовить соответствующие записи для них в предварительно загружаемых данных
pg_class и pg_type, и эти записи потребуется модифицировать при последующих изменениях в
структуре каталога. (Каталогам начальной загрузки также нужны предварительно загруженные
записи в pg_attribute, но, к счастью, сейчас с этим управляется скрипт genbki.pl.) По возмож-
ности избегайте включения новых каталогов в категорию каталогов начальной загрузки.
69.2. Исходные данные системных каталогов
Для каждого каталога, с которым связаны вручную создаваемые исходные данные, (не все катало-
ги такие) имеется соответствующий файл .dat, содержащий эти данные в редактируемом формате.
69.2.1. Формат файла данных
Каждый файл .dat содержит описания структур данных Perl, в результате вычисления которых
(функцией eval) в памяти формируется структура данных, состоящая из массива хеш-ссылок, соот-
ветствующих каждой строке каталога. Немного модифицированная выдержка из pg_database.dat
иллюстрирует основные моменты:
[</p>
  <h1 id="Здесь-мог-быть-комментарий">Здесь мог быть комментарий.</h1>
  <p>{ oid =&gt; ‘1’, oid_symbol =&gt; ‘TemplateDbOid’,
descr =&gt; ‘database's default template’,
datname =&gt; ‘template1’, datdba =&gt; ‘PGUID’, encoding =&gt; ‘ENCODING’,
2182Объявление и начальное содер-
жимое системных каталогов
datcollate =&gt; ‘LC_COLLATE’, datctype =&gt; ‘LC_CTYPE’, datistemplate =&gt; ‘t’,
datallowconn =&gt; ‘t’, datconnlimit =&gt; ‘-1’, datlastsysoid =&gt; ‘0’,
datfrozenxid =&gt; ‘0’, datminmxid =&gt; ‘1’, dattablespace =&gt; ‘1663’,
datacl =&gt; ‘<em>null</em>’ },
]
Замечания:
• Общий формат файла: открывающая квадратная скобка, один или более наборов фигурных
скобок, каждый из которых представляет строку каталога, и закрывающая квадратная скобка.
После каждой закрывающей фигурной скобки должна идти запятая.
• В каждой строке каталога записываются разделённые запятыми пары ключ =&gt; значение.
В качестве ключа принимаются имена столбцов каталога, а также ключи метаданных oid,
oid_symbol и descr. (Использование oid и oid_symbol описывается в Подразделе 69.2.2. В
descr задаётся строка с описанием объекта, которое будет вставлено в pg_description или
pg_shdescription.) Ключи метаданных могут опускаться, но ключ для каждого столбца ката-
лога должен присутствовать, если только в файле .h данного каталога для столбца не задано
значение по умолчанию.
• Все значения должны заключаться в апострофы. Апострофы внутри значений экранируют-
ся обратной косой чертой. Обратные косые черты в данных могут, но не обязательно должны
дублироваться; это соответствует правилам Perl по оформлению простых строковых констант.
Заметьте, что обратные косые черты, фигурирующие в данных, будут обрабатываться скане-
ром исходных данных как символы экранирования, согласно тем же правилам записи строко-
вых констант (см. Подраздел 4.1.2.2); например, \t преобразуется в символ табуляции. Если
вы хотите получить именно обратную косую черту в окончательном значении, вам надо будет
написать четыре этих символа: Perl отбрасывает два и оставляет \ сканеру исходных данных.
• Значения NULL представляются как <em>null</em>. (Заметьте, что создать значение с именно такой
строкой невозможно.)
• Комментарии предваряются знаком # и должны размещаться в отдельных строках.
• Для большей наглядности значения полей, выражающие OID других записей каталога, могут
быть представлены именами, а не только числовыми кодами OID. Об этом рассказывается в
Подразделе 69.2.3.
• Так как хеши являются неупорядоченной структурой данных, порядок полей и расположе-
ние строк не имеют семантической значимости. Однако для поддержания согласованного
представления мы установили несколько правил, которые применяет скрипт форматирования
reformat_dat_file.pl:
• В каждой паре фигурных скобок сначала идут поля метаданных oid, oid_symbol и descr, в
этом же порядке, а затем собственные поля каталога в определённом для них порядке.
• Переводы строк при необходимости вставляются между полями для ограничения длины
строки 80 символами, если это возможно. Перевод строки также вставляется между поля-
ми метаданных и обычными полями.
• Если в файле .h каталога задаётся значение по умолчанию для столбца и то же значение
указано в записи данных, reformat_dat_file.pl уберёт его из файла данных. Таким обра-
зом обеспечивается компактное представление данных.
• Скрипт reformat_dat_file.pl сохраняет пустые строки и строки комментариев в неизмен-
ном виде.
Скрипт reformat_dat_file.pl рекомендуется запускать перед сохранением изменений в дан-
ных каталога. Им удобно пользоваться, просто выполняя make reformat-dat-files в src/
include/catalog/.
• Если вы хотите добавить новый метод уменьшения представления данных, вы должны реали-
зовать его в reformat_dat_file.pl и также научить Catalog::ParseData() разворачивать дан-
ные в полное представление.
2183Объявление и начальное содер-
жимое системных каталогов
69.2.2. Назначение OID
Строке каталога, фигурирующей в исходных данных, можно вручную присвоить OID, добавив поле
метаданных oid =&gt; nnnn. Более того, когда строке присваивается OID, для этого OID можно создать
макрос C, добавив поле метаданных oid_symbol =&gt; имя.
Предварительно загружаемым строкам каталога должны заранее назначаться OID, если на них
по OID ссылаются другие предварительно загружаемые строки. Назначать OID также требуется,
если на OID нужно будет ссылаться из кода на C. В отсутствие этих условий поле метаданных oid
можно опустить и тогда загрузочный код назначит OID автоматически либо оставит его нулевым,
если OID в данном каталоге не используются. На практике мы обычно явно назначаем OID для
всех строк в определённом каталоге (даже если фактически присутствуют ссылки только на часть
из них) либо не назначаем их вовсе.
Указание фактического числового значения любого OID в коде на C считается крайне нежела-
тельным; вместо этого всегда следует использовать макрос. Прямые обращения к OID в pg_proc
требуются достаточно часто, поэтому был создан специальный механизм, создающий необходи-
мые макросы автоматически; см. src/backend/utils/Gen_fmgrtab.pl. С аналогичной целью преду-
смотрен (но по историческим причинам реализован по-другому) метод создания макросов для OID
в pg_type. Как следствие, записи oid_symbol в этих двух каталогах добавлять не нужно. Подобным
образом в pg_class автоматически включаются макросы для OID системных каталогов и индексов.
Для остальных системных каталогов все нужные вам макросы с oid_symbol вы должны добавлять
вручную.
Чтобы найти свободный OID для новой предварительно загружаемой строки, запустите скрипт
src/include/catalog/unused_oids. Он выводит диапазоны неиспользуемых OID, включающие гра-
ничные значения (например, выведенная строка «45-900» означает, что OID с 45 по 900 включи-
тельно ещё не задействованы). В настоящее время для назначения вручную зарезервированы зна-
чения OID 1-9999; скрипт unused_oids просто просматривает заголовки каталогов и файлы .dat
и проверяет, какие значения в них отсутствуют. Для поиска ошибок вы можете воспользоваться
скриптом duplicate_oids. (Скрипт genbki.pl также выявит дублирующиеся OID во время компи-
ляции.)
Счётчик OID начинается с 10000 при запуске начальной загрузки. Если строка каталога находится
в таблице с OID, но для неё не было явно установлено поле oid, она получит OID, равный 10000
или больше.
69.2.3. Поиск по OID
Перекрёстную ссылку из одной строки исходного каталога на другую можно записать, просто ука-
зав предопределённый OID целевой строки. Однако этот подход провоцирует ошибки и сложен
для понимания, поэтому для часто используемых каталогов в genbki.pl реализованы механизмы
записи символических ссылок. В настоящее время по символическим ссылкам можно обращаться
к методам доступа, функциям, операторам, классам и семействам операторов, а также типам. При
этом действуют следующие правила:
• Для использования символических ссылок в некотором столбце каталога требуется доба-
вить указание BKI_LOOKUP(правило_поиска) в определение этого столбца, где правилом_поис-
ка может быть pg_am, pg_proc, pg_operator, pg_opclass, pg_opfamily или pg_type. Указание
BKI_LOOKUP может быть добавлено к столбцам типа Oid, regproc, oidvector или Oid[]; в по-
следних двух случаях поиск будет выполняться для каждого элемента массива.
• В таком столбце все записи должны иметь символьный формат (исключение составляет 0,
обозначающий InvalidOid). (Если столбец объявлен как regproc, вместо 0 можно написать -.)
Скрипт genbki.pl выдаст предупреждение, встретив нераспознанное имя.
• Методы доступа, как и типы, представляются просто своими именами. Имена типов должны
соответствовать полям typname в соответствующих записях pg_type; псевдонимы типов ис-
пользовать нельзя, например, нельзя написать integer вместо int4.
2184Объявление и начальное содер-
жимое системных каталогов
• Функция может быть представлена своим значением proname, если оно уникально среди запи-
сей pg_proc.dat (это работает как ввод значения типа regproc). В противном случае её нужно
представить как proname(имя_типа_аргумента,имя_типа_аргумента,…), как в regprocedure.
Имена типов аргументов должны записываться в точности так, как они фигурируют в поле
proargtypes в pg_proc.dat. Не добавляйте в эту строку пробелы.
• Операторы представляются в виде oprname(левый_тип,правый_тип), при этом имена ти-
пов записываются в точности так, как они фигурируют в полях oprleft и oprright в
pg_operator.dat. (Вместо опущенного операнда унарного оператора записывается 0.)
• Имена классов операторов и семейств операторов уникальны только в рамках определённого
метода доступа, так что они представляются в виде имя_метода_доступа/имя_объекта.
• Ни в одном из этих случаев не поддерживается указание схемы; все объекты, создаваемые на
стадии начальной загрузки, будут принадлежать схеме pg_catalog.
Скрипт genbki.pl разрешает все символические ссылки при запуске и помещает в формируемый
файл BKI обычные числовые OID. Таким образом, при начальной загрузке отпадает необходимость
в разрешении имён.
69.2.4. Рецепты по редактированию файлов данных
Ниже приведены некоторые предложения по оптимальному решению некоторых распространён-
ных задач при изменении файлов каталогов.
Добавление в каталог нового столбца со значением по умолчанию:  Добавьте столбец в
заголовочный файл с указанием BKI_DEFAULT(значение). Файл данных потребуется редактировать,
только если в каких-либо существующих строках в добавленном поле должно быть не значение
по умолчанию.
Указание значения по умолчанию для существующего столбца, который его не
имел:  Добавьте указание BKI_DEFAULT в заголовочный файл, а затем выполните make reformat-
dat-files для удаления ставших избыточными записей поля.
Удаление столбца, со значением по умолчанию или без:  Удалите столбец из заголовочного
файла, а затем выполните make reformat-dat-files для удаления ставших избыточными записей
поля.
Изменение или удаление существующего значения по умолчанию:  Просто изменить заго-
ловочный файл недостаточно, так как при этом текущие данные будут интерпретироваться некор-
ректно. Сначала выполните make expand-dat-files, чтобы перезаписать в файлах данных все явно
заданные значения по умолчанию, затем удалите или измените указания BKI_DEFAULT, и в завер-
шение выполните make reformat-dat-files для повторного удаления избыточных полей.
Разовая массовая модификация:  Скрипт reformat_dat_file.pl можно скорректировать для
выполнения самых разных массовых модификаций. Просмотрев в нём блочные комментарии, вы
найдёте место, куда можно вставить модифицирующий код. В следующем примере мы произведём
объединение двух логических полей в pg_proc в символьном поле:</p>
  <ol>
    <li>Добавьте новый столбец со значением по умолчанию в pg_proc.h:
+
+
/* see PROKIND_ categories below */
char
prokind BKI_DEFAULT(f);</li>
    <li>Создайте на основе reformat_dat_file.pl новый скрипт, который вставит соответствующие зна-
чения «на лету»:
-
-
-
-
+
+
#
#
#
#
#
#
At this point we have the full row in memory as a hash
and can do any operations we want. As written, it only
removes default values, but this script can be adapted to
do one-off bulk-editing.
One-off change to migrate to prokind
Default has already been filled in by now, so change to other
2185Объявление и начальное содер-
жимое системных каталогов
+
+
+
+
+
+
+
+
+
      <h1 id="values-as-appropriate">values as appropriate</h1>
      <p>if ($values{proisagg} eq ‘t’)
{
$values{prokind} = ‘a’;
}
elsif ($values{proiswindow} eq ‘t’)
{
$values{prokind} = ‘w’;
}</p>
    </li>
    <li>Запустите новый скрипт:
$ cd src/include/catalog
$ perl rewrite_dat_with_prokind.pl
pg_proc.dat
После этого в файле pg_proc.dat окажутся все три столбца, prokind, proisagg и proiswindow,
хотя они будут фигурировать только в тех строках, где им присваиваются не значения по умол-
чанию, а любые другие значения.</li>
    <li>
      <h2 id="Удалите-старые-столбцы-из-pg_proch">Удалите старые столбцы из pg_proc.h:</h2>
      <p>-
-
-
-
/* is it an aggregate? <em>/
bool
proisagg BKI_DEFAULT(f);
/</em> is it a window function? */
bool
proiswindow BKI_DEFAULT(f);</p>
    </li>
    <li>Наконец, выполните make
pg_proc.dat.
reformat-dat-files для удаления ненужных старых записей из
Примеры
кода,
производящего
массовые
модификации,
вы
може-
те
найти
в
скриптах
convert_oid2name.pl
и
remove_pg_type_oid_symbols.pl,
вложенных
в
сообщение:
https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm
+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com
69.3. Формат файла BKI
В этом разделе описывается, как сервер PostgreSQL интерпретирует файлы BKI. Это описание
будет легче понять, если для наглядности вы откроете файл postgres.bki.
Содержимое BKI состоит из последовательности команд. Команды образуются из нескольких ком-
понентов, в зависимости от синтаксиса конкретной команды. Компоненты команд обычно разде-
ляются пробельными символами, но это не обязательно, если не возникает неоднозначности. Спе-
циальный разделитель команд отсутствует; следующий компонент, который не может синтаксиче-
ски относиться к предыдущей команде, начинает следующую. (Обычно новая команда начинается
в отдельной строке, для структурности.) Компонентами команд могут быть определённые ключе-
вые слова, специальные символы (скобки, запятые и т. д.), числа или строки в двойных кавычках.
Все буквы в них воспринимаются с учётом регистра.
Строки, начинающиеся с #, игнорируются.
69.4. Команды BKI
create имя_таблицы oid_таблицы [bootstrap] [shared_relation] [without_oids] [rowtype_oid oid]
(имя1 = тип1 [FORCE NOT NULL | FORCE NULL] [, имя2 = тип2 [FORCE NOT NULL | FORCE NULL], …])
Создать таблицу имя_таблицы с заданным oid_таблицы и столбцами, указанными в скобках.
Непосредственно bootstrap.c поддерживает следующие типы столбцов: bool, bytea, char
(1 байт), name, int2, int4, regproc, regclass, regtype, text, oid, tid, xid, cid, int2vector,
oidvector, <em>int4 (массив), _text (массив), _oid (массив), _char (массив), _aclitem (массив). Хо-
тя возможно создать таблицы, содержащие столбцы и других типов, это нельзя сделать, пока не
2186Объявление и начальное содер-
жимое системных каталогов
будет создан и заполнен соответствующими записями каталог pg_type. (По сути это означает,
что только эти типы столбцов могут быть в каталогах начальной загрузки, хотя другие каталоги
могут содержать любые встроенные типы.)
С указанием bootstrap таблица будет создана только на диске; никакие записи о ней не бу-
дут добавлены в pg_class, pg_attribute и т. д. Таким образом, таблица не будет доступна для
обычных операций SQL, пока такие записи не будут добавлены явно (командами insert). Это
указание применяется для создания самой структуры pg_class и подобных ей.
Если добавлено указание shared_relation, таблица создаётся как общая. Она будет содер-
жать столбец OID, если отсутствует указание without_oids. Дополнительным предложением
rowtype_oid может быть задан OID типа строки (OID записи в pg_type); если он не указан, OID
генерируется автоматически. (Предложение rowtype_oid бесполезно, если присутствует ука-
зание bootstrap, но его всё равно можно добавить для документирования.)
open имя_таблицы
Открыть таблицу имя_таблицы для добавления данных. Любая другая таблица, открытая в дан-
ный момент, закрывается.
close имя_таблицы
Закрыть открытую таблицу. Имя таблицы должно задаваться для перепроверки.
insert [OID = значение_oid] ( значение1 значение2 … )
Вставить новую строку в открытую таблицу, установив значение1, значение2 и т. д. в качестве
значений столбцов и значение_oid в качестве OID. Если значение_oid равно нулю (0) или это
указание опущено, а таблица при этом содержит OID, строке назначается следующий свобод-
ный OID.
Значения NULL могут задаваться специальным ключевым словом _null</em>. Значения, отличные
от идентификаторов и цифровых строк, должны заключаться в двойные кавычки.
declare [unique] index имя_индекса oid_индекса on имя_таблицы using имя_метода_доступа ( клас-
с_оп1 имя1 [, …] )
Создать индекс имя_индекса с OID, равным oid_индекса, в таблице имя_таблицы, с методом до-
ступа имя_метода_доступа. Индекс строится по полям имя1, имя2 и т. д., и для них используют-
ся соответственно классы операторов класс_оп1, класс_оп2 и т. д. Эта команда создаёт файл
индекса и добавляет соответствующие записи в каталог, но не инициализирует содержимое
индекса.
declare toast oid_таблицы_toast oid_индекса_toast on имя_таблицы
Создаёт таблицу TOAST для таблицы имя_таблицы. Таблице TOAST назначается OID, равный
oid_таблицы_toast, а её индексу назначается OID, равный oid_индекса_toast. Как и с declare
index, заполнение индекса откладывается.
build indices
Заполнить индексы, объявленные ранее.
69.5. Структура файла BKI
Команда open может применяться, только когда открываемая ей таблица существует и для неё име-
ются записи в каталогах. (Минимальный набор этих каталогов образуют pg_class, pg_attribute,
pg_proc и pg_type.) Чтобы можно было заполнить сами эти таблицы, команда create с указанием
bootstrap неявно открывает создаваемую таблицу для добавления данных.
Кроме того, команды declare index и declare toast нельзя применять, пока не будут созданы и
заполнены системные каталоги.
2187Объявление и начальное содер-
жимое системных каталогов
Таким образом, файл postgres.bki должен иметь следующую структуру:</li>
    <li>create bootstrap (создание) одной из критичных таблиц</li>
    <li>insert (добавление) данных, описывающих как минимум критичные таблицы</li>
    <li>close</li>
    <li>Повторение для других критичных таблиц.</li>
    <li>create (создание) (без bootstrap) некритичной таблицы</li>
    <li>open</li>
    <li>insert (добавление) требуемых данных</li>
    <li>close</li>
    <li>Повторение для других некритичных таблиц.
10.Определение индексов и таблиц TOAST.</li>
    <li>build indices
Несомненно есть и другие, недокументированные зависимости, диктующие определённый поря-
док.
69.6. Пример BKI
Следующая последовательность команд создаст таблицу test_table с OID 420, имеющую два
столбца cola и colb типа int4 и text, соответственно, и вставит две строки в эту таблицу:
create test_table 420 (cola = int4, colb = text)
open test_table
insert OID=421 ( 1 “value1” )
insert OID=422 ( 2 <em>null</em> )
close test_table
2188</li>
  </ol>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page4/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page3/">3</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page4/">4</a></li>
      
    
      
        <li><strong class="current-page">5</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page6/">6</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page7/">7</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page37/">37</a></li>
    

    
    
      <li><a href="http://localhost:4000/page6/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>