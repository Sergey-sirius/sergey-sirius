<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page5/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page5/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-068/" title="Глава 68. Физическое хранение базы данных"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 68. Физическое хранение базы данных"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-068/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~22 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-068/" rel="bookmark" title="Глава 68. Физическое хранение базы данных" itemprop="url">Глава 68. Физическое хранение базы данных</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 68. Физическое хранение базы данных</p>

<p>В данной главе рассматривается формат физического хранения, используемый базами данных
PostgreSQL.</p>

<p>68.1. Размещение файлов базы данных</p>

<p>Этот раздел описывает формат хранения на уровне файлов и каталогов.
Файлы конфигурации и файлы данных, используемые кластером базы данных, традиционно хра-
нятся вместе в каталоге данных кластера, который обычно называют PGDATA (по имени перемен-
ной среды, которую можно использовать для его определения). Обычно PGDATA находится в /var/
lib/pgsql/data. На одной и той же машине может находиться множество кластеров, управляемых
различными экземплярами сервера.
В каталоге PGDATA содержится несколько подкаталогов и управляющих файлов, как показано в
Таблице 68.1. В дополнение к этим обязательным элементам конфигурационные файлы кластера
postgresql.conf, pg_hba.conf и pg_ident.conf традиционно хранятся в PGDATA, хотя их можно
разместить и в другом месте.
Таблица 68.1. Содержание PGDATA
Элемент Описание
PG_VERSION Файл, содержащий
PostgreSQL
base Подкаталог, содержащий подкаталоги для каж-
дой базы данных
current_logfiles Файл, в котором отмечается, в какие файлы жур-
налов производит запись сборщик сообщений
global Подкаталог, содержащий общие таблицы кла-
стера, такие как pg_database
pg_commit_ts Подкаталог, содержащий данные о времени
фиксации транзакций
pg_dynshmem Подкаталог, содержащий файлы, используемые
подсистемой динамически разделяемой памяти
pg_logical Подкаталог, содержащий данные о состоянии
для логического декодирования
pg_multixact Подкаталог, содержащий данные о состоянии
мультитранзакций (используемые для разделяе-
мой блокировки строк)
pg_notify Подкаталог,
содержащий
данные
состоя-
ния прослушивания и нотификации (LISTEN/
NOTIFY)
pg_replslot Подкаталог, содержащий данные слота репли-
кации
pg_serial Подкаталог, содержащий информацию о выпол-
ненных сериализуемых транзакциях.
pg_snapshots Подкаталог, содержащий
снимки (snapshots)
pg_stat Подкаталог, содержащий постоянные файлы
для подсистемы статистики.
2171
номер
основной
версии
экспортированныеФизическое хранение базы данных
Элемент Описание
pg_stat_tmp Подкаталог, содержащий временные файлы для
подсистемы статистики
pg_subtrans Подкаталог, содержащий данные о состоянии
подтранзакций
pg_tblspc Подкаталог, содержащий символические ссыл-
ки на табличные пространства
pg_twophase Подкаталог, содержащий файлы состояний для
подготовленных транзакций
pg_wal Подкаталог, содержащий файлы WAL (журнал
предзаписи)
pg_xact Подкаталог, содержащий данные о состоянии
транзакции
postgresql.auto.conf Файл, используемый для хранения параметров
конфигурации, которые устанавливаются при
помощи ALTER SYSTEM
postmaster.opts Файл, содержащий параметры командной стро-
ки, с которыми сервер был запущен в последний
раз
postmaster.pid Файл блокировки, содержащий идентификатор (
ID) текущего управляющего процесса (PID), путь
к каталогу данных кластера, временную мет-
ку запуска управляющего процесса, номер пор-
та, путь к каталогу Unix-сокета (пустой для
Windows), первый корректный адрес прослуши-
вания (listen_address) (IP-адрес или *, либо пу-
стое значение в случае отсутствия прослушива-
ния по TCP), и ID сегмента разделяемой памяти (
этот файл отсутствует после остановки сервера).
Для каждой базы данных в кластере существует подкаталог внутри PGDATA/base, названный по
OID базы данных в pg_database. Этот подкаталог по умолчанию является местом хранения файлов
базы данных; в частности, там хранятся её системные каталоги.
Каждая таблица и индекс хранятся в отдельном файле. Для обычных отношений, эти фай-
лы получают имя по номеру файлового узла таблицы или индекса, который содержится в
pg_class.relfilenode. Но для временных отношений, имя файла имеет форму tBBB_FFF, где BBB</p>
<ul>
  <li>идентификатор серверного процесса сервера, который создал данный файл, а FFF — номер фай-
лового узла. В обоих случаях, помимо главного файла (также называемого основным слоем), у
каждой таблицы и индекса есть карта свободного пространства (см. Раздел 68.3), в которой хра-
нится информация о свободном пространстве в данном отношении. Имя файла карты свободного
пространства образуется из номера файлового узла с суффиксом _fsm. Также таблицы имеют кар-
ту видимости, хранящуюся в слое с суффиксом _vm, для отслеживания страниц, не содержащих
мёртвых записей. Карта видимости подробнее описана в Разделе 68.4. Нежурналируемые табли-
цы и индексы имеют третий слой, так называемый слой инициализации, имя которого содержит
суффикс _init (см. Раздел 68.5).
Внимание
Заметьте, что хотя номер файла таблицы часто совпадает с её OID, так бывает не всегда;
некоторые операции, например, TRUNCATE, REINDEX, CLUSTER и некоторые формы коман-
ды ALTER TABLE могут изменить номер файла, но при этом сохранят OID. Не следует рас-
считывать, что номер файлового узла и OID таблицы совпадают. Кроме того, для неко-
торых системных каталогов, включая и pg_class, в pg_class.relfilenode содержится
2172Физическое хранение базы данных
ноль. Фактический номер файлового узла для них хранится в низкоуровневой структу-
ре данных, и его можно получить при помощи функции pg_relation_filenode().
Когда объём таблицы или индекса превышает 1 GB, они делятся на сегменты размером в один
гигабайт. Файл первого сегмента называется по номеру файлового узла (filenode); последующие
сегменты получают имена filenode.1, filenode.2 и т. д. При такой организации хранения не возни-
кает проблем на платформах, имеющих ограничения по размеру файлов. (На самом деле, 1 ГБ —
лишь размер по умолчанию. Размер сегмента можно изменить при сборке PostgreSQL, используя
параметр конфигурации –with-segsize.) В принципе, карты свободного пространства и карты
видимости также могут занимать нескольких сегментов, хотя на практике это маловероятно.
У таблицы, столбцы которой могут содержать данные большого объёма, будет иметься собствен-
ная таблица TOAST, предназначенная для отдельного хранения значений, которые слишком вели-
ки для хранения в строках самой таблицы. Основная таблица связывается с её таблицей TOAST
(если таковая имеется) через pg_class.reltoastrelid. За подробной информацией обратитесь к
Разделу 68.2.
Содержание таблиц и индексов рассматривается ниже (см. Раздел 68.6).
Табличное пространство делает сценарий более сложным. Каждое пользовательское табличное
пространство имеет символическую ссылку внутри каталога PGDATA/pg_tblspc, указывающую на
физический каталог табличного пространства (т. е., положение, указанное в команде таблично-
го пространства CREATE TABLESPACE). Эта символическая ссылка получает имя по OID таблич-
ного пространства. Внутри физического каталога табличного пространства имеется подкаталог,
имя которого зависит от версии сервера PostgreSQL, как например PG_9.0_201008051. (Этот под-
каталог используется для того, чтобы последующие версии базы данных могли свободно исполь-
зовать одно и то же местоположение, заданное в CREATE TABLESPACE.) Внутри каталога конкрет-
ной версии находится подкаталог для каждой базы данных, которая имеет элементы в табличном
пространстве, названный по OID базы данных. Таблицы и индексы хранятся внутри этого катало-
га, используя схему именования файловых узлов. Табличное пространство pg_default недоступно
через pg_tblspc, но соответствует PGDATA/base. Подобным же образом, табличное пространство
pg_global недоступно через pg_tblspc, но соответствует PGDATA/global.
Функция pg_relation_filepath() показывает полный путь (относительно PGDATA) для любого от-
ношения. Часто это избавляет от необходимости запоминать многие из приведённых выше правил.
Но следует помнить, что эта функция выдаёт лишь имя первого сегмента основного слоя отноше-
ния, т. е. возможно, понадобится добавить номер сегмента и/или _fsm, _vm или _init, чтобы найти
все файлы, связанные с отношением.
Временные файлы (для таких операций, как сортировка объёма данных большего, чем может уме-
ститься в памяти) создаются внутри PGDATA/base/pgsql_tmp или внутри подкаталога pgsql_tmp
каталога табличного пространства, если для них определено табличное пространство, отличное
от pg_default. Имя временного файла имеет форму pgsql_tmpPPP.NNN, где PPP — PID серверного
процесса, а NNN служит для разделения различных временных файлов этого серверного процесса.
68.2. TOAST
В данном разделе рассматривается TOAST (The Oversized-Attribute Storage Technique, Методика
хранения сверхбольших атрибутов).
PostgreSQL использует фиксированный размер страницы (обычно 8 КБ), и не позволяет кортежам
занимать несколько страниц. Поэтому непосредственно хранить очень большие значения полей
невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или раз-
биваются на несколько физических строк. Это происходит незаметно для пользователя и на боль-
шую часть кода сервера влияет незначительно. Этот метод известен как TOAST (тост, или «лучшее
после изобретения нарезанного хлеба»). Инфраструктура TOAST также применяется для оптими-
зации обработки больших значений данных в памяти.
2173Физическое хранение базы данных
Лишь определённые типы данных поддерживают TOAST — нет смысла производить дополнитель-
ные действия с типами данных, размер которых не может быть большим. Чтобы поддерживать
TOAST, тип данных должен представлять значение переменной длины (varlena), в котором первое
четырёхбайтовое слово любого хранящегося значения содержит общую длину значения в байтах
(включая само это слово). Содержание оставшейся части значения TOAST не ограничивает. Спе-
циальные представления, в целом называемые значениями в формате TOAST, работают, манипу-
лируя этим начальным словом длины и интерпретируя его по-своему. Таким образом, функции
уровня C, работающие с типом данных, поддерживающим TOAST, должны аккуратно обращаться
со входными значениями, которые могут быть в формате TOAST: входные данные могут и не содер-
жать четырёхбайтовое слово длины и содержимое после него, пока не будут распакованы. (Обыч-
но в таких ситуациях нужно использовать макрос PG_DETOAST_DATUM прежде чем что-либо делать с
входным значением, но в некоторых случаях возможны и более эффективные подходы. За подроб-
ностями обратитесь к Подразделу 38.12.1.)
TOAST занимает два бита слова длины varlena (старшие биты на машинах с порядком байт от стар-
шего к младшему, или младшие биты — при другом порядке байт), таким образом, логический раз-
30
мер любого значения в формате TOAST ограничивается 1 Гигабайтом (2 - 1 байт). Когда оба бита
равны нулю, значение является обычным, не в формате TOAST, и оставшиеся биты слова длины
задают общий размер элемента данных (включая слово длины) в байтах. Когда установлен стар-
ший (или младший, в зависимости от архитектуры) бит, значение имеет однобайтовый заголовок
вместо обычного четырёхбайтового, а оставшиеся биты этого байта задают общий размер элемен-
та данных (включая байт длины) в байтах. Этот вариант позволяет экономно хранить значения
короче 127 байт и при этом допускает расширение значения этого типа данных до 1 Гбайта при
необходимости. Значения с однобайтовыми заголовками не выравниваются по какой-либо опреде-
лённой границе, тогда как значения с четырёхбайтовыми заголовками выравниваются по границе
минимум четырёх байт; это избавление от выравнивания даёт дополнительный выигрыш в объёме,
очень ощутимый для коротких значений. В качестве особого случая, если все оставшиеся биты
однобайтового заголовка равны нулю (что в принципе невозможно с учётом включения размера
длины), значением является указатель на отдельно размещённые данные, с несколькими возмож-
ными вариантами, описанными ниже. Тип и размер такого указателя TOAST определяется кодом,
хранящимся во втором байте значения. Наконец, когда старший (или младший, в зависимости от
архитектуры) бит очищен, а соседний бит установлен, содержимое данных хранится в упакован-
ном виде и должно быть распаковано перед использованием. В этом случае оставшиеся биты че-
тырёхбайтового слова длины задают общий размер сжатых, а не исходных данных. Заметьте, что
сжатие также возможно и для отделённых данных, но заголовок varlena не говорит, имеет ли оно
место — это определяется содержимым, на которое указывает указатель TOAST.
Как уже было сказано, существуют разные варианты использования указателя TOAST. Самый ста-
рый и наиболее популярный вариант — когда он указывает на отделённые данные, размещённые
в таблице TOAST, которая отделена, но связана с таблицей, содержащей собственно указатель
данных TOAST. Такой указатель на данные на диске создаётся кодом обработки TOAST (в access/
heap/tuptoaster.c), когда кортеж, сохраняемый на диск, оказывается слишком большим. Допол-
нительные подробности описаны в Подразделе  68.2.1. Кроме того, указатель TOAST может ука-
зывать на отделённые данные, размещённые где-то в памяти. Такие данные обязательно недолго-
временные и никогда не оказываются на диске, но этот механизм очень полезен для исключения
копирования и избыточной обработки данные большого размера. Дополнительные подробности
описаны в Подразделе 68.2.2.
В качестве метода сжатия внутренних и отделённых данных применяется довольно про-
стой и очень быстрый представитель семейства алгоритмов LZ. Подробнее см. src/common/
pg_lzcompress.c.
68.2.1. Отдельное размещение TOAST на диске
Если какие-либо столбцы таблицы хранятся в формате TOAST, у таблицы будет связанная с ней
таблица TOAST, OID которой хранится в значении pg_class.reltoastrelid для данной таблицы.
Размещаемые на диске TOAST-значения содержатся в таблице TOAST, что подробнее описано ни-
же.
2174Физическое хранение базы данных
Отделённые значения делятся на порции (после сжатия, если оно применяется) размером не бо-
лее TOAST_MAX_CHUNK_SIZE байт (по умолчанию это значение выбирается таким образом, чтобы
на странице помещались четыре строки порций, то есть размер одной составляет порядка 2000
байт). Каждая порция хранится как отдельная строка в таблице TOAST, принадлежащей исход-
ной таблице-владельцу. Каждая таблица TOAST имеет столбцы chunk_id (OID, идентифицирующий
конкретное TOAST-значение), chunk_seq (последовательный номер для порции внутри значения)
и chunk_data (фактические данные порции). Уникальный индекс по chunk_id и chunk_seq обеспе-
чивает быструю выдачу значений. Таким образом, в указателе, представляющем отдельно разме-
щаемое на диске значение TOAST, должно храниться OID таблицы TOAST, к которой нужно обра-
щаться, и OID определённого значения (его chunk_id). Для удобства в данных указателя также
хранится логический размер элемента данных (исходных данных без сжатия) и фактический раз-
мер хранимых данных (отличающийся, если было применено сжатие). Учитывая байты заголовка
varlena, общий размер указателя на хранимое на диске значение TOAST составляет 18 байт, неза-
висимо от фактического размера собственно значения.
Код обработки TOAST срабатывает, только когда значение строки, которое должно храниться в
таблице, по размеру больше, чем TOAST_TUPLE_THRESHOLD байт (обычно это 2 Кб). Код TOAST бу-
дет сжимать и/или выносить значения поля за пределы таблицы до тех пор, пока значение стро-
ки не станет меньше TOAST_TUPLE_TARGET байт (переменная величина, так же обычно 2 Кб) или
уменьшить объём станет невозможно. Во время операции UPDATE значения неизменённых полей
обычно сохраняются как есть, поэтому модификация строки с отдельно хранимыми значениями
не несёт издержек, связанных с TOAST, если все такие значения остаются без изменений.
Код обработки TOAST распознаёт четыре различные стратегии хранения столбцов, совместимых
с TOAST, на диске:
• PLAIN не допускает ни сжатие, ни отдельное хранение; кроме того, отключается использова-
ние однобайтовых заголовков для типов varlena. Это единственно возможная стратегия для
столбцов типов данных, которые несовместимы с TOAST.
• EXTENDED допускает как сжатие, так и отдельное хранение. Это стандартный вариант для
большинства типов данных, совместимых с TOAST. Сначала происходит попытка выполнить
сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.
• EXTERNAL допускает отдельное хранение, но не сжатие. Использование EXTERNAL ускорит опе-
рации над частями строк в больших столбцах text и bytea (ценой увеличения объёма памяти
для хранения), так как эти операции оптимизированы для извлечения только требуемых ча-
стей отделённого значения, когда оно не сжато.
• MAIN допускает сжатие, но не отдельное хранение. (Фактически, отдельное хранение, тем не
менее, будет выполнено для таких столбцов, но лишь как крайняя мера, когда нет другого
способа уменьшить строку так, чтобы она помещалась на странице.)
Каждый тип данных, совместимый с TOAST, определяет стандартную стратегию для столбцов этого
типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью ALTER
TABLE … SET STORAGE.
TOAST_TUPLE_TARGET можно задавать на уровне таблиц с помощью команды ALTER TABLE … SET
(toast_tuple_target = N)
Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк
могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются вы-
полнением сравнения с относительно маленькими значениями ключа, большая часть работы бу-
дет выполняться с использованием главной записи строки. Большие значения атрибутов в форма-
те TOAST будут просто передаваться (если будут выбраны) в тот момент, когда результирующий
набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в об-
щий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хра-
нения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполнять-
ся исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-
страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая
таблицу TOAST, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые
2175Физическое хранение базы данных
маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обра-
ботки таблицы без использования TOAST, в которой размер всех HTML-страниц был уменьшен до
7 Кб, чтобы они уместились в строках.
68.2.2. Отдельное размещение TOAST в памяти
Указатели TOAST могут указывать на данные, размещённые не на диске, а где-либо в памяти те-
кущего серверного процесса. Очевидно, что такие указатель не могут быть долговременными, но
они, тем не менее, полезны. В настоящее время поддерживаются два подварианта: косвенные ука-
затели на данные и указатели на развёрнутые данные.
Косвенный указатель TOAST просто указывает на значение varlena, хранящееся где-то в памяти.
Этот вариант изначально был реализован просто как подтверждение концепции, но в настоящее
время он применяется при логическом декодировании, чтобы не приходилось создавать физиче-
ские кортежи больше одного 1 ГБ (что может потребоваться при консолидации всех отделённых
значений полей в одном кортеже). Данный вариант имеет ограниченное применение, так как со-
здатель такого указателя должен полностью понимать, что целевые данные будут существовать,
только пока существует указатель, и никакой инфраструктуры для сохранения их нет.
Указатели на развёрнутые данные TOAST полезны для сложных типов, представление которых на
диске плохо приспособлено для вычислительных целей. Например, стандартное представление в
виде varlena массива PostgreSQL включает информацию о размерности, битовую карту элементов
NULL (если они в нём содержатся), а затем значения всех элементов по порядку. Когда элемент
сам по себе имеет переменную длину, единственный способ найти N-ный элемент — просканиро-
вать все предыдущие элементы. Это представление компактно, и поэтому подходит для хранения
на диске, но для вычислительной обработки массива гораздо удобнее иметь «развёрнутое» или
«деконструированное» представление, в котором можно определить начальные адреса всех эле-
ментов. Механизм указателей TOAST способствует решению этой задачи, допуская передачу по
ссылке элемента Datum как указателя на стандартное значение varlena (представление на диске)
или указателя TOAST на развёрнутое представление где-то в памяти. Детали развёрнутого пред-
ставление определяются самим типом данных, хотя оно может иметь стандартный заголовок и удо-
влетворять другим требованиям API, описанным в src/include/utils/expandeddatum.h. Функции
уровня C, работающие с этим типом, могут реализовать поддержку любого из этих представлений.
Функции, не знающие о развёрнутом представлении, а просто применяющие PG_DETOAST_DATUM к
своим входным данным, будут автоматически получать традиционное представление varlena; так
что поддержка развёрнутого представления может вводиться постепенно, по одной функции.
Указатели TOAST на развёрнутые значения далее подразделяются на указатели для чтения/за-
писи и указатели только для чтения. Представление, на которое они указывают, в любом случае
одинаковое, но функции, получающей указатель для чтения/записи, разрешается модифицировать
целевые данные прямо на месте, тогда как функция, получающая указатель только для чтения, не
должна этого делать; если ей нужно получить изменённую версию значения, она должна сначала
сделать копию. Это отличие и связанные с ним соглашения позволяют избежать излишнего копи-
рования развёрнутых значений при выполнении запросов.
Для всех типов указателей TOAST на данные в памяти, код обработки TOAST гарантирует, что та-
кие данные не окажутся случайно сохранены на диске. Указатели TOAST в памяти автоматически
сворачиваются в обычные значения varlena перед сохранением — а затем могут преобразоваться
в указатели TOAST на диске, если без этого не смогут уместиться в содержащем их кортеже.
68.3. Карта свободного пространства
Каждое табличное и индексное отношение, за исключением хеш-индексов, имеет карту свободно-
го пространства (Free Space Map, FSM) для отслеживания доступного места. Она хранится рядом с
данными главного отношения в отдельном слое, имя которого образуется номером файлового узла
отношения с суффиксом _fsm. Например, если файловый узел отношения — 12345, FSM хранится
в файле с именем 12345_fsm в том же каталоге, что и основной файл отношения.
Карта свободного пространства представляет собой дерево страниц FSM. Страницы FSM нижнего
уровня хранят информацию о свободном пространстве, доступном на каждой странице таблицы
2176Физическое хранение базы данных
(или индекса), используя один байт для представления каждой такой страницы. Верхние уровни
агрегируют информацию нижних уровней.
Внутри каждой страницы FSM имеется двоичное дерево, хранящееся в массиве, где один байт
выделяется на каждый узел дерева. Каждый листовой узел представляет страницу таблицы или
страницу FSM нижнего уровня. В каждом узле выше листовых хранится наибольшее из значений
его узлов-потомков. Поэтому максимальное из значений листовых узлов хранится в корневом узле.
Более подробную информацию о структуре FSM и о том, как выполняется обновление и поиск, вы
найдёте в src/backend/storage/freespace/README. Модуль pg_freespacemap может быть исполь-
зован для просмотра информации, хранящейся в картах свободного пространства.
68.4. Карта видимости
Каждое отношение таблицы имеет карту видимости (Visibility Map, VM) для отслеживания стра-
ниц, содержащих только кортежи, которые видны всем активным транзакциям; в ней также отсле-
живается, какие страницы содержат только замороженные кортежи. Она хранится вместе с дан-
ными главного отношения в отдельном файле, имя которого образуется номером файлового узла
отношения с суффиксом _vm. Например, если файловый узел отношения — 12345, VM хранится в
файле 12345_vm, в том же самом каталоге, что и основной файл отношения. Заметьте, что индексы
не имеют VM.
Карта видимости хранит по два бита на страницу таблицы. Первый бит, если он установлен, пока-
зывает, что вся страница видна или, другими словами, не содержит кортежей, которые необходи-
мо очистить. Эта информация может также использоваться при сканировании только индекса для
поиска ответов только в данных индекса. Установленный второй бит показывает, что все кортежи
на этой странице заморожены. Это означает, что процесс очистки для предотвращения зацикли-
вания не должен больше посещать эту страницу.
Карта может отражать реальные данные с запаздыванием в том смысле, что мы уверены, что в
случаях, когда установлен бит, известно, что условие верно, но если бит не установлен, оно может
быть верным или неверным. Биты карты видимости устанавливаются только при очистке, а сбра-
сываются при любых операциях, изменяющих данные на странице.
Для изучения информации, хранящейся в карте видимости, можно воспользоваться модулем
pg_visibility.
68.5. Слой инициализации
Каждая нежурналируемая таблица, и каждый индекс такой таблицы имеет файл инициализации.
Файл инициализации представляет собой пустую таблицу или индекс соответствующего типа. Ко-
гда нежурналируемая таблица должна быть заново очищена по причине сбоя, файл инициализа-
ции копируется поверх главного файла, а все прочие файлы удаляются (при необходимости они
будут автоматически созданы заново).
68.6. Компоновка страницы базы данных
В данном разделе рассматривается формат страницы, используемый в таблицах и индексах
1
PostgreSQL. Последовательности и таблицы TOAST форматируются как обычные таблицы.
В дальнейшем подразумевается, что байт содержит 8 бит. В дополнение, термин элемент отно-
сится к индивидуальному значению данных, которое хранится на странице. В таблице элемент —
это строка; в индексе — элемент индекса.
Каждая таблица и индекс хранятся как массив страниц фиксированного размера (обычно 8 kB,
хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы
1
Фактически индексные методы доступа не нуждаются в этом формате страниц. Все существующие индексные методы в действительности используют этот
основной формат, но данные, хранящиеся в индексных метастраницах обычно не следуют правилам компоновки.
2177Физическое хранение базы данных
логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой стра-
нице. В индексах первая страница обычно резервируется как метастраница, хранящая контроль-
ную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода
доступа индекса.
Таблица 68.2 показывает общую компоновку страницы. Каждая страница имеет пять частей.
Таблица 68.2. Общая компоновка страницы
Элемент Описание
Данные заголовка страницы Длина — 24 байта. Содержит общую информа-
цию о странице, включая указатели свободного
пространства.
Данные идентификаторов элементов Массив пар (смещение, длина), указывающих на
фактические элементы. Для каждого элемента
выделяется 4 байта.
Свободное пространство Незанятое пространство. Новые указатели эле-
ментов размещаются с начала этой области, са-
ми новые элементы — с конца.
Элементы Сами элементы данных как таковые.
Специальное пространство Специфические данные метода доступа. Для
различных методов хранятся различные дан-
ные. Для обычных таблиц таких данных нет.
Первые 24 байта каждой страницы образуют заголовок страницы (PageHeaderData). Его формат
подробно описан в Таблице  68.3. В первом поле отслеживается самая последняя запись в WAL,
связанная с этой страницей. Второе поле содержит контрольную сумму страницы, если включён
режим data checksums. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следуют
три двухбайтовых целочисленных поля (pd_lower, pd_upper и pd_special). Они содержат смещения
в байтах от начала страницы до начала незанятого пространства, до конца незанятого простран-
ства и до начала специального пространства. В следующих 2 байтах заголовка страницы, в поле
pd_pagesize_version, хранится размер страницы и индикатор версии. Начиная с PostgreSQL 8.3,
используется версия 4; в PostgreSQL 8.1 и 8.2 использовалась версия 3; в PostgreSQL 8.0 — версия
2; в PostgreSQL 7.3 и 7.4 — версия 1; а в предыдущих выпусках — версия 0. (Основная структура
страницы и формат заголовка почти во всех этих версиях одни и те же, но структура заголовка
строк в куче изменялась.) Размер страницы присутствует, в основном, только для перекрёстной
проверки; возможность использовать в одной инсталляции разные размеры страниц не поддержи-
вается. Последнее поле подсказывает, насколько вероятна возможность получить выигрыш, про-
изведя очистку страницы: оно отслеживает самый старый XMAX на странице, не подвергавшийся
очистке.
Таблица 68.3. Данные заголовка страницы (PageHeaderData)
Поле Тип Длина Описание
pd_lsn PageXLogRecPtr 8 байт LSN: Следующий байт
после последнего байта
записи WAL для послед-
него изменения на этой
странице
pd_checksum uint16 2 байта Контрольная
страницы
pd_flags uint16 2 байта Биты признаков
pd_lower LocationIndex 2 байта Смещение до начала
свободного простран-
ства
2178
суммаФизическое хранение базы данных
Поле Тип Длина Описание
pd_upper LocationIndex 2 байта Смещение до конца сво-
бодного пространства
pd_special LocationIndex 2 байта Смещение до нача-
ла специального про-
странства
pd_pagesize_version uint16 2 байта Информация о размере
страницы и номере вер-
сии компоновки
pd_prune_xid TransactionId 4 байта Самый старый неочи-
щенный
идентифика-
тор XMAX на страни-
це или ноль при отсут-
ствии такового
Всю подробную информацию можно найти в src/include/storage/bufpage.h.
За заголовком страницы следуют идентификаторы элемента (ItemIdData), каждому из которых
требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его
длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые иден-
тификаторы элементов размещаются по мере необходимости от начала свободного пространства.
Количество имеющихся идентификаторов элементов можно определить через значение pd_lower,
которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор эле-
мента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно исполь-
зовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам эле-
мент перемещается по странице для уплотнения свободного пространства. Фактически каждый
указатель на элемент (ItemPointer, также известный как CTID), созданный PostgreSQL, состоит из
номера страницы и индекса идентификатора элемента.
Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу неза-
нятого пространства. Точная структура меняется в зависимости от того, каким будет содер-
жание таблицы. Как таблицы, так и последовательности используют структуру под названием
HeapTupleHeaderData, которая описывается ниже.
Последний раздел является «особым разделом», который может содержать всё, что необходимо
методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева
и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные
таблицы не используют особый раздел вовсе (что указывается установкой значения pd_special
равным размеру страницы).
68.6.1. Компоновка строки таблицы
Все строки таблицы структурированы одним и тем же образом. Они включают заголовок фиксиро-
ванного размера (занимающий 23 байта на большинстве машин), за которым следует необязатель-
ная битовая карта пустых значений, необязательное поле идентификатора объекта и данные поль-
зователя. Подробное описание заголовка представлено в Таблица 68.4. Актуальные пользователь-
ские данные (столбцы строки) начинаются после смещения, заданного в t_hoff, которое должно
всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений имеет-
ся тогда, когда бит HEAP_HASNULL установлен в значении t_infomask. В случае наличия, она на-
чинается сразу после фиксированного заголовка и занимает достаточно байтов, чтобы иметь один
бит на столбец (т. е. t_natts битов всего). В этом списке битов установленный в единицу бит озна-
чает непустое значение, а установленный в ноль соответствует пустому значению. Когда битовая
карта отсутствует, все столбцы считаются непустыми. Идентификатор объекта присутствует, если
только бит HEAP_HASOID установлен в значении t_infomask. Если он есть, он расположен сразу
перед началом t_hoff. Любое заполнение, необходимое для того, чтобы сделать t_hoff кратным
MAXALIGN, будет расположено между битовой картой пустых значений и идентификатором объ-
екта. (Это в свою очередь гарантирует, что идентификатор объекта будет правильно выровнен.)
2179Физическое хранение базы данных
Таблица 68.4. Данные заголовка строки таблицы (HeapTupleHeaderData)
Поле Тип Длина Описание
t_xmin TransactionId 4 байта значение XID вставки
t_xmax TransactionId 4 байта значение XID удаления
t_cid CommandId 4 байта значение CID для встав-
ки и/или удаления (пе-
ресекается с t_xvac)
t_xvac TransactionId 4 байта XID
для
операции
VACUUM, которая пе-
ремещает версию стро-
ки
t_ctid ItemPointerData 6 байт текущее значение TID
этой или более новой
версии строки
t_infomask2 uint16 2 байта количество атрибутов
плюс различные биты
флагов
t_infomask uint16 2 байта различные биты флагов
t_hoff uint8 1 байт отступ до пользователь-
ских данных
Всю подробную информацию можно найти в src/include/access/htup_details.h.
Интерпретация текущих данных может быть проведена с помощью информации, полученной из
других таблиц, в основном из pg_attribute. Ключевые значения, необходимые для определения
расположения полей attlen и attalign. Не существует способа непосредственного получения за-
данного атрибута кроме случая, когда имеются только поля фиксированной длины, и при этом
нет пустых значений. Все эти особенности учитываются в функциях heap_getattr, fastgetattr и
heap_getsysattr.
Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь
нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений.
Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание
является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это
поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной дли-
ной имеют общую структуру заголовка struct varlena, которая включает общую длину сохранён-
ного значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут
храниться либо локально, либо в таблице TOAST. Также, возможно сжатие данных (см. Раздел 68.2).
2180</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-067/" title="Глава 67. Индексы BRIN"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 67. Индексы BRIN"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-067/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~9 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-067/" rel="bookmark" title="Глава 67. Индексы BRIN" itemprop="url">Глава 67. Индексы BRIN</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 67. Индексы BRIN</p>

<p>67.1. Введение</p>

<p>BRIN расшифровывается как «Block Range Index» (Индекс зон блоков). BRIN предназначается для
обработки очень больших таблиц, в которых определённые столбцы некоторым естественным об-
разом коррелируют с их физическим расположением в таблице. Зоной блоков называется группа
страниц, физически расположенных в таблице рядом; для каждой зоны в индексе сохраняется
некоторая сводная информация. Например, в таблице заказов магазина может содержаться поле
с датой добавления заказа, и практически всегда записи более ранних заказов и в таблице будут
размещены ближе к началу; в таблице, содержащей столбец с почтовым индексом, также есте-
ственным образом могут группироваться записи по городам.
Индексы BRIN могут удовлетворять запросы, выполняя обычное сканирование по битовой карте, и
будут возвращать все кортежи во всех страницах каждой зоны, если сводные данные, сохранённые
в индексе, соответствуют условиям запроса. Исполнитель запроса должен перепроверить эти
кортежи и отбросить те, что не соответствуют условиям запроса — другими словами, эти индексы
неточные. Так как индекс BRIN очень маленький, сканирование индекса влечёт мизерные издерж-
ки по сравнению с последовательным сканированием, но может избавить от необходимости ска-
нирования больших областей таблицы, которые определённо не содержат подходящие кортежи.
Конкретные данные, которые будут хранится в индексе BRIN, а также запросы, которые сможет
поддержать этот индекс, зависят от класса операторов, выбранного для каждого столбца индекса.
Например, типы данных с линейным порядком сортировки могут иметь классы операторов, храня-
щие минимальное и максимальное значение для каждой зоны блоков; для геометрических типов
может храниться прямоугольник, вмещающий все объекты в зоне блоков.
Размер зоны блоков определяется в момент создания индекса параметром хранения
pages_per_range. Число записей в индексе будет равняться размеру отношения в страницах, де-
лённому на установленное значение pages_per_range. Таким образом, чем меньше это число, тем
больше становится индекс (так как в нём требуется хранить больше элементов), но в то же время
сводные данные могут быть более точными и большее число блоков данных может быть пропущено
при сканировании индекса.
67.1.1. Обслуживание индекса
Во время создания индекса сканируются все существующие страницы, и в результате в индексе
создаётся сводный кортеж для каждой зоны, в том числе, возможно неполной зоны в конце. По
мере того, как данными наполняются новые страницы, если они оказываются в зонах, для которых
уже есть сводная информация, она будет обновлена с учётом данных из новых кортежей. Если же
создаётся новая страница, которая не попадает в последнюю зону, для новой зоны автоматически
не рассчитывается сводная запись; кортежи на таких страницах остаются неучтёнными, пока поз-
же не будет проведён расчёт сводных данных. Эта процедура может быть вызвана вручную, с по-
мощью функции brin_summarize_new_values(regclass), или автоматически, когда таблицу будет
обрабатывать VACUUM или при автоочистке по мере добавления записей. (Последний метод отклю-
чён по умолчанию и может быть включён параметром autosummarize.) И наоборот, можно удалить
сводное значение для зоны, вызвав функцию brin_desummarize_range(regclass, bigint), что мо-
жет быть полезно, когда этот кортеж в индексе становится не очень хорошим представлением со-
ответствующих данных, так как они изменились.
Когда включён режим автопересчёта сводки, при каждом заполнении зоны страниц механизму
автоочистки передаётся запрос для пересчёта сводки только по этой зоне, и он будет выполнен в
конце следующего прохода обработки той же базы данных. Если очередь запросов переполнена,
запрос в неё не записывается и в журнал сервера выводится соответствующее сообщение:
LOG: request for BRIN range summarization for index “brin_wi_idx” page 128 was not
recorded
2166Индексы BRIN
В этой ситуации сводка для данной зоны будет пересчитана при выполнении следующей обычной
очистки таблицы.
67.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов BRIN, перечисленные в Табли-
це 67.1.
Классы операторов minmax хранят минимальные и максимальные значения, встречающиеся в ин-
дексированном столбце в определённой зоне. Классы операторов inclusion хранят значение, в ко-
тором содержатся значения индексированного столбца в определённой зоне.
Таблица 67.1. Встроенные классы операторов BRIN
Имя Индексируемый тип данных Индексируемые операторы
abstime_minmax_ops abstime &lt; &lt;= = &gt;= &gt;
int8_minmax_ops bigint &lt; &lt;= = &gt;= &gt;
bit_minmax_ops bit &lt; &lt;= = &gt;= &gt;
varbit_minmax_ops bit varying &lt; &lt;= = &gt;= &gt;
box_inclusion_ops box « &amp;&lt; &amp;&amp; &amp;&gt; » ~= @&gt; &lt;@ &amp;&lt;| «| |</p>
<blockquote>
  <blockquote>
    <p>|&amp;&gt;
bytea_minmax_ops bytea &lt; &lt;= = &gt;= &gt;
bpchar_minmax_ops character &lt; &lt;= = &gt;= &gt;
char_minmax_ops “char” &lt; &lt;= = &gt;= &gt;
date_minmax_ops date &lt; &lt;= = &gt;= &gt;
float8<em>minmax_ops double precision &lt; &lt;= = &gt;= &gt;
inet_minmax_ops inet &lt; &lt;= = &gt;= &gt;
network_inclusion_ops inet &amp;&amp; »= «= = » «
int4_minmax_ops integer &lt; &lt;= = &gt;= &gt;
interval_minmax_ops interval &lt; &lt;= = &gt;= &gt;
macaddr_minmax_ops macaddr &lt; &lt;= = &gt;= &gt;
macaddr8_minmax_ops macaddr8 &lt; &lt;= = &gt;= &gt;
name_minmax_ops name &lt; &lt;= = &gt;= &gt;
numeric_minmax_ops numeric &lt; &lt;= = &gt;= &gt;
pg_lsn_minmax_ops pg_lsn &lt; &lt;= = &gt;= &gt;
oid_minmax_ops oid &lt; &lt;= = &gt;= &gt;
range_inclusion_ops любой тип диапазона « &amp;&lt; &amp;&amp; &amp;&gt; » @&gt; &lt;@ -|- = &lt; &lt;= =
=
float4_minmax_ops real &lt; &lt;= = &gt;= &gt;
reltime_minmax_ops reltime &lt; &lt;= = &gt;= &gt;
int2_minmax_ops smallint &lt; &lt;= = &gt;= &gt;
text_minmax_ops text &lt; &lt;= = &gt;= &gt;
tid_minmax_ops tid &lt; &lt;= = &gt;= &gt;
timestamp_minmax_ops timestamp without time zone &lt; &lt;= = &gt;= &gt;
timestamptz_minmax_ops timestamp with time zone &lt; &lt;= = &gt;= &gt;
time_minmax_ops time without time zone &lt; &lt;= = &gt;= &gt;
timetz_minmax_ops time with time zone &lt; &lt;= = &gt;= &gt;
2167Индексы BRIN
Имя Индексируемый тип данных Индексируемые операторы
uuid_minmax_ops uuid
&lt; &lt;= = &gt;= &gt;
67.3. Расширяемость
Интерфейс BRIN характеризуется высоким уровнем абстракции и таким образом требует от раз-
работчика метода доступа реализовать только смысловое наполнение обрабатываемого типа дан-
ных. Уровень BRIN берёт на себя заботу о параллельном доступе, поддержке журнала и поиске в
структуре индекса.
Всё, что нужно, чтобы получить работающий метод доступа BRIN — это реализовать несколько
пользовательских методов, определяющих поведение сводных значений, хранящихся в индексе, и
их взаимоотношения с ключами сканирования. Словом, BRIN сочетает расширяемость с универ-
сальностью, повторным использованием кода и аккуратным интерфейсом.
Класс операторов для BRIN должен предоставлять четыре метода:
BrinOpcInfo *opcInfo(Oid type_oid)
Возвращает внутреннюю информацию о сводных данных индексированных столбцов. Возвра-
щаемое значение должно указывать на BrinOpcInfo (в памяти palloc) со следующим определе-
нием:
typedef struct BrinOpcInfo
{
/* Число полей, хранящихся в столбце индекса этого класса операторов */
uint16
oi_nstored;
/* Непрозрачный указатель для внутреннего использования классом операторов */
void
*oi_opaque;
/* Элементы кеша типов для сохранённых столбцов */
TypeCacheEntry *oi_typcache[FLEXIBLE_ARRAY_MEMBER];
} BrinOpcInfo;
Поле BrinOpcInfo.oi_opaque могут использовать подпрограммы класса операторов для пере-
дачи информации опорным функциям при сканировании индекса.
bool consistent(BrinDesc *bdesc, BrinValues *column, ScanKey key)
Показывает, соответствует ли значение ScanKey заданным индексированным значениям неко-
торой зоны. Номер целевого атрибута передаётся в составе ключа сканирования.
bool addValue(BrinDesc *bdesc, BrinValues *column, Datum newval, bool isnull)
Для заданного кортежа индекса и индексируемого значения изменяет выбранный атрибут кор-
тежа, чтобы он дополнительно охватывал новое значение. Если в кортеж вносятся какие-либо
изменения, возвращается true.
bool unionTuples(BrinDesc *bdesc, BrinValues *a, BrinValues *b)
Консолидирует два кортежа индекса. Получая два кортежа, изменяет выбранный атрибут пер-
вого из них, что он охватывал оба кортежа. Второй кортеж не изменяется.
Основной дистрибутив включает поддержку двух типов классов операторов: minmax и inclusion.
Определения классов операторов, использующие их, представлены для встроенных типов данных,
насколько это уместно. Пользователь может определить дополнительные классы операторов для
других типов данных, применяя аналогичные определения, обойдясь без написания исходного ко-
да; достаточно будет объявить нужные записи в каталоге. Заметьте, что предположения о семан-
тике стратегий операторов зашиты в исходном коде опорных функций.
Также возможно создать классы операторов, воплощающие полностью другую семантику, разра-
ботав реализации четырёх основных опорных функций, описанных выше. Заметьте, что обратная
2168Индексы BRIN
совместимость между разными основными версиями не гарантируется: к примеру, в следующих
выпусках могут потребоваться дополнительные опорные функции.
При написании класса операторов для типа данных, представляющего полностью упорядоченное
множество, можно использовать опорные функции minmax вместе с соответствующими операто-
рами, как показано в Таблице 67.2. Все члены класса операторов (функции и операторы) являются
обязательными.
Таблица 67.2. Номера стратегий и опорных функций для классов операторов Minmax
Член класса операторов Объект
Опорная функция 1 внутренняя функция brin_minmax_opcinfo()
Опорная функция 2 внутренняя
value()
Опорная функция 3 внутренняя
consistent()
Опорная функция 4 внутренняя функция brin_minmax_union()
Стратегия оператора 1 оператор меньше
Стратегия оператора 2 оператор меньше-или-равно
Стратегия оператора 3 оператор равно
Стратегия оператора 4 оператор больше-или-равно
Стратегия оператора 5 оператор больше
функция
brin_minmax_add</em>
функция
brin_minmax_
При написании класса операторов для сложного типа данных, значения которого включаются в
другой тип, можно использовать опорные функции inclusion вместе с соответствующими операто-
рами, как показано в Таблице 67.3. Для этого требуется одна дополнительная функция, которую
можно написать на любом языке. Для расширенной функциональности можно определить другие
функции. Все операторы являются необязательными. Некоторые из них требует наличия других,
что показано в таблице как зависимости.
Таблица 67.3. Номера стратегий и опорных функций для классов операторов Inclusion
Член класса операторов Объект
Зависимость
Опорная функция 1 внутренняя
функция
inclusion_opcinfo()
brin_
Опорная функция 2 внутренняя
функция
inclusion_add_value()
brin_
Опорная функция 3 внутренняя
функция
brin_
inclusion_consistent()
Опорная функция 4 внутренняя
функция
inclusion_union()
Опорная функция 11 функция для слияния двух эле-
ментов
Опорная функция 12 необязательная функция для
проверки возможности слияния
двух элементов
Опорная функция 13 необязательная функция для
проверки, содержится ли один
элемент в другом
Опорная функция 14 необязательная функция для
проверки, является ли элемент
пустым
2169
brin_Индексы BRIN
Член класса операторов Объект Зависимость
Стратегия оператора 1 оператор левее Стратегия оператора 4
Стратегия оператора 2 оператор не-простирается-пра- Стратегия оператора 5
вее
Стратегия оператора 3 оператор перекрывается Стратегия оператора 4 оператор
вее Стратегия оператора 5 оператор правее Стратегия оператора 2
Стратегия оператора 6, 18 оператор то-же-или-равно Стратегия оператора 7
не-простирается-ле- Стратегия оператора 1
Стратегия оператора 7, 13, 16, оператор содержит-или-равно
24, 25
Стратегия оператора 8, 14, 26, оператор
27
равно
содержится-в-или- Стратегия оператора 3
Стратегия оператора 9 оператор
ше
не-простирается-вы- Стратегия оператора 11
Стратегия оператора 10 оператор ниже Стратегия оператора 12
Стратегия оператора 11 оператор выше Стратегия оператора 9
Стратегия оператора 12 оператор
же Стратегия оператора 20 оператор меньше Стратегия оператора 5
Стратегия оператора 21 оператор меньше-или-равно Стратегия оператора 5
Стратегия оператора 22 оператор больше Стратегия оператора 1
Стратегия оператора 23 оператор больше-или-равно Стратегия оператора 1
не-простирается-ни- Стратегия оператора 10
Номера опорных функций 1-10 зарезервированы для внутренних функций BRIN, так что функции
уровня SQL начинаются с номера 11. Опорная функция номер 11 является основной, необходимой
для построения индекса. Она должна принимать два аргумента того же типа данных, что и целе-
вой тип класса, и возвращать их объединение. Класс операторов inclusion может сохранять значе-
ния объединения в различных типах данных, в зависимости от параметра STORAGE. Возвращаемое
значение функции объединения должно соответствовать типу данных STORAGE.
Опорные функции под номерами 12 и 14 предоставляются для поддержки нерегулярностей встро-
енных типов данных. Функция номер 12 применяется для поддержки работы с сетевыми адресами
из различных семейств, которые нельзя объединять. Функция номер 14 применяется для поддерж-
ки зон с пустыми значениями. Функция номер 13 является необязательной, но рекомендуемой; она
проверяет новое значение, прежде чем оно будет передано функции объединения. Инфраструкту-
ра BRIN может соптимизировать некоторые операции, когда объединение не меняется, поэтому
применение этой функции может способствовать увеличению быстродействия индекса.
Классы операторов minmax и inclusion поддерживают операторы с разными типами, хотя с ними
зависимости становятся более сложными. Класс minmax требует, чтобы для двух аргументов одно-
го типа определялся полный набор операторов. Это позволяет поддерживать дополнительные ти-
пы данных, определяя дополнительные наборы операторов. Стратегии операторов класса inclusion
могут зависеть от других стратегий, как показано в Таблице 67.3, или от своих собственных стра-
тегий. Для них требуется, чтобы был определён необходимый оператор с типом данных STORAGE
для левого аргумента и другим поддерживаемым типом для правого аргумента реализуемого опе-
ратора. См. определение float4_minmax_ops в качестве примера для minmax и box_inclusion_ops
в качестве примера для inclusion.
2170</p>
  </blockquote>
</blockquote>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-066/" title="Глава 66. Индексы GIN"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 66. Индексы GIN"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-066/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~14 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-066/" rel="bookmark" title="Глава 66. Индексы GIN" itemprop="url">Глава 66. Индексы GIN</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 66. Индексы GIN</p>

<p>66.1. Введение</p>

<p>GIN расшифровывается как «Generalized Inverted Index» (Обобщённый инвертированный индекс).
GIN предназначается для случаев, когда индексируемые значения являются составными, а запро-
сы, на обработку которых рассчитан индекс, ищут значения элементов в этих составных объектах.
Например, такими объектами могут быть документы, а запросы могут выполнять поиск докумен-
тов, содержащих определённые слова.
Здесь мы используем термин объект, говоря о составном значении, которое индексируется, и тер-
мин ключ, говоря о включённом в него элементе. GIN всегда хранит и ищет ключи, а не объекты
как таковые.
Индекс GIN сохраняет набор пар (ключ, список идентификаторов), где список идентификаторов
содержит идентификаторы строк, в которых находится ключ. Один и тот же идентификатор строки
может фигурировать в нескольких списках, так как объект может содержать больше одного ключа.
Значение каждого ключа хранится только один раз, так что индекс GIN очень компактен в случаях,
когда один ключ встречается много раз.
GIN является обобщённым в том смысле, что код метода доступа GIN не должен знать о конкрет-
ных операциях, которые он ускоряет. Вместо этого задаются специальные стратегии для конкрет-
ных типов данных. Стратегия определяет, как извлекаются ключи из индексируемых объектов и
условий запросов, и как установить, действительно ли удовлетворяет запросу строка, содержащая
некоторые значения ключей.
Ключевым преимуществом GIN является то, что он позволяет разрабатывать дополнительные ти-
пы данных с соответствующими методами доступа экспертам в предметной области типа данных,
а не специалистам по СУБД. В этом аспекте он похож на GiST.
Сопровождением реализации GIN в PostgreSQL в основном занимаются Фёдор Сигаев и Олег Бар-
тунов. Дополнительные сведения о GIN можно получить на их сайте.
66.2. Встроенные классы операторов
В базовый дистрибутив PostgreSQL включены классы операторов GIN, перечисленные в Табли-
це 66.1. (Некоторые дополнительные модули, описанные в Приложении F, добавляют другие клас-
сы операторов GIN.)
Таблица 66.1. Встроенные классы операторов GIN
Имя Индексируемый тип данных Индексируемые операторы
array_ops anyarray
&amp;&amp; &lt;@ = @&gt;
jsonb_ops jsonb
? ?&amp; ?| @&gt;
jsonb_path_ops jsonb
@&gt;
tsvector_ops tsvector
@@ @@@
Из двух классов операторов для типа jsonb классом по умолчанию является jsonb_ops. Класс
jsonb_path_ops поддерживает меньше операторов, но обеспечивает для них большую производи-
тельность. За подробностями обратитесь к Подразделу 8.14.4.
66.3. Расширяемость
Интерфейс GIN характеризуется высоким уровнем абстракции и таким образом требует от разра-
ботчика метода доступа реализовать только смысловое наполнение обрабатываемого типа данных.
2160Индексы GIN
Уровень GIN берёт на себя заботу о параллельном доступе, поддержке журнала и поиске в струк-
туре дерева.
Всё, что нужно, чтобы получить работающий метод доступа GIN — это реализовать несколько
пользовательских методов, определяющих поведение ключей в дереве и отношения между ключа-
ми, индексируемыми объектами и поддерживаемыми запросами. Словом, GIN сочетает расширя-
емость с универсальностью, повторным использованием кода и аккуратным интерфейсом.
Класс операторов должен предоставить GIN следующие два метода:
Datum *extractValue(Datum itemValue, int32 *nkeys, bool **nullFlags)
Возвращает массив ключей (выделенный через palloc) для индексируемого объекта. Число воз-
вращаемых ключей должно записываться в *nkeys. Если какой-либо из ключей может быть
NULL, нужно так же выделить через palloc массив из *nkeys полей bool, записать его адрес
в *nullFlags и установить эти флаги NULL как требуется. В *nullFlags можно оставить зна-
чение NULL (это начальное значение), если все ключи отличны от NULL. Эта функция может
возвратить NULL, если объект не содержит ключей.
Datum *extractQuery(Datum query, int32 *nkeys, StrategyNumber n, bool **pmatch, Pointer
**extra_data, bool **nullFlags, int32 *searchMode)
Возвращает массив ключей (выделенный через palloc) для запрашиваемого значения; то есть,
в query поступает значение, находящееся по правую сторону индексируемого оператора, по
левую сторону которого указан индексируемый столбец. Аргумент n задаёт номер стратегии
оператора в классе операторов (см. Подраздел 38.15.2). Часто функция extractQuery должна
проанализировать n, чтобы определить тип данных аргумента query и выбрать метод для из-
влечения значений ключей. Число возвращаемых ключей должно быть записано в *nkeys. Ес-
ли какие-либо ключи могут быть NULL, нужно так же выделить через palloc массив из *nkeys
полей bool, сохранить его адрес в *nullFlags, и установить эти флаги NULL как требуется. В
*nullFlags можно оставить значение NULL (это начальное значение), если все ключи отличны
от NULL. Эта функция может возвратить NULL, если query не содержит ключей.
Выходной аргумент searchMode позволяет функции extractQuery выбрать режим, в кото-
ром должен выполняться поиск. Если *searchMode имеет значение GIN_SEARCH_MODE_DEFAULT
(это значение устанавливается перед вызовом), подходящими кандидатами считаются толь-
ко те объекты, которые соответствуют минимум одному из возвращённых ключей. Если в
*searchMode установлено значение GIN_SEARCH_MODE_INCLUDE_EMPTY, то в дополнение к объ-
ектам с минимум одним совпадением ключа, подходящими кандидатами будут считаться
и объекты, вообще не содержащие ключей. (Этот режим полезен для реализации, напри-
мер, операторов A-является-подмножеством-B.) Если в *searchMode установлено значение
GIN_SEARCH_MODE_ALL, подходящими кандидатами считаются все отличные от NULL объекты в
индексе, независимо от того, встречаются ли в них возвращаемые ключи. (Этот режим намного
медленнее двух других, так как он по сути требует сканирования всего индекса, но он может
быть необходим для корректной обработки крайних случаев. Оператор, который выбирает этот
режим в большинстве ситуаций, скорее всего не подходит для реализации в классе операторов
GIN.) Символы для этих значений режима определены в access/gin.h.
Выходной аргумент pmatch используется, когда поддерживается частичное соответствие. Что-
бы использовать его, extractQuery должна выделить массив из *nkeys булевских элементов и
сохранить его адрес в *pmatch. Элемент этого массива должен содержать true, если соответ-
ствующий ключ требует частичного соответствия, и false в противном случае. Если переменная
*pmatch содержит NULL, GIN полагает, что частичное соответствие не требуется. В эту пере-
менную записывается NULL перед вызовом, так что этот аргумент можно просто игнорировать
в классах операторов, не поддерживающих частичное соответствие.
Выходной аргумент extra_data позволяет функции extractQuery передать дополнительные
данные методам consistent и comparePartial. Чтобы использовать его, extractQuery должна
выделить массив из *nkeys указателей и сохранить его адрес в *extra_data, а затем сохранить
всё, что ей требуется, в отдельных указателях. В эту переменную записывается NULL перед вы-
2161Индексы GIN
зовом, поэтому данный аргумент может просто игнорироваться классами операторов, которым
не нужны дополнительные данные. Если массив *extra_data задан, он целиком передаётся в
метод consistent, а в comparePartial передаётся соответствующий его элемент.
Класс операторов должен также предоставить функцию для проверки, соответствует ли индекси-
рованный объект запросу. Поддерживаются две её вариации: булевская consistent и троичная
triConsistent. Функция triConsistent покрывает функциональность обоих, так что достаточно
реализовать только её. Однако, если вычисление булевской вариации оказывается значительно
дешевле, может иметь смысл реализовать их обе. Если представлена только булевская вариация,
некоторые оптимизации, построенные на отбраковывании объектов до выборки всех ключей, от-
ключаются.
bool consistent(bool check[], StrategyNumber n, Datum query, int32
extra_data[], bool *recheck, Datum queryKeys[], bool nullFlags[])
nkeys,
Pointer
Возвращает true, если индексированный объект удовлетворяет оператору запроса с номером
стратегии n (или потенциально удовлетворяет, когда возвращается указание перепроверки).
Эта функция не имеет прямого доступа к значению индексированного объекта, так как GIN
не хранит сами объекты. Вместо этого, она знает о значениях ключей, извлечённых из запро-
са и встречающихся в данном индексированном объекте. Массив check имеет длину nkeys,
что равняется числу ключей, ранее возвращённых функцией extractQuery для данного зна-
чения query. Элемент массива check равняется true, если индексированный объект содержит
соответствующий ключ запроса; то есть, если (check[i] == true), то i-ый ключ в массиве ре-
зультата extractQuery присутствует в индексированном объекте. Исходное значение query
передаётся на случай, если оно потребуется методу consistent; с той же целью ему пере-
даются массивы queryKeys[] и nullFlags[], ранее возвращённые функцией extractQuery. В
аргументе extra_data передаётся массив дополнительных данных, возвращённый функцией
extractQuery, или NULL, если дополнительных данных нет.
Когда extractQuery возвращает ключ NULL в queryKeys[], соответствующий элемент check[]
содержит true, если индексированный объект содержит ключ NULL; то есть можно считать, что
элементы check[] отражают условие IS NOT DISTINCT FROM. Функция consistent может прове-
рить соответствующий элемент nullFlags[], если ей нужно различать соответствие с обычным
значением и соответствие с NULL.
В случае успеха в *recheck нужно записать true, если кортеж данных нужно перепроверить
с оператором запроса, либо false, если проверка по индексу была точной. То есть результат
false гарантирует, что кортеж данных не соответствует запросу; результат true со значением
*recheck, равным false, гарантирует, что кортеж данных соответствует запросу; а результат
true со значением *recheck, равным true, означает, что кортеж данных может соответствовать
запросу, поэтому его нужно выбрать и перепроверить, применив оператор запроса непосред-
ственно к исходному индексированному элементу.
GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query,
int32 nkeys, Pointer extra_data[], Datum queryKeys[], bool nullFlags[])
Функция triConsistent подобна consistent, но вместо булевских значений в векторе check
ей передаются три варианта сравнений для каждого ключа: GIN_TRUE, GIN_FALSE и GIN_MAYBE.
GIN_FALSE и GIN_TRUE имеют обычное булевское значение, тогда как GIN_MAYBE означает, что
присутствие ключа неизвестно. Когда присутствуют значения GIN_MAYBE, функция должна воз-
вращать GIN_TRUE, только если объект удовлетворяет запросу независимо от того, содержит
ли индекс соответствующие ключи запроса. Подобным образом, функция должна возвращать
GIN_FALSE, только если объект не удовлетворяет запросу независимо от того, содержит ли он
ключи GIN_MAYBE. Если результат зависит от элементов GIN_MAYBE, то есть соответствие нельзя
утверждать или отрицать в зависимости от известных ключей запроса, функция должна вер-
нуть GIN_MAYBE.
Когда в векторе check нет элементов GIN_MAYBE, возвращаемое значение GIN_MAYBE равнознач-
но установленному флагу recheck в булевской функции consistent.
2162Индексы GIN
Кроме того, GIN нужно каким-то образом сортировать значения ключа, хранящиеся в индексе.
Класс операторов может определить порядок сортировки, указав метод сравнения:
int compare(Datum a, Datum b)
Сравнивает два ключа (не индексированные объекты!) и возвращает целое меньше нуля, ноль
или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго.
Ключи NULL никогда не передаются этой функции.
Если же класс операторов не определяет метод compare, GIN попытается найти класс операторов
B-дерева по умолчанию для типа данных ключа индекса и воспользоваться его функцией срав-
нения. Если класс операторов GIN предназначен только для одного типа данных, рекомендует-
ся задавать функцию сравнения в этом классе операторов, так как поиск класса операторов B-
дерева занимает несколько циклов. Однако для полиморфных классов операторов GIN (например,
array_ops) задать одну функцию сравнения обычно не представляется возможным.
Дополнительно класс операторов для GIN может предоставить следующий метод:
int comparePartial(Datum partial_key, Datum key, StrategyNumber n, Pointer extra_data)
Сравнивает ключ запроса с частичным соответствием с ключом индекса. Возвращает целое
число, знак которого отражает результат сравнения: отрицательное число означает, что ключ
индекса не соответствует запросу, но нужно продолжать сканирование индекса; ноль означа-
ет, что ключ индекса соответствует запросу; положительное число означает, что сканирова-
ние индекса нужно прекратить, так как других соответствий не будет. Функции передаётся
номер стратегии n оператора, сформировавшего запрос частичного соответствия, на случай,
если нужно знать его смысл, чтобы определить, когда прекращать сканирование. Кроме того,
ей передаётся extra_data — соответствующий элемент массива дополнительных данных, сфор-
мированного функцией extractQuery, либо NULL, если дополнительных данных нет. Значения
NULL этой функции никогда не передаются.
Для поддержки проверок на «частичное соответствие» класс операторов должен предоставить ме-
тод comparePartial, а метод extractQuery должен устанавливать параметр pmatch, когда встреча-
ется запрос на частичное соответствие. За подробностями обратитесь к Подразделу 66.4.2.
Фактические типы данных различных значений Datum, упоминаемых выше, зависят от класса опе-
раторов. Значения объектов, передаваемые в extractValue, всегда имеют входной тип класса опе-
раторов, а все значения ключей должны быть типа, заданного параметром STORAGE для класса.
Типом аргумента query, передаваемого функциям extractQuery, consistent и triConsistent, бу-
дет тот тип, что указан в качестве типа правого операнда оператора-члена класса, определяемого
по номеру стратегии. Это не обязательно должен быть индексируемый тип, достаточно лишь, что-
бы из него можно было извлечь значения ключей, имеющие нужный тип. Однако рекомендуется,
чтобы в SQL-объявлениях этих трёх опорных функций для аргумента query назначался индекси-
руемый тип класса операторов, даже несмотря на то, что фактический тип может быть другим, в
зависимости от оператора.
66.4. Реализация
Внутри индекс GIN содержит B-дерево, построенное по ключам, где каждый ключ является эле-
ментом одного или нескольких индексированных объектов (например, членом массива) и где каж-
дый кортеж на страницах листьев содержит либо указатель на B-дерево указателей на данные
(«дерево идентификаторов»), либо простой список указателей на данные («список идентификато-
ров»), когда этот список достаточно мал, чтобы уместиться в одном кортеже индекса вместе со
значением ключа.
Начиная с PostgreSQL версии 9.1, в индекс могут быть включены значения ключей, равные NULL.
Кроме того, в индекс вставляются NULL для индексируемых объектов, равных NULL или не содер-
жащих ключей, согласно функции extractValue. Это позволяет находить при поиске пустые объ-
екты, когда они должны быть найдены.
Составные индексы GIN реализуются в виде одного B-дерева по составным значениям (номер
столбца, значение ключа). Значения ключей для различных столбцов могут быть разных типов.
2163Индексы GIN
66.4.1. Методика быстрого обновления GIN
Природа инвертированного индекса такова, что обновление GIN обычно медленная операция: при
добавлении или изменении одной строки данных может потребоваться выполнить множество до-
бавлений записей в индекс (для каждого ключа, извлечённого из индексируемого объекта). На-
чиная с PostgreSQL 8.4, GIN может отложить большой объём этой работы, вставляя новые корте-
жи во временный, несортированный список записей, ожидающих индексации. Когда таблица очи-
щается, автоматически анализируется, вызывается функция gin_clean_pending_list или размер
этого списка временного списка становится больше чем gin_pending_list_limit, записи переносятся
в основную структуру данных GIN теми же методами массового добавления данных, что и при на-
чальном создании индекса. Это значительно увеличивает скорость обновления индекса GIN, даже
с учётом дополнительных издержек при очистке. К тому же эту дополнительную работу можно
выполнить в фоновом процессе, а не в процессе, непосредственно выполняющем запросы.
Основной недостаток такого подхода состоит в том, что при поиске необходимо не только прове-
рить обычный индекс, но и просканировать список ожидающих записей, так что если этот список
большой, поиск значительно замедляется. Ещё один недостаток состоит в том, что хотя в основ-
ном изменения производятся быстро, изменение, при котором этот список оказывается «слишком
большим», влечёт необходимость немедленной очистки и поэтому выполняется гораздо дольше
остальных изменений. Минимизировать эти недостатки можно, правильно организовав автоочист-
ку.
Если выдержанность времени операций важнее скорости обновления, применение списка ожида-
ющих записей можно отключить, выключив параметр хранения fastupdate для индекса GIN. За
подробностями обратитесь к CREATE INDEX.
66.4.2. Алгоритм частичного соответствия
GIN может поддерживать проверки «частичного соответствия», когда запрос выявляет не точное
соответствие одному или нескольким ключам, а возможные соответствия, попадающие в доста-
точно узкий диапазон значений ключей (при порядке сортировки ключей, определённым опор-
ным методом compare). В этом случае метод extractQuery возвращает не значение ключа, которое
должно соответствовать точно, а значение, определяющее нижнюю границу искомого диапазона,
и устанавливает флаг pmatch. Затем диапазон ключей сканируется методом comparePartial. Ме-
тод comparePartial должен вернуть ноль при соответствии ключа индекса, отрицательное значе-
ние, если соответствия нет, но нужно продолжать проверку диапазона, и положительное значе-
ние, если ключ индекса оказался за искомым диапазоном.
66.5. Приёмы и советы по применению GIN
Создание или добавление
Добавление объектов в индекс GIN может выполняться медленно, так как для каждого объек-
та скорее всего потребуется добавлять множество ключей. Поэтому при массовом добавлении
данных в таблицу рекомендуется удалить индекс GIN и пересоздать его по окончании добав-
ления.
Начиная с PostgreSQL 8.4, этот совет менее актуален, так как выполнение индексации может
быть отложенным (подробнее об этом в Подразделе 66.4.1). Но при очень большом объёме из-
менений может быть лучше всё-таки удалить и пересоздать индекс.
maintenance_work_mem
Время построения индекса GIN очень сильно зависит от параметра maintenance_work_mem; не
стоит экономить на рабочей памяти при создании индекса.
gin_pending_list_limit
В процессе последовательных добавлений в существующий индекс GIN с включённым режи-
мом fastupdate, система будет очищать список ожидающих индексации записей, когда его
размер будет превышать gin_pending_list_limit. Во избежание значительных колебаний ко-
2164Индексы GIN
нечного времени ответа имеет смысл проводить очистку этого списка в фоновом режиме (то
есть, применяя автоочистку). Избежать операций очистки на переднем плане можно, увели-
чив gin_pending_list_limit или проводя автоочистку более активно. Однако, если вследствие
увеличения порога операции очистки запустится очистка на переднем плане, она будет выпол-
няться ещё дольше.
Значение gin_pending_list_limit можно переопределить для отдельных индексов GIN, изме-
нив их параметры хранения, что позволяет задавать для каждого индекса GIN свой порог очист-
ки. Например, можно увеличить порог только для часто обновляемых индексов GIN и оставить
его низким для остальных.
gin_fuzzy_search_limit
Основной целью разработки индексов GIN было обеспечить поддержку хорошо расширяемого
полнотекстового поиска в PostgreSQL, а при полнотекстовом поиске нередко возникают ситуа-
ции, когда возвращается очень большой набор результатов. Однако чаще всего так происходит,
когда запрос содержит очень часто встречающиеся слова, так что полученный результат всё
равно оказывается бесполезным. Так как чтение множества записей с диска и последующая
сортировка их может занять много времени, это неприемлемо в производственных условиях.
(Заметьте, что поиск по индексу при этом выполняется очень быстро.)
Для управляемого выполнения таких запросов в GIN введено настраиваемое мяг-
кое ограничение сверху для числа возвращаемых строк: конфигурационный параметр
gin_fuzzy_search_limit. По умолчанию он равен 0 (то есть ограничение отсутствует). Если он
имеет ненулевое значение, возвращаемый набор строк будет случайно выбранным подмноже-
ством всего набора результатов.
«Мягким» оно называется потому, что фактическое число возвращаемых строк может несколь-
ко отличаться от заданного значения, в зависимости от запроса и качества системного гене-
ратора случайных чисел.
Из практики, со значениями в несколько тысяч (например, 5000 — 20000) получаются прием-
лемые результаты.
66.6. Ограничения
GIN полагает, что индексируемые операторы являются строгими. Это означает, что функция
extractValue вовсе не будет вызываться для значений NULL (вместо этого будет автоматически
создаваться пустая запись в индексе), так же как и extractQuery не будет вызываться с искомым
значением NULL (при этом сразу предполагается, что запрос не удовлетворяется). Заметьте, од-
нако, что при этом поддерживаются ключи NULL, содержащиеся в составных объектах или иско-
мых значениях.
66.7. Примеры
В базовый дистрибутив PostgreSQL включены классы операторов GIN, перечисленные ранее в Таб-
лице 66.1. Также классы операторов GIN содержатся в следующих модулях contrib:
btree_gin
Функциональность B-дерева для различных типов данных
hstore
Модуль для хранения пар (ключ, значение)
intarray
Расширенная поддержка int[]
pg_trgm
Схожесть текста на основе статистики триграмм
2165</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page4/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page3/">3</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page4/">4</a></li>
      
    
      
        <li><strong class="current-page">5</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page6/">6</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page7/">7</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page36/">36</a></li>
    

    
    
      <li><a href="http://localhost:4000/page6/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>