<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Последние посты &#8211; Sirius Blog</title>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130427752-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130427752-1');
</script>

</head>
<meta name="description" content="Describtion ..">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Последние посты">
<meta name="twitter:description" content="Describtion ..">
<meta name="twitter:creator" content="@2hotab2">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Последние посты">
<meta property="og:description" content="Describtion ..">
<meta property="og:url" content="http://localhost:4000/page18/">
<meta property="og:site_name" content="Sirius Blog">





<link rel="canonical" href="http://localhost:4000/page18/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Sirius Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.jpg">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.jpg">
<!-- 114x72 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x72" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.jpg">
<!-- 144x72 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x72" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.jpg">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Sergey Khatsiola photo" class="author-photo">
					<h4>Sergey Khatsiola</h4>
					<p>Кратко обо мне ...</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:2hotab2@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				<li>
					<a href="https://twitter.com/2hotab2"><i class="fa fa-fw fa-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="https://facebook.com/sergej.ha1"><i class="fa fa-fw fa-facebook"></i> Facebook</a>
				</li>
				
				
				<li>
					<a href="https://github.com/Sergey-sirius"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/handbook/" >HandBook</a></li>
	  
	    
	    <li><a href="https://github.com/Sergey-sirius" target="_blank">Main Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Последние посты">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Sirius Blog</h1>
      <h2>Последние посты</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-041/" title="Глава 41. Система правил"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 41. Система правил"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-041/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~48 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-041/" rel="bookmark" title="Глава 41. Система правил" itemprop="url">Глава 41. Система правил</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 41. Система правил</p>

<p>В этой главе обсуждается система правил, реализованная в PostgreSQL. Промышленные системы
правил по сути довольно простые, но при их использовании приходится сталкиваться с множеством
неочевидных вещей.
В некоторых других базах данных определяются активные правила баз данных, которые обычно
реализуются в виде процедур и триггеров. Так же их можно реализовать и в PostgreSQL.
Система правил (точнее говоря, система правил перезаписи запросов) полностью отличается от
механизма хранимых процедур и триггеров. Она изменяет запросы по заданным правилам, а затем
передаёт модифицированный запрос планировщику для планирования и выполнения. Это очень
мощное средство, подходящее для решения множества задач, например, для определения пред-
ставлений и процедур на языке запросов или реализации версионности. Теоретические основы и
преимущества этой системы правил также описаны в ston90b и ong90 (на английском языке).
41.1. Дерево запроса
Чтобы понять, как работает система правил, нужно знать, когда она вызывается, что принимает
на вход и какой результат выдаёт.
Система правил внедрена между анализатором запросов и планировщиком. Она принимает разо-
бранный запрос, одно дерево запроса, и определённые пользователем правила перезаписи, тоже
представленные деревьями с некоторой дополнительной информацией, и создаёт некоторое коли-
чество деревьев запросов в результате. Таким образом, на входе и выходе этой системы оказыва-
ется то, что может сформировать анализатор запросов, и как следствие, всё, с чем работает эта
система, представимо в виде операторов SQL.
Так что же такое дерево запроса? Это внутреннее представление оператора SQL, в котором
все образующие его части хранятся отдельно. Эти деревья можно увидеть в журнале серве-
ра, если установить параметры конфигурации debug_print_parse, debug_print_rewritten или
debug_print_plan. Действия правил также хранятся в виде деревьев запросов, в системном ката-
логе pg_rewrite. Они не форматируются как при выводе в журнал, но содержат точно такую же
информацию.
Для прочтения неформатированного дерева требуется некоторый навык. Но так как представле-
ния дерева запросов в виде SQL достаточно, чтобы понять систему правил, в этой главе не будет
рассказываться, как их читать.
Читая SQL-представления деревьев запросов в этой главе, необходимо понимать, на какие части
разбивается оператор, когда он преобразуется в структуру дерева запроса. Дерево запроса состоит
из следующих частей:
тип команды
Это простое значение, говорящее, какая команда (SELECT, INSERT, UPDATE или DELETE) сгенери-
ровала дерево запросов.
список отношений
Список отношений представляет собой массив отношений, используемых в запросе. В запросе
SELECT он включает отношения, указанные после ключевого слова FROM.
Каждый элемент списка отношений представляет таблицу или представление и говорит, с ка-
ким именем они упоминаются в других частях запроса. В дереве запросов записываются номе-
ра элементов списка отношений, а не их имена, поэтому для него неактуальна проблема дуб-
лирования имён, как для оператора SQL. Такая проблема может возникнуть при объединении
списков отношений, образованных разными правилами. В этой главе данная ситуация рассмат-
риваться не будет.
1095Система правил
результирующее отношение
Индекс в списке отношений, указывающий на отношение, которое будет получать результаты
запроса.
В запросах SELECT результирующее отношение отсутствует. (Особый случай SELECT INTO прак-
тически равнозначен CREATE TABLE с последующим INSERT … SELECT и здесь отдельно не
рассматривается.)
Для команд INSERT, UPDATE и DELETE результирующим отношением будет таблица (или пред-
ставление!), в которой будут происходить изменения.
выходной список
Выходной список — это список выражений, определяющих результат запроса. В случае SELECT,
это выражения, которые образуют окончательный набор выходных данных. Они соответствуют
выражениям, записанным между ключевыми словами SELECT и FROM. (Указание * — это просто
краткое обозначение имён всех столбцов отношения. Анализатор разворачивает его в список
отдельных столбцов, так что система правил никогда не видит его.)
Командам DELETE не нужен обычный выходной список, так как они не выдают никакие результа-
ты. Вместо этого планировщик добавляет в пустой выходной список специальную запись CTID,
чтобы исполнитель мог найти удаляемую строку. (CTID добавляется, когда результирующее от-
ношение — обычная таблица. Если это представление, планировщиком добавляется перемен-
ная, содержащая всю строку, как рассказывается в Подразделе 41.2.4.)
Для команд INSERT выходной список описывает новые строки, которые должны попасть в ре-
зультирующее отношение. Он включает выражения в предложении VALUES или предложении
SELECT в INSERT … SELECT. На первом этапе процесс перезаписи добавляет элементы выход-
ного списка для столбцов, которым ничего не присвоила исходная команда, но имеющих зна-
чения по умолчанию. Все остальные столбцы (без заданного значения и значения по умолча-
нию) планировщик заполняет константой NULL.
Для команд UPDATE выходной список описывает новые строки, которые должны заменить ста-
рые. В системе правил он содержит только выражения из части SET столбец = выражение. Для
пропущенных столбцов планировщик вставляет выражения, копирующие значения из старой
строки в новую. Так же, как и с командой DELETE, при этом добавляется CTID или переменная
со всей строкой, чтобы исполнитель мог найти изменяемую старую строку.
Каждая запись в выходном списке содержит выражение, которое может быть константой, пе-
ременной, указывающей на столбец отношения в таблице отношений, параметром или деревом
выражений, образованным из констант, переменных, операторов, вызовов функций и т. д.
условие фильтра
Условие фильтра запроса — это выражение, во многом похожее на те, что содержатся в вы-
ходном списке. Результат этого выражения — логический, он говорит, должна ли выполнять-
ся операция (INSERT, UPDATE, DELETE или SELECT) для данной строки в результате. Оно соответ-
ствует предложению WHERE SQL-оператора.
дерево соединения
Дерево соединения запроса показывает структуру предложения FROM. Для простых запросов
вида SELECT … FROM a, b, c, дерево соединения — это просто список элементов FROM, так
как они могут соединяться в любом порядке. Но с выражениями JOIN, особенно с внешними
соединениями, приходится соединять отношения именно в заданном порядке. В этом случае
дерево соединения отражает структуру выражений JOIN. Ограничения, связанные с конкрет-
ными предложениями JOIN (из выражений ON или USING), тоже сохраняются в виде условных
выражений, добавленных к соответствующим узлам дерева соединения. Как оказалось, выра-
жение WHERE верхнего уровня тоже удобно хранить как условие, добавленное к элементу верх-
1096Система правил
него уровня дерева соединения. Поэтому в дереве соединения на самом деле представляются
оба предложения оператора SELECT — FROM и WHERE.
другие
Другие части дерева запроса, например, предложение ORDER BY, в данном контексте не пред-
ставляют интереса. Система правил выполняет в них некоторые подстановки, применяя пра-
вила, но это не имеет непосредственного отношения к основам системы правил.
41.2. Система правил и представления
Представления в PostgreSQL реализованы на основе системы правил. Фактически по сути нет ни-
какого отличия
CREATE VIEW myview AS SELECT * FROM mytab;
от следующих двух команд:
CREATE TABLE myview (same column list as mytab);
CREATE RULE “_RETURN” AS ON SELECT TO myview DO INSTEAD
SELECT * FROM mytab;
так как именно эти действия CREATE VIEW выполняет внутри. Это имеет некоторые побочные эф-
фекты. В частности, информация о представлениях в системных каталогах PostgreSQL ничем не
отличается от информации о таблицах. Поэтому при анализе запроса нет абсолютно никакой раз-
ницы между таблицами и представлениями. Они представляют собой одно и то же — отношения.
41.2.1. Как работают правила SELECT
Правила ON SELECT применяются ко всем запросам на последнем этапе, даже если это команда
INSERT, UPDATE или DELETE. Эти правила отличаются от правил других видов тем, что они моди-
фицируют непосредственно дерево запросов, а не создают новое. Поэтому мы начнём описание с
правил SELECT.
В настоящее время возможно только одно действие в правиле ON SELECT и это должно быть без-
условное действие SELECT, выполняемое в режиме INSTEAD. Это ограничение было введено, что-
бы сделать правила достаточно безопасными для применения обычными пользователями, так что
действие правил ON SELECT сводится к реализации представлений.
В примерах этой главы рассматриваются два представления с соединением, которые выполняют
некоторые вычисления, и которые, в свою очередь, используются другими представлениями. Пер-
вое из этих двух представлений затем модифицируется, к нему добавляются правила для операций
INSERT, UPDATE и DELETE, так что в итоге получается представление, которое работает как обычная
таблица с некоторыми необычными функциями. Это не самый простой пример для начала, поэто-
му понять некоторые вещи будет сложнее. Но лучше иметь один пример, поэтапно охватывающий
все обсуждаемые здесь темы, чем несколько различных, при восприятии которых в итоге может
возникнуть путаница.
Например, нам нужна простейшая функция min, которая возвратит минимальное из двух целых
чисел. Её можно создать так:
CREATE FUNCTION min(integer, integer) RETURNS integer AS <script type="math/tex">% <![CDATA[
SELECT CASE WHEN $1 < $2 THEN $1 ELSE $2 END %]]></script> LANGUAGE SQL STRICT;
Таблицы, которые понадобятся нам для описания системы правил, выглядят так:
CREATE TABLE shoe_data (
shoename
text,
sh_avail
integer,
slcolor
text,
slminlen
real,
–
–
–
–
первичный ключ
число имеющихся пар
предпочитаемый цвет шнурков
минимальная длина шнурков
1097Система правил
slmaxlen
slunit
real,
text
– максимальная длина шнурков
– единица длины
);
CREATE TABLE shoelace_data (
sl_name
text,
sl_avail
integer,
sl_color
text,
sl_len
real,
sl_unit
text
); –
–
–
–
–
CREATE TABLE unit (
un_name
text,
un_fact
real
); – первичный ключ
– коэффициент для перевода в см
первичный ключ
число имеющихся пар
цвет шнурков
длина шнурков
единица длины
Как можно догадаться, в них хранятся данные обувной фабрики.
Представления создаются так:
CREATE VIEW shoe AS
SELECT sh.shoename,
sh.sh_avail,
sh.slcolor,
sh.slminlen,
sh.slminlen * un.un_fact AS slminlen_cm,
sh.slmaxlen,
sh.slmaxlen * un.un_fact AS slmaxlen_cm,
sh.slunit
FROM shoe_data sh, unit un
WHERE sh.slunit = un.un_name;
CREATE VIEW shoelace AS
SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name;
CREATE VIEW shoe_ready AS
SELECT rsh.shoename,
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM shoe rsh, shoelace rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;
Команда CREATE VIEW для представления shoelace (самого простого из имеющихся) создаёт отно-
шение shoelace и запись в pg_rewrite о правиле перезаписи, которое должно применяться, когда
в запросе на выборку задействуется отношение shoelace. Для этого правила не задаются условия
применения (о них рассказывается ниже, в описании правил не для SELECT, так как правила SELECT
в настоящее бывают только безусловными) и оно действует в режиме INSTEAD. Заметьте, что усло-
вия применения отличаются от условий фильтра запроса, например, действие для нашего правила
1098Система правил
содержит условие фильтра. Действие правила выражается одним деревом запроса, которое явля-
ется копией оператора SELECT в команде, создающей представление.
Примечание
Два дополнительных элемента списка отношений NEW и OLD, которые можно увидеть в
соответствующей строке pg_rewrite, не представляют интереса для правил SELECT.
Сейчас мы наполним таблицы unit (единицы измерения), shoe_data (данные о туфлях) и
shoelace_data (данные о шнурках) и выполним простой запрос к представлению:
INSERT INTO unit VALUES (‘cm’, 1.0);
INSERT INTO unit VALUES (‘m’, 100.0);
INSERT INTO unit VALUES (‘inch’, 2.54);
INSERT
INSERT
INSERT
INSERT INTO
INTO
INTO
INTO shoe_data
shoe_data
shoe_data
shoe_data
VALUES
VALUES
VALUES
VALUES
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
shoelace_data
(‘sh1’,
(‘sh2’,
(‘sh3’,
(‘sh4’,
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
VALUES
2,
0,
4,
3,
‘black’,
‘black’,
‘brown’,
‘brown’,
(‘sl1’,
(‘sl2’,
(‘sl3’,
(‘sl4’,
(‘sl5’,
(‘sl6’,
(‘sl7’,
(‘sl8’,
5,
6,
0,
8,
4,
0,
7,
1,
70.0,
30.0,
50.0,
40.0,
‘black’,
‘black’,
‘black’,
‘black’,
‘brown’,
‘brown’,
‘brown’,
‘brown’,
90.0,
40.0,
65.0,
50.0,
‘cm’);
‘inch’);
‘cm’);
‘inch’);
80.0, ‘cm’);
100.0, ‘cm’);
35.0, ‘inch’);
40.0, ‘inch’);
1.0, ‘m’);
0.9, ‘m’);
60, ‘cm’);
40, ‘inch’);
SELECT * FROM shoelace;
sl_name
| sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———–+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
7 | brown
|
60 | cm
|
60
sl3
|
0 | black
|
35 | inch
|
88.9
sl4
|
8 | black
|
40 | inch
|
101.6
sl8
|
1 | brown
|
40 | inch
|
101.6
sl5
|
4 | brown
|
1 | m
|
100
sl6
|
0 | brown
|
0.9 | m
|
90
(8 rows)
Это самый простой запрос SELECT, который можно выполнить с нашими представлениями, и мы
воспользуемся этим, чтобы объяснить азы правил представлений. Запрос SELECT * FROM shoelace
интерпретируется анализатором запросов и преобразуется в дерево запроса:
SELECT shoelace.sl_name, shoelace.sl_avail,
shoelace.sl_color, shoelace.sl_len,
shoelace.sl_unit, shoelace.sl_len_cm
FROM shoelace shoelace;
Это дерево передаётся в систему правил, которая проходит по списку отношений и проверяет, есть
ли какие-либо правила для этих отношений. Обрабатывая элемент отношения shoelace (сейчас он
единственный), система правил находит правило _RETURN с деревом запроса:
SELECT s.sl_name, s.sl_avail,
s.sl_color, s.sl_len, s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
1099Система правил
FROM shoelace old, shoelace new,
shoelace_data s, unit u
WHERE s.sl_unit = u.un_name;
Чтобы развернуть представление, механизм перезаписи просто формирует новый элемент для
списка отношений — подзапрос, содержащий дерево действия правила, и подставляет этот эле-
мент вместо исходного, на который ссылалось представление. Получившееся перезаписанное де-
рево запроса будет почти таким как дерево запроса:
SELECT shoelace.sl_name, shoelace.sl_avail,
shoelace.sl_color, shoelace.sl_len,
shoelace.sl_unit, shoelace.sl_len_cm
FROM (SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name) shoelace;
Однако есть одно различие: в списке отношений подзапроса будут содержаться два дополнитель-
ных элемента: shoelace old и shoelace new. Эти элементы не принимают непосредственного уча-
стия в запросе, так как они не задействованы в дереве соединения подзапроса и в целевом списке.
Механизм перезаписи использует их для хранения информации о проверке прав доступа, которая
изначально хранилась в элементе, указывающем на представление. Таким образом, исполнитель
будет по-прежнему проверять, имеет ли пользователь необходимые права для доступа к представ-
лению, хотя в перезаписанном запросе это представление не фигурирует непосредственно.
Так было применено первое правило. Система правил продолжит проверку оставшихся элементов
списка отношений на верхнем уровне запроса (в данном случае таких элементов нет) и рекурсивно
проверит элементы списка отношений в добавленном подзапросе, не ссылаются ли они на пред-
ставления. (Но old и new разворачиваться не будут — иначе мы получили бы бесконечную рекур-
сию!) В этом примере для shoelace_data и unit нет правил перезаписи, так что перезапись завер-
шается и результат, полученный выше, передаётся планировщику.
Сейчас мы хотим написать запрос, который выбирает туфли из имеющихся в данный момент, для
которых есть подходящие шнурки (по цвету и длине) и число готовых пар больше или равно двум.
SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;
shoename | sh_avail | sl_name | sl_avail | total_avail
———-+———-+———+———-+————-
sh1
|
2 | sl1
|
5 |
2
sh3
|
4 | sl7
|
7 |
4
(2 rows)
На этот раз анализатор запроса выводит такое дерево:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM shoe_ready shoe_ready
WHERE shoe_ready.total_avail &gt;= 2;
Первое правило применяется к представлению shoe_ready и в результате получается дерево за-
проса:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM (SELECT rsh.shoename,
1100Система правил
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM shoe rsh, shoelace rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
WHERE shoe_ready.total_avail &gt;= 2;
Подобным образом, правила для shoe и shoelace подставляются в список отношений, что даёт
окончательное дерево запроса:
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
shoe_ready.sl_name, shoe_ready.sl_avail,
shoe_ready.total_avail
FROM (SELECT rsh.shoename,
rsh.sh_avail,
rsl.sl_name,
rsl.sl_avail,
min(rsh.sh_avail, rsl.sl_avail) AS total_avail
FROM (SELECT sh.shoename,
sh.sh_avail,
sh.slcolor,
sh.slminlen,
sh.slminlen * un.un_fact AS slminlen_cm,
sh.slmaxlen,
sh.slmaxlen * un.un_fact AS slmaxlen_cm,
sh.slunit
FROM shoe_data sh, unit un
WHERE sh.slunit = un.un_name) rsh,
(SELECT s.sl_name,
s.sl_avail,
s.sl_color,
s.sl_len,
s.sl_unit,
s.sl_len * u.un_fact AS sl_len_cm
FROM shoelace_data s, unit u
WHERE s.sl_unit = u.un_name) rsl
WHERE rsl.sl_color = rsh.slcolor
AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
WHERE shoe_ready.total_avail &gt; 2;
На практике планировщик будет сворачивать это дерево до двух уровней: команды нижнего уров-
ня SELECT будут «подняты» к среднему SELECT, так как обрабатывать их отдельно нет необходимо-
сти. Но средний оператор SELECT не будет совмещён с верхним, так как он содержит агрегатные
функции. Если поднять его выше, поведение самого верхнего SELECT изменится нежелательным
образом. В целом же, сворачивание дерева запросов — это оптимизация, которая не должна за-
трагивать работу механизма перезаписи.
41.2.2. Правила представлений не для SELECT
До этого в описании правил представлений не затрагивались два компонента дерева запросов —
тип команды и результирующее отношение. На самом деле, тип команды не важен для правил
представления, но результирующее отношение может повлиять на работу механизма перезаписи,
потому что если это представление, требуются дополнительные операции.
Есть только несколько отличий между деревом запроса для SELECT и деревом для другой команды.
Очевидно, у них различные типы команд, и для команды, отличной от SELECT, результирующее от-
1101Система правил
ношение указывает на элемент в списке отношений, куда должен попасть результат. Все осталь-
ные компоненты в точности те же. Поэтому, например, если взять таблицы t1 и t2 со столбцами
a и b, деревья запросов для этих операторов:
SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;
UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;
будут практически одинаковыми. В частности:
• Списки отношений содержат элементы для таблиц t1 и t2.
• Выходные списки содержат одну переменную, указывающую на столбец b элемента-отноше-
ния для таблицы t2.
• Выражения условий сравнивают столбцы a обоих элементов-отношений на равенство.
• Деревья соединений показывают простое соединение между t1 и t2.
Как следствие, для обоих деревьев строятся похожие планы выполнения, с соединением двух таб-
лиц. Для UPDATE планировщик добавляет в выходной список недостающие столбцы из t1 и оконча-
тельное дерево становится таким:
UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;
В результате исполнитель, обрабатывающий соединение, выдаёт тот же результат, что и запрос:
SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
Но с UPDATE есть маленькая проблема: часть плана исполнителя, в которой выполняется соедине-
ние, не представляет, для чего предназначены результаты соединения. Она просто выдаёт резуль-
тирующий набор строк. Фактически есть одна команда SELECT, а другая, UPDATE, обрабатывается
исполнителем выше, где он уже знает, что это команда UPDATE и что результат должен попасть в
таблицу t1. Но какие из строк таблицы должны заменяться новыми?
Для решения этой проблемы в выходной список операторов UPDATE (и DELETE) добавляется ещё
один элемент: идентификатор текущего кортежа (Current Tuple ID, CTID).Это системный столбец,
содержащий номер блока в файле и позицию строки в блоке. Зная таблицу, по CTID можно полу-
чить исходную строку в t1, подлежащую изменению. С добавленным в выходной список CTID за-
прос фактически выглядит так:
SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
Теперь мы перейдём ещё к одной особенности PostgreSQL. Старые строки таблицы не переписы-
ваются, поэтому ROLLBACK выполняется быстро. С командой UPDATE в таблицу вставляется новая
строка результата (без CTID) и в заголовке старой строки, на которую указывает CTID, в поля cmax
и xmax записываются текущий счётчик команд и идентификатор текущей транзакции. Таким об-
разом, старая строка оказывается скрытой и после фиксирования транзакции процесс очистки
может окончательно удалить неактуальную версию строки.
Зная всё это, мы можем применять правила представлений абсолютно таким же образом к любой
команде — никаких различий нет.
41.2.3. Преимущества представлений в PostgreSQL
Выше было показано, как система правил внедряет определения представлений в исходное дерево
запроса. Во втором примере простой запрос SELECT к одному представлению создал окончательное
дерево запроса, соединяющее 4 таблицы (таблица unit использовалась дважды с разными имена-
ми).
Преимущество реализации представлений через систему правил заключается в том, что плани-
ровщик получает в одном дереве запроса всю информацию о таблицах, которые нужно прочитать,
о том, как связаны эти таблицы, об условиях в представлениях, а также об условиях, заданных в
1102Система правил
исходном запросе. И всё это имеет место, когда сам исходный запрос представляет собой соеди-
нение представлений. Планировщик должен выбрать лучший способ выполнения запроса, и чем
больше информации он получит, тем лучше может быть его выбор. И то, как в PostgreSQL реали-
зована система правил, гарантирует, что ему поступает вся информация, собранная о запросе на
данный момент.
41.2.4. Изменение представления
Но что произойдёт, если записать имя представления в качестве целевого отношения команды
INSERT, UPDATE или DELETE? Если проделать подстановки, описанные выше, будет получено дерево
запроса, в котором результирующее отношение указывает на элемент-подзапрос, что не будет ра-
ботать. Однако PostgreSQL даёт ряд возможностей, чтобы сделать представления изменяемыми.
Если подзапрос выбирает данные из одного базового отношения и он достаточно прост, механизм
перезаписи может автоматически заменить его нижележащим базовым отношением, чтобы ко-
манды INSERT, UPDATE или DELETE обращались к базовому отношению. Представления, «достаточно
простые» для этого, называются автоматически изменяемыми. Подробнее виды представлений,
которые могут изменяться автоматически, описаны в CREATE VIEW.
Эту задачу также можно решить, создав триггер INSTEAD OF для представления. В этом случае пе-
резапись будет работать немного по-другому. Для INSERT механизм перезаписи не делает с пред-
ставлением ничего, оставляя его результирующим отношением запроса. Для UPDATE и DELETE ему
по-прежнему придётся разворачивать запрос представления, чтобы получить «старые» строки,
которые эта команда попытается изменить или удалить. Поэтому представление разворачивается
как обычно, но в запрос добавляется ещё один элемент списка отношений, указывающий на пред-
ставление в роли результирующего отношения.
При этом возникает проблема идентификации строк в представлении, подлежащих изменению.
Вспомните, что когда результирующее отношение является таблицей, в выходной список добавля-
ется специальное поле CTID, указывающее на физическое расположение изменяемых строк. Но
это не будет работать, когда результирующее отношение — представление, так как в представле-
ниях нет CTID, потому что их строки физически нигде не находятся. Вместо этого, для операций
UPDATE или DELETE в выходной список добавляется специальный элемент wholerow (вся строка),
который разворачивается в содержимое всех столбцов представления. Используя этот элемент,
исполнитель передаёт строку «old» в триггер INSTEAD OF. Какие именно строки должны изменять-
ся фактически, будет решать сам триггер, исходя из полученных значений старых и новых строк.
Кроме того, пользователь может определить правила INSTEAD, в которых задать действия замены
для команд INSERT, UPDATE и DELETE с представлением. Эти правила обычно преобразуют команду
в другую команду, изменяющую одну или несколько таблиц, а не представление. Эта тема осве-
щается в Разделе 41.4.
Заметьте, что такие правила вычисляются сначала, перезаписывая исходный запрос до того, как
он будет планироваться и выполняться. Поэтому, если для представления определены и триггеры
INSTEAD OF, и правила для INSERT, UPDATE или DELETE, сначала вычисляются правила, а в зависи-
мости от их действия, триггеры могут не вызываться вовсе.
Автоматическая перезапись запросов INSERT, UPDATE или DELETE с простыми представлениями все-
гда производится в последнюю очередь. Таким образом, если у представления есть правила или
триггеры, они переопределяют поведение автоматически изменяемых представлений.
Если для представления не определены правила INSTEAD или триггеры INSTEAD OF, и запрос не
удаётся автоматически переписать в виде обращения к нижележащему базовому отношению, воз-
никает ошибка, потому что исполнитель не сможет изменить такое представление.
41.3. Материализованные представления
Материализованные представления в PostgreSQL основаны на системе правил, как и представле-
ния, но их содержимое сохраняется как таблица. Основное отличие между:
1103Система правил
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;
и этой командой:
CREATE TABLE mymatview AS SELECT * FROM mytab;
состоит в том, что материализованное представление впоследствии нельзя будет изменить непо-
средственно, а запрос, создающий материализованное представление, сохраняется точно так же,
как запрос представления, и получить актуальные данные в материализованном представлении
можно так:
REFRESH MATERIALIZED VIEW mymatview;
Информация о материализованном представлении в системных каталогах PostgreSQL ничем не от-
личается от информации о таблице или представлении. Поэтому для анализатора запроса матери-
ализованное представление является просто отношением, как таблица или представление. Когда
запрос обращается к материализованному представлению, данные возвращаются непосредствен-
но из него, как из таблицы; правило применяется, только чтобы его наполнить.
Хотя обращение к данным в материализованном представлении часто выполняется гораздо быст-
рее, чем обращение к нижележащим таблицам напрямую или через представление, данные в нём
не всегда актуальные (но иногда это вполне приемлемо). Рассмотрим таблицу с данными продаж:
CREATE TABLE invoice (
invoice_no
integer
seller_no
integer,
invoice_date date,
invoice_amt
numeric(13,2)
);
PRIMARY KEY,
– идентификатор продавца
– дата продажи
– сумма продажи
Если пользователям нужно быстро обработать исторические данные, возможно их интересуют
только общие показатели, а полнота данных на текущий момент не важна:
CREATE MATERIALIZED VIEW sales_summary AS
SELECT
seller_no,
invoice_date,
sum(invoice_amt)::numeric(13,2) as sales_amt
FROM invoice
WHERE invoice_date &lt; CURRENT_DATE
GROUP BY
seller_no,
invoice_date
ORDER BY
seller_no,
invoice_date;
CREATE UNIQUE INDEX sales_summary_seller
ON sales_summary (seller_no, invoice_date);
Это материализованное представление может быть полезно для построения графика в информа-
ционной панели менеджеров по продажам. Для ежесуточного обновления статистики можно за-
планировать задание по расписанию, которое будет выполнять этот оператор:
REFRESH MATERIALIZED VIEW sales_summary;
Ещё одно применение материализованного представления — предоставить быстрый доступ к дан-
ным, получаемым с удалённой системы через обёртку сторонних данных. Ниже приведён простой
пример с обёрткой file_fdw, с замерами времени, но так как при этом использовался кеш локаль-
ной системы, выигрыш в производительности при обращении к удалённой системе обычно будет
гораздо больше, чем показано здесь. Заметьте, что мы также использовали возможность добавить
индекс в материализованное представление, тогда как file_fdw индексы не поддерживает; при
других видах доступа к сторонним данным такого преимущества может не быть.
1104Система правил
Подготовка:
CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
SERVER local_file
OPTIONS (filename ‘/usr/share/dict/words’);
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;
Теперь давайте проверим написание слова. Сначала непосредственно через обёртку file_fdw:
SELECT count(<em>) FROM words WHERE word = ‘caterpiler’;
count
——-
0
(1 row)
Выполнив EXPLAIN ANALYZE, мы получаем:
Aggregate (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181
rows=1 loops=1)
-&gt; Foreign Scan on words (cost=0.00..21761.41 rows=1032 width=0) (actual
time=188.177..188.177 rows=0 loops=1)
Filter: (word = ‘caterpiler’::text)
Rows Removed by Filter: 479829
Foreign File: /usr/share/dict/words
Foreign File Size: 4953699
Planning time: 0.118 ms
Execution time: 188.273 ms
Если же теперь обратиться к материализованному представлению, запрос выполнится гораздо
быстрее:
Aggregate (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
-&gt; Index Only Scan using wrd_word on wrd (cost=0.42..4.44 rows=1 width=0) (actual
time=0.039..0.039 rows=0 loops=1)
Index Cond: (word = ‘caterpiler’::text)
Heap Fetches: 0
Planning time: 0.164 ms
Execution time: 0.117 ms
В любом случае слово записано неправильно, поэтому давайте попробуем найти то, что имелось
в виду. Сначала опять через file_fdw:
SELECT word FROM words ORDER BY word &lt;-&gt; ‘caterpiler’ LIMIT 10;
word
—————
cater
caterpillar
Caterpillar
caterpillars
caterpillar’s
Caterpillar’s
caterer
caterer’s
caters
catered
1105Система правил
(10 rows)
Limit (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594
rows=10 loops=1)
-&gt; Sort (cost=11583.61..11804.76 rows=88459 width=32) (actual
time=1431.589..1431.591 rows=10 loops=1)
Sort Key: ((word &lt;-&gt; ‘caterpiler’::text))
Sort Method: top-N heapsort Memory: 25kB
-&gt; Foreign Scan on words (cost=0.00..9672.05 rows=88459 width=32) (actual
time=0.057..1286.455 rows=479829 loops=1)
Foreign File: /usr/share/dict/words
Foreign File Size: 4953699
Planning time: 0.128 ms
Execution time: 1431.679 ms
Затем через материализованное представление:
Limit (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10
loops=1)
-&gt; Index Scan using wrd_trgm on wrd (cost=0.29..37020.87 rows=479829 width=10)
(actual time=187.219..188.252 rows=10 loops=1)
Order By: (word &lt;-&gt; ‘caterpiler’::text)
Planning time: 0.196 ms
Execution time: 198.640 ms
Если периодическое обновление данных из другого источника в локальной базе данных вас устра-
ивает, этот подход может дать значительный выигрыш в скорости.
41.4. Правила для INSERT, UPDATE и DELETE
Правила, определяемые для команд INSERT, UPDATE и DELETE, значительно отличаются от правил
представлений, описанных в предыдущем разделе. Во-первых, команда CREATE RULE позволяет со-
здавать правила со следующими особенностями:
• Они могут не определять действия.
• Они могут определять несколько действий.
• Они могут действовать в режиме INSTEAD или ALSO (по умолчанию).
• Становятся полезными псевдоотношения NEW и OLD.
• Они могут иметь условия применения.
Во-вторых, они не модифицируют само исходное дерево запроса. Вместо этого они создают
несколько новых деревьев запросов и могут заменить исходное.
Внимание
Во многих случаях для задач, выполнимых с использованием правил для INSERT/UPDATE/
DELETE, лучше применять триггеры. Оформляются триггеры чуть сложнее, но понять
их смысл гораздо проще. К тому же с правилами могут быть получены неожиданные
результаты, когда исходный запрос содержит изменчивые функции: в процессе испол-
нения правил эти функции могут вызываться большее число раз, чем ожидается.
Кроме того, в некоторых случаях эти типы правил вообще нельзя применять; а имен-
но, с предложениями WITH в исходном запросе и с вложенными подзапросами SELECT
с множественным присваиванием в списке SET запросов UPDATE. Это объясняется тем,
что копирование этих конструкций в запрос правила привело бы к многократному вы-
числению вложенного запроса, что пошло бы в разрез с выраженными намерениями
автора запроса.
1106Система правил
41.4.1. Как работают правила для изменения
Запомните синтаксис:
CREATE [ OR REPLACE ] RULE имя AS ON событие
TO таблица [ WHERE условие ]
DO [ ALSO | INSTEAD ] { NOTHING | команда | ( команда ; команда … ) }
В дальнейшем, под правилами для изменения подразумеваются правила, определяемые для ко-
манд INSERT, UPDATE или DELETE.
Правила для изменения применяются системой правил, когда результирующее отношение и тип
команды в дереве запроса совпадает с объектом и событием, заданным в команде CREATE RULE. Для
такого правила система правил создаёт список деревьев запросов. Изначально этот список пуст.
С правилом может быть связано ноль (ключевое слово NOTHING), одно или несколько действий.
Простоты ради мы рассмотрим правило с одним действием. Правило может иметь, а может не
иметь условия применения, и действует в режиме INSTEAD или ALSO (по умолчанию).
Что такое условие применения правила? Это условие, которое говорит, когда нужно, а когда не
нужно применять действия правила. В этом условии можно обращаться к псевдоотношениям NEW
и/или OLD, которые представляют целевое отношение (но с особым значением).
Всего есть три варианта формирования деревьев запросов для правила с одним действием.
Без условия применения в режиме ALSO или INSTEAD
дерево запроса из действия правила с добавленным условием исходного дерева
С условием применения в режиме ALSO
дерево запроса из действия правила с условием применения правила и условием, добавленным
из исходного дерева
С условием применения в режиме INSTEAD
дерево запроса из действия правила с условием применения правила и условием из исходного
дерева; также добавляется исходное дерево запроса с условием, обратным условию примене-
ния правила
Наконец, для правил ALSO в список добавляется исходное дерево запроса без изменений. Так как
исходное дерево запроса также добавляют только правила INSTEAD с условиями применения, в
итоге для правила с одним действием мы можем получить только одно или два дерева запросов.
Для правил ON INSERT исходный запрос (если он не перекрывается режимом INSTEAD) выполняет-
ся перед действиями, добавленными правилами. Поэтому эти действия могут видеть вставленные
строки. Но для правил ON UPDATE и ON DELETE исходный запрос выполняется после действий, до-
бавленных правилами. При таком порядке эти действия будут видеть строки, подлежащие измене-
нию или удалению; иначе бы действия не работали, не найдя строк, соответствующих их условиям
применения (эти строки уже будут изменены или удалены).
Деревья запросов, полученные из действий правил, снова попадают в систему перезаписи, где мо-
гут примениться дополнительные правила, добавляющие или убирающие деревья запроса. Поэто-
му действия правила должны выполнять команды другого типа или работать с другим результиру-
ющим отношением, иначе возникнет бесконечная рекурсия. (Система выявляет подобное рекур-
сивное разворачивание правил и выдаёт ошибку.)
Деревья запросов, заданные для действий в системном каталоге pg_rewrite, представляют собой
только шаблоны. Так как они могут обращаться к элементам NEW и OLD в списке отношений, их
можно будет использовать только после некоторых подстановок. В случае ссылки на NEW соответ-
ствующий элемент ищется в целевом списке исходного запроса. Если он найден, ссылка заменя-
ется выражением этого элемента. В противном случае NEW означает то же самое, что и OLD (для
1107Система правил
команды UPDATE) или заменяется значением NULL (для команды INSERT). Любые ссылки на OLD
заменяются ссылкой на элемент результирующего отношения в списке отношений.
После того как система применит все правила для изменения, она применяет правила представ-
ления к полученному дереву (или деревьям) запроса. Представления не могут добавлять новые
действия для изменения, поэтому нет необходимости применять такие правила к результату пе-
резаписи представления.
41.4.1.1. Пошаговый разбор первого правила
Предположим, что нам нужно отслеживать изменения в столбце sl_avail таблицы shoelace_data.
Мы можем создать таблицу для ведения журнала и правило, которое будет добавлять в неё записи
по условию, когда для shoelace_data выполняется UPDATE.
CREATE TABLE shoelace_log (
sl_name
text,
sl_avail
integer,
log_who
text,
log_when
timestamp
);
–
–
–
–
шнурки, количество которых изменилось
новое количество
кто изменил
когда
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
DO INSERT INTO shoelace_log VALUES (
NEW.sl_name,
NEW.sl_avail,
current_user,
current_timestamp
);
Теперь, если кто-то выполнит:
UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = ‘sl7’;
мы увидим в таблице журнала:
SELECT * FROM shoelace_log;
sl_name | sl_avail | log_who | log_when
———+———-+———+———————————-
sl7
|
6 | Al
| Tue Oct 20 16:14:45 1998 MET DST
(1 row)
Именно это нам и нужно. При этом внутри происходит следующее. Анализатор запроса создаёт
дерево:
UPDATE shoelace_data SET sl_avail = 6
FROM shoelace_data shoelace_data
WHERE shoelace_data.sl_name = ‘sl7’;
В системном каталоге находится правило log_shoelace, настроенное на изменение (ON UPDATE) с
условием применения:
NEW.sl_avail &lt;&gt; OLD.sl_avail
и действием:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old;
(Это выглядит несколько странно, так как обычно нельзя написать INSERT … VALUES … FROM.
Предложение FROM здесь добавлено, просто чтобы показать, что в дереве запроса для ссылок new и
1108Система правил
old есть элементы в списке отношений. Они необходимы для того, чтобы к ним могли обращаться
переменные в дереве запроса команды INSERT.)
Так как это правило ALSO с условием применения, система правил должна выдать два дерева за-
просов: изменённое действие правила и исходное дерево запроса. На первом шаге список отноше-
ний исходного запроса вставляется в дерево действия правила и получается:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data;
На втором шаге в это дерево добавляется условие применения правила, так что результирующий
набор ограничивается строками, в которых меняется sl_avail:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE new.sl_avail &lt;&gt; old.sl_avail;
(Это выглядит ещё более странно, ведь в INSERT … VALUES не записывается и предложение WHERE,
но планировщик и исполнитель не испытывают затруднений с этим. Они всё равно должны под-
держивать эту функциональность для INSERT … SELECT.)
На третьем шаге добавляется условие исходного дерева, что ещё больше ограничивает результи-
рующий набор, оставляя в нём только строки, которые затронул бы исходный запрос:
INSERT INTO shoelace_log VALUES (
new.sl_name, new.sl_avail,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE new.sl_avail &lt;&gt; old.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
На четвёртом шаге ссылки на NEW заменяются элементами выходного списка из исходного дерева
запроса или переменными из результирующего отношения:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE 6 &lt;&gt; old.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
На последнем, пятом шаге ссылки на OLD заменяются ссылками на результирующее отношение:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data new, shoelace_data old,
shoelace_data shoelace_data
WHERE 6 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
Вот и всё. Так как правило действует в режиме ALSO, мы также выводим исходное дерево запроса.
Таким образом, система правил выдаёт список с двумя деревьями запросов, соответствующими
этим операторам:
1109Система правил
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, 6,
current_user, current_timestamp )
FROM shoelace_data
WHERE 6 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
UPDATE shoelace_data SET sl_avail = 6
WHERE sl_name = ‘sl7’;
Они выполняются в показанном порядке и именно это должно делать данное правило.
Благодаря заменам и добавленным условиям в журнал не добавится запись, например, при таком
исходном запросе:
UPDATE shoelace_data SET sl_color = ‘green’
WHERE sl_name = ‘sl7’;
В этом случае исходное дерево запроса не содержит элемент выходного списка для sl_avail, так
что NEW.sl_avail будет заменено переменной shoelace_data.sl_avail. Таким образом, дополни-
тельная команда, созданная правилом, будет такой:
INSERT INTO shoelace_log VALUES (
shoelace_data.sl_name, shoelace_data.sl_avail,
current_user, current_timestamp )
FROM shoelace_data
WHERE shoelace_data.sl_avail &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_name = ‘sl7’;
Это условие применения не будет выполняться никогда.
Это также будет работать, если исходный запрос изменяет несколько строк. Так, если кто-то вы-
полнит команду:
UPDATE shoelace_data SET sl_avail = 0
WHERE sl_color = ‘black’;
фактически будут изменены четыре строки (sl1, sl2, sl3 и sl4). Но для sl3 значение sl_avail = 0.
В этом случае условие исходного дерева другое, так что это правило выдаёт такое дополнительное
дерево запроса:
INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
current_user, current_timestamp
FROM shoelace_data
WHERE 0 &lt;&gt; shoelace_data.sl_avail
AND shoelace_data.sl_color = ‘black’;
. С таким деревом запроса в журнал определённо будут добавлены три записи. И это абсолютно
правильно.
Здесь мы видим, почему важно, чтобы исходное дерево запроса выполнялось в конце. Если бы
оператор UPDATE выполнился сначала, все строки уже получили бы нулевые значения, так что
записывающий в журнал INSERT не нашёл бы строк, в которых 0 &lt;&gt; shoelace_data.sl_avail.
41.4.2. Сочетание с представлениями
Есть один простой вариант защититься от ранее упомянутой возможности выполнять INSERT,
UPDATE или DELETE для представлений, когда это нежелательно — создать правила, просто отбра-
сывающие деревья этих запросов. В нашем случае они будут выглядеть так:
CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
1110Система правил
DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
DO INSTEAD NOTHING;
Если теперь кто-то попытается выполнить одну из этих операций с представлением shoe, система
правил применит эти правила. Так как это правила без действий в режиме INSTEAD, результирую-
щий список деревьев запроса будет пуст и весь запрос аннулируется, так что после работы систе-
мы правил будет нечего оптимизировать и выполнять.
Более сложный вариант — использовать систему правил для создания правил, преобразующих
дерево запроса в выполняющее нужную операцию с реальными таблицами. Чтобы реализовать это
с представлением shoelace, мы создадим следующие правила:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
DO INSTEAD
INSERT INTO shoelace_data VALUES (
NEW.sl_name,
NEW.sl_avail,
NEW.sl_color,
NEW.sl_len,
NEW.sl_unit
);
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
DO INSTEAD
UPDATE shoelace_data
SET sl_name = NEW.sl_name,
sl_avail = NEW.sl_avail,
sl_color = NEW.sl_color,
sl_len = NEW.sl_len,
sl_unit = NEW.sl_unit
WHERE sl_name = OLD.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace
DO INSTEAD
DELETE FROM shoelace_data
WHERE sl_name = OLD.sl_name;
Если вы хотите поддерживать также запросы к представлению с RETURNING, вам надо создать пра-
вила с предложениями RETURNING, которые будут вычислять строки представления. Это обычно
довольно тривиально для представлений с одной нижележащей таблицей, но несколько затрудни-
тельно для представлений с соединением, таких как shoelace. Например, для INSERT это будет
выглядеть так:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
DO INSTEAD
INSERT INTO shoelace_data VALUES (
NEW.sl_name,
NEW.sl_avail,
NEW.sl_color,
NEW.sl_len,
NEW.sl_unit
)
RETURNING
shoelace_data.</em>,
(SELECT shoelace_data.sl_len * u.un_fact
FROM unit u WHERE shoelace_data.sl_unit = u.un_name);
Заметьте, что это одно правило поддерживает запросы и INSERT, и INSERT RETURNING к этому пред-
ставлению — предложение RETURNING просто игнорируется при обычном INSERT.
1111Система правил
Теперь предположим, что на фабрику прибывает партия шнурков с объёмной сопроводительной
накладной. Но вы не хотите вручную вносить по одной записи в представление shoelace. Вместо
этого можно создать две маленькие таблицы: в первую вы будете вставлять записи из накладной,
а вторая пригодится для специального приёма. Для этого мы выполним следующие команды:
CREATE TABLE shoelace_arrive (
arr_name
text,
arr_quant
integer
);
CREATE TABLE shoelace_ok (
ok_name
text,
ok_quant
integer
);
CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
DO INSTEAD
UPDATE shoelace
SET sl_avail = sl_avail + NEW.ok_quant
WHERE sl_name = NEW.ok_name;
Теперь вы можете наполнить таблицу shoelace_arrive данными о поступивших шнурках из на-
кладной:
SELECT * FROM shoelace_arrive;
arr_name | arr_quant
———-+———–
sl3
|
10
sl6
|
20
sl8
|
20
(3 rows)
Взгляните на текущие данные:
SELECT * FROM shoelace;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———-+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
6 | brown
|
60 | cm
|
60
sl3
|
0 | black
|
35 | inch
|
88.9
sl4
|
8 | black
|
40 | inch
|
101.6
sl8
|
1 | brown
|
40 | inch
|
101.6
sl5
|
4 | brown
|
1 | m
|
100
sl6
|
0 | brown
|
0.9 | m
|
90
(8 rows)
Теперь переместите прибывшие шнурки во вторую таблицу:
INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
Проверьте, что получилось:
SELECT * FROM shoelace ORDER BY sl_name;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———-+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
sl7
|
6 | brown
|
60 | cm
|
60
sl4
|
8 | black
|
40 | inch
|
101.6
1112Система правил
sl3
sl8
sl5
sl6
(8 rows)
|
|
|
|
10
21
4
20
|
|
|
|
black
brown
brown
brown
|
|
|
|
35
40
1
0.9
|
|
|
|
inch
inch
m
m
|
|
|
|
88.9
101.6
100
90
SELECT * FROM shoelace_log;
sl_name | sl_avail | log_who| log_when
———+———-+——–+———————————-
sl7
|
6 | Al
| Tue Oct 20 19:14:45 1998 MET DST
sl3
|
10 | Al
| Tue Oct 20 19:25:16 1998 MET DST
sl6
|
20 | Al
| Tue Oct 20 19:25:16 1998 MET DST
sl8
|
21 | Al
| Tue Oct 20 19:25:16 1998 MET DST
(4 rows)
Чтобы получить эти результаты из одного INSERT … SELECT, была проделана большая работа.
Мы подробно опишем всё преобразование дерева запросов в продолжении этой главы. Начнём с
дерева, выданного анализатором запроса:
INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
Теперь применяется первое правило shoelace_ok_ins, создающее такое дерево:
UPDATE shoelace
SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace
WHERE shoelace.sl_name = shoelace_arrive.arr_name;
и отбрасывающее исходный INSERT в shoelace_ok. Этот переписанный запрос снова поступает в
систему правил и второе применяемое правило shoelace_upd выдаёт:
UPDATE shoelace_data
SET sl_name = shoelace.sl_name,
sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
sl_color = shoelace.sl_color,
sl_len = shoelace.sl_len,
sl_unit = shoelace.sl_unit
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
shoelace new, shoelace_data shoelace_data
WHERE shoelace.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = shoelace.sl_name;
Это тоже правило INSTEAD, так что предыдущее дерево запроса отбрасывается. Заметьте, что этот
запрос по-прежнему использует представление shoelace. Но система правил ещё не закончила
свою работу, она продолжает и применяет правило _RETURN, так что мы получаем:
UPDATE shoelace_data
SET sl_name = s.sl_name,
sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
sl_color = s.sl_color,
sl_len = s.sl_len,
sl_unit = s.sl_unit
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
1113Система правил
shoelace new, shoelace_data shoelace_data,
shoelace old, shoelace new,
shoelace_data s, unit u
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name;
Наконец, применяется правило log_shoelace и выдаётся дополнительное дерево запроса:
INSERT INTO shoelace_log
SELECT s.sl_name,
s.sl_avail + shoelace_arrive.arr_quant,
current_user,
current_timestamp
FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
shoelace_ok old, shoelace_ok new,
shoelace shoelace, shoelace old,
shoelace new, shoelace_data shoelace_data,
shoelace old, shoelace new,
shoelace_data s, unit u,
shoelace_data old, shoelace_data new
shoelace_log shoelace_log
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name
AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;
Теперь, обработав все правила, система правил выдаёт построенные деревья запросов.
В итоге мы получаем два дерева запросов, равнозначные следующим операторам SQL:
INSERT INTO shoelace_log
SELECT s.sl_name,
s.sl_avail + shoelace_arrive.arr_quant,
current_user,
current_timestamp
FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
shoelace_data s
WHERE s.sl_name = shoelace_arrive.arr_name
AND shoelace_data.sl_name = s.sl_name
AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;
UPDATE shoelace_data
SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
FROM shoelace_arrive shoelace_arrive,
shoelace_data shoelace_data,
shoelace_data s
WHERE s.sl_name = shoelace_arrive.sl_name
AND shoelace_data.sl_name = s.sl_name;
В результате вся операция, в ходе которой данные, поступающие из одного отношения, вставля-
ются в другое, вставка преобразуется в изменение третьего, что затем становится изменением
четвёртого, и запись об этом изменении добавляется в пятое, сводится к двум запросам.
Здесь можно заметить маленькую не очень красивую деталь. Как видно, в этих двух запросах таб-
лица shoelace_data фигурирует в списке отношений дважды, тогда как определённо достаточно и
одного вхождения. Планировщик не понимает этого и поэтому для дерева запроса INSERT, выдан-
ного системой правил, будет получен такой план:
Nested Loop
-&gt; Merge Join
-&gt; Seq Scan
-&gt; Sort
1114Система правил
-&gt; Seq Scan on s
Seq Scan
-&gt; Sort
-&gt; Seq Scan on shoelace_arrive
Seq Scan on shoelace_data
-&gt;
-&gt;
Тогда как без лишнего элемента в списке отношений мы получили бы:
Merge Join
-&gt; Seq Scan
-&gt; Sort
-&gt;
-&gt; Seq Scan
-&gt; Sort
-&gt;
Seq Scan on s
Seq Scan on shoelace_arrive
При этом в журнале оказались бы точно такие же записи. Таким образом, применение правил по-
влекло дополнительное сканирование таблицы shoelace_data, в котором не было никакой необхо-
димости. И такое же избыточное сканирование выполняется ещё раз в UPDATE. Отнеситесь к этому
с пониманием, ведь сделать всё это возможным в принципе было действительно сложно.
И наконец, ещё одна, завершающая демонстрация системы правил PostgreSQL и всей её мощи.
Предположим, что вы добавили в базу данных шнурки с экстраординарными цветами:
INSERT INTO shoelace VALUES (‘sl9’, 0, ‘pink’, 35.0, ‘inch’, 0.0);
INSERT INTO shoelace VALUES (‘sl10’, 1000, ‘magenta’, 40.0, ‘inch’, 0.0);
Давайте создадим представление, чтобы убедиться, что шнурки (записи в shoelace) не подходят
ни к каким туфлям. Оно будет определено так:
CREATE VIEW shoelace_mismatch AS
SELECT * FROM shoelace WHERE NOT EXISTS
(SELECT shoename FROM shoe WHERE slcolor = sl_color);
Через него мы получаем наши записи:
SELECT * FROM shoelace_mismatch;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———+———-+———-+——–+———+———–
sl9
|
0 | pink
|
35 | inch
|
88.9
sl10
|
1000 | magenta |
40 | inch
|
101.6
Теперь мы хотим, чтобы шнурки, которые ни к чему не подходят, удалялись из базы данных. Чтобы
немного усложнить задачу для PostgreSQL, мы не будем удалять их непосредственно из таблицы.
Вместо этого мы создадим ещё одно представление:
CREATE VIEW shoelace_can_delete AS
SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;
И удалим их так:
DELETE FROM shoelace WHERE EXISTS
(SELECT * FROM shoelace_can_delete
WHERE sl_name = shoelace.sl_name);
Вуаля:
SELECT * FROM shoelace;
sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
———+———-+———-+——–+———+———–
sl1
|
5 | black
|
80 | cm
|
80
sl2
|
6 | black
|
100 | cm
|
100
1115Система правил
sl7
sl4
sl3
sl8
sl10
sl5
sl6
(9 rows)
|
|
|
|
|
|
|
6
8
10
21
1000
4
20
|
|
|
|
|
|
|
brown
black
black
brown
magenta
brown
brown
|
|
|
|
|
|
|
60
40
35
40
40
1
0.9
|
|
|
|
|
|
|
cm
inch
inch
inch
inch
m
m
|
|
|
|
|
|
|
60
101.6
88.9
101.6
101.6
100
90
Так запрос DELETE для представления с ограничивающим условием-подзапросом, использующим в
совокупности 4 вложенных/соединённых представления, с одним из которых тоже связано условие
с подзапросом, задействующим представление, и где используются вычисляемые столбцы пред-
ставлений, переписывается и преобразуется в одно дерево запроса, которое удаляет требуемые
данные из реальной таблицы.
На практике ситуации, когда необходима такая сложная конструкция, встречаются довольно ред-
ко, но, тем не менее, приятно осознавать, что всё это возможно и работает.
41.5. Правила и права
В результате переписывания запросов системой правил PostgreSQL обращение может происходить
не к тем таблицам/представлениям, к которым обращался исходный запрос. С правилами для из-
менения возможна так же и запись в другие таблицы.
Правила перезаписи не имеют отдельного владельца — владельцем правил перезаписи, опреде-
лённых для отношения (таблицы или представления), автоматически считается владелец этого
отношения. Система правил PostgreSQL меняет поведение стандартного механизма управления
доступом. К отношениям, используемым вследствие применения правил, проверяется доступ вла-
дельца правила, но не пользователя, выполняющего запрос. Это значит, что пользователь должен
иметь права, необходимые только для обращения к таблицам/представлениям, которые он явно
упоминает в своих запросах.
Например, представим, что у пользователя есть список телефонных номеров, некоторые из ко-
торых личные, а некоторые должна знать его ассистентка. Он может построить следующую кон-
струкцию:
CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
SELECT person, CASE WHEN NOT private THEN phone END AS phone
FROM phone_data;
GRANT SELECT ON phone_number TO assistant;
Никто, кроме него (и суперпользователей базы данных) не сможет обратиться к таблице
phone_data. Но так как ассистентке было дано (GRANT) соответствующее право, она сможет
выполнить SELECT для представления phone_number. Система правил преобразует SELECT из
phone_number в SELECT из таблицы phone_data. Так как пользователь является владельцем
phone_number, он же считается владельцем правила, доступ на чтение phone_data проверяется для
него, и выполнение запроса разрешается. Проверка прав доступа к phone_number тоже выполня-
ется, но при этом проверяется пользователь, выполняющий запрос, так что обращаться к этому
представлению смогут только сам пользователь и его ассистентка.
Права проверяются правило за правилом. То есть, в данный момент только ассистентка может
видеть открытые телефонные номера. Но она может создать другое представление и дать доступ
к нему всем (роли public), после чего все смогут видеть данные phone_number через представле-
ние ассистентки. Что она не может сделать, так это создать представление, которое обращается
к phone_data напрямую. (Вообще она может это сделать, но такое представление не будет рабо-
тать, так как при любой попытке прочитать его доступ к таблице будет запрещён.) И как только
пользователь заметит, что ассистентка открыла доступ к своему представлению phone_number, он
может лишить её права чтения этого представления. В результате все сразу потеряют доступ и к
представлению ассистентки.
1116Система правил
Может показаться, что такая проверка «правило-за-правилом» представляет уязвимость, но это не
так. Если бы даже этот механизм не работал, ассистентка могла бы создать таблицу со столбцами
как в phone_number и регулярно копировать туда данные. Тогда это были бы её собственные данные
и она могла бы открывать доступ к ним кому угодно. Другими словами, команда GRANT означает «Я
доверяю тебе». Если кто-то, кому вы доверяете, проделывает такие операции, стоит задуматься и,
возможно, лишить его доступа к данным, применив REVOKE.
Хотя представления могут применяться для скрытия содержимого определённых столбцов, как
описано выше, с их помощью нельзя надёжно скрыть данные в невидимых строках, если только не
установлен флаг security_barrier. Например, следующее представление небезопасно:
CREATE VIEW phone_number AS
SELECT person, phone FROM phone_data WHERE phone NOT LIKE ‘412%’;
Может показаться, что всё в порядке, ведь система правил преобразует SELECT из phone_number в
SELECT из phone_data и добавит ограничивающее условие, чтобы выдавались только строки с полем
phone, начинающимся не с 412. Но если пользователь может создавать собственные функции, ему
будет не сложно заставить планировщик выполнять функцию пользователя перед выражением NOT
LIKE. Например:
CREATE FUNCTION tricky(text, text) RETURNS bool AS <script type="math/tex">BEGIN
RAISE NOTICE '% => %', $1, $2;
RETURN true;
END</script> LANGUAGE plpgsql COST 0.0000000000000000000001;
SELECT * FROM phone_number WHERE tricky(person, phone);
Так он сможет получить все имена и номера телефонов из таблицы phone_data через сообщения
NOTICE, так как планировщик решит, что лучше выполнить недорогую функцию tricky перед бо-
лее дорогой операцией NOT LIKE. И даже если пользователь не имеет права создавать новые функ-
ции, он может использовать для подобных атак встроенные функции. (Например, многие функции
приведения показывают входные значения в сообщениях об ошибках.)
Подобные соображения распространяются и на правила для изменения. Применительно к приме-
рам предыдущего раздела, владелец таблиц в базе данных может дать кому-нибудь другому для
представления shoelace права SELECT, INSERT, UPDATE и DELETE, а для shoelace_log только SELECT.
Действие правила, добавляющее записи в журнал, всё равно будет выполняться успешно, а этот
другой пользователь сможет видеть записи в журнале. Но он не сможет создавать поддельные
записи, равно как и модифицировать или удалять существующие. В этом случае нет никакой воз-
можности заставить планировщик изменить порядок операций, так как единственное правило, ко-
торое обращается к shoelace_log — это безусловный INSERT. В более сложных сценариях это мо-
жет быть не так.
Когда требуется, чтобы представление обеспечивало защиту на уровне строк, к нему нужно при-
менить атрибут security_barrier. Это предотвратит утечку содержимого строк из злонамеренно
выбранных функций и операторов до того, как строки будут отфильтрованы представлением. На-
пример, показанное выше представление будет безопасным, если создать его так:
CREATE VIEW phone_number WITH (security_barrier) AS
SELECT person, phone FROM phone_data WHERE phone NOT LIKE ‘412%’;
Представления, созданные с атрибутом security_barrier, могут работать гораздо медленнее, чем
обычные. И вообще говоря, это неизбежно: самый быстрый план должен быть отвергнут, если он
может скомпрометировать защиту. Поэтому данный атрибут по умолчанию не устанавливается.
Планировщик запросов имеет больше свободы, работая с функциями, лишёнными побочных эф-
фектов. Такие функции называются герметичными (LEAKPROOF) и включают только простые ча-
сто используемые операторы, например, операторы равенства. Планировщик запросов может без-
опасно вычислять такие функции в любой момент выполнения запроса, так как при вызове их для
1117Система правил
строк, невидимых пользователю, не просочится никакая информация об этих строках. Более того,
функции, которые не принимают аргументы или которым не передаются аргументы из представ-
ления с барьером безопасности, можно не помечать как LEAKPROOF, чтобы они вышли наружу, так
как они никогда не получат данные из представления. И напротив, функции, которые могут вы-
звать ошибку в зависимости от значений аргументов (например, в случае переполнения или деле-
ния на ноль), герметичными не являются, и могут выдать существенную информацию о невидимых
строках, если будут выполнены перед фильтрами строк.
Важно понимать, что даже представление, созданное с атрибутом security_barrier, остаётся без-
опасным только в том смысле, что содержимое невидимых строк не будет передаваться потенци-
ально небезопасным функциям. Но пользователь может собрать некоторые сведения о невидимых
данных и другими способами; например, он может проанализировать план запроса, полученный
с EXPLAIN, или замерить время выполнения запросов с этим представлением. Злоумышленник мо-
жет сделать определённые выводы об объёме невидимых данных или даже получить некоторую
информацию о распределении данных или наиболее частых значениях (так как всё это отражается
в статистике для оптимизатора и, как следствие, влияет на время выполнения плана или даже на
выбор плана). Если возможность атаки через скрытые каналы вызывает опасения, вероятно, будет
разумным не предоставлять никакой доступ к этим данным.
41.6. Правила и статус команд
Сервер PostgreSQL возвращает строку состояния команды, например, INSERT 149592 1, для каж-
дой получаемой команды. Это довольно прозрачно, когда не задействуются правила, но что про-
изойдёт, если правила перезапишут запрос?
Правила влияют на состояния команды следующим образом:
• Если с запросом не связано безусловное правило INSTEAD, то выполняется заданный исход-
ный запрос и его статус выдаётся как обычно. (Но если определены какие-то условные прави-
ла INSTEAD, к исходному запросу добавляется условие, обратное их условиям применения. Это
может повлиять на число обрабатываемых строк и выводимый статус команды.)
• Если с запросом связано безусловное правило INSTEAD, исходный запрос не выполняется во-
все. В этом случае сервер возвратит статус команды от последнего запроса, вставленного пра-
вилом INSTEAD (условным или безусловным), и тип команды исходного запроса (INSERT, UPDATE
или DELETE). Если правила не добавили подходящего запроса, в возвращённом статусе коман-
ды показывается исходный тип запроса и нули вместо количества строк и OID.
Программист может добиться, чтобы статус команды во втором случае устанавливало нужное пра-
вило INSTEAD, назначив ему имя, стоящее по алфавиту после других активных правил, чтобы это
правило применялось последним.
41.7. Сравнение правил и триггеров
Многие вещи, которые можно сделать с помощью триггеров, можно также реализовать, используя
систему правил PostgreSQL. Однако, используя правила, нельзя реализовать, например, некото-
рые типы ограничений, в частности, внешние ключи. Хотя можно определить правило с ограни-
чивающим условием, которое будет преобразовать команду в NOTHING, если значение ключа не
находится в другой таблице, но при этом неподходящие данные будут отбрасываться молча, а это
не самый лучший вариант. Также, если требуется проверить правильность значений и, обнаружив
неверное значение, выдать ошибку, это нужно делать в триггере.
В этой главе мы разберём использование правил для изменения представлений. Все правила, при-
ведённые в примерах этой главы, можно также заменить триггерами INSTEAD OF для представле-
ний. Написать такие триггеры часто бывает проще, чем разработать правила, особенно если для
изменений применяется сложная логика.
Для тех задач, которые можно решить обоими способами, лучший выбирается в зависимости от
характера использования базы данных. Следует учитывать, что триггер срабатывает для каждой
обрабатываемой строки, а правило изменяет существующий запрос или создаёт ещё один. Поэто-
1118Система правил
му, если один оператор обрабатывает сразу много строк, правило, добавляющее дополнительную
команду, скорее всего, будет работать быстрее, чем триггер, который вызывается для каждой оче-
редной строки и должен каждый раз определять, что с ней делать. Однако триггеры концептуаль-
но гораздо проще правил, и использовать их правильно новичкам гораздо проще.
Давайте рассмотрим пример, показывающий, как выбор в пользу правил вместо триггеров оказы-
вается выигрышным в определённой ситуации. Пусть у нас есть две таблицы:
CREATE TABLE computer (
hostname
text,
manufacturer
text
); – индексированное
– индексированное
CREATE TABLE software (
software
text,
hostname
text
); – индексированное
– индексированное
Обе таблицы содержат несколько тысяч строк, а индексы по полю hostname являются уникальны-
ми. Правило или триггер должны реализовать ограничение, которое удалит строки из таблицы
software, ссылающиеся на удаляемый компьютер. Триггер выполнял бы такую команду:
DELETE FROM software WHERE hostname = $1;
Так как триггер вызывается для каждой отдельной строки, удаляемой из таблицы computer, он
может подготовить и сохранить план этой команды, а затем передавать значение hostname подго-
товленному запросу в параметрах. Правило же можно записать так:
CREATE RULE computer_del AS ON DELETE TO computer
DO DELETE FROM software WHERE hostname = OLD.hostname;
Теперь давайте взглянем на разные варианты удаления. В этом случае:
DELETE FROM computer WHERE hostname = ‘mypc.local.net’;
таблица computer сканируется по индексу (быстро), и команда, выполняемая триггером, так же бу-
дет применять сканирование по индексу (тоже быстро). Дополнительной командой правила будет:
DELETE FROM software WHERE computer.hostname = ‘mypc.local.net’
AND software.hostname = computer.hostname;
Так как созданы все необходимые индексы, планировщик создаст план
Nestloop
-&gt; Index Scan using comp_hostidx on computer
-&gt; Index Scan using soft_hostidx on software
Таким образом, большого различия в скорости между реализациями с триггером и с правилом не
будет.
Теперь мы хотим избавиться от 2000 компьютеров, у которых hostname начинается с old. Это мож-
но сделать двумя командами. Первая:
DELETE FROM computer WHERE hostname &gt;= ‘old’
AND hostname &lt; ‘ole’
Правило преобразует её в:
DELETE FROM software WHERE computer.hostname &gt;= ‘old’ AND computer.hostname &lt; ‘ole’
AND software.hostname = computer.hostname;
с планом:
Hash Join
-&gt; Seq Scan on software
-&gt; Hash
1119Система правил
-&gt;
Index Scan using comp_hostidx on computer
С другой возможной командой:
DELETE FROM computer WHERE hostname ~ ‘^old’;
для запроса, преобразованного правилом, получается следующий план:
Nestloop
-&gt; Index Scan using comp_hostidx on computer
-&gt; Index Scan using soft_hostidx on software
Это показывает, что планировщик не понимает, что ограничение по hostname в computer можно
также использовать для сканирования по индексу в software, когда несколько условий объединя-
ются с помощью AND, что он успешно делает для варианта команды с регулярным выражением.
Триггер будет вызываться для каждой из 2000 удаляемых записей о старых компьютерах, и это
приведёт к одному сканированию индекса в таблице computer и 2000 сканированиям индекса в
таблице software. Реализация с правилом делает это двумя командами, применяющими индексы.
Будет ли правило быстрее при последовательном сканировании, зависит от общего размера таб-
лицы software. С другой стороны, выполнение 2000 команд из триггера через менеджер SPI всё
равно займёт время, даже если все блоки индекса вскоре окажутся в кеше.
В завершение взгляните на эту команду:
DELETE FROM computer WHERE manufacturer = ‘bim’;
Она также может привести к удалению множества строк из таблицы computer. Поэтому триггер
снова пропустит через исполнитель такое же множество команд. Правило же выдаст следующую
команду:
DELETE FROM software WHERE computer.manufacturer = ‘bim’
AND software.hostname = computer.hostname;
План для этой команды снова будет содержать вложенный цикл по двум сканированиям индекса,
но на этот раз с другим индексом таблицы computer:
Nestloop
-&gt; Index Scan using comp_manufidx on computer
-&gt; Index Scan using soft_hostidx on software
Во всех этих случаях дополнительные команды будут более-менее независимыми от числа затра-
гиваемых строк.
Таким образом, правила будут значительно медленнее триггеров, только если их действия приво-
дят к образованию больших и плохо связанных соединений, когда планировщик оказывается бес-
силен.
1120</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-040/" title="Глава 40. Триггеры событий"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 40. Триггеры событий"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-040/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~8 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-040/" rel="bookmark" title="Глава 40. Триггеры событий" itemprop="url">Глава 40. Триггеры событий</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 40. Триггеры событий</p>

<p>В дополнение к триггерам, рассмотренным в Главе 39, PostgreSQL также предоставляет триггеры
событий. В отличие от обычных триггеров, которые подключаются к конкретной таблице и рабо-
тают только с командами DML, триггеры событий определяются на уровне базы данных и работа-
ют с командами DDL.
Как и обычные триггеры, триггеры событий можно создавать на любом процедурном языке, под-
держивающим триггеры событий, а также на C, но не на чистом SQL.
40.1. Обзор механизма работы триггеров событий
Триггер события срабатывает всякий раз, когда в базе данных, в которой он определён, про-
исходит связанное с ним событие. В настоящий момент поддерживаются следующие события:
ddl_command_start, ddl_command_end, table_rewrite и sql_drop. Поддержка дополнительных со-
бытий может быть добавлена в будущих выпусках.
Событие ddl_command_start происходит непосредственно перед выполнением команд CREATE,
ALTER, DROP, SECURITY LABEL, COMMENT, GRANT и REVOKE. Проверка на существование объекта пе-
ред срабатыванием триггера не производится. В качестве исключения, однако, это событие не
происходит для команд DDL, обращающихся к общим объектам кластера базы данных — ба-
зам данных, табличным пространствам, ролям, а также к самим триггерам событий. Событие
ddl_command_start также происходит непосредственно перед выполнением команды SELECT INTO,
так как она равнозначна команде CREATE TABLE AS.
Событие ddl_command_end происходит непосредственно после выполнения команд из того же на-
бора. Чтобы получить дополнительную информацию об операциях DDL, повлёкших произошедшее
событие, вызовите функцию pg_event_trigger_ddl_commands(), возвращающую множество, из ко-
да обработчика события ddl_command_end (см. Раздел 9.28). Заметьте, что этот триггер срабатыва-
ет после того, как эти действия имели место (но до фиксации транзакции), так что в системных
каталогах можно увидеть уже изменённое состояние.
Событие sql_drop происходит непосредственно перед событием ddl_command_end для команд, ко-
торые удаляют объекты базы данных. Для получения списка удалённых объектов используйте
возвращающую набор строк функцию pg_event_trigger_dropped_objects() в триггере события
sql_drop (см. Раздел 9.28). Обратите внимание, что триггер выполняется после удаления объектов
из таблиц системного каталога, поэтому их невозможно больше увидеть.
Событие table_rewrite происходит только после того, как таблица будет перезаписана в резуль-
тате определённых действий команд ALTER TABLE и ALTER TYPE. Хотя перезапись таблицы мо-
жет быть вызвана и другими управляющими операторами, в частности CLUSTER и VACUUM, событие
table_rewrite для них не вызывается.
Триггеры событий (как и прочие функции) не могут выполняться в прерванной транзакции. Поэто-
му, если команда DDL завершается ошибкой, соответствующие триггеры ddl_command_end не сра-
ботают. И наоборот, если триггер ddl_command_end завершился с ошибкой, последующие триггеры
событий не сработают, также как и сама команда не будет выполняться. Похожим образом, если
триггер ddl_command_end завершится ошибкой, действие команды DDL будет отменено, также как
это происходит при возникновении ошибки внутри транзакции.
Полный список команд, которые поддерживаются триггерами событий, можно найти в Разде-
ле 40.2.
Для создания триггера события используется команда CREATE EVENT TRIGGER. Предварительно
нужно создать функцию, со специальным возвращаемым типом event_trigger. Данная функция
не обязана возвращать значение (и может не возвращать). Возвращаемый тип служит лишь ука-
занием на то, что функция будет вызываться из триггера события.
Если есть несколько триггеров на одно и то же событие, то они будут вызываться в алфавитном
порядке по имени триггера.
1087Триггеры событий
В определении триггера можно использовать условие WHEN, чтобы, например, триггер
ddl_command_start срабатывал только для отдельных команд, которые нужно перехватить. Триг-
геры событий часто используются для ограничения диапазона DDL-команд, доступных пользова-
телям.
40.2. Матрица срабатывания триггеров событий
В Таблице 40.1 перечислены команды, для которых поддерживаются триггеры событий.
Таблица 40.1. Поддержка триггеров событий командами DDL
Тег команды
ddl_command_
start
ddl_command_
end
sql_drop
table_
rewrite
Замечания
ALTER
AGGREGATE X X - -<br />
ALTER
COLLATION X X - -<br />
ALTER
CONVERSION X X - -<br />
ALTER DOMAIN X X - -<br />
ALTER
EXTENSION X X - -<br />
ALTER FOREIGN
DATA WRAPPER X X - -<br />
ALTER FOREIGN
TABLE X X X -<br />
ALTER
FUNCTION X X - -<br />
ALTER
LANGUAGE X X - -<br />
ALTER
OPERATOR X X - -<br />
ALTER
OPERATOR
CLASS X X - -<br />
ALTER
OPERATOR
FAMILY X X - -<br />
ALTER POLICY X X - -<br />
ALTER SCHEMA X X - -<br />
ALTER
SEQUENCE X X - -<br />
ALTER SERVER X X - -<br />
ALTER TABLE X X X X<br />
ALTER TEXT
SEARCH
CONFIGURATION X X - -<br />
ALTER TEXT
SEARCH
DICTIONARY X X - -<br />
1088Триггеры событий
Тег команды
ddl_command_
start
ddl_command_
end
sql_drop
table_
rewrite
Замечания
ALTER TEXT
SEARCH PARSER X X - -<br />
ALTER TEXT
SEARCH
TEMPLATE X X - -<br />
ALTER TRIGGER X X - -<br />
ALTER TYPE X X - X<br />
ALTER USER
MAPPING X X - -<br />
ALTER VIEW X X - -<br />
CREATE
AGGREGATE X X - -<br />
COMMENT X X - - Только для
локальных
объектов
CREATE CAST X X - -<br />
CREATE
COLLATION X X - -<br />
CREATE
CONVERSION X X - -<br />
CREATE DOMAIN X X - -<br />
CREATE
EXTENSION X X - -<br />
CREATE
FOREIGN DATA
WRAPPER X X - -<br />
CREATE
FOREIGN TABLE X X - -<br />
CREATE
FUNCTION X X - -<br />
CREATE INDEX X X - -<br />
CREATE
LANGUAGE X X - -<br />
CREATE
OPERATOR X X - -<br />
CREATE
OPERATOR
CLASS X X - -<br />
CREATE
OPERATOR
FAMILY X X - -<br />
CREATE POLICY X X - -<br />
CREATE RULE X X - -<br />
CREATE SCHEMA X X - -<br />
1089Триггеры событий
Тег команды
ddl_command_
start
ddl_command_
end
sql_drop
table_
rewrite
Замечания
CREATE
SEQUENCE X X - -<br />
CREATE SERVER X X - -<br />
CREATE
STATISTICS X X - -<br />
CREATE TABLE X X - -<br />
CREATE TABLE
AS X X - -<br />
CREATE
TEXT SEARCH
CONFIGURATION X X - -<br />
CREATE
TEXT SEARCH
DICTIONARY X X - -<br />
CREATE TEXT
SEARCH PARSER X X - -<br />
CREATE
TEXT SEARCH
TEMPLATE X X - -<br />
CREATE
TRIGGER X X - -<br />
CREATE TYPE X X - -<br />
CREATE USER
MAPPING X X - -<br />
CREATE VIEW X X - -<br />
DROP
AGGREGATE X X X -<br />
DROP CAST X X X -<br />
DROP
COLLATION X X X -<br />
DROP
CONVERSION X X X -<br />
DROP DOMAIN X X X -<br />
DROP
EXTENSION X X X -<br />
DROP FOREIGN
DATA WRAPPER X X X -<br />
DROP FOREIGN
TABLE X X X -<br />
DROP FUNCTION X X X -<br />
DROP INDEX X X X -<br />
DROP LANGUAGE X X X -<br />
DROP OPERATOR X X X -<br />
1090Триггеры событий
Тег команды
ddl_command_
start
ddl_command_
end
sql_drop
table_
rewrite
Замечания
DROP OPERATOR
CLASS X X X -<br />
DROP OPERATOR
FAMILY X X X -<br />
DROP OWNED X X X -<br />
DROP POLICY X X X -<br />
DROP RULE X X X -<br />
DROP SCHEMA X X X -<br />
DROP SEQUENCE X X X -<br />
DROP SERVER X X X -<br />
DROP
STATISTICS X X X -<br />
DROP TABLE X X X -<br />
DROP TEXT
SEARCH
CONFIGURATION X X X -<br />
DROP TEXT
SEARCH
DICTIONARY X X X -<br />
DROP TEXT
SEARCH PARSER X X X -<br />
DROP TEXT
SEARCH
TEMPLATE X X X -<br />
DROP TRIGGER X X X -<br />
DROP TYPE X X X -<br />
DROP USER
MAPPING X X X -<br />
DROP VIEW X X X -<br />
GRANT X X - - Только для
локальных
объектов
IMPORT
FOREIGN
SCHEMA X X - -<br />
REVOKE X X - - Только для
локальных
объектов
SECURITY
LABEL X X - - Только для
локальных
объектов
SELECT INTO X X - -<br />
40.3. Триггерные функции событий на языке C
1091Триггеры событий
Этот раздел описывает низкоуровневые детали интерфейса для триггерной функции. Эта инфор-
мация необходима только при разработке триггерных функций событий на языке C. При исполь-
зовании языка более высокого уровня, эти детали обрабатываются автоматически. В большинстве
случаев необходимо рассмотреть использование процедурного языка прежде чем начать разраба-
тывать триггеры событий на C. В документации по каждому процедурному языку объясняется как
создавать триггеры событий на этом языке.
Триггерные функции событий должны использовать «version 1» интерфейса диспетчера функций.
Когда функция вызывается диспетчером триггеров событий, ей не передаются обычные аргумен-
ты, но передаётся указатель «context», ссылающийся на структуру EventTriggerData. Функции на
C могут проверить вызваны ли они диспетчером триггеров событий или нет выполнив макрос:
CALLED_AS_EVENT_TRIGGER(fcinfo)
который разворачивается в:
EventTriggerData
Если возвращается истина, то fcinfo-&gt;context можно безопасно привести к типу
EventTriggerData * и использовать указатель на структуру EventTriggerData. Функция не должна
изменять структуру EventTriggerData или любые данные, которые на неё указывают.
struct EventTriggerData определена в commands/event_trigger.h:
typedef struct EventTriggerData
{
NodeTag
type;
const char <em>event;
/</em> имя события <em>/
Node
*parsetree; /</em> дерево разбора <em>/
const char *tag;
/</em> тег команды <em>/
} EventTriggerData;
со следующими членами структуры:
type
Всегда T_EventTriggerData.
event
Описывает
событие,
для
которого
вызывается
функция.
Возможные
значения:
“ddl_command_start”, “ddl_command_end”, “sql_drop”, “table_rewrite”. Суть этих событий
описывается в Разделе 40.1.
parsetree
Указатель на дерево разбора команды. Детали можно посмотреть в исходном коде PostgreSQL.
Структура дерева разбора может быть изменена без предупреждений.
tag
Тег команды, для которой сработал триггер события. Например “CREATE FUNCTION”.
Функция триггера события должна возвращать указатель NULL (но не SQL значение null, то есть
не нужно устанавливать isNull в истину).
40.4. Полный пример триггера события
Вот очень простой пример функции для триггера события, написанной на C. (Примеры триггеров
для процедурных языков могут быть найдены в документации на процедурные языки.)
Функция noddl выдаёт ошибку при каждом вызове. Триггер с этой функцией определяется для
события ddl_command_start. Это предотвращает работу любых DDL-команд (за исключением тех,
о которых говорилось в Разделе 40.1).
Теперь исходный код триггерной функции:
1092Триггеры событий
#include “postgres.h”
#include “commands/event_trigger.h”
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(noddl);
Datum
noddl(PG_FUNCTION_ARGS)
{
EventTriggerData *trigdata;
if (!CALLED_AS_EVENT_TRIGGER(fcinfo)) /</em> internal error */
elog(ERROR, “not fired by event trigger manager”);
trigdata = (EventTriggerData *) fcinfo-&gt;context;
ereport(ERROR,
(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
errmsg(“command "%s" denied”, trigdata-&gt;tag)));
PG_RETURN_NULL();
}
После компиляции исходного кода (см. Подраздел 38.10.5) объявляем функцию и триггеры:
CREATE FUNCTION noddl() RETURNS event_trigger
AS ‘noddl’ LANGUAGE C;
CREATE EVENT TRIGGER noddl ON ddl_command_start
EXECUTE FUNCTION noddl();
Теперь проверим работу триггера:
=# \dy
List of event triggers
Name |
Event
| Owner | Enabled | Function | Tags
——-+——————-+——-+———+———-+——
noddl | ddl_command_start | dim
| enabled | noddl
|
(1 row)
=# CREATE TABLE foo(id serial);
ОШИБКА: command “CREATE TABLE” denied
В этой ситуации, для запуска DDL-команд, нужно либо удалить триггер события, либо отключить
его. Может быть удобным отключить триггер на время выполнения транзакции:
BEGIN;
ALTER EVENT TRIGGER noddl DISABLE;
CREATE TABLE foo (id serial);
ALTER EVENT TRIGGER noddl ENABLE;
COMMIT;
(Вспомним, что триггеры событий не обрабатывают DDL-команды для самих триггеров событий.)
40.5. Пример событийного триггера, обрабатывающего
перезапись таблицы
Благодаря существованию события table_rewrite, можно реализовать политику перезаписи таб-
лиц, допускающую перезапись только в определённое время обслуживания.
1093Триггеры событий
Следующий пример демонстрирует реализацию такой политики.
CREATE OR REPLACE FUNCTION no_rewrite()
RETURNS event_trigger
LANGUAGE plpgsql AS
<script type="math/tex">---
--- Реализация локальной политики перезаписи таблиц:
---
перезапись public.foo не допускается,
---
другие таблицы могут перезаписываться между 1 часом ночи и 6 часами утра,
---
если только их размер не превышает 100 блоков
---
DECLARE
table_oid oid := pg_event_trigger_table_rewrite_oid();
current_hour integer := extract('hour' from current_time);
pages integer;
max_pages integer := 100;
BEGIN
IF pg_event_trigger_table_rewrite_oid() = 'public.foo'::regclass
THEN
RAISE EXCEPTION 'you''re not allowed to rewrite the table %',
table_oid::regclass;
END IF;
SELECT INTO pages relpages FROM pg_class WHERE oid = table_oid;
IF pages > max_pages
THEN
RAISE EXCEPTION 'rewrites only allowed for table with less than % pages',
max_pages;
END IF;
IF current_hour NOT BETWEEN 1 AND 6
THEN
RAISE EXCEPTION 'rewrites only allowed between 1am and 6am';
END IF;
END;</script>;
CREATE EVENT TRIGGER no_rewrite_allowed
ON table_rewrite
EXECUTE FUNCTION no_rewrite();
1094</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/PostgreSQL-V11_Doc-039/" title="Глава 39. Триггеры"><img src="http://localhost:4000/images/abstract-11.jpg" alt="Глава 39. Триггеры"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2018-12-01T00:00:00+02:00"><a href="http://localhost:4000/PostgreSQL-V11_Doc-039/">December 01, 2018</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sergey Khatsiola">Sergey Khatsiola</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~17 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/PostgreSQL-V11_Doc-039/" rel="bookmark" title="Глава 39. Триггеры" itemprop="url">Глава 39. Триггеры</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Глава 39. Триггеры</p>

<p>В этой главе содержится общая информация о разработке триггерных функций. Триггерные функ-
ции могут быть написаны на большинстве доступных процедурных языков, включая PL/pgSQL (Гла-
ва 43), PL/Tcl (Глава 44), PL/Perl (Глава 45) и PL/Python (Глава 46). После прочтения этого раздела,
следует обратиться к разделу, посвящённому любимому процедурному языку, чтобы узнать спе-
цифические для него детали разработки триггеров.
Триггерные функции можно писать и на C, хотя большинство людей находит, что проще использо-
вать один из процедурных языков. В настоящее время невозможно написать триггерную функцию
на чистом SQL.
39.1. Обзор механизма работы триггеров
Триггер является указанием, что база данных должна автоматически выполнить заданную функ-
цию, всякий раз когда выполнен определённый тип операции. Триггеры можно использовать с
таблицами (секционированными и обычными), с представлениями и с внешними таблицами.
Для обычных и сторонних таблиц можно определять триггеры, которые будут срабатывать до
или после любой из команд INSERT, UPDATE или DELETE; либо один раз для каждой модифицируе-
мой строки, либо один раз для оператора SQL. Триггеры на UPDATE можно установить так, чтобы
они срабатывали, только когда в предложении SET оператора UPDATE упоминаются определённые
столбцы. Также триггеры могут срабатывать для операторов TRUNCATE. Если происходит событие
триггера, для обработки этого события в установленный момент времени вызывается функция
триггера.
Для представлений триггеры могут быть определены для выполнения вместо операций INSERT,
UPDATE и DELETE. Такие триггеры INSTEAD OF вызываются единожды для каждой строки, которая
должна быть изменена в этом представлении. Именно функция триггера отвечает за то, чтобы
произвести необходимые изменения в нижележащих базовых таблицах представления и должным
образом возвращать изменённые строки, чтобы они появлялись в представлении. Триггеры для
представлений тоже могут быть определены так, что они будут выполняться единожды для всего
оператора SQL, до или после операций INSERT, UPDATE или DELETE. Однако такие триггеры сраба-
тывают, только если для представления определён триггер INSTEAD OF. В противном случае все
операторы, обращающиеся к представлению, должны быть переписаны в виде операторов, обра-
щающихся к нижележащим базовым таблицам, и тогда будут срабатывать триггеры, установлен-
ные для этих таблиц.
Триггерная функция должна быть создана до триггера. Она должна быть объявлена без аргументов
и возвращать тип trigger. (Триггерная функция получает данные на вход посредством специально
переданной структуры TriggerData, а не в форме обычных аргументов.)
После создания триггерной функции создаётся триггер с помощью CREATE TRIGGER. Одна и та
же триггерная функция может быть использована для нескольких триггеров.
PostgreSQL предлагает как построчные, так и операторные триггеры. В случае построчного триг-
гера триггерная функция вызывается один раз для каждой строки, затронутой оператором, за-
пустившим триггер. Операторный же триггер, напротив, вызывается только один раз при выпол-
нении соответствующего оператора, независимо от количества строк, которые он затрагивает. В
частности оператор, который не затрагивает никаких строк, всё равно приведёт к срабатыванию
операторного триггера. Эти два типа триггеров также называют триггерами уровня строк и триг-
герами уровня оператора, соответственно. Триггеры на TRUNCATE могут быть определены только
на уровне оператора, а не на уровне строк.
Триггеры также классифицируются в соответствии с тем, срабатывают ли они до, после или вме-
сто операции. Они называются триггерами BEFORE, AFTER и INSTEAD OF, соответственно. Триггеры
BEFORE уровня оператора срабатывают до того, как оператор начинает делать что-либо, тогда как
триггеры AFTER уровня оператора срабатывают в самом конце работы оператора. Эти типы триг-
1077Триггеры
геров могут быть определены для таблиц, представлений или сторонних таблиц. Триггеры BEFORE
уровня строки срабатывают непосредственно перед обработкой конкретной строки, в то время как
триггеры AFTER уровня строки срабатывают в конце работы всего оператора (но до любого из триг-
геров AFTER уровня оператора). Эти типы триггеров могут определяться только для несекциониро-
ванных таблиц и сторонних таблиц, но не для представлений. Триггеры INSTEAD OF могут опреде-
ляться только для представлений и только на уровне строк: они срабатывают для каждой строки
сразу после того как строка представления идентифицирована как подлежащая обработке.
Оператор, нацеленный на родительскую таблицу в иерархии наследования или секционирования,
не вызывает срабатывания триггеров уровня оператора для задействованных дочерних таблиц;
срабатывать будут только такие триггеры для родительской таблицы. Однако если для этих дочер-
них таблиц установлены триггеры уровня строк, они будут срабатывать.
Если запрос INSERT содержит предложение ON CONFLICT DO UPDATE, возможно совместное приме-
нение и триггеров уровня строк BEFORE INSERT, и триггеров уровня строк BEFORE UPDATE, которое
отразится в окончательном состоянии изменяемой строки, если в запросе задействуются столбцы
EXCLUDED. При этом обращение к EXCLUDED не обязательно должно иметь место в обоих наборах
триггеров BEFORE на уровне строк. Следует рассмотреть возможность получения неожиданного
результата, когда имеются и триггеры BEFORE INSERT, и BEFORE UPDATE на уровне строки, и они вме-
сте модифицируют добавляемую/изменяемую строку (проблемы возможны, даже если изменения
более или менее равнозначные, но при этом не идемпотентные). Заметьте, что триггеры UPDATE
уровня оператора вызываются при ON CONFLICT DO UPDATE независимо от того, будут ли изменены
какие-либо строки в результате UPDATE (и даже в случае, когда альтернативный путь UPDATE вооб-
ще не выбирается). При выполнении запроса INSERT с предложением ON CONFLICT DO UPDATE сна-
чала выполняются триггеры BEFORE INSERT, затем триггеры BEFORE UPDATE, потом триггеры AFTER
UPDATE и, наконец, AFTER INSERT (речь идёт о триггерах на уровне операторов).
Если оператор UPDATE в секционированной таблице должен переместить строку в другую секцию,
это перемещение реализуется в результате выполнения DELETE в исходной секции и последующе-
го INSERT в новой секции. При этом в исходной секции срабатывают все триггеры BEFORE UPDATE
и BEFORE DELETE уровня строк. Затем в целевой секции срабатывают все триггеры BEFORE INSERT
уровня строк. Следует иметь в виду, что в случаях, когда все эти триггеры модифицируют переме-
щаемую строку, полученный результат может быть неожиданным. Если рассматривать триггеры
AFTER ROW, то применяться будут триггеры AFTER DELETE и AFTER INSERT, но не триггеры AFTER
UPDATE, так как команда UPDATE заменяется на DELETE и INSERT. Если же рассматривать тригге-
ры уровня операторов, ни триггеры DELETE, ни триггеры INSERT не будут срабатывать, даже если
производится перемещение строк; сработают только триггеры UPDATE, установленные в целевой
таблице оператора UPDATE.
Триггерные функции, вызываемые триггерами операторов, должны всегда возвращать NULL. Триг-
герные функции, вызываемые триггерами строк, могут вернуть строку таблицы (значение типа
HeapTuple). У триггера уровня строки, срабатывающего до операции, есть следующий выбор:
• Можно вернуть NULL, чтобы пропустить операцию для текущей строки. Это указывает испол-
нителю запросов, что не нужно выполнять операцию со строкой вызвавшей триггер (вставку,
изменение или удаление конкретной строки в таблице).
• Возвращаемая строка для триггеров INSERT или UPDATE будет именно той, которая будет
вставлена или обновлена в таблице. Это позволяет триггерной функции изменять вставляе-
мую или обновляемую строку.
Если в триггере BEFORE уровня строки не планируется использовать любой из этих вариантов, то
нужно аккуратно вернуть в качестве результата ту же строку, которая была передана на вход (то
есть строку NEW для триггеров INSERT и UPDATE, или строку OLD для триггеров DELETE).
INSTEAD OF триггер уровня строки должен вернуть либо NULL, чтобы указать, что он не модифици-
рует базовые таблицы представления, либо он должен вернуть строку представления, полученную
на входе (строку NEW для операций INSERT и UPDATE или строку OLD для операций DELETE). Отлич-
ное от NULL возвращаемое значение сигнализирует, что триггер выполнил необходимые измене-
1078Триггеры
ния данных в представлении. Это приведёт к увеличению счётчика количества строк, затронутых
командой. Для операций INSERT и UPDATE триггер может изменить строку NEW перед тем как её
вернуть. Это изменит данные, возвращаемые INSERT RETURNING или UPDATE RETURNING, и полезно
для того, чтобы не показывать уже не актуальные первоначальные данные.
Возвращаемое значение игнорируется для триггеров уровня строки, вызываемых после операции,
поэтому они могут возвращать NULL.
Если есть несколько триггеров на одно и то же событие для одной и той же таблицы, то они будут
вызываться в алфавитном порядке по имени триггера. Для триггеров BEFORE и INSTEAD OF потен-
циально изменённая строка, возвращаемая одним триггером, становится входящей строкой для
следующего триггера. Если любой из триггеров BEFORE или INSTEAD OF возвращает NULL, операция
для этой строки прекращается и последующие триггеры (для этой строки) не срабатывают.
В определении триггера можно указать логическое условие WHEN, которое будет проверяться, что-
бы посмотреть, нужно ли запускать триггер. В триггерах уровня строки в условии WHEN можно про-
верять старые и/или новые значения столбцов строки. (В триггерах уровня оператора также мож-
но использовать условие WHEN, хотя в этом случае это не так полезно.) В триггерах BEFORE условие
WHEN вычисляется непосредственно перед тем, как триггерная функция будет выполнена, поэтому
использование WHEN существенно не отличается от выполнения той же проверки в самом начале
триггерной функции. Однако, в триггерах AFTER условие WHEN вычисляется сразу после обновления
строки и от этого зависит, будет ли поставлено в очередь событие запуска триггера в конце опера-
тора или нет. Поэтому, когда условие WHEN в триггере AFTER не возвращает истину, не требуется ни
постановка события в очередь, ни повторная выборка этой строки в конце оператора. Это может
существенно ускорить работу операторов, изменяющих большое количество строк, с триггером,
который должен сработать только для нескольких. В триггерах INSTEAD OF не поддерживается
использование условий WHEN.
Как правило, триггеры BEFORE уровня строки используются для проверки или модификации дан-
ных, которые будут вставлены или изменены. Например, триггер BEFORE можно использовать для
вставки текущего времени в столбец timestamp или проверки, что два элемента строки согласова-
ны между собой. Триггеры AFTER уровня строки наиболее разумно использовать для каскадного
обновления данных в других таблицах или проверки согласованности сделанных изменений с дан-
ными в других таблицах. Причина для такого разделения работы в том, что триггер AFTER видит
окончательное значение строки, в то время как для триггера BEFORE это не так, ведь могут быть
другие триггеры BEFORE, которые сработают позже. Если нет особых причин для выбора между
триггерами BEFORE или AFTER, то триггер BEFORE предпочтительнее, так как не требует сохранения
информации об операции до конца работы оператора.
Если триггерная функция выполняет команды SQL, эти команды могут заново запускать триггеры.
Это известно как каскадные триггеры. Прямых ограничений на количество каскадных уровней
не существует. Вполне возможно, что каскадные вызовы приведут к рекурсивному срабатыванию
одного и того же триггера. Например, в триггере INSERT может выполняться команда, которая
добавляет строку в эту же таблицу, тем самым опять вызывая триггер на INSERT. Обязанность
программиста не допускать бесконечную рекурсию в таких случаях.
При определении триггера можно указывать аргументы. Цель включения аргументов в определе-
ние триггера в том, чтобы позволить разным триггерам с аналогичными требованиями вызывать
одну и ту же функцию. В качестве примера можно создать обобщенную триггерную функцию, ко-
торая принимает два аргумента с именами столбцов и записывает текущего пользователя в пер-
вый аргумент и текущий штамп времени во второй. При правильном написании такая триггерная
функция будет независима от конкретной таблицы, для которой она будет запускаться. Таким об-
разом, одна и та же функция может использоваться при выполнении INSERT в любую таблицу с
соответствующими столбцами, чтобы, например, автоматически отслеживать создание записей в
транзакционной таблице. Для триггеров UPDATE аргументы также могут использоваться для отсле-
живания последних сделанных изменений.
У каждого языка программирования, поддерживающего триггеры, есть свой собственный метод
доступа из триггерной функции к входным данным триггера. Входные данные триггера включают
1079Триггеры
в себя тип события (например, INSERT или UPDATE), а также любые аргументы, перечисленные в
CREATE TRIGGER. Для триггеров уровня строки входные данные также включают строку NEW для
триггеров INSERT и UPDATE и/или строку OLD для триггеров UPDATE и DELETE.
Триггеры уровня оператора по умолчанию не имеют возможностей для проверки отдельных строк,
модифицированных оператором. Но триггер AFTER STATEMENT может запросить создание для него
переходных таблиц, чтобы ему были доступны наборы затрагиваемых операцией строк. Тригге-
рам AFTER ROW также могут предоставляться переходные таблицы, чтобы они могли видеть все
изменения в таблице, а не только изменения в отдельных строках, для которых они срабатывают.
Метод обращения к переходным таблицам определяется применяемым языком программирова-
ния, но обычно переходные таблицы представляются как временные таблицы только для чтения,
к которым в триггерной функции можно обращаться, выполняя SQL-команды.
39.2. Видимость изменений в данных
Если в триггерной функции выполняются SQL-команды и эти команды обращаются к таблице, на
которую создан триггер, то необходимо знать правила видимости данных, потому что они опреде-
ляют, будут ли видеть эти SQL-команды изменения в данных, для которых сработал триггер. Крат-
ко:
• Триггеры уровня оператора следуют простым правилам видимости: никакие из изменений,
произведённых оператором, не видны в триггерах BEFORE, тогда как в триггерах AFTER видны
все изменения.
• Изменение данных (вставка, обновление или удаление), заставляющее сработать триггер, не
видно для команд SQL, выполняемых в триггере BEFORE уровня строки, потому что это измене-
ние ещё не произошло.
• Тем не менее, команды SQL, выполняемые в триггере BEFORE уровня строки, будут видеть из-
менения данных в строках, которые уже были обработаны в этом операторе. Это требует осто-
рожности, так как порядок обработки строк в целом непредсказуемый; команда SQL, обраба-
тывающая множество строк, может делать это в любом порядке.
• Аналогично, триггер INSTEAD OF уровня строки увидит изменения данных, внесённые при
предыдущих вызовах триггера INSTEAD OF для этой же внешней команды.
• Когда срабатывает триггер AFTER уровня строки, все изменения сделанные оператором уже
выполнены и видны в вызываемой триггерной функции.
Если триггерная функция написана на одном из стандартных процедурных языков, вышеприве-
дённые утверждения применимы, только если функция объявлена как VOLATILE. Функции объяв-
ленные как STABLE или IMMUTABLE в любом случае не будут видеть изменений, сделанных вызыва-
ющим оператором.
Дополнительную информацию о правилах видимости данных можно найти в Разделе 47.5. Пример
в Разделе 39.4 содержит демонстрацию этих правил.
39.3. Триггерные функции на языке C
Этот раздел описывает низкоуровневые детали интерфейса для триггерной функции. Эта инфор-
мация необходима только при разработке триггерных функций на C. При использовании языка
более высокого уровня эти детали обрабатываются автоматически. В большинстве случаев необ-
ходимо рассмотреть использование процедурного языка, прежде чем начать разрабатывать триг-
геры на C. В документации по каждому процедурному языку объясняется как создавать триггеры
на этом языке.
Триггерные функции должны использовать интерфейс функций «версии 1».
Когда функция вызывается диспетчером триггеров, ей не передаются обычные аргументы, но пе-
редаётся указатель «context», ссылающийся на структуру TriggerData. Функции на C могут про-
верить, вызваны ли они диспетчером триггеров или нет, выполнив макрос:
1080Триггеры
CALLED_AS_TRIGGER(fcinfo)
который разворачивается в:
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
Если возвращается истина, то fcinfo-&gt;context можно безопасно привести к типу TriggerData</p>
<ul>
  <li>и использовать указатель на структуру TriggerData. Функция не должна изменять структуру
TriggerData или любые данные, которые на неё указывают.
struct TriggerData определяется в commands/trigger.h:
typedef struct TriggerData
{
NodeTag
type;
TriggerEvent
tg_event;
Relation
tg_relation;
HeapTuple
tg_trigtuple;
HeapTuple
tg_newtuple;
Trigger
<em>tg_trigger;
Buffer
tg_trigtuplebuf;
Buffer
tg_newtuplebuf;
Tuplestorestate *tg_oldtable;
Tuplestorestate *tg_newtable;
} TriggerData;
где элементы определяются следующим образом:
type
Всегда T_TriggerData.
tg_event
Описывает событие, для которого вызывается функция. Можно использовать следующие мак-
росы для получения информации о tg_event:
TRIGGER_FIRED_BEFORE(tg_event)
Возвращает истину, если триггер сработал до операции.
TRIGGER_FIRED_AFTER(tg_event)
Возвращает истину, если триггер сработал после операции.
TRIGGER_FIRED_INSTEAD(tg_event)
Возвращает истину, если триггер сработал вместо операции.
TRIGGER_FIRED_FOR_ROW(tg_event)
Возвращает истину, если триггер сработал на уровне строки.
TRIGGER_FIRED_FOR_STATEMENT(tg_event)
Возвращает истину, если триггер сработал на уровне оператора.
TRIGGER_FIRED_BY_INSERT(tg_event)
Возвращает истину, если триггер сработал для операции INSERT.
TRIGGER_FIRED_BY_UPDATE(tg_event)
Возвращает истину, если триггер сработал для операции UPDATE.
TRIGGER_FIRED_BY_DELETE(tg_event)
Возвращает истину, если триггер сработал для операции DELETE.
1081Триггеры
TRIGGER_FIRED_BY_TRUNCATE(tg_event)
Возвращает истину, если триггер сработал для операции TRUNCATE.
tg_relation
Указатель на структуру, описывающую таблицу, для которой сработал триггер. Подробнее об
этой структуре в utils/rel.h. Самое интересное здесь это tg_relation-&gt;rd_att (дескриптор
записей таблицы) и tg_relation-&gt;rd_rel-&gt;relname (имя таблицы; имеет тип NameData, а не
char</em>; используйте SPI_getrelname(tg_relation), чтобы получить тип char* если потребуется
копия имени).
tg_trigtuple
Указатель на строку, для которой сработал триггер. Это строка, которая вставляется, обновля-
ется или удаляется. При срабатывании триггера для INSERT или DELETE это значение нужно
вернуть из функции, только если не планируется изменять строку (в случае INSERT) или про-
пускать операцию для этой строки.
tg_newtuple
Для триггера на UPDATE это указатель на новую версию строки либо NULL, если триггер на INSERT
или DELETE. Это значение нужно вернуть из функции в случае UPDATE, если не планируется
изменять строку или пропускать операцию для этой строки.
tg_trigger
Указатель на структуру с типом Trigger, определённую в utils/reltrigger.h:
typedef struct Trigger
{
Oid
tgoid;
char
<em>tgname;
Oid
tgfoid;
int16
tgtype;
char
tgenabled;
bool
tgisinternal;
Oid
tgconstrrelid;
Oid
tgconstrindid;
Oid
tgconstraint;
bool
tgdeferrable;
bool
tginitdeferred;
int16
tgnargs;
int16
tgnattr;
int16
*tgattr;
char
**tgargs;
char
*tgqual;
char
*tgoldtable;
char
*tgnewtable;
} Trigger;
где tgname — имя триггера, tgnargs — количество аргументов в tgargs, и tgargs — массив
указателей на аргументы, указанные в команде CREATE TRIGGER. Остальные члены структуры
предназначены для внутреннего использования.
tg_trigtuplebuf
Буфер, содержащий tg_trigtuple, или содержащий InvalidBuffer — если нет такой строки
или она не хранится в дисковом буфере.
tg_newtuplebuf
Буфер, содержащий tg_newtuple, или содержащий InvalidBuffer — если нет такой строки или
она не хранится в дисковом буфере.
1082Триггеры
tg_oldtable
Указатель на структуру типа Tuplestorestate, содержащую ноль или несколько строк в фор-
мате, определяемом содержимым tg_relation, или указатель NULL, если переходное отноше-
ние OLD TABLE отсутствует.
tg_newtable
Указатель на структуру типа Tuplestorestate, содержащую ноль или несколько строк в фор-
мате, определяемом содержимым tg_relation, или указатель NULL, если переходное отноше-
ние NEW TABLE отсутствует.
Чтобы обращаться к переходным таблицам в запросах, выполняемых через SPI, используйте
SPI_register_trigger_data.
Триггерная функция должна возвращать указатель HeapTuple или указатель NULL (но не SQL значе-
ние null, то есть не нужно устанавливать isNull в истину). Не забудьте, что если не планируете ме-
нять обрабатываемую триггером строку, то нужно вернуть либо tg_trigtuple, либо tg_newtuple.
39.4. Полный пример триггера
Вот очень простой пример триггерной функции, написанной на C. (Примеры триггеров для проце-
дурных языков могут быть найдены в документации на процедурные языки.)
Функция trigf сообщает количество строк в таблице ttest и пропускает операцию для строки при
попытке вставить пустое значение в столбец x. (Таким образом, триггер действует как ограничение
NOT NULL, но не прерывает транзакцию.)
Вначале определение таблицы:
CREATE TABLE ttest (
x integer
);
Теперь исходный код триггерной функции:
#include
#include
#include
#include
#include
“postgres.h”
“fmgr.h”
“executor/spi.h”
“commands/trigger.h”
“utils/rel.h”
/</em> this is what you need to work with SPI <em>/
/</em> … triggers … <em>/
/</em> … and relations <em>/
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(trigf);
Datum
trigf(PG_FUNCTION_ARGS)
{
TriggerData *trigdata = (TriggerData *) fcinfo-&gt;context;
TupleDesc
tupdesc;
HeapTuple
rettuple;
char
*when;
bool
checknull = false;
bool
isnull;
int
ret, i;
/</em> make sure it’s called as a trigger at all <em>/
if (!CALLED_AS_TRIGGER(fcinfo))
elog(ERROR, “trigf: not called by trigger manager”);
1083Триггеры
/</em> tuple to return to executor <em>/
if (TRIGGER_FIRED_BY_UPDATE(trigdata-&gt;tg_event))
rettuple = trigdata-&gt;tg_newtuple;
else
rettuple = trigdata-&gt;tg_trigtuple;
/</em> check for null values <em>/
if (!TRIGGER_FIRED_BY_DELETE(trigdata-&gt;tg_event)
&amp;&amp; TRIGGER_FIRED_BEFORE(trigdata-&gt;tg_event))
checknull = true;
if (TRIGGER_FIRED_BEFORE(trigdata-&gt;tg_event))
when = “before”;
else
when = “after “;
tupdesc = trigdata-&gt;tg_relation-&gt;rd_att;
/</em> connect to SPI manager <em>/
if ((ret = SPI_connect()) &lt; 0)
elog(ERROR, “trigf (fired %s): SPI_connect returned %d”, when, ret);
/</em> get number of rows in table <em>/
ret = SPI_exec(“SELECT count(</em>) FROM ttest”, 0);
if (ret &lt; 0)
elog(ERROR, “trigf (fired %s): SPI_exec returned %d”, when, ret);
/* count(*) returns int8, so be careful to convert */
i = DatumGetInt64(SPI_getbinval(SPI_tuptable-&gt;vals[0],
SPI_tuptable-&gt;tupdesc,
1,
&amp;isnull));
elog (INFO, “trigf (fired %s): there are %d rows in ttest”, when, i);
SPI_finish();
if (checknull)
{
SPI_getbinval(rettuple, tupdesc, 1, &amp;isnull);
if (isnull)
rettuple = NULL;
}
return PointerGetDatum(rettuple);
}
После компиляции исходного кода (см. Подраздел 38.10.5) объявляем функцию и триггеры:
CREATE FUNCTION trigf() RETURNS trigger
AS ‘имя_файла’
LANGUAGE C;
CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
FOR EACH ROW EXECUTE FUNCTION trigf();
CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
1084Триггеры
FOR EACH ROW EXECUTE FUNCTION trigf();
Теперь можно проверить работу триггера:
=&gt; INSERT INTO ttest VALUES (NULL);
INFO: trigf (fired before): there are 0 rows in ttest
INSERT 0 0
– Вставка записи пропущена (значение NULL), поэтому триггер AFTER не сработал
=&gt; SELECT * FROM ttest;
x
—
(0 rows)
=&gt; INSERT INTO ttest VALUES (1);
INFO: trigf (fired before): there are 0 rows in ttest
INFO: trigf (fired after ): there are 1 rows in ttest
^^^^^^^
вспомните, что говорилось о видимости
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
x
—
1
(1 row)
=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO: trigf (fired before): there are 1 rows in ttest
INFO: trigf (fired after ): there are 2 rows in ttest
^^^^^^^
вспомните, что говорилось о видимости
INSERT 167794 1
=&gt; SELECT * FROM ttest;
x
—
1
2
(2 rows)
=&gt; UPDATE ttest SET
INFO: trigf (fired
UPDATE 0
=&gt; UPDATE ttest SET
INFO: trigf (fired
INFO: trigf (fired
UPDATE 1
vac=&gt; SELECT * FROM
x
—
1
4
(2 rows)
x = NULL WHERE x = 2;
before): there are 2 rows in ttest
x = 4 WHERE x = 2;
before): there are 2 rows in ttest
after ): there are 2 rows in ttest
ttest;
=&gt; DELETE FROM ttest;
INFO: trigf (fired before): there are 2 rows in ttest
INFO: trigf (fired before): there are 1 rows in ttest
INFO: trigf (fired after ): there are 0 rows in ttest
1085Триггеры
INFO:
trigf (fired after ): there are 0 rows in ttest
^^^^^^^
вспомните, что говорилось о видимости
DELETE 2
=&gt; SELECT * FROM ttest;
x
—
(0 rows)
Более сложные примеры можно найти в src/test/regress/regress.c и в spi.
1086</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="http://localhost:4000/page17/" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="http://localhost:4000">1</a></li>
    

    
    
      
      
      <li>…</li>
    

    
    
    

    
      
        
        
        
        <li><a href="http://localhost:4000/page16/">16</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page17/">17</a></li>
      
    
      
        <li><strong class="current-page">18</strong></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page19/">19</a></li>
      
    
      
        
        
        
        <li><a href="http://localhost:4000/page20/">20</a></li>
      
    

    
    
      <li>…</li>
    

    
      <li><a href="http://localhost:4000/page40/">40</a></li>
    

    
    
      <li><a href="http://localhost:4000/page19/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 Sergey Khatsiola. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130427752-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>