<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-18T10:42:22+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sirius Blog</title><subtitle>Блог Сергея Хацёла</subtitle><entry><title type="html">Глава 1. Начало</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-001/" rel="alternate" type="text/html" title="Глава 1. Начало" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-001</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-001/">&lt;p&gt;Глава 1. Начало&lt;/p&gt;

&lt;p&gt;1.1. Установка&lt;/p&gt;

&lt;p&gt;Прежде чем вы сможете использовать PostgreSQL, вы конечно должны его установить. Однако
возможно, что PostgreSQL уже установлен у вас, либо потому что он включён в вашу операцион-
ную систему, либо его установил системный администратор. Если это так, обратитесь к докумен-
тации по операционной системе или к вашему администратору и узнайте, как получить доступ к
PostgreSQL.
Если же вы не знаете, установлен ли PostgreSQL или можно ли использовать его для эксперимен-
тов, тогда просто установите его сами. Сделать это несложно и это будет хорошим упражнением.
PostgreSQL может установить любой обычный пользователь; права суперпользователя (root) не
требуются.
Если вы устанавливаете PostgreSQL самостоятельно, обратитесь к Главе 16 за инструкциями по
установке, а закончив установку, вернитесь к этому введению. Обязательно прочитайте и выпол-
ните указания по установке соответствующих переменных окружения.
Если ваш администратор выполнил установку не с параметрами по умолчанию, вам может потре-
боваться проделать дополнительную работу. Например, если сервер баз данных установлен на уда-
лённом компьютере, вам нужно будет указать в переменной окружения PGHOST имя этого компью-
тера. Вероятно, также придётся установить переменную окружения PGPORT. То есть, если вы пыта-
етесь запустить клиентское приложение и оно сообщает, что не может подключиться к базе дан-
ных, вы должны обратиться к вашему администратору. Если это вы сами, вам следует обратиться к
документации и убедиться в правильности настройки окружения. Если вы не поняли, о чём здесь
идёт речь, перейдите к следующему разделу.
1.2. Основы архитектуры
Прежде чем продолжить, вы должны разобраться в основах архитектуры системы PostgreSQL. Со-
ставив картину взаимодействия частей PostgreSQL, вы сможете лучше понять материал этой гла-
вы.
Говоря техническим языком, PostgreSQL реализован в архитектуре клиент-сервер. Рабочий сеанс
PostgreSQL включает следующие взаимодействующие процессы (программы):
• Главный серверный процесс, управляющий файлами баз данных, принимающий подключения
клиентских приложений и выполняющий различные запросы клиентов к базам данных. Эта
программа сервера БД называется postgres.
• Клиентское приложение пользователя, желающее выполнять операции в базе данных. Кли-
ентские приложения могут быть очень разнообразными: это может быть текстовая утилита,
графическое приложение, веб-сервер, использующий базу данных для отображения веб-стра-
ниц, или специализированный инструмент для обслуживания БД. Некоторые клиентские при-
ложения поставляются в составе дистрибутива PostgreSQL, однако большинство создают сто-
ронние разработчики.
Как и в других типичных клиент-серверных приложениях, клиент и сервер могут располагаться
на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP. Важно не забывать
это и понимать, что файлы, доступные на клиентском компьютере, могут быть недоступны (или
доступны только под другим именем) на компьютере-сервере.
Сервер PostgreSQL может обслуживать одновременно несколько подключений клиентов. Для это-
го он запускает («порождает») отдельный процесс для каждого подключения. Можно сказать, что
клиент и серверный процесс общаются, не затрагивая главный процесс postgres. Таким образом,
главный серверный процесс всегда работает и ожидает подключения клиентов, принимая кото-
рые, он организует взаимодействие клиента и отдельного серверного процесса. (Конечно всё это
2Начало
происходит незаметно для пользователя, а эта схема рассматривается здесь только для понима-
ния.)
1.3. Создание базы данных
Первое, как можно проверить, есть ли у вас доступ к серверу баз данных, — это попытаться создать
базу данных. Работающий сервер PostgreSQL может управлять множеством баз данных, что поз-
воляет создавать отдельные базы данных для разных проектов и пользователей.
Возможно, ваш администратор уже создал базу данных для вас. В этом случае вы можете пропу-
стить этот этап и перейти к следующему разделу.
Для создания базы данных, в этом примере названной mydb, выполните следующую команду:
$ createdb mydb
Если вы не увидите никаких сообщений, значит операция была выполнена успешно и продолжение
этого раздела можно пропустить.
Если вы видите сообщение типа:
createdb: command not found
значит PostgreSQL не был установлен правильно. Либо он не установлен вообще, либо в путь по-
иска команд оболочки не включён его каталог. Попробуйте вызвать ту же команду, указав абсо-
лютный путь:
$ /usr/local/pgsql/bin/createdb mydb
У вас этот путь может быть другим. Свяжитесь с вашим администратором или проверьте, как были
выполнены инструкции по установке, чтобы исправить ситуацию.
Ещё один возможный ответ:
createdb: не удалось подключиться к базе postgres:
не удалось подключиться к серверу: No such file or directory
Он действительно работает локально и принимает
соединения через Unix-сокет “/tmp/.s.PGSQL.5432”?
Это означает, что сервер не работает или createdb не может к нему подключиться. И в этом случае
пересмотрите инструкции по установке или обратитесь к администратору.
Также вы можете получить сообщение:
createdb: не удалось подключиться к базе postgres:
ВАЖНО: роль “joe” не существует
где фигурирует ваше имя пользователя. Это говорит о том, что администратор не создал учётную
запись PostgreSQL для вас. (Учётные записи PostgreSQL отличаются от учётных записей пользо-
вателей операционной системы.) Если вы сами являетесь администратором, прочитайте Главу 21,
где написано, как создавать учётные записи. Для создания нового пользователя вы должны стать
пользователем операционной системы, под именем которого был установлен PostgreSQL (обычно
это postgres). Также возможно, что вам назначено имя пользователя PostgreSQL, не совпадающее
с вашим именем в ОС; в этом случае вам нужно явно указать ваше имя пользователя PostgreSQL,
используя ключ -U или установив переменную окружения PGUSER.
Если у вас есть учётная запись пользователя, но нет прав на создание базы данных, вы увидите
сообщение:
createdb: создать базу данных не удалось:
ОШИБКА: нет прав на создание базы данных
Создавать базы данных разрешено не всем пользователям. Если PostgreSQL отказывается созда-
вать базы данных для вас, значит вам необходимо соответствующее разрешение. В этом случае
3Начало
обратитесь к вашему администратору. Если вы устанавливали PostgreSQL сами, то для целей этого
1
введения вы должны войти в систему с именем пользователя, запускающего сервер БД.
Вы также можете создавать базы данных с другими именами. PostgreSQL позволяет создавать
сколько угодно баз данных. Имена баз данных должны начинаться с буквы и быть не длиннее 63
символов. В качестве имени базы данных удобно использовать ваше текущее имя пользователя.
Многие утилиты предполагают такое имя по умолчанию, так что вы сможете упростить ввод ко-
манд. Чтобы создать базу данных с таким именем, просто введите:
$ createdb
Если вы больше не хотите использовать вашу базу данных, вы можете удалить её. Например, ес-
ли вы владелец (создатель) базы данных mydb, вы можете уничтожить её, выполнив следующую
команду:
$ dropdb mydb
(Эта команда не считает именем БД по умолчанию имя текущего пользователя, вы должны явно
указать его.) В результате будут физически удалены все файлы, связанные с базой данных, и так
как отменить это действие нельзя, не выполняйте его, не подумав о последствиях.
Узнать о командах createdb и dropdb больше можно в справке createdb и dropdb.
1.4. Подключение к базе данных
Создав базу данных, вы можете обратиться к ней:
• Запустив терминальную программу PostgreSQL под названием psql, в которой можно интерак-
тивно вводить, редактировать и выполнять команды SQL.
• Используя существующие графические инструменты, например, pgAdmin или офисный пакет
с поддержкой ODBC или JDBC, позволяющий создавать и управлять базой данных. Эти воз-
можности здесь не рассматриваются.
• Написав собственное приложение, используя один из множества доступных языковых интер-
фейсов. Подробнее это рассматривается в Части IV.
Чтобы работать с примерами этого введения, начните с psql. Подключиться с его помощью к базе
данных mydb можно, введя команду:
$ psql mydb
Если имя базы данных не указать, она будет выбрана по имени пользователя. Об этом уже расска-
зывалось в предыдущем разделе, посвящённом команде createdb.
В psql вы увидите следующее сообщение:
psql (11.1)
Type “help” for help.
mydb=&amp;gt;
Последняя строка может выглядеть и так:
mydb=#
Что показывает, что вы являетесь суперпользователем, и так скорее всего будет, если вы уста-
навливали экземпляр PostgreSQL сами. В этом случае на вас не будут распространяться никакие
ограничения доступа, но для целей данного введения это не важно.
Если вы столкнулись с проблемами при запуске psql, вернитесь к предыдущему разделу. Команды
createdb и psql подключаются к серверу одинаково, так что если первая работает, должна рабо-
тать и вторая.
1
Объяснить это поведение можно так: Учётные записи пользователей PostgreSQL отличаются от учётных записей операционной системы. При подключении
к базе данных вы можете указать, с каким именем пользователя PostgreSQL нужно подключаться. По умолчанию же используется имя, с которым вы
зарегистрированы в операционной системе. При этом получается, что в PostgreSQL всегда есть учётная запись с именем, совпадающим с именем системного
пользователя, запускающего сервер, и к тому же этот пользователь всегда имеет права на создание баз данных. И чтобы подключиться с именем этого
пользователя PostgreSQL, необязательно входить с этим именем в систему, достаточно везде передавать его с параметром -U.
4Начало
Последняя строка в выводе psql — это приглашение, которое показывает, что psql ждёт ваших
команд и вы можете вводить SQL-запросы в рабочей среде psql. Попробуйте эти команды:
mydb=&amp;gt; SELECT version();
version
——————————————————————————————
PostgreSQL 11.1 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-
bit
(1 row)
mydb=&amp;gt; SELECT current_date;
date
————
2016-01-07
(1 row)
mydb=&amp;gt; SELECT 2 + 2;
?column?
———-
4
(1 row)
В программе psql есть множество внутренних команд, которые не являются SQL-операторами. Они
начинаются с обратной косой черты, «\». Например, вы можете получить справку по различным
SQL-командам PostgreSQL, введя:
mydb=&amp;gt; \h
Чтобы выйти из psql, введите:
mydb=&amp;gt; \q
и psql завершит свою работу, а вы вернётесь в командную оболочку операционной системы. (Что-
бы узнать о внутренних командах, введите \? в приглашении командной строки psql.) Все возмож-
ности psql документированы в справке psql. В этом руководстве мы не будем использовать эти
возможности явно, но вы можете изучить их и применять при удобном случае.&lt;/p&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 1. Начало</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 2. Язык SQL</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-002/" rel="alternate" type="text/html" title="Глава 2. Язык SQL" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-002</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-002/">&lt;p&gt;Глава 2. Язык SQL&lt;/p&gt;

&lt;p&gt;2.1. Введение&lt;/p&gt;

&lt;p&gt;В этой главе рассматривается использование SQL для выполнения простых операций. Она призва-
на только познакомить вас с SQL, но ни в коей мере не претендует на исчерпывающее руководство.
Про SQL написано множество книг, включая melt93 и date97. При этом следует учитывать, что
некоторые возможности языка PostgreSQL являются расширениями стандарта.
В следующих примерах мы предполагаем, что вы создали базу данных mydb, как описано в преды-
дущей главе, и смогли запустить psql.
Примеры этого руководства также можно найти в пакете исходного кода PostgreSQL в каталоге
src/tutorial/. (Двоичные дистрибутивы PostgreSQL могут не включать эти файлы.) Чтобы исполь-
зовать эти файлы, перейдите в этот каталог и запустите make:
$ cd …./src/tutorial
$ make
При этом будут созданы скрипты и скомпилированы модули C, содержащие пользовательские
функции и типы. Затем, чтобы начать работу с учебным материалом, выполните следующее:
$ cd …./tutorial
$ psql -s mydb
…
mydb=&amp;gt; \i basics.sql
Команда \i считывает и выполняет команды из заданного файла. Переданный psql параметр -
s переводит его в пошаговый режим, когда он делает паузу перед отправкой каждого оператора
серверу. Команды, используемые в этом разделе, содержатся в файле basics.sql.
2.2. Основные понятия
PostgreSQL — это реляционная система управления базами данных (РСУБД). Это означает, что
это система управления данными, представленными в виде отношений (relation). Отношение —
это математически точное обозначение таблицы. Хранение данных в таблицах так распростране-
но сегодня, что это кажется самым очевидным вариантом, хотя есть множество других способов
организации баз данных. Например, файлы и каталоги в Unix-подобных операционных системах
образуют иерархическую базу данных, а сегодня активно развиваются объектно-ориентированные
базы данных.
Любая таблица представляет собой именованный набор строк. Все строки таблицы имеют одина-
ковый набор именованных столбцов, при этом каждому столбцу назначается определённый тип
данных. Хотя порядок столбцов во всех строках фиксирован, важно помнить, что SQL не гаранти-
рует какой-либо порядок строк в таблице (хотя их можно явно отсортировать при выводе).
Таблицы объединяются в базы данных, а набор баз данных, управляемый одним экземпляром сер-
вера PostgreSQL, образует кластер баз данных.
2.3. Создание таблицы
Вы можете создать таблицу, указав её имя и перечислив все имена столбцов и их типы:
CREATE TABLE weather (
city
varchar(80),
temp_lo
int,
temp_hi
int,
– минимальная температура дня
– максимальная температура дня
6Язык SQL
prcp
date
real,
date
– уровень осадков
);
Весь этот текст можно ввести в psql вместе с символами перевода строк. psql понимает, что ко-
манда продолжается до точки с запятой.
В командах SQL можно свободно использовать пробельные символы (пробелы, табуляции и пере-
воды строк). Это значит, что вы можете ввести команду, выровняв её по-другому или даже уместив
в одной строке. Два минуса («–») обозначают начало комментария. Всё, что идёт за ними до конца
строки, игнорируется. SQL не чувствителен к регистру в ключевых словах и идентификаторах, за
исключением идентификаторов, взятых в кавычки (в данном случае это не так).
varchar(80) определяет тип данных, допускающий хранение произвольных символьных строк дли-
ной до 80 символов. int — обычный целочисленный тип. real — тип для хранения чисел с плаваю-
щей точкой одинарной точности. date — тип даты. (Да, столбец типа date также называется date.
Это может быть удобно или вводить в заблуждение — как посмотреть.)
PostgreSQL поддерживает стандартные типы SQL: int, smallint, real, double precision, char(N),
varchar(N), date, time, timestamp и interval, а также другие универсальные типы и богатый набор
геометрических типов. Кроме того, PostgreSQL можно расширять, создавая набор собственных ти-
пов данных. Как следствие, имена типов не являются ключевыми словами в данной записи, кроме
тех случаев, когда это требуется для реализации особых конструкций стандарта SQL.
Во втором примере мы сохраним в таблице города и их географическое положение:
CREATE TABLE cities (
name
varchar(80),
location
point
);
Здесь point — пример специфического типа данных PostgreSQL.
Наконец, следует сказать, что если вам больше не нужна какая-либо таблица, или вы хотите пере-
создать её по-другому, вы можете удалить её, используя следующую команду:
DROP TABLE имя_таблицы;
2.4. Добавление строк в таблицу
Для добавления строк в таблицу используется оператор INSERT:
INSERT INTO weather VALUES (‘San Francisco’, 46, 50, 0.25, ‘1994-11-27’);
Заметьте, что для всех типов данных применяются довольно очевидные форматы. Константы, за
исключением простых числовых значений, обычно заключаются в апострофы (‘), как в данном
примере. Тип date на самом деле очень гибок и принимает разные форматы, но в данном введении
мы будем придерживаться простого и однозначного.
Тип point требует ввода пары координат, например таким образом:
INSERT INTO cities VALUES (‘San Francisco’, ‘(-194.0, 53.0)’);
Показанный здесь синтаксис требует, чтобы вы запомнили порядок столбцов. Можно также при-
менить альтернативную запись, перечислив столбцы явно:
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
VALUES (‘San Francisco’, 43, 57, 0.0, ‘1994-11-29’);
Вы можете перечислить столбцы в другом порядке, если желаете опустить некоторые из них, на-
пример, если уровень осадков (столбец prcp) неизвестен:
INSERT INTO weather (date, city, temp_hi, temp_lo)
VALUES (‘1994-11-29’, ‘Hayward’, 54, 37);
7Язык SQL
Многие разработчики предпочитают явно перечислять столбцы, а не полагаться на их порядок в
таблице.
Пожалуйста, введите все показанные выше команды, чтобы у вас были данные, с которыми можно
будет работать дальше.
Вы также можете загрузить большой объём данных из обычных текстовых файлов, применив ко-
манду COPY. Обычно это будет быстрее, так как команда COPY оптимизирована для такого приме-
нения, хотя и менее гибка, чем INSERT. Например, её можно использовать так:
COPY weather FROM ‘/home/user/weather.txt’;
здесь подразумевается, что данный файл доступен на компьютере, где работает серверный про-
цесс, а не на клиенте, так как указанный файл будет прочитан непосредственно на сервере. По-
дробнее об этом вы можете узнать в описании команды COPY.
2.5. Выполнение запроса
Чтобы получить данные из таблицы, нужно выполнить запрос. Для этого предназначен SQL-опе-
ратор SELECT. Он состоит из нескольких частей: выборки (в которой перечисляются столбцы, ко-
торые должны быть получены), списка таблиц (в нём перечисляются таблицы, из которых будут
получены данные) и необязательного условия (определяющего ограничения). Например, чтобы
получить все строки таблицы weather, введите:
SELECT * FROM weather;
Здесь * — это краткое обозначение «всех столбцов».
1
Таким образом, это равносильно записи:
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
В результате должно получиться:
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
43 |
57 |
0 | 1994-11-29
Hayward
|
37 |
54 |
| 1994-11-29
(3 rows)
В списке выборки вы можете писать не только ссылки на столбцы, но и выражения. Например,
вы можете написать:
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
И получить в результате:
city
| temp_avg |
date
—————+———-+————
San Francisco |
48 | 1994-11-27
San Francisco |
50 | 1994-11-29
Hayward
|
45 | 1994-11-29
(3 rows)
Обратите внимание, как предложение AS позволяет переименовать выходной столбец. (Само слово
AS можно опускать.)
Запрос можно дополнить «условием», добавив предложение WHERE, ограничивающее множество
возвращаемых строк. В предложении WHERE указывается логическое выражение (проверка истин-
ности), которое служит фильтром строк: в результате оказываются только те строки, для которых
это выражение истинно. В этом выражении могут присутствовать обычные логические операто-
ры (AND, OR и NOT). Например, следующий запрос покажет, какая погода была в Сан-Франциско в
дождливые дни:
1
Хотя запросы SELECT * часто пишут экспромтом, это считается плохим стилем в производственном коде, так как результат таких запросов будет меняться
при добавлении новых столбцов.
8Язык SQL
SELECT * FROM weather
WHERE city = ‘San Francisco’ AND prcp &amp;gt; 0.0;
Результат:
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
(1 row)
Вы можете получить результаты запроса в определённом порядке:
SELECT * FROM weather
ORDER BY city;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
Hayward
|
37 |
54 |
| 1994-11-29
San Francisco |
43 |
57 |
0 | 1994-11-29
San Francisco |
46 |
50 | 0.25 | 1994-11-27
В этом примере порядок сортировки определён не полностью, поэтому вы можете получить стро-
ки Сан-Франциско в любом порядке. Но вы всегда получите результат, показанный выше, если
напишете:
SELECT * FROM weather
ORDER BY city, temp_lo;
Если требуется, вы можете убрать дублирующиеся строки из результата запроса:
SELECT DISTINCT city
FROM weather;
city
—————
Hayward
San Francisco
(2 rows)
И здесь порядок строк также может варьироваться. Чтобы получать неизменные результаты, со-
2
едините предложения DISTINCT и ORDER BY:
SELECT DISTINCT city
FROM weather
ORDER BY city;
2.6. Соединения таблиц
До этого все наши запросы обращались только к одной таблице. Однако запросы могут также об-
ращаться сразу к нескольким таблицам или обращаться к той же таблице так, что одновременно
будут обрабатываться разные наборы её строк. Запрос, обращающийся к разным наборам строк
одной или нескольких таблиц, называется соединением (JOIN). Например, мы захотели перечис-
лить все погодные события вместе с координатами соответствующих городов. Для этого мы долж-
ны сравнить столбец city каждой строки таблицы weather со столбцом name всех строк таблицы
cities и выбрать пары строк, для которых эти значения совпадают.
Примечание
Это не совсем точная модель. Обычно соединения выполняются эффективнее (сравни-
ваются не все возможные пары строк), но это скрыто от пользователя.
2
В некоторых СУБД, включая старые версии PostgreSQL, реализация предложения DISTINCT автоматически упорядочивает строки, так что ORDER BY добав-
лять не обязательно. Но стандарт SQL этого не требует и текущая версия PostgreSQL не гарантирует определённого порядка строк после DISTINCT.
9Язык SQL
Это можно сделать с помощью следующего запроса:
SELECT *
FROM weather, cities
WHERE city = name;
city
|temp_lo|temp_hi| prcp|
date
|
name
| location
————–+——-+——-+—–+———–+————–+———-
San Francisco|
46|
50| 0.25| 1994-11-27| San Francisco| (-194,53)
San Francisco|
43|
57|
0| 1994-11-29| San Francisco| (-194,53)
(2 rows)
Обратите внимание на две особенности полученных данных:
• В результате нет строки с городом Хейуорд (Hayward). Так получилось потому, что в таблице
cities нет строки для данного города, а при соединении все строки таблицы weather, для ко-
торых не нашлось соответствие, опускаются. Вскоре мы увидим, как это можно исправить.
• Название города оказалось в двух столбцах. Это правильно и объясняется тем, что столбцы
таблиц weather и cities были объединены. Хотя на практике это нежелательно, поэтому луч-
ше перечислить нужные столбцы явно, а не использовать *:
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
Упражнение:
Попробуйте определить, что будет делать этот запрос без предложения WHERE.
Так как все столбцы имеют разные имена, анализатор запроса автоматически понимает, к какой
таблице они относятся. Если бы имена столбцов в двух таблицах повторялись, вам пришлось бы
дополнить имена столбцов, конкретизируя, что именно вы имели в виду:
SELECT weather.city, weather.temp_lo, weather.temp_hi,
weather.prcp, weather.date, cities.location
FROM weather, cities
WHERE cities.name = weather.city;
Вообще хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтобы
запрос не поломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.
Запросы соединения, которые вы видели до этого, можно также записать в другом виде:
SELECT *
FROM weather INNER JOIN cities ON (weather.city = cities.name);
Эта запись не так распространена, как первый вариант, но мы показываем её, чтобы вам было
проще понять следующие темы.
Сейчас мы выясним, как вернуть записи о погоде в городе Хейуорд. Мы хотим, чтобы запрос про-
сканировал таблицу weather и для каждой её строки нашёл соответствующую строку в таблице
cities. Если же такая строка не будет найдена, мы хотим, чтобы вместо значений столбцов из таб-
лицы cities были подставлены «пустые значения». Запросы такого типа называются внешними
соединениями. (Соединения, которые мы видели до этого, называются внутренними.) Эта команда
будет выглядеть так:
SELECT *
FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);
city
|temp_lo|temp_hi| prcp|
date
|
name
| location
————–+——-+——-+—–+———–+————–+———-
Hayward
|
37|
54|
| 1994-11-29|
|
San Francisco|
46|
50| 0.25| 1994-11-27| San Francisco| (-194,53)
San Francisco|
43|
57|
0| 1994-11-29| San Francisco| (-194,53)
(3 rows)
10Язык SQL
Этот запрос называется левым внешним соединением, потому что из таблицы в левой части опе-
ратора будут выбраны все строки, а из таблицы справа только те, которые удалось сопоставить
каким-нибудь строкам из левой. При выводе строк левой таблицы, для которых не удалось найти
соответствия в правой, вместо столбцов правой таблицы подставляются пустые значения (NULL).
Упражнение:  Существуют также правые внешние соединения и полные внешние соединения.
Попробуйте выяснить, что они собой представляют.
В соединении мы также можем замкнуть таблицу на себя. Это называется замкнутым соединени-
ем. Например, представьте, что мы хотим найти все записи погоды, в которых температура лежит в
диапазоне температур других записей. Для этого мы должны сравнить столбцы temp_lo и temp_hi
каждой строки таблицы weather со столбцами temp_lo и temp_hi другого набора строк weather.
Это можно сделать с помощью следующего запроса:
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
W2.city, W2.temp_lo AS low, W2.temp_hi AS high
FROM weather W1, weather W2
WHERE W1.temp_lo &amp;lt; W2.temp_lo
AND W1.temp_hi &amp;gt; W2.temp_hi;
city
| low | high |
city
| low | high
—————+—–+——+—————+—–+——
San Francisco | 43 |
57 | San Francisco | 46 |
50
Hayward
| 37 |
54 | San Francisco | 46 |
50
(2 rows)
Здесь мы ввели новые обозначения таблицы weather: W1 и W2, чтобы можно было различить левую
и правую стороны соединения. Вы можете использовать подобные псевдонимы и в других запросах
для сокращения:
SELECT *
FROM weather w, cities c
WHERE w.city = c.name;
Вы будете встречать сокращения такого рода довольно часто.
2.7. Агрегатные функции
Как большинство других серверов реляционных баз данных, PostgreSQL поддерживает агрегатные
функции. Агрегатная функция вычисляет единственное значение, обрабатывая множество строк.
Например, есть агрегатные функции, вычисляющие: count (количество), sum (сумму), avg (сред-
нее), max (максимум) и min (минимум) для набора строк.
К примеру, мы можем найти самую высокую из всех минимальных дневных температур:
SELECT max(temp_lo) FROM weather;
max
—–
46
(1 row)
Если мы хотим узнать, в каком городе (или городах) наблюдалась эта температура, можно попро-
бовать:
SELECT city FROM weather WHERE temp_lo = max(temp_lo);
НЕВЕРНО
но это не будет работать, так как агрегатную функцию max нельзя использовать в предложении
WHERE. (Это ограничение объясняется тем, что предложение WHERE должно определить, для каких
строк вычислять агрегатную функцию, так что оно, очевидно, должно вычисляться до агрегатных
функций.) Однако, как часто бывает, запрос можно перезапустить и получить желаемый резуль-
тат, применив подзапрос:
SELECT city FROM weather
11Язык SQL
WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
city
—————
San Francisco
(1 row)
Теперь всё в порядке — подзапрос выполняется отдельно и результат агрегатной функции вычис-
ляется вне зависимости от того, что происходит во внешнем запросе.
Агрегатные функции также очень полезны в сочетании с предложением GROUP BY. Например, мы
можем получить максимум минимальной дневной температуры в разрезе городов:
SELECT city, max(temp_lo)
FROM weather
GROUP BY city;
city
| max
—————+—–
Hayward
| 37
San Francisco | 46
(2 rows)
Здесь мы получаем по одной строке для каждого города. Каждый агрегатный результат вычисля-
ется по строкам таблицы, соответствующим отдельному городу. Мы можем отфильтровать сгруп-
пированные строки с помощью предложения HAVING:
SELECT city, max(temp_lo)
FROM weather
GROUP BY city
HAVING max(temp_lo) &amp;lt; 40;
city
| max
———+—–
Hayward | 37
(1 row)
Мы получаем те же результаты, но только для тех городов, где все значения temp_lo меньше 40.
Наконец, если нас интересуют только города, названия которых начинаются с «S», мы можем сде-
лать:
SELECT city, max(temp_lo)
FROM weather
WHERE city LIKE ‘S%’
GROUP BY city
HAVING max(temp_lo) &amp;lt; 40;
1
–
1
Оператор LIKE (выполняющий сравнение по шаблону) рассматривается в Разделе 9.7.
Важно понимать, как соотносятся агрегатные функции и SQL-предложения WHERE и HAVING. Основ-
ное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем груп-
пирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления
агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных
функций. Как следствие, предложение WHERE не должно содержать агрегатных функций; не име-
ет смысла использовать агрегатные функции для определения строк для вычисления агрегатных
функций. Предложение HAVING, напротив, всегда содержит агрегатные функции. (Строго говоря,
вы можете написать предложение HAVING, не используя агрегаты, но это редко бывает полезно. То
же самое условие может работать более эффективно на стадии WHERE.)
В предыдущем примере мы смогли применить фильтр по названию города в предложении WHERE,
так как названия не нужно агрегировать. Такой фильтр эффективнее, чем дополнительное ограни-
чение HAVING, потому что с ним не приходится группировать и вычислять агрегаты для всех строк,
не удовлетворяющих условию WHERE.
12Язык SQL
2.8. Изменение данных
Данные в существующих строках можно изменять, используя команду UPDATE. Например, предпо-
ложим, что вы обнаружили, что все значения температуры после 28 ноября завышены на два гра-
дуса. Вы можете поправить ваши данные следующим образом:
UPDATE weather
SET temp_hi = temp_hi - 2,
WHERE date &amp;gt; ‘1994-11-28’;
temp_lo = temp_lo - 2
Посмотрите на новое состояние данных:
SELECT * FROM weather;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
41 |
55 |
0 | 1994-11-29
Hayward
|
35 |
52 |
| 1994-11-29
(3 rows)
2.9. Удаление данных
Строки также можно удалить из таблицы, используя команду DELETE. Предположим, что вас боль-
ше не интересует погода в Хейуорде. В этом случае вы можете удалить ненужные строки из таб-
лицы:
DELETE FROM weather WHERE city = ‘Hayward’;
Записи всех наблюдений, относящиеся к Хейуорду, удалены.
SELECT * FROM weather;
city
| temp_lo | temp_hi | prcp |
date
—————+———+———+——+————
San Francisco |
46 |
50 | 0.25 | 1994-11-27
San Francisco |
41 |
55 |
0 | 1994-11-29
(2 rows)
Остерегайтесь операторов вида
DELETE FROM имя_таблицы;
Без указания условия DELETE удалит все строки данной таблицы, полностью очистит её. При этом
система не попросит вас подтвердить операцию!&lt;/p&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 2. Язык SQL</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 3. Расширенные возможности</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-003/" rel="alternate" type="text/html" title="Глава 3. Расширенные возможности" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-003</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-003/">&lt;p&gt;Глава 3. Расширенные возможности&lt;/p&gt;

&lt;p&gt;3.1. Введение
В предыдущей главе мы изучили азы использования SQL для хранения и обработки данных в
PostgreSQL. Теперь мы обсудим более сложные возможности SQL, помогающие управлять данны-
ми и предотвратить их потерю или порчу. В конце главы мы рассмотрим некоторые расширения
PostgreSQL.
В этой главе мы будем время от времени ссылаться на примеры, приведённые в Главе 2 и изменять
или развивать их, поэтому будет полезно сначала прочитать предыдущую главу. Некоторые при-
меры этой главы также можно найти в файле advanced.sql в каталоге tutorial. Кроме того, этот
файл содержит пример данных для загрузки (здесь она повторно не рассматривается). Если вы не
знаете, как использовать этот файл, обратитесь к Разделу 2.1.
3.2. Представления
Вспомните запросы, с которыми мы имели дело в Разделе 2.6. Предположим, что вас интересует
составной список из погодных записей и координат городов, но вы не хотите каждый раз вводить
весь этот запрос. Вы можете создать представление по данному запросу, фактически присвоить
имя запросу, а затем обращаться к нему как к обычной таблице:
CREATE VIEW myview AS
SELECT city, temp_lo, temp_hi, prcp, date, location
FROM weather, cities
WHERE city = name;
SELECT * FROM myview;
Активное использование представлений — это ключевой аспект хорошего проектирования баз дан-
ных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые мо-
гут меняться по мере развития приложения, за надёжными интерфейсами.
Представления можно использовать практически везде, где можно использовать обычные табли-
цы. И довольно часто представления создаются на базе других представлений.
3.3. Внешние ключи
Вспомните таблицы weather и cities из Главы 2. Давайте рассмотрим следующую задачу: вы хо-
тите добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится
соответствующая строка в таблице cities. Это называется обеспечением ссылочной целостности
данных. В простых СУБД это пришлось бы реализовать (если это вообще возможно) так: сначала
явно проверить, есть ли соответствующие записи в таблице cities, а затем отклонить или вставить
новые записи в таблицу weather. Этот подход очень проблематичен и неудобен, поэтому всё это
PostgreSQL может сделать за вас.
Новое объявление таблицы будет выглядеть так:
CREATE TABLE cities (
city
varchar(80) primary key,
location point
);
CREATE TABLE weather (
city
varchar(80) references cities(city),
temp_lo
int,
temp_hi
int,
prcp
real,
14Расширенные возможности
date
date
);
Теперь попробуйте вставить недопустимую запись:
INSERT INTO weather VALUES (‘Berkeley’, 45, 53, 0.0, ‘1994-11-28’);
ОШИБКА: INSERT или UPDATE в таблице “weather” нарушает ограничение внешнего
ключа “weather_city_fkey”
ПОДРОБНОСТИ: Ключ (city)=(Berkeley) отсутствует в таблице “cities”.
Поведение внешних ключей можно подстроить согласно требованиям вашего приложения. Мы не
будем усложнять этот простой пример в данном введении, но вы можете обратиться за дополни-
тельной информацией к Главе 5. Правильно применяя внешние ключи, вы определённо создадите
более качественные приложения, поэтому мы настоятельно рекомендуем изучить их.
3.4. Транзакции
Транзакции — это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объ-
единяет последовательность действий в одну операцию “всё или ничего”. Промежуточные состо-
яния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно
завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.
Например, рассмотрим базу данных банка, в которой содержится информация о счетах клиентов,
а также общие суммы по отделениям банка. Предположим, что мы хотим перевести 100 долларов
со счёта Алисы на счёт Боба. Простоты ради, соответствующие SQL-команды можно записать так:
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
UPDATE branches SET balance = balance - 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Alice’);
UPDATE accounts SET balance = balance + 100.00
WHERE name = ‘Bob’;
UPDATE branches SET balance = balance + 100.00
WHERE name = (SELECT branch_name FROM accounts WHERE name = ‘Bob’);
Точное содержание команд здесь не важно, важно лишь то, что для выполнения этой довольно
простой операции потребовалось несколько отдельных действий. При этом с точки зрения банка
необходимо, чтобы все эти действия выполнились вместе, либо не выполнились совсем. Если Боб
получит 100 долларов, но они не будут списаны со счёта Алисы, объяснить это сбоем системы
определённо не удастся. И наоборот, Алиса вряд ли будет довольна, если она переведёт деньги,
а до Боба они не дойдут. Нам нужна гарантия, что если что-то помешает выполнить операцию
до конца, ни одно из действий не оставит следа в базе данных. И мы получаем эту гарантию, объ-
единяя действия в одну транзакцию. Говорят, что транзакция атомарна: с точки зрения других
транзакций она либо выполняется и фиксируется полностью, либо не фиксируется совсем.
Нам также нужна гарантия, что после завершения и подтверждения транзакции системой баз дан-
ных, её результаты в самом деле сохраняются и не будут потеряны, даже если вскоре произойдёт
авария. Например, если мы списали сумму и выдали её Бобу, мы должны исключить возможность
того, что сумма на его счёте восстановится, как только он выйдет за двери банка. Транзакционная
база данных гарантирует, что все изменения записываются в постоянное хранилище (например,
на диск) до того, как транзакция будет считаться завершённой.
Другая важная характеристика транзакционных баз данных тесно связана с атомарностью изме-
нений: когда одновременно выполняется множество транзакций, каждая из них не видит незавер-
шённые изменения, произведённые другими. Например, если одна транзакция подсчитывает ба-
ланс по отделениям, будет неправильно, если она посчитает расход в отделении Алисы, но не учтёт
приход в отделении Боба, или наоборот. Поэтому свойство транзакций “всё или ничего” должно
определять не только, как изменения сохраняются в базе данных, но и как они видны в процессе
работы. Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока
она не будет завершена, а затем они становятся видны все сразу.
15Расширенные возможности
В PostgreSQL транзакция определяется набором SQL-команд, окружённым командами BEGIN и
COMMIT. Таким образом, наша банковская транзакция должна была бы выглядеть так:
BEGIN;
UPDATE accounts SET balance = balance - 100.00
WHERE name = ‘Alice’;
– …
COMMIT;
Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения (на-
пример, потому что оказалось, что баланс Алисы стал отрицательным), мы можем выполнить ко-
манду ROLLBACK вместо COMMIT, и все наши изменения будут отменены.
PostgreSQL на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не встави-
те команду BEGIN, то каждый отдельный оператор будет неявно окружён командами BEGIN и COMMIT
(в случае успешного завершения). Группу операторов, окружённых командами BEGIN и COMMIT ино-
гда называют блоком транзакции.
Примечание
Некоторые клиентские библиотеки добавляют команды BEGIN и COMMIT автоматически
и неявно создают за вас блоки транзакций. Подробнее об этом вы можете узнать в
документации интересующего вас интерфейса.
Операторами в транзакции можно также управлять на более детальном уровне, используя точ-
ки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и
фиксировать все остальные. Определив точку сохранения с помощью SAVEPOINT, при необходимо-
сти вы можете вернуться к ней с помощью команды ROLLBACK TO. Все изменения в базе данных,
произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произ-
ведённые ранее, сохраняются.
Когда вы возвращаетесь к точке сохранения, она продолжает существовать, так что вы можете от-
катываться к ней несколько раз. С другой стороны, если вы уверены, что вам не придётся откаты-
ваться к определённой точке сохранения, её можно удалить, чтобы система высвободила ресурсы.
Помните, что при удалении или откате к точке сохранения все точки сохранения, определённые
после неё, автоматически уничтожаются.
Всё это происходит в блоке транзакции, так что в других сеансах работы с базой данных этого не
видно. Совершённые действия становятся видны для других сеансов все сразу, только когда вы
фиксируете транзакцию, а отменённые действия не видны вообще никогда.
Вернувшись к банковской базе данных, предположим, что мы списываем 100 долларов со счёта
Алисы, добавляем их на счёт Боба, и вдруг оказывается, что деньги нужно было перевести Уолли.
В данном случае мы можем применить точки сохранения:
BEGIN;
UPDATE accounts SET balance = balance
WHERE name = ‘Alice’;
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Bob’;
– ошибочное действие… забыть его и
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance
WHERE name = ‘Wally’;
COMMIT;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;100.00&lt;/li&gt;
  &lt;li&gt;100.00
использовать счёт Уолли&lt;/li&gt;
  &lt;li&gt;100.00
Этот пример, конечно, несколько надуман, но он показывает, как можно управлять выполнением
команд в блоке транзакций, используя точки сохранения. Более того, ROLLBACK TO — это един-
16Расширенные возможности
ственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии
из-за ошибки системы, не считая возможности полностью отменить её и начать снова.
3.5. Оконные функции
Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с теку-
щей строкой. Её действие можно сравнить с вычислением, производимым агрегатной функцией.
Однако с оконными функциями строки не группируются в одну выходную строку, что имеет место
с обычными, не оконными, агрегатными функциями. Вместо этого, эти строки остаются отдельны-
ми сущностями. Внутри же, оконная функция, как и агрегатная, может обращаться не только к
текущей строке результата запроса.
Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его
отдела:
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
FROM empsalary;
depname | empno | salary |
avg
———–+——-+——–+———————–
develop
|
11 |
5200 | 5020.0000000000000000
develop
|
7 |
4200 | 5020.0000000000000000
develop
|
9 |
4500 | 5020.0000000000000000
develop
|
8 |
6000 | 5020.0000000000000000
develop
|
10 |
5200 | 5020.0000000000000000
personnel |
5 |
3500 | 3700.0000000000000000
personnel |
2 |
3900 | 3700.0000000000000000
sales
|
3 |
4800 | 4866.6666666666666667
sales
|
1 |
5000 | 4866.6666666666666667
sales
|
4 |
4800 | 4866.6666666666666667
(10 rows)
Первые три столбца извлекаются непосредственно из таблицы empsalary, при этом для каждой
строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычис-
ленное по всем строкам, имеющим то же значение depname, что и текущая строка. (Фактически
среднее вычисляет та же обычная, не оконная функция avg, но предложение OVER превращает её
в оконную, так что её действие ограничивается рамками окон.)
Вызов оконной функции всегда содержит предложение OVER, следующее за названием и аргумен-
тами оконной функции. Это синтаксически отличает её от обычной, не оконной агрегатной функ-
ции. Предложение OVER определяет, как именно нужно разделить строки запроса для обработки
оконной функцией. Предложение PARTITION BY, дополняющее OVER, разделяет строки по группам,
или разделам, объединяя одинаковые значения выражений PARTITION BY. Оконная функция вы-
числяется по строкам, попадающим в один раздел с текущей строкой.
Вы можете также определять порядок, в котором строки будут обрабатываться оконными функци-
ями, используя ORDER BY в OVER. (Порядок ORDER BY для окна может даже не совпадать с порядком,
в котором выводятся строки.) Например:
SELECT depname, empno, salary,
rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
depname | empno | salary | rank
———–+——-+——–+——
develop
|
8 |
6000 |
1
develop
|
10 |
5200 |
2
develop
|
11 |
5200 |
2
develop
|
9 |
4500 |
4
develop
|
7 |
4200 |
5
17Расширенные возможности
personnel
personnel
sales
sales
sales
(10 rows)
|
|
|
|
|
2
5
1
4
3
|
|
|
|
|
3900
3500
5000
4800
4800
|
|
|
|
|
1
2
1
2
2
Как показано здесь, функция rank выдаёт порядковый номер для каждого уникального значения
в разделе текущей строки, по которому выполняет сортировку предложение ORDER BY. У функции
rank нет параметров, так как её поведение полностью определяется предложением OVER.
Строки, обрабатываемые оконной функцией, представляют собой «виртуальные таблицы», создан-
ные из предложения FROM и затем прошедшие через фильтрацию и группировку WHERE и GROUP BY
и, возможно, условие HAVING. Например, строка, отфильтрованная из-за нарушения условия WHERE,
не будет видна для оконных функций. Запрос может содержать несколько оконных функций, раз-
деляющих данные по-разному с применением разных предложений OVER, но все они будут обраба-
тывать один и тот же набор строк этой виртуальной таблицы.
Мы уже видели, что ORDER BY можно опустить, если порядок строк не важен. Также возможно
опустить PARTITION BY, в этом случае образуется один раздел, содержащий все строки.
Есть ещё одно важное понятие, связанное с оконными функциями: для каждой строки существует
набор строк в её разделе, называемый рамкой окна. Некоторые оконные функции обрабатывают
только строки рамки окна, а не всего раздела. По умолчанию с указанием ORDER BY рамка состоит
из всех строк от начала раздела до текущей строки и строк, равных текущей по значению выра-
1
жения ORDER BY. Без ORDER BY рамка по умолчанию состоит из всех строк раздела. Посмотрите
на пример использования sum:
SELECT salary, sum(salary) OVER () FROM empsalary;
salary | sum
——–+——-
5200 | 47100
5000 | 47100
3500 | 47100
4800 | 47100
3900 | 47100
4200 | 47100
4500 | 47100
4800 | 47100
6000 | 47100
5200 | 47100
(10 rows)
Так как в этом примере нет указания ORDER BY в предложении OVER, рамка окна содержит все
строки раздела, а он, в свою очередь, без предложения PARTITION BY включает все строки таблицы;
другими словами, сумма вычисляется по всей таблице и мы получаем один результат для каждой
строки результата. Но если мы добавим ORDER BY, мы получим совсем другие результаты:
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
salary | sum
——–+——-
3500 | 3500
3900 | 7400
4200 | 11600
4500 | 16100
4800 | 25700
1
Рамки окна можно определять и другими способами, но в этом введении они не рассматриваются. Узнать о них подробнее вы можете в Подразделе 4.2.8.
18Расширенные возможности
4800 |
5000 |
5200 |
5200 |
6000 |
(10 rows)
25700
30700
41100
41100
47100
Здесь в сумме накапливаются зарплаты от первой (самой низкой) до текущей, включая повторяю-
щиеся текущие значения (обратите внимание на результат в строках с одинаковой зарплатой).
Оконные функции разрешается использовать в запросе только в списке SELECT и предложении
ORDER BY. Во всех остальных предложениях, включая GROUP BY, HAVING и WHERE, они запрещены.
Это объясняется тем, что логически они выполняются после этих предложений, а также после
не оконных агрегатных функций, и значит агрегатную функцию можно вызывать в аргументах
оконной, но не наоборот.
Если вам нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы
можете использовать вложенный запрос. Например:
SELECT depname, empno, salary, enroll_date
FROM
(SELECT depname, empno, salary, enroll_date,
rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
FROM empsalary
) AS ss
WHERE pos &amp;lt; 3;
Данный запрос покажет только те строки внутреннего запроса, у которых rank (порядковый номер)
меньше 3.
Когда в запросе вычисляются несколько оконных функций для одинаково определённых окон, ко-
нечно можно написать для каждой из них отдельное предложение OVER, но при этом оно будет
дублироваться, что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна
выделить в предложение WINDOW, а затем ссылаться на него в OVER. Например:
SELECT sum(salary) OVER w, avg(salary) OVER w
FROM empsalary
WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
Подробнее об оконных функциях можно узнать в Подразделе 4.2.8, Разделе 9.21, Подразделе 7.2.5
и в справке SELECT.
3.6. Наследование
Наследование — это концепция, взятая из объектно-ориентированных баз данных. Она открывает
множество интересных возможностей при проектировании баз данных.
Давайте создадим две таблицы: cities (города) и capitals (столицы штатов). Естественно, столи-
цы штатов также являются городами, поэтому нам нужно явным образом добавлять их в резуль-
тат, когда мы хотим просмотреть все города. Если вы проявите смекалку, вы можете предложить,
например, такое решение:
CREATE TABLE
name
population
altitude
state
);
capitals (
text,
real,
int,
– (высота в футах)
char(2)
CREATE TABLE non_capitals (
name
text,
19Расширенные возможности
population real,
altitude
int
– (высота в футах)
);
CREATE VIEW cities AS
SELECT name, population, altitude FROM capitals
UNION
SELECT name, population, altitude FROM non_capitals;
Оно может устраивать, пока мы извлекаем данные, но если нам потребуется изменить несколько
строк, это будет выглядеть некрасиво.
Поэтому есть лучшее решение:
CREATE TABLE
name
population
altitude
);
cities (
text,
real,
int
– (высота в футах)
CREATE TABLE capitals (
state
char(2)
) INHERITS (cities);
В данном случае строка таблицы capitals наследует все столбцы (name, population и altitude)
от родительской таблицы cities. Столбец name имеет тип text, собственный тип PostgreSQL для
текстовых строк переменной длины. А в таблицу столиц добавлен дополнительный столбец state,
в котором будет указан штат. В PostgreSQL таблица может наследоваться от нуля или нескольких
других таблиц.
Например, следующий запрос выведет названия всех городов, включая столицы, находящихся вы-
ше 500 футов над уровнем моря:
SELECT name, altitude
FROM cities
WHERE altitude &amp;gt; 500;
Результат его выполнения:
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Madison
|
845
(3 rows)
А следующий запрос находит все города, которые не являются столицами штатов, но также нахо-
дятся выше 500 футов:
SELECT name, altitude
FROM ONLY cities
WHERE altitude &amp;gt; 500;
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
(2 rows)
Здесь слово ONLY перед названием таблицы cities указывает, что запрос следует выполнять только
для строк таблицы cities, не включая таблицы, унаследованные от cities. Многие операторы,
которые мы уже обсудили — SELECT, UPDATE и DELETE — поддерживают указание ONLY.
20Расширенные возможности
Примечание
Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уни-
кальности и внешними ключами, что ограничивает его применимость. Подробнее это
описывается в Разделе 5.9.
3.7. Заключение
PostgreSQL имеет множество возможностей, не затронутых в этом кратком введении, рассчитан-
ном на начинающих пользователей SQL. Эти возможности будут рассмотрены в деталях в продол-
жении книги.
Если вам необходима дополнительная вводная информация, посетите сайт PostgreSQL, там вы
найдёте ссылки на другие ресурсы.
21&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 3. Расширенные возможности</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 4. Синтаксис SQL</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-004/" rel="alternate" type="text/html" title="Глава 4. Синтаксис SQL" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-004</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-004/">&lt;p&gt;Глава 4. Синтаксис SQL&lt;/p&gt;

&lt;p&gt;В этой главе описывается синтаксис языка SQL. Тем самым закладывается фундамент для следу-
ющих глав, где будет подробно рассмотрено, как с помощью команд SQL описывать и изменять
данные.
Мы советуем прочитать эту главу и тем, кто уже знаком SQL, так как в ней описываются несколько
правил и концепций, которые реализованы в разных базах данных SQL по-разному или относятся
только к PostgreSQL.
4.1. Лексическая структура
SQL-программа состоит из последовательности команд. Команда, в свою очередь, представляет
собой последовательность компонентов, оканчивающуюся точкой с запятой («;»). Конец входного
потока также считается концом команды. Какие именно компоненты допустимы для конкретной
команды, зависит от её синтаксиса.
Компонентом команды может быть ключевое слово, идентификатор, идентификатор в кавычках,
строка (или константа) или специальный символ. Компоненты обычно разделяются пробельными
символами (пробел, табуляция, перевод строки), но это не требуется, если нет неоднозначности
(например, когда спецсимвол оказывается рядом с компонентом другого типа).
Например, следующий текст является правильной (синтаксически) SQL-программой:
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, ‘hi there’);
Это последовательность трёх команд, по одной в строке (хотя их можно было разместить и в одну
строку или наоборот, разделить команды на несколько строк).
Кроме этого, SQL-программы могут содержать комментарии. Они не являются компонентами ко-
манд, а по сути равносильны пробельным символам.
Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют команды, а какие
— их операнды или параметры. Первые несколько компонентов обычно содержат имя команды,
так что в данном примере мы можем говорить о командах «SELECT», «UPDATE» и «INSERT». Но
например, команда UPDATE требует, чтобы также в определённом положении всегда стоял компо-
нент SET, а INSERT в приведённом виде требует наличия компонента VALUES. Точные синтаксиче-
ские правила для каждой команды описаны в Части VI.
4.1.1. Идентификаторы и ключевые слова
Показанные выше команды содержали компоненты SELECT, UPDATE и VALUES, которые являются
примерами ключевых слов, то есть слов, имеющих фиксированное значение в языке SQL. Компо-
ненты MY_TABLE и A являются примерами идентификаторов. Они идентифицируют имена таблиц,
столбцов или других объектов баз данных, в зависимости от того, где они используются. Поэтому
иногда их называют просто «именами». Ключевые слова и идентификаторы имеют одинаковую
лексическую структуру, то есть, не зная языка, нельзя определить, является ли некоторый ком-
понент ключевым словом или идентификатором. Полный список ключевых слов приведён в При-
ложении C.
Идентификаторы и ключевые слова SQL должны начинаться с буквы (a-z, хотя допускаются также
не латинские буквы и буквы с диакритическими знаками) или подчёркивания (_). Последующими
символами в идентификаторе или ключевом слове могут быть буквы, цифры (0-9), знаки доллара
($) или подчёркивания. Заметьте, что строго следуя букве стандарта SQL, знаки доллара нельзя
использовать в идентификаторах, так что их использование вредит переносимости приложений.
В стандарте SQL гарантированно не будет ключевых слов с цифрами и начинающихся или закан-
чивающихся подчёркиванием, так что идентификаторы такого вида защищены от возможных кон-
фликтов с будущими расширениями стандарта.
23Синтаксис SQL
Система выделяет для идентификатора не более NAMEDATALEN-1 байт, а более длинные имена усека-
ются. По умолчанию NAMEDATALEN равно 64, так что максимальная длина идентификатора равна 63
байтам. Если этого недостаточно, этот предел можно увеличить, изменив константу NAMEDATALEN
в файле src/include/pg_config_manual.h.
Ключевые слова и идентификаторы без кавычек воспринимаются системой без учёта регистра.
Таким образом:
UPDATE MY_TABLE SET A = 5;
равносильно записи:
uPDaTE my_TabLE SeT a = 5;
Часто используется неформальное соглашение записывать ключевые слова заглавными буквами,
а имена строчными, например:
UPDATE my_table SET a = 5;
Есть и другой тип идентификаторов: отделённые идентификаторы или идентификаторы в ка-
вычках. Они образуются при заключении обычного набора символов в двойные кавычки (“). Та-
кие идентификаторы всегда будут считаться идентификаторами, но не ключевыми словами. Так
“select” можно использовать для обозначения столбца или таблицы «select», тогда как select
без кавычек будет воспринят как ключевое слово и приведёт к ошибке разбора команды в месте,
где ожидается имя таблицы или столбца. Тот же пример можно переписать с идентификаторами
в кавычках следующим образом:
UPDATE “my_table” SET “a” = 5;
Идентификаторы в кавычках могут содержать любые символы, за исключением символа с кодом&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;(Чтобы включить в такой идентификатор кавычки, продублируйте их.) Это позволяет создавать
таблицы и столбцы с именами, которые иначе были бы невозможны, например, с пробелами или
амперсандами. Ограничение длины при этом сохраняется.
Ещё один вариант идентификаторов в кавычках позволяет использовать символы Unicode по их
кодам. Такой идентификатор начинается с U&amp;amp; (строчная или заглавная U и амперсанд), а затем
сразу без пробелов идёт двойная кавычка, например U&amp;amp;”foo”. (Заметьте, что при этом возникает
неоднозначность с оператором &amp;amp;. Чтобы её избежать, окружайте этот оператор пробелами.) Затем
в кавычках можно записывать символы Unicode двумя способами: обратная косая черта, а за ней
код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем
код из шести шестнадцатеричных цифр. Например, идентификатор “data” можно записать так:
U&amp;amp;”d\0061t+000061”
В следующем менее тривиальном примере закодировано русское слово «слон», записанное кирил-
лицей:
U&amp;amp;”\0441\043B\043E\043D”
Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать,
добавив UESCAPE после строки, например:
U&amp;amp;”d!0061t!+000061” UESCAPE ‘!’
В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака
плюс, апострофа, кавычки или пробельного символа. Заметьте, что спецсимвол заключается не в
двойные кавычки, а в апострофы.
Чтобы сделать спецсимволом знак апострофа, напишите его дважды.
Unicode-формат полностью поддерживается только при использовании на сервере кодировки UTF8.
Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами
до \007F). И в четырёх, и в шестизначной форме можно записывать суррогатные пары UTF-16 и
таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шестизначной
24Синтаксис SQL
формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно, а
объединяются в один символ, который затем кодируется в UTF-8.)
Идентификатор, заключённый в кавычки, становится зависимым от регистра, тогда как идентифи-
каторы без кавычек всегда переводятся в нижний регистр. Например, идентификаторы FOO, foo и
“foo” считаются одинаковыми в PostgreSQL, но “Foo” и “FOO” отличны друг от друга и от предыду-
щих трёх. (Приведение имён без кавычек к нижнему регистру, как это делает PostgreSQL, несов-
местимо со стандартом SQL, который говорит о том, что имена должны приводиться к верхнему
регистру. То есть, согласно стандарту foo должно быть эквивалентно “FOO”, а не “foo”. Поэтому
при создании переносимых приложений рекомендуется либо всегда заключать определённое имя
в кавычки, либо не заключать никогда.)
4.1.2. Константы
В PostgreSQL есть три типа констант подразумеваемых типов: строки, битовые строки и числа.
Константы можно также записывать, указывая типы явно, что позволяет представить их более
точно и обработать более эффективно. Эти варианты рассматриваются в следующих подразделах.
4.1.2.1. Строковые константы
Строковая константа в SQL — это обычная последовательность символов, заключённая в апостро-
фы (‘), например: ‘Это строка’. Чтобы включить апостроф в строку, напишите в ней два апострофа
рядом, например: ‘Жанна д’‘Арк’. Заметьте, это не то же самое, что двойная кавычка (“).
Две строковые константы, разделённые пробельными символами и минимум одним переводом
строки, объединяются в одну и обрабатываются, как если бы строка была записана в одной кон-
станте. Например:
SELECT ‘foo’
‘bar’;
эквивалентно:
SELECT ‘foobar’;
но эта запись:
SELECT ‘foo’
‘bar’;
считается синтаксической ошибкой. (Это несколько странное поведение определено в стандарте
SQL, PostgreSQL просто следует ему.)
4.1.2.2. Строковые константы со спецпоследовательностями в стиле C
PostgreSQL также принимает «спецпоследовательности», что является расширением стандарта
SQL. Строка со спецпоследовательностями начинается с буквы E (заглавной или строчной), стоя-
щей непосредственно перед апострофом, например: E’foo’. (Когда константа со спецпоследова-
тельностью разбивается на несколько строк, букву E нужно поставить только перед первым откры-
вающим апострофом.) Внутри таких строк символ обратной косой черты () начинает C-подобные
спецпоследовательности, в которых сочетание обратной косой черты со следующим символом(а-
ми) даёт определённое байтовое значение, как показано в Таблице 4.1.
Таблица 4.1. Спецпоследовательности
Спецпоследовательность Интерпретация
\b символ «забой»
\f подача формы
\n новая строка
\r возврат каретки
\t табуляция
\o, \oo, \ooo (o = 0 - 7) восьмеричное значение байта
25Синтаксис SQL
Спецпоследовательность Интерпретация
\xh, \xhh (h = 0 — 9, A — F) шестнадцатеричное значение байта
\uxxxx, \Uxxxxxxxx (x = 0 — 9, A — F) 16- или 32-битный шестнадцатеричный код сим-
вола Unicode
Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким
образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (\).
Так же можно включить в строку апостроф, написав ', в дополнение к обычному способу ‘’.
Вы должны позаботиться, чтобы байтовые последовательности, которые вы создаёте таким обра-
зом, особенно в восьмеричной и шестнадцатеричной записи, образовывали допустимые символы
в серверной кодировке. Когда сервер работает с кодировкой UTF-8, вместо такой записи байт сле-
дует использовать спецпоследовательности Unicode или альтернативный синтаксис Unicode, опи-
санный в Подразделе 4.1.2.3. (В противном случае придётся кодировать символы UTF-8 вручную
и выписывать их по байтам, что очень неудобно.)
Спецпоследовательности с Unicode полностью поддерживаются только при использовании на сер-
вере кодировки UTF8. Когда используются другие кодировки, допускается указание только ASCII-
символов (с кодами до \u007F). И в четырёх, и в восьмизначной форме можно записывать сурро-
гатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя на-
личие восьмизначной формы технически делает это ненужным. (Когда суррогатные пары исполь-
зуются с серверной кодировкой UTF8, они сначала объединяются в один символ, который затем
кодируется в UTF-8.)
Внимание
Если параметр конфигурации standard_conforming_strings имеет значение off,
PostgreSQL распознаёт обратную косую черту как спецсимвол и в обычных строках,
и в строках со спецпоследовательностями. Однако в версии PostgreSQL 9.1 по умолча-
нию принято значение on, и в этом случае обратная косая черта распознаётся только
в спецстроках. Это поведение больше соответствует стандарту, хотя может нарушить
работу приложений, рассчитанных на предыдущий режим, когда обратная косая черта
распознавалась везде. В качестве временного решения вы можете изменить этот пара-
метр на off, но лучше уйти от такой практики. Если вам нужно, чтобы обратная косая
черта представляла специальный символ, задайте строковую константу с E.
В дополнение к standard_conforming_strings поведением обратной косой черты в
строковых константах управляют параметры escape_string_warning и backslash_quote.
Строковая константа не может включать символ с кодом 0.
4.1.2.3. Строковые константы со спецпоследовательностями Unicode
PostgreSQL также поддерживает ещё один вариант спецпоследовательностей, позволяющий вклю-
чать в строки символы Unicode по их кодам. Строковая константа со спецпоследовательностями
Unicode начинается с U&amp;amp; (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт
апостроф, например U&amp;amp;’foo’. (Заметьте, что при этом возникает неоднозначность с оператором &amp;amp;.
Чтобы её избежать, окружайте этот оператор пробелами.) Затем в апострофах можно записывать
символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шест-
надцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцате-
ричных цифр. Например, строку ‘data’ можно записать так:
U&amp;amp;’d\0061t+000061’
В следующем менее тривиальном примере закодировано русское слово «слон», записанное кирил-
лицей:
U&amp;amp;’\0441\043B\043E\043D’
26Синтаксис SQL
Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать,
добавив UESCAPEпосле строки, например:
U&amp;amp;’d!0061t!+000061’ UESCAPE ‘!’
В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака
плюс, апострофа, кавычки или пробельного символа.
Спецпоследовательности с Unicode поддерживаются только при использовании на сервере коди-
ровки UTF8. Когда используются другие кодировки, допускается указание только ASCII-символов
(с кодами до \007F). И в четырёх, и в шестизначной форме можно записывать суррогатные пары
UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шести-
значной формы технически делает это ненужным. (Когда суррогатные пары используются с сер-
верной кодировкой UTF8, они сначала объединяются в один символ, который затем кодируется в
UTF-8.)
Также заметьте, что спецпоследовательности Unicode в строковых константах работают, только
когда параметр конфигурации standard_conforming_strings равен on. Это объясняется тем, что ина-
че клиентские программы, проверяющие SQL-операторы, можно будет ввести в заблуждение и
эксплуатировать это как уязвимость, например, для SQL-инъекций. Если этот параметр имеет зна-
чение off, эти спецпоследовательности будут вызывать ошибку.
Чтобы включить спецсимвол в строку буквально, напишите его дважды.
4.1.2.4. Строковые константы, заключённые в доллары
Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, он может пло-
хо читаться, когда строка содержит много апострофов или обратных косых черт, так как каждый
такой символ приходится дублировать. Чтобы и в таких случаях запросы оставались читаемыми,
PostgreSQL предлагает ещё один способ записи строковых констант — «заключение строк в дол-
лары». Строковая константа, заключённая в доллары, начинается со знака доллара ($), необяза-
тельного «тега» из нескольких символов и ещё одного знака доллара, затем содержит обычную
последовательность символов, составляющую строку, и оканчивается знаком доллара, тем же те-
гом и замыкающим знаком доллара. Например, строку «Жанна д’Арк» можно записать в долларах
двумя способами:
&lt;script type=&quot;math/tex&quot;&gt;Жанна д'Арк&lt;/script&gt;
$SomeTag$Жанна д’Арк$SomeTag$
Заметьте, что внутри такой строки апострофы не нужно записывать особым образом. На самом
деле, в строке, заключённой в доллары, все символы можно записывать в чистом виде: содержи-
мое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не
являются спецсимволами, если только они не образуют последовательность, соответствующую от-
крывающему тегу.
Строковые константы в долларах можно вкладывать друг в друга, выбирая на разных уровнях вло-
женности разные теги. Чаще всего это используется при написании определений функций. На-
пример:
$function$
BEGIN
RETURN ($1 ~ $q$[\t\r\n\v\]$q$);
END;
$function$
Здесь последовательность $q$[\t\r\n\v\]$q$ представляет в долларах текстовую строку [\t\r
\n\v\], которая будет обработана, когда PostgreSQL будет выполнять эту функцию. Но так как
эта последовательность не соответствует внешнему тегу в долларах ($function$), с точки зрения
внешней строки это просто обычные символы внутри константы.
Тег строки в долларах, если он присутствует, должен соответствовать правилам, определённым
для идентификаторов без кавычек, и к тому же не должен содержать знак доллара. Теги регистро-
27Синтаксис SQL
зависимы, так что $tag$String content$tag$ — правильная строка, а $TAG$String content$tag
$ — нет.
Строка в долларах, следующая за ключевым словом или идентификатором, должна отделяться от
него пробельными символами, иначе доллар будет считаться продолжением предыдущего иден-
тификатора.
Заключение строк в доллары не является частью стандарта SQL, но часто это более удобный спо-
соб записывать сложные строки, чем стандартный вариант с апострофами. Он особенно полезен,
когда нужно представить строковую константу внутри другой строки, что часто требуется в опре-
делениях процедурных функций. Ограничившись только апострофами, каждую обратную косую
черту в приведённом примере пришлось бы записывать четырьмя такими символами, которые бы
затем уменьшились до двух при разборе внешней строки, и наконец до одного при обработке внут-
ренней строки во время выполнения функции.
4.1.2.5. Битовые строковые константы
Битовые строковые константы похожи на обычные с дополнительной буквой B (заглавной или
строчной), добавленной непосредственно перед открывающим апострофом (без промежуточных
пробелов), например: B’1001’. В битовых строковых константах допускаются лишь символы 0 и 1.
Битовые константы могут быть записаны и по-другому, в шестнадцатеричном виде, с начальной
буквой X (заглавной или строчной), например: X’1FF’. Такая запись эквивалентна двоичной, только
четыре двоичных цифры заменяются одной шестнадцатеричной.
Обе формы записи допускают перенос строк так же, как и обычные строковые константы. Однако
заключать в доллары битовые строки нельзя.
4.1.2.6. Числовые константы
Числовые константы могут быть заданы в следующем общем виде:
цифры
цифры.[цифры][e[+-]цифры]
[цифры].цифры[e[+-]цифры]
цифрыe[+-]цифры
где цифры — это одна или несколько десятичных цифр (0..9). До или после десятичной точки (при
её наличии) должна быть минимум одна цифра. Как минимум одна цифра должна следовать за
обозначением экспоненты (e), если оно присутствует. В числовой константе не может быть пробе-
лов или других символов. Заметьте, что любой знак минус или плюс в начале строки не считается
частью числа; это оператор, применённый к константе.
Несколько примеров допустимых числовых констант:
42
3.5
4.
.001
5e2
1.925e-3
Числовая константа, не содержащая точки и экспоненты, изначально рассматривается как кон-
станта типа integer, если её значение умещается в 32-битный тип integer; затем как константа
типа bigint, если её значение умещается в 64-битный bigint; в противном случае она принима-
ет тип numeric. Константы, содержащие десятичные точки и/или экспоненты, всегда считаются
константами типа numeric.
Изначально назначенный тип данных числовой константы это только отправная точка для алго-
ритмов определения типа. В большинстве случаев константа будет автоматически приведена к
наиболее подходящему типу для данного контекста. При необходимости вы можете принудительно
интерпретировать числовое значение как значение определённого типа, приведя его тип к нуж-
28Синтаксис SQL
ному.Например, вы можете сделать, чтобы числовое значение рассматривалось как имеющее тип
real (float4), написав:
REAL ‘1.23’
1.23::REAL
– строковый стиль
– стиль PostgreSQL (исторический)
На самом деле это только частные случаи синтаксиса приведения типов, который будет рассмат-
риваться далее.
4.1.2.7. Константы других типов
Константу обычного типа можно ввести одним из следующих способов:
type ‘string’
‘string’::type
CAST ( ‘string’ AS type )
Текст строковой константы передаётся процедуре преобразования ввода для типа, обозначенного
здесь type. Результатом становится константа указанного типа. Явное приведение типа можно
опустить, если нужный тип константы определяется однозначно (например, когда она присваива-
ется непосредственно столбцу таблицы), так как в этом случае приведение происходит автомати-
чески.
Строковую константу можно записать, используя как обычный синтаксис SQL, так и формат с
долларами.
Также можно записать приведение типов, используя синтаксис функций:
typename ( ‘string’ )
но это работает не для всех имён типов; подробнее об этом написано в Подразделе 4.2.9.
Конструкцию ::, CAST() и синтаксис вызова функции можно также использовать для преобразо-
вания типов обычных выражений во время выполнения, как описано в Подразделе 4.2.9. Во избе-
жание синтаксической неопределённости, запись тип ‘строка’ можно использовать только для
указания типа простой текстовой константы. Ещё одно ограничение записи тип ‘строка’: она не
работает для массивов; для таких констант следует использовать :: или CAST().
Синтаксис CAST() соответствует SQL, а запись type ‘string’ является обобщением стандарта:
в SQL такой синтаксис поддерживает только некоторые типы данных, но PostgreSQL позволяет
использовать его для всех. Синтаксис с :: имеет исторические корни в PostgreSQL, как и запись
в виде вызова функции.
4.1.3. Операторы
Имя оператора образует последовательность не более чем NAMEDATALEN-1 (по умолчанию 63) сим-
волов из следующего списка:
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;ul&gt;
              &lt;li&gt;/ &amp;lt; &amp;gt; = ~ ! @ # % ^ &amp;amp; | ` ?
Однако для имён операторов есть ещё несколько ограничений:
• Сочетания символов – и /* не могут присутствовать в имени оператора, так как они будут
обозначать начало комментария.
• Многосимвольное имя оператора не может заканчиваться знаком + или -, если только оно не
содержит также один из этих символов:
~ ! @ # % ^ &amp;amp; | ` ?
Например, @- — допустимое имя оператора, а &lt;em&gt;- — нет. Благодаря этому ограничению,
PostgreSQL может разбирать корректные SQL-запросы без пробелов между компонентами.
Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних операторов
пробелами для однозначности. Например, если вы определили левый унарный оператор с именем
29Синтаксис SQL
@, вы не можете написать X&lt;/em&gt;@Y, а должны написать X* @Y, чтобы PostgreSQL однозначно прочитал
это как два оператора, а не один.
4.1.4. Специальные знаки
Некоторые не алфавитно-цифровые символы имеют специальное значение, но при этом не явля-
ются операторами. Подробнее их использование будет рассмотрено при описании соответствую-
щего элемента синтаксиса. Здесь они упоминаются только для сведения и обобщения их предна-
значения.
• Знак доллара ($), предваряющий число, используется для представления позиционного пара-
метра в теле определения функции или подготовленного оператора. В других контекстах знак
доллара может быть частью идентификатора или строковой константы, заключённой в долла-
ры.
• Круглые скобки (()) имеют обычное значение и применяются для группировки выражений и
повышения приоритета операций. В некоторых случаях скобки — это необходимая часть син-
таксиса определённых SQL-команд.
• Квадратные скобки ([]) применяются для выделения элементов массива. Подробнее массивы
рассматриваются в Разделе 8.15.
• Запятые (,) используются в некоторых синтаксических конструкциях для разделения элемен-
тов списка.
• Точка с запятой (;) завершает команду SQL. Она не может находиться нигде внутри команды,
за исключением строковых констант или идентификаторов в кавычках.
• Двоеточие (:) применяется для выборки «срезов» массивов (см. Раздел 8.15.) В некоторых
диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в имени пере-
менной.
• Звёздочка (&lt;em&gt;) используется в некоторых контекстах как обозначение всех полей строки или
составного значения. Она также имеет специальное значение, когда используется как аргу-
мент некоторых агрегатных функций, а именно функций, которым не нужны явные парамет-
ры.
• Точка (.) используется в числовых константах, а также для отделения имён схемы, таблицы и
столбца.
4.1.5. Комментарии
Комментарий — это последовательность символов, которая начинается с двух минусов и продол-
жается до конца строки, например:
– Это стандартный комментарий SQL
Кроме этого, блочные комментарии можно записывать в стиле C:
/&lt;/em&gt; многострочный комментарий&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;с вложенностью: /* вложенный блок комментария &lt;em&gt;/
*/
где комментарий начинается с /&lt;/em&gt; и продолжается до соответствующего вхождения */. Блочные
комментарии можно вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в
C), так что вы можете комментировать большие блоки кода, которые при этом уже могут содержать
блоки комментариев.
Комментарий удаляется из входного потока в начале синтаксического анализа и фактически за-
меняется пробелом.
4.1.6. Приоритеты операторов
В Таблице 4.2 показаны приоритеты и очерёдность операторов, действующие в PostgreSQL. Боль-
шинство операторов имеют одинаковый приоритет и вычисляются слева направо. Приоритет и
очерёдность операторов жёстко фиксированы в синтаксическом анализаторе.
30Синтаксис SQL
Иногда вам потребуется добавлять скобки, когда вы комбинируете унарные и бинарные операторы.
Например, выражение:
SELECT 5 ! - 6;
будет разобрано как:
SELECT 5 ! (- 6);
так как анализатор до последнего не знает, что оператор ! определён как постфиксный, а не ин-
фиксный (внутренний). Чтобы получить желаемый результат в этом случае, нужно написать:
SELECT (5 !) - 6;
Такова цена расширяемости.
Таблица 4.2. Приоритет операторов (от большего к меньшему)
Оператор/элемент Очерёдность Описание
. слева-направо разделитель имён таблицы и
столбца
:: слева-направо приведение
PostgreSQL
[ ] слева-направо выбор элемента массива&lt;/li&gt;
      &lt;li&gt;
        &lt;ul&gt;
          &lt;li&gt;справа-налево унарный плюс, унарный минус
^ слева-направо возведение в степень&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;/ % слева-направо умножение, деление, остаток от
деления&lt;/li&gt;
      &lt;li&gt;
        &lt;ul&gt;
          &lt;li&gt;слева-направо сложение, вычитание
(любой другой оператор) слева-направо все другие встроенные и пользо-
вательские операторы
типов
в
стиле
BETWEEN IN LIKE ILIKE SIMILAR проверка диапазона, проверка
членства, сравнение строк
&amp;lt; &amp;gt; = &amp;lt;= &amp;gt;= &amp;lt;&amp;gt; операторы сравнения
IS ISNULL NOTNULL IS TRUE, IS FALSE, IS NULL, IS
DISTINCT FROM и т. д.
NOT справа-налево логическое отрицание
AND слева-направо логическая конъюнкция
OR слева-направо логическая дизъюнкция
Заметьте, что правила приоритета операторов также применяются к операторам, определённым
пользователем с теми же именами, что и вышеперечисленные встроенные операторы. Например,
если вы определите оператор «+» для некоторого нестандартного типа данных, он будет иметь тот
же приоритет, что и встроенный оператор «+», независимо от того, что он у вас делает.
Когда в конструкции OPERATOR используется имя оператора со схемой, например так:
SELECT 3 OPERATOR(pg_catalog.+) 4;
тогда OPERATOR имеет приоритет по умолчанию, соответствующий в Таблице  4.2 строке «любой
другой оператор». Это не зависит от того, какие именно операторы находятся в конструкции
OPERATOR().
Примечание
В PostgreSQL до версии 9.5 действовали немного другие правила приоритета операто-
ров. В частности, операторы &amp;lt;=, &amp;gt;= и &amp;lt;&amp;gt; обрабатывались по общему правилу; проверки
31Синтаксис SQL
IS имели более высокий приоритет; а NOT BETWEEN и связанные конструкции работа-
ли несогласованно — в некоторых случаях приоритетнее оказывался оператор NOT, а
не BETWEEN. Эти правила были изменены для лучшего соответствия стандарту SQL и
для уменьшения путаницы из-за несогласованной обработки логически равнозначных
конструкций. В большинстве случаев эти изменения никак не проявятся, либо могут
привести к ошибкам типа «нет такого оператора», которые можно разрешить, добавив
скобки. Однако, возможны особые случаи, когда запрос будет разобран без ошибки, но
его поведение может измениться. Если вас беспокоит, не нарушают ли эти изменения
незаметно работу вашего приложения, вы можете проверить это, включив конфигура-
ционный параметр operator_precedence_warning и пронаблюдав, не появятся ли преду-
преждения в журнале.
4.2. Выражения значения
Выражения значения применяются в самых разных контекстах, например в списке результатов
команды SELECT, в значениях столбцов в INSERT или UPDATE или в условиях поиска во многих ко-
мандах. Результат такого выражения иногда называют скаляром, чтобы отличить его от резуль-
тата табличного выражения (который представляет собой таблицу). А сами выражения значения
часто называют скалярными (или просто выражениями). Синтаксис таких выражений позволя-
ет вычислять значения из примитивных частей, используя арифметические, логические и другие
операции.
Выражениями значения являются:
• Константа или непосредственное значение
• Ссылка на столбец
• Ссылка на позиционный параметр в теле определения функции или подготовленного операто-
ра
• Выражение с индексом
• Выражение выбора поля
• Применение оператора
• Вызов функции
• Агрегатное выражение
• Вызов оконной функции
• Приведение типов
• Применение правил сортировки
• Скалярный подзапрос
• Конструктор массива
• Конструктор табличной строки
• Кроме того, выражением значения являются скобки (предназначенные для группировки под-
выражений и переопределения приоритета )
В дополнение к этому списку есть ещё несколько конструкций, которые можно классифицировать
как выражения, хотя они не соответствуют общим синтаксическим правилам. Они обычно имеют
вид функции или оператора и будут рассмотрены в соответствующем разделе Главы  9. Пример
такой конструкции — предложение IS NULL.
Мы уже обсудили константы в Подразделе 4.1.2. В следующих разделах рассматриваются осталь-
ные варианты.
4.2.1. Ссылки на столбцы
32Синтаксис SQL
Ссылку на столбец можно записать в форме:
отношение.имя_столбца
Здесь отношение — имя таблицы (возможно, полное, с именем схемы) или её псевдоним, опреде-
лённый в предложении FROM. Это имя и разделяющую точку можно опустить, если имя столбца
уникально среди всех таблиц, задействованных в текущем запросе. (См. также Главу 7.)
4.2.2. Позиционные параметры
Ссылка на позиционный параметр применяется для обращения к значению, переданному в SQL-
оператор извне. Параметры используются в определениях SQL-функций и подготовленных опе-
раторов. Некоторые клиентские библиотеки также поддерживают передачу значений данных от-
дельно от самой SQL-команды, и в этом случае параметры позволяют ссылаться на такие значе-
ния. Ссылка на параметр записывается в следующей форме:
$число
Например, рассмотрим следующее определение функции dept:
CREATE FUNCTION dept(text) RETURNS dept
AS &lt;script type=&quot;math/tex&quot;&gt;SELECT * FROM dept WHERE name = $1&lt;/script&gt;
LANGUAGE SQL;
Здесь $1 всегда будет ссылаться на значение первого аргумента функции.
4.2.3. Индексы элементов
Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, на-
писав:
выражение[индекс]
или несколько соседних элементов («срез массива»):
выражение[нижний_индекс:верхний_индекс]
(Здесь квадратные скобки [ ] должны быть в явном виде.) Каждый индекс сам по себе является
выражением, результатом которого должно быть целое число.
В общем случае выражение массива должно заключаться в круглые скобки, но их можно опустить,
когда выражение с индексом — это просто ссылка на столбец или позиционный параметр. Кроме
того, можно соединить несколько индексов, если исходный массив многомерный. Например:
моя_таблица.столбец_массив[4]
моя_таблица.столбец_массив_2d[17][34]
$1[10:42]
(функция_массив(a,b))[42]
В последней строке круглые скобки необходимы. Подробнее массивы рассматриваются в Разде-
ле 8.15.
4.2.4. Выбор поля
Если результат выражения — значение составного типа (строка таблицы), тогда определённое
поле этой строки можно извлечь, написав:
выражение.имя_поля
В общем случае выражение такого типа должно заключаться в круглые скобки, но их можно опу-
стить, когда это ссылка на таблицу или позиционный параметр. Например:
моя_таблица.столбец
$1.столбец
(функция_кортеж(a,b)).стол3
33Синтаксис SQL
(Таким образом, полная ссылка на столбец — это просто частный случай выбора поля.) Важный
особый случай здесь — извлечение поля из столбца составного типа:
(составной_столбец).поле
(моя_таблица.составной_столбец).поле
Здесь скобки нужны, чтобы показать, что составной_столбец — это имя столбца, а не таблицы, и
что моя_таблица — имя таблицы, а не схемы.
Вы можете запросить все поля составного значения, написав .&lt;em&gt;:
(составной_столбец).&lt;/em&gt;
Эта запись действует по-разному в зависимости от контекста; подробнее об этом говорится в Под-
разделе 8.16.5.
4.2.5. Применение оператора
Существуют три возможных синтаксиса применения операторов:
выражение оператор выражение (бинарный инфиксный оператор)
оператор выражение (унарный префиксный оператор)
выражение оператор (унарный постфиксный оператор)
где оператор соответствует синтаксическим правилам, описанным в Подразделе  4.1.3, либо это
одно из ключевых слов AND, OR и NOT, либо полное имя оператора в форме:
OPERATOR(схема.имя_оператора)
Существование конкретных операторов и их тип (унарный или бинарный) зависит от того, как и ка-
кие операторы определены системой и пользователем. Встроенные операторы описаны в Главе 9.
4.2.6. Вызовы функций
Вызов функции записывается просто как имя функции (возможно, дополненное именем схемы) и
список аргументов в скобках:
имя_функции ([выражение [, выражение … ]])
Например, так вычисляется квадратный корень из 2:
sqrt(2)
Список встроенных функций приведён в Главе 9. Пользователь также может определить и другие
функции.
Выполняя запросы в базе данных, где одни пользователи могут не доверять другим, в записи вы-
зовов функций соблюдайте меры предосторожности, описанные в Разделе 10.3.
Аргументам могут быть присвоены необязательные имена. Подробнее об этом см. Раздел 4.3.
Примечание
Функцию, принимающую один аргумент составного типа, можно также вызывать, ис-
пользуя синтаксис выбора поля, и наоборот, выбор поля можно записать в функцио-
нальном стиле. То есть записи col(table) и table.col равносильны и взаимозаменяе-
мы. Это поведение не оговорено стандартом SQL, но реализовано в PostgreSQL, так как
это позволяет использовать функции для эмуляции «вычисляемых полей». Подробнее
это описано в Подразделе 8.16.5.
4.2.7. Агрегатные выражения
34Синтаксис SQL
Агрегатное выражение представляет собой применение агрегатной функции к строкам, выбран-
ным запросом. Агрегатная функция сводит множество входных значений к одному выходному, как
например, сумма или среднее. Агрегатное выражение может записываться следующим образом:
агрегатная_функция (выражение [ , … ] [ предложение_order_by ] ) [ FILTER
( WHERE условие_фильтра ) ]
агрегатная_функция (ALL выражение [ , … ] [ предложение_order_by ] ) [ FILTER
( WHERE условие_фильтра ) ]
агрегатная_функция (DISTINCT выражение [ , … ] [ предложение_order_by ] ) [ FILTER
( WHERE условие_фильтра ) ]
агрегатная_функция ( * ) [ FILTER ( WHERE условие_фильтра ) ]
агрегатная_функция ( [ выражение [ , … ] ] ) WITHIN GROUP ( предложение_order_by )
[ FILTER ( WHERE условие_фильтра ) ]
Здесь агрегатная_функция — имя ранее определённой агрегатной функции (возможно, дополнен-
ное именем схемы), выражение — любое выражение значения, не содержащее в себе агрегатного
выражения или вызова оконной функции. Необязательные предложения предложение_order_by и
условие_фильтра описываются ниже.
В первой форме агрегатного выражения агрегатная функция вызывается для каждой строки. Вто-
рая форма эквивалентна первой, так как указание ALL подразумевается по умолчанию. В третьей
форме агрегатная функция вызывается для всех различных значений выражения (или набора раз-
личных значений, для нескольких выражений), выделенных во входных данных. В четвёртой фор-
ме агрегатная функция вызывается для каждой строки, так как никакого конкретного значения не
указано (обычно это имеет смысл только для функции count(&lt;em&gt;)). В последней форме используются
сортирующие агрегатные функции, которые будут описаны ниже.
Большинство агрегатных функций игнорируют значения NULL, так что строки, для которых выра-
жения выдают одно или несколько значений NULL, отбрасываются. Это можно считать истинным
для всех встроенных операторов, если явно не говорится об обратном.
Например, count(&lt;/em&gt;) подсчитает общее количество строк, а count(f1) только количество строк, в
которых f1 не NULL (так как count игнорирует NULL), а count(distinct f1) подсчитает число
различных и отличных от NULL значений столбца f1.
Обычно строки данных передаются агрегатной функции в неопределённом порядке и во многих
случаях это не имеет значения, например функция min выдаёт один и тот же результат независи-
мо от порядка поступающих данных. Однако некоторые агрегатные функции (такие как array_agg
и string_agg) выдают результаты, зависящие от порядка данных. Для таких агрегатных функций
можно добавить предложение_order_by и задать нужный порядок. Это предложение_order_by име-
ет тот же синтаксис, что и предложение ORDER BY на уровне запроса, как описано в Разделе 7.5, за
исключением того, что его выражения должны быть просто выражениями, а не именами резуль-
тирующих столбцов или числами. Например:
SELECT array_agg(a ORDER BY b DESC) FROM table;
Заметьте, что при использовании агрегатных функций с несколькими аргументами, предложение
ORDER BY идёт после всех аргументов. Например, надо писать так:
SELECT string_agg(a, ‘,’ ORDER BY a) FROM table;
а не так:
SELECT string_agg(a ORDER BY a, ‘,’) FROM table;
– неправильно
Последний вариант синтаксически допустим, но он представляет собой вызов агрегатной функции
одного аргумента с двумя ключами ORDER BY (при этом второй не имеет смысла, так как это кон-
станта).
Если предложение_order_by дополнено указанием DISTINCT, тогда все выражения ORDER BY долж-
ны соответствовать обычным аргументам агрегатной функции; то есть вы не можете сортировать
строки по выражению, не включённому в список DISTINCT.
35Синтаксис SQL
Примечание
Возможность указывать и DISTINCT, и ORDER BY в агрегатной функции — это расшире-
ние PostgreSQL.
При добавлении ORDER BY в обычный список аргументов агрегатной функции, описанном до это-
го, выполняется сортировка входных строк для универсальных и статистических агрегатных функ-
ций, для которых сортировка необязательна. Но есть подмножество агрегатных функций, сорти-
рующие агрегатные функции, для которых предложение_order является обязательным, обычно
потому, что вычисление этой функции имеет смысл только при определённой сортировке входных
строк. Типичными примерами сортирующих агрегатных функций являются вычисления ранга и
процентиля. Для сортирующей агрегатной функции предложение_order_by записывается внутри
WITHIN GROUP (…), что иллюстрирует последний пример, приведённый выше. Выражения в пред-
ложении_order_by вычисляются однократно для каждой входной строки как аргументы обычной
агрегатной функции, сортируются в соответствии с требованием предложения_order_by и поступа-
ют в агрегатную функции как входящие аргументы. (Если же предложение_order_by находится не
в WITHIN GROUP, оно не передаётся как аргумент(ы) агрегатной функции.) Выражения-аргументы,
предшествующие WITHIN GROUP, (если они есть), называются непосредственными аргументами,
а выражения, указанные в предложении_order_by — агрегируемыми аргументами. В отличие от
аргументов обычной агрегатной функции, непосредственные аргументы вычисляются однократно
для каждого вызова функции, а не для каждой строки. Это значит, что они могут содержать пе-
ременные, только если эти переменные сгруппированы в GROUP BY; это суть то же ограничение,
что действовало бы, будь эти непосредственные аргументы вне агрегатного выражения. Непосред-
ственные аргументы обычно используются, например, для указания значения процентиля, кото-
рое имеет смысл, только если это конкретное число для всего расчёта агрегатной функции. Спи-
сок непосредственных аргументов может быть пуст; в этом случае запишите просто (), но не (&lt;em&gt;).
(На самом деле PostgreSQL примет обе записи, но только первая соответствует стандарту SQL.)
Пример вызова сортирующей агрегатной функции:
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
percentile_cont
—————–
50489
она получает 50-ый процентиль, или медиану, значения столбца income из таблицы households.
В данном случае, 0.5 — это непосредственный аргумент; если бы дробь процентиля менялась от
строки к строке, это не имело бы смысла.
Если добавлено предложение FILTER, агрегатной функции подаются только те входные строки, для
которых условие_фильтра вычисляется как истинное; другие строки отбрасываются. Например:
SELECT
count(&lt;/em&gt;) AS unfiltered,
count(&lt;em&gt;) FILTER (WHERE i &amp;lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
unfiltered | filtered
————+———-
10 |
4
(1 row)
Предопределённые агрегатные функции описаны в Разделе 9.20. Пользователь также может опре-
делить другие агрегатные функции.
Агрегатное выражение может фигурировать только в списке результатов или в предложении
HAVING команды SELECT. Во всех остальных предложениях, например WHERE, они запрещены, так
как эти предложения логически вычисляются до того, как формируются результаты агрегатных
функций.
36Синтаксис SQL
Когда агрегатное выражение используется в подзапросе (см. Подраздел 4.2.11 и Раздел 9.22), оно
обычно вычисляется для всех строк подзапроса. Но если в аргументах (или в условии_filter) аг-
регатной функции есть только переменные внешнего уровня, агрегатная функция относится к бли-
жайшему внешнему уровню и вычисляется для всех строк соответствующего запроса. Такое агре-
гатное выражение в целом является внешней ссылкой для своего подзапроса и на каждом вычис-
лении считается константой. При этом допустимое положение агрегатной функции ограничива-
ется списком результатов и предложением HAVING на том уровне запросов, где она находится.
4.2.8. Вызовы оконных функций
Вызов оконной функции представляет собой применение функции, подобной агрегатной, к некото-
рому набору строк, выбранному запросом. В отличие от вызовов не оконных агрегатных функций,
при этом не происходит группировка выбранных строк в одну — каждая строка остаётся отдель-
ной в результате запроса. Однако оконная функция имеет доступ ко всем строкам, вошедшим в
группу текущей строки согласно указанию группировки (списку PARTITION BY) в вызове оконной
функции. Вызов оконной функции может иметь следующие формы:
имя_функции ([выражение [,
OVER имя_окна
имя_функции ([выражение [,
OVER ( определение_окна )
имя_функции ( * ) [ FILTER
имя_функции ( * ) [ FILTER
выражение … ]]) [ FILTER ( WHERE предложение_фильтра ) ]
выражение … ]]) [ FILTER ( WHERE предложение_фильтра ) ]
( WHERE предложение_фильтра ) ] OVER имя_окна
( WHERE предложение_фильтра ) ] OVER ( определение_окна )
Здесь определение_окна записывается в виде
[ имя_существующего_окна ]
[ PARTITION BY выражение [, …] ]
[ ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS ( FIRST | LAST ) ]
[, …] ]
[ определение_рамки ]
Необязательное определение_рамки может иметь вид:
( RANGE | ROWS | GROUPS ) начало_рамки [ исключение_рамки ]
( RANGE | ROWS | GROUPS ) BETWEEN начало_рамки AND конец_рамки [ исключение_рамки ]
Здесь начало_рамки и конец_рамки задаются одним из следующих способов:
UNBOUNDED PRECEDING
смещение PRECEDING
CURRENT ROW
смещение FOLLOWING
UNBOUNDED FOLLOWING
и исключение_рамки может быть следующим:
EXCLUDE
EXCLUDE
EXCLUDE
EXCLUDE
CURRENT ROW
GROUP
TIES
NO OTHERS
Здесь выражение — это любое выражение значения, не содержащее вызовов оконных функций.
имя_окна — ссылка на именованное окно, определённое предложением WINDOW в данном запросе.
Также возможно написать в скобках полное определение_окна, используя тот же синтаксис опре-
деления именованного окна в предложении WINDOW; подробнее это описано в справке по SELECT.
Стоит отметить, что запись OVER имя_окна не полностью равнозначна OVER (имя_окна …); по-
следний вариант подразумевает копирование и изменение определения окна и не будет допусти-
мым, если определение этого окна включает определение рамки.
Указание PARTITION BY группирует строки запроса в разделы, которые затем обрабатываются
оконной функцией независимо друг от друга. PARTITION BY работает подобно предложению GROUP
37Синтаксис SQL
BY на уровне запроса, за исключением того, что его аргументы всегда просто выражения, а не
имена выходных столбцов или числа. Без PARTITION BY все строки, выдаваемые запросом, рассмат-
риваются как один раздел. Указание ORDER BY определяет порядок, в котором оконная функция
обрабатывает строки раздела. Оно так же подобно предложению ORDER BY на уровне запроса и
так же не принимает имена выходных столбцов или числа. Без ORDER BY строки обрабатываются
в неопределённом порядке.
определение_рамки задаёт набор строк, образующих рамку окна, которая представляет собой под-
множество строк текущего раздела и используется для оконных функций, работающих с рамкой,
а не со всем разделом. Подмножество строк в рамке может меняться в зависимости от того, какая
строка является текущей. Рамку можно задать в режимах RANGE, ROWS или GROUPS; в каждом случае
она начинается с положения начало_рамки и заканчивается положением конец_рамки. Если коне-
ц_рамки не задаётся явно, подразумевается CURRENT ROW (текущая строка).
Если начало_рамки задано как UNBOUNDED PRECEDING, рамка начинается с первой строки раздела,
а если конец_рамки определён как UNBOUNDED FOLLOWING, рамка заканчивается последней строкой
раздела.
В режиме RANGE или GROUPS начало_рамки, заданное как CURRENT ROW, определяет в качестве нача-
ла первую родственную строку (строку, которая при сортировке согласно указанному для окна
предложению ORDER BY считается равной текущей), тогда как конец_рамки, заданный как CURRENT
ROW, определяет концом рамки последнюю родственную строку. В режиме ROWS вариант CURRENT
ROW просто обозначает текущую строку.
В вариантах определения рамки смещение PRECEDING и смещение FOLLOWING в качестве смещения
должно задаваться выражение, не содержащее какие-либо переменные и вызовы агрегатных или
оконных функций. Что именно будет означать смещение, определяется в зависимости от режима
рамки:
• В режиме ROWS смещение должно задаваться отличным от NULL неотрицательным целым чис-
лом, и это число определяет сдвиг, с которым начало рамки позиционируется перед текущей
строкой, а конец — после текущей строки.
• В режиме GROUPS смещение также должно задаваться отличным от NULL неотрицательным це-
лым числом, и это число определяет сдвиг (по количеству групп родственных строк), с кото-
рым начало рамки позиционируется перед группой строк, родственных текущей, а конец —
после этой группы. Группу родственных строк образуют строки, которые считаются равными
согласно ORDER BY. (Для использования режима GROUPS определение окна должно содержать
предложение ORDER BY.)
• В режиме RANGE для использования этих указаний предложение ORDER BY должно содержать
ровно один столбец. В этом случае смещение задаёт максимальную разницу между значени-
ем этого столбца в текущей строке и значением его же в предшествующих или последую-
щих строках рамки. Тип данных выражения смещение зависит от типа данных упорядочиваю-
щего столбца. Для числовых столбцов это обычно тот же числовой тип, а для столбцов с ти-
пом дата/время — тип interval. Например, если упорядочивающий столбец имеет тип date
или timestamp, возможна такая запись: RANGE BETWEEN ‘1 day’ PRECEDING AND ‘10 days’
FOLLOWING. Значение смещение при этом может так же быть отличным от NULL и неотрица-
тельным, хотя что считать «неотрицательным», будет зависит от типа данных.
В любом случае расстояние до конца рамки ограничивается расстоянием до конца раздела, так
что для строк, которые находятся у конца раздела, рамка может содержать меньше строк, чем
для других.
Заметьте, что в режимах ROWS и GROUPS указания 0 PRECEDING и 0 FOLLOWING равнозначны указанию
CURRENT ROW. Обычно это справедливо и для режима RANGE, в случае подходящего для типа данных
определения значения «нуля».
Дополнение исключение_рамки позволяет исключить из рамки строки, которые окружают текущую
строку, даже если они должны быть включены согласно указаниям, определяющим начало и конец
38Синтаксис SQL
рамки. EXCLUDE CURRENT ROW исключает из рамки текущую строку. EXCLUDE GROUP исключает из
рамки текущую строку и родственные ей согласно порядку сортировки. EXCLUDE TIES исключает
из рамки все родственные строки для текущей, но не собственно текущую строку. EXCLUDE NO
OTHERS просто явно выражает поведение по умолчанию — не исключает ни текущую строку, ни
родственные ей.
По умолчанию рамка определяется как RANGE UNBOUNDED PRECEDING, что равносильно расширен-
ному определению RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. С указанием ORDER BY
это означает, что рамка будет включать все строки от начала раздела до последней строки, род-
ственной текущей (для ORDER BY). Без ORDER BY это означает, что в рамку включаются все строки
раздела, так как все они считаются родственными текущей.
Действуют также следующие ограничения: в качестве начала_рамки нельзя задать UNBOUNDED
FOLLOWING, в качестве конца_рамки не допускается UNBOUNDED PRECEDING и конец_рамки не может
идти в показанном выше списке указаний начало_рамки AND конец_рамки перед началом_рамки. В
частности, синтаксис RANGE BETWEEN CURRENT ROW AND смещение PRECEDING не допускается. Но
при этом, например, определение ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING допустимо, хотя
оно и не выберет никакие строки.
Если добавлено предложение FILTER, оконной функции подаются только те входные строки, для
которых условие_фильтра вычисляется как истинное; другие строки отбрасываются. Предложение
FILTER допускается только для агрегирующих оконных функций.
Встроенные оконные функции описаны в Таблице  9.57, но пользователь может расширить этот
набор, создавая собственные функции. Кроме того, в качестве оконных функций можно использо-
вать любые встроенные или пользовательские универсальные, а также статистические агрегатные
функции. (Сортирующие и гипотезирующие агрегатные функции в настоящее время использовать
в качестве оконных нельзя.)
Запись со звёздочкой (&lt;/em&gt;) применяется при вызове не имеющих параметров агрегатных функций в
качестве оконных, например count(&lt;em&gt;) OVER (PARTITION BY x ORDER BY y). Звёздочка (&lt;/em&gt;) обычно не
применяется для исключительно оконных функций. Такие функции не допускают использования
DISTINCT и ORDER BY в списке аргументов функции.
Вызовы оконных функций разрешены в запросах только в списке SELECT и в предложении ORDER BY.
Дополнительно об оконных функциях можно узнать в Разделе 3.5, Разделе 9.21 и Подразделе 7.2.5.
4.2.9. Приведения типов
Приведение типа определяет преобразование данных из одного типа в другой. PostgreSQL воспри-
нимает две равносильные записи приведения типов:
CAST ( выражение AS тип )
выражение::тип
Запись с CAST соответствует стандарту SQL, тогда как вариант с :: — историческое наследие
PostgreSQL.
Когда приведению подвергается значение выражения известного типа, происходит преобразова-
ние типа во время выполнения. Это приведение будет успешным, только если определён подходя-
щий оператор преобразования типов. Обратите внимание на небольшое отличие от приведения
констант, описанного в Подразделе 4.1.2.7. Приведение строки в чистом виде представляет собой
начальное присваивание строковой константы и оно будет успешным для любого типа (конечно,
если строка содержит значение, приемлемое для данного типа данных).
Неявное приведение типа можно опустить, если возможно однозначно определить, какой тип
должно иметь выражение (например, когда оно присваивается столбцу таблицы); в таких случа-
ях система автоматически преобразует тип. Однако автоматическое преобразование выполняется
только для приведений с пометкой «допускается неявное применение» в системных каталогах. Все
39Синтаксис SQL
остальные приведения должны записываться явно. Это ограничение позволяет избежать сюрпри-
зов с неявным преобразованием.
Также можно записать приведение типа как вызов функции:
имя_типа ( выражение )
Однако это будет работать только для типов, имена которых являются также допустимыми име-
нами функций. Например, double precision так использовать нельзя, а float8 (альтернативное
название того же типа) — можно. Кроме того, имена типов interval, time и timestamp из-за син-
таксического конфликта можно использовать в такой записи только в кавычках. Таким образом,
запись приведения типа в виде вызова функции провоцирует несоответствия и, возможно, лучше
будет её не применять.
Примечание
Приведение типа, представленное в виде вызова функции, на самом деле соответству-
ет внутреннему механизму. Даже при использовании двух стандартных типов записи
внутри происходит вызов зарегистрированной функции, выполняющей преобразова-
ние. По соглашению именем такой функции преобразования является имя выходно-
го типа, и таким образом запись «в виде вызова функции» есть не что иное, как пря-
мой вызов нижележащей функции преобразования. При создании переносимого при-
ложения на это поведение, конечно, не следует рассчитывать. Подробнее это описано
в справке CREATE CAST.
4.2.10. Применение правил сортировки
Предложение COLLATE переопределяет правило сортировки выражения. Оно добавляется после
выражения:
выражение COLLATE правило_сортировки
где правило_сортировки — идентификатор правила, возможно дополненный именем схемы. Пред-
ложение COLLATE связывает выражение сильнее, чем операторы, так что при необходимости сле-
дует использовать скобки.
Если правило сортировки не определено явно, система либо выбирает его по столбцам, которые
используются в выражении, либо, если таких столбцов нет, переключается на установленное для
базы данных правило сортировки по умолчанию.
Предложение COLLATE имеет два распространённых применения: переопределение порядка сор-
тировки в предложении ORDER BY, например:
SELECT a, b, c FROM tbl WHERE … ORDER BY a COLLATE “C”;
и переопределение правил сортировки при вызове функций или операторов, возвращающих язы-
козависимые результаты, например:
SELECT * FROM tbl WHERE a &amp;gt; ‘foo’ COLLATE “C”;
Заметьте, что в последнем случае предложение COLLATE добавлено к аргументу оператора, на дей-
ствие которого мы хотим повлиять. При этом не имеет значения, к какому именно аргументу опе-
ратора или функции добавляется COLLATE, так как правило сортировки, применяемое к оператору
или функции, выбирается при рассмотрении всех аргументов, а явное предложение COLLATE пе-
реопределяет правила сортировки для всех других аргументов. (Однако добавление разных пред-
ложений COLLATE к нескольким аргументам будет ошибкой. Подробнее об этом см. Раздел 23.2.)
Таким образом, эта команда выдаст тот же результат:
SELECT * FROM tbl WHERE a COLLATE “C” &amp;gt; ‘foo’;
Но это будет ошибкой:
40Синтаксис SQL
SELECT * FROM tbl WHERE (a &amp;gt; ‘foo’) COLLATE “C”;
здесь правило сортировки нельзя применить к результату оператора &amp;gt;, который имеет несравни-
ваемый тип данных boolean.
4.2.11. Скалярные подзапросы
Скалярный подзапрос — это обычный запрос SELECT в скобках, который возвращает ровно одну
строку и один столбец. (Написание запросов освещается в Главе 7.) После выполнения запроса
SELECT его единственный результат используется в окружающем его выражении. В качестве ска-
лярного подзапроса нельзя использовать запросы, возвращающие более одной строки или столб-
ца. (Но если в результате выполнения подзапрос не вернёт строк, скалярный результат считается
равным NULL.) В подзапросе можно ссылаться на переменные из окружающего запроса; в процес-
се одного вычисления подзапроса они будут считаться константами. Другие выражения с подза-
просами описаны в Разделе 9.22.
Например, следующий запрос находит самый населённый город в каждом штате:
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
FROM states;
4.2.12. Конструкторы массивов
Конструктор массива — это выражение, которое создаёт массив, определяя значения его элемен-
тов. Конструктор простого массива состоит из ключевого слова ARRAY, открывающей квадратной
скобки [, списка выражений (разделённых запятыми), задающих значения элементов массива, и
закрывающей квадратной скобки ]. Например:
SELECT ARRAY[1,2,3+4];
array
———
_(1,2,7)
(1 row)
По умолчанию типом элементов массива считается общий тип для всех выражений, определённый
по правилам, действующим и для конструкций UNION и CASE (см. Раздел 10.5). Вы можете пере-
определить его явно, приведя конструктор массива к требуемому типу, например:&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SELECT ARRAY[1,2,22.7]::integer[];
array ‘(1,2,23)’
(1 row)
Это равносильно тому, что привести к нужному типу каждое выражение по отдельности. Подроб-
нее приведение типов описано в Подразделе 4.2.9.
Многомерные массивы можно образовывать, вкладывая конструкторы массивов. При этом во внут-
ренних конструкторах слово ARRAY можно опускать. Например, результат работы этих конструк-
торов одинаков:
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
array ((1,2),(3,4))
(1 row)
SELECT ARRAY[[1,2],[3,4]];
array
—————
((1,2),(3,4))
(1 row)
41Синтаксис SQL
Многомерные массивы должны быть прямоугольными, и поэтому внутренние конструкторы одно-
го уровня должны создавать вложенные массивы одинаковой размерности. Любое приведение ти-
па, применённое к внешнему конструктору ARRAY, автоматически распространяется на все внут-
ренние.
Элементы многомерного массива можно создавать не только вложенными конструкторами ARRAY,
но и другими способами, позволяющими получить массивы нужного типа. Например:
CREATE TABLE arr(f1 int[], f2 int[]);
INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);
SELECT ARRAY[f1, f2, ‘((9,10),(11,12))’::int[]] FROM arr;
array
————————————————
(((1,2),(3,4)),((5,6),(7,8)),((9,10),(11,12)))
(1 row)
Вы можете создать и пустой массив, но так как массив не может быть не типизированным, вы
должны явно привести пустой массив к нужному типу. Например:
SELECT ARRAY[]::integer[];
array
——-
()
(1 row)
Также возможно создать массив из результатов подзапроса. В этом случае конструктор массива
записывается так же с ключевым словом ARRAY, за которым в круглых скобках следует подзапрос.
Например:
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE ‘bytea%’);
array
———————————————————————–
(2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413)
(1 row)
SELECT ARRAY(SELECT ARRAY[i, i&lt;em&gt;2] FROM generate_series(1,5) AS a(i));
array
———————————-
((1,2),(2,4),(3,6),(4,8),(5,10))
(1 row)
Такой подзапрос должен возвращать один столбец. Если этот столбец имеет тип, отличный от мас-
сива, результирующий одномерный массив будет включать элементы для каждой строки-резуль-
тата подзапроса и типом элемента будет тип столбца результата. Если же тип столбца — массив,
будет создан массив того же типа, но большей размерности; в любом случае во всех строках под-
запроса должны выдаваться массивы одинаковой размерности, чтобы можно было получить пря-
моугольный результат.
Индексы массива, созданного конструктором ARRAY, всегда начинаются с одного. Подробнее о мас-
сивах вы узнаете в Разделе 8.15.
4.2.13. Конструкторы табличных строк
Конструктор табличной строки — это выражение, создающее строку или кортеж (или составное
значение) из значений его аргументов-полей. Конструктор строки состоит из ключевого слова ROW,
открывающей круглой скобки, нуля или нескольких выражений (разделённых запятыми), опреде-
ляющих значения полей, и закрывающей скобки. Например:
SELECT ROW(1,2.5,’this is a test’);
42Синтаксис SQL
Если в списке более одного выражения, ключевое слово ROW можно опустить.
Конструктор строки поддерживает запись составное_значение.&lt;/em&gt;, при этом данное значение будет
развёрнуто в список элементов, так же, как в записи .* на верхнем уровне списка SELECT (см.
Подраздел 8.16.5). Например, если таблица t содержит столбцы f1 и f2, эти записи равнозначны:
SELECT ROW(t.&lt;em&gt;, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
Примечание
До версии PostgreSQL 8.2 запись .&lt;/em&gt; не разворачивалась в конструкторах строк, так
что выражение ROW(t.&lt;em&gt;, 42) создавало составное значение из двух полей, в котором
первое поле так же было составным. Новое поведение обычно более полезно. Если
вам нужно получить прежнее поведение, чтобы одно значение строки было вложено в
другое, напишите внутреннее значение без .&lt;/em&gt;, например: ROW(t, 42).
По умолчанию значение, созданное выражением ROW, имеет тип анонимной записи. Если необхо-
димо, его можно привести к именованному составному типу — либо к типу строки таблицы, либо
составному типу, созданному оператором CREATE TYPE AS. Явное приведение может потребоваться
для достижения однозначности. Например:
CREATE TABLE mytable(f1 int, f2 float, f3 text);
CREATE FUNCTION getf1(mytable) RETURNS int AS ‘SELECT $1.f1’ LANGUAGE SQL;
– Приведение не требуется, так как существует только одна getf1()
SELECT getf1(ROW(1,2.5,’this is a test’));
getf1
——-
1
(1 row)
CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);
CREATE FUNCTION getf1(myrowtype) RETURNS int AS ‘SELECT $1.f1’ LANGUAGE SQL;
– Теперь приведение необходимо для однозначного выбора функции:
SELECT getf1(ROW(1,2.5,’this is a test’));
ОШИБКА: функция getf1(record) не уникальна
SELECT getf1(ROW(1,2.5,’this is a test’)::mytable);
getf1
——-
1
(1 row)
SELECT getf1(CAST(ROW(11,’this is a test’,2.5) AS myrowtype));
getf1
——-
11
(1 row)
Используя конструктор строк (кортежей), можно создавать составное значение для сохранения
в столбце составного типа или для передачи функции, принимающей составной параметр. Также
вы можете сравнить два составных значения или проверить их с помощью IS NULL или IS NOT
NULL, например:
SELECT ROW(1,2.5,’this is a test’) = ROW(1, 3, ‘not the same’);
43Синтаксис SQL
– выбрать все строки, содержащие только NULL
SELECT ROW(table.&lt;em&gt;) IS NULL FROM table;
Подробнее см. Раздел 9.23. Конструкторы строк также могут использоваться в сочетании с подза-
просами, как описано в Разделе 9.22.
4.2.14. Правила вычисления выражений
Порядок вычисления подвыражений не определён. В частности, аргументы оператора или функ-
ции не обязательно вычисляются слева направо или в любом другом фиксированном порядке.
Более того, если результат выражения можно получить, вычисляя только некоторые его части,
тогда другие подвыражения не будут вычисляться вовсе. Например, если написать:
SELECT true OR somefunc();
тогда функция somefunc() не будет вызываться (возможно). То же самое справедливо для записи:
SELECT somefunc() OR true;
Заметьте, что это отличается от «оптимизации» вычисления логических операторов слева напра-
во, реализованной в некоторых языках программирования.
Как следствие, в сложных выражениях не стоит использовать функции с побочными эффектами.
Особенно опасно рассчитывать на порядок вычисления или побочные эффекты в предложениях
WHERE и HAVING, так как эти предложения тщательно оптимизируются при построении плана вы-
полнения. Логические выражения (сочетания AND/OR/NOT) в этих предложениях могут быть видо-
изменены любым способом, допустимым законами Булевой алгебры.
Когда порядок вычисления важен, его можно зафиксировать с помощью конструкции CASE (см.
Раздел 9.17). Например, такой способ избежать деления на ноль в предложении WHERE ненадёжен:
SELECT … WHERE x &amp;gt; 0 AND y/x &amp;gt; 1.5;
Безопасный вариант:
SELECT … WHERE CASE WHEN x &amp;gt; 0 THEN y/x &amp;gt; 1.5 ELSE false END;
Применяемая так конструкция CASE защищает выражение от оптимизации, поэтому использовать
её нужно только при необходимости. (В данном случае было бы лучше решить проблему, переписав
условие как y &amp;gt; 1.5&lt;/em&gt;x.)
Однако, CASE не всегда спасает в подобных случаях. Показанный выше приём плох тем, что не
предотвращает раннее вычисление константных подвыражений. Как описано в Разделе 38.7, функ-
ции и операторы, помеченные как IMMUTABLE, могут вычисляться при планировании, а не выпол-
нении запроса. Поэтому в примере
SELECT CASE WHEN x &amp;gt; 0 THEN x ELSE 1/0 END FROM tab;
, скорее всего, произойдёт деление на ноль из-за того, что планировщик попытается упростить
константное подвыражение, даже если во всех строках в таблице x &amp;gt; 0, а значит во время выпол-
нения ветвь ELSE никогда не будет выполняться.
Хотя этот конкретный пример может показаться надуманным, похожие ситуации, в которых неяв-
но появляются константы, могут возникать и в запросах внутри функций, так как значения аргу-
ментов функции и локальных переменных при планировании могут быть заменены константами.
Поэтому, например, в функциях PL/pgSQL гораздо безопаснее для защиты от рискованных вычис-
лений использовать конструкцию IF-THEN-ELSE, чем выражение CASE.
Ещё один подобный недостаток этого подхода в том, что CASE не может предотвратить вычисление
заключённого в нём агрегатного выражения, так как агрегатные выражения вычисляются перед
всеми остальными в списке SELECT или предложении HAVING. Например, в следующем запросе
может возникнуть ошибка деления на ноль, несмотря на то, что он вроде бы защищён от неё:
44Синтаксис SQL
SELECT CASE WHEN min(employees) &amp;gt; 0
THEN avg(expenses / employees)
END
FROM departments;
Агрегатные функции min() и avg() вычисляются независимо по всем входным строкам, так что ес-
ли в какой-то строке поле employees окажется равным нулю, деление на ноль произойдёт раньше,
чем станет возможным проверить результат функции min(). Поэтому, чтобы проблемные входные
строки изначально не попали в агрегатную функцию, следует воспользоваться предложениями
WHERE или FILTER.
4.3. Вызов функций
PostgreSQL позволяет вызывать функции с именованными параметрами, используя запись с пози-
ционной или именной передачей аргументов. Именная передача особенно полезна для функций
со множеством параметров, так как она делает связь параметров и аргументов более явной и на-
дёжной. В позиционной записи значения аргументов функции указываются в том же порядке, в
каком они описаны в определении функции. При именной передаче аргументы сопоставляются с
параметрами функции по именам и указывать их можно в любом порядке. Для каждого варианта
вызова также учитывайте влияние типов аргументов функций, описанное в Разделе 10.3.
При записи любым способом параметры, для которых в определении функции заданы значения по
умолчанию, можно вовсе не указывать. Но это особенно полезно при именной передаче, так как
опустить можно любой набор параметров, тогда как при позиционной параметры можно опускать
только последовательно, справа налево.
PostgreSQL также поддерживает смешанную передачу, когда параметры передаются и по именам,
и по позиции. В этом случае позиционные параметры должны идти перед параметрами, передава-
емыми по именам.
Мы рассмотрим все три варианта записи на примере следующей функции:
CREATE FUNCTION concat_lower_or_upper(a text, b text,
uppercase boolean DEFAULT false)
RETURNS text
AS
&lt;script type=&quot;math/tex&quot;&gt;SELECT CASE
WHEN $3 THEN UPPER($1 || ' ' || $2)
ELSE LOWER($1 || ' ' || $2)
END;&lt;/script&gt;
LANGUAGE SQL IMMUTABLE STRICT;
Функция concat_lower_or_upper имеет два обязательных параметра: a и b. Кроме того, есть один
необязательный параметр uppercase, который по умолчанию имеет значение false. Аргументы a и
b будут сложены вместе и переведены в верхний или нижний регистр, в зависимости от параметра
uppercase. Остальные тонкости реализации функции сейчас не важны (подробнее о них рассказано
в Главе 38).
4.3.1. Позиционная передача
Позиционная передача — это традиционный механизм передачи аргументов функции в
PostgreSQL. Пример такой записи:
SELECT concat_lower_or_upper(‘Hello’, ‘World’, true);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
45Синтаксис SQL
Все аргументы указаны в заданном порядке. Результат возвращён в верхнем регистре, так как
параметр uppercase имеет значение true. Ещё один пример:
SELECT concat_lower_or_upper(‘Hello’, ‘World’);
concat_lower_or_upper
———————–
hello world
(1 row)
Здесь параметр uppercase опущен, и поэтому он принимает значение по умолчанию (false), и ре-
зультат переводится в нижний регистр. В позиционной записи любые аргументы с определённым
значением по умолчанию можно опускать справа налево.
4.3.2. Именная передача
При именной передаче для аргумента добавляется имя, которое отделяется от выражения значе-
ния знаками =&amp;gt;. Например:
SELECT concat_lower_or_upper(a =&amp;gt; ‘Hello’, b =&amp;gt; ‘World’);
concat_lower_or_upper
———————–
hello world
(1 row)
Здесь аргумент uppercase был так же опущен, так что он неявно получил значение false. Преиму-
ществом такой записи является возможность записывать аргументы в любом порядке, например:
SELECT concat_lower_or_upper(a =&amp;gt; ‘Hello’, b =&amp;gt; ‘World’, uppercase =&amp;gt; true);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
SELECT concat_lower_or_upper(a =&amp;gt; ‘Hello’, uppercase =&amp;gt; true, b =&amp;gt; ‘World’);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
Для обратной совместимости поддерживается и старый синтаксис с “:=”:
SELECT concat_lower_or_upper(a := ‘Hello’, uppercase := true, b := ‘World’);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
4.3.3. Смешанная передача
При смешанной передаче параметры передаются и по именам, и по позиции. Однако, как уже
было сказано, именованные аргументы не могут стоять перед позиционными. Например:
SELECT concat_lower_or_upper(‘Hello’, ‘World’, uppercase =&amp;gt; true);
concat_lower_or_upper
———————–
HELLO WORLD
(1 row)
В данном запросе аргументы a и b передаются по позиции, а uppercase — по имени. Единствен-
ное обоснование такого вызова здесь — он стал чуть более читаемым. Однако для более сложных
функций с множеством аргументов, часть из которых имеют значения по умолчанию, именная или
смешанная передача позволяют записать вызов эффективнее и уменьшить вероятность ошибок.
46Синтаксис SQL
Примечание
Именная и смешанная передача в настоящий момент не может использоваться при
вызове агрегатной функции (но они допускаются, если агрегатная функция использу-
ется в качестве оконной).&lt;/p&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 4. Синтаксис SQL</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 5. Определение данных</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-005/" rel="alternate" type="text/html" title="Глава 5. Определение данных" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-005</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-005/">&lt;p&gt;Глава 5. Определение данных&lt;/p&gt;

&lt;p&gt;Эта глава рассказывает, как создавать структуры базы данных, в которых будут храниться данные.
В реляционной базе данных данные хранятся в таблицах, так что большая часть этой главы будет
посвящена созданию и изменению таблиц, а также средствам управления данными в них. Затем
мы обсудим, как таблицы можно объединять в схемы и как ограничивать доступ к ним. Наконец,
мы кратко рассмотрим другие возможности, связанные с хранением данных, в частности наследо-
вание, секционирование таблиц, представления, функции и триггеры.
5.1. Основы таблиц
Таблица в реляционной базе данных похожа на таблицу на бумаге: она так же состоит из строк
и столбцов. Число и порядок столбцов фиксированы, а каждый столбец имеет имя. Число строк
переменно — оно отражает текущее количество находящихся в ней данных. SQL не даёт никаких
гарантий относительно порядка строк таблицы. При чтении таблицы строки выводятся в произ-
вольном порядке, если только явно не требуется сортировка. Подробнее это рассматривается в
Главе 7. Более того, SQL не назначает строкам уникальные идентификаторы, так что можно иметь
в таблице несколько полностью идентичных строк. Это вытекает из математической модели, кото-
рую реализует SQL, но обычно такое дублирование нежелательно. Позже в этой главе мы увидим,
как его избежать.
Каждому столбцу сопоставлен тип данных. Тип данных ограничивает набор допустимых значений,
которые можно присвоить столбцу, и определяет смысловое значение данных для вычислений.
Например, в столбец числового типа нельзя записать обычные текстовые строки, но зато его дан-
ные можно использовать в математических вычислениях. И наоборот, если столбец имеет тип тек-
стовой строки, для него допустимы практически любые данные, но он непригоден для математи-
ческих действий (хотя другие операции, например конкатенация строк, возможны).
В PostgreSQL есть внушительный набор встроенных типов данных, удовлетворяющий большин-
ство приложений. Пользователи также могут определять собственные типы данных. Большинство
встроенных типов данных имеют понятные имена и семантику, так что мы отложим их подробное
рассмотрение до Главы 8. Наиболее часто применяются следующие типы данных: integer для це-
лых чисел, numeric для чисел, которые могут быть дробными, text для текстовых строк, date для
дат, time для времени и timestamp для значений, включающих дату и время.
Для создания таблицы используется команда CREATE TABLE. В этой команде вы должны указать
как минимум имя новой таблицы и имена и типы данных каждого столбца. Например:
CREATE TABLE my_first_table (
first_column text,
second_column integer
);
Так вы создадите таблицу my_first_table с двумя столбцами. Первый столбец называется
first_column и имеет тип данных text; второй столбец называется second_column и имеет тип
integer. Имена таблицы и столбцов соответствуют синтаксису идентификаторов, описанному в
Подразделе 4.1.1. Имена типов также являются идентификаторами, хотя есть некоторые исключе-
ния. Заметьте, что список столбцов заключается в скобки, а его элементы разделяются запятыми.
Конечно, предыдущий пример ненатурален. Обычно в именах таблиц и столбцов отражается, ка-
кие данные они будут содержать. Поэтому давайте взглянем на более реалистичный пример:
CREATE TABLE products (
product_no integer,
name text,
price numeric
);
(Тип numeric может хранить дробные числа, в которых обычно выражаются денежные суммы.)
48Определение данных
Подсказка
Когда вы создаёте много взаимосвязанных таблиц, имеет смысл заранее выбрать еди-
ный шаблон именования таблиц и столбцов. Например, решить, будут ли в именах таб-
лиц использоваться существительные во множественном или в единственном числе
(есть соображения в пользу каждого варианта).
Число столбцов в таблице не может быть бесконечным. Это число ограничивается максимумом
в пределах от 250 до 1600, в зависимости от типов столбцов. Однако создавать таблицы с таким
большим числом столбцов обычно не требуется, а если такая потребность возникает, это скорее
признак сомнительного дизайна.
Если таблица вам больше не нужна, вы можете удалить её, выполнив команду DROP TABLE. На-
пример:
DROP TABLE my_first_table;
DROP TABLE products;
Попытка удаления несуществующей таблицы считается ошибкой. Тем не менее в SQL-скриптах
часто применяют безусловное удаление таблиц перед созданием, игнорируя все сообщения об
ошибках, так что они выполняют свою задачу независимо от того, существовали таблицы или нет.
(Если вы хотите избежать таких ошибок, можно использовать вариант DROP TABLE IF EXISTS, но
это не будет соответствовать стандарту SQL.)
Как изменить существующую таблицу, будет рассмотрено в этой главе позже, в Разделе 5.5.
Имея средства, которые мы обсудили, вы уже можете создавать полностью функциональные табли-
цы. В продолжении этой главы рассматриваются дополнительные возможности, призванные обес-
печить целостность данных, безопасность и удобство. Если вам не терпится наполнить свои таб-
лицы данными, вы можете вернуться к этой главе позже, а сейчас перейти к Главе 6.
5.2. Значения по умолчанию
Столбцу можно назначить значение по умолчанию. Когда добавляется новая строка и каким-то
её столбцам не присваиваются значения, эти столбцы принимают значения по умолчанию. Также
команда управления данными может явно указать, что столбцу должно быть присвоено значение
по умолчанию, не зная его. (Подробнее команды управления данными описаны в Главе 6.)
Если значение по умолчанию не объявлено явно, им считается значение NULL. Обычно это имеет
смысл, так как можно считать, что NULL представляет неизвестные данные.
В определении таблицы значения по умолчанию указываются после типа данных столбца. Напри-
мер:
CREATE TABLE products (
product_no integer,
name text,
price numeric DEFAULT 9.99
);
Значение по умолчанию может быть выражением, которое в этом случае вычисляется в мо-
мент присваивания значения по умолчанию (а не когда создаётся таблица). Например, столбцу
timestamp в качестве значения по умолчания часто присваивается CURRENT_TIMESTAMP, чтобы в
момент добавления строки в нём оказалось текущее время. Ещё один распространённый пример
— генерация «последовательных номеров» для всех строк. В PostgreSQL это обычно делается при-
мерно так:
CREATE TABLE products (
product_no integer DEFAULT nextval(‘products_product_no_seq’),
49Определение данных
…
);
здесь функция nextval() выбирает очередное значение из последовательности (см. Раздел 9.16).
Это употребление настолько распространено, что для него есть специальная короткая запись:
CREATE TABLE products (
product_no SERIAL,
…
);
SERIAL обсуждается позже в Подразделе 8.1.4.
5.3. Ограничения
Типы данных сами по себе ограничивают множество данных, которые можно сохранить в таблице.
Однако для многих приложений такие ограничения слишком грубые. Например, столбец, содер-
жащий цену продукта, должен, вероятно, принимать только положительные значения. Но такого
стандартного типа данных нет. Возможно, вы также захотите ограничить данные столбца по от-
ношению к другим столбцам или строкам. Например, в таблице с информацией о товаре должна
быть только одна строка с определённым кодом товара.
Для решения подобных задач SQL позволяет вам определять ограничения для столбцов и таб-
лиц. Ограничения дают вам возможность управлять данными в таблицах так, как вы захотите. Ес-
ли пользователь попытается сохранить в столбце значение, нарушающее ограничения, возникнет
ошибка. Ограничения будут действовать, даже если это значение по умолчанию.
5.3.1. Ограничения-проверки
Ограничение-проверка — наиболее общий тип ограничений. В его определении вы можете ука-
зать, что значение данного столбца должно удовлетворять логическому выражению (проверке ис-
тинности). Например, цену товара можно ограничить положительными значениями так:
CREATE TABLE products (
product_no integer,
name text,
price numeric CHECK (price &amp;gt; 0)
);
Как вы видите, ограничение определяется после типа данных, как и значение по умолчанию. Зна-
чения по умолчанию и ограничения могут указываться в любом порядке. Ограничение-проверка
состоит из ключевого слова CHECK, за которым идёт выражение в скобках. Это выражение должно
включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла.
Вы можете также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и
позволит вам ссылаться на это ограничение, когда вам понадобится изменить его. Сделать это
можно так:
CREATE TABLE products (
product_no integer,
name text,
price numeric CONSTRAINT positive_price CHECK (price &amp;gt; 0)
);
То есть, чтобы создать именованное ограничение, напишите ключевое слово CONSTRAINT, а за ним
идентификатор и собственно определение ограничения. (Если вы не определите имя ограничения
таким образом, система выберет для него имя за вас.)
Ограничение-проверка может также ссылаться на несколько столбцов. Например, если вы храните
обычную цену и цену со скидкой, так вы можете гарантировать, что цена со скидкой будет всегда
меньше обычной:
50Определение данных
CREATE TABLE products (
product_no integer,
name text,
price numeric CHECK (price &amp;gt; 0),
discounted_price numeric CHECK (discounted_price &amp;gt; 0),
CHECK (price &amp;gt; discounted_price)
);
Первые два ограничения определяются похожим образом, но для третьего используется новый
синтаксис. Оно не связано с определённым столбцом, а представлено отдельным элементом в спис-
ке. Определения столбцов и такие определения ограничений можно переставлять в произвольном
порядке.
Про первые два ограничения можно сказать, что это ограничения столбцов, тогда как третье яв-
ляется ограничением таблицы, так как оно написано отдельно от определений столбцов. Ограни-
чения столбцов также можно записать в виде ограничений таблицы, тогда как обратное не все-
гда возможно, так как подразумевается, что ограничение столбца ссылается только на связанный
столбец. (Хотя PostgreSQL этого не требует, но для совместимости с другими СУБД лучше следо-
вать это правилу.) Ранее приведённый пример можно переписать и так:
CREATE TABLE products (
product_no integer,
name text,
price numeric,
CHECK (price &amp;gt; 0),
discounted_price numeric,
CHECK (discounted_price &amp;gt; 0),
CHECK (price &amp;gt; discounted_price)
);
Или даже так:
CREATE TABLE products (
product_no integer,
name text,
price numeric CHECK (price &amp;gt; 0),
discounted_price numeric,
CHECK (discounted_price &amp;gt; 0 AND price &amp;gt; discounted_price)
);
Это дело вкуса.
Ограничениям таблицы можно присваивать имена так же, как и ограничениям столбцов:
CREATE TABLE products (
product_no integer,
name text,
price numeric,
CHECK (price &amp;gt; 0),
discounted_price numeric,
CHECK (discounted_price &amp;gt; 0),
CONSTRAINT valid_discount CHECK (price &amp;gt; discounted_price)
);
Следует заметить, что ограничение-проверка удовлетворяется, если выражение принимает зна-
чение true или NULL. Так как результатом многих выражений с операндами NULL будет значе-
ние NULL, такие ограничения не будут препятствовать записи NULL в связанные столбцы. Чтобы
гарантировать, что столбец не содержит значения NULL, можно использовать ограничение NOT
NULL, описанное в следующем разделе.
5.3.2. Ограничения NOT NULL
51Определение данных
Ограничение NOT NULL просто указывает, что столбцу нельзя присваивать значение NULL. При-
мер синтаксиса:
CREATE TABLE products (
product_no integer NOT NULL,
name text NOT NULL,
price numeric
);
Ограничение NOT NULL всегда записывается как ограничение столбца и функционально эквива-
лентно ограничению CHECK (имя_столбца IS NOT NULL), но в PostgreSQL явное ограничение NOT
NULL работает более эффективно. Хотя у такой записи есть недостаток — назначить имя таким
ограничениям нельзя.
Естественно, для столбца можно определить больше одного ограничения. Для этого их нужно про-
сто указать одно за другим:
CREATE TABLE products (
product_no integer NOT NULL,
name text NOT NULL,
price numeric NOT NULL CHECK (price &amp;gt; 0)
);
Порядок здесь не имеет значения, он не обязательно соответствует порядку проверки ограниче-
ний.
Для ограничения NOT NULL есть и обратное: ограничение NULL. Оно не означает, что столбец дол-
жен иметь только значение NULL, что конечно было бы бессмысленно. Суть же его в простом ука-
зании, что столбец может иметь значение NULL (это поведение по умолчанию). Ограничение NULL
отсутствует в стандарте SQL и использовать его в переносимых приложениях не следует. (Оно бы-
ло добавлено в PostgreSQL только для совместимости с некоторыми другими СУБД.) Однако неко-
торые пользователи любят его использовать, так как оно позволяет легко переключать ограниче-
ния в скрипте. Например, вы можете начать с:
CREATE TABLE products (
product_no integer NULL,
name text NULL,
price numeric NULL
);
и затем вставить ключевое слово NOT, где потребуется.
Подсказка
При проектировании баз данных чаще всего большинство столбцов должны быть по-
мечены как NOT NULL.
5.3.3. Ограничения уникальности
Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов
уникальны среди всех строк таблицы. Ограничение записывается так:
CREATE TABLE products (
product_no integer UNIQUE,
name text,
price numeric
);
в виде ограничения столбца и так:
52Определение данных
CREATE TABLE products (
product_no integer,
name text,
price numeric,
UNIQUE (product_no)
);
в виде ограничения таблицы.
Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограни-
чения таблицы, перечислив имена столбцов через запятую:
CREATE TABLE example (
a integer,
b integer,
c integer,
UNIQUE (a, c)
);
Такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уни-
кально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и
обычно не будут) уникальными.
Вы можете назначить уникальному ограничению имя обычным образом:
CREATE TABLE products (
product_no integer CONSTRAINT must_be_different UNIQUE,
name text,
price numeric
);
При добавлении ограничения уникальности будет автоматически создан уникальный индекс-B-
дерево для столбца или группы столбцов, перечисленных в ограничении. Условие уникальности,
распространяющееся только на некоторые строки, нельзя записать в виде ограничения уникаль-
ности, однако такое условие можно установить, создав уникальный частичный индекс.
Вообще говоря, ограничение уникальности нарушается, если в таблице оказывается несколько
строк, у которых совпадают значения всех столбцов, включённых в ограничение. Однако два зна-
чения NULL при сравнении никогда не считаются равными. Это означает, что даже при наличии
ограничения уникальности в таблице можно сохранить строки с дублирующимися значениями,
если они содержат NULL в одном или нескольких столбцах ограничения. Это поведение соответ-
ствует стандарту SQL, но мы слышали о СУБД, которые ведут себя по-другому. Имейте в виду эту
особенность, разрабатывая переносимые приложения.
5.3.4. Первичные ключи
Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может
быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были
одновременно уникальными и отличными от NULL. Таким образом, таблицы со следующими двумя
определениями будут принимать одинаковые данные:
CREATE TABLE products (
product_no integer UNIQUE NOT NULL,
name text,
price numeric
);
CREATE TABLE products (
product_no integer PRIMARY KEY,
name text,
price numeric
53Определение данных
);
Первичные ключи могут включать несколько столбцов; синтаксис похож на запись ограничений
уникальности:
CREATE TABLE example (
a integer,
b integer,
c integer,
PRIMARY KEY (a, c)
);
При добавлении первичного ключа автоматически создаётся уникальный индекс-B-дерево для
столбца или группы столбцов, перечисленных в первичном ключе, и данные столбцы помечаются
как NOT NULL.
Таблица может иметь максимум один первичный ключ. (Ограничений уникальности и ограни-
чений NOT NULL, которые функционально почти равнозначны первичным ключам, может быть
сколько угодно, но назначить ограничением первичного ключа можно только одно.) Теория реля-
ционных баз данных говорит, что первичный ключ должен быть в каждой таблице. В PostgreSQL
такого жёсткого требования нет, но обычно лучше ему следовать.
Первичные ключи полезны и для документирования, и для клиентских приложений. Например,
графическому приложению с возможностями редактирования содержимого таблицы, вероятно,
потребуется знать первичный ключ таблицы, чтобы однозначно идентифицировать её строки. Пер-
вичные ключи находят и другое применение в СУБД; в частности, первичный ключ в таблице опре-
деляет целевые столбцы по умолчанию для сторонних ключей, ссылающихся на эту таблицу.
5.3.5. Внешние ключи
Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны со-
ответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целост-
ностью двух связанных таблиц.
Пусть у вас уже есть таблица продуктов, которую мы неоднократно использовали ранее:
CREATE TABLE products (
product_no integer PRIMARY KEY,
name text,
price numeric
);
Давайте предположим, что у вас есть таблица с заказами этих продуктов. Мы хотим, чтобы в таб-
лице заказов содержались только заказы действительно существующих продуктов. Поэтому мы
определим в ней ограничение внешнего ключа, ссылающееся на таблицу продуктов:
CREATE TABLE orders (
order_id integer PRIMARY KEY,
product_no integer REFERENCES products (product_no),
quantity integer
);
С таким ограничением создать заказ со значением product_no, отсутствующим в таблице products
(и не равным NULL), будет невозможно.
В такой схеме таблицу orders называют подчинённой таблицей, а products — главной. Соответ-
ственно, столбцы называют так же подчинённым и главным (или ссылающимся и целевым).
Предыдущую команду можно сократить так:
CREATE TABLE orders (
order_id integer PRIMARY KEY,
54Определение данных
product_no integer REFERENCES products,
quantity integer
);
то есть, если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом
главной таблицы.
Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в
виде обычного ограничения таблицы. Например:
CREATE TABLE t1 (
a integer PRIMARY KEY,
b integer,
c integer,
FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
Естественно, число и типы столбцов в ограничении должны соответствовать числу и типам целе-
вых столбцов.
Ограничению внешнего ключа можно назначить имя стандартным способом.
Таблица может содержать несколько ограничений внешнего ключа. Это полезно для связи таблиц
в отношении многие-ко-многим. Скажем, у вас есть таблицы продуктов и заказов, но вы хотите,
чтобы один заказ мог содержать несколько продуктов (что невозможно в предыдущей схеме). Для
этого вы можете использовать такую схему:
CREATE TABLE products (
product_no integer PRIMARY KEY,
name text,
price numeric
);
CREATE TABLE orders (
order_id integer PRIMARY KEY,
shipping_address text,
…
);
CREATE TABLE order_items (
product_no integer REFERENCES products,
order_id integer REFERENCES orders,
quantity integer,
PRIMARY KEY (product_no, order_id)
);
Заметьте, что в последней таблице первичный ключ покрывает внешние ключи.
Мы знаем, что внешние ключи запрещают создание заказов, не относящихся ни к одному продук-
ту. Но что делать, если после создания заказов с определённым продуктом мы захотим удалить
его? SQL справится с этой ситуацией. Интуиция подсказывает следующие варианты поведения:
• Запретить удаление продукта
• Удалить также связанные заказы
• Что-то ещё?
Для иллюстрации давайте реализуем следующее поведение в вышеприведённом примере: при по-
пытке удаления продукта, на который ссылаются заказы (через таблицу order_items), мы запре-
щаем эту операцию. Если же кто-то попытается удалить заказ, то удалится и его содержимое:
CREATE TABLE products (
product_no integer PRIMARY KEY,
55Определение данных
name text,
price numeric
);
CREATE TABLE orders (
order_id integer PRIMARY KEY,
shipping_address text,
…
);
CREATE TABLE order_items (
product_no integer REFERENCES products ON DELETE RESTRICT,
order_id integer REFERENCES orders ON DELETE CASCADE,
quantity integer,
PRIMARY KEY (product_no, order_id)
);
Ограничивающие и каскадные удаления — два наиболее распространённых варианта. RESTRICT
предотвращает удаление связанной строки. NO ACTION означает, что если зависимые строки про-
должают существовать при проверке ограничения, возникает ошибка (это поведение по умолча-
нию). (Главным отличием этих двух вариантов является то, что NO ACTION позволяет отложить про-
верку в процессе транзакции, а RESTRICT — нет.) CASCADE указывает, что при удалении связанных
строк зависимые от них будут так же автоматически удалены. Есть ещё два варианта: SET NULL
и SET DEFAULT. При удалении связанных строк они назначают зависимым столбцам в подчинён-
ной таблице значения NULL или значения по умолчанию, соответственно. Заметьте, что это не
будет основанием для нарушения ограничений. Например, если в качестве действия задано SET
DEFAULT, но значение по умолчанию не удовлетворяет ограничению внешнего ключа, операция
закончится ошибкой.
Аналогично указанию ON DELETE существует ON UPDATE, которое срабатывает при изменении за-
данного столбца. При этом возможные действия те же, а CASCADE в данном случае означает, что
изменённые значения связанных столбцов будут скопированы в зависимые строки.
Обычно зависимая строка не должна удовлетворять ограничению внешнего ключа, если один из
связанных столбцов содержит NULL. Если в объявление внешнего ключа добавлено MATCH FULL,
строка будет удовлетворять ограничению, только если все связанные столбцы равны NULL (то
есть при разных значениях (NULL и не NULL) гарантируется невыполнение ограничения MATCH
FULL). Если вы хотите, чтобы зависимые строки не могли избежать и этого ограничения, объявите
связанные столбцы как NOT NULL.
Внешний ключ должен ссылаться на столбцы, образующие первичный ключ или ограничение уни-
кальности. Таким образом, для связанных столбцов всегда будет существовать индекс (определён-
ный соответствующим первичным ключом или ограничением), а значит проверки соответствия
связанной строки будут выполняться эффективно. Так как команды DELETE для строк главной таб-
лицы или UPDATE для зависимых столбцов потребуют просканировать подчинённую таблицу и най-
ти строки, ссылающиеся на старые значения, полезно будет иметь индекс и для подчинённых
столбцов. Но это нужно не всегда, и создать соответствующий индекс можно по-разному, поэтому
объявление внешнего ключа не создаёт автоматически индекс по связанным столбцам.
Подробнее об изменении и удалении данных рассказывается в Главе 6. Вы также можете подроб-
нее узнать о синтаксисе ограничений внешнего ключа в справке CREATE TABLE.
5.3.6. Ограничения-исключения
Ограничения-исключения гарантируют, что при сравнении любых двух строк по указанным столб-
цам или выражениям с помощью заданных операторов, минимум одно из этих сравнений возвра-
тит false или NULL. Записывается это так:
CREATE TABLE circles (
56Определение данных
c circle,
EXCLUDE USING gist (c WITH &amp;amp;&amp;amp;)
);
Подробнее об этом см. CREATE TABLE … CONSTRAINT … EXCLUDE.
При добавлении ограничения-исключения будет автоматически создан индекс того типа, который
указан в объявлении ограничения.
5.4. Системные столбцы
В каждой таблице есть несколько системных столбцов, неявно определённых системой. Как след-
ствие, их имена нельзя использовать в качестве имён пользовательских столбцов. (Заметьте, что
это не зависит от того, является ли имя ключевым словом или нет; заключение имени в кавычки
не поможет избежать этого ограничения.) Эти столбцы не должны вас беспокоить, вам лишь до-
статочно знать об их существовании.
oid
Идентификатор объекта (object ID) для строки. Этот столбец присутствует, только если таблица
была создана с указанием WITH OIDS, или если в момент её создания была установлена пере-
менная конфигурации default_with_oids. Этот столбец имеет тип oid (с тем же именем, что и
сам столбец); подробнее об этом типе см. Раздел 8.19.
tableoid
Идентификатор объекта для таблицы, содержащей строку. Этот столбец особенно полезен для
запросов, имеющих дело с иерархией наследования (см. Раздел  5.9), так как без него слож-
но определить, из какой таблицы выбрана строка. Связав tableoid со столбцом oid в таблице
pg_class, можно будет получить имя таблицы.
xmin
Идентификатор (код) транзакции, добавившей строку этой версии. (Версия строки — это её
индивидуальное состояние; при каждом изменении создаётся новая версия одной и той же
логической строки.)
cmin
Номер команды (начиная с нуля) внутри транзакции, добавившей строку.
xmax
Идентификатор транзакции, удалившей строку, или 0 для неудалённой версии строки. Значе-
ние этого столбца может быть ненулевым и для видимой версии строки. Это обычно означает,
что удаляющая транзакция ещё не была зафиксирована, или удаление было отменено.
cmax
Номер команды в удаляющей транзакции или ноль.
ctid
Физическое расположение данной версии строки в таблице. Заметьте, что хотя по ctid можно
очень быстро найти версию строки, значение ctid изменится при выполнении VACUUM FULL.
Таким образом, ctid нельзя применять в качестве долгосрочного идентификатора строки. Для
идентификации логических строк лучше использовать OID или даже дополнительный последо-
вательный номер.
Коды OID представляют собой 32-битные значения и выбираются из единого для всей СУБД счёт-
чика. В больших или долгоживущих базах данных этот счётчик может пойти по кругу. Таким об-
57Определение данных
разом, не рекомендуется рассчитывать на уникальность OID, если только вы не обеспечите её до-
полнительно. Если вам нужно идентифицировать строки таблицы, настоятельно рекомендуется
использовать последовательности. Однако можно использовать и коды OID, при выполнении сле-
дующих условий:
• Когда для идентификации строк таблиц применяется OID, в каждой такой таблице должно со-
здаваться ограничение уникальности для столбца OID. Когда такое ограничение уникально-
сти (или уникальный индекс) существует, система позаботится о том, чтобы OID новой строки
32
не совпал с уже существующими. (Конечно, это возможно, только если в таблице меньше 2
(4 миллиардов) строк, а на практике таблицы должны быть гораздо меньше, иначе может по-
страдать производительность системы.)
• Никогда не следует рассчитывать, что OID будут уникальны среди всех таблиц; в качестве
глобального идентификатора в рамках базы данных используйте комбинацию tableoid и OID
строки.
• Конечно, все эти таблицы должны быть созданы с указанием WITH OIDS. В PostgreSQL 8.1 и
новее по умолчанию подразумевается WITHOUT OIDS.
Идентификаторы транзакций также являются 32-битными. В долгоживущей базе данных они мо-
гут пойти по кругу. Это не критично при правильном обслуживании БД; подробнее об этом см.
Главу 24. Однако полагаться на уникальность кодов транзакций в течение длительного времени
(при более чем миллиарде транзакций) не следует.
32
Идентификаторы команд также 32-битные. Это создаёт жёсткий лимит на 2 (4 миллиарда) ко-
манд SQL в одной транзакции. На практике это не проблема — заметьте, что это лимит числа ко-
манд SQL, а не количества обрабатываемых строк. Кроме того, идентификатор получают только
те команды, которые фактически изменяют содержимое базы данных.
5.5. Изменение таблиц
Если вы создали таблицы, а затем поняли, что допустили ошибку, или изменились требования
вашего приложения, вы можете удалить её и создать заново. Но это будет неудобно, если табли-
ца уже заполнена данными, или если на неё ссылаются другие объекты базы данных (например,
по внешнему ключу). Поэтому PostgreSQL предоставляет набор команд для модификации таблиц.
Заметьте, что это по сути отличается от изменения данных, содержащихся в таблице: здесь мы
обсуждаем модификацию определения, или структуры, таблицы.
Вы можете:
•
•
•
•
•
•
•
•
Добавлять столбцы
Удалять столбцы
Добавлять ограничения
Удалять ограничения
Изменять значения по умолчанию
Изменять типы столбцов
Переименовывать столбцы
Переименовывать таблицы
Все эти действия выполняются с помощью команды ALTER TABLE; подробнее о ней вы можете
узнать в её справке.
5.5.1. Добавление столбца
Добавить столбец вы можете так:
ALTER TABLE products ADD COLUMN description text;
Новый столбец заполняется заданным для него значением по умолчанию (или значением NULL,
если вы не добавите указание DEFAULT).
58Определение данных
При этом вы можете сразу определить ограничения столбца, используя обычный синтаксис:
ALTER TABLE products ADD COLUMN description text CHECK (description &amp;lt;&amp;gt; ‘’);
На самом деле здесь можно использовать все конструкции, допустимые в определении столбца в
команде CREATE TABLE. Помните однако, что значение по умолчанию должно удовлетворять дан-
ным ограничениям, чтобы операция ADD выполнилась успешно. Вы также можете сначала запол-
нить столбец правильно, а затем добавить ограничения (см. ниже).
Подсказка
Добавление столбца со значением по умолчанию приводит к изменению всех строк
таблицы (в них будет сохранено новое значение). Однако, если значение по умолчанию
не указано, PostgreSQL может обойтись без физического изменения. Поэтому, если вы
планируете заполнить столбец в основном не значениями по умолчанию, лучше будет
добавить столбец без значения по умолчанию, затем вставить требуемые значения с
помощью UPDATE, а потом определить значение по умолчанию, как описано ниже.
5.5.2. Удаление столбца
Удалить столбец можно так:
ALTER TABLE products DROP COLUMN description;
Данные, которые были в этом столбце, исчезают. Вместе со столбцом удаляются и включающие его
ограничения таблицы. Однако, если на столбец ссылается ограничение внешнего ключа другой
таблицы, PostgreSQL не удалит это ограничение неявно. Разрешить удаление всех зависящих от
этого столбца объектов можно, добавив указание CASCADE:
ALTER TABLE products DROP COLUMN description CASCADE;
Общий механизм, стоящий за этим, описывается в Разделе 5.13.
5.5.3. Добавление ограничения
Для добавления ограничения используется синтаксис ограничения таблицы. Например:
ALTER TABLE products ADD CHECK (name &amp;lt;&amp;gt; ‘’);
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id)
REFERENCES product_groups;
Чтобы добавить ограничение NOT NULL, которое нельзя записать в виде ограничения таблицы,
используйте такой синтаксис:
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
Ограничение проходит проверку автоматически и будет добавлено, только если ему удовлетворя-
ют данные таблицы.
5.5.4. Удаление ограничения
Для удаления ограничения вы должны знать его имя. Если вы не присваивали ему имя, это неявно
сделала система, и вы должны выяснить его. Здесь может быть полезна команда psql \d имя_таб-
лицы (или другие программы, показывающие подробную информацию о таблицах). Зная имя, вы
можете использовать команду:
ALTER TABLE products DROP CONSTRAINT some_name;
(Если вы имеете дело с именем ограничения вида $2, не забудьте заключить его в кавычки, чтобы
это был допустимый идентификатор.)
59Определение данных
Как и при удалении столбца, если вы хотите удалить ограничение с зависимыми объектами, до-
бавьте указание CASCADE. Примером такой зависимости может быть ограничение внешнего ключа,
связанное со столбцами ограничения первичного ключа.
Так можно удалить ограничения любых типов, кроме NOT NULL. Чтобы удалить ограничение NOT
NULL, используйте команду:
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
(Вспомните, что у ограничений NOT NULL нет имён.)
5.5.5. Изменение значения по умолчанию
Назначить столбцу новое значение по умолчанию можно так:
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
Заметьте, что это никак не влияет на существующие строки таблицы, а просто задаёт значение по
умолчанию для последующих команд INSERT.
Чтобы удалить значение по умолчанию, выполните:
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
При этом по сути значению по умолчанию просто присваивается NULL. Как следствие, ошибки
не будет, если вы попытаетесь удалить значение по умолчанию, не определённое явно, так как
неявно оно существует и равно NULL.
5.5.6. Изменение типа данных столбца
Чтобы преобразовать столбец в другой тип данных, используйте команду:
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
Она будет успешна, только если все существующие значения в столбце могут быть неявно приве-
дены к новому типу. Если требуется более сложное преобразование, вы можете добавить указание
USING, определяющее, как получить новые значения из старых.
PostgreSQL попытается также преобразовать к новому типу значение столбца по умолчанию (ес-
ли оно определено) и все связанные с этим столбцом ограничения. Но преобразование может ока-
заться неправильным, и тогда вы получите неожиданные результаты. Поэтому обычно лучше уда-
лить все ограничения столбца, перед тем как менять его тип, а затем воссоздать модифицирован-
ные должным образом ограничения.
5.5.7. Переименование столбца
Чтобы переименовать столбец, выполните:
ALTER TABLE products RENAME COLUMN product_no TO product_number;
5.5.8. Переименование таблицы
Таблицу можно переименовать так:
ALTER TABLE products RENAME TO items;
5.6. Права
Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится
роль, с которой был выполнен оператор создания. Для большинства типов объектов в исходном со-
стоянии только владелец (или суперпользователь) может делать с объектом всё, что угодно. Чтобы
разрешить использовать его другим ролям, нужно дать им права.
Существует несколько типов прав: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER,
CREATE, CONNECT, TEMPORARY, EXECUTE и USAGE. Набор прав, применимых к определённому объекту,
60Определение данных
зависит от типа объекта (таблица, функция и т. д.) Полную информацию о различных типах прав,
поддерживаемых PostgreSQL, вы найдете на странице справки GRANT. Вы также увидите, как при-
меняются эти права, в следующих разделах и главах.
Неотъемлемое право изменять или удалять объект имеет только владелец объекта.
Объекту можно назначить нового владельца с помощью команды ALTER для соответствующего типа
объекта, например ALTER TABLE. Суперпользователь может делать это без ограничений, а обыч-
ный пользователь, только если он является одновременно текущим владельцем объекта (или чле-
ном роли владельца) и членом новой роли.
Для назначения прав применяется команда GRANT. Например, если в базе данных есть роль joe и
таблица accounts, право на изменение таблицы можно дать этой роли так:
GRANT UPDATE ON accounts TO joe;
Если вместо конкретного права написать ALL, роль получит все права, применимые для объекта
этого типа.
Для назначения права всем ролям в системе можно использовать специальное имя «роли»: PUBLIC.
Также для упрощения управления ролями, когда в базе данных есть множество пользователей,
можно настроить «групповые» роли; подробнее об этом см. Главу 21.
Чтобы лишить пользователей прав, используйте команду REVOKE:
REVOKE ALL ON accounts FROM PUBLIC;
Особые права владельца объекта (то есть права на выполнение DROP, GRANT, REVOKE и т. д.) всегда
неявно закреплены за владельцем и их нельзя назначить или отобрать. Но владелец объекта может
лишить себя обычных прав, например, разрешить всем, включая себя, только чтение таблицы.
Обычно распоряжаться правами может только владелец объекта (или суперпользователь). Однако
возможно дать право доступа к объекту «с правом передачи», что позволит получившему такое
право назначать его другим. Если такое право передачи впоследствии будет отозвано, то все, кто
получил данное право доступа (непосредственно или по цепочке передачи), потеряют его. Подроб-
нее об этом см. справку GRANT и REVOKE.
5.7. Политики защиты строк
В дополнение к стандартной системе прав SQL, управляемой командой GRANT, на уровне таблиц
можно определить политики защиты строк, ограничивающие для пользователей наборы строк,
которые могут быть возвращены обычными запросами или добавлены, изменены и удалены коман-
дами, изменяющими данные. Это называется также защитой на уровне строк (RLS, Row-Level
Security). По умолчанию таблицы не имеют политик, так что если система прав SQL разрешает
пользователю доступ к таблице, все строки в ней одинаково доступны для чтения или изменения.
Когда для таблицы включается защита строк (с помощью команды ALTER TABLE … ENABLE ROW
LEVEL SECURITY), все обычные запросы к таблице на выборку или модификацию строк должны
разрешаться политикой защиты строк. (Однако на владельца таблицы такие политики обычно не
действуют.) Если политика для таблицы не определена, применяется политика запрета по умол-
чанию, так что никакие строки в этой таблице нельзя увидеть или модифицировать. На операции
с таблицей в целом, такие как TRUNCATE и REFERENCES, защита строк не распространяется.
Политики защиты строк могут применяться к определённым командам и/или ролям. Политику
можно определить как применяемую к командам ALL (всем), либо SELECT, INSERT, UPDATE и DELETE.
Кроме того, политику можно связать с несколькими ролями, при этом действуют обычные правила
членства и наследования.
Чтобы определить, какие строки будут видимыми или могут изменяться в таблице, для политики
задаётся выражение, возвращающее логический результат. Это выражение будет вычисляться для
каждой строки перед другими условиями или функциями, поступающими из запроса пользовате-
ля. (Единственным исключением из этого правила являются герметичные функции, которые гаран-
61Определение данных
тированно не допускают утечки информации; оптимизатор может решить выполнить эти функции
до проверок защиты строк.) Строки, для которых это выражение возвращает не true, обрабаты-
ваться не будут. Чтобы независимо управлять набором строк, которые можно видеть, и набором
строк, которые можно модифицировать, в политике можно задать отдельные выражения. Выраже-
ния политик обрабатываются в составе запроса с правами исполняющего его пользователя, но для
обращения к данным, недоступным этому пользователю, в этих выражениях могут применяться
функции, определяющие контекст безопасности.
Суперпользователи и роли с атрибутом BYPASSRLS всегда обращаются к таблице, минуя систему
защиты строк. На владельца таблицы защита строк тоже не действует, хотя он может включить её
для себя принудительно, выполнив команду ALTER TABLE … FORCE ROW LEVEL SECURITY.
Неотъемлемое право включать или отключать защиту строк, а также определять политики для
таблицы, имеет только её владелец.
Для создания политик предназначена команда CREATE POLICY, для изменения — ALTER POLICY,
а для удаления — DROP POLICY. Чтобы включить или отключить защиту строк для определённой
таблицы, воспользуйтесь командой ALTER TABLE.
Каждой политике назначается имя, при этом для одной таблицы можно определить несколько
политик. Так как политики привязаны к таблицам, каждая политика для таблицы должна иметь
уникальное имя. В разных таблицах политики могут иметь одинаковые имена.
Когда к определённому запросу применяются несколько политик, они объединяются либо логиче-
ским сложением (если политики разрешительные (по умолчанию)), либо умножением (если поли-
тики ограничительные). Это подобно тому, как некоторая роль получает права всех ролей, в кото-
рые она включена. Разрешительные и ограничительные политики рассматриваются ниже.
В качестве простого примера, создать политику для отношения account, позволяющую только чле-
нам роли managers обращаться к строкам отношения и при этом только к своим, можно так:
CREATE TABLE accounts (manager text, company text, contact_email text);
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
CREATE POLICY account_managers ON accounts TO managers
USING (manager = current_user);
Эта политика неявно подразумевает и предложение WITH CHECK, идентичное предложению USING,
поэтому указанное ограничение применяется и к строкам, выбираемым командой (так что один
менеджер не может выполнить SELECT, UPDATE или DELETE для существующих строк, принадлежа-
щих другому), и к строкам, изменяемым командой (так что командами INSERT и UPDATE нельзя со-
здать строки, принадлежащие другому менеджеру).
Если роль не задана, либо задано специальное имя пользователя PUBLIC, политика применяется
ко всем пользователям в данной системе. Чтобы все пользователи могли обратиться только к соб-
ственной строке в таблице users, можно применить простую политику:
CREATE POLICY user_policy ON users
USING (user_name = current_user);
Это работает подобно предыдущему примеру.
Чтобы определить для строк, добавляемых в таблицу, отдельную политику, отличную от политики,
ограничивающей видимые строки, можно скомбинировать несколько политик. Следующая пара
политик позволит всем пользователям видеть все строки в таблице users, но изменять только свою
собственную:
CREATE POLICY user_sel_policy ON users
FOR SELECT
USING (true);
62Определение данных
CREATE POLICY user_mod_policy ON users
USING (user_name = current_user);
Для команды SELECT эти две политики объединяются операцией OR, так что в итоге это позволяет
выбирать все строки. Для команд других типов применяется только вторая политика, и эффект тот
же, что и раньше.
Защиту строк можно отключить так же командой ALTER TABLE. При отключении защиты, политики,
определённые для таблицы, не удаляются, а просто игнорируются. В результате в таблице будут
видны и могут модифицироваться все строки, с учётом ограничений стандартной системы прав
SQL.
Ниже показан развёрнутый пример того, как этот механизм защиты можно применять в производ-
ственной среде. Таблица passwd имитирует файл паролей в Unix:
– Простой пример на базе файла passwd
CREATE TABLE passwd (
user_name
text UNIQUE NOT NULL,
pwhash
text,
uid
int PRIMARY KEY,
gid
int NOT NULL,
real_name
text NOT NULL,
home_phone
text,
extra_info
text,
home_dir
text NOT NULL,
shell
text NOT NULL
);
CREATE ROLE admin;
CREATE ROLE bob;
CREATE ROLE alice;
– Администратор
– Обычный пользователь
– Обычный пользователь
– Наполнение таблицы
INSERT INTO passwd VALUES
(‘admin’,’xxx’,0,0,’Admin’,’111-222-3333’,null,’/root’,’/bin/dash’);
INSERT INTO passwd VALUES
(‘bob’,’xxx’,1,1,’Bob’,’123-456-7890’,null,’/home/bob’,’/bin/zsh’);
INSERT INTO passwd VALUES
(‘alice’,’xxx’,2,1,’Alice’,’098-765-4321’,null,’/home/alice’,’/bin/zsh’);
– Необходимо включить для этой таблицы защиту на уровне строк
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
– Создание политик
– Администратор может видеть и добавлять любые строки
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
– Обычные пользователи могут видеть все строки
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
– Обычные пользователи могут изменять собственные данные, но
– не могут задать произвольную оболочку входа
CREATE POLICY user_mod ON passwd FOR UPDATE
USING (current_user = user_name)
WITH CHECK (
current_user = user_name AND
shell IN (‘/bin/bash’,’/bin/sh’,’/bin/dash’,’/bin/zsh’,’/bin/tcsh’)
);
– Администраторы получают все обычные права
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
63Определение данных
– Пользователям разрешается чтение только общедоступных столбцов
GRANT SELECT
(user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
ON passwd TO public;
– Пользователям разрешается изменение определённых столбцов
GRANT UPDATE
(pwhash, real_name, home_phone, extra_info, shell)
ON passwd TO public;
Как и любые средства защиты, важно проверить политики, и убедиться в том, что они работают
ожидаемым образом. Применительно к предыдущему примеру, эти команды показывают, что си-
стема разрешений работает корректно.
– Администратор может видеть все строки и поля
postgres=&amp;gt; set role admin;
SET
postgres=&amp;gt; table passwd;
user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir
|
shell
———–+——–+—–+—–+———–+————–+————+————-
+———–
admin
| xxx
|
0 |
0 | Admin
| 111-222-3333 |
| /root
| /bin/dash
bob
| xxx
|
1 |
1 | Bob
| 123-456-7890 |
| /home/bob
| /bin/zsh
alice
| xxx
|
2 |
1 | Alice
| 098-765-4321 |
| /home/alice
| /bin/zsh
(3 rows)
– Проверим, что может делать Алиса
postgres=&amp;gt; set role alice;
SET
postgres=&amp;gt; table passwd;
ERROR: permission denied for relation passwd
postgres=&amp;gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
user_name | real_name | home_phone | extra_info | home_dir
|
shell
———–+———–+————–+————+————-+———–
admin
| Admin
| 111-222-3333 |
| /root
| /bin/dash
bob
| Bob
| 123-456-7890 |
| /home/bob
| /bin/zsh
alice
| Alice
| 098-765-4321 |
| /home/alice | /bin/zsh
(3 rows)
postgres=&amp;gt; update passwd set user_name = ‘joe’;
ERROR: permission denied for relation passwd
– Алиса может изменить своё имя (поле real_name), но не имя кого-либо другого
postgres=&amp;gt; update passwd set real_name = ‘Alice Doe’;
UPDATE 1
postgres=&amp;gt; update passwd set real_name = ‘John Doe’ where user_name = ‘admin’;
UPDATE 0
postgres=&amp;gt; update passwd set shell = ‘/bin/xx’;
ERROR: new row violates WITH CHECK OPTION for “passwd”
postgres=&amp;gt; delete from passwd;
ERROR: permission denied for relation passwd
postgres=&amp;gt; insert into passwd (user_name) values (‘xxx’);
ERROR: permission denied for relation passwd
– Алиса может изменить собственный пароль; попытки поменять другие пароли RLS просто
игнорирует
postgres=&amp;gt; update passwd set pwhash = ‘abc’;
UPDATE 1
64Определение данных
Все политики, создаваемые до этого, были разрешительными, что значит, что при применении
нескольких политик они объединялись логическим оператором «ИЛИ». Хотя можно создать такие
разрешительные политики, которые будут только разрешать доступ к строкам при определённых
условиях, может быть проще скомбинировать разрешительные политики с ограничительными (ко-
торым должны удовлетворять записи и которые объединяются логическим оператором «И»). В
развитие предыдущего примера мы добавим ограничительную политику, разрешающую админи-
стратору, подключённому через локальный сокет Unix, обращаться к записям таблицы passwd:
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
USING (pg_catalog.inet_client_addr() IS NULL);
Затем мы можем убедиться, что администратор, подключённый по сети, не увидит никаких запи-
сей, благодаря этой ограничительной политике:
=&amp;gt; SELECT current_user;
current_user
————–
admin
(1 row)
=&amp;gt; select inet_client_addr();
inet_client_addr
——————
127.0.0.1
(1 row)
=&amp;gt; SELECT current_user;
current_user
————–
admin
(1 row)
=&amp;gt; TABLE passwd;
user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir |
shell
———–+——–+—–+—–+———–+————+————+———-
+——-
(0 rows)
=&amp;gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
На проверки ссылочной целостности, например, на ограничения уникальности и внешние ключи,
защита строк никогда не распространяется, чтобы не нарушалась целостность данных. Поэтому
организацию и политики защиты на уровне строк необходимо тщательно прорабатывать, чтобы не
возникли «скрытые каналы» утечки информации через эти проверки.
В некоторых случаях важно, чтобы защита на уровне строк, наоборот, не действовала. Например,
резервное копирование может оказаться провальным, если механизм защиты на уровне строк мол-
ча не даст скопировать какие-либо строки. В таком случае вы можете установить для параметра
конфигурации row_security значение off. Это само по себе не отключит защиту строк; при этом
просто будет выдана ошибка, если результаты запроса отфильтруются политикой, с тем чтобы
можно было изучить причину ошибки и устранить её.
В приведённых выше примерах выражения политики учитывали только текущие значения в за-
прашиваемой или изменяемой строке. Это самый простой и наиболее эффективный по скорости
вариант; по возможности реализацию защиты строк следует проектировать именно так. Если же
для принятия решения о доступе необходимо обращаться к другим строкам или другим таблицам,
это можно осуществить, применяя в выражениях политик вложенные SELECT или функции, содер-
жащие SELECT. Однако учтите, что при такой реализации возможны условия гонки, что чревато
65Определение данных
утечкой информации, если не принять меры предосторожности. Например, рассмотрим следую-
щую конструкцию таблиц:
– определение групп привилегий
CREATE TABLE groups (group_id int PRIMARY KEY,
group_name text NOT NULL);
INSERT INTO groups VALUES
(1, ‘low’),
(2, ‘medium’),
(5, ‘high’);
GRANT ALL ON groups TO alice; – alice является администратором
GRANT SELECT ON groups TO public;
– определение уровней привилегий для пользователей
CREATE TABLE users (user_name text PRIMARY KEY,
group_id int NOT NULL REFERENCES groups);
INSERT INTO users VALUES
(‘alice’, 5),
(‘bob’, 2),
(‘mallory’, 2);
GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;
– таблица, содержащая защищаемую информацию
CREATE TABLE information (info text,
group_id int NOT NULL REFERENCES groups);
INSERT INTO information VALUES
(‘barely secret’, 1),
(‘slightly secret’, 2),
(‘very secret’, 5);
ALTER TABLE information ENABLE ROW LEVEL SECURITY;
– строка должна быть доступна для чтения/изменения пользователям с group_id,
– большим или равным group_id данной строки
CREATE POLICY fp_s ON information FOR SELECT
USING (group_id &amp;lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
USING (group_id &amp;lt;= (SELECT group_id FROM users WHERE user_name = current_user));
– мы защищаем таблицу с информацией, полагаясь только на RLS
GRANT ALL ON information TO public;
Теперь предположим, что Алиса (роль alice) желает записать «слегка секретную» информацию,
но при этом не хочет давать mallory доступ к ней. Она делает следующее:
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = ‘mallory’;
UPDATE information SET info = ‘secret from mallory’ WHERE group_id = 2;
COMMIT;
На первый взгляд всё нормально; mallory ни при каких условиях не должна увидеть строку «secret
from mallory». Однако здесь возможно условие гонки. Если Мэллори (роль mallory) параллельно
выполняет, скажем:
66Определение данных
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
и её транзакция в режиме READ COMMITTED, она сможет увидеть «secret from mallory». Это произой-
дёт, если её транзакция дойдёт до строки information сразу после того, как эту строку изменит
Алиса (роль alice). Она заблокируется, ожидая фиксирования транзакции Алисы, а затем прочи-
тает изменённое содержимое строки благодаря предложению FOR UPDATE. Однако при этом из-
менённое содержимое users не будет прочитано неявным запросом SELECT, так как этот вложен-
ный SELECT выполняется без указания FOR UPDATE; вместо этого строка users читается из снимка,
полученного в начале запроса. Таким образом, выражение политики проверяет старое значение
уровня привилегий пользователя mallory и позволяет ей видеть изменённую строку.
Обойти эту проблему можно несколькими способами. Первое простое решение заключается в ис-
пользовании SELECT … FOR SHARE во вложенных запросах SELECT в политиках защиты строк.
Однако для этого потребуется давать затронутым пользователям право UPDATE в целевой таблице
(здесь users), что может быть нежелательно. (Хотя можно применить ещё одну политику защиты
строк, чтобы они не могли практически воспользоваться этим правилом; либо поместить вложен-
ный SELECT в функцию, определяющую контекст безопасности.) Кроме этого, активное использо-
вание блокировок строк в целевой таблице может повлечь проблемы с производительностью, осо-
бенно при частых изменениях. Другое решение, практичное, если целевая таблица изменяется
нечасто, заключается в исключительной блокировке целевой таблицы при изменении, чтобы ни-
какие параллельные транзакции не видели старые значения строк. Либо можно просто дождаться
завершения всех параллельных транзакций после изменения в целевой таблице, прежде чем вно-
сить изменения, рассчитанные на новые условия безопасности.
За дополнительными подробностями обратитесь к CREATE POLICY и ALTER TABLE.
5.8. Схемы
Кластер баз данных PostgreSQL содержит один или несколько именованных экземпляров баз. На
уровне кластера создаются пользователи и группы, но данные могут относиться только к базам
данных. При этом в рамках одного подключения к серверу можно обращаться к данным только
одной базы данных, указанной при установлении соединения.
Примечание
Пользователи кластера не обязательно будут иметь доступ ко всем базам данных этого
кластера. То, что пользователи создаются на уровне кластера, означает только, что в
нём не может быть двух пользователей joe в разных базах данных, хотя система поз-
воляет ограничить доступ joe только некоторыми базами данных.
База данных содержит одну или несколько именованных схем, которые в свою очередь содержат
таблицы. Схемы также содержат именованные объекты других видов, включая типы данных, функ-
ции и операторы. Одно и то же имя объекта можно свободно использовать в разных схемах, напри-
мер и schema1, и myschema могут содержать таблицы с именем mytable. В отличие от баз данных,
схемы не ограничивают доступ к данным: пользователи могут обращаться к объектам в любой схе-
ме текущей базы данных, если им назначены соответствующие права.
Есть несколько возможных объяснений, для чего стоит применять схемы:
• Чтобы одну базу данных могли использовать несколько пользователей, независимо друг от
друга.
• Чтобы объединить объекты базы данных в логические группы для облегчения управления
ими.
• Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов
имён.
Схемы в некоторым смысле подобны каталогам в операционной системе, но они не могут быть
вложенными.
67Определение данных
5.8.1. Создание схемы
Для создания схемы используется команда CREATE SCHEMA. При этом вы определяете имя схемы
по своему выбору, например так:
CREATE SCHEMA myschema;
Чтобы создать объекты в схеме или обратиться к ним, указывайте полное имя, состоящее из имён
схемы и объекта, разделённых точкой:
схема.таблица
Этот синтаксис работает везде, где ожидается имя таблицы, включая команды модификации таб-
лицы и команды обработки данных, обсуждаемые в следующих главах. (Для краткости мы будем
говорить только о таблицах, но всё это распространяется и на другие типы именованных объектов,
например, типы и функции.)
Есть ещё более общий синтаксис
база_данных.схема.таблица
но в настоящее время он поддерживается только для формального соответствия стандарту SQL.
Если вы указываете базу данных, это может быть только база данных, к которой вы подключены.
Таким образом, создать таблицу в новой схеме можно так:
CREATE TABLE myschema.mytable (
…
);
Чтобы удалить пустую схему (не содержащую объектов), выполните:
DROP SCHEMA myschema;
Удалить схему со всеми содержащимися в ней объектами можно так:
DROP SCHEMA myschema CASCADE;
Стоящий за этим общий механизм описан в Разделе 5.13.
Часто бывает нужно создать схему, владельцем которой будет другой пользователь (это один из
способов ограничения пользователей пространствами имён). Сделать это можно так:
CREATE SCHEMA имя_схемы AUTHORIZATION имя_пользователя;
Вы даже можете опустить имя схемы, в этом случае именем схемы станет имя пользователя. Как
это можно применять, описано в Подразделе 5.8.6.
Схемы с именами, начинающимися с pg_, являются системными; пользователям не разрешено
использовать такие имена.
5.8.2. Схема public
До этого мы создавали таблицы, не указывая никакие имена схем. По умолчанию такие таблицы
(и другие объекты) автоматически помещаются в схему «public». Она содержится во всех создава-
емых базах данных. Таким образом, команда:
CREATE TABLE products ( … );
эквивалентна:
CREATE TABLE public.products ( … );
5.8.3. Путь поиска схемы
Везде писать полные имена утомительно, и часто всё равно лучше не привязывать приложения
к конкретной схеме. Поэтому к таблицам обычно обращаются по неполному имени, состоящему
просто из имени таблицы. Система определяет, какая именно таблица подразумевается, исполь-
68Определение данных
зуя путь поиска, который представляет собой список просматриваемых схем. Подразумеваемой
таблицей считается первая подходящая таблица, найденная в схемах пути. Если подходящая таб-
лица не найдена, возникает ошибка, даже если таблица с таким именем есть в других схемах базы
данных.
Возможность создавать одноимённые объекты в разных схемах усложняет написание запросов,
которые должны всегда обращаться к конкретным объектам. Это также потенциально позволяет
пользователям влиять на поведение запросов других пользователей, злонамеренно или случайно.
Ввиду преобладания неполных имён в запросах и их использования внутри PostgreSQL, добавить
схему в search_path — по сути значит доверять всем пользователям, имеющим право CREATE в
этой схеме. Когда вы выполняете обычный запрос, злонамеренный пользователь может создать
объекты в схеме, включённой в ваш путь поиска, и таким образом перехватывать управление и
выполнять произвольные функции SQL как если бы их выполняли вы.
Первая схема в пути поиска называется текущей. Эта схема будет использоваться не только при
поиске, но и при создании объектов — она будет включать таблицы, созданные командой CREATE
TABLE без указания схемы.
Чтобы узнать текущий тип поиска, выполните следующую команду:
SHOW search_path;
В конфигурации по умолчанию она возвращает:
search_path
————–
“$user”, public
Первый элемент ссылается на схему с именем текущего пользователя. Если такой схемы не суще-
ствует, ссылка на неё игнорируется. Второй элемент ссылается на схему public, которую мы уже
видели.
Первая существующая схема в пути поиска также считается схемой по умолчанию для новых объ-
ектов. Именно поэтому по умолчанию объекты создаются в схеме public. При указании неполной
ссылки на объект в любом контексте (при модификации таблиц, изменении данных или в запросах)
система просматривает путь поиска, пока не найдёт соответствующий объект. Таким образом, в
конфигурации по умолчанию неполные имена могут относиться только к объектам в схеме public.
Чтобы добавить в путь нашу новую схему, мы выполняем:
SET search_path TO myschema,public;
(Мы опускаем компонент $user, так как здесь в нём нет необходимости.) Теперь мы можем обра-
щаться к таблице без указания схемы:
DROP TABLE mytable;
И так как myschema — первый элемент в пути, новые объекты будут по умолчанию создаваться в
этой схеме.
Мы можем также написать:
SET search_path TO myschema;
Тогда мы больше не сможем обращаться к схеме public, не написав полное имя объекта. Един-
ственное, что отличает схему public от других, это то, что она существует по умолчанию, хотя её
так же можно удалить.
В Разделе 9.25 вы узнаете, как ещё можно манипулировать путём поиска схем.
Как и для имён таблиц, путь поиска аналогично работает для имён типов данных, имён функций
и имён операторов. Имена типов данных и функций можно записать в полном виде так же, как
и имена таблиц. Если же вам нужно использовать в выражении полное имя оператора, для этого
есть специальный способ — вы должны написать:
69Определение данных
OPERATOR(схема.оператор)
Такая запись необходима для избежания синтаксической неоднозначности. Пример такого выра-
жения:
SELECT 3 OPERATOR(pg_catalog.+) 4;
На практике пользователи часто полагаются на путь поиска, чтобы не приходилось писать такие
замысловатые конструкции.
5.8.4. Схемы и права
По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить
это, владелец схемы должен дать пользователю право USAGE для данной схемы. Чтобы пользовате-
ли могли использовать объекты схемы, может понадобиться назначить дополнительные права на
уровне объектов.
Пользователю также можно разрешить создавать объекты в схеме, не принадлежащей ему. Для
этого ему нужно дать право CREATE в требуемой схеме. Заметьте, что по умолчанию все имеют
права CREATE и USAGE в схеме public. Благодаря этому все пользователи могут подключаться к
заданной базе данных и создавать объекты в её схеме public. Некоторые шаблоны использования
требуют запретить это:
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
(Первое слово «public» обозначает схему, а второе означает «каждый пользователь». В первом слу-
чае это идентификатор, а во втором — ключевое слово, поэтому они написаны в разном регистре;
вспомните указания из Подраздела 4.1.1.)
5.8.5. Схема системного каталога
В дополнение к схеме public и схемам, создаваемым пользователями, любая база данных содер-
жит схему pg_catalog, в которой находятся системные таблицы и все встроенные типы данных,
функции и операторы. pg_catalog фактически всегда является частью пути поиска. Если даже эта
схема не добавлена в путь явно, она неявно просматривается до всех схем, указанных в пути. Так
обеспечивается доступность встроенных имён при любых условиях. Однако вы можете явным об-
разом поместить pg_catalog в конец пути поиска, если вам нужно, чтобы пользовательские имена
переопределяли встроенные.
Так как имена системных таблиц начинаются с pg_, такие имена лучше не использовать во избе-
жание конфликта имён, возможного при появлении в будущем системной таблицы с тем же име-
нем, что и ваша. (С путём поиска по умолчанию неполная ссылка будет воспринята как обращение
к системной таблице.) Системные таблицы будут и дальше содержать в имени приставку pg_, так
что они не будут конфликтовать с неполными именами пользовательских таблиц, если пользова-
тели со своей стороны не будут использовать приставку pg_.
5.8.6. Шаблоны использования
Схемам можно найти множество применений. Хотя есть несколько шаблонов использования, легко
поддерживаемых стандартной конфигурацией, только один из них достаточно безопасен, когда
одни пользователи базы данных не доверяют другим:
• Ограничить обычных пользователей личными схемами. Для реализации этого подхода выпол-
ните REVOKE CREATE ON SCHEMA public FROM PUBLIC и создайте для каждого пользователя схе-
му с его именем. Если затрагиваемые пользователи подключались к базе ранее, проведите
аудит схемы на предмет наличия таких же имён, как в схеме pg_catalog. Вспомните, что путь
поиска по умолчанию начинается со значения $user, которое разрешается в имя пользовате-
ля. Таким образом, если у всех пользователей будет отдельная схема, они по умолчанию будут
обращаться к собственным схемам.
• Удалить схему public из пути поиска по умолчанию для каждого пользователя с помощью ко-
манды ALTER ROLE пользователь SET search_path = “$user”. Все сохранят возможность со-
здавать объекты в общедоступной схеме, но обращаться к ним будут только по полным име-
70Определение данных
нам. Хотя обращение к таблицам по полным именам вполне безопасно, вызовы функций в схе-
ме public будут небезопасными или ненадёжными. Кроме того, пользователь, имеющий пра-
во CREATEROLE, может отменить это назначение и выполнять произвольные запросы от имени
пользователей, полагающихся на этот путь. Если вы создаёте функции или расширения в схе-
ме public или даёте пользователям право CREATEROLE, но не хотите, чтобы они стали практиче-
ски суперпользователями, вам нужно использовать первый шаблон.
• Удалить схему public из пути поиска search_path в postgresql.conf. Это будет иметь такое
же влияние на пользователей, что и предыдущий шаблон. В дополнение к его особенностям
относительно функций и права CREATEROLE, данный шаблон подразумевает также доверие к
владельцам базам данных, как к имеющим право CREATEROLE. Если вы создаёте функции или
расширения в схеме public, даёте пользователям права CREATEROLE, CREATEDB или делаете их
владельцами отдельных баз данных, но не хотите, чтобы они стали практически суперпользо-
вателями, вам нужно использовать первый шаблон.
• Сохранить поведение по умолчанию. Все пользователи неявно обращаются к схеме public. Тем
самым имитируется ситуация с полным отсутствием схем, что позволяет осуществить плав-
ный переход из среды без схем. Однако при этом любой пользователь может выполнять произ-
вольные запросы от имени любого пользователя, который не позаботится о своей защите спе-
циально. Этот шаблон подходит, только если в базе данных имеется всего один или несколько
взаимно доверяющих пользователей.
При любом подходе, устанавливая совместно используемые приложения (таблицы, которые нужны
всем, дополнительные функции сторонних разработчиков и т. д.), помещайте их в отдельные схемы.
Не забудьте дать другим пользователям права для доступа к этим схемам. Тогда пользователи
смогут обращаться к этим дополнительным объектам по полному имени или при желании добавят
эти схемы в свои пути поиска.
5.8.7. Переносимость
Стандарт SQL не поддерживает обращение в одной схеме к разным объектам, принадлежащим
разным пользователям. Более того, в ряде реализаций СУБД нельзя создавать схемы с именем, от-
личным от имени владельца. На практике, в СУБД, реализующих только базовую поддержку схем
согласно стандарту, концепции пользователя и схемы очень близки. Таким образом, многие поль-
зователи полагают, что полное имя на самом деле образуется как имя_пользователя.имя_таблицы.
И именно так будет вести себя PostgreSQL, если вы создадите схемы для каждого пользователя.
В стандарте SQL нет и понятия схемы public. Для максимального соответствия стандарту исполь-
зовать схему public не следует.
Конечно, есть СУБД, в которых вообще не реализованы схемы или пространства имён поддержива-
ют (возможно, с ограничениями) обращения к другим базам данных. Если вам потребуется рабо-
тать с этими системами, максимальной переносимости вы достигнете, вообще не используя схемы.
5.9. Наследование
PostgreSQL реализует наследование таблиц, что может быть полезно для проектировщиков баз
данных. (Стандарт SQL:1999 и более поздние версии определяют возможность наследования ти-
пов, но это во многом отличается от того, что описано здесь.)
Давайте начнём со следующего примера: предположим, что мы создаём модель данных для горо-
дов. В каждом штате есть множество городов, но лишь одна столица. Мы хотим иметь возможность
быстро получать город-столицу для любого штата. Это можно сделать, создав две таблицы: одну
для столиц штатов, а другую для городов, не являющихся столицами. Однако, что делать, если нам
нужно получить информацию о любом городе, будь то столица штата или нет? В решении этой
проблемы может помочь наследование. Мы определим таблицу capitals как наследника cities:
CREATE TABLE cities
name
population
altitude
(
text,
float,
int
– в футах
71Определение данных
);
CREATE TABLE capitals (
state
char(2)
) INHERITS (cities);
В этом случае таблица capitals наследует все столбцы своей родительской таблицы, cities. Сто-
лицы штатов также имеют дополнительный столбец state, в котором будет указан штат.
В PostgreSQL таблица может наследоваться от нуля или нескольких других таблиц, а запросы могут
выбирать все строки родительской таблицы или все строки родительской и всех дочерних таблиц.
По умолчанию принят последний вариант. Например, следующий запрос найдёт названия всех
городов, включая столицы штатов, расположенных выше 500 футов:
SELECT name, altitude
FROM cities
WHERE altitude &amp;gt; 500;
Для данных из введения (см. Раздел 2.1) он выдаст:
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Madison
|
845
А следующий запрос находит все города, которые не являются столицами штатов, но также нахо-
дятся на высоте выше 500 футов:
SELECT name, altitude
FROM ONLY cities
WHERE altitude &amp;gt; 500;
name
| altitude
———–+———-
Las Vegas |
2174
Mariposa |
1953
Здесь ключевое слово ONLY указывает, что запрос должен применяться только к таблице cities,
но не к таблицам, расположенным ниже cities в иерархии наследования. Многие операторы, ко-
торые мы уже обсудили, — SELECT, UPDATE и DELETE — поддерживают ключевое слово ONLY.
Вы также можете добавить после имени таблицы &lt;em&gt;, чтобы явно указать, что должны включаться
и дочерние таблицы:
SELECT name, altitude
FROM cities&lt;/em&gt;
WHERE altitude &amp;gt; 500;
Указывать * не обязательно, так как теперь это поведение всегда подразумевается по умолчанию.
Однако такая запись всё ещё поддерживается для совместимости со старыми версиями, где пове-
дение по умолчанию могло быть изменено.
В некоторых ситуациях бывает необходимо узнать, из какой таблицы выбрана конкретная строка.
Для этого вы можете воспользоваться системным столбцом tableoid, присутствующим в каждой
таблице:
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &amp;gt; 500;
этот запрос выдаст:
tableoid |
name
| altitude
72Определение данных
———-+———–+———-
139793 | Las Vegas |
2174
139793 | Mariposa |
1953
139798 | Madison
|
845
(Если вы попытаетесь выполнить его у себя, скорее всего вы получите другие значения OID.) Соб-
ственно имена таблиц вы можете получить, обратившись к pg_class:
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &amp;gt; 500 AND c.tableoid = p.oid;
в результате вы получите:
relname |
name
| altitude
———-+———–+———-
cities
| Las Vegas |
2174
cities
| Mariposa |
1953
capitals | Madison
|
845
Тот же эффект можно получить другим способом, используя альтернативный тип regclass; при
этом OID таблицы выводится в символьном виде:
SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &amp;gt; 500;
Механизм наследования не способен автоматически распределять данные команд INSERT или COPY
по таблицам в иерархии наследования. Поэтому в нашем примере этот оператор INSERT не выпол-
нится:
INSERT INTO cities (name, population, altitude, state)
VALUES (‘Albany’, NULL, NULL, ‘NY’);
Мы могли надеяться на то, что данные каким-то образом попадут в таблицу capitals, но этого не
происходит: INSERT всегда вставляет данные непосредственно в указанную таблицу. В некоторых
случаях добавляемые данные можно перенаправлять, используя правила (см. Главу 41). Однако в
нашем случае это не поможет, так как таблица cities не содержит столбца state и команда будет
отвергнута до применения правила.
Дочерние таблицы автоматически наследуют от родительской таблицы ограничения-проверки и
ограничения NOT NULL (если только для них не задано явно NO INHERIT). Все остальные ограни-
чения (уникальности, первичный ключ и внешние ключи) не наследуются.
Таблица может наследоваться от нескольких родительских таблиц, в этом случае она будет объ-
единять в себе все столбцы этих таблиц, а также столбцы, описанные непосредственно в её опре-
делении. Если в определениях родительских и дочерней таблиц встретятся столбцы с одним име-
нем, эти столбцы будут «объединены», так что в дочерней таблице окажется только один столбец.
Чтобы такое объединение было возможно, столбцы должны иметь одинаковый тип данных, в про-
тивном случае произойдёт ошибка. Наследуемые ограничения-проверки и ограничения NOT NULL
объединяются подобным образом. Так, например, объединяемый столбец получит свойство NOT
NULL, если какое-либо из порождающих его определений имеет свойство NOT NULL. Ограниче-
ния-проверки объединяются, если они имеют одинаковые имена; но если их условия различаются,
происходит ошибка.
Отношение наследования между таблицами обычно устанавливается при создании дочерней таб-
лицы с использованием предложения INHERITS оператора CREATE TABLE. Другой способ добавить
такое отношение для таблицы, определённой подходящим образом — использовать INHERIT с опе-
ратором ALTER TABLE. Для этого будущая дочерняя таблица должна уже включать те же столбцы
(с совпадающими именами и типами), что и родительская таблица. Также она должна включать
аналогичные ограничения-проверки (с теми же именами и выражениями). Удалить отношение на-
следования можно с помощью указания NO INHERIT оператора ALTER TABLE. Динамическое добав-
73Определение данных
ление и удаление отношений наследования может быть полезно при реализации секционирования
таблиц (см. Раздел 5.10).
Для создания таблицы, которая затем может стать наследником другой, удобно воспользоваться
предложением LIKE оператора CREATE TABLE. Такая команда создаст новую таблицу с теми же
столбцами, что имеются в исходной. Если в исходной таблицы определены ограничения CHECK,
для создания полностью совместимой таблицы их тоже нужно скопировать, и это можно сделать,
добавив к предложению LIKE параметр INCLUDING CONSTRAINTS.
Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. При этом в дочер-
них таблицах нельзя удалять или модифицировать столбцы или ограничения-проверки, унаследо-
ванные от родительских таблиц. Если вы хотите удалить таблицу вместе со всеми её потомками,
это легко сделать, добавив в команду удаления родительской таблицы параметр CASCADE (см. Раз-
дел 5.13).
При изменениях определений и ограничений столбцов команда ALTER TABLE распространяет эти
изменения вниз в иерархии наследования. Однако удалить столбцы, унаследованные дочерними
таблицами, можно только с помощью параметра CASCADE. При создании отношений наследова-
ния команда ALTER TABLE следует тем же правилам объединения дублирующихся столбцов, что
и CREATE TABLE.
В запросах с наследуемыми таблицами проверка прав доступа выполняется только в родительской
таблице. Так, например, наличие разрешения UPDATE для таблицы cities подразумевает право на
изменение строк также в таблице capitals, когда к ним происходит обращение через таблицу
cities. Это сохраняет видимость того, что эти данные (также) находятся в родительской табли-
це. Но изменить таблицу capitals напрямую без дополнительного разрешения нельзя. Подобным
образом, политики безопасности на уровне строк (см. Раздел 5.7) для родительской таблицы при-
меняются к строкам, получаемым из дочерних таблиц при выполнении запроса с наследованием.
Политики же дочерних таблиц, если они определены, действуют только когда такие таблицы яв-
но задействуются в запросе; в этом случае все политики, связанные с родительскими таблицами,
игнорируются.
Сторонние таблицы (см. Раздел 5.11) могут также входить в иерархию наследования как родитель-
ские или дочерние таблицы, так же, как и обычные. Если в иерархию наследования входит сторон-
няя таблица, все операции, не поддерживаемые ей, не будут поддерживаться иерархией в целом.
5.9.1. Ограничения
Заметьте, что не все SQL-команды могут работать с иерархиями наследования. Команды, выпол-
няющие выборку данных, изменение данных или модификацию схемы (например SELECT, UPDATE,
DELETE, большинство вариантов ALTER TABLE, но не INSERT и ALTER TABLE … RENAME), обычно
по умолчанию обрабатывают данные дочерних таблиц и могут исключать их, если поддерживают
указание ONLY. Команды для обслуживания и настройки базы данных (например REINDEX и VACUUM)
обычно работают только с отдельными физическими таблицами и не поддерживают рекурсивную
обработку отношений наследования. Соответствующее поведение каждой команды описано в её
справке (Команды SQL).
Возможности наследования серьёзно ограничены тем, что индексы (включая ограничения уни-
кальности) и ограничения внешних ключей относятся только к отдельным таблицам, но не к их по-
томкам. Это касается обеих сторон ограничений внешних ключей. Таким образом, применительно
к нашему примеру:
• Если мы объявим cities.name с ограничением UNIQUE или PRIMARY KEY, это не помешает доба-
вить в таблицу capitals строки с названиями городов, уже существующими в таблице cities.
И эти дублирующиеся строки по умолчанию будут выводиться в результате запросов к cities.
На деле таблица capitals по умолчанию вообще не будет содержать ограничение уникально-
сти, так что в ней могут оказаться несколько строк с одним названием. Хотя вы можете доба-
вить в capitals соответствующее ограничение, но это не предотвратит дублирование при объ-
единении с cities.
74Определение данных
• Подобным образом, если мы укажем, что cities.name ссылается (REFERENCES) на какую-то дру-
гую таблицу, это ограничение не будет автоматически распространено на capitals. В этом
случае решением может стать явное добавление такого же ограничения REFERENCES в таблицу
capitals.
• Если вы сделаете, чтобы столбец другой таблицы ссылался на cities(name), в этом столбце
можно будет указывать только названия городов, но не столиц. В этом случае хорошего реше-
ния нет.
Возможно, в будущем эти недостатки будут исправлены, но в настоящее время вам следует тща-
тельно взвесить все за и против, прежде чем использовать наследование в своих приложениях.
5.10. Секционирование таблиц
PostgreSQL поддерживает простое секционирование таблиц. В этом разделе описывается, как и
почему бывает полезно применять секционирование при проектировании баз данных.
5.10.1. Обзор
Секционированием данных называется разбиение одной большой логической таблицы на несколь-
ко меньших физических секций. Секционирование может принести следующую пользу:
• В определённых ситуациях оно кардинально увеличивает быстродействие, особенно когда
большой процент часто запрашиваемых строк таблицы относится к одной или лишь несколь-
ким секциям. Секционирование может сыграть роль ведущих столбцов в индексах, что позво-
лит уменьшить размер индекса и увеличит вероятность нахождения наиболее востребованных
частей индексов в памяти.
• Когда в выборке или изменении данных задействована большая часть одной секции, последо-
вательное сканирование этой секции может выполняться гораздо быстрее, чем случайный до-
ступ по индексу к данным, разбросанным по всей таблице.
• Массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя секции, ес-
ли это было предусмотрено при проектировании секционированных таблиц. Операция ALTER
TABLE DETACH PARTITION или удаление отдельной секции с помощью команды DROP TABLE вы-
полняются гораздо быстрее, чем массовая обработка. Эти команды также полностью исклю-
чают накладные расходы, связанные с выполнением VACUUM после DELETE.
• Редко используемые данные можно перенести на более дешёвые и медленные носители.
Всё это обычно полезно только для очень больших таблиц. Какие именно таблицы выиграют от
секционирования, зависит от конкретного приложения, хотя, как правило, это следует применять
для таблиц, размер которых превышает объём ОЗУ сервера.
PostgreSQL предлагает поддержку следующих видов секционирования:
Секционирование по диапазонам
Таблица секционируется по «диапазонам», определённым по ключевому столбцу или набору
столбцов, и не пересекающимся друг с другом. Например, можно секционировать данные по
диапазонам дат или по диапазонам идентификаторов определённых бизнес-объектов.
Секционирование по списку
Таблица секционируется с помощью списка, явно указывающего, какие значения ключа долж-
ны относиться к каждой секции.
Секционирование по хешу
Таблица секционируется по определённым модулям и остаткам, которые указываются для каж-
дой секции. Каждая секция содержит строки, для которых хеш-значение ключа разбиения, де-
лённое на модуль, равняется заданному остатку.
Если вашему приложению требуются другие формы секционирования, можно также прибегнуть
к альтернативным реализациям, с использованием наследования и представлений с UNION ALL.
75Определение данных
Такие подходы дают гибкость, но не дают такого выигрыша в производительности, как встроенное
декларативное секционирование.
5.10.2. Декларативное секционирование
PostgreSQL предоставляет возможность указать, как разбить таблицу на части, называемые сек-
циями. Разделённая таким способом таблица называется секционированной таблицей. Указание
секционирования состоит из определения метода секционирования и списка столбцов или выра-
жений, которые будут составлять ключ разбиения.
Все строки, вставляемые в секционированную таблицу, будут направляться в одну из секций в
зависимости от значения ключа разбиения. В каждой секции содержится подмножество данных,
определяемое границами секции. В настоящее время поддерживается секционирование по диапа-
зонам, по списку и по хешу.
Сами секции могут представлять собой секционируемые таблицы, благодаря применению так на-
зываемого вложенного секционирования. В каждой секции могут быть определены свои индексы,
ограничения и значения по умолчанию, отличные от других секций. Подробнее о создании секци-
онированных таблиц и секций рассказывается в описании CREATE TABLE.
Преобразовать обычную таблицу в секционированную и наоборот нельзя. Однако в секциониро-
ванную таблицу можно добавить в качестве секции обычную или секционированную таблицу с
данными, а также можно удалить секцию из секционированной таблицы и превратить её в отдель-
ную таблицу; обратитесь к описанию ALTER TABLE, чтобы узнать больше о подкомандах ATTACH
PARTITION и DETACH PARTITION.
За кулисами отдельные секции связываются с секционируемой таблицей средствами наследова-
ния; однако с секционированными таблицами и секциями нельзя использовать некоторые общие
возможности наследования, описанные ниже. Например, секция не может иметь никаких других
родителей, кроме секционированной таблицы, к которой она присоединена, так же как обычная
таблица не может наследоваться от секционированной таблицы. Это означает, что секциониро-
ванные таблицы и их секции не совмещаются в иерархии наследования с обычными таблицами. Но
так как иерархия наследования, включающая секционированную таблицу и её секции, остаётся
иерархией наследования, на неё распространяются все обычные правила наследования, описан-
ные в Раздел 5.9, с некоторыми исключениями. А именно:
• Ограничения CHECK вместе с NOT NULL, определённые в секционированной таблице, всегда на-
следуются всеми её секциями. Ограничения CHECK с характеристикой NO INHERIT в секциони-
рованных таблицах создавать нельзя.
• Использование указания ONLY при добавлении или удалении ограничения только в секцио-
нированной таблице поддерживается лишь когда в ней нет секций. Если секции существуют,
при попытке использования ONLY возникнет ошибка, так как добавление или удаление ограни-
чений только в секционированной таблице при наличии секций не поддерживается. С другой
стороны, ограничения можно добавлять или удалять непосредственно в секциях (если они от-
сутствуют в родительской таблице).
• Так как секционированная таблица сама по себе не содержит данные, использование
TRUNCATE ONLY для секционированной таблицы всегда будет считаться ошибкой.
• В секциях не может быть столбцов, отсутствующих в родительской таблице. Такие столбцы
невозможно определить ни при создании секций командой CREATE TABLE, ни путём последую-
щего добавления в секции командой ALTER TABLE. Таблицы могут быть подключены в качестве
секций командой ALTER TABLE … ATTACH PARTITION, только если их столбцы в точности со-
ответствуют родительской таблице, включая столбец oid (если он есть).
• Ограничение NOT NULL для столбца в секции нельзя удалить, если это ограничение существу-
ет в родительской таблице.
Секции также могут быть сторонними таблицами, хотя при этом накладываются некоторые ограни-
чения, отсутствующие с обычными таблицами; за подробностями обратитесь к описанию CREATE
FOREIGN TABLE.
76Определение данных
Изменение ключа разбиения в строке может привести к перемещению её в другую секцию, огра-
ничению которой соответствует изменённая строка.
5.10.2.1. Пример
Предположим, что мы создаём базу данных для большой компании, торгующей мороженым. Ком-
пания учитывает максимальную температуру и продажи мороженого каждый день в разрезе ре-
гионов. По сути нам нужна следующая таблица:
CREATE TABLE measurement (
city_id
int not null,
logdate
date not null,
peaktemp
int,
unitsales
int
);
Мы знаем, что большинство запросов будут работать только с данными за последнюю неделю,
месяц или квартал, так как в основном эта таблица нужна для формирования текущих отчётов для
руководства. Чтобы сократить объём хранящихся старых данных, мы решили оставлять данные
только за 3 последних года. Ненужные данные мы будем удалять в начале каждого месяца. В этой
ситуации мы можем использовать секционирование для удовлетворения всех наших требований
к таблице показателей.
Чтобы использовать декларативное секционирование в этом случае, выполните следующее:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Создайте таблицу measurement как секционированную таблицу с предложением PARTITION BY,
указав метод разбиения (в нашем случае RANGE) и список столбцов, которые будут образовывать
ключ разбиения.
CREATE TABLE measurement (
city_id
int not null,
logdate
date not null,
peaktemp
int,
unitsales
int
) PARTITION BY RANGE (logdate);
При разбиении по диапазонам в качестве ключа разбиения при желании можно использовать
набор из нескольких столбцов. Конечно, при этом скорее всего увеличится количество секций, и
каждая из них будет меньше. И напротив, использование меньшего числа столбцов может при-
вести к менее дробному критерию разбиения с меньшим числом секций. Запрос, обращающийся
к секционированной таблице, будет сканировать меньше секций, если в условии поиска фигури-
руют некоторые или все эти столбцы. Например, в таблице, секционируемой по диапазонам, в
качестве ключа разбиения можно выбрать столбцы lastname и firstname (в таком порядке).&lt;/li&gt;
  &lt;li&gt;Создайте секции. В определении каждой секции должны задаваться границы, соответствующие
методу и ключу разбиения родительской таблицы. Заметьте, что указание границ, при котором
множество значений новой секции пересекается со множеством значений в одной или несколь-
ких существующих секциях, будет ошибочным. При попытке добавления в родительскую табли-
цу данных, которые не соответствуют ни одной из существующей секций, произойдёт ошибка;
соответствующий раздел нужно добавлять вручную.
Секции, создаваемые таким образом, во всех отношениях являются обычными таблицами
PostgreSQL (или, возможно, сторонними таблицами). В частности, для каждой секции можно
независимо задать табличное пространство и параметры хранения.
Для таблиц-секций нет необходимости определять ограничения с условиями, задающими гра-
ницы значений. Нужные ограничения секций выводятся неявно из определения границ секции,
когда требуется к ним обратиться.
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
FOR VALUES FROM (‘2006-02-01’) TO (‘2006-03-01’);
CREATE TABLE measurement_y2006m03 PARTITION OF measurement
77Определение данных
FOR VALUES FROM (‘2006-03-01’) TO (‘2006-04-01’);
…
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
FOR VALUES FROM (‘2007-11-01’) TO (‘2007-12-01’);
CREATE TABLE measurement_y2007m12 PARTITION OF measurement
FOR VALUES FROM (‘2007-12-01’) TO (‘2008-01-01’)
TABLESPACE fasttablespace;
CREATE TABLE measurement_y2008m01 PARTITION OF measurement
FOR VALUES FROM (‘2008-01-01’) TO (‘2008-02-01’)
WITH (parallel_workers = 4)
TABLESPACE fasttablespace;
Для реализации вложенного секционирования укажите предложение PARTITION BY в командах,
создающих отдельные секции, например:
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
FOR VALUES FROM (‘2006-02-01’) TO (‘2006-03-01’)
PARTITION BY RANGE (peaktemp);
Когда будут созданы секции measurement_y2006m02, данные, добавляемые в measurement
и попадающие в measurement_y2006m02 (или данные, непосредственно добавляемые в
measurement_y2006m02, с учётом соответствия ограничению секции) будут затем перенаправле-
ны в одну из вложенных секций в зависимости от значения столбца peaktemp. Указанный ключ
разбиения может пересекаться с ключом разбиения родителя, хотя определять границы вло-
женной секции нужно осмотрительно, чтобы множество данных, которое она принимает, входи-
ло во множество, допускаемое собственными границами секции; система не пытается контро-
лировать это сама.&lt;/li&gt;
  &lt;li&gt;Создайте в секционируемой таблице индекс по ключевому столбцу (или столбцам), а также лю-
бые другие индексы, которые могут понадобиться. (Индекс по ключу, строго говоря, создавать
не обязательно, но в большинстве случаев он будет полезен.) При этом будет автоматически
создан отдельный индекс в каждой секции, и все секции, которые вы будете создавать или при-
соединять позднее, тоже будут содержать такой индекс.
CREATE INDEX ON measurement (logdate);&lt;/li&gt;
  &lt;li&gt;Убедитесь в том, что параметр конфигурации enable_partition_pruning не выключен в
postgresql.conf. Иначе запросы не будут оптимизироваться должным образом.
В данном примере нам потребуется создавать секцию каждый месяц, так что было бы разумно
написать скрипт, который бы формировал требуемый код DDL автоматически.
5.10.2.2. Обслуживание секций
Обычно набор секций, образованный изначально при создании таблиц, не предполагается сохра-
нять неизменным. Чаще наоборот, планируется удалять старые секции данных и периодически
добавлять новые. Одно из наиболее важных преимуществ секционирования состоит именно в том,
что оно позволяет практически моментально выполнять трудоёмкие операции, изменяя структуру
секций, а не физически перемещая большие объёмы данных.
Самый лёгкий способ удалить старые данные — просто удалить секцию, ставшую ненужной:
DROP TABLE measurement_y2006m02;
Так можно удалить миллионы записей гораздо быстрее, чем удалять их по одной. Заметьте, однако,
что приведённая выше команда требует установления блокировки ACCESS EXCLUSIVE.
Ещё один часто более предпочтительный вариант — убрать секцию из главной таблицы, но сохра-
нить возможность обращаться к ней как к самостоятельной таблице:
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
78Определение данных
При этом можно будет продолжать работать с данными, пока таблица не будет удалена. Например,
в этом состоянии очень кстати будет сделать резервную копию данных, используя COPY, pg_dump
или подобные средства. Возможно, эти данные также можно будет агрегировать, перевести в ком-
пактный формат, выполнить другую обработку или построить отчёты.
Аналогичным образом можно добавлять новую секцию с данными. Мы можем создать пустую сек-
цию в главной таблице так же, как мы создавали секции в исходном состоянии до этого:
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
FOR VALUES FROM (‘2008-02-01’) TO (‘2008-03-01’)
TABLESPACE fasttablespace;
А иногда удобнее создать новую таблицу вне структуры секций и сделать её полноценной секцией
позже. При таком подходе данные можно будет загрузить, проверить и преобразовать до того, как
они появятся в секционированной таблице:
CREATE TABLE measurement_y2008m02
(LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
TABLESPACE fasttablespace;
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
CHECK ( logdate &amp;gt;= DATE ‘2008-02-01’ AND logdate &amp;lt; DATE ‘2008-03-01’ );
\copy measurement_y2008m02 from ‘measurement_y2008m02’
– possibly some other data preparation work
ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
FOR VALUES FROM (‘2008-02-01’) TO (‘2008-03-01’ );
Прежде чем выполнять команду ATTACH PARTITION, рекомендуется создать ограничение CHECK в
присоединяемой таблице, описывающее желаемое ограничение секции. Благодаря этому система
сможет не сканировать таблицу для проверки выполнения неявного ограничения секции. Без этого
ограничения таблицу нужно будет просканировать и убедиться в выполнении ограничения секции,
удерживая блокировку ACCESS EXCLUSIVE в родительской таблице. После выполнения команды
ATTACH PARTITION это ограничение можно будет удалить за ненадобностью.
5.10.2.3. Ограничения
С секционированными таблицами связаны следующие ограничения:
• Нельзя создать ограничение-исключение, охватывающее все секции; можно только добавить
независимые ограничения в каждую отдельную секцию.
• Так как в секционированных таблицах первичные ключи не поддерживаются, на секциониро-
ванные таблицы не могут ссылаться внешние ключи. (Ссылки на внешние ключи других таб-
лиц из секционированных таблиц поддерживаются.)
• Когда в результате действия UPDATE строка должна переместиться из одной секции в другую,
есть вероятность, что другая параллельная команда UPDATE или DELETE пропустит эту стро-
ку. Например, предположим, что в сеансе 1 выполняется UPDATE для ключа секционирования,
а тем временем в параллельном сеансе 2, в котором эта строка видима, выполняется опера-
ция UPDATE или DELETE с этой строкой. Сеанс 2 может незаметно потерять эту строку, если
она будет удалена из секции вследствие действия в сеансе 1. В этом случае команды UPDATE
или DELETE в сессии 2, не зная о перемещении строки, считают, что строка была просто уда-
лена и ничего делать с ней не нужно. В обычном случае, когда таблица не секционирована
или когда строка не перемещается, в сеансе 2 была бы видна изменённая строка, и операция
UPDATE/DELETE выполнилась бы с новой версией строки.
• Триггеры BEFORE ROW при необходимости должны определяться в отдельных секциях, а не в
секционированной таблице.
• Смешивание временных и постоянных отношений в одном дереве секционирования не допус-
кается. Таким образом, если секционированная таблица постоянная, такими же должны быть
79Определение данных
её секции; с временными таблицами аналогично. В случае с временными отношениями все
таблицы дерева секционирования должны быть из одного сеанса.
5.10.3. Реализация с использованием наследования
Хотя встроенное декларативное секционирование полезно во многих часто возникающих ситуа-
циях, бывают обстоятельства, требующие более гибкого подхода. В этом случае секционирование
можно реализовать, применив механизм наследования таблиц, что даст ряд возможностей, непод-
держиваемых при декларативном секционировании, например:
• При декларативном секционировании все секции должны иметь в точности тот же набор
столбцов, что и секционируемая таблица, тогда как обычное наследование таблиц допускает
наличие в дочерних таблицах дополнительных столбцов, отсутствующих в родителе.
• Механизм наследования таблиц поддерживает множественное наследование.
• С декларативным секционированием поддерживается только разбиение по спискам, по диапа-
зонам и по хешу, тогда как с наследованием таблиц данные можно разделять по любому кри-
терию, выбранному пользователем. (Однако заметьте, что если исключение по ограничению
не позволяет эффективно устранять дочерние таблицы из планов запросов, производитель-
ность запросов будет очень низкой.)
• Для некоторых операций с декларативным секционированием требуется более сильная блоки-
ровка, чем с использованием наследования. Например, для добавления или удаления секций
из секционированной таблицы требуется установить блокировку ACCESS EXCLUSIVE в роди-
тельской таблице, тогда как в случае с обычным наследованием достаточно блокировки SHARE
UPDATE EXCLUSIVE.
5.10.3.1. Пример
Мы будем использовать ту же таблицу measurement, что и раньше. Чтобы реализовать секциони-
рование с использованием наследования, выполните следующие действия:&lt;/li&gt;
  &lt;li&gt;Создайте «главную» таблицу, от которой будут наследоваться все «дочерние» таблицы. Главная
таблица не будет содержать данные. Не определяйте в ней никакие ограничения-проверки, ес-
ли только вы не намерены применить их во всех дочерних таблицах. Также не имеет смысла
определять в ней какие-либо индексы или ограничения уникальности. В нашем примере глав-
ной таблицей будет measurement со своим изначальным определением.&lt;/li&gt;
  &lt;li&gt;Создайте несколько «дочерних» таблиц, унаследовав их все от главной. Обычно в таких таблицах
не будет никаких дополнительных столбцов, кроме унаследованных. Как и с декларативным сек-
ционированием, эти таблицы во всех отношениях будут обычными таблицами PostgreSQL (или
сторонними таблицами).
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
…
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);&lt;/li&gt;
  &lt;li&gt;Добавьте в дочерние таблицы неперекрывающиеся ограничения, определяющие допустимые
значения ключей для каждой из них.
Типичные примеры таких ограничений:
CHECK ( x = 1 )
CHECK ( county IN ( ‘Oxfordshire’, ‘Buckinghamshire’, ‘Warwickshire’ ))
CHECK ( outletID &amp;gt;= 100 AND outletID &amp;lt; 200 )
Убедитесь в том, что ограничения не пересекаются, то есть никакие значения ключа не относят-
ся сразу к нескольким дочерним таблицам. Например, часто допускают такую ошибку в опре-
делении диапазонов:
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
80Определение данных
Это не будет работать, так как неясно, к какой дочерней таблице должно относиться значение
200.
Дочерние таблицы лучше будет создать следующим образом:
CREATE TABLE measurement_y2006m02 (
CHECK ( logdate &amp;gt;= DATE ‘2006-02-01’ AND logdate &amp;lt; DATE ‘2006-03-01’ )
) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 (
CHECK ( logdate &amp;gt;= DATE ‘2006-03-01’ AND logdate &amp;lt; DATE ‘2006-04-01’ )
) INHERITS (measurement);
…
CREATE TABLE measurement_y2007m11 (
CHECK ( logdate &amp;gt;= DATE ‘2007-11-01’ AND logdate &amp;lt; DATE ‘2007-12-01’ )
) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 (
CHECK ( logdate &amp;gt;= DATE ‘2007-12-01’ AND logdate &amp;lt; DATE ‘2008-01-01’ )
) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 (
CHECK ( logdate &amp;gt;= DATE ‘2008-01-01’ AND logdate &amp;lt; DATE ‘2008-02-01’ )
) INHERITS (measurement);&lt;/li&gt;
  &lt;li&gt;Для каждой дочерней таблицы создайте индекс по ключевому столбцу (или столбцам), а также
любые другие индексы по своему усмотрению.
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);&lt;/li&gt;
  &lt;li&gt;Мы хотим, чтобы наше приложение могло сказать INSERT INTO measurement … и данные ока-
зались в соответствующей дочерней таблице. Мы можем добиться этого, добавив подходящую
триггерную функцию в главную таблицу. Если данные всегда будут добавляться только в послед-
нюю дочернюю таблицу, нам будет достаточно очень простой функции:
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS &lt;script type=&quot;math/tex&quot;&gt;BEGIN
INSERT INTO measurement_y2008m01 VALUES (NEW.*);
RETURN NULL;
END;&lt;/script&gt;
LANGUAGE plpgsql;
Создав эту функцию, мы создадим вызывающий её триггер:
CREATE TRIGGER insert_measurement_trigger
BEFORE INSERT ON measurement
FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
Мы должны менять определение триггерной функции каждый месяц, чтобы она всегда указыва-
ла на текущую дочернюю таблицу. Определение самого триггера, однако, менять не требуется.
Но мы можем также сделать, чтобы сервер автоматически находил дочернюю таблицу, в кото-
рую нужно направить добавляемую строку. Для этого нам потребуется более сложная триггер-
ная функция:
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
81Определение данных
RETURNS TRIGGER AS &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
BEGIN
IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
NEW.logdate &lt; DATE '2006-03-01' ) THEN
INSERT INTO measurement_y2006m02 VALUES (NEW.*);
ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
NEW.logdate &lt; DATE '2006-04-01' ) THEN
INSERT INTO measurement_y2006m03 VALUES (NEW.*);
...
ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
NEW.logdate &lt; DATE '2008-02-01' ) THEN
INSERT INTO measurement_y2008m01 VALUES (NEW.*);
ELSE
RAISE EXCEPTION
'Date out of range. Fix the measurement_insert_trigger() function!';
END IF;
RETURN NULL;
END; %]]&gt;&lt;/script&gt;
LANGUAGE plpgsql;
Определение триггера остаётся прежним. Заметьте, что все условия IF должны в точности от-
ражать ограничения CHECK соответствующих дочерних таблиц.
Хотя эта функция сложнее, чем вариант с одним текущим месяцем, её не придётся так часто
модифицировать, так как ветви условий можно добавить заранее.
Примечание
На практике будет лучше сначала проверять условие для последней дочерней таб-
лицы, если строки добавляются в неё чаще всего, но для простоты мы расположи-
ли проверки триггера в том же порядке, как и в других фрагментах кода для этого
примера.
Другой способ перенаправления добавляемых строк в соответствующую дочернюю таблицу
можно реализовать, определив для главной таблицы не триггер, а правила. Например:
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
( logdate &amp;gt;= DATE ‘2006-02-01’ AND logdate &amp;lt; DATE ‘2006-03-01’ )
DO INSTEAD
INSERT INTO measurement_y2006m02 VALUES (NEW.&lt;em&gt;);
…
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
( logdate &amp;gt;= DATE ‘2008-01-01’ AND logdate &amp;lt; DATE ‘2008-02-01’ )
DO INSTEAD
INSERT INTO measurement_y2008m01 VALUES (NEW.&lt;/em&gt;);
С правилами связано гораздо больше накладных расходов, чем с триггером, но они относятся к
запросу в целом, а не к каждой строке. Поэтому этот способ может быть более выигрышным при
массовом добавлении данных. Однако в большинстве случаев триггеры будут работать быстрее.
Учтите, что команда COPY игнорирует правила. Если вы хотите вставить данные с помощью COPY,
вам придётся копировать их сразу в нужную дочернюю таблицу, а не в главную таблицу. С другой
стороны, COPY не отменяет триггеры, так что с триггерами вы сможете использовать её обычным
образом.
82Определение данных
Ещё один недостаток подхода с правилами связан с невозможностью выдать ошибку, если до-
бавляемая строка не подпадает ни под одно из правил; в этом случае данные просто попадут
в главную таблицу.&lt;/li&gt;
  &lt;li&gt;Убедитесь в том, что параметр конфигурации constraint_exclusion не выключен в
postgresql.conf. В противном случае дочерние таблицы могут сканироваться, когда это не тре-
буется.
Как уже можно понять, для реализации сложной иерархии таблиц может потребоваться DDL-код
значительного объёма. В данном примере нам потребуется создавать дочернюю таблицу каждый
месяц, так что было бы разумно написать скрипт, формирующий требуемый код DDL автоматиче-
ски.
5.10.3.2. Обслуживание таблиц, секционированных через наследование
Чтобы быстро удалить старые данные, просто удалите ставшую ненужной дочернюю таблицу:
DROP TABLE measurement_y2006m02;
Чтобы удалить дочернюю таблицу из иерархии наследования, но сохранить к ней доступ как к
самостоятельной таблице:
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
Чтобы добавить новую дочернюю таблицу для новых данных, создайте пустую дочернюю таблицу
так же, как до этого создавали начальные:
CREATE TABLE measurement_y2008m02 (
CHECK ( logdate &amp;gt;= DATE ‘2008-02-01’ AND logdate &amp;lt; DATE ‘2008-03-01’ )
) INHERITS (measurement);
Можно также создать новую таблицу и наполнить её данными до добавления в иерархию таблиц.
Это позволит загрузить, проверить и при необходимости преобразовать данные до того, как запро-
сы к главной таблице смогут их увидеть.
CREATE TABLE measurement_y2008m02
(LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
CHECK ( logdate &amp;gt;= DATE ‘2008-02-01’ AND logdate &amp;lt; DATE ‘2008-03-01’ );
\copy measurement_y2008m02 from ‘measurement_y2008m02’
– возможна дополнительная подготовка данных
ALTER TABLE measurement_y2008m02 INHERIT measurement;
5.10.3.3. Ограничения
С реализацией секционирования через наследование связаны следующие ограничения:
• Система не может проверить автоматически, являются ли все ограничения CHECK взаимно ис-
ключающими. Поэтому безопаснее будет написать и отладить код для формирования дочер-
них таблиц и создания и/или изменения связанных объектов, чем делать это вручную.
• Показанные здесь схемы подразумевают, что ключевой столбец (или столбцы) в строке нико-
гда не меняется, или меняется не настолько, чтобы строку потребовалось перенести в другую
секцию. Если же попытаться выполнить такой оператор UPDATE, произойдёт ошибка из-за на-
рушения ограничения CHECK. Если вам нужно обработать и такие случаи, вы можете устано-
вить подходящие триггеры на обновление в дочерних таблицах, но это ещё больше усложнит
управление всей конструкцией.
• Если вы выполняете команды VACUUM или ANALYZE вручную, не забывайте, что их нужно запус-
кать для каждой дочерней таблицы в отдельности. Команда
ANALYZE measurement;
обработает только главную таблицу.
83Определение данных
• Операторы INSERT с предложениями ON CONFLICT скорее всего не будут работать ожидаемым
образом, так как действие ON CONFLICT предпринимается только в случае нарушений уникаль-
ности в указанном целевом отношении, а не его дочерних отношениях.
• Для направления строк в нужные дочерние таблицы потребуются триггеры или правила, ес-
ли только приложение не знает непосредственно о схеме секционирования. Разработать триг-
геры может быть довольно сложно, и они будут работать гораздо медленнее, чем внутреннее
распределение кортежей при декларативном секционировании.
5.10.4. Устранение секций
Устранение секций — это приём оптимизации запросов, который ускоряет работу с декларативно
секционированными таблицами. Например:
SET enable_partition_pruning = on;
– по умолчанию
SELECT count(&lt;em&gt;) FROM measurement WHERE logdate &amp;gt;= DATE ‘2008-01-01’;
Без устранения секций показанный запрос должен будет просканировать все секции таблицы
measurement. Когда устранение секций включено, планировщик рассматривает определение каж-
дой секции и может заключить, что какую-либо секцию сканировать не нужно, так как в ней не
может быть строк, удовлетворяющих предложению WHERE в запросе. Когда планировщик может
сделать такой вывод, он исключает (устраняет) секцию из плана запроса.
Используя команду EXPLAIN и параметр конфигурации enable_partition_pruning, можно увидеть
отличие плана, из которого были устранены секции, от плана без устранения. Типичный неопти-
мизированный план для такой конфигурации таблицы будет выглядеть так:
SET enable_partition_pruning = off;
EXPLAIN SELECT count(&lt;/em&gt;) FROM measurement WHERE logdate &amp;gt;= DATE ‘2008-01-01’;
QUERY PLAN
———————————————————————————–
Aggregate (cost=188.76..188.77 rows=1 width=8)
-&amp;gt; Append (cost=0.00..181.05 rows=3085 width=0)
-&amp;gt; Seq Scan on measurement_y2006m02 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &amp;gt;= ‘2008-01-01’::date)
-&amp;gt; Seq Scan on measurement_y2006m03 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &amp;gt;= ‘2008-01-01’::date)
…
-&amp;gt; Seq Scan on measurement_y2007m11 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &amp;gt;= ‘2008-01-01’::date)
-&amp;gt; Seq Scan on measurement_y2007m12 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &amp;gt;= ‘2008-01-01’::date)
-&amp;gt; Seq Scan on measurement_y2008m01 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &amp;gt;= ‘2008-01-01’::date)
В некоторых или всех секциях может применяться не полное последовательное сканирование,
а сканирование по индексу, но основная идея примера в том, что для удовлетворения запроса
не нужно сканировать старые секции. И когда мы включаем устранение секций, мы получаем
значительно более эффективный план, дающий тот же результат:
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &amp;gt;= DATE ‘2008-01-01’;
QUERY PLAN
———————————————————————————–
Aggregate (cost=37.75..37.76 rows=1 width=8)
-&amp;gt; Append (cost=0.00..36.21 rows=617 width=0)
-&amp;gt; Seq Scan on measurement_y2008m01 (cost=0.00..33.12 rows=617 width=0)
Filter: (logdate &amp;gt;= ‘2008-01-01’::date)
Заметьте, что механизм устранения секций учитывает только ограничения, определённые неявно
ключами разбиения, но не наличие индексов. Поэтому определять индексы для столбцов ключа не
обязательно. Нужно ли создавать индекс для определённой секции, зависит от того, какую часть
84Определение данных
секции (меньшую или большую), по вашим представлениям, будут сканировать запросы, обраща-
ющиеся к этой секции. Индекс будет полезен в первом случае, но не во втором.
Устранение секций может производиться не только при планировании конкретного запроса, но и в
процессе его выполнения. Благодаря этому может быть устранено больше секций, когда условные
выражения содержат значения, неизвестные во время планирования; например, это могут быть
параметры, определённые оператором PREPARE, значения, получаемые из подзапросов, или пара-
метризованные значения во внутренней стороне соединения с вложенным циклом. Устранение
секций во время выполнения запроса возможно в следующие моменты времени:
• Во время подготовки плана запроса. В этот момент можно устранить секции, учитывая зна-
чения параметров, известные при подготовке выполнения запроса. Секции, устранённые на
этом этапе, не будут видны в выводе EXPLAIN или EXPLAIN ANALYZE. Их общее количество мож-
но определить по свойству «Subplans Removed» в выводе EXPLAIN.
• В процессе собственно выполнения плана запроса. Устранение секций также может выпол-
няться на этом этапе и позволяет отфильтровать секции, используя значения, которые ста-
новятся известны, когда запрос выполняется фактически. В частности это могут быть значе-
ния из подзапросов и значения параметров времени выполнения, например из параметри-
зованных соединений с вложенными циклами. Так как значение этих параметров может ме-
няться многократно при выполнении запроса, устранение секций выполняется при измене-
нии любого из параметров, анализируемых механизмом устранения. Чтобы определить, были
ли секции устранены на данном этапе, нужно внимательно изучить свойство nloops в выводе
EXPLAIN ANALYZE.
Устранение секций можно отключить, воспользовавшись параметром enable_partition_pruning.
Примечание
В настоящее время устранение секций при планировании выполнения команд UPDATE
и DELETE реализовано посредством метода исключения по ограничению (однако оно
управляется параметром enable_partition_pruning, а не constraint_exclusion) — по-
дробности и замечания приведены в следующем разделе.
Кроме того, в настоящее время устранение секций в процессе выполнения распростра-
няется только на узлы типа Append, но не MergeAppend.
И то, и другое поведение скорее всего будет изменено в будущем выпуске PostgreSQL.
5.10.5. Секционирование и исключение по ограничению
Исключение по ограничению — приём оптимизации запросов, подобный устранению секций.
Прежде всего он применяется, когда секционирование осуществляется с использованием старо-
го метода наследования, но он может быть полезен и для других целей, включая декларативное
секционирование.
Исключение по ограничению работает во многом так же, как и устранение секций; отличие со-
стоит в том, что оно использует ограничения CHECK всех таблиц (поэтому оно так и называется),
тогда как для устранения секций используются границы секции, которые существуют только в
случае декларативного секционирования. Ещё одно различие состоит в том, что исключение по
ограничению применяется только во время планирования; во время выполнения секции из плана
удаляться не будут.
То, что исключение по ограничению использует ограничения CHECK (вследствие чего оно работает
медленнее устранения секций), иногда может быть и преимуществом. Ограничения могут быть
определены даже для декларативно секционированных таблиц, в дополнение к внутренним грани-
цам секций, и тогда исключение по ограничению сможет дополнительно убрать некоторые секции
из плана запроса.
85Определение данных
По умолчанию параметр constraint_exclusion имеет значение не on и не off, а промежуточное (и
рекомендуемое) значение partition, при котором этот приём будет применяться только к запро-
сам, где предположительно будут задействованы таблицы, секционированные с использованием
наследования. Значение on обязывает планировщик просматривать ограничения CHECK во всех за-
просах, даже в самых простых, где выигрыш от исключения по ограничению маловероятен.
Применяя исключения по ограничению, необходимо учитывать следующее:
• Исключение по ограничению применяется только при планировании запросов; в отличие от
устранения секций, оно не может осуществляться при выполнении запроса.
• Исключение по ограничению работает только когда предложение WHERE в запросе содержит
константы (или получаемые извне параметры). Например, сравнение с функцией переменной
природы, такой как CURRENT_TIMESTAMP, нельзя оптимизировать, так как планировщик не зна-
ет, в какую дочернюю таблицу попадёт значение функции во время выполнения.
• Ограничения секций должны быть простыми, иначе планировщик не сможет вычислить, ка-
кие дочерние таблицы не нужно обрабатывать. Для секционирования по спискам используй-
те простые условия на равенства, а для секционирования по диапазонам — простые проверки
диапазонов, подобные показанным в примерах. Рекомендуется создавать ограничения секций,
содержащие только такие сравнения секционирующих столбцов с константами, в которых ис-
пользуются операторы, поддерживающие B-деревья. Это объясняется тем, что в ключе разби-
ения допускаются только такие столбцы, которые могут быть проиндексированы в B-дереве.
• При анализе для исключения по ограничению исследуются все ограничения всех дочерних
таблиц, относящихся к главной, так что при большом их количестве время планирования за-
просов может значительно увеличиться. Поэтому устаревший вариант секционирования, ос-
нованный на наследовании, будет работать хорошо, пока количество дочерних таблиц не пре-
вышает примерно ста; не пытайтесь применять его с тысячами дочерних таблиц.
5.11. Сторонние данные
PostgreSQL частично реализует спецификацию SQL/MED, позволяя вам обращаться к данным, на-
ходящимся снаружи, используя обычные SQL-запросы. Такие данные называются сторонними.
Сторонние данные доступны в PostgreSQL через обёртку сторонних данных. Обёртка сторонних
данных — это библиотека, взаимодействующая с внешним источником данных и скрывающая в се-
бе внутренние особенности подключения и получения данных. Несколько готовых обёрток предо-
ставляются в виде модулей contrib ; см. Приложение F. Также вы можете найти другие обёртки,
выпускаемые как дополнительные продукты. Если ни одна из существующих обёрток вас не устра-
ивает, вы можете написать свою собственную (см. Главу 57).
Чтобы обратиться к сторонним данным, вы должны создать объект сторонний сервер, в котором
настраивается подключение к внешнему источнику данных, определяются параметры соответ-
ствующей обёртки сторонних данных. Затем вы должны создать одну или несколько сторонних
таблиц, определив тем самым структуру внешних данных. Сторонние таблицы можно использо-
вать в запросах так же, как и обычные, но их данные не хранятся на сервере PostgreSQL. При каж-
дом запросе PostgreSQL обращается к обёртке сторонних данных, которая, в свою очередь, полу-
чает данные из внешнего источника или передаёт их ему (в случае команд INSERT или UPDATE).
При обращении к внешним данным удалённый источник может потребовать аутентификации кли-
ента. Соответствующие учётные данные можно предоставить с помощью сопоставлений пользо-
вателей, позволяющих определить в частности имена и пароли, в зависимости от текущей роли
пользователя PostgreSQL.
Дополнительную информацию вы найдёте в CREATE FOREIGN DATA WRAPPER, CREATE SERVER,
CREATE USER MAPPING, CREATE FOREIGN TABLE и IMPORT FOREIGN SCHEMA.
5.12. Другие объекты баз данных
Таблицы — центральные объекты в структуре реляционной базы данных, так как они содержат
ваши данные. Но это не единственные объекты, которые могут в ней существовать. Помимо них вы
86Определение данных
можете создавать и использовать объекты и других типов, призванные сделать управление данны-
ми эффективнее и удобнее. Они не обсуждаются в этой главе, но мы просто перечислим некоторые
из них, чтобы вы знали об их существовании:
• Представления
• Функции, процедуры и операторы
• Типы данных и домены
• Триггеры и правила перезаписи
Подробнее соответствующие темы освещаются в Части V.
5.13. Отслеживание зависимостей
Когда вы создаёте сложные структуры баз данных, включающие множество таблиц с внешними
ключами, представлениями, триггерами, функциями и т. п., вы неявно создаёте сеть зависимостей
между объектами. Например, таблица с ограничением внешнего ключа зависит от таблицы, на
которую она ссылается.
Для сохранения целостности структуры всей базы данных, PostgreSQL не позволяет удалять объ-
екты, от которых зависят другие. Например, попытка удалить таблицу products (мы рассматривали
её в Подразделе 5.3.5), от которой зависит таблица orders, приведёт к ошибке примерно такого
содержания:
DROP TABLE products;
ОШИБКА: удалить объект “таблица products” нельзя, так как от него зависят другие
ПОДРОБНОСТИ: ограничение orders_product_no_fkey в отношении “таблица orders” зависит
от объекта “таблица products”
ПОДСКАЗКА: Для удаления зависимых объектов используйте DROP … CASCADE.
Сообщение об ошибке даёт полезную подсказку: если вы не хотите заниматься ликвидацией зави-
симостей по отдельности, можно выполнить:
DROP TABLE products CASCADE;
и все зависимые объекты, а также объекты, зависящие от них, будут удалены рекурсивно. В этом
случае таблица orders останется, а удалено будет только её ограничение внешнего ключа. Удале-
ние не распространится на другие объекты, так как ни один объект не зависит от этого ограни-
чения. (Если вы хотите проверить, что произойдёт при выполнении DROP … CASCADE, запустите
DROP без CASCADE и прочитайте ПОДРОБНОСТИ (DETAIL).)
Почти все команды DROP в PostgreSQL поддерживают указание CASCADE. Конечно, вид возможных
зависимостей зависит от типа объекта. Вы также можете написать RESTRICT вместо CASCADE, чтобы
включить поведение по умолчанию, когда объект можно удалить, только если от него не зависят
никакие другие.
Примечание
Стандарт SQL требует явного указания RESTRICT или CASCADE в команде DROP. Но это
требование на самом деле не выполняется ни в одной СУБД, при этом одни системы по
умолчанию подразумевают RESTRICT, а другие — CASCADE.
Если в команде DROP перечисляются несколько объектов, CASCADE требуется указывать, только ко-
гда есть зависимости вне заданной группы. Например, в команде DROP TABLE tab1, tab2 при на-
личии внешнего ключа, ссылающегося на tab1 из tab2, можно не указывать CASCADE, чтобы она
выполнилась успешно.
Для пользовательских функций PostgreSQL отслеживает зависимости, связанные с внешне види-
мыми свойствами функции, такими как типы аргументов и результата, но не зависимости, которые
87Определение данных
могут быть выявлены только при анализе тела функции. В качестве примера рассмотрите следу-
ющий сценарий:
CREATE TYPE rainbow AS ENUM (‘red’, ‘orange’, ‘yellow’,
‘green’, ‘blue’, ‘purple’);
CREATE TABLE my_colors (color rainbow, note text);
CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
‘SELECT note FROM my_colors WHERE color = $1’
LANGUAGE SQL;
(Описание функций языка SQL можно найти в Разделе 38.5.) PostgreSQL будет понимать, что функ-
ция get_color_note зависит от типа rainbow: при удалении типа будет принудительно удалена
функция, так как тип её аргумента оказывается неопределённым. Но PostgreSQL не будет учиты-
вать зависимость get_color_note от таблицы my_colors и не удалит функцию при удалении табли-
цы. Но у этого подхода есть не только минус, но и плюс. В случае отсутствия таблицы эта функция
останется рабочей в некотором смысле: хотя при попытке выполнить её возникнет ошибка, но при
создании новой таблицы с тем же именем функция снова будет работать.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 5. Определение данных</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 6. Модификация данных</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-006/" rel="alternate" type="text/html" title="Глава 6. Модификация данных" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-006</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-006/">&lt;p&gt;Глава 6. Модификация данных&lt;/p&gt;

&lt;p&gt;В предыдущей главе мы обсуждали, как создавать таблицы и другие структуры для хранения дан-
ных. Теперь пришло время заполнить таблицы данными. В этой главе мы расскажем, как добав-
лять, изменять и удалять данные из таблиц. А из следующей главы вы наконец узнаете, как извле-
кать нужные вам данные из базы данных.
6.1. Добавление данных
Сразу после создания таблицы она не содержит никаких данных. Поэтому, чтобы она была полез-
на, в неё прежде всего нужно добавить данные. По сути данные добавляются в таблицу по одной
строке. И хотя вы конечно можете добавить в таблицу несколько строк, добавить в неё меньше,
чем строку, невозможно. Даже если вы указываете значения только некоторых столбцов, создаёт-
ся полная строка.
Чтобы создать строку, вы будете использовать команду INSERT. В этой команде необходимо ука-
зать имя таблицы и значения столбцов. Например, рассмотрим таблицу товаров из Главы 5:
CREATE TABLE products (
product_no integer,
name text,
price numeric
);
Добавить в неё строку можно было бы так:
INSERT INTO products VALUES (1, ‘Cheese’, 9.99);
Значения данных перечисляются в порядке столбцов в таблице и разделяются запятыми. Обычно
в качестве значений указываются константы, но это могут быть и скалярные выражения.
Показанная выше запись имеет один недостаток — вам необходимо знать порядок столбцов в таб-
лице. Чтобы избежать этого, можно перечислить столбцы явно. Например, следующие две коман-
ды дадут тот же результат, что и показанная выше:
INSERT INTO products (product_no, name, price) VALUES (1, ‘Cheese’, 9.99);
INSERT INTO products (name, price, product_no) VALUES (‘Cheese’, 9.99, 1);
Многие считают, что лучше всегда явно указывать имена столбцов.
Если значения определяются не для всех столбцов, лишние столбцы можно опустить. В таком
случае эти столбцы получат значения по умолчанию. Например:
INSERT INTO products (product_no, name) VALUES (1, ‘Cheese’);
INSERT INTO products VALUES (1, ‘Cheese’);
Вторая форма является расширением PostgreSQL. Она заполняет столбцы слева по числу передан-
ных значений, а все остальные столбцы принимают значения по умолчанию.
Для ясности можно также явно указать значения по умолчанию для отдельных столбцов или всей
строки:
INSERT INTO products (product_no, name, price) VALUES (1, ‘Cheese’, DEFAULT);
INSERT INTO products DEFAULT VALUES;
Одна команда может вставить сразу несколько строк:
INSERT INTO products (product_no, name, price) VALUES
(1, ‘Cheese’, 9.99),
(2, ‘Bread’, 1.99),
(3, ‘Milk’, 2.99);
Также возможно вставить результат запроса (который может не содержать строк либо содержать
одну или несколько):
89Модификация данных
INSERT INTO products (product_no, name, price)
SELECT product_no, name, price FROM new_products
WHERE release_date = ‘today’;
Это позволяет использовать все возможности механизма запросов SQL (см. Главу 7) для вычисле-
ния вставляемых строк.
Подсказка
Когда нужно добавить сразу множество строк, возможно будет лучше использовать ко-
манду COPY. Она не такая гибкая, как INSERT, но гораздо эффективнее. Дополнитель-
но об ускорении массовой загрузки данных можно узнать в Разделе 14.4.
6.2. Изменение данных
Модификация данных, уже сохранённых в БД, называется изменением. Изменить можно все стро-
ки таблицы, либо подмножество всех строк, либо только избранные строки. Каждый столбец при
этом можно изменять независимо от других.
Для изменения данных в существующих строках используется команда UPDATE. Ей требуется сле-
дующая информация:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Имя таблицы и изменяемого столбца&lt;/li&gt;
  &lt;li&gt;Новое значение столбца&lt;/li&gt;
  &lt;li&gt;Критерий отбора изменяемых строк
Если вы помните, в Главе 5 говорилось, что в SQL в принципе нет уникального идентификатора
строк. Таким образом, не всегда возможно явно указать на строку, которую требуется изменить.
Поэтому необходимо указать условия, каким должны соответствовать требуемая строка. Только
если в таблице есть первичный ключ (вне зависимости от того, объявляли вы его или нет), можно
однозначно адресовать отдельные строки, определив условие по первичному ключу. Этим пользу-
ются графические инструменты для работы с базой данных, дающие возможность редактировать
данные по строкам.
Например, следующая команда увеличивает цену всех товаров, имевших до этого цену 5, до 10:
UPDATE products SET price = 10 WHERE price = 5;
В результате может измениться ноль, одна или множество строк. И если этому запросу не будет
удовлетворять ни одна строка, это не будет ошибкой.
Давайте рассмотрим эту команду подробнее. Она начинается с ключевого слова UPDATE, за кото-
рым идёт имя таблицы. Как обычно, имя таблицы может быть записано в полной форме, в против-
ном случае она будет найдена по пути. Затем идёт ключевое слово SET, за которым следует имя
столбца, знак равенства и новое значение столбца. Этим значением может быть любое скалярное
выражение, а не только константа. Например, если вы захотите поднять цену всех товаров на 10%,
это можно сделать так:
UPDATE products SET price = price * 1.10;
Как видно из этого примера, выражение нового значения может ссылаться на существующие зна-
чения столбцов в строке. Мы также опустили в нём предложение WHERE. Это означает, что будут
изменены все строки в таблице. Если же это предложение присутствует, изменяются только стро-
ки, которые соответствуют условию WHERE. Заметьте, что хотя знак равенства в предложении SET
обозначает операцию присваивания, а такой же знак в предложении WHERE используется для срав-
нения, это не приводит к неоднозначности. И конечно, в условии WHERE не обязательно должна
быть проверка равенства, а могут применяться и другие операторы (см. Главу 9). Необходимо толь-
ко, чтобы это выражение возвращало логический результат.
В команде UPDATE можно изменить значения сразу нескольких столбцов, перечислив их в предло-
жении SET. Например:
90Модификация данных
UPDATE mytable SET a = 5, b = 3, c = 1 WHERE a &amp;gt; 0;
6.3. Удаление данных
Мы рассказали о том, как добавлять данные в таблицы и как изменять их. Теперь вам осталось
узнать, как удалить данные, которые оказались не нужны. Так же, как добавлять данные можно
только целыми строками, удалять их можно только по строкам. В предыдущем разделе мы отмети-
ли, что в SQL нет возможности напрямую адресовать отдельные строки, так что удалить избранные
строки можно, только сформулировав для них подходящие условия. Но если в таблице есть пер-
вичный ключ, с его помощью можно однозначно выделить определённую строку. При этом можно
так же удалить группы строк, соответствующие условию, либо сразу все строки таблицы.
Для удаления строк используется команда DELETE; её синтаксис очень похож на синтаксис ко-
манды UPDATE. Например, удалить все строки из таблицы с товарами, имеющими цену 10, можно
так:
DELETE FROM products WHERE price = 10;
Если вы напишете просто:
DELETE FROM products;
будут удалены все строки таблицы! Будьте осторожны!
6.4. Возврат данных из изменённых строк
Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это
возможно с использованием предложения RETURNING, которое можно задать для команд INSERT,
UPDATE и DELETE. Применение RETURNING позволяет обойтись без дополнительного запроса к базе
для сбора данных и это особенно ценно, когда как-то иначе трудно получить изменённые строки
надёжным образом.
В предложении RETURNING допускается то же содержимое, что и в выходном списке команды
SELECT (см. Раздел 7.3). Оно может содержать имена столбцов целевой таблицы команды или зна-
чения выражений с этими столбцами. Также часто применяется краткая запись RETURNING *, вы-
бирающая все столбцы целевой таблицы по порядку.
В команде INSERT данные, выдаваемые в RETURNING, образуются из строки в том виде, в каком она
была вставлена. Это не очень полезно при простом добавлении, так как в результате будут полу-
чены те же данные, что были переданы клиентом. Но это может быть очень удобно при исполь-
зовании вычисляемых значений по умолчанию. Например, если в таблице есть столбец serial, в
котором генерируются уникальные идентификаторы, команда RETURNING может возвратить иден-
тификатор, назначенный новой строке:
CREATE TABLE users (firstname text, lastname text, id serial primary key);
INSERT INTO users (firstname, lastname) VALUES (‘Joe’, ‘Cool’) RETURNING id;
Предложение RETURNING также очень полезно с INSERT … SELECT.
В команде UPDATE данные, выдаваемые в RETURNING, образуются новым содержимым изменённой
строки. Например:
UPDATE products SET price = price * 1.10
WHERE price &amp;lt;= 99.99
RETURNING name, price AS new_price;
В команде DELETE данные, выдаваемые в RETURNING, образуются содержимым удалённой строки.
Например:
DELETE FROM products
WHERE obsoletion_date = ‘today’
91Модификация данных
RETURNING *;
Если для целевой таблицы заданы триггеры (см. Главу 39), в RETURNING выдаются данные из стро-
ки, изменённой триггерами. Таким образом, RETURNING часто применяется и для того, чтобы про-
верить содержимое столбцов, изменяемых триггерами.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 6. Модификация данных</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 7. Запросы</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-007/" rel="alternate" type="text/html" title="Глава 7. Запросы" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-007</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-007/">&lt;p&gt;Глава 7. Запросы&lt;/p&gt;

&lt;p&gt;В предыдущих главах рассказывалось, как создать таблицы, как заполнить их данными и как из-
менить эти данные. Теперь мы наконец обсудим, как получить данные из базы данных.&lt;/p&gt;

&lt;p&gt;7.1. Обзор&lt;/p&gt;

&lt;p&gt;Процесс или команда получения данных из базы данных называется запросом. В SQL запросы
формулируются с помощью команды SELECT. В общем виде команда SELECT записывается так:
[WITH запросы_with] SELECT список_выборки FROM табличное_выражение
[определение_сортировки]
В следующих разделах подробно описываются список выборки, табличное выражение и определе-
ние сортировки. Запросы WITH являются расширенной возможностью PostgreSQL и будут рассмот-
рены в последнюю очередь.
Простой запрос выглядит так:
SELECT * FROM table1;
Если предположить, что в базе данных есть таблица table1, эта команда получит все строки с
содержимым всех столбцов из table1. (Метод выдачи результата определяет клиентское прило-
жение. Например, программа psql выведет на экране ASCII-таблицу, хотя клиентские библиотеки
позволяют извлекать отдельные значения из результата запроса.) Здесь список выборки задан как
*, это означает, что запрос должен вернуть все столбцы табличного выражения. В списке выборки
можно также указать подмножество доступных столбцов или составить выражения с этими столб-
цами. Например, если в table1 есть столбцы a, b и c (и возможно, другие), вы можете выполнить
следующий запрос:
SELECT a, b + c FROM table1;
(в предположении, что столбцы b и c имеют числовой тип данных). Подробнее это описано в Раз-
деле 7.3.
FROM table1 — это простейший тип табличного выражения, в котором просто читается одна таб-
лица. Вообще табличные выражения могут быть сложными конструкциями из базовых таблиц, со-
единений и подзапросов. А можно и вовсе опустить табличное выражение и использовать команду
SELECT как калькулятор:
SELECT 3 * 4;
В этом может быть больше смысла, когда выражения в списке выборки возвращают меняющиеся
результаты. Например, можно вызвать функцию так:
SELECT random();
7.2. Табличные выражения
Табличное выражение вычисляет таблицу. Это выражение содержит предложение FROM, за кото-
рым могут следовать предложения WHERE, GROUP BY и HAVING. Тривиальные табличные выражения
просто ссылаются на физическую таблицу, её называют также базовой, но в более сложных выра-
жениях такие таблицы можно преобразовывать и комбинировать самыми разными способами.
Необязательные предложения WHERE, GROUP BY и HAVING в табличном выражении определяют по-
следовательность преобразований, осуществляемых с данными таблицы, полученной в предложе-
нии FROM. В результате этих преобразований образуется виртуальная таблица, строки которой пе-
редаются списку выборки, вычисляющему выходные строки запроса.
7.2.1. Предложение FROM
«Предложение FROM» образует таблицу из одной или нескольких ссылок на таблицы, разделённых
запятыми.
93Запросы
FROM табличная_ссылка [, табличная_ссылка [, …]]
Здесь табличной ссылкой может быть имя таблицы (возможно, с именем схемы), производная таб-
лица, например подзапрос, соединение таблиц или сложная комбинация этих вариантов. Если в
предложении FROM перечисляются несколько ссылок, для них применяется перекрёстное соеди-
нение (то есть декартово произведение их строк; см. ниже). Список FROM преобразуется в проме-
жуточную виртуальную таблицу, которая может пройти через преобразования WHERE, GROUP BY и
HAVING, и в итоге определит результат табличного выражения.
Когда в табличной ссылке указывается таблица, являющаяся родительской в иерархии наследова-
ния, в результате будут получены строки не только этой таблицы, но и всех её дочерних таблиц.
Чтобы выбрать строки только одной родительской таблицы, перед её именем нужно добавить клю-
чевое слово ONLY. Учтите, что при этом будут получены только столбцы указанной таблицы — до-
полнительные столбцы дочерних таблиц не попадут в результат.
Если же вы не добавляете ONLY перед именем таблицы, вы можете дописать после него *, тем са-
мым указав, что должны обрабатываться и все дочерние таблицы. Практических причин исполь-
зовать этот синтаксис больше нет, так как поиск в дочерних таблицах теперь производится по
умолчанию. Однако эта запись поддерживается для совместимости со старыми версиями.
7.2.1.1. Соединённые таблицы
Соединённая таблица — это таблица, полученная из двух других (реальных или производных от
них) таблиц в соответствии с правилами соединения конкретного типа. Общий синтаксис описания
соединённой таблицы:
T1 тип_соединения T2 [ условие_соединения ]
Соединения любых типов могут вкладываются друг в друга или объединяться: и T1, и T2 могут быть
результатами соединения. Для однозначного определения порядка соединений предложения JOIN
можно заключать в скобки. Если скобки отсутствуют, предложения JOIN обрабатываются слева
направо.
Типы соединений
Перекрёстное соединение
T1 CROSS JOIN T2
Соединённую таблицу образуют все возможные сочетания строк из T1 и T2 (т. е. их декарто-
во произведение), а набор её столбцов объединяет в себе столбцы T1 со следующими за ними
столбцами T2. Если таблицы содержат N и M строк, соединённая таблица будет содержать N&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;M строк.
FROM T1 CROSS JOIN T2 эквивалентно FROM T1 INNER JOIN T2 ON TRUE (см. ниже). Эта запись
также эквивалентна FROM T1, T2.
Примечание
Последняя запись не полностью эквивалентна первым при указании более чем двух
таблиц, так как JOIN связывает таблицы сильнее, чем запятая. Например, FROM T1
CROSS JOIN T2 INNER JOIN T3 ON условие не равнозначно FROM T1, T2 INNER
JOIN T3 ON условие, так как условие может ссылаться на T1 в первом случае, но
не во втором.
Соединения с сопоставлениями строк
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
ON логическое_выражение
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
USING ( список столбцов соединения )
94Запросы
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
Слова INNER и OUTER необязательны во всех формах. По умолчанию подразумевается INNER
(внутреннее соединение), а при указании LEFT, RIGHT и FULL — внешнее соединение.
Условие соединения указывается в предложении ON или USING, либо неявно задаётся ключе-
вым словом NATURAL. Это условие определяет, какие строки двух исходных таблиц считаются
«соответствующими» друг другу (это подробно рассматривается ниже).
Возможные типы соединений с сопоставлениями строк:
INNER JOIN
Для каждой строки R1 из T1 в результирующей таблице содержится строка для каждой
строки в T2, удовлетворяющей условию соединения с R1.
LEFT OUTER JOIN
Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляют-
ся все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений
столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет
минимум одна строка для каждой строки из T1.
RIGHT OUTER JOIN
Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляют-
ся все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений
столбцов T1 вставляются NULL. Это соединение является обратным к левому (LEFT JOIN):
в результирующей таблице всегда будет минимум одна строка для каждой строки из T2.
FULL OUTER JOIN
Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из
T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставля-
ются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют
никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.
Предложение ON определяет наиболее общую форму условия соединения: в нём указываются
выражения логического типа, подобные тем, что используются в предложении WHERE. Пара
строк из T1 и T2 соответствуют друг другу, если выражение ON возвращает для них true.
USING — это сокращённая запись условия, полезная в ситуации, когда с обеих сторон соедине-
ния столбцы имеют одинаковые имена. Она принимает список общих имён столбцов через за-
пятую и формирует условие соединения с равенством этих столбцов. Например, запись соеди-
нения T1 и T2 с USING (a, b) формирует условие ON T1.a = T2.a AND T1.b = T2.b.
Более того, при выводе JOIN USING исключаются избыточные столбцы: оба сопоставленных
столбца выводить не нужно, так как они содержат одинаковые значения. Тогда как JOIN ON
выдаёт все столбцы из T1, а за ними все столбцы из T2, JOIN USING выводит один столбец для
каждой пары (в указанном порядке), за ними все оставшиеся столбцы из T1 и, наконец, все
оставшиеся столбцы T2.
Наконец, NATURAL — сокращённая форма USING: она образует список USING из всех имён столб-
цов, существующих в обеих входных таблицах. Как и с USING, эти столбцы оказываются в выход-
ной таблице в единственном экземпляре. Если столбцов с одинаковыми именами не находится,
NATURAL JOIN действует как JOIN … ON TRUE и выдаёт декартово произведение строк.
Примечание
Предложение USING разумно защищено от изменений в соединяемых отношениях,
так как оно связывает только явно перечисленные столбцы. NATURAL считается бо-
лее рискованным, так как при любом изменении схемы в одном или другом отноше-
95Запросы
нии, когда появляются столбцы с совпадающими именами, при соединении будут
связываться и эти новые столбцы.
Для наглядности предположим, что у нас есть таблицы t1:
num | name
—–+——
1 | a
2 | b
3 | c
и t2:
num | value
—–+——-
1 | xxx
3 | yyy
5 | zzz
С ними для разных типов соединений мы получим следующие результаты:
=&amp;gt; SELECT * FROM t1 CROSS JOIN t2;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
1 | a
|
3 | yyy
1 | a
|
5 | zzz
2 | b
|
1 | xxx
2 | b
|
3 | yyy
2 | b
|
5 | zzz
3 | c
|
1 | xxx
3 | c
|
3 | yyy
3 | c
|
5 | zzz
(9 rows)
=&amp;gt; SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
3 | c
|
3 | yyy
(2 rows)
=&amp;gt; SELECT * FROM t1 INNER JOIN t2 USING (num);
num | name | value
—–+——+——-
1 | a
| xxx
3 | c
| yyy
(2 rows)
=&amp;gt; SELECT * FROM t1 NATURAL INNER JOIN t2;
num | name | value
—–+——+——-
1 | a
| xxx
3 | c
| yyy
(2 rows)
=&amp;gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
96Запросы
2 | b
3 | c
(3 rows)
|
|
|
3 | yyy
=&amp;gt; SELECT * FROM t1 LEFT JOIN t2 USING (num);
num | name | value
—–+——+——-
1 | a
| xxx
2 | b
|
3 | c
| yyy
(3 rows)
=&amp;gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
3 | c
|
3 | yyy
|
|
5 | zzz
(3 rows)
=&amp;gt; SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
2 | b
|
|
3 | c
|
3 | yyy
|
|
5 | zzz
(4 rows)
Условие соединения в предложении ON может также содержать выражения, не связанные непо-
средственно с соединением. Это может быть полезно в некоторых запросах, но не следует исполь-
зовать это необдуманно. Рассмотрите следующий запрос:
=&amp;gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = ‘xxx’;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
2 | b
|
|
3 | c
|
|
(3 rows)
Заметьте, что если поместить ограничение в предложение WHERE, вы получите другой результат:
=&amp;gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = ‘xxx’;
num | name | num | value
—–+——+—–+——-
1 | a
|
1 | xxx
(1 row)
Это связано с тем, что ограничение, помещённое в предложение ON, обрабатывается до операции
соединения, тогда как ограничение в WHERE — после. Это не имеет значения при внутренних со-
единениях, но важно при внешних.
7.2.1.2. Псевдонимы таблиц и столбцов
Таблицам и ссылкам на сложные таблицы в запросе можно дать временное имя, по которому к ним
можно будет обращаться в рамках запроса. Такое имя называется псевдонимом таблицы.
Определить псевдоним таблицы можно, написав
FROM табличная_ссылка AS псевдоним
97Запросы
или
FROM табличная_ссылка псевдоним
Ключевое слово AS является необязательным. Вместо псевдоним здесь может быть любой иденти-
фикатор.
Псевдонимы часто применяются для назначения коротких идентификаторов длинным именам таб-
лиц с целью улучшения читаемости запросов. Например:
SELECT * FROM “очень_длинное_имя_таблицы” s JOIN “другое_длинное_имя” a
ON s.id = a.num;
Псевдоним становится новым именем таблицы в рамках текущего запроса, т. е. после назначения
псевдонима использовать исходное имя таблицы в другом месте запроса нельзя. Таким образом,
следующий запрос недопустим:
SELECT * FROM my_table AS m WHERE my_table.a &amp;gt; 5;
– неправильно
Хотя в основном псевдонимы используются для удобства, они бывают необходимы, когда таблица
соединяется сама с собой, например:
SELECT * FROM people AS mother JOIN people AS child
ON mother.id = child.mother_id;
Кроме того, псевдонимы обязательно нужно назначать подзапросам (см. Подраздел 7.2.1.3).
В случае неоднозначности определения псевдонимов можно использовать скобки. В следующем
примере первый оператор назначает псевдоним b второму экземпляру my_table, а второй оператор
назначает псевдоним результату соединения:
SELECT * FROM my_table AS a CROSS JOIN my_table AS b …
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b …
В другой форме назначения псевдонима временные имена даются не только таблицам, но и её
столбцам:
FROM табличная_ссылка [AS] псевдоним ( столбец1 [, столбец2 [, …]] )
Если псевдонимов столбцов оказывается меньше, чем фактически столбцов в таблице, остальные
столбцы сохраняют свои исходные имена. Эта запись особенно полезна для замкнутых соединений
или подзапросов.
Когда псевдоним применяется к результату JOIN, он скрывает оригинальные имена таблиц внутри
JOIN. Например, это допустимый SQL-запрос:
SELECT a.* FROM my_table AS a JOIN your_table AS b ON …
а запрос:
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON …) AS c
ошибочный, так как псевдоним таблицы a не виден снаружи определения псевдонима c.
7.2.1.3. Подзапросы
Подзапросы, образующие таблицы, должны заключаться в скобки и им обязательно должны на-
значаться псевдонимы (как описано в Подразделе 7.2.1.2). Например:
FROM (SELECT * FROM table1) AS псевдоним
Этот пример равносилен записи FROM table1 AS псевдоним. Более интересные ситуации, которые
нельзя свести к простому соединению, возникают, когда в подзапросе используются агрегирую-
щие функции или группировка.
Подзапросом может также быть список VALUES:
FROM (VALUES (‘anne’, ‘smith’), (‘bob’, ‘jones’), (‘joe’, ‘blow’))
98Запросы
AS names(first, last)
Такому подзапросу тоже требуется псевдоним. Назначать псевдонимы столбцам списка VALUES не
требуется, но вообще это хороший приём. Подробнее это описано в Разделе 7.7.
7.2.1.4. Табличные функции
Табличные функции — это функции, выдающие набор строк, содержащих либо базовые типы дан-
ных (скалярных типов), либо составные типы (табличные строки). Они применяются в запросах как
таблицы, представления или подзапросы в предложении FROM. Столбцы, возвращённые табличны-
ми функциями, можно включить в выражения SELECT, JOIN или WHERE так же, как столбцы таблиц,
представлений или подзапросов.
Табличные функции можно также скомбинировать, используя запись ROWS FROM. Результаты функ-
ций будут возвращены в параллельных столбцах; число строк в этом случае будет наибольшим из
результатов всех функций, а результаты функций с меньшим количеством строк будут дополнены
значениями NULL.
вызов_функции [WITH ORDINALITY] [[AS] псевдоним_таблицы [(псевдоним_столбца [, …])]]
ROWS FROM( вызов_функции [, …] ) [WITH ORDINALITY] [[AS] псевдоним_таблицы
[(псевдоним_столбца [, …])]]
Если указано предложение WITH ORDINALITY, к столбцам результатов функций будет добавлен ещё
один, с типом bigint. В этом столбце нумеруются строки результирующего набора, начиная с 1.
(Это обобщение стандартного SQL-синтаксиса UNNEST … WITH ORDINALITY.) По умолчанию, этот
столбец называется ordinality, но ему можно присвоить и другое имя с помощью указания AS.
Специальную табличную функцию UNNEST можно вызвать с любым числом параметров-массивов, а
возвращает она соответствующее число столбцов, как если бы UNNEST (Раздел 9.18) вызывалась для
каждого параметра в отдельности, а результаты объединялись с помощью конструкции ROWS FROM.
UNNEST( выражение_массива [, …] ) [WITH ORDINALITY] [[AS] псевдоним_таблицы
[(псевдоним_столбца [, …])]]
Если псевдоним_таблицы не указан, в качестве имени таблицы используется имя функции; в случае
с конструкцией ROWS FROM() — имя первой функции.
Если псевдонимы столбцов не указаны, то для функции, возвращающей базовый тип данных, име-
нем столбца будет имя функции. Для функций, возвращающих составной тип, имена результиру-
ющих столбцов определяются индивидуальными атрибутами типа.
Несколько примеров:
CREATE TABLE foo (fooid int, foosubid int, fooname text);
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS &lt;script type=&quot;math/tex&quot;&gt;SELECT * FROM foo WHERE fooid = $1;&lt;/script&gt; LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
SELECT * FROM foo
WHERE foosubid IN (
SELECT foosubid
FROM getfoo(foo.fooid) z
WHERE z.fooid = foo.fooid
);
CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
99Запросы
В некоторых случаях бывает удобно определить табличную функцию, возвращающую различные
наборы столбцов при разных вариантах вызова. Для этого нужно указать, что она возвращает псев-
дотип record. Используя такую функцию, ожидаемую структуру строк нужно описать в самом за-
просе, чтобы система знала, как разобрать запрос и составить его план. Записывается это так:
вызов_функции [AS] псевдоним (определение_столбца [, …])
вызов_функции AS [псевдоним] (определение_столбца [, …])
ROWS FROM( … вызов_функции AS (определение_столбца [, …]) [, …] )
Без ROWS FROM() список определения_столбцов заменяет список псевдонимов, который можно
также добавить в предложении FROM; имена в определениях столбцов служат псевдонимами. С ROWS
FROM() список определения_столбцов можно добавить к каждой функции отдельно, либо в случае с
одной функцией и без предложения WITH ORDINALITY, список определения_столбцов можно запи-
сать вместо списка с псевдонимами столбцов после ROWS FROM().
Взгляните на этот пример:
SELECT *
FROM dblink(‘dbname=mydb’, ‘SELECT proname, prosrc FROM pg_proc’)
AS t1(proname name, prosrc text)
WHERE proname LIKE ‘bytea%’;
Здесь функция dblink (из модуля dblink) выполняет удалённый запрос. Она объявлена как функция,
возвращающая тип record, так как он подойдёт для запроса любого типа. В этом случае фактиче-
ский набор столбцов функции необходимо описать в вызывающем её запросе, чтобы анализатор
запроса знал, например, как преобразовать &lt;em&gt;.
7.2.1.5. Подзапросы LATERAL
Перед подзапросами в предложении FROM можно добавить ключевое слово LATERAL. Это позволит
ссылаться в них на столбцы предшествующих элементов списка FROM. (Без LATERAL каждый подза-
прос выполняется независимо и поэтому не может обращаться к другим элементам FROM.)
Перед табличными функциями в предложении FROM также можно указать LATERAL, но для них это
ключевое слово необязательно; в аргументах функций в любом случае можно обращаться к столб-
цам в предыдущих элементах FROM.
Элемент LATERAL может находиться на верхнем уровне списка FROM или в дереве JOIN. В последнем
случае он может также ссылаться на любые элементы в левой части JOIN, справа от которого он
находится.
Когда элемент FROM содержит ссылки LATERAL, запрос выполняется следующим образом: сначала
для строки элемента FROM с целевыми столбцами, или набора строк из нескольких элементов FROM,
содержащих целевые столбцы, вычисляется элемент LATERAL со значениями этих столбцов. Затем
результирующие строки обычным образом соединяются со строками, из которых они были вычис-
лены. Эта процедура повторяется для всех строк исходных таблиц.
LATERAL можно использовать так:
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
Здесь это не очень полезно, так как тот же результат можно получить более простым и привычным
способом:
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
Применять LATERAL имеет смысл в основном, когда для вычисления соединяемых строк необ-
ходимо обратиться к столбцам других таблиц. В частности, это полезно, когда нужно пе-
редать значение функции, возвращающей набор данных. Например, если предположить, что
vertices(polygon) возвращает набор вершин многоугольника, близкие вершины многоугольников
из таблицы polygons можно получить так:
SELECT p1.id, p2.id, v1, v2
100Запросы
FROM polygons p1, polygons p2,
LATERAL vertices(p1.poly) v1,
LATERAL vertices(p2.poly) v2
WHERE (v1 &amp;lt;-&amp;gt; v2) &amp;lt; 10 AND p1.id != p2.id;
Этот запрос можно записать и так:
SELECT p1.id,
FROM polygons
polygons
WHERE (v1 &amp;lt;-&amp;gt;
p2.id, v1, v2
p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
p2 CROSS JOIN LATERAL vertices(p2.poly) v2
v2) &amp;lt; 10 AND p1.id != p2.id;
или переформулировать другими способами. (Как уже упоминалось, в данном примере ключевое
слово LATERAL не требуется, но мы добавили его для ясности.)
Особенно полезно бывает использовать LEFT JOIN с подзапросом LATERAL, чтобы исходные стро-
ки оказывались в результате, даже если подзапрос LATERAL не возвращает строк. Например, ес-
ли функция get_product_names() выдаёт названия продуктов, выпущенных определённым произ-
водителем, но о продукции некоторых производителей информации нет, мы можем найти, каких
именно, примерно так:
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
7.2.2. Предложение WHERE
«Предложение WHERE» записывается так:
WHERE условие_ограничения
где условие_ограничения — любое выражение значения (см. Раздел 4.2), выдающее результат типа
boolean.
После обработки предложения FROM каждая строка полученной виртуальной таблицы проходит
проверку по условию ограничения. Если результат условия равен true, эта строка остаётся в вы-
ходной таблице, а иначе (если результат равен false или NULL) отбрасывается. В условии ограни-
чения, как правило, задействуется минимум один столбец из таблицы, полученной на выходе FROM.
Хотя строго говоря, это не требуется, но в противном случае предложение WHERE будет бессмыс-
ленным.
Примечание
Условие для внутреннего соединения можно записать как в предложении WHERE, так и
в предложении JOIN. Например, это выражение:
FROM a, b WHERE a.id = b.id AND b.val &amp;gt; 5
равнозначно этому:
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &amp;gt; 5
и возможно, даже этому:
FROM a NATURAL JOIN b WHERE b.val &amp;gt; 5
Какой вариант выбрать, в основном дело вкуса и стиля. Вариант с JOIN внутри пред-
ложения FROM, возможно, не лучший с точки зрения совместимости с другими СУБД,
хотя он и описан в стандарте SQL. Но для внешних соединений других вариантов нет:
их можно записывать только во FROM. Предложения ON и USING во внешних соединениях
не равнозначны условию WHERE, так как они могут добавлять строки (для входных строк
без соответствия), а также удалять их из конечного результата.
Несколько примеров запросов с WHERE:
101Запросы
SELECT … FROM fdt WHERE c1 &amp;gt; 5
SELECT … FROM fdt WHERE c1 IN (1, 2, 3)
SELECT … FROM fdt WHERE c1 IN (SELECT c1 FROM t2)
SELECT … FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)
SELECT … FROM fdt WHERE c1 BETWEEN
(SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100
SELECT … FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &amp;gt; fdt.c1)
fdt — название таблицы, порождённой в предложении FROM. Строки, которые не соответствуют
условию WHERE, исключаются из fdt. Обратите внимание, как в качестве выражений значения ис-
пользуются скалярные подзапросы. Как и любые другие запросы, подзапросы могут содержать
сложные табличные выражения. Заметьте также, что fdt используется в подзапросах. Дополне-
ние имени c1 в виде fdt.c1 необходимо только, если в порождённой таблице в подзапросе также
оказывается столбец c1. Полное имя придаёт ясность даже там, где без него можно обойтись. Этот
пример показывает, как область именования столбцов внешнего запроса распространяется на все
вложенные в него внутренние запросы.
7.2.3. Предложения GROUP BY и HAVING
Строки порождённой входной таблицы, прошедшие фильтр WHERE, можно сгруппировать с помо-
щью предложения GROUP BY, а затем оставить в результате только нужные группы строк, исполь-
зуя предложение HAVING.
SELECT список_выборки
FROM …
[WHERE …]
GROUP BY группирующий_столбец [, группирующий_столбец]…
«Предложение GROUP BY» группирует строки таблицы, объединяя их в одну группу при совпадении
значений во всех перечисленных столбцах. Порядок, в котором указаны столбцы, не имеет значе-
ния. В результате наборы строк с одинаковыми значениями преобразуются в отдельные строки,
представляющие все строки группы. Это может быть полезно для устранения избыточности выход-
ных данных и/или для вычисления агрегатных функций, применённых к этим группам. Например:
=&amp;gt; SELECT * FROM test1;
x | y
—+—
a | 3
c | 2
b | 5
a | 1
(4 rows)
=&amp;gt; SELECT x FROM test1 GROUP BY x;
x
—
a
b
c
(3 rows)
Во втором запросе мы не могли написать SELECT * FROM test1 GROUP BY x, так как для столбца
y нет единого значения, связанного с каждой группой. Однако столбцы, по которым выполняется
группировка, можно использовать в списке выборки, так как они имеют единственное значение
в каждой группе.
102Запросы
Вообще говоря, в группированной таблице столбцы, не включённые в список GROUP BY, можно
использовать только в агрегатных выражениях. Пример такого агрегатного выражения:
=&amp;gt; SELECT x, sum(y) FROM test1 GROUP BY x;
x | sum
—+—–
a |
4
b |
5
c |
2
(3 rows)
Здесь sum — агрегатная функция, вычисляющая единственное значение для всей группы. Подроб-
ную информацию о существующих агрегатных функциях можно найти в Разделе 9.20.
Подсказка
Группировка без агрегатных выражений по сути выдаёт набор различающихся значе-
ний столбцов. Этот же результат можно получить с помощью предложения DISTINCT
(см. Подраздел 7.3.3).
Взгляните на следующий пример: в нём вычисляется общая сумма продаж по каждому продукту
(а не общая сумма по всем продуктам):
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
FROM products p LEFT JOIN sales s USING (product_id)
GROUP BY product_id, p.name, p.price;
В этом примере столбцы product_id, p.name и p.price должны присутствовать в списке GROUP BY,
так как они используются в списке выборки. Столбец s.units может отсутствовать в списке GROUP
BY, так как он используется только в агрегатном выражении (sum(…)), вычисляющем сумму про-
даж. Для каждого продукта этот запрос возвращает строку с итоговой суммой по всем продажам
данного продукта.
Если бы в таблице products по столбцу product_id был создан первичный ключ, тогда в данном
примере было бы достаточно сгруппировать строки по product_id, так как название и цена про-
дукта функционально зависят от кода продукта и можно однозначно определить, какое название
и цену возвращать для каждой группы по ID.
В стандарте SQL GROUP BY может группировать только по столбцам исходной таблицы, но расши-
рение PostgreSQL позволяет использовать в GROUP BY столбцы из списка выборки. Также возможна
группировка по выражениям, а не просто именам столбцов.
Если таблица была сгруппирована с помощью GROUP BY, но интерес представляют только неко-
торые группы, отфильтровать их можно с помощью предложения HAVING, действующего подобно
WHERE. Записывается это так:
SELECT список_выборки FROM … [WHERE …] GROUP BY …
HAVING логическое_выражение
В предложении HAVING могут использоваться и группирующие выражения, и выражения, не участ-
вующие в группировке (в этом случае это должны быть агрегирующие функции).
Пример:
=&amp;gt; SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &amp;gt; 3;
x | sum
—+—–
a |
4
b |
5
103Запросы
(2 rows)
=&amp;gt; SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &amp;lt; ‘c’;
x | sum
—+—–
a |
4
b |
5
(2 rows)
И ещё один более реалистичный пример:
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
FROM products p LEFT JOIN sales s USING (product_id)
WHERE s.date &amp;gt; CURRENT_DATE - INTERVAL ‘4 weeks’
GROUP BY product_id, p.name, p.price, p.cost
HAVING sum(p.price * s.units) &amp;gt; 5000;
В данном примере предложение WHERE выбирает строки по столбцу, не включённому в группировку
(выражение истинно только для продаж за последние четыре недели), тогда как предложение
HAVING отфильтровывает группы с общей суммой продаж больше 5000. Заметьте, что агрегатные
выражения не обязательно должны быть одинаковыми во всех частях запроса.
Если в запросе есть вызовы агрегатных функций, но нет предложения GROUP BY, строки всё равно
будут группироваться: в результате окажется одна строка группы (или возможно, ни одной строки,
если эта строка будет отброшена предложением HAVING). Это справедливо и для запросов, которые
содержат только предложение HAVING, но не содержат вызовы агрегатных функций и предложение
GROUP BY.
7.2.4. GROUPING SETS, CUBE и ROLLUP
Более сложные, чем описанные выше, операции группировки возможны с концепцией наборов
группирования. Данные, выбранные предложениями FROM и WHERE, группируются отдельно для
каждого заданного набора группирования, затем для каждой группы вычисляются агрегатные
функции как для простых предложений GROUP BY, и в конце возвращаются результаты. Например:
=&amp;gt; SELECT * FROM items_sold;
brand | size | sales
——-+——+——-
Foo
| L
| 10
Foo
| M
| 20
Bar
| M
| 15
Bar
| L
| 5
(4 rows)
=&amp;gt; SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand),
(size), ());
brand | size | sum
——-+——+—–
Foo
|
| 30
Bar
|
| 20
| L
| 15
| M
| 35
|
| 50
(5 rows)
В каждом внутреннем списке GROUPING SETS могут задаваться ноль или более столбцов или выра-
жений, которые воспринимаются так же, как если бы они были непосредственно записаны в пред-
ложении GROUP BY. Пустой набор группировки означает, что все строки сводятся к одной группе
(которая выводится, даже если входных строк нет), как описано выше для агрегатных функций без
предложения GROUP BY.
104Запросы
Ссылки на группирующие столбцы или выражения заменяются в результирующих строках значе-
ниями NULL для тех группирующих наборов, в которых эти столбцы отсутствуют. Чтобы можно
было понять, результатом какого группирования стала конкретная выходная строка, предназна-
чена функция, описанная в Таблице 9.56.
Для указания двух распространённых видов наборов группирования предусмотрена краткая за-
пись. Предложение формы
ROLLUP ( e1, e2, e3, … )
представляет заданный список выражений и всех префиксов списка, включая пустой список; то
есть оно равнозначно записи
GROUPING SETS (
( e1, e2, e3, … ),
…
( e1, e2 ),
( e1 ),
( )
)
Оно часто применяется для анализа иерархических данных, например, для суммирования зарпла-
ты по отделам, подразделениям и компании в целом.
Предложение формы
CUBE ( e1, e2, … )
представляет заданный список и все его возможные подмножества (степень множества). Таким
образом, запись
CUBE ( a, b, c )
равнозначна
GROUPING
( a,
( a,
( a,
( a
(
(
(
(
)
SETS
b, c
b
c
(
),
),
),
),
b, c ),
b
),
c ),
)
Элементами предложений CUBE и ROLLUP могут быть либо отдельные выражения, либо вложенные
списки элементов в скобках. Вложенные списки обрабатываются как атомарные единицы, с кото-
рыми формируются отдельные наборы группирования. Например:
CUBE ( (a, b), (c, d) )
равнозначно
GROUPING SETS (
( a, b, c, d
( a, b
(
c, d
(
)
),
),
),
)
и
ROLLUP ( a, (b, c), d )
равнозначно
GROUPING SETS (
105Запросы
( a, b, c, d ),
( a, b, c
),
( a
),
(
)
)
Конструкции CUBE и ROLLUP могут применяться либо непосредственно в предложении GROUP BY,
либо вкладываться внутрь предложения GROUPING SETS. Если одно предложение GROUPING SETS
вкладывается внутрь другого, результат будет таким же, как если бы все элементы внутреннего
предложения были записаны непосредственно во внешнем.
Если в одном предложении GROUP BY задаётся несколько элементов группирования, окончатель-
ный список наборов группирования образуется как прямое произведение этих элементов. Напри-
мер:
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
равнозначно
GROUP BY GROUPING
(a, b, c, d),
(a, b, d),
(a, c, d),
(a, d),
)
SETS (
(a, b, c, e),
(a, b, e),
(a, c, e),
(a, e)
Примечание
Конструкция (a, b) обычно воспринимается в выражениях как конструктор строки.
Однако в предложении GROUP BY на верхнем уровне выражений запись (a, b) воспри-
нимается как список выражений, как описано выше. Если вам по какой-либо причине
нужен именно конструктор строки в выражении группирования, используйте запись
ROW(a, b).
7.2.5. Обработка оконных функций
Если запрос содержит оконные функции (см. Раздел 3.5, Раздел 9.21 и Подраздел 4.2.8), эти функ-
ции вычисляются после каждой группировки, агрегатных выражений и фильтрации HAVING. Дру-
гими словами, если в запросе есть агрегатные функции, предложения GROUP BY или HAVING, окон-
ные функции видят не исходные строки, полученные из FROM/WHERE, а сгруппированные.
Когда используются несколько оконных функций, все оконные функции, имеющие в своих опре-
делениях синтаксически равнозначные предложения PARTITION BY и ORDER BY, гарантированно
обрабатывают данные за один проход. Таким образом, они увидят один порядок сортировки, да-
же если ORDER BY не определяет порядок однозначно. Однако относительно функций с разными
формулировками PARTITION BY и ORDER BY никаких гарантий не даётся. (В таких случаях между
проходами вычислений оконных функций обычно требуется дополнительный этап сортировки и
эта сортировка может не сохранять порядок строк, равнозначный с точки зрения ORDER BY.)
В настоящее время оконные функции всегда требуют предварительно отсортированных данных,
так что результат запроса будет отсортирован согласно тому или иному предложению PARTITION
BY/ORDER BY оконных функций. Однако полагаться на это не следует. Если вы хотите, чтобы ре-
зультаты сортировались определённым образом, явно добавьте предложение ORDER BY на верхнем
уровне запроса.
7.3. Списки выборки
Как говорилось в предыдущем разделе, табличное выражение в SELECT создаёт промежуточную
виртуальную таблицу, возможно объединяя таблицы, представления, группируя и исключая лиш-
106Запросы
ние строки и т. д. Полученная таблица передаётся для обработки в список выборки. Этот список
выбирает, какие столбцы промежуточной таблицы должны выводиться в результате и как именно.
7.3.1. Элементы списка выборки
Простейший список выборки образует элемент *, который выбирает все столбцы из полученного
табличного выражения. Список выборки также может содержать список выражений значения че-
рез запятую (как определено в Разделе 4.2). Например, это может быть список имён столбцов:
SELECT a, b, c FROM …
Имена столбцов a, b и c представляют либо фактические имена столбцов таблиц, перечисленных
в предложении FROM, либо их псевдонимы, определённые как описано в Подразделе 7.2.1.2. Про-
странство имён в списке выборки то же, что и в предложении WHERE, если не используется груп-
пировка. В противном случае оно совпадает с пространством имён предложения HAVING.
Если столбец с заданным именем есть в нескольких таблицах, необходимо также указать имя таб-
лицы, например так:
SELECT tbl1.a, tbl2.a, tbl1.b FROM …
Обращаясь к нескольким таблицам, бывает удобно получить сразу все столбцы одной из таблиц:
SELECT tbl1.&lt;/em&gt;, tbl2.a FROM …
Подробнее запись имя_таблицы.* описывается в Подразделе 8.16.5.
Если в списке выборки используется обычное выражение значения, по сути при этом в возвраща-
емую таблицу добавляется новый виртуальный столбец. Выражение значения вычисляется один
раз для каждой строки результата со значениями столбцов в данной строке. Хотя выражения в
списке выборки не обязательно должны обращаться к столбцам табличного выражения из пред-
ложения FROM; они могут содержать, например и простые арифметические выражения.
7.3.2. Метки столбцов
Элементам в списке выборки можно назначить имена для последующей обработки, например, для
указания в предложении ORDER BY или для вывода в клиентском приложении. Например:
SELECT a AS value, b + c AS sum FROM …
Если выходное имя столбца не определено (с помощью AS), система назначает имя сама. Для про-
стых ссылок на столбцы этим именем становится имя целевого столбца, а для вызовов функций
это имя функции. Для сложных выражений система генерирует некоторое подходящее имя.
Слово AS можно опустить, но только если имя нового столбца не является ключевым словом
PostgreSQL (см. Приложение C). Во избежание случайного совпадения имени с ключевым словом
это имя можно заключить в кавычки. Например, VALUE — ключевое слово, поэтому такой вариант
не будет работать:
SELECT a value, b + c AS sum FROM …
а такой будет:
SELECT a “value”, b + c AS sum FROM …
Для предотвращения конфликта с ключевыми словами, которые могут появиться в будущем, ре-
комендуется всегда писать AS или заключать метки выходных столбцов в кавычки.
Примечание
Именование выходных столбцов отличается от того, что происходит в предложении
FROM (см. Подраздел 7.2.1.2). Один столбец можно переименовать дважды, но на выходе
окажется имя, назначенное в списке выборки.
107Запросы
7.3.3. DISTINCT
После обработки списка выборки в результирующей таблице можно дополнительно исключить
дублирующиеся строки. Для этого сразу после SELECT добавляется ключевое слово DISTINCT:
SELECT DISTINCT список_выборки …
(Чтобы явно включить поведение по умолчанию, когда возвращаются все строки, вместо DISTINCT
можно указать ключевое слово ALL.)
Две строки считаются разными, если они содержат различные значения минимум в одном столбце.
При этом значения NULL полагаются равными.
Кроме того, можно явно определить, какие строки будут считаться различными, следующим об-
разом:
SELECT DISTINCT ON (выражение [, выражение …]) список_выборки …
Здесь выражение — обычное выражение значения, вычисляемое для всех строк. Строки, для кото-
рых перечисленные выражения дают один результат, считаются дублирующимися и возвращается
только первая строка из такого набора. Заметьте, что «первая строка» набора может быть любой,
если только запрос не включает сортировку, гарантирующую однозначный порядок строк, посту-
пающих в фильтр DISTINCT. (Обработка DISTINCT ON производится после сортировки ORDER BY.)
Предложение DISTINCT ON не описано в стандарте SQL и иногда его применение считается плохим
стилем из-за возможной неопределённости в результатах. При разумном использовании GROUP BY
и подзапросов во FROM можно обойтись без этой конструкции, но часто она бывает удобнее.
7.4. Сочетание запросов
Результаты двух запросов можно обработать, используя операции над множествами: объединение,
пересечение и вычитание. Эти операции записываются соответственно так:
запрос1 UNION [ALL] запрос2
запрос1 INTERSECT [ALL] запрос2
запрос1 EXCEPT [ALL] запрос2
Здесь запрос1 и запрос2 — это запросы, в которых могут использоваться все возможности, рас-
смотренные до этого. Операции над множествами тоже можно вкладывать и соединять, например:
запрос1 UNION запрос2 UNION запрос3
Этот сложный запрос выполняется так:
(запрос1 UNION запрос2) UNION запрос3
UNION по сути добавляет результаты второго запроса к результатам первого (хотя никакой порядок
возвращаемых строк при этом не гарантируется). Более того, эта операция убирает дублирующи-
еся строки из результата так же, как это делает DISTINCT, если только не указано UNION ALL.
INTERSECT возвращает все строки, содержащиеся в результате и первого, и второго запроса. Дуб-
лирующиеся строки отфильтровываются, если не указано ALL.
EXCEPT возвращает все строки, которые есть в результате первого запроса, но отсутствуют в ре-
зультате второго. (Иногда это называют разницей двух запросов.) И здесь дублирующиеся строки
отфильтровываются, если не указано ALL.
Чтобы можно было вычислить объединение, пересечение или разницу результатов двух запросов,
эти запросы должны быть «совместимыми для объединения», что означает, что они должны иметь
одинаковое число столбцов и соответствующие столбцы должны быть совместимых типов, как опи-
сывается в Разделе 10.5.
7.5. Сортировка строк
108Запросы
После того как запрос выдал таблицу результатов (после обработки списка выборки), её можно от-
сортировать. Если сортировка не задана, строки возвращаются в неопределённом порядке. Факти-
ческий порядок строк в этом случае будет зависеть от плана соединения и сканирования, а также
от порядка данных на диске, поэтому полагаться на него нельзя. Определённый порядок выводи-
мых строк гарантируется, только если этап сортировки задан явно.
Порядок сортировки определяет предложение ORDER BY:
SELECT список_выборки
FROM табличное_выражение
ORDER BY выражение_сортировки1 [ASC | DESC] [NULLS { FIRST | LAST }]
[, выражение_сортировки2 [ASC | DESC] [NULLS { FIRST | LAST }] …]
Выражениями сортировки могут быть любые выражения, допустимые в списке выборки запроса.
Например:
SELECT a, b FROM table1 ORDER BY a + b, c;
Когда указывается несколько выражений, последующие значения позволяют отсортировать стро-
ки, в которых совпали все предыдущие значения. Каждое выражение можно дополнить ключевы-
ми словами ASC или DESC, которые выбирают сортировку соответственно по возрастанию или убы-
ванию. По умолчанию принят порядок по возрастанию (ASC). При сортировке по возрастанию сна-
чала идут меньшие значения, где понятие «меньше» определяется оператором &amp;lt;. Подобным обра-
1
зом, сортировка по возрастанию определяется оператором &amp;gt;.
Для определения места значений NULL можно использовать указания NULLS FIRST и NULLS LAST,
которые помещают значения NULL соответственно до или после значений не NULL. По умолча-
нию значения NULL считаются больше любых других, то есть подразумевается NULLS FIRST для
порядка DESC и NULLS LAST в противном случае.
Заметьте, что порядки сортировки определяются независимо для каждого столбца. Например,
ORDER BY x, y DESC означает ORDER BY x ASC, y DESC, и это не то же самое, что ORDER BY x
DESC, y DESC.
Здесь выражение_сортировки может быть меткой столбца или номером выводимого столбца, как в
данном примере:
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
Оба эти запроса сортируют результат по первому столбцу. Заметьте, что имя выводимого столбца
должно оставаться само по себе, его нельзя использовать в выражении. Например, это ошибка:
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;
– неправильно
Это ограничение позволяет уменьшить неоднозначность. Тем не менее неоднозначность возмож-
на, когда в ORDER BY указано простое имя, но оно соответствует и имени выходного столбца, и
столбцу из табличного выражения. В этом случае используется выходной столбец. Эта ситуация
может возникнуть, только когда с помощью AS выходному столбцу назначается то же имя, что
имеет столбец в другой таблице.
ORDER BY можно применить к результату комбинации UNION, INTERSECT и EXCEPT, но в этом случае
возможна сортировка только по номерам или именам столбцов, но не по выражениям.
7.6. LIMIT и OFFSET
Указания LIMIT и OFFSET позволяют получить только часть строк из тех, что выдал остальной за-
прос:
1
На деле PostgreSQL определяет порядок сортировки для ASC и DESC по классу оператора B-дерева по умолчанию для типа данных выражения. Обычно
типы данных создаются так, что этому порядку соответствуют операторы &amp;lt; и &amp;gt;, но возможно разработать собственный тип данных, который будет вести
себя по-другому.
109Запросы
SELECT список_выборки
FROM табличное_выражение
[ ORDER BY … ]
[ LIMIT { число | ALL } ] [ OFFSET число ]
Если указывается число LIMIT, в результате возвращается не больше заданного числа строк (мень-
ше может быть, если сам запрос выдал меньшее количество строк). LIMIT ALL равносильно отсут-
ствию указания LIMIT, как и LIMIT с аргументом NULL.
OFFSET указывает пропустить указанное число строк, прежде чем начать выдавать строки. OFFSET
0 равносильно отсутствию указания OFFSET, как и OFFSET с аргументом NULL.
Если указано и OFFSET, и LIMIT, сначала система пропускает OFFSET строк, а затем начинает под-
считывать строки для ограничения LIMIT.
Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата вы-
давались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества
строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду?
Порядок будет неизвестен, если не добавить ORDER BY.
Оптимизатор запроса учитывает ограничение LIMIT, строя планы выполнения запросов, поэтому
вероятнее всего планы (а значит и порядок строк) будут меняться при разных LIMIT и OFFSET. Та-
ким образом, различные значения LIMIT/OFFSET, выбирающие разные подмножества результатов
запроса, приведут к несогласованности результатов, если не установить предсказуемую сорти-
ровку с помощью ORDER BY. Это не ошибка, а неизбежное следствие того, что SQL не гарантирует
вывод результатов запроса в некотором порядке, если порядок не определён явно предложением
ORDER BY.
Строки, пропускаемые согласно предложению OFFSET, тем не менее должны вычисляться на сер-
вере. Таким образом, при больших значениях OFFSET работает неэффективно.
7.7. Списки VALUES
Предложение VALUES позволяет создать «постоянную таблицу», которую можно использовать в
запросе, не создавая и не наполняя таблицу в БД. Синтаксис предложения:
VALUES ( выражение [, …] ) [, …]
Для каждого списка выражений в скобках создаётся строка таблицы. Все списки должны иметь
одинаковое число элементов (т. е. число столбцов в таблице) и соответствующие элементы во всех
списках должны иметь совместимые типы данных. Фактический тип данных столбцов результата
определяется по тем же правилам, что и для UNION (см. Раздел 10.5).
Как пример:
VALUES (1, ‘one’), (2, ‘two’), (3, ‘three’);
вернёт таблицу из двух столбцов и трёх строк. Это равносильно такому запросу:
SELECT 1 AS column1, ‘one’ AS column2
UNION ALL
SELECT 2, ‘two’
UNION ALL
SELECT 3, ‘three’;
По умолчанию PostgreSQL назначает столбцам таблицы VALUES имена column1, column2 и т. д. Име-
на столбцов не определены в стандарте SQL и в другой СУБД они могут быть другими, поэтому
обычно лучше переопределить имена списком псевдонимов, например так:
=&amp;gt; SELECT * FROM (VALUES (1, ‘one’), (2, ‘two’), (3, ‘three’)) AS t (num,letter);
num | letter
—–+——–
110Запросы
1 | one
2 | two
3 | three
(3 rows)
Синтаксически список VALUES с набором выражений равнозначен:
SELECT список_выборки FROM табличное_выражение
и допускается везде, где допустим SELECT. Например, вы можете использовать его в составе UNION
или добавить к нему определение_сортировки (ORDER BY, LIMIT и/или OFFSET). VALUES чаще всего
используется как источник данных для команды INSERT, а также как подзапрос.
За дополнительными сведениями обратитесь к справке VALUES.
7.8. Запросы WITH (Общие табличные выражения)
WITH предоставляет способ записывать дополнительные операторы для применения в больших за-
просах. Эти операторы, которые также называют общими табличными выражениями (Common
Table Expressions, CTE), можно представить как определения временных таблиц, существующих
только для одного запроса. Дополнительным оператором в предложении WITH может быть SELECT,
INSERT, UPDATE или DELETE, а само предложение WITH присоединяется к основному оператору, ко-
торым также может быть SELECT, INSERT, UPDATE или DELETE.
7.8.1. SELECT в WITH
Основное предназначение SELECT в предложении WITH заключается в разбиении сложных запросов
на простые части. Например, запрос:
WITH regional_sales AS (
SELECT region, SUM(amount) AS total_sales
FROM orders
GROUP BY region
), top_regions AS (
SELECT region
FROM regional_sales
WHERE total_sales &amp;gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
product,
SUM(quantity) AS product_units,
SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
выводит итоги по продажам только для передовых регионов. Предложение WITH определяет два
дополнительных оператора regional_sales и top_regions так, что результат regional_sales ис-
пользуется в top_regions, а результат top_regions используется в основном запросе SELECT. Этот
пример можно было бы переписать без WITH, но тогда нам понадобятся два уровня вложенных под-
запросов SELECT. Показанным выше способом это можно сделать немного проще.
Необязательное указание RECURSIVE превращает WITH из просто удобной синтаксической кон-
струкции в средство реализации того, что невозможно в стандартном SQL. Используя RECURSIVE,
запрос WITH может обращаться к собственному результату. Очень простой пример, суммирующий
числа от 1 до 100:
WITH RECURSIVE t(n) AS (
VALUES (1)
UNION ALL
SELECT n+1 FROM t WHERE n &amp;lt; 100
111Запросы
)
SELECT sum(n) FROM t;
В общем виде рекурсивный запрос WITH всегда записывается как не рекурсивная часть, потом
UNION (или UNION ALL), а затем рекурсивная часть, где только в рекурсивной части можно обра-
титься к результату запроса. Такой запрос выполняется следующим образом:
Вычисление рекурсивного запроса
    &lt;ol&gt;
      &lt;li&gt;Вычисляется не рекурсивная часть. Для UNION (но не UNION ALL) отбрасываются дублирующи-
еся строки. Все оставшиеся строки включаются в результат рекурсивного запроса и также по-
мещаются во временную рабочую таблицу.&lt;/li&gt;
      &lt;li&gt;Пока рабочая таблица не пуста, повторяются следующие действия:
a. Вычисляется рекурсивная часть так, что рекурсивная ссылка на сам запрос обращается
к текущему содержимому рабочей таблицы. Для UNION (но не UNION ALL) отбрасываются
дублирующиеся строки и строки, дублирующие ранее полученные. Все оставшиеся строки
включаются в результат рекурсивного запроса и также помещаются во временную проме-
жуточную таблицу.
b. Содержимое рабочей таблицы заменяется содержимым промежуточной таблицы, а затем
промежуточная таблица очищается.
Примечание
Строго говоря, этот процесс является итерационным, а не рекурсивным, но комитетом
по стандартам SQL был выбран термин RECURSIVE.
В показанном выше примере в рабочей таблице на каждом этапе содержится всего одна строка и
в ней последовательно накапливаются значения от 1 до 100. На сотом шаге, благодаря условию
WHERE, не возвращается ничего, так что вычисление запроса завершается.
Рекурсивные запросы обычно применяются для работы с иерархическими или древовидными
структурами данных. В качестве полезного примера можно привести запрос, находящий все непо-
средственные и косвенные составные части продукта, используя только таблицу с прямыми свя-
зями:
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
SELECT sub_part, part, quantity FROM parts WHERE part = ‘our_product’
UNION ALL
SELECT p.sub_part, p.part, p.quantity
FROM included_parts pr, parts p
WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
Работая с рекурсивными запросами, важно обеспечить, чтобы рекурсивная часть запроса в конце
концов не выдала никаких кортежей (строк), в противном случае цикл будет бесконечным. Иногда
для этого достаточно применять UNION вместо UNION ALL, так как при этом будут отбрасываться
строки, которые уже есть в результате. Однако часто в цикле выдаются строки, не совпадающие
полностью с предыдущими: в таких случаях может иметь смысл проверить одно или несколько по-
лей, чтобы определить, не была ли текущая точка достигнута раньше. Стандартный способ реше-
ния подобных задач — вычислить массив с уже обработанными значениями. Например, рассмот-
рите следующий запрос, просматривающий таблицу graph по полю link:
WITH RECURSIVE search_graph(id, link, data, depth) AS (
SELECT g.id, g.link, g.data, 1
112Запросы
FROM graph g
UNION ALL
SELECT g.id, g.link, g.data, sg.depth + 1
FROM graph g, search_graph sg
WHERE g.id = sg.link
)
SELECT * FROM search_graph;
Этот запрос зациклится, если связи link содержат циклы. Так как нам нужно получать в резуль-
тате «depth», одно лишь изменение UNION ALL на UNION не позволит избежать зацикливания. Вме-
сто этого мы должны как-то определить, что уже достигали текущей строки, пройдя некоторый
путь. Для этого мы добавляем два столбца path и cycle и получаем запрос, защищённый от зацик-
ливания:
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
SELECT g.id, g.link, g.data, 1,
ARRAY[g.id],
false
FROM graph g
UNION ALL
SELECT g.id, g.link, g.data, sg.depth + 1,
path || g.id,
g.id = ANY(path)
FROM graph g, search_graph sg
WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
Помимо предотвращения циклов, значения массива часто бывают полезны сами по себе для пред-
ставления «пути», приведшего к определённой строке.
В общем случае, когда для выявления цикла нужно проверять несколько полей, следует использо-
вать массив строк. Например, если нужно сравнить поля f1 и f2:
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
SELECT g.id, g.link, g.data, 1,
ARRAY[ROW(g.f1, g.f2)],
false
FROM graph g
UNION ALL
SELECT g.id, g.link, g.data, sg.depth + 1,
path || ROW(g.f1, g.f2),
ROW(g.f1, g.f2) = ANY(path)
FROM graph g, search_graph sg
WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
Подсказка
Часто для распознавания цикла достаточного одного поля и тогда ROW() можно опу-
стить. При этом будет использоваться не массив данных составного типа, а простой
массив, что более эффективно.
Подсказка
Этот алгоритм рекурсивного вычисления запроса выдаёт в результате узлы, упорядо-
ченные по пути погружения. Чтобы получить результаты, отсортированные по глуби-
113Запросы
не, можно добавить во внешний запрос ORDER BY по столбцу «path», полученному, как
показано выше.
Для тестирования запросов, которые могут зацикливаться, есть хороший приём — добавить LIMIT
в родительский запрос. Например, следующий запрос зациклится, если не добавить предложение
LIMIT:
WITH RECURSIVE t(n) AS (
SELECT 1
UNION ALL
SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
Но в данном случае этого не происходит, так как в PostgreSQL запрос WITH выдаёт столько строк,
сколько фактически принимает родительский запрос. В производственной среде использовать этот
приём не рекомендуется, так как другие системы могут вести себя по-другому. Кроме того, это не
будет работать, если внешний запрос сортирует результаты рекурсивного запроса или соединяет
их с другой таблицей, так как в подобных случаях внешний запрос обычно всё равно выбирает
результат запроса WITH полностью.
Запросы WITH имеют полезное свойство — они вычисляются только раз для всего родительского
запроса, даже если этот запрос или соседние запросы WITH обращаются к ним неоднократно. Та-
ким образом, сложные вычисления, результаты которых нужны в нескольких местах, можно выно-
сить в запросы WITH в целях оптимизации. Кроме того, такие запросы позволяют избежать неже-
лательных вычислений функций с побочными эффектами. Однако есть и обратная сторона — оп-
тимизатор не может распространить ограничения родительского запроса на запрос WITH так, как
он делает это для обычного подзапроса. Запрос WITH обычно выполняется буквально и возвращает
все строки, включая те, что потом может отбросить родительский запрос. (Но как было сказано
выше, вычисление может остановиться раньше, если в ссылке на этот запрос затребуется только
ограниченное число строк.)
Примеры выше показывают только предложение WITH с SELECT, но таким же образом его можно
использовать с командами INSERT, UPDATE и DELETE. В каждом случае он по сути создаёт временную
таблицу, к которой можно обратиться в основной команде.
7.8.2. Изменение данных в WITH
В предложении WITH можно также использовать операторы, изменяющие данные (INSERT, UPDATE
или DELETE). Это позволяет выполнять в одном запросе сразу несколько разных операций. Напри-
мер:
WITH moved_rows AS (
DELETE FROM products
WHERE
“date” &amp;gt;= ‘2010-10-01’ AND
“date” &amp;lt; ‘2010-11-01’
RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
Этот запрос фактически перемещает строки из products в products_log. Оператор DELETE в WITH
удаляет указанные строки из products и возвращает их содержимое в предложении RETURNING; а
затем главный запрос читает это содержимое и вставляет в таблицу products_log.
Следует заметить, что предложение WITH в данном случае присоединяется к оператору INSERT,
а не к SELECT, вложенному в INSERT. Это необходимо, так как WITH может содержать операторы,
изменяющие данные, только на верхнем уровне запроса. Однако при этом применяются обычные
114Запросы
правила видимости WITH, так что к результату WITH можно обратиться и из вложенного оператора
SELECT.
Операторы, изменяющие данные, в WITH обычно дополняются предложением RETURNING (см. Раз-
дел 6.4), как показано в этом примере. Важно понимать, что временная таблица, которую можно
будет использовать в остальном запросе, создаётся из результата RETURNING, а не целевой табли-
цы оператора. Если оператор, изменяющий данные, в WITH не дополнен предложением RETURNING,
временная таблица не создаётся и обращаться к ней в остальном запросе нельзя. Однако такой
запрос всё равно будет выполнен. Например, допустим следующий не очень практичный запрос:
WITH t AS (
DELETE FROM foo
)
DELETE FROM bar;
Он удалит все строки из таблиц foo и bar. При этом число задействованных строк, которое получит
клиент, будет подсчитываться только по строкам, удалённым из bar.
Рекурсивные ссылки в операторах, изменяющих данные, не допускаются. В некоторых случаях это
ограничение можно обойти, обратившись к конечному результату рекурсивного WITH, например
так:
WITH RECURSIVE included_parts(sub_part, part) AS (
SELECT sub_part, part FROM parts WHERE part = ‘our_product’
UNION ALL
SELECT p.sub_part, p.part
FROM included_parts pr, parts p
WHERE p.part = pr.sub_part
)
DELETE FROM parts
WHERE part IN (SELECT part FROM included_parts);
Этот запрос удаляет все непосредственные и косвенные составные части продукта.
Операторы, изменяющие данные в WITH, выполняются только один раз и всегда полностью, вне
зависимости от того, принимает ли их результат основной запрос. Заметьте, что это отличается
от поведения SELECT в WITH: как говорилось в предыдущем разделе, SELECT выполняется только до
тех пор, пока его результаты востребованы основным запросом.
Вложенные операторы в WITH выполняются одновременно друг с другом и с основным запросом.
Таким образом, порядок, в котором операторы в WITH будут фактически изменять данные, непред-
сказуем. Все эти операторы выполняются с одним снимком данных (см. Главу 13), так что они не
могут «видеть», как каждый из них меняет целевые таблицы. Это уменьшает эффект непредсказу-
емости фактического порядка изменения строк и означает, что RETURNING — единственный вари-
ант передачи изменений от вложенных операторов WITH основному запросу. Например, в данном
случае:
WITH t AS (
UPDATE products SET price = price * 1.05
RETURNING *
)
SELECT * FROM products;
внешний оператор SELECT выдаст цены, которые были до действия UPDATE, тогда как в запросе
WITH t AS (
UPDATE products SET price = price * 1.05
RETURNING *
)
SELECT * FROM t;
внешний SELECT выдаст изменённые данные.
115Запросы
Неоднократное изменение одной и той же строки в рамках одного оператора не поддерживается.
Иметь место будет только одно из нескольких изменений и надёжно определить, какое именно,
часто довольно сложно (а иногда и вовсе невозможно). Это так же касается случая, когда строка
удаляется и изменяется в том же операторе: в результате может быть выполнено только обновле-
ние. Поэтому в общем случае следует избегать подобного наложения операций. В частности, из-
бегайте подзапросов WITH, которые могут повлиять на строки, изменяемые основным оператором
или операторами, вложенные в него. Результат действия таких запросов будет непредсказуемым.
В настоящее время, для оператора, изменяющего данные в WITH, в качестве целевой нельзя ис-
пользовать таблицу, для которой определено условное правило или правило ALSO или INSTEAD, ес-
ли оно состоит из нескольких операторов.
11&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 7. Запросы</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 8. Типы данных</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-008/" rel="alternate" type="text/html" title="Глава 8. Типы данных" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-008</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-008/">&lt;p&gt;Глава 8. Типы данных&lt;/p&gt;

&lt;p&gt;PostgreSQL предоставляет пользователям богатый ассортимент встроенных типов данных. Кроме
того, пользователи могут создавать свои типы в PostgreSQL, используя команду CREATE TYPE.
Таблица 8.1 содержит все встроенные типы данных общего пользования. Многие из альтернатив-
ных имён, приведённых в столбце «Псевдонимы», используются внутри PostgreSQL по историче-
ским причинам. В этот список не включены некоторые устаревшие типы и типы для внутреннего
применения.
Таблица 8.1. Типы данных
Имя Псевдонимы Описание
bigint int8 знаковое целое из 8 байт
bigserial serial8 восьмибайтное целое с автоуве-
личением
битовая строка фиксированной
длины
bit [ ( n) ]
bit varying [ ( n) ] varbit [ ( n) ] битовая
длины
строка
boolean bool логическое
false)
переменной
значение
(true/
box прямоугольник в плоскости
bytea двоичные
байт»)
данные
(«массив
character [ ( n) ] char [ ( n) ] символьная строка фиксирован-
ной длины
character varying [ ( n) ] varchar [ ( n) ] символьная строка переменной
длины
cidr сетевой адрес IPv4 или IPv6
circle круг в плоскости
date календарная дата (год, месяц,
день)
double precision
число двойной точности с пла-
вающей точкой (8 байт)
float8
адрес узла IPv4 или IPv6
inet
integer
знаковое четырёхбайтное целое
int, int4
interval [ поля ] [ ( p) ] интервал времени
json текстовые данные JSON
jsonb двоичные данные JSON, разо-
бранные
line прямая в плоскости
lseg отрезок в плоскости
macaddr MAC-адрес
macaddr8 Адрес MAC (Media Access
Control) (в формате EUI-64)
money денежная сумма
numeric [ ( p,
s) ]
decimal [ ( p,
117
s) ]
вещественное число заданной
точностиТипы данных
Имя
Псевдонимы
Описание
path геометрический путь в плоско-
сти
pg_lsn Последовательный
номер
журнале PostgreSQL
point геометрическая точка в плоско-
сти
polygon замкнутый
геометрический
путь в плоскости
в
real float4 число одинарной точности с
плавающей точкой (4 байта)
smallint int2 знаковое двухбайтное целое
smallserial serial2 двухбайтное целое с автоувели-
чением
serial serial4 четырёхбайтное целое с авто-
увеличением
text символьная строка переменной
длины
time [ ( p) ] [ without time
zone ] время суток (без часового поя-
са)
time [ ( p) ] with time zone timetz время суток с учётом часового
пояса
timestamp [ ( p) ] [ without
time zone ] дата и время (без часового поя-
са)
timestamp [ ( p) ] with time timestamptz
zone дата и время с учётом часового
пояса
tsquery запрос текстового поиска
tsvector документ для текстового поис-
ка
txid_snapshot снимок идентификатора тран-
закций
uuid универсальный
идентификатор
xml XML-данные
уникальный
Совместимость
В стандарте SQL описаны следующие типы (или их имена): bigint, bit, bit varying,
boolean, char, character varying, character, varchar, date, double precision,
integer, interval, numeric, decimal, real, smallint, time (с часовым поясом и без),
timestamp (с часовым поясом и без), xml.
Каждый тип данных имеет внутреннее представление, скрытое функциями ввода и вывода. При
этом многие встроенные типы стандартны и имеют очевидные внешние форматы. Однако есть
типы, уникальные для PostgreSQL, например геометрические пути, и есть типы, которые могут
иметь разные форматы, например, дата и время. Некоторые функции ввода и вывода не являются
в точности обратными друг к другу, то есть результат функции вывода может не совпадать со
входным значением из-за потери точности.
118Типы данных
8.1. Числовые типы
Числовые типы включают двух-, четырёх- и восьмибайтные целые, четырёх- и восьмибайтные чис-
ла с плавающей точкой, а также десятичные числа с задаваемой точностью. Все эти типы пере-
числены в Таблице 8.2.
Таблица 8.2. Числовые типы
Имя Размер Описание
Диапазон
smallint 2 байта целое в небольшом диа- -32768 .. +32767
пазоне
integer 4 байта типичный выбор для це- -2147483648
лых чисел
+2147483647
bigint 8 байт целое в большом диапа- -9223372036854775808 ..
зоне
9223372036854775807
decimal переменный вещественное число с до 131072 цифр до де-
указанной точностью
сятичной точки и до
16383 — после
numeric переменный вещественное число с до 131072 цифр до де-
указанной точностью
сятичной точки и до
16383 — после
real 4 байта вещественное число с точность в пределах 6
переменной точностью десятичных цифр
double precision 8 байт вещественное число с точность в пределах 15
переменной точностью десятичных цифр
smallserial 2 байта небольшое целое с ав- 1 .. 32767
тоувеличением
serial 4 байта целое с автоувеличени- 1 .. 2147483647
ем
bigserial 8 байт большое целое с авто- 1
..
увеличением
9223372036854775807
..
Синтаксис констант числовых типов описан в Подразделе 4.1.2. Для этих типов определён полный
набор соответствующих арифметических операторов и функций. За дополнительными сведениями
обратитесь к Главе 9. Подробнее эти типы описаны в следующих разделах.
8.1.1. Целочисленные типы
Типы smallint, integer и bigint хранят целые числа, то есть числа без дробной части, имею-
щие разные допустимые диапазоны. Попытка сохранить значение, выходящее за рамки диапазо-
на, приведёт к ошибке.
Чаще всего используется тип integer, как наиболее сбалансированный выбор ширины диапазона,
размера и быстродействия. Тип smallint обычно применяется, только когда крайне важно умень-
шить размер данных на диске. Тип bigint предназначен для тех случаев, когда числа не умеща-
ются в диапазон типа integer.
В SQL определены только типы integer (или int), smallint и bigint. Имена типов int2, int4 и
int8 выходят за рамки стандарта, хотя могут работать и в некоторых других СУБД.
8.1.2. Числа с произвольной точностью
Тип numeric позволяет хранить числа с очень большим количеством цифр. Он особенно рекомен-
дуется для хранения денежных сумм и других величин, где важна точность. Вычисления с типом
numeric дают точные результаты, где это возможно, например, при сложении, вычитании и умно-
119Типы данных
жении. Однако операции со значениями numeric выполняются гораздо медленнее, чем с целыми
числами или с типами с плавающей точкой, описанными в следующем разделе.
Ниже мы используем следующие термины: масштаб значения numeric определяет количество
десятичных цифр в дробной части, справа от десятичной точки, а точность — общее количество
значимых цифр в числе, т. е. количество цифр по обе стороны десятичной точки. Например, число
23.5141 имеет точность 6 и масштаб 4. Целочисленные значения можно считать числами с мас-
штабом 0.
Для столбца типа numeric можно настроить и максимальную точность, и максимальный масштаб.
Столбец типа numeric объявляется следующим образом:
NUMERIC(точность, масштаб)
Точность должна быть положительной, а масштаб положительным или равным нулю. Альтерна-
тивный вариант
NUMERIC(точность)
устанавливает масштаб 0. Форма:
NUMERIC
без указания точности и масштаба создаёт столбец, в котором можно сохранять числовые значе-
ния любой точности и масштаба в пределах, поддерживаемых системой. В столбце этого типа вход-
ные значения не будут приводиться к какому-либо масштабу, тогда как в столбцах numeric с явно
заданным масштабом значения подгоняются под этот масштаб. (Стандарт SQL утверждает, что
по умолчанию должен устанавливаться масштаб 0, т. е. значения должны приводиться к целым
числам. Однако мы считаем это не очень полезным. Если для вас важна переносимость, всегда
указывайте точность и масштаб явно.)
Примечание
Максимально допустимая точность, которую можно указать в объявлении типа, равна
1000; если же использовать NUMERIC без указания точности, действуют ограничения,
описанные в Таблице 8.2.
Если масштаб значения, которое нужно сохранить, превышает объявленный масштаб столбца, си-
стема округлит его до заданного количества цифр после точки. Если же после этого количество
цифр слева в сумме с масштабом превысит объявленную точность, произойдёт ошибка.
Числовые значения физически хранятся без каких-либо дополняющих нулей слева или справа.
Таким образом, объявляемые точность и масштаб столбца определяют максимальный, а не фикси-
рованный размер хранения. (В этом смысле тип numeric больше похож на тип varchar(n), чем на
char(n).) Действительный размер хранения такого значения складывается из двух байт для каж-
дой группы из четырёх цифр и дополнительных трёх-восьми байт.
Помимо обычных чисел тип numeric позволяет сохранить специальное значение NaN, что означает
«not-a-number» (не число). Любая операция c NaN выдаёт в результате тоже NaN. Записывая это зна-
чение в виде константы в команде SQL, его нужно заключать в апострофы, например так: UPDATE
table SET x = ‘NaN’. Регистр символов в строке NaN не важен.
Примечание
В большинстве реализаций «не-число» (NaN) считается не равным любому другому зна-
чению (в том числе и самому NaN). Чтобы значения numeric можно было сортировать
и использовать в древовидных индексах, PostgreSQL считает, что значения NaN равны
друг другу и при этом больше любых числовых значений (не NaN).
120Типы данных
Типы decimal и numeric равнозначны. Оба эти типа описаны в стандарте SQL.
При округлении значений тип numeric выдаёт число, большее по модулю, тогда как (на большин-
стве платформ) типы real и double precision выдают ближайшее чётное число. Например:
SELECT x,
round(x::numeric) AS num_round,
round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
x
| num_round | dbl_round
——+———–+———–
-3.5 |
-4 |
-4
-2.5 |
-3 |
-2
-1.5 |
-2 |
-2
-0.5 |
-1 |
-0
0.5 |
1 |
0
1.5 |
2 |
2
2.5 |
3 |
2
3.5 |
4 |
4
(8 rows)
8.1.3. Типы с плавающей точкой
Типы данных real и double precision хранят приближённые числовые значения с переменной
точностью. На практике эти типы обычно реализуют Стандарт IEEE 754 для двоичной арифметики
с плавающей точкой (с одинарной и двойной точностью соответственно), в той мере, в какой его
поддерживают процессор, операционная система и компилятор.
Неточность здесь выражается в том, что некоторые значения, которые нельзя преобразовать во
внутренний формат, сохраняются приближённо, так что полученное значение может несколько
отличаться от записанного. Управление подобными ошибками и их распространение в процессе
вычислений является предметом изучения целого раздела математики и компьютерной науки, и
здесь не рассматривается. Мы отметим только следующее:
• Если вам нужна точность при хранении и вычислениях (например, для денежных сумм), ис-
пользуйте вместо этого тип numeric.
• Если вы хотите выполнять с этими типами сложные вычисления, имеющие большую важ-
ность, тщательно изучите реализацию операций в вашей среде и особенно поведение в край-
них случаях (бесконечность, антипереполнение).
• Проверка равенства двух чисел с плавающей точкой может не всегда давать ожидаемый ре-
зультат.
На большинстве платформ тип real может сохранить значения в пределах от 1E-37 до 1E+37 с
точностью не меньше 6 десятичных цифр. Тип double precision предлагает диапазон значений
от 1E-307 до 1E+308 и точностью не меньше 15 цифр. Попытка сохранить слишком большие или
слишком маленькие значения приведёт к ошибке. Если точность вводимого числа слишком вели-
ка, оно будет округлено. При попытке сохранить число, близкое к 0, но непредставимое как от-
личное от 0, произойдёт ошибка антипереполнения.
Примечание
Параметр extra_float_digits определяет количество дополнительных значащих цифр
при преобразовании значения с плавающей точкой в текст для вывода. Со значени-
ем по умолчанию (0) вывод будет одинаковым на всех платформах, поддерживаемых
PostgreSQL. При его увеличении выводимое значение числа будет более точно пред-
ставлять хранимое, но от этого может пострадать переносимость.
121Типы данных
В дополнение к обычным числовым значениям типы с плавающей точкой могут содержать следу-
ющие специальные значения:
Infinity
-Infinity
NaN
Они представляют особые значения, описанные в IEEE 754, соответственно «бесконечность», «ми-
нус бесконечность» и «не число». (На компьютерах, где арифметика с плавающей точкой не соот-
ветствует стандарту IEEE 754, эти значения, вероятно, не будут работать должным образом.) За-
писывая эти значения в виде констант в команде SQL, их нужно заключать в апострофы, например
так: UPDATE table SET x = ‘-Infinity’. Регистр символов в этих строках не важен.
Примечание
Согласно IEEE754, NaN не должно считаться равным любому другому значению с пла-
вающей точкой (в том числе и самому NaN). Чтобы значения с плавающей точкой мож-
но было сортировать и использовать в древовидных индексах, PostgreSQL считает, что
значения NaN равны друг другу, и при этом больше любых числовых значений (не NaN).
PostgreSQL также поддерживает форматы float и float(p), оговорённые в стандарте SQL, для
указания неточных числовых типов. Здесь p определяет минимально допустимую точность в дво-
ичных цифрах. PostgreSQL воспринимает запись от float(1) до float(24) как выбор типа real, а
запись от float(25) до float(53) как выбор типа double precision. Значения p вне допустимого
диапазона вызывают ошибку. Если float указывается без точности, подразумевается тип double
precision.
Примечание
Предположение, что типы real и double precision имеют в мантиссе 24 и 53 бита со-
ответственно, справедливо для всех реализаций плавающей точки по стандарту IEEE.
На платформах, не поддерживающих IEEE, размер мантиссы может несколько отли-
чаться, но для простоты диапазоны p везде считаются одинаковыми.
8.1.4. Последовательные типы
Примечание
В этом разделе описывается специфичный для PostgreSQL способ создания столбца с
автоувеличением. Другой способ, соответствующий стандарту SQL, заключается в ис-
пользовании столбцов идентификации и рассматривается в описании CREATE TABLE.
Типы данных smallserial, serial и bigserial не являются настоящими типами, а представляют
собой просто удобное средство для создания столбцов с уникальными идентификаторами (подоб-
ное свойству AUTO_INCREMENT в некоторых СУБД). В текущей реализации запись:
CREATE TABLE имя_таблицы (
имя_столбца SERIAL
);
равнозначна следующим командам:
CREATE SEQUENCE имя_таблицы_имя_столбца_seq;
CREATE TABLE имя_таблицы (
имя_столбца integer NOT NULL DEFAULT nextval(‘имя_таблицы_имя_столбца_seq’)
);
122Типы данных
ALTER SEQUENCE имя_таблицы_имя_столбца_seq OWNED BY имя_таблицы.имя_столбца;
То есть при определении такого типа создаётся целочисленный столбец со значением по умол-
чанию, извлекаемым из генератора последовательности. Чтобы в столбец нельзя было вставить
NULL, в его определение добавляется ограничение NOT NULL. (Во многих случаях также имеет
смысл добавить для этого столбца ограничения UNIQUE или PRIMARY KEY для защиты от ошибочного
добавления дублирующихся значений, но автоматически это не происходит.) Последняя команда
определяет, что последовательность «принадлежит» столбцу, так что она будет удалена при уда-
лении столбца или таблицы.
Примечание
Так как типы smallserial, serial и bigserial реализованы через последовательности,
в числовом ряду значений столбца могут образовываться пропуски (или “дыры”), даже
если никакие строки не удалялись. Значение, выделенное из последовательности, счи-
тается “задействованным”, даже если строку с этим значением не удалось вставить в
таблицу. Это может произойти, например, при откате транзакции, добавляющей дан-
ные. См. описание nextval() в Разделе 9.16.
Чтобы вставить в столбец serial следующее значение последовательности, ему нужно присвоить
значение по умолчанию. Это можно сделать, либо исключив его из списка столбцов в операторе
INSERT, либо с помощью ключевого слова DEFAULT.
Имена типов serial и serial4 равнозначны: они создают столбцы integer. Так же являются си-
нонимами имена bigserial и serial8, но они создают столбцы bigint. Тип bigserial следует ис-
31
пользовать, если за всё время жизни таблицы планируется использовать больше чем 2 значений.
И наконец, синонимами являются имена типов smallserial и serial2, но они создают столбец
smallint.
Последовательность, созданная для столбца serial, автоматически удаляется при удалении свя-
занного столбца. Последовательность можно удалить и отдельно от столбца, но при этом также
будет удалено определение значения по умолчанию.
8.2. Денежные типы
Тип money хранит денежную сумму с фиксированной дробной частью; см. Таблицу 8.3. Точность
дробной части определяется на уровне базы данных параметром lc_monetary. Для диапазона, по-
казанного в таблице, предполагается, что число содержит два знака после запятой. Входные дан-
ные могут быть записаны по-разному, в том числе в виде целых и дробных чисел, а также в виде
строки в денежном формате, например ‘$1,000.00’. Выводятся эти значения обычно в денежном
формате, зависящем от региональных стандартов.
Таблица 8.3. Денежные типы
Имя Размер Описание Диапазон
money 8 байт денежная сумма -92233720368547
758.08
+92233720368547
758.07
..
Так как выводимые значения этого типа зависят от региональных стандартов, попытка загрузить
данные типа money в базу данных с другим параметром lc_monetary может быть неудачной. Во
избежание подобных проблем, прежде чем восстанавливать копию в новую базу данных, убедитесь
в том, что параметр lc_monetary в этой базе данных имеет то же значение, что и в исходной.
Значения типов numeric, int и bigint можно привести к типу money. Преобразования типов real
и double precision так же возможны через тип numeric, например:
123Типы данных
SELECT ‘12.34’::float8::numeric::money;
Однако использовать числа с плавающей точкой для денежных сумм не рекомендуется из-за воз-
можных ошибок округления.
Значение money можно привести к типу numeric без потери точности. Преобразование в другие
типы может быть неточным и также должно выполняться в два этапа:
SELECT ‘52093.89’::money::numeric::float8;
При делении значения типа money на целое число выполняется отбрасывание дробной части и
получается целое, ближайшее к нулю. Чтобы получить результат с округлением, выполните деле-
ние значения с плавающей точкой или приведите значение типа money к numeric до деления, а
затем приведите результат к типу money. (Последний вариант предпочтительнее, так как исклю-
чает риск потери точности.) Когда значение money делится на другое значение money, результатом
будет значение типа double precision (то есть просто число, не денежная величина); денежные
единицы измерения при делении сокращаются.
8.3. Символьные типы
Таблица 8.4. Символьные типы
Имя Описание
character varying( n), varchar( n) строка ограниченной переменной длины
character( n), char( n) строка фиксированной длины, дополненная про-
белами
text строка неограниченной переменной длины
В Таблице 8.4 перечислены символьные типы общего назначения, доступные в PostgreSQL.
SQL определяет два основных символьных типа: character varying(n) и character(n), где n — по-
ложительное число. Оба эти типа могут хранить текстовые строки длиной до n символов (не байт).
Попытка сохранить в столбце такого типа более длинную строку приведёт к ошибке, если только
все лишние символы не являются пробелами (тогда они будут усечены до максимально допусти-
мой длины). (Это несколько странное исключение продиктовано стандартом SQL.) Если длина со-
храняемой строки оказывается меньше объявленной, значения типа character будут дополнятся
пробелами; а тип character varying просто сохранит короткую строку.
При попытке явно привести значение к типу character varying(n) или character(n), часть стро-
ки, выходящая за границу в n символов, удаляется, не вызывая ошибки. (Это также продиктовано
стандартом SQL.)
Записи varchar(n) и char(n) являются синонимами character varying(n) и character(n), соот-
ветственно. Записи character без указания длины соответствует character(1). Если же длина не
указывается для character varying, этот тип будет принимать строки любого размера. Это пове-
дение является расширением PostgreSQL.
Помимо этого, PostgreSQL предлагает тип text, в котором можно хранить строки произвольной
длины. Хотя тип text не описан в стандарте SQL, его поддерживают и некоторые другие СУБД SQL.
Значения типа character физически дополняются пробелами до n символов и хранятся, а затем
отображаются в таком виде. Однако при сравнении двух значений типа character дополняющие
пробелы считаются незначащими и игнорируются. С правилами сортировки, где пробельные сим-
волы являются значащими, это поведение может приводить к неожиданным результатам, напри-
мер SELECT ‘a ‘::CHAR(2) collate “C” &amp;lt; E’a\n’::CHAR(2) вернёт true (условие будет истинным),
хотя в локали C символ пробела считается больше символа новой строки. При приведении значе-
ния character к другому символьному типу дополняющие пробелы отбрасываются. Заметьте, что
124Типы данных
эти пробелы несут смысловую нагрузку в типах character varying и text и в проверках по шаб-
лонам, то есть в LIKE и регулярных выражениях.
Для хранения короткой строки (до 126 байт) требуется дополнительный 1 байт плюс размер самой
строки, включая дополняющие пробелы для типа character. Для строк длиннее требуется не 1,
а 4 дополнительных байта. Система может автоматически сжимать длинные строки, так что фи-
зический размер на диске может быть меньше. Очень длинные текстовые строки переносятся в
отдельные таблицы, чтобы они не замедляли работу с другими столбцами. В любом случае, мак-
симально возможный размер строки составляет около 1 ГБ. (Допустимое значение n в объявлении
типа данных меньше этого числа. Это объясняется тем, что в зависимости от кодировки каждый
символ может занимать несколько байт. Если вы желаете сохранять строки без определённого
предела длины, используйте типы text или character varying без указания длины, а не задавайте
какое-либо большое максимальное значение.)
Подсказка
По быстродействию эти три типа практически не отличаются друг от друга, не счи-
тая большего размера хранения для типа с дополняющими пробелами и нескольких
машинных операций для проверки длины при сохранении строк в столбце с ограни-
ченной длиной. Хотя в некоторых СУБД тип character(n) работает быстрее других, в
PostgreSQL это не так; на деле character(n) обычно оказывается медленнее остальных
типов из-за большего размера данных и более медленной сортировки. В большинстве
случаев вместо него лучше применять text или character varying.
Подробнее синтаксис текстовых строк описан в Подразделе 4.1.2.1, а доступные операторы и функ-
ции перечисляются в Главе 9. Кодировка, используемая для хранения текстовых строк, определя-
ется набором символов, выбранным для базы данных. Подробнее это описано в Разделе 23.3.
Пример 8.1. Использование символьных типов
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES (‘ok’);
SELECT a, char_length(a) FROM test1; –
1
a
| char_length
——+————-
ok
|
2
CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES (‘ok’);
INSERT INTO test2 VALUES (‘good
‘);
INSERT INTO test2 VALUES (‘too long’);
ОШИБКА: значение не умещается в тип character varying(5)
INSERT INTO test2 VALUES (‘too long’::varchar(5)); – явное усечение
SELECT b, char_length(b) FROM test2;
b
| char_length
——-+————-
ok
|
2
good |
5
too l |
5
1
Функция char_length рассматривается в Разделе 9.4.
В PostgreSQL есть ещё два символьных типа фиксированной длины, приведённые в Таблице 8.5.
Тип name создан только для хранения идентификаторов во внутренних системных таблицах и не
125Типы данных
предназначен для обычного применения пользователями. В настоящее время его длина составля-
ет 64 байта (63 ASCII-символа плюс конечный знак), но в исходном коде C она задаётся констан-
той NAMEDATALEN. Эта константа определяется во время компиляции (и её можно менять в особых
случаях), а кроме того, максимальная длина по умолчанию может быть увеличена в следующих
версиях. Тип “char” (обратите внимание на кавычки) отличается от char(1) тем, что он факти-
чески хранится в одном байте. Он используется во внутренних системных таблицах для простых
перечислений.
Таблица 8.5. Специальные символьные типы
Имя Размер Описание
“char” 1 байт внутренний однобайтный тип
name 64 байта внутренний тип для имён объек-
тов
8.4. Двоичные типы данных
Для хранения двоичных данных предназначен тип bytea; см. Таблицу 8.6.
Таблица 8.6. Двоичные типы данных
Имя Размер
Описание
bytea 1 или 4 байта плюс сама двоич- двоичная строка переменной
ная строка
длины
Двоичные строки представляют собой последовательность октетов (байт) и имеют два отличия от
текстовых строк. Во-первых, в двоичных строках можно хранить байты с кодом 0 и другими «непе-
чатаемыми» значениями (обычно это значения вне десятичного диапазона 32..126). В текстовых
строках нельзя сохранять нулевые байты, а также значения и последовательности значений, не
соответствующие выбранной кодировке базы данных. Во-вторых, в операциях с двоичными стро-
ками обрабатываются байты в чистом виде, тогда как текстовые строки обрабатываются в зависи-
мости от языковых стандартов. То есть, двоичные строки больше подходят для данных, которые
программист видит как «просто байты», а символьные строки — для хранения текста.
Тип bytea поддерживает два формата ввода и вывода: «шестнадцатеричный» и традиционный для
PostgreSQL формат «спецпоследовательностей». Входные данные принимаются в обоих форматах,
а формат выходных данных зависит от параметра конфигурации bytea_output; по умолчанию вы-
бран шестнадцатеричный. (Заметьте, что шестнадцатеричный формат был введён в PostgreSQL
9.0; в ранних версиях и некоторых программах он не будет работать.)
Стандарт SQL определяет другой тип двоичных данных, BLOB (BINARY LARGE OBJECT, большой дво-
ичный объект). Его входной формат отличается от форматов bytea, но функции и операторы в ос-
новном те же.
8.4.1. Шестнадцатеричный формат bytea
В «шестнадцатеричном» формате двоичные данные кодируются двумя шестнадцатеричными циф-
рами на байт, при этом первая цифра соответствует старшим 4 битам. К полученной строке до-
бавляется префикс \x (чтобы она отличалась от формата спецпоследовательности). В некоторых
контекстах обратную косую черту нужно выделить, продублировав её, в тех же случаях это нуж-
но сделать для формата спецпоследовательности; подробнее это описано ниже. Шестнадцатерич-
ные цифры могут быть в любом регистре, а между парами цифр допускаются пробельные символы
(но не внутри пары и не в начале последовательности \x). Этот формат совместим со множеством
внешних приложений и протоколов, к тому же обычно преобразуется быстрее, поэтому предпо-
чтительнее использовать его.
Пример:
126Типы данных
SELECT ‘\xDEADBEEF’;
8.4.2. Формат спецпоследовательностей bytea
Формат «спецпоследовательностей» традиционно использовался в PostgreSQL для значений типа
bytea. В нём двоичная строка представляется в виде последовательности ASCII-символов, а байты,
непредставимые в виде ASCII-символов, передаются в виде спецпоследовательностей. Этот формат
может быть удобен, если с точки зрения приложения представление байт в виде символов имеет
смысл. Но на практике это обычно создаёт путаницу, так как двоичные и символьные строки мо-
гут выглядеть одинаково, а кроме того выбранный механизм спецпоследовательностей довольно
неуклюж. Поэтому в новых приложениях этот формат обычно не стоит использовать.
Передавая значения bytea в формате спецпоследовательности, байты с определёнными значени-
ями необходимо записывать специальным образом, хотя так можно записывать и все значения. В
общем виде для этого значение байта нужно преобразовать в трёхзначное восьмеричное число и
добавить перед ним обратную косую черту (и продублировать её, если значение записывается в
текстовой спецстроке). Саму обратную косую черту (символ с десятичным кодом 92) можно запи-
сать в виде двух таких символов. В Таблице 8.7 перечислены символы, которые нужно записывать
спецпоследовательностями, и приведены альтернативные варианты записи там, где они возмож-
ны.
Таблица 8.7. Спецпоследовательности записи значений bytea
Десятичное зна- Описание
чение байта Спецпоследова- Пример
тельность ввода Выводимое
представление
0 нулевой байт ‘\000’ SELECT
‘\000’::bytea; \x00
39 апостроф ‘’’’ или ‘\047’ SELECT
‘’’’::bytea; \x27
92 обратная
черта косая ‘' или ‘\134’
от 0 до 31 и от 127 «непечатаемые»
до 255
байты
SELECT
'::bytea;
E’\xxx’ (восьме- SELECT
ричное значение) ‘\001’::bytea;
‘\ \x5c
\x01
Набор непечатаемых символов, которые нужно записывать спецпоследовательностями, опреде-
ляется языковыми стандартами. В некоторых случаях можно оставить в буквальном виде и другие
символы. Заметьте, что во всех примерах в Таблице 8.7 задаётся значение ровно одного байта, хотя
выходное представление может состоять из нескольких символов.
Необходимость дублирования обратных косых черт в записи спецпоследовательностей, показан-
ного в Таблице 8.7, объясняется тем, что строковая константа должна пройти два этапа разбора на
сервере PostgreSQL. Первая обратная косая черта из каждой пары воспринимается анализатором
строки как спецсимвол (если используется синтаксис спецпоследовательностей) и таким образом
пропускается, оставляя только вторую косую черту. (Для избавления от этой вложенности можно
использовать строки в долларах.) Оставшаяся обратная косая черта затем распознаётся функцией
ввода bytea как спецсимвол, предваряющий трёхзначное восьмеричное значение или следующий
спецсимвол. Например, переданная серверу строковая константа ‘\001’ преобразуется в \001,
проходя через анализатор спецстрок. Затем строка \001 передаётся функции ввода типа bytea,
где она преобразуется в один байт с десятичным значением 1. Заметьте, что символ апостроф для
функции ввода bytea не отличается от остальных, поэтому он записывается как обычно принято
в строках. (См. также Подраздел 4.1.2.1.)
Данные Bytea по умолчанию выводятся в шестнадцатеричном формате (hex). Если поменять зна-
чение bytea_output на escape, «непечатаемый» байт представляется в виде трёхзначного восьме-
ричного значения, перед которым добавляется одна обратная косая черта. Большинство «печата-
емых» байтов представляются обычными символами из клиентского набора символов, например:
SET bytea_output = ‘escape’;
127Типы данных
SELECT ‘abc \153\154\155 \052\251\124’::bytea;
bytea
—————-
abc klm *\251T
Байт с десятичным кодом 92 (обратная косая черта) при выводе дублируется. Это иллюстрирует
Таблица 8.8.
Таблица 8.8. Спецпоследовательности выходных значений bytea
Десятичное зна- Описание
чение байта
92
обратная
черта
Спецпоследова- Пример
тельность выво-
да
косая &lt;br /&gt;
SELECT
‘\134’::bytea;
от 0 до 31 и от 127 «непечатаемые»
до 255
байты \xxx
байта)
от 32 до 126 представление из SELECT
клиентского набо- ‘\176’::bytea;
ра символов
«печатаемые»
байты
(значение SELECT
‘\001’::bytea;
Выводимый
зультат
ре-
&lt;br /&gt;
\001
~
В зависимости от применяемой клиентской библиотеки PostgreSQL, для преобразования значе-
ний bytea в спецстроки и обратно могут потребоваться дополнительные действия. Например, если
приложение сохраняет в строках символы перевода строк, возможно их также нужно будет пред-
ставить спецпоследовательностями.
8.5. Типы даты/времени
PostgreSQL поддерживает полный набор типов даты и времени SQL, показанный в Таблице  8.9.
Операции, возможные с этими типами данных, описаны в Разделе  9.9. Все даты считаются по
Григорианскому календарю, даже для времени до его введения (за дополнительными сведениями
обратитесь к Разделу B.4).
Таблица 8.9. Типы даты/времени
Имя
Размер
Описание
Наименьшее
значение
Наибольшее
значение Точность
timestamp [ ( 8 байт
p)
]
[ without time
zone ] дата и время 4713 до н. э.
(без часового
пояса) 294276 н. э. 1 микросекун-
да
timestamp [ ( 8 байт
p)
]
with
time zone дата и время ( 4713 до н. э.
с часовым поя-
сом) 294276 н. э. 1 микросекун-
да
дата (без вре- 4713 до н. э.
мени суток) 5874897 н. э. 1 день
time [ ( p) ] 8 байт
[ without time
zone ] время суток ( 00:00:00
без даты) 24:00:00 1 микросекун-
да
time [ ( p) ] 12 байт
with time zone время дня (без 00:00:00+1459 24:00:00-1459
даты), с часо-
вым поясом interval [ по- 16 байт
ля ] [ ( p) ] временной ин- -178000000 лет 178000000 лет 1 микросекун-
тервал
да
date
4 байта
128
1 микросекун-
даТипы данных
Примечание
Стандарт SQL требует, чтобы тип timestamp подразумевал timestamp without time
zone (время без часового пояса), и PostgreSQL следует этому. Для краткости timestamp
with time zone можно записать как timestamptz; это расширение PostgreSQL.
Типы time, timestamp и interval принимают необязательное значение точности p, определяющее,
сколько знаков после запятой должно сохраняться в секундах. По умолчанию точность не ограни-
чивается. Допустимые значения p лежат в интервале от 0 до 6.
Тип interval дополнительно позволяет ограничить набор сохраняемых поле следующими фраза-
ми:
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
Заметьте, что если указаны и поля, и точность p, указание поля должно включать SECOND, так как
точность применима только к секундам.
Тип time with time zone определён стандартом SQL, но в его определении описаны свойства
сомнительной ценности. В большинстве случаев сочетание типов date, time, timestamp without
time zone и timestamp with time zone удовлетворяет все потребности в функционале дат/времени,
возникающие в приложениях.
Типы abstime и reltime имеют меньшую точность и предназначены для внутреннего использова-
ния. Эти типы не рекомендуется использовать в обычных приложениях; их может не быть в буду-
щих версиях.
8.5.1. Ввод даты/времени
Значения даты и времени принимаются практически в любом разумном формате, включая ISO
8601, SQL-совместимый, традиционный формат POSTGRES и другие. В некоторых форматах поря-
док даты, месяца и года во вводимой дате неоднозначен и поэтому поддерживается явное опреде-
ление формата. Для этого предназначен параметр DateStyle. Когда он имеет значение MDY, выби-
рается интерпретация месяц-день-год, значению DMY соответствует день-месяц-год, а YMD — год-
месяц-день.
PostgreSQL обрабатывает вводимые значения даты/времени более гибко, чем того требует стан-
дарт SQL. Точные правила разбора даты/времени и распознаваемые текстовые поля, в том числе
названия месяцев, дней недели и часовых поясов описаны в Приложении B.
Помните, что любые вводимые значения даты и времени нужно заключать в апострофы, как тек-
стовые строки. За дополнительной информацией обратитесь к Подразделу 4.1.2.7. SQL предусмат-
ривает следующий синтаксис:
тип [ (p) ] ‘значение’
Здесь p — необязательное указание точности, определяющее число знаков после точки в секундах.
Точность может быть определена для типов time, timestamp и interval в интервале от 0 до 6. Если
129Типы данных
в определении константы точность не указана, она считается равной точности значения в строке
(но не больше 6 цифр).
8.5.1.1. Даты
В Таблице 8.10 приведены некоторые допустимые значения типа date.
Таблица 8.10. Вводимые даты
Пример Описание
1999-01-08 ISO 8601; 8 января в любом режиме (рекоменду-
емый формат)
January 8, 1999 воспринимается однозначно в любом режиме
datestyle
1/8/1999 8 января в режиме MDY и 1 августа в режиме DMY
1/18/1999 18 января в режиме MDY; недопустимая дата в
других режимах
01/02/03 2 января 2003 г. в режиме MDY; 1 февраля 2003 г.
в режиме DMY и 3 февраля 2001 г. в режиме YMD
1999-Jan-08 8 января в любом режиме
Jan-08-1999 8 января в любом режиме
08-Jan-1999 8 января в любом режиме
99-Jan-08 8 января в режиме YMD; ошибка в других режи-
мах
08-Jan-99 8 января; ошибка в режиме YMD
Jan-08-99 8 января; ошибка в режиме YMD
19990108 ISO 8601; 8 января 1999 в любом режиме
990108 ISO 8601; 8 января 1999 в любом режиме
1999.008 год и день года
J2451187 дата по юлианскому календарю
January 8, 99 BC 99 до н. э.
8.5.1.2. Время
Для хранения времени суток без даты предназначены типы time [ (p) ] without time zone и
time [ (p) ] with time zone. Тип time без уточнения эквивалентен типу time without time zone.
Допустимые вводимые значения этих типов состоят из записи времени суток и необязательного
указания часового пояса. (См. Таблицу 8.11 и Таблицу 8.12.) Если в значении для типа time without
time zone указывается часовой пояс, он просто игнорируется. Так же будет игнорироваться дата,
если её указать, за исключением случаев, когда в указанном часовом поясе принят переход на
летнее время, например America/New_York. В данном случае указать дату необходимо, чтобы си-
стема могла определить, применяется ли обычное или летнее время. Соответствующее смещение
часового пояса записывается в значении time with time zone.
Таблица 8.11. Вводимое время
Пример Описание
04:05:06.789 ISO 8601
04:05:06 ISO 8601
04:05 ISO 8601
040506 ISO 8601
130Типы данных
Пример Описание
04:05 AM то же, что и 04:05; AM не меняет значение вре-
мени
04:05 PM то же, что и 16:05; часы должны быть &amp;lt;= 12
04:05:06.789-8 ISO 8601
04:05:06-08:00 ISO 8601
04:05-08:00 ISO 8601
040506-08 ISO 8601
04:05:06 PST часовой пояс задаётся аббревиатурой
2003-04-12 04:05:06 America/New_York часовой пояс задаётся полным названием
Таблица 8.12. Вводимый часовой пояс
Пример Описание
PST аббревиатура (Pacific Standard Time, Стандарт-
ное тихоокеанское время)
America/New_York полное название часового пояса
PST8PDT указание часового пояса в стиле POSIX
-8:00 смещение часового пояса PST по ISO-8601
-800 смещение часового пояса PST по ISO-8601
-8 смещение часового пояса PST по ISO-8601
zulu принятое у военных сокращение UTC
z краткая форма zulu
Подробнее узнать о том, как указывается часовой пояс, можно в Подразделе 8.5.3.
8.5.1.3. Даты и время
Допустимые значения типов timestamp состоят из записи даты и времени, после которого может
указываться часовой пояс и необязательное уточнение AD или BC, определяющее эпоху до нашей
эры и нашу эру соответственно. (AD/BC можно указать и перед часовым поясом, но предпочтитель-
нее первый вариант.) Таким образом:
1999-01-08 04:05:06
и
1999-01-08 04:05:06 -8:00
допустимые варианты, соответствующие стандарту ISO 8601. В дополнение к этому поддержива-
ется распространённый формат:
January 8 04:05:06 1999 PST
Стандарт SQL различает константы типов timestamp without time zone и timestamp with time
zone по знаку «+» или «-» и смещению часового пояса, добавленному после времени. Следователь-
но, согласно стандарту, записи
TIMESTAMP ‘2004-10-19 10:23:54’
должен соответствовать тип timestamp without time zone, а
TIMESTAMP ‘2004-10-19 10:23:54+02’
тип timestamp with time zone. PostgreSQL никогда не анализирует содержимое текстовой стро-
ки, чтобы определить тип значения, и поэтому обе записи будут обработаны как значения типа
131Типы данных
timestamp without time zone. Чтобы текстовая константа обрабатывалась как timestamp with
time zone, укажите этот тип явно:
TIMESTAMP WITH TIME ZONE ‘2004-10-19 10:23:54+02’
В константе типа timestamp without time zone PostgreSQL просто игнорирует часовой пояс. То
есть результирующее значение вычисляется только из полей даты/времени и не подстраивается
под указанный часовой пояс.
Значения timestamp with time zone внутри всегда хранятся в UTC (Universal Coordinated Time,
Всемирное скоординированное время или время по Гринвичу, GMT). Вводимое значение, в котором
явно указан часовой пояс, переводится в UTC с учётом смещения данного часового пояса. Если
во входной строке не указан часовой пояс, подразумевается часовой пояс, заданный системным
параметром TimeZone и время так же пересчитывается в UTC со смещением timezone.
Когда значение timestamp with time zone выводится, оно всегда преобразуется из UTC в текущий
часовой пояс timezone и отображается как локальное время. Чтобы получить время для другого
часового пояса, нужно либо изменить timezone, либо воспользоваться конструкцией AT TIME ZONE
(см. Подраздел 9.9.3).
В преобразованиях между timestamp without time zone и timestamp with time zone обычно пред-
полагается, что значение timestamp without time zone содержит местное время (для часового
пояса timezone). Другой часовой пояс для преобразования можно задать с помощью AT TIME ZONE.
8.5.1.4. Специальные значения
PostgreSQL для удобства поддерживает несколько специальных значений даты/времени, перечис-
ленных в Таблице 8.13. Значения infinity и -infinity имеют особое представление в системе и
они отображаются в том же виде, тогда как другие варианты при чтении преобразуются в значе-
ния даты/времени. (В частности, now и подобные строки преобразуются в актуальные значения
времени в момент чтения.) Чтобы использовать эти значения в качестве констант в командах SQL,
их нужно заключать в апострофы.
Таблица 8.13. Специальные значения даты/времени
Вводимая строка Допустимые типы Описание
epoch date, timestamp 1970-01-01 00:00:00+00 (точка
отсчёта времени в Unix)
infinity date, timestamp время после максимальной до-
пустимой даты
-infinity date, timestamp время до минимальной допусти-
мой даты
now date, time, timestamp время начала текущей транзак-
ции
today date, timestamp время начала текущих суток
tomorrow date, timestamp время начала следующих суток
yesterday date, timestamp время начала предыдущих су-
ток
allballs time 00:00:00.00 UTC
Для получения текущей даты/времени соответствующего типа можно также использовать следу-
ющие SQL-совместимые функции: CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, LOCALTIME и
LOCALTIMESTAMP. Последние четыре функции принимают необязательное указание точности. (См.
Подраздел 9.9.4.) Заметьте, что во входных строках эти SQL-функции не распознаются.
8.5.2. Вывод даты/времени
132Типы данных
В качестве выходного формата типов даты/времени можно использовать один из четырёх стилей:
ISO 8601, SQL (Ingres), традиционный формат POSTGRES (формат date в Unix) или German. По
умолчанию выбран формат ISO. (Стандарт SQL требует, чтобы использовался именно ISO 8601.
Другой формат называется «SQL» исключительно по историческим причинам.) Примеры всех сти-
лей вывода перечислены в Таблице 8.14. Вообще со значениями типов date и time выводилась бы
только часть даты или времени из показанных примеров, но со стилем POSTGRES значение даты
без времени выводится в формате ISO.
Таблица 8.14. Стили вывода даты/время
Стиль Описание Пример
ISO ISO 8601, стандарт SQL 1997-12-17 07:37:16-08
SQL традиционный стиль 12/17/1997 07:37:16.00 PST
Postgres изначальный стиль Wed Dec 17 07:37:16 1997 PST
German региональный стиль 17.12.1997 07:37:16.00 PST
Примечание
ISO 8601 указывает, что дата должна отделяться от времени буквой T в верхнем реги-
стре. PostgreSQL принимает этот формат при вводе, но при выводе вставляет вместо
T пробел, как показано выше. Это сделано для улучшения читаемости и для совмести-
мости с RFC 3339 и другими СУБД.
В стилях SQL и POSTGRES день выводится перед месяцем, если установлен порядок DMY, а в
противном случае месяц выводится перед днём. (Как этот параметр также влияет на интерпрета-
цию входных значений, описано в Подразделе 8.5.1) Соответствующие примеры показаны в Таб-
лице 8.15.
Таблица 8.15. Соглашения о порядке компонентов даты
Параметр datestyle Порядок при вводе Пример вывода
SQL, DMY день/месяц/год 17/12/1997 15:37:16.00 CET
SQL, MDY месяц/день/год 12/17/1997 07:37:16.00 PST
Postgres, DMY день/месяц/год Wed 17 Dec 07:37:16 1997 PST
Стиль даты/времени пользователь может выбрать с помощью команды SET datestyle, параметра
DateStyle в файле конфигурации postgresql.conf или переменной окружения PGDATESTYLE на сер-
вере или клиенте.
Для большей гибкости при форматировании выводимой даты/времени можно использовать функ-
цию to_char (см. Раздел 9.8).
8.5.3. Часовые пояса
Часовые пояса и правила их применения определяются, как вы знаете, не только по географиче-
ским, но и по политическим соображениям. Часовые пояса во всём мире были более-менее стан-
дартизированы в начале прошлого века, но они продолжают претерпевать изменения, в частности
это касается перехода на летнее время. Для расчёта времени в прошлом PostgreSQL получает ис-
торические сведения о правилах часовых поясов из распространённой базы данных IANA (Olson).
Для будущего времени предполагается, что в заданном часовом поясе будут продолжать действо-
вать последние принятые правила.
PostgreSQL стремится к совместимости со стандартом SQL в наиболее типичных случаях. Однако
стандарт SQL допускает некоторые странности при смешивании типов даты и времени. Две оче-
видные проблемы:
133Типы данных
• Хотя для типа date часовой пояс указать нельзя, это можно сделать для типа time. В реально-
сти это не очень полезно, так как без даты нельзя точно определить смещение при переходе
на летнее время.
• По умолчанию часовой пояс задаётся постоянным смещением от UTC. Это также не позво-
ляет учесть летнее время при арифметических операций с датами, пересекающими границы
летнего времени.
Поэтому мы советуем использовать часовой пояс с типами, включающими и время, и дату. Мы
не рекомендуем использовать тип time with time zone (хотя PostgreSQL поддерживает его для
старых приложений и совместимости со стандартом SQL). Для типов, включающих только дату
или только время, в PostgreSQL предполагается местный часовой пояс.
Все значения даты и времени с часовым поясом представляются внутри в UTC, а при передаче
клиентскому приложению они переводятся в местное время, при этом часовой пояс по умолчанию
определяется параметром конфигурации TimeZone.
PostgreSQL позволяет задать часовой пояс тремя способами:
• Полное название часового пояса, например America/New_York. Все допустимые названия пе-
речислены в представлении pg_timezone_names (см. Раздел 52.90). Определения часовых поя-
сов PostgreSQL берёт из широко распространённой базы IANA, так что имена часовых поясов
PostgreSQL будут воспринимать и многие другие приложения.
• Аббревиатура часового пояса, например PST. Такое определение просто задаёт смещение
от UTC, в отличие от полных названий поясов, которые кроме того подразумевают и пра-
вила перехода на летнее время. Распознаваемые аббревиатуры перечислены в представле-
нии pg_timezone_abbrevs (см. Раздел 52.89). Аббревиатуры можно использовать во вводи-
мых значениях даты/времени и в операторе AT TIME ZONE, но не в параметрах конфигурации
TimeZone и log_timezone.
• В дополнение к полным названиям и аббревиатурам часовых поясов PostgreSQL принимает
указания часового пояса в стиле POSIX: STDсмещение или STDсмещениеDST, где STD — аббре-
виатура пояса, смещение — разница с UTC, а DST — необязательное дополнение, обозначаю-
щее летнее время и добавляющее к смещению ещё один час. Например, если бы обозначение
EST5EDT не являлось названием часового пояса, оно всё равно было бы воспринято и функцио-
нально соответствовало бы поясу североамериканского восточного времени. При такой запи-
си аббревиатура пояса может быть набором букв или обычной строкой, заключённой в угло-
вые скобки ((&amp;lt;&amp;gt;). Когда представлено название пояса с летним временем, при пересчёте вре-
мени будут использоваться правила перехода на летнее время, описанные в базе данных IANA
в файле posixrules. В стандартной инсталляции PostgreSQL файл posixrules соответствует
описанию US/Eastern, так что для указаний часовых поясов в стиле POSIX применяются пра-
вила перехода на летнее время, принятые в США. При необходимости это можно изменить,
заменив файл posixrules.
Вкратце, различие между аббревиатурами и полными названиями заключаются в следующем: аб-
бревиатуры представляют определённый сдвиг от UTC, а полное название подразумевает ещё и
местное правило по переходу на летнее время, то есть, возможно, два сдвига от UTC. Например,
2014-06-04 12:00 America/New_York представляет полдень по местному времени в Нью-Йорк, что
для данного дня было бы летним восточным временем (EDT или UTC-4). Так что 2014-06-04 12:00
EDT обозначает тот же момент времени. Но 2014-06-04 12:00 EST задаёт стандартное восточное
время (UTC-5), не зависящее о того, действовало ли летнее время в этот день.
Мало того, в некоторых юрисдикциях одна и та же аббревиатура часового пояса означала разные
сдвиги UTC в разное время; например, аббревиатура московского времени MSK несколько лет озна-
чала UTC+3, а затем стала означать UTC+4. PostgreSQL обрабатывает такие аббревиатуры в соот-
ветствии с их значениями на заданную дату, но, как и с примером выше EST, это не обязательно
будет соответствовать местному гражданскому времени в этот день.
При этом следует использовать возможность указания часового пояса в стиле POSIX с осторожно-
стью, так как при этом могут быть приняты заведомо неверные данные, потому что разумность
134Типы данных
аббревиатуры никак не проверяется. Например, команда SET TIMEZONE TO FOOBAR0 будет работать
и система примет эту довольно оригинальную аббревиатуру для UTC. Также следует учитывать,
что в названиях часовых поясов POSIX положительные смещения соответствуют сдвигу к западу
Гринвича. Во всех остальных формах PostgreSQL следует соглашению ISO-8601, по которому по-
ложительным смещениям соответствует сдвиг к востоку от Гринвича.
Независимо от формы, регистр в названиях и аббревиатурах часовых поясов не важен. (В
PostgreSQL до версии 8.2 он где-то имел значение, а где-то нет.)
Ни названия, ни аббревиатуры часовых поясов, не зашиты в самом сервере; они считываются из
файлов конфигурации, находящихся в путях …/share/timezone/ и …/share/timezonesets/ от-
носительно каталога установки (см. Раздел B.3).
Параметр конфигурации TimeZone можно установить в postgresql.conf или любым другим стан-
дартным способом, описанным в Главе 19. Часовой пояс может быть также определён следующи-
ми специальными способами:
• Часовой пояс для текущего сеанса можно установить с помощью SQL-команды SET TIME ZONE.
Это альтернативная запись команды SET TIMEZONE TO, более соответствующая SQL-стандарту.
• Если установлена переменная окружения PGTZ, клиенты libpq используют её значение, выпол-
няя при подключении к серверу команду SET TIME ZONE.
8.5.4. Ввод интервалов
Значения типа interval могут быть записаны в следующей расширенной форме:
[@] количество единица [количество единица…] [направление]
где количество — это число (возможно, со знаком); единица — одно из значений: microsecond,
millisecond, second, minute, hour, day, week, month, year, decade, century, millennium (которые
обозначают соответственно микросекунды, миллисекунды, секунды, минуты, часы, дни, недели,
месяцы, годы, десятилетия, века и тысячелетия), либо эти же слова во множественном числе, либо
их сокращения; направление может принимать значение ago (назад) или быть пустым. Знак @ яв-
ляется необязательным. Все заданные величины различных единиц суммируются вместе с учётом
знака чисел. Указание ago меняет знак всех полей на противоположный. Этот синтаксис также ис-
пользуется при выводе интервала, если параметр IntervalStyle имеет значение postgres_verbose.
Количества дней, часов, минут и секунд можно определить, не указывая явно соответствующие
единицы. Например, запись ‘1 12:59:10’ равнозначна ‘1 day 12 hours 59 min 10 sec’. Сочетание
года и месяца также можно записать через минус; например ‘200-10’ означает то, же что и ‘200
years 10 months’. (На самом деле только эти краткие формы разрешены стандартом SQL и они
используются при выводе, когда IntervalStyle имеет значение sql_standard.)
Интервалы можно также записывать в виде, определённом в ISO 8601, либо в «формате с кодами»,
описанном в разделе 4.4.3.2 этого стандарта, либо в «альтернативном формате», описанном в раз-
деле 4.4.3.3. Формат с кодами выглядит так:
P количество единица [ количество единица …] [ T [ количество единица …]]
Строка должна начинаться с символа P и может включать также T перед временем суток. Допусти-
мые коды единиц перечислены в Таблице 8.16. Коды единиц можно опустить или указать в любом
порядке, но компоненты времени суток должны идти после символа T. В частности, значение кода
M зависит от того, располагается ли он до или после T.
Таблица 8.16. Коды единиц временных интервалов ISO 8601
Код Значение
Y годы
M месяцы (в дате)
W недели
135Типы данных
Код Значение
D дни
H часы
M минуты (во времени)
S секунды
В альтернативном формате:
P [ год-месяц-день ] [ T часы:минуты:секунды ]
строка должна начинаться с P, а T разделяет компоненты даты и времени. Значения выражаются
числами так же, как и в датах ISO 8601.
При записи интервальной константы с указанием полей или присвоении столбцу типа interval стро-
ки с полями, интерпретация непомеченных величин зависит от полей. Например, INTERVAL ‘1’
YEAR воспринимается как 1 год, а INTERVAL ‘1’ — как 1 секунда. Кроме того, значения «справа»
от меньшего значащего поля, заданного в определении полей, просто отбрасываются. Например,
в записи INTERVAL ‘1 day 2:03:04’ HOUR TO MINUTE будут отброшены секунды, но не день.
Согласно стандарту SQL, все компоненты значения interval должны быть одного знака, и ведущий
минус применяется ко всем компонентам; например, минус в записи ‘-1 2:03:04’ применяется
и к дню, и к часам/минутам/секундам. PostgreSQL позволяет задавать для разных компонентов
разные знаки и традиционно обрабатывает знак каждого компонента в текстовом представлении
отдельно от других, так что в данном случае часы/минуты/секунды будут считаться положитель-
ными. Если параметр IntervalStyle имеет значение sql_standard, ведущий знак применяется
ко всем компонентам (но только если они не содержат знаки явно). В противном случае действу-
ют традиционные правила PostgreSQL. Во избежание неоднозначности рекомендуется добавлять
знак к каждому компоненту с отрицательным значением.
В расширенном формате ввода и в некоторых полях более компактных форматов значения компо-
нентов могут иметь дробные части, например ‘1.5 week’ или ‘01:02:03.45’. Такое значение при
сохранении пересчитывается в соответствующее число месяцев, дней и секунд. Когда при этом
остаётся дробная часть в месяцах или в днях, она переносится в младший компонент с допущени-
ем, что 1 месяц = 30 дней, а 1 день = 24 часа. Например, значение ‘1.5 month’ будет преобразо-
вано в 1 месяц и 15 дней. В виде дробного числа хранятся и выводятся только секунды.
В Таблице 8.17 показано несколько примеров допустимых вводимых значений типа interval.
Таблица 8.17. Ввод интервалов
Пример Описание
1-2 Стандартный формат SQL: 1 год и 2 месяца
3 4:05:06 Стандартный формат SQL: 3 дня 4 часа 5 минут
6 секунд
1 year 2 months 3 days 4 hours 5 minutes 6 seconds Традиционный формат Postgres: 1 год 2 месяца
3 дня 4 часа 5 минут 6 секунд
P1Y2M3DT4H5M6S «Формат с кодами» ISO 8601: то же значение,
что и выше
P0001-02-03T04:05:06 «Альтернативный формат» ISO 8601: то же зна-
чение, что и выше
Тип interval представлен внутри в виде отдельных значений месяцев, дней и секунд. Это объяс-
няется тем, что число дней в месяце может быть разным, а в сутках может быть и 23, и 25 часов в
дни перехода на летнее/зимнее время. Значения месяцев и дней представлены целыми числами, а
число секунд может быть дробным. Так как интервалы обычно получаются из строковых констант
или при вычитании типов timestamp, этот способ хранения эффективен в большинстве случаев, но
может давать неожиданные результаты:
136Типы данных
SELECT EXTRACT(hours from ‘80 minutes’::interval);
date_part
———–
1
SELECT EXTRACT(days from ‘80 hours’::interval);
date_part
———–
0
Для корректировки числа дней и часов, когда они выходят за обычные границы, есть специальные
функции justify_days и justify_hours.
8.5.5. Вывод интервалов
Формат вывода типа interval может определяться одним из четырёх стилей: sql_standard,
postgres, postgres_verbose и iso_8601. Выбрать нужный стиль позволяет команда SET
intervalstyle (по умолчанию выбран postgres). Примеры форматов разных стилей показаны в
Таблице 8.18.
Стиль sql_standard выдаёт результат, соответствующий стандарту SQL, если значение интервала
удовлетворяет ограничениям стандарта (и содержит либо только год и месяц, либо только день и
время, и при этом все его компоненты одного знака). В противном случае выводится год-месяц, за
которым идёт дата-время, а в компоненты для однозначности явно добавляются знаки.
Вывод в стиле postgres соответствует формату, который был принят в PostgreSQL до версии 8.4,
когда параметр DateStyle имел значение ISO.
Вывод в стиле postgres_verbose соответствует формату, который был принят в PostgreSQL до вер-
сии 8.4, когда значением параметром DateStyle было не ISO.
Вывод в стиле iso_8601 соответствует «формату с кодами» описанному в разделе 4.4.3.2 формата
ISO 8601.
Таблица 8.18. Примеры стилей вывода интервалов
Стиль Интервал год-месяц Интервал
мя
день-вре- Смешанный
вал
интер-
sql_standard 1-2 3 4:05:06
-1-2 +3 -4:05:06
postgres 1 year 2 mons 3 days 04:05:06
-1 year -2 mons +3 days
-04:05:06
postgres_verbose @ 1 year 2 mons @ 3 days 4 hours 5 mins @ 1 year 2 mons -3 days
6 secs
4 hours 5 mins 6 secs ago
iso_8601 P1Y2M P3DT4H5M6S
P-1Y-2M3DT-4H-5M-6S
8.6. Логический тип
В PostgreSQL есть стандартный SQL-тип boolean; см. Таблицу 8.19. Тип boolean может иметь сле-
дующие состояния: «true», «false» и третье состояние, «unknown», которое представляется SQL-
значением NULL.
Таблица 8.19. Логический тип данных
Имя Размер Описание
boolean 1 байт состояние: истина или ложь
Состояние «true» может задаваться следующими значениями:
TRUE
137Типы данных
‘t’
‘true’
‘y’
‘yes’
‘on’
‘1’
Для состояния «false» можно использовать следующие варианты:
FALSE
‘f’
‘false’
‘n’
‘no’
‘off’
‘0’
При этом пробелы в начале и конце строки игнорируются, и регистр так же не имеет значения.
Предпочтительными (совместимыми с SQL) являются варианты TRUE и FALSE.
Пример 8.2 показывает, что значения типа boolean при выводе представляются буквами t и f.
Пример 8.2. Использование типа boolean
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, ‘sic est’);
INSERT INTO test1 VALUES (FALSE, ‘non est’);
SELECT * FROM test1;
a |
b
—+———
t | sic est
f | non est
SELECT * FROM test1 WHERE a;
a |
b
—+———
t | sic est
8.7. Типы перечислений
Типы перечислений (enum) определяют статический упорядоченный набор значений, так же как
и типы enum, существующие в ряде языков программирования. В качестве перечисления можно
привести дни недели или набор состояний.
8.7.1. Объявление перечислений
Тип перечислений создаются с помощью команды CREATE TYPE, например так:
CREATE TYPE mood AS ENUM (‘sad’, ‘ok’, ‘happy’);
Созданные типы enum можно использовать в определениях таблиц и функций, как и любые другие:
CREATE TYPE mood AS ENUM (‘sad’, ‘ok’, ‘happy’);
CREATE TABLE person (
name text,
current_mood mood
);
INSERT INTO person VALUES (‘Moe’, ‘happy’);
SELECT * FROM person WHERE current_mood = ‘happy’;
name | current_mood
——+————–
138Типы данных
Moe | happy
(1 row)
8.7.2. Порядок
Порядок значений в перечислении определяется последовательностью, в которой были указаны
значения при создании типа. Перечисления поддерживаются всеми стандартными операторами
сравнения и связанными агрегатными функциями. Например:
INSERT INTO person VALUES (‘Larry’, ‘sad’);
INSERT INTO person VALUES (‘Curly’, ‘ok’);
SELECT * FROM person WHERE current_mood &amp;gt; ‘sad’;
name | current_mood
——-+————–
Moe
| happy
Curly | ok
(2 rows)
SELECT * FROM person WHERE current_mood &amp;gt; ‘sad’ ORDER BY current_mood;
name | current_mood
——-+————–
Curly | ok
Moe
| happy
(2 rows)
SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
name
——-
Larry
(1 row)
8.7.3. Безопасность типа
Все типы перечислений считаются уникальными и поэтому значения разных типов нельзя срав-
нивать. Взгляните на этот пример:
CREATE TYPE happiness AS ENUM (‘happy’, ‘very happy’, ‘ecstatic’);
CREATE TABLE holidays (
num_weeks integer,
happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, ‘happy’);
INSERT INTO holidays(num_weeks,happiness) VALUES (6, ‘very happy’);
INSERT INTO holidays(num_weeks,happiness) VALUES (8, ‘ecstatic’);
INSERT INTO holidays(num_weeks,happiness) VALUES (2, ‘sad’);
ОШИБКА: неверное значение для перечисления happiness: “sad”
SELECT person.name, holidays.num_weeks FROM person, holidays
WHERE person.current_mood = holidays.happiness;
ОШИБКА: оператор не существует: mood = happiness
Если вам действительно нужно сделать что-то подобное, вы можете либо реализовать собственный
оператор, либо явно преобразовать типы в запросе:
SELECT person.name, holidays.num_weeks FROM person, holidays
WHERE person.current_mood::text = holidays.happiness::text;
name | num_weeks
——+———–
Moe |
4
139Типы данных
(1 row)
8.7.4. Тонкости реализации
В метках значений регистр имеет значение, т. е. ‘happy’ и ‘HAPPY’ — не одно и то же. Также в
метках имеют значение пробелы.
Хотя типы-перечисления предназначены прежде всего для статических наборов значений, имеет-
ся возможность добавлять новые значения в существующий тип-перечисление и переименовывать
значения (см. ALTER TYPE). Однако удалять существующие значения из перечисления, а также
изменять их порядок, нельзя — для получения нужного результата придётся удалить и воссоздать
это перечисление.
Значение enum занимает на диске 4 байта. Длина текстовой метки значения ограничена парамет-
ром компиляции NAMEDATALEN; в стандартных сборках PostgreSQL он ограничивает длину 63 бай-
тами.
Сопоставления внутренних значений enum с текстовыми метками хранятся в системном каталоге
pg_enum. Он может быть полезен в ряде случаев.
8.8. Геометрические типы
Геометрические типы данных представляют объекты в двумерном пространстве. Все существую-
щие в PostgreSQL геометрические типы перечислены в Таблице 8.20.
Таблица 8.20. Геометрические типы
Имя Размер Описание Представление
point 16 байт Точка на плоскости (x,y)
line 32 байта Бесконечная прямая (A,B,C)
lseg 32 байта Отрезок ((x1,y1),(x2,y2))
box 32 байта Прямоугольник ((x1,y1),(x2,y2))
path 16+16n байт Закрытый путь (подоб- ((x1,y1),…)
ный многоугольнику)
path 16+16n байт Открытый путь polygon 40+16n байт Многоугольник (подоб- ((x1,y1),…)
ный закрытому пути)
circle 24 байта Окружность
[(x1,y1),…]
&amp;lt;(x,y),r&amp;gt; (центр окруж-
ности и радиус)
Для выполнения различных геометрических операций, в частности масштабирования, вращения
и определения пересечений, PostgreSQL предлагает богатый набор функций и операторов. Они
рассматриваются в Разделе 9.11.
8.8.1. Точки
Точки — это основной элемент, на базе которого строятся все остальные геометрические типы.
Значения типа point записываются в одном из двух форматов:
( x , y )
x , y
где x и y — координаты точки на плоскости, выраженные числами с плавающей точкой.
Выводятся точки в первом формате.
8.8.2. Прямые
140Типы данных
Прямые представляются линейным уравнением Ax + By + C = 0, где A и B не равны 0. Значения
типа line вводятся и выводятся в следующем виде:
( A, B, C )
Кроме того, для ввода может использоваться любая из этих форм:
[ ( x1
( ( x1
( x1
x1
,
,
,
,
y1 ) , ( x2
y1 ) , ( x2
y1 ) , ( x2
y1
,
x2
,
,
,
,
y2 ) ]
y2 ) )
y2 )
y2
где (x1,y1) и (x2,y2) — две различные точки на данной прямой.
8.8.3. Отрезки
Отрезок представляется парой точек, определяющих концы отрезка. Значения типа lseg записы-
ваются в одной из следующих форм:
[ ( x1
( ( x1
( x1
x1
,
,
,
,
y1 ) , ( x2
y1 ) , ( x2
y1 ) , ( x2
y1
,
x2
,
,
,
,
y2 ) ]
y2 ) )
y2 )
y2
где (x1,y1) и (x2,y2) — концы отрезка.
Выводятся отрезки в первом формате.
8.8.4. Прямоугольники
Прямоугольник представляется двумя точками, находящимися в противоположных его углах. Зна-
чения типа box записываются в одной из следующих форм:
( ( x1 , y1 ) , ( x2 , y2 ) )
( x1 , y1 ) , ( x2 , y2 )
x1 , y1
,
x2 , y2
где (x1,y1) и (x2,y2) — противоположные углы прямоугольника.
Выводятся прямоугольники во второй форме.
Во вводимом значении могут быть указаны любые два противоположных угла, но затем они будут
упорядочены, так что внутри сохранятся правый верхний и левый нижний углы, в таком порядке.
8.8.5. Пути
Пути представляют собой списки соединённых точек. Пути могут быть закрытыми, когда подра-
зумевается, что первая и последняя точка в списке соединены, или открытыми, в противном слу-
чае.
Значения типа path записываются в одной из следующих форм:
[ ( x1
( ( x1
( x1
( x1
x1
,
,
,
,
,
y1 ) , … , ( xn , yn
y1 ) , … , ( xn , yn
y1 ) , … , ( xn , yn
y1
, … ,
xn , yn
y1
, … ,
xn , yn
) ]
) )
)
)
где точки задают узлы сегментов, составляющих путь. Квадратные скобки ([]) указывают, что путь
открытый, а круглые (()) — закрытый. Когда внешние скобки опускаются, как в показанных выше
последних трёх формах, считается, что путь закрытый.
Пути выводятся в первой или второй форме, в соответствии с типом.
8.8.6. Многоугольники
141Типы данных
Многоугольники представляются списками точек (вершин). Многоугольники похожи на закрытые
пути, но хранятся в другом виде и для работы с ними предназначен отдельный набор функций.
Значения типа polygon записываются в одной из следующих форм:
( ( x1 , y1 ) , … , ( xn , yn ) )
( x1 , y1 ) , … , ( xn , yn )
( x1 , y1
, … ,
xn , yn )
x1 , y1
, … ,
xn , yn
где точки задают узлы сегментов, образующих границу многоугольника.
Выводятся многоугольники в первом формате.
8.8.7. Окружности
Окружности задаются координатами центра и радиусом. Значения типа circle записываются в
одном из следующих форматов:
&amp;lt; ( x
( ( x
( x
x
,
,
,
,
y ) , r &amp;gt;
y ) , r )
y ) , r
y
, r
где (x,y) — центр окружности, а r — её радиус.
Выводятся окружности в первом формате.
8.9. Типы, описывающие сетевые адреса
PostgreSQL предлагает типы данных для хранения адресов IPv4, IPv6 и MAC, показанные в Таб-
лице 8.21. Для хранения сетевых адресов лучше использовать эти типы, а не простые текстовые
строки, так как PostgreSQL проверяет вводимые значения данных типов и предоставляет специа-
лизированные операторы и функции для работы с ними (см. Раздел 9.12).
Таблица 8.21. Типы, описывающие сетевые адреса
Имя Размер Описание
cidr 7 или 19 байт Сети IPv4 и IPv6
inet 7 или 19 байт Узлы и сети IPv4 и IPv6
macaddr 6 байт MAC-адреса
macaddr8 8 байт MAC-адреса (в формате EUI-64)
При сортировке типов inet и cidr, адреса IPv4 всегда идут до адресов IPv6, в том числе адреса
IPv4, включённые в IPv6 или сопоставленные с ними, например ::10.2.3.4 или ::ffff:10.4.3.2.
8.9.1. inet
Тип inet содержит IPv4- или IPv6-адрес узла и может также содержать его подсеть, всё в одном
поле. Подсеть представляется числом бит, определяющих адрес сети в адресе узла (или «маску
сети»). Если маска сети равна 32 для адреса IPv4, такое значение представляет не подсеть, а опре-
делённый узел. Адреса IPv6 имеют длину 128 бит, поэтому уникальный адрес узла задаётся с мас-
кой 128 бит. Заметьте, что когда нужно, чтобы принимались только адреса сетей, следует исполь-
зовать тип cidr, а не inet.
Вводимые значения такого типа должны иметь формат IP-адрес/y, где IP-адрес — адрес IPv4 или
IPv6, а y — число бит в маске сети. Если компонент /y отсутствует, маска сети считается равной 32
для IPv4 и 128 для IPv6, так что это значение будет представлять один узел. При выводе компонент
/y опускается, если сетевой адрес определяет адрес одного узла.
142Типы данных
8.9.2. cidr
Тип cidr содержит определение сети IPv4 или IPv6. Входные и выходные форматы соответству-
ют соглашениям CIDR (Classless Internet Domain Routing, Бесклассовая межсетевая адресация).
Определение сети записывается в формате IP-адрес/y, где IP-адрес — адрес сети IPv4 или IPv6, а
y — число бит в маске сети. Если y не указывается, это значение вычисляется по старой классовой
схеме нумерации сетей, но при этом оно может быть увеличено, чтобы в него вошли все байты
введённого адреса. Если в сетевом адресе справа от маски сети окажутся биты со значением 1,
он будет считаться ошибочным.
В Таблице 8.22 показаны несколько примеров адресов.
Таблица 8.22. Примеры допустимых значений типа cidr
Вводимое значение cidr Выводимое значение cidr abbrev( cidr)
192.168.100.128/25 192.168.100.128/25 192.168.100.128/25
192.168/24 192.168.0.0/24 192.168.0/24
192.168/25 192.168.0.0/25 192.168.0.0/25
192.168.1 192.168.1.0/24 192.168.1/24
192.168 192.168.0.0/24 192.168.0/24
128.1 128.1.0.0/16 128.1/16
128 128.0.0.0/16 128.0/16
128.1.2 128.1.2.0/24 128.1.2/24
10.1.2 10.1.2.0/24 10.1.2/24
10.1 10.1.0.0/16 10.1/16
10 10.0.0.0/8 10/8
10.1.2.3/32 10.1.2.3/32 10.1.2.3/32
2001:4f8:3:ba::/64 2001:4f8:3:ba::/64 2001:4f8:3:ba::/64
2001:4f8:3:ba:2e0:81ff:fe22:
d1f1/128 2001:4f8:3:ba:2e0:81ff:fe22:
d1f1/128 2001:4f8:3:ba:2e0:81ff:fe22:d1f1
::ffff:1.2.3.0/120 ::ffff:1.2.3.0/120 ::ffff:1.2.3/120
::ffff:1.2.3.0/128 ::ffff:1.2.3.0/128 ::ffff:1.2.3.0/128
8.9.3. Различия inet и cidr
Существенным различием типов данных inet и cidr является то, что inet принимает значения
с ненулевыми битами справа от маски сети, а cidr — нет. Например, значение 192.168.0.1/24
является допустимым для типа inet, но не для cidr.
Подсказка
Если вас не устраивает выходной формат значений inet или cidr, попробуйте функции
host, text и abbrev.
8.9.4. macaddr
Тип macaddr предназначен для хранения MAC-адреса, примером которого является адрес сетевой
платы Ethernet (хотя MAC-адреса применяются и для других целей). Вводимые значения могут
задаваться в следующих форматах:
‘08:00:2b:01:02:03’
‘08-00-2b-01-02-03’
143Типы данных
‘08002b:010203’
‘08002b-010203’
‘0800.2b01.0203’
‘0800-2b01-0203’
‘08002b010203’
Все эти примеры определяют один и тот же адрес. Шестнадцатеричные цифры от a до f могут быть
и в нижнем, и в верхнем регистре. Выводятся MAC-адреса всегда в первой форме.
Стандарт IEEE 802-2001 считает канонической формой MAC-адресов вторую (с минусами), а
в первой (с двоеточиями) предполагает обратный порядок бит, так что 08-00-2b-01-02-03 =
01:00:4D:08:04:0C. В настоящее время этому соглашению практически никто не следует, и уместно
оно было только для устаревших сетевых протоколов (таких как Token Ring). PostgreSQL не меняет
порядок бит и во всех принимаемых форматах подразумевается традиционный порядок LSB.
Последние пять входных форматов не описаны ни в каком стандарте.
8.9.5. macaddr8
Тип macaddr8 хранит MAC-адреса в формате EUI-64, применяющиеся, например, для аппаратных
адресов плат Ethernet (хотя MAC-адреса используются и для других целей). Этот тип может при-
нять и 6-байтовые, и 8-байтовые адреса MAC и сохраняет их в 8 байтах. MAC-адреса, заданные
в 6-байтовом формате, хранятся в формате 8 байт, а 4-ый и 5-ый байт содержат FF и FE, соответ-
ственно. Заметьте, что для IPv6 используется модифицированный формат EUI-64, в котором 7-ой
бит должен быть установлен в 1 после преобразования из EUI-48. Для выполнения этого измене-
ния предоставляется функция macaddr8_set7bit. Вообще говоря, этот тип принимает любые стро-
ки, состоящие из пар шестнадцатеричных цифр (выровненных по границам байт), которые могут
согласованно разделяться одинаковыми символами ‘:’, ‘-‘ или ‘.’. Шестнадцатеричных цифр
должно быть либо 16 (8 байт), либо 12 (6 байт). Ведущие и замыкающие пробелы игнорируются.
Ниже показаны примеры допустимых входных строк:
‘08:00:2b:01:02:03:04:05’
‘08-00-2b-01-02-03-04-05’
‘08002b:0102030405’
‘08002b-0102030405’
‘0800.2b01.0203.0405’
‘0800-2b01-0203-0405’
‘08002b01:02030405’
‘08002b0102030405’
Во всех этих примерах задаётся один и тот же адрес. Для цифр с a по f принимаются буквы и в
верхнем, и в нижнем регистре. Вывод всегда представляется в первом из показанных форматов.
Последние шесть входных форматов, показанных выше, не являются стандартизированными. Что-
бы преобразовать традиционный 48-битный MAC-адрес в формате EUI-48 в модифицированный
формат EUI-64 для включения в состав адреса IPv6 в качестве адреса узла, используйте функцию
macaddr8_set7bit:
SELECT macaddr8_set7bit(‘08:00:2b:01:02:03’);
macaddr8_set7bit
————————-
0a:00:2b:ff:fe:01:02:03
(1 row)
8.10. Битовые строки
Битовые строки представляют собой последовательности из 1 и 0. Их можно использовать для
хранения или отображения битовых масок. В SQL есть два битовых типа: bit(n) и bit varying(n),
где n — положительное целое число.
144Типы данных
Длина значения типа bit должна в точности равняться n; при попытке сохранить данные длиннее
или короче произойдёт ошибка. Данные типа bit varying могут иметь переменную длину, но не
превышающую n; строки большей длины не будут приняты. Запись bit без указания длины равно-
значна записи bit(1), тогда как bit varying без указания длины подразумевает строку неогра-
ниченной длины.
Примечание
При попытке привести значение битовой строки к типу bit(n), оно будет усечено или
дополнено нулями справа до длины ровно n бит, ошибки при этом не будет. Подобным
образом, если явно привести значение битовой строки к типу bit varying(n), она будет
усечена справа, если её длина превышает n бит.
Синтаксис констант битовых строк описан в Подразделе 4.1.2.5, а все доступные битовые опера-
торы и функции перечислены в Разделе 9.6.
Пример 8.3. Использование битовых строк
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B’101’, B’00’);
INSERT INTO test VALUES (B’10’, B’101’);
ОШИБКА:
длина битовой строки (2) не соответствует типу bit(3)
INSERT INTO test VALUES (B’10’::bit(3), B’101’);
SELECT * FROM test;
a | b
—–+—–
101 | 00
100 | 101
Для хранения битовой строки используется по 1 байту для каждой группы из 8 бит, плюс 5 или
8 байт дополнительно в зависимости от длины строки (но длинные строки могут быть сжаты или
вынесены отдельно, как описано в Разделе 8.3 применительно к символьным строкам).
8.11. Типы, предназначенные для текстового поиска
PostgreSQL предоставляет два типа данных для поддержки полнотекстового поиска. Текстовым
поиском называется операция анализа набора документов с текстом на естественном языке, в ре-
зультате которой находятся фрагменты, наиболее соответствующие запросу. Тип tsvector пред-
ставляет документ в виде, оптимизированном для текстового поиска, а tsquery представляет за-
прос текстового поиска в подобном виде. Более подробно это описывается в Главе 12, а все свя-
занные функции и операторы перечислены в Разделе 9.13.
8.11.1. tsvector
Значение типа tsvector содержит отсортированный список неповторяющихся лексем, т. е. слов,
нормализованных так, что все словоформы сводятся к одной (подробнее это описано в Главе 12).
Сортировка и исключение повторяющихся слов производится автоматически при вводе значения,
как показано в этом примере:
SELECT ‘a fat cat sat on a mat and ate a fat rat’::tsvector;
tsvector
—————————————————-
‘a’ ‘and’ ‘ate’ ‘cat’ ‘fat’ ‘mat’ ‘on’ ‘rat’ ‘sat’
Для представления в виде лексем пробелов или знаков препинания их нужно заключить в апо-
строфы:
145Типы данных
SELECT &lt;script type=&quot;math/tex&quot;&gt;the lexeme '
' contains spaces&lt;/script&gt;::tsvector;
tsvector
——————————————-
‘
‘ ‘contains’ ‘lexeme’ ‘spaces’ ‘the’
(В данном и следующих примерах мы используем строку в долларах, чтобы не дублировать все
апострофы в таких строках.) При этом включаемый апостроф или обратную косую черту нужно
продублировать:
SELECT &lt;script type=&quot;math/tex&quot;&gt;the lexeme 'Joe''s' contains a quote&lt;/script&gt;::tsvector;
tsvector
————————————————
‘Joe’’s’ ‘a’ ‘contains’ ‘lexeme’ ‘quote’ ‘the’
Также для лексем можно указать их целочисленные позиции:
SELECT ‘a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11
rat:12’::tsvector;
tsvector
—————————————————————————
‘a’:1,6,10 ‘and’:8 ‘ate’:9 ‘cat’:3 ‘fat’:2,11 ‘mat’:7 ‘on’:5 ‘rat’:12
‘sat’:4
Позиция обычно указывает положение исходного слова в документе. Информация о расположе-
нии слов затем может использоваться для оценки близости. Позиция может задаваться числом
от 1 до 16383; большие значения просто заменяются на 16383. Если для одной лексемы дважды
указывается одно положение, такое повторение отбрасывается.
Лексемам, для которых заданы позиции, также можно назначить вес, выраженный буквами A, B,
C или D. Вес D подразумевается по умолчанию и поэтому он не показывается при выводе:
SELECT ‘a:1A fat:2B,4C cat:5D’::tsvector;
tsvector
—————————-
‘a’:1A ‘cat’:5 ‘fat’:2B,4C
Веса обычно применяются для отражения структуры документа, например для придания особого
значения словам в заголовке по сравнению со словами в обычном тексте. Назначенным весам
можно сопоставить числовые приоритеты в функциях ранжирования результатов.
Важно понимать, что тип tsvector сам по себе не выполняет нормализацию слов; предполагается,
что в сохраняемом значении слова уже нормализованы приложением. Например:
SELECT ‘The Fat Rats’::tsvector;
tsvector
——————–
‘Fat’ ‘Rats’ ‘The’
Для большинства англоязычных приложений приведённые выше слова будут считаться ненорма-
лизованными, но для tsvector это не важно. Поэтому исходный документ обычно следует обрабо-
тать функцией to_tsvector, нормализующей слова для поиска:
SELECT to_tsvector(‘english’, ‘The Fat Rats’);
to_tsvector
—————–
‘fat’:2 ‘rat’:3
И это подробнее описано в Главе 12.
8.11.2. tsquery
Значение tsquery содержит искомые лексемы, объединяемые логическими операторами &amp;amp; (И), |
(ИЛИ) и ! (НЕ), а также оператором поиска фраз &amp;lt;-&amp;gt; (ПРЕДШЕСТВУЕТ). Также допускается вари-
146Типы данных
ация оператора ПРЕДШЕСТВУЕТ вида &lt;N&gt;, где N — целочисленная константа, задающая расстоя-
ние между двумя искомыми лексемами. Запись оператора &amp;lt;-&amp;gt; равнозначна &amp;lt;1&amp;gt;.
Для группировки операторов могут использоваться скобки. Без скобок эти операторы имеют раз-
ные приоритеты, в порядке убывания: ! (НЕ), &amp;lt;-&amp;gt; (ПРЕДШЕСТВУЕТ), &amp;amp; (И) и | (ИЛИ).
Несколько примеров:
SELECT 'fat &amp;amp; rat'::tsquery;
tsquery
---------------
'fat' &amp;amp; 'rat'
SELECT 'fat &amp;amp; (rat | cat)'::tsquery;
tsquery
---------------------------
'fat' &amp;amp; ( 'rat' | 'cat' )
SELECT 'fat &amp;amp; rat &amp;amp; ! cat'::tsquery;
tsquery
------------------------
'fat' &amp;amp; 'rat' &amp;amp; !'cat'
Лексемам в tsquery можно дополнительно сопоставить буквы весов, при этом они будут соответ-
ствовать только тем лексемам в tsvector, которые имеют какой-либо из этих весов:
SELECT 'fat:ab &amp;amp; cat'::tsquery;
tsquery
------------------
'fat':AB &amp;amp; 'cat'
Кроме того, в лексемах tsquery можно использовать знак * для поиска по префиксу:
SELECT 'super:*'::tsquery;
tsquery
-----------
'super':*
Этот запрос найдёт все слова в tsvector, начинающиеся с приставки «super».
Апострофы в лексемах этого типа можно использовать так же, как и в лексемах в tsvector; и так
же, как и для типа tsvector, необходимая нормализация слова должна выполняться до приведения
значения к типу tsquery. Для такой нормализации удобно использовать функцию to_tsquery:
SELECT to_tsquery('Fat:ab &amp;amp; Cats');
to_tsquery
------------------
'fat':AB &amp;amp; 'cat'
Заметьте, что функция to_tsquery будет обрабатывать префиксы подобно другим словам, поэтому
следующее сравнение возвращает true:
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
?column?
----------
t
так как postgres преобразуется стеммером в postgr:
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
to_tsvector | to_tsquery
---------------+------------
147Типы данных
'postgradu':1 | 'postgr':*
и эта приставка находится в преобразованной форме слова postgraduate.
8.12. Тип UUID
Тип данных uuid сохраняет универсальные уникальные идентификаторы (Universally Unique
Identifiers, UUID), определённые в RFC 4122, ISO/IEC 9834-8:2005 и связанных стандартах. (В неко-
торых системах это называется GUID, глобальным уникальным идентификатором.) Этот иденти-
фикатор представляет собой 128-битное значение, генерируемое специальным алгоритмом, прак-
тически гарантирующим, что этим же алгоритмом оно не будет получено больше нигде в мире.
Таким образом, эти идентификаторы будут уникальными и в распределённых системах, а не толь-
ко в единственной базе данных, как значения генераторов последовательностей.
UUID записывается в виде последовательности шестнадцатеричных цифр в нижнем регистре, раз-
делённых знаками минуса на несколько групп, в таком порядке: группа из 8 цифр, за ней три груп-
пы из 4 цифр и, наконец, группа из 12 цифр, что в сумме составляет 32 цифры и представляет 128
бит. Пример UUID в этом стандартном виде:
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
PostgreSQL также принимает альтернативные варианты: цифры в верхнем регистре, стандартную
запись, заключённую в фигурные скобки, запись без минусов или с минусами, разделяющими лю-
бые группы из четырёх цифр. Например:
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
(a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11)
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
(a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11)
Выводится значение этого типа всегда в стандартном виде.
В PostgreSQL встроены функции хранения и сравнения идентификаторов UUID, но нет внутренней
функции генерирования UUID, потому что не существует какого-то единственного алгоритма, под-
ходящего для всех приложений. Сгенерировать UUID можно с помощью дополнительного модуля
uuid-ossp, в котором реализованы несколько стандартных алгоритмов, а можно воспользоваться
модулем pgcrypto, где тоже есть функция генерирования случайных UUID. Кроме того, можно сде-
лать это в клиентском приложении или в другой библиотеке, подключённой на стороне сервера.
8.13. Тип XML
Тип xml предназначен для хранения XML-данных. Его преимущество по сравнению с обычным ти-
пом text в том, что он проверяет вводимые значения на допустимость по правилам XML и для
работы с ним есть типобезопасные функции; см. Раздел 9.14. Для использования этого типа дис-
трибутив должен быть скомпилирован в конфигурации configure --with-libxml.
Тип xml может сохранять правильно оформленные «документы», в соответствии со стандартом
XML, а также фрагменты «содержимого», описанные как содержимое элементов в стандарте XML.
Другими словами, это означает, что фрагменты содержимого могут содержать несколько элемен-
тов верхнего уровня или текстовых узлов. Определить, является ли определённое значение ти-
па xml полным документом или фрагментом содержимого, позволяет выражение xmlvalue IS
DOCUMENT.
8.13.1. Создание XML-значений
Чтобы получить значение типа xml из текстовой строки, используйте функцию xmlparse:
XMLPARSE ( ( DOCUMENT | CONTENT ) value)
Примеры:
148Типы данных
XMLPARSE (DOCUMENT '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;book&gt;&lt;title&gt;Manual&lt;/title&gt;&lt;chapter&gt;...&amp;lt;/
chapter&amp;gt;&amp;lt;/book&amp;gt;')
XMLPARSE (CONTENT 'abc&lt;foo&gt;bar&lt;/foo&gt;&lt;bar&gt;foo&lt;/bar&gt;')
Хотя в стандарте SQL описан только один способ преобразования текстовых строк в XML-значения,
специфический синтаксис PostgreSQL:
xml '&lt;foo&gt;bar&lt;/foo&gt;'
'&lt;foo&gt;bar&lt;/foo&gt;'::xml
тоже допустим.
Тип xml не проверяет вводимые значения по схеме DTD (Document Type Declaration, Объявления
типа документа),даже если в них присутствуют ссылка на DTD. В настоящее время в PostgreSQL
также нет встроенной поддержки других разновидностей схем, например XML Schema.
Обратная операция, получение текстовой строки из xml, выполняется с помощью функции
xmlserialize:
XMLSERIALIZE ( ( DOCUMENT | CONTENT ) значение AS тип )
Здесь допустимый тип — character, character varying или text (или их псевдонимы). И в данном
случае стандарт SQL предусматривает только один способ преобразования xml в тип текстовых
строк, но PostgreSQL позволяет просто привести значение к нужному типу.
При преобразовании текстовой строки в тип xml или наоборот без использования функций
XMLPARSE и XMLSERIALIZE, выбор режима DOCUMENT или CONTENT определяется параметром конфи-
гурации сеанса «XML option», установить который можно следующей стандартной командой:
SET XML OPTION ( DOCUMENT | CONTENT );
или такой командой в духе PostgreSQL:
SET xmloption TO ( DOCUMENT | CONTENT );
По умолчанию этот параметр имеет значение CONTENT, так что допускаются все формы XML-дан-
ных.
Примечание
Когда параметр XML option имеет значение по умолчанию, текстовые строки нельзя
напрямую привести к типу xml, если они содержат объявление типа документа, так как
такие объявления не допускаются во фрагментах. Для выполнения преобразования в
таких случаях следует использовать XMLPARSE или изменить параметр XML option.
8.13.2. Обработка кодировки
Если на стороне сервера и клиента и в XML-данных используются разные кодировки символов, с
этим могут возникать проблемы. Когда запросы передаются на сервер, а их результаты возвраща-
ются клиенту в обычном текстовом режиме, PostgreSQL преобразует все передаваемые текстовые
данные в кодировку для соответствующей стороны; см. Раздел 23.3. В том числе это происходит
и со строковыми представлениями XML-данных, подобными тем, что показаны в предыдущих при-
мерах. Обычно это означает, что объявления кодировки, содержащиеся в XML-данных, могут не
соответствовать действительности, когда текстовая строка преобразуется из одной кодировки в
другую при передаче данных между клиентом и сервером, так как подобные включённые в дан-
ные объявления не будут изменены автоматически. Для решения этой проблемы объявления ко-
дировки, содержащиеся в текстовых строках, вводимых в тип xml, просто игнорируются и пред-
полагается, что XML-содержимое представлено в текущей кодировке сервера. Как следствие, для
правильной обработки таких строк с XML-данными клиент должен передавать их в своей текущей
кодировке. Для сервера не важно, будет ли клиент для этого преобразовывать документы в свою
кодировку, или изменит её, прежде чем передавать ему данные. При выводе значения типа xml
149Типы данных
не содержат объявления кодировки, а клиент должен предполагать, что все данные поступают в
его текущей кодировке.
Если параметры запроса передаются на сервер и он возвращает результаты клиенту в двоичном
режиме, кодировка символов не преобразуется, так что возникает другая ситуация. В этом случае
объявление кодировки в XML принимается во внимание, а если его нет, то предполагается, что
данные закодированы в UTF-8 (это соответствует стандарту XML; заметьте, что PostgreSQL не под-
держивает UTF-16). При выводе в данные будет добавлено объявление кодировки, выбранной на
стороне клиента (но если это UTF-8, объявление будет опущено).
Само собой, XML-данные в PostgreSQL будут обрабатываться гораздо эффективнее, когда и в XML-
данных, и на стороне клиента, и на стороне сервера используется одна кодировка. Так как внут-
ри XML-данные представляются в UTF-8, оптимальный вариант, когда на сервере также выбрана
кодировка UTF-8.
Внимание
Некоторые XML-функции могут вовсе не работать с данными не-ASCII, если кодиров-
ка сервера не UTF-8. В частности, это известная особенность функций xmltable() и
xpath().
8.13.3. Обращение к XML-значениям
Тип xml отличается от других тем, что для него не определены никакие операторы сравнения, так
как чётко определённого и универсального алгоритма сравнения XML-данных не существует. Од-
но из следствий этого — нельзя отфильтровать строки таблицы, сравнив столбец xml с искомым
значением. Поэтому обычно XML-значения должны дополняться отдельным ключевым полем, на-
пример ID. Можно также сравнивать XML-значения, преобразовав их сначала в текстовые строки,
но заметьте, что с учётом специфики XML-данных этот метод практически бесполезен.
Из-за отсутствия операторов сравнения для типа xml, для столбца этого типа также нельзя создать
индекс. Поэтому, когда требуется быстрый поиск в XML данных, обойти это ограничение можно,
приведя данные к типу текстовой строки и проиндексировав эти строки, либо проиндексировав
выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск выполнялся по
индексированному выражению.
Для ускорения поиска в XML-данных также можно использовать функции полнотекстового поиска
в PostgreSQL. Однако это требует определённой подготовки данных, что дистрибутив PostgreSQL
пока не поддерживает.
8.14. Типы JSON
Типы JSON предназначены для хранения данных JSON (JavaScript Object Notation, Запись объекта
JavaScript) согласно стандарту RFC 7159. Такие данные можно хранить и в типе text, но типы JSON
лучше тем, что проверяют, соответствует ли вводимое значение формату JSON. Для работы с ними
есть также несколько специальных функций и операторов; см. Раздел 9.15.
Существуют два типа данных JSON: json и jsonb. Они принимают на вход почти одинаковые на-
боры значений, но основное их отличие в эффективности. Тип json сохраняет точную копию вве-
дённого текста, которую функции обработки должны разбирать заново при каждом выполнении,
тогда как данные jsonb сохраняются в разобранном двоичном формате, что несколько замедляет
ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора
текста. Кроме того, jsonb поддерживает индексацию, что тоже может быть очень полезно.
Так как тип json сохраняет точную копию введённого текста, он сохраняет семантически незна-
чащие пробелы между элементами, а также порядок ключей в JSON-объектах. И если JSON-объ-
ект внутри содержит повторяющиеся ключи, этот тип сохранит все пары ключ/значение. (Функ-
150Типы данных
ции обработки будут считать действительной последнюю пару.) Тип jsonb, напротив, не сохраняет
пробелы, порядок ключей и значения с дублирующимися ключами. Если во входных данных ока-
зываются дублирующиеся ключи, сохраняется только последнее значение.
Для большинства приложений предпочтительнее хранить данные JSON в типе jsonb (если нет
особых противопоказаний, например важны прежние предположения о порядке ключей объектов).
PostgreSQL позволяет использовать только одну кодировку символов в базе данных, поэтому дан-
ные JSON не будут полностью соответствовать спецификации, если кодировка базы данных не
UTF-8. При этом нельзя будет вставить символы, непредставимые в кодировке сервера, и наоборот,
допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8.
RFC 7159 разрешает включать в строки JSON спецпоследовательности Unicode в виде \uXXXX. В
функцию ввода для типа json эти спецпоследовательности допускаются вне зависимости от коди-
ровки базы данных, и проверяется только правильность их синтаксиса (за \u должны следовать
четыре шестнадцатеричных цифры). Однако, функция ввода для типа jsonb более строгая: она не
допускает спецпоследовательности Unicode для не-ASCII символов (символов после U+007F), если
кодировка базы данных не UTF8. Тип jsonb также не принимает \u0000 (так как это значение не
может быть представлено в типе text PostgreSQL), и требует, чтобы суррогатные пары Unicode
использовались для представления символов вне основной многоязыковой плоскости (BMP) пра-
вильно. Корректные спецпоследовательности Unicode преобразуются для хранения в соответству-
ющий символ ASCII или UTF8 (это подразумевает сворачивание суррогатных пар в один символ).
Примечание
Многие из функций обработки JSON, описанные в Разделе  9.15, преобразуют спец-
последовательности Unicode в обычные символы, поэтому могут выдавать подобные
ошибки, даже если им на вход поступает тип json, а не jsonb. То, что функция ввода в
тип json не производит этих проверок, можно считать историческим артефактом, хотя
это и позволяет просто сохранять (но не обрабатывать) в JSON спецкоды Unicode в базе
данных с кодировкой не UTF8. Вообще же, по возможности следует избегать смешения
спецкодов Unicode в JSON с кодировкой базой данных не UTF8.
При преобразовании вводимого текста JSON в тип jsonb, примитивные типы, описанные в RFC
7159, по сути отображаются в собственные типы PostgreSQL как показано в Таблице 8.23. Таким
образом, к содержимому типа jsonb предъявляются некоторые дополнительные требования, про-
диктованные ограничениями представления нижележащего типа данных, которые не распростра-
няются ни на тип json, ни на формат JSON вообще. В частности, тип jsonb не принимает числа,
выходящие за диапазон типа данных PostgreSQL numeric, тогда как с json такого ограничения
нет. Такие ограничения, накладываемые реализацией, допускаются согласно RFC 7159. Однако,
на практике такие проблемы более вероятны в других реализациях, так как обычно примитивный
тип JSON number представляется в виде числа с плавающей точкой двойной точности IEEE 754
(что RFC 7159 явно признаёт и допускает). При использовании JSON в качестве формата обмена
данными с такими системами следует учитывать риски потери точности чисел, хранившихся в
PostgreSQL.
И напротив, как показано в таблице, есть некоторые ограничения в формате ввода примитивных
типов JSON, не актуальные для соответствующих типов PostgreSQL.
Таблица 8.23. Примитивные типы JSON и соответствующие им типы PostgreSQL
Примитивный тип JSON Тип PostgreSQL Замечания
string text \u0000 не допускается, как не
ASCII символ, если кодировка
базы данных не UTF8
number numeric Значения NaN и infinity не до-
пускаются
151Типы данных
Примитивный тип JSON Тип PostgreSQL Замечания
boolean boolean Допускаются только варианты
true и false (в нижнем реги-
стре)
null (нет) NULL в SQL имеет другой смысл
8.14.1. Синтаксис вводимых и выводимых значений JSON
Синтаксис ввода/вывода типов данных JSON соответствует стандарту RFC 7159.
Примеры допустимых выражений с типом json (или jsonb):
-- Простое скалярное/примитивное значение
-- Простыми значениями могут быть числа, строки в кавычках, true, false или null
SELECT '5'::json;
-- Массив из нуля и более элементов (элементы могут быть разных типов)
SELECT '[1, 2, &quot;foo&quot;, null]'::json;
-- Объект, содержащий пары ключей и значений
-- Заметьте, что ключи объектов — это всегда строки в кавычках
SELECT '(&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;: false)'::json;
-- Массивы и объекты могут вкладываться произвольным образом
SELECT '(&quot;foo&quot;: [true, &quot;bar&quot;], &quot;tags&quot;: (&quot;a&quot;: 1, &quot;b&quot;: null))'::json;
Как было сказано ранее, когда значение JSON вводится и затем выводится без дополнительной
обработки, тип json выводит тот же текст, что поступил на вход, а jsonb не сохраняет семантиче-
ски незначащие детали, такие как пробелы. Например, посмотрите на эти различия:
SELECT '(&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;:false)'::json;
json
-------------------------------------------------
(&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;:false)
(1 row)
SELECT '(&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;:false)'::jsonb;
jsonb
--------------------------------------------------
(&quot;bar&quot;: &quot;baz&quot;, &quot;active&quot;: false, &quot;balance&quot;: 7.77)
(1 row)
Первая семантически незначимая деталь, заслуживающая внимания: с jsonb числа выводятся по
правилам нижележащего типа numeric. На практике это означает, что числа, заданные в записи
с E, будут выведены без неё, например:
SELECT '(&quot;reading&quot;: 1.230e-5)'::json, '(&quot;reading&quot;: 1.230e-5)'::jsonb;
json
|
jsonb
-----------------------+-------------------------
(&quot;reading&quot;: 1.230e-5) | (&quot;reading&quot;: 0.00001230)
(1 row)
Однако, как видно из этого примера, jsonb сохраняет конечные нули дробного числа, хотя они и
не имеют семантической значимости, в частности для проверки на равенство.
8.14.2. Эффективная организация документов JSON
Представлять данные в JSON можно гораздо более гибко, чем в традиционной реляционной моде-
ли данных, что очень привлекательно там, где нет жёстких условий. И оба этих подхода вполне
могут сосуществовать и дополнять друг друга в одном приложении. Однако, даже для приложений,
152Типы данных
которым нужна максимальная гибкость, рекомендуется, чтобы документы JSON имели некоторую
фиксированную структуру. Эта структура обычно не навязывается жёстко (хотя можно деклара-
тивно диктовать некоторые бизнес-правила), но когда она предсказуема, становится гораздо про-
ще писать запросы, которые извлекают полезные данные из набора «документов» (информации)
в таблице.
Данные JSON, как и данные любых других типов, хранящиеся в таблицах, находятся под контро-
лем механизма параллельного доступа. Хотя хранить большие документы вполне возможно, не
забывайте, что при любом изменении устанавливается блокировка всей строки (на уровне стро-
ки). Поэтому для оптимизации блокировок транзакций, изменяющих данные, стоит ограничить
размер документов JSON разумными пределами. В идеале каждый документ JSON должен собой
представлять атомарный информационный блок, который, согласно бизнес-логике, нельзя разде-
лить на меньшие, индивидуально изменяемые блоки.
8.14.3. Проверки на вхождение и существование jsonb
Проверка вхождения — важная особенность типа jsonb, не имеющая аналога для типа json. Эта
проверка определяет, входит ли один документ jsonb в другой. В следующих примерах возвраща-
ется истинное значение (кроме упомянутых исключений):
-- Простые скалярные/примитивные значения включают только одно идентичное значение:
SELECT '&quot;foo&quot;'::jsonb @&amp;gt; '&quot;foo&quot;'::jsonb;
-- Массив с правой стороны входит в массив слева:
SELECT '[1, 2, 3]'::jsonb @&amp;gt; '[1, 3]'::jsonb;
-- Порядок элементов в массиве не важен, поэтому это условие тоже выполняется:
SELECT '[1, 2, 3]'::jsonb @&amp;gt; '[3, 1]'::jsonb;
-- А повторяющиеся элементы массива не имеют значения:
SELECT '[1, 2, 3]'::jsonb @&amp;gt; '[1, 2, 2]'::jsonb;
-- Объект с одной парой справа входит в объект слева:
SELECT '(&quot;product&quot;: &quot;PostgreSQL&quot;, &quot;version&quot;: 9.4, &quot;jsonb&quot;: true)'::jsonb @&amp;gt;
'(&quot;version&quot;: 9.4)'::jsonb;
-- Массив справа не считается входящим в
-- массив слева, хотя в последний и вложен подобный массив:
SELECT '[1, 2, [1, 3]]'::jsonb @&amp;gt; '[1, 3]'::jsonb; -- выдаёт false
-- Но если добавить уровень вложенности, проверка на вхождение выполняется:
SELECT '[1, 2, [1, 3]]'::jsonb @&amp;gt; '[[1, 3]]'::jsonb;
-- Аналогично, это вхождением не считается:
SELECT '(&quot;foo&quot;: (&quot;bar&quot;: &quot;baz&quot;))'::jsonb @&amp;gt; '(&quot;bar&quot;: &quot;baz&quot;)'::jsonb;
-- выдаёт false
-- Ключ с пустым объектом на верхнем уровне входит в объект с таким ключом:
SELECT '(&quot;foo&quot;: (&quot;bar&quot;: &quot;baz&quot;))'::jsonb @&amp;gt; '(&quot;foo&quot;: ())'::jsonb;
Общий принцип этой проверки в том, что входящий объект должен соответствовать объекту, со-
держащему его, по структуре и данным, возможно, после исключения из содержащего объекта
лишних элементов массива или пар ключ/значение. Но помните, что порядок элементов массива
для проверки на вхождение не имеет значения, а повторяющиеся элементы массива считаются
только один раз.
В качестве особого исключения для требования идентичности структур, массив может содержать
примитивное значение:
-- В этот массив входит примитивное строковое значение:
SELECT '[&quot;foo&quot;, &quot;bar&quot;]'::jsonb @&amp;gt; '&quot;bar&quot;'::jsonb;
153Типы данных
-- Это исключение действует только в одну сторону -- здесь вхождения нет:
SELECT '&quot;bar&quot;'::jsonb @&amp;gt; '[&quot;bar&quot;]'::jsonb; -- выдаёт false
Для типа jsonb введён также оператор существования, который является вариацией на тему
вхождения: он проверяет, является ли строка (заданная в виде значения text) ключом объекта
или элементом массива на верхнем уровне значения jsonb. В следующих примерах возвращается
истинное значение (кроме упомянутых исключений):
-- Строка существует в качестве элемента массива:
SELECT '[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]'::jsonb ? 'bar';
-- Строка существует в качестве ключа объекта:
SELECT '(&quot;foo&quot;: &quot;bar&quot;)'::jsonb ? 'foo';
-- Значения объектов не рассматриваются:
SELECT '(&quot;foo&quot;: &quot;bar&quot;)'::jsonb ? 'bar'; -- выдаёт false
-- Как и вхождение, существование определяется на верхнем уровне:
SELECT '(&quot;foo&quot;: (&quot;bar&quot;: &quot;baz&quot;))'::jsonb ? 'bar'; -- выдаёт false
-- Строка считается существующей, если она соответствует примитивной строке JSON:
SELECT '&quot;foo&quot;'::jsonb ? 'foo';
Объекты JSON для проверок на существование и вхождение со множеством ключей или элементов
подходят больше, чем массивы, так как, в отличие от массивов, они внутри оптимизируются для
поиска, и поиск элемента не будет линейным.
Подсказка
Так как вхождение в JSON проверяется с учётом вложенности, правильно написан-
ный запрос может заменить явную выборку внутренних объектов. Например, предпо-
ложим, что у нас есть столбец doc, содержащий объекты на верхнем уровне, и боль-
шинство этих объектов содержит поля tags с массивами вложенных объектов. Данный
запрос найдёт записи, в которых вложенные объекты содержат ключи &quot;term&quot;:&quot;paris&quot;
и &quot;term&quot;:&quot;food&quot;, и при этом пропустит такие ключи, находящиеся вне массива tags:
SELECT doc-&amp;gt;'site_name' FROM websites
WHERE doc @&amp;gt; '(&quot;tags&quot;:[(&quot;term&quot;:&quot;paris&quot;), (&quot;term&quot;:&quot;food&quot;)])';
Этого же результата можно добиться, например, так:
SELECT doc-&amp;gt;'site_name' FROM websites
WHERE doc-&amp;gt;'tags' @&amp;gt; '[(&quot;term&quot;:&quot;paris&quot;), (&quot;term&quot;:&quot;food&quot;)]';
Но данный подход менее гибкий и часто также менее эффективный.
С другой стороны, оператор существования JSON не учитывает вложенность: он будет
искать заданный ключ или элемент массива только на верхнем уровне значения JSON.
Различные операторы вхождения и существования, а также все другие операторы и функции для
работы с JSON документированы в Разделе 9.15.
8.14.4. Индексация jsonb
Для эффективного поиска ключей или пар ключ/значение в большом количестве документов jsonb
можно успешно применять индексы GIN. Для этого предоставляются два «класса операторов» GIN,
предлагающие выбор между производительностью и гибкостью.
Класс операторов GIN по умолчанию для jsonb поддерживает запросы с операторами существо-
вания ключа на верхнем уровне (?, ?&amp;amp; и ?|) и оператором существования пути/значения (@&amp;gt;). (По-
154Типы данных
дробнее семантика, реализуемая этими операторами, описана в Таблице 9.44.) Пример создания
индекса с этим классом операторов:
CREATE INDEX idxgin ON api USING GIN (jdoc);
Дополнительный класс операторов GIN jsonb_path_ops поддерживает индексацию только для опе-
ратора @&amp;gt;. Пример создания индекса с этим классом операторов:
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
Рассмотрим пример таблицы, в которой хранятся документы JSON, получаемые от сторонней веб-
службы, с документированным определением схемы. Типичный документ:
(
&quot;guid&quot;: &quot;9c36adc1-7fb5-4d5b-83b4-90356a46061a&quot;,
&quot;name&quot;: &quot;Angela Barton&quot;,
&quot;is_active&quot;: true,
&quot;company&quot;: &quot;Magnafone&quot;,
&quot;address&quot;: &quot;178 Howard Place, Gulf, Washington, 702&quot;,
&quot;registered&quot;: &quot;2009-11-07T08:53:22 +08:00&quot;,
&quot;latitude&quot;: 19.793713,
&quot;longitude&quot;: 86.513373,
&quot;tags&quot;: [
&quot;enim&quot;,
&quot;aliquip&quot;,
&quot;qui&quot;
]
)
Мы сохраняем эти документы в таблице api, в столбце jdoc типа jsonb. Если по этому столбцу
создаётся GIN-индекс, он может применяться в подобных запросах:
-- Найти документы, в которых ключ &quot;company&quot; имеет значение &quot;Magnafone&quot;
SELECT jdoc-&amp;gt;'guid', jdoc-&amp;gt;'name' FROM api WHERE jdoc @&amp;gt; '(&quot;company&quot;: &quot;Magnafone&quot;)';
Однако, в следующих запросах он не будет использоваться, потому что, несмотря на то, что опера-
тор ? — индексируемый, он применяется не к индексированному столбцу jdoc непосредственно:
-- Найти документы, в которых ключ &quot;tags&quot; содержит ключ или элемент массива &quot;qui&quot;
SELECT jdoc-&amp;gt;'guid', jdoc-&amp;gt;'name' FROM api WHERE jdoc -&amp;gt; 'tags' ? 'qui';
И всё же, правильно применяя индексы выражений, в этом запросе можно задействовать индекс.
Если запрос определённых элементов в ключе &quot;tags&quot; выполняется часто, вероятно стоит опреде-
лить такой индекс:
CREATE INDEX idxgintags ON api USING GIN ((jdoc -&amp;gt; 'tags'));
Теперь предложение WHERE jdoc -&amp;gt; 'tags' ? 'qui' будет выполняться как применение индек-
сируемого оператора ? к индексируемому выражению jdoc -&amp;gt; 'tags'. (Подробнее об индексах
выражений можно узнать в Разделе 11.7.)
Ещё один подход к использованию проверок на существование:
-- Найти документы, в которых ключ &quot;tags&quot; содержит элемент массива &quot;qui&quot;
SELECT jdoc-&amp;gt;'guid', jdoc-&amp;gt;'name' FROM api WHERE jdoc @&amp;gt; '(&quot;tags&quot;: [&quot;qui&quot;])';
Этот запрос может задействовать простой GIN-индекс по столбцу jdoc. Но заметьте, что такой
индекс будет хранить копии всех ключей и значений в поле jdoc, тогда как индекс выражения из
предыдущего примера хранит только данные внутри объекта с ключом tags. Хотя подход с простым
индексом гораздо более гибкий (так как он поддерживает запросы по любому ключу), индексы
конкретных выражений скорее всего будут меньше и быстрее, чем простые индексы.
Класс операторов jsonb_path_ops поддерживает только запросы с оператором @&amp;gt;, но зато он зна-
чительно производительнее класса по умолчанию jsonb_ops. Индекс jsonb_path_ops обычно го-
раздо меньше индекса jsonb_ops для тех же данных и более точен при поиске, особенно, если
155Типы данных
запросы обращаются к ключам, часто встречающимся в данных. Таким образом, с ним операции
поиска выполняются гораздо лучше, чем с классом операторов по умолчанию.
Техническое различие между GIN-индексами jsonb_ops и jsonb_path_ops состоит в том, что для
первых создаются независимые элементы индекса для каждого ключа/значения в данных, тогда
1
как для вторых создаются элементы только для значений. По сути, каждый элемент индекса
jsonb_path_ops представляет собой хеш значения и ключа(ей), приводящего к нему; например,
при индексации (&quot;foo&quot;: (&quot;bar&quot;: &quot;baz&quot;)) будет создан один элемент индекса с хешем, рассчитан-
ным по всем трём значениям: foo, bar и baz. Таким образом, проверка на вхождение этой структу-
ры будет использовать крайне точный поиск по индексу, но определить, является ли foo ключом,
с помощью такого индекса нельзя. С другой стороны, индекс jsonb_ops создаст три отдельных
элемента индекса, представляющих foo, bar и baz по отдельности; для выполнения проверки на
вхождение будут проверены строки таблицы, содержащие все эти три значения. Хотя GIN-индексы
позволяют вычислить AND довольно эффективно, такой поиск всё же будет менее точным и более
медленным, чем равнозначный поиск с jsonb_path_ops, особенно если любое одно из этих трёх
значений содержится в большом количестве строк.
Недостаток класса jsonb_path_ops заключается в том, что он не учитывает в индексе структуры
JSON, не содержащие никаких значений (&quot;a&quot;: ()). Для поиска по документам, содержащих такие
структуры, потребуется выполнить полное сканирование индекса, что довольно долго, поэтому
jsonb_path_ops не очень подходит для приложений, часто выполняющих такие запросы.
Тип jsonb также поддерживает индексы btree и hash. Они полезны, только если требуется прове-
рять равенство JSON-документов в целом. Порядок сортировки btree для типа jsonb редко имеет
большое значение, но для полноты он приводится ниже:
Объект &amp;gt; Массив &amp;gt; Логическое значение &amp;gt; Число &amp;gt; Строка &amp;gt; Null
Объект с n парами &amp;gt; Объект с n - 1 парами
Массив с n элементами &amp;gt; Массив с n - 1 элементами
Объекты с равным количеством пар сравниваются в таком порядке:
ключ-1, значение-1, ключ-2 ...
Заметьте, что ключи объектов сравниваются согласно порядку при хранении; в частности, из-за
того, что короткие ключи хранятся перед длинными, результаты могут оказаться несколько не
интуитивными:
( &quot;aa&quot;: 1, &quot;c&quot;: 1) &amp;gt; (&quot;b&quot;: 1, &quot;d&quot;: 1)
Массивы с равным числом элементом упорядочиваются аналогично:
элемент-1, элемент-2 ...
Примитивные значения JSON сравниваются по тем же правилам сравнения, что и нижележащие
типы данных PostgreSQL. Строки сравниваются с учётом порядка сортировки по умолчанию в те-
кущей базе данных.
8.14.5. Трансформации
Для различных процедурных языков представлены дополнительные расширения, реализующие
трансформации для типа jsonb.
Расширения для PL/Perl называются jsonb_plperl и jsonb_plperlu. Когда они используются, зна-
чения jsonb отображаются в соответствующие структуры Perl: массивы, хеши или скаляры.
Расширения для PL/Python называются jsonb_plpythonu, jsonb_plpython2u и jsonb_plpython3u
(принятое в PL/Python соглашение об именовании описано в Разделе 46.1). Когда они используют-
1
Поэтому понятие «значение» включает и элементы массивов, хотя в терминологии JSON иногда элементы массивов считаются отличными от значений
внутри объектов.
156Типы данных
ся, значения jsonb отображаются в соответствующие структуры Python: массивы, хеши или ска-
ляры.
8.15. Массивы
PostgreSQL позволяет определять столбцы таблицы как многомерные массивы переменной длины.
Элементами массивов могут быть любые встроенные или определённые пользователями базовые
типы, перечисления, составные типы, типы-диапазоны или домены.
8.15.1. Объявления типов массивов
Чтобы проиллюстрировать использовать массивов, мы создадим такую таблицу:
CREATE TABLE sal_emp (
name
text,
pay_by_quarter integer[],
schedule
text[][]
);
Как показано, для объявления типа массива к названию типа элементов добавляются квадратные
скобки ([]). Показанная выше команда создаст таблицу sal_emp со столбцами типов text (name),
одномерный массив с элементами integer (pay_by_quarter), представляющий квартальную зар-
плату работников, и двухмерный массив с элементами text (schedule), представляющий недель-
ный график работника.
Команда CREATE TABLE позволяет также указать точный размер массивов, например так:
CREATE TABLE tictactoe (
squares
integer[3][3]
);
Однако текущая реализация игнорирует все указанные размеры, т. е. фактически размер массива
остаётся неопределённым.
Текущая реализация также не ограничивает число размерностей. Все элементы массивов счита-
ются одного типа, вне зависимости от его размера и числа размерностей. Поэтому явно указывать
число элементов или размерностей в команде CREATE TABLE имеет смысл только для документи-
рования, на механизм работы с массивом это не влияет.
Для объявления одномерных массивов можно применять альтернативную запись с ключевым сло-
вом ARRAY, соответствующую стандарту SQL. Столбец pay_by_quarter можно было бы определить
так:
pay_by_quarter
integer ARRAY[4],
Или без указания размера массива:
pay_by_quarter
integer ARRAY,
Заметьте, что и в этом случае PostgreSQL не накладывает ограничения на фактический размер
массива.
8.15.2. Ввод значения массива
Чтобы записать значение массива в виде буквальной константы, заключите значения элементов
в фигурные скобки и разделите их запятыми. (Если вам знаком C, вы найдёте, что это похоже на
синтаксис инициализации структур в C.) Вы можете заключить значение любого элемента в двой-
ные кавычки, а если он содержит запятые или фигурные скобки, это обязательно нужно сделать.
(Подробнее это описано ниже.) Таким образом, общий формат константы массива выглядит так:
'( значение1 разделитель значение2 разделитель ... )'
где разделитель — символ, указанный в качестве разделителя в соответствующей записи в таблице
pg_type. Для стандартных типов данных, существующих в дистрибутиве PostgreSQL, разделителем
является запятая (,), за исключением лишь типа box, в котором разделитель —точка с запятой
157Типы данных
(;). Каждое значение здесь — это либо константа типа элемента массива, либо вложенный массив.
Например, константа массива может быть такой:
'((1,2,3),(4,5,6),(7,8,9))'
Эта константа определяет двухмерный массив 3x3, состоящий из трёх вложенных массивов целых
чисел.
Чтобы присвоить элементу массива значение NULL, достаточно просто написать NULL (регистр
символов при этом не имеет значения). Если же требуется добавить в массив строку, содержащую
«NULL», это слово нужно заключить в двойные кавычки.
(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай
констант, описанных в Подразделе  4.1.2.7. Константа изначально воспринимается как строка и
передаётся процедуре преобразования вводимого массива. При этом может потребоваться явно
указать целевой тип.)
Теперь мы можем показать несколько операторов INSERT:
INSERT INTO sal_emp
VALUES ('Bill',
'(10000, 10000, 10000, 10000)',
'((&quot;meeting&quot;, &quot;lunch&quot;), (&quot;training&quot;, &quot;presentation&quot;))');
INSERT INTO sal_emp
VALUES ('Carol',
'(20000, 25000, 25000, 25000)',
'((&quot;breakfast&quot;, &quot;consulting&quot;), (&quot;meeting&quot;, &quot;lunch&quot;))');
Результат двух предыдущих команд:
SELECT * FROM sal_emp;
name |
pay_by_quarter
|
schedule
-----+-------------------------+--------------------------------------
Bill |(10000,10000,10000,10000)|((meeting,lunch),(training,presentation))
Carol|(20000,25000,25000,25000)|((breakfast,consulting),(meeting,lunch))
(2 rows)
В многомерных массивов число элементов в каждой размерности должно быть одинаковым; в про-
тивном случае возникает ошибка. Например:
INSERT INTO sal_emp
VALUES ('Bill',
'(10000, 10000, 10000, 10000)',
'((&quot;meeting&quot;, &quot;lunch&quot;), (&quot;meeting&quot;))');
ОШИБКА: для многомерных массивов должны задаваться выражения
с соответствующими размерностями
Также можно использовать синтаксис конструктора ARRAY:
INSERT INTO sal_emp
VALUES ('Bill',
ARRAY[10000, 10000, 10000, 10000],
ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);
INSERT INTO sal_emp
VALUES ('Carol',
ARRAY[20000, 25000, 25000, 25000],
ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
Заметьте, что элементы массива здесь — это простые SQL-константы или выражения; и поэтому,
например строки будут заключаться в одинарные апострофы, а не в двойные, как в буквальной
константе массива. Более подробно конструктор ARRAY обсуждается в Подразделе 4.2.12.
158Типы данных
8.15.3. Обращение к массивам
Добавив данные в таблицу, мы можем перейти к выборкам. Сначала мы покажем, как получить
один элемент массива. Этот запрос получает имена сотрудников, зарплата которых изменилась
во втором квартале:
SELECT name FROM sal_emp WHERE pay_by_quarter[1] &amp;lt;&amp;gt; pay_by_quarter[2];
name
-------
Carol
(1 row)
Индексы элементов массива записываются в квадратных скобках. По умолчанию в PostgreSQL дей-
ствует соглашение о нумерации элементов массива с 1, то есть в массиве из n элементов первым
считается array[1], а последним — array[n].
Этот запрос выдаёт зарплату всех сотрудников в третьем квартале:
SELECT pay_by_quarter[3] FROM sal_emp;
pay_by_quarter
----------------
10000
25000
(2 rows)
Мы также можем получать обычные прямоугольные срезы массива, то есть подмассивы. Срез мас-
сива обозначается как нижняя-граница:верхняя-граница для одной или нескольких размерностей.
Например, этот запрос получает первые пункты в графике Билла в первые два дня недели:
SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';
schedule
------------------------
((meeting),(training))
(1 row)
Если одна из размерностей записана в виде среза, то есть содержит двоеточие, тогда срез распро-
страняется на все размерности. Если при этом для размерности указывается только одно число
(без двоеточия), в срез войдут элемент от 1 до заданного номера. Например, в этом примере [2]
будет равнозначно [1:2]:
SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';
schedule
-------------------------------------------
((meeting,lunch),(training,presentation))
(1 row)
Во избежание путаницы с обращением к одному элементу, срезы лучше всегда записывать явно
для всех измерений, например [1:2][1:1] вместо [2][1:1].
Значения нижняя-граница и/или верхняя-граница в указании среза можно опустить; опущенная
граница заменяется нижним или верхним пределом индексов массива. Например:
SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';
schedule
------------------------
((lunch),(presentation))
(1 row)
159Типы данных
SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';
schedule
------------------------
((meeting),(training))
(1 row)
Выражение обращения к элементу массива возвратит NULL, если сам массив или одно из выраже-
ний индексов элемента равны NULL. Значение NULL также возвращается, если индекс выходит за
границы массива (это не считается ошибкой). Например, если schedule в настоящее время имеет
размерности [1:3][1:2], результатом обращения к schedule[3][3] будет NULL. Подобным обра-
зом, при обращении к элементу массива с неправильным числом индексов возвращается NULL,
а не ошибка.
Аналогично, NULL возвращается при обращении к срезу массива, если сам массив или одно из
выражений, определяющих индексы элементов, равны NULL. Однако, в других случаях, например,
когда границы среза выходят за рамки массива, возвращается не NULL, а пустой массив (с раз-
мерностью 0). (Так сложилось исторически, что в этом срезы отличаются от обращений к обычным
элементам.) Если запрошенный срез пересекает границы массива, тогда возвращается не NULL,
а срез, сокращённый до области пересечения.
Текущие размеры значения массива можно получить с помощью функции array_dims:
SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';
array_dims
------------
[1:2][1:2]
(1 row)
array_dims выдаёт результат типа text, что удобно скорее для людей, чем для программ. Размеры
массива также можно получить с помощью функций array_upper и array_lower, которые возвра-
щают соответственно верхнюю и нижнюю границу для указанной размерности:
SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';
array_upper
-------------
2
(1 row)
array_length возвращает число элементов в указанной размерности массива:
SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';
array_length
--------------
2
(1 row)
cardinality возвращает общее число элементов массива по всем измерениям. Фактически это
число строк, которое вернёт функция unnest:
SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';
cardinality
-------------
4
(1 row)
8.15.4. Изменение массивов
160Типы данных
Значение массива можно заменить полностью так:
UPDATE sal_emp SET pay_by_quarter = '(25000,25000,27000,27000)'
WHERE name = 'Carol';
или используя синтаксис ARRAY:
UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
WHERE name = 'Carol';
Также можно изменить один элемент массива:
UPDATE sal_emp SET pay_by_quarter[4] = 15000
WHERE name = 'Bill';
или срез:
UPDATE sal_emp SET pay_by_quarter[1:2] = '(27000,27000)'
WHERE name = 'Carol';
При этом в указании среза может быть опущена нижняя-граница и/или верхняя-граница, но только
для массива, отличного от NULL, и имеющего ненулевую размерность (иначе неизвестно, какие
граничные значения должны подставляться вместо опущенных).
Сохранённый массив можно расширить, определив значения ранее отсутствовавших в нём эле-
ментов. При этом все элементы, располагающиеся между существовавшими ранее и новыми, при-
нимают значения NULL. Например, если массив myarray содержит 4 элемента, после присвоения
значения элементу myarray[6] его длина будет равна 6, а myarray[5] будет содержать NULL. В
настоящее время подобное расширение поддерживается только для одномерных, но не многомер-
ных массивов.
Определяя элементы по индексам, можно создавать массивы, в которых нумерация элементов мо-
жет начинаться не с 1. Например, можно присвоить значение выражению myarray[-2:7] и таким
образом создать массив, в котором будут элементы с индексами от -2 до 7.
Значения массива также можно сконструировать с помощью оператора конкатенации, ||:
SELECT ARRAY[1,2] || ARRAY[3,4];
?column?
-----------
(1,2,3,4)
(1 row)
SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
?column?
---------------------
((5,6),(1,2),(3,4))
(1 row)
Оператор конкатенации позволяет вставить один элемент в начало или в конец одномерного мас-
сива. Он также может принять два N-мерных массива или массивы размерностей N и N+1.
Когда в начало или конец одномерного массива вставляется один элемент, в образованном в ре-
зультате массиве будет та же нижняя граница, что и в массиве-операнде. Например:
SELECT array_dims(1 || '[0:1]=(2,3)'::int[]);
array_dims
------------
[0:2]
(1 row)
SELECT array_dims(ARRAY[1,2] || 3);
array_dims
161Типы данных
------------
[1:3]
(1 row)
Когда складываются два массива одинаковых размерностей, в результате сохраняется нижняя гра-
ница внешней размерности левого операнда. Выходной массив включает все элементы левого опе-
ранда, после которых добавляются все элементы правого. Например:
SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
array_dims
------------
[1:5]
(1 row)
SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
array_dims
------------
[1:5][1:2]
(1 row)
Когда к массиву размерности N+1 спереди или сзади добавляется N-мерный массив, он вставляется
аналогично тому, как в массив вставляется элемент (это было описано выше). Любой N-мерный
массив по сути является элементом во внешней размерности массива, имеющего размерность N
+1. Например:
SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
array_dims
------------
[1:3][1:2]
(1 row)
Массив также можно сконструировать с помощью функций array_prepend, array_append и
array_cat. Первые две функции поддерживают только одномерные массивы, а array_cat поддер-
живает и многомерные. Несколько примеров:
SELECT array_prepend(1, ARRAY[2,3]);
array_prepend
---------------
(1,2,3)
(1 row)
SELECT array_append(ARRAY[1,2], 3);
array_append
--------------
(1,2,3)
(1 row)
SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
array_cat
-----------
(1,2,3,4)
(1 row)
SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
array_cat
---------------------
((1,2),(3,4),(5,6))
(1 row)
SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
162Типы данных
array_cat
---------------------
((5,6),(1,2),(3,4))
В простых случаях описанный выше оператор конкатенации предпочтительнее непосредственного
вызова этих функций. Однако, так как оператор конкатенации перегружен для решения всех трёх
задач, возможны ситуации, когда лучше применить одну из этих функций во избежание неодно-
значности. Например, рассмотрите:
SELECT ARRAY[1, 2] || '(3, 4)';
?column?
-----------
(1,2,3,4)
-- нетипизированная строка воспринимается как массив
SELECT ARRAY[1, 2] || '7';
ERROR: malformed array literal: &quot;7&quot; -- как и эта
SELECT ARRAY[1, 2] || NULL;
?column?
----------
(1,2)
(1 row) -- как и буквальный NULL
SELECT array_append(ARRAY[1, 2], NULL);
array_append
--------------
(1,2,NULL) -- это могло иметься в виду на самом деле
В показанных примерах анализатор запроса видит целочисленный массив с одной стороны опера-
тора конкатенации и константу неопределённого типа с другой. Согласно своим правилам разре-
шения типа констант, он полагает, что она имеет тот же тип, что и другой операнд — в данном
случае, целочисленный массив. Поэтому предполагается, что оператор конкатенации здесь пред-
ставляет функцию array_cat, а не array_append. Если это решение оказывается неверным, его
можно скорректировать, приведя константу к типу элемента массива; однако может быть лучше
явно использовать функцию array_append.
8.15.5. Поиск значений в массивах
Чтобы найти значение в массиве, необходимо проверить все его элементы. Это можно сделать
вручную, если вы знаете размер массива. Например:
SELECT * FROM sal_emp WHERE pay_by_quarter[1]
pay_by_quarter[2]
pay_by_quarter[3]
pay_by_quarter[4]
=
=
=
=
10000 OR
10000 OR
10000 OR
10000;
Однако с большим массивами этот метод становится утомительным, и к тому же он не работает,
когда размер массива неизвестен. Альтернативный подход описан в Разделе  9.23. Показанный
выше запрос можно было переписать так:
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
А так можно найти в таблице строки, в которых массивы содержат только значения, равные 10000:
SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
Кроме того, для обращения к
generate_subscripts. Например так:
элементам
массива
SELECT * FROM
(SELECT pay_by_quarter,
generate_subscripts(pay_by_quarter, 1) AS s
163
можно
использовать
функциюТипы данных
FROM sal_emp) AS foo
WHERE pay_by_quarter[s] = 10000;
Эта функция описана в Таблице 9.59.
Также искать в массиве значения можно, используя оператор &amp;amp;&amp;amp;, который проверяет, перекрыва-
ется ли левый операнд с правым. Например:
SELECT * FROM sal_emp WHERE pay_by_quarter &amp;amp;&amp;amp; ARRAY[10000];
Этот и другие операторы для работы с массивами описаны в Разделе 9.18. Он может быть ускорен
с помощью подходящего индекса, как описано в Разделе 11.2.
Вы также можете искать определённые значения в массиве, используя функции array_position
и array_positions. Первая функция возвращает позицию первого вхождения значения в массив,
а вторая — массив позиций всех его вхождений. Например:
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
array_positions
-----------------
2
SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
array_positions
-----------------
(1,4,8)
Подсказка
Массивы — это не множества; необходимость поиска определённых элементов в масси-
ве может быть признаком неудачно сконструированной базы данных. Возможно, вме-
сто массива лучше использовать отдельную таблицу, строки которой будут содержать
данные элементов массива. Это может быть лучше и для поиска, и для работы с боль-
шим количеством элементов.
8.15.6. Синтаксис вводимых и выводимых значений массива
Внешнее текстовое представление значения массива состоит из записи элементов, интерпрети-
руемых по правилам ввода/вывода для типа элемента массива, и оформления структуры массива.
Оформление состоит из фигурных скобок (( и )), окружающих значение массива, и знаков-разде-
лителей между его элементами. В качестве знака-разделителя обычно используется запятая (,),
но это может быть и другой символ; он определяется параметром typdelim для типа элемента мас-
сива. Для стандартных типов данных, существующих в дистрибутиве PostgreSQL, разделителем
является запятая (,), за исключением лишь типа box, в котором разделитель — точка с запятой
(;). В многомерном массиве у каждой размерности (ряд, плоскость, куб и т. д.) есть свой уровень
фигурных скобок, а соседние значения в фигурных скобках на одном уровне должны отделяться
разделителями.
Функция вывода массива заключает значение элемента в кавычки, если это пустая строка или
оно содержит фигурные скобки, знаки-разделители, кавычки, обратную косую черту, пробельный
символ или это текст NULL. Кавычки и обратная косая черта, включённые в такие значения, преоб-
разуются в спецпоследовательность с обратной косой чертой. Для числовых типов данных можно
рассчитывать на то, что значения никогда не будут выводиться в кавычках, но для текстовых типов
следует быть готовым к тому, что выводимое значение массива может содержать кавычки.
По умолчанию нижняя граница всех размерностей массива равна одному. Чтобы представить мас-
сивы с другими нижними границами, перед содержимым массива можно указать диапазоны ин-
дексов. Такое оформление массива будет содержать квадратные скобки ([]) вокруг нижней и верх-
164Типы данных
ней границ каждой размерности с двоеточием (:) между ними. За таким указанием размерности
следует знак равно (=). Например:
SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
FROM (SELECT '[1:1][-2:-1][3:5]=(((1,2,3),(4,5,6)))'::int[] AS f1) AS ss;
e1 | e2
----+----
1 | 6
(1 row)
Процедура вывода массива включает в результат явное указание размерностей, только если ниж-
няя граница в одной или нескольких размерностях отличается от 1.
Если в качестве значения элемента задаётся NULL (в любом регистре), этот элемент считается рав-
ным непосредственно NULL. Если же оно включает кавычки или обратную косую черту, элемен-
ту присваивается текстовая строка «NULL». Кроме того, для обратной совместимости с версиями
PostgreSQL до 8.2, параметр конфигурации array_nulls можно выключить (присвоив ему off), что-
бы строки NULL не воспринимались как значения NULL.
Как было показано ранее, записывая значение массива, любой его элемент можно заключить в
кавычки. Это нужно делать, если при разборе значения массива без кавычек возможна неодно-
значность. Например, в кавычки необходимо заключать элементы, содержащие фигурные скобки,
запятую (или разделитель, определённый для данного типа), кавычки, обратную косую черту, а
также пробельные символы в начале или конце строки. Пустые строки и строки, содержащие од-
но слово NULL, также нужно заключать в кавычки. Чтобы включить кавычки или обратную косую
черту в значение, заключённое в кавычки, добавьте обратную косую черту перед таким символом.
С другой стороны, чтобы обойтись без кавычек, таким экранированием можно защитить все сим-
волы в данных, которые могут быть восприняты как часть синтаксиса массива.
Перед открывающей и после закрывающей скобки можно добавлять пробельные символы. Пробе-
лы также могут окружать каждую отдельную строку значения. Во всех случаях такие пробельные
символы игнорируются. Однако все пробелы в строках, заключённых в кавычки, или окружённые
не пробельными символами, напротив, учитываются.
Подсказка
Записывать значения массивов в командах SQL часто бывает удобнее с помощью кон-
структора ARRAY (см. Подраздел 4.2.12). В ARRAY отдельные значения элементов запи-
сываются так же, как если бы они не были членами массива.
8.16. Составные типы
Составной тип представляет структуру табличной строки или записи; по сути это просто список
имён полей и соответствующих типов данных. PostgreSQL позволяет использовать составные типы
во многом так же, как и простые типы. Например, в определении таблицы можно объявить столбец
составного типа.
8.16.1. Объявление составных типов
Ниже приведены два простых примера определения составных типов:
CREATE TYPE complex AS (
r
double precision,
i
double precision
);
CREATE TYPE inventory_item AS (
name
text,
165Типы данных
supplier_id
price
integer,
numeric
);
Синтаксис очень похож на CREATE TABLE, за исключением того, что он допускает только названия
полей и их типы, какие-либо ограничения (такие как NOT NULL) в настоящее время не поддержи-
ваются. Заметьте, что ключевое слово AS здесь имеет значение; без него система будет считать,
что подразумевается другой тип команды CREATE TYPE, и выдаст неожиданную синтаксическую
ошибку.
Определив такие типы, мы можем использовать их в таблицах:
CREATE TABLE on_hand (
item
inventory_item,
count
integer
);
INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);
или функциях:
CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;
SELECT price_extension(item, 10) FROM on_hand;
Всякий раз, когда создаётся таблица, вместе с ней автоматически создаётся составной тип. Этот
тип представляет тип строки таблицы, и его именем становится имя таблицы. Например, при вы-
полнении команды:
CREATE TABLE inventory_item (
name
text,
supplier_id
integer REFERENCES suppliers,
price
numeric CHECK (price &amp;gt; 0)
);
в качестве побочного эффекта будет создан составной тип inventory_item, в точности соответ-
ствующий тому, что был показан выше, и использовать его можно так же. Однако заметьте, что
в текущей реализации есть один недостаток: так как с составным типом не могут быть связаны
ограничения, то описанные в определении таблицы ограничения не применяются к значениям
составного типа вне таблицы. (Чтобы обойти этот недостаток, создайте домен поверх составного
типа и добавьте желаемые ограничения в виде ограничений CHECK для данного домена.)
8.16.2. Конструирование составных значений
Чтобы записать значение составного типа в виде текстовой константы, его поля нужно заключить
в круглые скобки и разделить их запятыми. Значение любого поля можно заключить в кавычки,
а если оно содержит запятые или скобки, это делать обязательно. (Подробнее об этом говорится
ниже.) Таким образом, в общем виде константа составного типа записывается так:
'( значение1 , значение2 , ... )'
Например, эта запись:
'(&quot;fuzzy dice&quot;,42,1.99)'
будет допустимой для описанного выше типа inventory_item. Чтобы присвоить NULL одному из
полей, в соответствующем месте в списке нужно оставить пустое место. Например, эта константа
задаёт значение NULL для третьего поля:
'(&quot;fuzzy dice&quot;,42,)'
Если же вместо NULL требуется вставить пустую строку, нужно записать пару кавычек:
'(&quot;&quot;,42,)'
166Типы данных
Здесь в первом поле окажется пустая строка, а в третьем — NULL.
(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай
констант, описанных в Подразделе  4.1.2.7. Константа изначально воспринимается как строка и
передаётся процедуре преобразования составного типа. При этом может потребоваться явно ука-
зать тип, к которому будет приведена константа.)
Значения составных типов также можно конструировать, используя синтаксис выражения ROW. В
большинстве случаев это значительно проще, чем записывать значения в строке, так как при этом
не нужно беспокоиться о вложенности кавычек. Мы уже обсуждали этот метод ранее:
ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)
Ключевое слово ROW на самом деле может быть необязательным, если в выражении определяются
несколько полей, так что эту запись можно упростить до:
('fuzzy dice', 42, 1.99)
('', 42, NULL)
Синтаксис выражения ROW более подробно рассматривается в Подразделе 4.2.13.
8.16.3. Обращение к составным типам
Чтобы обратиться к полю столбца составного типа, после имени столбца нужно добавить точку и
имя поля, подобно тому, как указывается столбец после имени таблицы. На самом деле, эти обра-
щения неотличимы, так что часто бывает необходимо использовать скобки, чтобы команда была
разобрана правильно. Например, можно попытаться выбрать поле столбца из тестовой таблицы
on_hand таким образом:
SELECT item.name FROM on_hand WHERE item.price &amp;gt; 9.99;
Но это не будет работать, так как согласно правилам SQL имя item здесь воспринимается как имя
таблицы, а не столбца в таблице on_hand. Поэтому этот запрос нужно переписать так:
SELECT (item).name FROM on_hand WHERE (item).price &amp;gt; 9.99;
либо указать также и имя таблицы (например, в запросе с многими таблицами), примерно так:
SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &amp;gt; 9.99;
В результате объект в скобках будет правильно интерпретирован как ссылка на столбец item, из
которого выбирается поле.
При выборке поля из значения составного типа также возможны подобные синтаксические казу-
сы. Например, чтобы выбрать одно поле из результата функции, возвращающей составное значе-
ние, потребуется написать что-то подобное:
SELECT (my_func(...)).field FROM ...
Без дополнительных скобок в этом запросе произойдёт синтаксическая ошибка.
Специальное имя поля * означает «все поля»; подробнее об этом рассказывается в Подразде-
ле 8.16.5.
8.16.4. Изменение составных типов
Ниже приведены примеры правильных команд добавления и изменения значений составных столб-
цов. Первые команды иллюстрируют добавление или изменение всего столбца:
INSERT INTO mytab (complex_col) VALUES((1.1,2.2));
UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;
В первом примере опущено ключевое слово ROW, а во втором оно есть; присутствовать или отсут-
ствовать оно может в обоих случаях.
167Типы данных
Мы можем изменить также отдельное поле составного столбца:
UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;
Заметьте, что при этом не нужно (и на самом деле даже нельзя) заключать в скобки имя столбца,
следующее сразу за предложением SET, но в ссылке на тот же столбец в выражении, находящемся
по правую сторону знака равенства, скобки обязательны.
И мы также можем указать поля в качестве цели команды INSERT:
INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);
Если при этом мы не укажем значения для всех полей столбца, оставшиеся поля будут заполнены
значениями NULL.
8.16.5. Использование составных типов в запросах
С составными типами в запросах связаны особые правила синтаксиса и поведение. Эти правила
образуют полезные конструкции, но они могут быть неочевидными, если не понимать стоящую за
ними логику.
В PostgreSQL ссылка на имя таблицы (или её псевдоним) в запросе по сути является ссылкой на
составное значение текущей строки в этой таблице. Например, имея таблицу inventory_item, по-
казанную выше, мы можем написать:
SELECT c FROM inventory_item c;
Этот запрос выдаёт один столбец с составным значением, и его результат может быть таким:
c
------------------------
(&quot;fuzzy dice&quot;,42,1.99)
(1 row)
Заметьте, однако, что простые имена сопоставляются сначала с именами столбцов, и только потом
с именами таблиц, так что такой результат получается только потому, что в таблицах запроса не
оказалось столбца с именем c.
Обычную запись полного имени столбца вида имя_таблицы.имя_столбца можно понимать как при-
менение выбора поля к составному значению текущей строки таблицы. (Из соображений эффек-
тивности на самом деле это реализовано по-другому.)
Когда мы пишем
SELECT c.* FROM inventory_item c;
то, согласно стандарту SQL, мы должны получить содержимое таблицы, развёрнутое в отдельные
столбцы:
name
| supplier_id | price
------------+-------------+-------
fuzzy dice |
42 | 1.99
(1 row)
как с запросом
SELECT c.name, c.supplier_id, c.price FROM inventory_item c;
PostgreSQL применяет такое развёртывание для любых выражений с составными значениями, хо-
тя как показано выше, необходимо заключить в скобки значение, к которому применяется .*, если
только это не простое имя таблицы. Например, если myfunc() — функция, возвращающая состав-
ной тип со столбцами a, b и c, то эти два запроса выдадут одинаковый результат:
SELECT (myfunc(x)).* FROM some_table;
SELECT (myfunc(x)).a, (myfunc(x)).b, (myfunc(x)).c FROM some_table;
168Типы данных
Подсказка
PostgreSQL осуществляет развёртывание столбцов фактически переводя первую форму
во вторую. Таким образом, в данном примере myfunc() будет вызываться три раза для
каждой строки и с одним, и с другим синтаксисом. Если это дорогостоящая функция,
и вы хотите избежать лишних вызовов, можно использовать такой запрос:
SELECT m.* FROM some_table, LATERAL myfunc(x) AS m;
Размещение вызова функции в элементе FROM LATERAL гарантирует, что она будет вы-
зываться для строки не более одного раза. Конструкция m.* так же разворачивается
в m.a, m.b, m.c, но теперь эти переменные просто ссылаются на выходные значения
FROM. (Ключевое слово LATERAL здесь является необязательным, но мы добавили его,
чтобы подчеркнуть, что функция получает x из some_table.)
Запись составное_значение.* приводит к такому развёртыванию столбцов, когда она фигурирует
на верхнем уровне выходного списка SELECT, в списке RETURNING команд INSERT/UPDATE/DELETE, в
предложении VALUES или в конструкторе строки. Во всех других контекстах (включая вложенные
в одну из этих конструкций), добавление .* к составному значению не меняет это значение, так
как это воспринимается как «все столбцы» и поэтому выдаётся то же составное значение. Напри-
мер, если функция somefunc() принимает в качестве аргумента составное значение, эти запросы
равносильны:
SELECT somefunc(c.*) FROM inventory_item c;
SELECT somefunc(c) FROM inventory_item c;
В обоих случаях текущая строка таблицы inventory_item передаётся функции как один аргумент
с составным значением. И хотя дополнение .* в этих случаях не играет роли, использовать его
считается хорошим стилем, так как это ясно указывает на использование составного значения. В
частности анализатор запроса воспримет c в записи c.* как ссылку на имя или псевдоним таблицы,
а не имя столбца, что избавляет от неоднозначности; тогда как без .* неясно, означает ли c имя
таблицы или имя столбца, и на самом деле при наличии столбца с именем c будет выбрано второе
прочтение.
Эту концепцию демонстрирует и следующий пример, все запросы в котором действуют одинаково:
SELECT * FROM inventory_item c ORDER BY c;
SELECT * FROM inventory_item c ORDER BY c.*;
SELECT * FROM inventory_item c ORDER BY ROW(c.*);
Все эти предложения ORDER BY обращаются к составному значению строки, вследствие чего стро-
ки сортируются по правилам, описанным в Подразделе 9.23.6. Однако, если в inventory_item со-
держится столбец с именем c, первый запрос будет отличаться от других, так как в нём выполнит-
ся сортировка только по данному столбцу. С показанными выше именами столбцов предыдущим
запросам также равнозначны следующие:
SELECT * FROM inventory_item c ORDER BY ROW(c.name, c.supplier_id, c.price);
SELECT * FROM inventory_item c ORDER BY (c.name, c.supplier_id, c.price);
(В последнем случае используется конструктор строки, в котором опущено ключевое слово ROW.)
Другая особенность синтаксиса, связанная с составными значениями, состоит в том, что мы мо-
жем использовать функциональную запись для извлечения поля составного значения. Это легко
можно объяснить тем, что записи поле(таблица) и таблица.поле взаимозаменяемы. Например,
следующие запросы равнозначны:
SELECT c.name FROM inventory_item c WHERE c.price &amp;gt; 1000;
SELECT name(c) FROM inventory_item c WHERE price(c) &amp;gt; 1000;
Более того, если у нас есть функция, принимающая один аргумент составного типа, мы можем
вызвать её в любой записи. Все эти запросы равносильны:
SELECT somefunc(c) FROM inventory_item c;
169Типы данных
SELECT somefunc(c.*) FROM inventory_item c;
SELECT c.somefunc FROM inventory_item c;
Эта равнозначность записи с полем и функциональной записи позволяет использовать с составны-
ми типами функции, реализующие «вычисляемые поля». При этом приложению, использующему
последний из предыдущих запросов, не нужно знать, что фактически somefunc — не настоящий
столбец таблицы.
Подсказка
Учитывая такое поведение, будет неразумно давать функции, принимающей один ар-
гумент составного типа, то же имя, что и одному из полей данного составного типа. В
случае неоднозначности прочтение имени поля будет выбрано при использовании син-
таксиса обращения к полю, а прочтение имени функции — если используется синтак-
сис вызова функции. Однако в PostgreSQL до 11 версии всегда выбиралось прочтение
имени поля, если только синтаксис вызова не подталкивал к прочтению имени функ-
ции. Чтобы принудительно выбрать прочтение имени функции, в предыдущих версиях
надо было дополнить это имя схемой, то есть написать схема.функция(составное_зна-
чение).
8.16.6. Синтаксис вводимых и выводимых значений составного ти-
па
Внешнее текстовое представление составного значения состоит из записи элементов, интерпре-
тируемых по правилам ввода/вывода для соответствующих типов полей, и оформления структуры
составного типа. Оформление состоит из круглых скобок (( и )) окружающих всё значение, и за-
пятых (,) между его элементами. Пробельные символы вне скобок игнорируются, но внутри они
считаются частью соответствующего элемента и могут учитываться или не учитываться в зависи-
мости от правил преобразования вводимых данных для типа этого элемента. Например, в записи:
'(
42)'
пробелы будут игнорироваться, если соответствующее поле имеет целочисленный тип, но не тек-
стовый.
Как было показано ранее, записывая составное значение, любой его элемент можно заключить в
кавычки. Это нужно делать, если при разборе этого значения без кавычек возможна неоднознач-
ность. Например, в кавычки нужно заключать элементы, содержащие скобки, кавычки, запятую
или обратную косую черту. Чтобы включить в поле составного значения, заключённое в кавычки,
такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную ко-
сую черту. (Кроме того, продублированные кавычки в значении поля, заключённого в кавычки,
воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно
обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть
синтаксиса составного значения, с помощью спецпоследовательностей.
Значение NULL в этой записи представляется пустым местом (когда между запятыми или скобка-
ми нет никаких символов). Чтобы ввести именно пустую строку, а не NULL, нужно написать &quot;&quot;.
Функция вывода составного значения заключает значения полей в кавычки, если они представ-
ляют собой пустые строки, либо содержат скобки, запятые, кавычки или обратную косую черту,
либо состоят из одних пробелов. (В последнем случае можно обойтись без кавычек, но они добав-
ляются для удобочитаемости.) Кавычки и обратная косая черта, заключённые в значения полей,
при выводе дублируются.
Примечание
Помните, что написанная SQL-команда прежде всего интерпретируется как текстовая
строка, а затем как составное значение. Вследствие этого число символов обратной ко-
170Типы данных
сой черты удваивается (если используются спецпоследовательности). Например, что-
бы ввести в поле составного столбца значение типа text с обратной косой чертой и
кавычками, команду нужно будет записать так:
INSERT ... VALUES ('(&quot;\&quot;\\&quot;)');
Сначала обработчик спецпоследовательностей удаляет один уровень обратной косой
черты, так что анализатор составного значения получает на вход (&quot;\&quot;\\&quot;). В свою
очередь, он передаёт эту строку процедуре ввода значения типа text, где она преоб-
разуются в &quot;\. (Если бы мы работали с типом данных, процедура ввода которого также
интерпретирует обратную косую черту особым образом, например bytea, нам могло
бы понадобиться уже восемь таких символов, чтобы сохранить этот символ в поле со-
ставного значения.) Во избежание такого дублирования спецсимволов строки можно
заключать в доллары (см. Подраздел 4.1.2.4).
Подсказка
Записывать составные значения в командах SQL часто бывает удобнее с помощью кон-
структора ROW. В ROW отдельные значения элементов записываются так же, как если бы
они не были членами составного выражения.
8.17. Диапазонные типы
Диапазонные типы представляют диапазоны значений некоторого типа данных (он также называ-
ется подтипом диапазона). Например, диапазон типа timestamp может представлять временной
интервал, когда зарезервирован зал заседаний. В данном случае типом данных будет tsrange (со-
кращение от «timestamp range»), а подтипом — timestamp. Подтип должен быть полностью упоря-
дочиваемым, чтобы можно было однозначно определить, где находится значение по отношению
к диапазону: внутри, до или после него.
Диапазонные типы полезны тем, что позволяют представить множество возможных значений в
одной структуре данных и чётко выразить такие понятия, как пересечение диапазонов. Наиболее
очевидный вариант их использования — применять диапазоны даты и времени для составления
расписания, но также полезными могут оказаться диапазоны цен, интервалы измерений и т. д.
8.17.1. Встроенные диапазонные типы
PostgreSQL имеет следующие встроенные диапазонные типы:
• int4range — диапазон подтипа integer
• int8range — диапазон подтипа bigint
• numrange — диапазон подтипа numeric
• tsrange — диапазон подтипа timestamp without time zone
• tstzrange — диапазон подтипа timestamp with time zone
• daterange — диапазон подтипа date
Помимо этого, вы можете определять собственные типы; подробнее это описано в CREATE TYPE.
8.17.2. Примеры
CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
(1108, '[2010-01-01 14:30, 2010-01-01 15:30)');
-- Вхождение
171Типы данных
SELECT int4range(10, 20) @&amp;gt; 3;
-- Перекрытие
SELECT numrange(11.1, 22.2) &amp;amp;&amp;amp; numrange(20.0, 30.0);
-- Получение верхней границы
SELECT upper(int8range(15, 25));
-- Вычисление пересечения
SELECT int4range(10, 20) * int4range(15, 25);
-- Является ли диапазон пустым?
SELECT isempty(numrange(1, 5));
Полный список операторов и функций, предназначенных для диапазонных типов, приведён в Таб-
лице 9.50 и Таблице 9.51.
8.17.3. Включение и исключение границ
Любой непустой диапазон имеет две границы, верхнюю и нижнюю, и включает все точки между
этими значениями. В него также может входить точка, лежащая на границе, если диапазон вклю-
чает эту границу. И наоборот, если диапазон не включает границу, считается, что точка, лежащая
на этой границе, в него не входит.
В текстовой записи диапазона включение нижней границы обозначается символом «[», а исклю-
чением — символом «(». Для верхней границы включение обозначается аналогично, символом
«]», а исключение — символом «)». (Подробнее это описано в Подразделе 8.17.5.)
Для проверки, включается ли нижняя или верхняя граница в диапазон, предназначены функции
lower_inc и upper_inc, соответственно.
8.17.4. Неограниченные (бесконечные) диапазоны
Нижнюю границу диапазона можно опустить и определить тем самым диапазон, включающий все
точки, лежащие ниже верхней границы. Подобным образом, если не определить верхнюю грани-
цу, в диапазон войдут все точки, лежащие выше нижней границы. Если же опущена и нижняя, и
правая границы, такой диапазон будет включать все возможные значения своего подтипа.
Это равнозначно тому, что нижней границей будет считаться «минус бесконечность», а верхней —
«плюс бесконечность». Но заметьте, что эти бесконечные значения не являются значениями под-
типа диапазона и поэтому также не могут входить в диапазон. (Как следствие, нет такого понятия,
как включаемая нижняя бесконечная граница — если попытаться записать такой диапазон, она
будет автоматически преобразована в исключаемую.)
Кроме этого, в некоторых типах есть понятие «бесконечность», но в данном контексте оно счита-
ется просто одним из значений. Например, во временных диапазонах [today,] означает то же са-
мое, что и [today,). Но диапазон [today,infinity] отличается от [today,infinity) — в послед-
нем специальное значение infinity типа timestamp не входит в диапазон.
Проверить, определена ли верхняя или нижняя граница, можно с помощью функций lower_inf и
upper_inf, соответственно.
8.17.5. Ввод/вывод диапазонов
Вводимое значение диапазона должно записываться в одной из следующих форм:
(нижняя-граница,верхняя-граница)
(нижняя-граница,верхняя-граница]
[нижняя-граница,верхняя-граница)
[нижняя-граница,верхняя-граница]
empty
172Типы данных
Тип скобок (квадратные или круглые) определяет, включаются ли в диапазон соответствующие
границы, как описано выше. Заметьте, что последняя форма содержит только слово empty и опре-
деляет пустой диапазон (диапазон, не содержащий точек).
Здесь нижняя-граница может быть строкой с допустимым значением подтипа или быть пустой (то-
гда диапазон будет без нижней границы). Аналогично, верхняя-граница может задаваться одним
из значений подтипа или быть неопределённой (пустой).
Любое значение диапазона можно заключить в кавычки (&quot;). А если значение содержит круглые
или квадратные скобки, запятые, кавычки или обратную косую черту, использовать кавычки необ-
ходимо, чтобы эти символы не рассматривались как часть синтаксиса диапазона. Чтобы включить
в значение диапазона, заключённое в кавычки, такие символы, как кавычки или обратная косая
черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавыч-
ки в значении диапазона, заключённого в кавычки, воспринимаются как одинарные, подобно апо-
строфам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в
данных, которые могут быть восприняты как часть синтаксиса диапазона, с помощью спецпосле-
довательностей. Чтобы задать в качестве границы пустую строку, нужно ввести &quot;&quot;, так как пустая
строка без кавычек будет означать отсутствие границы.
Пробельные символы до и после определения диапазона игнорируются, но когда они присутствуют
внутри скобок, они воспринимаются как часть значения верхней или нижней границы. (Хотя они
могут также игнорироваться в зависимости от подтипа диапазона.)
Примечание
Эти правила очень похожи на правила записи значений для полей составных типов.
Дополнительные замечания приведены в Подразделе 8.16.6.
Примеры:
-- в диапазон включается 3, не включается 7 и включаются все точки между ними
SELECT '[3,7)'::int4range;
-- в диапазон не включаются 3 и 7, но включаются все точки между ними
SELECT '(3,7)'::int4range;
-- в диапазон включается только одно значение 4
SELECT '[4,4]'::int4range;
-- диапазон не включает никаких точек (нормализация заменит его определение
-- на 'empty')
SELECT '[4,4)'::int4range;
8.17.6. Конструирование диапазонов
Для каждого диапазонного типа определена функция конструктора, имеющая то же имя, что и
данный тип. Использовать этот конструктор обычно удобнее, чем записывать текстовую константу
диапазона, так как это избавляет от потребности в дополнительных кавычках. Функция конструк-
тора может принимать два или три параметра. Вариант с двумя параметрами создаёт диапазон
в стандартной форме (нижняя граница включается, верхняя исключается), тогда как для вариан-
та с тремя параметрами включение границ определяется третьим параметром. Третий параметр
должен содержать одну из строк: «()», «(]», «[)» или «[]». Например:
-- Полная форма: нижняя граница, верхняя граница и текстовая строка, определяющая
-- включение/исключение границ.
SELECT numrange(1.0, 14.0, '(]');
-- Если третий аргумент опущен, подразумевается '[)'.
SELECT numrange(1.0, 14.0);
173Типы данных
-- Хотя здесь указывается '(]', при выводе значение будет приведено к
-- каноническому виду, так как int8range — тип дискретного диапазона (см. ниже).
SELECT int8range(1, 14, '(]');
-- Когда вместо любой границы указывается NULL, соответствующей границы
-- у диапазона не будет.
SELECT numrange(NULL, 2.2);
8.17.7. Типы дискретных диапазонов
Дискретным диапазоном считается диапазон, для подтипа которого однозначно определён «шаг»,
как например для типов integer и date. Значения этих двух типов можно назвать соседними, ко-
гда между ними нет никаких других значений. В непрерывных диапазонах, напротив, всегда (или
почти всегда) можно найти ещё одно значение между двумя данными. Например, непрерывным
диапазоном будет диапазон с подтипами numeric и timestamp. (Хотя timestamp имеет ограничен-
ную точность, то есть теоретически он является дискретным, но всё же лучше считать его непре-
рывным, так как шаг его обычно не определён.)
Можно также считать дискретным подтип диапазона, в котором чётко определены понятия «сле-
дующего» и «предыдущего» элемента для каждого значения. Такие определения позволяют пре-
образовывать границы диапазона из включаемых в исключаемые, выбирая следующий или преды-
дущий элемент вместо заданного значения. Например, диапазоны целочисленного типа [4,8] и
(3,9) описывают одно и то же множество значений; но для диапазона подтипа numeric это не так.
Для типа дискретного диапазона определяется функция канонизации, учитывающая размер ша-
га для данного подтипа. Задача этой функции — преобразовать равнозначные диапазоны к един-
ственному представлению, в частности нормализовать включаемые и исключаемые границы. Ес-
ли функция канонизации не определена, диапазоны с различным определением будут всегда счи-
таться разными, даже когда они на самом деле представляют одно множество значений.
Для встроенных типов int4range, int8range и daterange каноническое представление включает
нижнюю границу и не включает верхнюю; то есть диапазон приводится к виду [). Однако для
нестандартных типов можно использовать и другие соглашения.
8.17.8. Определение новых диапазонных типов
Пользователи могут определять собственные диапазонные типы. Это может быть полезно, когда
нужно использовать диапазоны с подтипами, для которых нет встроенных диапазонных типов. На-
пример, можно определить новый тип диапазона для подтипа float8:
CREATE TYPE floatrange AS RANGE (
subtype = float8,
subtype_diff = float8mi
);
SELECT '[1.234, 5.678]'::floatrange;
Так как для float8 осмысленное значение «шага» не определено, функция канонизации в данном
примере не задаётся.
Определяя собственный диапазонный тип, вы также можете выбрать другие правила сортировки
или класс оператора B-дерева для его подтипа, что позволит изменить порядок значений, от кото-
рого зависит, какие значения попадают в заданный диапазон.
Если подтип можно рассматривать как дискретный, а не непрерывный, в команде CREATE TYPE
следует также задать функцию канонизации. Этой функции будет передаваться значение диапазо-
на, а она должна вернуть равнозначное значение, но, возможно, с другими границами и формати-
рованием. Для двух диапазонов, представляющих одно множество значений, например, целочис-
ленные диапазоны [1, 7] и [1, 8), функция канонизации должна выдавать один результат. Какое
именно представление будет считаться каноническим, не имеет значения — главное, чтобы два
174Типы данных
равнозначных диапазона, отформатированных по-разному, всегда преобразовывались в одно зна-
чение с одинаковым форматированием. Помимо исправления формата включаемых/исключаемых
границ, функция канонизации может округлять значения границ, если размер шага превышает
точность хранения подтипа. Например, в типе диапазона для подтипа timestamp можно опреде-
лить размер шага, равный часу, тогда функция канонизации должна будет округлить границы, за-
данные, например с точностью до минут, либо вместо этого выдать ошибку.
Помимо этого, для любого диапазонного типа, ориентированного на использование с индексами
GiST или SP-GiST, должна быть определена разница значений подтипов, функция subtype_diff.
(Индекс сможет работать и без subtype_diff, но в большинстве случаев это будет не так эффектив-
но.) Эта функция принимает на вход два значения подтипа и возвращает их разницу (т. е. X минус
Y) в значении типа float8. В показанном выше примере может использоваться функция float8mi,
определяющая нижележащую реализацию обычного оператора «минус» для типа float8, но для
другого подтипа могут потребоваться дополнительные преобразования. Иногда для представления
разницы в числовом виде требуется ещё и творческий подход. Функция subtype_diff, насколько
это возможно, должна быть согласована с порядком сортировки, вытекающим из выбранных пра-
вил сортировки и класса оператора; то есть, её результат должен быть положительным, если со-
гласно порядку сортировки первый её аргумент больше второго.
Ещё один, не столь тривиальный пример функции subtype_diff:
CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS
'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;
CREATE TYPE timerange AS RANGE (
subtype = time,
subtype_diff = time_subtype_diff
);
SELECT '[11:10, 23:00]'::timerange;
Дополнительные сведения о создании диапазонных типов можно найти в описании CREATE TYPE.
8.17.9. Индексация
Для столбцов, имеющих диапазонный тип, можно создать индексы GiST и SP-GiST. Например, так
создаётся индекс GiST:
CREATE INDEX reservation_idx ON reservation USING GIST (during);
Индекс GiST или SP-GiST помогает ускорить запросы со следующими операторами: =, &amp;amp;&amp;amp;, &amp;lt;@, @&amp;gt;,
&amp;lt;&amp;lt;, &amp;gt;&amp;gt;, -|-, &amp;amp;&amp;lt; и &amp;amp;&amp;gt; (дополнительно о них можно узнать в Таблице 9.50.
Кроме того, для таких столбцов можно создать индексы на основе хеша и B-деревьев. Для индек-
сов таких типов полезен по сути только один оператор диапазона — равно. Порядок сортировки
B-дерева определяется для значений диапазона соответствующими операторами &amp;lt; и &amp;gt;, но этот по-
рядок может быть произвольным и он не очень важен в реальном мире. Поддержка B-деревьев и
хешей диапазонными типами нужна в основном для сортировки и хеширования при выполнении
запросов, но не для создания самих индексов.
8.17.10. Ограничения для диапазонов
Тогда как для скалярных значений естественным ограничением является UNIQUE, оно обычно не
подходит для диапазонных типов. Вместо этого чаще оказываются полезнее ограничения-исклю-
чения (см. CREATE TABLE ... CONSTRAINT ... EXCLUDE). Такие ограничения позволяют, например
определить условие «непересечения» диапазонов. Например:
CREATE TABLE reservation (
during tsrange,
EXCLUDE USING GIST (during WITH &amp;amp;&amp;amp;)
);
175Типы данных
Это ограничение не позволит одновременно сохранить в таблице несколько диапазонов, которые
накладываются друг на друга:
INSERT INTO reservation VALUES
('[2010-01-01 11:30, 2010-01-01 15:00)');
INSERT 0 1
INSERT INTO reservation VALUES
('[2010-01-01 14:45, 2010-01-01 15:45)');
ОШИБКА: конфликтующее значение ключа нарушает ограничение-исключение
&quot;reservation_during_excl&quot;
ПОДРОБНОСТИ: Ключ (during)=([&quot;2010-01-01 14:45:00&quot;,&quot;2010-01-01 15:45:00&quot;))
конфликтует с существующим ключом (during)=([&quot;2010-01-01 11:30:00&quot;,&quot;2010-01-01
15:00:00&quot;))
Для максимальной гибкости в ограничении-исключении можно сочетать простые скалярные типы
данных с диапазонами, используя расширение btree_gist. Например, если btree_gist установле-
но, следующее ограничение не будет допускать пересекающиеся диапазоны, только если совпа-
дают также и номера комнат:
CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
room text,
during tsrange,
EXCLUDE USING GIST (room WITH =, during WITH &amp;amp;&amp;amp;)
);
INSERT INTO room_reservation VALUES
('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');
INSERT 0 1
INSERT INTO room_reservation VALUES
('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');
ОШИБКА: конфликтующее значение ключа нарушает ограничение-исключение
&quot;room_reservation_room_during_excl&quot;
ПОДРОБНОСТИ: Ключ (room, during)=(123A, [ 2010-01-01 14:30:00,
2010-01-01 15:30:00 )) конфликтует
с существующим ключом (room, during)=(123A, [&quot;2010-01-01 14:00:00&quot;,&quot;2010-01-01
15:00:00&quot;)).
INSERT INTO room_reservation VALUES
('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');
INSERT 0 1
8.18. Типы доменов
Домен — пользовательский тип данных, основанный на другом нижележащем типе. Он может
быть определён с условиями, ограничивающими множество допустимых значений подмножеством
значений нижележащего типа. В остальном он ведёт себя как нижележащий тип — например, с
доменными типом будут работать любые операторы или функции, применимые к нижележащему
типу. Нижележащим типом может быть любой встроенный или пользовательский базовый тип,
тип-перечисление, массив, составной тип, диапазон или другой домен.
Например, мы можем создать домен поверх целых чисел, принимающий только положительные
числа:
CREATE
CREATE
INSERT
INSERT
DOMAIN posint AS integer CHECK (VALUE &amp;gt; 0);
TABLE mytable (id posint);
INTO mytable VALUES(1);
-- работает
INTO mytable VALUES(-1); -- ошибка
176Типы данных
Когда к значению доменного типа применяются операторы или функции, предназначенные для
нижележащего типа, домен автоматически приводится к нижележащему типу. Так, например, ре-
зультат операции mytable.id - 1 будет считаться имеющим тип integer, а не posint. Мы могли
бы записать (mytable.id - 1)::posint, чтобы снова привести результат к типу posint, что повле-
чёт перепроверку ограничений домена. В этом случае, если данное выражение будет применено
к id, равному 1, произойдёт ошибка. Значение нижележащего типа можно присвоить полю или
переменной доменного типа, не записывая приведение явно, но и в этом случае ограничения до-
мена будут проверяться.
За дополнительными сведениями обратитесь к описанию CREATE DOMAIN.
8.19. Идентификаторы объектов
Идентификатор объекта (Object Identifier, OID) используется внутри PostgreSQL в качестве первич-
ного ключа различных системных таблиц. В пользовательские таблицы столбец OID добавляется,
только если при создании таблицы указывается WITH OIDS или включён параметр конфигурации
default_with_oids. Идентификатор объекта представляется в типе oid. Также для типа oid опре-
делены следующие псевдонимы: regproc, regprocedure, regoper, regoperator, regclass, regtype,
regrole, regnamespace, regconfig и regdictionary. Обзор этих типов приведён в Таблице 8.24.
В настоящее время тип oid реализован как четырёхбайтное целое. Таким образом оно может быть
недостаточно большим для обеспечения уникальности в базе данных или даже в отдельных боль-
ших таблицах. Поэтому в пользовательских таблицах использовать столбец типа OID в качестве
первичного ключа не рекомендуется. Лучше всего ограничить применение этого типа обращени-
ями к системным таблицам.
Для самого типа oid помимо сравнения определены всего несколько операторов. Однако его мож-
но привести к целому и затем задействовать в обычных целочисленных вычислениях. (При этом
следует опасаться путаницы со знаковыми/беззнаковыми значениями.)
Типы-псевдонимы OID сами по себе не вводят новых операций и отличаются только специализиро-
ванными функциями ввода/вывода. Эти функции могут принимать и выводить не просто числовые
значения, как тип oid, а символические имена системных объектов. Эти типы позволяют упростить
поиск объектов по значениям OID. Например, чтобы выбрать из pg_attribute строки, относящие-
ся к таблице mytable, можно написать:
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
вместо:
SELECT * FROM pg_attribute
WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
Хотя второй вариант выглядит не таким уж плохим, но это лишь очень простой запрос. Если же
потребуется выбрать правильный OID, когда таблица mytable есть в нескольких схемах, вложенный
подзапрос будет гораздо сложнее. Преобразователь вводимого значения типа regclass находит
таблицу согласно заданному пути поиска схем, так что он делает «всё правильно» автоматически.
Аналогично, приведя идентификатор таблицы к типу regclass, можно получить символическое
представление числового кода.
Таблица 8.24. Идентификаторы объектов
Имя Ссылки Описание
oid any числовой идентифика- 564182
тор объекта
regproc pg_proc имя функции
regprocedure pg_proc функция с типами аргу- sum(int4)
ментов
regoper pg_operator имя оператора
177
Пример значения
sum
+Типы данных
Имя Ссылки Описание
Пример значения
regoperator pg_operator оператор с типами ар- *(integer,integer)
гументов
или -(NONE,integer)
regclass pg_class имя отношения
pg_type
regtype pg_type имя типа данных
integer
regrole pg_authid имя роли
smithee
regnamespace pg_namespace пространство имён
pg_catalog
regconfig pg_ts_config конфигурация
вого поиска
regdictionary pg_ts_dict словарь текстового по- simple
иска
тексто- english
Все типы псевдонимов OID для объектов, сгруппированных в пространство имён, принимают име-
на, дополненные именем схемы, и выводят имена со схемой, если данный объект нельзя будет
найти в текущем пути поиска без имени схемы. Типы regproc и regoper принимают только уни-
кальные вводимые имена (не перегруженные), что ограничивает их применимость; в большинстве
случаев лучше использовать regprocedure или regoperator. Для типа regoperator в записи унар-
ного оператора неиспользуемый операнд заменяется словом NONE.
Дополнительным свойством большинства типов псевдонимов OID является образование зави-
симостей. Когда в сохранённом выражении фигурирует константа одного из этих типов (на-
пример, в представлении или в значении столбца по умолчанию), это создаёт зависимость
от целевого объекта. Например, если значение по умолчанию определяется выражением
nextval('my_seq'::regclass), PostgreSQL понимает, что это выражение зависит от последова-
тельности my_seq, и не позволит удалить последовательность раньше, чем будет удалено это вы-
ражение. Единственным ограничением является тип regrole. Константы этого типа в таких выра-
жениях не допускаются.
Примечание
Типы псевдонимов OID не полностью следуют правилам изоляции транзакций. Плани-
ровщик тоже воспринимает их как простые константы, что может привести к неопти-
мальному планированию запросов.
Есть ещё один тип системных идентификаторов, xid, представляющий идентификатор транзакции
(сокращённо xact). Этот тип имеют системные столбцы xmin и xmax. Идентификаторы транзакций
определяются 32-битными числами.
Третий тип идентификаторов, используемых в системе, — cid, идентификатор команды (command
identifier). Этот тип данных имеют системные столбцы cmin и cmax. Идентификаторы команд — это
тоже 32-битные числа.
И наконец, последний тип системных идентификаторов — tid, идентификатор строки/кортежа
(tuple identifier). Этот тип данных имеет системный столбец ctid. Идентификатор кортежа пред-
ставляет собой пару (из номера блока и индекса кортежа в блоке), идентифицирующую физиче-
ское расположение строки в таблице.
(Подробнее о системных столбцах рассказывается в Разделе 5.4.)
8.20. Тип pg_lsn
Тип данных pg_lsn может применяться для хранения значения LSN (последовательный номер в
журнале, Log Sequence Number), которое представляет собой указатель на позицию в журнале
WAL. Этот тип содержит XLogRecPtr и является внутренним системным типом PostgreSQL.
178Типы данных
Технически LSN — это 64-битное целое, представляющее байтовое смещение в потоке журнала
предзаписи. Он выводится в виде двух шестнадцатеричных чисел до 8 цифр каждое, через косую
черту, например: 16/B374D848. Тип pg_lsn поддерживает стандартные операторы сравнения, та-
кие как = и &amp;gt;. Можно также вычесть один LSN из другого с помощью оператора -; результатом
будет число байт между этими двумя позициями в журнале предзаписи.
8.21. Псевдотипы
В систему типов PostgreSQL включены несколько специальных элементов, которые в совокупности
называются псевдотипами. Псевдотип нельзя использовать в качестве типа данных столбца, но
можно объявить функцию с аргументом или результатом такого типа. Каждый из существующих
псевдотипов полезен в ситуациях, когда характер функции не позволяет просто получить или вер-
нуть определённый тип данных SQL. Все существующие псевдотипы перечислены в Таблице 8.25.
Таблица 8.25. Псевдотипы
Имя Описание
any Указывает, что функция принимает любой вво-
димый тип данных.
anyelement Указывает, что функция принимает любой тип
данных (см. Подраздел 38.2.5).
anyarray Указывает, что функция принимает любой тип
массива (см. Подраздел 38.2.5).
anynonarray Указывает, что функция принимает любой тип
данных, кроме массивов (см. Подраздел 38.2.5).
anyenum Указывает, что функция принимает любое пере-
числение (см. Подраздел 38.2.5 и Раздел 8.7).
anyrange Указывает, что функция принимает любой диа-
пазонный тип данных (см. Подраздел  38.2.5 и
Раздел 8.17).
cstring Указывает, что функция принимает или возвра-
щает строку в стиле C.
internal Указывает, что функция принимает или возвра-
щает внутренний серверный тип данных.
language_handler Обработчик процедурного языка объявляется
как возвращающий тип language_handler .
fdw_handler Обработчик обёртки сторонних данных объявля-
ется как возвращающий тип fdw_handler .
index_am_handler Обработчик метода доступа индекса объявляет-
ся как возвращающий тип index_am_handler .
tsm_handler Обработчик метода выборки из таблицы объяв-
ляется как возвращающий тип tsm_handler .
record Указывает, что функция принимает или возвра-
щает неопределённый тип строки.
trigger Триггерная функция объявляется как возвраща-
ющая тип trigger.
event_trigger Функция событийного триггера объявляется как
возвращающая тип event_trigger .
pg_ddl_command Обозначает представление команд DDL, доступ-
ное событийным триггерам.
void Указывает, что функция не возвращает значе-
ние.
179Типы данных
Имя Описание
unknown Обозначает ещё не распознанный тип, то есть
раскрытое строковое значение.
opaque Устаревший тип, который раньше использовал-
ся во многих вышеперечисленных случаях.
Функции, написанные на языке C (встроенные или динамически загружаемые), могут быть объяв-
лены с параметрами или результатами любого из этих типов. Ответственность за безопасное по-
ведение функции с аргументами таких типов ложится на разработчика функции.
Функции, написанные на процедурных языках, могут использовать псевдотипы, только если это
позволяет соответствующий язык. В настоящее время большинство процедурных языков запреща-
ют использовать псевдотипы в качестве типа аргумента и позволяют использовать для результа-
тов только типы void и record (и trigger или event_trigger, когда функция реализует триггер
или событийный триггер). Некоторые языки также поддерживают полиморфные функции с типа-
ми anyelement, anyarray, anynonarray, anyenum и anyrange.
Псевдотип internal используется в объявлениях функций, предназначенных только для внутрен-
него использования в СУБД, но не для прямого вызова в запросах SQL. Если у функции есть как
хотя бы один аргумент типа internal, её нельзя будет вызывать из SQL. Чтобы сохранить типобез-
опасность при таком ограничении, следуйте важному правилу: не создавайте функцию, возвраща-
ющую результат типа internal, если у неё нет ни одного аргумента internal.&lt;/chapter&gt;&lt;/book&gt;&lt;/N&gt;&lt;/p&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 8. Типы данных</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 9. Функции и операторы</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-009/" rel="alternate" type="text/html" title="Глава 9. Функции и операторы" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-009</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-009/">&lt;p&gt;Глава 9. Функции и операторы&lt;/p&gt;

&lt;p&gt;PostgreSQL предоставляет огромное количество функций и операторов для встроенных типов дан-
ных. Кроме того, пользователи могут определять свои функции операторы, как описано в Части V.
Просмотреть все существующие функции и операторы можно в psql с помощью команд \df и \do,
соответственно.
Если для вас важна переносимость, учтите, что практически все функции и операторы, описанные
в этой главе, за исключением простейших арифметических и операторов сравнения, а также яв-
но отмеченных функций, не описаны в стандарте SQL. Тем не менее, частично эта расширенная
функциональность присутствует и в других СУБД SQL и во многих случаях различные реализации
одинаковых функций оказываются аналогичными и совместимыми. В этой главе не описываются
абсолютно все функции; некоторые дополнительные функции рассматриваются в других разделах
документации.
9.1. Логические операторы
Набор логических операторов включает обычные:
AND
OR
NOT
В SQL работает логическая система с тремя состояниями: true (истина), false (ложь) и NULL,
«неопределённое» состояние. Рассмотрите следующие таблицы истинности:
a b a AND b a OR b
TRUE TRUE TRUE TRUE
TRUE FALSE FALSE TRUE
TRUE NULL NULL TRUE
FALSE FALSE FALSE FALSE
FALSE NULL FALSE NULL
NULL NULL NULL NULL
a NOT a
TRUE FALSE
FALSE TRUE
NULL NULL
Операторы AND и OR коммутативны, то есть от перемены мест операндов результат не меняется.
Однако значение может иметь порядок вычисления подвыражений. Подробнее это описано в Под-
разделе 4.2.14.
9.2. Функции и операторы сравнения
Набор операторов сравнения включает обычные операторы, перечисленные в Таблице 9.1.
Таблица 9.1. Операторы сравнения
Оператор Описание
&amp;lt; меньше&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;больше
&amp;lt;= меньше или равно
= больше или равно
181Функции и операторы
Оператор Описание
= равно
&amp;lt;&amp;gt; или != не равно
Примечание
Оператор != преобразуется в &amp;lt;&amp;gt; на стадии разбора запроса. Как следствие, реализовать
операторы != и &amp;lt;&amp;gt; по-разному невозможно.
Операторы сравнения определены для всех типов данных, для которых они имеют смысл. Все
операторы сравнения представляют собой бинарные операторы, возвращающие значения типа
boolean; при этом выражения вида 1 &amp;lt; 2 &amp;lt; 3 недопустимы (так как не существует оператора &amp;lt;,
который бы сравнивал булево значение с 3).
Существует также несколько предикатов сравнения; они приведены в Таблице 9.2. Они работают
подобно операторам, но имеют особый синтаксис, установленный стандартом SQL.
Таблица 9.2. Предикаты сравнения
Предикат Описание
a BETWEEN x AND y между
a NOT BETWEEN x AND y не между
a BETWEEN SYMMETRIC x AND y между, после сортировки сравниваемых значе-
ний
a NOT BETWEEN SYMMETRIC x AND y не между, после сортировки сравниваемых зна-
чений
a IS DISTINCT FROM b не равно, при этом NULL воспринимается как
обычное значение
a IS NOT DISTINCT FROM b равно, при этом NULL воспринимается как обыч-
ное значение
выражение IS NULL эквивалентно NULL
выражение IS NOT NULL не эквивалентно NULL
выражение ISNULL эквивалентно NULL (нестандартный синтаксис)
выражение NOTNULL не эквивалентно NULL (нестандартный синтак-
сис)
логическое_выражение IS TRUE истина
логическое_выражение IS NOT TRUE ложь или неопределённость
логическое_выражение IS FALSE ложь
логическое_выражение IS NOT FALSE истина или неопределённость
логическое_выражение IS UNKNOWN неопределённость
логическое_выражение IS NOT UNKNOWN истина или ложь
Предикат BETWEEN упрощает проверки интервала:
a BETWEEN x AND y
равнозначно выражению
a &amp;gt;= x AND a &amp;lt;= y
Заметьте, что BETWEEN считает, что границы интервала также включаются в интервал. NOT BETWEEN
выполняет противоположное сравнение:
a NOT BETWEEN x AND y
182Функции и операторы
равнозначно выражению
a &amp;lt; x OR a &amp;gt; y
Предикат BETWEEN SYMMETRIC аналогичен BETWEEN, за исключением того, что аргумент слева от
AND не обязательно должен быть меньше или равен аргументу справа. Если это не так, аргументы
автоматически меняются местами, так что всегда подразумевается непустой интервал.
Обычные операторы сравнения выдают NULL (что означает «неопределённость»), а не true или
false, когда любое из сравниваемых значений NULL. Например, 7 = NULL выдаёт NULL, так же,
как и 7 &amp;lt;&amp;gt; NULL. Когда это поведение нежелательно, можно использовать предикаты IS [ NOT ]
DISTINCT FROM:
a IS DISTINCT FROM b
a IS NOT DISTINCT FROM b
Для значений не NULL условие IS DISTINCT FROM работает так же, как оператор &amp;lt;&amp;gt;. Однако, если
оба сравниваемых значения NULL, результат будет false, и только если одно из значений NULL,
возвращается true. Аналогично, условие IS NOT DISTINCT FROM равносильно = для значений не
NULL, но возвращает true, если оба сравниваемых значения NULL и false в противном случае. Та-
ким образом, эти предикаты по сути работают с NULL, как с обычным значением, а не с «неопре-
делённостью».
Для проверки, содержит ли значение NULL или нет, используются предикаты:
выражение IS NULL
выражение IS NOT NULL
или равнозначные (но нестандартные) предикаты:
выражение ISNULL
выражение NOTNULL
Заметьте, что проверка выражение = NULL не будет работать, так как NULL считается не «равным»
NULL. (Значение NULL представляет неопределённость, и равны ли две неопределённости, тоже
не определено.)
Подсказка
Некоторые приложения могут ожидать, что выражение = NULL вернёт true, если ре-
зультатом выражения является NULL. Такие приложения настоятельно рекомендует-
ся исправить и привести в соответствие со стандартом SQL. Однако, в случаях, когда
это невозможно, это поведение можно изменить с помощью параметра конфигурации
transform_null_equals. Когда этот параметр включён, PostgreSQL преобразует условие
x = NULL в x IS NULL.
Если выражение возвращает табличную строку, тогда IS NULL будет истинным, когда само выраже-
ние — NULL или все поля строки — NULL, а IS NOT NULL будет истинным, когда само выражение
не NULL, и все поля строки так же не NULL. Вследствие такого определения, IS NULL и IS NOT
NULL не всегда будут возвращать взаимодополняющие результаты для таких выражений; в частно-
сти такие выражения со строками, одни поля которых NULL, а другие не NULL, будут ложными
одновременно. В некоторых случаях имеет смысл написать строка IS DISTINCT FROM NULL или
строка IS NOT DISTINCT FROM NULL, чтобы просто проверить, равно ли NULL всё значение строки,
без каких-либо дополнительных проверок полей строки.
Логические значения можно также проверить с помощью предикатов
логическое_выражение
логическое_выражение
логическое_выражение
логическое_выражение
IS
IS
IS
IS
TRUE
NOT TRUE
FALSE
NOT FALSE
183Функции и операторы
логическое_выражение IS UNKNOWN
логическое_выражение IS NOT UNKNOWN
Они всегда возвращают true или false и никогда NULL, даже если какой-любо операнд — NULL.
Они интерпретируют значение NULL как «неопределённость». Заметьте, что IS UNKNOWN и IS NOT
UNKNOWN по сути равнозначны IS NULL и IS NOT NULL, соответственно, за исключением того, что
выражение может быть только булевого типа.
Также имеется несколько связанных со сравнениями функций; они перечислены в Таблице 9.3.
Таблица 9.3. Функции сравнения
Функция Описание
Пример
Результат примера
num_nonnulls(
VARIADIC “any”) возвращает число ар- num_nonnulls(1,
гументов, отличных от NULL, 2)
NULL 2
num_nulls(VARIADIC
“any”) возвращает число аргу- num_nulls(1, NULL,
ментов NULL
2) 1
9.3. Математические функции и операторы
Математические операторы определены для множества типов PostgreSQL. Как работают эти опе-
рации с типами, для которых нет стандартных соглашений о математических действиях (напри-
мер, с типами даты/времени), мы опишем в последующих разделах.
В Таблице 9.4 перечислены все доступные математические операторы.
Таблица 9.4. Математические операторы
Оператор Описание Пример Результат&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;сложение 2 + 3 5&lt;/li&gt;
    &lt;li&gt;вычитание 2 - 3 -1&lt;/li&gt;
    &lt;li&gt;умножение 2 * 3 6
/ деление (при целочис- 4 / 2
ленном делении оста-
ток отбрасывается) 2
% остаток от деления 1
^ возведение в степень ( 2.0 ^ 3.0
вычисляется слева на-
право) 8
|/ квадратный корень |/ 25.0 5
||/ кубический корень ||/ 27.0 3
! факториал 5 ! 120
!! факториал
ная форма) @ модуль числа (абсолют- @ -5.0
ное значение) 5
&amp;amp; битовый AND 91 &amp;amp; 15 11
| битовый OR 32 | 3 35
      &lt;h1 id=&quot;битовый-xor-17--5-20&quot;&gt;битовый XOR 17 # 5 20&lt;/h1&gt;
      &lt;p&gt;~ битовый NOT ~1 -2
« битовый сдвиг влево 1 « 4 16&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;битовый сдвиг вправо 8 » 2 2
5 % 4
(префикс- !! 5
184
120Функции и операторы
Битовые операторы работают только с целостными типами данных, тогда как другие и работают
и с остальными числовыми типами. Битовые операции также работают с битовыми строками bit
и bit varying, как показано в Таблице 9.13.
В Таблице  9.5 перечислены все существующие математические функции. Сокращение dp в ней
обозначает тип double precision (плавающее с двойной точностью). Многие из этих функций име-
ют несколько форм с разными типами аргументов. За исключением случаев, где это указано явно,
любая форма функции возвращает результат того же типа, что и аргумент. Функции, работающие
с данными double precision, в массе своей используют реализации из системных библиотек сер-
вера, поэтому точность и поведение в граничных случаях может зависеть от системы сервера.
Таблица 9.5. Математические функции
Функция Тип результата Описание
Пример
abs( x) тип аргумента модуль числа ( abs(-17.4)
абсолютное значе-
ние) 17.4
cbrt( dp) dp кубический
рень 3
ко- cbrt(27.0)
Результат
ceil( dp
numeric) или тип аргумента ближайшее целое, ceil(-42.8)
большее или рав-
ное аргументу -42
ceiling( dp
numeric) или тип аргумента ближайшее целое, ceiling(-95.3)
большее или рав-
ное аргументу (
равнозначно ceil) -95
преобразование
degrees(0.5)
радианов в граду-
сы 28.6478897565
412
целочисленный
результат y/x div(9,4) 2
exp(1.0) 2.7182818284
5905
degrees( dp)
dp
div( y
numeric, numeric
x numeric)
exp( dp
numeric) или тип аргумента экспонента floor( dp
numeric) или тип аргумента ближайшее целое, floor(-42.8)
меньшее или рав-
ное аргументу -43
ln( dp
numeric) или тип аргумента натуральный лога- ln(2.0)
рифм 0.6931471805
59945
log( dp
numeric) или тип аргумента логарифм по осно- log(100.0)
ванию 10 2
логарифм по осно- log(2.0, 64.0)
ванию b 6.0000000000
log( b
numeric, numeric
x numeric)
mod( y,
x)
pi()
power( a
dp)
зависит от типов остаток
аргументов
ния y/x
dp
dp,
b dp
power( a numeric, numeric
b numeric)
от
деле- mod(9,4)
константа «π»
pi()
1
3.1415926535
8979
a возводится в сте- power(9.0, 3.0)
пень b 729
a возводится в сте- power(9.0, 3.0)
пень b 729
185Функции и операторы
Функция Тип результата Описание radians( dp) dp преобразование
radians(45.0)
градусов в радиа-
ны 0.7853981633
97448
округление до бли- round(42.4)
жайшего целого 42
round( v numeric, numeric
s int) округление v до round(42.4382,
s десятичных зна- 2)
ков 42.44
scale( numeric) масштаб аргумен- scale(8.41)
та (число десятич-
ных цифр в дроб-
ной части) 2
round( dp
numeric)
или тип аргумента
integer
Пример
Результат
sign( dp
numeric) или тип аргумента знак аргумента ( sign(-8.4)
-1, 0, +1) -1
sqrt( dp
numeric) или тип аргумента квадратный
рень 1.4142135623731
trunc( dp
numeric) или тип аргумента округление к нулю trunc(42.8) 42
trunc( v numeric, numeric
s int) округление к 0 до trunc(42.4382,
s десятичных зна- 2)
ков 42.43
width_bucket(
int
operand dp, b1
dp,
b2
dp,
count int) возвращает номер width_bucket(
группы, в которую 5.35,
0.024,
попадёт operand в 10.06, 5)
гистограмме с чис-
лом групп count
равного размера, в
диапазоне от b1 до
b2; возвращает 0
или count+1, если
операнд лежит вне
диапазона 3
width_bucket(
int
operand numeric,
b1 numeric, b2
numeric,
count
int) возвращает номер width_bucket(
группы, в которую 5.35,
0.024,
попадёт operand в 10.06, 5)
гистограмме с чис-
лом групп count
равного размера, в
диапазоне от b1 до
b2; возвращает 0
или count+1, если
операнд лежит вне
диапазона 3
width_bucket(
int
operand
anyelement,
thresholds
anyarray) возвращает номер width_bucket(
2
группы, в которую now(),
попадёт
operand
array[‘yesterday’,
(группы
опреде-
‘today’,
ляются
нижни- ‘tomorrow’]::timestamptz[])
ми границами, пе-
редаваемыми
в
thresholds); воз-
вращает 0, если
186
ко- sqrt(2.0)Функции и операторы
Функция
Тип результата
Описание
Пример
операнд оказыва-
ется левее нижней
границы; массив
thresholds
дол-
жен быть отсор-
тирован по воз-
растанию, иначе
будут
получены
неожиданные ре-
зультаты
Результат
В Таблице 9.6 перечислены все функции для генерации случайных чисел.
Таблица 9.6. Случайные функции
Функция Тип результата Описание
random() dp случайное число в диапазоне
0.0 &amp;lt;= x &amp;lt; 1.0
setseed( dp) void задаёт отправную точку для по-
следующих вызовов random()
(значение между -1.0 и 1.0,
включая границы)
Характеристики значений, возвращаемых функцией random() зависят от системы. Для примене-
ния в криптографии они непригодны; альтернативы описаны в pgcrypto.
Наконец, в Таблице 9.7 перечислены все имеющиеся тригонометрические функции. Все эти функ-
ции принимают аргументы и возвращают значения типа double precision. У каждой функции
имеются две вариации — одна измеряет углы в радианах, а вторая в градусах.
Таблица 9.7. Тригонометрические функции
Функции (в радианах) Функции (в градусах) Описание
acos( x) acosd( x) арккосинус
asin( x) asind( x) арксинус
atan( x) atand( x) арктангенс
atan2( y,
x)
atan2d( y,
x)
арктангенс y/x
cos( x) cosd( x) косинус
cot( x) cotd( x) котангенс
sin( x) sind( x) синус
tan( x) tand( x) тангенс
Примечание
Также можно работать с углами в градусах, применяя вышеупомянутые функции пре-
образования единиц radians() и degrees(). Однако предпочтительнее использовать
тригонометрические функции с градусами, так как это позволяет избежать ошибок
округления в особых случаях, например, при вычислении sind(30).
9.4. Строковые функции и операторы
В этом разделе описаны функции и операторы для работы с текстовыми строками. Под строками
в данном контексте подразумеваются значения типов character, character varying и text. Если
не отмечено обратное, все нижеперечисленные функции работают со всеми этими типами, хотя с
187Функции и операторы
типом character следует учитывать возможные эффекты автоматического дополнения строк про-
белами. Некоторые из этих функций также поддерживают битовые строки.
В SQL определены несколько строковых функций, в которых аргументы разделяются не запятыми,
а ключевыми словами. Они перечислены в Таблице 9.8. PostgreSQL также предоставляет варианты
этих функций с синтаксисом, обычным для функций (см. Таблицу 9.9).
Примечание
До версии 8.3 в PostgreSQL эти функции также прозрачно принимали значения неко-
торых не строковых типов, неявно приводя эти значения к типу text. Сейчас такие
приведения исключены, так как они часто приводили к неожиданным результатам. Од-
нако оператор конкатенации строк (||) по-прежнему принимает не только строковые
данные, если хотя бы один аргумент имеет строковый тип, как показано в Таблице 9.8.
Во всех остальных случаях для повторения предыдущего поведения потребуется доба-
вить явное преобразование в text.
Таблица 9.8. Строковые функции и операторы языка SQL
Функция
Тип результата
Описание Пример Результат
string || string text Конкатенация
строк ‘Post’
‘greSQL’ || PostgreSQL
string
||
не text
string
или
не
string || string Конкатенация
‘Value: ‘ || 42
строк с одним не
строковым операн-
дом
Value: 42
bit_length(
string) Число бит в строке bit_length(
‘jose’) 32
char_length(
int
string)
или
character_
length( string) Число символов в char_length(
строке
‘jose’) 4
lower( string) text Переводит симво- lower(‘TOM’)
лы строки в ниж-
ний регистр tom
octet_length(
string) int Число байт в стро- octet_length(
ке
‘jose’) 4
int
overlay( string text
placing
string
from
int
[for
int]) Заменяет подстро- overlay(
Thomas
ку
‘Txxxxas’
placing
‘hom’
from 2 for 4)
position(
substring
string) Положение
ука- position(‘om’ in
занной подстроки ‘Thomas’)
3
substring(
text
string
[from
int] [for int]) Извлекает
строку
hom
substring(
text
string from шаб-
лон) Извлекает
под- substring(
строку,
соответ- ‘Thomas’
ствующую
регу- ‘…$’)
лярному выраже-
нию в стиле POSIX.
Подробно шабло-
int
in
188
под- substring(
‘Thomas’ from 2
for 3)
mas
fromФункции и операторы
Функция
Тип результата
Описание
Пример
ны описаны в Раз-
деле 9.7. Результат
substring(
text
string from шаб-
лон for спецсим-
вол) Извлекает
под-
строку,
соответ-
ствующую
регу-
лярному выраже-
нию в стиле SQL.
Подробно шабло-
ны описаны в Раз-
деле 9.7. substring(
‘Thomas’
from
‘%#”o_a#”&lt;em&gt;’ for
‘#’) oma
trim([leading | text
trailing | both]
[characters] from
string) Удаляет наиболь- trim(both ‘xyz’
шую
подстро- from ‘yxTomxx’)
ку,
содержащую
только
символы
characters
(по
умолчанию
про-
белы),
с
нача-
ла (leading), с
конца (trailing)
или с обеих сто-
рон
(both,
(по
умолчанию)) стро-
ки string Tom
trim([leading | text
trailing | both]
[from] string [,
characters] ) Нестандартный
синтаксис trim() Tom
upper( string) Переводит симво- upper(‘tom’)
лы строки в верх-
ний регистр
text
trim(both
‘yxTomxx’,
‘xyz’)
from
TOM
Кроме этого, в PostgreSQL есть и другие функции для работы со строками, перечисленные в Таб-
лице 9.9. Некоторые из них используются в качестве внутренней реализации стандартных строко-
вых функций SQL, приведённых в Таблице 9.8.
Таблица 9.9. Другие строковые функции
Функция Тип результата Описание ascii( string) int Возвращает ASCII- ascii(‘x’)
код первого сим-
вола
аргумента.
Для
UTF8
воз-
вращает код сим-
вола в Unicode.
Для других мно-
гобайтных кодиро-
вок аргумент дол-
жен быть ASCII-
символом. 120
Удаляет наиболь- btrim(
шую
подстроку, ‘xyxtrimyyx’,
состоящую толь- ‘xyz’)
ко
из
симво-
лов characters (
по умолчанию про- trim
btrim( string
text
text
[,
characters
text])
189
Пример
РезультатФункции и операторы
Функция Тип результата Описание
Пример
белов), с начала
и с конца строки
string Результат
chr( int) text Возвращает сим- chr(65)
вол с данным ко-
дом. Для UTF8 ар-
гумент восприни-
мается как код
символа Unicode, а
для других кодиро-
вок он должен ука-
зывать на ASCII-
символ. Код 0 (
NULL) не допуска-
ется, так как бай-
ты с нулевым ко-
дом в текстовых
строках сохранить
нельзя. A
concat( str “any” text
[, str “any” [,
…] ]) Соединяет тексто- concat(‘abcde’,
вые
представле- 2, NULL, 22)
ния
всех
аргу-
ментов, игнорируя
NULL. abcde222
concat_ws( sep text
text, str “any”
[, str “any” [,
…] ]) Соединяет все ар- concat_ws(‘,
гументы,
кроме ‘, ‘abcde’, 2,
первого,
через NULL, 22)
разделитель,
иг-
норируя аргумен-
ты NULL. Раздели-
тель указывается в
первом аргументе. abcde,2,22
convert( string bytea
bytea,
src&lt;/em&gt;
encoding
name,
dest_encoding
name) Преобразует стро- convert(‘text_
ку
string
из in_utf8’,
кодировки
src_
‘UTF8’,
encoding в dest_ ‘LATIN1’)
encoding .
Пе-
реданная строка
должна быть до-
пустимой для ис-
ходной
кодиров-
ки. Преобразова-
ния могут быть
определены с по-
мощью
CREATE
CONVERSION.
Все
встроенные
пре-
образования пере-
числены в Табли-
це 9.10. строка text_in_
utf8 ,
представ-
ленная в коди-
ровке Latin-1 (ISO
8859-1)
convert_from(
text
string
bytea,
src_encoding
name) Преобразует стро- convert_from(
ку
string
из ‘text_in_
кодировки
src_ utf8’, ‘UTF8’)
encoding в коди- строка text_in_
utf8 ,
представ-
ленная в кодиров-
190Функции и операторы
Функция
Тип результата
Описание
Пример
ровку базы дан-
ных. Переданная
строка
должна
быть допустимой
для исходной ко-
дировки. Результат
ке текущей базы
данных
convert_to(
bytea
string
text,
dest_encoding
name) Преобразует стро- convert_to(
ку в кодировку ‘некоторый
dest_encoding .
текст’, ‘UTF8’) некоторый текст,
представленный в
кодировке UTF8
decode( string
bytea
text,
format
text) Получает двоич- decode(
ные данные из тек- ‘MTIzAAE=’,
стового представ- ‘base64’)
ления в string.
Значения
пара-
метра format те
же, что и для
функции encode. \x3132330001
encode( data
text
bytea,
format
text) Переводит двоич- encode(
ные данные в тек- ‘123\000\001’,
стовое представле- ‘base64’)
ние в одном из
форматов: base64,
hex, escape. Фор-
мат escape пре-
образует нулевые
байты и байты
с 1 в старшем
бите
в
восьме-
ричные последова-
тельности \nnn и
дублирует обрат-
ную косую черту. MTIzAAE=
format(
text
formatstr
text
[,
formatarg
“any” [, …] ]) Форматирует аргу- format(‘Hello
мент в соответ- %s,
%1$s’,
ствии
со
стро- ‘World’)
кой формата. Эта
функция работает
подобно sprintf в
языке C. См. Под-
раздел 9.4.1. Hello
World
initcap( string) text Переводит первую initcap(‘hi
букву каждого сло- THOMAS’)
ва
в
строке
в
верхний
ре-
гистр, а осталь-
ные — в нижний.
Словами считают-
ся последователь-
ности
алфавит-
но-цифровых сим-
волов,
разделён-
ные любыми дру-
гими символами. Hi Thomas
191
World,Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
Возвращает пер- left(‘abcde’,
вые n символов 2)
в строке. Когда
n
меньше
ну-
ля, возвращаются
все символы сле-
ва, кроме послед-
них |n|. ab
int Число символов в length(‘jose’)
строке string 4
length( string
int
bytea,
encoding
name ) Число
символов, length(‘jose’,
которые содержит ‘UTF8’)
строка string в
заданной кодиров-
ке encoding. Пе-
реданная строка
должна быть допу-
стимой в этой ко-
дировке. 4
lpad( string
text
text, length int
[, fill text]) Дополняет строку lpad(‘hi’,
string слева до ‘xy’)
длины length сим-
волами fill (по
умолчанию пробе-
лами). Если длина
строки уже боль-
ше заданной, она
обрезается спра-
ва. xyxhi
ltrim( string
text
text
[,
characters
text]) Удаляет наиболь- ltrim(
шую
подстро- ‘zzzytest’,
ку,
содержащую ‘xyz’)
только
символы
characters
(по
умолчанию пробе-
лы), с начала стро-
ки string test
md5( string) Вычисляет MD5- md5(‘abc’)
хеш строки string
и возвращает ре-
зультат в 16-рич-
ном виде 90015098
3cd24fb0
d6963f7d
28e17f72
left( str
n int)
text, text
length( string)
text
parse_ident(
text[]
qualified_
identifier
text
[,
strictmode
boolean
DEFAULT
true ] )
5,
Раскладывает пол- parse_ident(
(SomeSchema,
ный
идентифи- ‘“SomeSchema”.someTable’)
sometable)
катор,
задава-
емый
парамет-
ром
qualified_
identifier ,
на
массив идентифи-
каторов,
удаляя
кавычки,
обрам-
ляющие
отдель-
ные идентифика-
192Функции и операторы
Функция Тип результата Описание
Пример
торы. По умолча-
нию лишние сим-
волы после по-
следнего иденти-
фикатора вызыва-
ют
ошибку,
но
если
отключить
строгий режим (
передать во вто-
ром
параметре
false), такие сим-
волы игнорируют-
ся. (Это поведе-
ние полезно для
разбора имён та-
ких объектов, как
функции.) Заметь-
те, что эта функ-
ция не усекает
чрезмерно длин-
ные идентифика-
торы.
Если
вы
хотите
получить
усечённые
име-
на, можно приве-
сти результат к
name[]. Результат
pg_client_
encoding() name Возвращает
имя pg_client_
текущей клиент- encoding()
ской кодировки SQL_ASCII
quote_ident(
string text) text Переданная стро- quote_ident(
ка
оформляется ‘Foo bar’)
для
использова-
ния в качестве
идентификатора в
SQL
-операторе.
При необходимо-
сти идентифика-
тор заключается
в кавычки (на-
пример, если он
содержит симво-
лы, недопустимые
в открытом ви-
де,
или
буквы
в разном реги-
стре). Если пере-
данная строка со-
держит кавычки,
они дублируются.
См. также При-
мер 43.1. “Foo bar”
quote_literal(
string text) text Переданная стро- quote_literal(
ка
оформляется E’O'Reilly’)
для
использова- ‘O’‘Reilly’
193Функции и операторы
Функция Тип результата Описание
Пример
ния в качестве
текстовой
стро-
ки в SQL-опера-
торе. Включённые
символы апостроф
и обратная косая
черта при этом
дублируются. За-
метьте, что quote_
literal
возвра-
щает NULL, когда
на вход ей переда-
ётся строка NULL;
если же нужно по-
лучить представ-
ление и такого ар-
гумента, лучше ис-
пользовать quote_
nullable .
См.
также
При-
мер 43.1. Результат
quote_literal(
value
anyelement) text Переводит данное quote_literal(
значение в тексто- 42.5)
вый вид и заклю-
чает в апостро-
фы как текстовую
строку. Символы
апостроф и обрат-
ная косая черта
при этом дублиру-
ются. ‘42.5’
quote_nullable(
string text) text Переданная стро- quote_nullable(
ка
оформляется NULL)
для
использова-
ния в качестве
текстовой строки
в SQL-операторе;
при этом для ар-
гумента NULL воз-
вращается
стро-
ка NULL. Симво-
лы апостроф и об-
ратная косая чер-
та
дублируются
должным образом.
См. также При-
мер 43.1. NULL
quote_nullable(
value
anyelement) text Переводит данное quote_nullable(
значение в тек- 42.5)
стовый вид и за-
ключает в апо-
строфы как тек-
стовую строку, при
этом для аргумен-
та NULL возвраща- ‘42.5’
194Функции и операторы
Функция
Тип результата
Описание
Пример
ется строка NULL.
Символы апостроф
и обратная косая
черта дублируют-
ся должным обра-
зом. Результат
regexp_match(
text[]
string
text,
pattern text [,
flags text]) Возвращает под-
ходящие подстро-
ки, полученные из
первого
вхожде-
ния регулярного
выражения POSIX
в строке string.
Подробности опи-
саны в Подразде-
ле 9.7.3. (bar,beque)
regexp_matches
setof text[]
( string
text,
pattern text [,
flags text]) Возвращает подхо- regexp_matches(
дящие подстроки, ‘foobar
полученные в ре- bequebaz’,
зультате примене- ‘ba.’, ‘g’)
ния регулярного
выражения POSIX
к string. Подроб-
ности описаны в
Подразделе 9.7.3. (bar)
regexp_replace
text
( string
text,
pattern text,
replacement
text [,
flags
text]) Заменяет подстро- regexp_replace(
ки, соответствую- ‘Thomas’,
‘.
щие заданному ре- [mN]a.’, ‘M’)
гулярному выра-
жению в стиле
POSIX. Подробно-
сти описаны в Под-
разделе 9.7.3. ThM
regexp_split_
text[]
to_array(
string
text,
pattern text [,
flags text ]) Разделяет содер- regexp_split_
жимое string на to_array(
элементы, исполь- ‘hello
world’,
зуя в качестве ‘\s+’)
разделителя регу-
лярное выражение
POSIX. Подробно-
сти описаны в Под-
разделе 9.7.3. (hello,world)
regexp_split_
setof text
to_table(
string
text,
pattern text [,
flags text]) Разделяет содер- regexp_split_
жимое string на to_table(
элементы, исполь- ‘hello
world’,
зуя в качестве ‘\s+’)
разделителя регу-
лярное выражение
POSIX. Подробно-
сти описаны в Под-
разделе 9.7.3. hello
repeat( string
text
text,
number
int) Повторяет содер- repeat(‘Pg’, 4)
жимое string ука- PgPgPgPg
195
regexp_match(
‘foobar
bequebaz’,
‘(
bar)(beque)’)
(baz)
(2 строки)
world
(2 строки)Функции и операторы
Функция
Тип результата
Описание
занное число
number) раз
(
Пример
Результат
replace( string text
text, from text,
to text) Заменяет
все replace(
вхождения
в ‘abcdefabcdef’,
string подстроки ‘cd’, ‘XX’)
from подстрокой
to abXXefabXXef
reverse( str) Возвращает пере- reverse(
вёрнутую строку
‘abcde’) edcba
Возвращает
по- right(‘abcde’,
следние n симво- 2)
лов в строке. Ко-
гда n меньше ну-
ля, возвращаются
все символы спра-
ва, кроме первых
|n|. de
rpad( string
text
text, length int
[, fill text]) Дополняет строку rpad(‘hi’,
string справа до ‘xy’)
длины length сим-
волами fill (по
умолчанию пробе-
лами). Если длина
строки уже боль-
ше заданной, она
обрезается. hixyx
rtrim( string
text
text
[,
characters
text]) Удаляет наиболь- rtrim(
шую
подстро- ‘testxxzx’,
ку,
содержащую ‘xyz’)
только
символы
characters
(по
умолчанию пробе-
лы), с конца стро-
ки string test
split_part(
text
string
text,
delimiter text,
field int) Разделяет строку split_part(
string по симво- ‘abc~@~def
лу delimiter и воз- ~@~ghi’, ‘~@~’,
вращает элемент 2)
по заданному но-
меру (считая с 1) def
strpos( string,
substring) Возвращает
по- strpos(‘high’,
ложение указан- ‘ig’)
ной подстроки (
подобно position(
substring
in
string), но с дру-
гим порядком ар-
гументов) 2
Извлекает
под- substr(
строку
(подоб- ‘alphabet’,
но
substring( 2) ph
right( str
n int)
text
text, text
int
substr( string, text
from
[,
count])
196
5,
3,Функции и операторы
Функция
Тип результата
Описание
Пример
string from from
for count)) Результат
starts_with(
bool
string, prefix) Возвращает true, starts_with(
если
строка ‘alphabet’,
string начинает- ‘alph’)
ся с подстроки
prefix. t
to_ascii(
text
string text [,
encoding text]) Преобразует
to_ascii(
string в ASCII ‘Karel’)
из
кодировки
encoding (поддер-
живаются
толь-
ко LATIN1, LATIN2,
LATIN9 и WIN1250) Karel
to_hex( number
int или bigint) Преобразует чис- to_hex(
ло number в 16-рич- 2147483647)
ный вид 7fffffff
Заменяет симво- translate(
лы в string, най- ‘12345’, ‘143’,
денные в наборе ‘ax’)
from, на соответ-
ствующие симво-
лы в множестве to.
Если строка from
длиннее to, най-
денные в исход-
ной строке лиш-
ние символы from
удаляются. a2x5
text
translate(
text
string
text,
from text, to
text)
Функции concat, concat_ws и format принимают переменное число аргументов, так что им для
объединения или форматирования можно передавать значения в виде массива, помеченного клю-
чевым словом VARIADIC (см. Подраздел 38.5.5). Элементы такого массива обрабатываются, как ес-
ли бы они были обычными аргументами функции. Если вместо массива в соответствующем аргу-
менте передаётся NULL, функции concat и concat_ws возвращают NULL, а format воспринимает
NULL как массив нулевого размера.
См. также агрегатную функцию string_agg в Разделе 9.20.
Таблица 9.10. Встроенные преобразования
Имя преобразования
a
Исходная кодировка Целевая кодировка
ascii_to_mic SQL_ASCII MULE_INTERNAL
ascii_to_utf8 SQL_ASCII UTF8
big5&lt;em&gt;to_euc_tw BIG5 EUC_TW
big5_to_mic BIG5 MULE_INTERNAL
big5_to_utf8 BIG5 UTF8
euc_cn_to_mic EUC_CN MULE_INTERNAL
euc_cn_to_utf8 EUC_CN UTF8
euc_jp_to_mic EUC_JP MULE_INTERNAL
euc_jp_to_sjis EUC_JP SJIS
197Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
euc_jp_to_utf8 EUC_JP UTF8
euc_kr_to_mic EUC_KR MULE_INTERNAL
euc_kr_to_utf8 EUC_KR UTF8
euc_tw_to_big5 EUC_TW BIG5
euc_tw_to_mic EUC_TW MULE_INTERNAL
euc_tw_to_utf8 EUC_TW UTF8
gb18030_to_utf8 GB18030 UTF8
gbk_to_utf8 GBK UTF8
iso_8859_10_to_utf8 LATIN6 UTF8
iso_8859_13_to_utf8 LATIN7 UTF8
iso_8859_14_to_utf8 LATIN8 UTF8
iso_8859_15_to_utf8 LATIN9 UTF8
iso_8859_16_to_utf8 LATIN10 UTF8
iso_8859_1_to_mic LATIN1 MULE_INTERNAL
iso_8859_1_to_utf8 LATIN1 UTF8
iso_8859_2_to_mic LATIN2 MULE_INTERNAL
iso_8859_2_to_utf8 LATIN2 UTF8
iso_8859_2_to_windows&lt;/em&gt;
1250 LATIN2 WIN1250
iso_8859&lt;em&gt;3_to_mic LATIN3 MULE_INTERNAL
iso_8859_3_to_utf8 LATIN3 UTF8
iso_8859_4_to_mic LATIN4 MULE_INTERNAL
iso_8859_4_to_utf8 LATIN4 UTF8
iso_8859_5_to_koi8_r ISO_8859_5 KOI8R
iso_8859_5_to_mic ISO_8859_5 MULE_INTERNAL
iso_8859_5_to_utf8 ISO_8859_5 UTF8
iso_8859_5_to_windows&lt;/em&gt;
1251 ISO_8859&lt;em&gt;5 WIN1251
iso_8859_5_to_windows&lt;/em&gt;
866 ISO_8859&lt;em&gt;5 WIN866
iso_8859_6_to_utf8 ISO_8859_6 UTF8
iso_8859_7_to_utf8 ISO_8859_7 UTF8
iso_8859_8_to_utf8 ISO_8859_8 UTF8
iso_8859_9_to_utf8 LATIN5 UTF8
johab_to_utf8 JOHAB UTF8
koi8_r_to_iso_8859_5 KOI8R ISO_8859_5
koi8_r_to_mic KOI8R MULE_INTERNAL
koi8_r_to_utf8 KOI8R UTF8
koi8_r_to_windows_1251 KOI8R WIN1251
koi8_r_to_windows_866 KOI8R WIN866
koi8_u_to_utf8 KOI8U UTF8
198Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
mic_to_ascii MULE_INTERNAL SQL_ASCII
mic_to_big5 MULE_INTERNAL BIG5
mic_to_euc_cn MULE_INTERNAL EUC_CN
mic_to_euc_jp MULE_INTERNAL EUC_JP
mic_to_euc_kr MULE_INTERNAL EUC_KR
mic_to_euc_tw MULE_INTERNAL EUC_TW
mic_to_iso_8859_1 MULE_INTERNAL LATIN1
mic_to_iso_8859_2 MULE_INTERNAL LATIN2
mic_to_iso_8859_3 MULE_INTERNAL LATIN3
mic_to_iso_8859_4 MULE_INTERNAL LATIN4
mic_to_iso_8859_5 MULE_INTERNAL ISO_8859_5
mic_to_koi8_r MULE_INTERNAL KOI8R
mic_to_sjis MULE_INTERNAL SJIS
mic_to_windows_1250 MULE_INTERNAL WIN1250
mic_to_windows_1251 MULE_INTERNAL WIN1251
mic_to_windows_866 MULE_INTERNAL WIN866
sjis_to_euc_jp SJIS EUC_JP
sjis_to_mic SJIS MULE_INTERNAL
sjis_to_utf8 SJIS UTF8
tcvn_to_utf8 WIN1258 UTF8
uhc_to_utf8 UHC UTF8
utf8_to_ascii UTF8 SQL_ASCII
utf8_to_big5 UTF8 BIG5
utf8_to_euc_cn UTF8 EUC_CN
utf8_to_euc_jp UTF8 EUC_JP
utf8_to_euc_kr UTF8 EUC_KR
utf8_to_euc_tw UTF8 EUC_TW
utf8_to_gb18030 UTF8 GB18030
utf8_to_gbk UTF8 GBK
utf8_to_iso_8859_1 UTF8 LATIN1
utf8_to_iso_8859_10 UTF8 LATIN6
utf8_to_iso_8859_13 UTF8 LATIN7
utf8_to_iso_8859_14 UTF8 LATIN8
utf8_to_iso_8859_15 UTF8 LATIN9
utf8_to_iso_8859_16 UTF8 LATIN10
utf8_to_iso_8859_2 UTF8 LATIN2
utf8_to_iso_8859_3 UTF8 LATIN3
utf8_to_iso_8859_4 UTF8 LATIN4
utf8_to_iso_8859_5 UTF8 ISO_8859_5
utf8_to_iso_8859_6 UTF8 ISO_8859_6
199Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
utf8_to_iso_8859_7 UTF8 ISO_8859_7
utf8_to_iso_8859_8 UTF8 ISO_8859_8
utf8_to_iso_8859_9 UTF8 LATIN5
utf8_to_johab UTF8 JOHAB
utf8_to_koi8_r UTF8 KOI8R
utf8_to_koi8_u UTF8 KOI8U
utf8_to_sjis UTF8 SJIS
utf8_to_tcvn UTF8 WIN1258
utf8_to_uhc UTF8 UHC
utf8_to_windows_1250 UTF8 WIN1250
utf8_to_windows_1251 UTF8 WIN1251
utf8_to_windows_1252 UTF8 WIN1252
utf8_to_windows_1253 UTF8 WIN1253
utf8_to_windows_1254 UTF8 WIN1254
utf8_to_windows_1255 UTF8 WIN1255
utf8_to_windows_1256 UTF8 WIN1256
utf8_to_windows_1257 UTF8 WIN1257
utf8_to_windows_866 UTF8 WIN866
utf8_to_windows_874 UTF8 WIN874
windows_1250_to_iso&lt;/em&gt;
8859&lt;em&gt;2 WIN1250 LATIN2
windows_1250_to_mic WIN1250 MULE_INTERNAL
windows_1250_to_utf8 WIN1250 UTF8
windows_1251_to_iso&lt;/em&gt;
8859&lt;em&gt;5 WIN1251 ISO_8859_5
windows_1251_to_koi8_r WIN1251 KOI8R
windows_1251_to_mic WIN1251 MULE_INTERNAL
windows_1251_to_utf8 WIN1251 UTF8
windows_1251_to_windows&lt;/em&gt;
866 WIN1251 WIN866
windows_1252&lt;em&gt;to_utf8 WIN1252 UTF8
windows_1256_to_utf8 WIN1256 UTF8
windows_866_to_iso_8859&lt;/em&gt;
5 WIN866 ISO_8859&lt;em&gt;5
windows_866_to_koi8_r WIN866 KOI8R
windows_866_to_mic WIN866 MULE_INTERNAL
windows_866_to_utf8 WIN866 UTF8
windows_866_to_windows&lt;/em&gt;
1251 WIN866 WIN
windows_874&lt;em&gt;to_utf8 WIN874 UTF8
euc_jis_2004_to_utf8 EUC_JIS_2004 UTF8
200Функции и операторы
Имя преобразования
a
Исходная кодировка Целевая кодировка
utf8_to_euc_jis_2004 UTF8 EUC_JIS_2004
shift_jis_2004_to_utf8 SHIFT_JIS_2004 UTF8
utf8_to_shift_jis_2004 UTF8 SHIFT_JIS_2004
euc_jis_2004_to_shift&lt;/em&gt;
jis_2004 EUC_JIS_2004 SHIFT_JIS_2004
shift_jis_2004&lt;em&gt;to_euc&lt;/em&gt;
jis_2004 SHIFT_JIS_2004 EUC_JIS_2004
a
Имена преобразований следуют стандартной схеме именования. К официальному названию исходной кодировки, в котором все не алфавитно-цифровые
символы заменяются подчёркиваниями, добавляется &lt;em&gt;to&lt;/em&gt;, а за ним аналогично подготовленное имя целевой кодировки. Таким образом, имена кодировок
могут не совпадать буквально с общепринятыми названиями.
9.4.1. format
Функция format выдаёт текст, отформатированный в соответствии со строкой формата, подобно
функции sprintf в C.
format(formatstr text [, formatarg “any” [, …] ])
formatstr — строка, определяющая, как будет форматироваться результат. Обычный текст в стро-
ке формата непосредственно копируется в результат, за исключением спецификаторов форма-
та. Спецификаторы формата представляют собой местозаполнители, определяющие, как долж-
ны форматироваться и выводиться в результате аргументы функции. Каждый аргумент formatarg
преобразуется в текст по правилам выводам своего типа данных, а затем форматируется и встав-
ляется в результирующую строку согласно спецификаторам формата.
Спецификаторы формата предваряются символом % и имеют форму
%[позиция][флаги][ширина]тип
Здесь:
позиция (необязателен)
Строка вида n$, где n — индекс выводимого аргумента. Индекс, равный 1, выбирает первый
аргумент после formatstr. Если позиция опускается, по умолчанию используется следующий
аргумент по порядку.
флаги (необязателен)
Дополнительные параметры, управляющие форматированием данного спецификатора. В на-
стоящее время поддерживается только знак минус (-), который выравнивает результата спе-
цификатора по левому краю. Он работает, только если также определена ширина.
ширина (необязателен)
Задаёт минимальное число символов, которое будет занимать результат данного спецификато-
ра. Выводимое значение выравнивается по правой или левой стороне (в зависимости от флага
-) с дополнением необходимым числом пробелов. Если ширина слишком мала, она просто иг-
норируется, т. е. результат не усекается. Ширину можно обозначить положительным целым,
звёздочкой (&lt;em&gt;), тогда ширина будет получена из следующего аргумента функции, или строкой
вида *n$, тогда ширина будет задаваться в n-ом аргументе функции.
Если ширина передаётся в аргументе функции, этот аргумент выбирается до аргумента, ис-
пользуемого для спецификатора. Если аргумент ширины отрицательный, результат выравни-
вается по левой стороне (как если бы был указан флаг -) в рамках поля длины abs(ширина).
тип (обязателен)
Тип спецификатора определяет преобразование соответствующего выводимого значения. Под-
держиваются следующие типы:
201Функции и операторы
• s форматирует значение аргумента как простую строку. Значение NULL представляется
пустой строкой.
• I обрабатывает значение аргумента как SQL-идентификатор, при необходимости заключая
его в кавычки. Значение NULL для такого преобразования считается ошибочным (так же,
как и для quote_ident).
• L заключает значение аргумента в апострофы, как строку SQL. Значение NULL выводится
буквально, как NULL, без кавычек (так же, как и с quote_nullable).
В дополнение к спецификаторам, описанным выше, можно использовать спецпоследовательность
%%, которая просто выведет символ %.
Несколько примеров простых преобразований формата:
SELECT format(‘Hello %s’, ‘World’);
Результат: Hello World
SELECT format(‘Testing %s, %s, %s, %%’, ‘one’, ‘two’, ‘three’);
Результат: Testing one, two, three, %
SELECT format(‘INSERT INTO %I VALUES(%L)’, ‘Foo bar’, E’O'Reilly’);
Результат: INSERT INTO “Foo bar” VALUES(‘O’‘Reilly’)
SELECT format(‘INSERT INTO %I VALUES(%L)’, ‘locations’, ‘C:\Program Files’);
Результат: INSERT INTO locations VALUES(‘C:\Program Files’)
Следующие примеры иллюстрируют использование поля ширина и флага -:
SELECT format(‘|%10s|’, ‘foo’);
Результат: |
foo|
SELECT format(‘|%-10s|’, ‘foo’);
Результат: |foo
|
SELECT format(‘|%&lt;/em&gt;s|’, 10, ‘foo’);
Результат: |
foo|
SELECT format(‘|%&lt;em&gt;s|’, -10, ‘foo’);
Результат: |foo
|
SELECT format(‘|%-&lt;/em&gt;s|’, 10, ‘foo’);
Результат: |foo
|
SELECT format(‘|%-&lt;em&gt;s|’, -10, ‘foo’);
Результат: |foo
|
Эти примеры показывают применение полей позиция:
SELECT format(‘Testing %3$s, %2$s, %1$s’, ‘one’, ‘two’, ‘three’);
Результат: Testing three, two, one
SELECT format(‘|%&lt;/em&gt;2$s|’, ‘foo’, 10, ‘bar’);
Результат: |
bar|
SELECT format(‘|%1$*2$s|’, ‘foo’, 10, ‘bar’);
Результат: |
foo|
В отличие от стандартной функции C sprintf, функция format в PostgreSQL позволяет комбиниро-
вать в одной строке спецификаторы с полями позиция и без них. Спецификатор формата без поля
202Функции и операторы
позиция всегда использует следующий аргумент после последнего выбранного. Кроме того, функ-
ция format не требует, чтобы в строке формата использовались все аргументы функции. Пример
этого поведения:
SELECT format(‘Testing %3$s, %2$s, %s’, ‘one’, ‘two’, ‘three’);
Результат: Testing three, two, three
Спецификаторы формата %I и %L особенно полезны для безопасного составления динамических
операторов SQL. См. Пример 43.1.
9.5. Функции и операторы двоичных строк
В этом разделе описываются функции и операторы для работы с данными типа bytea.
В SQL определены несколько строковых функций, в которых аргументы разделяются не запятыми,
а ключевыми словами. Подробнее это описано в Таблице 9.11. PostgreSQL также предоставляет
варианты этих функций с синтаксисом, обычным для функций (см. Таблицу 9.12).
Примечание
В примерах, приведённых на этой странице, подразумевается, что параметр сервера
bytea_output равен escape (выбран традиционный формат PostgreSQL).
Таблица 9.11. SQL-функции и операторы для работы с двоичными строками
Функция
Тип результата
Описание Пример
string || string bytea Конкатенация
строк ‘\Post’::bytea \Post’gres\000
||
‘\047gres
\000’::bytea
octet_length(
string) Число байт в дво- octet_length(
ичной строке
‘jo
\000se’::bytea)
int
Результат
5
overlay( string bytea
placing
string
from
int
[for
int]) Заменяет подстро- overlay(
T\002\003mas
ку
‘Th
\000omas’::bytea
placing
‘\002\003’::bytea
from 2 for 3)
position(
substring
string) Положение
ука- position(
3
занной подстроки ‘\000om’::bytea
in
‘Th
\000omas’::bytea)
int
in
substring(
bytea
string
[from
int] [for int]) Извлекает
строку
trim([both]
bytes
string) Удаляет наиболь-
шую строку, со-
держащую только
байты, заданные в
параметре bytes, с
начала и с конца
строки string
bytea
from
203
под- substring(
h\000o
‘Th
\000omas’::bytea
from 2 for 3)
trim(
Tom
‘\000\001’::bytea
from
‘\000Tom
\001’::bytea)Функции и операторы
В PostgreSQL есть и другие функции для работы с двоичными строками, перечисленные в Табли-
це 9.12. Некоторые из них используются в качестве внутренней реализации стандартных функций
SQL, приведённых в Таблице 9.11.
Таблица 9.12. Другие функции для работы с двоичными строками
Функция
Тип результата
Описание
Пример
Результат
btrim( string
bytea
bytea,
bytes
bytea) Удаляет наиболь- btrim(
trim
шую строку, со- ‘\000trim
держащую только \001’::bytea,
байты, заданные в ‘\000\001’::bytea)
параметре bytes, с
начала и с конца
строки string
decode( string
bytea
text,
format
text) Получает двоич- decode(
ные данные из тек- ‘123\000456’,
стового представ- ‘escape’)
ления в string.
Значения
пара-
метра format те
же, что и для
функции encode.
encode( data
text
bytea,
format
text) Переводит двоич- encode(
123\000456
ные данные в тек- ‘123\000456’::bytea,
стовое представле- ‘escape’)
ние в одном из
форматов: base64,
hex, escape. Фор-
мат escape пре-
образует нулевые
байты и байты
с 1 в старшем
бите
в
восьме-
ричные последова-
тельности \nnn и
дублирует обрат-
ную косую черту.
get_bit(
string, Извлекает бит из get_bit(
1
строки
‘Th
\000omas’::bytea,
45)
int
offset)
123\000456
get_byte(
int
string, offset) Извлекает байт из get_byte(
109
строки
‘Th
\000omas’::bytea,
4)
length( string) int Длина
строки
md5( string) text Вычисляет MD5- md5(
8ab2d3c9689aaf18
хеш строки string ‘Th
b4958c334c82d8b1
и возвращает ре- \000omas’::bytea)
зультат в 16-рич-
ном виде
204
двоичной length(
‘jo
\000se’::bytea)
5Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
set_bit(
bytea
string, offset,
newvalue) Устанавливает
значение бита
строке set_byte(
bytea
string, offset,
newvalue) Устанавливает
set_byte(
Th\000o@as
значение байта в ‘Th
строке
\000omas’::bytea,
4, 64)
sha224( bytea) bytea Хеш SHA-224 sha224(‘abc’) \x23097d223405d8228642
55b32aadbce4bda0b3f
7e36c9da7
sha256( bytea) bytea Хеш SHA-256 sha256(‘abc’) \xba7816bf8f01cfea4141
b00361a396177a9
cb410ff61f20015ad
sha384( bytea) bytea Хеш SHA-384 sha384(‘abc’) \xcb00753f45a35e8bb5a0
272c32ab0eded16
31a8b605a43ff5bed
8086072ba1e7cc2358baec
sha512( bytea) bytea Хеш SHA-512 sha512(‘abc’) \xddaf35a193617abacc41
12e6fa4e89a97ea
20a9eeee64b55d39a
2192992a274fc1a836ba3c
454d4423643ce80e2a9ac9
set_bit(
Th\000omAs
в ‘Th
\000omas’::bytea,
45, 0)
Для функций get_byte и set_byte байты нумеруется с 0. Функции get_bit и set_bit нумеруют
биты справа налево; например, бит 0 будет меньшим значащим битом первого байта, а бит 15 —
большим значащим битом второго байта.
Заметьте, что по историческим причинам функция md5 возвращает значение в шестнадцатерич-
ном виде в типе text, тогда как функции SHA-2 возвращают тип bytea. Используйте функции
encode и decode для преобразования значений из одного представления в другое. Например, вы-
звав encode(sha256(‘abc’), ‘hex’), вы получите значение в шестнадцатеричном виде в строке.
См. также агрегатную функцию string_agg в Разделе 9.20 и функции для работы с большими объ-
ектами в Разделе 35.4.
9.6. Функции и операторы для работы с битовыми
строками
В этом разделе описываются функции и операторы, предназначенные для работы с битовыми стро-
ками, то есть с данными типов bit и bit varying. Помимо обычных операторов сравнения, с таки-
ми данными можно использовать операторы, перечисленные в Таблице 9.13. Заметьте, что опера-
торы &amp;amp;, | и # работают только с двоичными строками одинаковой длины. Операторы побитового
сдвига сохраняют длины исходных строк, как показано в примерах.
Таблица 9.13. Операторы для работы с битовыми строками
Оператор Описание Пример Результат
|| конкатенация B’10001’ || B’011’ 10001011
&amp;amp; битовый AND B’10001’ &amp;amp; B’01101’ 00001
| битовый OR B’10001’ | B’01101’ 11101&lt;/p&gt;
        &lt;h1 id=&quot;битовый-xor-b10001--b01101-11100&quot;&gt;битовый XOR B’10001’ # B’01101’ 11100&lt;/h1&gt;
        &lt;p&gt;205Функции и операторы
Оператор Описание Пример Результат
~ битовый NOT ~ B’10001’ 01110
« битовый сдвиг влево B’10001’ « 3 01000
битовый сдвиг вправо B’10001’ » 2 00100
Следующие функции языка SQL работают как с символьными, так и с битовыми строками: length,
bit_length, octet_length, position, substring, overlay.
С битовыми и двоичными строками работают функции get_bit и set_bit. При работе с битовыми
строками эти функции нумеруют биты слева направо и самый левый бит считается нулевым.
Кроме того, целые значения можно преобразовать в тип bit и обратно. Например:
44::bit(10)
44::bit(3)
cast(-44 as bit(12))
‘1110’::bit(4)::integer
0000101100
100
111111010100
14
Заметьте, что приведение к типу «bit» без длины будет означать приведение к bit(1), и в резуль-
тате будет получен только один менее значащий бит числа.
Примечание
Приведение целого числа к типу bit(n) копирует правые n бит числа. Если же целое
преобразуется в битовую строку большей длины, чем требуется для этого числа, она
дополняется слева битами знака числа.
9.7. Поиск по шаблону
PostgreSQL предлагает три разных способа поиска текста по шаблону: традиционный оператор
LIKE языка SQL, более современный SIMILAR TO (добавленный в SQL:1999) и регулярные выраже-
ния в стиле POSIX. Помимо простых операторов, отвечающих на вопрос «соответствует ли строка
этому шаблону?», в PostgreSQL есть функции для извлечения или замены соответствующих под-
строк и для разделения строки по заданному шаблону.
Подсказка
Если этих встроенных возможностей оказывается недостаточно, вы можете написать
собственные функции на языке Perl или Tcl.
Внимание
Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, регулярные
выражения бывают и настолько сложными, что их обработка может занять приличное
время и объём памяти. Поэтому опасайтесь шаблонов регулярных выражений, посту-
пающих из недоверенных источников. Если у вас нет другого выхода, рекомендуется
ввести тайм-аут для операторов.
Поиск с шаблонами SIMILAR TO несёт те же риски безопасности, так как конструкция
SIMILAR TO предоставляет во многом те же возможности, что и регулярные выражения
в стиле POSIX.
Поиск с LIKE гораздо проще, чем два другие варианта, поэтому его безопаснее исполь-
зовать с недоверенными источниками шаблонов поиска.
206Функции и операторы
9.7.1. LIKE
строка LIKE шаблон [ESCAPE спецсимвол]
строка NOT LIKE шаблон [ESCAPE спецсимвол]
Выражение LIKE возвращает true, если строка соответствует заданному шаблону. (Как можно было
ожидать, выражение NOT LIKE возвращает false, когда LIKE возвращает true, и наоборот. Этому
выражению равносильно выражение NOT (строка LIKE шаблон).)
Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет в точно-
сти строку и LIKE работает как оператор сравнения. Подчёркивание (&lt;em&gt;) в шаблоне подменяет (вме-
сто него подходит) любой символ; а знак процента (%) подменяет любую (в том числе и пустую)
последовательность символов.
Несколько примеров:
‘abc’
‘abc’
‘abc’
‘abc’
LIKE
LIKE
LIKE
LIKE
‘abc’
‘a%’
‘_b&lt;/em&gt;’
‘c’
true
true
true
false
При проверке по шаблону LIKE всегда рассматривается вся строка. Поэтому, если нужно найти по-
следовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться
знаками процента.
Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответ-
ствующим символом в шаблоне нужно добавить спецсимвол. По умолчанию в качестве спецсимво-
ла выбрана обратная косая черта, но с помощью предложения ESCAPE можно выбрать и другой.
Чтобы включить спецсимвол в шаблон поиска, продублируйте его.
Примечание
Если параметр standard_conforming_strings выключен, каждый символ обратной косой
черты, записываемый в текстовой константе, нужно дублировать. Подробнее это опи-
сано в Подразделе 4.1.2.1.
Также можно отказаться от спецсимвола, написав ESCAPE ‘’. При этом механизм спецпоследова-
тельностей фактически отключается и использовать знаки процента и подчёркивания буквально
в шаблоне нельзя.
Вместо LIKE можно использовать ключевое слово ILIKE, чтобы поиск был регистр-независимым
с учётом текущей языковой среды. Этот оператор не описан в стандарте SQL; это расширение
PostgreSQL.
Кроме того, в PostgreSQL есть оператор &lt;del&gt;, равнозначный LIKE, и ~~*, соответствующий ILIKE.
Есть также два оператора !&lt;/del&gt; и !~~&lt;em&gt;, представляющие NOT LIKE и NOT ILIKE, соответственно. Все
эти операторы можно отнести к особенностям PostgreSQL.
Также существует оператор проверки префикса ^@ и соответствующая функция starts_with, ко-
торые покрывают случаи, когда нужно выполнить поиск только по началу строки.
9.7.2. Регулярные выражения SIMILAR TO
строка SIMILAR TO шаблон [ESCAPE спецсимвол]
строка NOT SIMILAR TO шаблон [ESCAPE спецсимвол]
Оператор SIMILAR TO возвращает true или false в зависимости от того, соответствует ли данная
строка шаблону или нет. Он работает подобно оператору LIKE, только его шаблоны соответствуют
определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют
собой любопытный гибрид синтаксиса LIKE с синтаксисом обычных регулярных выражений.
207Функции и операторы
Как и LIKE, условие SIMILAR TO истинно, только если шаблон соответствует всей строке; это отли-
чается от условий с регулярными выражениями, в которых шаблон может соответствовать любой
части строки. Также подобно LIKE, SIMILAR TO воспринимает символы _ и % как знаки подстанов-
ки, подменяющие любой один символ или любую подстроку, соответственно (в регулярных выра-
жениях POSIX им аналогичны символы . и .&lt;/em&gt;).
Помимо средств описания шаблонов, позаимствованных от LIKE, SIMILAR TO поддерживает следу-
ющие метасимволы, унаследованные от регулярных выражений POSIX:
• | означает выбор (одного из двух вариантов).
• * означает повторение предыдущего элемента 0 и более раз.
• + означает повторение предыдущего элемента 1 и более раз.
• ? означает вхождение предыдущего элемента 0 или 1 раз.
• (m) означает повторяет предыдущего элемента ровно m раз.
• (m,) означает повторение предыдущего элемента m или более раз.
• (m,n) означает повторение предыдущего элемента не менее чем m и не более чем n раз.
• Скобки () объединяют несколько элементов в одну логическую группу.
• Квадратные скобки […] обозначают класс символов так же, как и в регулярных выражениях
POSIX.
Обратите внимание, точка (.) не является метасимволом для оператора SIMILAR TO.
Как и с LIKE, обратная косая черта отменяет специальное значение любого из этих метасимволов,
а предложение ESCAPE позволяет выбрать другой спецсимвол.
Несколько примеров:
‘abc’
‘abc’
‘abc’
‘abc’
SIMILAR
SIMILAR
SIMILAR
SIMILAR
TO
TO
TO
TO
‘abc’
‘a’
‘%(b|d)%’
‘(b|c)%’
true
false
true
false
Функция substring с тремя параметрами, substring(строка from шаблон for спецсимвол) из-
влекает подстроку, соответствующую шаблону регулярного выражения SQL. Как и с SIMILAR TO,
указанному шаблону должна соответствовать вся строка, в противном случае функция не найдёт
ничего и вернёт NULL. Для обозначения части шаблона, которая должна быть возвращена в слу-
чае успеха, шаблон должен содержать два спецсимвола и кавычки (“) после каждого. Эта функция
возвращает часть шаблона между двумя такими маркерами.
Несколько примеров с маркерами #”, выделяющими возвращаемую строку:
substring(‘foobar’ from ‘%#”o_b#”%’ for ‘#’)
substring(‘foobar’ from ‘#”o_b#”%’ for ‘#’)
oob
NULL
9.7.3. Регулярные выражения POSIX
В Таблице 9.14 перечислены все существующие операторы для проверки строк регулярными вы-
ражениями POSIX.
Таблица 9.14. Операторы регулярных выражений
Оператор Описание
Пример
~ Проверяет соответствие регу- ‘thomas’ ~ ‘.&lt;em&gt;thomas.&lt;/em&gt;’
лярному выражению с учётом
регистра
~* Проверяет соответствие регу- ‘thomas’ ~* ‘.&lt;em&gt;Thomas.&lt;/em&gt;’
лярному выражению без учёта
регистра
208Функции и операторы
Оператор Описание
Пример
!~ Проверяет несоответствие регу- ‘thomas’ !~ ‘.&lt;em&gt;Thomas.&lt;/em&gt;’
лярному выражению с учётом
регистра
!~* Проверяет несоответствие регу- ‘thomas’ !~* ‘.&lt;em&gt;vadim.&lt;/em&gt;’
лярному выражению без учёта
регистра
Регулярные выражения POSIX предоставляют более мощные средства поиска по шаблонам, чем
операторы LIKE и SIMILAR TO. Во многих командах Unix, таких как egrep, sed и awk используется
язык шаблонов, похожий на описанный здесь.
Регулярное выражение — это последовательность символов, представляющая собой краткое опре-
деление набора строк (регулярное множество). Строка считается соответствующей регулярному
выражению, если она является членом регулярного множества, описываемого регулярным выра-
жением. Как и для LIKE, символы шаблона непосредственно соответствуют символам строки, за
исключением специальных символов языка регулярных выражений. При этом спецсимволы регу-
лярных выражений отличается от спецсимволов LIKE. В отличие от шаблонов LIKE, регулярное
выражение может совпадать с любой частью строки, если только оно не привязано явно к началу
и/или концу строки.
Несколько примеров:
‘abc’
‘abc’
‘abc’
‘abc’
~
~
~
~
‘abc’
‘^a’
‘(b|d)’
‘^(b|c)’
true
true
true
false
Более подробно язык шаблонов в стиле POSIX описан ниже.
Функция substring с двумя параметрами, substring(строка from шаблон), извлекает подстроку,
соответствующую шаблону регулярного выражения POSIX. Она возвращает фрагмент текста, под-
ходящий шаблону, если таковой находится в строке, либо NULL в противном случае. Но если шаб-
лон содержит скобки, она возвращает первое подвыражение, заключённое в скобки (то, которое
начинается с самой первой открывающей скобки). Если вы хотите использовать скобки, но не в
таком особом режиме, можно просто заключить в них всё выражение. Если же вам нужно вклю-
чить скобки в шаблон до подвыражения, которое вы хотите извлечь, это можно сделать, используя
группы без захвата, которые будут описаны ниже.
Несколько примеров:
substring(‘foobar’ from ‘o.b’)
substring(‘foobar’ from ‘o(.)b’)
oob
o
Функция regexp_replace подставляет другой текст вместо подстрок, соответствующих шаблонам
регулярных выражений POSIX. Она имеет синтаксис regexp_replace(исходная_строка, шаблон, за-
мена [, флаги]). Если исходная_строка не содержит фрагмента, подходящего под шаблон, она воз-
вращается неизменной. Если же соответствие находится, возвращается исходная_строка, в кото-
рой вместо соответствующего фрагмента подставляется замена. Строка замена может содержать
\n, где n — число от 1 до 9, указывающее на исходный фрагмент, соответствующий n-ому подвы-
ражению в скобках, и может содержать обозначение \&amp;amp;, указывающее, что будет вставлен фраг-
мент, соответствующий всему шаблону. Если же в текст замены нужно включить обратную косую
черту буквально, следует написать \. В необязательном параметре флаги передаётся текстовая
строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Флаг
i включает поиск без учёта регистра, а флаг g указывает, что заменяться должны все подходящие
подстроки, а не только первая из них. Допустимые флаги (кроме g) описаны в Таблице 9.22.
Несколько примеров:
209Функции и операторы
regexp_replace(‘foobarbaz’, ‘b..’, ‘X’)
fooXbaz
regexp_replace(‘foobarbaz’, ‘b..’, ‘X’, ‘g’)
fooXX
regexp_replace(‘foobarbaz’, ‘b(..)’, ‘X\1Y’, ‘g’)
fooXarYXazY
Функция regexp_match возвращает текстовый массив из всех подходящих подстрок, полученных
из первого вхождения шаблона регулярного выражения POSIX в строке. Она имеет синтаксис
regexp_match(строка, шаблон [, флаги]). Если вхождение не находится, результатом будет NULL. Ес-
ли вхождение находится и шаблон не содержит подвыражений в скобках, результатом будет тек-
стовый массив с одним элементом, содержащим подстроку, соответствующую всему шаблону. Если
вхождение находится и шаблон содержит подвыражения в скобках, результатом будет текстовый
массив, в котором n-ым элементом будет n-ое заключённое в скобки подвыражение шаблона (не
считая «незахватывающих» скобок; подробнее см. ниже). В параметре флаги передаётся необяза-
тельная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведе-
ние функции. Допустимые флаги описаны в Таблице 9.22.
Некоторые примеры:
SELECT regexp_match(‘foobarbequebaz’, ‘bar.&lt;em&gt;que’);
regexp_match
————–
(barbeque)
(1 row)
SELECT regexp_match(‘foobarbequebaz’, ‘(bar)(beque)’);
regexp_match
————–
(bar,beque)
(1 row)
В общем случае просто получить всю найденную подстроку или NULL, если нет соответствия, можно
примерно так:
SELECT (regexp_match(‘foobarbequebaz’, ‘bar.&lt;/em&gt;que’))[1];
regexp_match
————–
barbeque
(1 row)
Функция regexp_matches возвращает набор текстовых массивов со всеми подходящими подстро-
ками, полученными в результате применения регулярного выражения POSIX к строке. Она имеет
тот же синтаксис, что и regexp_match. Эта функция не возвращает никаких строк, если вхождений
нет; возвращает одну строку, если найдено одно вхождение и не передан флаг g, или N строк, если
найдено N вхождений и передан флаг g. Каждая возвращаемая строка представляет собой тексто-
вый массив, содержащий всю найденную подстроку или подстроки, соответствующие заключён-
ным в скобки подвыражениям шаблона, как и описанный выше результат regexp_match. Функция
regexp_matches принимает все флаги, показанные в Таблице 9.22, а также флаг g, указывающий
ей выдать все вхождения, а не только первое.
Несколько примеров:
SELECT regexp_matches(‘foo’, ‘not there’);
regexp_matches
—————-
(0 rows)
SELECT regexp_matches(‘foobarbequebazilbarfbonk’, ‘(b[^b]+)(b[^b]+)’, ‘g’);
regexp_matches
210Функции и операторы
—————-
(bar,beque)
(bazil,barf)
(2 rows)
Подсказка
В большинстве случаев regexp_matches() должна применяться с флагом g, так как ес-
ли вас интересует только первое вхождение, проще и эффективнее использовать функ-
цию regexp_match(). Однако regexp_match() существует только в PostgreSQL версии
10 и выше. В старых версиях обычно помещали вызов regexp_matches() во вложенный
SELECT, например, так:
SELECT col1, (SELECT regexp_matches(col2, ‘(bar)(beque)’)) FROM tab;
В результате выдаётся текстовый массив, если вхождение найдено, или NULL в против-
ном случае, так же как с regexp_match(). Без вложенного SELECT этот запрос не воз-
вращает никакие строки, если соответствие не находится, а это обычно не то, что нуж-
но.
Функция regexp_split_to_table разделяет строку, используя в качестве разделителя шаблон ре-
гулярного выражения POSIX. Она имеет синтаксис regexp_split_to_table(строка, шаблон [, фла-
ги]). Если шаблон не находится в переданной строке, возвращается вся строка целиком. Если на-
ходится минимум одно вхождение, для каждого такого вхождения возвращается текст от конца
предыдущего вхождения (или начала строки) до начала вхождения. После последнего найденного
вхождения возвращается фрагмент от его конца до конца строки. В необязательном параметре
флаги передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняю-
щих поведение функции. Флаги, которые поддерживает regexp_split_to_table, описаны в Табли-
це 9.22.
Функция regexp_split_to_array ведёт себя подобно regexp_split_to_table, за исключением то-
го, что regexp_split_to_array возвращает результат в массиве элементов типа text. Она имеет
синтаксис regexp_split_to_array(строка, шаблон [, флаги]). Параметры у этой функции те же, что
и у regexp_split_to_table.
Несколько примеров:
SELECT foo FROM regexp_split_to_table(‘the quick brown fox jumps over the lazy dog’,
‘\s+’) AS foo;
foo
——-
the
quick
brown
fox
jumps
over
the
lazy
dog
(9 rows)
SELECT regexp_split_to_array(‘the quick brown fox jumps over the lazy dog’, ‘\s+’);
regexp_split_to_array
———————————————–
(the,quick,brown,fox,jumps,over,the,lazy,dog)
(1 row)
211Функции и операторы
SELECT foo FROM regexp_split_to_table(‘the quick brown fox’, ‘\s*’) AS foo;
foo
—–
t
h
e
q
u
i
c
k
b
r
o
w
n
f
o
x
(16 rows)
Как показывает последний пример, функции разделения по регулярным выражениям игнорируют
вхождения нулевой длины, идущие в начале и в конце строки, а также непосредственно за преды-
дущим вхождением. Это поведение противоречит строгому определению поиска по регулярным
выражениям, который реализуют функции regexp_match и regexp_matches, но обычно более удоб-
но на практике. Подобное поведение наблюдается и в других программных средах, например в Perl.
9.7.3.1. Подробное описание регулярных выражений
Регулярные выражения в PostgreSQL реализованы с использованием программного пакета, кото-
рый разработал Генри Спенсер (Henry Spencer). Практически всё следующее описание регуляр-
ных выражений дословно скопировано из его руководства.
Регулярное выражение (Regular expression, RE), согласно определению в POSIX 1003.2, может
иметь две формы: расширенное RE или ERE (грубо говоря, это выражения, которые понимает
egrep) и простое RE или BRE (грубо говоря, это выражения для ed). PostgreSQL поддерживает обе
формы, а кроме того реализует некоторые расширения, не предусмотренные стандартом POSIX,
но широко используемые вследствие их доступности в некоторых языках программирования, на-
пример в Perl и Tcl. Регулярные выражения, использующие эти несовместимые с POSIX расшире-
ния, здесь называются усовершенствованными RE или ARE. ARE практически представляют со-
бой надмножество ERE, тогда как BRE отличаются некоторой несовместимостью в записи (помимо
того, что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, отметив особен-
ности, присущие только ARE, а затем расскажем, чем от них отличаются BRE.
Примечание
PostgreSQL изначально всегда предполагает, что регулярное выражение следует пра-
вилам ARE. Однако можно переключиться на более ограниченные правила ERE или
BRE, добавив в шаблон RE встроенный параметр, как описано в Подразделе 9.7.3.4.
Это может быть полезно для совместимости с приложениями, ожидающими от СУБД
строгого следования правилам POSIX 1003.2.
Регулярное выражение определяется как одна или более ветвей, разделённых символами |. Оно
считается соответствующим всему, что соответствует одной из этих ветвей.
Ветвь — это ноль или несколько количественных атомов или ограничений, соединённых вместе.
Соответствие ветви в целом образуется из соответствия первой части, за которым следует соот-
ветствие второй части и т. д.; пустой ветви соответствует пустая строка.
212Функции и операторы
Количественный атом — это атом, за которым может следовать определитель количества. Без
этого определителя ему соответствует одно вхождение атома. С определителем количества ему
может соответствовать некоторое число вхождений этого атома. Все возможные атомы перечис-
лены в Таблице 9.15. Варианты определителей количества и их значения перечислены в Табли-
це 9.16.
Ограничению соответствует пустая строка, но это соответствие возможно только при выполнении
определённых условий. Ограничения могут использоваться там же, где и атомы, за исключением
того, что их нельзя дополнять определителями количества. Простые ограничения показаны в Таб-
лице 9.17; некоторые дополнительные ограничения описаны ниже.
Таблица 9.15. Атомы регулярных выражений
Атом Описание
( re) (где re — любое регулярное выражение) описы-
вает соответствие re, при этом данное соответ-
ствие захватывается для последующей обработ-
ки
(?: re) подобно предыдущему, но соответствие не за-
хватывается (т. е. это набор скобок «без захва-
та») (применимо только к ARE)
. соответствует любому символу
[символы] выражение в квадратных скобках, соответству-
ет любому из символов (подробнее это описано в
Подразделе 9.7.3.2)
\k (где k — не алфавитно-цифровой символ) соот-
ветствует обычному символу буквально, т. е. &lt;br /&gt;
соответствует обратной косой черте
\c где c — алфавитно-цифровой символ (за которым
могут следовать другие символы), это спецсим-
вол, см. Подраздел  9.7.3.3 (применим только к
ARE; в ERE и BRE этому атому соответствует c)
( когда за этим символом следует любой символ,
кроме цифры, этот атом соответствует левой фи-
гурной скобке ((), если же за ним следует циф-
ра, это обозначает начало границы (см. ниже)
x (где x — один символ, не имеющий специального
значения) соответствует этому символу
Выражение RE не может заканчиваться обратной косой чертой ().
Примечание
Если параметр standard_conforming_strings выключен, каждый символ обратной косой
черты, записываемый в текстовой константе, нужно дублировать. Подробнее это опи-
сано в Подразделе 4.1.2.1.
Таблица 9.16. Определители количества в регулярных выражениях
Определитель Соответствует&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;0 или более вхождений атома&lt;/li&gt;
    &lt;li&gt;1 или более вхождений атома
? 0 или 1 вхождение атома
213Функции и операторы
Определитель Соответствует
(m) ровно m вхождений атома
(m,) m или более вхождений атома
(m, n) от m до n (включая границы) вхождений атома; m
не может быть больше n
&lt;em&gt;? не жадная версия *
+? не жадная версия +
?? не жадная версия ?
(m)? не жадная версия (m)
(m,)? не жадная версия (m,)
(m, n)? не жадная версия (m, n)
В формах с (…) числа m и n определяют так называемые границы количества. Эти числа должны
быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 включительно.
Не жадные определители (допустимые только в ARE) описывают те же возможные соответствия,
что и аналогичные им обычные («жадные»), но предпочитают выбирать наименьшее, а не наи-
большее количество вхождений. Подробнее это описано в Подразделе 9.7.3.5.
Примечание
Определители количества не могут следовать один за другим, например запись ** бу-
дет ошибочной. Кроме того, определители не могут стоять в начале выражения или
подвыражения и идти сразу после ^ или |.
Таблица 9.17. Ограничения в регулярных выражениях
Ограничение Описание
^ соответствует началу строки
$ соответствует концу строки
(?= re) позитивный просмотр вперёд находит соответ-
ствие там, где начинается подстрока, соответ-
ствующая re (только для ARE)
(?! re) негативный просмотр вперёд находит соответ-
ствие там, где не начинается подстрока, соот-
ветствующая re (только для ARE)
(?&amp;lt;= re) позитивный просмотр назад находит соответ-
ствие там, где заканчивается подстрока, соот-
ветствующая re (только для ARE)
(?&amp;lt;! re) негативный просмотр назад находит соответ-
ствие там, где не заканчивается подстрока, со-
ответствующая re (только для ARE)
Ограничения просмотра вперёд и назад не могут содержать ссылки назад (см. Подраздел 9.7.3.3),
и все скобки в них считаются «скобками без захвата».
9.7.3.2. Выражения в квадратных скобках
Выражение в квадратных скобках содержит список символов, заключённый в []. Обычно ему со-
ответствует любой символ из списка (об исключении написано ниже). Если список начинается с ^,
ему соответствует любой символ, который не перечисляется далее в этом списке. Если два символа
214Функции и операторы
в списке разделяются знаком -, это воспринимается как краткая запись полного интервала сим-
волов между двумя заданными (и включая их) в порядке сортировки; например выражению [0-9]
в ASCII соответствует любая десятичная цифра. Два интервала не могут разделять одну границу,
т. е. выражение a-c-e недопустимо. Интервалы зависят от порядка сортировки, который может
меняться, поэтому в переносимых программах их лучше не использовать.
Чтобы включить в список ], этот символ нужно написать первым (сразу за ^, если он присутствует).
Чтобы включить в список символ -, его нужно написать первым или последним, либо как вторую
границу интервала. Указать - в качестве первой границы интервал можно, заключив его между [.
и .], чтобы он стал элементом сортировки (см. ниже). За исключением этих символов, некоторых
комбинаций с [ (см. следующие абзацы) и спецсимволов (в ARE), все остальные специальные сим-
волы в квадратных скобках теряют своё особое значение. В частности, символ \ по правилам ERE
или BRE воспринимается как обычный, хотя в ARE он экранирует символ, следующий за ним.
Выражения в квадратных скобках могут содержать элемент сортировки (символ или последова-
тельность символов или имя такой последовательности), определение которого заключается меж-
ду [. и .]. Определяющая его последовательность воспринимается в выражении в скобках как
один элемент. Это позволяет включать в такие выражения элементы, соответствующие последо-
вательности нескольких символов. Например, с элементом сортировки ch в квадратных скобках
регулярному выражению [[.ch.]]&lt;/em&gt;c будут соответствовать первые пять символов строки chchcc.
Примечание
В настоящее время PostgreSQL не поддерживает элементы сортировки, состоящие из
нескольких символов. Эта информация относится к возможному в будущем поведению.
В квадратных скобках могут содержаться элементы сортировки, заключённые между [= и =], обо-
значающие классы эквивалентности, т. е. последовательности символов из всех элементов сорти-
ровки, эквивалентных указанному, включая его самого. (Если для этого символа нет эквивалент-
ных, он обрабатывается, как заключённый между [. и .].) Например, если е и ё — члены одного
класса эквивалентности, выражения [[=е=]], [[=ё=]] и [её] будут равнозначными. Класс эквива-
лентности нельзя указать в качестве границы интервала.
В квадратных скобках может также содержаться имя класса символов, заключённое между [: и
:], и заменяющее список всех символов этого класса. Стандартные имена классов: alnum, alpha,
blank, cntrl, digit, graph, lower, print, punct, space, upper и xdigit. Весь этот набор классов
определён в ctype и он может меняться в зависимости от локали (языковой среды). Класс символов
также нельзя использовать в качестве границы интервала.
Есть два особых вида выражений в квадратных скобках: выражения [[:&amp;lt;:]] и [[:&amp;gt;:]], представ-
ляющие собой ограничения, соответствующие пустым строкам в начале и конце слова. Слово в
данном контексте определяется как последовательность словосоставляющих символов, перед или
после которой нет словосоставляющих символов. Словосоставляющий символ — это символ клас-
са alnum (определённого в ctype) или подчёркивание. Это расширение совместимо со стандартом
POSIX 1003.2, но не описано в нём, и поэтому его следует использовать с осторожностью там, где
важна совместимость с другими системами. Обычно лучше использовать ограничивающие спец-
символы, описанные ниже; они также не совсем стандартны, но набрать их легче.
9.7.3.3. Спецсимволы регулярных выражений
Спецсимволы — это специальные команды, состоящие из \ и последующего алфавитно-цифрово-
го символа. Можно выделить следующие категории спецсимволов: обозначения символов, коды
классов, ограничения и ссылки назад. Символ \, за которым идёт алфавитно-цифровой символ,
не образующий допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет:
вне квадратных скобок пара из \ и последующего алфавитно-цифрового символа, воспринимается
просто как данный символ, а в квадратных скобках и сам символ \ воспринимается просто как
обратная косая черта. (Последнее на самом деле нарушает совместимость между ERE и ARE.)
215Функции и операторы
Спецобозначения символов введены для того, чтобы облегчить ввод в RE непечатаемых и других
неудобных символов. Они приведены в Таблице 9.18.
Коды классов представляют собой краткий способ записи имён некоторых распространённых клас-
сов символов. Они перечислены в Таблице 9.19.
Спецсимволы ограничений обозначают ограничения, которым при совпадении определённых
условий соответствует пустая строка. Они перечислены в Таблице 9.20.
Ссылка назад (\n) соответствует той же строке, какой соответствовало предыдущее подвыраже-
ние в скобках под номером n (см. Таблицу 9.21). Например, ([bc])\1 соответствует bb или cc, но
не bc или cb. Это подвыражение должно полностью предшествовать ссылке назад в RE. Нумеру-
ются подвыражения в порядке следования их открывающих скобок. При этом скобки без захвата
исключаются из рассмотрения.
Таблица 9.18. Спецобозначения символов в регулярных выражениях
Спецсимвол Описание
\a символ звонка, как в C
\b символ «забой», как в C
\B синоним для обратной косой черты (), сокраща-
ющий потребность в дублировании этого симво-
ла
\cX (где X — любой символ) символ, младшие 5 бит
которого те же, что и у X, а остальные равны 0
\e символ, определённый в последовательности
сортировки с именем ESC, либо, если таковой не
определён, символ с восьмеричным значением
033
\f подача формы, как в C
\n новая строка, как в C
\r возврат каретки, как в C
\t горизонтальная табуляция, как в C
\uwxyz (где wxyz ровно четыре шестнадцатеричные
цифры) символ с шестнадцатеричным кодом
0xwxyz
\Ustuvwxyz (где stuvwxyz ровно восемь шестнадцатерич-
ных цифр) символ с шестнадцатеричным кодом
0xstuvwxyz
\v вертикальная табуляция, как в C
\xhhh (где hhh — несколько шестнадцатеричных цифр)
символ с шестнадцатеричным кодом 0xhhh (сим-
вол всегда один вне зависимости от числа шест-
надцатеричных цифр)
\0 символ с кодом 0 (нулевой байт)
\xy (где xy — ровно две восьмеричных цифры, не
ссылка назад) символ с восьмеричным кодом 0xy
\xyz (где xyz — ровно три восьмеричных цифры, не
ссылка назад) символ с восьмеричным кодом
0xyz
Шестнадцатеричные цифры записываются символами 0-9 и a-f или A-F. Восьмеричные цифры —
цифры от 0 до 7.
216Функции и операторы
Спецпоследовательности с числовыми кодами, задающими значения вне диапазона ASCII (0-127),
воспринимаются по-разному в зависимости от кодировки базы данных. Когда база данных имеет
кодировку UTF-8, спецкод равнозначен позиции символа в Unicode, например, \u1234 обозначает
символ U+1234. Для других многобайтных кодировок спецпоследовательности обычно просто зада-
ют серию байт, определяющих символ. Если в кодировке базы данных отсутствует символ, задан-
ный спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей соответствовать.
Символы, переданные спецобозначением, всегда воспринимаются как обычные символы. Напри-
мер, \135 кодирует ] в ASCII, но спецпоследовательность \135 не будет закрывать выражение в
квадратных скобках.
Таблица 9.19. Спецкоды классов в регулярных выражениях
Спецсимвол Описание
\d [[:digit:]]
\s [[:space:]]
\w [[:alnum:]&lt;em&gt;] (подчёркивание также включает-
ся)
\D [^[:digit:]]
\S [^[:space:]]
\W [^[:alnum:]&lt;/em&gt;]
ется)
(подчёркивание также включа-
В выражениях в квадратных скобках спецсимволы \d, \s и \w теряют свои внешние квадрат-
ные скобки, а \D, \S и \W — недопустимы. (Так что, например запись [a-c\d] равнозначна [a-
c[:digit:]]. А запись [a-c\D], которая была бы равнозначна [a-c^[:digit:]], — недопустима.)
Таблица 9.20. Спецсимволы ограничений в регулярных выражений
Спецсимвол Описание
\A соответствует только началу строки (чем это от-
личается от ^, описано в Подразделе 9.7.3.5)
\m соответствует только началу слова
\M соответствует только концу слова
\y соответствует только началу или концу слова
\Y соответствует только положению не в начале и
не в конце слова
\Z соответствует только концу строки (чем это от-
личается от $, описано в Подразделе 9.7.3.5)
Определением слова здесь служит то же, что было приведено выше в описании [[:&amp;lt;:]] и [[:&amp;gt;:]].
В квадратных скобках спецсимволы ограничений не допускаются.
Таблица 9.21. Ссылки назад в регулярных выражениях
Спецсимвол Описание
\m (где m — цифра, отличная от 0) — ссылка назад
на подвыражение под номером m
\mnn (где m — цифра, отличная от 0, а nn — ещё
несколько цифр с десятичным значением mnn, не
превышающим число закрытых до этого скобок
с захватом) ссылка назад на подвыражение под
номером mnn
217Функции и операторы
Примечание
Регулярным выражениям присуща неоднозначность между восьмеричными кодами
символов и ссылками назад, которая разрешается следующим образом (это упомина-
лось выше). Ведущий ноль всегда считается признаком восьмеричной последователь-
ности. Единственная цифра, отличная от 0, за которой не следует ещё одна цифра, все-
гда воспринимается как ссылка назад. Последовательность из нескольких цифр, кото-
рая начинается не с 0, воспринимается как ссылка назад, если она идёт за подходящим
подвыражением (т. е. число оказывается в диапазоне, допустимом для ссылки назад),
в противном случае она воспринимается как восьмеричное число.
9.7.3.4. Метасинтаксис регулярных выражений
В дополнение к основному синтаксису, описанному выше, можно использовать также несколько
особых форм и разнообразные синтаксические удобства.
Регулярное выражение может начинаться с одного из двух специальных префиксов режима. Если
RE начинается с &lt;em&gt;**:, его продолжение рассматривается как ARE. (В PostgreSQL это обычно не
имеет значения, так как регулярные выражения воспринимаются как ARE по умолчанию; но это
может быть полезно, когда параметр флаги функций regex включает режим ERE или BRE.) Если
RE начинается с **&lt;/em&gt;=, его продолжение воспринимается как обычная текстовая строка, все его
символы воспринимаются буквально.
ARE может начинаться со встроенных параметров: последовательности (?xyz) (где xyz — один
или несколько алфавитно-цифровых символов), определяющих параметры остального регулярного
выражения. Эти параметры переопределяют любые ранее определённые параметры, в частности
они могут переопределить режим чувствительности к регистру, подразумеваемый для оператора
regex, или параметр флаги функции regex. Допустимые буквы параметров показаны в Таблице 9.22.
Заметьте, что те же буквы используются в параметре флаги функций regex.
Таблица 9.22. Буквы встроенных параметров ARE
Параметр Описание
b продолжение регулярного выражения — BRE
c поиск соответствий с учётом регистра (пере-
определяет тип оператора)
e продолжение RE — ERE
i поиск соответствий без учёта регистра (см. Под-
раздел 9.7.3.5) (переопределяет тип оператора)
m исторически сложившийся синоним n
n поиск соответствий с учётом перевода строк (см.
Подраздел 9.7.3.5)
p переводы строк учитываются частично (см. Под-
раздел 9.7.3.5)
q продолжение регулярного выражения — обыч-
ная строка («в кавычках»), содержимое которой
воспринимается буквально
s поиск соответствий без учёта перевода строк (
по умолчанию)
t компактный синтаксис (по умолчанию; см. ни-
же)
w переводы строк учитываются частично, но в дру-
гом, «странном» режиме (см. Подраздел 9.7.3.5)
218Функции и операторы
Параметр Описание
x развёрнутый синтаксис (см. ниже)
Внедрённые параметры начинают действовать сразу после скобки ), завершающей их последова-
тельность. Они могут находиться только в начале ARE (после указания ***:, если оно присутству-
ет).
Помимо обычного (компактного) синтаксиса RE, в котором имеют значение все символы, поддер-
живается также развёрнутый синтаксис, включить который можно с помощью встроенного пара-
метра x. В развёрнутом синтаксисе игнорируются пробельные символы, а также все символы от
      &lt;h1 id=&quot;до-конца-строки-или-конца-re-Это-позволяет-разделять-re-на-строки-и-добавлять-в-него-ком-&quot;&gt;до конца строки (или конца RE). Это позволяет разделять RE на строки и добавлять в него ком-&lt;/h1&gt;
      &lt;p&gt;ментарии. Но есть три исключения:
• пробельный символ или #, за которым следует \, сохраняется
• пробельный символ или # внутри выражения в квадратных скобках сохраняется
• пробельные символы и комментарии не могут присутствовать в составных символах, напри-
мер, в (?:
В данном контексте пробельными символами считаются пробел, табуляция, перевод строки и лю-
бой другой символ, относящийся к классу символов space.
И наконец, в ARE последовательность (?#ttt) (где ttt — любой текст, не содержащий )) вне квад-
ратных скобок также считается комментарием и полностью игнорируется. При этом она так же
не может находиться внутри составных символов, таких как (?:. Эти комментарии в большей сте-
пени историческое наследие, чем полезное средство; они считаются устаревшими, а вместо них
рекомендуется использовать развёрнутый синтаксис.
Ни одно из этих расширений метасинтаксиса не будет работать, если выражение начинается с
префикса &lt;strong&gt;&lt;em&gt;=, после которого строка воспринимается буквально, а не как RE.
9.7.3.5. Правила соответствия регулярным выражениям
В случае, когда RE может соответствовать более чем одной подстроке в заданной строке, соответ-
ствующей RE считается подстрока, которая начинается в ней первой. Если к данной позиции по-
добных соответствующих подстрок оказывается несколько, из них выбирается либо самая длин-
ная, либо самая короткая из возможных, в зависимости от того, какой режим выбран в RE: жадный
или не жадный.
Где жадный или не жадный характер RE определяется по следующим правилам:
• Большинство атомов и все ограничения не имеют признака жадности (так как они всё равно
не могут соответствовать подстрокам разного состава).
• Скобки, окружающие RE, не влияют на его «жадность».
• Атом с определителем фиксированного количества ((m) или (m)?) имеет ту же характеристи-
ку жадности (или может не иметь её), как и сам атом.
• Атом с другими обычными определителями количества (включая (m,n), где m равняется n)
считается жадным (предпочитает соответствие максимальной длины).
• Атом с не жадным определителем количества (включая (m,n)?, где m равно n) считается не
жадным (предпочитает соответствие минимальной длины).
• Ветвь (RE без оператора | на верхнем уровне) имеет ту же характеристику жадности, что и
первый количественный атом в нём, имеющий атрибут жадности.
• RE, образованное из двух или более ветвей, соединённых оператором |, всегда считается жад-
ным.
Эти правила связывают характеристики жадности не только с отдельными количественными ато-
мами, но и с ветвями и целыми RE, содержащими количественные атомы. Это означает, что при
219Функции и операторы
сопоставлении ветвь или целое RE может соответствовать максимально длинной или короткой
подстроке в целом. Когда определена длина всего соответствия, часть его, соответствующая кон-
кретному подвыражению, определяется с учётом характеристики жадности для этого подвыраже-
ния, при этом подвыражения, начинающиеся в RE раньше, имеют больший приоритет, чем следу-
ющие за ними.
Это иллюстрирует следующий пример:
SELECT SUBSTRING(‘XY1234Z’, ‘Y&lt;/em&gt;(&lt;a href=&quot;1,3&quot;&gt;0-9&lt;/a&gt;)’);
Результат: 123
SELECT SUBSTRING(‘XY1234Z’, ‘Y&lt;em&gt;?(&lt;a href=&quot;1,3&quot;&gt;0-9&lt;/a&gt;)’);
Результат: 1
В первом случае, RE в целом жадное, так как жадным является атом Y&lt;/em&gt;. Соответствие ему начина-
ется с буквы Y и оно включает подстроку максимальной длины с этого места, т. е. подстроку Y123.
Результат выражения — её часть, соответствующая подвыражению в скобках, т. е. 123. Во втором
случае, RE в целом наследует не жадный характер от атома Y&lt;em&gt;?. Соответствие ему так же начина-
ется с Y, но включает оно подстроку минимальной длины с этого места, т. е. Y1. И хотя подвыра-
жение &lt;a href=&quot;1,3&quot;&gt;0-9&lt;/a&gt; имеет жадный характер, оно не может повлиять на выбор длины соответствия
в целом, поэтому ему остаётся только подстрока 1.
Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё соответствие
будет максимально длинным или коротким в зависимости от характеристики всего RE. Характе-
ристики, связанные с подвыражениями, влияют только на то, какую часть подстроки может «по-
глотить» одно подвыражение относительно другого.
Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению или всему RE,
можно использовать определители (1,1) и (1,1)?, соответственно. Это полезно, когда вам нуж-
но, чтобы общая характеристика жадности RE отличалась от той, что вытекает из его элементов.
Например, предположим, что вы пытаетесь выделить из строки, содержащей несколько цифр, эти
цифры и части до и после них. Можно попытаться сделать это так:
SELECT regexp_match(‘abc01234xyz’, ‘(.&lt;/em&gt;)(\d+)(.&lt;em&gt;)’);
Результат: (abc0123,4,xyz)
Но это не будет работать: первая группа .&lt;/em&gt; — «жадная», она «съест» всё, что сможет, оставляя для
соответствия \d+ только последнюю возможность, то есть последнюю цифру. Можно попытаться
сделать запрос «нежадным»:
SELECT regexp_match(‘abc01234xyz’, ‘(.&lt;em&gt;?)(\d+)(.&lt;/em&gt;)’);
Результат: (abc,0,””)
И это не будет работать, так теперь весь RE в целом стал нежадным, и все соответствия заверша-
ются как можно раньше. Но мы можем получить нужный результат, явно сделав жадным всё RE:
SELECT regexp_match(‘abc01234xyz’, ‘(?:(.&lt;em&gt;?)(\d+)(.&lt;/em&gt;))(1,1)’);
Результат: (abc,01234,xyz)
Управление общей характеристикой «жадности» RE независимо от «жадности» его компонентов
даёт большую гибкость в описании шаблонов переменной длины.
При определении более длинного или более короткого соответствия длины соответствий опреде-
ляются в символах, а не в элементах сортировки. Пустая строка считается длиннее, чем отсутствие
соответствия. Например, выражению bb* соответствуют три символа в середине строки abbbc, вы-
ражению (week|wee)(night|knights) — все десять символов weeknights; когда выражение (.&lt;em&gt;).&lt;/em&gt;
сопоставляется со строкой abc, подвыражению в скобках соответствуют все три символа; а когда
(a&lt;em&gt;)&lt;/em&gt; сопоставляется со строкой bc, то и RE в целом, и подстроке в скобках соответствует пустая
строка.
Игнорирование регистра символов даёт практически тот же эффект, как если бы в алфавите ис-
чезли различия прописных и строчных букв. Если буква, существующая и в верхнем, и в нижнем
регистре, фигурирует вне квадратных скобок как обычный символ, она по сути преобразуется в
220Функции и операторы
выражение в квадратных скобках, содержащее оба варианта, например x становится [xX]. Если
же она фигурирует в выражении в квадратных скобках, в это выражение добавляются все её вари-
анты, например [x] становится [xX], а [^x] — [^xX].
Когда включён режим учёта перевода строк, атом . и выражения в квадратных скобках с ^ никогда
не будут соответствовать символам конца строки (так что соответствия никогда не будут пересе-
кать границы строк, если в RE нет явных указаний на эти символы), а ^ и $ будут соответствовать
пустой подстроке не только в начале и конце всего текста, но и в начале и конце каждой отдельной
его строки. Однако спецсимволы ARE \A и \Z по-прежнему будут соответствовать только началу
и концу всего текста.
В режиме, когда переводы строк учитываются частично, особый смысл перевод строк имеет для
атома . и выражений в квадратных скобках, но не для ^ и $.
В обратном частичном режиме, перевод строк имеет особый смысл для ^ и $, как и в режиме с
учётом перевода строк, но не для . и выражений в квадратных скобках. Данный режим не очень
полезен, но существует для симметрии.
9.7.3.6. Пределы и совместимость
В текущей реализации отсутствует какой-либо явно заданный предел длины RE. Однако, разраба-
тывая программы высокой степени переносимости, не следует применять RE длиннее 256 байт,
так как другая POSIX-совместимая реализация может отказаться обрабатывать такие регулярные
выражения.
Единственная особенность ARE, действительно несовместимая с ERE стандарта POSIX проявляет-
ся в том, что в ARE знак \ не теряет своё специальное значение в квадратных скобках. Все другие
расширения ARE используют синтаксические возможности, которые не определены, не допусти-
мы или не поддерживаются в ERE; синтаксис переключения режимов (&lt;/strong&gt;*) также выходит за рам-
ки синтаксиса POSIX как для BRE, так и для ERE.
Многие расширения ARE заимствованы из языка Perl, но некоторые были изменены, оптимизиро-
ваны, а несколько расширений Perl были исключены. В результате имеют место следующие несов-
местимости: атомы \b и \B, отсутствие специальной обработки завершающего перевода строки,
добавление исключений в квадратных скобках в число случаев, когда учитывается перевод строк,
особые условия для скобок и ссылок назад в ограничениях просмотра вперёд/назад и семантика
«наиболее длинное/короткое соответствие» (вместо «первое соответствие»).
Важно отметить две несовместимости синтаксиса ARE и регулярных выражений ERE, которые
воспринимал PostgreSQL до версии 7.4:
• В ARE \ с последующим алфавитно-цифровым символом представляет либо спецсимвол, ли-
бо ошибочную последовательность, тогда как в предыдущих версиях так можно было записы-
вать алфавитно-цифровые символы. Это не должно быть большой проблемой, так как раньше
не было причин использовать такие последовательности.
• В ARE знак \ сохраняет своё специальное значение в [], поэтому, чтобы передать \ в квадрат-
ных скобках буквально, его нужно записать как \.
9.7.3.7. Простые регулярные выражения
BRE имеют ряд отличий от ERE. В BRE знаки |, + и ? теряют специальное значение, а замены им
нет. Границы количества окружаются символами ( и ), тогда как ( и ) рассматриваются как
обычные символы. Вложенные подвыражения помещаются между ( и ), а ( и ) представляют
обычные символы. Символ ^ воспринимается как обычный, если только он не находится в начале
RE или подвыражения в скобках, $ — тоже обычный символ, если он находится не в конце RE
или в конце подвыражения в скобках, и * — обычный символ, когда он находится в начале RE
или подвыражения в скобках (возможно, после начального ^). И, наконец, в BRE работают ссылки
назад с одной цифрой, &amp;lt; и &amp;gt; — синонимы для [[:&amp;lt;:]] и [[:&amp;gt;:]], соответственно; никакие другие
спецсимволы в BRE не поддерживаются.
221Функции и операторы
9.8. Функции форматирования данных
Функции форматирования в PostgreSQL предоставляют богатый набор инструментов для преобра-
зования самых разных типов данных (дата/время, целое, числа с плавающей и фиксированной точ-
кой) в форматированные строки и обратно. Все они перечислены в Таблице 9.23. Все эти функции
следует одному соглашению: в первом аргументе передаётся значение, которое нужно отформа-
тировать, а во втором — шаблон, определяющий формат ввода или вывода.
Таблица 9.23. Функции форматирования
Функция
Тип результата Описание
Пример
to_char(
text) timestamp, text преобразует
текст
to_char(
text) interval, text преобразует интервал в to_char(interval
текст
‘15h
2m
12s’,
‘HH24:MI:SS’)
to_char( int,
преобразует
текст
text) text
время
целое
в to_char(current_
timestamp,
‘HH12:MI:SS’)
в to_char(125,
‘999’)
to_char ( double
precision, text) text преобразует
плаваю- to_char(
щее
одинарной/двой- 125.8::real,
ной точности в текст
‘999D9’)
to_char(
text) numeric, text преобразует числовое to_char(-125.8,
значение в текст
‘999D99S’)
to_date(
text) text, date преобразует текст в да- to_date(
ту
‘05
Dec
2000’,
‘DD Mon YYYY’)
numeric преобразует
число
to_number(
text)
text,
to_timestamp(
text)
text,
timestamp
zone
with
текст
в to_number(‘12,
454.8-‘,
‘99G999D9S’)
time преобразует строку во to_timestamp(
время
‘05
Dec
2000’,
‘DD Mon YYYY’)
Примечание
Также имеется функция to_timestamp с одним аргументом; см. Таблицу 9.30.
Подсказка
Функции to_timestamp и to_date предназначены для работы с входными форматами,
которые нельзя преобразовать простым приведением. Для большинства стандартных
форматов даты/времени работает простое приведение исходной строки к требуемому
типу и использовать его гораздо легче. Так же и функцию to_number нет необходимости
использовать для стандартных представлений чисел.
Шаблон вывода to_char может содержать ряд кодов, которые распознаются при форматировании
и заменяются соответствующими данными в зависимости от заданного значения. Любой текст,
который не является кодом, просто копируется в неизменном виде. Подобным образом в строке
шаблона ввода (для других функций) шаблонные коды определяют, какие значения должны посту-
пать из входной строки. Если в строке шаблона есть символы, не относящиеся к шаблонным ко-
222Функции и операторы
дам, соответствующие символы во входной строке просто пропускаются (вне зависимости от того,
совпадают ли они с символами в строке шаблона).
Все коды форматирования даты и времени перечислены в Таблице 9.24.
Таблица 9.24. Коды форматирования даты/времени
Код Описание
HH час (01-12)
HH12 час (01-12)
HH24 час (00-23)
MI минута (00-59)
SS секунда (00-59)
MS миллисекунда (000-999)
US микросекунда (000000-999999)
SSSS число секунд с начала суток (0-86399)
AM, am, PM или pm обозначение времени до/после полудня (без то-
чек)
A.M., a.m., P.M. или p.m. обозначение времени до/после полудня (с точка-
ми)
Y,YYY год (4 или более цифр) с разделителем
YYYY год (4 или более цифр)
YYY последние 3 цифры года
YY последние 2 цифры года
Y последняя цифра года
IYYY недельный год по ISO 8601 (4 или более цифр)
IYY последние 3 цифры недельного года по ISO 8601
IY последние 2 цифры недельного года по ISO 8601
I последняя цифра недельного года по ISO 8601
BC, bc, AD или ad обозначение эры (без точек)
B.C., b.c., A.D. или a.d. обозначение эры (с точками)
MONTH полное название месяца в верхнем регистре (до-
полненное пробелами до 9 символов)
Month полное название месяца с большой буквы (до-
полненное пробелами до 9 символов)
month полное название месяца в нижнем регистре (до-
полненное пробелами до 9 символов)
MON сокращённое название месяца в верхнем реги-
стре (3 буквы в английском; в других языках дли-
на может меняться)
Mon сокращённое название месяца с большой буквы
(3 буквы в английском; в других языках длина
может меняться)
mon сокращённое название месяца в нижнем реги-
стре (3 буквы в английском; в других языках дли-
на может меняться)
MM номер месяца (01-12)
223Функции и операторы
Код Описание
DAY полное название дня недели в верхнем регистре
(дополненное пробелами до 9 символов)
Day полное название дня недели с большой буквы (
дополненное пробелами до 9 символов)
day полное название дня недели в нижнем регистре
(дополненное пробелами до 9 символов)
DY сокращённое название дня недели в верхнем ре-
гистре (3 буквы в английском; в других языках
может меняться)
Dy сокращённое название дня недели с большой
буквы (3 буквы в английском; в других языках
длина может меняться)
dy сокращённое название дня недели в нижнем ре-
гистре (3 буквы в английском; в других языках
длина может меняться)
DDD номер дня в году (001-366)
IDDD номер дня в году по ISO 8601 (001-371; 1 день —
понедельник первой недели по ISO)
DD день месяца (01-31)
D номер дня недели, считая с воскресенья (1) до
субботы (7)
ID номер дня недели по ISO 8601, считая с поне-
дельника (1) до воскресенья (7)
W неделя месяца (1-5) (первая неделя начинается
в первое число месяца)
WW номер недели в году (1-53) (первая неделя начи-
нается в первый день года)
IW номер недели в году по ISO 8601 (01-53; первый
четверг года относится к неделе 1)
CC век (2 цифры) (двадцать первый век начался
2001-01-01)
J День по юлианскому календарю (номер дня с 24
ноября 4714 г. до н. э.)
Q quarter
RM номер месяца римскими цифрами в верхнем ре-
гистре (I-XII; I=январь)
rm номер месяца римскими цифрами в нижнем ре-
гистре (i-xii; i=январь)
TZ сокращённое название часового пояса в верхнем
регистре (поддерживается только в to_char )
tz сокращённое название часового пояса в нижнем
регистре (поддерживается только в to_char )
TZH часы часового пояса
TZM минуты часового пояса
OF смещение часового пояса от UTC (поддержива-
ется только в to_char )
224Функции и операторы
К любым кодам форматирования можно добавить модификаторы, изменяющие их поведение. На-
пример, шаблон форматирования FMMonth включает код Month с модификатором FM. Модификато-
ры, предназначенные для форматирования даты/времени, перечислены в Таблице 9.25.
Таблица 9.25. Модификаторы кодов для форматирования даты/времени
Модификатор Описание
Пример
Приставка FM режим заполнения (подавляет FMMonth
ведущие нули и дополнение
пробелами)
Окончание TH окончание порядкового числи- DDTH, например 12TH
тельного в верхнем регистре
Окончание th окончание порядкового числи- DDth, например 12th
тельного в нижнем регистре
Приставка FX глобальный параметр фиксиро- FX Month DD Day
ванного формата (см. замеча-
ния)
Приставка TM режим перевода (выводятся ло- TMMonth
кализованные названия дней и
месяцев, исходя из lc_time)
Окончание SP режим числа прописью (не реа- DDSP
лизован)
Замечания по использованию форматов даты/времени:
• FM подавляет дополняющие пробелы и нули справа, которые в противном случае будут добав-
лены, чтобы результат имел фиксированную ширину. В PostgreSQL модификатор FM действует
только на следующий код, тогда как в Oracle FM её действие распространяется на все последу-
ющие коды, пока не будет отключено последующим модификатором FM.
• TM не затрагивает замыкающие пробелы. Функции to_timestamp и to_date игнорируют указа-
ние TM.
• to_timestamp и to_date пропускают повторяющиеся пробелы во входной строке, если только
не используется параметр FX. Например, to_timestamp(‘2000    JUN’, ‘YYYY MON’) будет ра-
ботать, но to_timestamp(‘2000    JUN’, ‘FXYYYY MON’) вернёт ошибку, так как to_timestamp
в данном случае ожидает только один разделяющий пробел. Приставка FX должна быть пер-
вой в шаблоне.
• Шаблоны для to_char могут содержать обычный текст; он будет выведен в неизменном ви-
де. Чтобы принудительно вывести текст буквально, даже если он содержит шаблонные коды,
подстроку с ним можно заключить в кавычки. Например, в строке ‘“Hello Year “YYYY’, код
YYYY будет заменён годом, а буква Y в слове Year останется неизменной. В функциях to_date,
to_number и to_timestamp при обработке подстрок в кавычках и буквального текста некото-
рой длины пропускается такое же число символов во входной строке; например, при обработ-
ке подстроки “XX” будут пропущены два символа (любые, не обязательно XX).
• Если вам нужно получить на выходе двойные кавычки, вы должны предварить их символом
обратной косой черты, например: ‘&quot;YYYY Month&quot;’. В остальном этот символ вне кавычек
воспринимается как обычный. Внутри строки в кавычках он указывает, что следующий сим-
вол должен восприниматься буквально, каким бы он ни был (но это имеет смысл, только если
следующий символ — кавычки или обратная косая черта).
• Если в функциях to_timestamp и to_date формат года определяется менее, чем 4 цифрами,
например, как YYY, и в переданном значении года тоже меньше 4 цифр, год пересчитывается
в максимально близкий к году 2020, т. е. 95 воспринимается как 1995.
• В функциях to_timestamp и to_date с преобразованием YYYY связано ограничение, когда об-
рабатываемый год записывается более чем 4 цифрами. После YYYY необходимо будет доба-
225Функции и операторы
вить нецифровой символ или соответствующий код, иначе год всегда будет восприниматься
как 4 цифры. Например, в to_date(‘200001131’, ‘YYYYMMDD’) (с годом 20000) год будет ин-
терпретирован как состоящий из 4 цифр; чтобы исправить ситуацию, нужно добавить нециф-
ровой разделитель после года, как в to_date(‘20000-1131’, ‘YYYY-MMDD’), или код как в
to_date(‘20000Nov31’, ‘YYYYMonDD’).
• Функции to_timestamp и to_date принимают поле CC (век), но игнорируют его, если в шаб-
лоне есть поле YYY, YYYY или Y,YYY. Если CC используется с YY или Y, результатом будет год в
данном столетии. Если присутствует только код столетия, без года, подразумевается первый
год этого века.
• Функции to_timestamp и to_date принимают названия и номера дней недели (DAY, D и связан-
ные типы полей), но игнорируют их при вычислении результата. То же самое происходит с по-
лями квартала (Q).
• Функциям to_timestamp и to_date можно передать даты по недельному календарю ISO 8601
(отличающиеся от григорианских) одним из двух способов:
• Год, номер недели и дня недели: например, to_date(‘2006-42-4’, ‘IYYY-IW-ID’) возвра-
щает дату 2006-10-19. Если день недели опускается, он считается равным 1 (понедельни-
ку).
• Год и день года: например, to_date(‘2006-291’, ‘IYYY-IDDD’) также возвращает
2006-10-19.
Попытка ввести дату из смеси полей григорианского и недельного календаря ISO 8601 бес-
смысленна, поэтому это будет считаться ошибкой. В контексте ISO 8601 понятия «номер ме-
сяца» и «день месяца» не существуют, а в григорианском календаре нет понятия номера неде-
ли по ISO.
Внимание
Тогда как to_date не примет смесь полей григорианского и недельного календаря
ISO, to_char способна на это, так как форматы вроде YYYY-MM-DD (IYYY-IDDD) мо-
гут быть полезны. Но избегайте форматов типа IYYY-MM-DD; в противном случае с
датами в начале года возможны сюрпризы. (За дополнительными сведениями об-
ратитесь к Подразделу 9.9.1.)
• Функция to_timestamp воспринимает поля миллисекунд (MS) или микросекунд (US) как дроб-
ную часть число секунд. Например, to_timestamp(‘12.3’, ‘SS.MS’) — это не 3 миллисекун-
ды, а 300, так как это значение воспринимается как 12 + 0.3 секунды. Это значит, что для
формата SS.MS входные значения 12.3, 12.30 и 12.300 задают одно и то же число миллисе-
кунд. Чтобы получить три миллисекунды, время нужно записать в виде 12.003, тогда оно бу-
дет воспринято как 12 + 0.003 = 12.003 сек.
Ещё более сложный пример: to_timestamp(‘15:12:02.020.001230’, ‘HH24:MI:SS.MS.US’) бу-
дет преобразовано в 15 часов, 12 минут и 2 секунды + 20 миллисекунд + 1230 микросекунд =
2.021230 seconds.
• Нумерация дней недели в to_char(…, ‘ID’) соответствует функции extract(isodow
from …), но нумерация to_char(…, ‘D’) не соответствует нумерации, принятой в
extract(dow from …).
• Функция to_char(interval) обрабатывает форматы HH and HH12 в рамках 12 часов, то есть 0 и
36 часов будут выводиться как 12, тогда как HH24 выводит число часов полностью, и для зна-
чений interval результат может превышать 23.
Коды форматирования числовых значений перечислены в Таблице 9.26.
226Функции и операторы
Таблица 9.26. Коды форматирования чисел
Код Описание
9 позиция цифры (может отсутствовать, если циф-
ра незначащая)
0 позиция цифры (присутствует всегда, даже если
цифра незначащая)
. (точка) десятичная точка
, (запятая) разделитель групп (тысяч)
PR отрицательное значение в угловых скобках
S знак, добавляемый к числу (с учётом локали)
L символ денежной единицы (с учётом локали)
D разделитель целой и дробной части числа (с учё-
том локали)
G разделитель групп (с учётом локали)
MI знак минус в заданной позиции (если число &amp;lt; 0)
PL знак плюс в заданной позиции (если число &amp;gt; 0)
SG знак плюс или минус в заданной позиции
RN число римскими цифрами (в диапазоне от 1 до
3999)
TH или th окончание порядкового числительного
V сдвиг на заданное количество цифр (см. замеча-
ния)
EEEE экспоненциальная запись числа
Замечания по использованию форматов чисел:
• 0 обозначает позицию цифры, которая будет выводиться всегда, даже если это незначащий
ноль слева или справа. 9 также обозначает позицию цифры, но если это незначащий ноль сле-
ва, он заменяется пробелом, а если справа и задан режим заполнения, он удаляется. (Для
функции to_number() эти два символа равнозначны.)
• Символы шаблона S, L, D и G представляют знак, символ денежной единицы, десятичную точ-
ку и разделитель тысяч, как их определяет текущая локаль (см. lc_monetary и lc_numeric).
Символы точка и запятая представляют те же символы, обозначающие десятичную точку и
разделитель тысяч, но не зависят от локали.
• Если в шаблоне to_char() отсутствует явное указание положения знака, для него резервиру-
ется одна позиция рядом с числом (слева от него). Если левее нескольких 9 помещён S, знак
также будет приписан слева к числу.
• Знак числа, полученный кодами SG, PL или MI, не присоединяется к числу; например,
to_char(-12, ‘MI9999’) выдаёт ‘-  12’, тогда как to_char(-12, ‘S9999’) — ‘  -12’. (В
Oracle MI не может идти перед 9, наоборот 9 нужно указать перед MI.)
• TH не преобразует значения меньше 0 и не поддерживает дробные числа.
• PL, SG и TH — расширения PostgreSQL.
• В to_number при использовании шаблонных кодов, не обозначающих данные, таких как L и TH,
пропускается соответствующее количество входных символов. При этом не имеет значения,
совпадают ли они с символами шаблона, если только это не символы данных (то есть цифры,
знак числа, десятичная точка или запятая). Например, для подстроки TH будут пропущены
два символа, не представляющие данные.
227Функции и операторы
• V c to_char умножает вводимое значение на 10^n, где n — число цифр, следующих за V. V с
to_number подобным образом делит значение. Функции to_char и to_number не поддерживают
V с дробными числами (например, 99.9V99 не допускается).
• Код EEEE (научная запись) не может сочетаться с любыми другими вариантами форматирова-
ния или модификаторами, за исключением цифр и десятичной точки, и должен располагаться
в конце строки шаблона (например, 9.99EEEE — допустимый шаблон).
Для изменения поведения кодов к ним могут быть применены определённые модификаторы. На-
пример, FM99.99 обрабатывается как код 99.99 с модификатором FM. Все модификаторы для фор-
матирования чисел перечислены в Таблице 9.27.
Таблица 9.27. Модификаторы шаблонов для форматирования чисел
Модификатор Описание
Пример
Приставка FM режим заполнения (подавляет FM99.99
завершающие нули и дополне-
ние пробелами)
Окончание TH окончание порядкового числи- 999TH
тельного в верхнем регистре
Окончание th окончание порядкового числи- 999th
тельного в нижнем регистре
В Таблице 9.28 приведены некоторые примеры использования функции to_char.
Таблица 9.28. Примеры to_char
Выражение
Результат
to_char(current_timestamp,
 DD  HH12:MI:SS’) ‘Day,
to_char(current_timestamp,
 FMDD  HH12:MI:SS’) ‘FMDay,
‘Tuesday  , 06  05:39:18’
‘Tuesday, 6  05:39:18’
to_char(-0.1, ‘99.99’) ‘  -.10’
to_char(-0.1, ‘FM9.99’) ‘-.1’
to_char(-0.1, ‘FM90.99’) ‘-0.1’
to_char(0.1, ‘0.9’) ‘ 0.1’
to_char(12, ‘9990999.9’) ‘    0012.0’
to_char(12, ‘FM9990999.9’) ‘0012.’
to_char(485, ‘999’) ‘ 485’
to_char(-485, ‘999’) ‘-485’
to_char(485, ‘9 9 9’) ‘ 4 8 5’
to_char(1485, ‘9,999’) ‘ 1,485’
to_char(1485, ‘9G999’) ‘ 1 485’
to_char(148.5, ‘999.999’) ‘ 148.500’
to_char(148.5, ‘FM999.999’) ‘148.5’
to_char(148.5, ‘FM999.990’) ‘148.500’
to_char(148.5, ‘999D999’) ‘ 148,500’
to_char(3148.5, ‘9G999D999’) ‘ 3 148,500’
to_char(-485, ‘999S’) ‘485-‘
to_char(-485, ‘999MI’) ‘485-‘
228Функции и операторы
Выражение Результат
to_char(485, ‘999MI’) ‘485 ‘
to_char(485, ‘FM999MI’) ‘485’
to_char(485, ‘PL999’) ‘+485’
to_char(485, ‘SG999’) ‘+485’
to_char(-485, ‘SG999’) ‘-485’
to_char(-485, ‘9SG99’) ‘4-85’
to_char(-485, ‘999PR’) ‘&amp;lt;485&amp;gt;’
to_char(485, ‘L999’) ‘DM 485’
to_char(485, ‘RN’) ‘        CDLXXXV’
to_char(485, ‘FMRN’) ‘CDLXXXV’
to_char(5.2, ‘FMRN’) ‘V’
to_char(482, ‘999th’) ‘ 482nd’
to_char(485, ‘“Good number:”999’) ‘Good number: 485’
to_char(485.8, ‘“Pre:”999” Post:” .999’) ‘Pre: 485 Post: .800’
to_char(12, ‘99V999’) ‘ 12000’
to_char(12.4, ‘99V999’) ‘ 12400’
to_char(12.45, ‘99V9’) ‘ 125’
to_char(0.0004859, ‘9.99EEEE’) ‘ 4.86e-04’
9.9. Операторы и функции даты/времени
Все существующие функции для обработки даты/времени перечислены в Таблице 9.30, а подробнее
они описаны в следующих подразделах. Поведение основных арифметических операторов (+, * и
т. д.) описано в Таблице 9.29. Функции форматирования этих типов данных были перечислены в
Разделе 9.8. Общую информацию об этих типах вы получили (или можете получить) в Разделе 8.5.
Все описанные ниже функции и операторы принимают две разновидности типов time или
timestamp: с часовым поясом (time with time zone и timestamp with time zone) и без него (time
without time zone и timestamp without time zone). Для краткости здесь они рассматриваются
вместе. Кроме того, операторы + и * обладают переместительным свойством (например, date +
integer = integer + date); здесь будет приведён только один вариант для каждой пары.
Таблица 9.29. Операторы даты/времени
Оператор Пример
Результат&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;date ‘2001-09-28’ + integer date ‘2001-10-05’
‘7’ + date ‘2001-09-28’ + interval timestamp
‘1 hour’
01:00:00’ ‘2001-09-28&lt;/li&gt;
    &lt;li&gt;date ‘2001-09-28’
‘03:00’ ‘2001-09-28&lt;/li&gt;
    &lt;li&gt;interval ‘1 day’ + interval interval ‘1 day 01:00:00’
‘1 hour’&lt;/li&gt;
    &lt;li&gt;timestamp ‘2001-09-28 01:00’ timestamp&lt;/li&gt;
    &lt;li&gt;interval ‘23 hours’
00:00:00’ + time ‘01:00’ + interval ‘3 time ‘04:00:00’
hours’
229
+
time timestamp
03:00:00’
‘2001-09-29Функции и операторы
Оператор Пример
Результат&lt;/li&gt;
    &lt;li&gt;
      &lt;ul&gt;
        &lt;li&gt;interval ‘23 hours’
interval ‘-23:00:00’&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;date ‘2001-10-01’
‘2001-09-28’&lt;/li&gt;
    &lt;li&gt;date ‘2001-10-01’ - integer date ‘2001-09-24’
‘7’&lt;/li&gt;
    &lt;li&gt;date ‘2001-09-28’ - interval timestamp
‘1 hour’
23:00:00’&lt;/li&gt;
    &lt;li&gt;time ‘05:00’ - time ‘03:00’&lt;/li&gt;
    &lt;li&gt;time ‘05:00’ - interval ‘2 time ‘03:00:00’
hours’&lt;/li&gt;
    &lt;li&gt;timestamp ‘2001-09-28 23:00’ timestamp&lt;/li&gt;
    &lt;li&gt;interval ‘23 hours’
00:00:00’&lt;/li&gt;
    &lt;li&gt;interval ‘1 day’ - interval interval ‘1 day -01:00:00’
‘1 hour’&lt;/li&gt;
    &lt;li&gt;
      &lt;h2 id=&quot;timestamp-2001-09-29-0300-interval-1-day-150000&quot;&gt;timestamp ‘2001-09-29 03:00’ interval ‘1 day 15:00:00’&lt;/h2&gt;
      &lt;p&gt;timestamp
‘2001-09-27
12:00’&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;900 * interval ‘1 second’
interval ‘00:15:00’&lt;/li&gt;
    &lt;li&gt;21 * interval ‘1 day’
interval ‘21 days’&lt;/li&gt;
    &lt;li&gt;double precision
interval ‘1 hour’
/ interval ‘1 hour’ / double interval ‘00:40:00’
precision ‘1.5’
-
date integer ‘3’ (дня)
‘3.5’
‘2001-09-27
interval ‘02:00:00’
‘2001-09-28&lt;/li&gt;
    &lt;li&gt;interval ‘03:30:00’
Таблица 9.30. Функции даты/времени
Функция Тип результата Описание age( timestamp,
timestamp) interval Вычитает
аргу- age(timestamp
менты
и
вы- ‘2001-04-10’,
даёт «символиче-
timestamp
ский» результат с ‘1957-06-13’)
годами и месяца-
ми, а не просто
днями 43 years 9 mons 27
days (43 года 9
месяцев 27 дней)
age( timestamp) interval Вычитает
да- age(timestamp
ту/время
из ‘1957-06-13’)
current_date
(
полночь текущего
дня) 43 years 8 mons 3
days (43 года 8
месяцев 3 дня)
clock_timestamp
() timestamp
time zone current_date date current_time time
zone
with Текущая дата и
время (меняется
в процессе вы-
полнения операто-
ров); см. Подраз-
дел 9.9.4
Текущая дата; см.
Подраздел 9.9.4
with
time Текущее время су-
ток; см. Подраз-
дел 9.9.4
230
Пример
РезультатФункции и операторы
Функция Тип результата
Описание
Пример
Результат
current_
timestamp timestamp
time zone
date_part(
text,
timestamp) double precision Возвращает поле date_part(
даты (равнозначно ‘hour’,
extract); см. Под-
timestamp
раздел 9.9.1
‘2001-02-16
20:38:40’)
with Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
20
date_part(
double precision Возвращает поле date_part(
3
даты (равнозначно ‘month’,
text, interval)
extract); см. Под-
interval
‘2
раздел 9.9.1
years 3 months’)
date_trunc(
text,
timestamp)
timestamp
date_trunc(
interval
text, interval)
Отсекает
компо-
ненты даты до за-
данной точности;
см. также Подраз-
дел 9.9.2 date_trunc(
‘hour’,
timestamp
‘2001-02-16
20:38:40’)
Отсекает
компо-
ненты даты до за-
данной точности;
см. также Подраз-
дел 9.9.2 date_trunc(
2 days 03:00:00
‘hour’,
interval
‘2
days 3 hours 40
minutes’)
2001-02-16
20:00:00
extract( field
from timestamp) double precision Возвращает поле extract(hour
20
даты; см. Подраз- from
timestamp
дел 9.9.1
‘2001-02-16
20:38:40’)
extract( field
from interval) double precision Возвращает поле extract(month
3
даты; см. Подраз- from interval ‘2
дел 9.9.1
years 3 months’)
isfinite( date) boolean Проверяет конеч- isfinite(date
ность даты (её от- ‘2001-02-16’)
личие от +/-беско-
нечности) true
isfinite(
timestamp) boolean Проверяет конеч-
ность времени (его
отличие от +/-бес-
конечности) true
isfinite(
interval) boolean Проверяет конеч- isfinite(
ность интервала
interval
hours’) justify_days(
interval) interval Преобразует
ин- justify_days(
тервал так, что interval
‘35
каждый 30-днев- days’)
ный период счита-
ется одним меся-
цем 1 mon 5 days (1
месяц 5 дней)
justify_hours(
interval) interval Преобразует
ин- justify_hours(
тервал так, что interval
‘27
каждый 24-часо- hours’) 1 day 03:00:00 (
1 день 03:00:00)
231
isfinite(
timestamp
‘2001-02-16
21:28:30’)
true
‘4Функции и операторы
Функция Тип результата Описание
Пример
вой период счита-
ется одним днём Результат
justify_
interval(
interval) interval Преобразует
ин-
тервал с приме-
нением justify_
days и justify_
hours и дополни-
тельно корректи-
рует знаки 29 days 23:00:00
(29
дней
23:00:00)
localtime time Текущее время су-
ток; см. Подраз-
дел 9.9.4 localtimestamp timestamp Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
justify_
interval(
interval ‘1 mon
-1 hour’)
make_date( year date
int, month int,
day int) Образует дату из make_date(
полей: year (год), 2013, 7, 15)
month (месяц) и
day (день) 2013-07-15
make_interval( interval
years
int
DEFAULT
0,
months
int
DEFAULT 0, weeks
int DEFAULT 0,
days
int
DEFAULT 0, hours
int DEFAULT 0,
mins
int
DEFAULT 0, secs
double precision
DEFAULT 0.0) Образует
интер- make_interval(
вал из полей: years days =&amp;gt; 10)
(годы), months (
месяцы), weeks (
недели), days (
дни), hours (часы),
minutes (минуты) и
secs (секунды) 10 days
make_time( hour time
int,
min int,
sec
double
precision) Образует время из make_time(8,
полей: hour (час), 15, 23.5)
minute (минута) и
sec (секунда) 08:15:23.5
make_timestamp( timestamp
year int, month
int,
day int,
hour int, min
int, sec double
precision) Образует дату и make_timestamp(
время из полей: 2013, 7, 15,
year (год), month ( 8, 15, 23.5)
месяц), day (день),
hour (час), minute (
минута) и sec (се-
кунда) 2013-07-15
08:15:23.5
make_ timestamp
timestamptz(
time zone
year int, month
int,
day int,
hour
int,
min int,
sec
double precision,
with Образует дату и make_
время с часовым timestamptz(
поясом из полей: 2013, 7, 15,
year (год), month ( 8, 15, 23.5)
месяц), day (день),
hour (час), minute
(минута) и sec (
секунда). Если па-
232
2013-07-15
08:15:23.5+01Функции и операторы
Функция
Тип результата
[ timezone
text])
Описание
Пример
раметр timezone (
часовой пояс) не
указан, использу-
ется текущий ча-
совой пояс.
now() timestamp
time zone with Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
statement_
timestamp() timestamp
time zone with Текущая дата и
время
(на
мо-
мент начала те-
кущего
операто-
ра); см. Подраз-
дел 9.9.4
timeofday() text transaction_
timestamp() timestamp
time zone with Текущая дата и
время (на момент
начала
транзак-
ции); см. Подраз-
дел 9.9.4
to_timestamp(
double
precision) timestamp
time zone with Преобразует вре- to_timestamp(
мя эпохи Unix ( 1284352323)
число секунд с
1970-01-01
00:00:00+00)
в
стандартное вре-
мя
Результат
Текущая дата и
время (как clock_
timestamp , но в
виде строки типа
text); см. Подраз-
дел 9.9.4
2010-09-13
04:32:03+00
В дополнение к этим функциям поддерживается SQL-оператор OVERLAPS:
(начало1, конец1) OVERLAPS (начало2, конец2)
(начало1, длительность1) OVERLAPS (начало2, длительность2)
Его результатом будет true, когда два периода времени (определённые своими границами) пересе-
каются, и false в противном случае. Границы периода можно задать либо в виде пары дат, времени
или дат со временем, либо как дату, время (или дату со временем) c интервалом. Когда указывается
пара значений, первым может быть и начало, и конец периода: OVERLAPS автоматически считает
началом периода меньшее значение. Периоды времени считаются наполовину открытыми, т. е.
начало&amp;lt;=время&amp;lt;конец, если только начало и конец не равны — в этом случае период представляет
один момент времени. Это означает, например, что два периода, имеющие только общую границу,
не будут считаться пересекающимися.
SELECT (DATE ‘2001-02-16’,
(DATE ‘2001-10-30’,
Результат:true
SELECT (DATE ‘2001-02-16’,
(DATE ‘2001-10-30’,
Результат:false
SELECT (DATE ‘2001-10-29’,
DATE ‘2001-12-21’) OVERLAPS
DATE ‘2002-10-30’);
INTERVAL ‘100 days’) OVERLAPS
DATE ‘2002-10-30’);
DATE ‘2001-10-30’) OVERLAPS
233Функции и операторы
(DATE ‘2001-10-30’, DATE ‘2001-10-31’);
Результат:false
SELECT (DATE ‘2001-10-30’, DATE ‘2001-10-30’) OVERLAPS
(DATE ‘2001-10-30’, DATE ‘2001-10-31’);
Результат:true
При добавлении к дате со временем типа timestamp with time zone значения interval (или при
вычитании из него interval), поле дней в этой дате увеличивается (или уменьшается) на указан-
ное число дней. При пересечении границы перехода на летнее время (если в часовом поясе те-
кущего сеанса производится этот переход) это означает, что interval ‘1 day’ и interval ‘24
hours’ не обязательно будут равны. Например, в часовом поясе CST7CDT результатом выражения
timestamp with time zone ‘2005-04-02 12:00-07’ + interval ‘1 day’ будет timestamp with
time zone ‘2005-04-03 12:00-06’, тогда как, если добавить interval ‘24 hours’ к тому же зна-
чению timestamp with time zone, в результате получится timestamp with time zone ‘2005-04-03
13:00-06’. Эта разница объясняется тем, что 2005-04-03 02:00 в часовом поясе CST7CDT произо-
шёл переход на летнее время.
Обратите внимание на возможную неоднозначность в поле months в результате функции age, вы-
званную тем, что число дней в разных месяцах неодинаково. Вычисляя оставшиеся дни месяца,
PostgreSQL рассматривает месяц меньшей из двух дат. Например, результатом age(‘2004-06-01’,
‘2004-04-30’) будет 1 mon 1 day, так как в апреле 30 дней, а то же выражение с датой 30 мая
выдаст 1 mon 2 days, так как в мае 31 день.
Вычитание дат и дат со временем также может быть нетривиальной операцией. Один принципи-
ально простой способ выполнить такое вычисление — преобразовать каждое значение в количе-
ство секунд, используя EXTRACT(EPOCH FROM …), а затем найти разницу результатов; при этом
будет получено число секунд между двумя датами. При этом будет учтено неодинаковое число
дней в месяцах, изменения часовых поясов и переходы на летнее время. При вычитании дат или
дат со временем с помощью оператора «-» выдаётся число дней (по 24 часа) и часов/минут/секунд
между данными значениями, с учётом тех же факторов. Функция age возвращает число лет, меся-
цев, дней и часов/минут/секунд, выполняя вычитание по полям, а затем пересчитывая отрицатель-
ные значения. Различие этих подходов иллюстрируют следующие запросы. Показанные результа-
ты были получены для часового пояса ‘US/Eastern’; между двумя заданными датами произошёл
переход на летнее время:
SELECT EXTRACT(EPOCH FROM timestamptz ‘2013-07-01 12:00:00’) -
EXTRACT(EPOCH FROM timestamptz ‘2013-03-01 12:00:00’);
Результат:10537200
SELECT (EXTRACT(EPOCH FROM timestamptz ‘2013-07-01 12:00:00’) -
EXTRACT(EPOCH FROM timestamptz ‘2013-03-01 12:00:00’))
/ 60 / 60 / 24;
Результат:121.958333333333
SELECT timestamptz ‘2013-07-01 12:00:00’ - timestamptz ‘2013-03-01 12:00:00’;
Результат:121 days 23:00:00
SELECT age(timestamptz ‘2013-07-01 12:00:00’, timestamptz ‘2013-03-01 12:00:00’);
Результат:4 mons
9.9.1. EXTRACT, date_part
EXTRACT(field FROM source)
Функция extract получает из значений даты/времени поля, такие как год или час. Здесь источ-
ник — значение типа timestamp, time или interval. (Выражения типа date приводятся к типу
timestamp, так что допускается и этот тип.) Указанное поле представляет собой идентификатор,
по которому из источника выбирается заданное поле. Функция extract возвращает значения типа
double precision. Допустимые поля:
century
Век:
234Функции и операторы
SELECT EXTRACT(CENTURY FROM TIMESTAMP ‘2000-12-16 12:21:13’);
Результат:20
SELECT EXTRACT(CENTURY FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:21
Первый век начался 0001-01-01 00:00:00, хотя люди в то время и не считали так. Это определе-
ние распространяется на все страны с григорианским календарём. Века с номером 0 нет было;
считается, что 1 наступил после -1. Если такое положение вещей вас не устраивает, направ-
ляйте жалобы по адресу: Ватикан, Собор Святого Петра, Папе.
day
Для значений timestamp это день месяца (1 - 31), для значений interval — число дней
SELECT EXTRACT(DAY FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:16
SELECT EXTRACT(DAY FROM INTERVAL ‘40 days 1 minute’);
Результат:40
decade
Год, делённый на 10
SELECT EXTRACT(DECADE FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:200
dow
День недели, считая с воскресенья (0) до субботы (6)
SELECT EXTRACT(DOW FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:5
Заметьте, что в extract дни недели нумеруются не так, как в функции to_char(…, ‘D’).
doy
День года (1 - 365/366)
SELECT EXTRACT(DOY FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:47
epoch
Для значений timestamp with time zone это число секунд с 1970-01-01 00:00:00 UTC (может
быть отрицательным); для значений date и timestamp это число секунд с 1970-01-01 00:00:00
по местному времени, а для interval — общая длительность интервала в секундах
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE
‘2001-02-16 20:38:40.12-08’);
Результат:982384720.12
SELECT EXTRACT(EPOCH FROM INTERVAL ‘5 days 3 hours’);
Результат:442800
Преобразовать время эпохи назад, в значение дата/время, с помощью to_timestamp можно так:
SELECT to_timestamp(982384720.12);
Результат:2001-02-17 04:38:40.12+00
hour
Час (0 - 23)
SELECT EXTRACT(HOUR FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:20
235Функции и операторы
isodow
День недели, считая с понедельника (1) до воскресенья (7)
SELECT EXTRACT(ISODOW FROM TIMESTAMP ‘2001-02-18 20:38:40’);
Результат:7
Результат отличается от dow только для воскресенья. Такая нумерация соответствует ISO 8601.
isoyear
Год по недельному календарю ISO 8601, в который попадает дата (неприменимо к интервалам)
SELECT EXTRACT(ISOYEAR FROM DATE ‘2006-01-01’);
Результат:2005
SELECT EXTRACT(ISOYEAR FROM DATE ‘2006-01-02’);
Результат:2006
Год по недельному календарю ISO начинается с понедельника недели, в которой оказывается
4 января, так что в начале января или в конце декабря год по ISO может отличаться от года по
григорианскому календарю. Подробнее об этом рассказывается в описании поля week.
Этого поля не было в PostgreSQL до версии 8.3.
microseconds
Значение секунд с дробной частью, умноженное на 1 000 000; заметьте, что оно включает и
целые секунды
SELECT EXTRACT(MICROSECONDS FROM TIME ‘17:12:28.5’);
Результат:28500000
millennium
Тысячелетие
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:3
Годы 20 века относятся ко второму тысячелетию. Третье тысячелетие началось 1 января 2001 г.
milliseconds
Значение секунд с дробной частью, умноженное на 1 000; заметьте, что оно включает и целые
секунды.
SELECT EXTRACT(MILLISECONDS FROM TIME ‘17:12:28.5’);
Результат:28500
minute
Минуты (0 - 59)
SELECT EXTRACT(MINUTE FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:38
month
Для значений timestamp это номер месяца в году (1 - 12), а для interval — остаток от деления
числа месяцев на 12 (в интервале 0 - 11)
SELECT EXTRACT(MONTH FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:2
SELECT EXTRACT(MONTH FROM INTERVAL ‘2 years 3 months’);
Результат:3
SELECT EXTRACT(MONTH FROM INTERVAL ‘2 years 13 months’);
Результат:1
236Функции и операторы
quarter
Квартал года (1 - 4), к которому относится дата
SELECT EXTRACT(QUARTER FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:1
second
1
Секунды, включая дробную часть (0 - 59 )
SELECT EXTRACT(SECOND FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:40
SELECT EXTRACT(SECOND FROM TIME ‘17:12:28.5’);
Результат:28.5
timezone
Смещение часового пояса от UTC, представленное в секундах. Положительные значения соот-
ветствуют часовым поясам к востоку от UTC, а отрицательные — к западу. (Строго говоря, в
PostgreSQL используется не UTC, так как секунды координации не учитываются.)
timezone_hour
Поле часов в смещении часового пояса
timezone_minute
Поле минут в смещении часового пояса
week
Номер недели в году по недельному календарю ISO 8601. По определению, недели ISO 8601
начинаются с понедельника, а первая неделя года включает 4 января этого года. Другими сло-
вами, первый четверг года всегда оказывается в 1 неделе этого года.
В системе нумерации недель ISO первые числа января могут относиться к 52-ой или 53-ей неде-
ле предыдущего года, а последние числа декабря — к первой неделе следующего года. Напри-
мер, 2005-01-01 относится к 53-ей неделе 2004 г., а 2006-01-01 — к 52-ей неделе 2005 г., тогда
как 2012-12-31 включается в первую неделю 2013 г. Поэтому для получения согласованных
результатов рекомендуется использовать поле isoyear в паре с week.
SELECT EXTRACT(WEEK FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:7
year
Поле года. Учтите, что года 0 не было, и это следует иметь в виду, вычитая из годов нашей эры
годы до нашей эры.
SELECT EXTRACT(YEAR FROM TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:2001
Примечание
С аргументом +/-бесконечность extract возвращает +/-бесконечность для монотонно
увеличивающихся полей (epoch, julian, year, isoyear, decade, century и millennium).
Для других полей возвращается NULL. До версии 9.6 PostgreSQL возвращал ноль для
всех случаев с бесконечными аргументами.
Функция extract в основном предназначена для вычислительных целей. Функции форматирования
даты/времени описаны в Разделе 9.8.
1
60, если операционная система поддерживает секунды координации
237Функции и операторы
Функция date_part эмулирует традиционный для Ingres эквивалент стандартной SQL-функции
extract:
date_part(‘поле’, источник)
Заметьте, что здесь параметр поле должен быть строковым значением, а не именем. Функция
date_part воспринимает те же поля, что и extract.
SELECT date_part(‘day’, TIMESTAMP ‘2001-02-16 20:38:40’);
Результат:16
SELECT date_part(‘hour’, INTERVAL ‘4 hours 3 minutes’);
Результат:4
9.9.2. date_trunc
Функция date_trunc работает подобно trunc для чисел.
date_trunc(‘поле’, значение)
Здесь значение — это выражение типа timestamp или interval. (Значения типов date и time ав-
томатически приводятся к типам timestamp и interval, соответственно.) Параметр поле опреде-
ляет, до какой точности обрезать переданное значение. Возвращаемое значение будет иметь тип
timestamp или interval и все его значения, менее значимые, чем заданное поле, будут равны нулю
(или единице, если это номер дня или месяца).
Параметр поле может принимать следующие значения:
microseconds
milliseconds
second
minute
hour
day
week
month
quarter
year
decade
century
millennium
Примеры:
SELECT date_trunc(‘hour’, TIMESTAMP ‘2001-02-16 20:38:40’);
Результат: 2001-02-16 20:00:00
SELECT date_trunc(‘year’, TIMESTAMP ‘2001-02-16 20:38:40’);
Результат: 2001-01-01 00:00:00
9.9.3. AT TIME ZONE
Указание AT TIME ZONE позволяет переводить дату/время без часового пояса в дату/время с часо-
вым поясом и обратно, а также пересчитывать значения времени для различных часовых поясов.
Все разновидности этого указания проиллюстрированы в Таблице 9.31.
Таблица 9.31. Разновидности AT TIME ZONE
Выражение
Тип результата
timestamp without time zone timestamp with time zone
AT TIME ZONE часовой_пояс
238
Описание
Воспринимает заданное время
без указания часового пояса
как время в указанном часовом
поясеФункции и операторы
Выражение
Тип результата
Описание
timestamp with time zone AT timestamp without time zone
TIME ZONE часовой_пояс Переводит данное значение
timestamp с часовым поясом в
другой часовой пояс, но не со-
храняет информацию о нём в ре-
зультате
time with time zone AT TIME time with time zone
ZONE часовой_пояс Переводит данное время с ча-
совым поясом в другой часовой
пояс
В этих выражениях желаемый часовой_пояс можно задать либо в виде текстовой строки (напри-
мер, ‘America/Los_Angeles’), либо как интервал (например, INTERVAL ‘-08:00’). В первом случае
название часового пояса можно указать любым из способов, описанных в Подразделе 8.5.3.
Примеры (в предположении, что местный часовой пояс America/Los_Angeles):
SELECT TIMESTAMP ‘2001-02-16 20:38:40’ AT TIME ZONE ‘America/Denver’;
Результат: 2001-02-16 19:38:40-08
SELECT TIMESTAMP WITH TIME ZONE ‘2001-02-16 20:38:40-05’ AT TIME ZONE ‘America/Denver’;
Результат: 2001-02-16 18:38:40
SELECT TIMESTAMP ‘2001-02-16 20:38:40-05’ AT TIME ZONE ‘Asia/Tokyo’ AT TIME ZONE
‘America/Chicago’;
Результат: 2001-02-16 05:38:40
В первом примере для значения, заданного без часового пояса, указывается часовой пояс и по-
лученное время выводится в текущем часовом поясе (заданном параметром TimeZone). Во втором
примере значение времени смещается в заданный часовой пояс и выдаётся без указания часово-
го пояса. Этот вариант позволяет хранить и выводить значения с часовым поясом, отличным от
текущего. В третьем примере время в часовом поясе Токио пересчитывается для часового пояса
Чикаго. При переводе значений времени без даты в другие часовые пояса используются опреде-
ления часовых поясов, действующие в данный момент.
Функция timezone(часовой_пояс, время) равнозначна SQL-совместимой конструкции время AT
TIME ZONE часовой_пояс.
9.9.4. Текущая дата/время
PostgreSQL предоставляет набор функций, результат которых зависит от текущей даты и времени.
Все следующие функции соответствуют стандарту SQL и возвращают значения, отражающие вре-
мя начала текущей транзакции:
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(точность)
CURRENT_TIMESTAMP(точность)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(точность)
LOCALTIMESTAMP(точность)
CURRENT_TIME и CURRENT_TIMESTAMP возвращают время с часовым поясом. В результатах LOCALTIME
и LOCALTIMESTAMP нет информации о часовом поясе.
CURRENT_TIME, CURRENT_TIMESTAMP, LOCALTIME и LOCALTIMESTAMP могут принимать необязательный
параметр точности, определяющий, до какого знака после запятой следует округлять поле секунд.
Если этот параметр отсутствует, результат будет иметь максимально возможную точность.
Несколько примеров:
239Функции и операторы
SELECT CURRENT_TIME;
Результат: 14:39:53.662522-05
SELECT CURRENT_DATE;
Результат: 2001-12-23
SELECT CURRENT_TIMESTAMP;
Результат: 2001-12-23 14:39:53.662522-05
SELECT CURRENT_TIMESTAMP(2);
Результат: 2001-12-23 14:39:53.66-05
SELECT LOCALTIMESTAMP;
Результат: 2001-12-23 14:39:53.662522
Так как эти функции возвращают время начала текущей транзакции, во время транзакции эти зна-
чения не меняются. Это считается не ошибкой, а особенностью реализации: цель такого поведе-
ния в том, чтобы в одной транзакции «текущее» время было одинаковым и для разных изменений
в одной транзакций записывалась одна отметка времени.
Примечание
В других СУБД эти значения могут изменяться чаще.
В PostgreSQL есть также функции, возвращающие время начала текущего оператора, а также те-
кущее время в момент вызова функции. Таким образом, в PostgreSQL есть следующие функции, не
описанные в стандарте SQL:
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
Функция transaction_timestamp() равнозначна конструкции CURRENT_TIMESTAMP, но в её названии
явно отражено, что она возвращает. Функция statement_timestamp() возвращает время начала
текущего оператора (более точно, время получения последнего командного сообщения от клиен-
та). Функции statement_timestamp() и transaction_timestamp() возвращают одно и то же значе-
ние в первой команде транзакции, но в последующих их показания будут расходиться. Функция
clock_timestamp() возвращает фактическое текущее время, так что её значение меняется в рам-
ках одной команды SQL. Функция timeofday() существует в PostgreSQL по историческим причи-
нам и, подобно clock_timestamp(), она возвращает фактическое текущее время, но представлен-
ное в виде форматированной строки типа text, а не значения timestamp with time zone. Функция
now() — традиционный для PostgreSQL эквивалент функции transaction_timestamp().
Все типы даты/времени также принимают специальное буквальное значение now, подразумеваю-
щее текущую дату и время (тоже на момент начала транзакции). Таким образом, результат следу-
ющих трёх операторов будет одинаковым:
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP ‘now’; – не подходит для DEFAULT
Подсказка
Третья форма не подходит для указания в качестве значения DEFAULT при создании
таблицы. Система преобразует now в значение timestamp в момент разбора константы,
поэтому, когда будет вставляться значение по умолчанию, в соответствующем столбце
окажется время создания таблицы! Первые две формы не будут вычисляться, пока не
240Функции и операторы
потребуется значение по умолчанию, так как это вызовы функции. Поэтому они дадут
желаемый результат при добавлении строки в таблицу.
9.9.5. Задержка выполнения
В случае необходимости вы можете приостановить выполнение серверного процесса, используя
следующие функции:
pg_sleep(сек)
pg_sleep_for(interval)
pg_sleep_until(timestamp with time zone)
Функция pg_sleep переводит процесс текущего сеанса в спящее состояние на указанное число се-
кунд (сек). Параметр сек имеет тип double precision, так что в нём можно указать и дробное чис-
ло. Функция pg_sleep_for введена для удобства, ей можно передать большие значения задержки
в типе interval. А pg_sleep_until удобнее использовать, когда необходимо задать определённое
время выхода из спящего состояния. Например:
SELECT pg_sleep(1.5);
SELECT pg_sleep_for(‘5 minutes’);
SELECT pg_sleep_until(‘tomorrow 03:00’);
Примечание
Действительное разрешение интервала задержки зависит от платформы; обычно это
0.01. Фактическая длительность задержки не будет меньше указанного времени, но
может быть больше, в зависимости, например от нагрузки на сервер. В частности, не
гарантируется, что pg_sleep_until проснётся именно в указанное время, но она точно
не проснётся раньше.
Предупреждение
Прежде чем вызывать pg_sleep или её вариации, убедитесь в том, что в текущем сеансе
нет ненужных блокировок. В противном случае в состояние ожидания могут перейти
и другие сеансы, так что это отразится на системе в целом.
9.10. Функции для перечислений
Для типов перечислений (описанных в Разделе 8.7) предусмотрено несколько функций, которые
позволяют сделать код чище, не «зашивая» в нём конкретные значения перечисления. Эти функ-
ции перечислены в Таблице 9.32. В этих примерах подразумевается, что перечисление создано так:
CREATE TYPE rainbow AS ENUM (‘red’, ‘orange’, ‘yellow’, ‘green’,
‘blue’, ‘purple’);
Таблица 9.32. Функции для перечислений
Функция Описание
Пример
enum_first(anyenum) Возвращает первое зна- enum_first(
чение заданного пере- null::rainbow)
числения red
enum_last(anyenum) Возвращает последнее enum_last(
значение заданного пе- null::rainbow)
речисления purple
enum_range(anyenum) Возвращает все значе- enum_range(
ния заданного перечис- null::rainbow) (red,orange,yellow,
green,blue,purple)
241
Результат примераФункции и операторы
Функция Описание
Пример
ления в упорядоченном
массиве Результат примера
enum_range(anyenum,
anyenum) Возвращает набор зна-
чений, лежащих меж-
ду двумя заданными,
в виде упорядоченного
массива. Эти значения
должны принадлежать
одному перечислению.
Если первый параметр
равен NULL, функция
возвращает первое зна-
чение перечисления, а
если NULL второй — по-
следнее. enum_range(
‘orange’::rainbow,
‘green’::rainbow) (orange,yellow,
green)
enum_range(NULL,
‘green’::rainbow) (red,orange,yellow,
green)
enum_range(
‘orange’::rainbow,
NULL) (orange,yellow,
green,blue,purple)
Заметьте, что за исключением варианта enum_range с двумя аргументами, эти функции не обра-
щают внимание на конкретное переданное им значение; их интересует только объявленный тип.
Они возвращают один и тот же результат, когда им передаётся NULL или любое другое значение
типа. Обычно эти функции применяются к столбцам таблицы или аргументам внешних функций,
а не к предопределённым типам, как показано в этих примерах.
9.11. Геометрические функции и операторы
Для геометрических типов point, box, lseg, line, path, polygon и circle разработан большой набор
встроенных функций и операторов, представленный в Таблице 9.33, Таблице 9.34 и Таблице 9.35.
Внимание
Заметьте, что оператор «идентичности», ~=, представляет обычное сравнение на ра-
венство значений point, box, polygon и circle. Для некоторых из этих типов опреде-
лён также оператор =, но = проверяет только равенство площадей. Другие скалярные
операторы сравнения (&amp;lt;= и т. д.) так же сравнивают площади значений этих типов.
Таблица 9.33. Геометрические операторы
Оператор Описание
Пример&lt;/li&gt;
    &lt;li&gt;Сдвиг
box ‘((0,0),(1,1))’
point ‘(2.0,0)’
+&lt;/li&gt;
    &lt;li&gt;Сдвиг
box ‘((0,0),(1,1))’
point ‘(2.0,0)’
-&lt;/li&gt;
    &lt;li&gt;Масштабирование/поворот
box ‘((0,0),(1,1))’
point ‘(2.0,0)’
*
/ Масштабирование/поворот
box ‘((0,0),(2,2))’
point ‘(2.0,0)’
/
      &lt;h1 id=&quot;Точка-или-прямоугольник-в-пе--box-1-1-11&quot;&gt;Точка или прямоугольник в пе- box ‘((1,-1),(-1,1))’&lt;/h1&gt;
      &lt;p&gt;ресечении
box ‘((1,1),(-2,-2))’&lt;/p&gt;
      &lt;h1 id=&quot;Число-точек-в-пути-или-вершин--path-1001&quot;&gt;Число точек в пути или вершин # path ‘((1,0),(0,1),(&lt;/h1&gt;
      &lt;p&gt;в многоугольнике
-1,0))’
@-@ Длина, периметр
окружности
@@ Центр
или
длина @-@
0))’
path
‘((0,0),(1,
@@ circle ‘((0,0),10)’
242Функции и операторы
Оператор Описание
Пример&lt;/p&gt;
      &lt;h2 id=&quot;Точка-ближайшая-к-перво--point-00--lseg-&quot;&gt;Точка, ближайшая к перво- point ‘(0,0)’ ## lseg ‘((&lt;/h2&gt;
      &lt;p&gt;му операнду и принадлежащая 2,0),(0,2))’
второму
&amp;lt;-&amp;gt; Расстояние между операндами circle ‘((0,0),1)’
circle ‘((5,0),1)’
&amp;amp;&amp;amp; Пересекаются ли операнды? ( box ‘((0,0),(1,1))’ &amp;amp;&amp;amp;
Для положительного ответа до- box ‘((0,0),(2,2))’
статочно одной общей точки.)
« Строго слева? circle
‘((0,0),1)’
circle ‘((5,0),1)’
«&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;p&gt;Строго справа? circle
‘((5,0),1)’
circle ‘((0,0),1)’&lt;/p&gt;

        &lt;p&gt;&amp;amp;&amp;lt; Не простирается правее? box ‘((0,0),(1,1))’ &amp;amp;&amp;lt;
box ‘((0,0),(2,2))’
&amp;amp;&amp;gt; Не простирается левее? box ‘((0,0),(3,3))’ &amp;amp;&amp;gt;
box ‘((0,0),(2,2))’
«| Строго ниже? box ‘((0,0),(3,3))’ «|
box ‘((3,4),(5,5))’
|» Строго выше? box ‘((3,4),(5,5))’ |»
box ‘((0,0),(3,3))’
&amp;amp;&amp;lt;| Не простирается выше? box ‘((0,0),(1,1))’ &amp;amp;&amp;lt;|
box ‘((0,0),(2,2))’
|&amp;amp;&amp;gt; Не простирается ниже? box ‘((0,0),(3,3))’ |&amp;amp;&amp;gt;
box ‘((0,0),(2,2))’
&amp;lt;^ Ниже (может касаться)? circle
‘((0,0),1)’
circle ‘((0,5),1)’
&amp;lt;^
^ Выше (может касаться)? circle
‘((0,5),1)’
circle ‘((0,0),1)’&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;?# Пересекает? lseg ‘((-1,0),(1,0))’ ?&lt;/p&gt;
  &lt;h1 id=&quot;box--2-222&quot;&gt;box ‘((-2,-2),(2,2))’&lt;/h1&gt;
  &lt;p&gt;?- Горизонтальный объект? ?-
lseg
0))’
?- Выровнены по горизонтали? point ‘(1,0)’ ?- point ‘(
0,0)’
?| Вертикальный объект? ?|
lseg
0))’
?| Выровнены по вертикали? point ‘(0,1)’ ?| point ‘(
0,0)’
?-| Перпендикулярны? lseg
‘((0,0),(0,
1))’ ?-| lseg ‘((0,0),(
1,0))’
?|| Параллельны? lseg
‘((-1,0),(1,
0))’ ?|| lseg ‘((-1,2),(
1,2))’
@&amp;gt; Первый объект включает вто- circle
‘((0,0),2)’
рой?
point ‘(1,1)’
243
&amp;lt;-&amp;gt;
‘((-1,0),(1,
‘((-1,0),(1,
@&amp;gt;Функции и операторы
Оператор Описание
Пример
&amp;lt;@ Первый объект включён во вто- point ‘(1,1)’ &amp;lt;@ circle ‘(
рой?
(0,0),2)’
~= Одинаковы?
polygon
‘((0,0),(1,
1))’ ~= polygon ‘((1,1),
(0,0))’
Примечание
До PostgreSQL 8.2 операторы включения @&amp;gt; и &amp;lt;@ назывались соответственно ~ и @. Эти
имена по-прежнему доступны, но считаются устаревшими и в конце концов будут уда-
лены.
Таблица 9.34. Геометрические функции
Функция Тип результата Описание Пример
area( объект) double precision площадь area(box ‘((0,0),
(1,1))’)
center( объект) point центр center(box
0),(1,2))’)
diameter( circle) double precision диаметр круга diameter(circle ‘((
0,0),2.0)’)
height( box) double precision вертикальный размер height(box
прямоугольника
0),(1,1))’)
isclosed( path) boolean замкнутый путь? isclosed(path
0,0),(1,1),(2,
0))’)
isopen( path) boolean открытый путь? isopen(path
0),(1,1),(2,
0)]’)
length( объект) double precision длина length(path ‘((-1,
0),(1,0))’)
npoints( path) int число точек npoints(path
0),(1,1),(2,
0)]’)
npoints( polygon) int число точек npoints(polygon ‘((
1,1),(0,0))’)
pclose( path) path преобразует путь в за- pclose(path
мкнутый
0),(1,1),(2,
0)]’)
popen( path) path преобразует путь в от- popen(path
‘((0,
крытый
0),(1,1),(2,
0))’)
radius( circle) double precision радиус окружности width( box) double precision горизонтальный
раз- width(box
мер прямоугольника
0),(1,1))’)
244
radius(circle
0,0),2.0)’)
‘((0,
‘((0,
‘((
‘[(0,
‘[(0,
‘[(0,
‘((
‘((0,Функции и операторы
Таблица 9.35. Функции преобразования геометрических типов
Функция Тип результата Описание
box( circle) box окружность
угольник
box( point) box точка в пустой прямо- box(point ‘(0,0)’)
угольник
box точки в прямоугольник box(point ‘(0,0)’,
point ‘(1,1)’)
box( polygon) box многоугольник в пря- box(polygon ‘((0,
моугольник
0),(1,1),(2,
0))’)
bound_box(
box) box прямоугольники в окру- bound_box(box ‘((
жающий прямоуголь- 0,0),(1,1))’,
ник
box ‘((3,3),(
4,4))’)
circle( box) circle прямоугольник
окружность
circle( point,
double precision) circle окружность из центра и circle(point
радиуса
0)’, 2.0)
circle( polygon) circle многоугольник
окружность
в circle(polygon
0,0),(1,1),(2,
0))’)
line( point, line точки в прямую
line(point
0)’,
point
0)’)
lseg диагональ прямоуголь- lseg(box
‘((-1,
ника в отрезок
0),(1,0))’)
lseg точки в отрезок
lseg(point
0)’,
point
0)’)
path многоугольник в путь
path(polygon ‘((0,
0),(1,1),(2,
0))’)
point образует точку
point(23.4, -44.5)
point( box) point центр прямоугольника point(box
‘((-1,
0),(1,0))’)
point( circle) point центр окружности
point(circle ‘((0,
0),2.0)’)
point( lseg) point центр отрезка
point(lseg ‘((-1,
0),(1,0))’)
point( polygon) point центр многоугольника
point(polygon
0,0),(1,1),(2,
0))’)
polygon( box) polygon прямоугольник в мно- polygon(box
гоугольник с 4 верши- 0),(1,1))’)
нами
box( point,
point)
box,
point)
lseg( box)
lseg( point,
point)
path( polygon)
point( double
precision,
precision)
Пример
в
прямо- box(circle
0),2.0)’)
в circle(box
0),(1,1))’)
‘((0,
‘((0,
‘(0,
‘((
‘(-1,
‘(1,
‘(-1,
‘(1,
double
245
‘((
‘((0,Функции и операторы
Функция Тип результата Описание
Пример
polygon( circle) polygon круг в многоугольник с polygon(circle
12 вершинами
0,0),2.0)’)
polygon( число_
точек, circle) polygon окружность с заданным polygon(12, circle
числом_точек
‘((0,0),2.0)’)
polygon( path) polygon путь в многоугольник
‘((
polygon(path ‘((0,
0),(1,1),(2,
0))’)
К двум компонентам типа point (точка) можно обратиться, как к элементам массива с индексами
0 и 1. Например, если t.p — столбец типа point, SELECT p[0] FROM t вернёт координату X, а UPDATE
t SET p[1] = … изменит координату Y. Таким же образом, значение типа box или lseg можно
воспринимать как массив двух значений типа point.
Функция area работает с типами box, circle и path. При этом для типа path заданный путь
не должен быть самопересекающимся. Например, эта функция не примет значение типа path
‘((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))’::PATH, но примет визуально идентичный путь
‘((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))’::PATH. Если вы не вполне поняли,
что здесь подразумевается под самопересечением пути, нарисуйте на бумаге две фигуры по при-
ведённым координатам.
9.12. Функции и операторы для работы с сетевыми ад-
ресами
В Таблица 9.36 показаны операторы, работающие с типами cidr и inet. Операторы «, «=, », »=
и &amp;amp;&amp;amp; проверяют включения подсетей, рассматривая только биты сети в обоих адресах (игнорируя
биты узлов) и определяя, идентична ли одна сеть другой или её подсети.
Таблица 9.36. Операторы для типов cidr и inet
Оператор Описание Пример &amp;lt; меньше inet ‘192.168.1.5’
‘192.168.1.6’ &amp;lt; inet
&amp;lt;= меньше или равно inet ‘192.168.1.5’
‘192.168.1.5’ &amp;lt;= inet
= равно inet ‘192.168.1.5’
‘192.168.1.5’ = inet
= больше или равно inet ‘192.168.1.5’
‘192.168.1.5’ &amp;gt;= inet
больше inet ‘192.168.1.5’
‘192.168.1.4’ &amp;gt; inet
&amp;lt;&amp;gt; не равно inet ‘192.168.1.5’
‘192.168.1.4’ &amp;lt;&amp;gt; inet
« содержится в inet ‘192.168.1.5’
‘192.168.1/24’ « inet
«= равно или содержится в inet ‘192.168.1/24’ «= inet
‘192.168.1/24’&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;содержит inet ‘192.168.1/24’ » inet
‘192.168.1.5’
= равно или содержит inet ‘192.168.1/24’ »= inet
‘192.168.1/24’
246Функции и операторы
Оператор Описание Пример
&amp;amp;&amp;amp; содержит или содержится в inet ‘192.168.1/24’ &amp;amp;&amp;amp; inet
‘192.168.1.80/28’
~ битовый NOT ~ inet ‘192.168.1.6’
&amp;amp; битовый AND inet ‘192.168.1.6’
‘0.0.0.255’
&amp;amp;
inet
| битовый OR inet ‘192.168.1.6’
‘0.0.0.255’
|
inet&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;сложение inet ‘192.168.1.6’ + 25&lt;/li&gt;
      &lt;li&gt;вычитание inet ‘192.168.1.43’ - 36&lt;/li&gt;
      &lt;li&gt;вычитание inet ‘192.168.1.43’
‘192.168.1.19’
-
inet
В Таблице 9.37 перечислены функции, работающие с типами cidr и inet. Функции abbrev, host и
text предназначены в основном для вывода данных в альтернативных форматах.
Таблица 9.37. Функции для типов cidr и inet
Функция Тип результата Описание abbrev( inet) text вывод
адрес
в abbrev(inet
кратком
тексто- ‘10.1.0.0/16’)
вом виде 10.1.0.0/16
abbrev( cidr) text вывод
адрес
в abbrev(cidr
кратком
тексто- ‘10.1.0.0/16’)
вом виде 10.1/16
broadcast( inet) inet широковещатель-
ный адрес сети 192.168.1.255/
24
family( inet) int возвращает семей- family(‘::1’)
ство адреса; 4 для
адреса IPv4, 6 для
IPv6 6
host( inet) text извлекает IP-адрес host(
в виде текста
‘192.168.1.5/
24’) 192.168.1.5
hostmask( inet) inet вычисляет маску hostmask(
узла для сетевого ‘192.168.23.20/
адреса
30’) 0.0.0.3
masklen( inet) int выдаёт длину мас- masklen(
ки сети
‘192.168.1.5/
24’) 24
netmask( inet) inet вычисляет маску netmask(
сети для сетевого ‘192.168.1.5/
адреса
24’) 255.255.255.0
network( inet) cidr извлекает компо- network(
нент сети из адре- ‘192.168.1.5/
са
24’) 192.168.1.0/24
set_masklen(
inet, int) inet задаёт размер мас- set_masklen(
ки для значения ‘192.168.1.5/
inet
24’, 16) 192.168.1.5/16
247
Пример
broadcast(
‘192.168.1.5/
24’)
РезультатФункции и операторы
Функция Тип результата Описание
Пример
Результат
set_masklen(
cidr, int) cidr задаёт размер мас- set_masklen(
ки для значения ‘192.168.1.0/
cidr
24’::cidr, 16) 192.168.0.0/16
text( inet) text выводит в тексто- text(inet
вом виде IP-адрес и ‘192.168.1.5’)
длину маски 192.168.1.5/32
inet_same_
family( inet,
inet) boolean адреса относятся inet_same_
false
к одному семей- family(
ству?
‘192.168.1.5/24’,
‘::1’)
inet_merge(
inet, inet) cidr наименьшая сеть, inet_merge(
192.168.0.0/22
включающая обе ‘192.168.1.5/24’,
заданные сети
‘192.168.2.5/24’)
Любое значение cidr можно привести к типу inet, явно или нет; поэтому все функции, показанные
выше с типом inet, также будут работать со значениями cidr. (Некоторые из функций указаны
отдельно для типов inet и cidr, потому что их поведение с разными типами различается.) Кроме
того, значение inet тоже можно привести к типу cidr. При этом все биты справа от сетевой маски
просто обнуляются, чтобы значение стало допустимым для типа cidr. К типам inet и cidr можно
привести и обычные текстовые значения, используя обычный синтаксис, например: inet(выраже-
ние) или столбец::cidr.
В Таблице  9.38 приведена функция, предназначенная для работы с типом macaddr. Функция
trunc(macaddr) возвращает MAC-адрес, последние 3 байта в котором равны 0. Это может быть по-
лезно для вычисления префикса, определяющего производителя.
Таблица 9.38. Функции macaddr
Функция Тип результата Описание
Пример
trunc( macaddr) macaddr обнуляет послед- trunc(macaddr
ние 3 байта
‘12:34:56:
78:90:ab’)
Результат
12:34:56:
00:00:00
Тип macaddr также поддерживает стандартные реляционные операторы лексической сортировки
(&amp;gt;, &amp;lt;= и т. д.) и операторы битовой арифметики (~, &amp;amp; и |), соответствующие операциям NOT, AND
и OR.
В Таблице  9.39 приведены функции, предназначенные для работы с типом macaddr8. Функция
trunc(macaddr8) возвращает MAC-адрес, последние 5 байт в котором равны нулю. Это может быть
полезно для вычисления префикса, определяющего производителя.
Таблица 9.39. Функции macaddr8
Функция
Тип результата
Описание
Пример
Результат
trunc( macaddr8) macaddr8 обнуляет послед- trunc(macaddr8
12:34:56:00:00:00:00:0
ние 5 байт
‘12:34:56:78:90:ab:cd:ef’)
macaddr8_
set7bit(
macaddr8) устанавливает в 7
бите единицу, что-
бы получить так
называемый моди-
фицированный ад-
рес EUI-64 (для
включения в адрес
IPv6)
macaddr8
248
macaddr8_
02:34:56:ff:fe:ab:cd:eФункции и операторы
Тип macaddr8 также поддерживает стандартные реляционные операторы лексической сортировки
(&amp;gt;, &amp;lt;= и т. д.) и операторы битовой арифметики (~, &amp;amp; и |), соответствующие операциям NOT, AND
и OR.
9.13. Функции и операторы текстового поиска
В Таблице 9.40, Таблице 9.41 и Таблице 9.42 собраны все существующие функции и операторы,
предназначенные для полнотекстового поиска. Во всех деталях возможности полнотекстового по-
иска в PostgreSQL описаны в Главе 12.
Таблица 9.40. Операторы текстового поиска
Оператор Тип результата Описание
Пример
Результат
@@ boolean tsvector соответ- to_tsvector(
t
ствует tsquery ?
‘fat cats ate
rats’)
@@
to_
tsquery(‘cat &amp;amp;
rat’)
@@@ boolean устаревший сино- to_tsvector(
t
ним для @@
‘fat cats ate
rats’) @@@ to_
tsquery(‘cat &amp;amp;
rat’)
|| tsvector объединяет
значения
tsvector
&amp;amp;&amp;amp; tsquery логическое И ( ‘fat
| ( ‘fat’ | ‘rat’ )
AND) двух запро- rat’::tsquery &amp;amp;&amp;amp; &amp;amp; ‘cat’
сов tsquery
‘cat’::tsquery
|| tsquery логическое ИЛИ ( ‘fat
| ( ‘fat’ | ‘rat’ )
OR) двух запросов rat’::tsquery || | ‘cat’
tsquery
‘cat’::tsquery
!! tsquery отрицание запро- !! ‘cat’::tsquery !’cat’
са tsquery
&amp;lt;-&amp;gt; tsquery tsquery предше- to_tsquery(
ствует tsquery
‘fat’) &amp;lt;-&amp;gt; to_
tsquery(‘rat’)
@&amp;gt; boolean запрос
tsquery ‘cat’::tsquery @&amp;gt; f
включает другой? ‘cat
&amp;amp;
rat’::tsquery
&amp;lt;@ boolean запрос
tsquery ‘cat’::tsquery &amp;lt;@ t
включён в другой? ‘cat
&amp;amp;
rat’::tsquery
два ‘a:1
‘a’:1
‘b’:2,5
b:2’::tsvector || ‘c’:3 ‘d’:4
‘c:1
d:2
b:3’::tsvector
‘fat’ &amp;lt;-&amp;gt; ‘rat’
Примечание
Операторы включения tsquery рассматривают только лексемы двух запросов, игнори-
руя операторы их сочетания.
В дополнение к операторам, перечисленным в этой таблице, для типов tsvector и tsquery опре-
делены обычные операторы сравнения для B-дерева (=, &amp;lt; и т. д.). Они не очень полезны для поиска,
но позволяют, в частности, создавать индексы для столбцов этих типов.
249Функции и операторы
Таблица 9.41. Функции текстового поиска
Функция Тип результата Описание
Пример
Результат
array_to_
tsvector(
text[]) tsvector преобразует мас- array_to_
сив
лексем
в tsvector(
tsvector
‘(fat,cat,
rat)’::text[]) ‘cat’ ‘fat’ ‘rat’
get_current_
ts_config() regconfig получает конфигу- get_current_
рацию текстового ts_config()
поиска по умолча-
нию english
length(
tsvector) integer число лексем
значении
tsvector numnode(
tsquery) integer число лексем и numnode(‘(fat &amp;amp;
5
операторов в за- rat)
|
просе tsquery
cat’::tsquery)
в length(‘fat:2,
3
4
cat:3
rat:5A’::tsvector)
plainto_
tsquery
tsquery(
[конфигурация
regconfig ,] за-
прос text) выдаёт значение plainto_
tsquery, игнори- tsquery(
руя пунктуацию
‘english’, ‘The
Fat Rats’) ‘fat’ &amp;amp; ‘rat’
phraseto_
tsquery
tsquery(
[конфигурация
regconfig ,] за-
прос text) выдаёт значение
tsquery для поис-
ка фразы, игнори-
руя пунктуацию ‘fat’ &amp;lt;-&amp;gt; ‘rat’
websearch_to_
tsquery
tsquery(
[конфигурация
regconfig ,] за-
прос text) преобразует в зна- websearch_to_
чение tsquery по- tsquery(
исковый запрос в ‘english’,
веб-стиле
‘“fat rat” or
rat’) querytree(
запрос tsquery) text получает индекси- querytree(‘foo
руемую часть за- &amp;amp;
проса tsquery
bar’::tsquery) setweight(
вектор tsvector,
вес “char”) tsvector
phraseto_
tsquery(
‘english’, ‘The
Fat Rats’)
‘fat’ &amp;lt;-&amp;gt; ‘rat’ |
‘rat’
‘foo’
!
назначает
вес setweight(
‘cat’:3A
каждому элементу ‘fat:2,4 cat:3
‘fat’:2A,4A
вектора
rat:5B’::tsvector, ‘rat’:5A
‘A’)
setweight(
tsvector
вектор tsvector,
вес “char”, лек-
семы text[]) назначает вес эле- setweight(
‘cat’:3A ‘fat’:2,
ментам
вектора, ‘fat:2,4 cat:3
4 ‘rat’:5A
перечисленным в rat:5B’::tsvector,
массиве лексемы
‘A’, ‘(cat,
rat)’)
strip( tsvector) tsvector убирает позиции и strip(‘fat:2,4
‘cat’ ‘fat’ ‘rat’
веса из значения cat:3
tsvector
rat:5A’::tsvector)
to_tsquery(
tsquery
[конфигурация
regconfig ,] за-
прос text) нормализует слова to_tsquery(
и переводит их в ‘english’, ‘The
tsquery
&amp;amp; Fat &amp;amp; Rats’)
250
‘fat’ &amp;amp; ‘rat’Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
to_tsvector(
tsvector
[конфигурация
regconfig ,] до-
кумент text) сокращает текст to_tsvector(
документа до зна- ‘english’, ‘The
чения tsvector
Fat Rats’) ‘fat’:2 ‘rat’:3
to_tsvector(
tsvector
[конфигурация
regconfig ,] до-
кумент json(b) ) сокращает
каж-
дое строковое зна-
чение
в
доку-
менте до значе-
ния tsvector, а
затем складывает
эти значения по
порядку в доку-
менте и выдаёт
один tsvector to_tsvector(
‘english’,
‘(“a”: “The Fat
Rats”)’::json) ‘fat’:2 ‘rat’:3
json(b)&lt;em&gt;to&lt;/em&gt;
tsvector
tsvector(
[конфигурация
regconfig,]
до-
кумент json(b) ,
фильтр json(b) ) сокращает каждое
значение в до-
кументе, заданное
фильтром, до векто-
ра tsvector, а за-
тем соединяет их
в порядке следо-
вания в докумен-
те и получает один
tsvector. Фильтр
представляет со-
бой массив jsonb,
в котором пере-
числяются
типы
элементов, кото-
рые должны войти
в результирующий
tsvector. Возмож-
ные значения для
элементов филь-
тра: “string” (
включить все стро-
ковые значения),
“numeric” (вклю-
чить все числовые
значения в виде
строк), “boolean” (
включить все логи-
ческие значения
в
виде
“true”/
“false”), “key” (
включить все клю-
чи) или “all” (
включить всё вы-
шеперечислен-
ное). Эти значения
можно комбиниро-
вать для вклю-
чения, например,
всех строковых и json_to_
tsvector(
‘english’,
‘(“a”:
“The
Fat Rats”, “b”:
123)’::json,
‘[“string”,
“numeric”]’) ‘123’:5
‘rat’:3
251
‘fat’:2Функции и операторы
Функция Тип результата Описание
Пример
числовых
значе-
ний.
Результат
ts_delete(
вектор tsvector,
лексема text) tsvector удаляет заданную ts_delete(
‘cat’:3 ‘rat’:5A
лексему из векто- ‘fat:2,4 cat:3
ра
rat:5A’::tsvector,
‘fat’)
ts_delete(
вектор tsvector,
лексемы text[]) tsvector удаляет все вхож-
дения лексем, пе-
речисленных
в
массиве лексемы,
из вектора
ts_filter(
вектор tsvector,
веса “char”[]) tsvector выбирает из век- ts_filter(
‘cat’:3B ‘rat’:5A
тора только эле- ‘fat:2,4 cat:3b
менты с заданным rat:5A’::tsvector,
весом
‘(a,b)’)
ts_delete(
‘cat’:3
‘fat:2,4 cat:3
rat:5A’::tsvector,
ARRAY[‘fat’,
‘rat’])
ts_headline(
text
[конфигурация
regconfig,]
до-
кумент text, за-
прос tsquery [,
параметры text]) выводит
фраг- ts_headline(‘x
x y &lt;b&gt;z&lt;/b&gt;
мент, соответству- y
z’,
ющий запросу
‘z’::tsquery)
ts_headline(
text
[конфигурация
regconfig,]
до-
кумент json(b) ,
запрос
tsquery
[,
параметры
text]) выводит
фраг- ts_headline(
мент, соответству- ‘(“a”:”x
y
ющий запросу
z”)’::json,
‘z’::tsquery) (“a”:”x y &lt;b&gt;z&amp;lt;/
b&amp;gt;”)
ts_rank([ веса float4
float4[],]
век-
тор
tsvector,
запрос
tsquery
[,
нормализация
integer]) вычисляет
ранг ts_rank(
документа по от- textsearch,
ношению к запро- query)
су 0.818
ts_rank_cd(
float4
[веса float4[],]
вектор tsvector,
запрос
tsquery
[,
нормализация
integer]) вычисляет
ранг ts_rank_cd(
документа по от- ‘(0.1,
0.2,
ношению к за-
0.4, 1.0)’,
просу, используя
textsearch,
плотность покры- query)
тия (CDR) 2.01317
ts_rewrite(
запрос tsquery,
цель
tsquery,
замена tsquery) tsquery подставляет в за- ts_rewrite(‘a &amp;amp;
просе вместо цели b’::tsquery,
замену
‘a’::tsquery,
‘foo|
bar’::tsquery) ‘b’ &amp;amp; ( ‘foo’ |
‘bar’ )
ts_rewrite(
запрос tsquery,
выборка text) tsquery заменяет элемен-
ты запроса, выби-
рая цели и под-
становки
коман-
дой SELECT
252
SELECT
ts_ ‘b’ &amp;amp; ( ‘foo’ |
rewrite(‘a
&amp;amp;
‘bar’ )
b’::tsquery,
‘SELECT t,s
FROM aliases’)Функции и операторы
Функция
Тип результата
Описание Пример Результат
tsquery_
tsquery
phrase( запрос1
tsquery, запрос2
tsquery) создаёт запрос, ко-
торый ищет за-
прос1, за кото-
рым идёт запрос2 (
как делает опера-
тор &amp;lt;-&amp;gt;) tsquery_phrase(
to_tsquery(
‘fat’),
to_
tsquery(
‘cat’)) ‘fat’ &amp;lt;-&amp;gt; ‘cat’
tsquery_
tsquery
phrase( запрос1
tsquery, запрос2
tsquery, рассто-
яние integer) создаёт запрос, ко-
торый ищет за-
прос1, за которым
идёт запрос2 на
заданном рассто-
янии tsquery_phrase(
to_tsquery(
‘fat’),
to_
tsquery(
‘cat’), 10) ‘fat’ &amp;lt;10&amp;gt; ‘cat’
tsvector_to_
array(
tsvector) text[] преобразует
tsvector_to_
(cat,fat,rat)
tsvector в массив array(‘fat:2,
лексем
4
cat:3
rat:5A’::tsvector)
tsvector_
update_
trigger() trigger триггерная функ-
ция для автома-
тического измене-
ния столбца типа
tsvector CREATE
TRIGGER
…
tsvector_
update_
trigger(
tsvcol,
‘pg_
catalog.
swedish’,
title, body) tsvector_
update_
trigger_
column() trigger триггерная функ-
ция для автома-
тического измене-
ния столбца типа
tsvector CREATE
TRIGGER
…
tsvector_
update_
trigger_
column(tsvcol,
configcol,
title, body)
unnest(
setof record
tsvector,
OUT
лексема
text,
OUT
позиции
smallint[], OUT
веса text)
разворачивает
unnest(‘fat:2,
(cat,(3),
tsvector в набор 4
cat:3 (D)) …
строк
rat:5A’::tsvector)
Примечание
Все функции текстового поиска, принимающие необязательный аргумент regconfig,
будут использовать конфигурацию, указанную в параметре default_text_search_config,
когда этот аргумент опущен.
Функции в Таблице  9.42 перечислены отдельно, так как они не очень полезны в традиционных
операциях поиска. Они предназначены в основном для разработки и отладки новых конфигураций
текстового поиска.
253Функции и операторы
Таблица 9.42. Функции отладки текстового поиска
Функция
Тип результата
Описание
Пример
Результат
ts_debug(
setof record
[конфигурация
regconfig,]
до-
кумент
text,
OUT
псевдоним
text, OUT
опи-
сание text, OUT
фрагмент
text,
OUT
словари
regdictionary[],
OUT
словарь
regdictionary,
OUT
лексемы
text[]) проверяет конфи- ts_debug(
гурацию
‘english’, ‘The
Brightest
supernovaes’) (asciiword,
“Word,
all
ASCII”,The,(
english_stem
),english_
stem,()) …
ts_lexize(
словарь
regdictionary,
фрагмент text) проверяет словарь ts_lexize(
‘english_
stem’, ‘stars’) (star)
ts_parse( имя_ setof record
анализатора
text,
доку-
мент
text,
OUT код_фрагмен-
та integer, OUT
фрагмент text) проверяет
затор анали- ts_parse(
‘default’, ‘foo&lt;/b&gt;&lt;/li&gt;
      &lt;li&gt;bar’) (1,foo) …
ts_parse( oid_
анализатора oid,
документ
text,
OUT код_фрагмен-
та integer, OUT
фрагмент text) проверяет
затор анали- ts_parse(3722,
‘foo - bar’) (1,foo) …
text[]
setof record
ts_token_
setof record
type( имя_
анализатора
text, OUT код_
фрагмента
integer,
OUT
псевдоним text,
OUT
описание
text) получает
типы ts_token_type(
фрагментов, опре- ‘default’)
делённые анализа-
тором (1,asciiword,
“Word,
all
ASCII”) …
ts_token_
setof record
type( oid_
анализатора oid,
OUT
код_фраг-
мента
integer,
OUT
псевдоним
text, OUT описа-
ние text) получает
типы ts_token_type(
фрагментов, опре- 3722)
делённые анализа-
тором (1,asciiword,
“Word,
all
ASCII”) …
ts_stat(
запрос
[веса получает
стати- ts_stat(
стику
столбца ‘SELECT
vector
tsvector
from apod’) (foo,10,
15) …
sql_
text,
text,
setof record
254Функции и операторы
Функция
Тип результата
]
OUT
слово
text, OUT
чис-
ло_док integer,
OUT число_вхожд
integer)
Описание
Пример
Результат
9.14. XML-функции
Функции и подобные им выражения, описанные в этом разделе, работают со значениями типа xml.
Информацию о типе xml вы можете найти в Разделе 8.13. Выражения xmlparse и xmlserialize,
преобразующие значения xml в текст и обратно, здесь повторно не рассматриваются. Для исполь-
зования большинства этих функций дистрибутив должен быть собран с ключом configure –with-
libxml.
9.14.1. Создание XML-контента
Для получения XML-контента из данных SQL существует целый набор функций и функциональных
выражений, особенно полезных для выдачи клиентским приложениям результатов запроса в виде
XML-документов.
9.14.1.1. xmlcomment
xmlcomment(текст)
Функция xmlcomment создаёт XML-значение, содержащее XML-комментарий с заданным текстом.
Этот текст не должен содержать «–» или заканчиваться знаком «-», чтобы результирующая кон-
струкция была допустимой в XML. Если аргумент этой функции NULL, результатом её тоже будет
NULL.
Пример:
SELECT xmlcomment(‘hello’);
xmlcomment
————–
&lt;!--hello--&gt;
9.14.1.2. xmlconcat
xmlconcat(xml[, …])
Функция xmlconcat объединяет несколько XML-значений и выдаёт в результате один фрагмент
XML-контента. Значения NULL отбрасываются, так что результат будет равен NULL, только если
все аргументы равны NULL.
Пример:
SELECT xmlconcat(‘&lt;abc&gt;&lt;/abc&gt;’, ‘&lt;bar&gt;foo&lt;/bar&gt;’);
xmlconcat
———————-&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;abc /&gt;
&lt;bar&gt;foo&lt;/bar&gt;
&lt;p&gt;XML-объявления, если они присутствуют, обрабатываются следующим образом. Если во всех ар-
гументах содержатся объявления одной версии XML, эта версия будет выдана в результате; в про-
тивном случае версии не будет. Если во всех аргументах определён атрибут standalone со значе-
нием «yes», это же значение будет выдано в результате. Если во всех аргументах есть объявление
standalone, но минимум в одном со значением «no», в результате будет это значение. В противном
255Функции и операторы
случае в результате не будет объявления standalone. Если же окажется, что в результате должно
присутствовать объявление standalone, а версия не определена, тогда в результате будет выведена
версия 1.0, так как XML-объявление не будет допустимым без указания версии. Указания кодиров-
ки игнорируются и будут удалены в любых случаях.
Пример:
SELECT xmlconcat(‘&lt;?xml version=&quot;1.1&quot;?&gt;&lt;foo&gt;&lt;/foo&gt;’, ‘&amp;lt;?xml version=”1.1” standalone=”no”?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;bar /&gt;
  &lt;p&gt;’);
xmlconcat
———————————–
&lt;?xml version=&quot;1.1&quot;?&gt;&lt;foo&gt;&lt;/foo&gt;&lt;bar&gt;&lt;/bar&gt;
9.14.1.3. xmlelement
xmlelement(name имя [, xmlattributes(значение [AS атрибут] [, …])]
[, содержимое, …])
Выражение xmlelement создаёт XML-элемент с заданным именем, атрибутами и содержимым.
Примеры:
SELECT xmlelement(name foo);
xmlelement
————&lt;/p&gt;
&lt;/blockquote&gt;
&lt;foo /&gt;

&lt;p&gt;SELECT xmlelement(name foo, xmlattributes(‘xyz’ as bar));
xmlelement
——————&lt;/p&gt;
&lt;foo bar=&quot;xyz&quot; /&gt;

&lt;p&gt;SELECT xmlelement(name foo, xmlattributes(current_date as bar), ‘cont’, ‘ent’);
xmlelement
————————————-&lt;/p&gt;
&lt;foo bar=&quot;2007-01-26&quot;&gt;content&lt;/foo&gt;
&lt;p&gt;Если имена элементов и атрибутов содержат символы, недопустимые в XML, эти символы заме-
няются последовательностями &lt;em&gt;xHHHH&lt;/em&gt;, где HHHH — шестнадцатеричный код символа в Unicode.
Например:
SELECT xmlelement(name “foo$bar”, xmlattributes(‘xyz’ as “a&amp;amp;b”));
xmlelement
———————————-&lt;/p&gt;
&lt;foo_x0024_bar a_x0026_b=&quot;xyz&quot; /&gt;

&lt;p&gt;Если в качестве значения атрибута используется столбец таблицы, имя атрибута можно не указы-
вать явно, этим именем станет имя столбца. Во всех остальных случаях имя атрибута должно быть
определено явно. Таким образом, это выражение допустимо:
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
А следующие варианты — нет:
SELECT xmlelement(name test, xmlattributes(‘constant’), a, b) FROM test;
256Функции и операторы
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
Содержимое элемента, если оно задано, будет форматировано согласно его типу данных. Когда
оно само имеет тип xml, из него можно конструировать сложные XML-документы. Например:
SELECT xmlelement(name foo, xmlattributes(‘xyz’ as bar),
xmlelement(name abc),
xmlcomment(‘test’),
xmlelement(name xyz));
xmlelement
———————————————-&lt;/p&gt;
&lt;foo bar=&quot;xyz&quot;&gt;&lt;abc /&gt;&lt;!--test--&gt;&lt;xyz /&gt;&lt;/foo&gt;
&lt;p&gt;Содержимое других типов будет оформлено в виде блока символьных данных XML. Это, в частно-
сти, означает, что символы &amp;lt;, &amp;gt; и &amp;amp; будут преобразованы в сущности XML. Двоичные данные (дан-
ные типа bytea) представляются в кодировке base64 или в шестнадцатеричном виде, в зависимо-
сти от значения параметра xmlbinary. Следует ожидать, что конкретные представления отдельных
типов данных могут быть изменены для приведения типов SQL и PostgreSQL в соответствие со
стандартом XML Schema, когда появится его более полное описание.
9.14.1.4. xmlforest
xmlforest(содержимое [AS имя] [, …])
Выражение xmlforest создаёт последовательность XML-элементов с заданными именами и содер-
жимым.
Примеры:
SELECT xmlforest(‘abc’ AS foo, 123 AS bar);
xmlforest
——————————&lt;/p&gt;
&lt;foo&gt;abc&lt;/foo&gt;
&lt;bar&gt;123&lt;/bar&gt;
&lt;p&gt;SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = ‘pg_catalog’;
xmlforest
——————————————————————————————-&lt;/p&gt;
&lt;table_name&gt;pg_authid&lt;/table_name&gt;
&lt;column_name&gt;rolname&lt;/column_name&gt;
&lt;table_name&gt;pg_authid&lt;/table_name&gt;
&lt;column_name&gt;rolsuper&lt;/column_name&gt;
&lt;p&gt;…
Как показано во втором примере, имя элемента можно опустить, если источником содержимого
служит столбец (в этом случае именем элемента по умолчанию будет имя столбца). В противном
случае это имя необходимо указывать.
Имена элементов с символами, недопустимыми для XML, преобразуются так же, как и для
xmlelement. Данные содержимого тоже приводятся к виду, допустимому для XML (кроме данных,
которые уже имеют тип xml).
Заметьте, что такие XML-последовательности не являются допустимыми XML-документами, если
они содержат больше одного элемента на верхнем уровне, поэтому может иметь смысл вложить
выражения xmlforest в xmlelement.
9.14.1.5. xmlpi
257Функции и операторы
xmlpi(name цель [, содержимое])
Выражение xmlpi создаёт инструкцию обработки XML. Содержимое, если оно задано, не должно
содержать последовательность символов ?&amp;gt;.
Пример:
SELECT xmlpi(name php, ‘echo “hello world”;’);
xmlpi
—————————–
&lt;?php echo &quot;hello world&quot;;?&gt;
9.14.1.6. xmlroot
xmlroot(xml, version текст | нет значения [, standalone yes|no|нет значения])
Выражение xmlroot изменяет свойства корневого узла XML-значения. Если в нём указывается
версия, она заменяет значение в объявлении версии корневого узла; также в корневой узел пере-
носится значение свойства standalone.
SELECT xmlroot(xmlparse(document ‘&lt;?xml version=&quot;1.1&quot;?&gt;&lt;content&gt;abc&lt;/content&gt;’),
version ‘1.0’, standalone yes);
xmlroot
—————————————-
&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;/p&gt;
&lt;content&gt;abc&lt;/content&gt;
&lt;p&gt;9.14.1.7. xmlagg
xmlagg(xml)
Функция xmlagg, в отличие от других описанных здесь функций, является агрегатной. Она соеди-
няет значения, поступающие на вход агрегатной функции, подобно функции xmlconcat, но делает
это, обрабатывая множество строк, а не несколько выражений в одной строке. Дополнительно аг-
регатные функции описаны в Разделе 9.20.
Пример:
CREATE
INSERT
INSERT
SELECT
TABLE test (y int, x xml);
INTO test VALUES (1, ‘&lt;foo&gt;abc&lt;/foo&gt;’);
INTO test VALUES (2, ‘&lt;bar&gt;&lt;/bar&gt;’);
xmlagg(x) FROM test;
xmlagg
———————-&lt;/p&gt;
&lt;foo&gt;abc&lt;/foo&gt;
&lt;bar /&gt;

&lt;p&gt;Чтобы задать порядок сложения элементов, в агрегатный вызов можно добавить предложение
ORDER BY, описанное в Подраздел 4.2.7. Например:
SELECT xmlagg(x ORDER BY y DESC) FROM test;
xmlagg
———————-&lt;/p&gt;
&lt;bar /&gt;
&lt;foo&gt;abc&lt;/foo&gt;
&lt;p&gt;Следующий нестандартный подход рекомендовался в предыдущих версиях и может быть по-преж-
нему полезен в некоторых случаях:
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
xmlagg
258Функции и операторы
———————-&lt;/p&gt;
&lt;bar /&gt;
&lt;foo&gt;abc&lt;/foo&gt;
&lt;p&gt;9.14.2. Условия с XML
Описанные в этом разделе выражения проверяют свойства значений xml.
9.14.2.1. IS DOCUMENT
xml IS DOCUMENT
Выражение IS DOCUMENT возвращает true, если аргумент представляет собой правильный XML-
документ, false в противном случае (т. е. если это фрагмент содержимого) и NULL, если его аргу-
мент также NULL. Чем документы отличаются от фрагментов содержимого, вы можете узнать в
Разделе 8.13.
9.14.2.2. IS NOT DOCUMENT
xml IS NOT DOCUMENT
Выражение IS NOT DOCUMENT возвращает false, если аргумент представляет собой правильный
XML-документ, true в противном случае (т. е. если это фрагмент содержимого) и NULL, если его
аргумент — NULL.
9.14.2.3. XMLEXISTS
XMLEXISTS(текст
PASSING [BY REF] xml [BY REF])
Функция xmlexists возвращает true, если выражение XPath в первом аргументе возвращает какие
либо узлы, и false — в противном случае. (Если один из аргументов равен NULL, результатом также
будет NULL.)
Пример:
SELECT xmlexists(‘//town[text() = ‘‘Toronto’’]’ PASSING BY REF ‘&lt;towns&gt;&lt;town&gt;Toronto&amp;lt;/
town&amp;gt;&lt;town&gt;Ottawa&lt;/town&gt;&amp;lt;/towns&amp;gt;');
xmlexists
------------
t
(1 row)
Указания BY REF не несут смысловой нагрузки в PostgreSQL, но могут присутствовать для соответ-
ствия стандарту SQL и совместимости с другими реализациями. По стандарту SQL первое указа-
ние BY REF является обязательным, а второе — нет. Также заметьте, что, согласно стандарту SQL,
конструкция xmlexists должна принимать в первом аргументе выражение XQuery, но PostgreSQL
в настоящее время поддерживает только XPath, подмножество XQuery.
9.14.2.4. xml_is_well_formed
xml_is_well_formed(текст)
xml_is_well_formed_document(текст)
xml_is_well_formed_content(текст)
Эти функции проверяют, является ли текст правильно оформленным XML, и возвращают соответ-
ствующее логическое значение. Функция xml_is_well_formed_document проверяет аргумент как
правильно оформленный документ, а xml_is_well_formed_content — правильно оформленное со-
держание. Функция xml_is_well_formed может делать первое или второе, в зависимости от значе-
ния параметра конфигурации xmloption (DOCUMENT или CONTENT, соответственно). Это значит, что
259Функции и операторы
xml_is_well_formed помогает понять, будет ли успешным простое приведение к типу xml, тогда
как две другие функции проверяют, будут ли успешны соответствующие варианты XMLPARSE.
Примеры:
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('&amp;lt;&amp;gt;');
xml_is_well_formed
--------------------
f
(1 row)
SELECT xml_is_well_formed('&lt;abc&gt;&lt;/abc&gt;');
xml_is_well_formed
--------------------
t
(1 row)
SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
xml_is_well_formed
--------------------
t
(1 row)
SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg=&quot;http://postgresql.org/ stuff&quot;&gt;bar&lt;/pg:foo&gt;');
xml_is_well_formed_document
-----------------------------
t
(1 row)
SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg=&quot;http://postgresql.org/ stuff&quot;&gt;bar&amp;lt;/my:foo&amp;gt;');
xml_is_well_formed_document
-----------------------------
f
(1 row)
Последний пример показывает, что при проверке также учитываются сопоставления пространств
имён.
9.14.3. Обработка XML
Для обработки значений типа xml в PostgreSQL представлены функции xpath и xpath_exists, вы-
числяющие выражения XPath 1.0, а также табличная функция XMLTABLE.
9.14.3.1. xpath
xpath(xpath, xml [, nsarray])
Функция xpath вычисляет выражение XPath (аргумент xpath типа text) для заданного xml. Она
возвращает массив XML-значений с набором узлов, полученных в результате выражения XPath.
Если выражение XPath выдаёт не набор узлов, а скалярное значение, возвращается массив из од-
ного элемента.
Вторым аргументом должен быть правильно оформленный XML-документ. В частности, в нём дол-
жен быть единственный корневой элемент.
В необязательном третьем аргументе функции передаются сопоставления пространств имён. Эти
сопоставления должны определяться в двумерном массиве типа text, во второй размерности ко-
260Функции и операторы
торого 2 элемента (т. е. это должен быть массив массивов, состоящих из 2 элементов). В первом
элементе каждого массива определяется псевдоним (префикс) пространства имён, а во втором —
его URI. Псевдонимы, определённые в этом массиве, не обязательно должны совпадать с префик-
сами пространств имён в самом XML-документе (другими словами, для XML-документа и функции
xpath псевдонимы имеют локальный характер).
Пример:
SELECT xpath('/my:a/text()', '&lt;my:a xmlns:my=&quot;http://example.com&quot;&gt;test&lt;/my:a&gt;',
ARRAY[ARRAY['my', 'http://example.com']]);
xpath
--------
(test)
(1 row)
Для пространства имён по умолчанию (анонимного) это выражение можно записать так:
SELECT xpath('//mydefns:b/text()', '&lt;a xmlns=&quot;http://example.com&quot;&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;',
ARRAY[ARRAY['mydefns', 'http://example.com']]);
xpath
--------
(test)
(1 row)
9.14.3.2. xpath_exists
xpath_exists(xpath, xml [, nsarray])
Функция xpath_exists представляет собой специализированную форму функции xpath. Она воз-
вращает не весь набор XML-узлов, удовлетворяющих выражению XPath, а только одно логическое
значение, показывающее, есть ли такие узлы. Эта функция равнозначна стандартному условию
XMLEXISTS, за исключением того, что она также поддерживает сопоставления пространств имён.
Пример:
SELECT xpath_exists('/my:a/text()', '&lt;my:a xmlns:my=&quot;http://example.com&quot;&gt;test&lt;/my:a&gt;',
ARRAY[ARRAY['my', 'http://example.com']]);
xpath_exists
--------------
t
(1 row)
9.14.3.3. xmltable
xmltable( [XMLNAMESPACES(URI пространства имён AS имя пространства имён[, ...]),]
выражение_строки PASSING [BY REF] выражение_документа [BY REF]
COLUMNS имя ( type [PATH выражение_столбца] [DEFAULT выражение_по_умолчанию]
[NOT NULL | NULL]
| FOR ORDINALITY )
[, ...]
)
Функция xmltable строит таблицу из данного XML-значения по фильтру XPath, извлекающему
строки, с необязательным набором определений столбцов.
Необязательное предложение XMLNAMESPACES задаёт разделённый запятыми список пространств
имён. В нём определяются пространства имён XML и их псевдонимы. Определение пространства
по умолчанию в настоящее время не поддерживается.
261Функции и операторы
Обязательный аргумент выражение_строки задаёт выражение XPath, вычисляемое в данном XML-
документе и выдающее упорядоченную последовательность XML-узлов. Эту последовательность
xmltable преобразует в выходные строки.
В аргументе выражение_документа передаётся XML-документ для обработки. Предложения BY REF
не действуют в PostgreSQL, но допускаются для соответствия стандарту SQL и совместимости
с другими реализациями. Передаваемый XML-документ должен быть правильно оформленным;
фрагменты/леса не принимаются.
В предложении COLUMNS задаётся список столбцов в выходной таблице. Если предложение COLUMNS
опускается, строки в результирующем наборе содержат один столбец типа xml с данными, кото-
рые отобрало выражение_строки. Если COLUMNS присутствует, каждый его элемент описывает один
столбец. Формат этого предложения показан выше в примере синтаксиса. Имя столбца и его тип
должны задаваться обязательно: путь, значение по умолчанию и признак допустимости NULL мо-
гут опускаться.
Столбец с признаком FOR ORDINALITY будет заполняться номерами строк, соответствующими по-
рядку, в котором строки находились в исходном документе XML. Признак FOR ORDINALITY может
быть не больше чем у одного столбца.
В указании выражение_столбца для столбца задаётся выражение XPath, вычисляемое для каждой
строки относительно результата выражение_строки и выдающее значение столбца. Если выраже-
ние_столбца отсутствует, в качестве неявного пути используется имя столбца.
Если выражение XPath для столбца выдаёт несколько элементов, происходит ошибка. Если вы-
ражению соответствует пустой элемент, результатом будет пустая строка (не NULL). Атрибуты
xsi:nil при поиске игнорируются.
Значением столбца становится текстовое содержимое XML-узла, отобранного выражением_столб-
ца. Несколько узлов text() внутри целевого элемента складываются вместе по порядку. Все до-
черние элементы, инструкции обработки и комментарии игнорируются, но текстовое содержи-
мое дочерних элементов добавляется к результату. Заметьте, что исключительно пробельные узлы
text() между двумя не текстовыми элементами сохраняются, как не убираются и ведущие пробе-
лы в узле text().
Если выражение пути не находит элемент строки, но задано выражение_по_умолчанию, значением
поля становится результат вычисления этого выражения. Если предложение DEFAULT для этого
столбца отсутствует, в это поле записывается NULL. В выражении_по_умолчанию можно обращаться
к значениям выходных столбцов, описанных ранее в списке столбцов, так что значение по умол-
чанию одного столбца можно получить из значения другого.
Столбцы могут иметь признак NOT NULL. Если выражение_столбца для столбца с признаком NOT NULL
не соответствует ничему и при этом отсутствует указание DEFAULT или выражение_по_умолчанию
также выдаёт NULL, происходит ошибка.
В отличие от обычных функций PostgreSQL, выражение_столбца и выражение_по_умолчанию не сво-
дятся к единственному простому значению перед вызовом функции. Так, выражение_столбца обыч-
но вычисляется ровно один раз для каждой входной строки, а выражение_по_умолчанию вычисля-
ется каждый раз, когда для поля требуется значение по умолчанию. Если выражение оказывается
стабильным или постоянным, повторное вычисление может не выполняться. По сути xmltable дей-
ствует больше как подзапрос, а не как вызов функции. Это значит, что вы можете с пользой при-
менять изменчивые функции, такие как nextval в выражении_по_умолчанию, а выражение_столбца
может зависеть от других частей XML-документа.
Примеры:
CREATE TABLE xmldata AS SELECT
xml $$
262Функции и операторы&lt;/pg:foo&gt;&lt;/town&gt;&lt;/towns&gt;&lt;/p&gt;
&lt;ROWS&gt;
&lt;ROW id=&quot;1&quot;&gt;
&lt;COUNTRY_ID&gt;AU&lt;/COUNTRY_ID&gt;
&lt;COUNTRY_NAME&gt;Australia&lt;/COUNTRY_NAME&gt;
&lt;/ROW&gt;
&lt;ROW id=&quot;5&quot;&gt;
&lt;COUNTRY_ID&gt;JP&lt;/COUNTRY_ID&gt;
&lt;COUNTRY_NAME&gt;Japan&lt;/COUNTRY_NAME&gt;
&lt;PREMIER_NAME&gt;Shinzo Abe&lt;/PREMIER_NAME&gt;
&lt;SIZE unit=&quot;sq_mi&quot;&gt;145935&lt;/SIZE&gt;
&lt;/ROW&gt;
&lt;ROW id=&quot;6&quot;&gt;
&lt;COUNTRY_ID&gt;SG&lt;/COUNTRY_ID&gt;
&lt;COUNTRY_NAME&gt;Singapore&lt;/COUNTRY_NAME&gt;
&lt;SIZE unit=&quot;sq_km&quot;&gt;697&lt;/SIZE&gt;
&lt;/ROW&gt;
&lt;/ROWS&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;AS data;
SELECT xmltable.*
FROM xmldata,
XMLTABLE('//ROWS/ROW'
PASSING data
COLUMNS id int PATH '@id',
ordinality FOR ORDINALITY,
&quot;COUNTRY_NAME&quot; text,
country_id text PATH 'COUNTRY_ID',
size_sq_km float PATH 'SIZE[@unit = &quot;sq_km&quot;]',
size_other text PATH
'concat(SIZE[@unit!=&quot;sq_km&quot;], &quot; &quot;, SIZE[@unit!=&quot;sq_km&quot;]/
@unit)',
premier_name text PATH 'PREMIER_NAME' DEFAULT 'not
specified') ;
id | ordinality | COUNTRY_NAME | country_id | size_sq_km |
size_other
| premier_name
----+------------+--------------+------------+------------+--------------
+---------------
1 |
1 | Australia
| AU
|
|
| not
specified
5 |
2 | Japan
| JP
|
| 145935 sq_mi | Shinzo Abe
6 |
3 | Singapore
| SG
|
697 |
| not
specified
Следующий пример иллюстрирует сложение нескольких узлов text(), использование имени столб-
ца в качестве фильтра XPath и обработку пробельных символов, XML-комментариев и инструкций
обработки:
CREATE TABLE xmlelements AS SELECT
xml&lt;/script&gt;&lt;/p&gt;
&lt;root&gt;
&lt;element&gt; Hello&lt;!-- xyxxz --&gt;2a2&lt;?aaaaa?&gt; &lt;!--x--&gt;
&amp;lt;/root&amp;gt;
$$ AS data;
bbb&lt;x&gt;xxx&lt;/x&gt;CC
SELECT xmltable.*
FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
element
----------------------
263
&lt;/element&gt;Функции и операторы
Hello2a2
bbbCC
Следующий пример показывает, как с помощью предложения XMLNAMESPACES можно задать список
пространств имён, используемых в XML-документе и в выражениях XPath:
WITH xmldata(data) AS (VALUES ('
&lt;example xmlns=&quot;http://example.com/myns&quot; xmlns:B=&quot;http://example.com/b&quot;&gt;
&lt;item foo=&quot;1&quot; B:bar=&quot;2&quot; /&gt;
&lt;item foo=&quot;3&quot; B:bar=&quot;4&quot; /&gt;
&lt;item foo=&quot;4&quot; B:bar=&quot;5&quot; /&gt;
&lt;/example&gt;'::xml)
)
SELECT xmltable.*
FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
'http://example.com/b' AS &quot;B&quot;),
'/x:example/x:item'
PASSING (SELECT data FROM xmldata)
COLUMNS foo int PATH '@foo',
bar int PATH '@B:bar');
foo | bar
-----+-----
1 |
2
3 |
4
4 |
5
(3 rows)
9.14.4. Отображение таблиц в XML
Следующие функции отображают содержимое реляционных таблиц в значения XML. Их можно
рассматривать как средства экспорта в XML:
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
tableforest boolean, targetns text)
Результат всех этих функций имеет тип xml.
table_to_xml отображает в xml содержимое таблицы, имя которой задаётся в параметре tbl. Тип
regclass принимает идентификаторы строк в обычной записи, которые могут содержать указание
схемы и кавычки. Функция query_to_xml выполняет запрос, текст которого передаётся в парамет-
ре query, и отображает в xml результирующий набор. Последняя функция, cursor_to_xml выбира-
ет указанное число строк из курсора, переданного в параметре cursor. Этот вариант рекоменду-
ется использовать с большими таблицами, так как все эти функции создают результирующий xml
в памяти.
Если параметр tableforest имеет значение false, результирующий XML-документ выглядит так:
&lt;имя_таблицы&gt;
&lt;row&gt;
&lt;имя_столбца1&gt; данные &lt;/имя_столбца1&gt;
&lt;имя_столбца2&gt; данные &lt;/имя_столбца2&gt;
&lt;/row&gt;
&lt;row&gt;
...
&lt;/row&gt;
...
&lt;/имя_таблицы&gt;
264Функции и операторы
А если tableforest равен true, в результате будет выведен следующий фрагмент XML:
&lt;имя_таблицы&gt;
&lt;имя_столбца1&gt; данные &lt;/имя_столбца1&gt;
&lt;имя_столбца2&gt; данные &lt;/имя_столбца2&gt;
&lt;/имя_таблицы&gt;
&lt;имя_таблицы&gt;
...
&lt;/имя_таблицы&gt;
...
Если имя таблицы неизвестно, например, при отображении результатов запроса или курсора, вме-
сто него в первом случае вставляется table, а во втором — row.
Выбор между этими форматами остаётся за пользователем. Первый вариант позволяет создать
готовый XML-документ, что может быть полезно для многих приложений, а второй удобно приме-
нять с функцией cursor_to_xml, если её результаты будут собираться в документ позже. Получен-
ный результат можно изменить по вкусу с помощью рассмотренных выше функций создания XML-
содержимого, в частности xmlelement.
Значения данных эти функции отображают так же, как и ранее описанная функция xmlelement.
Параметр nulls определяет, нужно ли включать в результат значения NULL. Если он установлен,
значения NULL в столбцах представляются так:
&lt;имя_столбца xsi:nil=&quot;true&quot; /&gt;
Здесь xsi — префикс пространства имён XML Schema Instance. При этом в результирующий XML
будет добавлено соответствующее объявление пространства имён. Если же данный параметр ра-
вен false, столбцы со значениями NULL просто не будут выводиться.
Параметр targetns определяет целевое пространство имён для результирующего XML. Если про-
странство имён не нужно, значением этого параметра должна быть пустая строка.
Следующие функции выдают документы XML Schema, которые содержат схемы отображений, вы-
полняемых соответствующими ранее рассмотренными функциями:
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean,
targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,
targetns text)
Чтобы результаты отображения данных в XML соответствовали XML-схемам, важно, чтобы паре
функций передавались одинаковые параметры.
Следующие функции выдают отображение данных в XML и соответствующую XML-схему в одном
документе (или фрагменте), объединяя их вместе. Это может быть полезно там, где желательно
получить самодостаточные результаты с описанием:
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,
targetns text)
В дополнение к ним есть следующие функции, способные выдать аналогичные представления для
целых схем в базе данных или даже всей текущей базы данных:
schema_to_xml(schema name, nulls boolean, tableforest boolean,
265Функции и операторы
targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean,
targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean,
targetns text)
database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,
targetns text)
Заметьте, что объём таких данных может быть очень большим, а XML будет создаваться в памяти.
Поэтому, вместо того, чтобы пытаться отобразить в XML сразу всё содержимое больших схем или
баз данных, лучше делать это по таблицам, возможно даже используя курсор.
Результат отображения содержимого схемы будет выглядеть так:
&lt;имя_схемы&gt;
отображение-таблицы1
отображение-таблицы2
...
&lt;/имя_схемы&gt;
Формат отображения таблицы определяется параметром tableforest, описанным выше.
Результат отображения содержимого базы данных будет таким:
&lt;имя_схемы&gt;
&lt;имя_схемы1&gt;
...
&lt;/имя_схемы1&gt;
&lt;имя_схемы2&gt;
...
&lt;/имя_схемы2&gt;
...
&lt;/имя_схемы&gt;
Здесь отображение схемы имеет вид, показанный выше.
В качестве примера, иллюстрирующего использование результата этих функций, на
Рисунке  9.1 показано XSLT-преобразование, которое переводит результат функции
table_to_xml_and_xmlschema в HTML-документ, содержащий таблицу с данными. Подобным обра-
зом результаты этих функций можно преобразовать и в другие форматы на базе XML.
266Функции и операторы
Рисунок 9.1. XSLT-преобразование, переводящее результат SQL/XML в формат HTML
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;xsl:output method=&quot;xml&quot; doctype-system=&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot; doctype-public=&quot;-//W3C/DTD XHTML 1.0 Strict//EN&quot; indent=&quot;yes&quot; /&gt;
&lt;xsl:template match=&quot;/*&quot;&gt;
&lt;xsl:variable name=&quot;schema&quot; select=&quot;//xsd:schema&quot; /&gt;
&lt;xsl:variable name=&quot;tabletypename&quot; select=&quot;$schema/xsd:element[@name=name(current())]/@type&quot; /&gt;
&lt;xsl:variable name=&quot;rowtypename&quot; select=&quot;$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/
xsd:element[@name='row']/@type&quot; /&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;xsl:value-of select=&quot;name(current())&quot; /&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;xsl:for-each select=&quot;$schema/xsd:complexType[@name=$rowtypename]/
xsd:sequence/xsd:element/@name&quot;&gt;
&lt;th&gt;&lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;/th&gt;
&lt;/xsl:for-each&gt;
&lt;/tr&gt;
&lt;xsl:for-each select=&quot;row&quot;&gt;
&lt;tr&gt;
&lt;xsl:for-each select=&quot;*&quot;&gt;
&lt;td&gt;&lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;/td&gt;
&lt;/xsl:for-each&gt;
&lt;/tr&gt;
&lt;/xsl:for-each&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
9.15. Функции и операторы JSON
В Таблице 9.43 перечислены функции, позволяющие создавать данные в формате JSON (см. Раз-
дел 8.14).
267Функции и операторы
Таблица 9.43. Операторы для типов json и jsonb
Оператор Тип правого опе- Описание
ранда
Пример
Результат
мера
-&amp;gt; int Выдаёт
элемент
массива JSON (по
номеру от 0, от-
рицательные чис-
ла задают позиции
с конца)
-&amp;gt; text Выдаёт поле объ- '(&quot;a&quot;:
(&quot;b&quot;:&quot;foo&quot;)
екта JSON по клю- (&quot;b&quot;:&quot;foo&quot;))'::json-
чу
&amp;gt;'a'
-&amp;gt;&amp;gt; int Выдаёт
элемент '[1,2,
массива JSON в ти- 3]'::json-&amp;gt;&amp;gt;2
пе text
3
-&amp;gt;&amp;gt; text Выдаёт поле объ- '(&quot;a&quot;:1,
екта JSON в типе &quot;b&quot;:2)'::json-
text
&amp;gt;&amp;gt;'b'
2
#&amp;gt; text[] Выдаёт
объект '(&quot;a&quot;:
(&quot;b&quot;: (&quot;c&quot;: &quot;foo&quot;)
JSON по заданно- (&quot;c&quot;:
му пути
&quot;foo&quot;)))'::json#&amp;gt;'(a,
b)'
#&amp;gt;&amp;gt; text[] Выдаёт
объект '(&quot;a&quot;:[1,2,3],
3
JSON по заданно- &quot;b&quot;:[4,5,
му пути в типе 6])'::json#&amp;gt;&amp;gt;'(a,
text
2)'
при-
'[(&quot;a&quot;:&quot;foo&quot;),
(&quot;c&quot;:&quot;baz&quot;)
(&quot;b&quot;:&quot;bar&quot;),
(&quot;c&quot;:&quot;baz&quot;)]'::json-
&amp;gt;2
Примечание
Эти операторы существуют в двух вариациях для типов json и jsonb. Операторы из-
влечения поля/элемента/пути возвращают тот же тип, что у операнда слева (json или
jsonb), за исключением тех, что возвращают тип text (они возвращают значение как
текстовое). Если входные данные JSON не содержат структуры, удовлетворяющей за-
просу, например в них нет искомого элемента, то операторы извлечения поля/элемен-
та/пути не выдают ошибку, а возвращают NULL. Все операторы извлечения поля/эле-
мента/пути, принимающие целочисленные позиции в массивах JSON, поддерживают и
отсчёт от конца массива по отрицательной позиции.
Стандартные операторы сравнения, приведённые в Таблице  9.1, есть для типа jsonb, но не для
json. Они следуют правилам сортировки для операций B-дерева, описанным в Подразделе 8.14.4.
Некоторые из следующих операторов существуют только для jsonb, как показано в Таблице 9.44.
Многие из этих операторов могут быть проиндексированы с помощью классов операторов jsonb.
Полное описание проверок на вхождение и существование для jsonb приведено в Подразде-
ле  8.14.3. Как эти операторы могут использоваться для эффективного индексирования данных
jsonb, описано в Подразделе 8.14.4.
Таблица 9.44. Дополнительные операторы jsonb
Оператор Тип правого операн- Описание
да
@&amp;gt; jsonb
Пример
Левое значение JSON '(&quot;a&quot;:1,
содержит на верхнем
&quot;b&quot;:2)'::jsonb
'(&quot;b&quot;:2)'::jsonb
268
@&amp;gt;Функции и операторы
Оператор Тип правого операн- Описание
Пример
да
уровне путь/значение
JSON справа?
&amp;lt;@ jsonb Путь/значение
JSON '(&quot;b&quot;:2)'::jsonb
слева содержится на '(&quot;a&quot;:1,
верхнем уровне в пра- &quot;b&quot;:2)'::jsonb
вом значении JSON?
? text Присутствует ли стро- '(&quot;a&quot;:1,
ка в качестве ключа &quot;b&quot;:2)'::jsonb ? 'b'
верхнего уровня в зна-
чении JSON?
?| text[] Какие-либо
строки '(&quot;a&quot;:1,
&quot;b&quot;:2,
массива присутствуют
&quot;c&quot;:3)'::jsonb ?|
в
качестве
ключей array['b', 'c']
верхнего уровня?
?&amp;amp; text[] Все строки массива '[&quot;a&quot;,
присутствуют в каче-
&quot;b&quot;]'::jsonb
стве ключей верхнего array['a', 'b']
уровня?
&amp;lt;@
?&amp;amp;
|| jsonb Соединяет два значе- '[&quot;a&quot;, &quot;b&quot;]'::jsonb
ния jsonb в новое зна- ||
'[&quot;c&quot;,
чение jsonb
&quot;d&quot;]'::jsonb
- text Удаляет пару ключ/ '(&quot;a&quot;: &quot;b&quot;)'::jsonb -
значение
или
эле- 'a'
мент-строку из левого
операнда. Пары ключ/
значение выбираются
по значению ключа.
- text[] Удаляет множество пар '(&quot;a&quot;:
&quot;b&quot;,
&quot;c&quot;:
ключ/значение или эле- &quot;d&quot;)'::jsonb - '(a,
менты-строки из ле- c)'::text[]
вого операнда. Пары
ключ/значение выбира-
ются по значению клю-
ча.
- integer Удаляет из массива эле- '[&quot;a&quot;,
мент в заданной пози- - 1
ции (отрицательные но-
мера позиций отсчиты-
ваются от конца). Выда-
ёт ошибку, если контей-
нер верхнего уровня —
не массив.
#- text[] Удаляет поле или эле- '[&quot;a&quot;,
мент с заданным пу- (&quot;b&quot;:1)]'::jsonb #-
тём (для массивов JSON '(1,b)'
отрицательные номера
позиций отсчитывают-
ся от конца)
269
&quot;b&quot;]'::jsonbФункции и операторы
Примечание
Оператор || соединяет элементы верхнего уровня обоих операндов. Вложенность при
этом не учитывается. Например, если оба операнда содержат поле с одноимённым клю-
чом, значением поля в результате будет значение, взятое из правого операнда.
В Таблице  9.45 показаны функции, позволяющие создавать значения типов json и jsonb. (Для
типа jsonb нет аналогов функций row_to_json и array_to_json, но практически тот же результат
можно получить с помощью to_jsonb.)
Таблица 9.45. Функции для создания JSON
Функция Описание
to_json(anyelement) Возвращает значение в to_json('Fred
виде json или jsonb. &quot;Hi.&quot;'::text)
Массивы и составные
структуры преобразу-
ются (рекурсивно) в
массивы и объекты; для
других типов, для ко-
торых определено при-
ведение к json, при-
меняется эта функ-
ция приведения, а для
всех остальных выдаёт-
ся скалярное значение.
Значения всех скаляр-
ных типов, кроме чис-
лового, логического и
NULL, представляются
в текстовом виде, в сти-
ле, допустимом для зна-
чений json или jsonb.
to_jsonb(
anyelement)
Пример
Результат примера
said
&quot;Fred said \&quot;Hi.\&quot;&quot;
array_to_json(
anyarray [, pretty_
bool]) Возвращает массив в array_to_json(
виде массива JSON. '((1,5),(99,
Многомерный массив 100))'::int[])
PostgreSQL
становит-
ся массивом масси-
вов JSON. Если пара-
метр pretty_bool ра-
вен true, между эле-
ментами 1-ой размер-
ности вставляются раз-
рывы строк. [[1,5],[99,100]]
row_to_json(record
[, pretty_bool]) Возвращает кортеж в row_to_json(row(
виде объекта JSON. Ес- 1,'foo'))
ли параметр pretty_
bool равен true, меж-
ду элементами 1-ой раз-
мерности вставляются
разрывы строк. (&quot;f1&quot;:1,&quot;f2&quot;:&quot;foo&quot;)
json_build_array(
VARIADIC &quot;any&quot;) Формирует
массив json_build_array(
JSON (возможно, разно- 1,2,'3',4,5)
родный) из переменно-
го списка аргументов. [1, 2, &quot;3&quot;, 4, 5]
270Функции и операторы
Функция
jsonb_build_array(
VARIADIC &quot;any&quot;) Описание json_build_object(
VARIADIC &quot;any&quot;) Формирует
объект json_build_object(
JSON из переменно- 'foo',1,'bar',2)
го списка аргументов.
По соглашению в этом
списке перечисляются
по очереди ключи и
значения. (&quot;foo&quot;: 1, &quot;bar&quot;: 2)
Формирует
объект json_object('(a,
JSON из текстового 1, b, &quot;def&quot;, c,
массива.
Этот
мас- 3.5)')
сив должен иметь ли-
бо одну размерность json_object('((a,
с чётным числом эле-
1),(b,
&quot;def&quot;),
ментов (в этом слу- (c, 3.5))')
чае они воспринимают-
ся как чередующиеся
ключи/значения), либо
две размерности и при
этом каждый внутрен-
ний массив содержит
ровно два элемента, ко-
торые воспринимаются
как пара ключ/значе-
ние. (&quot;a&quot;:
&quot;1&quot;,
&quot;b&quot;:
&quot;def&quot;, &quot;c&quot;: &quot;3.5&quot;)
Эта
форма
json_ json_object('(a,
object
принимает b)', '(1,2)')
ключи и значения по
парам из двух отдель-
ных массивов. Во всех
остальных отношениях
она не отличается от
формы с одним аргу-
ментом. (&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;2&quot;)
jsonb_build_object(
VARIADIC &quot;any&quot;)
json_object(text[])
jsonb_object(
text[])
json_object(keys
text[],
values
text[])
jsonb_object(keys
text[],
values
text[])
Пример
Результат примера
Примечание
Функции array_to_json и row_to_json подобны to_json, но предлагают возможность
улучшенного вывода. Действие to_json, описанное выше, распространяется на каждое
отдельное значение, преобразуемое этими функциями.
Примечание
В расширении hstore определено преобразование из hstore в json, так что значения
hstore, преобразуемые функциями создания JSON, будут представлены в виде объектов
JSON, а не как примитивные строковые значения.
В Таблице 9.46 показаны функции, предназначенные для работы со значениями json и jsonb.
271Функции и операторы
Таблица 9.46. Функции для обработки JSON
Функция Тип результата Описание Пример Результат
мера
json_array_
length(json) int Возвращает чис-
ло элементов во
внешнем массиве
JSON. json_array_
length('[1,2,
3,(&quot;f1&quot;:1,
&quot;f2&quot;:[5,6]),
4]') 5
jsonb_array_
length(jsonb)
json_each(
json)
jsonb_each(
jsonb)
json_each_
text(json)
jsonb_each_
text(jsonb)
json_extract_
path(from_
json
json,
VARIADIC path_
elems text[])
setof key text, Разворачивает
select
* key | value
внешний
объект from json_each( -----+-------
value json
JSON в набор пар '(&quot;a&quot;:&quot;foo&quot;,
a
| &quot;foo&quot;
setof key text, ключ/значение
( &quot;b&quot;:&quot;bar&quot;)')
b
| &quot;bar&quot;
value jsonb
key/value).
setof key text, Разворачивает
внешний
объект
value text
JSON в набор пар
ключ/значение
(
key/value). Возвра-
щаемые значения
будут иметь тип
text.
json_extract_
path(
'(&quot;f2&quot;:
(&quot;f3&quot;:1),
&quot;f4&quot;:(&quot;f5&quot;:99,
&quot;f6&quot;:&quot;foo&quot;))',
'f4') (&quot;f5&quot;:99,
&quot;f6&quot;:&quot;foo&quot;)
text Возвращает значе-
ние JSON по пути,
заданному элемен-
тами пути path_
elems , как text
(равнозначно опе-
ратору #&amp;gt;&amp;gt;). json_extract_
path_text(
'(&quot;f2&quot;:
(&quot;f3&quot;:1),
&quot;f4&quot;:(&quot;f5&quot;:99,
&quot;f6&quot;:&quot;foo&quot;))',
'f4', 'f6') foo
setof text Возвращает набор json_object_
ключей во внеш- keys(
нем объекте JSON. '(&quot;f1&quot;:&quot;abc&quot;,
&quot;f2&quot;:(&quot;f3&quot;:&quot;a&quot;,
&quot;f4&quot;:&quot;b&quot;))') anyelement Разворачивает
объект из from_
json
в таблич-
ную строку, в ко-
торой столбцы со-
jsonb
jsonb_extract_
path_text(
from_json
jsonb, VARIADIC
path_elems
text[])
json_object_
keys(json)
jsonb_object_
keys(jsonb)
json_populate_
record(base
anyelement,
from_json
json)
select
* key | value
from json_each_ -----+-------
a
| foo
text(
b
| bar
'(&quot;a&quot;:&quot;foo&quot;,
&quot;b&quot;:&quot;bar&quot;)')
Возвращает значе-
ние JSON по пу-
ти, заданному эле-
ментами пути (
path_elems ) (рав-
нозначно операто-
ру #&amp;gt; operator).
json
jsonb_extract_
path(from_
json
jsonb,
VARIADIC path_
elems text[])
json_extract_
path_text(
from_json json,
VARIADIC path_
elems text[])
при-
272
json_object_keys
-----------------
f1
f2
b
|
select
* a |
c
from
json_
---+-----------
populate_
+-------------
record(
null::myrowtype,Функции и операторы
Функция
Тип результата
jsonb_populate_
recordset(base
anyelement,
from_json
jsonb)
json_array_
elements(json)
setof anyelement Разворачивает
внешний
массив
объектов из from_
json в набор таб-
личных строк, в
котором столбцы
соответствуют ти-
пу строки, задан-
ному параметром
base (см. примеча-
ния ниже).
setof text Разворачивает
массив JSON в
набор
значений
text. value
select
*
from
-----------
json_array_
foo
elements_text(
bar
'[&quot;foo&quot;,
&quot;bar&quot;]')
text Возвращает
тип json_typeof(
внешнего
значе- '-123.4')
ния JSON в ви-
де текстовой стро-
ки. Возможные ти-
пы: object, array,
string, number,
boolean и null.
record Формирует обыч-
ную запись из объ-
екта JSON (см.
примечания
ни-
же). Как и со
всеми
функция-
ми, возвращающи-
ми record, при
вызове необходи-
мо явно опреде-
лить структуру за-
писи с помощью
предложения AS.
setof jsonb
jsonb_typeof(
jsonb)
json_to_
record(json)
jsonb_to_
record(jsonb)
select
* a | b
from
json_ ---+---
1 | 2
populate_
3 | 4
recordset(
null::myrowtype,
'[(&quot;a&quot;:1,
&quot;b&quot;:2),(&quot;a&quot;:3,
&quot;b&quot;:4)]')
value
select
*
from
-----------
json_array_
1
elements('[1,
true
true,
[2,
[2,false]
false]]')
jsonb_array_
elements_text(
jsonb)
json_typeof(
json)
Результат
при-
мера
1 | (2,&quot;a b&quot;) |
(4,&quot;a b c&quot;)
Разворачивает
массив JSON в
набор
значений
JSON.
setof json
jsonb_array_
elements(
jsonb)
json_array_
elements_text(
json)
Пример
ответствуют типу '(&quot;a&quot;: 1, &quot;b&quot;:
строки, заданному [&quot;2&quot;, &quot;a b&quot;],
параметром base &quot;c&quot;: (&quot;d&quot;: 4,
(см. примечания &quot;e&quot;: &quot;a b c&quot;))')
ниже).
jsonb_populate_
record(base
anyelement,
from_json
jsonb)
json_populate_
recordset(base
anyelement,
from_json
json)
Описание
273
number
b
|
select
* a |
c
| d |
from
json_to_
r
record(
---+---------
'(&quot;a&quot;:1,
+---------+---
&quot;b&quot;:[1,2,3],
+---------------
&quot;c&quot;:[1,2,3],
1 | [1,2,3] |
&quot;e&quot;:&quot;bar&quot;,&quot;r&quot;:
(1,2,3) |
|
(&quot;a&quot;: 123, &quot;b&quot;:
&quot;a b c&quot;))') as (123,&quot;a b c&quot;)
x(a
int,
b
text, c int[],
d
text,
r
myrowtype)Функции и операторы
Функция Тип результата Описание Пример json_to_
recordset(
json) setof record Формирует обыч-
ный
набор
за-
писей из масси-
ва объекта JSON
(см. примечания
ниже).
Как
и
со всеми функция-
ми, возвращающи-
ми record, при
вызове необходи-
мо явно опреде-
лить структуру за-
писи с помощью
предложения AS. select
* a | b
from
json_to_ ---+-----
1 | foo
recordset(
2 |
'[(&quot;a&quot;:1,
&quot;b&quot;:&quot;foo&quot;),
(&quot;a&quot;:&quot;2&quot;,
&quot;c&quot;:&quot;bar&quot;)]') as
x(a
int,
b
text);
json Возвращает
зна-
чение from_json ,
из которого ис-
ключаются все по-
ля объекта, содер-
жащие значения
NULL. Другие зна-
чения NULL оста-
ются нетронуты-
ми. json_strip_
nulls(
'[(&quot;f1&quot;:1,
&quot;f2&quot;:null),2,
null,3]') [(&quot;f1&quot;:1),2,
null,3]
jsonb_set(
jsonb
target
jsonb,
path text[],
new_value
jsonb[,
create_
missing
boolean]) Возвращает значе-
ние target, в ко-
тором раздел с за-
данным путём (
path) заменяется
новым значением
(new_value ), ли-
бо в него добав-
ляется значение
new_value , если
аргумент create_
missing
равен
true (это значе-
ние по умолча-
нию) и элемент,
на который ссыла-
ется path, не су-
ществует. Как и с
операторами, рас-
считанными на пу-
ти, отрицательные
числа в пути (path)
обозначают отсчёт
от конца массивов
JSON. jsonb_set(
'[(&quot;f1&quot;:1,
&quot;f2&quot;:null),2,
null,3]', '(0,
f1)','[2,3,
4]', false) [(&quot;f1&quot;:[2,3,
4],&quot;f2&quot;:null),
2,null,3]
jsonb_insert(
target
jsonb,
path text[],
new_value Возвращает значе- jsonb_insert(
ние target с встав- '(&quot;a&quot;:
[0,1,
ленным в него 2])',
'(a,
новым значением
jsonb_to_
recordset(
jsonb)
json_strip_
nulls(from_
json json)
jsonb
jsonb_strip_
nulls(from_
json jsonb)
jsonb
274
Результат
мера
при-
[(&quot;f1&quot;: 1, &quot;f2&quot;:
null, &quot;f3&quot;: [2,
3, 4]), 2]
jsonb_set(
'[(&quot;f1&quot;:1,
&quot;f2&quot;:null),
2]', '(0,f3)',
'[2,3,4]')
(&quot;a&quot;: [0, &quot;new_
value&quot;, 1, 2])Функции и операторы
Функция
Тип результата
jsonb, [ insert_
after boolean])
jsonb_pretty(
from_json
jsonb)
text
Описание Пример
new_value . Если
место в target,
выбранное путём
path, оказывается
в массиве JSONB,
new_value
будет
вставлен до (по
умолчанию)
или
после (если па-
раметр
insert_
after равен true)
выбранной пози-
ции. Если место
в target, выбран-
ное путём path,
оказывается в объ-
екте JSONB, зна-
чение new_value
будет вставлено в
него, только ес-
ли заданный путь
path не существу-
ет. Как и с опе-
раторами, рассчи-
танными на пу-
ти, отрицательные
числа в пути (path)
обозначают отсчёт
от конца массивов
JSON. 1)', '&quot;new_
value&quot;')
Возвращает значе-
ние from_json в
виде текста JSON с
отступами. jsonb_pretty(
'[(&quot;f1&quot;:1,
&quot;f2&quot;:null),2,
null,3]')
jsonb_insert(
'(&quot;a&quot;:
[0,1,
2])',
'(a,
1)', '&quot;new_
value&quot;', true)
Результат
при-
мера
(&quot;a&quot;:
[0,
1,
&quot;new_value&quot;,
2])
[
(
&quot;f1&quot;: 1,
&quot;f2&quot;:
null
),
2,
null,
3
]
Примечание
Многие из этих функций и операторов преобразуют спецпоследовательности Unicode в
JSON-строках в соответствующие одиночные символы. Для входных данных типа jsonb
это ничем не грозит, так как преобразование уже выполнено; однако для типа json в
результате может произойти ошибка, как отмечено в Разделе 8.14.
Примечание
Хотя
в
примерах
использования
функций
json_populate_record,
json_populate_recordset, json_to_record и json_to_recordset применяются кон-
станты, обычно эти функции обращаются к таблицам в предложении FROM, а в качестве
275Функции и операторы
аргумента указывается один из столбцов типа json или jsonb. Извлечённые значения
затем могут использоваться в других частях запроса, например, в предложениях WHERE
и результирующих списках. Извлекая множество значений подобным образом, можно
значительно увеличить производительность по сравнению с использованием операто-
ров, работающих с отдельными ключами.
Ключи JSON сопоставляются с идентичными именами столбцов в целевом типе запи-
сей. Приведение типов JSON для этих функций выполняется «насколько это возмож-
но», и его результаты могут быть не вполне ожидаемыми для некоторых типов. По-
ля JSON, отсутствующие в целевом типе, в выходные данные не попадают, а целевые
столбцы, для которых нет соответствующих полей JSON, будут просто содержать NULL.
Примечание
В target должны присутствовать все элементы пути, заданного параметром path функ-
ций jsonb_set и jsonb_insert, за исключением последнего. Если create_missing ра-
вен false, должны присутствовать абсолютно все элементы пути path, переданного
функции jsonb_set. Если это условие не выполняется, значение target возвращается
неизменённым.
Если последним элементом пути оказывается ключ объекта, он будет создан в случае
отсутствия и получит новое значение. Если последний элемент пути — позиция в мас-
сиве, то когда она положительна, целевой элемент отсчитывается слева, а когда отри-
цательна — справа, то есть -1 указывает на самый правый элемент и т. д. Если позиция
лежит вне диапазона -длина_массива .. длина_массива -1, и параметр create_missing
равен true, новое значение добавляется в начало массива, если позиция отрицательна,
и в конец, если положительна.
Примечание
Значение null, возвращаемое функцией json_typeof, не следует путать с SQL NULL.
Тогда как при вызове json_typeof('null'::json) возвращается null, при вызове
json_typeof(NULL::json) будет возвращено значение SQL NULL.
Примечание
Если аргумент функции json_strip_nulls содержит повторяющиеся имена полей в
любом объекте, в результате могут проявиться семантические различия, в зависимости
от порядка этих полей. Это не проблема для функции jsonb_strip_nulls, так как в
значениях jsonb имена полей не могут дублироваться.
В Разделе 9.20 вы также можете узнать об агрегатной функции json_agg, которая агрегирует зна-
чения записи в виде JSON, и агрегатной функции json_object_agg, агрегирующей пары значений
в объект JSON, а также их аналогах для jsonb, функциях jsonb_agg и jsonb_object_agg.
9.16. Функции для работы с последовательностями
В этом разделе описаны функции для работы с объектами, представляющими последователь-
ности. Такие объекты (также называемыми генераторами последовательностей или просто по-
следовательностями) являются специальными таблицами из одной строки и создаются коман-
дой CREATE SEQUENCE. Используются они обычно для получения уникальных идентификаторов
строк таблицы. Функции, перечисленные в Таблице  9.47, предоставляют простые и безопасные
для параллельного использования методы получения очередных значений таких последователь-
ностей.
276Функции и операторы
Таблица 9.47. Функции для работы с последовательностями
Функция Тип результата Описание
currval( regclass) bigint Выдаёт значение заданной по-
следовательности, которое бы-
ло возвращено при последнем
вызове функции nextval
lastval() bigint Выдаёт значение любой после-
довательности, которое было
возвращено при последнем вы-
зове функции nextval
nextval( regclass) bigint Продвигает
последователь-
ность к следующему значению
и возвращает его
bigint Устанавливает текущее значе-
ние последовательности
bigint, bigint Устанавливает текущее значе-
ние последовательности и флаг
is_called , указывающий на
то, что это значение использо-
валось
setval( regclass,
setval( regclass,
boolean)
bigint)
Последовательность, к которой будет обращаться одна из этих функций, определяется аргументом
regclass, задающим просто OID последовательности в системном каталоге pg_class. Вычислять
этот OID вручную не нужно, так как процедура ввода данных regclass автоматически выполнит эту
работу за вас. Просто запишите имя последовательности в апострофах, чтобы оно выглядело как
строковая константа. Для совместимости с обычными именами SQL эта строка будет переведена
в нижний регистр, если только она не заключена в кавычки. Например:
nextval('foo')
nextval('FOO')
nextval('&quot;Foo&quot;')
обращается к последовательности foo
обращается к последовательности foo
обращается к последовательности Foo
При необходимости имя последовательности можно дополнить именем схемы:
nextval('myschema.foo')
nextval('&quot;myschema&quot;.foo')
nextval('foo')
обращается к myschema.foo
то же самое
ищет foo в пути поиска
Подробнее тип regclass описан в Разделе 8.19.
Примечание
В PostgreSQL до версии 8.1 аргументы этих функций имели тип text, а не regclass,
и поэтому описанное выше преобразование текстовой строки в OID имело место при
каждом вызове функции. Это поведение сохраняется и сейчас для обратной совмести-
мости, но сейчас оно реализовано как неявное приведение типа text к типу regclass
перед вызовом функции.
Когда вы записываете аргумент функции, работающей с последовательностью, как тек-
стовую строку в чистом виде, она становится константой типа regclass. Так как фак-
тически это будет просто значение OID, оно будет привязано к изначально идентифи-
цированной последовательности, несмотря на то, что она может быть переименована,
перенесена в другую схему и т. д. Такое «раннее связывание» обычно желательно для
ссылок на последовательности в значениях столбцов по умолчанию и представлени-
ях. Но иногда возникает необходимость в «позднем связывании», когда ссылки на по-
следовательности распознаются в процессе выполнения. Чтобы получить такое пове-
дение, нужно принудительно изменить тип константы с regclass на text:
nextval('foo'::text)
foo распознаётся во время выполнения
277Функции и операторы
Заметьте, что версии PostgreSQL до 8.1 поддерживали только позднее связывание, так
что это может быть полезно и для совместимости со старыми приложениями.
Конечно же, аргументом таких функций может быть не только константа, но и выра-
жение. Если это выражение текстового типа, неявное приведение типов повлечёт раз-
решение имени во время выполнения.
Ниже описаны все функции, предназначенные для работы с последовательностями:
nextval
Продвигает последовательность к следующему значению и возвращает его. Это атомарная опе-
рация: если nextval вызывается одновременно в нескольких сеансах, в результате каждого вы-
зова будут гарантированно получены разные значения.
Если последовательность создаётся с параметрами по умолчанию, успешные вызовы nextval
получают очередные значения по возрастанию, начиная с 1. Другое поведение можно получить
с помощью специальных параметров в команде CREATE SEQUENCE; подробнее это описано на
странице описания команды.
Важно
Во избежание блокирования параллельных транзакций, пытающихся получить зна-
чения одной последовательности, операция nextval никогда не откатывается; то
есть, как только значение было выбрано, оно считается использованным и не будет
возвращено снова. Это утверждение верно, даже когда окружающая транзакция
впоследствии прерывается или вызывающий запрос никак не использует это зна-
чение. Например, команда INSERT с предложением ON CONFLICT вычислит кортеж,
претендующий на добавление, произведя все требуемые вызовы nextval, прежде
чем выявит конфликты, которые могут привести к отработке правил ON CONFLICT
вместо добавления. В таких ситуациях в последовательности задействованных зна-
чений могут образовываться «дыры». Таким образом, объекты последовательностей
PostgreSQL не годятся для получения непрерывных последовательностей.
Этой функции требуется право USAGE или UPDATE для последовательности.
currval
Возвращает значение, выданное при последнем вызове nextval для этой последовательности
в текущем сеансе. (Если в данном сеансе nextval ни разу не вызывалась для данной после-
довательности, возвращается ошибка.) Так как это значение ограничено рамками сеанса, эта
функция выдаёт предсказуемый результат вне зависимости от того, вызвалась ли впоследствии
nextval в других сеансах или нет.
Этой функции требуется право USAGE или SELECT для последовательности.
lastval
Возвращает значение, выданное при последнем вызове nextval в текущем сеансе. Эта функция
подобна currval, но она не принимает в параметрах имя последовательности, а обращается к
той последовательности, для которой вызывалась nextval в последний раз в текущем сеансе.
Если в текущем сеансе функция nextval ещё не вызывалась, при вызове lastval произойдёт
ошибка.
Этой функции требуется право USAGE или SELECT для последней использованной последователь-
ности.
setval
Сбрасывает счётчик последовательности. В форме с двумя параметрами устанавливает для по-
следовательности заданное значение поля last_value и значение true для флага is_called,
278Функции и операторы
показывающего, что при следующем вызове nextval последовательность должна сначала про-
двинуться к очередному значению, которое будет возвращено. При этом currval также возвра-
тит заданное значение. В форме с тремя параметрами флагу is_called можно присвоить true
или false. Со значением true она действует так же, как и форма с двумя параметрами. Если
же присвоить этому флагу значение false, первый вызов nextval после этого вернёт именно
заданное значение, а продвижение последовательности произойдёт при последующем вызове
nextval. Кроме того, значение, возвращаемое currval в этом случае, не меняется. Например,
SELECT setval('foo', 42);
SELECT setval('foo', 42, true);
SELECT setval('foo', 42, false);
Следующий вызов nextval вернёт 43
То же самое
Следующий вызов nextval вернёт 42
Результатом самой функции setval будет просто значение её второго аргумента.
Важно
Так как значения последовательностей изменяются вне транзакций, действие
функции setval не отменяется при откате транзакции.
Этой функции требуется право UPDATE для последовательности.
9.17. Условные выражения
В этом разделе описаны SQL-совместимые условные выражения, которые поддерживаются в
PostgreSQL.
Подсказка
Если возможностей этих условных выражений оказывается недостаточно, вероятно,
имеет смысл перейти к написанию серверных функций на более мощном языке про-
граммирования.
9.17.1. CASE
Выражение CASE в SQL представляет собой общее условное выражение, напоминающее операторы
if/else в других языках программирования:
CASE WHEN условие THEN результат
[WHEN ...]
[ELSE результат]
END
Предложения CASE можно использовать везде, где допускаются выражения. Каждое условие в нём
представляет собой выражение, возвращающее результат типа boolean. Если результатом выра-
жения оказывается true, значением выражения CASE становится результат, следующий за услови-
ем, а остальная часть выражения CASE не вычисляется. Если же условие не выполняется, за ним
таким же образом проверяются все последующие предложения WHEN. Если не выполняется ни од-
но из условий WHEN, значением CASE становится результат, записанный в предложении ELSE. Если
при этом предложение ELSE отсутствует, результатом выражения будет NULL.
Пример:
SELECT * FROM test;
a
---
1
2
3
279Функции и операторы
SELECT a,
CASE WHEN a=1 THEN 'one'
WHEN a=2 THEN 'two'
ELSE 'other'
END
FROM test;
a | case
---+-------
1 | one
2 | two
3 | other
Типы данных всех выражений результатов должны приводиться к одному выходному типу. По-
дробнее это описано в Разделе 10.5.
Существует также «простая» форма выражения CASE, разновидность вышеприведённой общей
формы:
CASE выражение
WHEN значение THEN результат
[WHEN ...]
[ELSE результат]
END
В такой форме сначала вычисляется первое выражение, а затем его результат сравнивается с вы-
ражениями значений в предложениях WHEN, пока не будет найдено равное ему. Если такого не зна-
чения не находится, возвращается результат предложения ELSE (или NULL). Эта форма больше
похожа на оператор switch, существующий в языке C.
Показанный ранее пример можно записать по-другому, используя простую форму CASE:
SELECT a,
CASE a WHEN 1 THEN 'one'
WHEN 2 THEN 'two'
ELSE 'other'
END
FROM test;
a | case
---+-------
1 | one
2 | two
3 | other
В выражении CASE вычисляются только те подвыражения, которые необходимы для получения
результата. Например, так можно избежать ошибки деления на ноль:
SELECT ... WHERE CASE WHEN x &amp;lt;&amp;gt; 0 THEN y/x &amp;gt; 1.5 ELSE false END;
Примечание
Как было описано в Подразделе 4.2.14, всё же возможны ситуации, когда подвыраже-
ния вычисляются на разных этапах, так что железной гарантии, что в «CASE вычис-
ляются только необходимые подвыражения», в принципе нет. Например, константное
подвыражение 1/0 обычно вызывает ошибку деления на ноль на этапе планирования,
хотя эта ветвь CASE может вовсе не вычисляться во время выполнения.
9.17.2. COALESCE
280Функции и операторы
COALESCE(значение [, ...])
Функция COALESCE возвращает первый попавшийся аргумент, отличный от NULL. Если же все ар-
гументы равны NULL, результатом тоже будет NULL. Это часто используется при отображении
данных для подстановки некоторого значения по умолчанию вместо значений NULL:
SELECT COALESCE(description, short_description, '(none)') ...
Этот запрос вернёт значение description, если оно не равно NULL, либо short_description, если
оно не NULL, и строку (none), если оба эти значения равны NULL.
Как и выражение CASE, COALESCE вычисляет только те аргументы, которые необходимы для полу-
чения результата; то есть, аргументы правее первого отличного от NULL аргумента не вычисля-
ются. Эта функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги называ-
ются NVL и IFNULL.
9.17.3. NULLIF
NULLIF(значение1, значение2)
Функция NULLIF возвращает значение NULL, если значение1 равно значение2; в противном случае
она возвращает значение1. Это может быть полезно для реализации обратной операции к COALESCE.
В частности, для примера, показанного выше:
SELECT NULLIF(value, '(none)') ...
Если аргумент value равен (none), результатом выражения будет NULL, а в противном случае —
значение аргумента value.
9.17.4. GREATEST и LEAST
GREATEST(значение [, ...])
LEAST(значение [, ...])
Функции GREATEST и LEAST выбирают наибольшее или наименьшее значение из списка выражений.
Все эти выражения должны приводиться к общему типу данных, который станет типом результата
(подробнее об этом в Разделе 10.5). Значения NULL в этом списке игнорируются, так что результат
выражения будет равен NULL, только если все его аргументы равны NULL.
Заметьте, что функции GREATEST и LEAST не описаны в стандарте SQL, но часто реализуются в СУБД
как расширения. В некоторых других СУБД они могут возвращать NULL, когда не все, а любой из
аргументов равен NULL.
9.18. Функции и операторы для работы с массивами
В Таблице 9.48 показаны операторы, предназначенные для работы с массивами.
Таблица 9.48. Операторы для работы с массивами
Оператор Описание Пример
= равно ARRAY[1.1,2.1,
3.1]::int[]
ARRAY[1,2,3]
Результат
t
=
&amp;lt;&amp;gt; не равно ARRAY[1,2,3]
ARRAY[1,2,4] &amp;lt;&amp;gt; t
&amp;lt; меньше ARRAY[1,2,3]
ARRAY[1,2,4] &amp;lt; t
&amp;gt; больше ARRAY[1,4,3]
ARRAY[1,2,4] &amp;gt; t
&amp;lt;= меньше или равно ARRAY[1,2,3]
ARRAY[1,2,3] &amp;lt;= t
281Функции и операторы
Оператор Описание Пример
Результат
&amp;gt;= больше или равно ARRAY[1,4,3]
ARRAY[1,4,3] &amp;gt;= t
@&amp;gt; содержит ARRAY[1,4,3]
ARRAY[3,1] @&amp;gt; t
&amp;lt;@ содержится в ARRAY[2,7]
ARRAY[1,7,4,2,6] &amp;amp;&amp;amp; пересечение (есть об- ARRAY[1,4,3]
щие элементы)
ARRAY[2,1] &amp;amp;&amp;amp; t
|| соединение массива с ARRAY[1,2,3]
массивом
ARRAY[4,5,6] || (1,2,3,4,5,6)
|| соединение массива с ARRAY[1,2,3]
||
массивом
ARRAY[[4,5,6], [7,
8,9]] ((1,2,3),(4,5,
6),(7,8,9))
|| соединение элемента с 3 || ARRAY[4,5,6]
массивом (3,4,5,6)
|| соединение массива с ARRAY[4,5,6] || 7
элементом (4,5,6,7)
&amp;lt;@
t
Операторы сравнения массивов сравнивают содержимое массивов по элементам, используя при
этом функцию сравнения для B-дерева, определённую для типа данного элемента по умолчанию.
В многомерных массивах элементы просматриваются по строкам (индекс последней размерности
меняется в первую очередь). Если содержимое двух массивов совпадает, а размерности различа-
ются, результат их сравнения будет определяться первым отличием в размерностях. (В PostgreSQL
до версии 8.2 поведение было другим: два массива с одинаковым содержимом считались одинако-
выми, даже если число их размерностей и границы индексов различались.)
Подробнее поведение операторов с массивами описано в Разделе 8.15. За дополнительными све-
дениями об операторах, поддерживающих индексы, обратитесь к Разделу 11.2.
В Таблице 9.49 перечислены функции, предназначенные для работы с массивами. Дополнительная
информация о них и примеры использования приведены в Разделе 8.15.
Таблица 9.49. Функции для работы с массивами
Функция Тип результата Описание array_append (
anyarray,
anyelement) anyarray добавляет элемент array_append(
в конец массива
ARRAY[1,2], 3) (1,2,3)
array_cat (
anyarray,
anyarray) anyarray соединяет два мас- array_cat(
сива
ARRAY[1,2,3],
ARRAY[4,5]) (1,2,3,4,5)
array_ndims (
anyarray) int возвращает число array_ndims(
размерностей мас- ARRAY[[1,2,
сива
3], [4,5,6]]) 2
array_dims (
anyarray) text возвращает
тек- array_dims(
стовое представле- ARRAY[[1,2,
ние размерностей 3], [4,5,6]])
массива [1:2][1:3]
array_fill (
anyelement,
int[]
int[]]) anyarray возвращает
мас- array_fill(7,
сив, заполненный
ARRAY[3],
заданным значе- ARRAY[2])
нием и имеющий [2:4]=(7,7,7)
[,
282
Пример
РезультатФункции и операторы
Функция
Тип результата
Описание
Пример
указанные размер-
ности, в которых
нижняя
граница
может быть отлич-
на от 1 Результат
array_length (
int
anyarray, int) возвращает длину array_length(
указанной размер- array[1,2,3],
ности массива
1) 3
array_lower (
int
anyarray, int) возвращает ниж- array_lower(
нюю границу ука- '[0:2]=(1,2,
занной размерно- 3)'::int[], 1)
сти массива 0
array_position ( int
anyarray,
anyelement [,
int]) возвращает пози-
цию первого вхож-
дения второго ар-
гумента в массиве,
начиная с элемен-
та,
выбираемого
третьим аргумен-
том, либо с перво-
го элемента (мас-
сив должен быть
одномерным) array_position(
ARRAY['sun',
'mon','tue',
'wed','thu',
'fri','sat'],
'mon') 2
array_
positions (
anyarray,
anyelement) int[] возвращает
мас-
сив с позиция-
ми всех вхождений
второго аргумента
в массиве, задава-
емым первым ар-
гументом (массив
должен быть одно-
мерным) array_
positions(
ARRAY['A','A',
'B','A'], 'A') (1,2,4)
array_prepend (
anyelement,
anyarray) anyarray вставляет элемент array_prepend(
в начало массива 1, ARRAY[2,3]) (1,2,3)
array_remove (
anyarray,
anyelement) anyarray удаляет из масси- array_remove(
ва все элементы, ARRAY[1,2,3,
равные заданному 2], 2)
значению (массив
должен быть одно-
мерным) (1,3)
array_replace ( anyarray
anyarray,
anyelement,
anyelement) заменяет в масси- array_replace(
ве все элементы, ARRAY[1,2,5,
равные заданному 4], 5, 3)
значению, другим
значением (1,2,3,4)
array_to_
string (
anyarray,
[, text]) выводит элементы
массива через за-
данный раздели-
тель и позволяет
определить заме-
ну для значения
NULL 1,2,3,*,5
text
text
283
array_to_
string(
ARRAY[1, 2, 3,
NULL, 5], ',
', '*')Функции и операторы
Функция
Тип результата
Описание
Пример
Результат
array_upper (
int
anyarray, int) возвращает верх- array_upper(
нюю границу ука- ARRAY[1,8,3,
занной размерно- 7], 1)
сти массива 4
cardinality(
anyarray) возвращает общее cardinality(
число элементов в ARRAY[[1,2],
массиве, либо 0, [3,4]])
если массив пуст 4
разбивает строку
на элементы мас-
сива,
используя
заданный раздели-
тель и, возможно,
замену для значе-
ний NULL (xx,NULL,zz)
int
string_to_
text[]
array ( text,
text [, text])
unnest(
anyarray)
unnest(
anyarray,
anyarray
...])
string_to_
array(
'xx~^~yy~
^~zz',
'~^~',
'yy')
setof anyelement разворачивает
unnest(ARRAY[1,
массив в набор 2])
строк
setof anyelement, разворачивает
anyelement [, массивы (возмож-
но разных типов)
[, ...]
в набор строк. Это
допускается толь-
ко в предложении
FROM; см. Подраз-
дел 7.2.1.4
unnest(ARRAY[1,
2],
ARRAY['foo',
'bar','baz'])
1
2
(2 строки)
1
foo
2
bar
NULL baz
(3 строки)
В функциях array_position и array_positions каждый элемент массива сравнивается с искомым
значением по принципу IS NOT DISTINCT FROM.
Функция array_position возвращает NULL, если искомое значение не находится.
Функция array_positions возвращает NULL, только если в качестве массива передаётся NULL; если
же в массиве не находится значение, она возвращает пустой массив.
Если для функции string_to_array в качестве разделителя задан NULL, каждый символ входной
строки станет отдельным элементом в полученном массиве. Если разделитель пустая строка, стро-
ка будет возвращена целиком в массиве из одного элемента. В противном случае входная строка
разбивается по вхождениям подстроки, указанной в качестве разделителя.
Если для функции string_to_array параметр замены значения NULL опущен или равен NULL,
никакие подстроки во входных данных не будут заменяться на NULL. Если же параметр замены
NULL опущен или равен NULL для функции array_to_string, все значения NULL просто пропус-
каются и никак не представляются в выходной строке.
Примечание
В поведении string_to_array по сравнению с PostgreSQL версий до 9.1 произошли два
изменения. Во-первых, эта функция возвращает пустой массив (содержащий 0 элемен-
тов), а не NULL, когда входная строка имеет нулевую длину. Во-вторых, если в каче-
стве разделителя задан NULL, эта функция разбивает строку по символам, а не просто
возвращает NULL, как было раньше.
284Функции и операторы
Вы также можете узнать об агрегатной функции, работающей с массивами, array_agg в Разде-
ле 9.20.
9.19. Диапазонные функции и операторы
Диапазонные типы данных рассматриваются в Разделе 8.17.
В Таблице 9.50 показаны операторы, предназначенные для работы с диапазонами.
Таблица 9.50. Диапазонные операторы
Оператор Описание Пример Результат
= равно int4range(1,5)
=
'[1,4]'::int4range t
&amp;lt;&amp;gt; не равно numrange(1.1,2.2)
&amp;lt;&amp;gt;
numrange(1.1,
2.3) t
&amp;lt; меньше int4range(1,10)
int4range(2,3) &amp;lt; t
&amp;gt; больше int4range(1,10)
int4range(1,5) &amp;gt; t
&amp;lt;= меньше или равно numrange(1.1,2.2)
&amp;lt;=
numrange(1.1,
2.2) t
&amp;gt;= больше или равно numrange(1.1,2.2)
&amp;gt;=
numrange(1.1,
2.0) t
@&amp;gt; содержит диапазон int4range(2,4)
int4range(2,3) t
@&amp;gt; содержит элемент '[2011-01-01,
t
2011-03-01)'::tsrange
@&amp;gt;
'2011-01-10'::timestamp
&amp;lt;@ диапазон содержится в int4range(2,4)
int4range(1,7) &amp;lt;@ элемент содержится в &amp;amp;&amp;amp; пересекает (есть общие int8range(3,7)
точки)
int8range(4,12) &amp;lt;&amp;lt;
42
7)
&amp;lt;@
@&amp;gt;
&amp;lt;@
int4range(1,
t
f
&amp;amp;&amp;amp; t
строго слева от int8range(1,10) &amp;lt;&amp;lt;
int8range(100,110) t
&amp;gt;&amp;gt; строго справа от int8range(50,60) &amp;gt;&amp;gt;
int8range(20,30) t
&amp;amp;&amp;lt; не простирается правее int8range(1,20) &amp;amp;&amp;lt;
int8range(18,20) t
&amp;amp;&amp;gt; не простирается левее int8range(7,20)
int8range(5,10) t
-|- примыкает к
&amp;amp;&amp;gt;
numrange(1.1,2.2)
-|-
numrange(2.2,
3.3)
285
tФункции и операторы
Оператор Описание Пример
Результат
+ union numrange(5,15)
numrange(10,20) + [5,20)
* пересечение int8range(5,15)
int8range(10,20) * [10,15)
- вычитание int8range(5,15)
int8range(10,20) - [5,10)
Простые операторы сравнения &amp;lt;, &amp;gt;, &amp;lt;= и &amp;gt;= сначала сравнивают нижние границы, и только если
они равны, сравнивают верхние. Эти операторы сравнения обычно не очень полезны для диапазо-
нов; основное их предназначение — сделать возможным построение индексов-B-деревьев по диа-
пазонам.
Операторы слева/справа/примыкает всегда возвращают false, если один из диапазонов пуст; то
есть, считается, что пустой диапазон находится не слева и не справа от какого-либо другого диа-
пазона.
Операторы сложения и вычитания вызывают ошибку, если получающийся в результате диапазон
оказывается состоящим из двух разделённых поддиапазонов, так как его нельзя представить в
этом типе данных.
В Таблице 9.51 перечислены функции, предназначенные для работы с диапазонными типами.
Таблица 9.51. Диапазонные функции
Функция
Тип результата
Описание
Пример
Результат
граница lower(numrange(
lower( anyrange) тип элемента диа- нижняя
пазона
диапазона
1.1, 2.2)) 1.1
upper( anyrange) тип элемента диа- верхняя граница upper(numrange(
пазона
диапазона
1.1, 2.2)) 2.2
isempty(
anyrange) boolean диапазон пуст? lower_inc (
anyrange) boolean нижняя
граница lower_inc(
включается?
numrange(1.1,
2.2)) true
upper_inc (
anyrange) boolean верхняя граница upper_inc(
включается?
numrange(1.1,
2.2)) false
lower_inf (
anyrange) boolean нижняя
граница lower_inf('(,
равна бесконечно- )'::daterange)
сти? true
upper_inf (
anyrange) boolean верхняя граница upper_inf('(,
равна бесконечно- )'::daterange)
сти? true
range_merge (
anyrange,
anyrange) anyrange наименьший диа- range_merge(
пазон, включаю- '[1,
щий оба заданных 2)'::int4range,
диапазона
'[3,
4)'::int4range) [1,4)
isempty(
numrange(1.1,
2.2))
false
Функции lower и upper возвращают NULL, если диапазон пуст или указанная граница равна бес-
конечности. Если же пустой диапазон передаётся функциям lower_inc, upper_inc, lower_inf и
upper_inf, все они возвращают false.
286Функции и операторы
9.20. Агрегатные функции
Агрегатные функции получают единственный результат из набора входных значений. Встроенные
агрегатные функции общего назначения перечислены в Таблице 9.52, а статистические агрегат-
ные функции — в Таблице 9.53. Встроенные внутригрупповые сортирующие агрегатные функции
перечислены в Таблице  9.54, встроенные внутригрупповые гипотезирующие — в Таблице  9.55.
Группирующие операторы, тесно связанные с агрегатными функциями, перечислены в Табли-
це 9.56. Особенности синтаксиса агрегатных функцией разъясняются в Подразделе 4.2.7. За до-
полнительной вводной информацией обратитесь к Разделу 2.7.
Таблица 9.52. Агрегатные функции общего назначения
Функция Типы аргумента Тип результата array_agg(
выражение) любой тип не мас- массив элементов Нет
сива
с типом аргумента входные значения,
включая
NULL,
объединяются
в
массив
array_agg(
выражение) любой тип массива тот же, что и тип Нет
аргумента входные
масси-
вы собираются в
массив
большей
размерности (они
должны иметь од-
ну размерность и
не могут быть пу-
стыми или равны
NULL)
avg( выражение) smallint,
int,
bigint,
real,
double precision,
numeric
или
interval numeric для лю- Да
бых целочислен-
ных
аргументов,
double precision
для аргументов с
плавающей
точ-
кой, в противном
случае тип данных
аргумента арифметическое
среднее для всех
входных значений
bit_and(
выражение) smallint,
int, тот же, что и тип Да
аргумента
bigint или bit побитовое И для
всех входных зна-
чений, не равных
NULL, или NULL,
если таких нет
bit_or(
выражение) smallint,
int, тот же, что и тип Да
аргумента
bigint или bit побитовое
ИЛИ
для всех входных
значений, не рав-
ных NULL, или
NULL, если таких
нет
bool_and(
выражение) bool bool Да true, если все вход-
ные значения рав-
ны true, и false в
противном случае
bool_or(
выражение) bool bool Да true, если хотя бы
одно входное зна-
чение равно true, и
false в противном
случае
287
Частичный
жим
ре- ОписаниеФункции и операторы
Функция
Типы аргумента Тип результата
count(*)
Частичный
жим
ре- Описание
bigint Да количество
ных строк
вход-
count(
выражение) any bigint Да количество вход-
ных строк, для
которых значение
выражения не рав-
но NULL
every(
выражение) bool bool Да синоним
and
json_agg(
выражение) any json Нет агрегирует значе-
ния в виде массива
JSON
jsonb_agg(
выражение) any jsonb Нет агрегирует значе-
ния в виде массива
JSON
json_object_
(any, any)
agg( имя, значе-
ние) json Нет агрегирует пары
имя/значение в ви-
де объекта JSON
jsonb_object_
(any, any)
agg( имя, значе-
ние) jsonb Нет агрегирует пары
имя/значение в ви-
де объекта JSON
bool_
max( выражение) любой числовой, тот же, что и тип Да
строковый, сете- аргумента
вой тип или тип
даты/времени, ли-
бо массив этих ти-
пов максимальное зна-
чение выражения
среди всех вход-
ных данных
min( выражение) любой числовой, тот же, что и тип Да
строковый, сете- аргумента
вой тип или тип
даты/времени, ли-
бо массив этих ти-
пов минимальное зна-
чение выражения
среди всех вход-
ных данных
string_agg(
выражение,
делитель)
(text, text) или ( тот же, что и типы Нет
аргументов
раз- bytea, bytea)
sum( выражение) smallint,
int,
bigint,
real,
double precision,
numeric, interval
или money bigint для аргу- Да
ментов smallint
или int, numeric
для
аргументов
bigint, и тип аргу-
мента в остальных
случаях
xmlagg(
выражение) xml xml
Нет
288
входные
данные
складываются
в
строку через за-
данный раздели-
тель
сумма
значений
выражения по всем
входным данным
соединение XML-
значений
(см.
также
Подраз-
дел 9.14.1.7)Функции и операторы
Следует заметить, что за исключением count, все эти функции возвращают NULL, если для них не
была выбрана ни одна строка. В частности, функция sum, не получив строк, возвращает NULL, а не
0, как можно было бы ожидать, и array_agg в этом случае возвращает NULL, а не пустой массив.
Если необходимо, подставить в результат 0 или пустой массив вместо NULL можно с помощью
функции coalesce.
Агрегатные функции, поддерживающие частичный режим, являются кандидатами на участие в
различных оптимизациях, например, в параллельном агрегировании.
Примечание
Булевы агрегатные функции bool_and и bool_or соответствуют стандартным SQL-аг-
регатам every и any или some. Что касается any и some, по стандарту их синтаксис до-
пускает некоторую неоднозначность:
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
Здесь ANY можно рассматривать и как объявление подзапроса, и как агрегатную функ-
цию, если этот подзапрос возвращает одну строку с булевым значением. Таким обра-
зом, этим агрегатным функциям нельзя было дать стандартные имена.
Примечание
Пользователи с опытом использования других СУБД SQL могут быть недовольны ско-
ростью агрегатной функции count, когда она применяется ко всей таблице. Подобный
запрос:
SELECT count(*) FROM sometable;
потребует затрат в количестве, пропорциональном размеру таблицы: PostgreSQL при-
дётся полностью просканировать либо всю таблицу, либо один из индексов, включаю-
щий все её строки.
Агрегатные функции array_agg, json_agg, jsonb_agg, json_object_agg, jsonb_object_agg,
string_agg и xmlagg так же, как и подобные пользовательские агрегатные функции, выдают раз-
ные по содержанию результаты в зависимости от порядка входных значений. По умолчанию поря-
док не определён, но его можно задать, дополнив вызов агрегатной функции предложением ORDER
BY, как описано в Подразделе 4.2.7. Обычно нужного результата также можно добиться, передав
для агрегирования результат подзапроса с сортировкой. Например:
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
Но учтите, что этот подход может не работать, если на внешнем уровне запроса выполняется до-
полнительная обработка, например, соединение, так как при этом результат подзапроса может
быть переупорядочен перед вычислением агрегатной функции.
В Таблице 9.53 перечислены агрегатные функции, обычно применяемые в статистическом анали-
зе. (Они выделены просто для того, чтобы не загромождать список наиболее популярных агрегат-
ных функций.) В их описании под N подразумевается число входных строк, для которых входные
выражения не равны NULL. Все эти функции возвращают NULL во всех случаях, когда вычисление
бессмысленно, например, когда N равно 0.
Таблица 9.53. Агрегатные функции для статистических вычислений
Функция
corr( Y,
Тип аргумента
X)
Тип результата
Частичный
жим
double precision double precision Да
289
ре- Описание
коэффициент кор-
реляцииФункции и операторы
Функция
Тип аргумента
covar_pop(
X)
Y,
covar_samp(
X)
Y,
Тип результата
Частичный
жим
ре- Описание
double precision double precision Да ковариация
купности
сово-
double precision double precision Да ковариация выбор-
ки
regr_avgx(
X) Y, double precision double precision Да среднее независи-
мой переменной (
sum( X)/N)
regr_avgy(
X) Y, double precision double precision Да среднее
зависи-
мой переменной (
sum( Y)/N)
Да число
входных
строк, в которых
оба выражения не
NULL
double precision double precision Да пересечение
с
осью OY линии, по-
лученной методом
наименьших квад-
ратов по данным (
X, Y)
regr_count(
X)
Y,
regr_intercept(
Y, X)
regr_r2(
double precision bigint
X) double precision double precision Да
Y,
regr_slope(
X)
Y,
квадрат
циента
ции
коэффи-
корреля-
double precision double precision Да наклон линии, по-
лученной методом
наименьших квад-
ратов по данным (
X, Y)
regr_sxx( Y, X) double precision double precision Да sum( X^2) - sum(
X)^2/N
(«сумма
квадратов» неза-
висимой перемен-
ной)
regr_sxy( Y, X) double precision double precision Да sum( X*Y) - sum(
X) * sum( Y)/N (
«сумма произведе-
ний» независимых
и зависимых пере-
менных)
regr_syy( Y, X) double precision double precision Да sum( Y^2) - sum(
Y)^2/N
(«сумма
квадратов» зави-
симой
перемен-
ной)
double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных сохранившийся
синоним stddev_
samp
stddev(
выражение)
smallint,
int,
bigint,
real,
double precision
или numeric
290Функции и операторы
Функция Тип аргумента Тип результата
Частичный
жим
ре- Описание
stddev_pop(
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных стандартное
от-
клонение по гене-
ральной совокуп-
ности входных зна-
чений
stddev_samp(
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных стандартное
от-
клонение по вы-
борке входных зна-
чений
variance(
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных сохранившийся
синоним
var_
samp
var_pop (
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных дисперсия для ге-
неральной
сово-
купности входных
значений (квадрат
стандартного от-
клонения)
var_samp (
выражение) smallint,
int,
bigint,
real,
double precision
или numeric double precision Да
для аргументов с
плавающей
точ-
кой, numeric для
остальных дисперсия по вы-
борке для входных
значений (квадрат
отклонения по вы-
борке)
В Таблице 9.54 показаны некоторые агрегатные функции, использующие синтаксис сортирующих
агрегатных функций. Иногда такие функции функциями называют функциями «обратного распре-
деления».
Таблица 9.54. Сортирующие агрегатные функции
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
Описание
mode() WITHIN
GROUP (ORDER
BY выражение_
сортировки) любой сортиру- тот же, что Нет
емый тип
у
выражения
сортировки возвращает
значение, наи-
более
часто
встречающее-
ся
во
вход-
ных данных (
если одинаково
часто встреча-
ются несколько
значений, про-
извольно выби-
рается первое
из них)
percentile_
double
cont( дробь)
precision
WITHIN
GROUP
(ORDER BY вы- тот же, что Нет
double
выражения
precision или у
сортировки
interval непрерывный
процентиль:
возвращает
значение, соот-
291Функции и операторы
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
ражение_
сортировки)
Описание
ветствующее
заданной дро-
би по поряд-
ку, интерполи-
руя
соседние
входные значе-
ния, если необ-
ходимо
percentile_
double
cont( дроби)
precision[]
WITHIN
GROUP
(ORDER BY вы-
ражение_
сортировки) массив
ти- Нет
double
precision или па выражения
сортировки
interval множествен-
ный
непре-
рывный
про-
центиль:
воз-
вращает
мас-
сив результа-
тов,
соответ-
ствующих фор-
ме параметра
дроби (для каж-
дого элемента
не NULL под-
ставляется зна-
чение, соответ-
ствующее дан-
ному проценти-
лю)
percentile_
double
disc( дробь)
precision
WITHIN
GROUP
(ORDER BY вы-
ражение_
сортировки) любой сортиру- тот же, что Нет
емый тип
у
выражения
сортировки дискретный
процентиль:
возвращает
первое значе-
ние из вход-
ных данных, по-
зиция которого
по порядку рав-
на или превос-
ходит указан-
ную дробь
percentile_
double
disc( дроби)
precision[]
WITHIN
GROUP
(ORDER BY вы-
ражение_
сортировки) любой сортиру- массив
ти- Нет
емый тип
па выражения
сортировки множествен-
ный
дискрет-
ный
процен-
тиль:
возвра-
щает
мас-
сив результа-
тов,
соответ-
ствующих фор-
ме
парамет-
ра
дроби
(
для
каждого
элемента
не
NULL подстав-
ляется
вход-
ное
значе-
ние,
соответ-
ствующее дан-
292Функции и операторы
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
Описание
ному проценти-
лю)
Все агрегатные функции, перечисленные в Таблице 9.54, игнорируют значения NULL при сорти-
ровке данных. Для функций, принимающих параметр дробь, значение этого параметра должно
быть от 0 до 1; в противном случае возникает ошибка. Однако, если в этом параметре передаётся
NULL, эти функции просто выдают NULL.
Все агрегатные функции, перечисленные в Таблице  9.55, связаны с одноимёнными оконными
функциями, определёнными в Разделе 9.21. В каждом случае их результат — значение, которое
вернула бы связанная оконная функция для «гипотетической» строки, полученной из аргументов,
если бы такая строка была добавлена в сортированную группу строк, которую образуют сортиро-
ванные_аргументы.
Таблица 9.55. Гипотезирующие агрегатные функции
Функция
Тип непосред- Тип агрегиро- Тип результа- Частичный
ственного ар- ванного аргу- та
режим
гумента
мента
Описание
rank(
VARIADIC &quot;any&quot; VARIADIC &quot;any&quot; bigint
аргументы)
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет ранг гипотети-
ческой
стро-
ки, с пропус-
ками повторя-
ющихся строк
dense_rank(
VARIADIC &quot;any&quot; VARIADIC &quot;any&quot; bigint
аргументы)
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет ранг гипотети-
ческой строки,
без пропусков
percent_
VARIADIC &quot;any&quot; VARIADIC &quot;any&quot; double
rank(
precision
аргументы)
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет относительный
ранг гипотети-
ческой строки,
от 0 до 1
cume_dist(
VARIADIC &quot;any&quot; VARIADIC &quot;any&quot; double
аргументы)
precision
WITHIN
GROUP
(ORDER
BY
сортирован-
ные_
аргументы) Нет относительный
ранг гипотети-
ческой строки,
от 1/N до 1
Для всех этих гипотезирующих агрегатных функций непосредственные аргументы должны соот-
ветствовать (по количеству и типу) сортированным_аргументам. В отличие от встроенных агрегат-
ных функций, они не являются строгими, то есть не отбрасывают входные строки, содержащие
NULL. Значения NULL сортируются согласно правилу, указанному в предложении ORDER BY.
293Функции и операторы
Таблица 9.56. Операции группировки
Функция Тип результата Описание
GROUPING( аргументы...) integer Целочисленная битовая маска,
показывающая, какие аргумен-
ты не вошли в текущий набор
группирования
Операции группировки применяются в сочетании с наборами группирования (см. Подраздел 7.2.4)
для различения результирующих строк. Аргументы операции GROUPING на самом деле не вычисля-
ются, но они должны в точности соответствовать выражениям, заданным в предложении GROUP BY
на их уровне запроса. Биты назначаются справа налево (правый аргумент отражается в младшем
бите); бит равен 0, если соответствующее выражение вошло в критерий группировки набора груп-
пирования, для которого сформирована строка результата, или 1 в противном случае. Например:
=&amp;gt; SELECT * FROM items_sold;
make | model | sales
-------+-------+-------
Foo
| GT
| 10
Foo
| Tour | 20
Bar
| City | 15
Bar
| Sport | 5
(4 rows)
=&amp;gt; SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY
ROLLUP(make,model);
make | model | grouping | sum
-------+-------+----------+-----
Foo
| GT
|
0 | 10
Foo
| Tour |
0 | 20
Bar
| City |
0 | 15
Bar
| Sport |
0 | 5
Foo
|
|
1 | 30
Bar
|
|
1 | 20
|
|
3 | 50
(7 rows)
9.21. Оконные функции
Оконные функции дают возможность выполнять вычисления с набором строк, каким-либо образом
связанным с текущей строкой запроса. Вводную информацию об этом можно получить в Разде-
ле 3.5, а подробнее узнать о синтаксисе можно в Подразделе 4.2.8.
Встроенные оконные функции перечислены в Таблице 9.57. Заметьте, что эти функции должны
вызываться именно как оконные, т. е. при вызове необходимо использовать предложение OVER.
В дополнение к этим функциям в качестве оконных можно использовать любые встроенные или
пользовательские универсальные или статистические агрегатные функции (но не сортирующие и
не гипотезирующие); список встроенных агрегатных функций приведён в Разделе 9.20. Агрегат-
ные функции работают как оконные, только когда за их вызовом следует предложение OVER; в про-
тивном случае они работают как обычные, не оконные функции и выдают для всего набора един-
ственную строку.
Таблица 9.57. Оконные функции общего назначения
Функция Тип результата Описание
row_number() bigint номер текущей строки в её раз-
деле, начиная с 1
rank() bigint ранг текущей строки с про-
пусками; то же, что и row_
294Функции и операторы
Функция Тип результата Описание
number для первой родствен-
ной ей строки
dense_rank() bigint ранг текущей строки без про-
пусков; эта функция считает
группы родственных строк
percent_rank() double precision относительный ранг текущей
строки: (rank - 1) / (общее число
строк раздела - 1)
cume_dist() double precision кумулятивное распределение: (
число строк раздела, предше-
ствующих или родственных те-
кущей строке) / общее число
строк раздела
ntile( число_групп
ранжирование по целым чис-
лам от 1 до значения аргумента
так, чтобы размеры групп были
максимально близки
integer) integer
lag( значение anyelement [,
смещение integer [,
по_
умолчанию anyelement ]]) тип аргумента значение возвращает значение для стро-
ки, положение которой задаёт-
ся смещением от текущей стро-
ки к началу раздела; если такой
строки нет, возвращается зна-
чение по_умолчанию (оно долж-
но иметь тот же тип, что и зна-
чение). Оба параметра смеще-
ние и по_умолчанию вычисля-
ются для текущей строки. Если
они не указываются, то смеще-
ние считается равным 1, а по_
умолчанию — NULL
lead( значение anyelement [,
смещение integer [,
по_
умолчанию anyelement ]]) тип аргумента значение возвращает значение для стро-
ки, положение которой задаёт-
ся смещением от текущей стро-
ки к концу раздела; если такой
строки нет, возвращается зна-
чение по_умолчанию (оно долж-
но иметь тот же тип, что и зна-
чение). Оба параметра смеще-
ние и по_умолчанию вычисля-
ются для текущей строки. Если
они не указываются, то смеще-
ние считается равным 1, а по_
умолчанию — NULL
first_value( тип аргумента значение возвращает значение, вычис-
ленное для первой строки в рам-
ке окна
тип аргумента значение возвращает значение, вычис-
ленное для последней строки в
рамке окна
n тип аргумента значение возвращает значение, вычис-
ленное в н-ой строке в рамке ок-
last_value(
nth_value(
integer)
значение any)
значение any)
значение any,
295Функции и операторы
Функция
Тип результата
Описание
на (считая с 1), или NULL, если
такой строки нет
Результат всех функций, перечисленных в Таблице 9.57, зависит от порядка сортировки, заданного
предложением ORDER BY в определении соответствующего окна. Строки, которые являются одина-
ковыми при рассмотрении только столбцов ORDER BY, считаются родственными. Четыре функции,
вычисляющие ранг (включая cume_dist), реализованы так, что их результат будет одинаковым для
всех родственных строк.
Заметьте, что функции first_value, last_value и nth_value рассматривают только строки в «рам-
ке окна», которая по умолчанию содержит строки от начала раздела до последней родственной
строки для текущей. Поэтому результаты last_value и иногда nth_value могут быть не очень по-
лезны. В таких случаях можно переопределить рамку, добавив в предложение OVER подходящее
указание рамки (RANGE, ROWS или GROUPS). Подробнее эти указания описаны в Подразделе 4.2.8.
Когда в качестве оконной функции используется агрегатная, она обрабатывает строки в рамке те-
кущей строки. Агрегатная функция с ORDER BY и определением рамки окна по умолчанию будет
вычисляться как «бегущая сумма», что может не соответствовать желаемому результату. Чтобы
агрегатная функция работала со всем разделом, следует опустить ORDER BY или использовать ROWS
BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING. Используя другие указания в определе-
нии рамки, можно получить и другие эффекты.
Примечание
В стандарте SQL определены параметры RESPECT NULLS или IGNORE NULLS для функций
lead, lag, first_value, last_value и nth_value. В PostgreSQL такие параметры не ре-
ализованы: эти функции ведут себя так, как положено в стандарте по умолчанию (или
с подразумеваемым параметром RESPECT NULLS). Также функция nth_value не поддер-
живает предусмотренные стандартом параметры FROM FIRST и FROM LAST: реализовано
только поведение по умолчанию (с подразумеваемым параметром FROM FIRST). (Полу-
чить эффект параметра FROM LAST можно, изменив порядок ORDER BY на обратный.)
Функция cume_dist вычисляет процент строк раздела, которые меньше или равны текущей строке
или родственным ей строкам, тогда как percent_rank вычисляет процент строк раздела, которые
меньше текущей строки, в предположении, что текущая строка не относится к разделу.
9.22. Выражения подзапросов
В этом разделе описаны выражения подзапросов, которые реализованы в PostgreSQL в соответ-
ствии со стандартом SQL. Все рассмотренные здесь формы выражений возвращает булевы значе-
ния (true/false).
9.22.1. EXISTS
EXISTS (подзапрос)
Аргументом EXISTS является обычный оператор SELECT, т. е. подзапрос. Выполнив запрос, систе-
ма проверяет, возвращает ли он строки в результате. Если он возвращает минимум одну строку,
результатом EXISTS будет «true», а если не возвращает ни одной — «false».
Подзапрос может обращаться к переменным внешнего запроса, которые в рамках одного вычис-
ления подзапроса считаются константами.
Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как только будет воз-
вращена хотя бы одна строка. Поэтому в подзапросах следует избегать побочных эффектов (на-
пример, обращений к генераторам последовательностей); проявление побочного эффекта может
быть непредсказуемым.
296Функции и операторы
Так как результат этого выражения зависит только от того, возвращаются строки или нет, но не от
их содержимого, список выходных значений подзапроса обычно не имеет значения. Как следствие,
широко распространена практика, когда проверки EXISTS записываются в форме EXISTS(SELECT
1 WHERE ...). Однако из этого правила есть и исключения, например с подзапросами с предло-
жением INTERSECT.
Этот простой пример похож на внутреннее соединение по столбцу col2, но он выдаёт максимум
одну строку для каждой строки в tab1, даже если в tab2 ей соответствуют несколько строк:
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
9.22.2. IN
выражение IN (подзапрос)
В правой стороне этого выражения в скобках задаётся подзапрос, который должен возвращать ров-
но один столбец. Вычисленное значение левого выражения сравнивается со значениями во всех
строках, возвращённых подзапросом. Результатом всего выражения IN будет «true», если строка
с таким значением находится, и «false» в противном случае (в том числе, когда подзапрос вообще
не возвращает строк).
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция IN возвращает NULL, а
не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
конструктор_строки IN (подзапрос)
В левой части этой формы IN записывается конструктор строки (подробнее они рассматриваются
в Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен вернуть ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом.
Результатом всего выражения IN будет «true», если строка с такими значениями находится, и
«false» в противном случае (в том числе, когда подзапрос вообще не возвращает строк).
Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам
сравнения. Две строки считаются равными, если все их соответствующие элементы не равны
NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не рав-
ные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён
(равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы
один NULL, результатом IN будет NULL.
9.22.3. NOT IN
выражение NOT IN (подзапрос)
Справа в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вы-
численное значение левого выражения сравнивается со значением во всех строках, возвращённых
подзапросом. Результатом всего выражения NOT IN будет «true», если находятся только несовпа-
дающие строки (в том числе, когда подзапрос вообще не возвращает строк). Если же находится
хотя бы одна подходящая строка, результатом будет «false».
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция NOT IN возвращает
NULL, а не true. Это соответствует принятым в SQL правилам сравнения переменных со значени-
ями NULL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
297Функции и операторы
конструктор_строки NOT IN (подзапрос)
В левой части этой формы NOT IN записывается конструктор строки (подробнее они описываются
в Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен вернуть ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом.
Результатом всего выражения NOT IN будет «true», если равных строк не найдётся (в том числе, и
когда подзапрос не возвращает строк), и «false», если такие строки есть.
Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам
сравнения. Две строки считаются равными, если все их соответствующие элементы не равны
NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не рав-
ные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён
(равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы
один NULL, результатом NOT IN будет NULL.
9.22.4. ANY/SOME
выражение оператор ANY (подзапрос)
выражение оператор SOME (подзапрос)
В правой части конструкции в скобках записывается подзапрос, который должен возвращать ров-
но один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой
строке результата подзапроса с помощью заданного оператора условия, который должен выдавать
логическое значение. Результатом ANY будет «true», если хотя бы для одной строки условие истин-
но, и «false» в противном случае (в том числе, и когда подзапрос не возвращает строк).
Ключевое слово SOME является синонимом ANY. Конструкцию IN можно записать также записать
как = ANY.
Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы для одной строки
условный оператор выдаёт NULL, конструкция ANY возвращает NULL, а не false. Это соответствует
принятым в SQL правилам сравнения переменных со значениями NULL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
конструктор_строки оператор ANY (подзапрос)
конструктор_строки оператор SOME (подзапрос)
В левой части этой формы ANY записывается конструктор строки (подробнее они описываются в
Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен возвращать ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом,
с применением заданного оператора. Результатом всего выражения ANY будет «true», если для
какой-либо из строк подзапроса результатом сравнения будет true, или «false», если для всех строк
результатом сравнения оказывается false (в том числе, и когда подзапрос не возвращает строк).
Результатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения
не равен true, а минимум для одной равен NULL.
Подробнее логика сравнения конструкторов строк описана в Подразделе 9.23.5.
9.22.5. ALL
выражение оператор ALL (подзапрос)
В правой части конструкции в скобках записывается подзапрос, который должен возвращать ров-
но один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой
строке результата подзапроса с помощью заданного оператора условия, который должен выдавать
логическое значение. Результатом ALL будет «true», если условие истинно для всех строк (и когда
подзапрос не возвращает строк), или «false», если находятся строки, для которых оно ложно. Ре-
зультатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения
не равен true, а минимум для одной равен NULL.
298Функции и операторы
Конструкция NOT IN равнозначна &amp;lt;&amp;gt; ALL.
Так же, как и с EXISTS, здесь не следует рассчитывать на то, что подзапрос будет всегда выпол-
няться полностью.
конструктор_строки оператор ALL (подзапрос)
В левой части этой формы ALL записывается конструктор строки (подробнее они описываются в
Подразделе 4.2.13). Справа в скобках записывается подзапрос, который должен возвращать ровно
столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого
выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом,
с применением заданного оператора. Результатом всего выражения ALL будет «true», если для всех
строк подзапроса результатом сравнения будет true (или если подзапрос не возвращает строк),
либо «false», если результат сравнения равен false для любой из строк подзапроса. Результатом
выражения будет NULL, если ни для одной из строк подзапроса результат сравнения не равен true,
а минимум для одной равен NULL.
Подробнее логика сравнения конструкторов строк описана в Подразделе 9.23.5.
9.22.6. Сравнение единичных строк
конструктор_строки оператор (подзапрос)
В левой части конструкции записывается конструктор строки (подробнее они описываются в Под-
разделе  4.2.13). Справа в скобках записывается подзапрос, который должен возвращать ровно
столько столбцов, сколько содержит строка в выражении слева. Более того, подзапрос может вер-
нуть максимум одну строку. (Если он не вернёт строк, результатом будет NULL.) Конструкция воз-
вращает результат сравнения строки слева с этой одной строкой результата подзапроса.
Подробнее логика сравнения конструкторов строк описана в Подразделе 9.23.5.
9.23. Сравнение табличных строк и массивов
В этом разделе описываются несколько специальных конструкций, позволяющих сравнивать груп-
пы значений. Синтаксис этих конструкций связан с формами выражений с подзапросами, описан-
ными в предыдущем разделе, а отличаются они отсутствием подзапросов. Конструкции, в кото-
рых в качестве подвыражений используются массивы, являются расширениями PostgreSQL; все
остальные формы соответствуют стандарту SQL. Все описанные здесь выражения возвращают ло-
гические значения (true/false).
9.23.1. IN
выражение IN (значение [, ...])
Справа в скобках записывается список скалярных выражений. Результатом будет «true», если зна-
чение левого выражения равняется одному из значений выражений в правой части. Эту конструк-
цию можно считать краткой записью условия
выражение = значение1
OR
выражение = значение2
OR
...
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция IN возвращает NULL, а
не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.
9.23.2. NOT IN
выражение NOT IN (значение [, ...])
Справа в скобках записывается список скалярных выражений. Результатом будет «true», если зна-
чение левого выражения не равно ни одному из значений выражений в правой части. Эту кон-
струкцию можно считать краткой записью условия
299Функции и операторы
выражение &amp;lt;&amp;gt; значение1
AND
выражение &amp;lt;&amp;gt; значение2
AND
...
Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа
не находится, а хотя бы одно из значений справа равно NULL, конструкция NOT IN возвращает
NULL, а не true, как можно было бы наивно полагать. Это соответствует принятым в SQL правилам
сравнения переменных со значениями NULL.
Подсказка
Выражения x NOT IN y и NOT (x IN y) полностью равнозначны. Учитывая, что значения
NULL могут ввести в заблуждение начинающих скорее в конструкции NOT IN, чем в IN,
лучше формулировать условия так, чтобы в них было как можно меньше отрицаний.
9.23.3. ANY/SOME (с массивом)
выражение оператор ANY (выражение массива)
выражение оператор SOME (выражение массива)
Справа в скобках записывается выражение, результатом которого является массив. Вычисленное
значение левого выражения сравнивается с каждым элементом этого массива с применением за-
данного оператора условия, который должен выдавать логическое значение. Результатом ANY бу-
дет «true», если для какого-либо элемента условие истинно, и «false» в противном случае (в том
числе, и когда массив оказывается пустым).
Если значением массива оказывается NULL, результатом ANY также будет NULL. Если NULL по-
лучен в левой части, результатом ANY обычно тоже будет NULL (хотя оператор нестрогого сравне-
ния может выдать другой результат). Кроме того, если массив в правой части содержит элементы
NULL и ни c одним из элементов условие не выполняется, результатом ANY будет NULL, а не false
(опять же, если используется оператор строгого сравнения). Это соответствует принятым в SQL
правилам сравнения переменных со значениями NULL.
Ключевое слово SOME является синонимом ANY.
9.23.4. ALL (с массивом)
выражение оператор ALL (выражение массива)
Справа в скобках записывается выражение, результатом которого является массив. Вычисленное
значение левого выражения сравнивается с каждым элементом этого массива с применением
заданного оператора условия, который должен выдавать логическое значение. Результатом ALL
будет «true», если для всех элементов условие истинно (или массив не содержит элементов), и
«false», если находятся строки, для которых оно ложно.
Если значением массива оказывается NULL, результатом ALL также будет NULL. Если NULL по-
лучен в левой части, результатом ALL обычно тоже будет NULL (хотя оператор нестрогого сравне-
ния может выдать другой результат). Кроме того, если массив в правой части содержит элементы
NULL и при этом нет элементов, с которыми условие не выполняется, результатом ALL будет NULL,
а не true (опять же, если используется оператор строгого сравнения). Это соответствует принятым
в SQL правилам сравнения переменных со значениями NULL.
9.23.5. Сравнение конструкторов строк
конструктор_строки оператор конструктор_строки
С обеих сторон представлены конструкторы строк (они описываются в Подразделе  4.2.13). При
этом данные строки должны содержать одинаковое число полей. После вычисления каждой сто-
300Функции и операторы
роны они сравниваются по строкам. Сравнения конструкторов строк возможны с оператором =, &amp;lt;&amp;gt;,
&amp;lt;, &amp;lt;=, &amp;gt; или &amp;gt;=. Каждый элемент строки должен иметь тип, для которого определён класс операто-
ров B-дерева; в противном случае при попытке сравнения может возникнуть ошибка.
Примечание
Ошибок, связанных с числом или типов элементов, не должно быть, если сравнение
выполняется с ранее полученными столбцами.
Сравнения = и &amp;lt;&amp;gt; несколько отличаются от других. С этими операторами две строки считаются
равными, если все их соответствующие поля не равны NULL и равны между собой, и неравными,
если какие-либо соответствующие их поля не NULL и не равны между собой. В противном случае
результатом сравнения будет неопределённость (NULL).
С операторами &amp;lt;, &amp;lt;=, &amp;gt; и &amp;gt;= элементы строк сравниваются слева направо до тех пор, пока не бу-
дет найдена пара неравных элементов или значений NULL. Если любым из элементов пары ока-
зывается NULL, результатом сравнения будет неопределённость (NULL), в противном случае ре-
зультат всего выражения определяется результатом сравнения этих двух элементов. Например,
результатом ROW(1,2,NULL) &amp;lt; ROW(1,3,0) будет true, а не NULL, так как третья пара элементов
не принимается в рассмотрение.
Примечание
До версии 8.2 PostgreSQL обрабатывал условия &amp;lt;, &amp;lt;=, &amp;gt; и &amp;gt;= не так, как это описано в
стандарте SQL. Сравнение ROW(a,b) &amp;lt; ROW(c,d) выполнялось как a &amp;lt; c AND b &amp;lt; d,
тогда как по стандарту должно быть a &amp;lt; c OR (a = c AND b &amp;lt; d).
конструктор_строки IS DISTINCT FROM конструктор_строки
Эта конструкция похожа на сравнение строк с оператором &amp;lt;&amp;gt;, но со значениями NULL она выдаёт
не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению
не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого
выражения будет true или false, но не NULL.
конструктор_строки IS NOT DISTINCT FROM конструктор_строки
Эта конструкция похожа на сравнение строк с оператором =, но со значениями NULL она выдаёт
не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению
не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого
выражения всегда будет true или false, но не NULL.
9.23.6. Сравнение составных типов
запись оператор запись
Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если результат зависит от
сравнения двух значений NULL или значения NULL и не NULL. PostgreSQL выполняет это требо-
вание только при сравнении строк, созданных конструкторами (как описано в Подразделе 9.23.5),
или строки, созданной конструктором, со строкой результата подзапроса (как было описано в Раз-
деле 9.22). В других контекстах при сравнении полей составных типов два значения NULL счита-
ются равными, а любое значение не NULL полагается меньшим NULL. Это отклонение от правила
необходимо для полноценной реализации сортировки и индексирования составных типов.
После вычисления каждой стороны они сравниваются по строкам. Сравнения составных типов
возможны с оператором =, &amp;lt;&amp;gt;, &amp;lt;, &amp;lt;=, &amp;gt; или &amp;gt;=, либо другим подобным. (Точнее, оператором сравне-
ния строк может быть любой оператор, входящий в класс операторов B-дерева, либо обратный к
оператору =, входящему в класс операторов B-дерева.) По умолчанию вышеперечисленные опера-
торы действуют так же, как выражение IS [ NOT ] DISTINCT FROM для конструкторов строк (см.
Подраздел 9.23.5).
301Функции и операторы
Для поддержки сравнения строк с элементами, для которых не определён класс операторов B-
дерева по умолчанию, введены следующие операторы: *=, *&amp;lt;&amp;gt;, *&amp;lt;, *&amp;lt;=, *&amp;gt; и *&amp;gt;=. Эти операторы
сравнивают внутреннее двоичное представление двух строк. Учтите, что две строки могут иметь
различное двоичное представление, даже когда при сравнении оператором равенства считаются
равными. Порядок строк с такими операторами детерминирован, но не несёт смысловой нагрузки.
Данные операторы применяются внутри системы для материализованных представлений и могут
быть полезны для других специальных целей (например, репликации), но, вообще говоря, не пред-
назначены для использования в обычных запросах.
9.24. Функции, возвращающие множества
В этом разделе описаны функции, которые могут возвращать не одну, а множество строк. Чаще
всего из их числа используются функции, генерирующие ряды значений, которые перечислены
в Таблице 9.58 и Таблице 9.59. Другие, более специализированные функции множеств описаны в
других разделах этой документации. Варианты комбинирования нескольких функций, возвращаю-
щих множества строк, описаны в Подразделе 7.2.1.4.
Таблица 9.58. Функции, генерирующие ряды значений
Функция Тип аргумента
Тип результата
Описание
generate_series(
start, stop) int, bigint или numeric setof
int,
setof Выдаёт ряд целых чи-
bigint
или
setof сел от start до stop с
numeric (определяется шагом 1
типом аргумента)
generate_series(
int, bigint или numeric setof
int,
setof Выдаёт ряд значений от
start, stop, step)
bigint
или
setof start до stop с задан-
numeric (определяется ным шагом (step)
типом аргумента)
generate_series(
timestamp
start,
stop,
step timestamp
interval)
zone
with
или setof timestamp или Выдаёт ряд значений от
time setof timestamp with start до stop с задан-
time zone (определяет- ным шагом (step)
ся типом аргумента)
Если заданный шаг (step) положительный, а start оказывается больше stop, эти функции возвра-
щают 0 строк. Тот же результат будет, если step меньше 0, а start меньше stop, или если какой-ли-
бо аргумент равен NULL. Если же step будет равен 0, произойдёт ошибка. Несколько примеров:
SELECT * FROM generate_series(2,4);
generate_series
-----------------
2
3
4
(3 rows)
SELECT * FROM generate_series(5,1,-2);
generate_series
-----------------
5
3
1
(3 rows)
SELECT * FROM generate_series(4,3);
generate_series
-----------------
(0 rows)
302Функции и операторы
SELECT generate_series(1.1, 4, 1.3);
generate_series
-----------------
1.1
2.4
3.7
(3 rows)
-- этот пример задействует оператор прибавления к дате целого числа
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
dates
------------
2004-02-05
2004-02-12
2004-02-19
(3 rows)
SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
'2008-03-04 12:00', '10 hours');
generate_series
---------------------
2008-03-01 00:00:00
2008-03-01 10:00:00
2008-03-01 20:00:00
2008-03-02 06:00:00
2008-03-02 16:00:00
2008-03-03 02:00:00
2008-03-03 12:00:00
2008-03-03 22:00:00
2008-03-04 08:00:00
(9 rows)
Таблица 9.59. Функции, генерирующие индексы массивов
Функция
Тип результата Описание
setof int Выдаёт ряд значений для ис-
пользования в качестве индекса
данного массива.
generate_subscripts( array setof int
anyarray, dim int, reverse
boolean) Выдаёт ряд значений для ис-
пользования в качестве индек-
са данного массива. Если пара-
метр reverse равен true, зна-
чения выдаются от большего к
меньшему.
generate_subscripts(
anyarray, dim int)
array
Функция generate_subscripts позволяет упростить получение всего набора индексов для указан-
ной размерности заданного массива. Она выдаёт 0 строк, если в массиве нет указанной размерно-
сти или сам массив равен NULL (хотя для элементов, равных NULL, индексы будут выданы, как и
для любых других). Взгляните на следующие примеры:
-- простой пример использования
SELECT generate_subscripts('(NULL,1,NULL,2)'::int[], 1) AS s;
s
---
1
2
3
303Функции и операторы
4
(4 rows)
-- для показанного массива получение индекса и обращение
-- к элементу по индексу выполняется с помощью подзапроса
SELECT * FROM arrays;
a
--------------------
(-1,-2)
(100,200,300)
(2 rows)
SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
array
| subscript | value
---------------+-----------+-------
(-1,-2)
|
1 |
-1
(-1,-2)
|
2 |
-2
(100,200,300) |
1 |
100
(100,200,300) |
2 |
200
(100,200,300) |
3 |
300
(5 rows)
-- разворачивание двумерного массива
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
from generate_subscripts($1,1) g1(i),
generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
unnest2
---------
1
2
3
4
(4 rows)
Когда после функции в предложении FROM добавляется WITH ORDINALITY, в выходные данные до-
бавляется столбец типа bigint, числа в котором начинаются с 1 и увеличиваются на 1 для каждой
строки, выданной функцией. В первую очередь это полезно для функций, возвращающих множе-
ства, например, unnest().
-- функция, возвращающая множество, с нумерацией
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
ls
| n
-----------------+----
pg_serial
| 1
pg_twophase
| 2
postmaster.opts | 3
pg_notify
| 4
postgresql.conf | 5
pg_tblspc
| 6
logfile
| 7
base
| 8
postmaster.pid | 9
304Функции и операторы
pg_ident.conf
global
pg_xact
pg_snapshots
pg_multixact
PG_VERSION
pg_wal
pg_hba.conf
pg_stat_tmp
pg_subtrans
(19 строк)
|
|
|
|
|
|
|
|
|
|
10
11
12
13
14
15
16
17
18
19
9.25. Системные информационные функции
В Таблице 9.60 перечислен ряд функций, предназначенных для получения информации о текущем
сеансе и системе.
В дополнение к перечисленным здесь функциям существуют также функции, связанные с под-
системой статистики, которые тоже предоставляют системную информацию. Подробнее они рас-
сматриваются в Подразделе 28.2.2.
Таблица 9.60. Функции получения информации о сеансе
Имя Тип результата Описание
current_catalog name имя текущей базы данных (в
стандарте SQL она называется
«каталогом»)
current_database() name имя текущей базы данных
current_query() text текст запроса, выполняемого в
данный момент, в том виде, в ка-
ком его передал клиент (может
состоять из нескольких опера-
торов)
current_role name синоним current_user
current_schema [()] name имя текущей схемы
current_schemas( name[] имена схем в пути поиска, воз-
можно включая схемы, добавля-
емые в него неявно
current_user name имя пользователя в текущем
контексте выполнения
inet_client_addr() inet адрес удалённой стороны со-
единения
inet_client_port() int порт удалённой стороны соеди-
нения
inet_server_addr() inet адрес локальной стороны соеди-
нения
inet_server_port() int порт локальной стороны соеди-
нения
pg_backend_pid() int код серверного процесса, обслу-
живающего текущий сеанс
int[] идентификаторы процессов, не
дающих серверному процессу с
определённым ID получить бло-
кировку
pg_blocking_pids(
boolean)
int)
305Функции и операторы
Имя Тип результата Описание
pg_conf_load_time() timestamp with time zone время загрузки конфигурации
pg_current_logfile(
[ text]) text имя файла главного журнала
или журнала в заданном форма-
те, который в настоящее время
используется сборщиком сооб-
щений
pg_my_temp_schema() oid OID временной схемы этого се-
анса или 0, если её нет
pg_is_other_temp_schema(
oid) boolean является ли заданная схема
временной в другом сеансе?
pg_jit_available() boolean доступна ли JIT-компиляция в
данном сеансе (см. Главу  32)?
Возвращает false, если пара-
метр jit равен false.
pg_listening_channels() setof text имена каналов, по которым те-
кущий сеанс принимает сигна-
лы
pg_notification_queue_
usage() double занятая доля очереди асинхрон-
ных уведомлений (0-1)
pg_postmaster_start_time(
) timestamp with time zone время запуска сервера
pg_safe_snapshot_
blocking_pids(
int) int[] Идентификаторы процессов, не
дающих серверному процессу с
определённым ID получить без-
опасный снимок
pg_trigger_depth() int текущий уровень вложенности
в триггерах PostgreSQL (0, если
эта функция вызывается (прямо
или косвенно) не из тела триг-
гера)
session_user name имя пользователя сеанса
user name синоним current_user
version() text информация
о
версии
PostgreSQL. Также можно про-
читать версию в машинно-ори-
ентированном виде, обратив-
шись к переменной server_
version_num.
Примечание
Функции current_catalog, current_role, current_schema, current_user, session_user
и user имеют особый синтаксический статус в SQL: они должны вызываться без скобок
после имени. (PostgreSQL позволяет добавить скобки в вызове current_schema, но не
других функций.)
Функция session_user обычно возвращает имя пользователя, установившего текущее соединение
с базой данных, но суперпользователи могут изменить это имя, выполнив команду SET SESSION
AUTHORIZATION. Функция current_user возвращает идентификатор пользователя, по которому
будут проверяться его права. Обычно это тот же пользователь, что и пользователь сеанса, но его
306Функции и операторы
можно сменить с помощью SET ROLE. Этот идентификатор также меняется при выполнении функ-
ций с атрибутом SECURITY DEFINER. На языке Unix пользователь сеанса называется «реальным»,
а текущий — «эффективным». Имена current_role и user являются синонимами current_user.
(В стандарте SQL current_role и current_user имеют разное значение, но в PostgreSQL они не
различаются, так как пользователи и роли объединены в единую сущность.)
Функция current_schema возвращает имя схемы, которая стоит первой в пути поиска (или NULL,
если путь поиска пуст). Эта схема будет задействована при создании таблиц или других имено-
ванных объектов, если целевая схема не указана явно. Функция current_schemas(boolean) возвра-
щает массив имён всех схем, находящихся в пути поиска. Её логический параметр определяет,
будут ли включаться в результат неявно добавляемые в путь поиска системные схемы, такие как
pg_catalog.
Примечание
Путь поиска можно изменить во время выполнения следующей командой:
SET search_path TO схема [, схема, ...]
Функция inet_client_addr возвращает IP-адрес текущего клиента, inet_client_port — номер
его порта, inet_server_addr — IP-адрес сервера, по которому он принял подключение клиента,
а inet_server_port — соответствующий номер порта. Все эти функции возвращают NULL, если
текущее соединение устанавливается через Unix-сокет.
Функция pg_blocking_pids возвращает массив идентификаторов процессов сеансов, которые бло-
кирует серверный процесс с указанным идентификатором, либо пустой массив, если такой сер-
верный процесс не найден или не заблокирован. Один серверный процесс блокирует другой, если
он либо удерживает блокировку, конфликтующую с блокировкой, запрашиваемой серверным про-
цессом (жёсткая блокировка), либо ждёт блокировки, которая вызвала бы конфликт с запросом
блокировки заблокированного процесса и находится перед ней в очереди ожидания (мягкая бло-
кировка). При распараллеливании запросов эта функция всегда выдаёт видимые клиентом иден-
тификаторы процессов (то есть, результаты pg_backend_pid), даже если фактическая блокировка
удерживается или ожидается дочерним рабочим процессом. Вследствие этого, в результатах мо-
гут оказаться дублирующиеся PID. Также заметьте, что когда конфликтующую блокировку удер-
живает подготовленная транзакция, в выводе этой функции она будет представлена нулевым ID
процесса. Частые вызовы этой функции могут отразиться на производительности базы данных, так
как ей нужен монопольный доступ к общему состоянию менеджера блокировок, хоть и на корот-
кое время.
Функция pg_conf_load_time возвращает время (timestamp with time zone), когда в последний
раз сервер загружал файлы конфигурации. (Если текущий сеанс начался раньше, она возвращает
время, когда эти файлы были перезагружены для данного сеанса, так что в разных сеансах это
значение может немного различаться. В противном случае это будет время, когда файлы конфи-
гурации считал главный процесс.)
Функция pg_current_logfile возвращает в значении text путь к файлам журналов, в настоящее
время используемым сборщиком сообщений. Этот путь состоит из каталога log_directory и имени
файла журнала. Если сборщик сообщений отключён, возвращается значение NULL. Если ведутся
несколько журналов в разных форматах, при вызове функции pg_current_logfile без аргументов
возвращается путь файла, имеющего первый формат по порядку из следующего списка: stderr,
csvlog. Если файл журнала имеет какой-то иной формат, возвращается NULL. Чтобы запросить файл
в определённом формате, передайте либо csvlog, либо stderr в качестве значения необязательного
параметра типа text. Если запрошенный формат не включён в log_destination, будет возвращено
значение NULL. Функция pg_current_logfiles отражает содержимое файла current_logfiles.
pg_my_temp_schema возвращает OID временной схемы текущего сеанса или 0, если такой нет (в
рамках сеанса не создавались временные таблицы). pg_is_other_temp_schema возвращает true, ес-
307Функции и операторы
ли заданный OID относится к временной схеме другого сеанса. (Это может быть полезно, напри-
мер для исключения временных таблиц других сеансов из общего списка при просмотре таблиц
базы данных.)
Функция pg_listening_channels возвращает набор имён каналов асинхронных уведомлений, на
которые подписан текущий сеанс. Функция pg_notification_queue_usage возвращает долю от все-
го свободного пространства для уведомлений, в настоящее время занятую уведомлениями, ожи-
дающими обработки, в виде значения double в диапазоне 0..1. За дополнительными сведениями
обратитесь к LISTEN и NOTIFY.
pg_postmaster_start_time возвращает время (timestamp with time zone), когда был запущен
сервер.
Функция pg_safe_snapshot_blocking_pids возвращает массив идентификаторов процессов сеан-
сов, которые блокируют серверный процесс с указанным идентификатором (не дают получить
ему безопасный снимок), либо пустой массив, если такой серверный процесс не найден или
не заблокирован. Сеанс, выполняющий транзакцию уровня SERIALIZABLE, блокирует транзакцию
SERIALIZABLE READ ONLY DEFERRABLE, не давая ей получить снимок, пока она не определит, что
можно безопасно избежать установления предикатных блокировок. За дополнительными сведени-
ями о сериализуемых и откладываемых транзакциях обратитесь к Подразделу 13.2.3. Частые вы-
зовы этой функции могут отразиться на производительности базы данных, так как ей нужен доступ
к общему состоянию менеджера предикатных блокировок, хоть и на короткое время.
Функция version возвращает строку, описывающую версию сервера PostgreSQL. Эту информа-
цию также можно получить из переменной server_version или, в более машинно-ориентирован-
ном формате, из переменной server_version_num. При разработке программ следует использовать
server_version_num (она появилась в версии 8.2) либо PQserverVersion , а не разбирать тексто-
вую версию.
В Таблице  9.61 перечислены функции, позволяющую пользователю программно проверить свои
права доступа к объектам. Подробнее о правах можно узнать в Разделе 5.6.
Таблица 9.61. Функции для проверки прав доступа
Имя
Тип результата
Описание
has_any_column_privilege
( boolean
user, table, privilege) имеет ли пользователь ука-
занное право для какого-либо
столбца таблицы
has_any_column_privilege
table, privilege) ( boolean имеет ли текущий пользователь
указанное право для какого-ли-
бо столбца таблицы
has_column_privilege (
boolean
user,
table,
column,
privilege) имеет ли пользователь указан-
ное право для столбца
has_column_privilege (
boolean
table, column, privilege) имеет ли текущий пользователь
указанное право для столбца
has_database_privilege (
boolean
user, database, privilege) имеет ли пользователь указан-
ное право для базы данных
has_database_privilege
database, privilege) boolean имеет ли текущий пользователь
указанное право для базы дан-
ных
has_foreign_data_wrapper_
boolean
privilege ( user,
fdw,
privilege) имеет ли пользователь указан-
ное право для обёртки сторон-
них данных
(
308Функции и операторы
Имя
Тип результата
Описание
has_foreign_data_wrapper_
boolean
privilege ( fdw, privilege) имеет ли текущий пользователь
указанное право для обёртки
сторонних данных
has_function_privilege (
boolean
user, function, privilege) имеет ли пользователь указан-
ное право для функции
has_function_privilege
function, privilege) boolean имеет ли текущий пользователь
указанное право для функции
has_language_privilege (
boolean
user, language, privilege) имеет ли пользователь указан-
ное право для языка
has_language_privilege
language, privilege) boolean имеет ли текущий пользователь
указанное право для языка
has_schema_privilege (
user, schema, privilege) boolean имеет ли пользователь указан-
ное право для схемы
has_schema_privilege
schema, privilege) boolean имеет ли текущий пользователь
указанное право для схемы
has_sequence_privilege (
boolean
user, sequence, privilege) имеет ли пользователь указан-
ное право для последовательно-
сти
has_sequence_privilege
sequence, privilege) boolean имеет ли текущий пользователь
указанное право для последова-
тельности
has_server_privilege (
user, server, privilege) boolean имеет ли пользователь указан-
ное право для стороннего серве-
ра
has_server_privilege
server, privilege) boolean имеет ли текущий пользователь
указанное право для сторонне-
го сервера
has_table_privilege ( user, boolean
table, privilege) имеет ли пользователь указан-
ное право для таблицы
has_table_privilege
table, privilege) boolean имеет ли текущий пользователь
указанное право для таблицы
has_tablespace_privilege ( boolean
user,
tablespace,
privilege) имеет ли пользователь указан-
ное право для табличного про-
странства
has_tablespace_privilege
tablespace, privilege)
(
(
(
(
(
(
( boolean имеет ли текущий пользователь
указанное право для таблично-
го пространства
has_type_privilege ( user,
type, privilege) boolean имеет ли пользователь указан-
ное право для типа
has_type_privilege
privilege) boolean имеет ли текущий пользователь
указанное право для типа
pg_has_role ( user,
privilege) role, boolean имеет ли пользователь указан-
ное право для роли
pg_has_role ( role,
privilege) boolean имеет ли текущий пользователь
указанное право для роли
boolean включена ли для текущего
пользователя защита на уровне
строк для таблицы
row_security_active
table)
( type,
(
309Функции и операторы
has_table_privilege проверяет, может ли пользователь выполнять с таблицей заданные действия.
В качестве идентификатора пользователя можно задать его имя, OID (pg_authid.oid) или public
(это будет указывать на псевдороль PUBLIC). Если этот аргумент опущен, подразумевается теку-
щий пользователь (current_user). Таблицу можно указать по имени или по OID. (Таким образом,
фактически есть шесть вариантов функции has_table_privilege, различающихся по числу и типу
аргументов.) Когда указывается имя объекта, его можно дополнить именем схемы, если это необ-
ходимо. Интересующее право доступа записывается в виде текста и может быть одним из следую-
щих: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES и TRIGGER. Дополнительно к названию
права можно добавить WITH GRANT OPTION и проверить, разрешено ли пользователю передавать это
право другим. Кроме того, в одном параметре можно перечислить несколько названий прав через
запятую, и тогда функция возвратит true, если пользователь имеет одно из этих прав. (Регистр в
названии прав не имеет значения, а между ними (но не внутри) разрешены пробельные символы.)
Пара примеров:
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable',
'INSERT, SELECT WITH GRANT OPTION');
has_sequence_privilege проверяет, может ли пользователь выполнять заданные действия с по-
следовательностью. В определении аргументов эта функция аналогична has_table_privilege. До-
пустимые для неё права складываются из USAGE, SELECT и UPDATE.
has_any_column_privilege проверяет, может ли пользователь выполнять заданные дей-
ствия с каким-либо столбцом таблицы. В определении аргументов эта функция аналогич-
на has_table_privilege, а допустимые права складываются из SELECT, INSERT, UPDATE и
REFERENCES. Заметьте, что любое из этих прав, назначенное на уровне таблицы, автоматиче-
ски распространяется на все её столбцы, так что has_any_column_privilege всегда возвра-
щает true, если has_table_privilege даёт положительный ответ для тех же аргументов. Но
has_any_column_privilege возвращает true ещё и тогда, когда право назначено только для неко-
торых столбцов.
has_column_privilege проверяет, может ли пользователь выполнять заданные действия со столб-
цом таблицы. В определении аргументов эта функция аналогична has_table_privilege, с неболь-
шим дополнением: столбец можно задать по имени или номеру атрибута. Для неё допустимые
права складываются из SELECT, INSERT, UPDATE и REFERENCES. Заметьте, что любое из этих прав,
назначенное на уровне таблицы, автоматически распространяется на все столбцы таблицы.
has_database_privilege проверяет, может ли пользователь выполнять заданные действия с базой
данных. В определении аргументов эта функция аналогична has_table_privilege. Для неё допу-
стимые права складываются из CREATE, CONNECT и TEMPORARY (или TEMP, что равносильно TEMPORARY).
has_function_privilege проверяет, может ли пользователь обратиться к заданной функции. В
определении аргументов эта функция аналогична has_table_privilege. Когда функция определя-
ется не своим OID, а текстовой строкой, эта строка должна быть допустимой для вводимого зна-
чения типа regprocedure (см. Раздел 8.19). Для этой функции допустимо только право EXECUTE.
Например:
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
has_foreign_data_wrapper_privilege проверяет, может ли пользователь обращаться к обёртке
сторонних данных. В определении аргументов она аналогична has_table_privilege. Для неё до-
пустимо только право USAGE.
has_language_privilege проверяет, может ли пользователь обращаться к процедурному языку. В
определении аргументов эта функция аналогична has_table_privilege. Для неё допустимо только
право USAGE.
has_schema_privilege проверяет, может ли пользователь выполнять заданные действия со схемой.
В определении аргументов эта функция аналогична has_table_privilege. Для неё допустимые
права складываются из CREATE и USAGE.
310Функции и операторы
has_server_privilege проверяет, может ли пользователь обращаться к стороннему серверу. В
определении аргументов она аналогична has_table_privilege. Для неё допустимо только право
USAGE.
has_tablespace_privilege проверяет, может ли пользователь выполнять заданное действие в таб-
личном пространстве. В определении аргументов эта функция аналогична has_table_privilege.
Для неё допустимо только право CREATE.
has_type_privilege проверяет, может ли пользователь обратиться к типу определённым образом.
Возможные аргументы аналогичны has_table_privilege. При указании типа текстовой строкой, а
не по OID, допускаются те же входные значения, что и для типа данных regtype (см. Раздел 8.19).
Для неё допустимо только право USAGE.
pg_has_role проверяет, может ли пользователь выполнять заданные действия с ролью. В опреде-
лении аргументов эта функция аналогична has_table_privilege, за исключением того, что име-
нем пользователя не может быть public. Для неё допустимые права складываются из MEMBER и
USAGE. MEMBER обозначает прямое или косвенное членство в данной роли (то есть наличие права
выполнить команду SET ROLE), тогда как USAGE показывает, что пользователь получает все права
роли сразу, без SET ROLE.
row_security_active проверяет, включена ли защита на уровне строк для указанной таблицы в
контексте и окружении текущего пользователя (current_user). Таблицу можно задать по имени
или OID.
В Таблице 9.62 перечислены функции, определяющие видимость объекта с текущим путём поиска
схем. К примеру, таблица считается видимой, если содержащая её схема включена в путь поиска
и нет другой таблицы с тем же именем, которая была бы найдена по пути поиска раньше. Другими
словами, к этой таблице можно будет обратиться просто по её имени, без явного указания схемы.
Просмотреть список всех видимых таблиц можно так:
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
Таблица 9.62. Функции для определения видимости
Имя Тип результата Описание
pg_collation_is_visible(
collation_oid ) boolean видимо ли правило сортировки
pg_conversion_is_visible(
conversion_oid ) boolean видимо ли преобразование
pg_function_is_visible(
function_oid ) boolean видима ли функция
pg_opclass_is_visible(
opclass_oid ) boolean видим ли класс операторов
pg_operator_is_visible(
operator_oid ) boolean видим ли оператор
pg_opfamily_is_visible(
opclass_oid ) boolean видимо ли семейство операто-
ров
pg_statistics_obj_is_
visible( stat_oid ) boolean видим ли объект статистики в
пути поиска
pg_table_is_visible(
table_oid ) boolean видима ли таблица
pg_ts_config_is_visible(
config_oid ) boolean видима ли конфигурация тек-
стового поиска
pg_ts_dict_is_visible(
dict_oid ) boolean видим ли словарь текстового по-
иска
311Функции и операторы
Имя Тип результата Описание
pg_ts_parser_is_visible(
parser_oid ) boolean видим ли анализатор текстово-
го поиска
pg_ts_template_is_
visible( template_oid ) boolean видим ли шаблон текстового по-
иска
pg_type_is_visible(
oid )
видим ли тип (или домен)
type_ boolean
Каждая из этих функций проверяет видимость объектов определённого типа. Заметьте, что
pg_table_is_visible можно также использовать для представлений, материализованных пред-
ставлений, индексов, последовательностей и сторонних таблиц; pg_function_is_visible — для
процедур и агрегатных функций; pg_type_is_visible — для доменов. Для функций и операторов
объект считается видимым в пути поиска, если при просмотре пути не находится предшествующий
ему другой объект с тем же именем и типами аргументов. Для классов операторов во внимание
принимается и имя оператора, и связанный с ним метод доступа к индексу.
Всем этим функциям должен передаваться OID проверяемого объекта. Если вы хотите проверить
объект по имени, удобнее использовать типы-псевдонимы OID (regclass, regtype, regprocedure,
regoperator, regconfig или regdictionary), например:
SELECT pg_type_is_visible('myschema.widget'::regtype);
Заметьте, что проверять таким способом имена без указания схемы не имеет большого смысла —
если имя удастся распознать, значит и объект будет видимым.
В Таблице 9.63 перечислены функции, извлекающие информацию из системных каталогов.
Таблица 9.63. Функции для обращения к системным каталогам
Имя
Тип результата Описание
text получает имя типа данных в
формате SQL
text получает определение ограни-
чения
pg_get_constraintdef(
text
constraint_oid ,
pretty_
bool ) получает определение ограни-
чения
pg_get_expr(
pg_node_
tree , relation_oid ) text декомпилирует
внутреннюю
форму выражения, в предполо-
жении, что все переменные в
нём ссылаются на таблицу или
отношение, указанное вторым
параметром
pg_get_expr(
pg_node_
text
tree ,
relation_oid ,
pretty_bool ) декомпилирует
внутреннюю
форму выражения, в предполо-
жении, что все переменные в
нём ссылаются на таблицу или
отношение, указанное вторым
параметром
pg_get_functiondef(
oid ) text получает определение функции
или процедуры
text получает список аргументов из
определения функции или про-
цедуры (со значениями по умол-
чанию)
format_type(
typemod)
type_oid ,
pg_get_constraintdef(
constraint_oid )
pg_get_function_
arguments( func_oid )
func_
312Функции и операторы
Имя Тип результата Описание
pg_get_function_identity_
arguments( func_oid ) text получает список аргументов,
идентифицирующий функцию
или процедуру (без значений по
умолчанию)
pg_get_function_result(
func_oid ) text получает предложение RETURNS
для функции (для процедуры
возвращает NULL)
pg_get_indexdef(
oid ) text получает команду CREATE INDEX
для индекса
pg_get_indexdef(
index_
text
oid ,
column_no ,
pretty_
bool ) получает команду CREATE INDEX
для индекса или определе-
ние одного индексированного
столбца, когда column_no не
равен 0
pg_get_keywords() получает список ключевых слов
SQL по категориям
index_
setof record
pg_get_ruledef( rule_oid ) text получает команду CREATE RULE
для правила
pg_get_ruledef(
pretty_bool ) rule_oid , text получает команду CREATE RULE
для правила
pg_get_serial_sequence(
text
table_name , column_name ) получает имя последователь-
ности, используемой столбцом
идентификации или столбцом
serial
pg_get_statisticsobjdef(
statobj_oid ) text получает
команду
CREATE
STATISTICS для объекта расши-
ренной статистики
(trigger_ text получает
команду
CREATE
[ CONSTRAINT ] TRIGGER для
триггера
pg_get_triggerdef (trigger_ text
oid , pretty_bool ) получает
команду
CREATE
[ CONSTRAINT ] TRIGGER для
триггера
pg_get_userbyid(
oid ) name получает имя роли по заданно-
му OID
view_ text получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление (устаревшая функция)
pg_get_viewdef(
view_
name , pretty_bool ) text получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление (устаревшая функция)
pg_get_viewdef( view_oid ) text получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление
pg_get_viewdef(
pretty_bool ) view_oid , text получает команду SELECT, опре-
деляющую представление или
pg_get_triggerdef
oid )
pg_get_viewdef(
name )
role_
313Функции и операторы
Имя
Тип результата
Описание
материализованное
ление
представ-
pg_get_viewdef(
view_oid , text
wrap_column_int ) получает команду SELECT, опре-
деляющую представление или
материализованное представ-
ление; при необходимости раз-
бивает строки с полями, вы-
ходящие за wrap_int симво-
лов, подразумевая форматиро-
ванный вывод
pg_index_column_has_
property( index_oid ,
column_no , prop_name ) boolean проверяет, имеет ли столбец ин-
декса заданное свойство
pg_index_has_property(
index_oid , prop_name ) boolean проверяет, имеет ли индекс за-
данное свойство
pg_indexam_has_property(
am_oid , prop_name ) boolean проверяет, имеет ли метод до-
ступа индекса заданное свой-
ство
pg_options_to_table(
reloptions) setof record получает набор параметров хра-
нилища в виде имя/значение
pg_tablespace_databases(
tablespace_oid ) setof oid получает или устанавливает
OID баз данных, объекты кото-
рых содержатся в заданном таб-
личном пространстве
pg_tablespace_location(
tablespace_oid ) text получает путь в файловой си-
стеме к местоположению задан-
ного табличного пространства
pg_typeof( regtype получает тип данных любого
значения
collation for ( any) text получает правило сортировки
для аргумента
to_regclass( rel_name ) regclass получает OID указанного отно-
шения
to_regproc( func_name ) regproc получает OID указанной функ-
ции
regprocedure получает OID указанной функ-
ции
any)
to_regprocedure(
name )
to_regoper(
имя_
type_name )
to_regnamespace(
name )
to_regrole(
получает OID указанного опера-
тора
имя_оператора ) regoper
to_regoperator(
оператора)
to_regtype(
func_
schema_
role_name )
regoperator получает OID указанного опера-
тора
regtype получает OID указанного типа
regnamespace получает OID указанной схемы
regrole получает OID указанной роли
format_type возвращает в формате SQL имя типа данных, определяемого по OID и, возможно,
модификатору типа. Если модификатор неизвестен, вместо него можно передать NULL.
314Функции и операторы
pg_get_keywords возвращает таблицу с ключевыми словами SQL, которые воспринимает сервер.
Столбец word содержит ключевое слово, а catcode — код категории: U — не зарезервировано, C
— имя столбца, T — имя типа или функции, R — зарезервировано. Столбец catdesc содержит воз-
можно локализованное описание категории.
pg_get_constraintdef,
pg_get_indexdef,
pg_get_ruledef,
pg_get_statisticsobjdef
и
pg_get_triggerdef восстанавливают команду, создававшую заданное ограничение, индекс, пра-
вило, объект статистики или триггер, соответственно. (Учтите, что они возвращают не изначаль-
ный текст команды, а результат декомпиляции.) pg_get_expr декомпилирует внутреннюю форму
отдельного выражения, например значения по умолчанию для столбца. Это может быть полез-
но для изучения содержимого системных каталогов. Если выражение может содержать перемен-
ные, укажите во втором параметре OID отношения, на который они ссылаются; если таких пере-
менных нет, вместо OID можно передать 0. pg_get_viewdef восстанавливает запрос SELECT, опре-
деляющий представление. Многие из этих функций имеют две версии, одна из которых позволя-
ет получить форматированный вывод (с параметром pretty_bool). Форматированный текст легче
читается, но нет гарантии, что он будет всегда восприниматься одинаково будущими версиями
PostgreSQL; поэтому не следует применять форматирование при выгрузке метаданных. Если в па-
раметре pretty_bool передаётся false, эта версия функции выдаёт тот же результат, что и версия
без параметров.
pg_get_functiondef возвращает полный оператор CREATE OR REPLACE FUNCTION для заданной функ-
ции. pg_get_function_arguments возвращает список аргументов функции, в виде достаточном для
включения в команду CREATE FUNCTION. pg_get_function_result в дополнение возвращает готовое
предложение RETURNS для функции. pg_get_function_identity_arguments возвращает список ар-
гументов, достаточный для однозначной идентификации функции, в форме, допустимой, например
для команды ALTER FUNCTION. Значения по умолчанию в этой форме опускаются.
pg_get_serial_sequence возвращает имя последовательности, связанной со столбцом, либо NULL,
если такой последовательности нет. Для столбца идентификации это будет последовательность,
связанная с ним внутренним образом. Для столбцов, имеющих один из последовательных типов
(serial, smallserial, bigserial), это последовательность, созданная объявлением данного столб-
ца. В последнем случае эту связь можно изменить или разорвать, воспользовавшись командой
ALTER SEQUENCE OWNED BY. (Возможно, эту функцию стоило назвать pg_get_owned_sequence; её
существующее имя отражает тот факт, что она обычно используется со столбцами serial или
bigserial.) В первом параметре функции указывается имя таблицы, возможно дополненное схе-
мой, а во втором имя столбца. Так как первый параметр может содержать имя схемы и таблицы,
он воспринимается не как идентификатор в кавычках и поэтому по умолчанию приводится к ниж-
нему регистру, тогда как имя столбца во втором параметре воспринимается как заключённое в
кавычки и в нём регистр символов сохраняется. Эта функция возвращает имя в виде, пригодном
для передачи функциям, работающим с последовательностями (см. Раздел 9.16). Обычно она при-
меняется для получения текущего значения последовательности для столбца идентификации или
последовательного столбца, например:
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
pg_get_userbyid получает имя роли по её OID.
Функции pg_index_column_has_property, pg_index_has_property и pg_indexam_has_property по-
казывают, обладает ли указанный столбец индекса, индекс или метод доступа индекса заданным
свойством. Они возвращают NULL, если имя свойства неизвестно или неприменимо к конкретному
объекту, либо если OID или номер столбца не указывают на действительный объект. Описание
свойств столбцов вы можете найти в Таблице 9.64, свойства индексов описаны в Таблице 9.65, а
свойства методов доступа — в Таблица 9.66. (Заметьте, что методы доступа, реализуемые расши-
рениями, могут определять для своих индексов дополнительные имена свойств.)
Таблица 9.64. Свойства столбца индекса
Имя Описание
asc Сортируется ли столбец по возрастанию при
сканировании вперёд?
315Функции и операторы
Имя Описание
desc Сортируется ли столбец по убыванию при скани-
ровании вперёд?
nulls_first Выдаются ли NULL в начале при сканирования
вперёд?
nulls_last Выдаются ли NULL в конце при сканировании
вперёд?
orderable Связан ли со столбцом некоторый порядок сор-
тировки?
distance_orderable Может ли столбец сканироваться по порядку
оператором «расстояния», например, ORDER BY
столбец &amp;lt;-&amp;gt; константа ?
returnable Может ли значение столбца быть получено при
сканировании только индекса?
search_array Поддерживает ли столбец внутренними сред-
ствами поиск столбец = ANY(массив) ?
search_nulls Поддерживает ли столбец поиск IS NULL и IS
NOT NULL?
Таблица 9.65. Свойства индекса
Имя Описание
clusterable Может ли индекс использоваться в команде
CLUSTER?
index_scan Поддерживает ли индекс простое сканирование
(не по битовой карте)?
bitmap_scan Поддерживает ли индекс сканирование по бито-
вой карте?
backward_scan Может ли в процессе сканирования меняться на-
правление (для поддержки перемещения курсо-
ра FETCH BACKWARD без необходимости материа-
лизации)?
Таблица 9.66. Свойства метода доступа индекса
Имя Описание
can_order Поддерживает ли метод доступа ASC, DESC и свя-
занные ключевые слова в CREATE INDEX?
can_unique Поддерживает ли метод доступа уникальные ин-
дексы?
can_multi_col Поддерживает ли метод доступа индексы по
нескольким столбцам?
can_exclude Поддерживает ли
ния-исключения?
can_include Поддерживает ли метод доступа предложение
INCLUDE команды CREATE INDEX?
метод
доступа
ограниче-
pg_options_to_table возвращает набор параметров хранилища в виде пар (имя_параметра/значе-
ние_параметра), когда ей передаётся pg_class.reloptions или pg_attribute.attoptions.
pg_tablespace_databases позволяет изучить содержимое табличного пространства. Она возвра-
щает набор OID баз данных, объекты которых размещены в этом табличном пространстве. Если
316Функции и операторы
эта функция возвращает строки, это означает, что табличное пространство не пустое и удалить
его нельзя. Какие именно объекты находятся в табличном пространстве, можно узнать, подклю-
чаясь к базам данных, OID которых сообщила pg_tablespace_databases, и анализируя их каталоги
pg_class.
pg_typeof возвращает OID типа данных для переданного значения. Это может быть полезно для
разрешения проблем или динамического создания SQL-запросов. Эта функция объявлена как воз-
вращающая тип regtype, который является псевдонимом типа OID (см. Раздел 8.19); это означает,
что значение этого типа можно сравнивать как OID, но выводится оно как название типа. Напри-
мер:
SELECT pg_typeof(33);
pg_typeof
-----------
integer
(1 row)
SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
typlen
--------
4
(1 row)
Выражение collation for возвращает правило сортировки для переданного значения. Например:
SELECT collation for (description) FROM pg_description LIMIT 1;
pg_collation_for
------------------
&quot;default&quot;
(1 row)
SELECT collation for ('foo' COLLATE &quot;de_DE&quot;);
pg_collation_for
------------------
&quot;de_DE&quot;
(1 row)
Это значение может быть заключено в кавычки и дополнено схемой. Если для выражения аргу-
мента нет правила сортировки, возвращается значение NULL. Если же правила сортировки не
применимы для типа аргумента, происходит ошибка.
Функции to_regclass, to_regproc, to_regprocedure, to_regoper, to_regoperator, to_regtype,
to_regnamespace и to_regrole преобразуют имена отношений, функций, операторов, типов, схем
и ролей (заданных значением text) в объекты типа regclass, regproc, regprocedure, regoper,
regoperator, regtype, regnamespace и regrole, соответственно. Перечисленные функции отлича-
ются от явных приведений к этим типам тем, что они не принимают числовые OID и возвращают
NULL вместо ошибки, если имя не найдено (или, в случае с to_regproc и to_regoper, если данному
имени соответствуют несколько объектов).
В Таблице 9.67 перечислены функции, связанные с идентификацией и адресацией объектов баз
данных.
Таблица 9.67. Функции получения информации и адресации объектов
Имя
pg_describe_object(
classid oid,
objid
objsubid integer)
Тип результата Описание
text получает описание объекта ба-
зы данных
oid,
317Функции и операторы
Имя
Тип результата
pg_identify_object(
classid oid,
objid
objsubid integer)
Описание
type text, schema text, name получает идентификатор объек-
та базы данных
oid, text, identity text
pg_identify_object_as_
type
text,
object_names
address( classid oid, objid text[], object_args text[]
oid, objsubid integer)
pg_get_object_address(
classid
oid,
objid
type text,
object_names objsubid integer
text[], object_args text[])
получает внешнее представле-
ние адреса объекта базы данных
oid, получает адрес объекта базы
данных из его внешнего пред-
ставления
pg_describe_object возвращает текстовое описание объекта БД, идентифицируемого по OID ка-
талога, OID объекта и ID подобъекта (например, номер столбца в таблице; ID подобъекта равен
нулю для объекта в целом). Это описание предназначено для человека и может переводиться, в
зависимости от конфигурации сервера. С помощью этой функции, например, можно узнать, что за
объект хранится в каталоге pg_depend.
pg_identify_object возвращает запись, содержащую достаточно информации для однозначной
идентификации объекта БД по OID каталога, OID объекта и ID подобъекта. Эта информация пред-
назначена для машины и поэтому никогда не переводится. Столбец type содержит тип объекта
БД; schema — имя схемы, к которой относится объект (либо NULL для объектов, не относящихся к
схемам); name — имя объекта, при необходимости в кавычках, которое присутствует, только если
оно (возможно, вместе со схемой) однозначно идентифицирует объект (в противном случае NULL);
identity — полный идентификатор объекта, точный формат которого зависит от типа объекта, а
каждая его часть дополняется схемой и заключается в кавычки, если требуется.
pg_identify_object_as_address возвращает запись, содержащую достаточно информации для од-
нозначной идентификации объекта БД по OID каталога, OID объекта и ID подобъекта. Выдаваемая
информация не зависит от текущего сервера, то есть по ней можно идентифицировать одноимён-
ный объект на другом сервере. Поле type содержит тип объекта БД, а object_names и object_args
— текстовые массивы, в совокупности формирующие ссылку на объект. Эти три значения мож-
но передать функции pg_get_object_address, чтобы получить внутренний адрес объекта. Данная
функция является обратной к pg_get_object_address.
pg_get_object_address возвращает запись, содержащую достаточно информации для уникальной
идентификации объекта БД по его типу и массивам имён и аргументов. В ней возвращаются зна-
чения, которые используются в системных каталогах, например pg_depend, и могут передаваться в
другие системные функции, например pg_identify_object или pg_describe_object. Поле classid
содержит OID системного каталога, к которому относится объект; objid — OID самого объекта,
а objsubid — идентификатор подобъекта или 0 в случае его отсутствия. Эта функция является
обратной к pg_identify_object_as_address.
Функции, перечисленные в Таблице 9.68, извлекают комментарии, заданные для объектов с по-
мощью команды COMMENT. Если найти комментарий для заданных параметров не удаётся, они
возвращают NULL.
Таблица 9.68. Функции получения комментариев
Имя Тип результата Описание
col_description( table_
oid , column_number ) text получает
комментарий
столбца таблицы
obj_description( object_
oid , catalog_name ) text получает комментарий для объ-
екта базы данных
obj_description(
oid ) text получает комментарий для объ-
екта базы данных (устаревшая
форма)
object_
318
дляФункции и операторы
Имя Тип результата Описание
shobj_description( object_
oid , catalog_name ) text получает комментарий для раз-
деляемого объекта баз данных
col_description возвращает комментарий для столбца с заданным номером в таблице с указан-
ным OID. (obj_description нельзя использовать для столбцов таблицы, так столбцы не имеют соб-
ственных OID.)
Функция obj_description с двумя параметрами возвращает комментарий для объекта,
имеющего заданный OID и находящегося в указанном системном каталоге. Например,
obj_description(123456,'pg_class') вернёт комментарий для таблицы с OID 123456. Форма
obj_description с одним параметром принимает только OID. Она является устаревшей, так как
значения OID могут повторяться в разных системных каталогах, и поэтому она может возвращать
комментарий для другого объекта.
shobj_description работает подобно obj_description, но она получает комментарии для разде-
ляемых объектов. Некоторые системные каталоги являются глобальными для всех баз данных в
кластере и описания объектов в них также хранятся глобально.
Функции, перечисленные в Таблице 9.69, выдают информацию о транзакциях сервера в форме во
внешнем представлении. В основном эти функции используются, чтобы определить, какие тран-
закции были зафиксированы между двумя снимками состояния.
Таблица 9.69. Идентификаторы транзакций и снимков состояния
Имя Тип результата Описание
txid_current() bigint получает идентификатор теку-
щей транзакции и присваивает
новый, если текущая транзак-
ция его не имеет
txid_current_if_assigned(
) bigint работает
аналогично
txid_
current() , но возвращает
NULL, не присваивая новый
идентификатор транзакции, ес-
ли он ещё не присвоен
txid_current_snapshot() txid_snapshot получает код текущего снимка
txid_snapshot_xip(
snapshot ) setof bigint возвращает
идентификаторы
выполняющихся транзакций в
снимке
txid_
txid_snapshot_xmax(
snapshot ) txid_ bigint возвращает значение xmax для
заданного снимка
txid_snapshot_xmin(
snapshot ) txid_ bigint возвращает значение xmin для
заданного снимка
txid_visible_in_snapshot(
bigint, txid_snapshot ) boolean видима ли транзакция с указан-
ным идентификатором в данном
снимке? (коды подтранзакций
не поддерживаются)
txid_status( text возвращает состояние заданной
транзакции — committed (за-
фиксирована), aborted (прерва-
на), in progress (выполняется)
или NULL, если идентификатор
транзакции слишком старый
bigint)
Внутренний тип идентификаторов транзакций (xid) имеет размер 32 бита, поэтому они повторя-
ются через 4 миллиарда транзакций. Однако эти функции выдают 64-битные значения, дополнен-
319Функции и операторы
ные счётчиком «эпохи», так что эти значения останутся уникальными на протяжении всей жиз-
ни сервера. Используемый этими функциями тип данных txid_snapshot сохраняет информацию о
видимости транзакций в определённый момент времени. Его состав описан в Таблице 9.70.
Таблица 9.70. Состав информации о снимке
Имя Описание
xmin Идентификатор самой ранней транзакции (txid)
из активных. Все предыдущие транзакции ли-
бо зафиксированы и видимы, либо отменены и
мертвы.
xmax Первый txid из ещё не назначенных. На момент
снимка не было запущенных (а значит и види-
мых) транзакций с идентификатором, большим
или равным данному.
xip_list Список идентификаторов транзакций, активных
в момент снимка. Он включает только идентифи-
каторы с номерами от xmin до xmax; хотя уже мо-
гут быть транзакции с идентификаторами боль-
ше xmax. Если в этом списке не оказывается
идентификатора транзакции xmin &amp;lt;= txid &amp;lt;
xmax, это означает, что она уже не выполня-
лась к моменту снимка и, таким образом, видима
или мертва, в зависимости от типа завершения.
Идентификаторы подтранзакций в этот список
не включаются.
В текстовом виде txid_snapshot представляется как xmin:xmax:xip_list.
10:20:10,14,15 означает xmin=10, xmax=20, xip_list=10, 14, 15.
Например,
Функция txid_status(bigint) выдаёт состояние фиксации последней транзакции. Проверяя его,
приложения могут определить, была ли транзакция зафиксирована или прервана, когда приложе-
ние отключается от сервера баз данных в процессе выполнения COMMIT. Состояние транзакции мо-
жет быть следующим: in progress (выполняется), committed (зафиксирована) и aborted (прерва-
на), если только транзакция не настолько стара, чтобы система удалила информация о её состоя-
нии фиксирования. Если же она так стара, что упоминаний о ней в системе не осталось и информа-
ция о фиксации потеряна, эта функция возвращает NULL. Заметьте, что для подготовленных тран-
закций возвращается состояние in progress; приложения должны проверять pg_prepared_xacts,
если им нужно определить, является ли транзакция «txid» подготовленной.
Функции, показанные в Таблице  9.71, выдают информацию об уже зафиксированных тран-
закциях. Они возвращают полезные данные, только когда включён параметр конфигурации
track_commit_timestamp и только для транзакций, зафиксированных после его включения.
Таблица 9.71. Информация о фиксации транзакций
Имя Тип результата
Описание
pg_xact_commit_timestamp(
xid) timestamp with time zone
выдаёт время фиксации тран-
закции
pg_last_committed_xact() xid xid, timestamp timestamp выдаёт идентификатор и время
фиксации транзакции, зафикси-
with time zone
рованной последней
Функции, перечисленные в Таблице 9.72, выводят свойства, установленные командой initdb, на-
пример, версию каталога. Они также выводят сведения о работе журнала предзаписи и контроль-
ных точках. Эта информация относится ко всему кластеру, а не к отдельной базе данных. Данные
функции выдают практически всю ту же информацию, и из того же источника, что и pg_controldata,
но в форме, более подходящей для функций SQL.
320Функции и операторы
Таблица 9.72. Функции управления данными
Имя Тип результата Описание
pg_control_checkpoint() record Возвращает информацию о со-
стоянии текущей контрольной
точки.
pg_control_system() record Возвращает информацию о те-
кущем состоянии управляюще-
го файла.
pg_control_init() record Возвращает информацию о со-
стоянии инициализации класте-
ра.
pg_control_recovery() record Возвращает информацию о со-
стоянии восстановления.
Функция pg_control_checkpoint возвращает запись, показанную в Таблице 9.73.
Таблица 9.73. Столбцы результата pg_control_checkpoint
Имя столбца Тип данных
checkpoint_lsn pg_lsn
redo_lsn pg_lsn
redo_wal_file text
timeline_id integer
prev_timeline_id integer
full_page_writes boolean
next_xid text
next_oid oid
next_multixact_id xid
next_multi_offset xid
oldest_xid xid
oldest_xid_dbid oid
oldest_active_xid xid
oldest_multi_xid xid
oldest_multi_dbid oid
oldest_commit_ts_xid xid
newest_commit_ts_xid xid
checkpoint_time timestamp with time zone
Функция pg_control_system возвращает запись, показанную в Таблице 9.74.
Таблица 9.74. Столбцы результата pg_control_system
Имя столбца Тип данных
pg_control_version integer
catalog_version_no integer
system_identifier bigint
pg_control_last_modified timestamp with time zone
321Функции и операторы
Функция pg_control_init возвращает запись, показанную в Таблице 9.75.
Таблица 9.75. Столбцы результата pg_control_init
Имя столбца Тип данных
max_data_alignment integer
database_block_size integer
blocks_per_segment integer
wal_block_size integer
bytes_per_wal_segment integer
max_identifier_length integer
max_index_columns integer
max_toast_chunk_size integer
large_object_chunk_size integer
float4_pass_by_value boolean
float8_pass_by_value boolean
data_page_checksum_version integer
Функция pg_control_recovery возвращает запись, показанную в Таблице 9.76
Таблица 9.76. Столбцы результата pg_control_recovery
Имя столбца Тип данных
min_recovery_end_lsn pg_lsn
min_recovery_end_timeline integer
backup_start_lsn pg_lsn
backup_end_lsn pg_lsn
end_of_backup_record_required boolean
9.26. Функции для системного администрирования
Функции, описанные в этом разделе, предназначены для контроля и управления сервером
PostgreSQL.
9.26.1. Функции для управления конфигурацией
В Таблице 9.77 показаны функции, позволяющие получить и изменить значения параметров кон-
фигурации выполнения.
Таблица 9.77. Функции для управления конфигурацией
Имя Тип результата Описание
current_setting( setting_
name [, missing_ok ]) text получает текущее значение па-
раметра
set_config( setting_name ,
new_value , is_local ) text устанавливает новое значение
параметра и возвращает его
Функция current_setting выдаёт текущее значение параметра setting_name. Она соответствует
стандартной SQL-команде SHOW. Пример использования:
SELECT current_setting('datestyle');
322Функции и операторы
current_setting
-----------------
ISO, MDY
(1 row)
Если параметра с именем setting_name нет, функция current_setting выдаёт ошибку, если только
дополнительно не передан параметр missing_ok со значением true.
set_config устанавливает для параметра setting_name значение new_value. Если параметр
is_local равен true, новое значение будет действовать только в рамках текущей транзакции. Что-
бы это значение действовало на протяжении текущего сеанса, ему нужно присвоить false. Эта
функция соответствует SQL-команде SET. Пример использования:
SELECT set_config('log_statement_stats', 'off', false);
set_config
------------
off
(1 row)
9.26.2. Функции для передачи сигналов серверу
Функции, перечисленные в Таблице 9.78, позволяют передавать управляющие сигналы другим сер-
верным процессам. Вызывать эти функции по умолчанию разрешено только суперпользователям,
но доступ к ним можно дать и другим пользователям командой GRANT, кроме явно отмеченных ис-
ключений.
Таблица 9.78. Функции для передачи сигналов серверу
Имя
Тип результата Описание
boolean Отменяет текущий запрос в
обслуживающем процессе. Это
действие разрешается и ролям,
являющимся членами роли, об-
служивающий процесс которой
затрагивается, и ролям, кото-
рым дано право pg_signal_
backend ; однако только супер-
пользователям разрешено воз-
действовать на обслуживающие
процессы других суперпользо-
вателей.
pg_reload_conf() boolean Даёт команду серверным про-
цессам перегрузить конфигура-
цию
pg_rotate_logfile() boolean Прокручивает журнал сообще-
ний сервера
boolean Завершает
обслуживающий
процесс. Это действие разре-
шается и ролям, являющимся
членами роли, обслуживающий
процесс которой прерывается,
и ролям, которым дано пра-
во pg_signal_backend ; одна-
ко только суперпользователям
разрешено прерывать обслужи-
вающие процессы других супер-
пользователей.
pg_cancel_backend(
int)
pg_terminate_backend(
int)
pid
pid
323Функции и операторы
Каждая из этих функций возвращает true при успешном завершении и false в противном случае.
pg_cancel_backend и pg_terminate_backend передают сигналы (SIGINT и SIGTERM, соответствен-
но) серверному процессу с заданным кодом PID. Код активного процесса можно получить из столб-
ца pid представления pg_stat_activity или просмотрев на сервере процессы с именем postgres
(используя ps в Unix или Диспетчер задач в Windows). Роль пользователя активного процесса мож-
но узнать в столбце usename представления pg_stat_activity.
pg_reload_conf отправляет сигнал SIGHUP главному серверному процессу, который командует
всем подчинённым процессам перезагрузить файлы конфигурации.
pg_rotate_logfile указывает менеджеру журнала сообщений немедленно переключиться на но-
вый файл. Это имеет смысл, только когда работает встроенный сборщик сообщений, так как без
него подпроцесс менеджера журнала не запускается.
9.26.3. Функции управления резервным копированием
Функции, перечисленные в Таблице  9.79, предназначены для выполнения резервного копиро-
вания «на ходу». Эти функции нельзя выполнять во время восстановления (за исключением
pg_is_in_backup, pg_backup_start_time и pg_wal_lsn_diff).
Таблица 9.79. Функции управления резервным копированием
Имя Тип результата Описание
pg_create_restore_point(
name text) pg_lsn Создаёт именованную точку
для восстановления (по умолча-
нию разрешено только супер-
пользователям, но право на её
выполнение (EXECUTE) можно
дать и другим пользователям)
pg_current_wal_flush_
lsn() pg_lsn Получает текущую позицию
сброса данных в журнале пред-
записи
pg_current_wal_insert_
lsn() pg_lsn Получает текущую позицию до-
бавления в журнале предзаписи
pg_current_wal_lsn() pg_lsn Получает текущую позицию за-
писи в журнале предзаписи
pg_start_backup(
label
text [,
fast boolean
exclusive boolean]]) pg_lsn Подготавливает сервер к ре-
зервному
копированию
(по
умолчанию разрешено только
суперпользователям, но право
на её выполнение (EXECUTE)
можно дать и другим пользова-
телям)
pg_stop_backup() pg_lsn Завершает монопольное резерв-
ное копирование (по умолча-
нию разрешено только супер-
пользователям, но право на её
выполнение (EXECUTE) можно
дать и другим пользователям)
pg_stop_backup(
exclusive
boolean
[,
wait_for_
archive boolean]) setof record Завершает монопольное или
немонопольное резервное копи-
рование (по умолчанию разре-
шено только суперпользовате-
лям, но право на её выполнение
(EXECUTE) можно дать и дру-
гим пользователям)
[,
324Функции и операторы
Имя Тип результата Описание
pg_is_in_backup() bool Возвращает true в процессе ис-
ключительного резервного ко-
пирования
pg_backup_start_time() timestamp with time zone Получает время запуска вы-
полняющегося исключительно-
го резервного копирования
pg_switch_wal() pg_lsn Инициирует переключение на
новый файл журнала предза-
писи (по умолчанию разреше-
но только суперпользователям,
но право на её выполнение (
EXECUTE) можно дать и другим
пользователям)
pg_walfile_name(
lsn )
lsn
pg_walfile_name_offset(
lsn pg_lsn )
pg_wal_lsn_diff(
lsn
lsn , lsn pg_lsn )
Получает из позиции в журна-
ле предзаписи имя соответству-
ющего файла
pg_ text
text, integer
Получает из позиции в журна-
ле предзаписи имя соответству-
ющего файла и десятичное сме-
щение в нём
Вычисляет разницу между дву-
мя позициями в журнале пред-
записи
pg_ numeric
pg_start_backup принимает произвольную заданную пользователем метку резервной копии.
(Обычно это имя файла, в котором будет сохранена резервная копия.) При копировании в моно-
польном режиме эта функция записывает файл метки (backup_label) и, если есть ссылки в ката-
логе pg_tblspc/, файл карты табличных пространств (tablespace_map) в каталог данных кластера
БД, выполняет процедуру контрольной точки, а затем возвращает в текстовом виде начальную по-
зицию в журнале предзаписи для данной резервной копии. Результат этой функции может быть
полезен, но если он не нужен, его можно просто игнорировать. При копировании в немонопольном
режиме содержимое этих файлов выдаётся функцией pg_stop_backup и должно быть записано в
архивную копию вызывающим субъектом.
postgres=# select pg_start_backup('label_goes_here');
pg_start_backup
-----------------
0/D4445B8
(1 row)
У этой функции есть также второй, необязательный параметр типа boolean. Если он равен true,
pg_start_backup начнёт работу максимально быстро. При этом будет немедленно выполнена про-
цедура контрольной точки, что может повлечь массу операций ввода/вывода и затормозить парал-
лельные запросы.
При монопольном копировании функция pg_stop_backup удаляет файл метки (и, если существует,
файл tablespace_map), созданный функцией pg_start_backup. При немонопольном копировании
содержимое backup_label и tablespace_map возвращается в результате функции и должно быть
записано в файлы в архиве (а не в каталоге данных). Также есть необязательный второй параметр
типа boolean. Если он равен false, pg_stop_backup завершится сразу после окончания резервно-
го копирования, не дожидаясь архивации WAL. Это поведение полезно только для программ ре-
зервного копирования, которые независимо осуществляют архивацию WAL. Если же WAL не заар-
хивируется, резервная копия может оказаться неполной, а значит, бесполезной. Когда он равен
true, pg_stop_backup будет ждать выполнения архивации WAL, если архивирование включено; для
резервного сервера это означает, что ожидание возможно только при условии archive_mode =
325Функции и операторы
always. Если активность записи на ведущем сервере невысока, может иметь смысл выполнить на
нём pg_switch_wal для немедленного переключения сегмента.
При выполнении на ведущем эта функция также создаёт файл истории резервного копирования в
области архива журнала предзаписи. В этом файле для данной резервной копии сохраняется мет-
ка, заданная при вызове pg_start_backup, начальная и конечная позиция в журнале предзаписи,
а также время начала и окончания. Возвращает данная функция позицию окончания резервной
копии в журнале предзаписи (которую тоже можно игнорировать). После записи конечной пози-
ции текущая позиция автоматически перемещается к следующему файлу журнала предзаписи,
чтобы файл конечной позиции можно было немедленно архивировать для завершения резервного
копирования.
pg_switch_wal производит переключение на следующий файл журнала предзаписи, что позволяет
архивировать текущий (в предположении, что архивация выполняется непрерывно). Эта функция
возвращает конечную позицию в журнале предзаписи (в только что законченном файле журна-
ла) + 1. Если с момента последнего переключения файлов не было активности, отражающейся в
журнале предзаписи, pg_switch_wal не делает ничего и возвращает начальную позицию в файле
журнала предзаписи, используемом в данный момент.
pg_create_restore_point создаёт именованную запись в журнале предзаписи, которую можно ис-
пользовать как цель при восстановлении, и возвращает соответствующую позицию в журнале пред-
записи. Затем полученное имя можно присвоить параметру recovery_target_name, указав тем са-
мым точку, до которой будет выполняться восстановление. Учтите, что если вы создадите несколь-
ко точек восстановления с одним именем, восстановление будет остановлено на первой точке с
этим именем.
pg_current_wal_lsn выводит текущую позицию записи в журнале предзаписи в том же формате,
что и вышеописанные функции. pg_current_wal_insert_lsn подобным образом выводит текущую
позицию добавления, а pg_current_wal_flush_lsn — позицию сброса данных журнала. Позици-
ей добавления называется «логический» конец журнала предзаписи в любой момент времени, то-
гда как позиция записи указывает на конец данных, фактически вынесённых из внутренних буфе-
ров сервера, а позиция сброса показывает, до какого места данные гарантированно сохранены в
надёжном хранилище. Позиция записи отмечает конец данных, которые может видеть снаружи
внешний процесс, и именно она представляет интерес при копировании частично заполненных
файлов журнала. Позиция добавления и позиция сброса выводятся в основном для отладки сер-
верной части. Все эти операции выполняются в режиме «только чтение» и не требуют прав супер-
пользователя.
Из результатов всех описанных выше функций можно получить имя файла журнала предзаписи и
смещение в нём, используя функцию pg_walfile_name_offset. Например:
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
file_name
| file_offset
--------------------------+-------------
00000001000000000000000D |
4039624
(1 row)
Подобным образом, pg_walfile_name извлекает только имя файла журнала предзаписи. Когда за-
данная позиция в журнале предзаписи находится ровно на границе файлов, обе эти функции воз-
вращают имя предыдущего файла. Обычно это поведение предпочтительно при архивировании
журнала предзаписи, так как именно предыдущий файл является последним подлежащим архи-
вации.
pg_wal_lsn_diff вычисляет разницу в байтах между двумя позициями в журнале предзаписи. По-
лученный результат можно использовать с pg_stat_replication или другими функциями, пере-
численными в Таблице 9.79, для определения задержки репликации.
Подробнее практическое применение этих функций описывается в Разделе 25.3.
9.26.4. Функции управления восстановлением
326Функции и операторы
Функции, приведённые в Таблице  9.80, предоставляют сведения о текущем состоянии ведомого
сервера. Эти функции могут выполняться, как во время восстановления, так и в обычном режиме
работы.
Таблица 9.80. Функции для получения информации о восстановлении
Имя Тип результата Описание
pg_is_in_recovery() bool Возвращает true в процессе вос-
становления.
pg_last_wal_receive_lsn(
) pg_lsn Получает позицию последней
записи журнала предзаписи,
полученной и записанной на
диск в процессе потоковой ре-
пликации. Пока выполняется
потоковая репликация, эта по-
зиция постоянно увеличивает-
ся. По окончании восстановле-
ния она останавливается на за-
писи WAL, полученной и запи-
санной на диск последней. Если
потоковая репликация отклю-
чена или ещё не запускалась,
функция возвращает NULL.
pg_last_wal_replay_lsn(
) pg_lsn Получает позицию последней
записи журнала предзаписи,
воспроизведённой при восста-
новлении. В процессе восста-
новления эта позиция постоян-
но увеличивается. По оконча-
нии восстановления она оста-
навливается на записи WAL, ко-
торая была восстановлена по-
следней. Если сервер был за-
пущен не в режиме восстанов-
ления, эта функция возвращает
NULL.
pg_last_xact_replay_
timestamp() timestamp with time zone Получает отметку времени по-
следней транзакции, воспроиз-
ведённой при восстановлении.
Это время, когда на главном
сервере произошла фиксация
или откат записи WAL для этой
транзакции. Если в процессе
восстановления не была воспро-
изведена ни одна транзакция,
эта функция возвращает NULL.
В противном случае это зна-
чение постоянно увеличивает-
ся в процессе восстановления.
По окончании восстановления
оно останавливается на тран-
закции, которая была восста-
новлена последней. Если сер-
вер был запущен не в режи-
ме восстановления, эта функ-
ция возвращает NULL.
327Функции и операторы
Функции, перечисленные в Таблице 9.81 управляют процессом восстановления. Вызывать их в дру-
гое время нельзя.
Таблица 9.81. Функции управления восстановлением
Имя Тип результата Описание
pg_is_wal_replay_paused(
) bool Возвращает true, если восста-
новление приостановлено.
pg_wal_replay_pause() void Немедленно приостанавливает
восстановление (по умолчанию
разрешено только суперпользо-
вателям, но право на её выпол-
нение (EXECUTE) можно дать и
другим пользователям).
pg_wal_replay_resume() void Перезапускает восстановление,
если оно было приостановлено (
по умолчанию разрешено толь-
ко суперпользователям, но пра-
во на её выполнение (EXECUTE)
можно дать и другим пользова-
телям).
Когда восстановление приостановлено, запись изменений в базу не производится. Если она нахо-
дится в «горячем резерве», все последующие запросы будут видеть один согласованный снимок
базы данных и до продолжения восстановления конфликты запросов исключаются.
Когда потоковая репликация выключена, пауза при восстановлении может длиться сколь угодно
долго без каких-либо проблем. Если же запущена потоковая репликация, новые записи WAL про-
должат поступать и заполнят весь диск рано или поздно, в зависимости от длительности паузы,
интенсивности записи в WAL и объёма свободного пространства.
9.26.5. Функции синхронизации снимков
PostgreSQL позволяет синхронизировать снимки состояния между сеансами баз данных. Снимок
состояния определяет, какие данные видны транзакции, работающей с этим снимком. Синхрони-
зация снимков необходима, когда в двух или более сеансах нужно видеть одно и то же содержимое
базы данных. Если в двух сеансах транзакции запускаются независимо, всегда есть вероятность,
что некая третья транзакция будет зафиксирована между командами START TRANSACTION для пер-
вых двух, и в результате в одном сеансе будет виден результат третьей, а в другом — нет.
Для решения этой проблемы PostgreSQL позволяет транзакции экспортировать снимок состоя-
ния, с которым она работает. Пока экспортирующая этот снимок транзакция выполняется, другие
транзакции могут импортировать его и, таким образом, увидеть абсолютно то же состояние ба-
зы данных, что видит первая транзакция. Но учтите, что любые изменения, произведённые эти-
ми транзакциями, будут не видны для других, как это и должно быть с изменениями в незафикси-
рованных транзакциях. Таким образом, транзакции синхронизируют только начальное состояние
данных, а последующие производимые в них изменения изолируются как обычно.
Снимки состояния экспортируются с помощью функции pg_export_snapshot, показанной в Табли-
це 9.82, и импортируются командой SET TRANSACTION.
Таблица 9.82. Функции синхронизации снимков
Имя Тип результата Описание
pg_export_snapshot() text Сохраняет снимок текущего со-
стояния и возвращает его иден-
тификатор
Функция pg_export_snapshot создаёт снимок текущего состояния и возвращает его идентифика-
тор в строке типа text. Данная строка должна передаваться (за рамками базы данных) клиентам,
328Функции и операторы
которые будут импортировать этот снимок. При этом импортировать его нужно раньше, чем за-
вершится транзакция, которая его экспортировала. Если необходимо, транзакция может экспор-
тировать несколько снимков. Заметьте, что это имеет смысл только для транзакций уровня READ
COMMITTED, так как транзакции REPEATABLE READ и более высоких уровней изоляции работают с
одним снимком состояния. После того как транзакция экспортировала снимок, её нельзя подгото-
вить с помощью PREPARE TRANSACTION.
Подробнее использование
TRANSACTION.
экспортированных
снимков
рассматривается
в
описании
SET
9.26.6. Функции репликации
В Таблице 9.83 перечислены функции, предназначенные для управления и взаимодействия с ме-
ханизмом репликации. Чтобы изучить этот механизм детальнее, обратитесь к Подразделу 26.2.5,
Подразделу 26.2.6 и Главе 50. Использовать эти функции разрешено только суперпользователям.
Многие из этих функций соответствуют командам в протоколе репликации; см. Раздел 53.4.
Функции, описанные в Подразделе  9.26.3, Подразделе  9.26.4 и Подразделе  9.26.5 также имеют
отношение к репликации.
Таблица 9.83. Функции репликации SQL
Функция
Тип результата
Описание
pg_create_physical_
(slot_name name, lsn pg_lsn )
replication_slot(
slot_
name name [, immediately_
reserve boolean, temporary
boolean]) Создаёт новый физический слот
репликации с именем slot_
name . Необязательный второй
параметр, когда он равен true,
указывает, что LSN для этого
слота репликации должен быть
зарезервирован немедленно; в
противном случае LSN резер-
вируется при первом подклю-
чении клиента потоковой ре-
пликации. Передача изменений
из физического слота возможна
только по протоколу потоковой
репликации — см. Раздел  53.4.
Необязательный третий пара-
метр, temporary, когда он равен
true, указывает, что этот слот не
должен постоянно храниться на
диске, так как он предназначен
только для текущего сеанса.
Временные слоты также осво-
бождаются при любой ошиб-
ке. Эта функция соответству-
ет команде протокола репли-
кации
CREATE_REPLICATION_
SLOT ... PHYSICAL .
pg_drop_replication_slot(
slot_name name) Удаляет физический или логи-
ческий слот репликации с име-
нем slot_name . Соответствует
команде протокола репликации
DROP_REPLICATION_SLOT . Для
логических слотов эта функция
должна вызываться через под-
ключение к той же базе данных,
в которой был создан слот.
void
329Функции и операторы
Функция
Тип результата
Описание
pg_create_logical_
(slot_name name, lsn pg_lsn )
replication_slot(
slot_
name name, plugin name [,
temporary boolean]) Создаёт новый логический (
декодирующий) слот реплика-
ции с именем slot_name , ис-
пользуя модуль вывода plugin.
Необязательный третий пара-
метр, temporary, когда равен
true, указывает, что этот слот
не должен постоянно хранить-
ся на диске, так как он
предназначен только для теку-
щего сеанса. Временные сло-
ты также освобождаются при
любой ошибке. Вызов этой
функции равнозначен выполне-
нию команды протокола репли-
кации
CREATE_REPLICATION_
SLOT ... LOGICAL .
pg_logical_slot_get_
(lsn pg_lsn , xid xid, data text)
changes( slot_name
name,
upto_lsn pg_lsn , upto_
nchanges
int,
VARIADIC
options text[]) Возвращает изменения в слоте
slot_name с позиции, до кото-
рой ранее были получены из-
менения. Если параметры upto_
lsn и upto_nchanges равны
NULL, логическое декодирова-
ние продолжится до конца жур-
нала транзакций. Если upto_
lsn не NULL, декодировать-
ся будут только транзакции,
зафиксированные до заданно-
го LSN. Если upto_nchanges
не NULL, декодирование оста-
новится, когда число строк, по-
лученных при декодировании,
превысит заданное значение.
Заметьте, однако, что фактиче-
ское число возвращённых строк
может быть больше, так как
это ограничение проверяется
только после добавления строк,
декодированных для очередной
транзакции.
pg_logical_slot_peek_
(lsn pg_lsn , xid xid, data text)
changes( slot_name
name,
upto_lsn pg_lsn , upto_
nchanges
int,
VARIADIC
options text[]) Работает так же, как функ-
ция pg_logical_slot_get_
changes() , но не забирает из-
менения; то есть, они будут по-
лучены снова при следующих
вызовах.
pg_logical_slot_get_
(lsn pg_lsn , xid xid, data Работает так же, как функ-
ция pg_logical_slot_get_
binary_changes(
slot_name bytea)
changes() , но выдаёт измене-
name,
upto_lsn
pg_lsn ,
ния в типе bytea.
upto_nchanges
int,
VARIADIC options text[])
pg_logical_slot_peek_
(lsn pg_lsn , xid xid, data Работает так же, как функ-
ция pg_logical_slot_get_
binary_changes(
slot_name bytea)
changes() , но выдаёт измене-
name,
upto_lsn
pg_lsn ,
330Функции и операторы
Функция
Тип результата
upto_nchanges
int,
VARIADIC options text[])
pg_replication_slot_
advance( slot_name
upto_lsn pg_lsn )
(slot_name
name, lsn ) bool
name, end_lsn
Описание
ния в типе bytea и не забирает
их; то есть, они будут получены
снова при следующих вызовах.
pg_ Продвигает текущую подтвер-
ждённую позицию слота репли-
кации с именем slot_name .
Слот нельзя переместить назад,
а также вперёд за текущую по-
зицию добавления. Возвращает
имя слота и позицию, до кото-
рой он продвинулся.
pg_replication_origin_
create( node_name text) oid Создаёт источник репликации
с заданным внешним именем
и возвращает назначенный ему
внутренний идентификатор.
pg_replication_origin_
drop( node_name text) void Удаляет ранее созданный ис-
точник репликации, в том числе
связанную информацию о вос-
произведении.
pg_replication_origin_
oid( node_name text) oid Ищет источник репликации по
имени и возвращает внутрен-
ний идентификатор. Если такой
источник не находится, выдаёт-
ся ошибка.
pg_replication_origin_
session_setup(
node_name
text) void Помечает текущий сеанс, как
воспроизводящий журнал из
указанного источника, что поз-
воляет отслеживать положе-
ние воспроизведения. Чтобы
отменить это действие, вызо-
вите pg_replication_origin_
session_reset . Может ис-
пользоваться, только если не
был настроен предыдущий ис-
точник.
pg_replication_origin_
session_reset() void Отменяет
действие
replication_origin_
session_setup()
.
pg_replication_origin_
session_is_setup() bool В текущем сеансе настроен ис-
точник репликации?
pg_replication_origin_
session_progress(
flush
bool) pg_lsn Возвращает позицию воспроиз-
ведения для источника репли-
кации, настроенного в текущем
сеансе. Параметр flush опреде-
ляет, будет ли гарантироваться
сохранение локальной транзак-
ции на диске.
pg_replication_origin_
xact_setup(
origin_lsn
pg_lsn ,
origin_timestamp
timestamptz) void Помечает текущую транзакцию
как воспроизводящую транзак-
цию, зафиксированную с ука-
занным LSN и временем. Может
вызываться только после то-
го, как был настроен источник
331
pg_Функции и операторы
Функция Тип результата Описание
репликации в результате вы-
зова pg_replication_origin_
session_setup()
.
pg_replication_origin_
xact_reset() void Отменяет
действие
pg_
replication_origin_xact_
setup() .
pg_replication_origin_
void
advance ( node_name
text,
lsn pg_lsn ) Устанавливает положение ре-
пликации для заданного уз-
ла в указанную позицию. Это
в основном полезно для уста-
новки начальной позиции или
новой позиции после изме-
нения конфигурации и по-
добных действий. Но учтите,
что неосторожное использова-
ние этой функции может приве-
сти к несогласованности репли-
цированных данных.
pg_replication_origin_
pg_lsn
progress( node_name
text,
flush bool) Возвращает позицию воспроиз-
ведения для заданного источни-
ка репликации. Параметр flush
определяет, будет ли гаранти-
роваться сохранение локальной
транзакции на диске.
pg_logical_emit_message(
pg_lsn
transactional bool,
prefix
text, содержимое text) Выдаёт текстовое сообщение
логического декодирования. Её
можно использовать для пе-
редачи произвольных сообще-
ний через WAL модулям ло-
гического декодирования. Па-
раметр transactional устанав-
ливает, должно ли сообщение
быть частью текущей транзак-
ции или оно должно записы-
ваться немедленно и декодиро-
ваться сразу, как только эта за-
пись будет прочитана при ло-
гическом декодировании. Пара-
метр prefix задаёт текстовый
префикс, по которому модули
логического декодирования мо-
гут легко распознать интересу-
ющие их сообщения. В парамет-
ре content передаётся текст со-
общения.
pg_logical_emit_message(
pg_lsn
transactional bool,
prefix
text, содержимое bytea) Выдаёт двоичное сообщение ло-
гического декодирования. Её
можно использовать для пе-
редачи произвольных сообще-
ний через WAL модулям ло-
гического декодирования. Па-
раметр transactional устанав-
ливает, должно ли сообщение
быть частью текущей транзак-
332Функции и операторы
Функция
Тип результата
Описание
ции или оно должно записы-
ваться немедленно и декодиро-
ваться сразу, как только эта за-
пись будет прочитана при ло-
гическом декодировании. Пара-
метр prefix задаёт текстовый
префикс, по которому модули
логического декодирования мо-
гут легко распознать интересу-
ющие их сообщения. В парамет-
ре content передаётся двоич-
ное содержание сообщения.
9.26.7. Функции управления объектами баз данных
Функции, перечисленные в Таблице 9.84, вычисляют объём, который занимают на диске различ-
ные объекты баз данных.
Таблица 9.84. Функции получения размера объектов БД
Имя
pg_column_size(
any)
Тип результата Описание
int Число байт, необходимых для
хранения заданного значения (
возможно, в сжатом виде)
pg_database_size( oid) bigint Объём, который занимает на
диске база данных с заданным
OID
pg_database_size( name) bigint Объём, который занимает на
диске база данных с заданным
именем
regclass) bigint Общий объём индексов, связан-
ных с указанной таблицей
pg_relation_size(
relation bigint
regclass, fork text) Объём, который занимает на
диске указанный слой ('main',
'fsm', 'vm' или 'init') задан-
ной таблицы или индекса
pg_relation_size(
regclass) Краткая форма pg_relation_
size(..., 'main')
pg_indexes_size(
pg_size_bytes(
relation bigint
text)
bigint Преобразует размер в понятном
человеку формате с единицами
измерения в число байт
pg_size_pretty( bigint) text Преобразует размер в байтах,
представленный в 64-битном
целом, в понятный человеку
формат с единицами измерения
pg_size_pretty( numeric) text Преобразует размер в бай-
тах, представленный в значе-
нии числового типа, в понятный
человеку формат с единицами
измерения
pg_table_size( regclass) bigint Объём, который занимает на
диске данная таблица, за ис-
333Функции и операторы
Имя
Тип результата Описание
ключением индексов (но вклю-
чая TOAST, карту свободного
места и карту видимости)
pg_tablespace_size( oid) bigint Объём, который занимает на
диске табличное пространство
с указанным OID
pg_tablespace_size( name) bigint Объём, который занимает на
диске табличное пространство
с заданным именем
bigint Общий объём, который занима-
ет на диске заданная таблица,
включая все индексы и данные
TOAST
pg_total_relation_size(
regclass)
pg_column_size показывает, какой объём требуется для хранения данного значения.
pg_total_relation_size принимает OID или имя таблицы или данных TOAST и возвращает общий
объём, который занимает на диске эта таблица, включая все связанные с ней индексы. Результат
этой функции равняется pg_table_size + pg_indexes_size.
pg_table_size принимает OID или имя таблицы и возвращает объём, который занимает на диске
эта таблица без индексов. (При этом учитывается размер TOAST, карты свободного места и карты
видимости.)
pg_indexes_size принимает OID или имя таблицы и возвращает общий объём, который занимают
все индексы таблицы.
pg_database_size и pg_tablespace_size принимают OID или имя базы данных либо таблич-
ного пространства и возвращают общий объём, который они занимают на диске. Для исполь-
зования pg_database_size требуется иметь право CONNECT для указанной базы данных (оно
предоставляется по умолчанию) или быть членом роли pg_read_all_stats. Для использования
pg_tablespace_size необходимо иметь право CREATE для указанного табличного пространства или
быть членом роли pg_read_all_stats, если только это не табличное пространство по умолчанию
для текущей базы данных.
pg_relation_size принимает OID или имя таблицы, индекса или TOAST-таблицы и возвращает
размер одного слоя этого отношения (в байтах). (Заметьте, что в большинстве случаев удобнее
использовать более высокоуровневые функции pg_total_relation_size и pg_table_size, которые
суммируют размер всех слоёв.) С одним аргументом она возвращает размер основного слоя для
данных заданного отношения. Название другого интересующего слоя можно передать во втором
аргументе:
• 'main' возвращает размер основного слоя данных заданного отношения.
• 'fsm' возвращает размер карты свободного места (см. Раздел 68.3), связанной с заданным от-
ношением.
• 'vm' возвращает размер карты видимости (см. Раздел 68.4), связанной с заданным отношени-
ем.
• 'init' возвращает размер слоя инициализации для заданного отношения, если он имеется.
pg_size_pretty можно использовать для форматирования результатов других функций в виде, бо-
лее понятном человеку, с единицами измерения bytes, kB, MB, GB и TB.
pg_size_bytes можно использовать для получения размера в байтах из строки в формате, понят-
ном человеку. Входная строка может содержать единицы bytes, kB, MB, GB и TB, и разбирается
без учёта регистра. Если единицы не указываются, подразумеваются байты.
334Функции и операторы
Примечание
Единицы kB, MB, GB и TB, фигурирующие в функциях pg_size_pretty и pg_size_bytes,
2
определяются как степени 2, а не 10, так что 1kB равен 1024 байтам, 1MB равен 1024
= 1048576 байтов и т. д.
Вышеописанные функции, работающие с таблицами или индексами, принимают аргумент типа
regclass, который представляет собой просто OID таблицы или индекса в системном катало-
ге pg_class. Однако вам не нужно вручную вычислять OID, так как процедура ввода значения
regclass может сделать это за вас. Для этого достаточно записать имя таблицы в апострофах, как
обычную текстовую константу. В соответствии с правилами обработки обычных имён SQL, если
имя таблицы не заключено в кавычки, эта строка будет переведена в нижний регистр.
Если переданному значению OID не соответствуют существующий объект, эти функции возвраща-
ют NULL.
Функции, перечисленные в Таблице 9.85, помогают определить, в каких файлах на диске хранятся
объекты базы данных.
Таблица 9.85. Функции определения расположения объектов
Имя Тип результата Описание
pg_relation_filenode(
relation regclass) oid Номер файлового узла для ука-
занного отношения
pg_relation_filepath(
relation regclass) text Путь к файлу, в котором хранит-
ся указанное отношение
Находит отношение, связанное
с данным табличным простран-
ством и файловым узлом
pg_filenode_relation(
regclass
tablespace oid,
filenode
oid)
pg_relation_filenode принимает OID или имя таблицы, индекса, последовательности или таб-
лицы TOAST и возвращает номер «файлового узла», связанным с этим объектом. Файловым уз-
лом называется основной компонент имени файла, используемого для хранения данных (подроб-
нее это описано в Разделе  68.1). Для большинства таблиц этот номер совпадает со значением
pg_class.relfilenode, но для некоторых системных каталогов relfilenode равен 0, и нужно ис-
пользовать эту функцию, чтобы узнать действительное значение. Если указанное отношение не
хранится на диске, как например представление, данная функция возвращает NULL.
pg_relation_filepath подобна pg_relation_filenode, но возвращает полный путь к файлу (отно-
сительно каталога данных PGDATA) отношения.
Функция pg_filenode_relation является обратной к pg_relation_filenode. Она возвращает OID
отношения по заданному OID «табличного пространства» и «файловому узлу». Для таблицы в таб-
личном пространстве по умолчанию в первом параметре можно передать 0.
В Таблица 9.86 перечислены функции, предназначенные для управления правилами сортировки.
Таблица 9.86. Функции управления правилами сортировки
Имя Тип результата Описание
pg_collation_actual_
version( oid) text выдаёт действующую версию
правила сортировки из опера-
ционной системы
pg_import_system_
collations( schema
regnamespace) integer импортирует правила сортиров-
ки из операционной системы
335Функции и операторы
Функция pg_collation_actual_version возвращает действующую версию объекта правила сорти-
ровки, которая в настоящее время установлена в операционной системе. Если она отличается от
значения в pg_collation.collversion, может потребоваться перестроить объекты, зависящие от
данного правила сортировки. См. также ALTER COLLATION.
Функция pg_import_system_collations добавляет правила сортировки в системный каталог
pg_collation, анализируя все локали, которые она находит в операционной системе. Эту инфор-
мацию использует initdb; за подробностями обратитесь к Подразделу 23.2.2. Если позднее в си-
стему устанавливаются дополнительные локали, эту функцию можно запустить снова, чтобы доба-
вились правила сортировки для новых локалей. Локали, для которых обнаруживаются существую-
щие записи в pg_collation, будут пропущены. (Объекты правил сортировки для локалей, которые
перестают существовать в операционной системе, никогда не удаляются этой функцией.) В пара-
метре schema обычно передаётся pg_catalog, но это не обязательно; правила сортировки могут
быть установлены и в другую схему. Эта функция возвращает число созданных ей объектов правил
сортировки.
9.26.8. Функции обслуживания индексов
В Таблице 9.87 перечислены функции, предназначенные для обслуживания индексов. Эти функ-
ции нельзя вызывать в процессе восстановления. Использовать эти функции разрешено только су-
перпользователям и владельцу определённого индекса.
Таблица 9.87. Функции обслуживания индексов
Имя Тип результата Описание
brin_summarize_new_
values( index regclass) integer обобщает ещё не обобщённые
зоны страниц
brin_summarize_range(
integer
index regclass, blockNumber
bigint) обобщает зону страниц, охваты-
вающую данный блок (если она
ещё не обобщена)
brin_desummarize_range(
integer
index regclass, blockNumber
bigint) сброс обобщения зоны страниц,
охватывающей данный блок (ес-
ли она была обобщена)
gin_clean_pending_list(
index regclass) перемещает элементы из спис-
ка записей GIN, ожидающих об-
работки, в основную структуру
индекса
bigint
Функция brin_summarize_new_values принимает OID или имя индекса BRIN и просматривает ин-
декс в поисках зон страниц в базовой таблице, ещё не обобщённых в индексе; для каждой такой
зоны в результате сканирования страниц таблицы создаётся новый обобщающий кортеж в индек-
се. Возвращает эта функция число вставленных в индекс обобщающих записей о зонах страниц.
Функция brin_summarize_range делает то же самое, но затрагивает только зону, охватывающую
блок с заданным номером.
Функция gin_clean_pending_list принимает OID или имя индекса GIN и очищает очередь указан-
ного индекса, массово перемещая элементы из неё в основную структуру данных GIN. Возвращает
она число страниц, убранных из очереди. Заметьте, что если для обработки ей передаётся индекс
GIN, построенный с отключённым параметром fastupdate, очистка не производится и возвраща-
ется значение 0, так как у такого индекса нет очереди записей. Подробнее об очереди записей и
параметре fastupdate рассказывается в Подразделе 66.4.1 и Разделе 66.5.
9.26.9. Функции для работы с обычными файлами
Функции, перечисленные в Таблице 9.88, предоставляют прямой доступ к файлам, находящимся
на сервере. Обычным пользователям, не включённым в роль pg_read_server_files, они позволяют
обращаться только к файлам в каталоге кластера баз данных и в каталоге log_directory. Для
336Функции и операторы
файлов в каталоге кластера этим функциям передаётся относительный путь, а для файлов журнала
— путь, соответствующий значению параметра log_directory.
Заметьте, что пользователи, обладающие правом EXECUTE для pg_read_file() или связанных
функций, имеют возможность читать любой файл на сервере, который может прочитать сервер-
ный процесс, и это чтение не ограничивается никакими проверками уровня базы данных. В част-
ности это означает, что пользователь с такими правами может прочитать содержимое таблицы
pg_authid, в которой хранятся данные аутентификации, равно как и любой другой файл в базе
данных. Таким образом, разрешать доступ к этим функциям следует с большой осторожностью.
Таблица 9.88. Функции для работы с обычными файлами
Имя
Тип результата
Описание
pg_ls_dir(
dirname text [, setof text
missing_ok
boolean,
include_dot_dirs
boolean]) Выводит содержимое каталога (
по умолчанию разрешено толь-
ко суперпользователям, но пра-
во на её выполнение (EXECUTE)
можно дать и другим пользова-
телям).
pg_ls_logdir() setof record Выводит имя, размер и время
последнего изменения файлов
в каталоге журнала сообщений.
Доступ к этой функции имеют
члены роли pg_monitor , также
его можно разрешить и другим
ролям обычных пользователей.
pg_ls_waldir() setof record Выводит имя, размер и время
последнего изменения файлов
в каталоге WAL. Доступ к этой
функции имеют члены роли pg_
monitor , также его можно раз-
решить и другим ролям обыч-
ных пользователей.
pg_read_file(
filename
text
text
[,
offset
bigint,
length bigint [, missing_
ok boolean] ]) Возвращает содержимое тек-
стового файла (по умолчанию
разрешено только суперпользо-
вателям, но право на её выпол-
нение (EXECUTE) можно дать и
другим пользователям).
pg_read_binary_file(
bytea
filename text [,
offset
bigint,
length bigint [,
missing_ok boolean] ]) Возвращает содержимое файла
(по умолчанию разрешено толь-
ко суперпользователям, но пра-
во на её выполнение (EXECUTE)
можно дать и другим пользова-
телям).
pg_stat_file(
filename
record
text[, missing_ok boolean]) Возвращает информацию о фай-
ле (по умолчанию разреше-
но только суперпользователям,
но право на её выполнение (
EXECUTE) можно дать и другим
пользователям).
Некоторые из этих функций принимают необязательный параметр missing_ok, который определя-
ет их поведение в случае отсутствия файла или каталога. Если он равен true, функция возвращает
NULL (за исключением pg_ls_dir, которая возвращает пустое множество). Если он равен false,
возникает ошибка. Значение по умолчанию — false.
337Функции и операторы
pg_ls_dir возвращает имена всех файлов (а также каталогов и других специальных файлов) в
заданном каталоге. Параметр include_dot_dirs определяет, будут ли в результирующий набор
включаться каталоги «.» и «..». По умолчанию они не включаются (false), но их можно включить,
чтобы с параметром missing_ok равным true, пустой каталог можно было отличить от несуще-
ствующего.
pg_ls_logdir возвращает имя, размер и время последнего изменения (mtime) всех файлов в ката-
логе журналов сообщений. По умолчанию использовать её разрешено только суперпользователям
и членам роли pg_monitor. Другим пользователям доступ к ней можно дать, используя GRANT.
pg_ls_waldir возвращает имя, размер и время последнего изменения (mtime) всех файлов в ката-
логе журнала предзаписи (WAL). По умолчанию использовать её разрешено только суперпользо-
вателям и членам роли pg_monitor. Другим пользователям доступ к ней можно дать, используя
GRANT.
pg_read_file возвращает фрагмент текстового файла с заданного смещения (offset), размером
не больше length байт (размер может быть меньше, если файл кончится раньше). Если смещение
offset отрицательно, оно отсчитывается от конца файла. Если параметры offset и length опуще-
ны, возвращается всё содержимое файла. Прочитанные из файла байты обрабатываются как сим-
волы в серверной кодировке; если они оказываются недопустимыми для этой кодировки, возника-
ет ошибка.
pg_read_binary_file подобна pg_read_file, но её результат имеет тип bytea; как следствие, ни-
какие проверки кодировки не выполняются. В сочетании с convert_from эту функцию можно при-
менять для чтения файлов в произвольной кодировке:
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
pg_stat_file возвращает запись, содержащую размер файла, время последнего обращения и по-
следнего изменения, а также время последнего изменения состояния (только в Unix-системах),
время создания (только в Windows) и признак типа boolean, показывающий, что это каталог. При-
меры использования:
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
9.26.10. Функции управления рекомендательными блокировками
Функции, перечисленные в Таблице 9.89, предназначены для управления рекомендательными бло-
кировками. Подробнее об их использовании можно узнать в Подразделе 13.3.5.
Таблица 9.89. Функции управления рекомендательными блокировками
Имя
Тип результата Описание
pg_advisory_lock(
bigint) key void Получает исключительную бло-
кировку на уровне сеанса
pg_advisory_lock(
int, key2 int) key1 void Получает исключительную бло-
кировку на уровне сеанса
pg_advisory_lock_shared(
key bigint) void Получает разделяемую блоки-
ровку на уровне сеанса
pg_advisory_lock_shared(
key1 int, key2 int) void Получает разделяемую блоки-
ровку на уровне сеанса
pg_advisory_unlock(
bigint) boolean Освобождает исключительную
блокировку на уровне сеанса
key
338Функции и операторы
Имя
Тип результата Описание
boolean Освобождает исключительную
блокировку на уровне сеанса
pg_advisory_unlock_all() void Освобождает все блокировки на
уровне сеанса, удерживаемые в
данном сеансе
pg_advisory_unlock_
shared( key bigint) boolean Освобождает разделяемую бло-
кировку на уровне сеанса
pg_advisory_unlock_
boolean
shared( key1 int, key2 int) Освобождает разделяемую бло-
кировку на уровне сеанса
pg_advisory_xact_lock(
key bigint) void Получает исключительную бло-
кировку на уровне транзакции
pg_advisory_xact_lock(
key1 int, key2 int) void Получает исключительную бло-
кировку на уровне транзакции
pg_advisory_xact_lock_
shared( key bigint) void Получает разделяемую блоки-
ровку на уровне транзакции
pg_advisory_xact_lock_
void
shared( key1 int, key2 int) Получает разделяемую блоки-
ровку на уровне транзакции
pg_try_advisory_lock(
bigint) key boolean Получает исключительную бло-
кировку на уровне сеанса, если
это возможно
pg_try_advisory_lock(
key1 int, key2 int) boolean Получает исключительную бло-
кировку на уровне сеанса, если
это возможно
pg_try_advisory_lock_
shared( key bigint) boolean Получает разделяемую блоки-
ровку на уровне сеанса, если
это возможно
pg_try_advisory_lock_
boolean
shared( key1 int, key2 int) Получает разделяемую блоки-
ровку на уровне сеанса, если
это возможно
pg_try_advisory_xact_
lock( key bigint) boolean Получает исключительную бло-
кировку на уровне транзакции,
если это возможно
pg_try_advisory_xact_
lock( key1 int, key2 int) boolean Получает исключительную бло-
кировку на уровне транзакции,
если это возможно
pg_try_advisory_xact_
lock_shared(
key bigint) boolean Получает разделяемую блоки-
ровку на уровне транзакции, ес-
ли это возможно
pg_try_advisory_xact_
lock_shared(
key1
key2 int) boolean Получает разделяемую блоки-
ровку на уровне транзакции, ес-
ли это возможно
pg_advisory_unlock(
int, key2 int)
key1
int,
pg_advisory_lock блокирует определённый приложением ресурс, задаваемый одним 64-битным
или двумя 32-битными ключами (заметьте, что их значения не пересекаются). Если идентифика-
тор этого ресурса удерживает другой сеанс, эта функция не завершится, пока ресурс не станет
доступным. Данная функция устанавливает блокировку в исключительном режиме. Если поступа-
ет сразу несколько запросов на блокировку, они накапливаются, так что если один ресурс был
заблокирован три раза, его необходимо три раза разблокировать, чтобы он был доступен в других
сеансах.
339Функции и операторы
pg_advisory_lock_shared работает подобно pg_advisory_lock, но позволяет разделять блокиров-
ку с другими сеансами, запрашивающими её как разделяемую. Выполнение может быть приоста-
новлено, только если другой сеанс запросил её в исключительном режиме.
pg_try_advisory_lock работает подобно pg_advisory_lock, но не ждёт освобождения ресурса. Эта
функция либо немедленно получает блокировку и возвращает true, либо сразу возвращает false,
если получить её не удаётся.
pg_try_advisory_lock_shared работает как pg_try_advisory_lock, но пытается получить разде-
ляемую, а не исключительную блокировку.
pg_advisory_unlock освобождает ранее полученную исключительную блокировку на уровне сеан-
са. Если блокировка освобождена успешна, эта функция возвращает true, а если она не была за-
нята — false, при этом сервер выдаёт предупреждение SQL.
pg_advisory_unlock_shared работает подобно pg_advisory_unlock, но освобождает разделяемую
блокировку на уровне сеанса.
pg_advisory_unlock_all освобождает все блокировки на уровне сеанса, закреплённые за текущим
сеансом. (Эта функция неявно вызывается в конце любого сеанса, даже при нештатном отключе-
нии клиента.)
pg_advisory_xact_lock работает подобно pg_advisory_lock, но её блокировка автоматически
освобождается в конце текущей транзакции и не может быть освобождена явным образом.
pg_advisory_xact_lock_shared подобна функции pg_advisory_lock_shared, но её блокировка ав-
томатически освобождается в конце текущей транзакции и не может быть освобождена явным
образом.
pg_try_advisory_xact_lock работает подобно pg_try_advisory_lock, но её блокировка (если она
была получена) автоматически освобождается в конце текущей транзакции и не может быть осво-
бождена явным образом.
pg_try_advisory_xact_lock_shared работает подобно pg_try_advisory_lock_shared, но её блоки-
ровка (если она была получена) автоматически освобождается в конце текущей транзакции и не
может быть освобождена явным образом.
9.27. Триггерные функции
В настоящее время в PostgreSQL есть единственная встроенная триггерная функция,
suppress_redundant_updates_trigger, которая предотвращает изменения, фактически не влияю-
щие на данные в строке, тогда как обычно изменения выполняются вне зависимости от того, были
ли изменены данные. (Обычное поведение не предполагает сравнения данных, поэтому изменения
выполняются быстрее, и в ряде случаев именно это поведение желательно.)
В идеале, следует избегать операций изменения, которые фактически не меняют данные в запи-
сях. Подобные ненужные изменения могут обходиться дорого, особенно когда требуется обновлять
множество индексов, к тому же впоследствии базу данных придётся очищать от «мёртвых» строк.
Однако выявить такие изменения в клиентском коде бывает сложно, если вообще возможно, а при
составлении соответствующих проверочных выражений легко допустить ошибку. В качестве аль-
тернативного решения можно использовать функцию suppress_redundant_updates_trigger, кото-
рая опускает изменения, не меняющие данные. Однако использовать её следует с осторожностью.
Данный триггер выполняется не большое, но значительное время для каждой записи, так что если
большинство записей всё-таки фактически изменяются, этот триггер скорее замедлит операцию
изменения.
340Функции и операторы
Функцию suppress_redundant_updates_trigger можно привязать к таблице так:
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
В большинстве случаев этот триггер должен вызываться для каждой строки последним. А так как
триггеры вызываются по порядку сортировки их имён, имя для него нужно выбирать таким, чтобы
оно было последним среди имён всех триггеров, которые могут быть в таблице.
Подробнее о создании триггеров можно узнать в описании CREATE TRIGGER.
9.28. Функции событийных триггеров
PostgreSQL предоставляет следующие вспомогательные функции для получения информации в
событийных триггерах.
Подробнее о событийных триггерах можно узнать в Главе 40.
9.28.1. Получение изменений в конце команды
Функция pg_event_trigger_ddl_commands возвращает список команд DDL, выполняемых в резуль-
тате действия пользователя. Вызывать её можно только в функции, реализующей событийный
триггер ddl_command_end. При попытке вызвать её в любом другом контексте возникнет ошиб-
ка. Функция pg_event_trigger_ddl_commands возвращает одну строку для каждой базовой коман-
ды; для некоторых команд, записываемых в виде одного предложения SQL, может возвращаться
несколько строк. Эта функция возвращает следующие столбцы:
Имя Тип Описание
classid oid OID каталога, к которому отно-
сится объект
objid oid OID самого объекта
objsubid integer Идентификатор подобъекта (на-
пример, номер для столбца)
command_tag text Тег команды
object_type text Тип объекта
schema_name text Имя схемы, к которой относит-
ся объект; если объект не отно-
сится ни к какой схеме — NULL.
В кавычки имя не заключается.
object_identity text Текстовое представление иден-
тификатора объекта, включаю-
щее схему. При необходимости
компоненты этого идентифика-
тора заключаются в кавычки.
in_extension bool True, если команда является ча-
стью скрипта расширения
command pg_ddl_command Полное представление коман-
ды, во внутреннем формате. Его
нельзя вывести непосредствен-
но, но можно передать другим
функциям, чтобы получить раз-
личные сведения о команде.
9.28.2. Обработка объектов, удалённых командой DDL
341Функции и операторы
Функция pg_event_trigger_dropped_objects возвращает список всех объектов, удалён-
ных
командой,
вызвавшей
событие
sql_drop.
При
вызове
в
другом
контексте
pg_event_trigger_dropped_objects выдаёт ошибку. pg_event_trigger_dropped_objects возвра-
щает следующие столбцы:
Имя Тип Описание
classid oid OID каталога, к которому отно-
сился объект
objid oid OID самого объекта
objsubid integer Идентификатор подобъекта (на-
пример, номер для столбца)
original bool True, если это один из корневых
удаляемых объектов
normal bool True, если к этому объекту в гра-
фе зависимостей привело отно-
шение обычной зависимости
is_temporary bool True, если объект был времен-
ным
object_type text Тип объекта
schema_name text Имя схемы, к которой относил-
ся объект; если объект не отно-
сился ни к какой схеме — NULL.
В кавычки имя не заключается.
object_name text Имя объекта, если сочетание
схемы и имени позволяет уни-
кально идентифицировать объ-
ект; в противном случае — NULL.
Имя не заключается в кавычки
и не дополняется именем схе-
мы.
object_identity text Текстовое представление иден-
тификатора объекта, включаю-
щее схему. При необходимости
компоненты этого идентифика-
тора заключаются в кавычки.
address_names text[] Массив, который в сочета-
нии с object_type и масси-
вом address_args можно пере-
дать функции pg_get_object_
address() , чтобы воссоздать
адрес объекта на удалённом
сервере, содержащем одно-
имённый объект того же рода.
address_args text[] Дополнение к массиву address_
names
Функцию pg_event_trigger_dropped_objects можно использовать в событийном триггере так:
CREATE FUNCTION test_event_trigger_for_drops()
RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
obj record;
BEGIN
FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
342Функции и операторы
LOOP
RAISE NOTICE '% dropped object: % %.% %',
tg_tag,
obj.object_type,
obj.schema_name,
obj.object_name,
obj.object_identity;
END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
ON sql_drop
EXECUTE FUNCTION test_event_trigger_for_drops();
9.28.3. Обработка события перезаписи таблицы
В Таблице 9.90 показаны функции, выдающие информацию о таблице, для которой произошло со-
бытие перезаписи таблицы (table_rewrite). При попытке вызвать их в другом контексте возник-
нет ошибка.
Таблица 9.90. Информация о перезаписи таблицы
Имя Тип результата Описание
pg_event_trigger_table_
rewrite_oid() Oid OID таблицы, которая будет пе-
резаписана.
pg_event_trigger_table_
rewrite_reason() int Код причины, показывающий,
чем вызвана перезапись. Точ-
ное значение кодов зависит от
выпуска (версии).
Функцию pg_event_trigger_table_rewrite_oid можно использовать в событийном триггере так:
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
RETURNS event_trigger
LANGUAGE plpgsql AS
$$
BEGIN
RAISE NOTICE 'rewriting table % for reason %',
pg_event_trigger_table_rewrite_oid()::regclass,
pg_event_trigger_table_rewrite_reason();
END;
$$;
CREATE EVENT TRIGGER test_table_rewrite_oid
ON table_rewrite
EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
&lt;/root&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 9. Функции и операторы</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry><entry><title type="html">Глава 10. Преобразование типов</title><link href="http://localhost:4000/PostgreSQL-V11_Doc-010/" rel="alternate" type="text/html" title="Глава 10. Преобразование типов" /><published>2018-12-01T00:00:00+02:00</published><updated>2018-12-01T00:00:00+02:00</updated><id>http://localhost:4000/PostgreSQL-V11_Doc-010</id><content type="html" xml:base="http://localhost:4000/PostgreSQL-V11_Doc-010/">&lt;p&gt;Глава 10. Преобразование типов&lt;/p&gt;

&lt;p&gt;SQL-операторы, намеренно или нет, требуют совмещать данные разных типов в одном выражении.
Для вычисления подобных выражений со смешанными типами PostgreSQL предоставляет широкий
набор возможностей.
Очень часто пользователю не нужно понимать все тонкости механизма преобразования. Однако
следует учитывать, что неявные преобразования, производимые PostgreSQL, могут влиять на ре-
зультат запроса. Поэтому при необходимости нужные результаты можно получить, применив яв-
ное преобразование типов.
В этой главе описываются общие механизмы преобразования типов и соглашения, принятые в
PostgreSQL. За дополнительной информацией о конкретных типах данных и разрешённых для них
функциях и операторах обратитесь к соответствующим разделам в Главе 8 и Главе 9.
10.1. Обзор
SQL — язык со строгой типизацией. То есть каждый элемент данных в нём имеет некоторый тип,
определяющий его поведение и допустимое использование. PostgreSQL наделён расширяемой си-
стемой типов, более универсальной и гибкой по сравнению с другими реализациями SQL. При этом
преобразования типов в PostgreSQL в основном подчиняются определённым общим правилам, для
их понимания не нужен эвристический анализ. Благодаря этому в выражениях со смешанными
типами можно использовать даже типы, определённые пользователями.
Анализатор выражений PostgreSQL разделяет их лексические элементы на пять основных кате-
горий: целые числа, другие числовые значения, текстовые строки, идентификаторы и ключевые
слова. Константы большинства не числовых типов сначала классифицируются как строки. В опре-
делении языка SQL допускается указывать имена типов в строках и это можно использовать в
PostgreSQL, чтобы направить анализатор по верному пути. Например, запрос:
SELECT text ‘Origin’ AS “label”, point ‘(0,0)’ AS “value”;
label | value
——–+——-
Origin | (0,0)
(1 row)
содержит две строковых константы, типа text и типа point. Если для такой константы не указан
тип, для неё первоначально предполагается тип unknown, который затем может быть уточнён, как
описано ниже.
В SQL есть четыре фундаментальных фактора, определяющих правила преобразования типов для
анализатора выражений PostgreSQL:
Вызовы функций
Система типов PostgreSQL во многом построена как дополнение к богатым возможностям функ-
ций. Функции могут иметь один или несколько аргументов, и при этом PostgreSQL разрешает
перегружать имена функций, так что имя функции само по себе не идентифицирует вызывае-
мую функцию; анализатор выбирает правильную функцию в зависимости от типов переданных
аргументов.
Операторы
PostgreSQL позволяет использовать в выражениях префиксные и постфиксные операторы с од-
ним аргументом, а также операторы с двумя аргументами. Как и функции, операторы можно
перегружать, так что и с ними существует проблема выбора правильного оператора.
Сохранение значений
SQL-операторы INSERT и UPDATE помещают результаты выражений в таблицы. При этом полу-
чаемые значения должны соответствовать типам целевых столбцов или, возможно, приводить-
ся к ним.
344Преобразование типов
UNION, CASE и связанные конструкции
Так как все результаты запроса объединяющего оператора SELECT должны оказаться в одном
наборе столбцов, результаты каждого подзапроса SELECT должны приводиться к одному набору
типов. Подобным образом, результирующие выражения конструкции CASE должны приводиться
к общему типу, так как выражение CASE в целом должно иметь определённый выходной тип. То
же справедливо в отношении конструкций ARRAY и функций GREATEST и LEAST.
Информация о существующих преобразованиях или приведениях типов, для каких типов они опре-
делены и как их выполнять, хранится в системных каталогах. Пользователь также может добавить
дополнительные преобразования с помощью команды CREATE CAST. (Обычно это делается, когда
определяются новые типы данных. Набор приведений для встроенных типов достаточно хорошо
проработан, так что его лучше не менять.)
Дополнительная логика анализа помогает выбрать оптимальное приведение в группах типов,
допускающих неявные преобразования. Для этого типы данных разделяются на несколько ба-
зовых категорий, которые включают: boolean, numeric, string, bitstring, datetime, timespan,
geometric, network и пользовательские типы. (Полный список категорий приведён в Таблице 52.63;
хотя его тоже можно расширить, определив свои категории.) В каждой категории могут быть вы-
браны один или несколько предпочитаемых типов, которые будут считаться наиболее подходя-
щими при рассмотрении нескольких вариантов. Аккуратно выбирая предпочитаемые типы и до-
пустимые неявные преобразования, можно добиться того, что выражения с неоднозначностями
(в которых возможны разные решения задачи преобразования) будут разрешаться наилучшим об-
разом.
Все правила преобразования типов разработаны с учётом следующих принципов:
• Результат неявных преобразованиях всегда должен быть предсказуемым и понятным.
• Если в неявном преобразовании нет нужды, анализатор и исполнитель запроса не должны
тратить лишнее время на это. То есть, если запрос хорошо сформулирован и типы значений
совпадают, он должен выполняться без дополнительной обработки в анализаторе и без лиш-
них вызовов неявных преобразований.
• Кроме того, если запрос изначально требовал неявного преобразования для функции, а поль-
зователь определил новую функцию с точно совпадающими типами аргументов, анализатор
должен переключиться на новую функцию и больше не выполнять преобразование для вызова
старой.
10.2. Операторы
При выборе конкретного оператора, задействованного в выражении, PostgreSQL следует описан-
ному ниже алгоритму. Заметьте, что на этот выбор могут неявно влиять приоритеты остальных
операторов в данном выражении, так как они определяют, какие подвыражения будут аргумента-
ми операторов. Подробнее об этом рассказывается в Подразделе 4.1.6.
Выбор оператора по типу
1.
Выбрать операторы для рассмотрения из системного каталога pg_operator. Если имя операто-
ра не дополнено именем схемы (обычно это так), будут рассматриваться все операторы с под-
ходящим именем и числом аргументов, видимые в текущем пути поиска (см. Подраздел 5.8.3).
Если имя оператора определено полностью, в рассмотрение принимаются только операторы
из указанной схемы.
•
2.
(Optional) Если в пути поиска оказывается несколько операторов с одинаковыми типами
аргументов, учитываются только те из них, которые находятся в пути раньше. Операторы
с разными типами аргументов рассматриваются на равных правах вне зависимости от их
положения в пути поиска.
Проверить, нет ли среди них оператора с точно совпадающими типами аргументов. Если такой
оператор есть (он может быть только одним в отобранном ранее наборе), использовать его.
345Преобразование типов
1
Отсутствие точного совпадения создаёт угрозу вызова с указанием полного имени (нетипич-
ным) любого оператора, который может оказаться в схеме, где могут создавать объекты недо-
веренные пользователи. В таких ситуациях приведите типы аргументов для получения точного
совпадения.
3.
a. (Optional) Если один аргумент при вызове бинарного оператора имеет тип unknown, для
данной проверки предполагается, что он имеет тот же тип, что и второй его аргумент. При
вызове бинарного оператора с двумя аргументами unknown или унарного с одним unknown,
оператор не будет выбран на этом шаге.
b. (Optional) Если один аргумент при вызове бинарного оператора имеет тип unknown, а другой
— домен, проверить, есть ли оператор, принимающий базовый тип домена с обеих сторон;
если таковой находится, использовать его.
Найти самый подходящий.
a. Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразо-
ваны (неявным образом) так, чтобы они совпали. В данном случае считается, что констан-
ты типа unknown можно преобразовать во что угодно. Если остаётся только один кандидат,
использовать его, в противном случае перейти к следующему шагу.
b. Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена.
Благодаря этому при поиске неоднозначно заданного оператора домены будут подобны
свои базовым типам.
c. Просмотреть все кандидаты и оставить только те, для которых точно совпадают как мож-
но больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
d. Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые
типы (из категории типов входных значений) в наибольшем числе позиций, где требуется
преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитае-
мые типы. Если остаётся только один кандидат, использовать его, в противном случае пе-
рейти к следующему шагу.
e. Если какие-либо значения имеют тип unknown, проверить категории типов, принимаемых
в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать
категорию string, если какой-либо кандидат принимает эту категорию. (Эта склонность
к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта
категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать
её; в противном случае констатировать неудачу — сделать правильный выбор без дополни-
тельных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы вы-
бранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из
этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для
данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
f. Если в списке аргументов есть аргументы и типа unknown, и известного типа, и этот из-
вестный тип один для всех аргументов, предположить, что аргументы типа unknown также
имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргу-
мента unknown. Если остаётся только один кандидат, использовать его, в противном случае
констатировать неудачу.
Ниже это проиллюстрировано на примерах.
1
Эта угроза неактуальна для имён без схемы, так как путь поиска, содержащий схемы, в которых недоверенные пользователи могут создавать объекты, не
соответствует шаблону безопасного использования схем.
346Преобразование типов
Пример 10.1. Разрешение оператора факториала
В стандартном каталоге определён только один оператор факториала (постфиксный !) и он при-
нимает аргумент типа bigint. При просмотре следующего выражения его аргументу изначально
назначается тип integer:
SELECT 40 ! AS “40 factorial”;
40 factorial
————————————————–
815915283247897734345611269596115894272000000000
(1 row)
Анализатор выполняет преобразование типа для этого операнда и запрос становится равносиль-
ным:
SELECT CAST(40 AS bigint) ! AS “40 factorial”;
Пример 10.2. Разрешение оператора конкатенации строк
Синтаксис текстовых строк используется как для записи строковых типов, так и для сложных ти-
пов расширений. Если тип не указан явно, такие строки сопоставляются по тому же алгоритму с
наиболее подходящими операторами.
Пример с одним неопределённым аргументом:
SELECT text ‘abc’ || ‘def’ AS “text and unknown”;
text and unknown
——————
abcdef
(1 row)
В этом случае анализатор смотрит, есть ли оператор, у которого оба аргумента имеют тип text.
Такой оператор находится, поэтому предполагается, что второй аргумент следует воспринимать
как аргумент типа text.
Конкатенация двух значений неопределённых типов:
SELECT ‘abc’ || ‘def’ AS “unspecified”;
unspecified
————-
abcdef
(1 row)
В данном случае нет подсказки для выбора типа, так как в данном запросе никакие типы не ука-
заны. Поэтому анализатор просматривает все возможные операторы и находит в них кандидаты,
принимающие аргументы категорий string и bit-string. Так как категория string является предпо-
чтительной, выбирается она, а затем для разрешения типа не типизированной константы выбира-
ется предпочтительный тип этой категории, text.
Пример 10.3. Разрешение оператора абсолютного значения и отрицания
В каталоге операторов PostgreSQL для префиксного оператора @ есть несколько записей, описы-
вающих операции получения абсолютного значения для различных числовых типов данных. Одна
из записей соответствует типу float8, предпочтительного в категории числовых типов. Таким об-
разом, столкнувшись со значением типа unknown, PostgreSQL выберет эту запись:
SELECT @ ‘-4.5’ AS “abs”;
abs
—–
347Преобразование типов
4.5
(1 row)
Здесь система неявно привела константу неизвестного типа к типу float8, прежде чем применять
выбранный оператор. Можно убедиться в том, что выбран именно тип float8, а не какой-то другой:
SELECT @ ‘-4.5e500’ AS “abs”;
ОШИБКА:
“-4.5e500” вне диапазона для типа double precision
С другой стороны, префиксный оператор ~ (побитовое отрицание) определён только для целочис-
ленных типов данных, но не для float8. Поэтому, если попытаться выполнить похожий запрос с
~, мы получаем:
SELECT ~ ‘20’ AS “negation”;
ОШИБКА: оператор не уникален: ~ “unknown”
ПОДСКАЗКА: Не удалось выбрать лучшую кандидатуру оператора. Возможно, вам следует
добавить явные преобразования типов.
Это происходит оттого, что система не может решить, какой оператор предпочесть из нескольких
возможных вариантов ~. Мы можем облегчить её задачу, добавив явное преобразование:
SELECT ~ CAST(‘20’ AS int8) AS “negation”;
negation
———-
-21
(1 row)
Пример 10.4. Разрешение оператора включения в массив
Ещё один пример разрешения оператора с одним аргументом известного типа и другим неизвест-
ного:
SELECT array[1,2] &amp;lt;@ ‘{1,2,3}’ as “is subset”;
is subset
———–
t
(1 row)
В каталоге операторов PostgreSQL есть несколько записей для инфиксного оператора &amp;lt;@, но
только два из них могут принять целочисленный массива слева: оператор включения массива
(anyarray&amp;lt;@anyarray) и оператор включения диапазона (anyelement&amp;lt;@anyrange). Так как ни один
из этих полиморфных псевдотипов (см. Раздел 8.21) не считается предпочтительным, анализатор
не может избавиться от неоднозначности на данном этапе. Однако, в Шаг 3.f говорится, что кон-
станта неизвестного типа должна рассматриваться как значение типа другого аргумента, в дан-
ном случае это целочисленный массив. После этого подходящим считается только один из двух
операторов, так что выбирается оператор с целочисленными массивами. (Если бы был выбран опе-
ратор включения диапазона, мы получили бы ошибку, так как значение в строке не соответствует
формату значений диапазона.)
Пример 10.5. Нестандартный оператор с доменом
Иногда пользователи пытаются ввести операторы, применимые только к определённому домену.
Это возможно, но вовсе не так полезно, как может показаться, ведь правила разрешения операто-
ров применяются к базовому типу домена. Взгляните на этот пример:
CREATE DOMAIN mytext AS text CHECK(…);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS …;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
348Преобразование типов
CREATE TABLE mytable (val mytext);
SELECT * FROM mytable WHERE val = ‘foo’;
В этом запросе не будет использоваться нововведённый оператор. При разборе запроса сначала
будет проверено, есть ли оператор mytext = mytext (см. Шаг 2.a), но это не так; затем будет рас-
смотрен базовый тип домена (text) и проверено наличие оператора text = text (см. Шаг 2.b), и
таковой действительно есть; в итоге строковое значение типа unknown будет воспринято как text
и будет применён оператор text = text. Единственный вариант задействовать нововведённый опе-
ратор — добавить явное приведение:
SELECT * FROM mytable WHERE val = text ‘foo’;
так, чтобы оператор mytext = text был найден сразу, согласно правилу точного совпадения. Ес-
ли дело доходит до правил наибольшего соответствия, они активно дискредитируют операторы
доменных типов. Если бы они этого не делали, с таким оператором возникало бы слишком много
ошибок разрешения операторов, потому что правила приведения всегда считают домен приводи-
мым к базовому типу и наоборот, так что доменный оператор применялся бы во всех случаях, где
применяется одноимённый оператор с базовым типом.
10.3. Функции
При выборе конкретной функции, задействованной в выражении, PostgreSQL следует описанному
ниже алгоритму.
Разрешение функции по типу
1.
Выбрать функции для рассмотрения из системного каталога pg_proc. Если имя функции не
дополнено именем схемы, будут рассматриваться все функции с подходящим именем и числом
аргументов, видимые в текущем пути поиска (см. Подраздел 5.8.3). Если имя функции опреде-
лено полностью, в рассмотрение принимаются только функции из указанной схемы.
a. (Optional) Если в пути поиска оказывается несколько функций с одинаковыми типами ар-
гументов, учитываются только те из них, которые находятся в пути раньше. Функции с раз-
ными типами аргументов рассматриваются на равных правах вне зависимости от их поло-
жения в пути поиска.
b. (Optional) Если в числе параметров функции есть массив VARIADIC и при вызове не указы-
вается ключевое слово VARIADIC, функция обрабатывается, как если бы этот параметр был
заменён одним или несколькими параметрами типа элементов массива, по числу аргумен-
тов при вызове. После такого расширения по фактическим типам аргументов она может
совпасть с некоторой функцией с постоянным числом аргументов. В этом случае исполь-
зуется функция, которая находится в пути раньше, а если они оказываются в одной схеме,
предпочитается вариант с постоянными аргументами.
2
Это создаёт угрозу безопасности при вызове с полным именем функции с переменным
числом аргументов, которая может оказаться в схеме, где могут создавать объекты недо-
веренные пользователи. Злонамеренный пользователь может перехватывать управление и
выполнять произвольные SQL-функции, как будто их выполняете вы. Запись вызова с клю-
чевым словом VARIADIC устраняет эту угрозу. Однако для вызовов с передачей параметров
VARIADIC “any” часто не существует необходимой формулировки с ключом VARIADIC. Чтобы
такие вызовы были безопасными, создание объектов в схеме функции должно разрешаться
только доверенным пользователям.
c.
(Optional) Функции, для которых определены значения параметров по умолчанию, счита-
ются совпадающими с вызовом, в котором опущено ноль или более параметров в соответ-
ствующих позициях. Если для вызова подходят несколько функций, используется та, что
обнаруживается в пути поиска раньше. Если в одной схеме оказываются несколько функ-
ций с одинаковыми типами в позициях обязательных параметров (что возможно, если в них
2
Эта угроза неактуальна для имён без схемы, так как путь поиска, содержащий схемы, в которых недоверенные пользователи могут создавать объекты, не
соответствует шаблону безопасного использования схем.
349Преобразование типов
определены разные наборы пропускаемых параметров), система не сможет выбрать опти-
мальную, и выдаст ошибку «неоднозначный вызов функции», если лучшее соответствие
для вызова не будет найдено.
2
Это создаёт угрозу при вызове с полным именем любой функции, которая может оказать-
ся в схеме, где могут создавать объекты недоверенные пользователи. Злонамеренный поль-
зователь может создать функцию с именем уже существующей, продублировав параметры
исходной и добавив дополнительные со значениями по умолчанию. В результате при по-
следующих вызовах будет выполняться не исходная функция. Для ликвидации этой угрозы
помещайте функции в схемы, в которых создавать объекты могут только доверенные объ-
екты.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Проверить, нет ли функции, принимающей в точности типы входных аргументов. Если такая
функция есть (она может быть только одной в отобранном ранее наборе), использовать её. От-
2
сутствие точного совпадения создаёт угрозу вызова с полным именем функции в схеме, где
могут создавать объекты недоверенные пользователи. В таких ситуациях приведите типы ар-
гументов для получения точного соответствия. (В случаях с unknown совпадения на этом этапе
не будет никогда.)&lt;/li&gt;
  &lt;li&gt;Если точное совпадение не найдено, проверить, не похож ли вызов функции на особую форму
преобразования типов. Это имеет место, когда при вызове функции передаётся всего один ар-
гумент и имя функции совпадает с именем (внутренним) некоторого типа данных. Более того,
аргументом функции должна быть либо строка неопределённого типа, либо значение типа,
двоично-совместимого с указанным или приводимого к нему с помощью функций ввода/выво-
да типа (то есть, преобразований в стандартный строковый тип и обратно). Если эти условия
3
выполняются, вызов функции воспринимается как особая форма конструкции CAST.&lt;/li&gt;
  &lt;li&gt;Найти самый подходящий.
a. Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразо-
ваны (неявным образом) так, чтобы они совпали. В данном случае считается, что констан-
ты типа unknown можно преобразовать во что угодно. Если остаётся только один кандидат,
использовать его, в противном случае перейти к следующему шагу.
b. Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена.
Благодаря этому при поиске неоднозначно заданной функции домены будут подобны свои
базовым типам.
c. Просмотреть все кандидаты и оставить только те, для которых точно совпадают как мож-
но больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
d. Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые
типы (из категории типов входных значений) в наибольшем числе позиций, где требуется
преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитае-
мые типы. Если остаётся только один кандидат, использовать его, в противном случае пе-
рейти к следующему шагу.
e. Если какие-либо значения имеют тип unknown, проверить категории типов, принимаемых
в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать
категорию string, если какой-либо кандидат принимает эту категорию. (Эта склонность
к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта
категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать
её; в противном случае констатировать неудачу — сделать правильный выбор без дополни-
тельных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы вы-
бранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из
этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для
данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если
3
Этот шаг нужен для поддержки приведений типов в стиле вызова функции, когда на самом деле соответствующей функции приведения нет. Если такая
функция приведения есть, она обычно называется именем выходного типа и необходимости в особом подходе нет. За дополнительными комментариями
обратитесь к CREATE CAST.
350Преобразование типов
остаётся только один кандидат, использовать его, в противном случае перейти к следую-
щему шагу.
f.
Если в списке аргументов есть аргументы и типа unknown, и известного типа, и этот из-
вестный тип один для всех аргументов, предположить, что аргументы типа unknown также
имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргу-
мента unknown. Если остаётся только один кандидат, использовать его, в противном случае
констатировать неудачу.
Заметьте, что для функций действуют те же правила «оптимального соответствия», что и для опе-
раторов. Они проиллюстрированы следующими примерами.
Пример 10.6. Разрешение функции округления по типам аргументов
В PostgreSQL есть только одна функция round, принимающая два аргумента: первый типа numeric,
а второй — integer. Поэтому в следующем запросе первый аргумент integer автоматически при-
водится к типу numeric:
SELECT round(4, 4);
round
——–
4.0000
(1 row)
Таким образом, анализатор преобразует этот запрос в:
SELECT round(CAST (4 AS numeric), 4);
Так как числовые константы с десятичными точками изначально относятся к типу numeric, для
следующего запроса преобразование типов не потребуется, так что он немного эффективнее:
SELECT round(4.0, 4);
Пример 10.7. Разрешение функций с переменными параметрами
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
LANGUAGE sql AS ‘SELECT 1’;
CREATE FUNCTION
Эта функция принимает в аргументах ключевое слово VARIADIC, но может вызываться и без него.
Ей можно передавать и целочисленные, и любые числовые аргументы:
SELECT public.variadic_example(0),
public.variadic_example(0.0),
public.variadic_example(VARIADIC array[0.0]);
variadic_example | variadic_example | variadic_example
——————+——————+——————
1 |
1 |
1
(1 row)
Однако для первого и второго вызова предпочтительнее окажутся специализированные функции,
если таковые есть:
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
LANGUAGE sql AS ‘SELECT 2’;
CREATE FUNCTION
CREATE FUNCTION public.variadic_example(int) RETURNS int
LANGUAGE sql AS ‘SELECT 3’;
CREATE FUNCTION
SELECT public.variadic_example(0),
public.variadic_example(0.0),
351Преобразование типов
public.variadic_example(VARIADIC array[0.0]);
variadic_example | variadic_example | variadic_example
——————+——————+——————
3 |
2 |
1
(1 row)
Если используется конфигурация по умолчанию и существует только первая функция, первый и
второй вызовы будут небезопасными. Любой пользователь может перехватить их, создав вторую
или третью функцию. Безопасным будет третий вызов, в котором тип аргумента соответствует в
точности и используется ключевое слово VARIADIC.
Пример 10.8. Разрешение функции извлечения подстроки
В PostgreSQL есть несколько вариантов функции substr, и один из них принимает аргументы типов
text и integer. Если эта функция вызывается со строковой константой неопределённого типа, си-
стема выбирает функцию, принимающую аргумент предпочитаемой категории string (а конкрет-
нее, типа text).
SELECT substr(‘1234’, 3);
substr
——–
34
(1 row)
Если текстовая строка имеет тип varchar, например когда данные поступают из таблицы, анали-
затор попытается привести её к типу text:
SELECT substr (varchar ‘1234’, 3);
substr
——–
34
(1 row)
Этот запрос анализатор фактически преобразует в:
SELECT substr(CAST (varchar ‘1234’ AS text), 3);
Примечание
Анализатор узнаёт из каталога pg_cast, что типы text и varchar двоично-совместимы,
что означает, что один тип можно передать функции, принимающей другой, не выпол-
няя физического преобразования. Таким образом, в данном случае операция преобра-
зования на самом не добавляется.
И если функция вызывается с аргументом типа integer, анализатор попытается преобразовать
его в тип text:
SELECT substr(1234, 3);
ОШИБКА: функция substr(integer, integer) не существует
ПОДСКАЗКА: Функция с данными именем и типами аргументов не найдена. Возможно, вам
следует добавить явные преобразования типов.
Этот вариант не работает, так как integer нельзя неявно преобразовать в text. Однако с явным
преобразованием запрос выполняется:
SELECT substr(CAST (1234 AS text), 3);
substr
——–
352Преобразование типов
34
(1 row)
10.4. Хранимое значение
Значения, вставляемые в таблицу, преобразуется в тип данных целевого столбца по следующему
алгоритму.
Преобразование по типу хранения&lt;/li&gt;
  &lt;li&gt;Проверить точное совпадение с целевым типом.&lt;/li&gt;
  &lt;li&gt;Если типы не совпадают, попытаться привести тип к целевому. Это возможно, если в каталоге
pg_cast (см. CREATE CAST) зарегистрировано приведение присваивания между двумя типами.
Если же результат выражения — строка неизвестного типа, содержимое этой строки будет
подано на вход процедуре ввода целевого типа.&lt;/li&gt;
  &lt;li&gt;Проверить, не требуется ли приведение размера для целевого типа. Приведение размера — это
преобразование типа к такому же. Если это приведение описано в каталоге pg_cast, приме-
нить к его к результату выражения, прежде чем сохранить в целевом столбце. Функция, реали-
зующая такое приведение, всегда принимает дополнительный параметр типа integer, в кото-
ром передаётся значение atttypmod для целевого столбца (обычно это её объявленный размер,
хотя интерпретироваться значение atttypmod для разных типов данных может по-разному), и
третий параметр типа boolean, передающий признак явное/неявное преобразование. Функция
приведения отвечает за все операции с длиной, включая её проверку и усечение данных.
Пример 10.9. Преобразование для типа хранения character
Следующие запросы показывают, что сохраняемое значение подгоняется под размер целевого
столбца, объявленного как character(20):
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT ‘abc’ || ‘def’;
SELECT v, octet_length(v) FROM vv;
v
| octet_length
———————-+————–
abcdef
|
20
(1 row)
Суть происходящего здесь в том, что две константы неизвестного типа по умолчанию воспринима-
ются как значения text, что позволяет применить к ним оператор || как оператор конкатенации
значений text. Затем результат оператора, имеющий тип text, приводится к типу bpchar («blank-
padded char» (символы, дополненные пробелами), внутреннее имя типа character) в соответствии
с типом целевого столбца. (Так как типы text и bpchar двоично-совместимы, при этом преобразо-
вании реальный вызов функции не добавляется.) Наконец, в системном каталоге находится функ-
ция изменения размера bpchar(bpchar, integer, boolean) и применяется для результата опера-
тора и длины столбца. Эта связанная с типом функция проверяет длину данных и добавляет недо-
стающие пробелы.
10.5. UNION, CASE и связанные конструкции
SQL-конструкция UNION взаимодействует с системой типов, так как ей приходится объединять зна-
чения возможно различных типов в единый результирующий набор. Алгоритм разрешения типов
при этом применяется независимо к каждому отдельному столбцу запроса. Подобным образом
различные типы сопоставляются при выполнении INTERSECT и EXCEPT сопоставляют различные
типы подобно UNION. По такому же алгоритму сопоставляют типы выражений и определяют тип
своего результата конструкции CASE, ARRAY, VALUES, GREATEST и LEAST.
Разрешение типов для UNION, CASE и связанных конструкций
1.
Если все данные одного типа и это не тип unknown, выбрать его.
353Преобразование типов
4&lt;/li&gt;
  &lt;li&gt;Если тип данных — домен, далее считать их типом базовый тип домена.&lt;/li&gt;
  &lt;li&gt;Если все данные типа unknown, выбрать для результата тип text (предпочитаемый для катего-
рии string). В противном случае значения unknown для остальных правил игнорируются.&lt;/li&gt;
  &lt;li&gt;Если известные типы входных данных оказываются не из одной категории, констатировать
неудачу.&lt;/li&gt;
  &lt;li&gt;Выбрать первый известный предпочитаемый тип из этой категории, если такой есть.&lt;/li&gt;
  &lt;li&gt;В противном случае выбрать последний известный тип, в который можно неявно преобразовать
все данные предшествующих известных типов. (Такой тип есть всегда, в крайнем случае этому
условию удовлетворяет первый тип.)&lt;/li&gt;
  &lt;li&gt;Привести все данные к выбранном типу. Констатировать неудачу, если для каких-либо данных
преобразование в этот тип невозможно.
Ниже это проиллюстрировано на примерах.
Пример 10.10. Разрешение типов с частичным определением в Union
SELECT text ‘a’ AS “text” UNION SELECT ‘b’;
text
——
a
b
(2 rows)
В данном случае константа ‘b’ неизвестного типа будет преобразована в тип text.
Пример 10.11. Разрешение типов в простом объединении
SELECT 1.2 AS “numeric” UNION SELECT 1;
numeric
———
1
1.2
(2 rows)
Константа 1.2 имеет тип numeric и целочисленное значение 1 может быть неявно приведено к
типу numeric, так что используется этот тип.
Пример 10.12. Разрешение типов в противоположном объединении
SELECT 1 AS “real” UNION SELECT CAST(‘2.2’ AS REAL);
real
——
1
2.2
(2 rows)
Здесь значение типа real нельзя неявно привести к integer, но integer можно неявно привести
к real, поэтому типом результата объединения будет real.
Пример 10.13. Разрешение типов во вложенном объединении
SELECT NULL UNION SELECT NULL UNION SELECT 1;
ERROR:
UNION types text and integer cannot be matched
4
Так же, как домены воспринимаются при выборе операторов и функций, доменные типы могут сохраняться в конструкции UNION или подобной, если
пользователь позаботится о том, чтобы все входные данные приводились к этому типу явно или неявно. В противном случае предпочтение будет отдано
базовому типу домена.
354Преобразование типов
Эта ошибка возникает из-за того, что PostgreSQL воспринимает множественные UNION как пары с
вложенными операциями, то есть как запись
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
Внутренний UNION разрешается как выдающий тип text, согласно правилам, приведённым выше.
Затем внешний UNION получает на вход типы text и integer, что и приводит к показанной ошибке.
Эту проблему можно устранить, сделав так, чтобы у самого левого UNION минимум с одной стороны
были данные желаемого типа результата.
Операции INTERSECT и EXCEPT также разрешаются по парам. Однако остальные конструкции, опи-
санные в этом разделе, рассматривают все входные данные сразу.
10.6. Выходные столбцы SELECT
Правила, описанные в предыдущих разделах, распространяются на присвоение типов данных, кро-
ме unknown, во всех выражениях в запросах SQL, за исключением бестиповых буквальных значе-
ний, принимающих вид простых выходных столбцов команды SELECT. Например, в запросе
SELECT ‘Hello World’;
ничто не говорит о том, какой тип должно принимать строковое буквальное значение. В этой си-
туации PostgreSQL разрешит тип такого значения как text.
Когда SELECT является одной из ветвей конструкции UNION (или INTERSECT/EXCEPT) или когда он
находится внутри INSERT … SELECT, это правило не действует, так как более высокий приоритет
имеют правила, описанные в предыдущих разделах. В первом случае тип бестипового буквального
значения может быть получен из другой ветви UNION, а во втором — из целевого столбца.
Списки RETURNING в данном контексте воспринимаются так же, как выходные списки SELECT.
Примечание
До PostgreSQL 10 этого правила не было и бестиповые буквальные значения в выход-
ном списке SELECT оставались с типом unknown. Это имело различные негативные по-
следствия, так что было решено это изменить.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="PostgreSQL" /><category term="PostgreSQL_Book_11" /><summary type="html">Глава 10. Преобразование типов</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22abstract-11.jpg%22%7D" /></entry></feed>