---
layout: page
title: Глава 57. Написание обёртки сторонних данных
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 57. Написание обёртки сторонних данных


Все операции со сторонней таблицей производятся через созданную для неё обёртку сторонних
данных, представляющую собой набор подпрограмм, которые вызывает ядро сервера. Обёртка сто-
ронних данных отвечает за получение данных из удалённого источника данных и передачу их ис-
полнителю запросов PostgreSQL. Чтобы поддерживалось изменение данных в сторонних таблицах,
эту операцию также должна выполнять обёртка. В данной главе освещается написание обёртки
сторонних данных.
Реализация обёрток сторонних данных, включённых в стандартный дистрибутив, может послу-
жить хорошим примером при написании собственных обёрток. Её вы можете найти в подкатало-
ге contrib дерева исходного кода. Некоторые полезные детали также можно узнать на странице
справки CREATE FOREIGN DATA WRAPPER.
Примечание
В стандарте SQL описан интерфейс для написания обёрток сторонних данных, но
PostgreSQL не реализует его, так как это потребовало бы больших усилий, а данный
стандартизированный API всё равно не получил широкого распространения.
57.1. Функции обёрток сторонних данных
Автор FDW (Foreign Data Wrapper, Обёртки сторонних данных) должен реализовать функцию-обра-
ботчик и может дополнительно добавить функцию проверки. Обе функции должны быть написаны
на компилируемом языке, таком как C, и использовать интерфейс версии 1. Подробнее соглаше-
ние о вызовах и динамическая загрузка кода на C описывается в Разделе 38.10.
Функция-обработчик просто возвращает структуру с указателями на реализующие подпрограммы,
которые будут вызываться планировщиком, исполнителем и различными служебными командами.
Основная часть разработки FDW заключается в написании этих реализующих подпрограмм. Функ-
ция-обработчик должна быть зарегистрирована в PostgreSQL как функция без аргументов, возвра-
щающая специальный псевдотип fdw_handler. Реализующие подпрограммы представляют собой
обычные функции на C, которые не видны и не могут вызываться на уровне SQL. Они описаны в
Разделе 57.2.
Функция проверки отвечает за проверку параметров, передаваемых с командами CREATE и ALTER
для этой обёртки сторонних данных, а также параметров сторонних серверов, сопоставлений
пользователей и сторонних таблиц, доступных через эту обёртку. Эта функция должна быть за-
регистрирована как принимающая два аргумента: текстовый массив, содержащий параметры
для проверки, и OID, представляющий тип объекта, с которым связаны эти параметры (в виде
OID системного каталога, в котором будет сохраняться объект: ForeignDataWrapperRelationId,
ForeignServerRelationId, UserMappingRelationId или ForeignTableRelationId). Если функция
проверки отсутствует, параметры не проверяются ни при создании, ни при изменении объекта.
57.2. Подпрограммы обёртки сторонних данных
Функция-обработчик FDW возвращает структуру FdwRoutine (выделенную с помощью palloc), со-
держащую указатели на подпрограммы, которые реализуют описанные ниже функции. Из всех
функций обязательными являются только те, что касаются сканирования, а остальные могут от-
сутствовать.
Тип структуры FdwRoutine объявлен в src/include/foreign/fdwapi.h, там же можно узнать до-
полнительные подробности.
2088Написание обёрт-
ки сторонних данных
57.2.1. Подпрограммы FDW для сканирования сторонних таблиц
void
GetForeignRelSize(PlannerInfo *root,
RelOptInfo *baserel,
Oid foreigntableid);
Выдаёт оценку размера отношения для сторонней таблицы. Она вызывается в начале планирова-
ния запроса, в котором сканируется сторонняя таблица. В параметре root передаётся общая ин-
формация планировщика о запросе, в baserel — информация о данной таблице, а в foreigntableid
— OID записи в pg_class для данной таблицы. (Значение foreigntableid можно получить и из
структуры данных планировщика, но простоты ради оно передаётся явно.)
Эта функция должна записать в baserel->rows ожидаемое число строк, которое будет получено
при сканировании таблицы, с учётом фильтра, заданного ограничением выборки. Изначально в
baserel->rows содержится просто постоянная оценка по умолчанию, которую следует заменить,
если это вообще возможно. Функция также может поменять значение baserel->width, если она
может дать лучшую оценку средней ширины строки результата.
За дополнительными сведениями обратитесь к Разделу 57.4.
void
GetForeignPaths(PlannerInfo *root,
RelOptInfo *baserel,
Oid foreigntableid);
Формирует возможные пути доступа для сканирования сторонней таблицы. Эта функция вызывает-
ся при планировании запроса. Ей передаются те же параметры, что и функции GetForeignRelSize,
которая к этому времени уже будет вызвана.
Эта функция должна выдать минимум один путь доступа (узел ForeignPath) для скани-
рования сторонней таблицы и должна вызвать add_path, чтобы добавить каждый такой
путь в baserel->pathlist. Для формирования узлов ForeignPath рекомендуется вызывать
create_foreignscan_path. Данная функция может выдавать несколько путей доступа, то есть пу-
тей, для которых по заданным pathkeys можно получить уже отсортированный результат. Каждый
путь доступа должен содержать оценки стоимости и может содержать любую частную информа-
цию FDW, необходимую для выбора целевого метода сканирования.
За дополнительными сведениями обратитесь к Разделу 57.4.
ForeignScan *
GetForeignPlan(PlannerInfo *root,
RelOptInfo *baserel,
Oid foreigntableid,
ForeignPath *best_path,
List *tlist,
List *scan_clauses,
Plan *outer_plan);
Создаёт узел плана ForeignScan из выбранного пути доступа к сторонней таблице. Эта функ-
ция вызывается в конце планирования запроса. Ей передаются те же параметры, что и
GetForeignRelSize, плюс выбранный путь ForeignPath (до этого сформированный функциями
GetForeignPaths, GetForeignJoinPaths или GetForeignUpperPaths), целевой список, который дол-
жен быть выдан этим узлом плана, условия ограничения, которые должны применяться для дан-
ного узла, и внешний вложенный подплан ForeignScan, применяемый для перепроверок, выпол-
няемых функцией RecheckForeignScan. (Если путь задаётся для соединения, а не для базового от-
ношения, в foreigntableid передаётся InvalidOid.)
Эта функция должна создать и выдать узел плана ForeignScan; для формирования этого узла ре-
комендуется использовать make_foreignscan.
2089Написание обёрт-
ки сторонних данных
За дополнительными сведениями обратитесь к Разделу 57.4.
void
BeginForeignScan(ForeignScanState *node,
int eflags);
Начинает сканирование сторонней таблицы. Эта функция вызывается при запуске исполнителя.
Она должна выполнить все подготовительные действия, необходимые для осуществления сканиро-
вания, но не должна собственно производить сканирование (оно должно начаться с первым вызо-
вом IterateForeignScan). Узел ForeignScanState уже был создан, но его поле fdw_state по-преж-
нему NULL. Информацию о сканируемой таблице можно получить через узел ForeignScanState (в
частности, из нижележащего узла ForeignScan, содержащего частную информацию FDW, задан-
ную функцией GetForeignPlan). Параметр eflags содержит битовые флаги, описывающие режим
работы исполнителя для этого узла плана.
Заметьте, что когда (eflags & EXEC_FLAG_EXPLAIN_ONLY) не равно нулю, эта функция не должна
выполнять какие-либо внешне проявляющиеся действия; она должна сделать только то, что необ-
ходимо для получения состояния узла, подходящего для ExplainForeignScan и EndForeignScan.
TupleTableSlot *
IterateForeignScan(ForeignScanState *node);
Выбирает одну строку из стороннего источника и возвращает её в слоте таблицы кортежей (для
этой цели следует использовать ScanTupleSlot, переданный с узлом). Когда строки заканчива-
ются, возвращает NULL. Инфраструктура слотов таблицы кортежей позволяет возвращать как
физические, так и виртуальные кортежи; в большинстве случаев второй вариант предпочтитель-
нее с точки зрения производительности. Заметьте, что эта функция вызывается в контексте крат-
ковременной памяти, который будет сбрасываться между вызовами. Если вам нужна более дол-
гоживущая память, создайте соответствующий контекст в BeginForeignScan либо используйте
es_query_cxt из структуры EState, переданной с узлом.
Возвращаемые строки должны соответствовать целевому списку fdw_scan_tlist, если он переда-
ётся, а в противном случае — типу строки сканируемой сторонней таблицы. Если вы решите для
оптимизации не возвращать ненужные столбцы, в их позиции нужно вставить NULL, либо сформи-
ровать список fdw_scan_tlist без этих столбцов.
Заметьте, что для исполнителя PostgreSQL не важно, удовлетворяют ли возвращаемые строки ка-
ким-либо ограничениям, определённым для сторонней таблицы — но это важно для планировщи-
ка, так что запросы могут оптимизироваться некорректно, если в сторонней таблице будут видны
строки, не удовлетворяющие объявленному ограничению. Если ограничение нарушается, тогда
как пользователь объявил, что оно должно выполняться, может быть уместно сообщить об ошибке
(точно так же, как и при несовпадении типов данных).
void
ReScanForeignScan(ForeignScanState *node);
Перезапускает сканирование с начала. Заметьте, что значения параметров, от которых зависит
сканирование, могли измениться, так что новое сканирование не обязательно вернёт те же строки.
void
EndForeignScan(ForeignScanState *node);
Завершает сканирование и освобождает ресурсы. Обычно при этом не нужно освобождать память,
выделенную через palloc, но например, открытые файлы и подключения к удалённым серверам
следует закрыть.
57.2.2. Подпрограммы FDW для сканирования сторонних соедине-
ний
Если FDW поддерживает соединения на удалённой стороне (вместо того, чтобы считывать данные
обеих таблиц и выполнять соединения локально), она должна предоставить эту реализующую под-
программу:
2090Написание обёрт-
ки сторонних данных
void
GetForeignJoinPaths(PlannerInfo *root,
RelOptInfo *joinrel,
RelOptInfo *outerrel,
RelOptInfo *innerrel,
JoinType jointype,
JoinPathExtraData *extra);
Формирует возможные пути доступа для соединения двух (и более) сторонних таблиц, принадле-
жащих одному стороннему серверу. Эта необязательная функция вызывается во время планирова-
ния запроса. Как и GetForeignPaths, эта функция должна построить путь(и) ForeignPath для пе-
реданного joinrel и вызвать add_path, чтобы добавить эти пути в набор путей, подходящих для со-
единения. Но, в отличие от GetForeignPaths, эта функция не обязательно должна возвращать ми-
нимум один путь, так как всегда возможен альтернативный путь с локальным соединением таблиц.
Заметьте, что эта функция будет вызываться неоднократно для одного и того же соединения с раз-
ными комбинациями внутреннего и внешнего отношений; минимизировать двойную работу долж-
на сама FDW.
Если для соединения выбирается путь ForeignPath, он будет представлять весь процесс соедине-
ния; пути, сформированные для задействованных таблиц и подчинённых соединений, в нём при-
меняться не будут. Далее этот путь соединения обрабатывается во многом так же, как и путь ска-
нирования одной сторонней таблицы. Одно различие состоит в том, что scanrelid результирую-
щего плана узла ForeignScan должно быть равно нулю, так как он не представляет какое-либо
одно отношение; вместо этого набор соединяемых отношений представляется в поле fs_relids
узла ForeignScan. (Это поле заполняется автоматически кодом ядра планировщика, так что FDW
делать это не нужно.) Ещё одно отличие в том, что список столбцов для удалённого соединения
нельзя получить из системных каталогов и поэтому FDW должна выдать в fdw_scan_tlist требу-
емый список узлов TargetEntry, представляющий набор столбцов, которые будут выдаваться во
время выполнения в возвращаемых кортежах.
За дополнительными сведениями обратитесь к Разделу 57.4.
57.2.3. Подпрограммы FDW для планирования обработки после
сканирования/соединения
Если FDW поддерживает удалённое выполнение операций после сканирования/соединения, на-
пример, удалённое агрегирование, она должна предоставить эту реализующую подпрограмму:
void
GetForeignUpperPaths(PlannerInfo *root,
UpperRelationKind stage,
RelOptInfo *input_rel,
RelOptInfo *output_rel,
void *extra);
Формирует возможные пути доступа для обработки верхнего отношения. Этот термин планиров-
щика подразумевает любую обработку запросов после сканирования/соединения, в частности, аг-
регирование, вычисление оконных функций, сортировку и изменение таблиц. Эта необязательная
функция вызывается во время планирования запроса. В настоящее время она вызывается, только
если все базовые отношения, задействованные в запросе, относятся к одной FDW. Эта функция
должна построить путь(и) ForeignPath для любых действий после сканирования/соединения, ко-
торые FDW умеет выполнять удалённо, и вызвать add_path, чтобы добавить эти пути к указанному
верхнему отношению. Как и GetForeignJoinPaths, эта функция не обязательно должна возвращать
какие-либо пути, так как всегда возможны пути с локальной обработкой.
Параметр stage определяет, какой шаг после сканирования/соединения рассматривается в дан-
ный момент. Параметр output_rel указывает на верхнее отношение, которое должно получить пу-
ти, представляющие вычисление этого шага, а input_rel — на отношение, представляющее вход-
ные данные для этого шага. В параметре extra передаётся дополнительная информация; в настоя-
2091Написание обёрт-
ки сторонних данных
щее время он устанавливается только для UPPERREL_PARTIAL_GROUP_AGG и UPPERREL_GROUP_AGG, и в
этом случае указывает на структуру GroupPathExtraData. (Заметьте, что пути ForeignPath, добав-
ляемые в output_rel, обычно не будут напрямую зависеть от путей input_rel, так как ожидается,
что они будут обрабатываться снаружи. Однако изучить пути, построенные для предыдущего шага
обработки, может быть полезно для исключения лишних операций при планировании.)
За дополнительными сведениями обратитесь к Разделу 57.4.
57.2.4. Подпрограммы FDW для изменения данных в сторонних
таблицах
Если FDW поддерживает запись в сторонние таблицы, она должна предоставить некоторые или
все подпрограммы, реализующие следующие функции, в зависимости от потребностей и возмож-
ностей FDW:
void
AddForeignUpdateTargets(Query *parsetree,
RangeTblEntry *target_rte,
Relation target_relation);
Операции UPDATE и DELETE выполняются со строками, ранее выбранными функциями сканирова-
ния таблицы. FDW может потребоваться дополнительная информация, например, ID строки или
значения столбцов первичного ключа, чтобы точно знать, какую именно строку нужно изменить
или удалить. Для этого данная функция может добавить дополнительные скрытые или «отбросо-
вые» целевые столбцы в список столбцов, которые должны быть получены из сторонней таблицы
во время UPDATE или DELETE.
Для этого добавьте в parsetree->targetList элементы TargetEntry, содержащие выражения для
дополнительных выбираемых значений. У каждой такой записи должен быть признак resjunk
= true и должно быть отдельное собственное имя resname, по которому она будет иденти-
фицироваться во время выполнения. Избегайте использования имён вида ctidN, wholerow или
wholerowN, так как столбцы с такими именами может генерировать ядро системы. Если допол-
нительные выражения сложнее, чем просто переменные, их нужно пропустить через функцию
eval_const_expressions прежде чем добавлять в целевой список.
Хотя эта функция вызывается во время планирования, передаваемая ей информация несколько
отличается от той, что получают другие подпрограммы планирования. В parsetree передаётся
дерево разбора команды UPDATE или DELETE, а параметры target_rte и target_relation описывают
целевую стороннюю таблицу.
Если указатель AddForeignUpdateTargets равен NULL, дополнительные целевые выражения не до-
бавляются. (Это делает невозможным реализацию операций DELETE, хотя операция UPDATE может
быть всё же возможна, если FDW идентифицирует строки, полагаясь на то, что первичный ключ
не меняется.)
List *
PlanForeignModify(PlannerInfo *root,
ModifyTable *plan,
Index resultRelation,
int subplan_index);
Выполняет любые дополнительные действия планирования, необходимые для добавления, изме-
нения или удаления в сторонней таблице. Эта функция формирует частную информацию FDW, ко-
торая будет добавлена в узел плана ModifyTable, осуществляющий изменение. Эта информация
должна возвращаться в списке (List); она будет доставлена в функцию BeginForeignModify на
стадии выполнения.
В root передаётся общая информация планировщика о запросе, а в plan — узел плана ModifyTable,
заполненный, не считая поля fdwPrivLists. Параметр resultRelation указывает на целевую сто-
роннюю таблицу по номеру в списке отношений, а subplan_index определяет целевое отношение
2092Написание обёрт-
ки сторонних данных
в данном узле ModifyTable, начиная с нуля; воспользуйтесь этим индексом, обращаясь к plan-
>plans или другой вложенной структуре узла plan.
За дополнительными сведениями обратитесь к Разделу 57.4.
Если указатель PlanForeignModify равен NULL, дополнительные действия во время планирования
не предпринимаются, и в качестве fdw_private в BeginForeignModify поступит NULL.
void
BeginForeignModify(ModifyTableState *mtstate,
ResultRelInfo *rinfo,
List *fdw_private,
int subplan_index,
int eflags);
Начинает выполнение операции изменения данных в сторонней таблице. Эта подпрограмма
выполняется при запуске исполнителя. Она должна выполнять любые подготовительные дей-
ствия, необходимые для того, чтобы собственно произвести изменения в таблице. Впоследствии
для каждого кортежа, который будет вставляться, изменяться или удаляться, будет вызываться
ExecForeignInsert, ExecForeignUpdate или ExecForeignDelete.
В параметре mtstate передаётся общее состояние выполняемого плана узла ModifyTable; через
эту структуру доступны глобальные сведения о плане и состояние выполнения. В rinfo переда-
ётся структура ResultRelInfo, описывающая целевую стороннюю таблицу. (Если FDW нужно со-
хранить частное состояние, необходимое для этой операции, она может воспользоваться полем
ri_FdwState структуры ResultRelInfo.) В fdw_private передаются частные данные, если они были
сформированы процедурой PlanForeignModify. Параметр subplan_index определяет целевое от-
ношение в данном узле ModifyTable, а в eflags передаются битовые флаги, описывающие режим
работы исполнителя для этого узла плана.
Заметьте, что когда (eflags & EXEC_FLAG_EXPLAIN_ONLY) не равно нулю, эта функция не должна вы-
полнять какие-либо внешне проявляющиеся действия; она должна сделать только то, что необхо-
димо для получения состояния узла, подходящего для ExplainForeignModify и EndForeignModify.
Если указатель на BeginForeignModify равен NULL, никакое действие при запуске исполнителя не
выполняется.
TupleTableSlot *
ExecForeignInsert(EState *estate,
ResultRelInfo *rinfo,
TupleTableSlot *slot,
TupleTableSlot *planSlot);
Вставляет один кортеж в стороннюю таблицу. В estate передаётся глобальное состояние выпол-
нения запроса, а в rinfo — структура ResultRelInfo, описывающая целевую стороннюю таблицу.
Параметр slot содержит кортеж, который должен быть вставлен; он будет соответствовать опре-
делению типа строки сторонней таблицы. Параметр planSlot содержит кортеж, сформированный
вложенным планом узла ModifyTable; он отличается от slot тем, что может содержать допол-
нительные «отбросовые» столбцы. (Значение planSlot обычно не очень интересно для операций
INSERT, но оно представлено для полноты.)
Возвращаемым значением будет либо слот, содержащий данные, которые были фактически встав-
лены (они могут отличаться от переданных данных, например, в результате действий триггеров),
либо NULL, если никакая строка фактически не была вставлена (опять же, обычно в результате
действий триггеров). Чтобы вернуть результат, также можно использовать передаваемый на вход
slot.
Данные в возвращаемом слоте используются, только если запрос INSERT содержит предложение
RETURNING или для сторонней таблицы определён триггер AFTER ROW. Триггерам нужны все столб-
цы, но для предложения RETURNING FDW может ради оптимизации не возвращать некоторые или
2093Написание обёрт-
ки сторонних данных
все столбцы, в зависимости от его содержания. Так или иначе, какой-либо слот необходимо вер-
нуть, чтобы отметить, что операция успешна, иначе возвращённое число строк будет неверным.
Если указатель на ExecForeignInsert равен NULL, вставить данные в стороннюю таблицу не удаст-
ся, в ответ будет выдаваться сообщение об ошибке.
TupleTableSlot *
ExecForeignUpdate(EState *estate,
ResultRelInfo *rinfo,
TupleTableSlot *slot,
TupleTableSlot *planSlot);
Изменяет один кортеж в сторонней таблице. В estate передаётся глобальное состояние выполне-
ния запроса, а в rinfo — структура ResultRelInfo, описывающая целевую стороннюю таблицу.
Параметр slot содержит новые данные для кортежа; он будет соответствовать определению типа
строки сторонней таблицы. Параметр planSlot содержит кортеж, сформированный вложенным
планом узла ModifyTable; он отличается от slot тем, что может содержать дополнительные «от-
бросовые» столбцы. В частности, в этом слоте можно получить любые отбросовые столбцы, запро-
шенные в AddForeignUpdateTargets.
Возвращаемым значением будет либо слот, содержащий строку в состоянии после изменения (её
содержимое может отличаться от переданного, например, в результате действий триггеров), либо
NULL, если никакая строка фактически не была изменена (опять же, обычно в результате действий
триггеров). Чтобы вернуть результат, также можно использовать передаваемый на вход slot.
Данные в возвращаемом слоте используются, только если запрос UPDATE содержит предложение
RETURNING или для сторонней таблицы определён триггер AFTER ROW. Триггерам нужны все столб-
цы, но для предложения RETURNING FDW может ради оптимизации не возвращать некоторые или
все столбцы, в зависимости от его содержания. Так или иначе, какой-либо слот необходимо вер-
нуть, чтобы отметить, что операция успешна, иначе возвращённое число строк будет неверным.
Если указатель на ExecForeignUpdate равен NULL, изменить данные в сторонней таблице не удаст-
ся, а в ответ будет выдаваться сообщение об ошибке.
TupleTableSlot *
ExecForeignDelete(EState *estate,
ResultRelInfo *rinfo,
TupleTableSlot *slot,
TupleTableSlot *planSlot);
Удаляет один кортеж из сторонней таблицы. В estate передаётся глобальное состояние выполне-
ния запроса, а в rinfo — структура ResultRelInfo, описывающая целевую стороннюю таблицу.
Параметр slot при вызове не содержит ничего полезного, но в эту структуру можно поместить
возвращаемый кортеж. Параметр planSlot содержит кортеж, сформированный вложенным пла-
ном узла ModifyTable; в частности, в нём могут содержаться отбросовые столбцы, запрошенные
в AddForeignUpdateTargets. Отбросовые столбцы необходимы, чтобы определить, какой именно
кортеж удалять.
Возвращаемым значением будет либо слот, содержащий строку, которая была удалена, либо NULL,
если не удалена никакая строка (обычно в результате действия триггеров). Для размещения воз-
вращаемого кортежа можно использовать передаваемый на вход slot.
Данные в возвращаемом слоте используются, только если запрос DELETE содержит предложение
RETURNING или для сторонней таблицы определён триггер AFTER ROW. Триггерам нужны все столб-
цы, но для предложения RETURNING FDW может ради оптимизации не возвращать некоторые или
все столбцы, в зависимости от его содержания. Так или иначе, какой-либо слот необходимо вер-
нуть, чтобы отметить, что операция успешна, иначе возвращённое число строк будет неверным.
Если указатель на ExecForeignDelete равен NULL, удалить данные из сторонней таблицы не удаст-
ся, а в ответ будет выдаваться сообщение об ошибке.
2094Написание обёрт-
ки сторонних данных
void
EndForeignModify(EState *estate,
ResultRelInfo *rinfo);
Завершает изменение данных в таблице и освобождает ресурсы. Обычно при этом не нужно осво-
бождать память, выделенную через palloc, но например, открытые файлы и подключения к уда-
лённым серверам следует закрыть.
Если указатель на EndForeignModify равен NULL, никакое действие при завершении исполнителя
не выполняется.
Кортежи, вставляемые в секционированную таблицу командами INSERT и COPY FROM, направляют-
ся в соответствующие секции. Если обёртка сторонних данных поддерживает перенаправление в
секции в сторонних таблицах, она также должна предоставить описанные ниже обработчики. Эти
функции также вызываются, когда результат COPY FROM помещается в стороннюю таблицу.
void
BeginForeignInsert(ModifyTableState *mtstate,
ResultRelInfo *rinfo);
Начинает выполнение операции добавления данных в сторонней таблице. Эта подпрограмма вы-
зывается непосредственно перед тем, как первый кортеж будет вставлен в стороннюю таблицу
— и когда это секция, выбранная для размещения кортежа, и когда это целевое отношение ко-
манды COPY FROM. Она должна выполнять любые подготовительные действия, необходимые перед
собственно добавлением данных. Впоследствии для каждого кортежа, добавляемого в стороннюю
таблицу, будет вызываться обработчик ExecForeignInsert.
В параметре mtstate передаётся общее состояние выполняемого плана узла ModifyTable; через
эту структуру доступна глобальная информация о плане и состоянии выполнения. В rinfo пере-
даётся структура ResultRelInfo, описывающая целевую стороннюю таблицу. (Если FDW нужно
сохранить частное состояние, необходимое для этой операции, она может воспользоваться полем
ri_FdwState структуры ResultRelInfo.)
Когда этот обработчик вызывается командой COPY FROM, связанные с планом глобальные данные
в mtstate не передаются. При этом параметр planSlot обработчика ExecForeignInsert, впослед-
ствии вызываемого для каждого вставляемого кортежа, равен NULL — и когда сторонняя таблица
является секцией, выбранной для помещения кортежа, и когда это целевое отношение данной ко-
манды.
Если указатель на BeginForeignInsert равен NULL, никакое действие при инициализации не вы-
полняется.
void
EndForeignInsert(EState *estate,
ResultRelInfo *rinfo);
Завершает операцию добавления и освобождает ресурсы. Обычно при этом не нужно освобождать
память, выделенную через palloc, но например, открытые файлы и подключения к удалённым сер-
верам следует закрыть.
Если указатель на EndForeignInsert равен NULL, никакое действие при завершении не выполня-
ется.
int
IsForeignRelUpdatable(Relation rel);
Сообщает, какие операции изменения данных поддерживает указанная сторонняя таблица. Воз-
вращаемое значение должно быть битовой маской кодов событий, обозначающих операции, под-
держиваемые таблицей, и заданных в перечислении CmdType; то есть, (1 << CMD_UPDATE) = 4 для
UPDATE, (1 << CMD_INSERT) = 8 для INSERT и (1 << CMD_DELETE) = 16 для DELETE.
2095Написание обёрт-
ки сторонних данных
Если указатель на IsForeignRelUpdatable равен NULL, предполагается, что сторонние таблицы
позволяют добавлять, изменять и удалять строки, если FDW предоставляет процедуры для функ-
ций ExecForeignInsert, ExecForeignUpdate или ExecForeignDelete, соответственно. Данная функ-
ция необходима, только если FDW поддерживает операции изменения для одних таблиц и не под-
держивает для других. (Хотя для этого можно выдать ошибку в подпрограмме, выполняющей опе-
рацию, а не задействовать эту функцию. Однако данная функция позволяет корректно отражать
поддержку изменений в представлениях information_schema.)
Некоторые операции добавления, изменений и удаления данных в сторонних таблицах можно соп-
тимизировать, применив альтернативный набор интерфейсов. Обычные интерфейсы для операций
добавления, изменения и удаления выбирают строки с удалённого сервера, а затем модифицируют
их по одной. В некоторых случаях такой подход «строка-за-строкой» необходим, но он может быть
не самым эффективным. Если есть возможность определить на стороннем сервере, какие строки
должны модифицироваться, собственно не считывая их, и если никакие локальные триггеры этой
операцией не затрагиваются, то возможно организовать операцию так, чтобы она выполнялась це-
ликом на удалённом сервере. Это становится возможным благодаря описанным ниже интерфей-
сам.
bool
PlanDirectModify(PlannerInfo *root,
ModifyTable *plan,
Index resultRelation,
int subplan_index);
Определяет, возможно ли безопасно выполнить прямую модификацию на удалённом сервере. Ес-
ли да, возвращает true, произведя требуемые для этого операции планирования. В противном
случае возвращает false. Эта необязательная функция вызывается во время планирования за-
проса. Если результат этой функции положительный, на стадии выполнения будут вызываться
BeginDirectModify, IterateDirectModify и EndDirectModify. Иначе модификация таблиц будет
осуществляться посредством функций изменения, описанных выше. Данная функция принимает
те же параметры, что и PlanForeignModify.
Для осуществления прямой модификации на удалённом сервере эта функция должна подставить
в целевой подплан узел ForeignScan, выполняющий прямую модификацию на удалённом сервере.
В поле operation структуры ForeignScan должно быть установлено соответствующее значение
перечисления CmdType: то есть, CMD_UPDATE для UPDATE, CMD_INSERT для INSERT и CMD_DELETE для
DELETE.
За дополнительными сведениями обратитесь к Разделу 57.4.
Если указатель на PlanDirectModify равен NULL, сервер не будет пытаться произвести прямую
модификацию.
void
BeginDirectModify(ForeignScanState *node,
int eflags);
Подготавливает прямую модификацию на удалённом сервере. Эта функция вызывается при
запуске исполнителя. Она должна выполнить все подготовительные действия, необходимые
для осуществления прямой модификации (модификация должна начаться с первым вызовом
IterateDirectModify). Узел ForeignScanState уже был создан, но его поле fdw_state по-прежне-
му NULL. Информацию о модифицируемой таблице можно получить через узел ForeignScanState
(в частности, из нижележащего узла ForeignScan, содержащего частную информацию FDW, за-
данную функцией PlanDirectModify). Параметр eflags содержит битовые флаги, описывающие
режим работы исполнителя для этого узла плана.
Заметьте, что когда (eflags & EXEC_FLAG_EXPLAIN_ONLY) не равно нулю, эта функция не должна
выполнять какие-либо внешне проявляющиеся действия; она должна сделать только то, что необ-
ходимо для получения состояния узла, подходящего для ExplainDirectModify и EndDirectModify.
2096Написание обёрт-
ки сторонних данных
Если указатель на BeginDirectModify равен NULL, сервер не будет пытаться произвести прямую
модификацию.
TupleTableSlot *
IterateDirectModify(ForeignScanState *node);
Когда в запросе INSERT, UPDATE или DELETE отсутствует предложение RETURNING, просто возвраща-
ет NULL после прямой модификации на удалённом сервере. Когда в запросе есть это предложе-
ние, выбирает одну строку результата с данными, требующимися для вычисления RETURNING, и
возвращает её в слоте таблицы кортежей (для этой цели следует использовать ScanTupleSlot, пе-
реданный с узлом). Данные, которые были фактически добавлены, изменены или удалены, нужно
сохранить в es_result_relation_info->ri_projectReturning->pi_exprContext->ecxt_scantuple
в структуре EState, переданной с узлом. Возвращает NULL, если строк больше нет. Заметьте, что
эта функция вызывается в контексте кратковременной памяти, который будет сбрасываться меж-
ду вызовами. Если вам нужна более долгоживущая память, создайте соответствующий контекст в
BeginDirectModify либо используйте es_query_cxt из переданной с узлом структуры EState.
Возвращаемые строки должны соответствовать целевому списку fdw_scan_tlist, если он переда-
ётся, а в противном случае — типу строки изменяемой сторонней таблицы. Если вы решите для
оптимизации не возвращать ненужные столбцы, не требующиеся для получения RETURNING, в их
позиции нужно вставить NULL, либо сформировать список fdw_scan_tlist без этих столбцов.
Независимо от того, есть ли в запросе это предложение или нет, число строк, возвращаемых за-
просом, должно увеличиваться самой FDW. Когда этого предложения в запросе нет, FDW должна
также увеличивать число строк для узла ForeignScanState в случае EXPLAIN ANALYZE.
Если указатель на IterateDirectModify равен NULL, сервер не будет пытаться произвести прямую
модификацию.
void
EndDirectModify(ForeignScanState *node);
Очищает ресурсы после непосредственной модификации на удалённом сервере. Обычно при этом
не нужно освобождать память, выделенную через palloc, но например, открытые файлы и подклю-
чения к удалённому серверу следует закрыть.
Если указатель на EndDirectModify равен NULL, сервер не будет пытаться произвести прямую мо-
дификацию.
57.2.5. Подпрограммы FDW для блокировки строк
Если FDW желает поддержать функцию поздней блокировки строк (описанную в Разделе 57.5),
она должна предоставить следующие реализующие подпрограммы:
RowMarkType
GetForeignRowMarkType(RangeTblEntry *rte,
LockClauseStrength strength);
Сообщает, какой вариант пометки строк будет использоваться для сторонней таблицы. Здесь rte
представляет узел RangeTblEntry для таблицы, а strength описывает силу блокировки, запрошен-
ную соответствующим предложением FOR UPDATE/SHARE, если оно имеется. Результатом должно
быть значение перечисления RowMarkType.
Эта функция вызывается в процессе планирования запроса для каждой сторонней таблицы, кото-
рая участвует в запросе UPDATE, DELETE или SELECT FOR UPDATE/SHARE, и не является целевой в
запросе UPDATE или DELETE.
Если указатель GetForeignRowMarkType равен NULL, всегда выбирается вариант ROW_MARK_COPY.
(Вследствие этого, функция RefetchForeignRow никогда не будет вызываться, так что и её задавать
не нужно.)
2097Написание обёрт-
ки сторонних данных
За подробностями обратитесь к Разделу 57.5.
HeapTuple
RefetchForeignRow(EState *estate,
ExecRowMark *erm,
Datum rowid,
bool *updated);
Повторно считывает один кортеж из сторонней таблицы после блокировки, если она требует-
ся. В estate передаётся глобальное состояние выполнения запроса. В erm передаётся структура
ExecRowMark, описывающая целевую стороннюю таблицу и тип запрашиваемой блокировки (если
требуется блокировка). Параметр rowid идентифицирует считываемый кортеж. Параметр updated
используется как выходной.
Эта функция должна вернуть копию выбранного кортежа (размещённую в памяти palloc) или NULL,
если получить блокировку строки не удаётся. Тип запрашиваемой блокировки строки определяет-
ся значением erm->markType, которое было до этого возвращено функцией GetForeignRowMarkType.
(Вариант ROW_MARK_REFERENCE означает, что нужно просто повторно выбрать кортеж, не запраши-
вая никакую блокировку, а ROW_MARK_COPY никогда не поступает в эту подпрограмму.)
Кроме того, переменной *updated следует присвоить true, если была считана изменённая версия
кортежа, а не версия, полученная ранее. (Если FDW не знает этого наверняка, рекомендуется
всегда возвращать true.)
Заметьте, что по умолчанию в случае неудачи при попытке получить блокировку строки должна
выдаваться ошибка; значение NULL может возвращаться, только если в erm->waitPolicy выбран
вариант SKIP LOCKED.
В rowid передаётся значение ctid, полученное ранее для строки, которую нужно считать повтор-
но. Хотя значение rowid передаётся в виде Datum, в настоящее время это может быть только tid.
Такой интерфейс функции выбран с расчётом на то, чтобы в будущем в качестве идентификаторов
строк могли приниматься и другие типы данных.
Если указатель на RefetchForeignRow равен NULL, повторно выбрать данные не удастся, в ответ
будет выдаваться сообщение об ошибке.
За подробностями обратитесь к Разделу 57.5.
bool
RecheckForeignScan(ForeignScanState *node,
TupleTableSlot *slot);
Перепроверяет, соответствует ли по-прежнему ранее возвращённый кортеж применимым услови-
ям сканирования и соединения, и возможно выдаёт изменённую версию кортежа. Для обёрток
сторонних данных, которые не выносят соединение наружу, обычно удобнее присвоить этому ука-
зателю NULL и задать fdw_recheck_quals. Однако, когда внешние соединения выносятся наружу,
недостаточно повторно применить к результирующему кортежу проверки, относящиеся ко всем
базовым таблицам, даже если присутствуют все атрибуты, так как невыполнение некоторого усло-
вия может приводить и к обнулению некоторых атрибутов, а не только исключению этого кортежа.
RecheckForeignScan может перепроверить условия и возвратить true, если они по-прежнему вы-
полняются, или false в противном случае, но также она может записать в переданный слот кортеж
на замену предыдущему.
Чтобы вынести соединение наружу, обёртка сторонних данных обычно конструирует альтернатив-
ный план локального соединения, применяемый только для перепроверок; он становится внеш-
ним подпланом узла ForeignScan. Когда требуется перепроверка, может быть выполнен этот под-
план и результирующий кортеж сохранён в слоте. Этот план может не быть эффективным, так
как ни одна базовая таблица не выдаст больше одной строки; например, он может реализовы-
вать все соединения в виде вложенных циклов. Для поиска подходящего локального пути соедине-
ния в существующих путях можно воспользоваться функцией GetExistingLocalJoinPath. Функция
2098Написание обёрт-
ки сторонних данных
GetExistingLocalJoinPath ищет непараметризованный путь в списке путей заданного отношения
соединения. (Если такой путь не находится, она возвращает NULL, и в этом случае обёртка сто-
ронних данных может построить локальный путь сама или решить не создавать пути доступа для
этого соединения.)
57.2.6. Подпрограммы FDW для EXPLAIN
void
ExplainForeignScan(ForeignScanState *node,
ExplainState *es);
Дополняет вывод EXPLAIN для сканирования сторонней таблицы. Эта функция может вызывать
ExplainPropertyText и связанные функции и добавлять поля в вывод EXPLAIN. Поля флагов в es
позволяют определить, что именно выводить, а для выдачи статистики времени выполнения в слу-
чае с EXPLAIN ANALYZE можно проанализировать состояние узла ForeignScanState.
Если указатель ExplainForeignScan равен NULL, никакая дополнительная информация при EXPLAIN
не выводится.
void
ExplainForeignModify(ModifyTableState *mtstate,
ResultRelInfo *rinfo,
List *fdw_private,
int subplan_index,
struct ExplainState *es);
Дополняет вывод EXPLAIN для изменений в сторонней таблице. Эта функция может вызывать
ExplainPropertyText и связанные функции и добавлять поля в вывод EXPLAIN. Поля флагов в es
позволяют определить, что именно выводить, а для выдачи статистики времени выполнения в слу-
чае с EXPLAIN ANALYZE можно проанализировать состояние узла ModifyTableState. Первые четыре
аргумента у этой функции те же, что и у BeginForeignModify.
Если указатель ExplainForeignModify равен NULL, никакая дополнительная информация при
EXPLAIN не выводится.
void
ExplainDirectModify(ForeignScanState *node,
ExplainState *es);
Дополняет вывод EXPLAIN для прямой модификации данных на удалённом сервере. Эта функция
может вызывать ExplainPropertyText и связанные функции и добавлять поля в вывод EXPLAIN.
Поля флагов в es позволяют определить, что именно выводить, а для выдачи статистики времени
выполнения в случае EXPLAIN ANALYZE можно проанализировать состояние узла ForeignScanState.
Если указатель ExplainDirectModify равен NULL, никакая дополнительная информация при
EXPLAIN не выводится.
57.2.7. Подпрограммы FDW для ANALYZE
bool
AnalyzeForeignTable(Relation relation,
AcquireSampleRowsFunc *func,
BlockNumber *totalpages);
Эта функция вызывается, когда для сторонней таблицы выполняется ANALYZE. Если FDW может
собрать статистику для этой сторонней таблицы, эта функция должна вернуть true и передать в
func указатель на функцию, которая будет выдавать строки выборки из таблицы, а в totalpages
ожидаемый размер таблицы в страницах. В противном случае эта функция должна вернуть false.
Если FDW не поддерживает сбор статистики ни для каких таблиц, в AnalyzeForeignTable можно
установить значение NULL.
2099Написание обёрт-
ки сторонних данных
Функция выдачи выборки, если она предоставляется, должна иметь следующую сигнатуру:
int
AcquireSampleRowsFunc(Relation relation,
int elevel,
HeapTuple *rows,
int targrows,
double *totalrows,
double *totaldeadrows);
Она должна выбирать из таблицы максимум targrows строк и помещать их в переданный вызыва-
ющим кодом массив rows. Возвращать она должна фактическое число выбранных строк. Кроме
того, эта функция должна сохранить общее количество актуальных и «мёртвых»строк в таблице
в выходных параметрах totalrows и totaldeadrows, соответственно. (Если для данной FDW нет
понятия «мёртвых» строк, в totaldeadrows нужно записать 0.)
57.2.8. Подпрограммы FDW для IMPORT FOREIGN SCHEMA
List *
ImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid);
Получает список команд, создающих сторонние таблицы. Эта функция вызывается при выполне-
нии команды IMPORT FOREIGN SCHEMA; ей передаётся дерево разбора этого оператора и OID
целевого стороннего сервера. Она должна вернуть набор строк C, в каждой из которых должна
содержаться команда CREATE FOREIGN TABLE. Эти строки будут разобраны и выполнены ядром
сервера.
В структуре ImportForeignSchemaStmt поле remote_schema задаёт имя удалённой схемы, из кото-
рой импортируются таблицы. Поле list_type устанавливает, как фильтровать имена таблиц: ва-
риант FDW_IMPORT_SCHEMA_ALL означает, что нужно импортировать все таблицы в удалённой схе-
ме (в этом случае поле table_list пустое), FDW_IMPORT_SCHEMA_LIMIT_TO означает, что нужно им-
портировать только таблицы, перечисленные в table_list, и FDW_IMPORT_SCHEMA_EXCEPT означает,
что нужно исключить таблицы, перечисленные в списке table_list. В поле options передаётся
список параметров для процесса импорта. Значение этих параметров определяется самой FDW.
Например, у FDW может быть параметр, определяющий, нужно ли сохранять у импортируемых
столбцов атрибут NOT NULL. Эти параметры могут не иметь ничего общего с параметрами, которые
принимает FDW в качестве параметров объектов базы.
FDW может игнорировать поле local_schema в ImportForeignSchemaStmt, так как ядро сервера
само вставит это имя в разобранные команды CREATE FOREIGN TABLE.
Также, FDW может не выполнять сама фильтрацию по полям list_type и table_list, так как ядро
сервера автоматически пропустит все возвращённые команды для таблиц, исключённых по задан-
ным критериям. Однако часто лучше сразу избежать лишней работы, не формируя команды для
исключаемых таблиц. Для проверки, удовлетворяет ли фильтру заданное имя сторонней таблицы,
может быть полезна функция IsImportableForeignTable().
Если FDW не поддерживает импорт определений таблиц, указателю ImportForeignSchema можно
присвоить NULL.
57.2.9. Подпрограммы FDW для параллельного выполнения
Узел ForeignScan может, хотя это не требуется, поддерживать параллельное выполнение. Парал-
лельный ForeignScan будет выполняться в нескольких процессах и должен возвращать одну строку
только единожды. Для этого взаимодействующие процессы могут координировать свои действия
через фиксированного размера блоки в динамической разделяемой памяти. Эта разделяемая па-
мять не будет гарантированно отображаться по одному адресу в разных процессах, так что она
не может содержать указатели. Все следующие функции являются необязательными, но большин-
ство из них необходимы при реализации поддержки параллельного выполнения.
bool
2100Написание обёрт-
ки сторонних данных
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
RangeTblEntry *rte);
Проверяет, будет ли сканирование выполняться параллельным исполнителем. Эта функция будет
вызываться, только когда планировщик считает, что параллельный план принципиально возмо-
жен, и должна возвращать true, если такое сканирование может безопасно выполняться парал-
лельным исполнителем. Обычно это не так, если удалённый источник данных является транзак-
ционным. Но возможно исключение, когда в подключении рабочего процесса к этому источнику
каким-то образом используется тот же транзакционный контекст, что и в ведущем процессе.
Если эта функция не определена, считается, что сканирование должно происходить в ведущем
процессе. Заметьте, что возвращённое значение true не означает, что само сканирование может
выполняться в параллельном режиме, а только то, что сканирование будет производится в парал-
лельном исполнителе. Таким образом, может быть полезно определить этот обработчик, даже ес-
ли параллельное выполнение не поддерживается.
Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);
Оценивает объём динамической разделяемой памяти, которая потребуется для параллельной опе-
рации. Это значение может превышать объём, который будет занят фактически, но не должно быть
меньше. Возвращаемое значение задаётся в байтах. Эта функция является необязательной и мо-
жет быть опущена, если не требуется; но в этом случае должны быть также опущены следующие
три функции, так как для FDW не будет выделена разделяемая память.
void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
void *coordinate);
Инициализирует динамическую разделяемую память, которая потребуется для параллельной опе-
рации. coordinate указывает на область разделяемой памяти размера, равного возвращаемому
значению EstimateDSMForeignScan. Эта функция является необязательной и может быть опущена,
если не требуется.
void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
void *coordinate);
Заново инициализирует динамическую разделяемую память, требуемую для параллельной опера-
ции, перед тем как будет повторно просканирован узел чтения сторонних данных. Эта функция
является необязательной и может быть опущена, если не требуется. В этой функции рекоменду-
ется сбрасывать только общее состояние, а в функции ReScanForeignScan сбрасывать только ло-
кальное. В настоящее время эта функция будет вызываться перед ReScanForeignScan, но лучше
на этот порядок не рассчитывать.
void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
void *coordinate);
Инициализирует локальное состояние параллельного исполнителя на основе общего состояния,
заданного ведущим исполнителем во время InitializeDSMForeignScan. Эта функция является
необязательной и может быть опущена, если не требуется.
void
ShutdownForeignScan(ForeignScanState *node);
Освобождает ресурсы, когда становится понятно, что этот узел больше не будет выполняться. Этот
обработчик вызывается не во всех случаях; иногда может вызываться только EndForeignScan. Так
как сегмент DSM, используемый параллельным запросом, освобождается сразу после вызова этого
обработчика, обёртки сторонних данных, которым нужно выполнять некоторые действия до лик-
видации сегмента DSM, должны реализовывать этот метод.
2101Написание обёрт-
ки сторонних данных
57.2.10. Подпрограммы FDW для изменения параметризации пу-
тей
List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
RelOptInfo *child_rel);
Эта функция вызывается при преобразовании пути, параметризованного самым верхним родите-
лем данного дочернего отношения child_rel, в путь, параметризованный дочерним отношением.
Она используется для изменения параметров любых путей или трансляции любых узлов выраже-
ний, сохранённых в поле fdw_private переданной структуры ForeignPath. Этот обработчик может
по мере необходимости использовать reparameterize_path_by_child, adjust_appendrel_attrs
или adjust_appendrel_attrs_multilevel.
57.3. Вспомогательные функции для обёрток сторон-
них данных
Ядро сервера экспортирует набор полезных вспомогательных функций, которые позволяют разра-
ботчикам обёрток сторонних данных легко обращаться к атрибутам объектов, связанных с FDW,
например, к параметрам FDW. Чтобы использовать эти функции, необходимо включить в исходный
файл заголовочный файл foreign/foreign.h. В этом заголовочном файле также определяются ти-
пы структур, возвращаемых этими функциями.
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
Эта функция возвращает объект ForeignDataWrapper для обёртки сторонних данных с указанным
OID. Объект ForeignDataWrapper содержит свойства FDW (они описаны в foreign/foreign.h).
ForeignServer *
GetForeignServer(Oid serverid);
Эта функция возвращает объект ForeignServer для стороннего сервера с указанным OID. Объект
ForeignServer содержит свойства сервера (они описаны в foreign/foreign.h).
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
Эта функция возвращает объект UserMapping для сопоставления пользователя, которое опреде-
лено для указанной роли на указанном сервере. (Если сопоставление для указанной роли от-
сутствует, она возвращает сопоставление для PUBLIC или выдаёт ошибку, если его нет.) Объект
UserMapping содержит свойства сопоставления пользователя (они описаны в foreign/foreign.h).
ForeignTable *
GetForeignTable(Oid relid);
Эта функция возвращает объект ForeignTable для сторонней таблицы с указанным OID. Объект
ForeignTable содержит свойства сторонней таблицы (они описаны в foreign/foreign.h).
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
Эта функция возвращает параметры FDW уровня столбцов для столбца из таблицы с указанным
OID сторонней таблицы и указанным номером, в виде списка DefElem. Если для столбца не опре-
делены параметры, возвращается NULL.
В дополнение к функциям, выбирающим объекты по OID, для некоторых объектов добавлены функ-
ции поиска по именам:
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
2102Написание обёрт-
ки сторонних данных
Эта функция возвращает объект ForeignDataWrapper для обёртки сторонних данных с указанным
именем. В случае отсутствия такой обёртки возвращается NULL, если missing_ok равно true, а
иначе выдаётся ошибка.
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
Эта функция возвращает объект ForeignServer для стороннего сервера с указанным именем. В
случае отсутствия такого сервера возвращается NULL, если missing_ok равно true, а иначе выда-
ётся ошибка.
57.4. Планирование запросов с обёртками сторонних
данных
Процедуры в FDW, реализующие функции GetForeignRelSize, GetForeignPaths, GetForeignPlan,
PlanForeignModify, GetForeignJoinPaths, GetForeignUpperPaths и PlanDirectModify, должны
вписываться в работу планировщика PostgreSQL. Здесь даётся несколько замечаний о том, как это
должно происходить.
Для уменьшения объёма выбираемых из сторонней таблицы данных (и как следствие, сокращения
стоимости) может использоваться информация, поступающая в root и baserel. Особый интерес
представляет поле baserel->baserestrictinfo, так как оно содержит ограничивающие условия
(предложение WHERE), по которым можно отфильтровать выбираемые строки. (Сама FDW не обя-
зательно должна применять эти ограничения, так как их может проверить и ядро исполнителя.)
Список baserel->reltarget->exprs позволяет определить, какие именно столбцы требуется вы-
брать; но учтите, что в нём перечисляются только те столбцы, которые выдаются узлом плана
ForeignScan, но не столбцы, которые задействованы в ограничивающих условиях и при этом не
выводятся запросом.
Когда функциям планирования FDW требуется сохранять свою информацию, они могут использо-
вать различные частные поля. Вообще, все структуры, которые FDW помещает в закрытые поля,
должны выделяться функцией palloc, чтобы они автоматически освобождались при завершении
планирования.
Для хранения информации, относящейся к определённой сторонней таблице, функции планиро-
вания FDW могут использовать поле baserel->fdw_private, которое может содержать указатель
на void. Ядро планировщика никак не касается его, кроме того, что записывает в него NULL
при создании узла RelOptInfo. Оно полезно для передачи информации из GetForeignRelSize в
GetForeignPaths и/или из GetForeignPaths в GetForeignPlan и позволяет избежать повторных вы-
числений.
GetForeignPaths может обозначить свойства различных путей доступа, сохранив частную инфор-
мацию в поле fdw_private узлов ForeignPath. Это поле fdw_private объявлено как указатель
на список (List), но в принципе может содержать всё, что угодно, так как ядро планировщика
его не касается. Однако лучше поместить в него данные, которые сможет представить функция
nodeToString, для применения средств отладки, имеющихся на сервере.
GetForeignPlan может изучить поле fdw_private выбранного узла ForeignPath и сформировать
списки fdw_exprs и fdw_private, которые будут помещены в узел ForeignScan, где они будут на-
ходиться во время выполнения запроса. Оба эти списка должны быть представлены в форме, кото-
рую способна копировать функция copyObject. Список fdw_private не имеет других ограничений
и никаким образом не интерпретируется ядром сервера. Список fdw_exprs, если этот указатель
не NULL, предположительно содержит деревья выражений, которые должны быть вычислены при
выполнении запроса. Затем планировщик обрабатывает эти деревья, чтобы они были полностью
готовы к выполнению.
GetForeignPlan обычно может скопировать полученный целевой список в узел плана как есть. Пе-
редаваемый список scan_clauses содержит те же предложения, что и baserel->baserestrictinfo,
2103Написание обёрт-
ки сторонних данных
но, возможно, в другом порядке для более эффективного выполнения. В простых случаях
FDW может просто убрать узлы RestrictInfo из списка scan_clauses (используя функцию
extract_actual_clauses) и поместить все предложения в список ограничений узла плана, что бу-
дет означать, что эти предложения будут проверяться исполнителем во время выполнения. Более
сложные FDW могут самостоятельно проверять некоторые предложения, и в этом случае такие
предложения можно удалить из списка ограничений узла, чтобы исполнитель не тратил время на
их перепроверку.
Например, FDW может распознавать некоторые предложения ограничений вида сторонняя_пере-
менная = подвыражение, которые, по её представлению, могут выполняться на удалённом сервере
с локально вычисленным значением подвыражения. Собственно выявление такого предложения
должно происходить в функции GetForeignPaths, так как это влияет на оценку стоимости пути. Эта
функция может включить в поле fdw_private конкретного пути указатель на узел RestrictInfo
этого предложения. Затем GetForeignPlan удалит это предложение из scan_clauses, но добавит
подвыражение в fdw_exprs, чтобы оно было приведено к исполняемой форме. Она также может по-
местить управляющую информацию в поле fdw_private плана узла, которая скажет исполняющим
функциям, что делать во время выполнения. Запрос, передаваемый удалённому серверу, будет со-
держать что-то вроде WHERE сторонняя_переменная = $1, а значение параметра будет получено во
время выполнения в результате вычисления дерева выражения fdw_exprs.
Все предложения, удаляемые из списка условий узла плана, должны быть добавлены в
fdw_recheck_quals или перепроверены функцией RecheckForeignScan для обеспечения коррект-
ного поведения на уровне изоляции READ COMMITTED. Когда имеет место параллельное изменение
в некоторой другой таблице, задействованной в запросе, исполнителю может потребоваться убе-
диться в том, что все исходные условия по-прежнему выполняются для кортежа, возможно, с дру-
гим набором значений параметров. Использовать fdw_recheck_quals обычно проще, чем реализо-
вывать проверки внутри RecheckForeignScan, но этот метод недостаточен, когда внешние соеди-
нения выносятся наружу, так как вследствие перепроверки в соединённых кортежах могут обну-
ляться некоторые поля, но сами кортежи не будут исключаться.
Ещё одно поле ForeignScan, которое могут заполнять FDW, это fdw_scan_tlist, описывающее кор-
тежи, возвращаемые обёрткой для этого узла плана. Для простых сторонних таблиц в него можно
записать NIL, из чего будет следовать, что возвращённые кортежи имеют тип, объявленный для
сторонней таблицы. Отличное от NIL значение должно указывать на список целевых элементов
(список структур TargetEntry), содержащий переменные и/или выражения, представляющие воз-
вращаемые столбцы. Это можно использовать, например, чтобы показать, что FDW опустила неко-
торые столбцы, которые по её наблюдению не нужны для запроса. Также, если FDW может вы-
числить выражения, используемые в запросе, более эффективно, чем это можно сделать локаль-
но, она должна добавить эти выражения в список fdw_scan_tlist. Заметьте, что планы соедине-
ния (полученные из путей, созданных функцией GetForeignJoinPaths) должны всегда заполнять
fdw_scan_tlist, описывая набор столбцов, которые они будут возвращать.
FDW должна всегда строить минимум один путь, зависящий только от предложений ограниче-
ния таблицы. В запросах с соединением она может также построить пути, зависящие от огра-
ничения соединения, например сторонняя_переменная = локальная_переменная. Такие предложе-
ния будут отсутствовать в baserel->baserestrictinfo; их нужно искать в списках соединений
отношений. Путь, построенный с таким предложением, называется «параметризованным». Дру-
гие отношения, задействованные в выбранном предложении соединения, должны связываться c
этим путём соответствующим значением param_info; для получения этого значения используется
get_baserel_parampathinfo. В GetForeignPlan часть локальная_переменная предложения соеди-
нения будет добавлена в fdw_exprs, и затем, во время выполнения, это будет работать так же, как
и обычное предложение ограничения.
Если FDW поддерживает удалённые соединения, GetForeignJoinPaths должна выдавать пу-
ти ForeignPath для потенциально удалённых соединений почти так же, как это делает
GetForeignPaths для базовых таблиц. Информация о выбранном соединении может быть пере-
дана функции GetForeignPlan так же, как было описано выше. Однако поле baserestrictinfo
неприменимо к отношениям соединения; вместо этого соответствующие предложения соединения
2104Написание обёрт-
ки сторонних данных
для конкретного соединения передаются в GetForeignJoinPaths в отдельном параметре (extra-
>restrictlist).
FDW может дополнительно поддерживать прямое выполнение некоторых действий плана, находя-
щихся выше уровня сканирований и соединений, например, группировки или агрегирования. Для
реализации этой возможности FDW должна сформировать пути и вставить их в соответствующее
верхнее отношение. Например, путь, представляющий удалённое агрегирование, должен встав-
ляться в отношение UPPERREL_GROUP_AGG с помощью add_path. Этот путь будет сравниваться по сто-
имости с локальным агрегированием, выполненным по результатам пути простого сканирования
стороннего отношения (заметьте, что такой путь также должен быть сформирован, иначе во время
планирования произойдёт ошибка). Если путь с удалённым агрегированием выигрывает, что, как
правило, и происходит, он будет преобразован в план обычным образом, вызовом GetForeignPlan.
Такие пути рекомендуется формировать в обработчике GetForeignUpperPaths, который вызывает-
ся для каждого верхнего отношения (то есть на каждом шаге обработки после сканирования/со-
единения), если все базовые отношения запроса выдаются одной обёрткой.
PlanForeignModify и другие обработчики, описанные в Подразделе  57.2.4, рассчитаны на то,
что стороннее отношение будет сканироваться обычным способом, а затем отдельные изменения
строк будут обрабатываться локальным узлом плана ModifyTable. Этот подход необходим в об-
щем случае, когда для такого изменения требуется прочитать не только сторонние, но и локаль-
ные таблицы. Однако, если операция может быть целиком выполнена сторонним сервером, FDW
может построить путь, представляющий эту возможность, и вставить его в верхнее отношение
UPPERREL_FINAL, где он будет конкурировать с подходом ModifyTable. Этот подход также должен
применяться для реализации удалённого SELECT FOR UPDATE, вместо обработчиков блокировки
строк, описанных Подразделе 57.2.5. Учтите, что путь, вставляемый в UPPERREL_FINAL, отвечает за
реализацию всех аспектов поведения запроса.
При планировании запросов UPDATE или DELETE функции PlanForeignModify и PlanDirectModify
могут обратиться к структуре RelOptInfo сторонней таблицы и воспользоваться информацией
baserel->fdw_private, записанной ранее функциями планирования сканирования. Однако при за-
просе INSERT целевая таблица не сканируется, так что для неё RelOptInfo не заполняется. На
список (List), возвращаемый функцией PlanForeignModify, накладываются те же ограничения,
что и на список fdw_private в узле плана ForeignScan, то есть он должен содержать только такие
структуры, которые способна копировать функция copyObject.
Команда INSERT с предложением ON CONFLICT не поддерживает указание объекта конфликта, так
как уникальные ограничения или ограничения-исключения в удалённых таблицах неизвестны ло-
кально. Из этого, в свою очередь, вытекает, что предложение ON CONFLICT DO UPDATE не поддер-
живается, так как в нём это указание является обязательным.
57.5. Блокировка строк в обёртках сторонних данных
Если нижележащий механизм хранения FDW поддерживает концепцию блокировки отдельных
строк, предотвращающую одновременное изменение этих строк, обычно имеет смысл реализовать
в FDW установление блокировок на уровне строк в приближении, настолько близком к обычным
таблицам PostgreSQL, насколько это возможно и практично. При этом нужно учитывать ряд заме-
чаний.
Первое важное решение, которое нужно принять — будет ли реализована ранняя блокировка или
поздняя блокировка. С ранней блокировкой строка блокируется, когда впервые считывается из
нижележащего хранилища, тогда как с поздней блокировкой строка блокируется, только когда
известно, что её нужно заблокировать. (Различие возникает из-за того, что некоторые строки мо-
гут быть отброшены локально проверяемыми условиями ограничений или соединений.) Ранняя
блокировка гораздо проще и не требует дополнительных обращений к удалённому хранилищу, но
может вызывать блокировку строк, которые можно было бы не блокировать, что может повлечь
учащение конфликтов и даже неожиданные взаимоблокировки. Кроме того, поздняя блокировка
возможна, только если блокируемая строка может быть однозначно идентифицирована позже. По-
этому в идентификаторе строки следует идентифицировать определённую версию строки, как это
делает TID в PostgreSQL.
2105Написание обёрт-
ки сторонних данных
По умолчанию PostgreSQL игнорирует возможности блокировки, обращаясь к FDW, но FDW может
установить ранние блокировки и без явной поддержки со стороны ядра. Функции, описанные в
Подразделе  57.2.5, которые были добавлены в API в PostgreSQL 9.5, позволяют FDW применять
поздние блокировки, если она этого пожелает.
Также следует учесть, что в режиме изоляции READ COMMITTED серверу PostgreSQL может потребо-
ваться перепроверить условия ограничений и соединения с изменённой версией некоторого целе-
вого кортежа. Для перепроверки условий соединения требуется повторно получить копии исход-
ных строк, которые ранее были соединены в целевой кортеж. В случае со стандартными таблицами
PostgreSQL для этого в список столбцов, проходящих через соединение, включаются TID из исход-
ных таблиц, а затем исходные строки извлекаются заново при необходимости. При таком подхо-
де набор данных соединения остаётся компактным, но требуется недорогая операция повторного
чтения строк, а также возможность однозначно идентифицировать повторно считываемую версию
строки по TID. Поэтому по умолчанию при работе со сторонними таблицами в список столбцов,
проходящих через соединение, включается копия всей строки, извлекаемой из сторонней табли-
цы. Это не накладывает специальных требований на FDW, но может привести к снижению произ-
водительности при соединении слиянием или по хешу. FDW, которая может удовлетворить требо-
ваниям повторного чтения, может реализовать первый вариант.
Для команд UPDATE или DELETE со сторонней таблицей рекомендуется, чтобы операция ForeignScan
в целевой таблице выполняла раннюю блокировку строк, которые она выбирает, возможно, исполь-
зуя аналог SELECT FOR UPDATE. FDW может определить, является ли таблица целевой таблицей
команд UPDATE/DELETE, во время планирования, сравнив её relid с root->parse->resultRelation,
или во время планирования, вызвав ExecRelationIsTargetRelation(). Также возможно выполнять
позднюю блокировку в обработчике ExecForeignUpdate или ExecForeignDelete, но специальной
поддержки для этого нет.
Для сторонних таблиц, блокировка которых запрашивается командой SELECT FOR UPDATE/SHARE,
операция ForeignScan так же может произвести раннюю блокировку, выбрав кортежи, используя
аналог SELECT FOR UPDATE/SHARE. Чтобы вместо этого произвести позднюю блокировку, предо-
ставьте подпрограммы-обработчики, описанные в Подразделе 57.2.5. В GetForeignRowMarkType вы-
берите вариант отметки строк ROW_MARK_EXCLUSIVE, ROW_MARK_NOKEYEXCLUSIVE, ROW_MARK_SHARE или
ROW_MARK_KEYSHARE, в зависимости от запрошенной силы блокировки. (Код ядра будет работать
одинаково при любом из этих четырёх вариантов.) Затем вы сможете определить, должна ли сто-
ронняя таблица блокироваться командой этого типа, вызвав функцию get_plan_rowmark во время
планирования либо ExecFindRowMark во время выполнения; нужно проверить не только, что воз-
вращённая структура rowmark отлична от NULL, но и что её поле strength не равно LCS_NONE.
Наконец, для сторонних таблиц, задействованных в командах UPDATE, DELETE или SELECT
FOR UPDATE/SHARE, но не требующих блокировки строк, можно переопределить поведение по
умолчанию, заключающееся в копировании строк целиком, выбрав в GetForeignRowMarkType
вариант ROW_MARK_REFERENCE, получив значение силы блокировки LCS_NONE. В результате
RefetchForeignRow будет вызываться с таким значением markType; она должна будет за-
ново считывать строку, не запрашивая новую блокировку. (Если вы реализуете функцию
GetForeignRowMarkType, но не хотите повторно считывать незаблокированные строки, выберите
для LCS_NONE вариант ROW_MARK_COPY.)
Дополнительные сведения можно получить в src/include/nodes/lockoptions.h, в комментариях
к RowMarkType и PlanRowMark в src/include/nodes/plannodes.h, и в комментариях к ExecRowMark
в src/include/nodes/execnodes.h.
2106
