---
layout: page
title: Глава 56. Написание обработчика процедурного языка
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 56. Написание обработчика процедурного языка

Все функции, написанные на языке, вызываемом не через текущий интерфейс «версии 1» для ком-
пилируемых языков (а именно, это функции на процедурных языках и функции, написанные на
SQL) выполняются через обработчик вызова для заданного языка. Задача такого обработчика вы-
зова — выполнить функцию должным образом, например, интерпретируя для этого её исходный
текст. В этой главе в общих чертах рассказывается, как можно написать обработчик нового про-
цедурного языка.
Обработчик вызова процедурного языка — это «обычная » функция, которая разрабатывается на
компилируемом языке, таком как C, вызывается через интерфейс версии 1, и регистрируется в
PostgreSQL как не принимающая аргументы и возвращающая тип language_handler. Этот специ-
альный псевдотип помечает функцию как обработчик вызова и препятствует её вызову непосред-
ственно из команд SQL. Более подробно соглашение о вызовах и динамическая загрузка кода на
C описывается в Разделе 38.10.
Обработчик вызова вызывается так же, как и любая другая функция: он получает указатель на
переменную struct FunctionCallInfoData, содержащую значения аргументов и информацию о
вызываемой функции, и должен вернуть результат типа Datum (и, возможно, установить признак
isnull в структуре FunctionCallInfoData, если нужно вернуть результат SQL NULL). Отличие об-
работчика вызова от обычной вызываемой функцией состоит в том, что поле flinfo->fn_oid струк-
туры FunctionCallInfoData для него будет содержать OID вызываемой функции, а не самого обра-
ботчика. По этому OID обработчик вызова должен понять, какую функцию вызывать. Кроме того,
список передаваемых аргументов для него формируется в соответствии с объявлением целевой
функции, а не обработчика вызова.
Обработчик вызова сам должен выбрать запись функции из системного каталога pg_proc и про-
анализировать типы аргументов и результата вызываемой функции. Содержимое предложения AS
команды CREATE FUNCTION для этой функции будет находиться в столбце prosrc строки в pg_proc.
Обычно это исходный текст на процедурном языке, но в принципе это может быть и что-то другое,
например, путь к файлу или иные данные, говорящие обработчику вызова, что именно делать.
Часто функция многократно вызывается в одном SQL-операторе. Чтобы в таких случаях избежать
повторных обращений за информацией о вызываемой функции, обработчик вызова может восполь-
зоваться полем flinfo->fn_extra. Изначально оно содержит NULL, но обработчик вызова может
поместить в него указатель на требуемую информацию. При последующих вызовах, если поле
flinfo->fn_extra будет отлично от NULL, им можно воспользоваться и пропустить шаг получе-
ния этой информации. Обработчик вызова должен позаботиться о том, чтобы указатель в flinfo-
>fn_extra указывал на блок памяти, который не будет освобождён раньше, чем завершится запрос
(именно столько может существовать структура FmgrInfo). В качестве одного из вариантов, это-
го можно добиться, разместив дополнительные данные в контексте памяти, заданном в flinfo-
>fn_mcxt; срок жизни таких данных обычно совпадает со сроком жизни самой структуры FmgrInfo.
С другой стороны, обработчик может выбрать и более долгоживущий контекст памяти с тем, чтобы
кешировать определения функций и между запросами.
Когда функция на процедурном языке вызывается как триггер, ей не передаются аргументы
обычным способом; вместо этого поле context в FunctionCallInfoData указывает на структуру
TriggerData, тогда как при обычном вызове функции оно содержит NULL. Обработчик языка, в свою
очередь, должен каким-либо образом предоставить эту информацию функциям на этом процедур-
ном языке.
Шаблон обработчика процедурного языка, написанный на C, выглядит так:
#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
2085Написание обработчи-
ка процедурного языка
#include
#include
#include
#include
#include
"fmgr.h"
"access/heapam.h"
"utils/syscache.h"
"catalog/pg_proc.h"
"catalog/pg_type.h"
PG_MODULE_MAGIC;
PG_FUNCTION_INFO_V1(plsample_call_handler);
Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
Datum
retval;
if (CALLED_AS_TRIGGER(fcinfo))
{
/*
* Вызывается как триггерная функция
*/
TriggerData
*trigdata = (TriggerData *) fcinfo->context;
retval = ...
}
else
{
/*
* Вызывается как функция
*/
retval = ...
}
return retval;
}
Чтобы завершить код обработчика, нужно добавить лишь несколько тысяч строк вместо многото-
чий.
Скомпилировав функцию-обработчик языка в загружаемый модуль (см. Подраздел 38.10.5), этот
язык (plsample) можно зарегистрировать следующими командами:
CREATE FUNCTION plsample_call_handler() RETURNS language_handler
AS 'имя_файла'
LANGUAGE C;
CREATE LANGUAGE plsample
HANDLER plsample_call_handler;
Хотя обработчика вызова достаточно для создания простейшего процедурного языка, есть ещё две
функции, которые можно реализовать дополнительно, чтобы пользоваться языком было удобнее:
функция проверки и обработчик внедрённого кода. Функцию проверки можно реализовать, чтобы
производить проверку синтаксиса языка во время CREATE FUNCTION. Если же реализован обра-
ботчик внедрённого кода, этот язык будет поддерживать выполнение анонимных блоков кода ко-
мандой DO.
Если для процедурного языка предоставляется функция проверки, она должна быть объявлена как
функция, принимающая один параметр типа oid. Результат функции проверки игнорируется, так
что она обычно объявляется как возвращающая тип void. Эта функция будет вызываться в кон-
це выполнения команды CREATE FUNCTION, создающей или изменяющей функцию, написанную на
процедурном языке. Переданный ей OID указывает на строку в pg_proc для этой функции. Функ-
2086Написание обработчи-
ка процедурного языка
ция проверки должна выбрать эту строку обычным образом и произвести все необходимые провер-
ки. Прежде всего нужно вызвать CheckFunctionValidatorAccess(), чтобы отличить явные вызовы
этой функции от происходящих при выполнении команды CREATE FUNCTION. Затем обычно прове-
ряется, например, что типы аргументов и результата функции поддерживаются языком и что те-
ло функции синтаксически правильно для данного языка. Если функция проверки заключает, что
всё в порядке, она должна просто завершиться. Если же она обнаруживает ошибку, она должна
сообщить о ней через обычный механизм ereport(). Выданная таким образом ошибка приведёт к
откату транзакции, так что определение некорректной функции зафиксировано не будет.
Функции проверки обычно должны учитывать параметр check_function_bodies: если он отключён,
то дорогостоящие или зависящие от контекста проверки содержимого функции выполнять не сле-
дует. Если язык подразумевает выполнение кода в процессе компиляции, проверяющая функция
должна избегать проверок, которые влекут за собой такое выполнение. В частности, указанный
параметр отключает утилита pg_dump, чтобы она могла загружать функции на процедурных язы-
ках, не заботясь о побочных эффектах или зависимостях содержимого функций от других объектов
базы. (Вследствие этого требования, обработчик языка не должен полагать, что функция прошла
полную проверку. Смысл существования функции проверки не в том, чтобы убрать эти проверки
из обработчика вызова, а в том, чтобы немедленно уведомить пользователя об очевидных ошиб-
ках при выполнении CREATE FUNCTION.) Хотя выбор, что именно должно проверяться, по большо-
му счёту остаётся за функцией проверки, заметьте, что основной код CREATE FUNCTION выполняет
присваивания SET, связанные с функцией, только когда check_function_bodies включён. Таким
образом, проверки, результаты которых могут зависеть от параметров GUC, определённо должны
опускаться, когда check_function_bodies отключён, во избежание ложных ошибок при восстанов-
лении базы из копии.
Если для процедурного языка предоставляется обработчик встроенного кода, он должен объяв-
ляться в виде функции, принимающей один параметр типа internal. Результат такого обработчи-
ка игнорируется, поэтому обычно он объявляется как возвращающий тип void. Обработчик встро-
енного кода будет вызываться при выполнении оператора DO с данным процедурным языком. В ка-
честве параметра ему на самом деле передаётся указатель на структуру InlineCodeBlock, содер-
жащую информацию о параметрах DO, в частности, текст выполняемого анонимного блока внед-
рённого кода.
Все подобные объявления функций, а также саму команду CREATE LANGUAGE, рекомендуется упа-
ковывать в расширение так, чтобы для установки языка было достаточно простой команды CREATE
EXTENSION. За информацией о разработке расширений обратитесь к Разделу 38.16.
Реализация процедурных языков, включённых в стандартный дистрибутив, может послужить хо-
рошим примером при написании собственных обработчиков языков. Её вы можете найти в подка-
талоге src/pl дерева исходного кода. Некоторые полезные детали также можно узнать на страни-
це справки CREATE LANGUAGE.
2087
