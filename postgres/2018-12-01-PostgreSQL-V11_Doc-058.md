---
layout: page
title: Глава 58. Написание метода извлечения выборки таблицы
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 58. Написание метода извлечения выборки таблицы

Реализация предложения TABLESAMPLE в PostgreSQL поддерживает подключение собственных ме-
тодов извлечения выборки таблицы, в дополнение к методам BERNOULLI и SYSTEM, которые требу-
ются стандартом SQL. Метод выборки определяет, какие строки таблицы будут выбираться, когда
используется предложение TABLESAMPLE.
На уровне SQL метод извлечения выборки таблицы представляется одной функцией SQL, обычно
реализуемой на C, имеющей сигнатуру
method_name(internal) RETURNS tsm_handler
Имя функции будет совпадать с именем метода, указываемым в предложении TABLESAMPLE. Аргу-
мент internal является фиктивным (в нём всегда передаётся ноль) и введён только для того, что-
бы эту функцию нельзя было вызывать напрямую из команд SQL. Возвращать эта функция должна
структуру типа TsmRoutine (выделенную вызовом palloc), содержащую указатели на опорные функ-
ции для метода извлечения выборки. Эти опорные функции представляют собой простые функции
на C, которые не видны и не могут вызываться на уровне SQL. Эти опорные функции описаны в
Разделе 58.1.
В дополнение к указателям на функции в структуре TsmRoutine должны задаваться следующие
дополнительные поля:
List *parameterTypes
Это список OID, содержащий OID типов данных параметров, которые будут приниматься пред-
ложением TABLESAMPLE при использовании этого метода извлечения выборки. Например, для
встроенных методов этот список содержит один элемент со значением FLOAT4OID, представля-
ющий процент выборки. Другие методы могут иметь дополнительные или иные параметры.
bool repeatable_across_queries
Если это поле равно true, данный метод извлечения выборки может выдавать одинаковые вы-
борки при последовательных запросах с одними и теми же параметрами и значением затравки
REPEATABLE при условии неизменности содержимого таблицы. Если равно false, предложение
REPEATABLE не будет приниматься с этим методом извлечения выборки.
bool repeatable_across_scans
Если это поле равно true, метод извлечения выборки может выдавать одинаковые выборки при
последовательном сканировании в рамках одного запроса (предполагается неизменность па-
раметров, значения затравки и снимка данных). Если равно false, планировщик не будет вы-
бирать планы, требующие неоднократного сканирования выборки, так как это может привести
к несогласованному результату запроса.
Тип структуры TsmRoutine объявлен в src/include/access/tsmapi.h, где можно найти дополни-
тельную информацию.
Методы извлечения выборки, включённые в стандартный дистрибутив, могут послужить хорошим
примером, если вы хотите написать свой метод. Код встроенных методов вы можете найти в под-
каталоге src/backend/access/tablesample дерева исходного кода, а код дополнительных методов
— в подкаталоге contrib.
58.1. Опорные функции метода извлечения выборки
Функция-обработчик TSM возвращает структуру TsmRoutine (выделенную вызовом palloc) с указа-
телями на опорные функции, описанные ниже. Большинство этих функций обязательные, но неко-
торые — нет, и их указатели могут быть равны NULL.
2107Написание метода извле-
чения выборки таблицы
void
SampleScanGetSampleSize (PlannerInfo *root,
RelOptInfo *baserel,
List *paramexprs,
BlockNumber *pages,
double *tuples);
Эта функция вызывается во время планирования. Она должна рассчитать число страниц отно-
шения, которые будут прочитаны при простом сканировании, и число кортежей, выбираемых
при сканировании. (Например, эти числа можно получить, оценив процент выбираемых дан-
ных, а затем умножив baserel->pages и baserel->tuples на это значение и округлив резуль-
тат до целых.) Список paramexprs содержит выражения, переданные в параметрах предложению
TABLESAMPLE. Если для целей оценивания нужны их значения, рекомендуется воспользоваться
estimate_expression_value(), чтобы попытаться свести эти выражения к константам; но данная
функция должна выдавать оценку размера, даже если это не удастся, и не должна выдавать ошиб-
ку, даже если считает переданные значения неверными (помните, что это только приблизитель-
ные оценки чисел, которые будут получены во время выполнения). Параметры pages и tuples яв-
ляются выходными.
void
InitSampleScan (SampleScanState *node,
int eflags);
Выполняет инициализацию перед выполнением узла плана SampleScan. Эта функция вызывается
при запуске исполнителя. Она должна выполнить все подготовительные действия, необходимые
для начала обработки. Узел SampleScanState уже был создан, но его поле tsm_state содержит
NULL. Функция InitSampleScan может выделить через palloc область для любых внутренних дан-
ных, нужных методу извлечения выборки, и сохранить указатель на неё в node->tsm_state. Инфор-
мацию о сканируемой таблице можно получить через другие поля узла SampleScanState (но за-
метьте, что дескриптор сканирования node->ss.ss_currentScanDesc ещё не настроен). Параметр
eflags содержит битовые флаги, описывающие режим работы исполнителя для этого узла плана.
Когда (eflags & EXEC_FLAG_EXPLAIN_ONLY) не равно нулю, собственно сканирование не будет вы-
полняться, поэтому эта функция должна сделать только то, что необходимо для получения состо-
яния узла, подходящего для EXPLAIN и EndSampleScan.
Эту функцию можно опустить (присвоить указателю NULL), тогда вся инициализация, необходи-
мая для метода извлечения выборки, должна иметь место в BeginSampleScan.
void
BeginSampleScan (SampleScanState *node,
Datum *params,
int nparams,
uint32 seed);
Начинает выполнение сканирования выборки. Эта функция вызывается непосредственно пе-
ред первой попыткой выбрать кортеж и может вызываться повторно, если потребуется переза-
пустить сканирование. Информацию о сканируемой таблице можно получить через поля узла
SampleScanState (но заметьте, что дескриптор сканирования node->ss.ss_currentScanDesc ещё
не настроен). Массив params, длины nparams, содержит значения параметров, переданных в пред-
ложении TABLESAMPLE. Их количество и типы задаются в списке parameterTypes метода выборки,
и они гарантированно не равны NULL. Параметр seed содержит значение затравки, которое этот
метод должен учитывать при генерации любых случайных чисел; это либо хеш, полученный из
значения REPEATABLE, если оно было передано, либо результат random() в противном случае.
Эта функция может скорректировать поля node->use_bulkread и node->use_pagemode. Если поле
node->use_bulkread равно true (это значение по умолчанию), при сканировании будет использо-
ваться стратегия доступа к буферу, ориентированная на переработку буферов после использова-
ния. Может быть разумным присвоить ему false, если при сканировании будет просматриваться
только небольшой процент страниц. Если поле node->use_pagemode равно true (это значение по
2108Написание метода извле-
чения выборки таблицы
умолчанию), при сканировании проверка видимости будет выполняться в один проход для всех
кортежей на каждой просматриваемой странице. Может иметь смысл присвоить ему false, если
при сканировании выбирается только небольшой процент кортежей на странице. В результате бу-
дет выполняться меньше проверок видимости кортежей, хотя каждая проверка будет дороже, так
как потребует расширенную блокировку.
Если метод выборки помечен как repeatable_across_scans, он должен быть способен выбирать
при повторном сканировании тот же набор кортежей, что был выбран в первый раз, то есть новый
вызов BeginSampleScan должен приводить к выборке тех же кортежей, что и предыдущий (если
параметры TABLESAMPLE и значение затравки не меняются).
BlockNumber
NextSampleBlock (SampleScanState *node);
Возвращает номер блока следующей сканируемой страницы либо InvalidBlockNumber, если стра-
ниц для сканирования не осталось.
Эту функцию можно опустить (присвоить её указателю NULL), в этом случае код ядра произведёт
последовательное сканирование всего отношения. Такое сканирование может быть синхронизи-
рованным, так что метод выборки не должен полагать, что страницы отношения каждый раз про-
сматриваются в одном и том же порядке.
OffsetNumber
NextSampleTuple (SampleScanState *node,
BlockNumber blockno,
OffsetNumber maxoffset);
Возвращает номер смещения следующего кортежа, выбираемого с указанной страницы, либо
InvalidOffsetNumber, если кортежей для выборки не осталось. В maxoffset задаётся максималь-
ный номер смещения, допустимый на этой странице.
Примечание
NextSampleTuple не говорит явно, для каких из номеров смещений в диапазоне 1 ..
maxoffset действительно содержатся актуальные кортежи. Это обычно не проблема,
так как код ядра игнорирует запросы на выборку несуществующих или невидимых кор-
тежей; это не должно приводить к отклонениям в выборке. Однако при необходимо-
сти функция может проверить node->ss.ss_currentScanDesc->rs_vistuples[] и по-
нять, какие кортежи актуальны и видимы. (Для этого требуется, чтобы признак node-
>use_pagemode равнялся true.)
Примечание
Функция NextSampleTuple не должна полагать, что в blockno будет получен тот же
номер страницы, что был выдан при последнем вызове NextSampleBlock. Этот номер
определённо был выдан при каком-то предыдущем вызове NextSampleBlock, но код яд-
ра может вызывать NextSampleBlock перед тем, как собственно сканировать страни-
цы, для поддержки упреждающего чтения. Однако можно рассчитывать на то, что как
только начнётся выборка кортежей с одной данной страницы, все последующие вызо-
вы NextSampleTuple будут обращаться к этой странице, пока не будет возвращено зна-
чение InvalidOffsetNumber.
void
EndSampleScan (SampleScanState *node);
Завершает сканирование и освобождает ресурсы. Обычно при этом не нужно освобождать память,
выделенную через palloc, но все видимые извне ресурсы должны быть очищены. Эту функцию чаще
всего можно опустить (присвоить её указателю NULL), если таких ресурсов нет.
2109
