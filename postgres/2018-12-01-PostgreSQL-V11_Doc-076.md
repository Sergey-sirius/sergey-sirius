---
layout: page
title: Приложение F. Дополнительно поставляемые модули
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Приложение F. Дополнительно поставляемые модули

В этом и следующем приложении содержится информация о модулях, которые можно найти в ка-
талоге contrib дистрибутива PostgreSQL. В их число входят средства портирования, утилиты ана-
лиза и подключаемые функции, не включённые в состав основной системы PostgreSQL, в основном
потому что они адресованы ограниченной аудитории или находятся в экспериментальном состоя-
нии, неподходящем для основного дерева кода. Однако это всё не умаляет их полезность.
В этом приложении описываются расширения и другие подключаемые серверные модули, вклю-
чённые в contrib. В Приложении G описываются вспомогательные программы.
При сборке сервера из дистрибутивного исходного кода эти компоненты собираются, только если
выбрана цель "world" (см. Шаг 2). Вы можете собрать и установить их отдельно, выполнив:
make
make install
в каталоге contrib в настроенном дереве исходного кода; либо собрать и установить только один
выбранный модуль, проделав то же самое в его подкаталоге. Для многих модулей имеются регрес-
сионные тесты, которые можно выполнить, запустив:
make check
перед установкой или
make installcheck
, когда сервер PostgreSQL будет работать.
Если вы используете готовую собранную версию PostgreSQL, эти модули обычно поставляются в
виде отдельного подпакета, например postgresql-contrib.
Многие модули предоставляют дополнительные пользовательские функции, операторы и типы.
Чтобы использовать один из таких модулей, когда его исполняемый код установлен, вы должны за-
регистрировать новые объекты SQL в СУБД. В PostgreSQL версии 9.1 и новее для этого нужно вос-
пользоваться командой CREATE EXTENSION. В чистой базе данных вы можете просто выполнить:
CREATE EXTENSION имя_модуля;
Запускать эту команду должен суперпользователь баз данных. При этом новые объекты SQL будут
зарегистрированы только в текущей базе данных, так что эту команду нужно выполнять в каждой
базе данных, в которой вы хотите пользоваться функциональностью этого модуля. Вы также може-
те запустить её в template1, чтобы установленное расширение копировалось во все впоследствии
создаваемые базы по умолчанию.
Многие модули позволяют устанавливать свои объекты в схему по выбору. Для этого нужно доба-
вить SCHEMA имя_схемы в команду CREATE EXTENSION. По умолчанию объекты устанавливаются в
текущую схему для создаваемых объектов, которой по умолчанию становится public.
Если ваша база данных была получена в результате выгрузки/перезагрузки данных PostgreSQL
версии до 9.1, и вы ранее использовали версию этого модуля, рассчитанную на версию до 9.1,
вместо этого вы должны выполнить:
CREATE EXTENSION имя_модуля FROM unpackaged;
При этом объекты этого модуля версии до 9.1 будут упакованы в соответствующий объект расши-
рения. После этого обновления расширения будут осуществляться командой ALTER EXTENSION.
За дополнительными сведениями об обновлении расширении обратитесь к Разделу 38.16.
Однако некоторые из этих модулей не являются «расширениями» в этом смысле, а подключаются к
серверу по-другому, например, через параметр конфигурации shared_preload_libraries. Подробнее
об этом говорится в документации каждого модуля.
2472Дополнительно по-
ставляемые модули
F.1. adminpack
Модуль adminpack предоставляет несколько вспомогательных функций, которыми могут пользо-
ваться pgAdmin и другие средства администрирования и управления базами данных, например,
для удалённого управления файлами журналов сервера. По умолчанию использовать все эти функ-
ции разрешено только суперпользователям, но такое право можно дать и другим пользователям
с помощью команды GRANT.
Функции, приведённые в Таблице F.1, предоставляют возможность записи в файлы на компьюте-
ре, где работает сервер. (См. также функции в Таблице 9.88, которые открывают доступ только на
чтение.) Они позволяют обычным пользователям обращаться только к файлам в каталоге класте-
ра баз данных, но не ограничивают суперпользователей и членов ролей pg_read_server_files или
pg_write_server_files. При этом путь может задаваться и как абсолютный, и как относительный.
Таблица F.1. Функции модуля adminpack
Имя Тип результата Описание
pg_catalog.pg_file_write(
filename text, data text,
append boolean) bigint Записать или дописать в тексто-
вый файл
pg_catalog.pg_file_
rename(oldname
text,
newname
text
[,
archivename text]) boolean Переименовать файл
pg_catalog.pg_file_
unlink(filename text) boolean Удалить файл
pg_catalog.pg_logdir_ls(
) setof record Получить список файлов жур-
налов
в
каталоге
log_
directory
Функция pg_file_write записывает данные (data) в файл с именем filename. Если флаг append
сброшен, этот файл не должен существовать. Если же флаг append установлен, существование
файла допускается и в этом случае данные будут дописаны в него. Возвращает число записанных
байтов.
Функция pg_file_rename переименовывает файл. Если параметр archivename опущен или равен
NULL, она просто переименовывает файл oldname в newname (файл с новым именем не должен суще-
ствовать). Если параметр archivename задан, она сначала переименовывает newname в archivename
(такой файл не должен существовать), а затем переименовывает oldname в newname. В случае ошиб-
ки на втором этапе переименования она попытается переименовать archivename назад в newname,
прежде чем выдать ошибку. Возвращает true в случае успеха и false, если исходные файлы отсут-
ствуют или их невозможно изменить; в других случаях выдаются ошибки.
Функция pg_file_unlink удаляет заданный файл. Возвращает true в случае успеха, false в случае
отсутствия указанного файла либо при сбое в вызове unlink(); в других случаях выдаются ошибки.
Функция pg_logdir_ls возвращает время создания и пути всех файлов журналов в каталоге
log_directory. Чтобы эта функция работала, параметр log_filename должен иметь значение по умол-
чанию (postgresql-%Y-%m-%d_%H%M%S.log).
F.2. amcheck
Модуль amcheck предоставляет функции, позволяющие проверять логическую целостность струк-
туры отношений. Если нарушения структуры не обнаруживаются, эти функции отрабатывают без
ошибок.
2473Дополнительно по-
ставляемые модули
Эти функции проверяют различные инварианты в структуре представления определённых отно-
шений. Правильность работы функций методов доступа, стоящих за сканированием индекса и дру-
гими важными операциями, зависит от всегда соблюдаемых инвариантов. Например, определён-
ные функции проверяют, помимо остальных вещей, что все страницы B-дерева содержат элемен-
ты в «логическом» порядке (например, индекс-B-дерево, построенный по столбцу text, должен
содержать кортежи, упорядоченные в лексическом порядке с учётом правила сортировки). Если
этот конкретный инвариант каким-то образом нарушается, следует ожидать, что бинарный поиск
на затронутой странице введёт в заблуждение процедуру сканирования индекса, что приведёт к
неверным результатам запросов SQL.
Проверка выполняется теми же процедурами, что используются при сканировании индекса, и это
может быть код пользовательского класса операторов. Например, проверка индекса-B-дерева за-
действует сравнения, выполняемые одной или несколькими опорными функциями B-дерева под
номером 1. Подробнее опорные функции класса операторов описываются в Подразделе 38.15.3.
Функции amcheck могут выполнять только суперпользователи.
F.2.1. Функции
bt_index_check(index regclass, heapallindexed boolean) returns void
bt_index_check проверяет, соблюдаются ли в целевом индексе-B-дереве различные инвариан-
ты. Пример использования:
test=# SELECT bt_index_check(index => c.oid, heapallindexed => i.indisunique),
c.relname,
c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = 'btree' AND n.nspname = 'pg_catalog'
-- Не проверять временные таблицы (они могут относиться к другим сеансам):
AND c.relpersistence != 't'
-- Функция может выдать ошибку без этих условий:
AND c.relkind = 'i' AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;
bt_index_check |
relname
| relpages
----------------+---------------------------------+----------
| pg_depend_reference_index
|
43
| pg_depend_depender_index
|
40
| pg_proc_proname_args_nsp_index |
31
| pg_description_o_c_o_index
|
21
| pg_attribute_relid_attnam_index |
14
| pg_proc_oid_index
|
10
| pg_attribute_relid_attnum_index |
9
| pg_amproc_fam_proc_index
|
5
| pg_amop_opr_fam_index
|
5
| pg_amop_fam_strat_index
|
5
(10 rows)
Этот пример демонстрирует сеанс проверки 10 самых больших индексов системных каталогов
в базе данных «test». Проверка всех кортежей кучи на предмет наличия соответствующих кор-
тежей индекса запрашивается только для тех из этих индексов, которые являются уникальны-
ми. Так как ошибки не было, все проверенные индексы представляются логически целостными.
Естественно, этот запрос можно легко изменить, чтобы функция bt_index_check вызывалась
для всех индексов в базе, которые поддерживают эту проверку.
Функция bt_index_check запрашивает блокировку AccessShareLock для целевого индекса и от-
ношения, которому он принадлежит. Это тот же режим блокировки, что запрашивается для от-
2474Дополнительно по-
ставляемые модули
ношений обычными операторами SELECT. bt_index_check не проверяет инварианты, существу-
ющие в иерархии потомок/родитель, но проверяет представление всех кортежей кучи в индек-
се в виде индексных кортежей, когда параметр heapallindexed равен true. Когда в работаю-
щей производственной среде требуется регулярная лёгкая проверка на наличие нарушений,
использование bt_index_check часто будет подходящим компромиссом между полнотой про-
верки и минимизацией влияния на производительность и доступность приложения.
bt_index_parent_check(index regclass, heapallindexed boolean) returns void
Функция bt_index_parent_check проверяет, соблюдаются ли в целевом объекте, индексе-B-
дереве, различные инварианты. Кроме того, если аргумент heapallindexed равен true, эта
функция проверяет наличие в индексе всех кортежей из кучи, которые должны в него по-
пасть, и отсутствие потерянных связей в структуре индекса. Проверки, которые может про-
изводить bt_index_parent_check, включают в себя все проверки, выполняемые функцией
bt_index_check. Функцию bt_index_parent_check можно считать более полноценным вариан-
том bt_index_check: в отличие от bt_index_check, bt_index_parent_check проверяет ещё и
инварианты, существующие в иерархии родитель/потомок. bt_index_parent_check следует об-
щему соглашению и выдаёт ошибку в случае обнаружения логической несогласованности или
другой проблемы.
Функция bt_index_parent_check запрашивает в целевом индексе блокировку ShareLock (также
ShareLock запрашивается и в основном отношении). Эти блокировки предотвращают одновре-
менное изменение данных командами INSERT, UPDATE и DELETE. Эти блокировки также препят-
ствуют одновременной обработке нижележащего отношения командой VACUUM и другими вспо-
могательными командами. Заметьте, что эта функция удерживает блокировки только во время
выполнения, а не на протяжении всей транзакции.
Дополнительные проверки, проводимые функцией bt_index_parent_check, более ориентиро-
ваны на выявление различных патологических случаев. В том числе это может быть непра-
вильно реализованный класс операторов B-дерева, используемый проверяемым индексом, или,
гипотетически, неизвестные ошибки в нижележащем коде метода доступа индекса-B-дерева.
Заметьте, что функцию bt_index_parent_check нельзя применять, когда включён режим го-
рячего резерва (то есть на физических репликах в режиме «только чтение»), в отличие от
bt_index_check.
F.2.2. Дополнительная проверка heapallindexed
Когда аргумент heapallindexed проверяющих функций равен true, для таблицы, связанной с от-
ношением целевого индекса, добавляется дополнительная фаза проверки. Она включает «фиктив-
ную» операцию CREATE INDEX, которая проверяет присутствие всех гипотетических новых индекс-
ных кортежей по временной сводной структуре в памяти (она создаётся при необходимости на
первом этапе проверки). Сводная структура «помечает» каждый кортеж, который находится в це-
левом индексе. На высоком уровне идея проверки heapallindexed состоит в том, чтобы убедиться,
что новый индекс, равнозначный целевому, содержит только те записи, которые можно найти в
существующей структуре.
С дополнительным этапом heapallindexed связаны значительные издержки: проверка обычно бу-
дет выполняться в несколько раз дольше. Однако никакие новые блокировки уровня отношения
при проверке heapallindexed не запрашиваются.
Сводная структура ограничивается по объёму значением maintenance_work_mem. Для выявления
несогласованности в представленных в индексе кортежах с вероятностью упущений в пределах
2% требуется приблизительно 2 байта памяти на кортеж. По мере уменьшения объёма памяти в
пересчёте на кортеж этот процент медленно растёт. Этот подход значительно ограничивает из-
держки такой проверки, и при этом лишь немного уменьшается вероятность выявления пробле-
мы, особенно в инсталляциях, где эта проверка включена в процедуру регулярного обслуживания.
Даже если единичное отсутствие или повреждение кортежа упущено, есть все шансы выявить его
при очередной проверке.
2475Дополнительно по-
ставляемые модули
F.2.3. Эффективное использование amcheck
Модуль amcheck может быть полезен для выявления различных типов проблем, которые могут
остаться незамеченными при включении контрольных сумм страниц данных. В частности это:
• Структурные несоответствия, возникающие при некорректной реализации класса операторов.
В том числе это проблемы, возникающие при изменении правил сравнения в операционной
системе. Сравнения данных сортируемого типа, например text, должны быть постоянными
(как и все сравнения, применяемые при сканировании индекса-B-дерева), что подразумевает
неизменность правил сортировки в операционной системе. Проблемы могут возникать при об-
новлениях правил в операционной системе, хотя такие случаи редки. Чаще проявляются несо-
ответствия порядка сортировки между ведущим и ведомым сервером, например, из-за разли-
чий основных версий используемых операционных систем. Возникающие расхождения обыч-
но наблюдаются только на ведомых серверах, так что и выявить их обычно можно только на
них.
Когда возникает подобная проблема, она может затрагивать не абсолютно все индексы, по-
строенные с порочным правилом сортировки, просто потому что индексированные значения
могут иметь тот же абсолютный порядок, независящий от различий поведения. За дополни-
тельными сведениями об использовании в PostgreSQL правил сортировки и локалей операци-
онной системы обратитесь к Разделу 23.1 и Разделу 23.2.
• Несоответствия структуры между индексами и проиндексированными отношениями в куче
(когда выполняется проверка heapallindexed).
Во время обычных операций перекрёстная проверка индексов по отношениям в куче не про-
изводится. Симптомы повреждения данных в куче могут быть неочевидными.
• Повреждения, вызванные гипотетическими неизвестными ошибками в нижележащем коде
методов доступа, коде сортировки и управления транзакциями PostgreSQL.
Автоматическая проверка структурной целостности индексов играет важную роль в общем те-
стировании новых или предлагаемых возможностей PostgreSQL, с которыми может возник-
нуть логическая несогласованность. Такую же роль играет проверка структуры таблицы и свя-
занной информации о видимости и состоянии транзакций. И поэтому одна из очевидных стра-
тегий тестирования — регулярно вызывать функции amcheck при проведении стандартных ре-
грессионных тестов. Подробнее о выполнении тестов можно узнать в Разделе 33.1.
• Ошибки в файловой системе или подсистеме хранения, когда просто не включены контроль-
ные суммы.
Заметьте, что amcheck рассматривает страницу в том виде, как она представлена в некотором
буфере разделяемой памяти к моменту проверки, если при обращению к нужному блоку он
уже находится в разделяемом буфере. Вследствие этого, amcheck не обязательно видит дан-
ные, находящиеся в файловой системе в момент проверки. Заметьте, что когда контрольные
суммы включены, amcheck может выдать ошибку из-за несоответствия контрольных сумм, ес-
ли в буфер будет считываться испорченный блок.
• Повреждения, вызванные дефектными чипами ОЗУ или вообще подсистемой памяти.
PostgreSQL не защищает от ошибок памяти; предполагается, что в эксплуатируемом вами
сервере установлена память с ECC (Error Correcting Codes, Коды исправления ошибок) или
лучшая защита. Однако память ECC обычно защищает только от ошибок в одном бите и не
следует считать её абсолютной защитой от сбоев, приводящих к повреждению памяти.
Когда выполняется проверка heapallindexed, в целом значительно увеличивается шанс выяв-
ления ошибок в отдельных битах, так как она тестирует точное двоичное равенство и сверяет
проиндексированные атрибуты с кучей.
Вообще говоря, amcheck может доказать только наличие повреждений, но не доказать их отсут-
ствие.
2476Дополнительно по-
ставляемые модули
F.2.4. Исправление повреждений
Когда amcheck сигнализирует о повреждении данных, ложные срабатывания практически исклю-
чены. amcheck считает ошибочными ситуации, которые никогда не должны наблюдаться по опре-
делению, поэтому ошибки amcheck, как правило, требуют тщательного анализа.
Общего метода устранения проблем, которые может выявить amcheck, не существует. Начать нуж-
но с поиска корня проблемы, приводящей к нарушению инварианта. Полезную роль в диагностике
повреждений, которые выявляет amcheck, может сыграть pageinspect. Одна лишь команда REINDEX
может быть неэффективна, когда потребуется исправить повреждения.
F.3. auth_delay
Модуль auth_delay добавляет небольшую задержку в процессе проверки подлинности перед тем,
как выдаётся сообщение об ошибке, чтобы усложнить подбор паролей к базам данных. Заметьте,
что это никоим образом не препятствует атакам типа «отказ в обслуживании», а даже наоборот,
может помочь их осуществить, так как процессы, ожидающие сообщения об ошибке, всё равно
занимают слоты подключения.
Чтобы эта функция работала, данный модуль нужно загрузить посредством параметра конфигура-
ции shared_preload_libraries в postgresql.conf.
F.3.1. Параметры конфигурации
auth_delay.milliseconds (int)
Число миллисекунд, которое нужно подождать, прежде чем сообщать об ошибке аутентифика-
ции. По умолчанию 0.
Эти параметры должны задаваться в postgresql.conf. Обычное использование выглядит так:
# postgresql.conf
shared_preload_libraries = 'auth_delay'
auth_delay.milliseconds = '500'
F.3.2. Автор
КайГай Кохэй <kaigai@ak.jp.nec.com>
F.4. auto_explain
Модуль auto_explain предоставляет возможность автоматического протоколирования планов вы-
полнения медленных операторов, что позволяет обойтись без выполнения EXPLAIN вручную. Это
особенно полезно для выявления неоптимизированных запросов в больших приложениях.
Этот модуль не предоставляет функций, доступных из SQL. Чтобы использовать его, просто загру-
зите его в процесс сервера. Это можно сделать в отдельном сеансе:
LOAD 'auto_explain';
(Для этого нужно быть суперпользователем.) Более типична конфигурация, когда он загру-
жается в некоторые или все сеансы в результате включения auto_explain в переменную
session_preload_libraries или в shared_preload_libraries в файле postgresql.conf. Загрузив этот мо-
дуль, вы можете отслеживать исключительно медленные запросы, вне зависимости от того, когда
они происходят. Конечно, это имеет свою цену.
F.4.1. Параметры конфигурации
Есть несколько параметров конфигурации, которые управляют поведением auto_explain. Заметь-
те, что поведение по умолчанию сводится к бездействию, так что необходимо установить как ми-
нимум переменную auto_explain.log_min_duration, если вы хотите получить какие-либо резуль-
таты.
2477Дополнительно по-
ставляемые модули
auto_explain.log_min_duration (integer)
Переменная auto_explain.log_min_duration задаёт время выполнения оператора, в миллисе-
кундах, при превышении которого план оператора будет протоколироваться. Если это значе-
ние равно 0, протоколироваться будут планы всех операторов. При значении -1 (по умолчанию)
протоколирование планов полностью отключается. Например, если вы установите значение
250ms, протоколироваться будут все запросы, выполняющиеся 250 мс и дольше. Изменить этот
параметр могут только суперпользователи.
auto_explain.log_analyze (boolean)
При включении параметра auto_explain.log_analyze в протокол будет записываться вывод
команды EXPLAIN ANALYZE, а не простой EXPLAIN. По умолчанию этот параметр отключён. Из-
менить его могут только суперпользователи.
Примечание
Когда этот параметр включён, замер времени на уровне узлов плана производится
для всех операторов, даже если они выполняются недостаточно долго для протоко-
лирования. Это может оказать крайне негативное влияние на производительность.
Отключение auto_explain.log_timing исключает это влияние, но при этом соби-
рается меньше информации.
auto_explain.log_buffers (boolean)
Параметр auto_explain.log_buffers определяет, будет ли при протоколировании пла-
на выполнения выводиться статистика об использовании буферов; он равносилен указа-
нию BUFFERS команды EXPLAIN. Этот параметр действует, только если включён параметр
auto_explain.log_analyze. По умолчанию этот параметр отключён. Изменить его могут толь-
ко суперпользователи.
auto_explain.log_timing (boolean)
Параметр auto_explain.log_timing определяет, будет ли при протоколировании плана выпол-
нения выводиться длительность на уровне узлов: он равнозначен указанию TIMING команды
EXPLAIN. Издержки от постоянного чтения системных часов могут значительно замедлить за-
просы в некоторых системах, так что может иметь смысл отключать этот параметр, когда нуж-
но знать только знать количество строк, но не точную длительность каждого узла. Этот пара-
метр действует, только если включён auto_explain.log_analyze. По умолчанию этот параметр
отключён. Изменить его могут только суперпользователи.
auto_explain.log_triggers (boolean)
При включении параметра auto_explain.log_triggers в протокол будет записываться ста-
тистика выполнения триггеров. Этот параметр действует, только если включён параметр
auto_explain.log_analyze. По умолчанию этот параметр отключён. Изменить его могут толь-
ко суперпользователи.
auto_explain.log_verbose (boolean)
Параметр auto_explain.log_verbose определяет, будут ли при протоколировании плана
выполнения выводиться подробные сведения; он равнозначен указанию VERBOSE команды
EXPLAIN. По умолчанию этот параметр отключён. Изменить его могут только суперпользовате-
ли.
auto_explain.log_format (enum)
Параметр auto_explain.log_format выбирает формат вывода для EXPLAIN. Он может прини-
мать значение text, xml, json и yaml. Значение по умолчанию — text. Изменить этот параметр
могут только суперпользователи.
2478Дополнительно по-
ставляемые модули
auto_explain.log_nested_statements (boolean)
При включении параметра auto_explain.log_nested_statements протоколированию могут
подлежать и вложенные операторы (операторы, выполняемые внутри функции). Когда он от-
ключён, протоколируются планы запросов только верхнего уровня. Изменить этот параметр
могут только суперпользователи.
auto_explain.sample_rate (real)
Параметр auto_explain.sample_rate задаёт для auto_explain процент операторов, которые бу-
дут отслеживаться в каждом сеансе. Значение по умолчанию — 1, то есть отслеживаются все
запросы. Вложенные операторы отслеживаются совместно — либо все, либо никакой из них.
Изменить этот параметр могут только суперпользователи.
В обычной ситуации эти параметры устанавливаются в postgresql.conf, хотя суперпользователи
могут изменить их «на лету» в рамках своих сеансов. Типичное их использование может выглядеть
так:
# postgresql.conf
session_preload_libraries = 'auto_explain'
auto_explain.log_min_duration = '3s'
F.4.2. Пример
postgres=#
postgres=#
postgres=#
postgres=#
LOAD 'auto_explain';
SET auto_explain.log_min_duration = 0;
SET auto_explain.log_analyze = true;
SELECT count(*)
FROM pg_class, pg_index
WHERE oid = indrelid AND indisunique;
В результате этих команд может быть получен такой вывод:
LOG: duration: 3.651 ms plan:
Query Text: SELECT count(*)
FROM pg_class, pg_index
WHERE oid = indrelid AND indisunique;
Aggregate (cost=16.79..16.80 rows=1 width=0) (actual time=3.626..3.627 rows=1
loops=1)
-> Hash Join (cost=4.17..16.55 rows=92 width=0) (actual time=3.349..3.594 rows=92
loops=1)
Hash Cond: (pg_class.oid = pg_index.indrelid)
-> Seq Scan on pg_class (cost=0.00..9.55 rows=255 width=4) (actual
time=0.016..0.140 rows=255 loops=1)
-> Hash (cost=3.02..3.02 rows=92 width=4) (actual time=3.238..3.238 rows=92
loops=1)
Buckets: 1024 Batches: 1 Memory Usage: 4kB
-> Seq Scan on pg_index (cost=0.00..3.02 rows=92 width=4) (actual
time=0.008..3.187 rows=92 loops=1)
Filter: indisunique
F.4.3. Автор
Такахиро Итагаки <itagaki.takahiro@oss.ntt.co.jp>
F.5. bloom
Модуль bloom предоставляет метод доступа индекса, основанный на фильтрах Блума.
Фильтр Блума представляет собой компактную структуру данных, позволяющую проверить, явля-
ется ли элемент членом множества. В виде метода доступа индекса он позволяет быстро исклю-
чать неподходящие кортежи по сигнатурам, размер которых определяется при создании индекса.
2479Дополнительно по-
ставляемые модули
Сигнатура — это неточное представление проиндексированных атрибутов, вследствие чего оно
допускает ложные положительные срабатывания; то есть оно может показывать, что элемент со-
держится в множестве, хотя это не так. Поэтому результаты поиска по такому индексу должны
всегда перепроверяться по фактическим значениям атрибутов записи в таблице. Чем больше раз-
мер сигнатуры, тем меньше вероятность ложного срабатывания и число напрасных обращений к
таблице, но это, разумеется, влечёт увеличение индекса и замедление сканирования.
Этот тип индекса наиболее полезен, когда в таблице много атрибутов и в запросах проверяются
их произвольные сочетания. Традиционный индекс-B-дерево быстрее индекса Блума, но для под-
держки всевозможных запросов может потребоваться множество индексов типа B-дерево, при том
что индекс Блума нужен всего один. Заметьте, однако, что индексы Блума поддерживают только
проверки на равенство, тогда как индексы-B-деревья также полезны при проверке неравенств и
поиске в диапазоне.
F.5.1. Параметры
Индекс bloom принимает в своём предложении WITH следующие параметры:
length
Длина каждой сигнатуры (элемента индекса) в битах, округлённая вверх до ближайшего числа,
кратного 16. Значение по умолчанию — 80, а максимальное значение — 4096.
col1 — col32
Число битов, генерируемых для каждого столбца индекса. В имени параметра отражается но-
мер столбца индекса, для которого это число задаётся. Значение по умолчанию — 2 бита, а
максимум — 4095. Параметры для неиспользуемых столбцов индекса игнорируются.
F.5.2. Примеры
Пример создания индекса bloom:
CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)
WITH (length=80, col1=2, col2=2, col3=4);
Эта команда создаёт индекс с длиной сигнатуры 80 бит, в которой атрибуты i1 и i2 отображаются
в 2 бита, а атрибут i3 — в 4. Мы могли бы опустить указания length, col1 и col2, так как в них
задаются значения по умолчанию.
Ниже представлен более полный пример определения и использования индекса Блума, а также
приводится сравнение его с равнозначным индексом-B-деревом. Видно, что индекс Блума значи-
тельно меньше индекса-B-дерева, и при этом он может работать быстрее.
=# CREATE TABLE tbloom AS
SELECT
(random() * 1000000)::int as i1,
(random() * 1000000)::int as i2,
(random() * 1000000)::int as i3,
(random() * 1000000)::int as i4,
(random() * 1000000)::int as i5,
(random() * 1000000)::int as i6
FROM
generate_series(1,10000000);
SELECT 10000000
=# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);
CREATE INDEX
=# SELECT pg_size_pretty(pg_relation_size('bloomidx'));
pg_size_pretty
----------------
153 MB
(1 row)
2480Дополнительно по-
ставляемые модули
=# CREATE index btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);
CREATE INDEX
=# SELECT pg_size_pretty(pg_relation_size('btreeidx'));
pg_size_pretty
----------------
387 MB
(1 row)
Последовательное сканирование по этой большой таблице выполняется долго:
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
--------------------------------------------------------------------------------------------
Seq Scan on tbloom (cost=0.00..213694.08 rows=1 width=24) (actual
time=1445.438..1445.438 rows=0 loops=1)
Filter: ((i2 = 898732) AND (i5 = 123451))
Rows Removed by Filter: 10000000
Planning time: 0.177 ms
Execution time: 1445.473 ms
(5 rows)
Поэтому планировщик обычно предпочтёт сканирование по индексу, если это возможно. Ин-
декс-B-дерево даёт такие результаты:
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
--------------------------------------------------------------------------------------------
Index Only Scan using btreeidx on tbloom (cost=0.56..298311.96 rows=1 width=24)
(actual time=445.709..445.709 rows=0 loops=1)
Index Cond: ((i2 = 898732) AND (i5 = 123451))
Heap Fetches: 0
Planning time: 0.193 ms
Execution time: 445.770 ms
(5 rows)
При таком поиске Блум оказывается лучше B-дерева:
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
--------------------------------------------------------------------------------------------
Bitmap Heap Scan on tbloom (cost=178435.39..178439.41 rows=1 width=24) (actual
time=76.698..76.698 rows=0 loops=1)
Recheck Cond: ((i2 = 898732) AND (i5 = 123451))
Rows Removed by Index Recheck: 2439
Heap Blocks: exact=2408
-> Bitmap Index Scan on bloomidx (cost=0.00..178435.39 rows=1 width=0) (actual
time=72.455..72.455 rows=2439 loops=1)
Index Cond: ((i2 = 898732) AND (i5 = 123451))
Planning time: 0.475 ms
Execution time: 76.778 ms
(8 rows)
Обратите внимание на относительно большое количество ложных срабатываний: для перепровер-
ки по куче были отобраны 2439 строк, но на самом деле ни одна из них не удовлетворила запросу.
Мы можем уменьшить это количество, создав сигнатуру большей длины. В данном примере при
создании индекса с length=200 число ложных срабатываний уменьшилось до 55, но размер индек-
са удвоился (до 306 Мбайт) и запрос стал выполняться дольше (125 мс).
При таком подходе основная проблема поиска по B-дереву состоит в том, что B-дерево неэффек-
тивно, когда условия поиска не ограничивают ведущие столбцы индекса. Поэтому, применяя ин-
дексы типа B-дерево, лучше создавать отдельные индексы для каждого столбца. В этом случае
планировщик построит примерно такой план:
2481Дополнительно по-
ставляемые модули
=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
QUERY PLAN
--------------------------------------------------------------------------------------------
Bitmap Heap Scan on tbloom (cost=9.29..13.30 rows=1 width=24) (actual
time=0.148..0.148 rows=0 loops=1)
Recheck Cond: ((i5 = 123451) AND (i2 = 898732))
-> BitmapAnd (cost=9.29..9.29 rows=1 width=0) (actual time=0.145..0.145 rows=0
loops=1)
-> Bitmap Index Scan on tbloom_i5_idx (cost=0.00..4.52 rows=11 width=0)
(actual time=0.089..0.089 rows=10 loops=1)
Index Cond: (i5 = 123451)
-> Bitmap Index Scan on tbloom_i2_idx (cost=0.00..4.52 rows=11 width=0)
(actual time=0.048..0.048 rows=8 loops=1)
Index Cond: (i2 = 898732)
Planning time: 2.049 ms
Execution time: 0.280 ms
(9 rows)
Хотя этот запрос выполняется гораздо быстрее, чем с каким-либо одиночным индексом, мы платим
за это увеличением размера индекса. Каждый индекс-B-дерево занимает 214 Мбайт, так что общий
объём индексов превышает 1.2 Гбайта, что в 8 раз больше размера индекса Блума.
F.5.3. Интерфейс класса операторов
Класс операторов для индексов Блума требует наличия только хеш-функции для индексируемо-
го типа данных и оператора равенства для поиска. Этот пример демонстрирует соответствующее
определение класса операторов для типа text:
CREATE OPERATOR CLASS text_ops
DEFAULT FOR TYPE text USING bloom AS
OPERATOR
1
=(text, text),
FUNCTION
1
hashtext(text);
F.5.4. Ограничения
• В этот модуль включены только классы операторов для int4 и text.
• При поиске поддерживается только оператор =. Но в будущем возможно добавление поддерж-
ки для массивов с операциями объединения и пересечения.
• Метод доступа bloom не поддерживает уникальные индексы (UNIQUE).
• Метод доступа bloom не поддерживает поиск значений NULL.
F.5.5. Авторы
Фёдор Сигаев <teodor@postgrespro.ru>, Postgres Professional, Москва, Россия
Александр Коротков <a.korotkov@postgrespro.ru>, Postgres Professional, Москва, Россия
Олег Бартунов <obartunov@postgrespro.ru>, Postgres Professional, Москва, Россия
F.6. btree_gin
Модуль btree_gin предоставляет показательные классы операторов GIN, реализующие поведе-
ние, подобное тому, что реализуют обычные классы B-дерева, для типов данных int2, int4, int8,
float4, float8, timestamp with time zone, timestamp without time zone, time with time zone,
time without time zone, date, interval, oid, money, "char", varchar, text, bytea, bit, varbit,
macaddr, macaddr8, inet, cidr, uuid, name, bool, bpchar и всех типов-перечислений (enum).
Вообще говоря, эти классы операторов не будут работать быстрее аналогичных стандартных ме-
тодов индекса-B-дерева, и им не хватает одной важной возможности стандартной реализации B-
дерева: возможности ограничивать уникальность. Тем не менее, их можно применять для тести-
2482Дополнительно по-
ставляемые модули
рования GIN или взять за основу для разработки других классов операторов GIN. Также, для за-
просов, где проверяется и столбец с индексом GIN, и столбец с индексом-B-деревом, может быть
более эффективным создать составной индекс GIN, который использует один из этих классов опе-
раторов, чем использовать два отдельных индекса, выборку из которых придётся объединять, вы-
числяя AND битовых карт.
F.6.1. Пример использования
CREATE TABLE test (a int4);
-- создать индекс
CREATE INDEX testidx ON test USING GIN (a);
-- запрос
SELECT * FROM test WHERE a < 10;
F.6.2. Авторы
Фёдор Сигаев (<teodor@stack.net>) и Олег Бартунов (<oleg@sai.msu.su>). Подробности можно
найти на странице http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin.
F.7. btree_gist
Модуль btree_gist предоставляет показательные классы операторов GiST, реализующие поведе-
ние, подобное тому, что реализуют обычные классы B-дерева, для типов данных int2, int4, int8,
float4, float8, numeric, timestamp with time zone, timestamp without time zone, time with time
zone, time without time zone, date, interval, oid, money, char, varchar, text, bytea, bit, varbit,
macaddr, macaddr8, inet, cidr, uuid и всех типов enum.
Вообще говоря, эти классы операторов не будут работать быстрее аналогичных стандартных ме-
тодов индекса-B-дерева, и им не хватает одной важной возможности стандартной реализации B-
дерева: возможности ограничивать уникальность. Однако они предлагают несколько других воз-
можностей, описанных ниже. Также эти классы операторов полезны, когда требуется составной
индекс GiST, в котором некоторые столбцы имеют типы данных, индексируемые только с GiST, а
другие — простые типы. Наконец, эти классы операторов можно применять для тестирования GiST
или взять за основу для разработки других классов операторов GiST.
Помимо типичных операторов поиска по B-дереву, btree_gist также поддерживает использование
индекса для операции <> («не равно»). Это может быть полезно в сочетании с ограничением-ис-
ключением, как описано ниже.
Также, для типов данных, имеющих естественную метрику расстояния, btree_gist определяет
оператор расстояния <-> и поддерживает использование индексов GiST для поиска ближайших
соседей с применением этого оператора. Операторы расстояния определены для типов int2, int4,
int8, float4, float8, timestamp with time zone, timestamp without time zone, time without
time zone, date, interval, oid и money.
F.7.1. Пример использования
Простой пример использования btree_gist вместо btree:
CREATE TABLE test (a int4);
-- создать индекс
CREATE INDEX testidx ON test USING GIST (a);
-- запрос
SELECT * FROM test WHERE a < 10;
-- поиск ближайших соседей: найти десять записей, ближайших к "42"
SELECT *, a <-> 42 AS dist FROM test ORDER BY a <-> 42 LIMIT 10;
Так можно использовать ограничение-исключение, состоящее в том, что в клетке в зоопарке могут
содержаться животные только одного типа:
=> CREATE TABLE zoo (
cage
INTEGER,
2483Дополнительно по-
ставляемые модули
animal TEXT,
EXCLUDE USING GIST (cage WITH =, animal WITH <>)
);
=> INSERT INTO zoo VALUES(123, 'zebra');
INSERT 0 1
=> INSERT INTO zoo VALUES(123, 'zebra');
INSERT 0 1
=> INSERT INTO zoo VALUES(123, 'lion');
ERROR: conflicting key value violates exclusion constraint "zoo_cage_animal_excl"
DETAIL: Key (cage, animal)=(123, lion) conflicts with existing key (cage,
animal)=(123, zebra).
=> INSERT INTO zoo VALUES(124, 'lion');
INSERT 0 1
F.7.2. Авторы
Фёдор Сигаев (<teodor@stack.net>), Олег Бартунов (<oleg@sai.msu.su>), Янко Рихтер
(<jankorichter@yahoo.de>) и Пол Юнгвирт (<pj@illuminatedcomputing.com>). Подробности мож-
но найти на странице http://www.sai.msu.su/~megera/postgres/gist/.
F.8. citext
Модуль citext предоставляет тип данных для строк, нечувствительных к регистру, citext. По сути
он сравнивает значения, вызывая внутри себя функцию lower. В остальном он почти не отличается
от типа text.
F.8.1. Обоснование
Стандартный способ выполнить сравнение строк без учёта регистра в PostgreSQL заключается в
использовании функции lower при сравнении значений, например
SELECT * FROM tab WHERE lower(col) = LOWER(?);
Этот подход работает довольно хорошо, но имеет ряд недостатков:
• Операторы SQL становятся громоздкими, и нужно не забывать всегда обрабатывать функцией
lower и столбец, и значение.
• Индекс не будет использоваться, если только дополнительно не создать функциональный ин-
декс с функцией lower.
• Если вы объявляете столбец как UNIQUE или PRIMARY KEY, неявно создаваемый индекс будет
чувствительным к регистру. Поэтому он бесполезен для регистронезависимого поиска, так же
как он не будет обеспечивать уникальность без учёта регистра.
Тип данных citext позволяет исключить вызовы lower в SQL-запросах и позволяет сделать пер-
вичный ключ регистронезависимым. Тип citext учитывает локаль, так же, как и тип text, что
означает, что сравнение символов в верхнем и нижнем регистре зависит от правил LC_CTYPE для
базы данных. Это поведение, опять же, не отличается от вызовов lower в запросах. Но так как оно
реализуется прозрачно типом данных, в самих запросах дополнительно не нужно ничего делать.
F.8.2. Как его использовать
Простой пример использования:
CREATE TABLE users (
nick CITEXT PRIMARY KEY,
pass TEXT
NOT NULL
);
INSERT INTO users VALUES ( 'larry',
INSERT INTO users VALUES ( 'Tom',
sha256(random()::text::bytea) );
sha256(random()::text::bytea) );
2484Дополнительно по-
ставляемые модули
INSERT INTO users VALUES ( 'Damian', sha256(random()::text::bytea) );
INSERT INTO users VALUES ( 'NEAL',
sha256(random()::text::bytea) );
INSERT INTO users VALUES ( 'Bjørn', sha256(random()::text::bytea) );
SELECT * FROM users WHERE nick = 'Larry';
Оператор SELECT вернёт один кортеж, несмотря на то, что в столбец nick записано значение larry,
а в запросе фигурирует Larry.
F.8.3. Поведение при сравнении строк
Модуль citext выполняет сравнения, приводя каждую строку к нижнему регистру (как если бы
вызывалась функция lower) и затем производя сравнения как обычно. Так, например, две строки
будут считаться равными, если функция lower, обработав их, выдаст одинаковые результаты.
Чтобы имитировать правило сортировки без учёта регистра в максимально возможной степени,
этот модуль предоставляет специальные, ориентированные на citext, операторы и функции для
обработки строки. Так, например, операторы регулярных выражений ~ и ~* действуют в том же
ключе, когда применяются к типу citext: оба они не учитывают регистр. Это же распространяется
на операторы !~ и !~*, а также операторы LIKE ~~, ~~*, !~~ и !~~*. Если же вы хотите, чтобы эти
операторы учитывали регистр, вы можете привести их аргументы к типу text.
Подобным образом, все следующие функции выполняют сопоставления без учёта регистра, если
их аргументы имеют тип citext:
• regexp_match()
• regexp_matches()
• regexp_replace()
• regexp_split_to_array()
• regexp_split_to_table()
• replace()
• split_part()
• strpos()
• translate()
Для функций с регулярными выражениями, если вам нужно регистрозависимое сопоставление,
вы можете добавить флаг «c», чтобы принудительно включить этот режим. Чтобы получить реги-
строзависимое поведение без этого флага, вы должны привести аргумент к типу text, прежде чем
вызывать эту функцию.
F.8.4. Ограничения
• Смена регистра символов в citext зависит от параметра LC_CTYPE вашей базы данных. Таким
образом, как будут сравниваться значения, определяется при создании базы данных. На са-
мом деле, по определениям стандарта Unicode, это сравнение не будет истинно регистронеза-
висимым. По сути это означает, что если вас устраивает установленное правило сортировки,
вас должны устраивать и сравнения citext. Но если в вашей базе данных хранятся строки на
разных языках, пользователи одного языка могут получать неожиданные результаты запро-
сов, если правило сортировки предназначено для другого языка.
• Начиная с PostgreSQL версии 9.1, вы можете добавлять указание COLLATE к значениям дан-
ных или столбцам citext. В настоящее время операторы citext принимают во внимание та-
кое явное указание COLLATE, сравнивая строки в нижнем регистре, но изначальное приведе-
ние в нижний регистр всегда выполняется согласно параметру LC_CTYPE базы данных (как ес-
ли бы указывалось COLLATE "default"). Это может быть изменено в будущем, чтобы на обоих
этапах учитывалось указание COLLATE во входных данных.
• Тип citext не так эффективен, как text, так как функции операторов и функции сравнения
для B-дерева должны делать копии данных и переводить их в нижний регистр для сравнения.
2485Дополнительно по-
ставляемые модули
Однако он несколько эффективнее варианта с применением lower для получения регистроне-
зависимого сравнения.
• Тип citext малополезен в ситуациях, когда вам нужно сравнивать данные без учёта регистра
в одних контекстах, и с учётом регистра — в других. Обычно в таких случаях используют text
и вручную применяют функцию lower, когда нужно выполнить сравнение без учёта регистра;
это прекрасно работает, если регистронезависимое сравнение требуется выполнять относи-
тельно редко. Если же почти всегда сравнение должно быть регистронезависимым и толь-
ко иногда регистрозависимым, имеет смысл сохранить данные в столбце типа citext, и явно
приводить их к типу text для регистрозависимого сравнения. В любом случае, чтобы оба ва-
рианта поиска были быстрыми, вам потребуются два индекса.
• Схема, содержащая операторы citext, должна находиться в текущем пути search_path (обыч-
но это схема public); в противном случае будут вызываться регистрозависимые операторы
для типа text.
F.8.5. Автор
Дэвид Е. Уилер <david@kineticode.com>
Разработку вдохновил оригинальный модуль citext Дональда Фрейзера.
F.9. cube
Этот модуль реализует тип данных cube для представления многомерных кубов.
F.9.1. Синтаксис
В Таблице F.2 показаны внешние представления типа cube. Буквы x, y и т. д. обозначают числа с
плавающей точкой.
Таблица F.2. Внешние представления кубов
Внешний синтаксис Значение
x Одномерная точка (или одномерный интервал
нулевой длины)
( x) То же, что и выше
x1, x2,...,
( x1, x2,...,
( x),(
Точка в n-мерном пространстве, представленная
внутри как куб нулевого объёма
xn
То же, что и выше
xn)
Одномерный интервал, начинающийся в точке x
и заканчивающийся в y, либо наоборот; порядок
значения не имеет
y)
[( x),(
То же, что и выше
y)]
( x1,...,
[( x1,...,
xn),(
xn),(
y1,...,
y1,...,
N-мерный куб, представленный парой диаго-
нально противоположных углов
yn)
То же, что и выше
yn)]
В каком порядке вводятся противоположные углы куба, не имеет значения. Функции, принима-
ющие тип cube, автоматически меняют углы местами, чтобы получить единое внутреннее пред-
ставление «левый нижний — правый верхний». Когда эти углы совмещаются, в cube для экономии
пространства хранится только один угол с флагом «является точкой».
Пробельные символы игнорируются, так что [(x),(y)] не отличается от [ ( x ), ( y ) ].
F.9.2. Точность
Значения хранятся внутри как 64-битные числа с плавающей точкой. Это значит, что числа с более
чем 16 значащими цифрами будут усекаться.
2486Дополнительно по-
ставляемые модули
F.9.3. Использование
В Таблице F.3 показаны операторы, предназначенные для работы с типом cube.
Таблица F.3. Операторы для кубов
Оператор Результат Описание
a = b boolean Кубы a и b идентичны.
a && b boolean Кубы a и b пересекаются.
a @> b boolean Куб a включает куб b.
a <@ b boolean Куб a включён в куб b.
a < b boolean Куб a меньше куба b.
a <= b boolean Куб a меньше или равен кубу b.
a > b boolean Куб a больше куба b.
a >= b boolean Куб a больше или равен кубу b.
a <> b boolean Куб a не равен кубу b.
a -> n float8 Выдаёт n-ную координату куба (
отсчитывая с 1).
a ~> n float8 Выдаёт n-ную координату ку-
ба следующим образом: n =
2 * k - 1 обозначает нижнюю
границу k-той размерности, n
= 2 * k обозначает верхнюю
границу k-той размерности. От-
рицательные n обозначают об-
ратное значение соответствую-
щей положительной координа-
ты. Этот оператор предназна-
чен для поддержки KNN-GiST.
a <-> b float8 Евклидово расстояние между a
и b.
a <#> b float8 Расстояние городских кварта-
лов (метрика L-1) между a и b.
a <=> b float8 Расстояние Чебышева (метрика
L-inf) между a и b.
(До версии PostgreSQL 8.2 операторы включения @> и <@ обозначались соответственно как @ и ~.
Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упраздне-
ны. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые
геометрические типы данных!)
Скалярные операторы упорядочивания (<, >= и т. д.) не имеют большого смысла ни для каких прак-
тических целей, кроме сортировки. Эти операторы сначала сравнивают первые координаты и если
они равны, сравнивают вторые и т. д. Они предназначены в основном для поддержки класса опе-
раторов индекса-B-дерева для типа cube, который может быть полезен, например, если вы хотите
создать ограничение UNIQUE для столбца типа cube.
Модуль cube также предоставляет класс операторов индекса GiST для значений cube. Индекс GiST
для cube может применяться для поиска значений в выражениях с операторами =, &&, @> и <@ в
предложениях WHERE.
GiST-индекс для cube может быть полезен и для поиска ближайших соседей с использованием
операторов метрики <->, <#> и <=> в предложениях ORDER BY. Например, ближайшего соседа точки
в трёхмерном пространстве (0.5, 0.5, 0.5) можно эффективно найти так:
2487Дополнительно по-
ставляемые модули
SELECT c FROM test ORDER BY c <-> cube(array[0.5,0.5,0.5]) LIMIT 1;
Оператор ~> может также использоваться таким образом, чтобы эффективно выдавать первые
несколько значений, отсортированных по выбранной координате. Например, чтобы получить пер-
вые несколько кубов, упорядоченных по возрастанию первой координаты (левого нижнего угла),
можно использовать следующий запрос:
SELECT c FROM test ORDER BY c ~> 1 LIMIT 5;
А чтобы получить двумерные кубы, отсортированные по убыванию первой координаты правого
верхнего угла:
SELECT c FROM test ORDER BY c ~> 3 DESC LIMIT 5;
В Таблице F.4 перечислены все доступные функции.
Таблица F.4. Функции для работы с кубами
Функция Результат Описание
cube(float8) cube Создаёт
одномерный cube(1) == '(1)'
куб, у которого обе ко-
ординаты равны.
cube(float8,
float8) cube Создаёт
куб.
cube(float8[]) cube Создаёт куб нулево- cube(ARRAY[1,2]) ==
го объёма по коорди- '(1,2)'
натам, определяемым
массивом.
cube(float8[],
float8[]) cube Создаёт куб с коорди- cube(ARRAY[1,2],
натами правого верхне- ARRAY[3,4]) == '(
го и левого нижнего 1,2),(3,4)'
углов, определяемыми
двумя массивами, кото-
рые должны быть оди-
наковой длины.
cube(cube, float8) cube Создаёт новый куб, до-
бавляя размерность к
существующему кубу с
одинаковым значением
новой координаты для
обеих углов. Это быва-
ет полезно, когда нуж-
но построить кубы по-
этапно из вычисляемых
значений.
cube('(1,2),(3,
4)'::cube,
5)
== '(1,2,5),(3,
4,5)'
cube(cube,
float8) cube Создаёт новый куб, до-
бавляя размерность к
существующему кубу.
Это бывает полезно, ко-
гда нужно построить
кубы поэтапно из вы-
числяемых значений.
cube('(1,2),(3,
4)'::cube, 5, 6)
== '(1,2,5),(3,
4,6)'
cube_dim(cube) integer Возвращает число раз- cube_dim('(1,2),
мерностей куба.
(3,4)') == '2'
cube_ll_coord(
cube, integer) float8 Возвращает значение cube_ll_coord('(
n-ной координаты лево- 1,2),(3,4)', 2)
го нижнего угла куба. == '2'
float8,
2488
Пример
одномерный cube(1,2) == '(1),
(2)'Дополнительно по-
ставляемые модули
Функция Результат Описание
cube_ur_coord(
cube, integer) float8 Возвращает значение cube_ur_coord('(
n-ной координаты пра- 1,2),(3,4)', 2)
вого верхнего угла ку- == '4'
ба.
cube_is_point(
cube) boolean Возвращает true, если
куб является точкой, то
есть если два определя-
ющих его угла совпада-
ют.
cube_distance(cube,
cube) float8 Возвращает расстояние
между двумя кубами.
Если оба куба являют-
ся точками, вычисля-
ется обычная функция
расстояния.
cube_subset(cube,
integer[]) cube Создаёт
новый
куб
из существующего, ис-
пользуя список раз-
мерностей из масси-
ва. Может применяться
для получения коорди-
нат углов в одном изме-
рении, для удаления из-
мерений и изменения
их порядка.
cube_union(cube,
cube) cube Создаёт объединение
двух кубов.
cube_inter(cube,
cube) cube Создаёт
пересечение
двух кубов.
cube Увеличивает размер ку-
ба на заданный ра-
диус r как минимум
в n измерениях. Если
радиус отрицательный,
куб, наоборот, умень-
шается. Все определён-
ные измерения изменя-
ются на величину ради-
уса r. Координаты лево-
го нижнего угла умень-
шаются на r, а коорди-
наты правого верхнего
увеличиваются на r. Ес-
ли координата левого
нижнего угла становит-
ся больше соответству-
ющей координаты пра-
вого верхнего (это воз-
можно, только когда r
< 0), обоим координа-
там присваивается их
среднее значение. Ес-
ли n превышает чис-
cube_enlarge(c
cube, r double,
integer)
n
2489
Пример
cube_subset(cube(
'(1,3,5),(6,7,
8)'),
ARRAY[2])
== '(3),(7)'
cube_
subset(cube('(1,
3,5),(6,7,8)'),
ARRAY[3,2,1,1])
== '(5,3,1,1),(
8,7,6,6)'
cube_enlarge('(1,
2),(3,4)', 0.5,
3) == '(0.5,1.5,
-0.5),(3.5,4.5,
0.5)'Дополнительно по-
ставляемые модули
Функция
Результат
Описание
Пример
ло определённых изме-
рений и куб увеличива-
ется (r > 0), добавля-
ются дополнительные
размерности, недоста-
ющие до n; началь-
ным значением для до-
полнительных коорди-
нат считается ноль. Эта
функция полезна для
создания окружающих
точку прямоугольников
для поиска ближайших
точек.
F.9.4. Поведение по умолчанию
Я полагаю, что это объединение:
select cube_union('(0,5,2),(2,3,1)', '0');
cube_union
-------------------
(0, 0, 0),(2, 5, 2)
(1 row)
не противоречит здравому смыслу, как и это пересечение
select cube_inter('(0,-1),(1,1)', '(-2),(2)');
cube_inter
-------------
(0, 0),(1, 0)
(1 row)
Во всех бинарных операциях с кубами разных размерностей, я полагаю, что куб с меньшей размер-
ностью является декартовой проекцией; то есть в опущенных в строковом представлении коорди-
натах предполагаются нули. Таким образом, показанные выше вызовы равнозначны следующим:
cube_union('(0,5,2),(2,3,1)','(0,0,0),(0,0,0)');
cube_inter('(0,-1),(1,1)','(-2,0),(2,0)');
В следующем предикате включения применяется синтаксис точек, хотя фактически второй аргу-
мент представляется внутри кубом. Этот синтаксис избавляет от необходимости определять от-
дельный тип точек и функции для предикатов (cube,point).
select cube_contains('(0,0),(1,1)', '0.5,0.5');
cube_contains
--------------
t
(1 row)
F.9.5. Замечания
Примеры использования можно увидеть в регрессионном тесте sql/cube.sql.
Во избежание некорректного применения этого типа, число размерностей кубов искусственно
ограничено значением 100. Если это ограничение вас не устраивает, его можно изменить в
cubedata.h.
2490Дополнительно по-
ставляемые модули
F.9.6. Благодарности
Первый автор: Джин Селков мл. <selkovjr@mcs.anl.gov>, Аргоннская национальная лаборатория,
Отдел математики и компьютерных наук
Я очень благодарен в первую очередь профессору Джо Геллерштейну (http://db.cs.berkeley.edu/
jmh/) за пояснение сути GiST (http://gist.cs.berkeley.edu/) и его бывшему студенту, Энди Донгу, за
пример, написанный для Illustra. Я также признателен всем разработчикам Postgres в настоящем
и прошлом за возможность создать свой собственный мир и спокойно жить в нём. Ещё я хотел
бы выразить признательность Аргоннской лаборатории и Министерству энергетики США за годы
постоянной поддержки моих исследований в области баз данных.
Небольшие изменения в этот пакет внёс Бруно Вольф III <bruno@wolff.to> в августе/сентябре 2002
г. В том числе он перешёл от одинарной к двойной точности и добавил несколько новых функций.
Дополнительные изменения внёс Джошуа Рейх <josh@root.net> в июле 2006 г. В частности, он
добавил cube(float8[], float8[]), подчистил код и перевёл его на протокол вызовов версии V1
с устаревшего протокола V0.
F.10. dblink
Модуль dblink обеспечивает подключения к другим базам данных PostgreSQL из сеанса базы дан-
ных.
См. также описание модуля postgres_fdw, который предоставляет примерно ту же функциональ-
ность, но через более современную и стандартизированную инфраструктуру.
2491Дополнительно по-
ставляемые модули
dblink_connect
dblink_connect — открывает постоянное подключение к удалённой базе данных
Синтаксис
dblink_connect(text connstr) returns text
dblink_connect(text connname, text connstr) returns text
Описание
Функция dblink_connect() устанавливает подключение к удалённой базе данных PostgreSQL. Це-
левой сервер и база данных указываются в стандартной строке подключения libpq. Если требу-
ется, этому подключению можно назначить имя. В один момент времени могут быть открытыми
несколько именованных подключений, но только одно подключение без имени. Подключение бу-
дет сохраняться, пока не будет закрыто или до завершения сеанса базы данных.
В строке подключения также может задаваться имя существующего стороннего сервера. Для опре-
деления стороннего сервера рекомендуется использовать обёртку сторонних данных dblink_fdw.
См. пример ниже, а также CREATE SERVER и CREATE USER MAPPING.
Аргументы
connname
Имя, назначаемое этому подключению; если опускается, открывается безымянное подключе-
ние, заменяющее ранее существующее безымянное подключение.
connstr
Строка подключения в стиле libpq, например hostaddr=127.0.0.1 port=5432 dbname=mydb
user=postgres password=mypasswd options=-csearch_path=. За подробностями обратитесь к
Подразделу 34.1.1. В ней также может задаваться имя стороннего сервера.
Возвращаемое значение
Возвращает состояние (это всегда строка OK, так как в случае любой ошибки функция прерывается,
выдавая исключение).
Замечания
Если к базе данных, которая не приведена в соответствие шаблону безопасного использова-
ния схем, имеют доступ недоверенные пользователи, начинайте сеанс с удаления доступных им
для записи схем из пути поиска (search_path). Например, для этого можно добавить options=-
csearch_path= в connstr. Это касается не только dblink, но и любых других интерфейсов для вы-
полнения произвольных SQL-команд.
Создавать подключения, не требующие аутентификации по паролю, с помощью dblink_connect
разрешено только суперпользователям. Если эта возможность нужна обычным пользователям,
следует воспользоваться функцией dblink_connect_u.
Использовать в именах подключений знаки «равно» не рекомендуется, так как при этом возможна
путаница со строками подключений в других функциях dblink.
Примеры
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
dblink_connect
----------------
OK
(1 row)
SELECT dblink_connect('myconn', 'dbname=postgres options=-csearch_path=');
2492Дополнительно по-
ставляемые модули
dblink_connect
----------------
OK
(1 row)
-- Функциональность обёртки сторонних данных (FOREIGN DATA WRAPPER)
-- Замечание: чтобы это работало, для локальных подключений требуется аутентификация по
паролю
--
В противном случае, вызвав dblink_connect(), вы получите:
--
----------------------------------------------------------------------
--
ERROR: password is required
--
DETAIL: Non-superuser cannot connect if the server does not request a
password.
--
HINT: Target server's authentication method must be changed.
--
--
ОШИБКА: требуется пароль
--
ПОДРОБНОСТИ: Обычный пользователь не может подключиться, если сервер не
требует пароль.
--
ПОДСКАЗКА: Необходимо изменить метод аутентификации целевого сервера.
CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1',
dbname 'contrib_regression');
CREATE USER regress_dblink_user WITH PASSWORD 'secret';
CREATE USER MAPPING FOR regress_dblink_user SERVER fdtest OPTIONS (user
'regress_dblink_user', password 'secret');
GRANT USAGE ON FOREIGN SERVER fdtest TO regress_dblink_user;
GRANT SELECT ON TABLE foo TO regress_dblink_user;
\set ORIGINAL_USER :USER
\c - regress_dblink_user
SELECT dblink_connect('myconn', 'fdtest');
dblink_connect
----------------
OK
(1 row)
SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);
a | b |
c
----+---+---------------
0 | a | {a0,b0,c0}
1 | b | {a1,b1,c1}
2 | c | {a2,b2,c2}
3 | d | {a3,b3,c3}
4 | e | {a4,b4,c4}
5 | f | {a5,b5,c5}
6 | g | {a6,b6,c6}
7 | h | {a7,b7,c7}
8 | i | {a8,b8,c8}
9 | j | {a9,b9,c9}
10 | k | {a10,b10,c10}
(11 rows)
\c - :ORIGINAL_USER
REVOKE USAGE ON FOREIGN SERVER fdtest FROM regress_dblink_user;
REVOKE SELECT ON TABLE foo FROM regress_dblink_user;
DROP USER MAPPING FOR regress_dblink_user SERVER fdtest;
DROP USER regress_dblink_user;
2493Дополнительно по-
ставляемые модули
DROP SERVER fdtest;
2494Дополнительно по-
ставляемые модули
dblink_connect_u
dblink_connect_u — открывает постоянное подключение к удалённой базе данных, небезопасно
Синтаксис
dblink_connect_u(text connstr) returns text
dblink_connect_u(text connname, text connstr) returns text
Описание
Функция dblink_connect_u() не отличается от dblink_connect(), за исключением того, что она
позволяет подключаться с любым методом аутентификации обычным пользователям.
Если удалённый сервер выбирает режим аутентификации без пароля, возможно олицетворение
и последующее повышение привилегий, так как сеанс будет установлен от имени пользователя,
который исполняет локальный процесс PostgreSQL. Кроме того, даже если удалённый сервер за-
прашивает пароль, этот пароль можно получить из среды сервера, например, из файла ~/.pgpass,
принадлежащего пользователю сервера. Это чревато не только олицетворением, но и выдачей па-
роля не заслуживающему доверия удалённому серверу. Поэтому dblink_connect_u() изначально
устанавливается так, что роль PUBLIC лишена всех прав на её использование, то есть вызывать
её могут только суперпользователи. В некоторых ситуациях допустимо дать право EXECUTE для
dblink_connect_u() определённым пользователям, которым можно доверять, но это нужно делать
осторожно. Также рекомендуется убедиться в том, что файл ~/.pgpass, принадлежащий пользо-
вателю сервера, не содержит никаких записей со звёздочкой в качестве имени узла.
За дополнительными подробностями обратитесь к описанию dblink_connect().
2495Дополнительно по-
ставляемые модули
dblink_disconnect
dblink_disconnect — закрывает постоянное подключение к удалённой базе данных
Синтаксис
dblink_disconnect() returns text
dblink_disconnect(text connname) returns text
Описание
dblink_disconnect() закрывает подключение, ранее открытое функцией dblink_connect(). Фор-
ма без аргументов закрывает безымянное подключение.
Аргументы
connname
Имя закрываемого именованного подключения.
Возвращаемое значение
Возвращает состояние (это всегда строка OK, так как в случае любой ошибки функция прерывается,
выдавая исключение).
Примеры
SELECT dblink_disconnect();
dblink_disconnect
-------------------
OK
(1 row)
SELECT dblink_disconnect('myconn');
dblink_disconnect
-------------------
OK
(1 row)
2496Дополнительно по-
ставляемые модули
dblink
dblink — выполняет запрос в удалённой базе данных
Синтаксис
dblink(text connname, text sql [, bool fail_on_error]) returns setof record
dblink(text connstr, text sql [, bool fail_on_error]) returns setof record
dblink(text sql [, bool fail_on_error]) returns setof record
Описание
dblink выполняет запрос (обычно SELECT, но это может быть и любой другой оператор SQL, воз-
вращающий строки) в удалённой базе данных.
Когда этой функции передаются два аргумента типа text, первый сначала рассматривается как
имя постоянного подключения; если такое подключение находится, команда выполняется для
него. Если не находится, первый аргумент воспринимается как строка подключения, как для функ-
ции dblink_connect, и заданное подключение устанавливается только на время выполнения этой
команды.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
connstr
Строка подключения, описанная ранее для dblink_connect
sql
SQL-запрос, который вы хотите выполнить в удалённой базе данных, например select * from
foo.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и функция не возвращает строки.
Возвращаемое значение
Эта функция возвращает строки, выдаваемые в результате запроса. Так как dblink может выпол-
нять произвольные запросы, она объявлена как возвращающая тип record, а не некоторый опре-
делённый набор столбцов. Это означает, что вы должны указать ожидаемый набор столбцов в вы-
зывающем запросе — в противном случае PostgreSQL не будет знать, чего ожидать. Например:
SELECT *
FROM dblink('dbname=mydb options=-csearch_path=',
'select proname, prosrc from pg_proc')
AS t1(proname name, prosrc text)
WHERE proname LIKE 'bytea%';
В части «псевдонима» предложения FROM должны указываться имена столбцов и типы, которые
будет возвращать функция. (Указание имён столбцов в псевдониме таблицы предусмотрено стан-
дартом SQL, но определение типов столбцов является расширением PostgreSQL.) Это позволяет
системе понять, во что должно разворачиваться обозначение *, и на что ссылается proname в пред-
ложении WHERE, прежде чем пытаться выполнять эту функцию. Во время выполнения произойдёт
ошибка, если действительный результат запроса из удалённой базы данных не будет содержать
2497Дополнительно по-
ставляемые модули
столько столбцов, сколько указано в предложении FROM. Однако имена столбцов могут не совпа-
дать, так же, как dblink не настаивает на точном совпадении типов. Функция завершится успеш-
но, если возвращаемые строки данных будут допустимыми для ввода в тип столбца, объявленный
в предложении FROM.
Замечания
Использовать dblink с предопределёнными запросами будет удобнее, если создать представление.
Это позволит скрыть в его определении информацию о типах столбцов и не выписывать её в каждом
запросе. Например:
CREATE VIEW myremote_pg_proc AS
SELECT *
FROM dblink('dbname=postgres options=-csearch_path=',
'select proname, prosrc from pg_proc')
AS t1(proname name, prosrc text);
SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
Примеры
SELECT * FROM dblink('dbname=postgres options=-csearch_path=',
'select proname, prosrc from pg_proc')
AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
proname
|
prosrc
------------+------------
byteacat
| byteacat
byteaeq
| byteaeq
bytealt
| bytealt
byteale
| byteale
byteagt
| byteagt
byteage
| byteage
byteane
| byteane
byteacmp
| byteacmp
bytealike | bytealike
byteanlike | byteanlike
byteain
| byteain
byteaout
| byteaout
(12 rows)
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
dblink_connect
----------------
OK
(1 row)
SELECT * FROM dblink('select proname, prosrc from pg_proc')
AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
proname
|
prosrc
------------+------------
byteacat
| byteacat
byteaeq
| byteaeq
bytealt
| bytealt
byteale
| byteale
byteagt
| byteagt
byteage
| byteage
byteane
| byteane
byteacmp
| byteacmp
bytealike | bytealike
byteanlike | byteanlike
2498Дополнительно по-
ставляемые модули
byteain
byteaout
(12 rows)
| byteain
| byteaout
SELECT dblink_connect('myconn', 'dbname=regression options=-csearch_path=');
dblink_connect
----------------
OK
(1 row)
SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')
AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
proname
|
prosrc
------------+------------
bytearecv | bytearecv
byteasend | byteasend
byteale
| byteale
byteagt
| byteagt
byteage
| byteage
byteane
| byteane
byteacmp
| byteacmp
bytealike | bytealike
byteanlike | byteanlike
byteacat
| byteacat
byteaeq
| byteaeq
bytealt
| bytealt
byteain
| byteain
byteaout
| byteaout
(14 rows)
2499Дополнительно по-
ставляемые модули
dblink_exec
dblink_exec — выполняет команду в удалённой базе данных
Синтаксис
dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
dblink_exec(text sql [, bool fail_on_error]) returns text
Описание
Функция dblink_exec выполняет команду (то есть любой SQL-оператор, не возвращающий строки)
в удалённой базе данных.
Когда этой функции передаются два аргумента типа text, первый сначала рассматривается как
имя постоянного подключения; если такое подключение находится, команда выполняется для
него. Если не находится, первый аргумент воспринимается как строка подключения, как для функ-
ции dblink_connect, и заданное подключение устанавливается только на время выполнения этой
команды.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
connstr
Строка подключения, описанная ранее для dblink_connect
sql
SQL-запрос, который вы хотите выполнить в удалённой базе данных, например insert into
foo values(0,'a','{"a0","b0","c0"}').
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и возвращаемым значением функции будет ERROR.
Возвращаемое значение
Возвращает состояние (либо строку состояния команды, либо ERROR).
Примеры
SELECT dblink_connect('dbname=dblink_test_standby');
dblink_connect
----------------
OK
(1 row)
SELECT dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
dblink_exec
-----------------
INSERT 943366 1
(1 row)
2500Дополнительно по-
ставляемые модули
SELECT dblink_connect('myconn', 'dbname=regression');
dblink_connect
----------------
OK
(1 row)
SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
dblink_exec
------------------
INSERT 6432584 1
(1 row)
SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);
NOTICE: sql error
DETAIL: ERROR: null value in column "relnamespace" violates not-null constraint
dblink_exec
-------------
ERROR
(1 row)
2501Дополнительно по-
ставляемые модули
dblink_open
dblink_open — открывает курсор в удалённой базе данных
Синтаксис
dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text
dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns
text
Описание
Функция dblink_open() открывает курсор в удалённой базе данных. Открытым курсором можно
будет манипулировать функциями dblink_fetch() и dblink_close().
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
cursorname
Имя, назначаемое курсору.
sql
Оператор SELECT, который вы хотите выполнять в удалённой базе данных, например select *
from pg_class.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и возвращаемым значением функции будет ERROR.
Возвращаемое значение
Возвращает состояние, OK или ERROR.
Замечания
Так как курсор может существовать только в рамках транзакции, функция dblink_open начина-
ет явный блок транзакции (командой BEGIN) на удалённой стороне, если транзакция там ещё
не открыта. Эта транзакция будет снова закрыта при соответствующем вызове dblink_close. За-
метьте, что если вы с помощью dblink_exec изменяете данные между вызовами dblink_open
и dblink_close, а затем происходит ошибка, либо если вы вызываете dblink_disconnect перед
dblink_close, ваши изменения будут потеряны, так как транзакция будет прервана.
Примеры
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
dblink_connect
----------------
OK
(1 row)
SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
dblink_open
-------------
2502Дополнительно по-
ставляемые модули
OK
(1 row)
2503Дополнительно по-
ставляемые модули
dblink_fetch
dblink_fetch — возвращает строки из открытого курсора в удалённой базе данных
Синтаксис
dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record
dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error])
returns setof record
Описание
dblink_fetch выбирает строки из курсора, ранее открытого функцией dblink_open.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
cursorname
Имя курсора, из которого выбираются данные.
howmany
Максимальное число строк, которое нужно получить. Данная функция выбирает через курсор
следующие howmany строк, начиная с текущей позиции курсора и двигаясь вперёд. Когда курсор
доходит до конца, строки больше не выдаются.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и функция не возвращает строки.
Возвращаемое значение
Эта функция возвращает строки, выбираемые через курсор. Для использования этой функции
необходимо задать ожидаемый набор столбцов, как ранее говорилось в описании dblink.
Замечания
При несовпадении числа возвращаемых столбцов, определённого в предложении FROM, с фактиче-
ским числом столбцов, возвращённых удалённым курсором, выдаётся ошибка. В этом случае уда-
лённый курсор всё равно продвигается на столько строк, на сколько он продвинулся бы, если бы
ошибка не произошла. То же самое верно для любых других ошибок, происходящих при локальной
обработке результатов после выполнения удалённой команды FETCH.
Примеры
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
dblink_connect
----------------
OK
(1 row)
SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like
''bytea%''');
dblink_open
-------------
2504Дополнительно по-
ставляемые модули
OK
(1 row)
SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
funcname | source
----------+----------
byteacat | byteacat
byteacmp | byteacmp
byteaeq | byteaeq
byteage | byteage
byteagt | byteagt
(5 rows)
SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
funcname | source
-----------+-----------
byteain
| byteain
byteale
| byteale
bytealike | bytealike
bytealt
| bytealt
byteane
| byteane
(5 rows)
SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
funcname |
source
------------+------------
byteanlike | byteanlike
byteaout
| byteaout
(2 rows)
SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
funcname | source
----------+--------
(0 rows)
2505Дополнительно по-
ставляемые модули
dblink_close
dblink_close — закрывает курсор в текущей базе данных
Синтаксис
dblink_close(text cursorname [, bool fail_on_error]) returns text
dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text
Описание
dblink_close закрывает курсор, ранее открытый функцией dblink_open.
Аргументы
connname
Имя используемого подключения; опустите этот параметр, чтобы использовать безымянное
подключение.
cursorname
Имя курсора, который будет закрыт.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и возвращаемым значением функции будет ERROR.
Возвращаемое значение
Возвращает состояние, OK или ERROR.
Замечания
Если вызов dblink_open начал явный блок транзакции и это последний открытый курсор, оставав-
шийся в этом подключении, то dblink_close выполнит соответствующую команду COMMIT.
Примеры
SELECT dblink_connect('dbname=postgres options=-csearch_path=');
dblink_connect
----------------
OK
(1 row)
SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
dblink_open
-------------
OK
(1 row)
SELECT dblink_close('foo');
dblink_close
--------------
OK
(1 row)
2506Дополнительно по-
ставляемые модули
dblink_get_connections
dblink_get_connections — возвращает имена всех открытых именованных подключений dblink
Синтаксис
dblink_get_connections() returns text[]
Описание
dblink_get_connections возвращает массив имён всех открытых именованных подключений
dblink.
Возвращаемое значение
Возвращает текстовый массив имён подключений, либо NULL, если они отсутствуют.
Примеры
SELECT dblink_get_connections();
2507Дополнительно по-
ставляемые модули
dblink_error_message
dblink_error_message — выдаёт сообщение последней ошибки для именованного подключения
Синтаксис
dblink_error_message(text connname) returns text
Описание
dblink_error_message извлекает самое последнее сообщение удалённой ошибки для заданного
подключения.
Аргументы
connname
Имя используемого подключения.
Возвращаемое значение
Возвращает сообщение последней ошибки, либо пустую строку, если в сеансе этого подключения
не было ошибок.
Примеры
SELECT dblink_error_message('dtest1');
2508Дополнительно по-
ставляемые модули
dblink_send_query
dblink_send_query — передаёт асинхронный запрос в удалённую базу данных
Синтаксис
dblink_send_query(text connname, text sql) returns int
Описание
dblink_send_query передаёт запрос для асинхронного выполнения, то есть не дожидается получе-
ния результата. С этим подключением не должен быть связан уже выполняющийся асинхронный
запрос.
После успешной передачи асинхронного запроса состояние его завершения можно проверять,
вызывая функцию dblink_is_busy, и в итоге получать данные, вызвав dblink_get_result. Также
можно попытаться отменить активный асинхронный запрос, вызвав dblink_cancel_query.
Аргументы
connname
Имя используемого подключения.
sql
Оператор SQL, который вы хотите выполнить в удалённой базе данных, например select *
from pg_class.
Возвращаемое значение
Возвращает 1, если запрос был успешно отправлен на обработку, или 0 в противном случае.
Примеры
SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 < 3');
2509Дополнительно по-
ставляемые модули
dblink_is_busy
dblink_is_busy — проверяет, не выполняется ли через подключение асинхронный запрос
Синтаксис
dblink_is_busy(text connname) returns int
Описание
dblink_is_busy проверяет, не выполняется ли асинхронный запрос.
Аргументы
connname
Имя проверяемого подключения.
Возвращаемое значение
Возвращает 1, если подключение занято, или 0 в противном случае. Если эта функция возвращает
0, гарантируется, что вызов dblink_get_result не будет заблокирован.
Примеры
SELECT dblink_is_busy('dtest1');
2510Дополнительно по-
ставляемые модули
dblink_get_notify
dblink_get_notify — выдаёт асинхронные уведомления подключения
Синтаксис
dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)
dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra
text)
Описание
dblink_get_notify выдаёт уведомления либо безымянного подключения, либо подключения с
заданным именем. Чтобы получать уведомления через dblink, необходимо сначала выполнить
LISTEN, воспользовавшись функцией dblink_exec. За подробностями обратитесь к LISTEN и
NOTIFY.
Аргументы
connname
Имя именованного подключения, уведомления которого нужно получить.
Возвращаемое значение
Возвращает setof (notify_name text, be_pid int, extra text) или пустой набор, если уведом-
лений нет.
Примеры
SELECT dblink_exec('LISTEN virtual');
dblink_exec
-------------
LISTEN
(1 row)
SELECT * FROM dblink_get_notify();
notify_name | be_pid | extra
-------------+--------+-------
(0 rows)
NOTIFY virtual;
NOTIFY
SELECT * FROM dblink_get_notify();
notify_name | be_pid | extra
-------------+--------+-------
virtual
|
1229 |
(1 row)
2511Дополнительно по-
ставляемые модули
dblink_get_result
dblink_get_result — получает результат асинхронного запроса
Синтаксис
dblink_get_result(text connname [, bool fail_on_error]) returns setof record
Описание
dblink_get_result получает результаты асинхронного запроса, запущенного ранее вызовом
dblink_send_query. Если запрос ещё выполняется, dblink_get_result будет ждать его заверше-
ния.
Аргументы
connname
Имя используемого подключения.
fail_on_error
Если равен true (это значение по умолчанию), в случае ошибки, выданной на удалённой стороне
соединения, ошибка также выдаётся локально. Если равен false, удалённая ошибка выдаётся
локально как ЗАМЕЧАНИЕ, и функция не возвращает строки.
Возвращаемое значение
Для асинхронного запроса (то есть, SQL-оператора, возвращающего строки) эта функция выдаёт
строки, полученные в результате запроса. Чтобы использовать эту функцию, вы должны задать
ожидаемый набор столбцов, как ранее говорилось в описании dblink.
Для асинхронной команды (то есть, SQL-оператора, не возвращающего строки), эта функция воз-
вращает одну строку с одним текстовым столбцом, содержащим строку состояния команды. Для
такого вызова в предложении FROM так же необходимо определить, что результат будет содержать
один текстовый столбец.
Замечания
Эта функция должна вызываться, если dblink_send_query возвращает 1. Её нужно вызывать по
одному разу для каждого отправленного запроса, а затем ещё раз для получения пустого набора
данных, прежде чем подключением можно будет пользоваться снова.
Когда используются dblink_send_query и dblink_get_result, подсистема dblink получает весь на-
бор удалённых результатов, прежде чем передавать его для локальной обработки. Если запрос
возвращает большое количество строк, это может занимать много памяти в локальном сеансе.
Поэтому может быть лучше открыть такой запрос как курсор, вызвав dblink_open, а затем выби-
рать результаты удобоваримыми порциями. Кроме того, можно воспользоваться простой функци-
ей dblink(), которая не допускает заполнения памяти, выгружая большие наборы результатов на
диск.
Примеры
contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
dblink_connect
----------------
OK
(1 row)
contrib_regression=# SELECT * FROM
2512Дополнительно по-
ставляемые модули
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 < 3') AS
t1;
t1
----
1
(1 row)
contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 |
f3
----+----+------------
0 | a | {a0,b0,c0}
1 | b | {a1,b1,c1}
2 | c | {a2,b2,c2}
(3 rows)
contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 | f3
----+----+----
(0 rows)
contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 < 3;
select * from foo where f1 > 6') AS t1;
t1
----
1
(1 row)
contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 |
f3
----+----+------------
0 | a | {a0,b0,c0}
1 | b | {a1,b1,c1}
2 | c | {a2,b2,c2}
(3 rows)
contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 |
f3
----+----+---------------
7 | h | {a7,b7,c7}
8 | i | {a8,b8,c8}
9 | j | {a9,b9,c9}
10 | k | {a10,b10,c10}
(4 rows)
contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text,
f3 text[]);
f1 | f2 | f3
----+----+----
(0 rows)
2513Дополнительно по-
ставляемые модули
dblink_cancel_query
dblink_cancel_query — отменяет любой активный запрос в заданном подключении
Синтаксис
dblink_cancel_query(text connname) returns text
Описание
Функция dblink_cancel_query пытается отменить любой запрос, выполняющийся через заданное
подключение. Заметьте, что её вызов не обязательно будет успешным (например, потому что уда-
лённый запрос уже завершился). Запрос отмены просто увеличивает шансы того, что выполняю-
щийся запрос будет вскоре прерван. При этом всё равно нужно завершить обычную процедуру
обработки запроса, например, вызвать dblink_get_result.
Аргументы
connname
Имя используемого подключения.
Возвращаемое значение
Возвращает OK, если запрос отмены был отправлен, либо текст сообщения об ошибке в случае
неудачи.
Примеры
SELECT dblink_cancel_query('dtest1');
2514Дополнительно по-
ставляемые модули
dblink_get_pkey
dblink_get_pkey — возвращает позиции и имена полей первичного ключа отношения
Синтаксис
dblink_get_pkey(text relname) returns setof dblink_pkey_results
Описание
Функция dblink_get_pkey выдаёт информацию о первичном ключе отношения в локальной базе
данных. Иногда это полезно при формировании запросов, отправляемых в удалённые базы данных.
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
"FooBar"; без кавычек эта строка приводится к нижнему регистру.
Возвращаемое значение
Возвращает одну строку для каждого поля первичного ключа, либо не возвращает строк, если в
отношении нет первичного ключа. Тип результирующей строки определён как
CREATE TYPE dblink_pkey_results AS (position int, colname text);
В столбце position содержится число от 1 до N; это номер поля в первичном ключе, а не номер
столбца в списке столбцов таблицы.
Примеры
CREATE TABLE foobar (
f1 int,
f2 int,
f3 int,
PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE
SELECT * FROM dblink_get_pkey('foobar');
position | colname
----------+---------
1 | f1
2 | f2
3 | f3
(3 rows)
2515Дополнительно по-
ставляемые модули
dblink_build_sql_insert
dblink_build_sql_insert — формирует оператор INSERT из локального кортежа, заменяя значения
полей первичного ключа переданными альтернативными значениями
Синтаксис
dblink_build_sql_insert(text relname,
int2vector primary_key_attnums,
integer num_primary_key_atts,
text[] src_pk_att_vals_array,
text[] tgt_pk_att_vals_array) returns text
Описание
Функция dblink_build_sql_insert может быть полезна при избирательной репликации локальной
таблицы с удалённой базой данных. Она выбирает строку из локальной таблицы по заданному
первичному ключу, а затем формирует SQL-команду INSERT, дублирующую эту строку, но заменяет
в ней значения первичного ключа данными из последнего аргумента. (Чтобы получить точную
копию строки, просто укажите одинаковые значения в двух последних аргументах.)
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
"FooBar"; без кавычек эта строка приводится к нижнему регистру.
primary_key_attnums
Номера атрибутов (начиная с 1) полей первичного ключа, например 1 2.
num_primary_key_atts
Число полей первичного ключа.
src_pk_att_vals_array
Значения полей первичного ключа, по которым будет выполняться поиск локального кортежа.
Каждое поле здесь представляется в текстовом виде. Если локальной строки с этими значени-
ями первичного ключа нет, выдаётся ошибка.
tgt_pk_att_vals_array
Значения полей первичного ключа, которые будут помещены в результирующую команду
INSERT. Каждое поле представляется в текстовом виде.
Возвращаемое значение
Возвращает запрошенный SQL-оператор в текстовом виде.
Замечания
Начиная с PostgreSQL 9.0, номера атрибутов в primary_key_attnums воспринимаются как логиче-
ские номера столбцов, соответствующие позициям столбцов в SELECT * FROM relname. Предыду-
щие версии воспринимали эти номера как физические позиции столбцов. Отличие этих подходов
проявляется, когда на протяжении жизни таблицы из неё удаляются столбцы левее указанных.
Примеры
SELECT dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
2516Дополнительно по-
ставляемые модули
dblink_build_sql_insert
--------------------------------------------------
INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
(1 row)
2517Дополнительно по-
ставляемые модули
dblink_build_sql_delete
dblink_build_sql_delete — формирует оператор DELETE со значениями, передаваемыми для полей
первичного ключа
Синтаксис
dblink_build_sql_delete(text relname,
int2vector primary_key_attnums,
integer num_primary_key_atts,
text[] tgt_pk_att_vals_array) returns text
Описание
Функция dblink_build_sql_delete может быть полезна при избирательной репликации локальной
таблицы с удалённой базой данных. Она формирует SQL-команду DELETE, которая удалит строку с
заданными значениями первичного ключа.
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
"FooBar"; без кавычек эта строка приводится к нижнему регистру.
primary_key_attnums
Номера атрибутов (начиная с 1) полей первичного ключа, например 1 2.
num_primary_key_atts
Число полей первичного ключа.
tgt_pk_att_vals_array
Значения полей первичного ключа, которые будут использоваться в результирующей команде
DELETE. Каждое поле представляется в текстовом виде.
Возвращаемое значение
Возвращает запрошенный SQL-оператор в текстовом виде.
Замечания
Начиная с PostgreSQL 9.0, номера атрибутов в primary_key_attnums воспринимаются как логиче-
ские номера столбцов, соответствующие позициям столбцов в SELECT * FROM relname. Предыду-
щие версии воспринимали эти номера как физические позиции столбцов. Отличие этих подходов
проявляется, когда на протяжении жизни таблицы из неё удаляются столбцы левее указанных.
Примеры
SELECT dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
dblink_build_sql_delete
---------------------------------------------
DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
(1 row)
2518Дополнительно по-
ставляемые модули
dblink_build_sql_update
dblink_build_sql_update — формирует оператор UPDATE из локального кортежа, заменяя значения
первичного ключа переданными альтернативными значениями
Синтаксис
dblink_build_sql_update(text relname,
int2vector primary_key_attnums,
integer num_primary_key_atts,
text[] src_pk_att_vals_array,
text[] tgt_pk_att_vals_array) returns text
Описание
Функция dblink_build_sql_update может быть полезна при избирательной репликации локаль-
ной таблицы с удалённой базой данных. Она выбирает строку из локальной таблицы по заданному
первичному ключу, а затем формирует SQL-команду UPDATE, дублирующую эту строку, но заме-
няющую в ней значения первичного ключа данными из последнего аргумента. (Чтобы получить
точную копию строки, просто укажите одинаковые значения в двух последних аргументах.) Ко-
манда UPDATE всегда присваивает значения всем полям строки — основное отличие этой функции
от dblink_build_sql_insert в том, что она предполагает, что целевая строка уже существует в
удалённой таблице.
Аргументы
relname
Имя локального отношения, например foo или myschema.mytab. Заключите его в двойные ка-
вычки, если это имя в смешанном регистре или содержит специальные символы, например
"FooBar"; без кавычек эта строка приводится к нижнему регистру.
primary_key_attnums
Номера атрибутов (начиная с 1) полей первичного ключа, например 1 2.
num_primary_key_atts
Число полей первичного ключа.
src_pk_att_vals_array
Значения полей первичного ключа, по которым будет выполняться поиск локального кортежа.
Каждое поле здесь представляется в текстовом виде. Если локальной строки с этими значени-
ями первичного ключа нет, выдаётся ошибка.
tgt_pk_att_vals_array
Значения полей первичного ключа, которые будут помещены в результирующую команду
UPDATE. Каждое поле представляется в текстовом виде.
Возвращаемое значение
Возвращает запрошенный SQL-оператор в текстовом виде.
Замечания
Начиная с PostgreSQL 9.0, номера атрибутов в primary_key_attnums воспринимаются как логиче-
ские номера столбцов, соответствующие позициям столбцов в SELECT * FROM relname. Предыду-
щие версии воспринимали эти номера как физические позиции столбцов. Отличие этих подходов
проявляется, когда на протяжении жизни таблицы из неё удаляются столбцы левее указанных.
Примеры
SELECT dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
2519Дополнительно по-
ставляемые модули
dblink_build_sql_update
-------------------------------------------------------------
UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
(1 row)
F.11. dict_int
Модуль dict_int представляет собой пример дополнительного шаблона словаря для полнотексто-
вого поиска. Этот словарь был создан для управляемой индексации целых чисел (со знаком и без);
он позволяет индексировать такие числа и при этом избежать чрезмерного разрастания списка
уникальных слов, и тем самым значительно увеличивает скорость поиска.
F.11.1. Конфигурирование
Этот словарь принимает два параметра:
• Параметр maxlen задаёт максимальное число цифр, из которого может состоять целое число.
Значение по умолчанию — 6.
• Параметр rejectlong определяет, должны ли чрезмерно длинные числа усекаться или игно-
рироваться. Если rejectlong имеет значение false (по умолчанию), этот словарь возвраща-
ет первые maxlen цифр целого числа. Если rejectlong равен true, чрезмерное длинное целое
воспринимается как стоп-слово, и в результате не индексируется. Заметьте, это означает, что
такое целое нельзя будет найти.
F.11.2. Использование
При установке расширения dict_int в базе создаётся шаблон текстового поиска intdict_template
и словарь intdict на его базе, с параметрами по умолчанию. Вы можете изменить параметры
словаря, например так:
mydb# ALTER TEXT SEARCH DICTIONARY intdict (MAXLEN = 4, REJECTLONG = true);
ALTER TEXT SEARCH DICTIONARY
или создать новые словари на базе этого шаблона.
Протестировать этот словарь можно так:
mydb# select ts_lexize('intdict', '12345678');
ts_lexize
-----------
{123456}
Но для практического применения его нужно включить в конфигурацию текстового поиска, как
описано в Главе 12. Это может выглядеть примерно так:
ALTER TEXT SEARCH CONFIGURATION english
ALTER MAPPING FOR int, uint WITH intdict;
F.12. dict_xsyn
Модуль dict_xsyn (Extended Synonym Dictionary, расширенный словарь синонимов) представляет
собой пример дополнительного шаблона словаря для полнотекстового поиска. Этот словарь заме-
няет слова группами их синонимов, что позволяет находить слово по одному из его синонимов.
F.12.1. Конфигурирование
Словарь dict_xsyn принимает следующие параметры:
• Параметр matchorig определяет, будет ли словарь принимать изначальное слово. По умолча-
нию он включён (имеет значение true).
• Параметр matchsynonyms определяет, будет ли словарь принимать синонимы. По умолчанию
он отключён (имеет значение false).
2520Дополнительно по-
ставляемые модули
• Параметр keeporig определяет, будет ли исходное слово включаться в вывод словаря. По
умолчанию он включён (имеет значение true).
• Параметр keepsynonyms определяет, будут ли в вывод словаря включаться синонимы. По
умолчанию он включён (имеет значение true).
• Параметр rules задаёт базовое имя файла со списком синонимов. Этот файл должен нахо-
диться в каталоге $SHAREDIR/tsearch_data/ (где под $SHAREDIR понимается каталог с общими
данными инсталляции PostgreSQL). Имя файла должно заканчиваться расширением .rules
(которое не нужно указывать в параметре rules).
Файл правил имеет следующий формат:
• Каждая строка представляет группу синонимов для одного слова, которое задаётся первым в
этой строке. Символы разделяются пробельными символами, так что строка выглядит так:
word syn1 syn2 syn3
• Символ решётки (#) обозначает начало комментария. Он может находиться в любом месте
строки. Следующая за ним часть строки игнорируется.
Пример словаря можно найти в файле xsyn_sample.rules, устанавливаемом в $SHAREDIR/
tsearch_data/.
F.12.2. Использование
При установке расширения dict_xsyn в базе создаётся шаблон текстового поиска xsyn_template и
словарь xsyn на его базе, с параметрами по умолчанию. Вы можете изменить параметры словаря,
например так:
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES='my_rules', KEEPORIG=false);
ALTER TEXT SEARCH DICTIONARY
или создать новые словари на базе этого шаблона.
Протестировать этот словарь можно так:
mydb=# SELECT ts_lexize('xsyn', 'word');
ts_lexize
-----------------------
{syn1,syn2,syn3}
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES='my_rules', KEEPORIG=true);
ALTER TEXT SEARCH DICTIONARY
mydb=# SELECT ts_lexize('xsyn', 'word');
ts_lexize
-----------------------
{word,syn1,syn2,syn3}
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES='my_rules', KEEPORIG=false,
MATCHSYNONYMS=true);
ALTER TEXT SEARCH DICTIONARY
mydb=# SELECT ts_lexize('xsyn', 'syn1');
ts_lexize
-----------------------
{syn1,syn2,syn3}
mydb# ALTER TEXT SEARCH DICTIONARY xsyn (RULES='my_rules', KEEPORIG=true,
MATCHORIG=false, KEEPSYNONYMS=false);
ALTER TEXT SEARCH DICTIONARY
mydb=# SELECT ts_lexize('xsyn', 'syn1');
2521Дополнительно по-
ставляемые модули
ts_lexize
-----------------------
{word}
Но для практического применения его нужно включить в конфигурацию текстового поиска, как
описано в Главе 12. Это может выглядеть примерно так:
ALTER TEXT SEARCH CONFIGURATION english
ALTER MAPPING FOR word, asciiword WITH xsyn, english_stem;
F.13. earthdistance
Модуль earthdistance реализует два разных варианта вычисления ортодромии (расстояния между
точками на поверхности Земли). Описанный первым вариант зависит от модуля cube (который
должен быть установлен, чтобы можно было установить earthdistance). Второй вариант основан
на встроенном типе данных point, в котором в качестве координат задаётся широта и долгота.
В этом модуле Земля считается идеальной сферой. (Если для вас это слишком грубо, обратите
внимание на проект PostGIS project.)
F.13.1. Земные расстояния по кубам
Данные хранятся в кубах, представляющих точки (оба угла куба совпадают) по 3 координатам,
выражающим смещения x, y и z от центра Земли. Этот модуль предоставляет домен earth на базе
cube, включающий проверки того, что значение соответствует этим ограничениям и представляет
точку, достаточно близкую к сферической поверхности Земли.
Радиус Земли выдаёт функция earth() (в метрах). Изменив одну эту функцию, вы можете сделать
так, чтобы модуль работал с другими единицами, либо выдать другое значение радиуса, которое
кажется вам более подходящим.
Этот пакет может также применяться и для астрономических расчётов. Астрономы обычно меня-
ют функцию earth(), чтобы она возвращала радиус, равный 180/pi(), и расстояния в результате
выдавались в градусах.
В этом модуле реализованы функции для ввода данных, выражающих широту и долготу (в граду-
сах), для вывода ширины и долготы, для вычисления ортодромии между двумя точками и простого
указания окружающего прямоугольника, что полезно для поиска по индексу.
Предоставляемые этим модулем функции показаны в Таблица F.5.
Таблица F.5. Функции земных расстояний по кубам
Функция Возвращает Описание
earth() float8 Возвращает
предполагаемый
радиус Земли.
sec_to_gc(float8) float8 Переводит расстояние по обыч-
ной прямой (по секущей) меж-
ду двумя точками на поверхно-
сти Земли в расстояние между
ними по сфере.
gc_to_sec(float8) float8 Переводит расстояние по сфе-
ре между двумя точками на по-
верхности Земли в расстояние
по обычной прямой (по секу-
щей) между ними.
ll_to_earth(float8,
float8) earth Возвращает положение точки
на поверхности Земли по задан-
ной широте (аргумент 1) и дол-
готе (аргумент 2) в градусах.
2522Дополнительно по-
ставляемые модули
Функция Возвращает Описание
latitude(earth) float8 Возвращает широту (в градусах)
точки на поверхности Земли.
longitude(earth) float8 Возвращает долготу (в граду-
сах) точки на поверхности Зем-
ли.
earth_distance(earth,
earth) float8 Возвращает расстояние по сфе-
ре между двумя точками на по-
верхности Земли.
earth_box(earth, float8) cube Возвращает охватывающий куб,
подходящий для поиска по ин-
дексу с применением операто-
ра кубов @> точек в пределах
заданной ортодромии от цели.
Некоторые точки в этом кубе
будут отстоять от цели дальше,
чем на заданную ортодромию,
поэтому в запрос нужно вклю-
чить вторую проверку с функци-
ей earth_distance .
F.13.2. Земные расстояния по точкам
Вторая часть этого модуля основана на представлении точек на Земле в виде значений типа point,
в которых первый компонент представляет долготу в градусах, а второй — широту. Точки воспри-
нимаются как (долгота, широта), а не наоборот, так как долгота ближе к интуитивному представ-
лению как оси X, а широта — оси Y.
В модуле реализован один оператор, показанный в Таблице F.6.
Таблица F.6. Операторы земных расстояний по точкам
Оператор Возвращает Описание
point <@> point float8 Выдаёт расстояние в сухопут-
ных милях между точками на
поверхности Земли.
Заметьте, что в этой части модуля, в отличие от части, построенной на cube, единицы зашиты
жёстко: изменение функции earth() не повлияет на результат этого оператора.
Представление в виде долготы/широты плохо тем, что вам придётся учитывать граничные условия
возле полюсов и в районе +/- 180 градусов долготы. Представление на базе cube лишено таких
нарушений непрерывности.
F.14. file_fdw
Модуль file_fdw реализует обёртку сторонних данных file_fdw, с помощью которой можно об-
ращаться к файлам данных в файловой системе сервера или выполнять программы на сервере и
читать их вывод. Файлы и вывод программ должны быть в формате, который понимает команда
COPY FROM; он рассматривается в описании COPY. В настоящее время файлы доступны только для
чтения.
Для сторонней таблицы, создаваемой через эту обёртку, можно задать следующие параметры:
filename
Определяет имя файла, который нужно прочитать. Это имя должно задаваться абсолютным
путём. Необходимо определить либо параметр filename, либо program, но не оба сразу.
2523Дополнительно по-
ставляемые модули
program
Определяет команду, которая будет выполнена. Поток стандартного вывода этой команды бу-
дет прочитан так же, как и с COPY FROM PROGRAM. Необходимо определить либо параметр
program, либо filename, но не оба сразу.
format
Определяет формат файла (аналогично указанию FORMAT в команде COPY).
header
Указывает, что данные содержат строку заголовка с именами столбцов (аналогично указанию
HEADER в команде COPY).
delimiter
Задаёт символ, разделяющий столбцы в данных (аналогично указанию DELIMITER в команде
COPY).
quote
Задаёт символ, используемый для заключения данных в кавычки (аналогично указанию QUOTE
в команде COPY).
escape
Задаёт символ, используемый для экранирования данных (аналогично указанию ESCAPE в ко-
манде COPY).
null
Определяет строку, задающую значение NULL в данных (аналогично указанию NULL в команде
COPY).
encoding
Задаёт кодировку данных (аналогично указанию ENCODING в команде COPY).
Заметьте, что хотя COPY принимает указания, такие как HEADER, без соответствующего значения,
синтаксис обёртки сторонних данных требует, чтобы значение присутствовало во всех случаях.
Чтобы активировать указания COPY, которым значение обычно не передаётся, им можно просто
передать значение TRUE, так как все они являются логическими.
Для столбцов сторонней таблицы, создаваемой через эту обёртку, можно задать следующие пара-
метры:
force_not_null
Логическое значение. Если true, то значение столбца не должно сверяться со значением NULL
(заданным в параметре null на уровне таблицы). Аналогично включению столбца в список ука-
зания FORCE_NOT_NULL команды COPY.
force_null
Логическое значение. Если true, значения столбцов нужно сверять со значением NULL (задан-
ным в параметре NULL), даже если они заключены в кавычки. Без этого параметра только зна-
чения без кавычек, соответствующие значению null, будут возвращаться как NULL. Аналогич-
но включению столбца в список указания FORCE_NULL команды COPY.
В настоящий момент file_fdw не поддерживает указания OIDS и FORCE_QUOTE команды COPY.
Перечисленные параметры применимы только для сторонних таблиц или их столбцов. Их нельзя
указать для обёртки сторонних данных file_fdw, серверов или сопоставлений пользователей, ис-
пользующих эту обёртку.
2524Дополнительно по-
ставляемые модули
Для изменения параметров, определяемых для таблицы, требуется быть суперпользователем или
иметь права стандартной роли pg_read_server_files (для указания имени файла) или стандарт-
ной роли pg_execute_server_programs (для указания программы). Это сделано в целях безопасно-
сти: только избранные пользователи должны выбирать, какой файл читать или какую программу
запускать. В принципе право изменения остальных параметров можно предоставить и обычным
пользователям, но в настоящий момент это не реализовано.
Задавая параметр program, помните, что эта строка выполняется оболочкой ОС. Если вы хотите
передавать заданной команде параметры из недоверенного источника, позаботьтесь об исключе-
нии или экранировании всех символов, которые могут иметь особое назначение в оболочке. По
соображениям безопасности лучше, чтобы эта командная строка была фиксированной или как ми-
нимум в ней не передавались данные, поступающие от пользователя.
Для сторонних таблиц, работающих через file_fdw, команда EXPLAIN показывает имя используе-
мого файла или запускаемой программы. Если не указывать COSTS OFF, то выводится и размер
файла (в байтах).
Пример F.1. Создание сторонней таблицы для журнала сервера PostgreSQL
Одно из очевидных применений file_fdw это предоставление доступа к журналу сообщений
PostgreSQL как к таблице. Для этого необходимо предварительно настроить вывод сообщений в
файл CSV (дальше мы будем считать, что это файл pglog.csv). Сначала установите расширение
file_fdw:
CREATE EXTENSION file_fdw;
Затем создайте сторонний сервер:
CREATE SERVER pglog FOREIGN DATA WRAPPER file_fdw;
Всё готово для создания сторонней таблицы. В команде CREATE FOREIGN TABLE нужно перечислить
столбцы таблицы, указать файл CSV и его формат:
CREATE FOREIGN TABLE pglog (
log_time timestamp(3) with time zone,
user_name text,
database_name text,
process_id integer,
connection_from text,
session_id text,
session_line_num bigint,
command_tag text,
session_start_time timestamp with time zone,
virtual_transaction_id text,
transaction_id bigint,
error_severity text,
sql_state_code text,
message text,
detail text,
hint text,
internal_query text,
internal_query_pos integer,
context text,
query text,
query_pos integer,
location text,
application_name text
) SERVER pglog
OPTIONS ( filename '/home/josh/data/log/pglog.csv', format 'csv' );
Вот и всё. Теперь для просмотра журнала сервера можно просто выполнять запросы к таблице. В
производственной среде, разумеется, ещё потребуется как-то учесть ротацию файлов журнала.
2525Дополнительно по-
ставляемые модули
F.15. fuzzystrmatch
Модуль fuzzystrmatch содержит несколько функций для вычисления схожести и расстояния меж-
ду строками.
Внимание
В настоящее время функции soundex, metaphone, dmetaphone и dmetaphone_alt плохо
работают с многобайтными кодировками (в частности, с UTF-8).
F.15.1. Soundex
Система Soundex позволяет вычислить похожие по звучанию имена, приводя их к одинаковым
кодам. Изначально она использовалась для обработки данных переписи населения США в 1880,
1900 и 1910 г. Заметьте, что эта система не очень полезна для неанглоязычных имён.
Модуль fuzzystrmatch предоставляет две функции для работы с кодами Soundex:
soundex(text) returns text
difference(text, text) returns int
Функция soundex преобразует строку в код Soundex. Функция difference преобразует две строки
в их коды Soundex и затем сообщает количество совпадающих позиций в этих кодах. Так как коды
Soundex состоят из четырёх символов, результатом может быть число от нуля до четырёх (0 обо-
значает полное несоответствие, а 4 — точное совпадение). (Таким образом, имя этой функции не
вполне корректное — лучшим именем для неё было бы similarity.)
Несколько примеров использования:
SELECT soundex('hello world!');
SELECT soundex('Anne'), soundex('Ann'), difference('Anne', 'Ann');
SELECT soundex('Anne'), soundex('Andrew'), difference('Anne', 'Andrew');
SELECT soundex('Anne'), soundex('Margaret'), difference('Anne', 'Margaret');
CREATE TABLE s (nm text);
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
s
s
s
s
VALUES
VALUES
VALUES
VALUES
('john');
('joan');
('wobbly');
('jack');
SELECT * FROM s WHERE soundex(nm) = soundex('john');
SELECT * FROM s WHERE difference(s.nm, 'john') > 2;
F.15.2. Левенштейн
Эта функция вычисляет расстояние Левенштейна между двумя строками:
levenshtein(text source, text target, int ins_cost, int del_cost, int sub_cost) returns
int
levenshtein(text source, text target) returns int
levenshtein_less_equal(text source, text target, int ins_cost, int del_cost, int
sub_cost, int max_d) returns int
levenshtein_less_equal(text source, text target, int max_d) returns int
И в source, и в target может быть передана любая строка, отличная от NULL, не длиннее 255
символов. Параметры стоимости (ins_cost, del_cost, sub_cost) определяют цену добавления, удале-
2526Дополнительно по-
ставляемые модули
ния или замены символов, соответственно. Эти параметры можно опустить, как во второй версии
функции; в этом случае все они по умолчанию равны 1.
Функция levenshtein_less_equal является ускоренной версией функции Левенштейна, предна-
значенной для использования, только когда интерес представляют небольшие расстояния. Если
фактическое расстояние меньше или равно max_d, то levenshtein_less_equal возвращает точное
его значение; в противном случае она возвращает значение, большее чем max_d. Если значение
max_d отрицательное, она работает так же, как функция levenshtein.
Примеры:
test=# SELECT levenshtein('GUMBO', 'GAMBOL');
levenshtein
-------------
2
(1 row)
test=# SELECT levenshtein('GUMBO', 'GAMBOL', 2, 1, 1);
levenshtein
-------------
3
(1 row)
test=# SELECT levenshtein_less_equal('extensive', 'exhaustive', 2);
levenshtein_less_equal
------------------------
3
(1 row)
test=# SELECT levenshtein_less_equal('extensive', 'exhaustive', 4);
levenshtein_less_equal
------------------------
4
(1 row)
F.15.3. Metaphone
Metaphone, как и Soundex, построен на идее составления кода, представляющего входную строку.
Две строки признаются похожими, если их коды совпадают.
Эта функция вычисляет код метафона входной строки:
metaphone(text source, int max_output_length) returns text
В качестве source должна передаваться строка, отличная от NULL, не длиннее 255 символов. Па-
раметр max_output_length задаёт максимальную длину выходного кода метафона; если код ока-
зывается длиннее, он обрезается до этой длины.
Пример:
test=# SELECT metaphone('GUMBO', 4);
metaphone
-----------
KM
(1 row)
F.15.4. Double Metaphone
Алгоритм Double Metaphone (Двойной метафон) вычисляет две строки «похожего звучания» для
заданной строки — «первичную» и «альтернативную». В большинстве случаев они совпадают, но
2527Дополнительно по-
ставляемые модули
для неанглоязычных имён в особенности они могут быть весьма различными, в зависимости от
произношения. Эти функции вычисляют первичный и альтернативный коды:
dmetaphone(text source) returns text
dmetaphone_alt(text source) returns text
Длина входных строк может быть любой.
Пример:
test=# SELECT dmetaphone('gumbo');
dmetaphone
------------
KMP
(1 row)
F.16. hstore
Этот модуль реализует тип данных hstore для хранения пар ключ/значение внутри одного значе-
ния PostgreSQL. Это может быть полезно в самых разных сценариях, например для хранения строк
со множеством редко анализируемых атрибутов или частично структурированных данных. Ключи
и значения задаются простыми текстовыми строками.
F.16.1. Внешнее представление hstore
Текстовое представление типа hstore, применяемое для ввода и вывода, включает ноль или более
пар ключ => значение, разделённых запятыми. Несколько примеров:
k => v
foo => bar, baz => whatever
"1-a" => "anything at all"
Порядок пар не имеет значения (и может не воспроизводиться при выводе). Пробелы между па-
рами и вокруг знака => игнорируются. Ключи и значения, содержащие пробелы, запятые и знаки
= или >, нужно заключать в двойные кавычки. Если в ключ или значение нужно вставить символ
кавычек или обратную косую черту, добавьте перед ним обратную косую черту.
Все ключи в hstore уникальны. Если вы объявите тип hstore с дублирующимися ключами, в hstore
будет сохранён только один ключ без гарантии определённого выбора:
SELECT 'a=>1,a=>2'::hstore;
hstore
----------
"a"=>"1"
В качестве значения (но не ключа) может задаваться SQL NULL. Например:
key => NULL
В ключевом слове NULL регистр не имеет значения. Если требуется, чтобы текст NULL восприни-
мался как обычная строка «NULL», заключите его в кавычки.
Примечание
Учтите, что когда текстовый формат hstore используется для ввода данных, он приме-
няется до обработки кавычек или спецсимволов. Таким образом, если значение hstore
передаётся в параметре, дополнительная обработка не требуется. Но если вы переда-
ёте его в виде строковой константы, то все символы апострофов и (в зависимости от
параметра конфигурации standard_conforming_strings) обратной косой черты нужно
корректно экранировать. Подробнее о записи строковых констант можно узнать в Под-
разделе 4.1.2.1.
2528Дополнительно по-
ставляемые модули
При выводе значения и ключи всегда заключаются в кавычки, даже когда без этого можно обой-
тись.
F.16.2. Операторы и функции hstore
Реализованные в модуле hstore операторы перечислены в Таблице F.7, функции — в Таблице F.8.
Таблица F.7. Операторы hstore
Оператор Описание hstore -> text выдаёт значение для 'a=>x, b=>y'::hstore
ключа (или NULL при -> 'a'
его отсутствии) x
hstore -> text[] выдаёт значения для 'a=>x,
b=>y,
ключей (или NULL при
c=>z'::hstore
->
их отсутствии)
ARRAY['c','a'] {"z","x"}
hstore || hstore объединяет два набора 'a=>b, c=>d'::hstore "a"=>"b",
hstore
||
'c=>x, "d"=>"q"
d=>q'::hstore
hstore ? text набор hstore включает 'a=>1'::hstore ? 'a'
ключ? t
hstore ?& text[] набор hstore включает 'a=>1,
все указанные ключи? b=>2'::hstore
ARRAY['a','b'] t
hstore ?| text[]
Пример
набор hstore включает 'a=>1,
какой-либо из указан- b=>2'::hstore
ных ключей?
ARRAY['b','c']
Результат
"c"=>"x",
?&
t
?|
hstore @> hstore левый операнд включа- 'a=>b,
b=>1,
ет правый?
c=>NULL'::hstore @>
'b=>1' hstore <@ hstore левый операнд вклю- 'a=>c'::hstore
<@ f
чён в правый?
'a=>b,
b=>1,
c=>NULL'
hstore - text удаляет ключ из левого 'a=>1,
b=>2,
операнда
c=>3'::hstore
-
'b'::text "a"=>"1", "c"=>"3"
hstore - text[] удаляет ключи из лево- 'a=>1,
b=>2,
го операнда
c=>3'::hstore
-
ARRAY['a','b'] "c"=>"3"
hstore - hstore удаляет соответствую- 'a=>1,
b=>2,
щие пары из левого
c=>3'::hstore
-
операнда
'a=>4, b=>2'::hstore "a"=>"1", "c"=>"3"
record #= hstore заменяет поля в record см. раздел Примеры
соответствующими зна-
чениями из hstore %% hstore преобразует hstore в %%
'a=>foo, {a,foo,b,bar}
массив
перемежаю- b=>bar'::hstore
щихся ключей и значе-
ний
%# hstore преобразует hstore в %#
'a=>foo, {{a,foo},{b,bar}}
двумерный массив клю- b=>bar'::hstore
чей/значений
2529
tДополнительно по-
ставляемые модули
Примечание
До версии PostgreSQL 8.2 операторы включения @> и <@ обозначались соответственно
как @ и ~. Эти имена по-прежнему действуют, но считаются устаревшими и в конце
концов будут упразднены. Заметьте, что старые имена произошли из соглашения, ко-
торому раньше следовали геометрические типы данных!
Таблица F.8. Функции hstore
Функция Тип результата Описание hstore(record) hstore формирует hstore hstore(ROW(1,
из записи или кор- 2))
тежа f1=>1,f2=>2
hstore(text[]) hstore формирует hstore
из массива, кото-
рый может содер-
жать попарно клю-
чи/значения, ли-
бо быть двумер-
ным массивом a=>1,
b=>2,
c=>3, d=>4
hstore(text[],
text[]) hstore формирует hstore hstore(
из отдельных мас- ARRAY['a',
сивов ключей и 'b'],
значений
ARRAY['1',
'2']) "a"=>"1",
"b"=>"2"
hstore(text,
text) hstore формирует hstore hstore('a',
с одним элемен- 'b')
том "a"=>"b"
akeys(hstore) text[] выдаёт
ключи akeys('a=>1,
hstore в виде мас- b=>2')
сива {a,b}
skeys(hstore) setof text выдаёт
ключи skeys('a=>1,
hstore в виде мно- b=>2')
жества a
b
avals(hstore) text[] выдаёт
ключи avals('a=>1,
hstore в виде мас- b=>2')
сива {1,2}
svals(hstore) setof text выдаёт значения svals('a=>1,
hstore в виде мно- b=>2')
жества 1
2
hstore_to_
array(hstore) text[] выдаёт ключи и hstore_to_
значения hstore в array('a=>1,
виде массива пере- b=>2')
межающихся клю-
чей и значений {a,1,b,2}
hstore_to_
matrix(hstore) text[] выдаёт ключи и hstore_to_
значения hstore matrix('a=>1,
в виде двумерного b=>2')
массива {{a,1},{b,2}}
hstore_to_
json(hstore) json выдаёт hstore в hstore_to_
виде
значения json('"a
json, преобразуя key"=>1,
b=>t, {"a
2530
Пример
hstore(
ARRAY['a','1',
'b','2'])
||
hstore(
ARRAY[['c',
'3'],['d',
'4']])
Результат
key": "1",
"b":
"t",
"c":
null,Дополнительно по-
ставляемые модули
Функция Тип результата Описание
Пример
все отличные от
c=>null,
NULL значения в
d=>12345,
строки JSON
e=>012345,
f=>1.234,
g=>2.345e+4') Результат
"d": "12345",
"e": "012345",
"f": "1.234",
"g": "2.345e
+4"}
hstore_to_
jsonb(hstore) jsonb выдаёт hstore в hstore_to_
виде
значения jsonb('"a
jsonb, преобразуя key"=>1,
b=>t,
все отличные от
c=>null,
NULL значения в
d=>12345,
строки JSON
e=>012345,
f=>1.234,
g=>2.345e+4') {"a
hstore_to_
json_loose(
hstore) json выдаёт hstore в
виде
значения
json, по возмож-
ности распознавая
числовые и логи-
ческие значения
и передавая их в
JSON без кавычек hstore_to_
json_loose(
'"a
key"=>1,
b=>t, c=>null,
d=>12345,
e=>012345,
f=>1.234,
g=>2.345e+4') {"a
hstore_to_
jsonb_loose(
hstore) jsonb выдаёт hstore в
виде
значения
jsonb, по возмож-
ности распознавая
числовые и логи-
ческие значения
и передавая их в
JSON без кавычек hstore_to_
jsonb_loose(
'"a
key"=>1,
b=>t, c=>null,
d=>12345,
e=>012345,
f=>1.234,
g=>2.345e+4') {"a
slice(hstore,
text[]) hstore извлекает подмно- slice('a=>1,
жество из hstore b=>2,
c=>3'::hstore,
ARRAY['b','c',
'x']) each(hstore) setof(key text,
value text) выдаёт ключи и select
* key | value
значения hstore в from each('a=>1, -----+-------
a
| 1
виде множества
b=>2')
b
| 2
exist(hstore,
text) boolean набор
hstore exist('a=>1',
включает ключ?
'a') t
defined(hstore,
text) boolean набор
hstore defined(
включает для клю- 'a=>NULL','a')
ча значение, от-
личное от NULL? f
delete(hstore,
text) hstore удаляет
пару delete('a=>1,
с
соответствую- b=>2','b')
щим ключом "a"=>"1"
delete(hstore,
text[]) hstore удаляет
пары delete('a=>1,
с соответствующи- b=>2,c=>3',
ми ключами
ARRAY['a',
'b']) "c"=>"3"
2531
key": "1",
"b":
"t",
"c":
null,
"d": "12345",
"e": "012345",
"f": "1.234",
"g": "2.345e
+4"}
key":
1,
"b":
true,
"c":
null,
"d":
12345,
"e": "012345",
"f":
1.234,
"g": 2.345e+4}
key":
1,
"b":
true,
"c":
null,
"d":
12345,
"e": "012345",
"f":
1.234,
"g": 2.345e+4}
"b"=>"2",
"c"=>"3"Дополнительно по-
ставляемые модули
Функция Тип результата Описание
Пример
delete(hstore,
hstore) hstore удаляет пары, со- delete('a=>1,
ответствующие па- b=>2','a=>4,
рам во втором ар- b=>2'::hstore)
гументе
populate_
record(record,
hstore) record заменяет поля в см. раздел Приме-
record
соответ- ры
ствующими значе-
ниями из hstore
Результат
"a"=>"1"
Примечание
Функция hstore_to_json применяется, когда значение hstore нужно привести к json.
Подобным образом, hstore_to_jsonb применяется, когда значение hstore нужно при-
вести к jsonb.
Примечание
Функция populate_record на самом деле объявлена как принимающая в первом аргу-
менте anyelement, а не record, но если ей будет передан не тип записи, она выдаст
ошибку.
F.16.3. Индексы
Тип hstore поддерживает индексы GiST и GIN для операторов @>, ?, ?& и ?|. Например:
CREATE INDEX hidx ON testhstore USING GIST (h);
CREATE INDEX hidx ON testhstore USING GIN (h);
Тип hstore также поддерживает индексы btree и hash для оператора =. Это позволяет объявлять
столбцы hstore как уникальные (UNIQUE) и использовать их в выражениях GROUP BY, ORDER BY или
DISTINCT. Порядок сортировки значений hstore не имеет практического смысла, но эти индексы
могут быть полезны для поиска по равенству. Индексы для сравнений (с помощью =) можно создать
так:
CREATE INDEX hidx ON testhstore USING BTREE (h);
CREATE INDEX hidx ON testhstore USING HASH (h);
F.16.4. Примеры
Добавление ключа или изменение значения для существующего ключа:
UPDATE tab SET h = h || hstore('c', '3');
Удаление ключа:
UPDATE tab SET h = delete(h, 'k1');
Приведение типа record к типу hstore:
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');
SELECT hstore(t) FROM test AS t;
hstore
---------------------------------------------
2532Дополнительно по-
ставляемые модули
"col1"=>"123", "col2"=>"foo", "col3"=>"bar"
(1 row)
Приведение типа hstore к предопределённому типу record:
CREATE TABLE test (col1 integer, col2 text, col3 text);
SELECT * FROM populate_record(null::test,
'"col1"=>"456", "col2"=>"zzz"');
col1 | col2 | col3
------+------+------
456 | zzz |
(1 row)
Изменение существующей записи по данным из hstore:
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');
SELECT (r).* FROM (SELECT t #= '"col3"=>"baz"' AS r FROM test t) s;
col1 | col2 | col3
------+------+------
123 | foo | baz
(1 row)
F.16.5. Статистика
Тип hstore, вследствие присущей ему либеральности, может содержать множество самых разных
ключей. Контроль допустимости ключей является задачей приложения. Следующие примеры де-
монстрируют несколько приёмов проверки ключей и получения статистики.
Простой пример:
SELECT * FROM each('aaa=>bq, b=>NULL, ""=>1');
С таблицей:
SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;
Актуальная статистика:
SELECT key, count(*) FROM
(SELECT (each(h)).key FROM testhstore) AS stat
GROUP BY key
ORDER BY count DESC, key;
key
| count
-----------+-------
line
|
883
query
|
207
pos
|
203
node
|
202
space
|
197
status
|
195
public
|
194
title
|
190
org
|
189
...................
F.16.6. Совместимость
Начиная с PostgreSQL 9.0, hstore использует внутреннее представление, отличающееся от преды-
дущих версий. Это не проблема при обновлении путём выгрузки/перезагрузки данных, так как
текстовое представление (используемое при выгрузке) не меняется.
2533Дополнительно по-
ставляемые модули
В случае двоичного обновления обратная совместимость поддерживается благодаря тому, что но-
вый код понимает данные в старом формате. При таком обновлении возможно небольшое сниже-
ние производительности при обработке данных, которые ещё не были изменены новым кодом.
Все значения в столбце таблицы можно обновить принудительно, выполнив следующий оператор
UPDATE:
UPDATE tablename SET hstorecol = hstorecol || '';
Это можно сделать и так:
ALTER TABLE tablename ALTER hstorecol TYPE hstore USING hstorecol || '';
Вариант с командой ALTER TABLE требует расширенной блокировки таблицы, но не приводит к
замусориванию таблицы старыми версиями строк.
F.16.7. Трансформации
Также имеются дополнительные расширения, реализующие трансформации типа hstore для язы-
ков PL/Perl и PL/Python. Расширения для PL/Perl называются hstore_plperl и hstore_plperlu для
доверенного и недоверенного PL/Perl, соответственно. Если вы установите эти трансформации и
укажете их при создании функции, значения hstore будут отображаться в хеши Perl. Расширения
для PL/Python называются hstore_plpythonu, hstore_plpython2u и hstore_plpython3u (соглаше-
ния об именовании, принятые для интерфейса PL/Python, описаны в Разделе 46.1). Если вы вос-
пользуетесь ими, значения hstore будут отображаться в словари Python.
F.16.8. Авторы
Олег Бартунов <oleg@sai.msu.su>, Москва, Московский Государственный Университет, Россия
Фёдор Сигаев <teodor@sigaev.ru>, Москва, ООО «Дельта-Софт», Россия
Дополнительные улучшения внёс Эндрю Гирт <andrew@tao11.riddles.org.uk>, Великобритания
F.17. intagg
Модуль intagg предоставляет агрегатор и нумератор целых чисел. На данный момент имеются
встроенные функции, предлагающие более широкие возможности, поэтому intagg считается уста-
ревшим. Однако этот модуль продолжает существовать для обратной совместимости, теперь как
набор обёрток встроенных функций.
F.17.1. Функции
Агрегатор реализуется функцией int_array_aggregate(integer), которая выдаёт массив целых
чисел, содержащий в точности те числа, что переданы ей. Это обёртка встроенной функции
array_agg, которая делает то же самое для массива любого типа.
Нумератор реализуется функцией int_array_enum(integer[]), которая возвращает набор целых
(setof integer). По сути его действие обратно действие агрегатора: получив массив целых, он
разворачивает его в набор строк. Это оболочка функции unnest, которая делает то же самое для
массива любого типа.
F.17.2. Примеры использования
Во многих СУБД есть понятие таблицы соотношений «один ко многим». Такая таблица обычно
находится между двумя индексированными таблицами, например:
CREATE TABLE left (id INT PRIMARY KEY, ...);
CREATE TABLE right (id INT PRIMARY KEY, ...);
CREATE TABLE one_to_many(left INT REFERENCES left, right INT REFERENCES right);
Как правило, она используется так:
2534Дополнительно по-
ставляемые модули
SELECT right.* from right JOIN one_to_many ON (right.id = one_to_many.right)
WHERE one_to_many.left = item;
Этот запрос вернёт все элементы из таблицы справа для записи в таблице слева. Это очень рас-
пространённая конструкция в SQL.
Однако этот подход может вызывать затруднения с очень большим количеством записей в таблице
one_to_many. Часто такое соединение влечёт сканирование индекса и выборку каждой записи в
таблице справа для конкретного элемента слева. Если у вас динамическая система, с этим ничего
не поделать. Но если какое-то множество данных довольно статическое, вы можете создать свод-
ную таблицу, применив агрегатор.
CREATE TABLE summary AS
SELECT left, int_array_aggregate(right) AS right
FROM one_to_many
GROUP BY left;
Эта команда создаст таблицу, содержащую одну строку для каждого элемента слева с массивом
элементов справа. Она малополезна, пока не найден подходящий способ использования этого мас-
сива; именно для этого и нужен нумератор массива. Вы можете выполнить:
SELECT left, int_array_enum(right) FROM summary WHERE left = элемент;
Приведённый выше запрос с вызовом int_array_enum выдаёт те же результаты, что и
SELECT left, right FROM one_to_many WHERE left = элемент;
Отличие состоит в том, что запрос к сводной таблице должен выдать только одну строку таблицы,
тогда как непосредственный запрос к one_to_many потребует сканирования индекса и выборки
строки для каждой записи.
На тестовом компьютере команда EXPLAIN показала, что стоимость запроса снизилась с 8488 до
329. Исходный запрос выполнял соединение с таблицей one_to_many и был заменён на:
SELECT right, count(right) FROM
( SELECT left, int_array_enum(right) AS right
FROM summary JOIN (SELECT left FROM left_table WHERE left = элемент) AS lefts
ON (summary.left = lefts.left)
) AS list
GROUP BY right
ORDER BY count DESC;
F.18. intarray
Модуль intarray предоставляет ряд полезных функций и операторов для работы с массивами це-
лых чисел без NULL. Также он поддерживает поиск по индексу для некоторых из этих операторов.
Все эти операции выдают ошибку, если в передаваемом массиве оказываются значения NULL.
Многие из этих операций имеют смысл только с одномерными массивами. Хотя им можно передать
входной массив и большей размерности, значения будут считываться из него как из линейного
массива в порядке хранения.
F.18.1. Функции и операторы intarray
Реализованные в модуле intarray функции перечислены в Таблице F.9, а операторы — в Табли-
це F.10.
Таблица F.9. Функции intarray
Функция Тип результата Описание
icount(int[]) int число элементов в icount('{1,2,
массиве
3}'::int[])
2535
Пример
Результат
3Дополнительно по-
ставляемые модули
Функция Тип результата Описание sort(int[],
text dir) int[] сортирует массив sort('{1,2,
— в dir должно 3}'::int[],
задаваться asc (по 'desc')
возрастанию) или
desc (по убыва-
нию) {3,2,1}
sort(int[]) int[] сортирует в поряд- sort(array[11,
ке возрастания
77,44]) {11,44,77}
sort_asc(
int[]) int[] сортирует в поряд-
ке возрастания sort_desc(
int[]) int[] сортирует в поряд-
ке убывания uniq(int[]) int[] удаляет
ты int индекс
первого idx(array[11,
элемента, равного 22,33,22,
item (0, если тако- 11], 22)
го нет) 2
subarray(int[],
int start, int
len) int[] часть массива, на- subarray('{1,
чинающаяся с по- 2,3,2,
зиции start и со- 1}'::int[], 2,
стоящая из len 3)
элементов {2,3,2}
subarray(int[],
int start) int[] часть массива, на- subarray('{1,
чинающаяся с по- 2,3,2,
зиции start
1}'::int[], 2) {2,3,2,1}
intset(int) int[] создаёт массив с intset(42)
одним элементом {42}
idx(int[],
item)
int
Пример
дублика- uniq(sort('{1,
2,3,2,
1}'::int[]))
Результат
{1,2,3}
Таблица F.10. Операторы intarray
Оператор Возвращает Описание
int[] && int[] boolean пересекается с — true, если
массивы имеют минимум один
общий элемент
int[] @> int[] boolean включает — true, если левый
массив содержит правый мас-
сив
int[] <@ int[] boolean включается в — true, если ле-
вый массив содержится в пра-
вом массиве
# int[] int число элементов в массиве
int[] # int int индекс элемента (делает то же,
что и функция idx)
int[] + int int[] вставляет элемент в массив (до-
бавляет его в конец массива)
int[] + int[] int[] соединяет массивы (правый
массив добавляется в конец ле-
вого)
2536Дополнительно по-
ставляемые модули
Оператор Возвращает Описание
int[] - int int[] удаляет из массива записи, рав-
ные правому аргументу
int[] - int[] int[] удаляет из левого массива эле-
менты правого массива
int[] | int int[] объединение аргументов
int[] | int[] int[] объединение массивов
int[] & int[] int[] пересечение массивов
int[] @@ query_int boolean true, если массив удовлетворя-
ет запросу (см. ниже)
query_int ~~ int[] boolean true, если запросу удовлетво-
ряет массив (коммутирующий
оператор к @@)
(До версии PostgreSQL 8.2 операторы включения @> и <@ обозначались соответственно как @ и ~.
Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упраздне-
ны. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые
геометрические типы данных!)
Операторы &&, @> и <@ равнозначны встроенным операторам PostgreSQL с теми же именами, за ис-
ключением того, что они работают только с целочисленными массивами, не содержащими NULL,
тогда как встроенные операторы работают с массивами любых типов. Благодаря этому ограниче-
нию, в большинстве случаев они работают быстрее, чем встроенные операторы.
Операторы @@ и ~~ проверяют, удовлетворяет ли массив запросу, представляемому в виде значения
специализированного типа данных query_int. Запрос содержит целочисленные значения, сравни-
ваемые с элементами массива, возможно с использованием операторов & (AND), | (OR) и ! (NOT).
При необходимости могут использоваться скобки. Например, запросу 1&(2|3) удовлетворяют за-
просы, которые содержат 1 и также содержат 2 или 3.
F.18.2. Поддержка индексов
Модуль intarray поддерживает индексы для операторов &&, @>, <@ и @@, а также обычную проверку
равенства массивов.
Модуль предоставляет два класса операторов GiST: gist__int_ops (используется по умолчанию),
подходящий для маленьких и средних по размеру наборов данных, и gist__intbig_ops, применя-
ющий сигнатуру большего размера и подходящий для индексации больших наборов данных (то
есть столбцов, содержащих много различных значений массива). В этой реализации используется
структура данных RD-дерева со встроенным сжатием с потерями.
Есть также нестандартный класс операторов GIN, gin__int_ops, поддерживающий те же операто-
ры.
Выбор между индексами GiST и GIN зависит от относительных характеристик производительности
GiST и GIN, которые здесь не рассматриваются.
F.18.3. Пример
-- сообщение может относиться к одной или нескольким «секциям»
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);
-- создать специализированный индекс
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);
-- вывести сообщения из секций 1 или 2 — оператор пересечения
SELECT message.mid FROM message WHERE message.sections && '{1,2}';
2537Дополнительно по-
ставляемые модули
-- вывести сообщения из секций 1 и 2 — оператор включения
SELECT message.mid FROM message WHERE message.sections @> '{1,2}';
-- тот же результат, но с оператором запроса
SELECT message.mid FROM message WHERE message.sections @@ '1&2'::query_int;
F.18.4. Тестирование производительности
В каталоге исходного кода contrib/intarray/bench содержится набор тестов, которые можно про-
вести на установленном сервере PostgreSQL. (Для этого нужно установить пакет DBD::Pg.) Чтобы
запустить эти тесты, выполните:
cd .../contrib/intarray/bench
createdb TEST
psql -c "CREATE EXTENSION intarray" TEST
./create_test.pl | psql TEST
./bench.pl
Скрипт bench.pl принимает несколько аргументов, о которых можно узнать, запустив его без ар-
гументов.
F.18.5. Авторы
Разработку
осуществили
Фёдор
Сигаев
(<teodor@sigaev.ru>)
и
Олег
Бартунов
(<oleg@sai.msu.su>). Дополнительные сведения можно найти на странице http://www.sai.msu.su/
~megera/postgres/gist/. Андрей Октябрьский проделал отличную работу, добавив новые функции
и операторы.
F.19. isn
Модуль isn предоставляет типы данных для следующих международных стандартов нумерации
товаров: EAN13, UPC, ISBN (книги), ISMN (музыка) и ISSN (серийные номера). Номера проверя-
ются на входе согласно жёстко заданному списку префиксов: этот список префиксов также при-
меняется для группирования цифр при выводе. Так как время от времени появляются новые пре-
фиксы, этот список префиксов может устаревать. Ожидается, что будущая версия этого модуля
будет получать список префиксов из одной или нескольких таблиц, благодаря чему его при необ-
ходимости смогут легко обновлять пользователи; однако в настоящее время этот список можно
изменить, только модифицировав исходный код и перекомпилировав его. Также есть вероятность,
что в будущем этот модуль лишится функций проверки префиксов и группирования цифр.
F.19.1. Типы данных
В Таблице F.11 перечислены типы данных, реализованные модулем isn.
Таблица F.11. Типы данных isn
Тип данных Описание
EAN13 European Article Number (Европейский номер то-
вара), всегда выводится в формате EAN13
ISBN13 International Standard Book Number (Междуна-
родный стандартный книжный номер), выводи-
мый в новом формате EAN13
ISMN13 International Standard Music Number (Междуна-
родный стандартный музыкальный номер), вы-
водимый в новом формате EAN13
ISSN13 International Standard Serial Number (Междуна-
родный стандартный серийный номер), выводи-
мый в новом формате EAN13
2538Дополнительно по-
ставляемые модули
Тип данных Описание
ISBN Международный стандартный книжный номер,
выводимый в старом коротком формате
ISMN Международный стандартный музыкальный но-
мер, выводимый в старом коротком формате
ISSN Международный стандартный серийный номер,
выводимый в старом коротком формате
UPC Universal Product Code (Универсальный код то-
вара)
Замечания:
1. Номера ISBN13, ISMN13, ISSN13 являются номерами EAN13.
2. Не все номера EAN13 (только их подмножество) представляют ISBN13, ISMN13 или ISSN13.
3. Некоторые номера ISBN13 можно вывести в формате ISBN.
4. Некоторые номера ISMN13 можно вывести в формате ISMN.
5. Некоторые номера ISSN13 можно вывести в формате ISSN.
6. Номера UPC являются подмножеством номеров EAN13 (по сути они являются номерами EAN13
без первой цифры 0).
7. Любые номера UPC, ISBN, ISMN и ISSN можно представить как номера EAN13.
Внутри все эти типы представляются одинаково (64-битными целыми числами) и все они взаимо-
заменяемы. Различные типы введены для управления форматированием при выводе и для строгой
проверки правильности ввода, что и определяет конкретный тип номера.
Типы ISBN, ISMN и ISSN выводят короткую версию числа (ISxN 10), когда это возможно, либо выби-
рают формат ISxN 13 для чисел, не умещающихся в короткую версию. Типы EAN13, ISBN13, ISMN13
и ISSN13 всегда выводят длинную версию ISxN (EAN13).
F.19.2. Приведения
Модуль isn предоставляет следующие пары приведений типов:
• ISBN13 <=> EAN13
• ISMN13 <=> EAN13
• ISSN13 <=> EAN13
• ISBN <=> EAN13
• ISMN <=> EAN13
• ISSN <=> EAN13
• UPC <=> EAN13
• ISBN <=> ISBN13
• ISMN <=> ISMN13
• ISSN <=> ISSN13
При приведении EAN13 к другому типу выполняется проверка времени выполнения, соответствует
ли исходное значение целевому типу, и если это не так, выдаётся ошибка. При других приведениях
значения просто перемечаются, так что они успешно выполняются всегда.
F.19.3. Функции и операторы
Модуль isn предоставляет стандартные операторы сравнения плюс поддержку индексов по хешу
и B-деревьев для этих типов данных. Кроме того, он реализует ряд специализированных функций;
они перечислены в Таблице F.12. В этой таблице под isn понимается один из типов данных модуля.
2539Дополнительно по-
ставляемые модули
Таблица F.12. Функции isn
Функция Возвращает Описание
isn_weak(boolean) boolean Устанавливает ослабленный ре-
жим проверки ввода (возвраща-
ет новое состояние)
isn_weak() boolean Выдаёт
текущее
состояние
ослабленного режима
make_valid(isn) isn Делает неверный номер верным
(сбрасывает флаг ошибки)
is_valid(isn) boolean Проверяет присутствие флага
ошибки
Ослабленный режим позволяет вставлять в таблицу неверные значения. Под неверным значением
понимается номер, в котором не сходится проверочная цифра, а не номер отсутствует вовсе.
Зачем может понадобиться ослабленный режим? Ну например, у вас может быть большой набор
номеров ISBN, и очень многие из них по каким-то странным причинам содержат неверную кон-
трольную цифру (возможно, номера были отсканированы с печатного листа и были распознаны
неправильно, или они вводились вручную, кто знает...). В любом случае, суть в том, что вы хотите
с этим разобраться, но вам нужно загрузить все эти номера в базу данных, а затем, возможно,
использовать дополнительное средство поиска неверных номеров в базе данных с тем, чтобы про-
верить и исправить данные; так что, например, вам нужно будет выбрать все неверные номера в
таблице.
Если попытаться вставить в таблицу неверный номер в ослабленном режиме проверки, номер бу-
дет вставлен с исправленной проверочной цифрой, но выводиться будет с восклицательным знаком
(!) в конце, например 0-11-000322-5!. Этот маркер ошибки можно проверить с помощью функции
is_valid и очистить функцией make_valid.
Вы также можете принудительно вставить числа даже не в ослабленном режиме, добавив символ
! в конце номера.
Есть ещё одна особенность — во вводимом номере вместо проверочной цифры можно указать ? и
нужная проверочная цифра будет вставлена автоматически.
F.19.4. Примеры
-- Использование типов напрямую:
SELECT isbn('978-0-393-04002-9');
SELECT isbn13('0901690546');
SELECT issn('1436-4522');
-- Приведение типов:
-- заметьте, что номер ean13 можно привести к другому типу, только когда
-- этот номер будет допустимым для целевого типа;
-- таким образом, это НЕ будет работать: select isbn(ean13('0220356483481'));
-- а это будет:
SELECT upc(ean13('0220356483481'));
SELECT ean13(upc('220356483481'));
-- Создание таблицы с одним столбцом, который будет содержать номера ISBN:
CREATE TABLE test (id isbn);
INSERT INTO test VALUES('9780393040029');
-- Автоматическое вычисление проверочных цифр (обратите внимание на '?'):
INSERT INTO test VALUES('220500896?');
2540Дополнительно по-
ставляемые модули
INSERT INTO test VALUES('978055215372?');
SELECT issn('3251231?');
SELECT ismn('979047213542?');
-- Использование ослабленного режима:
SELECT isn_weak(true);
INSERT INTO test VALUES('978-0-11-000533-4');
INSERT INTO test VALUES('9780141219307');
INSERT INTO test VALUES('2-205-00876-X');
SELECT isn_weak(false);
SELECT id FROM test WHERE NOT is_valid(id);
UPDATE test SET id = make_valid(id) WHERE id = '2-205-00876-X!';
SELECT * FROM test;
SELECT isbn13(id) FROM test;
F.19.5. Библиография
Информация, на основе которой реализован этот модуль, была собрана с нескольких сайтов, вклю-
чая:
• https://www.isbn-international.org/
• http://www.issn.org/
• https://www.ismn-international.org/
• https://www.wikipedia.org/
Префиксы, используемые для группирования цифр, были также взяты с:
• https://www.gs1.org/standards/id-keys
• https://en.wikipedia.org/wiki/List_of_ISBN_identifier_groups
• https://www.isbn-international.org/content/isbn-users-manual
• https://en.wikipedia.org/wiki/International_Standard_Music_Number
• https://www.ismn-international.org/ranges.html
Алгоритмы реализованы со всей тщательностью и скрупулёзно сверены с алгоритмами, предлага-
емыми в официальных руководствах ISBN, ISMN, ISSN.
F.19.6. Автор
Герман Мендез Браво (Kronuz), 2004 — 2006
Этот модуль написан под влиянием кода isbn_issn Гаретта А. Уоллмена.
F.20. lo
Модуль lo поддерживает управление большими объектами (БО или LO, Large Objects, иногда BLOB,
Binary Large OBjects). Он реализует тип данных lo и триггер lo_manage.
F.20.1. Обоснование
Одна из проблема драйвера JDBC (она распространяется и на драйвер ODBC) в том, что специфи-
кация типа предполагает, что ссылки на BLOB хранятся в таблице, и если запись меняется, свя-
занный BLOB удаляется из базы.
2541Дополнительно по-
ставляемые модули
Но с PostgreSQL этого не происходит. Большие объекты обрабатываются как самостоятельные объ-
екты; запись в таблице может ссылаться на большой объект по OID, но при этом на один и тот же
объект могут ссылаться несколько записей таблицы, так что система не удаляет большой объект,
только потому что вы меняете или удаляете такую запись.
Это не проблема для приложений, ориентированных на PostgreSQL, но стандартный код, исполь-
зующий JDBC или ODBC, не будет удалять эти объекты, в результате чего они окажутся потерян-
ными — объектами, которые никак не задействованы, а просто занимают место на диске.
Модуль lo позволяет решить эту проблему, добавляя триггер к таблицам, которые содержат столб-
цы, ссылающиеся на БО. Этот триггер по сути просто вызывает lo_unlink, когда вы удаляете или
изменяете значение, ссылающееся на большой объект. Данный триггер предполагает, что на лю-
бой большой объект, на который ссылается контролируемый им столбец, указывает только одна
ссылка!
Этот модуль также предоставляет тип данных lo, который просто является доменом на базе oid.
Он может быть полезен для выделения столбцов, содержащих ссылки на большие объекты, среди
столбцов, содержащих другие OID. Для использования триггера применять тип lo необязательно,
но этот тип может быть полезен для отслеживания столбцов в вашей базе, представляющих боль-
шие объекты, с которыми работает триггер. Кроме того, поступали сообщения, что драйвер ODBC
не работает корректно, если для столбцов BLOB используется не тип lo.
F.20.2. Как его использовать
Пример его использования:
CREATE TABLE image (title text, raster lo);
CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON image
FOR EACH ROW EXECUTE FUNCTION lo_manage(raster);
Для каждого столбца, который будет содержать уникальные ссылки на большие объекты, создайте
триггер BEFORE UPDATE OR DELETE и передайте имя столбца в качестве единственного аргумента
триггера. Вы также можете сделать, чтобы триггер срабатывал только при изменениях в столбце,
указав BEFORE UPDATE OF имя_столбца. Если вам нужно иметь в одной таблице несколько столбцов
lo, создайте отдельный триггер для каждого (при этом обязательно нужно дать всем триггерам в
одной таблице разные имена).
F.20.3. Ограничения
• При удалении таблицы, однако, всё равно будут потеряны относящиеся к ней объекты, так
как триггер не будет выполняться. Этого можно избежать, выполнив перед DROP TABLE коман-
ду DELETE FROM таблица.
То же касается и команды TRUNCATE.
Если у вас уже есть, или вы подозреваете, что есть потерянные большие объекты, обратите
внимание на модуль vacuumlo, который может помочь вычистить их. Имеет смысл периодиче-
ски запускать vacuumlo в качестве меры, дополняющей действие триггера lo_manage.
• Некоторые клиентские программы могут создавать собственные таблицы, но не создавать для
них соответствующие триггеры. Кроме того, и пользователи могут не создавать такие тригге-
ры (забывая о них, либо не зная, как это сделать).
F.20.4. Автор
Питер Маунт <peter@retep.org.uk>
F.21. ltree
2542Дополнительно по-
ставляемые модули
Этот модуль реализует тип данных ltree для представления меток данных в иерархической дре-
вовидной структуре. Он также предоставляет расширенные средства для поиска в таких деревьях.
F.21.1. Определения
Метка — это последовательность алфавитно-цифровых символов и знаков подчёркивания (напри-
мер, в локали C допускаются символы A-Za-z0-9_). Метки должны занимать меньше 256 байт.
Примеры: 42, Personal_Services
Путь метки — это последовательность из нуля или нескольких разделённых точками меток (на-
пример, L1.L2.L3), представляющая путь от корня иерархического дерева к конкретному узлу.
Длина пути метки должна быть меньше 65 КБ, но лучше, если она будет в пределах 2 КБ.
Пример: Top.Countries.Europe.Russia
Модуль ltree предоставляет несколько типов данных:
• ltree хранит путь метки.
• lquery представляет напоминающий регулярные выражения запрос для поиска нужных зна-
чений ltree. Простое слово выбирает путь с этой меткой. Звёздочка (*) выбирает ноль или бо-
лее меток. Например:
foo
*.foo.*
*.foo
Выбирает в точности путь метки foo
Выбирает путь, содержащий метку foo
Выбирает путь, в котором последняя метка foo
Звёздочке можно также добавить числовую характеристику, ограничивающую число потенци-
ально совпадающих меток:
*{n}
*{n,}
*{n,m}
*{,m}
Выбирает
Выбирает
Выбирает
Выбирает
ровно n меток
не меньше n меток
не меньше n и не больше m меток
не больше m меток — то же самое, что и
*{0,m}
В конце метки, отличной от звёздочки, в lquery можно добавить модификаторы, чтобы найти
что-то сложнее, чем точное соответствие:
@
*
Выбирать метки без учёта регистра, например, запросу a@ соответствует A
Выбирать любую метку с данным префиксом, например запросу foo*
соответствует foobar
%
Выбирать начальные слова, разделённые подчёркиваниями
Поведение модификатора % несколько нетривиальное. Он пытается найти соответствие по
словам, а не по всей метке. Например, запросу foo_bar% соответствует foo_bar_baz но не
foo_barbaz. В сочетании с *, сопоставление префикса применяется отдельно к каждому сло-
ву, например запросу foo_bar%* соответствует foo1_bar2_baz, но не foo1_br2_baz.
Также вы можете записать несколько различных меток через знак | (обозначающий ИЛИ)
для выборки любой из этих меток, либо добавить знак ! (НЕ) в начале, чтобы выбрать все мет-
ки, не соответствующие указанным альтернативам.
Расширенный пример lquery:
Top.*{0,2}.sport*@.!football|tennis.Russ*|Spain
a. b.
c.
d.
e.
Этот запрос выберет путь, который:
a. начинается с метки Top
b. и затем включает от нуля до двух меток до
c. метки, начинающейся с префикса sport (без учёта регистра)
2543Дополнительно по-
ставляемые модули
d. затем метку, отличную от football и tennis
e. и заканчивается меткой, которая начинается подстрокой Russ или в точности равна Spain.
• ltxtquery представляет подобный полнотекстовому запрос поиска подходящих значений
ltree. Значение ltxtquery содержит слова, возможно с модификаторами @, *, % в конце; эти
модификаторы имеют то же значение, что и в lquery. Слова можно объединять символами &
(И), | (ИЛИ), ! (НЕ) и скобками. Ключевое отличие от lquery состоит в том, что ltxtquery вы-
бирает слова независимо от их положения в пути метки.
Пример ltxtquery:
Europe & Russia*@ & !Transportation
Этот запрос выберет пути, содержащие метку Europe или любую метку с начальной подстро-
кой Russia (без учёта регистра), но не пути, содержащие метку Transportation. Положение
этих слов в пути не имеет значения. Кроме того, когда применяется %, слово может быть сопо-
ставлено с любым другим отделённым подчёркиваниями словом в метке, вне зависимости от
его положения.
Замечание: ltxtquery допускает пробелы между символами, а ltree и lquery — нет.
F.21.2. Операторы и функции
Для типа ltree определены обычные операторы сравнения =, <>, <, >, <=, >=. Сравнение сортирует
пути в порядке движения по дереву, а потомки узла сортируются по тексту метки. В дополнение
к ним есть и специализированные операторы, перечисленные в Таблице F.13.
Таблица F.13. Операторы ltree
Оператор Возвращает Описание
ltree @> ltree boolean левый аргумент является пред-
ком правого (или равен ему)?
ltree <@ ltree boolean левый аргумент является по-
томком правого (или равен
ему)?
ltree ~ lquery boolean значение ltree соответствует
lquery?
lquery ~ ltree boolean значение ltree соответствует
lquery?
ltree ? lquery[] boolean значение ltree соответствует
одному из lquery в массиве?
lquery[] ? ltree boolean значение ltree соответствует
одному из lquery в массиве?
ltree @ ltxtquery boolean значение ltree соответствует
ltxtquery?
ltxtquery @ ltree boolean значение ltree соответствует
ltxtquery?
ltree || ltree ltree объединяет два пути ltree
ltree || text ltree преобразует текст в ltree и объ-
единяет с путём
text || ltree ltree преобразует текст в ltree и объ-
единяет с путём
ltree[] @> ltree boolean массив содержит предка ltree?
ltree <@ ltree[] boolean массив содержит предка ltree?
2544Дополнительно по-
ставляемые модули
Оператор Возвращает Описание
ltree[] <@ ltree boolean массив
ltree?
содержит
потомка
ltree @> ltree[] boolean массив
ltree?
содержит
потомка
ltree[] ~ lquery boolean массив содержит путь, соответ-
ствующий lquery?
lquery ~ ltree[] boolean массив содержит путь, соответ-
ствующий lquery?
ltree[] ? lquery[] boolean массив ltree содержит путь,
соответствующий любому из
lquery?
lquery[] ? ltree[] boolean массив ltree содержит путь,
соответствующий любому из
lquery?
ltree[] @ ltxtquery boolean массив содержит путь, соответ-
ствующий ltxtquery?
ltxtquery @ ltree[] boolean массив содержит путь, соответ-
ствующий ltxtquery?
ltree[] ?@> ltree ltree первый элемент массива, явля-
ющийся предком ltree; NULL,
если такого нет
ltree[] ?<@ ltree ltree первый элемент массива, явля-
ющийся потомком ltree; NULL,
если такого нет
ltree[] ?~ lquery ltree первый элемент массива, соот-
ветствующий lquery; NULL, ес-
ли такого нет
ltree[] ?@ ltxtquery ltree первый элемент массива, соот-
ветствующий ltxtquery; NULL,
если такого нет
Операторы <@, @>, @ и ~ имеют аналоги в виде ^<@, ^@>, ^@, ^~, которые отличатся только тем, что
не используют индексы. Они полезны только для тестирования.
Доступные функции перечислены в Таблице F.14.
Таблица F.14. Функции ltree
Функция Тип результата Описание subltree(ltree,
int start, int
end) ltree подпуть ltree от subltree(
позиции start до 'Top.Child1.
позиции end-1 (на- Child2',1,2)
чиная с 0) Child1
subpath(ltree,
int
offset,
int len) ltree подпуть ltree, на- subpath(
чиная
с
пози- 'Top.Child1.
ции offset, дли- Child2',0,2)
ной
len.
Если
offset меньше ну-
ля, подпуть начи-
нается с этого сме-
щения от конца пу- Top.Child1
2545
Пример
РезультатДополнительно по-
ставляемые модули
Функция Тип результата Описание
Пример
ти. Если len мень-
ше нуля, будет от-
брошено заданное
число меток с кон-
ца строки. Результат
subpath(ltree,
int offset) ltree подпуть ltree, на- subpath(
чиная с позиции 'Top.Child1.
offset и до конца Child2',1)
пути. Если offset
меньше нуля, под-
путь начинается с
этого смещения от
конца пути. Child1.Child2
nlevel(ltree) integer число меток в пути nlevel(
'Top.Child1.
Child2') 3
a, integer позиция первого
вхождения b в a;
-1, если вхождения
нет index(
6
'0.1.2.3.5.4.5.6.
8.5.6.8',
'5.6')
index(ltree
a,
ltree b, int
offset) integer позиция первого
вхождения b в a,
найденного от по-
зиции offset; ес-
ли offset меньше
0, поиск начинает-
ся с -offset меток
от конца пути index(
9
'0.1.2.3.5.4.5.6.
8.5.6.8',
'5.6',-4)
text2ltree(
text) ltree приводит text
типу ltree ltree2text(
ltree) text приводит ltree к
типу text lca(ltree,
ltree, ...) ltree наибольший
об- lca('1.2.3',
щий предок путей '1.2.3.4.5.6')
(принимается до 8
аргументов) lca(ltree[]) ltree наибольший
об- lca(
1.2
щий предок путей array['1.2.3'::ltree,
в массиве
'1.2.3.4'])
index(ltree
ltree b)
к
1.2
F.21.3. Индексы
ltree поддерживает несколько типов индексов, которые могут ускорить означенные операции:
• B-дерево по значениям ltree: <, <=, =, >=, >
• GiST по значениям ltree: <, <=, =, >=, >, @>, <@, @, ~, ?
Пример создания такого индекса:
CREATE INDEX path_gist_idx ON test USING GIST (path);
• GiST по столбцу ltree[]: ltree[] <@ ltree, ltree @> ltree[], @, ~, ?
Пример создания такого индекса:
2546Дополнительно по-
ставляемые модули
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
Примечание: Индекс этого типа является неточным.
F.21.4. Пример
Для этого примера используются следующие данные (это же описание данных находится в файле
contrib/ltree/ltreetest.sql в дистрибутиве исходного кода):
CREATE
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
CREATE
CREATE
TABLE test (path ltree);
INTO test VALUES ('Top');
INTO test VALUES ('Top.Science');
INTO test VALUES ('Top.Science.Astronomy');
INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INTO test VALUES ('Top.Hobbies');
INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INTO test VALUES ('Top.Collections');
INTO test VALUES ('Top.Collections.Pictures');
INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
INDEX path_gist_idx ON test USING GIST (path);
INDEX path_idx ON test USING BTREE (path);
В итоге мы получаем таблицу test, наполненную данными, представляющими следующую иерар-
хию:
Top
/
| \
Science Hobbies Collections
/
|
\
Astronomy
Amateurs_Astronomy Pictures
/ \
|
Astrophysics Cosmology
Astronomy
/ |
\
Galaxies Stars Astronauts
Мы можем выбрать потомки в иерархии наследования:
ltreetest=> SELECT path FROM test WHERE path <@ 'Top.Science';
path
------------------------------------
Top.Science
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
(4 rows)
Несколько примеров выборки по путям:
ltreetest=> SELECT path FROM test WHERE path ~ '*.Astronomy.*';
path
-----------------------------------------------
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
Top.Collections.Pictures.Astronomy
Top.Collections.Pictures.Astronomy.Stars
Top.Collections.Pictures.Astronomy.Galaxies
2547Дополнительно по-
ставляемые модули
Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)
ltreetest=> SELECT path FROM test WHERE path ~ '*.!pictures@.*.Astronomy.*';
path
------------------------------------
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
(3 rows)
Ещё несколько примеров полнотекстового поиска:
ltreetest=> SELECT path FROM test WHERE path @ 'Astro*% & !pictures@';
path
------------------------------------
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
Top.Hobbies.Amateurs_Astronomy
(4 rows)
ltreetest=> SELECT path FROM test WHERE path @ 'Astro* & !pictures@';
path
------------------------------------
Top.Science.Astronomy
Top.Science.Astronomy.Astrophysics
Top.Science.Astronomy.Cosmology
(3 rows)
Образование пути с помощью функций:
ltreetest=> SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path <@
'Top.Science.Astronomy';
?column?
------------------------------------------
Top.Science.Space.Astronomy
Top.Science.Space.Astronomy.Astrophysics
Top.Science.Space.Astronomy.Cosmology
(3 rows)
Эту процедуру можно упростить, создав функцию SQL, вставляющую метку в определённую пози-
цию в пути:
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
LANGUAGE SQL IMMUTABLE;
ltreetest=> SELECT ins_label(path,2,'Space') FROM test WHERE path <@
'Top.Science.Astronomy';
ins_label
------------------------------------------
Top.Science.Space.Astronomy
Top.Science.Space.Astronomy.Astrophysics
Top.Science.Space.Astronomy.Cosmology
(3 rows)
F.21.5. Трансформации
Также имеются дополнительные расширения, реализующие трансформации типа ltree для языка
PL/Python. Эти расширения называются ltree_plpythonu, ltree_plpython2u и ltree_plpython3u
2548Дополнительно по-
ставляемые модули
(соглашения об именовании, принятые для интерфейса PL/Python, описаны в Разделе  46.1). Ес-
ли вы установите эти трансформации и укажете их при создании функции, значения ltree будут
отображаться в списки Python. (Однако обратное преобразование не поддерживается.)
F.21.6. Авторы
Разработку
осуществили
Фёдор
Сигаев
(<teodor@stack.net>)
и
Олег
Бартунов
(<oleg@sai.msu.su>). Дополнительные сведения можно найти на странице http://www.sai.msu.su/
~megera/postgres/gist/. Авторы выражают благодарность Евгению Родичеву за полезные дискус-
сии. Замечания и сообщения об ошибках приветствуются.
F.22. pageinspect
Модуль pageinspect предоставляет функции, позволяющие исследовать страницы баз данных на
низком уровне, что бывает полезно для отладки. Все эти функции могут вызывать только супер-
пользователи.
F.22.1. Функции общего назначения
get_raw_page(relname text, fork text, blkno int) returns bytea
Функция get_raw_page считывает указанный блок отношения с заданным именем и возвращает
копию значения bytea. Это позволяет получить одну согласованную во времени копию блока.
В параметре fork нужно передать 'main', чтобы обратиться к основному слою данных, 'fsm'
— к карте свободного пространства, 'vm' — к карте видимости, либо 'init' — к слою иници-
ализации.
get_raw_page(relname text, blkno int) returns bytea
Упрощённая версия get_raw_page для
get_raw_page(relname, 'main', blkno)
чтения
данных
из
основного
слоя.
Синоним
page_header(page bytea) returns record
Функция page_header показывает поля, общие для всех страниц кучи и индекса PostgreSQL.
В качестве аргумента ей передаётся образ страницы, полученный в результате вызова
get_raw_page. Например:
test=# SELECT * FROM page_header(get_raw_page('pg_class', 0));
lsn
| checksum | flags | lower | upper | special | pagesize | version |
prune_xid
-----------+----------+--------+-------+-------+---------+----------+---------
+-----------
0/24A1B50 |
0 |
1 |
232 |
368 |
8192 |
8192 |
4 |
0
Возвращаемые столбцы соответствуют полям в структуре PageHeaderData. За подробностями
обратитесь к src/include/storage/bufpage.h.
Поле checksum содержит контрольную сумму, сохранённую для страницы. Эта сумма может
быть неверной при повреждении страницы. Если в данном экземпляре кластера контрольные
суммы отключены, это значение не имеет смысла.
page_checksum(page bytea, blkno int4) returns smallint
Функция page_checksum вычисляет контрольную сумму страницы, которая должна была бы на-
ходиться в заданном блоке.
В качестве аргумента ей передаётся образ страницы, полученный в результате вызова
get_raw_page. Например:
2549Дополнительно по-
ставляемые модули
test=# SELECT page_checksum(get_raw_page('pg_class', 0), 0);
page_checksum
---------------
13443
Заметьте, что вычисление контрольной суммы зависит от номера блока, поэтому обеим функ-
циям нужно передавать одинаковые номера (за исключением случаев эзотерической отладки).
Контрольную сумму, вычисленную этой функцией, можно сравнить с полем checksum резуль-
тата функции page_header. Если контрольные суммы для текущего экземпляра БД включены,
эти значения должны быть равны.
heap_page_items(page bytea) returns setof record
Функция heap_page_items показывает все указатели линейных блоков на странице кучи. Для
используемых блоков также выводятся заголовки кортежей. При этом показываются все кор-
тежи, независимо от того, были ли видны они в снимке MVCC в момент копирования исходной
страницы.
В качестве аргумента ей передаётся образ страницы кучи, полученный в результате вызова
get_raw_page. Например:
test=# SELECT * FROM heap_page_items(get_raw_page('pg_class', 0));
Описание возвращаемых полей можно найти в src/include/storage/itemid.h и src/include/
access/htup_details.h.
tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 integer, t_bits
text [, do_detoast bool]) returns bytea[]
Функция tuple_data_split разделяет данные кортежей на атрибуты так, как это происходит
внутри сервера.
test=# SELECT tuple_data_split('pg_class'::regclass, t_data, t_infomask,
t_infomask2, t_bits) FROM heap_page_items(get_raw_page('pg_class', 0));
В качестве аргументов этой функции должны передаваться атрибуты, возвращаемые функцией
heap_page_items.
Если параметр do_detoast равен true, полученные атрибуты будут распакованы по мере необ-
ходимости. Если он не задан, подразумевается false.
heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns bytea[]
Функция heap_page_item_attrs похожа на heap_page_items, но возвращает неструктурирован-
ное содержимое кортежа в виде массива атрибутов, которые могут быть распакованы, если
установлен флаг do_detoast (по умолчанию они не распаковываются).
В качестве аргумента ей передаётся образ страницы кучи, полученный в результате вызова
get_raw_page. Например:
test=# SELECT * FROM heap_page_item_attrs(get_raw_page('pg_class', 0),
'pg_class'::regclass);
fsm_page_contents(page bytea) returns text
Функция fsm_page_contents показывает внутреннюю структуру узла на странице FSM. Она вы-
даёт текст из нескольких строк, по одной строке на узел двоичного дерева на заданной стра-
нице. При этом выдаются только ненулевые узлы. Также выводится так называемый указатель
«следующего слота», который указывает на следующий слот, получаемый с этой страницы.
Подробнее структура страницы FSM описана в src/backend/storage/freespace/README.
2550Дополнительно по-
ставляемые модули
F.22.2. Функции для индексов-B-деревьев
bt_metap(relname text) returns record
Функция bt_metap возвращает информацию о метастранице индекса-B-дерева. Например:
test=# SELECT * FROM bt_metap('pg_cast_oid_index');
-[ RECORD 1 ]-----------+-------
magic
| 340322
version
| 3
root
| 1
level
| 0
fastroot
| 1
fastlevel
| 0
oldest_xact
| 582
last_cleanup_num_tuples | 1000
bt_page_stats(relname text, blkno int) returns record
bt_page_stats возвращает сводную информацию по единичным страницам B-дерева. Напри-
мер:
test=# SELECT * FROM bt_page_stats('pg_cast_oid_index', 1);
-[ RECORD 1 ]-+-----
blkno
| 1
type
| l
live_items
| 256
dead_items
| 0
avg_item_size | 12
page_size
| 8192
free_size
| 4056
btpo_prev
| 0
btpo_next
| 0
btpo
| 0
btpo_flags
| 3
bt_page_items(relname text, blkno int) returns setof record
bt_page_items возвращает детализированную информацию обо всех элементах на странице B-
дерева. Например:
test=# SELECT * FROM bt_page_items('pg_cast_oid_index', 1);
itemoffset | ctid
| itemlen | nulls | vars |
data
------------+---------+---------+-------+------+-------------
1 | (0,1)
|
12 | f
| f
| 23 27 00 00
2 | (0,2)
|
12 | f
| f
| 24 27 00 00
3 | (0,3)
|
12 | f
| f
| 25 27 00 00
4 | (0,4)
|
12 | f
| f
| 26 27 00 00
5 | (0,5)
|
12 | f
| f
| 27 27 00 00
6 | (0,6)
|
12 | f
| f
| 28 27 00 00
7 | (0,7)
|
12 | f
| f
| 29 27 00 00
8 | (0,8)
|
12 | f
| f
| 2a 27 00 00
На странице уровня листьев B-дерева, ctid указывает на кортеж в куче. На внутренней стра-
нице часть ctid, содержащая номер блока, указывает на другую страницу в самом индексе, а
часть смещения (второе число) игнорируется и обычно равняется 1.
Заметьте, что первый элемент в любой, кроме самой правой, странице (то есть в любой стра-
нице с ненулевым значением в поле btpo_next) представляет собой «верхний ключ», то есть
его поле data задаёт верхнюю границу всех элементов, находящихся на странице, а поле ctid
лишено смысла. Кроме того, на внутренних страницах первый действительный элемент дан-
ных (первый элемент после верхнего ключа) представляет элемент «минус бесконечность», без
2551Дополнительно по-
ставляемые модули
фактического значения в поле data. Однако такой элемент содержит в своём поле ctid кор-
ректную ссылку на данные.
bt_page_items(page bytea) returns setof record
Также можно передать функции bt_page_items страницу в виде значения bytea. Образ стра-
ницы для передачи в аргументе можно получить в результате вызова get_raw_page. Таким об-
разом, последний пример можно также переписать так:
test=# SELECT * FROM bt_page_items(get_raw_page('pg_cast_oid_index', 1));
itemoffset | ctid
| itemlen | nulls | vars |
data
------------+---------+---------+-------+------+-------------
1 | (0,1)
|
12 | f
| f
| 23 27 00 00
2 | (0,2)
|
12 | f
| f
| 24 27 00 00
3 | (0,3)
|
12 | f
| f
| 25 27 00 00
4 | (0,4)
|
12 | f
| f
| 26 27 00 00
5 | (0,5)
|
12 | f
| f
| 27 27 00 00
6 | (0,6)
|
12 | f
| f
| 28 27 00 00
7 | (0,7)
|
12 | f
| f
| 29 27 00 00
8 | (0,8)
|
12 | f
| f
| 2a 27 00 00
Все остальные детали те же, что и с предыдущим вариантом вызова.
F.22.3. Функции для индексов BRIN
brin_page_type(page bytea) returns text
Функция brin_page_type возвращает тип страницы для заданной страницы индекса BRIN или
выдаёт ошибку, если эта страница не является корректной страницей индекса BRIN. Например:
test=# SELECT brin_page_type(get_raw_page('brinidx', 0));
brin_page_type
----------------
meta
brin_metapage_info(page bytea) returns record
Функция brin_metapage_info возвращает разнообразные сведения о метастранице индекса
BRIN. Например:
test=# SELECT * FROM brin_metapage_info(get_raw_page('brinidx', 0));
magic
| version | pagesperrange | lastrevmappage
------------+---------+---------------+----------------
0xA8109CFA |
1 |
4 |
2
brin_revmap_data(page bytea) returns setof tid
Функция brin_revmap_data выдаёт список идентификаторов кортежей со страницы сопостав-
лений зон индекса BRIN. Например:
test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) LIMIT 5;
pages
---------
(6,137)
(6,138)
(6,139)
(6,140)
(6,141)
brin_page_items(page bytea, index oid) returns setof record
Функция brin_page_items выдаёт содержимое, сохранённое в странице данных BRIN. Напри-
мер:
2552Дополнительно по-
ставляемые модули
test=# SELECT * FROM brin_page_items(get_raw_page('brinidx', 5),
'brinidx')
ORDER BY blknum, attnum LIMIT 6;
itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |
value
------------+--------+--------+----------+----------+-------------+--------------
137 |
0 |
1 | t
| f
| f
|
137 |
0 |
2 | f
| f
| f
| {1 .. 88}
138 |
4 |
1 | t
| f
| f
|
138 |
4 |
2 | f
| f
| f
| {89 .. 176}
139 |
8 |
1 | t
| f
| f
|
139 |
8 |
2 | f
| f
| f
| {177 .. 264}
Возвращаемые столбцы соответствуют полям в структурах BrinMemTuple и BrinValues. Подроб-
нее они описаны в src/include/access/brin_tuple.h.
F.22.4. Функции для индексов GIN
gin_metapage_info(page bytea) returns record
Функция gin_metapage_info выдаёт информацию о метастранице индекса GIN. Например:
test=# SELECT * FROM gin_metapage_info(get_raw_page('gin_index', 0));
-[ RECORD 1 ]----+-----------
pending_head
| 4294967295
pending_tail
| 4294967295
tail_free_size
| 0
n_pending_pages | 0
n_pending_tuples | 0
n_total_pages
| 7
n_entry_pages
| 6
n_data_pages
| 0
n_entries
| 693
version
| 2
gin_page_opaque_info(page bytea) returns record
Функция gin_page_opaque_info выдаёт информацию из непрозрачной области индекса GIN,
например, тип страницы. Например:
test=# SELECT * FROM gin_page_opaque_info(get_raw_page('gin_index', 2));
rightlink | maxoff |
flags
-----------+--------+------------------------
5 |
0 | {data,leaf,compressed}
(1 row)
gin_leafpage_items(page bytea) returns setof record
Функция gin_leafpage_items выдаёт информацию о данных, хранящихся в странице индекса
GIN на уровне листьев. Например:
test=# SELECT first_tid, nbytes, tids[0:5] AS some_tids
FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));
first_tid | nbytes |
some_tids
-----------+--------+----------------------------------------------------------
(8,41)
|
244 | {"(8,41)","(8,43)","(8,44)","(8,45)","(8,46)"}
(10,45)
|
248 | {"(10,45)","(10,46)","(10,47)","(10,48)","(10,49)"}
(12,52)
|
248 | {"(12,52)","(12,53)","(12,54)","(12,55)","(12,56)"}
(14,59)
|
320 | {"(14,59)","(14,60)","(14,61)","(14,62)","(14,63)"}
(167,16) |
376 | {"(167,16)","(167,17)","(167,18)","(167,19)","(167,20)"}
(170,30) |
376 | {"(170,30)","(170,31)","(170,32)","(170,33)","(170,34)"}
(173,44) |
197 | {"(173,44)","(173,45)","(173,46)","(173,47)","(173,48)"}
2553Дополнительно по-
ставляемые модули
(7 rows)
F.22.5. Функции для хеш-индексов
hash_page_type(page bytea) returns text
Функция hash_page_type возвращает тип страницы для заданной страницы хеш-индекса. На-
пример:
test=# SELECT hash_page_type(get_raw_page('con_hash_index', 0));
hash_page_type
----------------
metapage
hash_page_stats(page bytea) returns setof record
Функция hash_page_stats возвращает информацию о странице группы или переполнения хеш-
индекса. Например:
test=# SELECT * FROM hash_page_stats(get_raw_page('con_hash_index', 1));
-[ RECORD 1 ]---+-----------
live_items
| 407
dead_items
| 0
page_size
| 8192
free_size
| 8
hasho_prevblkno | 4096
hasho_nextblkno | 8474
hasho_bucket
| 0
hasho_flag
| 66
hasho_page_id
| 65408
hash_page_items(page bytea) returns setof record
Функция hash_page_items возвращает информацию о данных, хранящихся на странице группы
или переполнения хеш-индекса. Например:
test=# SELECT * FROM hash_page_items(get_raw_page('con_hash_index', 1)) LIMIT 5;
itemoffset |
ctid
|
data
------------+-----------+------------
1 | (899,77) | 1053474816
2 | (897,29) | 1053474816
3 | (894,207) | 1053474816
4 | (892,159) | 1053474816
5 | (890,111) | 1053474816
hash_bitmap_info(index oid, blkno int) returns record
Функция hash_bitmap_info показывает состояние бита в странице битовой карты для опреде-
лённой страницы переполнения хеш-индекса. Например:
test=# SELECT * FROM hash_bitmap_info('con_hash_index', 2052);
bitmapblkno | bitmapbit | bitstatus
-------------+-----------+-----------
65 |
3 | t
hash_metapage_info(page bytea) returns record
hash_metapage_info возвращает информацию, хранящуюся в метастранице хеш-индекса. На-
пример:
test=# SELECT magic, version, ntuples, ffactor, bsize, bmsize, bmshift,
test-#
maxbucket, highmask, lowmask, ovflpoint, firstfree, nmaps, procid,
test-#
regexp_replace(spares::text, '(,0)*}', '}') as spares,
2554Дополнительно по-
ставляемые модули
test-#
regexp_replace(mapp::text, '(,0)*}', '}') as mapp
test-# FROM hash_metapage_info(get_raw_page('con_hash_index', 0));
-[ RECORD
1 ]-------------------------------------------------------------------------------
spares
|
{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}
magic
| 105121344
version
| 3
ntuples
| 500500
ffactor
| 40
bsize
| 8152
bmsize
| 4096
bmshift
| 15
maxbucket | 12512
highmask | 16383
lowmask
| 8191
ovflpoint | 28
firstfree | 1204
nmaps
| 1
procid
| 450
spares
|
{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}
mapp
| {65}
F.23. passwordcheck
Модуль passwordcheck проверяет пароли пользователей, задаваемые командами CREATE ROLE и
ALTER ROLE. Если пароль признаётся слишком слабым, он не принимается и команда завершается
ошибкой.
Чтобы задействовать этот модуль, добавьте строку '$libdir/passwordcheck' в переменную
shared_preload_libraries в postgresql.conf, а затем перезапустите сервер.
Этот модуль можно приспособить к вашим нуждам, изменив исходный код. Например, для провер-
ки паролей вы можете использовать библиотеку CrackLib — для этого нужно только раскомменти-
ровать две строки в Makefile и пересобрать модуль. (Мы не можем включить CrackLib по умолча-
нию из-за лицензии.) Без CrackLib этот модуль проверяет стойкость пароля по простым правилам,
которые вы можете изменить или расширить по своему усмотрению.
Внимание
Чтобы незашифрованные пароли не передавались по сети, не записывались в жур-
нал сервера и не стали каким-либо образом известны администратору баз данных,
PostgreSQL позволяет пользователю передавать предварительно зашифрованные па-
роли. Используя это, клиентские программы могут шифровать пароль, прежде чем пе-
редавать его серверу.
Это ограничивает полезность модуля passwordcheck, так как в этом случае можно толь-
ко попытаться угадать пароль. Поэтому использовать passwordcheck не рекомендует-
ся, когда требуется высокий уровень безопасности. Более безопасно будет применить
внешний вариант проверки подлинности, например GSSAPI (см. Главу 20), а не исполь-
зовать пароли, хранящиеся в базе данных.
Также можно изменить passwordcheck, чтобы предварительно зашифрованные паро-
ли не принимались, но если пользователи будут задавать пароли открытым текстом, с
этим связаны свои риски безопасности.
2555Дополнительно по-
ставляемые модули
F.24. pg_buffercache
Модуль pg_buffercache даёт возможность понять, что происходит в общем кеше буферов в реаль-
ном времени.
Этот модуль предоставляет функцию на C pg_buffercache_pages, возвращающую набор записей,
плюс представление pg_buffercache, которое является удобной обёрткой этой функции.
По умолчанию его использование разрешено только суперпользователям и членам роли
pg_read_all_stats. Дать доступ другим можно с помощью GRANT.
F.24.1. Представление pg_buffercache
Определения столбцов, содержащихся в представлении, показаны в Таблице F.15.
Таблица F.15. Столбцы pg_buffercache
Имя Тип
Ссылки
Описание
bufferid integer relfilenode oid pg_class.relfilenode Номер файлового узла
для отношения
reltablespace oid pg_tablespace.oid OID табличного про-
странства, содержаще-
го отношение
reldatabase oid pg_database.oid OID базы данных, со-
держащей отношение
relforknumber smallint Номер слоя в отно-
шении; см. include/
common/relpath.h
relblocknumber bigint Номер страницы в отно-
шении
isdirty boolean Страница загрязнена?
usagecount smallint Счётчик обращений по
часовой стрелке
pinning_backends integer Число обслуживающих
процессов,
закрепив-
ших этот буфер
ID,
в
диапазоне
1..shared_buffers
Для каждого буфера в общем кеше выдаётся одна строка. Для неиспользуемых буферов все поля
равны NULL, за исключением bufferid. Общие системные каталоги показываются как относящи-
еся к базе данных под номером 0.
Так как кеш используется совместно всеми базами данных, обычно в нём находятся и страницы из
отношений, не принадлежащих текущей базе данных. Это означает, что для некоторых строк при
соединении с pg_class не найдутся соответствующие строки, либо соединение будет некоррект-
ным. Если вы хотите выполнить соединение с pg_class, будет правильным ограничить соединение
строками, в которых reldatabase содержит OID текущей базы данных или ноль.
При обращении к представлению pg_buffercache устанавливаются блокировки менеджера внут-
ренних буферов на время, достаточное для копирования всех данных состояния буферов, которые
будут выводиться в представлении. Благодаря этому представление выдаёт согласованный набор
результатов, не блокируя при этом обычные операции с буфером дольше, чем необходимо. Тем не
менее, это может повлиять на производительность базы данных, если обращаться к этому пред-
ставлению часто.
2556Дополнительно по-
ставляемые модули
F.24.2. Пример вывода
regression=# SELECT c.relname, count(*) AS buffers
FROM pg_buffercache b INNER JOIN pg_class c
ON b.relfilenode = pg_relation_filenode(c.oid) AND
b.reldatabase IN (0, (SELECT oid FROM pg_database
WHERE datname = current_database()))
GROUP BY c.relname
ORDER BY 2 DESC
LIMIT 10;
relname
| buffers
---------------------------------+---------
tenk2
|
345
tenk1
|
141
pg_proc
|
46
pg_class
|
45
pg_attribute
|
43
pg_class_relname_nsp_index
|
30
pg_proc_proname_args_nsp_index |
28
pg_attribute_relid_attnam_index |
26
pg_depend
|
22
pg_depend_reference_index
|
20
(10 rows)
F.24.3. Авторы
Марк Кирквуд <markir@paradise.net.nz>
Предложения по конструкции: Нейл Конвей <neilc@samurai.com>
Советы по отладке: Том Лейн <tgl@sss.pgh.pa.us>
F.25. pgcrypto
Модуль pgcrypto предоставляет криптографические функции для PostgreSQL.
F.25.1. Стандартные функции хеширования
F.25.1.1. digest()
digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea
Вычисляет двоичный хеш данных (data). Параметр type выбирает используемый алгоритм. Под-
держиваются стандартные алгоритмы: md5, sha1, sha224, sha256, sha384 и sha512. Если модуль
pgcrypto собирался с OpenSSL, становятся доступны и другие алгоритмы, как описано в Табли-
це F.19.
Если вы хотите получить дайджест в виде шестнадцатеричной строки, примените encode() к ре-
зультату. Например:
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;
F.25.1.2. hmac()
hmac(data text, key text, type text) returns bytea
2557Дополнительно по-
ставляемые модули
hmac(data bytea, key bytea, type text) returns bytea
Вычисляет имитовставку на основе хеша для данных data с ключом key. Параметр type имеет то
же значение, что и для digest().
Эта функция похожа на digest(), но вычислить хеш с ней можно, только зная ключ. Это защищает
от сценария подмены данных и хеша вместе с ними.
Если размер ключа больше размера блока хеша, он сначала хешируется, а затем используется в
качестве ключа хеширования данных.
F.25.2. Функции хеширования пароля
Функции crypt() и gen_salt() разработаны специально для хеширования паролей. Функция
crypt() выполняет хеширование, а gen_salt() подготавливает параметры алгоритма для неё.
Алгоритмы в crypt() отличаются от обычных алгоритмов хеширования MD5 и SHA1 в следующих
аспектах:
1. Они медленные. Так как объём данных невелик, это единственный способ усложнить перебор
паролей.
2. Они используют случайное значение, называемое солью, чтобы у пользователей с одинаковыми
паролями зашифрованные пароли оказывались разными. Это также обеспечивает дополнитель-
ную защиту от получения обратного алгоритма.
3. Они включают в результат тип алгоритма, что допускает сосуществование паролей, хеширован-
ных разными алгоритмами.
4. Некоторые из них являются адаптируемыми — то есть с ростом производительности компьюте-
ров эти алгоритмы можно настроить так, чтобы они стали медленнее, при этом сохраняя совме-
стимость с существующими паролями.
В Таблице F.16 перечислены алгоритмы, поддерживаемые функцией crypt().
Таблица F.16. Алгоритмы, которые поддерживает crypt()
Алгоритм Макс. длина Адаптивный? Размер соли ( Размер
пароля
бит)
зультата
bf 72
md5 без
ний
xdes 8
des 8
да
ре- Описание
128 60 На
базе
Blowfish, вариа-
ция 2a
48 34 crypt
MD5
да 24 20 Расширенный
DES
нет 12 13 Изначальный
crypt из UNIX
ограниче- нет
на
базе
F.25.2.1. crypt()
crypt(password text, salt text) returns text
Вычисляет хеш пароля (password) в стиле crypt(3). Для сохранения нового пароля необходимо вы-
звать gen_salt(), чтобы сгенерировать новое значение соли (salt). Для проверки пароля нужно
передать сохранённое значение хеша в параметре salt и проверить, соответствует ли результат
сохранённому значению.
Пример установки нового пароля:
2558Дополнительно по-
ставляемые модули
UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
Пример проверки пароля:
SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;
Этот запрос возвращает true, если введённый пароль правильный.
F.25.2.2. gen_salt()
gen_salt(type text [, iter_count integer ]) returns text
Вычисляет новое случайное значение соли для функции crypt(). Строка соли также говорит
crypt(), какой алгоритм использовать.
Параметр type задаёт алгоритм хеширования. Принимаются следующие варианты: des, xdes, md5
и bf.
Параметр iter_count позволяет пользователю указать счётчик итераций для алгоритма, который
его принимает. Чем больше это число, тем больше времени уйдёт на вычисление хеша пароля, а
значит, тем больше времени понадобится, чтобы взломать его. Хотя со слишком большим значе-
нием время вычисления хеша может вырасти до нескольких лет — это вряд ли практично. Когда
параметр iter_count опускается, применяется количество итераций по умолчанию. Множество
допустимых значений для iter_count зависит от алгоритма, как показано в Таблице F.17.
Таблица F.17. Счётчики итераций для crypt()
Алгоритм По умолчанию Мин. Макс.
xdes 725 1 16777215
bf 6 4 31
Для xdes есть дополнительное ограничение: счётчик итераций должен быть нечётным.
При выборе подходящего числа итераций учтите, что оригинальный алгоритм DES crypt был рас-
считан так, чтобы выдавать 4 хеша в секунду на компьютерах того времени. Если за секунду будет
вычисляться меньше 4 хешей, скорее всего, возникнут определённые неудобства при пользовании.
С другой стороны, скорость больше, чем 100 хешей в секунду, вероятно, будет слишком высокой.
В Таблице F.18 дана сводка относительной скорости различных алгоритмов хеширования. В табли-
це показано, сколько времени уйдёт на перебор всех комбинацией символов в восьмисимвольном
пароле, в предположении, что пароль содержит только буквы в нижнем регистре, либо буквы в
верхнем и нижнем регистре, а также цифры. В строках crypt-bf числа после косой черты показы-
вают значение параметра iter_count функции gen_salt.
Таблица F.18. Скорости алгоритмов хеширования
Алгоритм Хешей/сек. Для [a-z] Для [A-Za-z0-9] Длительность
относительно
md5
crypt-bf/8 1792 4 года 3927 лет 100k
crypt-bf/7 3648 2 года 1929 лет 50k
crypt-bf/6 7168 1 год 982 лет 25k
crypt-bf/5 13504 188 дней 521 лет 12.5k
crypt-md5 171584 15 дней 41 год 1k
crypt-des 23221568 157.5 минут 108 дней 7
sha1 37774272 90 минут 68 дней 4
2559Дополнительно по-
ставляемые модули
Алгоритм Хешей/сек. Для [a-z] Для [A-Za-z0-9] Длительность
относительно
md5
md5 (хеш) 150085504 22.5 минут 17 дней 1
Замечания:
• Для расчётов использовался процессор Intel Mobile Core i3.
• Показатели алгоритмов crypt-des и crypt-md5 взяты из вывода теста программы John the
Ripper v1.6.38.
• Показатели md5 получены программой mdcrack 1.2.
• Показатели sha1 получены программой lcrack-20031130-beta.
• Показатели crypt-bf получены простой программой, обрабатывающей в цикле 1000 паро-
лей из 8-символов. Таким способом можно показать скорость с разным числом итераций. Для
справки: john -test показывает 13506 циклов/с для crypt-bf/5. (Это очень небольшое разли-
чие в результатах согласуется с тем фактом, что реализация crypt-bf в pgcrypto не отличает-
ся от применяемой в программе John the Ripper.)
Заметьте, что вариант «перепробовать все комбинации» не вполне реалистичен. Обычно перебор
паролей производится с применением словарей, которые содержат и обычные слова, и их различ-
ные видоизменения. Поэтому даже похожие на слова пароли обычно можно подобрать быстрее,
чем за указанное время, тогда как 6-символьный несловесный пароль может избежать взлома. А
может и не избежать.
F.25.3. Функции шифрования на базе PGP
Функции, описанные здесь, реализуют часть стандарта OpenPGP (RFC 4880), относящуюся к шиф-
рованию. Они поддерживают шифрование как с симметричным, так и с закрытым ключом.
Зашифрованное PGP сообщение состоит из 2 частей или пакетов:
• Пакет, содержащий сеансовый ключ — либо симметричный, либо открытый (в зашифрован-
ном виде).
• Пакет, содержащий данные, зашифрованные сеансовым ключом.
При шифровании с симметричным ключом (то есть, паролем):
1. Заданный пароль хешируется по алгоритму String2Key (S2K). Этот алгоритм подобен алгорит-
мам crypt() — специально замедлен и добавляет случайную соль — но на выход выдаёт двоич-
ный ключ полной длины.
2. Если требуется отдельный сеансовый ключ, генерируется новый случайный ключ. В противном
случае в качестве сеансового будет использоваться непосредственно ключ S2K.
3. Когда используется непосредственно ключ S2K, в пакет сеансового ключа помещаются только
параметры S2K. В противном случае сеансовый ключ шифруется ключом S2K и результат поме-
щается в пакет сеансового ключа.
При шифровании с открытым ключом:
1. Генерируется новый случайный сеансовый ключ.
2. Он зашифровывается открытым ключом и помещается в пакет сеансового ключа.
В любом случае данные, которые должны быть зашифрованы, обрабатываются так:
1. Необязательная подготовка данных: сжатие, перекодировка в UTF-8 и/или преобразование кон-
цов строк.
2560Дополнительно по-
ставляемые модули
2. Перед данными добавляется блок случайных байт. Это равносильно использованию случайного
вектора инициализации.
3. В конце добавляется хеш SHA1 случайного префикса и данных.
4. Всё это шифруется сеансовым ключом и помещается в пакет данных.
F.25.3.1. pgp_sym_encrypt()
pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
Шифрует данные (data) симметричным ключом PGP psw. В options могут передаваться крипто-
графические параметры, описанные ниже.
F.25.3.2. pgp_sym_decrypt()
pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
Расшифровывает сообщение, зашифрованное симметричным ключом PGP.
Расшифровывать данные bytea функцией pgp_sym_decrypt запрещено. Это ограничение введено,
чтобы не допустить вывода некорректных символьных данных. Расшифровывать изначально тек-
стовые данные с помощью pgp_sym_decrypt_bytea можно без ограничений.
Аргумент options может содержать криптографические параметры, описанные ниже.
F.25.3.3. pgp_pub_encrypt()
pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
Зашифровывает данные (data) открытым ключом PGP (key). Если передать этой функции закрытый
ключ, она выдаст ошибку.
Аргумент options может содержать криптографические параметры, описанные ниже.
F.25.3.4. pgp_pub_decrypt()
pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns
bytea
Расшифровывает сообщение, зашифрованное открытым ключом. В key должен передаваться за-
крытый ключ, соответствующий открытому ключу, применяющемуся при шифровании. Если сек-
ретный ключ защищён паролем, этот пароль нужно передать в параметре psw. Если пароля нет,
но необходимо передать криптографические параметры, вы должны передать пустой пароль.
Расшифровывать данные bytea функцией pgp_pub_decrypt запрещено. Это ограничение введено,
чтобы не допустить вывода недопустимых символьных данных. Расшифровывать изначально тек-
стовые данные с помощью pgp_pub_decrypt_bytea можно без ограничений.
Аргумент options может содержать криптографические параметры, описанные ниже.
F.25.3.5. pgp_key_id()
pgp_key_id(bytea) returns text
pgp_key_id извлекает идентификатор ключа из открытого или закрытого ключа PGP. Она также
может выдать идентификатор ключа, которым были зашифрованы данные, если ей передаётся
зашифрованное сообщение.
Она может выдать два специальных идентификатора ключа:
2561Дополнительно по-
ставляемые модули
• SYMKEY
Сообщение зашифровано симметричным ключом.
• ANYKEY
Сообщение зашифровано открытом ключом, но идентификатор ключа был удалён. Это означа-
ет, что вам надо будет перепробовать ключи, чтобы подобрать подходящий. Сама библиотека
pgcrypto не генерирует такие сообщения.
Заметьте, что разные ключи могут иметь одинаковый идентификатор. Это редкое, но не невероят-
ное явление. В таком случае клиентское приложение должно пытаться расшифровать данные с
каждым ключом, пока не найдёт подходящий — примерно так же, как и с ANYKEY.
F.25.3.6. armor(), dearmor()
armor(data bytea [ , keys text[], values text[] ]) returns text
dearmor(data text) returns bytea
Эти функции переводят двоичные данные в/из формата PGP «ASCII Armor», по сути представляю-
щий собой кодировку Base64 с контрольными суммами и дополнительным форматированием.
Если задаются массивы keys и values, для каждой пары ключ/значения в формат Armor добавля-
ется заголовок Armor. Оба массива должны быть одномерными и иметь одинаковую длину. Зада-
ваемые ключи и значения могут содержать только символы ASCII.
F.25.3.7. pgp_armor_headers
pgp_armor_headers(data text, key out text, value out text) returns setof record
Функция pgp_armor_headers() извлекает заголовки Armor из параметра data. Она возвращает на-
бор строк с двумя столбцами, key и value. Если в ключах или значениях оказываются символы не
ASCII, они воспринимаются как UTF-8.
F.25.3.8. Параметры функций PGP
Имена параметров подобны принятым в GnuPG. Значение параметра должно задаваться после
знака равно; друг от друга параметры отделяются запятыми. Например:
pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
Все эти параметры, кроме convert-crlf, применяются только к функциям шифрования. Функции
расшифровывания получают параметры из данных PGP.
Вероятно, самые интересные параметры — это compress-algo и unicode-mode. Остальные должны
иметь достаточно адекватные значения по умолчанию.
F.25.3.8.1. cipher-algo
Выбирает алгоритм шифрования.
Значения: bf, aes128, aes192, aes256 (только OpenSSL: 3des, cast5)
По умолчанию: aes128
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.2. compress-algo
Выбирает алгоритм сжатия. Принимается, только если PostgreSQL собран с zlib.
Значения:
0 — без сжатия
1 — сжатие ZIP
2 — сжатие ZLIB (= ZIP плюс метаданные и CRC блоков)
По умолчанию: 0
2562Дополнительно по-
ставляемые модули
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.3. compress-level
Определяет уровень сжатия. Чем больше уровень, тем меньшего объёма результат, но длительнее
процесс. Значение 0 отключает сжатие.
Значения: 0, 1-9
По умолчанию: 6
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.4. convert-crlf
Определяет, преобразовывать ли \n в \r\n при шифровании и \r\n в \n при дешифровании. В RFC
4880 требуется, чтобы текстовые данные хранились с переводами строк в виде \r\n. Воспользуй-
тесь этим параметром, чтобы поведение полностью соответствовало RFC.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
F.25.3.8.5. disable-mdc
Не защищать данные хешем SHA-1. Единственная разумная причина использовать этот параметр
— добиться совместимости с древними программами PGP, вышедшими до того, как в RFC 4880
была предусмотрена защита пакетов с SHA-1. Все последние реализации с gnupg.org и pgp.com
прекрасно поддерживают это.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.8.6. sess-key
Использовать отдельный сеансовый ключ. Для шифрования с открытым ключом всегда использу-
ется отдельный сеансовый ключ; этот параметр предназначен для шифрования с симметричным
ключом, которое по умолчанию использует непосредственно ключ S2K.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt
F.25.3.8.7. s2k-mode
Режим алгоритма S2K.
Значения:
0 — Без соли. Опасно!
1 — С солью, но с фиксированным числом итераций.
3 — С переменным числом итераций.
По умолчанию: 3
Применим к: pgp_sym_encrypt
F.25.3.8.8. s2k-count
Число итераций для алгоритма S2K. Оно должно быть не меньше 1024 и не больше 65011712.
По умолчанию: случайное значение между 65536 и 253952
Применим к: pgp_sym_encrypt, только с s2k-mode=3
F.25.3.8.9. s2k-digest-algo
Выбирает алгоритм хеширования, который будет использоваться для вычисления S2K.
2563Дополнительно по-
ставляемые модули
Значения: md5, sha1
По умолчанию: sha1
Применим к: pgp_sym_encrypt
F.25.3.8.10. s2k-cipher-algo
Выбирает шифр, который будет использоваться для шифрования отдельного сеансового ключа.
Значения: bf, aes, aes128, aes192, aes256
По умолчанию: используется cipher-algo
Применим к: pgp_sym_encrypt
F.25.3.8.11. unicode-mode
Определяет, преобразовывать ли текстовые данные из внутренней кодировки базы данных в UTF-8
и обратно. Если кодировка базы уже UTF-8, перекодировка не производится, но сообщение поме-
чается как UTF-8. Без данного параметра этого не происходит.
Значения: 0, 1
По умолчанию: 0
Применим к: pgp_sym_encrypt, pgp_pub_encrypt
F.25.3.9. Формирование ключей PGP с применением GnuPG
Формирование нового ключа:
gpg --gen-key
Предпочитаемый тип ключей: «DSA and Elgamal».
Для шифрования RSA вы должны создать главный ключ либо DSA, либо RSA только для подписа-
ния, а затем добавить подключ для шифрования, выполнив команду gpg --edit-key.
Просмотр списка ключей:
gpg --list-secret-keys
Экспорт открытого ключа в формате «ASCII Armor»:
gpg -a --export KEYID > public.key
Экспорт закрытого ключа в формате «ASCII Armor»:
gpg -a --export-secret-keys KEYID > secret.key
Прежде чем передавать эти ключи функциям PGP, вы должны применить функцию dearmor() к
этим ключам. Либо, если вы можете обработать двоичные данные, уберите -a из команды.
Дополнительную информацию вы можете получить в руководстве man gpg, The GNU Privacy
Handbook (Руководство GNU по обеспечению конфиденциальности) и другой документации на сай-
те https://www.gnupg.org/.
F.25.3.10. Ограничения кода PGP
• Не поддерживается подписывание. Это также означает, что принадлежность подключа шиф-
рования главному ключу не проверяется.
• Не поддерживается использование ключа шифрования в качестве главного ключа. Так как по-
добная практика обычно не приветствуется, это не должно быть проблемой.
• Нет поддержки нескольких подключей. Это может представляться проблемой, так как такие
ключи не редкость. С другой стороны, вы всё равно не должны использовать обычные ключи
GPG/PGP с pgcrypto, а должны создать новые, учитывая, что это другой сценарий использова-
ния.
2564Дополнительно по-
ставляемые модули
F.25.4. Низкоуровневые функции шифрования
Эти функции выполняют только шифрование данных; они не предоставляют расширенные возмож-
ности шифрования PGP. Таким образом, с ними связаны следующие проблемы:
1. Они используют ключ пользователя непосредственно в качестве ключа шифрования.
2. Они не обеспечивают проверку целостности, которая должна выявлять модификацию зашифро-
ванных данных.
3. Они рассчитаны на то, что пользователи будут управлять всеми параметрами шифрования са-
мостоятельно, даже вектором инициализации.
4. Они не рассчитаны на текст.
Поэтому с появлением поддержки шифрования PGP использовать низкоуровневые функции шиф-
рования не рекомендуется.
encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea
encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
Эти функции зашифровывают/расшифровывают данные, применяя метод шифрования, заданный
параметром type. Строка type имеет следующий формат:
алгоритм [ - режим ] [ /pad: дозаполнение ]
где допустимый алгоритм:
• bf — Blowfish
• aes — AES (Rijndael-128, -192 или -256)
допустимый режим:
• cbc — следующий блок зависит от предыдущего (по умолчанию)
• ecb — каждый блок шифруется отдельно (только для тестирования)
и допустимое дозаполнение:
• pkcs — данные могут быть любой длины (по умолчанию)
• none — размер данных должен быть кратен размеру блока шифра
Так что, например, эти вызовы равнозначны:
encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
Для функций encrypt_iv и decrypt_iv параметр iv задаёт начальное значение для режима CBC;
для ECB он игнорируется. Оно обрезается или дополняется нулями, если его размер не равен ровно
размеру блока. В функциях без этого параметра оно по умолчанию заполняется нулями.
F.25.5. Функции получения случайных данных
gen_random_bytes(count integer) returns bytea
Возвращает криптографически стойкие случайные байты в количестве count. За один вызов можно
получить максимум 1024 байт. Это ограничение предотвращает исчерпание пула энтропии.
gen_random_uuid() returns uuid
2565Дополнительно по-
ставляемые модули
Возвращает UUID версии 4 (случайный).
F.25.6. Замечания
F.25.6.1. Конфигурирование
Модуль pgcrypto настраивается согласно установкам, полученным в главном скрипте configure
PostgreSQL. На его конфигурацию влияют аргументы --with-zlib и --with-openssl.
При компиляции с zlib шифрующие функции PGP могут сжимать данные перед шифрованием.
При компиляции с OpenSSL будут доступны дополнительные алгоритмы. Кроме того, функции
шифрования с открытым ключом будут быстрее, так как OpenSSL содержит оптимизированные
функции для работы с большими числами (BIGNUM).
Таблица F.19. Обзор функциональности с и без OpenSSL
Функциональность Встроенная С OpenSSL
MD5 да да
SHA1 да да
SHA224/256/384/512 да да
Другие алгоритмы хеширова- нет
ния да (Примечание 1)
Blowfish да да
AES да да
DES/3DES/CAST5 нет да
Низкоуровневое шифрование да да
шифрование да да
Шифрование PGP с открытым да
ключом да
Симметричное
PGP
Замечания:
1. Автоматически выбирается любой алгоритм хеширования, который поддерживает OpenSSL. Это
невозможно с шифрами, они должны поддерживаться явно.
F.25.6.2. Обработка NULL
Как и положено по стандарту SQL, все эти функции возвращают NULL, если один из аргументов
— NULL. Это может угрожать безопасности при неаккуратном использовании.
F.25.6.3. Ограничения безопасности
Все функции pgcrypto выполняются внутри сервера баз данных. Это означает, что все данные и
пароли передаются между функциями pgcrypto и клиентскими приложениями открытым текстом.
Поэтому вы должны:
1. Подключаться локально или использовать подключения SSL.
2. Доверять и системе, и администратору баз данных.
Если это невозможно, лучше произвести шифрование в клиентском приложении.
Эта реализация не противостоит атакам по сторонним каналам. Например, время, требующееся
для выполнения функции дешифрования pgcrypto, будет разным для разного шифротекста задан-
ного размера.
2566Дополнительно по-
ставляемые модули
F.25.6.4. Полезное чтение
• https://www.gnupg.org/gph/en/manual.html
The GNU Privacy Handbook (Руководство GNU по обеспечению конфиденциальности)
• http://www.openwall.com/crypt/
Описывает алгоритм crypt-blowfish.
• http://www.iusmentis.com/security/passphrasefaq/
Как выбрать хороший пароль.
• http://world.std.com/~reinhold/diceware.html
Интересный способ выбора пароля.
• http://www.interhack.net/people/cmcurtin/snake-oil-faq.html
Описывает хорошую и плохую криптографию.
F.25.6.5. Техническая информация
• https://tools.ietf.org/html/rfc4880
Формат сообщений OpenPGP.
• https://tools.ietf.org/html/rfc1321
Алгоритм вычисления дайджеста сообщения MD5.
• https://tools.ietf.org/html/rfc2104
HMAC: Хеширование по ключу для аутентификации сообщений.
• https://www.usenix.org/legacy/events/usenix99/provos.html
Сравнение алгоритмов crypt-des, crypt-md5 и bcrypt.
• https://en.wikipedia.org/wiki/Fortuna_(PRNG)
Описание Fortuna CSPRNG.
• http://jlcooke.ca/random/
Драйвер /dev/random для Linux на базе Fortuna, написанный Жан-Люком Куком.
F.25.7. Автор
Марко Крин <markokr@gmail.com>
Модуль pgcrypto заимствует код из следующих источников:
Алгоритм Автор Источник исходного кода
Шифрование DES Дэвид Буррен и другие FreeBSD, libcrypt
Хеширование MD5 Пол-Хеннинг Камп FreeBSD, libcrypt
Шифрование Blowfish Solar Designer www.openwall.com
Шифр Blowfish Саймон Тэтем PuTTY
Шифр Rijndael Брайан Глэдмен OpenBSD, sys/crypto
Хеш MD5 и SHA1 Проект WIDE KAME, kame/sys/crypto
SHA256/384/512 Аарон Д. Гиффорд OpenBSD, sys/crypto
2567Дополнительно по-
ставляемые модули
Алгоритм Автор Источник исходного кода
Математика BIGNUM Майкл Дж. Фромбергер dartmouth.edu/~sting/sw/imath
F.26. pg_freespacemap
Модуль pg_freespacemap предоставляет средства для исследования карты свободного простран-
ства (FSM). В нём реализована функция pg_freespace, точнее, две перегруженных функции. Эти
функции показывают значение, записанное в карте свободного пространства для данной страни-
цы, либо для всех страниц отношения.
По умолчанию его использование разрешено только суперпользователям и членам роли
pg_stat_scan_tables. Дать доступ другим можно с помощью GRANT.
F.26.1. Функции
pg_freespace(rel regclass IN, blkno bigint IN) returns int2
Возвращает объём свободного пространства на странице для отношения, заданного парамет-
ром blkno, согласно FSM.
pg_freespace(rel regclass IN, blkno OUT bigint, avail OUT int2)
Выдаёт объём свободного пространства на каждой странице отношения, согласно FSM. Возвра-
щается набор кортежей (blkno bigint, avail int2), по одному кортежу для каждой страницы
в отношении.
Значения, хранимые в карте свободного пространства, не являются точными. Они округляются до
1/256 величины BLCKSZ (до 32 байт со значением BLCKSZ по умолчанию) и не поддерживаются в
актуальном состоянии при каждом добавлении и изменении кортежей.
Для индексов отслеживаются полностью неиспользованные страницы, а не свободное простран-
ство в страницах. Таким образом, эти значения отражают только то, что страница занята или сво-
бодна.
Примечание
Интерфейс был изменён в версии 8.4, в соответствии с нововведениями реализации
FSM, которые появились в этой версии.
F.26.2. Пример вывода
postgres=# SELECT * FROM pg_freespace('foo');
blkno | avail
-------+-------
0 |
0
1 |
0
2 |
0
3 |
32
4 |
704
5 |
704
6 |
704
7 | 1216
8 |
704
9 |
704
10 |
704
11 |
704
2568Дополнительно по-
ставляемые модули
12 |
704
13 |
704
14 |
704
15 |
704
16 |
704
17 |
704
18 |
704
19 | 3648
(20 rows)
postgres=# SELECT * FROM pg_freespace('foo', 7);
pg_freespace
--------------
1216
(1 row)
F.26.3. Автор
Исходную версию разработал Марк Кирквуд <markir@paradise.net.nz>. Для версии 8.4 с новой
реализацией FSM код адаптировал Хейкки Линнакангас <heikki@enterprisedb.com>
F.27. pg_prewarm
Модуль pg_prewarm предоставляет удобную возможность загружать данные отношений в кеш
операционной системы или в кеш буферов PostgreSQL. Предварительную загрузку можно
выполнить вручную, вызвав функцию pg_prewarm, или автоматически, добавив pg_prewarm в
shared_preload_libraries. Во втором случае система запустит фоновый процесс, который будет пе-
риодически записывать содержимое разделяемых буферов в файл autoprewarm.blocks с тем, что-
бы эти блоки подгружались в память при запуске сервера, используя два дополнительных фоновых
процесса.
F.27.1. Функции
pg_prewarm(regclass, mode text default 'buffer', fork text default 'main',
first_block int8 default null,
last_block int8 default null) RETURNS int8
Первый аргумент задаёт отношение, которое будет «разогрето». Во втором указывается метод
«разогрева», из описанных ниже; в третьем задаётся целевой слой отношения, обычно main. В чет-
вёртом аргументе можно передать номер первого разогреваемого блока (NULL принимается как
синоним нуля), а в пятом — номер последнего блока (NULL означает последний блок отношения).
Возвращает эта функция количество разогретых блоков.
Эта функция поддерживает три режима разогрева. В режиме prefetch выдаются асинхронные за-
просы предвыборки данных операционной системе, если они поддерживаются, либо происходит
ошибка. В режиме read считывается заданный диапазон блоков; в отличие от prefetch это проис-
ходит синхронно и поддерживается во всех ОС и любыми сборками, но может быть медленнее. В
режиме buffer запрошенный диапазон блоков считывается в кеш буферов базы данных.
Заметьте, что с любым из этих методов попытка разогреть больше блоков, чем может уместиться
в кеше (в кеше ОС в режимах prefetch и read, либо в кеше PostgreSQL в режиме buffer) скорее
всего приведёт к тому, что блоки с меньшими номерами будут вытеснены из кеша при чтении по-
следующих блоков. Кроме того, разогретые данные никаким специальным образом не защищают-
ся от вытеснения из кеша, так что возможна ситуация, когда из-за другой активности только что
разогретые блоки будут вытеснены вскоре после чтения; с другой стороны при таком разогреве
из кеша могут быть вытеснены другие данные. Поэтому разогрев обычно наиболее полезен при
загрузке, когда кеши в основном пусты.
autoprewarm_start_worker() RETURNS void
2569Дополнительно по-
ставляемые модули
Запустить основной рабочий процесс авторазогрева. Обычно он запускается автоматически, но
эта функция полезна, если автоматический разогрев не был настроен при запуске сервера и вы
хотите запустить этот процесс позже.
autoprewarm_dump_now() RETURNS int8
Обновить autoprewarm.blocks немедленно. Это может быть полезно, если рабочий процесс авто-
разогрева не работает, но вы хотите, чтобы авторазогрев был произведён при перезапуске. Эта
функция возвращает число записей, внесённых в autoprewarm.blocks.
F.27.2. Параметры конфигурации
pg_prewarm.autoprewarm (boolean)
Указывает, должен ли сервер запускать рабочий процесс авторазогрева. По умолчанию он
включён. Задать этот параметр можно только при запуске сервера.
pg_prewarm.autoprewarm_interval (int)
Задаёт интервал между обновлениями файла autoprewarm.blocks. Значение по умолчанию —
300 сек. При значении, равном 0, файл будет сохраняться не периодически, а только при от-
ключении сервера.
F.27.3. Автор
Роберт Хаас <rhaas@postgresql.org>
F.28. pgrowlocks
Модуль pgrowlocks предоставляет функцию, показывающую информацию о блокировке строк для
заданной таблицы.
По
умолчанию
его
использование
разрешено
суперпользователям,
pg_stat_scan_tables и пользователям с правом SELECT в заданной таблице.
членам
роли
F.28.1. Обзор
pgrowlocks(text) returns setof record
В параметре передаётся имя таблицы. В результате возвращается набор записей, в котором строка
соответствует строке, заблокированной в таблице. Столбцы результата показаны в Таблице F.20.
Таблица F.20. Столбцы результата pgrowlocks
Имя Тип Описание
locked_row tid Идентификатор кортежа (TID)
блокированной строки
locker xid Идентификатор блокирующей
транзакции или идентифика-
тор мультитранзакции, если это
мультитранзакция
multi boolean True, если блокирующий субъ-
ект — мультитранзакция
xids xid[] Идентификаторы блокирующих
транзакций (больше одной для
мультитранзакции)
modes text[] Режим блокирования (больше
одного для мультитранзакции),
массив со значениями Key
2570Дополнительно по-
ставляемые модули
Имя Тип Описание
Share, Share, For No Key Update,
No Key Update, For Update,
Update.
pids integer[] Идентификаторы блокирующих
обслуживающих процессов (
больше одного для мультитран-
закции)
Функция pgrowlocks запрашивает блокировку AccessShareLock для целевой таблицы и считывает
строку за строкой для сбора информации о блокировке строк. Это происходит небыстро для боль-
шой таблицы. Заметьте, что:
1. Если таблица в целом заблокирована кем-то ещё, функция pgrowlocks будет блокироваться.
2. Функция pgrowlocks не гарантирует внутреннюю согласованность результатов. В ходе её выпол-
нения могут быть установлены новые блокировки строк, либо освобождены старые.
Функция pgrowlocks не показывает содержимое заблокированных строк. Если вы хотите парал-
лельно взглянуть на содержимое строк, можно проделать примерно следующее:
SELECT * FROM accounts AS a, pgrowlocks('accounts') AS p
WHERE p.locked_row = a.ctid;
Однако учтите, что такой запрос будет очень неэффективным.
F.28.2. Пример вывода
=# SELECT * FROM pgrowlocks('t1');
locked_row | locker | multi | xids |
modes
| pids
------------+--------+-------+-------+----------------+--------
(0,1)
|
609 | f
| {609} | {"For Share"} | {3161}
(0,2)
|
609 | f
| {609} | {"For Share"} | {3161}
(0,3)
|
607 | f
| {607} | {"For Update"} | {3107}
(0,4)
|
607 | f
| {607} | {"For Update"} | {3107}
(4 rows)
F.28.3. Автор
Тацуо Исии
F.29. pg_stat_statements
Модуль pg_stat_statements предоставляет возможность отслеживать статистику выполнения сер-
вером всех операторов SQL.
Этот модуль нужно загружать, добавив pg_stat_statements в shared_preload_libraries в файле
postgresql.conf, так как ему требуется дополнительная разделяемая память. Это значит, что для
загрузки или выгрузки модуля необходимо перезапустить сервер.
Когда модуль pg_stat_statements загружается, он отслеживает статистику по всем базам
данных на сервере. Для получения и обработки этой статистики этот модуль предоставля-
ет представление pg_stat_statements и вспомогательные функции pg_stat_statements_reset и
pg_stat_statements. Эти объекты не доступны глобально, но их можно установить в определённой
базе данных, выполнив команду CREATE EXTENSION pg_stat_statements.
F.29.1. Представление pg_stat_statements
Статистика, собираемая модулем, выдаётся через представление с именем pg_stat_statements.
Это представление содержит отдельные строки для каждой комбинации идентификатора базы дан-
2571Дополнительно по-
ставляемые модули
ных, идентификатора пользователя и идентификатора запроса (но в количестве, не превышающем
максимальное число различных операторов, которые может отслеживать модуль). Столбцы пред-
ставления показаны в Таблице F.21.
Таблица F.21. Столбцы pg_stat_statements
Имя Тип Ссылки Описание
userid oid pg_authid .oid OID пользователя, вы-
полнявшего оператор
dbid oid pg_database .oid OID базы данных, в ко-
торой выполнялся опе-
ратор
queryid bigint Внутренний
хеш-код,
вычисленный по дереву
разбора оператора
query text Текст,
представляю-
щий оператор
calls bigint Число выполнений
total_time double precision Общее время, потра-
ченное на оператор, в
миллисекундах
min_time double precision Минимальное
время,
потраченное на опера-
тор, в миллисекундах
max_time double precision Максимальное время,
потраченное на опера-
тор, в миллисекундах
mean_time double precision Среднее время, потра-
ченное на оператор, в
миллисекундах
stddev_time double precision Стандартное отклоне-
ние во времени, потра-
ченном на оператор, в
миллисекундах
rows bigint Общее число строк, по-
лученных или затрону-
тых оператором
shared_blks_hit bigint Общее число попада-
ний в разделяемый кеш
блоков для данного опе-
ратора
shared_blks_read bigint Общее
число
чте-
ний разделяемых бло-
ков для данного опера-
тора
shared_blks_dirtied bigint Общее число разделя-
емых блоков, «загряз-
нённых» данным опера-
тором
shared_blks_written bigint Общее число разделя-
емых блоков, записан-
ных данным операто-
ром
2572Дополнительно по-
ставляемые модули
Имя Тип
Ссылки
Описание
local_blks_hit bigint Общее число попада-
ний в локальный кеш
блоков для данного опе-
ратора
local_blks_read bigint Общее число чтений
локальных блоков для
данного оператора
local_blks_dirtied bigint Общее число локаль-
ных блоков, «загряз-
нённых» данным опера-
тором
local_blks_written bigint Общее число локаль-
ных блоков, записан-
ных данным операто-
ром
temp_blks_read bigint Общее число чтений
временных блоков для
данного оператора
temp_blks_written bigint Общее число записей
временных блоков для
данного оператора
blk_read_time double precision Общее время, потра-
ченное оператором на
чтение блоков, в мил-
лисекундах (если вклю-
чён track_io_timing, или
ноль в противном слу-
чае)
blk_write_time double precision Общее время, потра-
ченное оператором на
запись блоков, в мил-
лисекундах (если вклю-
чён track_io_timing, или
ноль в противном слу-
чае)
По соображениям безопасности только суперпользователям и членам роли pg_read_all_stats
разрешено видеть текст SQL и queryid запросов, выполняемых другими пользователями. Однако
другие пользователи могут видеть статистику, если это представление установлено в их базу дан-
ных.
Планируемые запросы (то есть, SELECT, INSERT, UPDATE и DELETE) объединяются в одну запись в
pg_stat_statements, когда они имеют идентичные структуры запросов согласно внутреннему вы-
численному хешу. Обычно два запроса будут считаться равными при таком сравнении, если они
семантически равнозначны, не считая значений констант, фигурирующих в запросе. Однако слу-
жебные команды (то есть все другие команды) сравниваются строго по текстовым строкам запро-
сов.
Когда значение константы игнорируется в целях сравнения запроса с другими запросами, эта кон-
станта заменяется в выводе pg_stat_statements обозначением параметра, например, $1. В осталь-
ном этот вывод содержит текст первого запроса, хеш которого равнялся значению queryid, свя-
занному с записью в pg_stat_statements.
В некоторых случаях запросы с визуально различными текстами могут быть объединены в одну
запись pg_stat_statements. Обычно это происходит только для семантически равнозначных за-
2573Дополнительно по-
ставляемые модули
просов, но есть небольшая вероятность, что из-за наложений хеша несвязанные запросы могут
оказаться объединёнными в одной записи. (Однако это невозможно для запросов, принадлежащих
разным пользователям баз данных.)
Так как значение хеша queryid вычисляется по представлениям запроса на стадии после разбора,
возможна и обратная ситуация: запросы с одинаковым текстом могут оказаться в разных записях,
если они получили различные представления по разным причинам, например, из-за изменения
search_path.
Потребители статистики pg_stat_statements могут пожелать использовать в качестве более ста-
бильного и надёжного идентификатора для каждой записи не текст запроса, а queryid (возможно,
в сочетании с dbid и userid). Однако важно понимать, что стабильность значения хеша queryid
гарантируется с ограничениями. Так как этот идентификатор получается из дерева запроса по-
сле анализа, его значение будет, помимо прочего, зависеть от внутренних идентификаторов объ-
ектов, фигурирующих в этом представлении. С этим связано несколько неинтуитивных следствий.
Например, pg_stat_statements будет считать два одинаково выглядящих запроса разными, если
они обращаются к таблице, которая была удалена, а затем воссоздана между этими запросами. Ре-
зультат хеширования также чувствителен к различиям в машинной архитектуре и другим особен-
ностям платформы. Более того, не стоит рассчитывать на то, что queryid будет оставаться неиз-
менным при обновлении основных версий PostgreSQL.
Как правило, значения queryid можно считать надёжными и сравнимыми, только с условием, что
версия сервера и детали метаданных каталога неизменны. Следовательно, можно ожидать, что два
сервера, участвующие в репликации на основе воспроизведения физического WAL, будут иметь
одинаковые queryid для одного запроса. Однако схемы с логической репликацией не гарантируют
сохранения идентичности реплик во всех имеющих значение деталях, так что queryid не будет по-
лезным идентификатором для накопления показателей стоимости по набору логических реплик.
В случае сомнений в том или ином подходе, рекомендуется непосредственно протестировать его.
Обозначения параметров, применяемые для замены констант в представляющем запросы тексте,
нумеруются, начиная со следующего за последним параметром $n в исходном тексте запроса, или
с $1 в отсутствие параметров в нём. Стоит отметить, что в некоторых случаях на эту нумерацию
могут влиять скрытые символы параметров. Например, PL/pgSQL применяет такие символы для
добавления в запросы значений локальных переменных функций, так что оператор PL/pgSQL вида
SELECT i + 1 INTO j будет представлен в тексте как SELECT i + $2.
Текст, представляющий запрос, сохраняется во внешнем файле не диске и не занимает разделя-
емую память. Поэтому даже очень объёмный текст запроса может быть сохранён успешно. Одна-
ко, если в файле накапливается много длинных текстов запросов, он может вырасти до неудобова-
римого размера. В качестве решения этой проблемы, pg_stat_statements может решить стереть
текст запросов, и в результате во всех существующих записях в представлении pg_stat_statements
в поле query окажутся значения NULL, хотя статистика, связанная с каждым queryid будет сохра-
нена. Если это происходит и мешает анализу, возможно, стоит уменьшить pg_stat_statements.max
для предотвращения таких ситуаций.
F.29.2. Функции
pg_stat_statements_reset() returns void
Функция pg_stat_statements_reset очищает всю статистику, собранную к этому времени мо-
дулем pg_stat_statements. По умолчанию эту функцию могут выполнять только суперпользо-
ватели.
pg_stat_statements(showtext boolean) returns setof record
Представление pg_stat_statements реализовано на базе функции, которая тоже называется
pg_stat_statements. Клиенты могут вызывать функцию pg_stat_statements непосредственно,
и могут указать showtext := false и получить результат без текста запроса (то есть, выход-
ной аргумент (OUT), соответствующий столбцу представления query, будет содержать NULL).
Эта возможность предназначена для поддержки внешних инструментов, для которых жела-
тельно избежать издержек, связанных с получением текстов запросов неопределённой дли-
2574Дополнительно по-
ставляемые модули
ны. Такие инструменты могут кешировать текст первого запроса, который они получат само-
стоятельно, как это и делает pg_stat_statements, а затем запрашивать тексты запросов толь-
ко при необходимости. Так как сервер сохраняет тексты запросов в файле, этот подход сокра-
щает объём физического ввода/вывода, порождаемого при постоянном обращении к данным
pg_stat_statements.
F.29.3. Параметры конфигурации
pg_stat_statements.max (integer)
Параметр pg_stat_statements.max задаёт максимальное число операторов, отслеживаемых
модулем (то есть, максимальное число строк в представлении pg_stat_statements). Когда на
обработку поступает больше, чем заданное число различных операторов, информация о редко
выполняемых операторах отбрасывается. Значение по умолчанию — 5000. Этот параметр мож-
но задать только при запуске сервера.
pg_stat_statements.track (enum)
Параметр pg_stat_statements.track определяет, какие операторы будут отслеживаться моду-
лем. Со значением top отслеживаются операторы верхнего уровня (те, что непосредственно
выполняются клиентами), со значением all также отслеживаются вложенные операторы (на-
пример, операторы, вызываемые внутри функций), а значение none полностью отключает сбор
статистики по операторам. Значение по умолчанию — top. Изменять этот параметр могут толь-
ко суперпользователи.
pg_stat_statements.track_utility (boolean)
Параметр pg_stat_statements.track_utility определяет, будет ли этот модуль отслеживать
служебные команды. Служебными командами считаются команды, отличные от SELECT, INSERT,
UPDATE и DELETE. Значение по умолчанию — on (вкл.). Изменить этот параметр могут только
суперпользователи.
pg_stat_statements.save (boolean)
Параметр pg_stat_statements.save определяет, должна ли статистика операторов сохранять-
ся после перезагрузки сервера. Если он отключён (имеет значение off), статистика не сохра-
няется при остановке сервера и не перезагружается при запуске. Значение по умолчанию — on
(вкл.). Этот параметр можно задать только в postgresql.conf или в командной строке сервера.
Этому модулю требуется дополнительная разделяемая память в объёме, пропорциональном
pg_stat_statements.max. Заметьте, что эта память будет занята при загрузке модуля, даже если
pg_stat_statements.track имеет значение none.
Эти параметры должны задаваться в postgresql.conf. Обычное использование выглядит так:
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.max = 10000
pg_stat_statements.track = all
F.29.4. Пример вывода
bench=# SELECT pg_stat_statements_reset();
$ pgbench -i bench
$ pgbench -c10 -t300 bench
bench=# \x
bench=# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5;
-[ RECORD 1 ]---------------------------------------------------------------------
2575Дополнительно по-
ставляемые модули
query
calls
total_time
rows
hit_percent
-[ RECORD 2
query
calls
total_time
rows
hit_percent
-[ RECORD 3
query
calls
total_time
rows
hit_percent
-[ RECORD 4
query
calls
total_time
rows
hit_percent
-[ RECORD 5
query
calls
total_time
rows
hit_percent
| UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2;
| 3000
| 9609.00100000002
| 2836
| 99.9778970000200936
]---------------------------------------------------------------------
| UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2;
| 3000
| 8015.156
| 2990
| 99.9731126579631345
]---------------------------------------------------------------------
| copy pgbench_accounts from stdin
| 1
| 310.624
| 100000
| 0.30395136778115501520
]---------------------------------------------------------------------
| UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2;
| 3000
| 271.741999999997
| 3000
| 93.7968855088209426
]---------------------------------------------------------------------
| alter table pgbench_accounts add primary key (aid)
| 1
| 81.42
| 0
| 34.4947735191637631
F.29.5. Авторы
Такахиро Итагаки <itagaki.takahiro@oss.ntt.co.jp>. Нормализацию запросов добавил Питер
Геохеган <peter@2ndquadrant.com>.
F.30. pgstattuple
Модуль pgstattuple предоставляет различные функции для получения статистики на уровне кор-
тежей.
Так как эти функции возвращают подробную информацию, относящуюся к уровню страни-
цы, доступ к ним по умолчанию ограничен. Право EXECUTE для них имеет только роль
pg_stat_scan_tables. Разумеется, суперпользователи могут обойти это ограничение. После того
как это расширение установлено, можно поменять права доступа к этим функциям командами
GRANT и разрешить их выполнение другим пользователям. Однако предпочтительнее будет доба-
вить этих пользователей в роль pg_stat_scan_tables.
F.30.1. Функции
pgstattuple(regclass) returns record
Функция pgstattuple возвращает физическую длину отношения, процент «мёртвых» кортежей
и другую информацию. Она может быть полезна для принятия решения о необходимости очист-
ки. В аргументе передаётся имя (возможно, дополненное схемой) или OID целевого отношения.
Например:
test=> SELECT * FROM pgstattuple('pg_catalog.pg_proc');
-[ RECORD 1 ]------+-------
table_len
| 458752
tuple_count
| 1470
2576Дополнительно по-
ставляемые модули
tuple_len
tuple_percent
dead_tuple_count
dead_tuple_len
dead_tuple_percent
free_space
free_percent
|
|
|
|
|
|
|
438896
95.67
11
3157
0.69
8932
1.95
Столбцы результата описаны в Таблице F.22.
Таблица F.22. Столбцы результата pgstattuple
Столбец Тип Описание
table_len bigint Физическая длина отношения
в байтах
tuple_count bigint Количество
жей
tuple_len bigint Общая длина «живых» корте-
жей в байтах
tuple_percent float8 Процент «живых» кортежей
dead_tuple_count bigint Количество «мёртвых» корте-
жей
dead_tuple_len bigint Общая длина «мёртвых» кор-
тежей в байтах
dead_tuple_percent float8 Процент «мёртвых» кортежей
free_space bigint Общий объём свободного про-
странства в байтах
free_percent float8 Процент свободного простран-
ства
«живых»
корте-
Примечание
Значение table_len всегда будет больше суммы tuple_len, dead_tuple_len и
free_space. Разница объясняется фиксированными издержками, внутристранич-
ной таблицей указателей на кортежи и пропусками, добавляемыми для выравнива-
ния кортежей.
Функция pgstattuple получает блокировку отношения только для чтения. Таким образом, её
результаты отражают не мгновенный снимок; на них будут влиять параллельные изменения.
pgstattuple считает кортеж «мёртвым», если HeapTupleSatisfiesDirty возвращает false.
pgstattuple(text) returns record
Эта функция равнозначна функции pgstattuple(regclass) за исключением того, что для неё
целевое отношение задаётся в текстовом виде. Данная функция оставлена для обратной сов-
местимости, в будущем она может перейти в разряд устаревших.
pgstatindex(regclass) returns record
Функция pgstatindex возвращает запись с информацией об индексе типа B-дерево. Например:
test=> SELECT * FROM pgstatindex('pg_cast_oid_index');
-[ RECORD 1 ]------+------
version
| 2
tree_level
| 0
index_size
| 16384
root_block_no
| 1
2577Дополнительно по-
ставляемые модули
internal_pages
leaf_pages
empty_pages
deleted_pages
avg_leaf_density
leaf_fragmentation
|
|
|
|
|
|
0
1
0
0
54.27
0
Столбцы результата:
Столбец Тип Описание
version integer Номер версии B-дерева
tree_level integer Уровень корневой страницы в
дереве
index_size bigint Общий объём индекса в байтах
root_block_no bigint Расположение страницы кор-
ня (0, если её нет)
internal_pages bigint Количество
«внутренних»
страниц (верхнего уровня)
leaf_pages bigint Количество страниц на уровне
листьев
empty_pages bigint Количество пустых страниц
deleted_pages bigint Количество удалённых стра-
ниц
avg_leaf_density float8 Средняя плотность страниц на
уровне листьев
leaf_fragmentation float8 Фрагментация на уровне ли-
стьев
Выдаваемый размер индекса (index_size) обычно вычисляется по формуле internal_pages +
leaf_pages + empty_pages + deleted_pages плюс одна страница, так как в нём учитывается
и метастраница индекса.
Как и pgstattuple, эта функция собирает данные страница за страницей и не следует ожидать,
что её результат представляет мгновенный снимок всего индекса.
pgstatindex(text) returns record
Эта функция равнозначна функции pgstatindex(regclass) за исключением того, что для неё
целевое отношение задаётся в текстовом виде. Данная функция оставлена для обратной сов-
местимости, в будущем она может перейти в разряд устаревших.
pgstatginindex(regclass) returns record
Функция pgstatginindex возвращает запись с информацией об индексе типа GIN. Например:
test=> SELECT * FROM pgstatginindex('test_gin_index');
-[ RECORD 1 ]--+--
version
| 1
pending_pages | 0
pending_tuples | 0
Столбцы результата:
Столбец Тип Описание
version integer Номер версии GIN
pending_pages integer Количество страниц в списке
ожидающих обработки
2578Дополнительно по-
ставляемые модули
Столбец Тип Описание
pending_tuples bigint Количество кортежей в списке
ожидающих обработки
pgstathashindex(regclass) returns record
Функция pgstathashindex возвращает запись с информацией о хеш-индексе. Например:
test=> select * from pgstathashindex('con_hash_index');
-[ RECORD 1 ]--+-----------------
version
| 4
bucket_pages
| 33081
overflow_pages | 0
bitmap_pages
| 1
unused_pages
| 32455
live_items
| 10204006
dead_items
| 0
free_percent
| 61.8005949100872
Столбцы результата:
Столбец Тип Описание
version integer Номер версии HASH
bucket_pages bigint Количество страниц групп
overflow_pages bigint Количество страниц перепол-
нения
bitmap_pages bigint Количество страниц битовой
карты
unused_pages bigint Количество неиспользованных
страниц
live_items bigint Количество
жей
dead_tuples bigint Количество «мёртвых» корте-
жей
free_percent float Процент свободного простран-
ства
«живых»
корте-
pg_relpages(regclass) returns bigint
Функция pg_relpages возвращает число страниц в отношении.
pg_relpages(text) returns bigint
Эта функция равнозначна функции pg_relpages(regclass) за исключением того, что для неё
целевое отношение задаётся в текстовом виде. Данная функция оставлена для обратной сов-
местимости, в будущем она может перейти в разряд устаревших.
pgstattuple_approx(regclass) returns record
Функция pgstattuple_approx является более быстрой альтернативой pgstattuple, возвращаю-
щей приблизительные результаты. В качестве аргумента ей передаётся имя или OID целевого
отношения. Например:
test=> SELECT * FROM pgstattuple_approx('pg_catalog.pg_proc'::regclass);
-[ RECORD 1 ]--------+-------
table_len
| 573440
scanned_percent
| 2
approx_tuple_count
| 2740
approx_tuple_len
| 561210
2579Дополнительно по-
ставляемые модули
approx_tuple_percent
dead_tuple_count
dead_tuple_len
dead_tuple_percent
approx_free_space
approx_free_percent
|
|
|
|
|
|
97.87
0
0
0
11996
2.09
Выходные столбцы описаны в Таблице F.23.
Тогда как pgstattuple всегда производит полное сканирование таблицы и возвращает точное
число живых и мёртвых кортежей (и их размер), а также точный объём свободного простран-
ства, функция pgstattuple_approx пытается избежать полного сканирования и возвращает
точную статистику только по мёртвым кортежам, а количество и объём живых кортежей, как
и объём свободного пространства определяет приблизительно.
Она делает это, пропуская страницы, в которых, согласно карте видимости, есть только види-
мые кортежи (если для страницы установлен соответствующий бит, предполагается, что она
не содержит мёртвых кортежей). Для таких страниц эта функция узнаёт объём свободного про-
странства из карты свободного пространства и предполагает, что остальное пространство на
странице занято живыми кортежами.
На страницах, которые нельзя пропустить, она сканирует каждый кортеж, отражает его нали-
чие и размер в соответствующих счётчиках и суммирует свободное пространство на странице. В
конце она оценивает приблизительно общее число живых кортежей, исходя из числа проскани-
рованных страниц и кортежей (так же, как VACUUM рассчитывает значение pg_class.reltuples).
Таблица F.23. Столбцы результата pgstattuple_approx
Столбец Тип Описание
table_len bigint Физическая длина отношения
в байтах (точная)
scanned_percent float8 Просканированный
таблицы
approx_tuple_count bigint Количество «живых» корте-
жей (приблизительное)
approx_tuple_len bigint Общая длина «живых» корте-
жей в байтах (приблизитель-
ная)
approx_tuple_percent float8 Процент «живых» кортежей
dead_tuple_count bigint Количество «мёртвых» корте-
жей (точное)
dead_tuple_len bigint Общая длина «мёртвых» кор-
тежей в байтах (точная)
dead_tuple_percent float8 Процент «мёртвых» кортежей
approx_free_space bigint Общий объём свободного про-
странства в байтах (приблизи-
тельный)
approx_free_percent float8 Процент свободного простран-
ства
процент
В показанном выше выводе показатели свободного пространства могут не соответствовать вы-
воду pgstattuple в точности, потому что карта свободного пространства показывает верное
значение, но не гарантируется, что оно будет точным до байта.
F.30.2. Авторы
Тацуо Исии, Сатоши Нагаясу и Абхиджит Менон-Сен
2580Дополнительно по-
ставляемые модули
F.31. pg_trgm
Модуль pg_trgm предоставляет функции и операторы для определения схожести алфавитно-циф-
ровых строк на основе триграмм, а также классы операторов индексов, поддерживающие быстрый
поиск схожих строк.
F.31.1. Понятия, связанные с триграммами (или триграфами)
Триграмма — это группа трёх последовательных символов, взятых из строки. Мы можем измерить
схожесть двух строк, подсчитав число триграмм, которые есть в обеих. Эта простая идея оказыва-
ется очень эффективной для измерения схожести слов на многих естественных языках.
Примечание
pg_trgm, извлекая триграммы из строк, игнорирует символы, не относящиеся к словам
(не алфавитно-цифровые). При выделении триграмм, содержащихся в строке, считает-
ся, что перед каждым словом находятся два пробела, а после — один пробел. Напри-
мер, из строки «cat» выделяется набор триграмм: « c», « ca», «cat» и «at ». Из строки
«foo|bar» выделяются триграммы: « f», « fo», «foo», «oo », « b», « ba», «bar» и «ar ».
F.31.2. Функции и операторы
Реализованные в модуле pg_trgm функции перечислены в Таблице F.24, а операторы — в Табли-
це F.25.
Таблица F.24. Функции pg_trgm
Функция Возвращает Описание
similarity(text, text) real Возвращает число, показываю-
щее, насколько близки два ар-
гумента. Диапазон результатов
— от нуля (это значение указы-
вает, что две строки полностью
различны) до одного (это значе-
ние указывает, что две строки
идентичны).
show_trgm(text) text[] Возвращает массив всех три-
грамм в заданной строке. (На
практике это редко бывает по-
лезно, кроме как для отладки.)
word_similarity(text,
text) real Возвращает число, представ-
ляющее наибольшую степень
схожести между набором три-
грамм в первой строке и любым
непрерывным фрагментом упо-
рядоченного набора триграмм
во второй строке. Подробнее об
этом рассказывается ниже.
strict_word_similarity(
text, text) real Подобна
word_similarity(
text,
text) , но подгоня-
ет границы фрагментов к гра-
ницам слов. Так как триграм-
мы не пересекают слова, эта
функция фактически выдаёт
наибольшую степень схожести
между первой строкой и любой
2581Дополнительно по-
ставляемые модули
Функция Возвращает Описание
непрерывной последовательно-
стью слов во второй строке.
show_limit() real Возвращает текущий порог схо-
жести, который использует опе-
ратор %. Это значение задаёт
минимальную схожесть между
двумя словами, при которой они
считаются настолько близкими,
что одно может быть, например,
ошибочным написанием друго-
го (устаревшая).
set_limit(real) real Задаёт текущий порог схоже-
сти, который использует опе-
ратор %. Это значение должно
быть в диапазоне от 0 до 1 (по
умолчанию 0.3). Возвращает то
же значение, что было переда-
но на вход (устаревшая).
Рассмотрим следующий пример:
# SELECT word_similarity('word', 'two words');
word_similarity
-----------------
0.8
(1 row)
Набор триграмм для первой строки: {" w"," wo","wor","ord","rd "}. Во второй строке упоря-
доченный набор триграмм: {" t"," tw","two","wo "," w"," wo","wor","ord","rds","ds "}.
Наиболее близкий фрагмент упорядоченного множества триграмм во второй строке: {" w","
wo","wor","ord"}, а коэффициент схожести равен 0.8.
Эта функция возвращает значение, которое можно примерно воспринимать как максимальную
оценку схожести первой строки с любой подстрокой второй строки. Данная функция не добавляет
пробелы к границам фрагмента, поэтому совпадение с отдельным словом оценивается выше, чем
совпадение с частью слова.
При этом strict_word_similarity(text, text) выбирает последовательность слов во вто-
рой строке. В показанном выше примере strict_word_similarity(text,
text) выберет
последовательность из одного слова 'words', которой соответствуют триграммы {"
w","
wo","wor","ord","rds","ds "}.
# SELECT strict_word_similarity('word', 'two words'), similarity('word', 'words');
strict_word_similarity | similarity
------------------------+------------
0.571429 |
0.571429
(1 row)
Таким образом, функция strict_word_similarity(text, text) полезна для определения схожести
целых слов, а word_similarity(text, text) больше подходит для определения схожести частей
слов.
Таблица F.25. Операторы pg_trgm
Оператор Возвращает Описание
text % text boolean Возвращает true, если схо-
жесть аргументов выше теку-
2582Дополнительно по-
ставляемые модули
Оператор Возвращает Описание
щего порога, заданного пара-
метром pg_trgm.similarity_
threshold .
text <% text boolean Возвращает true, если схо-
жесть между набором три-
грамм в первом аргументе и
непрерывным фрагментом упо-
рядоченного набора триграмм
во втором превышает уровень
схожести,
устанавливаемый
параметром
pg_trgm.word_
similarity_threshold .
text %> text boolean Коммутирующий оператор для
<%.
text <<% text boolean Возвращает true, если во вто-
ром аргументе имеется непре-
рывный фрагмент упорядочен-
ного набора триграмм, соот-
ветствующего границам слов,
и его схожесть с набором
триграмм первого аргумен-
та превышает уровень схоже-
сти, устанавливаемый парамет-
ром
pg_trgm.strict_word_
similarity_threshold .
text %>> text boolean Коммутирующий оператор для
<<%.
text <-> text real Возвращает «расстояние» меж-
ду аргументами, то есть один
минус значение similarity() .
text <<-> text real Возвращает «расстояние» меж-
ду
аргументами,
то
есть
один минус значение word_
similarity() .
text <->> text real Коммутирующий оператор для
<<->.
text <<<-> text real Возвращает «расстояние» меж-
ду аргументами, то есть один
минус значение strict_word_
similarity() .
text <->>> text real Коммутирующий оператор для
<<<->.
F.31.3. Параметры GUC
pg_trgm.similarity_threshold (real)
Задаёт текущий порог схожести, который использует оператор %. Это значение должно быть в
диапазоне от 0 до 1 (по умолчанию 0.3).
pg_trgm.word_similarity_threshold (real)
Задаёт текущий порог схожести, который используют операторы <% и %>. Это значение должно
быть в диапазоне от 0 до 1 (по умолчанию 0.6).
2583Дополнительно по-
ставляемые модули
F.31.4. Поддержка индексов
Модуль pg_trgm предоставляет классы операторов индексов GiST и GIN, позволяющие создавать
индекс по текстовым столбцам для очень быстрого поиска по критерию схожести. Эти типы ин-
дексов поддерживают вышеописанные операторы схожести и дополнительно поддерживают поиск
на основе триграмм для запросов с LIKE, ILIKE, ~ и ~*. (Эти индексы не поддерживают простые
операторы сравнения и равенства, так что вам может понадобиться и обычный индекс-B-дерево.)
Пример:
CREATE TABLE test_trgm (t text);
CREATE INDEX trgm_idx ON test_trgm USING GIST (t gist_trgm_ops);
или
CREATE INDEX trgm_idx ON test_trgm USING GIN (t gin_trgm_ops);
На этот момент у вас будет индекс по столбцу t, используя который можно осуществлять поиск
по схожести. Пример типичного запроса:
SELECT t, similarity(t, 'слово') AS sml
FROM test_trgm
WHERE t % 'слово'
ORDER BY sml DESC, t;
Он выдаст все значения в текстовом столбце, которые достаточно схожи со словом word, в поряд-
ке сортировки от наиболее к наименее схожим. Благодаря использованию индекса, эта операция
будет быстрой даже с очень большими наборами данных.
Другой вариант предыдущего запроса:
SELECT t, t <-> 'слово' AS dist
FROM test_trgm
ORDER BY dist LIMIT 10;
Он может быть довольно эффективно выполнен с применением индексов GiST, а не GIN. Обычно он
выигрышнее первого варианта только когда требуется получить небольшое количество близких
совпадений.
Также вы можете использовать индекс по столбцу t для оценки схожести слов условных и оценки
схожести слов в строгом смысле. Примеры типичных запросов:
SELECT t, word_similarity('слово', t) AS sml
FROM test_trgm
WHERE 'слово' <% t
ORDER BY sml DESC, t;
и
SELECT t, strict_word_similarity('слово', t) AS sml
FROM test_trgm
WHERE 'слово' <<% t
ORDER BY sml DESC, t;
В результате будут возвращены все значения в текстовом столбце, для которых найдется непре-
рывный фрагмент в упорядоченном наборе триграмм, достаточно схожий с набором триграмм
строки слово. Данные значения будут отсортированы по порядку от наиболее к наименее схожим.
Этот индекс позволит ускорить поиск даже с очень большим объёмом данных.
Другие возможные варианты предыдущих запросов:
SELECT t, 'слово' <<-> t AS dist
FROM test_trgm
ORDER BY dist LIMIT 10;
и
2584Дополнительно по-
ставляемые модули
SELECT t, 'слово' <<<-> t AS dist
FROM test_trgm
ORDER BY dist LIMIT 10;
Они могут быть довольно эффективно выполнены с применением индексов GiST, а не GIN.
Начиная с PostgreSQL 9.1, эти типы индексов также поддерживают поиск с операторами LIKE и
ILIKE, например:
SELECT * FROM test_trgm WHERE t LIKE '%foo%bar';
При таком поиске по индексу сначала из искомой строки извлекаются триграммы, а затем они
ищутся в индексе. Чем больше триграмм оказывается в искомой строке, тем более эффективным
будет поиск по индексу. В отличие от поиска по B-дереву, искомая строка не должна привязывать-
ся к левому краю.
Начиная с PostgreSQL 9.3, индексы этих типов также поддерживают поиск по регулярным выра-
жениям (операторы ~ и ~*), например:
SELECT * FROM test_trgm WHERE t ~ '(foo|bar)';
При таком поиске из регулярного выражения извлекаются триграммы, а затем они ищутся в ин-
дексе. Чем больше триграмм удаётся извлечь из регулярного выражения, тем более эффективным
будет поиск по индексу. В отличие от поиска по B-дереву, искомая строка не должна привязывать-
ся к левому краю.
Относительно поиска по регулярному выражению или с LIKE, имейте в виду, что при отсутствии
триграмм в искомом шаблоне поиск сводится к полному сканирования индекса.
Выбор между индексами GiST и GIN зависит от относительных характеристик производительности
GiST и GIN, которые здесь не рассматриваются.
F.31.5. Интеграция с текстовым поиском
Сопоставление триграмм — очень полезный приём в сочетании с применением полнотекстового
индекса. В частности это может помочь найти слова, написанные неправильно, которые не будут
находиться непосредственно механизмом полнотекстового поиска.
В первую очередь нужно построить дополнительную таблицу, содержащую все уникальные слова
в документе:
CREATE TABLE words AS SELECT word FROM
ts_stat('SELECT to_tsvector(''simple'', bodytext) FROM documents');
Здесь documents — это таблица с текстовым полем bodytext, по которому мы будем выполнять по-
иск. Конфигурация simple используется с функцией to_tsvector вместо конфигурации для опре-
делённого языка по той причине, что нам нужен список исходных (необработанных стеммером)
слов.
Затем нужно создать индекс триграмм по столбцу со словами:
CREATE INDEX words_idx ON words USING GIN (word gin_trgm_ops);
Теперь мы можем использовать запрос SELECT, подобный показанному в предыдущем примере, и
предлагать варианты исправлений слов, введённых пользователем с ошибками. Кроме того, может
быть полезно дополнительно проверить, что выбранные слова также имеют длину, примерно рав-
ную длине ошибочных слов.
Примечание
Так как таблица words была сформирована как отдельная статическая таблица, её нуж-
но периодически обновлять, чтобы она достаточно хорошо соответствовала набору до-
кументов. Постоянно поддерживать её в полностью актуальном состоянии обычно не
требуется.
2585Дополнительно по-
ставляемые модули
F.31.6. Ссылки
Сайт разработки GiST http://www.sai.msu.su/~megera/postgres/gist/
Сайт разработки Tsearch2 http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/
F.31.7. Авторы
Олег Бартунов <oleg@sai.msu.su>, Москва, Московский Государственный Университет, Россия
Фёдор Сигаев <teodor@sigaev.ru>, Москва, ООО «Дельта-Софт», Россия
Александр Коротков <a.korotkov@postgrespro.ru>, Москва, Postgres Professional, Россия
Документация: Кристофер Кингс-Линн
Разработку этого модуля спонсировало ООО «Дельта-Софт», г. Москва, Россия.
F.32. pg_visibility
Модуль pg_visibility даёт возможность исследовать для определённой таблицы карту видимости
(Visibility Map, VM) и информацию о видимости на уровне страниц. Он также предоставляет функ-
ции для проверки целостности карты видимости и принудительного её пересоздания.
Для хранения информации о видимости на уровне страниц применяются по три различных бита.
Бит полной видимости в карте показывает, что каждый кортеж в соответствующей странице отно-
шения является видимым для всех текущих и будущих транзакций. Бит полной заморозки в карте
видимости показывает, что все кортежи в данной странице являются замороженными; то есть ни-
какой операции очистки в будущем не придётся обрабатывать эту страницу, пока в ней не будет
добавлен, изменён, удалён или заблокирован кортеж. Бит PD_ALL_VISIBLE в заголовке страницы
имеет то же значение, что и бит полной видимости в карте видимости, но он хранится в самой
странице данных, а не в отдельной структуре данных. В обычной ситуации эти два бита будут со-
гласованы, но бит полной видимости в странице иногда может быть установлен, тогда как в карте
видимости он оказывается сброшенным при восстановлении после сбоя. Считываемые значения
могут также различаться, если они подвергаются изменению в промежутке между обращениями
pg_visibility к карте видимости и к странице данных. Разумеется, эти биты также могут разли-
чаться при событиях, приводящих к разрушению данных.
Функции, выдающие информацию о битах PD_ALL_VISIBLE, более дорогостоящие, чем те, что обра-
щаются только к карте видимости, так как они должны читать блоки отношения, а не только карту
видимости (которая намного меньше). Дорогостоящими являются также и функции, проверяющие
блоки данных отношения.
F.32.1. Функции
pg_visibility_map(relation regclass, blkno bigint, all_visible OUT boolean, all_frozen
OUT boolean) returns record
Возвращает биты полной видимости и полной заморозки в карте видимости для указанного
блока заданного отношения.
pg_visibility(relation regclass, blkno bigint, all_visible OUT boolean, all_frozen OUT
boolean, pd_all_visible OUT boolean) returns record
Возвращает биты полной видимости и полной заморозки в карте видимости для указанного
блока заданного отношения, а также бит PD_ALL_VISIBLE этого блока.
pg_visibility_map(relation regclass, blkno
all_frozen OUT boolean) returns setof record
OUT
bigint,
all_visible
OUT
boolean,
Возвращает биты полной видимости и полной заморозки в карте видимости для каждого блока
заданного отношения.
2586Дополнительно по-
ставляемые модули
pg_visibility(relation regclass, blkno OUT bigint, all_visible OUT boolean, all_frozen
OUT boolean, pd_all_visible OUT boolean) returns setof record
Возвращает биты полной видимости и полной заморозки в карте видимости для каждого блока
заданного отношения, а также бит PD_ALL_VISIBLE каждого блока.
pg_visibility_map_summary(relation
bigint) returns record
regclass,
all_visible
OUT
bigint,
all_frozen
OUT
Возвращает число полностью видимых страниц и полностью замороженных страниц в отноше-
нии, согласно карте видимости.
pg_check_frozen(relation regclass, t_ctid OUT tid) returns setof tid
Возвращает идентификаторы TID незамороженных кортежей в страницах, помеченных как пол-
ностью замороженные в карте видимости. Если эта функция возвращает непустой набор TID,
карта видимости испорчена.
pg_check_visible(relation regclass, t_ctid OUT tid) returns setof tid
Возвращает идентификаторы TID не полностью видимых кортежей в страницах, помеченных
как полностью видимые в карте видимости. Если эта функция возвращает непустой набор TID,
карта видимости испорчена.
pg_truncate_visibility_map(relation regclass) returns void
Аннулирует карту видимости для заданного отношения. Эта функция полезна, если вы счита-
ете, что карта видимости для указанного отношения испорчена, и хотите принудительно пере-
создать её. Первая же команда VACUUM, выполняемая с данным отношением после этой функ-
ции, просканирует все страницы в отношении и пересоздаст карту видимости. (Пока это не
произойдёт, для запросов карта видимости будет выглядеть как полностью нулевая.)
По умолчанию эти функции разрешено выполнять только суперпользователям и членам роли
pg_stat_scan_tables, за исключением pg_truncate_visibility_map(relation regclass), кото-
рую могут выполнять только суперпользователи.
F.32.2. Автор
Роберт Хаас <rhaas@postgresql.org>
F.33. postgres_fdw
Модуль postgres_fdw предоставляет обёртку сторонних данных postgres_fdw, используя которую
можно обращаться к данным, находящимся на внешних серверах PostgreSQL.
Функциональность этого модуля во многом пересекается с функциональностью старого модуля
dblink. Однако postgres_fdw предоставляет более прозрачный и стандартизированный синтаксис
для обращения к удалённым таблицам и во многих случаях даёт лучшую производительность.
Чтобы подготовиться к обращению к удалённым данным через postgres_fdw:
1. Установите расширение postgres_fdw с помощью команды CREATE EXTENSION.
2. Создайте объект стороннего сервера, используя CREATE SERVER, который будет представлять
удалённую базу данных, к которой вы хотите подключаться. Укажите свойства подключения,
кроме user и password, в параметрах объекта сервера.
3. Создайте сопоставление пользователей, используя CREATE USER MAPPING, для каждого поль-
зователя базы, которому нужен доступ к удалённому серверу. Укажите имя и пароль удалённого
пользователя в параметрах user и password сопоставления.
4. Создайте стороннюю таблицу, используя CREATE FOREIGN TABLE или IMPORT FOREIGN
SCHEMA, для каждой удалённой таблицы, к которой вы хотите обращаться. Столбцы сторонней
таблицы должны соответствовать столбцам целевой удалённой таблицы. Однако вы можете ис-
пользовать локально имена таблиц и/или столбцов, отличные от удалённых, если укажете кор-
ректные удалённые имена в параметрах объекта сторонней таблицы.
2587Дополнительно по-
ставляемые модули
После этого для обращения к данным, хранящимся в нижележащей удалённой таблице, вам нуж-
но только выполнять SELECT. Вы также можете изменять данные в удалённой таблице, выполняя
INSERT, UPDATE или DELETE. (Разумеется, удалённый пользователь, указанный в сопоставлении, дол-
жен иметь необходимые права для этого.)
Заметьте, что в настоящее время в postgres_fdw не поддерживаются операторы INSERT с предло-
жением ON CONFLICT DO UPDATE. Однако предложение ON CONFLICT DO NOTHING поддерживается,
при отсутствии указания для выбора уникального индекса.
Обычно рекомендуется объявлять столбцы сторонней таблицы точно с теми же типами данных и
правилами сортировки, если они применимы, как у целевых столбцов удалённой таблицы. Хотя
postgres_fdw в настоящее время довольно лоялен к преобразованиям типов данных при необхо-
димости, но когда типы или правила сортировки не совпадают, возможны неожиданные семанти-
ческие аномалии, вследствие того, что удалённый сервер будет обрабатывать предложения WHERE
не совсем так, как локальный сервер.
Заметьте, что сторонняя таблица может быть объявлена с меньшим количеством или с другим
порядком столбцов, чем в нижележащей удалённой таблице. Сопоставление столбцов удалённой
таблицы осуществляется по имени, а не по позиции.
F.33.1. Параметры обёртки для postgres_fdw
F.33.1.1. Параметры подключения
Для стороннего сервера, настраиваемого с использованием обёртки сторонних данных
postgres_fdw, можно задать те же параметры, что принимает libpq в строках подключения, как
описано в Подразделе 34.1.2, за исключением следующих недопустимых параметров:
• user и password (их следует задавать в сопоставлениях пользователей)
• client_encoding (автоматически принимается равной локальной кодировке сервера)
• fallback_application_name (всегда postgres_fdw)
Подключаться к сторонним серверам без аутентификации по паролю могут только суперполь-
зователи, поэтому в сопоставлениях для обычных пользователей всегда нужно задавать пароль
(password).
F.33.1.2. Параметры имени объекта
Эти параметры позволяют управлять тем, как на удалённый сервер PostgreSQL будут передавать-
ся имена, фигурирующие в операторах SQL. Данные параметры нужны, когда сторонняя таблица
создаётся с именами, отличными от имён удалённой таблицы.
schema_name
Этот параметр, который может задаваться для сторонней таблицы, указывает имя схемы для
обращения к этой таблице на удалённом сервере. Если данный параметр опускается, приме-
няется схема сторонней таблицы.
table_name
Этот параметр, который может задаваться для сторонней таблицы, указывает имя таблицы для
обращения к этой таблице на удалённом сервере. Если данный параметр опускается, приме-
няется имя сторонней таблицы.
column_name
Этот параметр, который может задаваться для столбца сторонней таблицы, указывает имя
столбца для обращения к этому столбцу на удалённом сервере. Если данный параметр опуска-
ется, применяется исходное имя столбца.
F.33.1.3. Параметры оценки стоимости
Модуль postgres_fdw получает удалённые данные, выполняя запросы на удалённых серверах, по-
этому в идеале ожидаемая стоимость сканирования сторонней таблицы должна равняться стоимо-
2588Дополнительно по-
ставляемые модули
сти выполнения на удалённом сервере плюс издержки сетевого взаимодействия. Самый надёжный
способ получить такие оценки — узнать стоимость у удалённого сервера и добавить некоторую
надбавку — но для простых запросов может быть невыгодно передавать дополнительный запрос,
только чтобы получить оценку стоимости. Поэтому postgres_fdw предоставляет следующие пара-
метры, позволяющие управлять вычислением оценки стоимости:
use_remote_estimate
Этот параметр, который может задаваться для сторонней таблицы или для стороннего сервера,
определяет, будет ли postgres_fdw выполнять удалённо команды EXPLAIN для получения оце-
нок стоимости. Параметр, заданный для сторонней таблицы, переопределяет параметр серве-
ра, но только для данной таблицы. Значение по умолчанию — false (выкл.).
fdw_startup_cost
Этот параметр, который может задаваться для стороннего сервера, устанавливает числовое
значение, добавляемое к оценке стоимости запуска для любого сканирования сторонней таб-
лицы на этом сервере. Он выражает дополнительные издержки на установление подключения,
разбор и планирование запроса на удалённой стороне и т. д. Значение по умолчанию — 100.
fdw_tuple_cost
Этот параметр, который может задаваться для стороннего сервера, устанавливает числовое
значение, выражающее дополнительную цену чтения одного кортежа из сторонней таблицы
на этом сервере. Это число можно увеличить или уменьшить, отражая меньшую или большую
фактическую скорость сетевого взаимодействия с удалённым сервером. Значение по умолча-
нию — 0.01.
Когда поведение use_remote_estimate включено, postgres_fdw получает количество строк и оцен-
ку стоимости с удалённого сервера, а затем добавляет к оценке стоимости fdw_startup_cost
и fdw_tuple_cost. Когда поведение use_remote_estimate отключено, postgres_fdw рассчиты-
вает число строк и оценку стоимости локально, а затем так же добавляет к этой оценке
fdw_startup_cost и fdw_tuple_cost. Локальная оценка может быть точной только при условии
наличия локальной копии статистики удалённых таблиц. Обновить эту статистику для сторонней
таблицы можно с помощью команды ANALYZE; при этом удалённая таблица будет просканирова-
на, и по её содержимому будут вычислена и сохранена статистика как для локальной таблицы.
Локальное хранение статистики может быть полезно для сокращения издержек планирования для
удалённой таблицы — но если удалённая таблица меняется часто, локальная статистика будет
быстро устаревать.
F.33.1.4. Параметры удалённого выполнения
По умолчанию ограничения WHERE, содержащие встроенные операторы и функции, обрабатывают-
ся на удалённом сервере, а ограничения, содержащие вызовы не встроенных функций, проверя-
ются локально после получения строк. Если же расширенные функции доступны на удалённом
сервере и можно рассчитывать, что они дадут те же результаты, что и локально, производитель-
ность можно увеличить, передавая и такие предложения WHERE для удалённого выполнения. Этим
поведением позволяет управлять следующий параметр:
extensions
В этом параметре задаётся список имён расширений PostgreSQL через запятую, которые уста-
новлены и имеют совместимые версии и на локальном, и на удалённом сервере. Относящиеся
к перечисленным расширениям и при этом постоянные (immutable) функции и операторы мо-
гут передаваться на выполнение удалённому серверу. Этот параметр можно задать только для
стороннего сервера, но не для таблицы.
При использовании параметра extensions пользователь сам отвечает за то, чтобы перечис-
ленные расширения существовали и их поведение было одинаковым на локальном и удалённом
сервере. В противном случае удалённые запросы могут выдавать ошибки или неожиданные ре-
зультаты.
2589Дополнительно по-
ставляемые модули
fetch_size
Этот параметр определяет, сколько строк должна получать postgres_fdw в одной операции вы-
борки. Его можно задать для сторонней таблицы или стороннего сервера. Значение по умол-
чанию — 100 строк.
F.33.1.5. Параметры изменения данных
По умолчанию все сторонние таблицы, доступные через postgres_fdw, считаются допускающими
изменения. Это можно переопределить с помощью следующего параметра:
updatable
Этот параметр определяет, будет ли postgres_fdw допускать изменения в сторонних таблицах
посредством команд INSERT, UPDATE и DELETE. Его можно задать для сторонней таблицы или для
стороннего сервера. Параметр, определённый на уровне таблицы, переопределяет параметр
уровня сервера. Значение по умолчанию — true (изменения разрешены).
Конечно, если удалённая таблица на самом деле не допускает изменения, всё равно произойдёт
ошибка. Использование этого параметра прежде всего позволяет выдать ошибку локально, не
обращаясь к удалённому серверу. Заметьте, однако, что представление information_schema
будет показывать, что определённая сторонняя таблица postgres_fdw является изменяемой
(или нет), согласно значению данного параметра, не проверяя это на удалённом сервере.
F.33.1.6. Параметры импорта
Обёртка postgres_fdw позволяет импортировать определения сторонних таблиц с применением
команды IMPORT FOREIGN SCHEMA. Эта команда создаёт на локальном сервере определения
сторонних таблиц, соответствующие таблицам или представлениям, существующим на удалённом
сервере. Если импортируемые удалённые таблицы содержат столбцы пользовательских типов дан-
ных, на локальном сервере должны быть совместимые типы с теми же именами.
Поведение процедуры импорта можно настроить следующими параметрами (задаваемыми в ко-
манде IMPORT FOREIGN SCHEMA):
import_collate
Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с
внешнего сервера, включаться характеристики столбцов COLLATE. По умолчанию они включа-
ются. Вам может потребоваться отключить его, если на удалённом сервере набор имён правил
сортировки отличается от локального, что скорее всего будет иметь место, если серверы рабо-
тают в разных операционных системах.
import_default
Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с
внешнего сервера, включаться заданные для столбцов выражения DEFAULT. По умолчанию они
не включаются. Если вы включите этот параметр, остерегайтесь выражений по умолчанию,
которые могут вычисляться на локальном сервере не так, как на удалённом; например, частый
источник проблем — nextval(). Если в импортируемом выражении используются функции или
операторы, несуществующие локально, команда IMPORT в целом выдаст сбой.
import_not_null
Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с
внешнего сервера, включаться ограничения столбцов NOT NULL. По умолчанию они включают-
ся.
Заметьте, что никакие другие ограничения, кроме NOT NULL, из удалённых таблиц импортировать-
ся не будут. Хотя PostgreSQL поддерживает ограничения CHECK для сторонних таблиц, никаких
средств для автоматического импорта их нет из-за риска различного вычисления выражения огра-
2590Дополнительно по-
ставляемые модули
ничения на локальном и удалённом серверах. Любая такая несогласованность в поведении огра-
ничений CHECK могла бы привести к сложно выявляемым ошибкам в оптимизации запросов. Поэто-
му, если вы хотите импортировать ограничения CHECK, вы должны сделать это вручную и должны
внимательно проверить семантику каждого. Более подробно интерпретация ограничений CHECK
для сторонних таблиц описана в CREATE FOREIGN TABLE.
Таблицы или сторонние таблицы, являющиеся секциями некоторой другой таблицы, исключаются
автоматически. Секционированные таблицы импортируются, только если они не являются секци-
ями каких-либо других таблиц. Так как все данные могут быть доступны через секционированную
таблицу, являющуюся вершиной в иерархии секционирования, при таком подходе должен быть
возможен доступ ко всем данным без создания дополнительных объектов.
F.33.2. Управление соединением
Модуль postgres_fdw устанавливает соединение со сторонним сервером при первом запросе, в ко-
тором участвует сторонняя таблица, связанная со сторонним сервером. Это соединение сохраня-
ется и повторно используется для последующих запросов в том же сеансе. Однако, если для обра-
щения к стороннему серверу задействуются разные пользователи (сопоставления пользователей),
отдельное соединение устанавливается для каждого сопоставления пользователей.
F.33.3. Управление транзакциями
В процессе выполнения запроса, в котором участвуют какие-либо удалённые таблицы на сторон-
нем сервере, postgres_fdw открывает транзакцию на удалённом сервере, если такая транзакция
ещё не была открыта для текущей локальной транзакции. Эта удалённая транзакция фиксируется
или прерывается, когда фиксируется или прерывается локальная транзакция. Подобным образом
реализуется и управление точками сохранения.
Для удалённой транзакции выбирается режим изоляции SERIALIZABLE, когда локальная транзак-
ция открыта в режиме SERIALIZABLE; в противном случае применяется режим REPEATABLE READ.
Этот выбор гарантирует, что если запрос сканирует несколько таблиц на удалённом сервере, он
будет получать согласованные данные одного снимка для всех сканирований. Как следствие, по-
следовательные запросы в одной транзакции будут видеть одни данные удалённого сервера, даже
если на нём параллельно происходят изменения, вызванные другими действиями. Это поведение
ожидаемо для локальной транзакции в режимах SERIALIZABLE и REPEATABLE READ, но для локаль-
ной транзакции в режиме READ COMMITTED оно может быть неожиданным. В будущих выпусках
PostgreSQL эти правила могут быть изменены.
F.33.4. Оптимизация удалённых запросов
Обёртка postgres_fdw пытается оптимизировать удалённые запросы, уменьшая объём обмена дан-
ными со сторонними серверами. Для этого она может передавать на выполнение удалённому сер-
веру предложения WHERE и не получать столбцы таблицы, не требующиеся для текущего запроса.
Чтобы уменьшить риск некорректного выполнения запросов, предложения WHERE передаются уда-
лённому серверу, только если в них используются типы данных, операторы и функции, встроен-
ные в ядро или относящиеся к расширениям, перечисленным в параметре extensions. Операто-
ры и функции в таких предложениях также должны быть постоянными (IMMUTABLE). Для запросов
UPDATE или DELETE обёртка postgres_fdw пытается оптимизировать выполнение, передавая весь
запрос на удалённый сервер, если в запросе нет предложения WHERE, которое нельзя было бы пере-
дать, не выполняется локальное соединение, в целевой таблице отсутствуют локальные триггеры
BEFORE/AFTER уровня строки и в родительских представлениях нет ограничения CHECK OPTION. Кро-
ме того, в запросах UPDATE выражения, присваиваемые целевым столбцам, должны задействовать
только встроенные типы данных и постоянные (IMMUTABLE) операторы и функции, чтобы уменьшить
риск неверного выполнения запроса.
Когда обёртка postgres_fdw обнаруживает соединение сторонних таблиц на одном стороннем сер-
вере, она передаёт всё соединение этому серверу, если только по какой-то причине не решит, что
будет эффективнее выбирать строки из каждой таблицы по отдельности, или сопоставляемые при
2591Дополнительно по-
ставляемые модули
обращении к таблицам пользователи оказываются разными. При передаче предложений JOIN при-
нимаются те же меры предосторожности, что были описаны выше для предложений WHERE.
Запрос, фактически отправляемый удалённому серверу для выполнения, можно изучить с помо-
щью команды EXPLAIN VERBOSE.
F.33.5. Окружение удалённого выполнения запросов
В удалённых сеансах, установленных обёрткой postgres_fdw, в параметре search_path задаётся
только pg_catalog, так что без указания схемы видны только встроенные объекты. Это не про-
блема для запросов, которые генерирует сама postgres_fdw, так как она всегда добавляет такие
указания. Однако это может быть опасно для функций, которые выполняются на удалённом сер-
вере при срабатывании триггеров или правил для удалённых таблиц. Например, если удалённая
таблица на самом деле представляет собой представление, любые функции, используемые в этом
представлении, будут выполняться с таким ограниченным путём поиска. Поэтому рекомендуется
в таких функциях дополнять схемой все имена либо добавлять параметры SET search_path (см.
CREATE FUNCTION) в определения таких функций, чтобы установить ожидаемый ими путь поиска
в окружении.
Обёртка postgres_fdw подобным образом устанавливает для удалённого сеанса различные пара-
метры:
•
•
•
•
TimeZone — UTC
DateStyle — ISO
IntervalStyle — postgres
extra_float_digits принимает значение 3 для удалённых серверов версии 9.0 и новее либо 2 для
более старых версий
С ними проблемы менее вероятны, чем с search_path, но если они возникнут, их можно урегули-
ровать, установив нужные значения с помощью SET.
Это поведение не рекомендуется переопределять, устанавливая значения этих параметров на
уровне сеанса; это скорее всего приведёт к поломке postgres_fdw.
F.33.6. Совместимость с разными версиями
Модуль postgres_fdw может применяться с удалёнными серверами версий, начиная с PostgreSQL
8.3. Способность только чтения данных доступна, начиная с 8.1. Однако, при этом есть ограниче-
ние, вызванное тем, что postgres_fdw полагает, что постоянные встроенные функции и операто-
ры могут безопасно передаваться на удалённый сервер для выполнения, если они фигурируют в
предложении WHERE для сторонней таблицы. Таким образом, встроенная функция, добавленная в
более новой версии, чем на удалённом сервере, может быть отправлена на выполнение, что в ре-
зультате приведёт к ошибке «функция не существует» или подобной. Отказы такого типа можно
предотвратить, переписав запрос, например, поместив ссылку на стороннюю таблицу во вложен-
ный SELECT с OFFSET 0 в качестве защиты от оптимизации, и применив проблематичную функцию
или оператор снаружи этого вложенного SELECT.
F.33.7. Примеры
Ниже приведёт пример создания сторонней таблицы с применением postgres_fdw. Сначала уста-
новите расширение:
CREATE EXTENSION postgres_fdw;
Затем создайте сторонний сервер с помощью команды CREATE SERVER. В данном примере мы
хотим подключиться к серверу PostgreSQL, работающему по адресу 192.83.123.89, порт 5432. База
данных, к которой устанавливается подключение, на удалённом сервере называется foreign_db:
CREATE SERVER foreign_server
FOREIGN DATA WRAPPER postgres_fdw
2592Дополнительно по-
ставляемые модули
OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
Для определения роли, которая будет задействована на удалённом сервере, с помощью CREATE
USER MAPPING задаётся сопоставление пользователей:
CREATE USER MAPPING FOR local_user
SERVER foreign_server
OPTIONS (user 'foreign_user', password 'password');
Теперь можно создать стороннюю таблицу, применив команду CREATE FOREIGN TABLE. В этом
примере мы хотим обратиться к таблице some_schema.some_table на удалённом сервере. Локаль-
ным именем этой таблицы будет foreign_table:
CREATE FOREIGN TABLE foreign_table (
id integer NOT NULL,
data text
)
SERVER foreign_server
OPTIONS (schema_name 'some_schema', table_name 'some_table');
Важно, чтобы типы данных и другие свойства столбцов, объявленных в CREATE FOREIGN TABLE, соот-
ветствовали фактической удалённой таблице. Также должны соответствовать имена столбцов, ес-
ли только вы не добавите параметры column_name для отдельных столбцов, задающие их реальные
имена в удалённой таблице. Во многих случаях использовать IMPORT FOREIGN SCHEMA предпо-
чтительнее, чем конструировать определения сторонних таблиц вручную.
F.33.8. Автор
Шигеру Ханада <shigeru.hanada@gmail.com>
F.34. seg
Этот модуль реализует тип данных seg для представления отрезков или интервалов чисел с пла-
вающей точкой. Тип seg может выражать отсутствие уверенности в границах интервала, что поз-
воляет применять его для представления лабораторных измерений.
F.34.1. Обоснование
Геометрия измерений обычно более сложна, чем точка в числовом континууме. Измерение обыч-
но представляет собой отрезок этого континуума с нечёткими границами. Измеряемые показате-
ли выражаются интервалами вследствие неопределённости и случайности, а также того, что из-
меряемое значение может отражать некоторое условие, например, диапазон температур стабиль-
ности протеина.
Руководствуясь только здравым смыслом, кажется более удобным хранить такие данные в виде
интервалов, а не в виде двух отдельных чисел. На практике это оказывается даже эффективнее в
большинстве приложений.
Более того, вследствие нечёткости границ использование традиционных числовых типов данных
приводит к определённой потере информации. Рассмотрим такой пример: ваш инструмент выдаёт
6.50 и вы вводите это значение в базу данных. Что вы получите, прочитав это значение из базы?
Смотрите:
test=> select 6.50 :: float8 as "pH";
pH
---
6.5
(1 row)
В мире измерений, 6.50 — не то же самое, что 6.5. И разница между этими измерениями иногда
бывает критической. Экспериментаторы обычно записывают (и публикуют) цифры, которые за-
2593Дополнительно по-
ставляемые модули
служивают доверия. Запись 6.50 на самом деле представляет неточный интервал, содержащийся
внутри большего и ещё более неточного интервала, 6.5, и единственное, что у них может быть об-
щего, это их центральные точки. Поэтому мы определённо не хотим, чтобы такие разные элементы
данных выглядели одинаково.
Вывод? Удобно иметь специальный тип данных, в котором можно сохранить границы интервала
с произвольной переменной точностью. В данном случае точность переменная в том смысле, что
для каждого элемента данных она может записываться индивидуально.
Проверьте это:
test=> select '6.25 .. 6.50'::seg as "pH";
pH
------------
6.25 .. 6.50
(1 row)
F.34.2. Синтаксис
Внешнее представление интервала образуется одним или двумя числами с плавающей точкой, со-
единёнными оператором диапазона (.. или ...). Кроме того, интервал можно задать центральной
точкой плюс/минус отклонение. Также этот тип позволяет сохранить дополнительные индикаторы
достоверности (<, > или ~). (Однако индикаторы достоверности игнорируются всеми встроенными
операторами.) Допустимые представления показаны в Таблице F.26; некоторые примеры приведе-
ны в Таблице F.27.
В Таблице F.26 символы x, y и delta обозначают числа с плавающей точкой. Перед значениями x
и y, но не delta, может быть добавлен индикатор достоверности.
Таблица F.26. Внешнее представление seg
x Одно значение (интервал нулевой длины)
x .. y Интервал от x до y
x (+-)
Интервал от x - delta до x + delta
delta
x .. Открытый интервал с нижней границей x
.. x Открытый интервал с верхней границей x
Таблица F.27. Примеры допустимых вводимых значений seg
5.0 Создаёт сегмент нулевой длины (или точку, если
хотите)
~5.0 Создаёт сегмент нулевой длины и записывает ~
в данные. Знак ~ игнорируется при операциях с
seg, но сохраняется как комментарий.
<5.0 Создаёт точку с координатой 5.0. Знак < игнори-
руется, но сохраняется как комментарий.
>5.0 Создаёт точку с координатой 5.0. Знак > игнори-
руется, но сохраняется как комментарий.
5(+-)0.3 Создаёт интервал 4.7 .. 5.3. Заметьте, что за-
пись (+-) не сохраняется.
50 .. Всё, что больше или равно 50
.. 0 Всё, что меньше или равно 0
1.5e-2 .. 2E-2 Создаёт интервал 0.015 .. 0.02
1 ... 2 То же, что и 1...2, либо 1 .. 2, либо 1..2 (пробе-
лы вокруг оператора диапазона игнорируются)
2594Дополнительно по-
ставляемые модули
Так как ... часто используется в источниках данных, он принимается в качестве альтернативного
написания ... К сожалению, это порождает неоднозначность при разборе: неясно, какая верхняя
граница имеется в виду в записи 0...23 — 23 или 0.23. Для разрешения этой неоднозначности во
входных числах seg перед десятичной точкой всегда должна быть минимум одна цифра.
В качестве меры предосторожности, seg не принимает интервалы с нижней границей, превыша-
ющей верхнюю, например: 5 .. 2.
F.34.3. Точность
Значения seg хранятся внутри как пары 32-битных чисел с плавающей точкой. Это значит, что
числа с более чем 7 значащими цифрами будут усекаться.
Числа, содержащие 7 и меньше значащих цифр, сохраняют изначальную точность. То есть, если
запрос возвращает 0.00, вы можете быть уверены, что конечные нули не являются артефактами
форматирования: они отражают точность исходных данных. Количество ведущих нулей не влияет
на точность: значение 0.0067 будет считаться имеющим только две значащих цифры.
F.34.4. Использование
Модуль seg включает класс операторов индекса GiST для значений seg. Операторы, поддержива-
емые этим классом операторов, перечислены в Таблице F.28.
Таблица F.28. Операторы seg для GiST
Оператор Описание
[a, b] << [c, d] [a, b] полностью находится левее [c, d]. То есть,
[a, b] << [c, d] — true, если b < c, и false в про-
тивном случае.
[a, b] >> [c, d] [a, b] полностью находится правее [c, d]. То есть,
[a, b] >> [c, d] — true, если a > d, и false в про-
тивном случае.
[a, b] &< [c, d] Пересекает или левее — Ещё лучше это читает-
ся как «не простирается правее». Результатом
будет true, когда b <= d.
[a, b] &> [c, d] Пересекает или правее — Ещё лучше это чита-
ется как «не простирается левее». Результатом
будет true, когда a >= c.
[a, b] = [c, d] Равенство — сегменты [a, b] и [c, d] равны, то
есть, a = c и b = d.
[a, b] && [c, d] Сегменты [a, b] и [c, d] пересекаются.
[a, b] @> [c, d] Сегмент [a, b] содержит сегмент [c, d], то есть,
a <= c и b >= d.
[a, b] <@ [c, d] Сегмент [a, b] содержится в [c, d], то есть, a >=
c и b <= d.
(До версии PostgreSQL 8.2 операторы включения @> и <@ обозначались соответственно как @ и ~.
Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упраздне-
ны. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые
геометрические типы данных!)
Также поддерживаются стандартные операторы для B-дерева, например:
Оператор Описание
[a, b] < [c, d] Меньше
2595Дополнительно по-
ставляемые модули
Оператор Описание
[a, b] > [c, d] Больше
Эти операторы не имеют большого смысла ни для какой практической цели, кроме сортировки.
Эти операторы сначала сравнивают (a) с (c), и если они равны, сравнивают (b) с (d). Результат
сравнения позволяет упорядочить значения образом, подходящим для большинства случаев, что
полезно, если вы хотите применять ORDER BY с этим типом.
F.34.5. Замечания
Примеры использования можно увидеть в регрессионном тесте sql/seg.sql.
Механизм, преобразующий (+-) в обычные диапазоны, не вполне точно определяет число знача-
щих цифр для границ. Например, он добавляет дополнительную цифру к нижней границе, если
результирующий интервал включает степень десяти:
postgres=> select '10(+-)1'::seg as seg;
seg
---------
9.0 .. 11
-- должно быть: 9 .. 11
Производительность индекса-R-дерева может значительно зависеть от начального порядка вводи-
мых значений. Может быть очень полезно отсортировать входную таблицу по столбцу seg; пример
можно найти в скрипте sort-segments.pl.
F.34.6. Благодарности
Первый автор: Джин Селков мл. <selkovjr@mcs.anl.gov>, Аргоннская национальная лаборатория,
Отдел математики и компьютерных наук
Я очень благодарен в первую очередь профессору Джо Геллерштейну (http://dbcsberkeleyedu/jmh/
) за пояснение сути GiST (http://gistcsberkeleyedu/). Я также признателен всем разработчикам
Postgres в настоящем и прошлом за возможность создать свой собственный мир и спокойно жить
в нём. Ещё я хотел бы выразить признательность Аргоннской лаборатории и Министерству энер-
гетики США за годы постоянной поддержки моих исследований в области баз данных.
F.35. sepgsql
Загружаемый модуль sepgsql поддерживает мандатное управление доступом (MAC, Mandatory
Access Control) с метками, построенное на базе политик безопасности SELinux.
Предупреждение
Текущая реализация имеет существенные ограничения и контролирует не все дей-
ствия. См. Подраздел F.35.7.
F.35.1. Обзор
Этот модуль интегрируется в SELinux и обеспечивает дополнительный уровень проверок безопас-
ности, расширяющий и дополняющий обычные средства PostgreSQL. С точки зрения SELinux, дан-
ный модуль позволяет PostgreSQL выполнять роль менеджера объектов в пространстве пользова-
теля. При выполнении запроса DML обращение к каждой таблице или функции в нём будет кон-
тролироваться согласно системной политике безопасности. Эта проверка дополняет штатную про-
верку разрешений SQL, которую производит PostgreSQL.
Механизм SELinux принимает решения о разрешении доступа на основе меток безопасности, пред-
ставляемых строками вида system_u:object_r:sepgsql_table_t:s0. В каждом решении учитыва-
ются две метки: метка субъекта, пытающегося выполнить действие, и метка объекта, над которым
2596Дополнительно по-
ставляемые модули
должно совершаться это действие. Так как эти метки могут применяться к объекту любого вида,
решения о разрешении доступа к объектам внутри базы данных могут подчиняться (и с этим моду-
лем фактически подчиняются) общим критериям, применяемым к объектам любого другого типа,
например, к файлам. Эта схема позволяет организовать централизованную политику безопасности
для защиты информационных активов, не зависящую от того, как именно хранятся эти активы.
Назначить метку безопасности объекту баз данных позволяет команда SECURITY LABEL.
F.35.2. Установка
Модуль sepgsql может работать только в Linux 2.6.28 и новее с включённым SELinux. На остальных
платформах он не поддерживается. Вам также понадобится libselinux 2.1.10 или новее и selinux-
policy 3.9.13 или новее (хотя в некоторых дистрибутивах необходимые правила могут быть адапти-
рованы к политике старой версии).
Команда sestatus позволяет проверить состояние SELinux. Типичный её вывод выглядит так:
$ sestatus
SELinux status:
SELinuxfs mount:
Current mode:
Mode from config file:
Policy version:
Policy from config file:
enabled
/selinux
enforcing
enforcing
24
targeted
Если SELinux отключён или не установлен, его необходимо привести в рабочее состояние, прежде
чем устанавливать этот модуль.
Чтобы собрать этот модуль, добавьте параметр --with-selinux в команду PostgreSQL configure.
Убедитесь в том, что в момент сборки установлен RPM-пакет libselinux-devel.
Чтобы использовать этот модуль, вы должны включить sepgsql в shared_preload_libraries в
postgresql.conf. Этот модуль не будет корректно работать, если загрузить его каким-либо другим
способом. Загрузив его, нужно выполнить sepgsql.sql в каждой базе данных. Этот скрипт устано-
вит функции, необходимые для управления метками безопасности, и назначит начальные метки
безопасности.
Следующий пример показывает, как инициализировать новый кластер баз данных и установить в
него функции и метки безопасности sepgsql. Измените пути в соответствии с размещением вашей
инсталляции:
$ export PGDATA=/path/to/data/directory
$ initdb
$ vi $PGDATA/postgresql.conf
изменить
#shared_preload_libraries = ''
# (после изменения требуется
перезапуск)
на
shared_preload_libraries = 'sepgsql'
# (после изменения требуется
перезапуск)
$ for DBNAME in template0 template1 postgres; do
postgres --single -F -c exit_on_error=true $DBNAME \
</usr/local/pgsql/share/contrib/sepgsql.sql >/dev/null
done
Заметьте, что вы можете увидеть следующие уведомления, в зависимости от конкретных установ-
ленных версий libselinux и selinux-policy:
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
2597
line 33 has invalid object type
line 36 has invalid object typeДополнительно по-
ставляемые модули
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:
db_language
line 37 has invalid object type
line 38 has invalid object type
line 39 has invalid object type
line 40 has invalid object type
Эти сообщения не критичны и их можно игнорировать.
Если процесс установки завершается без ошибок, вы можете запустить сервер обычным образом.
F.35.3. Регрессионные тесты
Природа SELinux такова, что для проведения регрессионных тестов sepgsql требуются дополни-
тельные действия по настройке и некоторые из них должен выполнять root. Регрессионные тесты
не будут запускаться обычной командой make check или make installcheck; вы должны настроить
конфигурацию и затем вызвать тестовый скрипт вручную. Тесты должны запускаться в каталоге
contrib/sepgsql настроенного дерева сборки PostgreSQL. Хотя им требуется дерево сборки, эти
тесты рассчитаны на использование установленного сервера, то есть они примерно соответствуют
make installcheck, но не make check.
Сначала установите sepgsql в рабочую базу данных по инструкциям, приведённым в Подразде-
ле F.35.2. Заметьте, что для этого текущий пользователь операционной системы должен подклю-
чаться к базе данных как суперпользователь без аутентификации по паролю.
На втором шаге соберите и установите пакет политики для регрессионного теста. Политика
sepgsql-regtest представляет собой политику особого назначения, предоставляющую набор пра-
вил, включаемых во время регрессионных тестов. Её следует скомпилировать из исходного фай-
ла sepgsql-regtest.te, что можно сделать командой make со скриптом Makefile, поставляемым с
SELinux. Вам нужно будет найти нужный Makefile в своей системе; путь, показанный ниже, при-
ведён только в качестве примера. Скомпилировав пакет политики, его нужно установить с помо-
щью команды semodule, которая загружает переданные ей пакеты в ядро. Если пакет установлен
корректно, команда semodule -l должна вывести sepgsql-regtest в списке доступных пакетов
политик:
$ cd .../contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.07
На третьем шаге включите параметр sepgsql_regression_test_mode. По соображени-
ям безопасности, правила в sepgsql-regtest по умолчанию неактивны; параметр
sepgsql_regression_test_mode активирует правила, необходимые для проведения регрессионных
тестов. Включить этот параметр можно командой setsebool:
$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode --> on
На четвёртом шаге убедитесь в том, что ваша оболочка работает в домене unconfined_t:
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
Если необходимо сменить рабочий домен, в подробностях это описывается в Подразделе F.35.8.
Наконец, запустите скрипт регрессионного теста:
$ ./test_sepgsql
2598Дополнительно по-
ставляемые модули
Этот скрипт попытается проверить, все ли шаги по настройке конфигурации выполнены коррект-
но, а затем запустит регрессионные тесты для модуля sepgsql.
Завершив тесты, рекомендуется отключить параметр sepgsql_regression_test_mode:
$ sudo setsebool sepgsql_regression_test_mode off
Другой, возможно, более предпочтительный вариант — удалить политику sepgsql-regtest полно-
стью:
$ sudo semodule -r sepgsql-regtest
F.35.4. Параметры GUC
sepgsql.permissive (boolean)
Этот параметр переводит sepgsql в разрешительный режим, вне зависимости от режима си-
стемы. По умолчанию он имеет значение off (отключён). Задать этот параметр можно только в
postgresql.conf или в командной строке при запуске сервера.
Когда этот параметр включён, sepgsql действует в разрешительном режиме, даже если
SELinux в целом находится в ограничительном режиме. Этот параметр полезен в первую оче-
редь для тестирования.
sepgsql.debug_audit (boolean)
Этот параметр включает вывод сообщений аудита вне зависимости от параметров системной
политики. По умолчанию он отключён (имеет значение off), что означает, что сообщения будут
выводиться согласно параметрам системы.
Политики безопасности SELinux также содержит правила, определяющие, будут ли фиксиро-
ваться в журнале определённые события. По умолчанию фиксируются нарушения доступа, а
успешный доступ — нет.
Этот параметр принудительно включает фиксирование в журнале всех возможных событий,
вне зависимости от системной политики.
F.35.5. Функциональные возможности
F.35.5.1. Управляемые классы объектов
Модель безопасности SELinux описывает все правила доступа в виде отношений между сущностью
субъекта (обычно, это клиент базы данных) и сущностью объекта (например, объектом базы дан-
ных), каждая из которых определяется меткой безопасности. Если осуществляется попытка досту-
па к непомеченному объекту, он обрабатывается как объект, имеющий метку unlabeled_t.
В настоящее время sepgsql позволяет назначать метки безопасности схемам, таблицам, столбцам,
последовательностям, представлениям и функциям. Когда sepgsql активен, метки безопасности
автоматически назначаются поддерживаемым объектам базы в момент создания. Такая метка на-
зывается меткой безопасности по умолчанию и устанавливается согласно политике безопасности
системы, которая учитывает метку создателя, метку, назначенную родительскому объекту созда-
ваемого объекта и, возможно, имя создаваемого объекта.
Новый объект базы, как правило, наследует метку безопасности, назначенную родительскому объ-
екту, если только в политике безопасности не заданы специальные правила, называемые правила-
ми перехода типов (в этом случае может быть назначена другая метка). Для схем родительским
объектом является текущая база данных; для таблиц, последовательностей, представлений и функ-
ций — схема, содержащая эти объекты; для столбцов — таблица.
F.35.5.2. Разрешения для DML
Для таблиц, задействованных в запросе в качестве целевых, проверяются разрешения
db_table:select, db_table:insert, db_table:update или db_table:delete в зависимости от ти-
2599Дополнительно по-
ставляемые модули
па оператора; кроме того, для всех таблиц, содержащих столбцы, фигурирующие в предложении
WHERE или RETURNING, или служащих источником данных для UPDATE и т. п., также проверяется
разрешение db_table:select.
Для всех задействованных столбцов также проверяются разрешения на уровне столбцов. Раз-
решение db_column:select проверяется не только для столбцов, которые считываются операто-
ром SELECT, но и для тех, к которым обращаются другие операторы DML; db_column:update или
db_column:insert также проверяется для столбцов, изменяемых операторами UPDATE или INSERT.
Например, рассмотрим запрос:
UPDATE t1 SET x = 2, y = func1(y) WHERE z = 100;
В данном случае db_column:update будет проверяться для столбца t1.x, так как он изменяется,
db_column:{select update} будет проверяться для t1.y, так как он и считывается, и изменяется,
а db_column:select — для столбца t1.z, так как он только считывается. На уровне таблицы также
будет проверяться разрешение db_table:{select update}.
Для последовательностей проверяется разрешение db_sequence:get_value, когда имеет место об-
ращение к объекту последовательности в SELECT; заметьте, однако, что в настоящее время разре-
шения на выполнение связанных функций, таких как, lastval(), не проверяются.
Для представлений проверяется db_view:expand, а затем все другие соответствующие разрешения
для объектов, развёрнутых из определения представления, в индивидуальном порядке.
Для функций проверяется db_procedure:{execute}, когда пользователь пытается выполнить функ-
цию в составе запроса, либо при вызове по быстрому пути. Если эта функция является доверенной
процедурой, также проверяется разрешение db_procedure:{entrypoint}, чтобы удостовериться,
что эта функция может быть точкой входа в доверенную процедуру.
При обращении к любому объекту схемы необходимо иметь разрешение db_schema:search для
содержащей его схемы. Когда имя целевого объекта не дополняется схемой, схемы, для которых
данное разрешение отсутствует, не будут просматриваться (то же происходит, если у пользователя
нет права USAGE для этой схемы). Когда схема указывается явно, пользователь получит ошибку,
если он не имеет требуемого разрешения для доступа к указанной схеме.
Клиенту должен быть разрешён доступ ко всем задействованным в запросе таблицам и столбцам,
даже если они проявились в нём в результате разворачивания представлений, так что правила
применяются согласованно вне зависимости от варианта обращения к содержимому таблиц.
Стандартная система привилегий позволяет суперпользователям баз данных изменять системные
каталоги с помощью команд DML и обращаться к таблицам TOAST или модифицировать их. Когда
модуль sepgsql активен, эти операции запрещаются.
F.35.5.3. Разрешения для DDL
SELinux определяет набор разрешений для управления стандартными операциями для каждого
типа объекта: создание, изменение определения, удаление и смена метки безопасности. В допол-
нение к ним для некоторых типов объектов предусмотрены специальные разрешения для управ-
ления их специфическими операциями, как например, добавление или удаление объектов в опре-
делённой схеме.
Для создания нового объекта базы данных требуется разрешение create. SELinux разрешает или
запрещает выполнение этой операции в зависимости от метки безопасности клиента и предпола-
гаемой метки безопасности нового объекта. В некоторых случаях требуются дополнительные раз-
решения:
• CREATE DATABASE дополнительно требует разрешения getattr в исходной или шаблонной
базе данных.
• Создание объекта схемы дополнительно требует разрешения add_name в родительской схеме.
2600Дополнительно по-
ставляемые модули
• Создание таблицы дополнительно требует разрешения на создание каждой отдельного столб-
ца таблицы, как если бы каждый столбец таблицы был отдельным объектом верхнего уровня.
• Создание функции с атрибутом LEAKPROOF дополнительно требует разрешения install. (Это
разрешение также проверяется, когда атрибут LEAKPROOF устанавливается для существующей
функции.)
Когда выполняется команда DROP, для удаляемого объекта будет проверяться разрешение drop.
Разрешения будут также проверяться и для объектов, удаляемых косвенно, вследствие указания
CASCADE. Для удаления объектов, содержащихся в определённой схеме, (таблиц, представления,
последовательностей и процедур) дополнительно нужно иметь разрешение remove_name в этой схе-
ме.
Когда выполняется команда ALTER, для каждого модифицируемого объекта проверяется разреше-
ние setattr, кроме подчинённых объектов, таких как индексы или триггеры таблиц (на них распро-
страняются разрешения родительского объекта). В некоторых случаях требуются дополнительные
разрешения:
• При перемещении объекта в новую схему дополнительно требуется разрешение remove_name в
старой схеме и add_name в новой.
• Для установки атрибута LEAKPROOF для функции требуется разрешение install.
• Для использования SECURITY LABEL дополнительно требуется разрешение relabelfrom для
объекта с его старой меткой безопасности и relabelto для этого объекта с новой меткой без-
опасности. (В случаях, когда установлено несколько поставщиков меток и пользователь пы-
тается задать метку, неподконтрольную SELinux, должно проверяться только разрешение
setattr. В настоящее время этого не происходит из-за ограничений реализации.)
F.35.5.4. Доверенные процедуры
Доверенные процедуры похожи на функции, определяющие контекст безопасности, или команды
setuid. В SELinux реализована возможность запускать доверенный код с меткой безопасности, от-
личной от метки клиента, как правило, для предоставления чётко контролируемого доступа к важ-
ным данным (при этом например, могут отсеиваться строки или хранимые значения могут выво-
диться с меньшей точностью). Будет ли функция вызываться как доверенная процедура, опреде-
ляется её меткой безопасности и политикой операционной системы. Например:
postgres=# CREATE TABLE customer (
cid
int primary key,
cname
text,
credit text
);
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
FROM customer WHERE cid = $1'
LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL
Показанные выше операции должен выполнять пользователь с правами администратора.
postgres=# SELECT * FROM customer;
ERROR: SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
cid | cname |
show_credit
2601Дополнительно по-
ставляемые модули
-----+--------+---------------------
1 | taro
| 1111-2222-3333-xxxx
2 | hanako | 5555-6666-7777-xxxx
(2 rows)
В данном случае обычный пользователь не может обращаться к customer.credit напрямую, но
доверенная процедура show_credit позволяет ему получить номера кредитных карт клиентов, в
которых будут скрыты некоторые цифры.
F.35.5.5. Динамические переключения домена
Возможность динамического перехода из домена в домен SELinux позволяет переводить метку
безопасности клиентского процесса, клиентский домен в новый контекст, если это допускается
политикой безопасности. Для этого клиент должен иметь разрешение setcurrent, а также разре-
шение dyntransition для перехода из старого в новый домен.
Динамические переключения домена следует тщательно продумывать, так как таким образом
пользователи могут менять свои метки, а значит и привилегии, по собственному желанию, а не
(как в случае с доверенными процедурами) по правилам, диктуемым системой. Таким образом,
разрешение dyntransition считается безопасным, только когда применяется для переключения
в домен с более ограниченным набором привилегий, чем текущий. Например:
regression=# select sepgsql_getcon();
sepgsql_getcon
-------------------------------------------------------
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)
regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-
s0:c1.c4');
sepgsql_setcon
----------------
t
(1 row)
regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-
s0:c1.c1023');
ERROR: SELinux: security policy violation
В показанном выше примере мы смогли переключиться из более широкого диапазона MCS
c1.c1023 в более узкий c1.c4, но переключение в обратную сторону было запрещено.
Сочетание динамического переключения домена с доверенными процедурами позволяет полу-
чить интересное решение, подходящее для реализации жизненного цикла процессов с пулом со-
единений. Даже если вашему менеджеру пула соединений не разрешается запускать многие ко-
манды SQL, вы можете разрешить ему сменить метку безопасности клиента, вызвав функцию
sepgsql_setcon() из доверенной процедуры; для этого может передаваться удостоверение для ав-
торизации запроса на смену метки клиента. После этого сеанс получит привилегии целевого поль-
зователя, а не пользователя пула соединений. Позднее менеджер пула может отменить смену кон-
текста безопасности, вызвав sepgsql_setcon() с аргументом NULL, так же из доверенной процеду-
ры с необходимыми проверками разрешений. Идея этого подхода в том, что только этой доверен-
ной процедуре будет разрешено менять действующую метку безопасности и только в том случае,
когда ей передаётся правильное удостоверение. Разумеется, чтобы это решение было безопасным,
хранилище удостоверений (таблица, определение процедуры или что-то другое) не должно быть
общедоступным.
F.35.5.6. Разное
Выполнение команды LOAD в активном режиме запрещается, так как любой загруженный модуль
может легко обойти ограничения политики безопасности.
2602Дополнительно по-
ставляемые модули
F.35.6. Функции sepgsql
В Таблице F.29 перечислены все доступные функции.
Таблица F.29. Функции sepgsql
sepgsql_getcon() returns text Возвращает клиентский домен, текущую метку
безопасности клиента.
sepgsql_setcon(text) returns bool Переключает домен клиента текущего сеанса в
новый домен, если это допускает политика без-
опасности. Эта функция также принимает в ар-
гументе NULL как запрос на переход в начальный
домен клиента.
sepgsql_mcstrans_in(text) returns text Переводит заданный диапазон MLS/MCS из пол-
ной записи в низкоуровневый формат, если ра-
ботает демон mcstrans.
sepgsql_mcstrans_out(text) returns text Переводит заданный диапазон MLS/MCS из низ-
коуровневого формата в полную запись, если ра-
ботает демон mcstrans.
sepgsql_restorecon(text) returns bool Устанавливает начальные метки безопасности
для всех объектов в текущей базе данных. В аргу-
менте может передаваться NULL или имя файла
со спецификациями контекстов, который будет
применяться вместо стандартного системного.
F.35.7. Ограничения
Разрешения для языка определения данных (DDL, Data Definition Language)
Вследствие ограничений реализации, для некоторых операций DDL разрешения не проверя-
ются.
Разрешения для языка управления данными (DCL, Data Control Language)
Вследствие ограничений реализации, для операций DCL разрешения не проверяются.
Управление доступом на уровне строк
PostgreSQL поддерживает ограничение доступа на уровне строк, а sepgsql — нет.
Скрытые каналы
Модуль sepgsql не пытается скрыть существование определённого объекта, даже если поль-
зователю не разрешено обращаться к нему. Например, возможно догадаться о существовании
невидимого объекта по конфликтам первичного ключа, нарушениям внешних ключей и т. д.,
даже когда нельзя получить содержимое этого объекта. Существование совершенно секретной
таблицы невозможно скрыть; надеяться можно только на то, что будет защищено её содержи-
мое.
F.35.8. Внешние ресурсы
SE-PostgreSQL Introduction, Введение в SE-PostgreSQL
На этой вики-странице даётся краткий обзор этого решения и рассказывается об архитектуре
и конструкции безопасности, администрировании и ожидаемых в будущем возможностях.
SELinux User's and Administrator's Guide, Руководство пользователя и администратора SELinux
В этом документе представлен широкий спектр знаний по администрированию SELinux в ОС.
В первую очередь он ориентирован на системы Red Hat, но его область применения не ограни-
чена ими.
2603Дополнительно по-
ставляемые модули
Fedora SELinux FAQ, Часто задаваемые вопросы по SELinux в ОС Fedora
В этом документе даются ответы на часто задаваемые вопросы по SELinux. В первую очередь
он ориентирован на ОС Fedora, но его область применения не ограничена ей.
F.35.9. Автор
КайГай Кохэй <kaigai@ak.jp.nec.com>
F.36. spi
Модуль spi предоставляет несколько рабочих примеров использования Интерфейса программиро-
вания сервера (Server Programming Interface, SPI) и триггеров. Хотя эти функции имеют некото-
рую ценность сами по себе, они ещё более полезны как заготовки, которые можно приспособить
под собственные нужды. Эти функции достаточно общие, чтобы работать с любой таблицей, но вы
должны явно указать имена таблицы и полей (как описано ниже) при создании триггера.
Каждая группа функций, описанная ниже, представлена в виде отдельно устанавливаемого рас-
ширения.
F.36.1. refint — функции для реализации ссылочной целостности
Функции check_primary_key() и check_foreign_key() применяются для проверки ограничений
внешних ключей. (Эта функциональность уже давно вытеснена встроенным механизмом внешних
ключей, но этот модуль всё ещё полезен в качестве примера.)
Функция check_primary_key() проверяет ссылающуюся таблицу. Чтобы воспользоваться ей, со-
здайте триггер BEFORE INSERT OR UPDATE с этой функцией для таблицы, ссылающейся на другую.
Укажите в аргументах триггера: имена столбцов ссылающейся таблицы, образующих внешний
ключ, имя целевой таблицы и имена столбцов в ней, образующих первичный/уникальный ключ.
Чтобы контролировать несколько внешних ключей, создайте триггер для каждой такой ссылки.
Функция check_foreign_key() проверяет целевую таблицу. Чтобы использовать её, создайте триг-
гер BEFORE DELETE OR UPDATE с этой функцией для таблицы, на которую ссылаются другие. Ука-
жите в аргументах триггера: число ссылающихся таблиц, для которых функция должна выполнить
проверки, действие в случае обнаружения ссылающегося ключа (cascade — удалить ссылающу-
юся строку, restrict — прервать транзакцию, setnull — установить в ссылающихся полях зна-
чения NULL), имена столбцов целевой таблицы, образующих первичный/уникальный ключ, а за-
тем имена таблиц и столбцов (в количестве, задаваемом первым аргументом). Заметьте, что поля
первичных/уникальных столбцов должны иметь пометку NOT NULL и по ним должен быть создан
уникальный индекс.
Примеры приведены в refint.example.
F.36.2. timetravel — функции для реализации перемещений во
времени
В далёком прошлом в PostgreSQL была встроенная возможность перемещений во времени, для ко-
торой фиксировалось время добавления и удаления каждого кортежа. Эти функции позволяют её
имитировать. Чтобы использовать их, вы должны добавить в таблицу два столбца типа abstime, в
которых будет храниться дата/время, когда кортеж был вставлен (start_date) и когда изменён/уда-
лён (stop_date):
CREATE TABLE mytab (
...
start_date
stop_date
...
);
...
abstime,
abstime
...
2604Дополнительно по-
ставляемые модули
Эти столбцы могут называться как угодно, но в данном описании они называются start_date и
stop_date.
Когда вставляется новая строка, в start_date обычно устанавливается текущее время, а в stop_date
— infinity (бесконечность). Триггер автоматически подставит эти значения, если добавляемая
строка содержит NULL в этих столбцах. Обычно не-NULL в этих столбцах может оказаться только
при загрузке в базу выгруженных данных.
Кортежи, в которых поле stop_date равно infinity, считаются «актуальными сейчас» и могут быть
изменены. Кортежи с определённой датой stop_date больше не могут быть изменены — триггер
будет препятствовать этому. (Если вам нужно сделать это, вы можете отключить машину времени
как показано ниже.)
Если кортеж является изменяемым, при модификации в нём меняется только stop_date (на те-
кущее время), но в таблицу вставляется новый кортеж с модифицированными данными. В поле
start_date в этом новом кортеже записывается текущее время, а в stop_date записывается infinity.
При удалении кортеж на самом деле не удаляется; в нём только записывается текущее время в
stop_date.
Чтобы запросить кортежи «актуальные сейчас», добавьте stop_date = 'infinity' в условие
WHERE вашего запроса. (Возможно, вы захотите завернуть это условие в представление.) Анало-
гичным образом вы можете запрашивать кортежи, которые были актуальны в любой момент в про-
шлом, задав подходящие условия для start_date и stop_date.
Функция timetravel() реализует код универсального триггера, поддерживающего это поведение.
Чтобы использовать её, создайте триггер BEFORE INSERT OR UPDATE OR DELETE с этой функцией для
каждой таблицы, перемещающейся во времени. Передайте триггеру два аргумента: фактические
имена столбцов start_date и stop_date. Вы также можете дополнительно передать от одного до
трёх аргументов, задающих имена столбцов типа text. Данный триггер сохранит имя текущего
пользователя в первый из этих столбцов при INSERT, во второй — при UPDATE, и в третий — при
DELETE.
Функция set_timetravel() позволяет включить или отключить машину времени для табли-
цы. Вызов set_timetravel('mytab', 1) включает машину времени для таблицы mytab, а
set_timetravel('mytab', 0) — отключает её для таблицы mytab. В обоих случаях возвращает-
ся прежнее состояние. Когда машина времени выключена, вы можете свободно модифицировать
столбцы start_date и stop_date. Заметьте, что состояние активности машины является локальным
для текущего сеанса базы данных — в новых сеансах машина времени всегда включена для всех
таблиц.
Функция get_timetravel() возвращает состояние перемещения во времени для таблицы, не меняя
его.
Пример приведён в timetravel.example.
F.36.3. autoinc — функции для автоувеличения полей
Функция autoinc() реализует код триггера, сохраняющего следующее значение последовательно-
сти в целочисленном поле. Это в некоторой степени пересекается со встроенной функционально-
стью столбца «serial», но есть и отличия: autoinc() препятствует попыткам вставить другое зна-
чение поля при добавлении строк и может увеличивать значение поля при изменениях.
Чтобы использовать её, создайте триггер BEFORE INSERT (или BEFORE INSERT OR UPDATE) с этой
функцией. Передайте триггеру два аргумента: имя целочисленного столбца, который будет ме-
няться, и имя объекта последовательности, который будет поставлять значения. (Вообще вы мо-
жете задать любое число пар таких имён, если хотите поддерживать несколько автоувеличиваю-
щихся столбцов.)
Пример приведён в autoinc.example.
2605Дополнительно по-
ставляемые модули
F.36.4. insert_username — функции для отслеживания пользовате-
ля, вносящего изменения
Функция insert_username() реализует код триггера, сохраняющего имя текущего пользователя в
текстовом поле. Это может быть полезно для отслеживания пользователя, изменившего конкрет-
ную строку таблицы последним.
Чтобы использовать её, создайте триггер BEFORE INSERT и/или UPDATE с этой функцией. Передайте
триггеру один аргумент: имя целевого текстового столбца.
Пример приведён в insert_username.example.
F.36.5. moddatetime — функции для отслеживания времени по-
следнего изменения
Функция moddatetime() реализует код триггера, сохраняющего текущее время в поле типа
timestamp. Это может быть полезно для отслеживания времени последней модификации конкрет-
ной строки таблицы.
Чтобы использовать её, создайте триггер BEFORE UPDATE с этой функцией. Передайте триггеру один
аргумент: имя целевого столбца. Столбец должен иметь тип timestamp или timestamp with time
zone.
Пример приведён в moddatetime.example.
F.37. sslinfo
Модуль sslinfo выдаёт информацию о SSL-сертификате, который был представлен текущим кли-
ентом при подключении к PostgreSQL. Этот модуль бесполезен (большинство функций возвратят
NULL), если для текущего подключения не задействуется SSL.
Это расширение не будет собираться, если конфигурация была произведена без ключа --with-
openssl.
F.37.1. Предоставляемые функции
ssl_is_used() returns boolean
Возвращает true, если текущее подключение использует SSL, и false в противном случае.
ssl_version() returns text
Возвращает имя протокола, по которому организовано SSL-подключение (например TLSv1.0,
TLSv1.1 или TLSv1.2).
ssl_cipher() returns text
Возвращает имя шифра, используемого для SSL-подключения (например, DHE-RSA-AES256-
SHA).
ssl_client_cert_present() returns boolean
Возвращает true, если текущий клиент предоставил серверу действительный клиентский SSL-
сертификат, и false в противном случае. (Сервер может требовать, а может и не требовать
предоставления клиентского сертификата.)
ssl_client_serial() returns numeric
Возвращает серийный номер текущего клиентского сертификата. Сочетание серийного номе-
ра сертификата с выдавшим его центром сертификации гарантирует однозначную идентифи-
2606Дополнительно по-
ставляемые модули
кацию сертификата (но не его владелец — владелец должен регулярно менять свои ключи и
получать сертификаты в центре сертификации).
Поэтому, если вы используете собственный ЦС и настроили сервер, чтобы он принимал серти-
фикаты только от этого ЦС, серийный номер будет наиболее надёжным (хотя не очень запоми-
нающимся) ключом идентификации пользователя.
ssl_client_dn() returns text
Возвращает полное имя субъекта из текущего клиентского сертификата, преобразуя символь-
ные данные в кодировку текущей базы данных. Предполагается, что если в именах в сертифи-
катах используются символы вне таблицы ASCII, то ваша база данных может представить эти
символы. Если в вашей базе используется кодировка SQL_ASCII, символы вне ASCII в имени
будут представлены последовательностями UTF-8.
Результат выглядит примерно так: /CN=Somebody /C=Some country/O=Some organization.
ssl_issuer_dn() returns text
Возвращает полное имя издателя текущего клиентского сертификата, преобразуя символьные
данные в кодировку текущей базы данных. Преобразования кодировки осуществляются так же,
как и в ssl_client_dn.
Сочетание возвращаемого значения этой функции с серийным номером сертификата однознач-
но идентифицирует сертификат.
Эта функция полезна, только если в установленном на сервере файле с сертификатами ЦС со-
держатся сертификаты нескольких ЦС или если один ЦС выдаёт сертификаты для промежу-
точных центров сертификации.
ssl_client_dn_field(fieldname text) returns text
Эта функция возвращает значение указанного поля данных субъекта сертификата, либо NULL,
если это поле отсутствует. Имена полей задаются строковыми константами, которые затем
преобразуются в идентификаторы объектов ASN1, используя базу данных объектов OpenSSL.
Принимаются следующие значения:
commonName (или CN)
surname (или SN)
name
givenName (или GN)
countryName (или C)
localityName (или L)
stateOrProvinceName (или ST)
organizationName (или O)
organizationUnitName (или OU)
title
description
initials
postalCode
streetAddress
generationQualifier
description
dnQualifier
x500UniqueIdentifier
pseudonym
role
emailAddress
Все эти поля являются необязательными, за исключением commonName. Какие из них будут
включены в сертификат, а какие нет, зависит полностью от политики вашего ЦС. Значение
2607Дополнительно по-
ставляемые модули
этих полей, однако, строго определено стандартами X.500 и X.509, так что их нельзя интерпре-
тировать произвольным образом.
ssl_issuer_field(fieldname text) returns text
То же, что ssl_client_dn_field, но для издателя, а не для субъекта сертификата.
ssl_extension_info() returns setof record
Предоставляет информацию о расширениях клиентского сертификата: имя расширения, зна-
чение расширения и является ли это расширение критическим.
F.37.2. Автор
Виктор Вагнер <vitus@cryptocom.ru>, ООО «Криптоком»
Дмитрий Воронин <carriingfate92@yandex.ru>
Электронный адрес группы разработчиков OpenSSL в Криптокоме: <openssl@cryptocom.ru>
F.38. tablefunc
Модуль tablefunc содержит ряд функций, возвращающих таблицы (то есть, множества строк). Эти
функции полезны и сами по себе, и как примеры написания на C функций, возвращающих наборы
строк.
F.38.1. Предоставляемые функции
Функции, предоставляемые модулем tablefunc, перечислены в Таблице F.30.
Таблица F.30. Функции tablefunc
Функция Возвращает Описание
normal_rand(int
numvals,
float8
mean,
float8
stddev) setof float8 Выдаёт набор случайных значе-
ний, имеющих нормальное рас-
пределение
crosstab(text sql) setof record Выдаёт «повёрнутую таблицу»,
содержащую имена строк плюс
N столбцов значений, где N опре-
деляется видом строк, задан-
ным в вызывающем запросе
crosstabN(text sql) setof table_crosstab_ crosstab(text source_sql,
text category_sql) setof record Выдаёт «повёрнутую таблицу»
со столбцами значений, задан-
ными вторым запросом
crosstab(text sql, int N) setof record Устаревшая версия crosstab(
text) . Параметр N теперь игно-
рируется, так как число столб-
цов значений всегда определя-
ется вызывающим запросом
connectby(text
relname,
text keyid_fld, text setof record Выдаёт представление иерархи-
ческой древовидной структуры
2608
N
Выдаёт «повёрнутую таблицу»,
содержащую имена строк плюс
N столбцов значений. Функ-
ции crosstab2, crosstab3 и
crosstab4 предопределены, но
вы можете создать дополни-
тельные функции crosstabN,
как описано нижеДополнительно по-
ставляемые модули
Функция
parent_keyid_fld [, text
orderby_fld ], text start_
with, int max_depth [,
text branch_delim ])
Возвращает
Описание
F.38.1.1. normal_rand
normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8
Функция normal_rand выдаёт набор случайных значений, имеющих нормальное распределение
(распределение Гаусса).
Параметр numvals задаёт количество значений, которое выдаст эта функция. Параметр mean зада-
ёт медиану нормального распределения, а stddev — стандартное отклонение.
Например, этот вызов запрашивает 1000 значений с медианой 5 и стандартным отклонением 3:
test=# SELECT * FROM normal_rand(1000, 5, 3);
normal_rand
----------------------
1.56556322244898
9.10040991424657
5.36957140345079
-0.369151492880995
0.283600703686639
.
.
.
4.82992125404908
9.71308014517282
2.49639286969028
(1000 rows)
F.38.1.2. crosstab(text)
crosstab(text sql)
crosstab(text sql, int N)
Функция crosstab применяется для формирования «повёрнутых» отображений, в которых данные
идут вдоль строк, а не сверху вниз. Например, мы можем иметь такие данные:
row1
row1
row1
...
row2
row2
row2
...
val11
val12
val13
val21
val22
val23
и хотим видеть их так:
row1
row2
...
val11
val21
val12
val22
val13
val23
...
...
Функция crosstab принимает в текстовом параметре SQL-запрос, выдающий исходные данные пер-
вым способом, и выдаёт таблицу, отформатированную вторым способом.
В параметре sql передаётся SQL-запрос, выдающий исходный набор данных. Этот запрос должен
возвращать один столбец row_name, один столбец category и один столбец value. Параметр N яв-
ляется устаревшим и игнорируется, если передаётся при вызове (раньше он должен был соответ-
2609Дополнительно по-
ставляемые модули
ствовать количеству выходных столбцов значений, но теперь это количество определяется вызы-
вающим запросом).
Например, заданный запрос может выдавать такой результат:
row_name
cat
value
----------+-------+-------
row1
cat1
val1
row1
cat2
val2
row1
cat3
val3
row1
cat4
val4
row2
cat1
val5
row2
cat2
val6
row2
cat3
val7
row2
cat4
val8
Функция crosstab объявлена как возвращающая setof record, так что фактические имена и типы
столбцов должны определяться в предложении FROM вызывающего оператора SELECT, например
так:
SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);
Этот запрос выдаст примерно такой результат:
<== столбцы значений ==>
row_name
category_1
category_2
----------+------------+------------
row1
val1
val2
row2
val5
val6
Предложение FROM должно определять результат со столбцом row_name (того же типа данных, что
у первого результирующего столбца SQL-запроса), за которым следуют N столбцов значений (все
того же типа данных, что и третий результирующий столбец SQL-запроса). Количество выходных
столбцов значений может быть произвольным и имена выходных столбцов определяете вы сами.
Функция crosstab выдаёт одну выходную строку для каждой последовательной группы с одним
значением row_name. Она заполняет столбцы значений слева направо полями value из этих строк.
Если в группе оказывается меньше строк, чем выходных столбцов значений, дополнительные
столбцы принимают значения NULL; если же строк оказывается больше, лишние строки игнори-
руются.
На практике в SQL-запросе всегда должно указываться ORDER BY 1,2, чтобы входные строки были
отсортированы должным образом, то есть, чтобы данные с одинаковым значением row_name соби-
рались вместе и корректно упорядочивались в строке. Заметьте, что сама crosstab не учитывает
второй столбец результата запроса; он присутствует только для того, чтобы определять порядок,
в котором значения третьего столбца будут следовать в строке.
Полный пример:
CREATE
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
TABLE ct(id SERIAL, rowid
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
INTO ct(rowid, attribute,
TEXT, attribute TEXT, value TEXT);
value) VALUES('test1','att1','val1');
value) VALUES('test1','att2','val2');
value) VALUES('test1','att3','val3');
value) VALUES('test1','att4','val4');
value) VALUES('test2','att1','val5');
value) VALUES('test2','att2','val6');
value) VALUES('test2','att3','val7');
value) VALUES('test2','att4','val8');
SELECT *
FROM crosstab(
'select rowid, attribute, value
2610Дополнительно по-
ставляемые модули
from ct
where attribute = ''att2'' or attribute = ''att3''
order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);
row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
test1
| val2
| val3
|
test2
| val6
| val7
|
(2 rows)
Вы можете в любом случае обойтись без написания предложения FROM, определяющего выходные
столбцы, создав собственную функцию crosstab, в определении которой будет зашит желательный
тип выходной строки. Это описывается в следующем разделе. Также имеется возможность вклю-
чить требуемое предложение FROM в определение представления.
Примечание
Также изучите команду \crosstabview в psql, реализующую функциональность, подоб-
ную crosstab().
F.38.1.3. crosstabN(text)
crosstabN(text sql)
Функции crosstabN являются примерами того, как можно создать собственные обёртки универ-
сальной функции crosstab, чтобы не приходилось выписывать имена и типы столбцов в вызыва-
ющем запросе SELECT. Модуль tablefunc включает функции crosstab2, crosstab3 и crosstab4,
определяющие типы выходных строк так:
CREATE TYPE tablefunc_crosstab_N AS (
row_name TEXT,
category_1 TEXT,
category_2 TEXT,
.
.
.
category_N TEXT
);
Таким образом, эти функции могут применяться непосредственно, когда входной запрос выдаёт
столбцы row_name и value типа text и вы хотите получить на выходе 2, 3 или 4 столбца значений.
В остальном эти функции ведут себя в точности так же, как и универсальная функция crosstab.
Так, пример, приведённый в предыдущем разделе, можно переписать и в таком виде:
SELECT *
FROM crosstab3(
'select rowid, attribute, value
from ct
where attribute = ''att2'' or attribute = ''att3''
order by 1,2');
Эти функции представлены в основном в демонстрационных целях. Вы можете создать соб-
ственные типы возвращаемых данных и реализовать функции на базе нижележащей функции
crosstab(). Это можно сделать двумя способами:
• Создать составной тип, описывающий желаемые выходные столбцы, примерно как это дела-
ется в примерах в contrib/tablefunc/tablefunc--1.0.sql. Затем нужно выбрать уникальное
имя для функции, принимающей один параметр text и возвращающей setof имя_вашего_ти-
2611Дополнительно по-
ставляемые модули
па, и связать его с той же нижележащей функцией crosstab на C. Например, если ваш источ-
ник данных выдаёт имена строк типа text и значения типа float8, и вы хотите получить 5
столбцов значений:
CREATE TYPE my_crosstab_float8_5_cols AS (
my_row_name text,
my_category_1 float8,
my_category_2 float8,
my_category_3 float8,
my_category_4 float8,
my_category_5 float8
);
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
RETURNS setof my_crosstab_float8_5_cols
AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
• Использовать выходные параметры (OUT), чтобы явно определить возвращаемый тип. Тот же
пример можно реализовать и таким способом:
CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
IN text,
OUT my_row_name text,
OUT my_category_1 float8,
OUT my_category_2 float8,
OUT my_category_3 float8,
OUT my_category_4 float8,
OUT my_category_5 float8)
RETURNS setof record
AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;
F.38.1.4. crosstab(text, text)
crosstab(text source_sql, text category_sql)
Основное ограничение формы crosstab с одним параметром состоит в том, что она воспринимает
все значения в группе одинаково и вставляет очередное значение в первый свободный столбец.
Если вы хотите, чтобы столбцы значений соответствовали определённым категориям данных и
некоторые группы могли содержать данные не для всех категорий, этот подход не будет работать.
Форма crosstab с двумя параметрами решает эту задачу, принимая явный список категорий, со-
ответствующих выходным столбцам.
В параметре source_sql передаётся SQL-оператор, выдающий исходный набор данных. Этот опе-
ратор должен выдавать строки со столбцом row_name, столбцом category и столбцом value. Также
он может выдать один или несколько «дополнительных» столбцов. Столбец row_name должен быть
первым, а столбцы category и value — последними двумя, именно в этом порядке. Все столб-
цы между row_name и category воспринимаются как «дополнительные». Ожидается, что «допол-
нительные» столбцы будут содержать одинаковые значения для всех строк с одним значением
row_name.
Например, source_sql может выдать такой набор данных:
SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;
row_name
extra_col
cat
value
----------+------------+-----+---------
row1
extra1
cat1
val1
row1
extra1
cat2
val2
row1
extra1
cat4
val4
row2
extra2
cat1
val5
row2
extra2
cat2
val6
2612Дополнительно по-
ставляемые модули
row2
row2
extra2
extra2
cat3
cat4
val7
val8
В параметре category_sql передаётся оператор SQL, выдающий набор категорий. Этот оператор
должен возвращать всего один столбец. Он должен выдать минимум одну строку; в противном
случае произойдёт ошибка. Кроме того, выдаваемые им значения не должны повторяться, иначе
так же произойдёт ошибка. В качестве category_sql можно передать, например, такой запрос:
SELECT DISTINCT cat FROM foo ORDER BY 1;
cat
-------
cat1
cat2
cat3
cat4
Функция crosstab объявлена как возвращающая тип setof record, так что фактические имена
и типы выходных столбцов должны определяться в предложении FROM вызывающего оператора
SELECT, например так:
SELECT * FROM crosstab('...', '...')
AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);
При этом будет получен примерно такой результат:
<== столбцы значений
==>
row_name
extra
cat1
cat2
cat3
cat4
---------+-------+------+------+------+------
row1
extra1 val1
val2
val4
row2
extra2 val5
val6
val7
val8
В предложении FROM должно определяться нужное количество выходных столбцов соответствую-
щих типов данных. Если запрос source_sql выдаёт N столбцов, первые N-2 из них должны соот-
ветствовать первым N-2 выходным столбцам. Оставшиеся выходные столбцы должны иметь тип
последнего столбца результата source_sql и их должно быть столько, сколько строк оказалось в
результате запроса category_sql.
Функция crosstab выдаёт одну выходную строку для каждой последовательной группы входных
строк с одним значением row_name. Выходной столбец row_name плюс все «дополнительные» столб-
цы копируются из первой строки группы. Выходные столбцы значений заполняются содержимым
полей value из строк с соответствующими значениями category. Если в поле category оказыва-
ется значение, отсутствующее в результате запроса category_sql, содержимое поля value в этой
строке игнорируется. Выходные столбцы, для которых соответствующая категория не представле-
на ни в одной из входных строк группы, принимают значения NULL.
На практике в запросе source_sql всегда нужно указывать ORDER BY 1, чтобы все значения с од-
ним row_name гарантированно выводились вместе. Порядок же категорий внутри группы не важен.
Кроме того, важно, чтобы порядок значений, выдаваемых запросом category_sql, соответствовал
заданному порядку выходных столбцов.
Два законченных примера:
create
insert
insert
insert
insert
insert
insert
table sales(year int, month int, qty int);
into sales values(2007, 1, 1000);
into sales values(2007, 2, 1500);
into sales values(2007, 7, 500);
into sales values(2007, 11, 1500);
into sales values(2007, 12, 2000);
into sales values(2008, 1, 1000);
select * from crosstab(
2613Дополнительно по-
ставляемые модули
'select year, month, qty from sales order by 1',
'select m from generate_series(1,12) m'
) as (
year int,
"Jan" int,
"Feb" int,
"Mar" int,
"Apr" int,
"May" int,
"Jun" int,
"Jul" int,
"Aug" int,
"Sep" int,
"Oct" int,
"Nov" int,
"Dec" int
);
year | Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
2007 | 1000 | 1500 |
|
|
|
| 500 |
|
|
| 1500 | 2000
2008 | 1000 |
|
|
|
|
|
|
|
|
|
|
(2 rows)
CREATE
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
TABLE cth(rowid text, rowdt
INTO cth VALUES('test1','01
INTO cth VALUES('test1','01
INTO cth VALUES('test1','01
INTO cth VALUES('test2','02
INTO cth VALUES('test2','02
INTO cth VALUES('test2','02
INTO cth VALUES('test2','02
timestamp, attribute text, val text);
March 2003','temperature','42');
March 2003','test_result','PASS');
March 2003','volts','2.6987');
March 2003','temperature','53');
March 2003','test_result','FAIL');
March 2003','test_startdate','01 March 2003');
March 2003','volts','3.1234');
SELECT * FROM crosstab
(
'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
rowid text,
rowdt timestamp,
temperature int4,
test_result text,
test_startdate timestamp,
volts float8
);
rowid |
rowdt
| temperature | test_result |
test_startdate
| volts
-------+--------------------------+-------------+-------------
+--------------------------+--------
test1 | Sat Mar 01 00:00:00 2003 |
42 | PASS
|
| 2.6987
test2 | Sun Mar 02 00:00:00 2003 |
53 | FAIL
| Sat Mar 01 00:00:00
2003 | 3.1234
(2 rows)
Вы можете создать предопределённые функции, чтобы не выписывать имена и типы результирую-
щих столбцов в каждом запросе. Примеры приведены в предыдущем разделе. Нижележащая функ-
ция C для этой формы crosstab называется crosstab_hash.
2614Дополнительно по-
ставляемые модули
F.38.1.5. connectby
connectby(text relname, text keyid_fld, text parent_keyid_fld
[, text orderby_fld ], text start_with, int max_depth
[, text branch_delim ])
Функция connectby выдаёт отображение данных, содержащихся в таблице, в иерархическом виде.
Таблица должна содержать поле ключа, однозначно идентифицирующее строки, и поле ключа
родителя, ссылающееся на родителя строки (если он есть). Функция connectby может вывести
вложенное дерево, начиная с любой строки.
Параметры описаны в Таблице F.31.
Таблица F.31. Параметры connectby
Параметр Описание
relname Имя исходного отношения
keyid_fld Имя поля ключа
parent_keyid_fld Имя поля, содержащего ключ родителя
orderby_fld Имя поля, по которому сортируются потомки (
необязательно)
start_with Значение ключа отправной строки
max_depth Максимальная глубина, на которую можно по-
грузиться, либо ноль для неограниченного по-
гружения
branch_delim Строка, разделяющая ключи в выводе ветви (
необязательно)
Поля ключа и ключа родителя могут быть любого типа, но должны иметь общий тип. Заметьте, что
значение start_with должно задаваться текстовой строкой, вне зависимости от типа поля ключа.
Функция connectby объявлена как возвращающая setof record, так что фактические имена и типы
выходных столбцов должны определяться в предложении FROM вызывающего оператора SELECT,
например так:
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0,
'~')
AS t(keyid text, parent_keyid text, level int, branch text, pos int);
Первые два выходных столбца используются для вывода ключа текущей строки и ключа её ро-
дителя; их тип должен соответствовать типу поля ключа. Третий выходной столбец задаёт глуби-
ну в дереве и должен иметь тип integer. Если передаётся параметр branch_delim, в следующем
столбце выводятся ветви, и этот столбец должен иметь тип text. Наконец, если передаётся пара-
метр orderby_fld, в последнем столбце выводятся последовательные числа, и он должен иметь
тип integer.
В столбце «branch» показывается путь по ключам, приведший к текущей строке. Ключи разде-
ляются заданной строкой branch_delim. Если выводить ветви не требуется, опустите параметр
branch_delim и столбец branch в списке выходных столбцов.
Если порядок потомков одного родителя имеет значение, добавьте параметр orderby_fld, указы-
вающий поле для упорядочивания потомков. Это поле может иметь любой тип, допускающий сор-
тировку. Список выходных столбцов должен включать последним столбцом целочисленный стол-
бец с последовательными значениями, если и только если передаётся параметр orderby_fld.
Параметры, представляющие имена таблицы и полей, копируются как есть в SQL-запросы, кото-
рые connectby генерирует внутри. Таким образом, их нужно заключить в двойные кавычки, если
они содержат буквы в разном регистре или специальные символы. Также может понадобиться до-
полнить имя таблицы схемой.
2615Дополнительно по-
ставляемые модули
С большими таблицами производительность будет неудовлетворительной, если не создать индекс
по полю с ключом родителя.
Важно, чтобы строка branch_delim не фигурировала в значениях ключа, иначе connectby мо-
жет некорректно сообщить об ошибке бесконечной вложенности. Заметьте, что если параметр
branch_delim не задаётся, для выявления зацикленности применяется символ ~.
Пример:
CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INSERT
INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO
INTO
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
connectby_tree
VALUES('row1',NULL, 0);
VALUES('row2','row1', 0);
VALUES('row3','row1', 0);
VALUES('row4','row2', 1);
VALUES('row5','row2', 0);
VALUES('row6','row4', 0);
VALUES('row7','row3', 0);
VALUES('row8','row6', 0);
VALUES('row9','row5', 0);
-- с ветвями без orderby_fld (порядок результатов не гарантируется)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
AS t(keyid text, parent_keyid text, level int, branch text);
keyid | parent_keyid | level |
branch
-------+--------------+-------+---------------------
row2 |
|
0 | row2
row4 | row2
|
1 | row2~row4
row6 | row4
|
2 | row2~row4~row6
row8 | row6
|
3 | row2~row4~row6~row8
row5 | row2
|
1 | row2~row5
row9 | row5
|
2 | row2~row5~row9
(6 rows)
-- без ветвей и без orderby_fld (порядок результатов не гарантируется)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
AS t(keyid text, parent_keyid text, level int);
keyid | parent_keyid | level
-------+--------------+-------
row2 |
|
0
row4 | row2
|
1
row6 | row4
|
2
row8 | row6
|
3
row5 | row2
|
1
row9 | row5
|
2
(6 rows)
-- с ветвями и с orderby_fld (заметьте, что row5 идёт перед row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0,
'~')
AS t(keyid text, parent_keyid text, level int, branch text, pos int);
keyid | parent_keyid | level |
branch
| pos
-------+--------------+-------+---------------------+-----
row2 |
|
0 | row2
|
1
row5 | row2
|
1 | row2~row5
|
2
row9 | row5
|
2 | row2~row5~row9
|
3
row4 | row2
|
1 | row2~row4
|
4
row6 | row4
|
2 | row2~row4~row6
|
5
row8 | row6
|
3 | row2~row4~row6~row8 |
6
2616Дополнительно по-
ставляемые модули
(6 rows)
-- без ветвей, с orderby_fld (заметьте, что row5 идёт перед row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
AS t(keyid text, parent_keyid text, level int, pos int);
keyid | parent_keyid | level | pos
-------+--------------+-------+-----
row2 |
|
0 |
1
row5 | row2
|
1 |
2
row9 | row5
|
2 |
3
row4 | row2
|
1 |
4
row6 | row4
|
2 |
5
row8 | row6
|
3 |
6
(6 rows)
F.38.2. Автор
Джо Конвей
F.39. tcn
Модуль tcn предлагает триггерную функцию, уведомляющую приёмники уведомлений об измене-
ниях в любой таблице, к которой привязан триггер. Она должна использоваться в качестве триг-
гера AFTER вида FOR EACH ROW.
Этой функции в операторе CREATE TRIGGER передаётся только один параметр, и он не является
обязательным. Если этот параметр присутствует, он задаёт имя канала для уведомлений. В случае
его отсутствия именем канала будет tcn.
Сообщение уведомления включает имя таблицы, букву, обозначающую тип выполняемой операции
и пары имя столбца/значение для столбца первичного ключа. Каждая часть сообщения отделяет-
ся от следующей запятой. Для упрощения разбора сообщения регулярными выражениями имена
таблицы и столбцов всегда заключаются в двойные кавычки, а значения данных — в апострофы.
Внутренние кавычки и апострофы дублируются.
Далее приведена краткая демонстрация использования расширения.
test=# create table tcndata
test-#
(
test(#
a int not null,
test(#
b date not null,
test(#
c text,
test(#
primary key (a, b)
test(#
);
CREATE TABLE
test=# create trigger tcndata_tcn_trigger
test-#
after insert or update or delete on tcndata
test-#
for each row execute function triggered_change_notification();
CREATE TRIGGER
test=# listen tcn;
LISTEN
test=# insert into tcndata values (1, date '2012-12-22', 'one'),
test-#
(1, date '2012-12-23', 'another'),
test-#
(2, date '2012-12-23', 'two');
INSERT 0 3
Asynchronous notification "tcn" with payload ""tcndata",I,"a"='1',"b"='2012-12-22'"
received from server process with PID 22770.
Asynchronous notification "tcn" with payload ""tcndata",I,"a"='1',"b"='2012-12-23'"
received from server process with PID 22770.
2617Дополнительно по-
ставляемые модули
Asynchronous notification "tcn" with payload ""tcndata",I,"a"='2',"b"='2012-12-23'"
received from server process with PID 22770.
test=# update tcndata set c = 'uno' where a = 1;
UPDATE 2
Asynchronous notification "tcn" with payload ""tcndata",U,"a"='1',"b"='2012-12-22'"
received from server process with PID 22770.
Asynchronous notification "tcn" with payload ""tcndata",U,"a"='1',"b"='2012-12-23'"
received from server process with PID 22770.
test=# delete from tcndata where a = 1 and b = date '2012-12-22';
DELETE 1
Asynchronous notification "tcn" with payload ""tcndata",D,"a"='1',"b"='2012-12-22'"
received from server process with PID 22770.
F.40. test_decoding
Модуль test_decoding представляет пример модуля вывода логического декодирования. Он не де-
лает ничего особенно полезного, но может послужить отправной точкой для разработки собствен-
ного модуля вывода.
Модуль test_decoding получает WAL через механизм логического декодирования и переводит его
в текстовое представление выполняемых операций.
Типичный вывод этого модуля, работающего через интерфейс логического декодирования SQL,
может выглядеть так:
postgres=# SELECT * FROM pg_logical_slot_get_changes('test_slot', NULL, NULL, 'include-
xids', '0');
lsn
| xid |
data
-----------+-----+--------------------------------------------------
0/16D30F8 | 691 | BEGIN
0/16D32A0 | 691 | table public.data: INSERT: id[int4]:2 data[text]:'arg'
0/16D32A0 | 691 | table public.data: INSERT: id[int4]:3 data[text]:'demo'
0/16D32A0 | 691 | COMMIT
0/16D32D8 | 692 | BEGIN
0/16D3398 | 692 | table public.data: DELETE: id[int4]:2
0/16D3398 | 692 | table public.data: DELETE: id[int4]:3
0/16D3398 | 692 | COMMIT
(8 rows)
F.41. tsm_system_rows
Модуль tsm_system_rows предоставляет метод извлечения выборки SYSTEM_ROWS, который можно
использовать в предложении TABLESAMPLE команды SELECT.
Этот метод извлечения выборки принимает один целочисленный аргумент, задающий максималь-
ное число выбираемых строк. Результирующая выборка будет содержать в точности столько строк,
если только в таблице не оказывается меньше заданного числа строк (в этом случае выдаётся вся
таблица).
Как и встроенный метод извлечения выборки SYSTEM, SYSTEM_ROWS производит выборку на уровне
блоков, так что выборка будет не полностью случайной, а может подвергаться эффектам класте-
ризации, особенно когда запрашивается небольшое число строк.
SYSTEM_ROWS не поддерживает предложение REPEATABLE.
F.41.1. Примеры
Пример получения выборки из таблицы с применением метода SYSTEM_ROWS. Сначала нужно уста-
новить расширение:
2618Дополнительно по-
ставляемые модули
CREATE EXTENSION tsm_system_rows;
Затем вы можете использовать его в команде SELECT, например так:
SELECT * FROM my_table TABLESAMPLE SYSTEM_ROWS(100);
Эта команда выдаст выборку из 100 строк из таблицы my_table (а если в таблице не окажется 100
видимых строк, будут возвращены все строки).
F.42. tsm_system_time
Модуль tsm_system_time предоставляет метод извлечения выборки SYSTEM_TIME, который можно
использовать в предложении TABLESAMPLE команды SELECT.
Этот метод извлечения выборки принимает в единственном аргументе число с плавающей точкой,
задающее максимальное время (в миллисекундах), которое отводится на чтение таблицы. Это да-
ёт возможность непосредственно управлять длительностью выполнения запроса, ценой того, что
размер выборки оказывается трудно предсказуемым. Результирующая выборка будет содержать
столько строк, сколько удастся прочитать за отведённое время, если только быстрее не будет про-
читана вся таблица.
Как и встроенный метод извлечения выборки SYSTEM, SYSTEM_TIME производит выборку на уровне
блоков, так что выборка будет не полностью случайной, а может подвергаться эффектам класте-
ризации, особенно когда выбирается небольшое число строк.
SYSTEM_TIME не поддерживает предложение REPEATABLE.
F.42.1. Примеры
Пример получения выборки из таблицы с применением метода SYSTEM_TIME. Сначала нужно уста-
новить расширение:
CREATE EXTENSION tsm_system_time;
Затем вы можете использовать его в команде SELECT, например так:
SELECT * FROM my_table TABLESAMPLE SYSTEM_TIME(1000);
Эта команда выдаст настолько большую выборку из my_table, насколько много строк она успеет
прочитать за 1 секунду (1000 миллисекунд). Разумеется, если за 1 секунду удастся прочитать всю
таблицу, будут возвращены все её строки.
F.43. unaccent
Модуль unaccent представляет словарь текстового поиска, который убирает надстрочные (диакри-
тические) знаки из лексем. Это фильтрующий словарь, что значит, что выводимые им данные все-
гда передаются следующему словарю (если он есть), в отличие от нормальных словарей. Применяя
его, можно выполнить полнотекстовый поиск без учёта ударений (диакритики).
Текущую реализацию unaccent нельзя использовать в качестве нормализующего словаря для сло-
варя thesaurus.
F.43.1. Конфигурирование
Словарь unaccent принимает следующие параметры:
• Параметр RULES задаёт базовое имя файла со списком правил преобразования. Этот файл дол-
жен находиться в каталоге $SHAREDIR/tsearch_data/ (где под $SHAREDIR понимается каталог
с общими данными инсталляции PostgreSQL). Имя файла должно заканчиваться расширением
.rules (которое не нужно указывать в параметре RULES).
Файл правил имеет следующий формат:
2619Дополнительно по-
ставляемые модули
• Каждая строка представляет одно правило перевода, состоящее из символа с диакритикой, за
которым следует символ без диакритики. Первый символ переводится во второй. Например,
À
Á
Â
Ã
Ä
Å
Æ
A
A
A
A
A
A
AE
Эти два символа должны разделяться пробельным символом, а любые начальные или конеч-
ные пробельные символы в этой строке игнорируются.
• В качестве альтернативного варианта, если в строке задан всего один символ, вхождения это-
го символа будут удаляться; это полезно для языков, в которых диакритика представляется
отдельными символами.
• На самом деле роль «символа» может играть любая строка, не содержащая пробельные сим-
волы, так что словари unaccent могут быть полезны и для другого рода замены подстрок, а не
только для удаления диакритик.
• Как и другие файлы конфигурации текстового поиска в PostgreSQL, файл правил должен
иметь кодировку UTF-8. При загрузке данные из него будут автоматически преобразованы
в кодировку текущей базы данных. Все строки в нём, содержащие непереводимые символы,
просто игнорируются, так что файлы правил могут содержать правила, неприменимые в теку-
щей кодировке.
Более полный набор правил, непосредственно пригодный для большинства европейских языков,
можно найти в файле unaccent.rules, который помещается в $SHAREDIR/tsearch_data/, когда
устанавливается модуль unaccent. Этот файл правил переводит буквы с диакритикой в те же бук-
вы без диакритики, а также разворачивает лигатуры в равнозначные последовательности простых
символов (например, Æ в AE).
F.43.2. Использование
При установке расширения unaccent в базе создаётся шаблон текстового поиска unaccent
и словарь unaccent на его основе. Для словаря unaccent по умолчанию определяется пара-
метр RULES='unaccent', благодаря чему его можно сразу использовать со стандартным файлом
unaccent.rules. При желании вы можете изменить этот параметр, например, так
mydb=# ALTER TEXT SEARCH DICTIONARY unaccent (RULES='my_rules');
или создать новые словари на основе этого шаблона.
Протестировать этот словарь можно так:
mydb=# select ts_lexize('unaccent','Hôtel');
ts_lexize
-----------
{Hotel}
(1 row)
Следующий пример показывает, как вставить словарь unaccent в конфигурацию текстового поис-
ка:
mydb=# CREATE TEXT SEARCH CONFIGURATION fr ( COPY = french );
mydb=# ALTER TEXT SEARCH CONFIGURATION fr
ALTER MAPPING FOR hword, hword_part, word
WITH unaccent, french_stem;
mydb=# select to_tsvector('fr','Hôtels de la Mer');
to_tsvector
-------------------
'hotel':1 'mer':4
2620Дополнительно по-
ставляемые модули
(1 row)
mydb=# select to_tsvector('fr','Hôtel de la Mer') @@ to_tsquery('fr','Hotels');
?column?
----------
t
(1 row)
mydb=# select ts_headline('fr','Hôtel de la Mer',to_tsquery('fr','Hotels'));
ts_headline
------------------------
<b>Hôtel</b> de la Mer
(1 row)
F.43.3. Функции
Функция unaccent() удаляет надстрочные (диакритические) знаки из заданной строки. По сути
она представляет собой обёртку вокруг словарей в стиле unaccent, но может вызываться и вне
обычного контекста текстового поиска.
unaccent([словарь regdictionary,] строка text) returns text
Если аргумент словарь опущен, будет использоваться словарь с именем unaccent, находящийся в
той же схеме, что и сама функция unaccent().
Пример:
SELECT unaccent('unaccent', 'Hôtel');
SELECT unaccent('Hôtel');
F.44. uuid-ossp
Модуль uuid-ossp предоставляет функции для генерирования универсальных уникальных иденти-
фикаторов (UUID) по одному из нескольких стандартных алгоритмов. В нём также есть функции,
выдающие специальные UUID-константы.
F.44.1. Функции uuid-ossp
В Таблице F.32 показаны функции, предназначенные для генерации UUID. Четыре алгоритма для
генерации UUID, обозначаемые номерами версий 1, 3, 4 и 5, описаны в стандартах ITU-T Rec. X.667,
ISO/IEC 9834-8:2005 и RFC 4122. (Алгоритма версии 2 нет.) Каждый из этих алгоритмов предна-
значен для различных сфер применения.
Таблица F.32. Функции для генерирования UUID
Функция Описание
uuid_generate_v1() Эта функция генерирует UUID версии 1. Такой
UUID включает в себя MAC-адрес компьютера и
текущее время. Заметьте, что UUID такого типа
раскрывают «личность» компьютера, создавше-
го идентификатор, и время этой операции, что
может быть неприемлемым для определённых
приложений, где важна конфиденциальность.
uuid_generate_v1mc() Эта функция генерирует UUID версии 1, но вме-
сто реального MAC-адреса компьютера исполь-
зуется случайный групповой MAC-адрес.
uuid_generate_v3(namespace
text)
uuid,
Эта функция генерирует UUID версии 3 для за-
данного пространства имён UUID и указанного
имени. Пространство имён должно задаваться
name
2621Дополнительно по-
ставляемые модули
Функция
Описание
одной из специальных констант, которые выда-
ются функциями uuid_ns_*()
, перечислен-
ными в Таблице F.33. (Хотя теоретически это мо-
жет быть любой UUID.) Имя задаёт идентифика-
тор в выбранном пространстве имён.
Например:
SELECT uuid_generate_v3(uuid_ns_url(),
'http://www.postgresql.org');
Из параметра name будет получен MD5-хеш, так
что из сгенерированного UUID нельзя будет вос-
становить имя. В генерируемых таким алгорит-
мом UUID нет элемента случайности или зави-
симости от окружения, так что они могут быть
воспроизведены.
Эта функция генерирует UUID версии 4, кото-
рый всецело определяется случайными числа-
ми.
uuid_generate_v4()
uuid_generate_v5(namespace
text)
uuid,
Эта функция генерирует UUID версии 5, кото-
рый похож на версию 3, но хеш рассчитывает-
ся по алгоритму SHA-1. Версия 5 предпочтитель-
нее версии 3, так как SHA-1 считается более без-
опасным, чем MD5.
name
Таблица F.33. Функции, возвращающие UUID-константы
uuid_nil() «Нулевой» UUID, который не считается действи-
тельным UUID.
uuid_ns_dns() Константа, обозначающая пространство имён
DNS для UUID.
uuid_ns_url() Константа, обозначающая пространство имён
URL для UUID.
uuid_ns_oid() Константа, обозначающая пространство имён
идентификаторов объектов ISO (OID, ISO Object
Identifier) для UUID. (Здесь имеются в виду иден-
тификаторы объектов ASN.1, которые никак не
связаны с OID, применяемыми в PostgreSQL.)
uuid_ns_x500() Константа, обозначающая пространство имён с
уникальными именами X.500 для UUID.
F.44.2. Сборка uuid-ossp
В прошлом этот модуль зависел от библиотеки OSSP UUID, что отразилось в его имени. Хотя биб-
лиотеку OSSP UUID всё ещё можно найти по адресу http://www.ossp.org/pkg/lib/uuid/, она плохо под-
держивается и её становится всё сложнее портировать на новые платформы. Поэтому модуль uuid-
ossp теперь на некоторых платформах можно собирать без библиотеки OSSP. Во FreeBSD, NetBSD
и некоторых других ОС на базе BSD подходящие функции формирования UUID включены в систем-
ную библиотеку libc. В Linux, macOS и некоторых других платформах подходящие функции предо-
ставляются библиотекой libuuid, которая изначально пришла из проекта e2fsprogs (хотя в совре-
менных дистрибутивах Linux она является частью пакета util-linux-ng). Вызывая configure, пе-
редайте ключ --with-uuid=bsd, чтобы использовать функции BSD, либо --with-uuid=e2fs, чтобы
использовать libuuid из e2fsprogs, либо ключ --with-uuid=ossp, чтобы использовать библиотеку
OSSP UUID. В конкретной системе может быть установлено сразу несколько библиотек, поэтому
configure не выбирает библиотеку автоматически.
2622Дополнительно по-
ставляемые модули
Примечание
Если вам нужны только случайные UUID (версии 4), в качестве альтернативы вы мо-
жете использовать функцию gen_random_uuid() из модуля pgcrypto.
F.44.3. Автор
Питер Эйзентраут <peter_e@gmx.net>
F.45. xml2
Модуль xml2 предоставляет функции для выполнения запросов XPath и преобразований XSLT.
F.45.1. Уведомление об актуальности
Начиная с PostgreSQL 8.3, функциональность, связанная с XML, основана на стандарте SQL/XML
и включена в ядро сервера. Эта функциональность охватывает проверку синтаксиса XML и запро-
сы XPath, что в частности делает и этот модуль, но он имеет абсолютно несовместимый API. Этот
модуль планируется удалить в будущей версии PostgreSQL в пользу нового стандартного API, так
что мы рекомендуем вам попробовать перевести свои приложения на новый API. Если вы обнару-
жите, что какая-то функциональность этого модуля не представлена новым API в подходящей фор-
ме, пожалуйста, напишите о вашем затруднении в <pgsql-hackers@postgresql.org>, чтобы этот
недостаток был рассмотрен и, возможно, устранён.
F.45.2. Описание функций
Функции, предоставляемые этим модулем, перечислены в Таблице F.34. Эти функции позволяют
выполнять простой разбор XML и запросы XPath. Все их аргументы имеют тип text, поэтому для
краткости типы опущены.
Таблица F.34. Функции
Функция Возвращает Описание
xml_valid(document) bool Эта функция разбирает текст
документа, переданный в пара-
метре, и возвращает true, ес-
ли это правильно сформиро-
ванный XML. (Замечание: это
псевдоним стандартной функ-
ции PostgreSQL xml_is_well_
formed() . Имя xml_valid(
) технически некорректно, так
как понятия правильности фор-
мата (well-formed) и допустимо-
сти (valid) в XML различаются.)
xpath_string(document,
query) text xpath_number(document,
query) float4 Эти функции обрабатывают за-
прос XPath для переданного до-
кумента и приводят результат к
указанному типу.
xpath_bool(document,
query) bool xpath_nodeset(document,
query, toptag, itemtag) text
Эта функция обрабатывает за-
прос для документа и помещает
результат внутрь XML-тегов. Ес-
ли результат содержит несколь-
ко значений, она выдаст:
2623Дополнительно по-
ставляемые модули
Функция
Возвращает
Описание
<toptag>
<itemtag>Значение 1, которое
может быть фрагментом XML</
itemtag>
<itemtag>Значение 2....</
itemtag>
</toptag>
Если toptag или itemtag — пу-
стая строка, соответствующий
тег опускается.
xpath_nodeset(document,
query) text Подобна
xpath_nodeset(
document, query, toptag,
itemtag) , но выводит резуль-
тат без обоих тегов.
xpath_nodeset(document,
query, itemtag) text Подобна
xpath_nodeset(
document, query, toptag,
itemtag) , но выводит резуль-
тат без toptag.
xpath_list(document,
query, separator) text Эта
функция
возвращает
несколько значений, вставляя
между ними заданный раздели-
тель, например: Значение 1,
Значение 2,Значение 3 , если
разделитель — знак , .
xpath_list(document,
query) text Это обёртка предыдущей функ-
ции, устанавливающая в каче-
стве разделителя знак , .
F.45.3. xpath_table
xpath_table(text key, text document, text relation, text xpaths, text criteria) returns
setof record
Табличная функция xpath_table выполняет набор запросов XPath для каждого из набора докумен-
тов и возвращает результаты в виде таблицы. В первом столбце результата возвращается первич-
ный ключ из таблицы документов, так что результат оказывается готовым к применению в соеди-
нениях. Параметры функции описаны в Таблице F.35.
Таблица F.35. Параметры xpath_table
Параметр Описание
key имя «ключевого» поля — содержимое этого по-
ля просто окажется в первом столбце выходной
таблицы, то есть оно указывает на запись, из
которой была получена определённая выходная
строка (см. замечание о нескольких значениях
ниже)
document имя поля, содержащего XML-документ
relation имя таблицы (или представления), содержащей
документы
xpaths одно или несколько выражений XPath, разделён-
ных символом |
criteria содержимое предложения WHERE. Оно не мо-
жет быть пустым, так что если вам нужно обра-
2624Дополнительно по-
ставляемые модули
Параметр
Описание
ботать все строки в отношении, напишите true
или 1=1
Эти параметры (за исключением строк XPath) просто подставляются в обычный оператор SQL
SELECT, так что у вас есть определённая гибкость — оператор выглядит так:
SELECT <key>, <document> FROM <relation> WHERE <criteria>
поэтому в этих параметрах можно передать всё, что будет корректно воспринято в этих позициях.
Этот SELECT должен возвращать ровно два столбца (что и будет иметь место, если только вы не
перечислите несколько полей в параметрах key или document). Будьте осторожны — при таком
примитивном подходе обязательно нужно проверять все значения, получаемые от пользователя,
во избежание атак с инъекцией SQL.
Эта функция предназначена для использования в выражении FROM, с предложением AS, задающим
выходные столбцы; например:
SELECT * FROM
xpath_table('article_id',
'article_xml',
'articles',
'/article/author|/article/pages|/article/title',
'date_entered > ''2003-01-01'' ')
AS t(article_id integer, author text, page_count integer, title text);
Предложение AS определяет имена и типы столбцов в выходной таблице. Первым определяется
«ключевое» поле, а за ним поля, соответствующие запросам XPath. Если запросов XPath боль-
ше, чем столбцов в результате, лишние запросы будут игнорироваться. Если же результирующих
столбцов больше, чем запросов XPath, дополнительные столбцы принимают значение NULL.
Заметьте, что в этом примере столбец результата page_count определён как целочисленный. Дан-
ная функция внутри имеет дело со строковыми значениями, так что, когда вы указываете, что в
результате нужно получить целое число, она берёт текстовое представление результата XPath и,
применяя функции ввода PostgreSQL, преобразует её в целое число (или в тот тип, который указан
в предложении AS). Если она не сможет сделать это, произойдёт ошибка — например, если резуль-
тат пустой — так что если вы допускаете возможность таких проблем с данными, возможно, будет
лучше просто оставить для столбца тип text.
Вызывающий оператор SELECT не обязательно должен быть простым SELECT * — он может обра-
щаться к выходным столбцам по именам и соединять их с другими таблицами. Эта функция форми-
рует виртуальную таблицу, с которой вы можете выполнять любые операции, какие пожелаете (на-
пример, агрегировать, соединять, сортировать данные и т. д.). Поэтому возможен и такой запрос:
SELECT t.title, p.fullname, p.email
FROM xpath_table('article_id', 'article_xml', 'articles',
'/article/title|/article/author/@id',
'xpath_string(article_xml,''/article/@date'') > ''2003-03-20'' ')
AS t(article_id integer, title text, author_id integer),
tblPeopleInfo AS p
WHERE t.author_id = p.person_id;
в качестве более сложного примера. Разумеется, для удобства вы можете завернуть весь этот за-
прос в представление.
F.45.3.1. Результаты с набором значений
Функция xpath_table рассчитана на то, что результатом каждого запроса XPath может быть набор
данных, так что количество возвращённых этой функцией строк может не совпадать с количеством
входных документов. В первой строке возвращается первый результат каждого запроса, во второй
2625Дополнительно по-
ставляемые модули
— второй результат и т. д. Если один из запросов возвращает меньше значений, чем другие, вместо
недостающих значений будет возвращаться NULL.
В некоторых случаях пользователь знает, что некоторый запрос XPath будет возвращать только
один результат (возможно, уникальный идентификатор документа) — если он используется рядом
с запросом XPath, возвращающим несколько результатов, результат с одним значением будет вы-
веден только в первой выходной строке. Чтобы исправить это, можно воспользоваться полем клю-
ча и соединить результат с более простым запросом XPath. Например:
CREATE TABLE test (
id int PRIMARY KEY,
xml text
);
INSERT INTO test VALUES (1, '<doc num="C1">
<line num="L1"><a>1</a><b>2</b><c>3</c></line>
<line num="L2"><a>11</a><b>22</b><c>33</c></line>
</doc>');
INSERT INTO test VALUES (2, '<doc num="C2">
<line num="L1"><a>111</a><b>222</b><c>333</c></line>
<line num="L2"><a>111</a><b>222</b><c>333</c></line>
</doc>');
SELECT * FROM
xpath_table('id','xml','test',
'/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
'true')
AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int, val2 int, val3 int)
WHERE id = 1 ORDER BY doc_num, line_num
id | doc_num | line_num | val1 | val2 | val3
----+---------+----------+------+------+------
1 | C1
| L1
|
1 |
2 |
3
1 |
| L2
|
11 |
22 |
33
Чтобы получить doc_num в каждой строке, можно вызывать xpath_table дважды и соединить ре-
зультаты:
SELECT t.*,i.doc_num FROM
xpath_table('id', 'xml', 'test',
'/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
'true')
AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),
xpath_table('id', 'xml', 'test', '/doc/@num', 'true')
AS i(id int, doc_num varchar(10))
WHERE i.id=t.id AND i.id=1
ORDER BY doc_num, line_num;
id | line_num | val1 | val2 | val3 | doc_num
----+----------+------+------+------+---------
1 | L1
|
1 |
2 |
3 | C1
1 | L2
|
11 |
22 |
33 | C1
(2 rows)
F.45.4. Функции XSLT
Если установлена libxslt, доступны следующие функции:
F.45.4.1. xslt_process
2626Дополнительно по-
ставляемые модули
xslt_process(text document, text stylesheet, text paramlist) returns text
Эта функция применяет стиль XSL к документу и возвращает результат преобразования. В
paramlist передаётся список присвоений значений параметрам, которые будут использоваться в
преобразовании, в форме a=1,b=2. Учтите, что разбор параметров выполнен очень просто: значе-
ния параметров не могут содержать запятые!
Есть также версия xslt_process с двумя аргументами, которая не передаёт никакие параметры
преобразованию.
F.45.5. Автор
Джон Грей <jgray@azuli.co.uk>
Разработку этого модуля спонсировала компания Torchbox Ltd. (www.torchbox.com). Этот модуль
выпускается под той же лицензией BSD, что и PostgreSQL.
2627
