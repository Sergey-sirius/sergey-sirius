---
layout: page
title: Глава 44. PL/Tcl — процедурный язык Tcl
description: ""
tags: [PostgreSQL]
image:
  feature: abstract-11.jpg
  #credit: dargadgetz
  #creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
share: true
modified: 2018-12-03 T15:14:43-04:00
---

Глава 44. PL/Tcl — процедурный язык Tcl

PL/Tcl — это загружаемый процедурный язык для СУБД PostgreSQL, позволяющий использовать
язык Tcl для написания функций PostgreSQL.
44.1. Обзор
PL/Tcl предоставляет большинство возможностей, которые имеет разработчик функций на C, с
небольшими ограничениями, и позволяет применять мощные библиотеки обработки строк, суще-
ствующие для Tcl.
Одним убедительным хорошим ограничением является то, что весь код выполняется в контексте
безопасности интерпретатора Tcl. Помимо ограниченного набора команд безопасного Tcl, разре-
шены только несколько команд для обращения к базе данных через SPI и вызовы elog() для вы-
дачи сообщений. PL/Tcl не даёт возможности взаимодействовать с внутренним механизмом серве-
ра баз данных или обращаться к ОС с правами серверного процесса PostgreSQL, что возможно в
функциях на C. Таким образом, использование этого языка можно доверить непривилегированным
пользователям; это не даст им неограниченные полномочия.
Ещё одно существенное ограничение заключается в том, что функции на Tcl нельзя использовать
для создания функций ввода/вывода для новых типов данных.
Иногда возникает желание написать функцию на Tcl, которая не будут ограничена безопасным
Tcl. Например, может потребоваться функция, которая будет посылать сообщения по почте. Для
этих случаев есть вариация PL/Tcl, названная PL/TclU (название подразумевает «untrusted Tcl»,
недоверенный Tcl). Это тот же язык, за исключением того, что для него используется полноцен-
ный интерпретатор Tcl. Если применяется PL/TclU, он должен быть установлен как недоверен-
ный процедурный язык, чтобы только суперпользователи могли создавать функции на нём. Автор
функции на PL/TclU должен позаботиться о том, чтобы эту функцию нельзя было использовать не
по назначению, так как она может делать всё, что может пользователь с правами администратора
баз данных.
Разделяемый объектный код для обработчиков вызова PL/Tcl и PL/TclU собирается автоматически
и устанавливается в каталог библиотек PostgreSQL, если поддержка Tcl включена на этапе кон-
фигурирования процедуры установки. Чтобы установить PL/Tcl и/или PL/TclU в конкретную базу
данных, воспользуйтесь командой CREATE EXTENSION, например, так: CREATE EXTENSION pltcl или
CREATE EXTENSION pltclu.
44.2. Функции на PL/Tcl и их аргументы
Чтобы создать функцию на языке PL/Tcl, используйте стандартный синтаксис CREATE FUNCTION:
CREATE FUNCTION имя_функции (типы_аргументов) RETURNS тип_результата AS $$
# Тело функции на PL/Tcl
$$ LANGUAGE pltcl;
С PL/TclU команда та же, но в качестве языка должно быть указано pltclu.
Тело функции содержит просто скрипт на Tcl. Когда вызывается функция, значения аргументов
передаются скрипту Tcl в виде переменных с именами 1 ... n. Результат из кода Tcl возвращается
как обычно, оператором return. В процедуре значение, возвращаемое из кода Tcl, игнорируется.
Например, функцию, возвращающую большее из двух целых чисел, можно определить так:
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
if {$1 > $2} {return $1}
return $2
$$ LANGUAGE pltcl STRICT;
Обратите внимание на предложение STRICT, которое избавляет нас от необходимости думать о
входящих значениях NULL: если при вызове передаётся значение NULL, функция не будет выпол-
няться вовсе, будет сразу возвращён результат NULL.
1184PL/Tcl — процедурный язык Tcl
В нестрогой функции, если фактическое значение аргумента — NULL, соответствующей перемен-
ной $n будет присвоена пустая строка. Чтобы определить, был ли передан NULL в определённом
аргументе, используйте функцию argisnull. Например, предположим, что нам нужна функция
tcl_max, которая с одним аргументом NULL и вторым аргументом не NULL должна возвращать не
NULL, а второй аргумент:
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
if {[argisnull 1]} {
if {[argisnull 2]} { return_null }
return $2
}
if {[argisnull 2]} { return $1 }
if {$1 > $2} {return $1}
return $2
$$ LANGUAGE pltcl;
Как показано выше, чтобы вернуть значение NULL из функции PL/Tcl, нужно выполнить
return_null. Это можно сделать и в строгой, и в нестрогой функции.
Аргументы составного типа передаются функции в виде массивов Tcl. Именами элементов массива
являются имена атрибутов составного типа. Если атрибут в переданной строке имеет значение
NULL, он будет отсутствовать в данном массиве. Например:
CREATE TABLE employee (
name text,
salary integer,
age integer
);
CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$
if {200000.0 < $1(salary)} {
return "t"
}
if {$1(age) < 30 && 100000.0 < $1(salary)} {
return "t"
}
return "f"
$$ LANGUAGE pltcl;
Функции PL/Tcl могут возвращать и результаты составного типа. Для этого код на Tcl должен вер-
нуть список пар имя/значение столбца, соответствующий ожидаемому типу результата. Столбцы,
имена которых в этом списке отсутствуют, получат значения NULL, а если в списке указано имя
несуществующего столбца, возникнет ошибка. Например:
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$
return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
$$ LANGUAGE pltcl;
Выходные аргументы процедур возвращаются таким же образом. Например:
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$
return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
$$ LANGUAGE pltcl;
CALL tcl_triple(5, 10);
Подсказка
Список результатов можно создать из желаемого кортежа, представленного в виде
массива, с помощью команды array get языка Tcl. Например:
1185PL/Tcl — процедурный язык Tcl
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$
set 1(salary) [expr {$1(salary) + $2}]
return [array get 1]
$$ LANGUAGE pltcl;
Функции PL/Tcl могут возвращать наборы результатов. Для этого код на Tcl должен вызывать
return_next для каждой возвращаемой строки, передавая ей соответствующее значение, когда
возвращается скалярный тип, или список пар имя/значение столбца, когда возвращается состав-
ной тип. Пример с результатом скалярного типа:
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$
for {set i $1} {$i < $2} {incr i} {
return_next $i
}
$$ LANGUAGE pltcl;
и с результатом составного:
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$
for {set i $1} {$i < $2} {incr i} {
return_next [list x $i x2 [expr {$i * $i}]]
}
$$ LANGUAGE pltcl;
44.3. Значения данных в PL/Tcl
Значения аргументов, передаваемые в код функции PL/Tcl, представляют собой просто входные
аргументы, преобразованные в текстовый вид (так же, как при выводе оператором SELECT). И на-
оборот, команды return и return_next примут любую строку, соответствующую формату ввода для
объявленного типа результата функции или заданного столбца в результате составного типа.
44.4. Глобальные данные в PL/Tcl
Иногда полезно иметь некоторые глобальные данные, сохраняемые между двумя вызовами функ-
ции или совместно используемые разными функциями. Это легко сделать в PL/Tcl, но есть некото-
рые ограничения, которые необходимо понимать.
По соображениям безопасности, PL/Tcl выполняет функции, вызываемые некоторой ролью SQL в
отдельном интерпретаторе Tcl, выделенном для этой роли. Это предотвращает случайное или зло-
намеренное влияние одного пользователя на поведение функций PL/Tcl другого пользователя. В
каждом интерпретаторе будут свои значения всех «глобальных» переменных Tcl. Таким образом,
в двух функциях PL/Tcl будут общие глобальные переменные, только если они выполняются одной
ролью SQL. В приложении, выполняющем код в одном сеансе с разными ролями SQL (вызывающем
функции SECURITY DEFINER, использующем команду SET ROLE и т. д.) может понадобиться явно
предпринять дополнительные меры, чтобы функции могли разделять свои данные. Для этого сна-
чала установите для функций, которые должны взаимодействовать, одного владельца, а затем за-
дайте для них свойство SECURITY DEFINER. Разумеется, при этом нужно позаботиться о том, чтобы
эти функции не могли сделать ничего непредусмотренного.
Все функции PL/TclU, вызываемые в одном сеансе, выполняются одним интерпретатором Tcl, ко-
торый, конечно, отличается от интерпретатора(ов), используемого для функций PL/Tcl. Поэтому
глобальные данные функций PL/TclU автоматически становятся общими. Это не считается угро-
зой безопасности, так как все функции PL/TclU выполняются на одном уровне доверия, а именно
уровне суперпользователя базы данных.
Чтобы защитить функции PL/Tcl от непреднамеренного влияния друг на друга, каждой из них
предоставляется глобальная переменная-массив через команду upvar. Глобальным именем этой
переменной является внутреннее имя функции, а в качестве локального выбрано GD. Переменную
GD рекомендуется использовать для постоянных внутренних данных функции. Обычные глобаль-
1186PL/Tcl — процедурный язык Tcl
ные переменные Tcl следует использовать только для значений, которые предназначены имен-
но для совместного использования несколькими функциями. (Заметьте, что массивы GD являются
глобальными только для конкретного интерпретатора, так что они не нарушают ограничения без-
опасности, описанные выше.)
Использование GD демонстрируется в примере spi_execp, приведённом ниже.
44.5. Обращение к базе данных из PL/Tcl
Для обращения к базе данных из тела функции на PL/Tcl предназначены следующие команды:
spi_exec ?-count n? ?-array имя? команда ?тело-цикла?
Выполняет команду SQL, заданную в виде строки. В случае ошибки в этой команде выдаётся
ошибка в Tcl. В противном случае spi_exec возвращает число обработанных командой строк
(выбранных, добавленных, изменённых или удалённых), либо ноль, если эта команда — служеб-
ный оператор. Кроме того, если команда — оператор SELECT, значения выбранных столбцов
помещаются в переменные Tcl, как описано ниже.
Необязательное значение -count задаёт для spi_exec максимальное число строк, которое
должно быть обработано в команде. Его действие можно представить как выполнение FETCH n
для курсора, предварительно подготовленного для команды.
Если в качестве команды выполняется оператор SELECT, значения результирующих столбцов
помещаются в переменные Tcl, названные по именам столбцов. Если передаётся -array, зна-
чения столбцов вместо этого становятся элементами названного ассоциативного массива, ин-
дексами в котором становятся имена столбцов. Кроме того, в элементе с именем «.tupno» со-
храняется номер текущей строки в результирующем наборе (отсчитывая от нуля), если только
это имя не занято одним из столбцов результата.
Если в качестве команды выполняется SELECT без указания скрипта тело-цикла, в переменных
Tcl или элементах массива сохраняется только первая строка результатов; оставшиеся строки
(если они есть), игнорируются. Если запрос не возвращает строки, не сохраняется ничего. (Этот
случай можно отследить, проверив результат spi_exec.) Например, команда:
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
присвоит переменной $cnt в Tcl число строк, содержащихся в системном каталоге pg_proc.
Если передаётся необязательный аргумент тело-цикла, заданный в нём блок скрипта Tcl будет
выполняться для каждой строки результата запроса. (Аргумент тело-цикла игнорируется, если
целевая команда — не SELECT.) При этом значения столбцов текущей строки сохраняются в
переменных Tcl или элементах массива перед каждой итерацией этого цикла. Например, код:
spi_exec -array C "SELECT * FROM pg_class" {
elog DEBUG "have table $C(relname)"
}
будет выводить в журнал сообщение для каждой строки pg_class. Это работает подобно другим
конструкциям циклов в Tcl; в частности, команды continue и break в теле цикла будут действо-
вать обычным образом.
Если в столбце результата запроса выдаётся NULL, целевая переменная для неё не устанавли-
вается, и оказывается «неустановленной».
spi_prepare запрос список-типов
Подготавливает и сохраняет план запроса для последующего выполнения. Сохранённый план
будет продолжать существование до завершения текущего сеанса.
Запрос может принимать параметры, то есть местозаполнители для значений, которые будут
передаваться, когда план будет собственно выполняться. В строке запроса эти параметры обо-
значаются как $1 ... $n. Если в запросе используются параметры, нужно задать имена типов
1187PL/Tcl — процедурный язык Tcl
этих параметров в виде списка Tcl. (Если параметры отсутствуют, задайте пустой список_ти-
пов.)
Функция spi_prepare возвращает идентификатор запроса, который может использоваться в
последующих вызовах spi_execp. Пример приведён в описании spi_execp.
spi_execp ?-count n? ?-array имя? ?-nulls строка? ид-запроса ?список-значений? ?тело-цик-
ла?
Выполняет запрос, ранее подготовленный функцией spi_prepare. В качестве ид_запроса пере-
даётся идентификатор, возвращённый функцией spi_prepare. Если в запросе задействуются
параметры, необходимо указать список-значений. Это должен быть принятый в Tcl список па-
раметров. Он должен иметь ту же длину, что и список типов параметров, ранее переданный
spi_prepare. Опустите список-значений, если у запроса нет параметров.
Необязательный аргумент -nulls принимает строку из пробелов и символов 'n', которые от-
мечают, в каких параметрах spi_execp передаются значения NULL. Если присутствует, эта
строка должна иметь ту же длину, что и список-значений. В случае её отсутствия значения
всех параметров считаются отличными от NULL.
Не считая отличий в способе передачи запроса и параметров, spi_execp работает так же, как
spi_exec. Параметры -count, -array и тело-цикла задаются так же, и так же передаётся воз-
вращаемое значение.
Взгляните на пример функции на PL/Tcl, использующей подготовленный план:
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
if {![ info exists GD(plan) ]} {
# подготовить сохранённый план при первом вызове
set GD(plan) [ spi_prepare \
"SELECT count(*) AS cnt FROM t1 WHERE num >= \$1 AND num <= \$2" \
[ list int4 int4 ] ]
}
spi_execp -count 1 $GD(plan) [ list $1 $2 ]
return $cnt
$$ LANGUAGE pltcl;
Обратные косые черты внутри строки запроса, передаваемой функции spi_prepare, нужны для
того, чтобы маркеры $n передавались функции spi_prepare как есть, а не заменялись при под-
становке переменных Tcl.
spi_lastoid
Возвращает OID строки, вставленной последней командой spi_exec или spi_execp, если этой
командой был оператор INSERT с одной строкой и изменяемая таблица содержит OID. (В про-
тивном случае вы получите ноль.)
subtransaction команда
Скрипт Tcl, который содержит команда, выполняется в подтранзакции SQL. Если этот скрипт
возвращает ошибку, вся подтранзакция откатывается назад, а затем в окружающий код Tcl воз-
вращается ошибка. За дополнительными подробностями и примером обратитесь к Разделу 44.9.
quote строка
Дублирует все вхождения апострофа и обратной косой черты в заданной строке. Это можно
использовать для защиты строк, которые будут вставляться в команды SQL, передаваемые в
spi_exec или spi_prepare. Например, представьте, что при выполнении такой команды SQL:
"SELECT '$val' AS ret"
переменная языка Tcl val содержит doesn't. Это приведёт к формированию такой окончатель-
ной строки команды:
1188PL/Tcl — процедурный язык Tcl
SELECT 'doesn't' AS ret
при разборе которой в процессе spi_exec или spi_prepare возникнет ошибка. Чтобы этот за-
прос работал правильно, итоговая команда должна выглядеть так:
SELECT 'doesn''t' AS ret
Получить её в PL/Tcl можно так:
"SELECT '[ quote $val ]' AS ret"
Преимуществом spi_execp является то, что для неё заключать значения параметров в кавыч-
ки подобным образом не нужно, так как параметры никогда не разбираются в составе строки
команды SQL.
elog уровень сообщение
Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни сообщений: DEBUG
(ОТЛАДКА), LOG (СООБЩЕНИЕ), INFO (ИНФОРМАЦИЯ), NOTICE (ЗАМЕЧАНИЕ), WARNING (ПРЕ-
ДУПРЕЖДЕНИЕ), ERROR (ОШИБКА) и FATAL (ВАЖНО). С уровнем ERROR выдаётся ошибка; ес-
ли она не перехватывается окружающим кодом Tcl, она распространяется в вызывающий за-
прос, что приводит к прерыванию текущей транзакции или подтранзакции. По сути то же са-
мое делает команда error языка Tcl. Сообщение уровня FATAL прерывает транзакцию и приво-
дит к завершению текущего сеанса. (Вероятно, нет обоснованной причины использовать этот
уровень ошибок в функциях PL/Tcl, но он поддерживается для полноты.) При использовании
других уровней происходит просто вывод сообщения с заданным уровнем важности. Будут ли
сообщения определённого уровня передаваться клиенту и/или записываться в журнал, опреде-
ляется конфигурационными переменными log_min_messages и client_min_messages. За допол-
нительными сведениями обратитесь к Главе 19 и Разделу 44.8.
44.6. Триггерные функции на PL/Tcl
На PL/Tcl можно написать триггерные функции. PostgreSQL требует, чтобы функция, которая бу-
дет вызываться как триггерная, была объявлена как функция без аргументов и возвращала тип
trigger.
Информация от менеджера триггеров передаётся в тело функции в следующих переменных:
$TG_name
Имя триггера из оператора CREATE TRIGGER.
$TG_relid
Идентификатор объекта таблицы, для которой будет вызываться триггерная функция.
$TG_table_name
Имя таблицы, для которой будет вызываться триггерная функция.
$TG_table_schema
Схема таблицы, для которой будет вызываться триггерная функция.
$TG_relatts
Список языка Tcl, содержащий имена столбцов таблицы. В начало списка добавлен пустой эле-
мент, поэтому при поиске в этом списке имени столбца с помощью стандартной в Tcl коман-
ды lsearch будет возвращён номер элемента, начиная с 1, так же, как нумеруются столбцы
в PostgreSQL. (В позициях удалённых столбцов также содержатся пустые элементы, так что
нумерация следующих за ними атрибутов не нарушается.)
$TG_when
Строка BEFORE, AFTER или INSTEAD OF, в зависимости от типа события триггера.
1189PL/Tcl — процедурный язык Tcl
$TG_level
Строка ROW или STATEMENT, в зависимости от уровня события триггера.
$TG_op
Строка INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от действия события триггера.
$NEW
Ассоциативный массив, содержащий значения новой строки таблицы для действий INSERT или
UPDATE, либо пустой массив для DELETE. Индексами в массиве являются имена столбцов. Столб-
цы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора этот массив не
определяется.
$OLD
Ассоциативный массив, содержащий значения старой строки таблицы для действий UPDATE или
DELETE, либо пустой массив для INSERT. Индексами в массиве являются имена столбцов. Столб-
цы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора этот массив не
определяется.
$args
Список на языке Tcl аргументов функции, заданных в операторе CREATE TRIGGER. Эти аргументы
также доступны под обозначениями $1 ... $n в теле функции.
Возвращаемым значением триггерной функции может быть строка OK или SKIP либо список пар
имя столбца/значение. Если возвращается значение OK, операция (INSERT/UPDATE/DELETE), которая
привела к срабатыванию триггера, выполняется нормально. Значение SKIP указывает менеджеру
триггеров просто пропустить эту операцию с текущей строкой данных. Если возвращается список,
через него PL/Tcl передаёт менеджеру триггеров изменённую строку; содержимое изменённой
строки задаётся именами и значениями столбцов в списке. Все столбцы, не перечисленные в этом
списке, получают значения NULL. Возвращать изменённую строку имеет смысл только для триг-
геров уровня строки с порядком BEFORE команд INSERT и UPDATE, в которых вместо заданной в $NEW
будет записываться изменённая строка; либо с порядком INSTEAD OF команд INSERT и UPDATE, в ко-
торых возвращаемая строка служит исходными данными для предложений INSERT RETURNING или
UPDATE RETURNING. В триггерах уровня строки с порядком BEFORE или INSTEAD OF команды DELETE
возврат изменённой строки воспринимается так же, как и возврат значения OK, то есть операция
выполняется. Для всех остальных типов триггеров возвращаемое значение игнорируется.
Подсказка
Список результатов можно создать из изменённого кортежа, представленного в виде
массива, с помощью команды array get языка Tcl.
Следующий небольшой пример показывает триггерную функцию, которая ведёт в таблице цело-
численный счётчик числа изменений, выполненных в строке. Для новых строк счётчик инициали-
зируется нулевым значением, а затем увеличивается на единицу при каждом изменении.
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
switch $TG_op {
INSERT {
set NEW($1) 0
}
UPDATE {
set NEW($1) $OLD($1)
incr NEW($1)
}
default {
1190PL/Tcl — процедурный язык Tcl
return OK
}
}
return [array get NEW]
$$ LANGUAGE pltcl;
CREATE TABLE mytab (num integer, description text, modcnt integer);
CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
Заметьте, что сама триггерная функция не знает имени столбца; оно передаётся в аргументах
триггера. Это позволяет применять эту функцию для различных таблиц.
44.7. Функции событийных триггеров в PL/Tcl
На PL/Tcl можно написать функции событийных триггеров. PostgreSQL требует, чтобы функция,
которая будет вызываться как событийный триггер, была объявлена как функция без аргументов
и возвращала тип event_trigger.
Информация от менеджера триггеров передаётся в тело функции в следующих переменных:
$TG_event
Имя события, при котором срабатывает этот триггер.
$TG_tag
Тег команды, для которой срабатывает этот триггер.
Возвращаемое значение триггерной функции игнорируется.
В этом примере мини-функция событийного триггера просто выдаёт замечание (NOTICE) при каж-
дом выполнении поддерживаемой команды:
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;
CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
44.8. Обработка ошибок в PL/Tcl
Tcl-код, содержащийся или вызываемый из функции PL/Tcl, может выдавать ошибку либо выполняя
недопустимую операцию, либо генерируя ошибку с помощью команды error языка Tcl или коман-
ды elog языка PL/Tcl. Такие ошибки могут быть перехвачены в среде Tcl с помощью команды Tcl
catch. Если ошибка не перехватывается, а распространяется выше уровня выполнения функций
PL/Tcl, она передаётся в запрос, вызвавший функцию, как ошибка SQL.
И напротив, ошибки СУБД, возникающие внутри команд spi_exec, spi_prepare и spi_execp в сре-
де PL/Tcl, выдаются как ошибки Tcl, так что их можно перехватить командой Tcl catch. (Каждая
из этих команд PL/Tcl выполняет SQL-операцию в подтранзакции, которая откатывается в слу-
чае ошибки, так что для частично завершённых операций производится автоматическая очистка.)
Опять же, если ошибка не перехватывается и распространяется выше верхнего уровня, она стано-
вится ошибкой SQL.
В Tcl имеется переменная errorCode, представляющая дополнительную информацию об ошибке
в виде, удобном для обработки в программах на Tcl. Эта информация передаётся в формате спис-
ка Tcl, первое слово в котором указывает на подсистему или библиотеку, выдающую ошибку; по-
следующее содержимое определяется в зависимости от подсистемы или библиотеки. Для ошибок
СУБД, возникающих в командах PL/Tcl, первым словом будет POSTGRES, вторым — номер версии
PostgreSQL, а дополнительные слова представляют пары имя/значения, передающие подробную
1191PL/Tcl — процедурный язык Tcl
информацию об ошибке. В этих парах всегда передаются поля SQLSTATE, condition и message (пер-
вые два представляют код ошибки и имя условия, как описано в Приложении  A). Также могут
передаваться поля detail, hint, context, schema, table, column, datatype, constraint, statement,
cursor_position, filename, lineno и funcname.
С информацией в переменной errorCode среды PL/Tcl удобно работать, загрузив переменную в
массив, чтобы имена полей стали индексами в массиве. Пример такого кода:
if {[catch { spi_exec $sql_command }]} {
if {[lindex $::errorCode 0] == "POSTGRES"} {
array set errorArray $::errorCode
if {$errorArray(condition) == "undefined_table"} {
# разобраться с отсутствием таблицы
} else {
# разобраться с другими типами ошибок SQL
}
}
}
(Двойные двоеточия явно указывают, что переменная errorCode является глобальной.)
44.9. Явные подтранзакции в PL/Tcl
Перехват ошибок, произошедших при обращении к базе данных, как описано в Разделе 44.8, может
привести к нежелательной ситуации, когда часть операций будет успешно выполнена, прежде чем
произойдёт сбой. Данные останутся в несогласованном состоянии после обработки такой ошибки.
PL/Tcl предлагает решение этой проблемы в форме явных подтранзакций.
Рассмотрите функцию, реализующую перевод денег между двумя счетами:
CREATE FUNCTION transfer_funds() RETURNS void AS $$
if [catch {
spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'"
spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'"
} errormsg] {
set result [format "error transferring funds: %s" $errormsg]
} else {
set result "funds transferred successfully"
}
spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
Если второй оператор UPDATE выдаст исключение, эта функция запишет в журнал сообщение об
ошибке, но результат первого UPDATE будет тем не менее зафиксирован. Другими словами, денеж-
ные средства будут списаны со счёта Джо, но не поступят на счёт Мери. Это происходит потому,
что каждый вызов spi_exec выполняется в отдельной подтранзакции, а откатывается только одна
из подтранзакций.
В таких случаях вы можете обернуть несколько операций с базой данных в одну явную подтран-
закцию, которая будет выполнена успешно или отменена как единое целое. Для этого в PL/Tcl есть
команда subtransaction. С ней мы можем переписать нашу функцию так:
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
if [catch {
subtransaction {
spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name =
'joe'"
spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name =
'mary'"
1192PL/Tcl — процедурный язык Tcl
}
} errormsg] {
set result [format "error transferring funds: %s" $errormsg]
} else {
set result "funds transferred successfully"
}
spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
Заметьте, что и в этом случае нужно использовать catch. В противном случае ошибка распростра-
нится на верхний уровень функции, что не даст произвести желаемое добавление записи в табли-
цу operations. Команда subtransaction не перехватывает ошибки, она только обеспечивает откат
всех операций с базой данных в своей области действия в случае ошибки.
Откат явной подтранзакции происходит в случае любых ошибок, сгенерированных вложенным ко-
дом Tcl, а не только ошибок, возникающих при обращении к базе данных. Таким образом, обычное
исключение Tcl, возникшее внутри команды subtransaction, также приведёт к откату подтран-
закции. Однако при выходе из вложенного кода Tcl без ошибки (например, с помощью команды
return) откат не производится.
44.10. Управление транзакциями
В процедуре, которая вызывается в коде верхнего уровня или в анонимном блоке кода (в команде
DO), можно управлять транзакциями. Чтобы зафиксировать текущую транзакцию, выполните ко-
манду commit, а чтобы откатить — rollback. (Заметьте, что выполнить SQL-команды COMMIT или
ROLLBACK через spi_exec или подобную функцию нельзя. Соответствующие операции могут выпол-
няться только данными функциями.) После завершения одной транзакции следующая начинается
автоматически, отдельной функции для этого нет.
Пример:
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS $$
for {set i 0} {$i < 10} {incr i} {
spi_exec "INSERT INTO test1 (a) VALUES ($i)"
if {$i % 2 == 0} {
commit
} else {
rollback
}
}
$$;
CALL transaction_test1();
Транзакции не могут завершаться, когда имеется открытая явная подтранзакция.
44.11. Конфигурация PL/Tcl
В этом разделе описываются параметры конфигурации, влияющие на работу PL/Tcl.
pltcl.start_proc (string)
В этом параметре, если он не пуст, задаётся имя (возможно, дополненное схемой) функции на
языке PL/Tcl без параметров, которая будет выполняться, когда для PL/Tcl будет создаваться
новый экземпляр Tcl. Такая функция может выполнять инициализацию в рамках сеанса, напри-
мер, загружать дополнительный код Tcl. Новый интерпретатор Tcl создаётся при первом выпол-
нении какой-либо функции PL/Tcl в сеансе базы данных или когда требуется дополнительный
интерпретатор из-за того, что функция PL/Tcl была вызвана новой ролью SQL.
1193PL/Tcl — процедурный язык Tcl
Указанная функция должна быть написана на языке pltcl и не должна иметь свойство SECURITY
DEFINER. (Благодаря этим ограничениям эта функция будет запускаться в интерпретаторе, ко-
торый она должна инициализировать.) Текущий пользователь должен иметь право и на её вы-
полнение тоже.
Если эта функция завершится ошибкой, эта ошибка прервёт вызов функции, которой потребо-
вался новый интерпретатор, и распространится в вызывающий запрос, приводя к прерыванию
текущей транзакции или подтранзакции. Любые действия, уже произведённые в среде Tcl, от-
менены не будут; однако этот интерпретатор более не будет использоваться. При следующей
попытке использования этого языка последует повторная попытка инициализации со свежим
интерпретатором Tcl.
Изменять этот параметр разрешено только суперпользователям. Хотя изменить его можно в
рамках сеанса, такие изменения не повлияют на работу интерпретаторов Tcl, созданных ранее.
pltclu.start_proc (string)
Это параметр полностью аналогичен pltcl.start_proc, но применяется к PL/TclU. Указанная
функция должна быть написана на языке pltclu.
44.12. Имена процедур Tcl
В PostgreSQL одно имя функции может использоваться разными определениями функций, если
они имеют разное число и типы аргументов. Tcl, однако, требует, чтобы имена всех процедур раз-
личались. PL/Tcl решает эту проблему, устанавливая такие внутренние имена процедур Tcl, чтобы
они включали в свой состав OID функции из системной таблицы pg_proc. Таким образом, функци-
ям PostgreSQL с одним именем и разными типами аргументов так же будут соответствовать раз-
личные процедуры Tcl. Это обычно остаётся незамеченным для программиста PL/Tcl, но может
проявиться при отладке.
1194
